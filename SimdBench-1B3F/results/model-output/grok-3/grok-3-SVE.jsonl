{"task_id": "SimdBench_0_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    for (; i < length; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, length);\n        svint64_t vec_src = svld1_s64(pg, src + i);\n        svbool_t vec_mask = svld1_b8(pg, mask + i);\n        svst1_s64(pg, dst + i, svsel_s64(vec_mask, vec_src, svld1_s64(pg, dst + i)));\n    }\n}\n```"}
{"task_id": "SimdBench_0_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    for (; i < length; i += svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, length);\n        svint64_t vec_src = svld1_s64(pg, src + i);\n        svbool_t mask_vec = svld1_s8(pg, mask + i);\n        svst1_s64(pg, dst + i, svsel_s64(mask_vec, vec_src, svld1_s64(pg, dst + i)));\n    }\n}\n```"}
{"task_id": "SimdBench_0_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    for (; i < length; i += svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, length);\n        svint64_t vec_src = svld1_s64(pg, src + i);\n        svbool_t vec_mask = svld1_b8(pg, mask + i);\n        svst1_s64(pg, dst + i, svsel_s64(vec_mask, vec_src, svld1_s64(pg, dst + i)));\n    }\n}\n```"}
{"task_id": "SimdBench_0_SVE", "completion": "<xaiArtifact artifact_id=\"9ab733b9-7fa7-46cf-92a8-6dc1dc2d2176\" artifact_version_id=\"38f7620d-fa16-4beb-94bd-ca8b90312a0f\" title=\"conditional_move_simd.c\" contentType=\"text/x-c\">\n\n#include <arm_sve.h> \n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    for (; i < length; i += svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, length);\n        svint64_t vec_src = svld1_s64(pg, src + i);\n        svbool_t vec_mask = svld1_b8(pg, mask + i);\n        svst1_s64(pg, dst + i, svsel_s64(vec_mask, vec_src, svld1_s64(pg, dst + i)));\n    }\n}\n\n</xaiArtifact>"}
{"task_id": "SimdBench_0_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    for (; i < length; i += svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, length);\n        svint64_t vec_src = svld1_s64(pg, src + i);\n        svbool_t vec_mask = svld1_b8(pg, mask + i);\n        svst1_s64(pg, dst + i, svsel_s64(vec_mask, vec_src, svld1_s64(pg, dst + i)));\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    svint32_t scale_vec = svdup_s32(scale);\n    svint32_t seven_vec = svdup_s32(7);\n\n    for (size_t i = 0; i < length; i += svcntw()) {\n        pg = svwhilelt_b32(i, length);\n        \n        svint32_t src_vec = svld1_s32(pg, src + i);\n        \n        svint32_t scaled = svmul_s32_z(pg, src_vec, scale_vec);\n        \n        svint32_t tmp1 = svlsr_n_s32_z(pg, scaled, 3);\n        svint32_t tmp2 = svlsl_n_s32_z(pg, scaled, 3);\n        \n        svint32_t prod = svmul_s32_z(pg, tmp1, tmp2);\n        svint32_t sum = svadd_s32_z(pg, scaled, prod);\n        \n        svint32_t result = svdiv_s32_z(pg, sum, seven_vec);\n        \n        svst1_s32(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svint32_t vec_src = svld1_s32(pg, src + i);\n        \n        svint32_t vec_scaled = svmul_n_s32_x(pg, vec_src, scale);\n        svint32_t tmp1 = svlsr_n_s32_x(pg, vec_scaled, 3);\n        svint32_t tmp2 = svlsl_n_s32_x(pg, vec_scaled, 3);\n        svint32_t tmp3 = svmul_s32_x(pg, tmp1, tmp2);\n        svint32_t vec_result = svadd_s32_x(pg, vec_scaled, tmp3);\n        vec_result = svdiv_n_s32_x(pg, vec_result, 7);\n        \n        svst1_s32(pg, dst + i, vec_result);\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n    do {\n        svint32_t vec_src = svld1(pg, &src[i]);\n        svint32_t vec_scale = svdup_n_s32(scale);\n        \n        // Step 1: tmp1 = (element * scale) >> 3\n        svint32_t vec_tmp1 = svmul_s32_z(pg, vec_src, vec_scale);\n        vec_tmp1 = svlsr_n_s32_z(pg, vec_tmp1, 3);\n        \n        // Step 2: tmp2 = (element * scale) << 3\n        svint32_t vec_tmp2 = svmul_s32_z(pg, vec_src, vec_scale);\n        vec_tmp2 = svlsl_n_s32_z(pg, vec_tmp2, 3);\n        \n        // Step 3: result = (element * scale + tmp1 * tmp2) / 7\n        svint32_t vec_result = svmul_s32_z(pg, vec_src, vec_scale);\n        svint32_t vec_tmp_product = svmul_s32_z(pg, vec_tmp1, vec_tmp2);\n        vec_result = svadd_s32_z(pg, vec_result, vec_tmp_product);\n        vec_result = svdiv_n_s32_z(pg, vec_result, 7);\n        \n        // Store result to dst\n        svst1(pg, &dst[i], vec_result);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n    \n    do {\n        // Load a vector of integers from src\n        svint32_t vec_src = svld1(pg, &src[i]);\n        \n        // Step 1: Compute tmp1 = (element * scale) >> 3\n        svint32_t vec_scaled = svmul_n_s32_z(pg, vec_src, scale);\n        svint32_t vec_tmp1 = svlsr_n_s32_z(pg, vec_scaled, 3);\n        \n        // Step 2: Compute tmp2 = (element * scale) << 3\n        svint32_t vec_tmp2 = svlsl_n_s32_z(pg, vec_scaled, 3);\n        \n        // Step 3: Compute final result = (element * scale + tmp1 * tmp2) / 7\n        svint32_t vec_tmp1_tmp2 = svmul_s32_z(pg, vec_tmp1, vec_tmp2);\n        svint32_t vec_sum = svadd_s32_z(pg, vec_scaled, vec_tmp1_tmp2);\n        svint32_t vec_result = svdiv_n_s32_z(pg, vec_sum, 7);\n        \n        // Store the result in dst\n        svst1(pg, &dst[i], vec_result);\n        \n        // Update the index and predicate for the next iteration\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n    \n    do {\n        // Load a vector of integers from src\n        svint32_t vec_src = svld1(pg, &src[i]);\n        \n        // Step 1: Compute tmp1 = (element * scale) >> 3\n        svint32_t vec_scaled = svmul_n_s32_z(pg, vec_src, scale);\n        svint32_t vec_tmp1 = svlsr_n_s32_z(pg, vec_scaled, 3);\n        \n        // Step 2: Compute tmp2 = (element * scale) << 3\n        svint32_t vec_tmp2 = svlsl_n_s32_z(pg, vec_scaled, 3);\n        \n        // Step 3: Compute final result = (element * scale + tmp1 * tmp2) / 7\n        svint32_t vec_tmp3 = svmul_z(pg, vec_tmp1, vec_tmp2);\n        svint32_t vec_result = svadd_z(pg, vec_scaled, vec_tmp3);\n        vec_result = svdiv_n_s32_z(pg, vec_result, 7);\n        \n        // Store the result to dst\n        svst1(pg, &dst[i], vec_result);\n        \n        // Update the index and predicate for the next iteration\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    svbool_t pg = svptrue_b64();\n    size_t vec_len = svcntd();\n    size_t i;\n\n    for (i = 0; i < rows; i += vec_len) {\n        // Create a predicate for the current vector length, handling tail elements\n        svbool_t p = svwhilelt_b64(i, rows);\n        \n        // Compute the source index for the current row\n        svuint64_t indices = svadd_n_u64_z(p, svindex_u64(i, 1), 0);\n        svuint64_t src_indices = svmul_n_u64_z(p, indices, cols);\n        src_indices = svadd_n_u64_z(p, src_indices, stride);\n        \n        // Load from source with strided access\n        svfloat64_t vec = svld1_gather_u64base_index_f64(p, (const float64_t *)src, src_indices);\n        \n        // Store to destination\n        svst1_f64(p, &dst[i], vec);\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    svbool_t pg = svptrue_b64();\n    size_t vec_len = svcntd();\n    size_t i = 0;\n\n    for (; i <= rows - vec_len; i += vec_len) {\n        svfloat64_t data = svld1(pg, &src[i * cols + stride]);\n        svst1(pg, &dst[i], data);\n    }\n\n    // Handle remaining elements if rows is not a multiple of vector length\n    if (i < rows) {\n        svbool_t rem_pg = svwhilelt_b64(i, rows);\n        svfloat64_t data = svld1(rem_pg, &src[i * cols + stride]);\n        svst1(rem_pg, &dst[i], data);\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    svbool_t pg = svptrue_b64();\n    size_t vec_len = svcntd();\n    size_t i = 0;\n\n    for (; i <= rows - vec_len; i += vec_len) {\n        svfloat64_t data = svld1(pg, &src[i * cols + stride]);\n        svst1(pg, &dst[i], data);\n    }\n\n    // Handle remaining elements if rows is not a multiple of vector length\n    if (i < rows) {\n        svbool_t rem_pg = svwhilelt_b64(i, rows);\n        svfloat64_t data = svld1(rem_pg, &src[i * cols + stride]);\n        svst1(rem_pg, &dst[i], data);\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    svbool_t pg = svptrue_b64();\n    size_t vec_len = svcntd();\n    size_t i = 0;\n\n    for (; i + vec_len <= rows; i += vec_len) {\n        svfloat64_t data = svld1_f64(pg, &src[i * cols + stride]);\n        svst1_f64(pg, &dst[i], data);\n    }\n\n    // Handle remaining elements if rows is not a multiple of vector length\n    if (i < rows) {\n        svbool_t rem_pg = svwhilelt_b64(i, rows);\n        svfloat64_t data = svld1_f64(rem_pg, &src[i * cols + stride]);\n        svst1_f64(rem_pg, &dst[i], data);\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    svbool_t pg = svptrue_b64();\n    size_t vec_len = svcntd();\n    size_t i;\n\n    for (i = 0; i < rows; i += vec_len) {\n        // Create a predicate for the current vector length, accounting for tail elements\n        svbool_t p = svwhilelt_b64(i, rows);\n        \n        // Compute the source index for the current row batch\n        svuint64_t indices = svadd_n_u64_z(p, svindex_u64(i, 1), 0);\n        svuint64_t src_offset = svmul_n_u64_z(p, indices, cols);\n        src_offset = svadd_n_u64_z(p, src_offset, stride);\n        \n        // Load from source with strided access\n        svfloat64_t vec = svld1_f64(p, src + svextract_u64(src_offset, 0));\n        for (size_t j = 1; j < vec_len; j++) {\n            if (i + j < rows) {\n                double val = src[(i + j) * cols + stride];\n                vec = svinsr_f64(vec, j, val);\n            }\n        }\n        \n        // Store to destination\n        svst1_f64(p, dst + i, vec);\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t vec_len = svcntw();\n    svbool_t pg = svptrue_b32();\n    \n    for (size_t i = 0; i < length; i += vec_len) {\n        // Adjust predicate for the last iteration if length is not a multiple of vector length\n        if (i + vec_len > length) {\n            pg = svwhilelt_b32(i, length);\n        }\n        \n        // Load indices for gather and scatter operations\n        svint32_t idx_vec = svld1_s32(pg, &indices[i]);\n        \n        // Gather operation: read from src using indices and store to dst\n        svfloat32_t gathered = svld1_gather_s32index_f32(pg, src, idx_vec);\n        svst1_f32(pg, &dst[i], gathered);\n        \n        // Scatter operation: read from src and write to dst using indices\n        svfloat32_t src_vec = svld1_f32(pg, &src[i]);\n        svst1_scatter_s32index_f32(pg, dst, idx_vec, src_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        \n        // Gather operation: dst[i] = src[indices[i]]\n        svint32_t idx_vec = svld1_s32(pg, indices + i);\n        svfloat32_t src_vec = svld1_gather_index(pg, src, idx_vec);\n        svst1_f32(pg, dst + i, src_vec);\n        \n        // Scatter operation: dst[indices[i]] = src[i]\n        svfloat32_t src_vec2 = svld1_f32(pg, src + i);\n        svst1_scatter_index(pg, dst, idx_vec, src_vec2);\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    for (size_t i = 0; i < length; ) {\n        svfloat32_t src_vec = svld1_f32(pg, src + i);\n        svuint32_t idx_vec = svld1_u32(pg, indices + i);\n\n        // Gather operation\n        svfloat32_t gathered = svld1_gather_u32index_f32(pg, src, idx_vec);\n        svst1_f32(pg, dst + i, gathered);\n\n        // Scatter operation\n        svst1_scatter_u32index_f32(pg, dst, idx_vec, src_vec);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        \n        // Gather operation\n        svint32_t idx = svld1_s32(pg, indices + i);\n        svfloat32_t values = svld1_gather_s32index_f32(pg, src, idx);\n        svst1_f32(pg, dst + i, values);\n        \n        // Scatter operation\n        svst1_scatter_s32index_f32(pg, dst, idx, svld1_f32(pg, src + i));\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n    \n    // Gather operation\n    for (; i < length; i += svcntw()) {\n        pg = svwhilelt_b32(i, length);\n        svint32_t idx = svld1_s32(pg, indices + i);\n        svfloat32_t val = svld1_gather_s32index_f32(pg, src, idx);\n        svst1_f32(pg, dst + i, val);\n    }\n    \n    // Reset loop counter for scatter operation\n    i = 0;\n    pg = svwhilelt_b32(i, length);\n    \n    // Scatter operation\n    for (; i < length; i += svcntw()) {\n        pg = svwhilelt_b32(i, length);\n        svint32_t idx = svld1_s32(pg, indices + i);\n        svfloat32_t val = svld1_f32(pg, src + i);\n        svst1_scatter_s32index_f32(pg, dst, idx, val);\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t len = end - start + 1;\n    uint64_t half_len = len / 2;\n    \n    for (uint64_t i = 0; i < half_len; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, half_len);\n        \n        svint16_t left = svld1_s16(pg, &arr[start + i]);\n        svint16_t right = svld1_s16(pg, &arr[end - i - svcntw() + 1]);\n        \n        svst1_s16(pg, &arr[start + i], right);\n        svst1_s16(pg, &arr[end - i - svcntw() + 1], left);\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t len = end - start + 1;\n    uint64_t half_len = len / 2;\n    \n    svbool_t pg = svwhilelt_b16(0, half_len);\n    uint64_t vec_len = svcntw();\n    \n    for (uint64_t i = 0; i < half_len; i += vec_len) {\n        svbool_t p = svwhilelt_b16(i, half_len);\n        \n        svint16_t vec_left = svld1_s16(p, arr + start + i);\n        svint16_t vec_right = svld1_s16(p, arr + end - i - vec_len + 1);\n        \n        svst1_s16(p, arr + start + i, vec_right);\n        svst1_s16(p, arr + end - i - vec_len + 1, vec_left);\n    }\n    \n    if (len % 2 == 1) {\n        int16_t temp = arr[start + half_len];\n        arr[start + half_len] = arr[start + half_len];\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t len = end - start + 1;\n    uint64_t i = 0;\n\n    while (i < len / 2) {\n        uint64_t left_idx = start + i;\n        uint64_t right_idx = end - i;\n        \n        svbool_t pg = svwhilelt_b16(i, len / 2);\n        svint16_t left = svld1_s16(pg, arr + left_idx);\n        svint16_t right = svld1_s16(pg, arr + right_idx);\n        \n        svst1_s16(pg, arr + left_idx, right);\n        svst1_s16(pg, arr + right_idx, left);\n        \n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t len = end - start + 1;\n    uint64_t i = 0;\n\n    while (i < len / 2) {\n        svbool_t pg = svwhilelt_b16(i, len / 2);\n        uint64_t count = svcntw();\n\n        svint16_t left = svld1_s16(pg, arr + start + i);\n        svint16_t right = svld1_s16(pg, arr + end - i - count + 1);\n\n        svst1_s16(pg, arr + start + i, right);\n        svst1_s16(pg, arr + end - i - count + 1, left);\n\n        i += count;\n    }\n\n    // Handle remaining elements scalarly\n    for (; i < len / 2; i++) {\n        int16_t temp = arr[start + i];\n        arr[start + i] = arr[end - i];\n        arr[end - i] = temp;\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t len = end - start + 1;\n    uint64_t half = len / 2;\n    uint64_t i;\n\n    svbool_t pg = svwhilelt_b16(0, half);\n    svuint64_t idx = svindex_u64(start, 1);\n    svuint64_t rev_idx = svindex_u64(end, -1);\n\n    for (i = 0; i < half; i += svcntw()) {\n        pg = svwhilelt_b16(i, half);\n        svint16_t left = svld1_s16(pg, &arr[svxtr_u64(idx, i)]);\n        svint16_t right = svld1_s16(pg, &arr[svxtr_u64(rev_idx, i)]);\n        svst1_s16(pg, &arr[svxtr_u64(idx, i)], right);\n        svst1_s16(pg, &arr[svxtr_u64(rev_idx, i)], left);\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "<xaiArtifact artifact_id=\"b83ab621-709f-4e5f-aa3c-af1bb7c08a7e\" artifact_version_id=\"bb5d294e-bb66-4519-ac94-3e7c82c6143c\" title=\"tensor_slice.c\" contentType=\"text/x-c\">\n\n#include <arm_sve.h> \n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    size_t offset = slice_idx * slice_size;\n    \n    for (size_t i = 0; i < slice_size; i += svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, slice_size);\n        svuint8_t vec = svld1_u8(pg, &tensor[offset + i]);\n        svst1_u8(pg, &slice[i], vec);\n    }\n}\n\n</xaiArtifact>"}
{"task_id": "SimdBench_5_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    size_t offset = slice_idx * slice_size;\n    svbool_t pg = svwhilelt_b8(0, slice_size);\n    \n    for (size_t i = 0; i < slice_size; i += svcntb()) {\n        pg = svwhilelt_b8(i, slice_size);\n        svuint8_t vec = svld1_u8(pg, tensor + offset + i);\n        svst1_u8(pg, slice + i, vec);\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    size_t offset = slice_idx * slice_size;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b8(i, slice_size);\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t vec = svld1_u8(pg, tensor + offset + i);\n        svst1_u8(pg, slice + i, vec);\n        i += svcntb();\n        pg = svwhilelt_b8(i, slice_size);\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    size_t offset = slice_idx * slice_size;\n    \n    for (size_t i = 0; i < slice_size; i += svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, slice_size);\n        svuint8_t vec = svld1_u8(pg, tensor + offset + i);\n        svst1_u8(pg, slice + i, vec);\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t offset = slice_idx * dim1 * dim2;\n    svbool_t pg = svwhilelt_b8(0, dim1 * dim2);\n    \n    for (size_t i = 0; i < dim1 * dim2; i += svcntb()) {\n        svbool_t pg_loop = svwhilelt_b8(i, dim1 * dim2);\n        svuint8_t vec = svld1_u8(pg_loop, tensor + offset + i);\n        svst1_u8(pg_loop, slice + i, vec);\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t i_end = (i + block_size < rows) ? i + block_size : rows;\n            size_t j_end = (j + block_size < cols) ? j + block_size : cols;\n\n            for (size_t ii = i; ii < i_end; ++ii) {\n                size_t jj = j;\n                for (; jj < j_end; jj += svcntw()) {\n                    svbool_t pg = svwhilelt_b16(jj, j_end);\n                    svint16_t vec = svld1(pg, &src[ii * cols + jj]);\n                    svst1_scatter_u64base_index_s16(pg, svindex_u64(dst + jj * rows + ii, rows), vec);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t i_end = (i + block_size < rows) ? i + block_size : rows;\n            size_t j_end = (j + block_size < cols) ? j + block_size : cols;\n\n            for (size_t ii = i; ii < i_end; ++ii) {\n                svbool_t pg = svwhilelt_b16(j, j_end);\n                svint16_t vec = svld1(pg, &src[ii * cols + j]);\n                size_t jj = j;\n                while (svptest_any(svptrue_b16(), pg)) {\n                    svbool_t store_pg = svwhilelt_b16(jj, j_end);\n                    svst1_scatter_index(store_pg, &dst[jj * rows + ii], svindex_u64(0, rows), vec);\n                    jj += svcntw();\n                    pg = svwhilelt_b16(jj, j_end);\n                    vec = svld1(pg, &src[ii * cols + jj]);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t i_end = (i + block_size < rows) ? i + block_size : rows;\n            size_t j_end = (j + block_size < cols) ? j + block_size : cols;\n\n            for (size_t ii = i; ii < i_end; ++ii) {\n                svbool_t pg = svwhilelt_b16(j, j_end);\n                svint16_t vec = svld1_s16(pg, &src[ii * cols + j]);\n                for (size_t jj = j; jj < j_end; ++jj) {\n                    if (svptest_any(pg, svptrue_b16())) {\n                        int16_t val = src[ii * cols + jj];\n                        dst[jj * rows + ii] = val;\n                    }\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t i_end = i + block_size < rows ? i + block_size : rows;\n            size_t j_end = j + block_size < cols ? j + block_size : cols;\n\n            for (size_t ii = i; ii < i_end; ++ii) {\n                svbool_t pg = svwhilelt_b16(j, j_end);\n                svint16_t vec = svld1(pg, &src[ii * cols + j]);\n                for (size_t jj = j; jj < j_end; ++jj) {\n                    if (svptest_any(pg, svptrue_b16())) {\n                        int16_t val = svclastb_s16(pg, 0, vec);\n                        dst[jj * rows + ii] = val;\n                        vec = svextw_s16(pg, vec, 1);\n                    }\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t i_end = (i + block_size < rows) ? i + block_size : rows;\n            size_t j_end = (j + block_size < cols) ? j + block_size : cols;\n\n            for (size_t ii = i; ii < i_end; ii++) {\n                size_t jj = j;\n                svbool_t pg = svwhilelt_b16(jj, j_end);\n                while (svptest_any(svptrue_b16(), pg)) {\n                    svint16_t vec = svld1(pg, &src[ii * cols + jj]);\n                    svst1(pg, &dst[jj * rows + ii], vec);\n                    jj += svcntw();\n                    pg = svwhilelt_b16(jj, j_end);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\n#include <arm_sve.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    svfloat32_t sum_vec = svdup_f32(0.0f);\n    svbool_t pg = svwhilelt_b32(0, dim);\n    \n    for (size_t i = 0; i < dim; i += svcntw()) {\n        svbool_t p = svand_b_z(svptrue_b32(), pg, svwhilelt_b32(i, dim));\n        svfloat32_t data = svld1_f32(p, &array[i * dim * dim + i * dim + i]);\n        sum_vec = svadd_f32_z(p, sum_vec, data);\n        pg = svwhilelt_b32(i + svcntw(), dim);\n    }\n    \n    return svaddv_f32(svptrue_b32(), sum_vec);\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\n#include <arm_sve.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    svfloat32_t sum_vec = svdup_f32(0.0f);\n    svbool_t pg = svwhilelt_b32(0, dim);\n    \n    for (size_t i = 0; i < dim; i += svcntw()) {\n        svbool_t mask = svwhilelt_b32(i, dim);\n        svfloat32_t data = svld1_f32(mask, &array[i * dim * dim + i * dim + i]);\n        sum_vec = svadd_f32_z(pg, sum_vec, data);\n    }\n    \n    float sum = svaddv_f32(pg, sum_vec);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\n#include <arm_sve.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    svfloat32_t sum_vec = svdup_f32(0.0f);\n    svbool_t pg = svwhilelt_b32(0, dim);\n    \n    for (size_t i = 0; i < dim; i += svcntw()) {\n        svbool_t p = svwhilelt_b32(i, dim);\n        svfloat32_t data = svld1_f32(p, &array[i * dim * dim + i * dim + i]);\n        sum_vec = svadd_f32_m(pg, sum_vec, data);\n    }\n    \n    return svaddv_f32(svptrue_b32(), sum_vec);\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\n#include <arm_sve.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    svfloat32_t sum_vec = svdup_f32(0.0f);\n    svbool_t pg = svwhilelt_b32(0, dim);\n    \n    for (size_t i = 0; i < dim; i += svcntw()) {\n        svbool_t p = svwhilelt_b32(i, dim);\n        svfloat32_t elements = svld1_f32(p, &array[i * dim * dim + i * dim + i]);\n        sum_vec = svadd_f32_m(p, sum_vec, elements);\n    }\n    \n    return svaddv_f32(pg, sum_vec);\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\n#include <arm_sve.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    svfloat32_t sum_vec = svdup_f32(0.0f);\n    svbool_t pg = svptrue_b32();\n    \n    for (size_t i = 0; i < dim; i += svcntw()) {\n        svbool_t pred = svwhilelt_b32(i, dim);\n        svfloat32_t data = svld1_f32(pred, &array[i * dim * dim + i * dim + i]);\n        sum_vec = svadd_f32_m(pred, sum_vec, data);\n    }\n    \n    return svaddv_f32(pg, sum_vec);\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t i, j;\n    for (i = 0; i < rows; i++) {\n        for (j = 0; j < cols; j += svcntd()) {\n            svbool_t pg = svwhilelt_b64(j, cols);\n            svfloat64_t vec_src = svld1_f64(pg, &src[i * cols + j]);\n            svbool_t mask = svcmpgt_f64(pg, vec_src, svdup_f64(threshold));\n            svfloat64_t vec_scaled = svmul_f64_z(pg, vec_src, svdup_f64(scale));\n            svfloat64_t vec_result = svsel_f64(mask, vec_scaled, vec_src);\n            svst1_f64(pg, &dst[i * cols + j], vec_result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t i, j;\n    for (i = 0; i < rows; i++) {\n        for (j = 0; j < cols; j += svcntd()) {\n            svbool_t pg = svwhilelt_b64(j, cols);\n            svfloat64_t vec = svld1_f64(pg, &src[i * cols + j]);\n            svbool_t mask = svcmpgt_f64(pg, vec, svdup_f64(threshold));\n            svfloat64_t scaled = svmul_f64_z(pg, vec, svdup_f64(scale));\n            svfloat64_t result = svsel_f64(mask, scaled, vec);\n            svst1_f64(pg, &dst[i * cols + j], result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t i, j;\n    for (i = 0; i < rows; i++) {\n        for (j = 0; j < cols; j += svcntd()) {\n            svbool_t pg = svwhilelt_b64(j, cols);\n            svfloat64_t src_vec = svld1_f64(pg, &src[i * cols + j]);\n            svbool_t mask = svcmpgt_f64(pg, src_vec, svdup_f64(threshold));\n            svfloat64_t scaled_vec = svmul_f64_z(pg, src_vec, svdup_f64(scale));\n            svfloat64_t result_vec = svsel_f64(mask, scaled_vec, src_vec);\n            svst1_f64(pg, &dst[i * cols + j], result_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t i;\n    svbool_t pg;\n    svfloat64_t v_threshold, v_scale;\n\n    for (i = 0; i < rows * cols; i += svcntd()) {\n        pg = svwhilelt_b64(i, rows * cols);\n        svfloat64_t v_src = svld1(pg, src + i);\n        v_threshold = svdup_f64(threshold);\n        v_scale = svdup_f64(scale);\n        svbool_t mask = svcmpgt(pg, v_src, v_threshold);\n        svfloat64_t v_result = svsel(mask, svmul_f64_z(pg, v_src, v_scale), v_src);\n        svst1(pg, dst + i, v_result);\n    }\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t i, j;\n    for (i = 0; i < rows; i++) {\n        for (j = 0; j < cols; j += svcntd()) {\n            svbool_t pg = svwhilelt_b64(j, cols);\n            svfloat64_t vec_src = svld1_f64(pg, &src[i * cols + j]);\n            svfloat64_t vec_threshold = svdup_f64(threshold);\n            svfloat64_t vec_scale = svdup_f64(scale);\n            svbool_t mask = svcmpgt_f64(pg, vec_src, vec_threshold);\n            svfloat64_t vec_result = svsel_f64(mask, \n                                              svmul_f64_z(pg, vec_src, vec_scale), \n                                              vec_src);\n            svst1_f64(pg, &dst[i * cols + j], vec_result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    svbool_t pg = svptrue_b64();\n    for (size_t i = 0; i < rows; i++) {\n        size_t idx = indices[i];\n        const double *src_row = src + idx * cols;\n        double *dst_row = dst + i * cols;\n        size_t j = 0;\n        for (; j < cols; j += svcntd()) {\n            svbool_t pm = svwhilelt_b64(j, cols);\n            svfloat64_t vec = svld1_f64(pm, src_row + j);\n            svst1_f64(pm, dst_row + j, vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t idx = indices[i];\n        const double *src_row = src + idx * cols;\n        double *dst_row = dst + i * cols;\n        \n        size_t j = 0;\n        for (; j < cols; j += svcntd()) {\n            svbool_t pg = svwhilelt_b64(j, cols);\n            svfloat64_t vec = svld1_f64(pg, src_row + j);\n            svst1_f64(pg, dst_row + j, vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t idx = indices[i];\n        const double *src_row = src + idx * cols;\n        double *dst_row = dst + i * cols;\n        \n        size_t j = 0;\n        for (; j < cols; j += svcntd()) {\n            svbool_t pg = svwhilelt_b64(j, cols);\n            svfloat64_t vec = svld1_f64(pg, src_row + j);\n            svst1_f64(pg, dst_row + j, vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t idx = indices[i];\n        const double *src_row = src + idx * cols;\n        double *dst_row = dst + i * cols;\n        \n        size_t j = 0;\n        for (; j < cols; j += svcntd()) {\n            svbool_t pg = svwhilelt_b64(j, cols);\n            svfloat64_t vec = svld1_f64(pg, src_row + j);\n            svst1_f64(pg, dst_row + j, vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t src_row = indices[i] * cols;\n        size_t dst_row = i * cols;\n        size_t j = 0;\n        \n        svbool_t pg = svwhilelt_b64(j, cols);\n        while (svptest_any(svptrue_b64(), pg)) {\n            svfloat64_t data = svld1_f64(pg, &src[src_row + j]);\n            svst1_f64(pg, &dst[dst_row + j], data);\n            j += svcntd();\n            pg = svwhilelt_b64(j, cols);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, length);\n    \n    while (i < length) {\n        svint64_t vec1 = svld1_s64(pg, src1 + i);\n        svint64_t vec2 = svld1_s64(pg, src2 + i);\n        svint64_t sum = svadd_s64_z(pg, vec1, vec2);\n        svint64_t scalar_vec = svdup_s64(scalar);\n        svint64_t result = svadd_s64_z(pg, sum, scalar_vec);\n        svint64_t final = svdiv_n_s64_z(pg, result, 2);\n        svst1_s64(pg, dst + i, final);\n        \n        i += svcntd();\n        pg = svwhilelt_b64(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, length);\n        svint64_t v1 = svld1_s64(pg, src1 + i);\n        svint64_t v2 = svld1_s64(pg, src2 + i);\n        svint64_t sum = svadd_s64_z(pg, v1, v2);\n        svint64_t scalar_vec = svdup_s64(scalar);\n        svint64_t result = svadd_s64_z(pg, sum, scalar_vec);\n        svint64_t final = svdiv_s64_z(pg, result, svdup_s64(2));\n        svst1_s64(pg, dst + i, final);\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, length);\n    \n    for (; i < length; i += svcntd()) {\n        pg = svwhilelt_b64(i, length);\n        \n        svint64_t vec1 = svld1_s64(pg, src1 + i);\n        svint64_t vec2 = svld1_s64(pg, src2 + i);\n        \n        svint64_t sum = svadd_s64_z(pg, vec1, vec2);\n        sum = svadd_s64_z(pg, sum, svdup_s64(scalar));\n        sum = svdiv_s64_z(pg, sum, svdup_s64(2));\n        \n        svst1_s64(pg, dst + i, sum);\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    svbool_t pg = svwhilelt_b64(0, length);\n    for (size_t i = 0; i < length; ) {\n        svint64_t v1 = svld1_s64(pg, src1 + i);\n        svint64_t v2 = svld1_s64(pg, src2 + i);\n        svint64_t sum = svadd_s64_z(pg, v1, v2);\n        svint64_t scalar_vec = svdup_s64(scalar);\n        svint64_t result = svadd_s64_z(pg, sum, scalar_vec);\n        svint64_t final = svdiv_s64_z(pg, result, svdup_s64(2));\n        svst1_s64(pg, dst + i, final);\n        i += svcntd();\n        pg = svwhilelt_b64(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, length);\n    \n    while (svptest_any(svptrue_b64(), pg)) {\n        svint64_t v1 = svld1_s64(pg, src1 + i);\n        svint64_t v2 = svld1_s64(pg, src2 + i);\n        svint64_t sum = svadd_s64_z(pg, v1, v2);\n        sum = svadd_s64_z(pg, sum, svdup_s64(scalar));\n        sum = svdiv_s64_z(pg, sum, svdup_s64(2));\n        svst1_s64(pg, dst + i, sum);\n        \n        i += svcntd();\n        pg = svwhilelt_b64(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n    \n    svbool_t pg = svwhilelt_b32(0, length);\n    svint32_t min_vec = svdup_s32(INT32_MAX);\n    \n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t p = svwhilelt_b32(i, length);\n        svint32_t data = svld1_s32(p, src + i);\n        \n        // Mask for even indices (0, 2, 4, ...)\n        svbool_t even_mask = svzip1_b32(p, svnot_b_z(p, p));\n        min_vec = svmin_s32_m(p, min_vec, svsel_s32(even_mask, data, min_vec));\n    }\n    \n    int min_val = svminv_s32(pg, min_vec);\n    \n    // Handle odd length arrays by checking last even element if necessary\n    if (length % 2 == 1 && length > 1) {\n        min_val = (src[length - 1] < min_val) ? src[length - 1] : min_val;\n    }\n    \n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n    \n    svbool_t pg = svwhilelt_b32(0, length);\n    svint32_t min_vec = svdup_s32(INT32_MAX);\n    svbool_t even_mask = svzip1_b32(svpfalse_b(), svptrue_b32());\n    \n    size_t i = 0;\n    for (; i + svcntw() <= length; i += svcntw()) {\n        svbool_t pg_loop = svwhilelt_b32(i, length);\n        svint32_t vec = svld1_s32(pg_loop, src + i);\n        svbool_t even_pg = svand_b_z(pg_loop, pg_loop, even_mask);\n        min_vec = svmin_z(pg_loop, min_vec, svsel_z(even_pg, vec, svdup_s32(INT32_MAX)));\n        even_mask = svnot_b_z(pg_loop, even_mask);\n    }\n    \n    int min_val = svminv_s32(svptrue_b32(), min_vec);\n    \n    for (; i < length; i += 2) {\n        if (i < length && src[i] < min_val) {\n            min_val = src[i];\n        }\n    }\n    \n    return min_val == INT32_MAX ? -1 : min_val;\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n    \n    svbool_t pg = svwhilelt_b32(0, length);\n    svint32_t min_vec = svdup_s32(INT32_MAX);\n    svbool_t even_mask = svzip1_b32(svfalse_b(), svtrue_b32());\n\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t p = svwhilelt_b32(i, length);\n        svint32_t vec = svld1_s32(p, src + i);\n        \n        svbool_t mask = svand_b_z(pg, p, even_mask);\n        min_vec = svmin_s32_m(mask, min_vec, vec);\n        \n        even_mask = svnot_b_z(pg, even_mask);\n    }\n\n    int min_val = svminv_s32(pg, min_vec);\n    \n    size_t rem = length % 2;\n    if (rem) {\n        for (size_t i = length - rem; i < length; i += 2) {\n            if (src[i] < min_val) min_val = src[i];\n        }\n    }\n    \n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    svbool_t pg = svptrue_b32();\n    svint32_t min_vec = svdup_s32(INT32_MAX);\n    size_t i = 0;\n\n    // Process elements in chunks based on vector length\n    while (i < length) {\n        // Load a vector of data\n        svint32_t data = svld1_s32(pg, &src[i]);\n\n        // Create a predicate for even indices (considering array indexing)\n        svbool_t even_pred = svpfalse();\n        for (size_t j = 0; j < svcntw() && (i + j) < length; j++) {\n            if ((i + j) % 2 == 0) {\n                even_pred = svptrue_pat_b32(SV_VL1 << j);\n            }\n        }\n\n        // Update minimum for even indices\n        min_vec = svmin_s32_m(even_pred, min_vec, data);\n\n        i += svcntw();\n        if (i >= length) break;\n    }\n\n    // Reduce the vector to find the minimum value\n    int min_val = svminv_s32(pg, min_vec);\n\n    // Check if there are remaining elements not processed in vector loop\n    for (; i < length; i += 2) {\n        if (i < length && min_val > src[i]) {\n            min_val = src[i];\n        }\n    }\n\n    // If no even elements were processed, return -1\n    if (length < 2 && min_val == INT32_MAX) {\n        return -1;\n    }\n\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    svbool_t pg = svptrue_b32();\n    svint32_t min_vec = svdup_n_s32(INT32_MAX);\n    size_t i = 0;\n\n    // Process vectorized chunks\n    while (i + svcntw() <= length) {\n        svint32_t vec = svld1_s32(pg, &src[i]);\n        svbool_t even_mask = svzip1_b32(svpfalse_b(), svptrue_b32());\n        svint32_t even_vec = svsel_s32(even_mask, vec, svdup_n_s32(INT32_MAX));\n        min_vec = svmin_s32_z(pg, min_vec, even_vec);\n        i += svcntw();\n    }\n\n    // Handle remaining elements\n    int min_val = INT32_MAX;\n    for (; i < length; i += 2) {\n        if (i < length) {\n            min_val = (src[i] < min_val) ? src[i] : min_val;\n        }\n    }\n\n    // Reduce vector to scalar\n    min_val = (svminv_s32(pg, min_vec) < min_val) ? svminv_s32(pg, min_vec) : min_val;\n\n    return (min_val == INT32_MAX) ? -1 : min_val;\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t vec_len = svcntw();\n    svbool_t pg = svwhilelt_b32(0, length);\n\n    for (size_t i = 0; i < length; i += vec_len) {\n        pg = svwhilelt_b32(i, length);\n        \n        // Load the source vector\n        svint32_t vec_src = svld1(pg, &src[i]);\n        \n        // Perform arithmetic right shift\n        svint32_t vec_asr = svasr_n_s32_z(pg, vec_src, shift);\n        \n        // Convert to unsigned for logical right shift\n        svuint32_t vec_unsigned = svreinterpret_u32_s32(vec_src);\n        svuint32_t vec_lsr = svlsr_n_u32_z(pg, vec_unsigned, shift);\n        \n        // Convert back to signed and add the results\n        svint32_t vec_lsr_signed = svreinterpret_s32_u32(vec_lsr);\n        svint32_t vec_result = svadd_s32_z(pg, vec_asr, vec_lsr_signed);\n        \n        // Store the result\n        svst1(pg, &dst[i], vec_result);\n    }\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n    \n    do {\n        svint32_t vec_src = svld1(pg, &src[i]);\n        \n        // Arithmetic right shift\n        svint32_t vec_arith_shift = svshr_n_s32(pg, vec_src, shift);\n        \n        // Logical right shift: convert to unsigned, shift, then back to signed\n        svuint32_t vec_unsigned = svreinterpret_u32_s32(vec_src);\n        svuint32_t vec_logical_shift_u = svshr_n_u32(pg, vec_unsigned, shift);\n        svint32_t vec_logical_shift = svreinterpret_s32_u32(vec_logical_shift_u);\n        \n        // Add the results of arithmetic and logical shifts\n        svint32_t vec_result = svadd_s32_m(pg, vec_arith_shift, vec_logical_shift);\n        \n        // Store the result\n        svst1(pg, &dst[i], vec_result);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n    \n    do {\n        svint32_t vec_src = svld1(pg, &src[i]);\n        \n        // Arithmetic right shift\n        svint32_t vec_ashr = svashr_n_s32(pg, vec_src, shift);\n        \n        // Logical right shift: convert to unsigned, shift, then back to signed\n        svuint32_t vec_unsigned = svreinterpret_u32_s32(vec_src);\n        svuint32_t vec_lshr = svlsr_n_u32(pg, vec_unsigned, shift);\n        svint32_t vec_lshr_signed = svreinterpret_s32_u32(vec_lshr);\n        \n        // Add the results of arithmetic and logical shifts\n        svint32_t vec_result = svadd_s32(pg, vec_ashr, vec_lshr_signed);\n        \n        // Store the result\n        svst1(pg, &dst[i], vec_result);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    size_t vec_len = svcntw();\n\n    for (; i + vec_len <= length; i += vec_len) {\n        // Load vector from source array\n        svint32_t vec_src = svld1(pg, &src[i]);\n\n        // Perform arithmetic right shift\n        svint32_t vec_ashr = svashr_n_s32(pg, vec_src, shift);\n\n        // Convert to unsigned for logical right shift\n        svuint32_t vec_unsigned = svreinterpret_u32_s32(vec_src);\n        svuint32_t vec_lshr = svlsr_n_u32(pg, vec_unsigned, shift);\n\n        // Convert back to signed and add results\n        svint32_t vec_lshr_signed = svreinterpret_s32_u32(vec_lshr);\n        svint32_t vec_result = svadd_s32(pg, vec_ashr, vec_lshr_signed);\n\n        // Store result to destination array\n        svst1(pg, &dst[i], vec_result);\n    }\n\n    // Handle remaining elements\n    if (i < length) {\n        svbool_t pg_rem = svwhilelt_b32(i, length);\n        svint32_t vec_src = svld1(pg_rem, &src[i]);\n        svint32_t vec_ashr = svashr_n_s32(pg_rem, vec_src, shift);\n        svuint32_t vec_unsigned = svreinterpret_u32_s32(vec_src);\n        svuint32_t vec_lshr = svlsr_n_u32(pg_rem, vec_unsigned, shift);\n        svint32_t vec_lshr_signed = svreinterpret_s32_u32(vec_lshr);\n        svint32_t vec_result = svadd_s32(pg_rem, vec_ashr, vec_lshr_signed);\n        svst1(pg_rem, &dst[i], vec_result);\n    }\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n    \n    do {\n        svint32_t vec_src = svld1(pg, &src[i]);\n        \n        // Arithmetic right shift\n        svint32_t vec_ashr = svasr_n_s32_z(pg, vec_src, shift);\n        \n        // Logical right shift: convert to unsigned, shift, convert back to signed\n        svuint32_t vec_unsigned = svreinterpret_u32_s32(vec_src);\n        svuint32_t vec_lshr = svlsr_n_u32_z(pg, vec_unsigned, shift);\n        svint32_t vec_lshr_signed = svreinterpret_s32_u32(vec_lshr);\n        \n        // Add the results of arithmetic and logical shifts\n        svint32_t vec_result = svadd_s32_z(pg, vec_ashr, vec_lshr_signed);\n        \n        // Store the result\n        svst1(pg, &dst[i], vec_result);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    int64_t sum = 0;\n    size_t i = 0;\n\n    // Create a vector type for 32-bit integers\n    svint32_t vec;\n    // Create a predicate for active lanes\n    svbool_t pg = svptrue_b32();\n\n    // Process elements in chunks based on vector length\n    for (; i + svcntw() <= total_elements; i += svcntw()) {\n        // Load a chunk of the matrix into a vector\n        vec = svld1(pg, &matrix[i]);\n        // Add the vector elements to the sum (horizontal reduction)\n        sum += svaddv(pg, vec);\n    }\n\n    // Handle remaining elements that don't fit into a full vector\n    if (i < total_elements) {\n        // Adjust predicate to only process remaining elements\n        pg = svwhilelt_b32(i, total_elements);\n        vec = svld1(pg, &matrix[i]);\n        sum += svaddv(pg, vec);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    size_t len = rows * cols;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b32(i, len);\n    svint32_t sum_vec = svdup_s32(0);\n\n    for (; i < len; i += svcntw()) {\n        pg = svwhilelt_b32(i, len);\n        svint32_t vec = svld1_s32(pg, matrix + i);\n        sum_vec = svadd_s32_z(pg, sum_vec, vec);\n    }\n\n    sum = svaddv_s32(svptrue_b32(), sum_vec);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    svint32_t vec;\n    svbool_t pg;\n    int64_t sum = 0;\n    size_t i = 0;\n    size_t total_elements = rows * cols;\n\n    while (i < total_elements) {\n        pg = svwhilelt_b32(i, total_elements);\n        vec = svld1(pg, &matrix[i]);\n        sum += svaddv(pg, vec);\n        i += svcntw();\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    svint32_t vec_sum = svdup_n_s32(0);\n    svbool_t pg = svwhilelt_b32(0, rows * cols);\n    \n    for (size_t i = 0; i < rows * cols; i += svcntw()) {\n        svbool_t p = svwhilelt_b32(i, rows * cols);\n        svint32_t vec = svld1_s32(p, matrix + i);\n        vec_sum = svadd_m(p, vec_sum, vec);\n    }\n    \n    return svaddv_s32(svptrue_b32(), vec_sum);\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    svint32_t vec_sum = svdup_n_s32(0);\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b32(i, total_elements);\n    for (; i < total_elements; i += svcntw()) {\n        pg = svwhilelt_b32(i, total_elements);\n        svint32_t vec = svld1_s32(pg, matrix + i);\n        vec_sum = svadd_s32_z(pg, vec_sum, vec);\n    }\n\n    return svaddv_s32(svptrue_b32(), vec_sum);\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\n#include <arm_sve.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    svint8_t max_val = svdup_n_s8(src[0]);\n    svuint64_t max_idx = svdup_n_u64(0);\n    svbool_t pg = svptrue_b8();\n    \n    size_t i = 0;\n    for (; i + svcntb() <= length; i += svcntb()) {\n        svint8_t vec = svld1_s8(pg, src + i);\n        svbool_t cmp = svcmpgt_s8(pg, vec, max_val);\n        max_val = svsel_s8(cmp, vec, max_val);\n        svuint64_t idx = svindex_u64(i, 1);\n        max_idx = svsel_u64(cmp, idx, max_idx);\n    }\n\n    int8_t local_max = svmaxv_s8(pg, max_val);\n    size_t local_max_idx = svlastb_u64(svptrue_b64(), max_idx);\n\n    for (; i < length; i++) {\n        if (src[i] > local_max) {\n            local_max = src[i];\n            local_max_idx = i;\n        }\n    }\n\n    return local_max_idx;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\n#include <arm_sve.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    svbool_t pg = svptrue_b8();\n    svint8_t max_vec = svld1_s8(pg, src);\n    svuint64_t max_idx = svindex_u64(0, 1);\n    size_t result_idx = 0;\n    size_t i = 0;\n\n    for (i = svcntb(); i < length; i += svcntb()) {\n        svbool_t pg_loop = svwhilelt_b8(i, length);\n        svint8_t vec = svld1_s8(pg_loop, src + i);\n        svuint64_t idx = svindex_u64(i, 1);\n\n        svbool_t mask = svcmpgt_s8(pg_loop, vec, max_vec);\n        max_vec = svsel_s8(mask, vec, max_vec);\n        max_idx = svsel_u64(mask, idx, max_idx);\n    }\n\n    int8_t max_scalar = svmaxv_s8(pg, max_vec);\n    svbool_t final_mask = svcmpeq_s8(pg, max_vec, max_scalar);\n    result_idx = svlasta_u64(pg, max_idx);\n\n    for (; i < length; i++) {\n        if (src[i] > max_scalar) {\n            max_scalar = src[i];\n            result_idx = i;\n        }\n    }\n\n    return result_idx;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\n#include <arm_sve.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    svbool_t pg = svwhilelt_b8(0, length);\n    svint8_t max_vec = svld1_s8(pg, src);\n    svuint64_t max_idx = svindex_u64(0, 1);\n    size_t max_pos = 0;\n    int8_t max_val = src[0];\n    size_t i = 0;\n\n    while (i < length) {\n        pg = svwhilelt_b8(i, length);\n        svint8_t vec = svld1_s8(pg, src + i);\n        svbool_t cmp = svcmpgt_s8(pg, vec, max_vec);\n        \n        if (svptest_any(pg, cmp)) {\n            max_vec = svsel_s8(cmp, vec, max_vec);\n            svuint64_t idx = svindex_u64(i, 1);\n            max_idx = svsel_u64(cmp, idx, max_idx);\n        }\n        \n        i += svcntb();\n    }\n\n    int8_t local_max = svmaxv_s8(svptrue_b8(), max_vec);\n    svbool_t max_mask = svcmpeq_s8(svptrue_b8(), max_vec, local_max);\n    uint64_t final_idx = svlastb_u64(max_mask, max_idx);\n\n    for (size_t j = final_idx; j < length; j++) {\n        if (src[j] > max_val) {\n            max_val = src[j];\n            max_pos = j;\n        }\n    }\n\n    return max_pos;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\n#include <arm_sve.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    svbool_t pg = svwhilelt_b8(0, length);\n    svint8_t max_vec = svdup_s8(src[0]);\n    svuint64_t idx_vec = svindex_u64(0, 1);\n    svuint64_t max_idx_vec = svdup_u64(0);\n    size_t i = 0;\n\n    while (i < length) {\n        svint8_t vec = svld1_s8(pg, src + i);\n        svbool_t mask = svcmpgt_s8(pg, vec, max_vec);\n        max_vec = svsel_s8(mask, vec, max_vec);\n        max_idx_vec = svsel_u64(mask, idx_vec, max_idx_vec);\n        i += svcntb();\n        pg = svwhilelt_b8(i, length);\n        idx_vec = svadd_u64_z(svptrue_b64(), idx_vec, svdup_u64(svcntb()));\n    }\n\n    int8_t max_scalar = src[0];\n    size_t max_idx = 0;\n    for (size_t j = 0; j < length; j++) {\n        if (src[j] > max_scalar) {\n            max_scalar = src[j];\n            max_idx = j;\n        }\n    }\n\n    int8_t max_vec_scalar = svmaxv_s8(svptrue_b8(), max_vec);\n    if (max_vec_scalar >= max_scalar) {\n        max_idx = svlasta_u64(svptrue_b64(), max_idx_vec);\n    }\n\n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\n#include <arm_sve.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    svint8_t max_vec = svld1_s8(svptrue_b8(), src);\n    svuint64_t max_idx = svindex_u64(0, 1);\n    size_t i = 0;\n    size_t max_index = 0;\n    int8_t max_val = src[0];\n\n    while (i < length) {\n        svbool_t pg = svwhilelt_b8(i, length);\n        svint8_t vec = svld1_s8(pg, src + i);\n        svbool_t cmp = svcmpgt_s8(pg, vec, max_vec);\n\n        if (svptest_any(svptrue_b8(), cmp)) {\n            max_vec = svsel_s8(cmp, vec, max_vec);\n            svuint64_t idx = svindex_u64(i, 1);\n            max_idx = svsel_u64(cmp, idx, max_idx);\n\n            int8_t local_max = svmaxv_s8(pg, max_vec);\n            if (local_max > max_val) {\n                max_val = local_max;\n                max_index = svlasta_u64(svpfalse(), max_idx);\n            }\n        }\n\n        i += svcntb();\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b16(i, length);\n        svuint16_t indices = svindex_u16(i, 1);\n        svuint32_t indices_u32 = svmovlb_u32(indices);\n        svuint32_t masked = svand_n_u32_x(pg, indices_u32, mask);\n        svbool_t sel = svcmpne_n_u32(pg, masked, 0);\n        svuint16_t vec1 = svld1_u16(pg, src1 + i);\n        svuint16_t vec2 = svld1_u16(pg, src2 + i);\n        svuint16_t result = svsel_u16(sel, vec1, vec2);\n        svst1_u16(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b16(i, length);\n    \n    for (; i < length; i += svcntw()) {\n        pg = svwhilelt_b16(i, length);\n        \n        svuint16_t indices = svindex_u16(i, 1);\n        svuint32_t indices_u32 = svmov_u32_z(pg, indices);\n        svbool_t mask_pred = svcmpne_n_u32(pg, svand_n_u32_z(pg, indices_u32, mask), 0);\n        \n        svuint16_t src1_vec = svld1_u16(pg, src1 + i);\n        svuint16_t src2_vec = svld1_u16(pg, src2 + i);\n        \n        svuint16_t result = svsel_u16(mask_pred, src1_vec, src2_vec);\n        \n        svst1_u16(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b16(i, length);\n    \n    for (; i < length; i += svcntw()) {\n        pg = svwhilelt_b16(i, length);\n        \n        svuint16_t indices = svindex_u16(i, 1);\n        svuint32_t indices_u32 = svmov_u32_z(pg, indices);\n        svuint32_t masked = svand_u32_z(pg, indices_u32, mask);\n        svbool_t pred = svcmpne_n_u32(pg, masked, 0);\n        \n        svuint16_t vec1 = svld1_u16(pg, src1 + i);\n        svuint16_t vec2 = svld1_u16(pg, src2 + i);\n        \n        svuint16_t result = svsel_u16(pred, vec1, vec2);\n        \n        svst1_u16(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b16(i, length);\n    \n    for (; i < length; i += svcntw()) {\n        pg = svwhilelt_b16(i, length);\n        \n        svuint16_t indices = svindex_u16(i, 1);\n        svuint32_t indices_u32 = svlsr_n_u32_z(pg, svmovl_u32(pg, indices), 0);\n        svbool_t mask_pred = svcmpne_n_u32(pg, svand_n_u32_z(pg, indices_u32, mask), 0);\n        \n        svuint16_t vec1 = svld1_u16(pg, src1 + i);\n        svuint16_t vec2 = svld1_u16(pg, src2 + i);\n        svuint16_t result = svsel_u16(mask_pred, vec1, vec2);\n        \n        svst1_u16(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b16(i, length);\n    \n    for (; i < length; i += svcntw()) {\n        svuint16_t indices = svindex_u16(i, 1);\n        svuint32_t indices_u32 = svmov_u32_z(pg, indices);\n        svuint32_t masked = svand_u32_z(pg, indices_u32, mask);\n        svbool_t pred = svcmpne_n_u32(pg, masked, 0);\n        \n        svuint16_t vec1 = svld1_u16(pg, src1 + i);\n        svuint16_t vec2 = svld1_u16(pg, src2 + i);\n        svuint16_t result = svsel_u16(pred, vec1, vec2);\n        \n        svst1_u16(pg, dst + i, result);\n        \n        pg = svwhilelt_b16(i + svcntw(), length);\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n    \n    while (i < length) {\n        svuint32_t vec = svld1_u32(pg, src + i);\n        svuint32_t popcnt = svcnt_u32_z(pg, vec);\n        svst1_u32(pg, dst + i, popcnt);\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svuint32_t vec = svld1_u32(pg, src + i);\n        svuint32_t popcnt = svcnt_u32_z(pg, vec);\n        svst1_u32(pg, dst + i, popcnt);\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svuint32_t vec = svld1_u32(pg, src + i);\n        svuint32_t popcnt = svcnt_u32_z(pg, vec);\n        svst1_u32(pg, dst + i, popcnt);\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svuint32_t vec = svld1_u32(pg, src + i);\n        svuint32_t count = svcntp_b32(pg, svptrue_b32());\n        svst1_u32(pg, dst + i, count);\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svuint32_t vec = svld1_u32(pg, src + i);\n        svuint32_t popcnt = svcnt_u32_z(pg, vec);\n        svst1_u32(pg, dst + i, popcnt);\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b16(i, length);\n        svuint16_t v1 = svld1_u16(pg, src1 + i);\n        svuint16_t v2 = svld1_u16(pg, src2 + i);\n        svuint16_t result = svqadd_u16(pg, v1, v2);\n        svst1_u16(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b16(i, length);\n        svuint16_t vec1 = svld1_u16(pg, &src1[i]);\n        svuint16_t vec2 = svld1_u16(pg, &src2[i]);\n        svuint16_t result = svqadd_u16(pg, vec1, vec2);\n        svst1_u16(pg, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b16(i, length);\n        svuint16_t v1 = svld1_u16(pg, src1 + i);\n        svuint16_t v2 = svld1_u16(pg, src2 + i);\n        svuint16_t result = svqadd_u16(v1, v2);\n        svst1_u16(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b16(i, length);\n        svuint16_t v1 = svld1_u16(pg, src1 + i);\n        svuint16_t v2 = svld1_u16(pg, src2 + i);\n        svuint16_t result = svqadd_u16(v1, v2);\n        svst1_u16(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b16(i, length);\n        svuint16_t v1 = svld1_u16(pg, src1 + i);\n        svuint16_t v2 = svld1_u16(pg, src2 + i);\n        svuint16_t res = svqadd_u16(v1, v2);\n        svst1_u16(pg, dst + i, res);\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    const double min_val = -100.0;\n    const double max_val = 100.0;\n\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            svfloat64_t sum = svdup_f64(0.0);\n            svbool_t pg = svptrue_b64();\n\n            for (size_t k = 0; k < n; k += svcntd()) {\n                svbool_t p_a = svptrue_b64();\n                svbool_t p_b = svptrue_b64();\n\n                // Load elements from A and B\n                svfloat64_t a_vec = svld1_f64(pg, &A[i * n + k]);\n                svfloat64_t b_vec = svld1_f64(pg, &B[k * p + j]);\n\n                // Check range for A\n                p_a = svand_b_z(pg, p_a, svcmple_f64(pg, a_vec, svdup_f64(max_val)));\n                p_a = svand_b_z(pg, p_a, svcmpge_f64(pg, a_vec, svdup_f64(min_val)));\n\n                // Check range for B\n                p_b = svand_b_z(pg, p_b, svcmple_f64(pg, b_vec, svdup_f64(max_val)));\n                p_b = svand_b_z(pg, p_b, svcmpge_f64(pg, b_vec, svdup_f64(min_val)));\n\n                // Combine predicates\n                svbool_t p_combined = svand_b_z(pg, p_a, p_b);\n\n                // Perform multiplication and accumulate\n                sum = svmla_m(p_combined, sum, a_vec, b_vec);\n            }\n\n            // Store the result\n            C[i * p + j] = svaddv_f64(svptrue_b64(), sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    svfloat64_t zero = svdup_f64(0.0);\n    svfloat64_t lower_bound = svdup_f64(-100.0);\n    svfloat64_t upper_bound = svdup_f64(100.0);\n\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            svfloat64_t sum = zero;\n            size_t k = 0;\n\n            while (k < n) {\n                svbool_t pg = svwhilelt_b64(k, n);\n                \n                svfloat64_t a_vec = svld1(pg, &A[i * n + k]);\n                svfloat64_t b_vec = svld1(pg, &B[k * p + j]);\n                \n                svbool_t a_mask = svand_b_z(pg, \n                    svcmplt(pg, a_vec, upper_bound),\n                    svcmpgt(pg, a_vec, lower_bound));\n                    \n                svbool_t b_mask = svand_b_z(pg,\n                    svcmplt(pg, b_vec, upper_bound),\n                    svcmpgt(pg, b_vec, lower_bound));\n                    \n                svbool_t final_mask = svand_b_z(pg, a_mask, b_mask);\n                \n                sum = svmla_m(final_mask, sum, a_vec, b_vec);\n                \n                k += svcntd();\n            }\n            \n            C[i * p + j] = svaddv(svptrue_b64(), sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    svfloat64_t zero = svdup_f64(0.0);\n    svfloat64_t lower_bound = svdup_f64(-100.0);\n    svfloat64_t upper_bound = svdup_f64(100.0);\n\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            svfloat64_t sum = svdup_f64(0.0);\n            size_t k = 0;\n\n            while (k < n) {\n                svbool_t pg = svwhilelt_b64(k, n);\n                svfloat64_t a_vec = svld1_f64(pg, &A[i * n + k]);\n                svfloat64_t b_vec = svld1_f64(pg, &B[k * p + j]);\n\n                svbool_t mask_a = svand_b_z(svptrue_b64(),\n                                            svcmpge_f64(pg, a_vec, lower_bound),\n                                            svcmple_f64(pg, a_vec, upper_bound));\n                svbool_t mask_b = svand_b_z(svptrue_b64(),\n                                            svcmpge_f64(pg, b_vec, lower_bound),\n                                            svcmple_f64(pg, b_vec, upper_bound));\n                svbool_t mask = svand_b_z(svptrue_b64(), mask_a, mask_b);\n\n                svfloat64_t prod = svmul_f64_z(mask, a_vec, b_vec);\n                sum = svadd_f64_z(pg, sum, prod);\n\n                k += svcntd();\n            }\n\n            C[i * p + j] = svaddv_f64(svptrue_b64(), sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    svfloat64_t zero = svdup_f64(0.0);\n    svfloat64_t lower_bound = svdup_f64(-100.0);\n    svfloat64_t upper_bound = svdup_f64(100.0);\n\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            svfloat64_t sum = zero;\n            size_t k = 0;\n\n            while (k < n) {\n                svbool_t pg = svwhilelt_b64(k, n);\n                svfloat64_t a_vec = svld1_f64(pg, &A[i * n + k]);\n                svfloat64_t b_vec = svld1_f64(pg, &B[k * p + j]);\n\n                svbool_t a_valid = svand_b_z(pg, svcmpge_f64(pg, a_vec, lower_bound), svcmple_f64(pg, a_vec, upper_bound));\n                svbool_t b_valid = svand_b_z(pg, svcmpge_f64(pg, b_vec, lower_bound), svcmple_f64(pg, b_vec, upper_bound));\n                svbool_t valid = svand_b_z(pg, a_valid, b_valid);\n\n                sum = svmla_m(valid, sum, a_vec, b_vec);\n                k += svcntd();\n            }\n\n            C[i * p + j] = svaddv_f64(svptrue_b64(), sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    svfloat64_t zero = svdup_f64(0.0);\n    svfloat64_t lower_bound = svdup_f64(-100.0);\n    svfloat64_t upper_bound = svdup_f64(100.0);\n\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            svfloat64_t sum = zero;\n            size_t k = 0;\n\n            while (k < n) {\n                svbool_t pg = svwhilelt_b64(k, n);\n                svfloat64_t a_vec = svld1_f64(pg, &A[i * n + k]);\n                svfloat64_t b_vec = svld1_f64(pg, &B[k * p + j]);\n\n                svbool_t a_mask = svand_b_z(pg, svcmple_f64(pg, a_vec, upper_bound),\n                                           svcmpge_f64(pg, a_vec, lower_bound));\n                svbool_t b_mask = svand_b_z(pg, svcmple_f64(pg, b_vec, upper_bound),\n                                           svcmpge_f64(pg, b_vec, lower_bound));\n                svbool_t mask = svand_b_z(pg, a_mask, b_mask);\n\n                sum = svmla_m(mask, sum, a_vec, b_vec);\n                k += svcntd();\n            }\n\n            C[i * p + j] = svaddv_f64(svptrue_b64(), sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i < total_elements; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        svint64_t va = svld1_s64(pg, A + i);\n        svint64_t vb = svld1_s64(pg, B + i);\n        svint64_t vc = svadd_s64_z(pg, va, vb);\n        svst1_s64(pg, C + i, vc);\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i < total_elements; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        svint64_t va = svld1_s64(pg, &A[i]);\n        svint64_t vb = svld1_s64(pg, &B[i]);\n        svint64_t vc = svadd_s64_z(pg, va, vb);\n        svst1_s64(pg, &C[i], vc);\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i < total_size; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, total_size);\n        svint64_t va = svld1_s64(pg, A + i);\n        svint64_t vb = svld1_s64(pg, B + i);\n        svint64_t vc = svadd_s64_z(pg, va, vb);\n        svst1_s64(pg, C + i, vc);\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i < total_elements; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        svint64_t a = svld1_s64(pg, &A[i]);\n        svint64_t b = svld1_s64(pg, &B[i]);\n        svint64_t sum = svadd_s64_z(pg, a, b);\n        svst1_s64(pg, &C[i], sum);\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i < total_elements; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        svint64_t va = svld1_s64(pg, A + i);\n        svint64_t vb = svld1_s64(pg, B + i);\n        svint64_t vc = svadd_s64_z(pg, va, vb);\n        svst1_s64(pg, C + i, vc);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svfloat32_t v1 = svld1_f32(pg, src1 + i);\n        svfloat32_t v2 = svld1_f32(pg, src2 + i);\n        svfloat32_t sum = svadd_f32_z(pg, v1, v2);\n        svfloat32_t rounded = svrintn_f32_z(pg, sum);\n        svst1_f32(pg, dst + i, rounded);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    \n    for (; i + svcntw() <= length; i += svcntw()) {\n        svfloat32_t v1 = svld1_f32(pg, src1 + i);\n        svfloat32_t v2 = svld1_f32(pg, src2 + i);\n        svfloat32_t sum = svadd_f32_z(pg, v1, v2);\n        svfloat32_t rounded = svrintn_f32_z(pg, sum);\n        svst1_f32(pg, dst + i, rounded);\n    }\n    \n    if (i < length) {\n        svbool_t pg_tail = svwhilelt_b32(i, length);\n        svfloat32_t v1 = svld1_f32(pg_tail, src1 + i);\n        svfloat32_t v2 = svld1_f32(pg_tail, src2 + i);\n        svfloat32_t sum = svadd_f32_z(pg_tail, v1, v2);\n        svfloat32_t rounded = svrintn_f32_z(pg_tail, sum);\n        svst1_f32(pg_tail, dst + i, rounded);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    for (; i < length; ) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svfloat32_t vec1 = svld1_f32(pg, src1 + i);\n        svfloat32_t vec2 = svld1_f32(pg, src2 + i);\n        svfloat32_t sum = svadd_f32_z(pg, vec1, vec2);\n        svfloat32_t rounded = svrintn_f32_z(pg, sum);\n        svst1_f32(pg, dst + i, rounded);\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n    \n    for (; i < length; ) {\n        svfloat32_t v1 = svld1_f32(pg, src1 + i);\n        svfloat32_t v2 = svld1_f32(pg, src2 + i);\n        svfloat32_t sum = svadd_f32_z(pg, v1, v2);\n        svfloat32_t rounded = svrintn_f32_z(pg, sum);\n        svst1_f32(pg, dst + i, rounded);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n    \n    for (; i < length; i += svcntw()) {\n        pg = svwhilelt_b32(i, length);\n        \n        svfloat32_t vec1 = svld1_f32(pg, src1 + i);\n        svfloat32_t vec2 = svld1_f32(pg, src2 + i);\n        \n        svfloat32_t sum = svadd_f32_z(pg, vec1, vec2);\n        svfloat32_t rounded = svrintn_f32_z(pg, sum);\n        \n        svst1_f32(pg, dst + i, rounded);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n    \n    for (; i < length; i += svcntw()) {\n        pg = svwhilelt_b32(i, length);\n        \n        // Load vectors\n        svfloat32_t v1 = svld1_f32(pg, src1 + i);\n        svfloat32_t v2 = svld1_f32(pg, src2 + i);\n        \n        // Calculate absolute difference\n        svfloat32_t diff = svsub_f32_x(pg, v1, v2);\n        svfloat32_t abs_diff = svabs_f32_x(pg, diff);\n        \n        // Condition 1: |src1 - src2| <= 50\n        svbool_t cond1 = svcmple_f32(pg, abs_diff, 50.0f);\n        \n        // Condition 2: index is multiple of 2\n        svbool_t cond2 = svzip1_b32(svnot_b_z(pg, svcmpeq_s32(pg, svindex_s32(i, 1), 0)), svfalse());\n        \n        // Combine conditions\n        svbool_t mask = svand_b_z(pg, cond1, cond2);\n        \n        // Element-wise multiplication\n        svfloat32_t result = svmul_f32_m(mask, v1, v2);\n        \n        // Round up (ceiling)\n        result = svceil_f32_m(mask, result);\n        \n        // Set -1 for elements not meeting conditions\n        svfloat32_t final_result = svsel_f32(mask, result, svdup_f32(-1.0f));\n        \n        // Store result\n        svst1_f32(pg, dst + i, final_result);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n    \n    for (; i < length; i += svcntw()) {\n        pg = svwhilelt_b32(i, length);\n        \n        // Load vectors\n        svfloat32_t v1 = svld1_f32(pg, src1 + i);\n        svfloat32_t v2 = svld1_f32(pg, src2 + i);\n        \n        // Calculate absolute difference\n        svfloat32_t diff = svabs_f32_z(pg, svsub_f32_z(pg, v1, v2));\n        \n        // Condition 1: abs difference <= 50\n        svbool_t cond1 = svcmple_f32(pg, diff, 50.0f);\n        \n        // Condition 2: index is multiple of 2\n        svbool_t cond2 = svptrue_b32();\n        if (i % 2 == 0) {\n            cond2 = svzip1_b32(svtrue_b32(), svfalse_b32());\n        } else {\n            cond2 = svzip1_b32(svfalse_b32(), svtrue_b32());\n        }\n        \n        // Combine conditions\n        svbool_t cond = svand_b_z(pg, cond1, cond2);\n        \n        // Calculate multiplication and round up\n        svfloat32_t result = svmul_f32_z(cond, v1, v2);\n        result = svceil_f32_z(cond, result);\n        \n        // Set -1 for elements not meeting conditions\n        svfloat32_t final_result = svsel_f32(cond, result, svdup_f32(-1.0f));\n        \n        // Store result\n        svst1_f32(pg, dst + i, final_result);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    for (size_t i = 0; i < length; ) {\n        svbool_t p = svwhilelt_b32(i, length);\n        svfloat32_t v1 = svld1_f32(p, src1 + i);\n        svfloat32_t v2 = svld1_f32(p, src2 + i);\n        \n        svfloat32_t diff = svsub_f32_x(p, v1, v2);\n        svfloat32_t abs_diff = svabs_f32_x(p, diff);\n        svbool_t cond1 = svcmple_f32(p, abs_diff, 50.0f);\n        \n        svuint32_t indices = svindex_u32(i, 1);\n        svbool_t cond2 = svcmpeq_u32(p, svand_u32_x(p, indices, 1), 0);\n        \n        svbool_t mask = svand_b_z(p, cond1, cond2);\n        \n        svfloat32_t result = svmul_f32_m(mask, v1, v2);\n        result = svceil_f32_m(mask, result);\n        \n        svfloat32_t final = svsel_f32(mask, result, svdup_f32(-1.0f));\n        \n        svst1_f32(p, dst + i, final);\n        \n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    svfloat32_t minus_one = svdup_f32(-1.0f);\n    svfloat32_t fifty = svdup_f32(50.0f);\n    \n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        \n        svfloat32_t v1 = svld1_f32(pg, src1 + i);\n        svfloat32_t v2 = svld1_f32(pg, src2 + i);\n        \n        svfloat32_t diff = svsub_f32_x(pg, v1, v2);\n        svfloat32_t abs_diff = svabs_f32_x(pg, diff);\n        svbool_t cond1 = svcmplt_f32(pg, abs_diff, fifty);\n        \n        svbool_t cond2 = svptrue_b32();\n        if (i % 2 == 0) {\n            svuint32_t indices = svindex_u32(i, 1);\n            svbool_t even_mask = svcmpeq_u32(pg, svand_u32_x(pg, indices, svdup_u32(1)), svdup_u32(0));\n            cond2 = svand_b_z(pg, cond1, even_mask);\n        } else {\n            cond2 = svpfalse_b();\n        }\n        \n        svfloat32_t result = svmul_f32_m(cond2, v1, v2);\n        result = svceil_f32_m(pg, result);\n        result = svsel_f32(cond2, result, minus_one);\n        \n        svst1_f32(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    svfloat32_t v_minus_one = svdup_f32(-1.0f);\n    svfloat32_t v_fifty = svdup_f32(50.0f);\n\n    for (size_t i = 0; i < length; ) {\n        svbool_t p = svwhilelt_b32(i, length);\n        svfloat32_t v1 = svld1_f32(p, src1 + i);\n        svfloat32_t v2 = svld1_f32(p, src2 + i);\n\n        // Condition 1: |src1 - src2| <= 50\n        svfloat32_t diff = svsub_f32_x(p, v1, v2);\n        svfloat32_t abs_diff = svabs_f32_x(p, diff);\n        svbool_t cond1 = svcmple_f32(p, abs_diff, v_fifty);\n\n        // Condition 2: Index is multiple of 2\n        svuint32_t indices = svindex_u32(i, 1);\n        svbool_t cond2 = svcmpeq_u32(p, svand_u32_x(p, indices, svdup_u32(1)), 0);\n\n        // Combine conditions\n        svbool_t cond = svand_b_z(p, cond1, cond2);\n\n        // Compute multiplication and round up for elements meeting conditions\n        svfloat32_t result = svmul_f32_x(p, v1, v2);\n        result = svceil_f32_x(p, result);\n\n        // Set -1 for elements not meeting conditions\n        result = svsel_f32(cond, result, v_minus_one);\n\n        // Store result\n        svst1_f32(p, dst + i, result);\n\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    svfloat64_t scalar_vec = svdup_f64(scalar);\n    size_t total_elements = m * n;\n    \n    for (size_t i = 0; i < total_elements; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        svfloat64_t vec = svld1_f64(pg, mat + i);\n        svfloat64_t result = svmul_f64_z(pg, vec, scalar_vec);\n        svst1_f64(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    svfloat64_t scalar_vec = svdup_f64(scalar);\n    size_t total_elements = m * n;\n    size_t vec_len = svcntd();\n    \n    size_t i = 0;\n    for (; i <= total_elements - vec_len; i += vec_len) {\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        svfloat64_t mat_vec = svld1_f64(pg, &mat[i]);\n        svfloat64_t result = svmul_f64_z(pg, mat_vec, scalar_vec);\n        svst1_f64(pg, &dst[i], result);\n    }\n    \n    // Handle remaining elements\n    if (i < total_elements) {\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        svfloat64_t mat_vec = svld1_f64(pg, &mat[i]);\n        svfloat64_t result = svmul_f64_z(pg, mat_vec, scalar_vec);\n        svst1_f64(pg, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    svfloat64_t scalar_vec = svdup_f64(scalar);\n    size_t i = 0;\n    size_t len = m * n;\n    \n    for (; i < len; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, len);\n        svfloat64_t vec = svld1_f64(pg, mat + i);\n        svfloat64_t result = svmul_f64_z(pg, vec, scalar_vec);\n        svst1_f64(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "<xaiArtifact artifact_id=\"c8145671-483d-4b8f-9db1-616b9cc8e9e4\" artifact_version_id=\"eb0a03b1-26bd-4e4b-b909-108ec5f7ea74\" title=\"matrix_scalar_mul_simd.c\" contentType=\"text/x-c\">\n\n#include <arm_sve.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t i;\n    svfloat64_t vscalar = svdup_f64(scalar);\n    svbool_t pg = svptrue_b64();\n\n    for (i = 0; i < m * n; i += svcntd()) {\n        svfloat64_t vmat = svld1_f64(pg, mat + i);\n        svfloat64_t vres = svmul_f64_z(pg, vmat, vscalar);\n        svst1_f64(pg, dst + i, vres);\n    }\n}\n\n</xaiArtifact>"}
{"task_id": "SimdBench_22_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    svfloat64_t scalar_vec = svdup_f64(scalar);\n    size_t len = m * n;\n    size_t i = 0;\n\n    for (; i < len; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, len);\n        svfloat64_t mat_vec = svld1_f64(pg, mat + i);\n        svfloat64_t result = svmul_f64_z(pg, mat_vec, scalar_vec);\n        svst1_f64(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        svfloat32_t sum = svdup_f32(0.0f);\n        svbool_t pg = svwhilelt_b32(0, n);\n        \n        // Compute sum of squares for the row\n        for (size_t j = 0; j < n; j += svcntw()) {\n            svbool_t p = svwhilelt_b32(j, n);\n            svfloat32_t vec = svld1_f32(p, row + j);\n            sum = svmla_f32_x(pg, sum, vec, vec);\n        }\n        \n        // Reduce sum to scalar\n        float norm = svaddv_f32(pg, sum);\n        norm = sqrtf(norm);\n        \n        // Avoid division by zero\n        if (norm == 0.0f) continue;\n        \n        // Normalize the row\n        svfloat32_t norm_vec = svdup_f32(norm);\n        for (size_t j = 0; j < n; j += svcntw()) {\n            svbool_t p = svwhilelt_b32(j, n);\n            svfloat32_t vec = svld1_f32(p, row + j);\n            vec = svdiv_f32_x(p, vec, norm_vec);\n            svst1_f32(p, row + j, vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        svfloat32_t sum = svdup_f32(0.0f);\n        svbool_t pg = svwhilelt_b32(0, n);\n\n        // Compute sum of squares for the row\n        for (size_t j = 0; j < n; j += svcntw()) {\n            svbool_t pg_loop = svwhilelt_b32(j, n);\n            svfloat32_t vec = svld1_f32(pg_loop, row + j);\n            sum = svmla_f32_x(pg_loop, sum, vec, vec);\n        }\n\n        // Reduce sum across vector\n        float sum_squares = svaddv_f32(pg, sum);\n        float norm = sqrtf(sum_squares);\n\n        // Avoid division by zero\n        if (norm == 0.0f) norm = 1.0f;\n\n        // Normalize the row\n        svfloat32_t norm_vec = svdup_f32(1.0f / norm);\n        for (size_t j = 0; j < n; j += svcntw()) {\n            svbool_t pg_loop = svwhilelt_b32(j, n);\n            svfloat32_t vec = svld1_f32(pg_loop, row + j);\n            svfloat32_t normalized = svmul_f32_x(pg_loop, vec, norm_vec);\n            svst1_f32(pg_loop, row + j, normalized);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        svfloat32_t sum = svdup_f32(0.0f);\n        svbool_t pg = svwhilelt_b32(0, n);\n\n        // Compute sum of squares for the row\n        for (size_t j = 0; j < n; j += svcntw()) {\n            svbool_t p = svwhilelt_b32(j, n);\n            svfloat32_t vec = svld1_f32(p, row + j);\n            sum = svmla_f32_x(pg, sum, vec, vec);\n        }\n\n        // Compute L^2 norm (sqrt of sum of squares)\n        float norm = svaddv_f32(pg, sum);\n        norm = sqrtf(norm);\n        svfloat32_t norm_vec = svdup_f32(norm);\n\n        // Normalize the row\n        for (size_t j = 0; j < n; j += svcntw()) {\n            svbool_t p = svwhilelt_b32(j, n);\n            svfloat32_t vec = svld1_f32(p, row + j);\n            vec = svdiv_f32_x(p, vec, norm_vec);\n            svst1_f32(p, row + j, vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        svfloat32_t sum = svdup_f32(0.0f);\n        svbool_t pg = svwhilelt_b32(0, n);\n\n        // Compute sum of squares\n        for (size_t j = 0; j < n; j += svcntw()) {\n            svbool_t mask = svwhilelt_b32(j, n);\n            svfloat32_t vec = svld1_f32(mask, row + j);\n            sum = svmla_f32_m(mask, sum, vec, vec);\n        }\n\n        // Compute L2 norm\n        float norm = svaddv_f32(svptrue_b32(), sum);\n        norm = sqrtf(norm);\n        svfloat32_t norm_vec = svdup_f32(norm);\n\n        // Normalize row\n        for (size_t j = 0; j < n; j += svcntw()) {\n            svbool_t mask = svwhilelt_b32(j, n);\n            svfloat32_t vec = svld1_f32(mask, row + j);\n            svfloat32_t normalized = svdiv_f32_m(mask, vec, norm_vec);\n            svst1_f32(mask, row + j, normalized);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        \n        // Calculate L^2 norm (square root of sum of squares)\n        svfloat32_t sum = svdup_f32(0.0f);\n        svbool_t pg = svwhilelt_b32(0, n);\n        \n        for (size_t j = 0; j < n; j += svcntw()) {\n            svbool_t pg_loop = svwhilelt_b32(j, n);\n            svfloat32_t vec = svld1_f32(pg_loop, row + j);\n            sum = svmla_f32_x(pg_loop, sum, vec, vec);\n        }\n        \n        // Horizontal sum reduction\n        float sum_scalar = svaddv_f32(svptrue_b32(), sum);\n        float norm = sqrtf(sum_scalar);\n        \n        // Avoid division by zero\n        if (norm == 0.0f) continue;\n        \n        // Normalize the row\n        svfloat32_t norm_vec = svdup_f32(1.0f / norm);\n        for (size_t j = 0; j < n; j += svcntw()) {\n            svbool_t pg_loop = svwhilelt_b32(j, n);\n            svfloat32_t vec = svld1_f32(pg_loop, row + j);\n            svfloat32_t normalized = svmul_f32_x(pg_loop, vec, norm_vec);\n            svst1_f32(pg_loop, row + j, normalized);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            svfloat64_t sum = svdup_f64(0.0);\n            size_t k = 0;\n            \n            for (; k < n - (n % svcntd()); k += svcntd()) {\n                svbool_t pg = svwhilelt_b64(k, n);\n                svfloat64_t a = svld1_f64(pg, &mat1[i * n + k]);\n                svfloat64_t b = svld1_f64(pg, &mat2[k * p + j]);\n                sum = svmla_f64_x(pg, sum, a, b);\n            }\n            \n            double final_sum = svaddv_f64(svptrue_b64(), sum);\n            \n            for (; k < n; k++) {\n                final_sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            \n            dst[i * p + j] = round(final_sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            svfloat64_t sum = svdup_f64(0.0);\n            size_t k = 0;\n\n            for (; k <= n - svcntd(); k += svcntd()) {\n                svbool_t pg = svwhilelt_b64(k, n);\n                svfloat64_t a = svld1_f64(pg, &mat1[i * n + k]);\n                svfloat64_t b = svld1_f64(pg, &mat2[k * p + j]);\n                sum = svmla_f64_x(pg, sum, a, b);\n            }\n\n            double final_sum = svaddv_f64(svptrue_b64(), sum);\n\n            for (; k < n; k++) {\n                final_sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n\n            dst[i * p + j] = round(final_sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            svfloat64_t sum = svdup_f64(0.0);\n            svbool_t pg = svwhilelt_b64(0, n);\n            size_t k = 0;\n\n            while (k < n) {\n                svfloat64_t a = svld1_f64(pg, &mat1[i * n + k]);\n                svfloat64_t b = svld1_f64(pg, &mat2[k * p + j]);\n                sum = svmla_f64_x(pg, sum, a, b);\n                k += svcntd();\n                pg = svwhilelt_b64(k, n);\n            }\n\n            double result = svaddv_f64(svptrue_b64(), sum);\n            dst[i * p + j] = round(result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            svfloat64_t sum = svdup_f64(0.0);\n            size_t k = 0;\n            \n            for (; k < n - (n % svcntd()); k += svcntd()) {\n                svbool_t pg = svwhilelt_b64(k, n);\n                svfloat64_t a = svld1(pg, &mat1[i * n + k]);\n                svfloat64_t b = svld1(pg, &mat2[k * p + j]);\n                sum = svmad_f64_m(pg, a, b, sum);\n            }\n            \n            // Handle remaining elements\n            if (k < n) {\n                svbool_t pg = svwhilelt_b64(k, n);\n                svfloat64_t a = svld1(pg, &mat1[i * n + k]);\n                svfloat64_t b = svld1(pg, &mat2[k * p + j]);\n                sum = svmad_f64_m(pg, a, b, sum);\n            }\n            \n            // Reduce sum and round to nearest integer\n            double result = svaddv_f64(svptrue_b64(), sum);\n            dst[i * p + j] = round(result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            svfloat64_t sum = svdup_f64(0.0);\n            svbool_t pg = svwhilelt_b64(0, n);\n            \n            for (size_t k = 0; k < n; k += svcntd()) {\n                svbool_t active = svwhilelt_b64(k, n);\n                svfloat64_t a = svld1_f64(active, &mat1[i * n + k]);\n                svfloat64_t b = svld1_f64(active, &mat2[k * p + j]);\n                sum = svmla_m(active, sum, a, b);\n            }\n            \n            double result = svaddv_f64(svptrue_b64(), sum);\n            dst[i * p + j] = round(result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    svfloat32_t quarter = svdup_f32(0.25f);\n    svfloat32_t four = svdup_f32(4.0f);\n\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j += svcntw()) {\n            svbool_t pg = svwhilelt_b32(j, cols);\n            svfloat32_t vec = svld1_f32(pg, &src[i * cols + j]);\n            vec = svmul_f32_z(pg, vec, four);\n            vec = svrintn_f32_z(pg, vec);\n            vec = svmul_f32_z(pg, vec, quarter);\n            svst1_f32(pg, &dst[j * rows + i], vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    svfloat32_t quarter = svdup_f32(0.25f);\n    svfloat32_t four = svdup_f32(4.0f);\n    \n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j += svcntw()) {\n            svbool_t pg = svwhilelt_b32(j, cols);\n            svfloat32_t vec = svld1_f32(pg, &src[i * cols + j]);\n            vec = svmul_f32_z(pg, vec, four);\n            vec = svrintn_f32_z(pg, vec);\n            vec = svmul_f32_z(pg, vec, quarter);\n            svst1_f32(pg, &dst[j * rows + i], vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    svfloat32_t quarter = svdup_f32(0.25f);\n    svfloat32_t four = svdup_f32(4.0f);\n\n    for (size_t i = 0; i < rows; i++) {\n        size_t j = 0;\n        while (j < cols) {\n            svbool_t pg = svwhilelt_b32(j, cols);\n            svfloat32_t vec = svld1_f32(pg, &src[i * cols + j]);\n            svfloat32_t scaled = svmul_f32_z(pg, vec, four);\n            svfloat32_t rounded = svrintn_f32_z(pg, scaled);\n            svfloat32_t result = svmul_f32_z(pg, rounded, quarter);\n            \n            for (size_t k = 0; k < svcntw() && (j + k) < cols; k++) {\n                dst[(j + k) * rows + i] = svclastb_f32(svptrue_b32(), 0.0f, svext_f32(result, result, k));\n            }\n            j += svcntw();\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    svfloat32_t quarter = svdup_f32(0.25f);\n    svfloat32_t four = svdup_f32(4.0f);\n\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j += svcntw()) {\n            svbool_t pg = svwhilelt_b32(j, cols);\n            svfloat32_t vec = svld1_f32(pg, &src[i * cols + j]);\n            vec = svmul_f32_z(pg, vec, four);\n            vec = svrintn_f32_z(pg, vec);\n            vec = svmul_f32_z(pg, vec, quarter);\n            svst1_f32(pg, &dst[j * rows + i], vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    const float quarter = 0.25f;\n    svfloat32_t quarter_vec = svdup_f32(quarter);\n    \n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j += svcntw()) {\n            svbool_t pg = svwhilelt_b32(j, cols);\n            \n            // Load source vector\n            svfloat32_t src_vec = svld1_f32(pg, &src[i * cols + j]);\n            \n            // Round to nearest quarter\n            svfloat32_t scaled = svmul_f32_z(pg, src_vec, svdup_f32(4.0f));\n            svfloat32_t rounded = svrintn_f32_z(pg, scaled);\n            svfloat32_t result = svmul_f32_z(pg, rounded, quarter_vec);\n            \n            // Store transposed\n            svst1_f32(pg, &dst[j * rows + i], result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i < total_elements; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        svfloat32_t vec1 = svld1_f32(pg, tensor1 + i);\n        svfloat32_t vec2 = svld1_f32(pg, tensor2 + i);\n        svfloat32_t result = svsub_f32_z(pg, vec1, vec2);\n        svfloat32_t rounded = svrinta_f32_z(pg, result);\n        svst1_f32(pg, dst + i, rounded);\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i < total_elements; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        svfloat32_t v1 = svld1_f32(pg, tensor1 + i);\n        svfloat32_t v2 = svld1_f32(pg, tensor2 + i);\n        svfloat32_t result = svsub_f32_z(pg, v1, v2);\n        result = svrintz_f32_z(pg, result);\n        svst1_f32(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i < total_elements; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        svfloat32_t vec1 = svld1_f32(pg, tensor1 + i);\n        svfloat32_t vec2 = svld1_f32(pg, tensor2 + i);\n        svfloat32_t sub = svsub_f32_z(pg, vec1, vec2);\n        svfloat32_t result = svrinta_f32_z(pg, sub);\n        svst1_f32(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i < total_elements; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        svfloat32_t vec1 = svld1_f32(pg, tensor1 + i);\n        svfloat32_t vec2 = svld1_f32(pg, tensor2 + i);\n        svfloat32_t result = svsub_f32_z(pg, vec1, vec2);\n        svfloat32_t rounded = svrinta_f32_z(pg, result);\n        svst1_f32(pg, dst + i, rounded);\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i < total_elements; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        svfloat32_t vec1 = svld1_f32(pg, tensor1 + i);\n        svfloat32_t vec2 = svld1_f32(pg, tensor2 + i);\n        svfloat32_t result = svsub_f32_z(pg, vec1, vec2);\n        result = svrinta_f32_z(pg, result);\n        svst1_f32(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t i;\n    for (i = 0; i < m * n; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, m * n);\n        svfloat64_t v1 = svld1_f64(pg, &mat1[i]);\n        svfloat64_t v2 = svld1_f64(pg, &mat2[i]);\n        svfloat64_t result = svmul_f64_z(pg, v1, v2);\n        svst1_f64(pg, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t i;\n    for (i = 0; i < m * n; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, m * n);\n        svfloat64_t vec1 = svld1_f64(pg, &mat1[i]);\n        svfloat64_t vec2 = svld1_f64(pg, &mat2[i]);\n        svfloat64_t result = svmul_f64_z(pg, vec1, vec2);\n        svst1_f64(pg, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t i;\n    for (i = 0; i < m * n; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, m * n);\n        svfloat64_t vec1 = svld1_f64(pg, &mat1[i]);\n        svfloat64_t vec2 = svld1_f64(pg, &mat2[i]);\n        svfloat64_t result = svmul_f64_z(pg, vec1, vec2);\n        svst1_f64(pg, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t i;\n    for (i = 0; i < m * n; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, m * n);\n        svfloat64_t v1 = svld1_f64(pg, mat1 + i);\n        svfloat64_t v2 = svld1_f64(pg, mat2 + i);\n        svfloat64_t result = svmul_f64_z(pg, v1, v2);\n        svst1_f64(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t i;\n    for (i = 0; i < m * n; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, m * n);\n        svfloat64_t v1 = svld1_f64(pg, mat1 + i);\n        svfloat64_t v2 = svld1_f64(pg, mat2 + i);\n        svfloat64_t result = svmul_f64_z(pg, v1, v2);\n        svst1_f64(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        svfloat32_t sum = svdup_f32(0.0f);\n        svbool_t pg = svwhilelt_b32(0, n);\n        size_t j = 0;\n\n        while (j < n) {\n            svfloat32_t mat_vec = svld1_f32(pg, &mat[i * n + j]);\n            svfloat32_t vec_vec = svld1_f32(pg, &vec[j]);\n            sum = svmla_f32_z(pg, sum, mat_vec, vec_vec);\n            j += svcntw();\n            pg = svwhilelt_b32(j, n);\n        }\n\n        float result = svaddv_f32(svptrue_b32(), sum);\n        dst[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        svfloat32_t sum = svdup_f32(0.0f);\n        svbool_t pg = svwhilelt_b32(0, n);\n        size_t j = 0;\n\n        while (j < n) {\n            svfloat32_t mat_vec = svld1_f32(pg, &mat[i * n + j]);\n            svfloat32_t vec_vec = svld1_f32(pg, &vec[j]);\n            sum = svmla_f32_z(pg, sum, mat_vec, vec_vec);\n            j += svcntw();\n            pg = svwhilelt_b32(j, n);\n        }\n\n        dst[i] = svaddv_f32(svptrue_b32(), sum);\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        svfloat32_t sum = svdup_f32(0.0f);\n        svbool_t pg = svwhilelt_b32(0, n);\n        size_t j = 0;\n\n        while (j < n) {\n            svfloat32_t mat_vec = svld1_f32(pg, &mat[i * n + j]);\n            svfloat32_t vec_vec = svld1_f32(pg, &vec[j]);\n            sum = svmla_f32_z(pg, sum, mat_vec, vec_vec);\n            j += svcntw();\n            pg = svwhilelt_b32(j, n);\n        }\n\n        float result = svaddv_f32(svptrue_b32(), sum);\n        dst[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        svfloat32_t sum = svdup_f32(0.0f);\n        svbool_t pg = svwhilelt_b32(0, n);\n        \n        for (size_t j = 0; j < n; j += svcntw()) {\n            svbool_t mask = svwhilelt_b32(j, n);\n            svfloat32_t mat_vec = svld1_f32(mask, &mat[i * n + j]);\n            svfloat32_t vec_vec = svld1_f32(mask, &vec[j]);\n            sum = svmla_m(mask, sum, mat_vec, vec_vec);\n        }\n        \n        dst[i] = svaddv_f32(svptrue_b32(), sum);\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        svfloat32_t sum = svdup_f32(0.0f);\n        svbool_t pg = svwhilelt_b32(0, n);\n        size_t j = 0;\n\n        while (j < n) {\n            svfloat32_t mat_vec = svld1_f32(pg, &mat[i * n + j]);\n            svfloat32_t vec_vec = svld1_f32(pg, &vec[j]);\n            sum = svmla_f32_x(pg, sum, mat_vec, vec_vec);\n            j += svcntw();\n            pg = svwhilelt_b32(j, n);\n        }\n\n        float result = svaddv_f32(svptrue_b32(), sum);\n        dst[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```c\n#include <arm_sve.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    svbool_t pg = svwhilelt_b64(0, m * n);\n    \n    for (size_t i = 0; i < m * n; i += svcntd()) {\n        svbool_t p = svwhilelt_b64(i, m * n);\n        svfloat64_t vec = svld1_f64(p, mat + i);\n        sum_vec = svadd_f64_z(pg, sum_vec, vec);\n    }\n    \n    double sum = svaddv_f64(pg, sum_vec);\n    return sum / (m * n);\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```c\n#include <arm_sve.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    svbool_t pg = svptrue_b64();\n    size_t total_elements = m * n;\n    size_t i = 0;\n\n    for (; i < total_elements - (total_elements % svcntd()); i += svcntd()) {\n        svfloat64_t vec = svld1_f64(pg, &mat[i]);\n        sum_vec = svadd_f64_z(pg, sum_vec, vec);\n    }\n\n    double sum = svaddv_f64(pg, sum_vec);\n\n    for (; i < total_elements; i++) {\n        sum += mat[i];\n    }\n\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```c\n#include <arm_sve.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    svbool_t pg = svwhilelt_b64(0, m * n);\n    size_t i = 0;\n\n    while (i < m * n) {\n        svbool_t pred = svwhilelt_b64(i, m * n);\n        svfloat64_t vec = svld1_f64(pred, mat + i);\n        sum_vec = svadd_f64_z(pred, sum_vec, vec);\n        i += svcntd();\n    }\n\n    double sum = svaddv_f64(svptrue_b64(), sum_vec);\n    return sum / (m * n);\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```c\n#include <arm_sve.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    svbool_t pg = svwhilelt_b64(0, m * n);\n    \n    for (size_t i = 0; i < m * n; i += svcntd()) {\n        svbool_t p = svwhilelt_b64(i, m * n);\n        svfloat64_t vec = svld1_f64(p, mat + i);\n        sum_vec = svadd_f64_m(p, sum_vec, vec);\n    }\n    \n    double sum = svaddv_f64(svptrue_b64(), sum_vec);\n    return sum / (m * n);\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```c\n#include <arm_sve.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    size_t total_elements = m * n;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b64(i, total_elements);\n    for (; i < total_elements; i += svcntd()) {\n        pg = svwhilelt_b64(i, total_elements);\n        svfloat64_t vec = svld1_f64(pg, mat + i);\n        sum_vec = svadd_f64_z(pg, sum_vec, vec);\n    }\n\n    double sum = svaddv_f64(pg, sum_vec);\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        const int* row = matrix + i * cols;\n        bool ascending = directions[i];\n        svbool_t pg = svwhilelt_b32(0, cols - 1);\n        \n        svint32_t curr = svld1_s32(pg, row);\n        svint32_t next = svld1_s32(pg, row + 1);\n        \n        svbool_t cmp;\n        if (ascending) {\n            cmp = svcmple_s32(pg, curr, next);\n        } else {\n            cmp = svcmpge_s32(pg, curr, next);\n        }\n        \n        if (!svptest_all(cmp)) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        const int* row = matrix + i * cols;\n        bool ascending = directions[i];\n        svbool_t pg = svwhilelt_b32(0, cols - 1);\n        \n        svint32_t v1 = svld1_s32(pg, row);\n        svint32_t v2 = svld1_s32(pg, row + 1);\n        \n        svbool_t cmp;\n        if (ascending) {\n            cmp = svcmple_s32(pg, v1, v2);\n        } else {\n            cmp = svcmpge_s32(pg, v1, v2);\n        }\n        \n        if (!svptest_all(cmp)) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        const int* row = matrix + i * cols;\n        svbool_t pg = svwhilelt_b32(0, cols - 1);\n        svint32_t curr = svld1_s32(pg, row);\n        svint32_t next = svld1_s32(pg, row + 1);\n        \n        svbool_t sorted;\n        if (directions[i]) {\n            // Ascending: curr <= next\n            sorted = svcmple_s32(pg, curr, next);\n        } else {\n            // Descending: curr >= next\n            sorted = svcmpge_s32(pg, curr, next);\n        }\n        \n        if (!svptest_all_true(pg, sorted)) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        const int* row = matrix + i * cols;\n        svbool_t pg = svwhilelt_b32(0, cols - 1);\n        svint32_t curr = svld1_s32(pg, row);\n        svint32_t next = svld1_s32(pg, row + 1);\n        \n        svbool_t sorted;\n        if (directions[i]) {\n            sorted = svcmple_s32(pg, curr, next);\n        } else {\n            sorted = svcmpge_s32(pg, curr, next);\n        }\n        \n        if (!svptest_all_true(pg, sorted)) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        const int* row = matrix + i * cols;\n        bool ascending = directions[i];\n        svbool_t pg = svwhilelt_b32(0, cols - 1);\n        \n        svint32_t curr = svld1_s32(pg, row);\n        svint32_t next = svld1_s32(pg, row + 1);\n        \n        svbool_t cmp;\n        if (ascending) {\n            cmp = svcmple_s32(pg, curr, next);\n        } else {\n            cmp = svcmpge_s32(pg, curr, next);\n        }\n        \n        if (!svptest_all(cmp)) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    svbool_t pg = svwhilelt_b16(0, length);\n    svint16_t vbase = svdup_s16(base);\n\n    for (size_t i = 0; i < length; i += svcntw()) {\n        pg = svwhilelt_b16(i, length);\n        svint16_t vsrc = svld1_s16(pg, src + i);\n        svint16_t vdiv = svdiv_s16_z(pg, vsrc, vbase);\n        svint16_t vmult = svmul_s16_z(pg, vdiv, vbase);\n        svst1_s16(pg, dst + i, vmult);\n    }\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    svbool_t pg = svwhilelt_b16(0, length);\n    svint16_t v_base = svdup_s16((int16_t)base);\n\n    for (size_t i = 0; i < length; i += svcntw()) {\n        pg = svwhilelt_b16(i, length);\n        svint16_t v_src = svld1_s16(pg, src + i);\n        svint16_t v_div = svdiv_n_s16_z(pg, v_src, v_base);\n        svint16_t v_mul = svmul_n_s16_z(pg, v_div, v_base);\n        svst1_s16(pg, dst + i, v_mul);\n    }\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    svbool_t pg = svwhilelt_b16(0, length);\n    svint16_t vbase = svdup_s16(base);\n\n    for (size_t i = 0; i < length; i += svcntw()) {\n        pg = svwhilelt_b16(i, length);\n        svint16_t vsrc = svld1_s16(pg, src + i);\n        svint16_t vdiv = svdiv_s16_z(pg, vsrc, vbase);\n        svint16_t vmul = svmul_s16_z(pg, vdiv, vbase);\n        svst1_s16(pg, dst + i, vmul);\n    }\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    svbool_t pg = svwhilelt_b16(0, length);\n    svint16_t vbase = svdup_s16(base);\n\n    for (size_t i = 0; i < length; i += svcntw()) {\n        pg = svwhilelt_b16(i, length);\n        svint16_t vsrc = svld1_s16(pg, src + i);\n        svint16_t vdiv = svdiv_s16_z(pg, vsrc, vbase);\n        svint16_t vmul = svmul_s16_z(pg, vdiv, vbase);\n        svst1_s16(pg, dst + i, vmul);\n    }\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    svbool_t pg = svwhilelt_b16(0, length);\n    svint16_t vbase = svdup_s16(base);\n\n    for (size_t i = 0; i < length; i += svcntw()) {\n        pg = svwhilelt_b16(i, length);\n        svint16_t vsrc = svld1_s16(pg, src + i);\n        svint16_t vdiv = svdiv_s16_z(pg, vsrc, vbase);\n        svint16_t vmul = svmul_s16_z(pg, vdiv, vbase);\n        svst1_s16(pg, dst + i, vmul);\n    }\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    svbool_t pg = svptrue_b64();\n    size_t vec_len = svcntd();\n\n    for (size_t i = 0; i < rows; i++) {\n        bool row_match = true;\n        size_t j = 0;\n\n        for (; j + vec_len <= cols; j += vec_len) {\n            svfloat64_t mat_vec = svld1_f64(pg, &matrix[i * cols + j]);\n            svfloat64_t vec_vec = svld1_f64(pg, &vector[j]);\n            svbool_t cmp = svcmpeq_f64(pg, mat_vec, vec_vec);\n            if (!svptest_all(cmp)) {\n                row_match = false;\n                break;\n            }\n        }\n\n        if (row_match) {\n            for (; j < cols; j++) {\n                if (matrix[i * cols + j] != vector[j]) {\n                    row_match = false;\n                    break;\n                }\n            }\n        }\n\n        if (row_match) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        svbool_t pg = svwhilelt_b64(0, cols);\n        svfloat64_t vec = svld1_f64(pg, vector);\n        svfloat64_t row = svld1_f64(pg, &matrix[i * cols]);\n        svbool_t match = svcmpeq_f64(pg, row, vec);\n        if (svptest_all(match)) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    svbool_t pg = svptrue_b64();\n    \n    for (size_t i = 0; i < rows; i++) {\n        bool row_match = true;\n        size_t j = 0;\n        \n        for (; j < cols; j += svcntd()) {\n            svbool_t match = svptrue_b64();\n            svfloat64_t mat_vec = svld1_f64(pg, &matrix[i * cols + j]);\n            svfloat64_t vec_vec = svld1_f64(pg, &vector[j]);\n            \n            match = svcmpeq_f64(pg, mat_vec, vec_vec);\n            \n            if (!svptest_any(pg, match)) {\n                row_match = false;\n                break;\n            }\n        }\n        \n        if (row_match && j >= cols) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        svbool_t pg = svwhilelt_b64(0, cols);\n        svfloat64_t match = svptrue_b64();\n        size_t j = 0;\n\n        while (j < cols) {\n            svfloat64_t mat_vec = svld1_f64(pg, &matrix[i * cols + j]);\n            svfloat64_t vec_vec = svld1_f64(pg, &vector[j]);\n            svbool_t eq = svcmpeq_f64(pg, mat_vec, vec_vec);\n            match = svand_b_z(svptrue_b64(), match, eq);\n            j += svcntd();\n            pg = svwhilelt_b64(j, cols);\n        }\n\n        if (svptest_any(svptrue_b64(), match)) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        svbool_t pg = svwhilelt_b64(0, cols);\n        svfloat64_t v_vec = svld1_f64(pg, vector);\n        svfloat64_t v_row = svld1_f64(pg, matrix + i * cols);\n        svbool_t match = svcmpeq_f64(pg, v_row, v_vec);\n        if (svptest_all(pg, match)) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```c\n#include <arm_sve.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n    \n    svbool_t pg = svwhilelt_b8(0, total_elements);\n    size_t i = 0;\n    \n    while (i < total_elements) {\n        svuint8_t a_vec = svld1_u8(pg, &A[i]);\n        svuint8_t b_vec = svld1_u8(pg, &B[i]);\n        \n        svbool_t eq_mask = svcmpeq_u8(pg, a_vec, b_vec);\n        equal_count += svcntp_b8(pg, eq_mask);\n        \n        i += svcntb();\n        pg = svwhilelt_b8(i, total_elements);\n    }\n    \n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```c\n#include <arm_sve.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n    \n    svbool_t pg = svwhilelt_b8(0, total_elements);\n    size_t i = 0;\n    \n    while (i < total_elements) {\n        svuint8_t vec_a = svld1_u8(pg, &A[i]);\n        svuint8_t vec_b = svld1_u8(pg, &B[i]);\n        \n        svbool_t eq_mask = svcmpeq_u8(pg, vec_a, vec_b);\n        equal_count += svcntp_b8(pg, eq_mask);\n        \n        i += svcntb();\n        pg = svwhilelt_b8(i, total_elements);\n    }\n    \n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```c\n#include <arm_sve.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_size = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    svbool_t pg = svwhilelt_b8(0, total_size);\n    size_t i = 0;\n\n    while (i < total_size) {\n        svuint8_t vec_a = svld1_u8(pg, &A[i]);\n        svuint8_t vec_b = svld1_u8(pg, &B[i]);\n        svbool_t eq_mask = svcmpeq_u8(pg, vec_a, vec_b);\n        count += svcntp_b8(pg, eq_mask);\n        i += svcntb();\n        pg = svwhilelt_b8(i, total_size);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```c\n#include <arm_sve.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n    \n    while (total_elements >= svcntb()) {\n        svbool_t pg = svwhilelt_b8(total_elements, 0);\n        svuint8_t vec_a = svld1_u8(pg, A);\n        svuint8_t vec_b = svld1_u8(pg, B);\n        svbool_t eq_mask = svcmpeq_u8(pg, vec_a, vec_b);\n        equal_count += svcntp_b8(pg, eq_mask);\n        \n        A += svcntb();\n        B += svcntb();\n        total_elements -= svcntb();\n    }\n    \n    // Handle remaining elements\n    for (size_t i = 0; i < total_elements; i++) {\n        if (A[i] == B[i]) {\n            equal_count++;\n        }\n    }\n    \n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```c\n#include <arm_sve.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n    \n    svbool_t pg = svwhilelt_b8(0, total_elements);\n    size_t i = 0;\n    \n    while (i < total_elements) {\n        svuint8_t a_vec = svld1_u8(pg, &A[i]);\n        svuint8_t b_vec = svld1_u8(pg, &B[i]);\n        svbool_t eq_mask = svcmpeq_u8(pg, a_vec, b_vec);\n        equal_count += svcntp_b8(pg, eq_mask);\n        \n        i += svcntb();\n        pg = svwhilelt_b8(i, total_elements);\n    }\n    \n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, length);\n        svint64_t vec_x = svld1_s64(pg, &x[i]);\n        svint64_t vec_ax = svmul_n_s64_x(pg, vec_x, a);\n        svint64_t vec_y = svld1_s64(pg, &y[i]);\n        svint64_t vec_abs_y = svabs_s64_x(pg, vec_y);\n        svint64_t result = svsub_s64_x(pg, vec_ax, vec_abs_y);\n        svst1_s64(pg, &y[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, length);\n        svint64_t vec_x = svld1_s64(pg, &x[i]);\n        svint64_t vec_ax = svmul_n_s64_z(pg, vec_x, a);\n        svint64_t vec_abs_y = svabs_s64_z(pg, &y[i]);\n        svint64_t result = svsub_s64_z(pg, vec_ax, vec_abs_y);\n        svst1_s64(pg, &y[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, length);\n    \n    while (i < length) {\n        svint64_t vec_x = svld1_s64(pg, &x[i]);\n        svint64_t vec_ax = svmul_n_s64_x(pg, vec_x, a);\n        svint64_t vec_y = svabs_s64_x(pg, &y[i]);\n        svint64_t result = svsub_s64_x(pg, vec_ax, vec_y);\n        svst1_s64(pg, &y[i], result);\n        \n        i += svcntd();\n        pg = svwhilelt_b64(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, length);\n        svint64_t vec_x = svld1_s64(pg, &x[i]);\n        svint64_t vec_ax = svmul_n_s64_z(pg, vec_x, a);\n        svint64_t vec_abs_y = svabs_s64_z(pg, vec_y);\n        svint64_t result = svsub_s64_z(pg, vec_ax, vec_abs_y);\n        svst1_s64(pg, &y[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, length);\n        svint64_t vec_x = svld1_s64(pg, x + i);\n        svint64_t vec_ax = svmul_n_s64_x(pg, vec_x, a);\n        svint64_t vec_y = svld1_s64(pg, y + i);\n        svint64_t vec_abs_y = svabs_s64_x(pg, vec_y);\n        svint64_t vec_result = svsub_s64_x(pg, vec_ax, vec_abs_y);\n        svst1_s64(pg, y + i, vec_result);\n    }\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\n#include <arm_sve.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    svint16_t vmin = svdup_n_s16(vec[0]);\n    svint16_t vmax = svdup_n_s16(vec[0]);\n    svbool_t pg = svptrue_b16();\n    \n    size_t i = 0;\n    for (; i + svcntw() <= length; i += svcntw()) {\n        svint16_t v = svld1_s16(pg, vec + i);\n        vmin = svmin_s16_m(pg, vmin, v);\n        vmax = svmax_s16_m(pg, vmax, v);\n    }\n    \n    MinMaxPair result;\n    result.min_num = svminv_s16(pg, vmin);\n    result.max_num = svmaxv_s16(pg, vmax);\n    \n    for (; i < length; i++) {\n        if (vec[i] < result.min_num) result.min_num = vec[i];\n        if (vec[i] > result.max_num) result.max_num = vec[i];\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\n#include <arm_sve.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    svint16_t vmin = svdup_n_s16(vec[0]);\n    svint16_t vmax = svdup_n_s16(vec[0]);\n    svbool_t pg = svwhilelt_b16(0, length);\n\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t p = svwhilelt_b16(i, length);\n        svint16_t v = svld1_s16(p, vec + i);\n        vmin = svmin_s16_m(pg, vmin, v);\n        vmax = svmax_s16_m(pg, vmax, v);\n    }\n\n    MinMaxPair result;\n    result.min_num = svminv_s16(pg, vmin);\n    result.max_num = svmaxv_s16(pg, vmax);\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\n#include <arm_sve.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    svint16_t min_vec = svdup_n_s16(vec[0]);\n    svint16_t max_vec = svdup_n_s16(vec[0]);\n    svbool_t pg = svwhilelt_b16(0, length);\n\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t p = svwhilelt_b16(i, length);\n        svint16_t v = svld1_s16(p, vec + i);\n        min_vec = svmin_s16_m(p, min_vec, v);\n        max_vec = svmax_s16_m(p, max_vec, v);\n    }\n\n    MinMaxPair result;\n    result.min_num = svminv_s16(pg, min_vec);\n    result.max_num = svmaxv_s16(pg, max_vec);\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\n#include <arm_sve.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    svint16_t min_vec = svdup_n_s16(vec[0]);\n    svint16_t max_vec = svdup_n_s16(vec[0]);\n    svbool_t pg = svwhilelt_b16(0, length);\n    \n    size_t i = 0;\n    while (i < length) {\n        svint16_t data = svld1_s16(pg, vec + i);\n        min_vec = svmin_s16_m(pg, min_vec, data);\n        max_vec = svmax_s16_m(pg, max_vec, data);\n        i += svcntw();\n        pg = svwhilelt_b16(i, length);\n    }\n    \n    MinMaxPair result;\n    result.min_num = svminv_s16(pg, min_vec);\n    result.max_num = svmaxv_s16(pg, max_vec);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\n#include <arm_sve.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    svint16_t min_vec = svdup_n_s16(vec[0]);\n    svint16_t max_vec = svdup_n_s16(vec[0]);\n    svbool_t pg = svptrue_b16();\n    \n    size_t i = 0;\n    for (; i + svcntw() <= length; i += svcntw()) {\n        svint16_t data = svld1_s16(pg, &vec[i]);\n        min_vec = svmin_s16_z(pg, min_vec, data);\n        max_vec = svmax_s16_z(pg, max_vec, data);\n    }\n    \n    MinMaxPair result;\n    result.min_num = svminv_s16(pg, min_vec);\n    result.max_num = svmaxv_s16(pg, max_vec);\n    \n    // Handle remaining elements\n    if (i < length) {\n        svbool_t mask = svwhilelt_b16(i, length);\n        svint16_t data = svld1_s16(mask, &vec[i]);\n        min_vec = svmin_s16_z(mask, min_vec, data);\n        max_vec = svmax_s16_z(mask, max_vec, data);\n        result.min_num = svminv_s16(mask, min_vec);\n        result.max_num = svmaxv_s16(mask, max_vec);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n    if (cols == 1) return true;\n\n    svbool_t pg = svwhilelt_b32(0, cols - 1);\n    \n    for (size_t i = 0; i < rows; i++) {\n        const int* row = matrix + i * cols;\n        svint32_t curr = svld1_s32(pg, row);\n        svint32_t next = svld1_s32(pg, row + 1);\n        \n        svbool_t cmp = svcmplt_s32(pg, curr, next);\n        if (!svptest_all(cmp)) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```c\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; i++) {\n        const int* row = matrix + i * cols;\n        bool is_increasing = true;\n        size_t j = 0;\n\n        while (j < cols - 1) {\n            svbool_t pg = svwhilelt_b32(j, cols - 1);\n            svint32_t vec1 = svld1_s32(pg, row + j);\n            svint32_t vec2 = svld1_s32(pg, row + j + 1);\n            svbool_t cmp = svcmplt_s32(pg, vec1, vec2);\n\n            if (!svptest_all(pg, cmp)) {\n                is_increasing = false;\n                break;\n            }\n\n            j += svcntw();\n        }\n\n        if (!is_increasing) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols <= 1) return false;\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        svbool_t pg = svwhilelt_b32(0, cols - 1);\n        svint32_t curr = svld1_s32(pg, row);\n        svint32_t next = svld1_s32(pg, row + 1);\n        svbool_t cmp = svcmplt_s32(pg, curr, next);\n        if (!svptest_all(pg, cmp)) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```cpp\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        svbool_t pg = svwhilelt_b32(0, cols - 1);\n        svint32_t vec1 = svld1_s32(pg, row);\n        svint32_t vec2 = svld1_s32(pg, row + 1);\n        svbool_t cmp = svcmplt_s32(pg, vec1, vec2);\n\n        if (!svptest_all(pg, cmp)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols <= 1) return false;\n\n    for (size_t i = 0; i < rows; i++) {\n        const int* row = matrix + i * cols;\n        svbool_t pg = svwhilelt_b32(0, cols - 1);\n        svint32_t v1 = svld1_s32(pg, row);\n        svint32_t v2 = svld1_s32(pg, row + 1);\n        svbool_t cmp = svcmplt_s32(pg, v1, v2);\n        \n        if (!svptest_all(cmp)) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t blocks_per_row = cols / block_size;\n    size_t blocks_per_col = rows / block_size;\n    svbool_t pg = svwhilelt_b32(0, block_size * block_size);\n\n    for (size_t block_row = 0; block_row < blocks_per_col; block_row++) {\n        for (size_t block_col = 0; block_col < blocks_per_row; block_col++) {\n            if (block_row == 0 && block_col == 0) {\n                continue;\n            }\n\n            const int* first_block = matrix;\n            const int* current_block = matrix + block_row * block_size * cols + block_col * block_size;\n\n            for (size_t i = 0; i < block_size; i++) {\n                const int* first_row = first_block + i * cols;\n                const int* curr_row = current_block + i * cols;\n                size_t j = 0;\n\n                while (j < block_size) {\n                    svint32_t vec1 = svld1(pg, first_row + j);\n                    svint32_t vec2 = svld1(pg, curr_row + j);\n                    svbool_t cmp = svcmpeq(pg, vec1, vec2);\n\n                    if (!svptest_all(cmp)) {\n                        return false;\n                    }\n\n                    j += svcntw();\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t blocks_per_row = cols / block_size;\n    size_t blocks_per_col = rows / block_size;\n    svbool_t pg = svwhilelt_b32(0, block_size * block_size);\n\n    // Load the first block into a vector for comparison\n    int first_block[block_size * block_size];\n    for (size_t i = 0; i < block_size; i++) {\n        for (size_t j = 0; j < block_size; j++) {\n            first_block[i * block_size + j] = matrix[i * cols + j];\n        }\n    }\n\n    // Compare each block with the first block\n    for (size_t block_row = 0; block_row < blocks_per_col; block_row++) {\n        for (size_t block_col = 0; block_col < blocks_per_row; block_col++) {\n            if (block_row == 0 && block_col == 0) continue; // Skip the first block\n\n            size_t start_row = block_row * block_size;\n            size_t start_col = block_col * block_size;\n            bool block_equal = true;\n\n            for (size_t i = 0; i < block_size && block_equal; i++) {\n                size_t row_idx = start_row + i;\n                svint32_t v_first = svld1_s32(pg, &first_block[i * block_size]);\n                svint32_t v_current = svld1_s32(pg, &matrix[row_idx * cols + start_col]);\n                svbool_t cmp = svcmpeq_s32(pg, v_first, v_current);\n                \n                if (!svptest_all(cmp)) {\n                    block_equal = false;\n                }\n            }\n\n            if (!block_equal) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t blocks_per_row = cols / block_size;\n    size_t blocks_per_col = rows / block_size;\n    svbool_t pg = svwhilelt_b32(0, block_size * block_size);\n\n    for (size_t br = 0; br < blocks_per_col; ++br) {\n        for (size_t bc = 0; bc < blocks_per_row; ++bc) {\n            if (br == 0 && bc == 0) continue;\n\n            const int* first_block = matrix;\n            const int* current_block = matrix + br * block_size * cols + bc * block_size;\n            bool blocks_equal = true;\n\n            for (size_t i = 0; i < block_size; ++i) {\n                const int* first_row = first_block + i * cols;\n                const int* curr_row = current_block + i * cols;\n                size_t j = 0;\n\n                while (j < block_size) {\n                    svint32_t vec1 = svld1(pg, first_row + j);\n                    svint32_t vec2 = svld1(pg, curr_row + j);\n                    svbool_t cmp = svcmpeq(pg, vec1, vec2);\n                    if (!svptest_all(cmp)) {\n                        blocks_equal = false;\n                        break;\n                    }\n                    j += svcntw();\n                }\n\n                if (!blocks_equal) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t blocks_per_row = cols / block_size;\n    size_t blocks_per_col = rows / block_size;\n    svbool_t pg = svwhilelt_b32(0, block_size);\n\n    for (size_t block_row = 0; block_row < blocks_per_col; block_row++) {\n        for (size_t block_col = 1; block_col < blocks_per_row; block_col++) {\n            for (size_t i = 0; i < block_size; i++) {\n                const int* first_block_row = matrix + (block_row * block_size * cols);\n                const int* curr_block_row = matrix + (block_row * block_size * cols + block_col * block_size);\n\n                svint32_t first_vec = svld1_s32(pg, first_block_row + i * cols);\n                svint32_t curr_vec = svld1_s32(pg, curr_block_row + i * cols);\n\n                svbool_t cmp = svcmpeq_s32(pg, first_vec, curr_vec);\n                if (!svptest_all(pg, cmp)) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    // Check if block_size is valid and matrix can be divided into blocks\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t blocks_per_row = cols / block_size;\n    size_t blocks_per_col = rows / block_size;\n    \n    // Process blocks\n    for (size_t block_row = 0; block_row < blocks_per_col; block_row++) {\n        for (size_t block_col = 0; block_col < blocks_per_row; block_col++) {\n            if (block_row == 0 && block_col == 0) {\n                continue; // Skip first block\n            }\n            \n            // Compare current block with first block\n            for (size_t i = 0; i < block_size; i++) {\n                size_t row_offset = block_row * block_size * cols + i * cols;\n                size_t first_row_offset = i * cols;\n                \n                svbool_t pg = svwhilelt_b32(0, block_size);\n                size_t col_offset = block_col * block_size;\n                \n                // Load vectors from first block and current block\n                svint32_t first_vec = svld1_s32(pg, matrix + first_row_offset + col_offset);\n                svint32_t curr_vec = svld1_s32(pg, matrix + row_offset + col_offset);\n                \n                // Compare vectors\n                svbool_t cmp = svcmpeq_s32(pg, first_vec, curr_vec);\n                \n                // Check if all elements match\n                if (!svptest_all(cmp)) {\n                    return false;\n                }\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == NULL || length < block_size || block_size == 0) {\n        return false;\n    }\n\n    size_t vector_length = svcntd();\n    svbool_t pg = svptrue_b64();\n\n    // Load the first block into registers\n    svfloat64_t first_block[block_size];\n    for (size_t i = 0; i < block_size; i += vector_length) {\n        size_t elements = (block_size - i) < vector_length ? (block_size - i) : vector_length;\n        svbool_t mask = svwhilelt_b64(i, block_size);\n        first_block[i / vector_length] = svld1_f64(mask, vec + i);\n    }\n\n    // Process complete blocks\n    for (size_t i = block_size; i <= length - block_size; i += block_size) {\n        for (size_t j = 0; j < block_size; j += vector_length) {\n            size_t elements = (block_size - j) < vector_length ? (block_size - j) : vector_length;\n            svbool_t mask = svwhilelt_b64(j, block_size);\n\n            // Load current block\n            svfloat64_t curr_block = svld1_f64(mask, vec + i + j);\n\n            // Compute absolute difference\n            svfloat64_t diff = svabs_f64_z(pg, svsub_f64_z(pg, curr_block, first_block[j / vector_length]));\n\n            // Compare with tolerance\n            svbool_t cmp = svcmplt_f64(pg, diff, svdup_f64(tolerance));\n\n            // Check if all elements are within tolerance\n            if (!svptest_all(pg, cmp)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (!vec || tolerance < 0 || length < block_size || block_size == 0) {\n        return false;\n    }\n\n    svbool_t pg = svwhilelt_b64(0, block_size);\n    svfloat64_t tol_vec = svdup_f64(tolerance);\n    svfloat64_t first_block[block_size];\n\n    for (size_t i = 0; i < block_size; i += svcntd()) {\n        size_t count = svcntd();\n        if (i + count > block_size) count = block_size - i;\n        svbool_t pg_i = svwhilelt_b64(i, block_size);\n        first_block[i / svcntd()] = svld1_f64(pg_i, vec + i);\n    }\n\n    for (size_t i = block_size; i + block_size <= length; i += block_size) {\n        for (size_t j = 0; j < block_size; j += svcntd()) {\n            size_t count = svcntd();\n            if (j + count > block_size) count = block_size - j;\n            svbool_t pg_j = svwhilelt_b64(j, block_size);\n            svfloat64_t current = svld1_f64(pg_j, vec + i + j);\n            svfloat64_t diff = svabs_f64_z(pg_j, svsub_f64_z(pg_j, current, first_block[j / svcntd()]));\n            svbool_t cmp = svcmple_f64(pg_j, diff, tol_vec);\n            if (!svptest_all(pg_j, cmp)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || tolerance < 0 || length < block_size || block_size == 0) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 1) {\n        return false;\n    }\n\n    svbool_t pg = svwhilelt_b64(0, block_size);\n    svfloat64_t tol_vec = svdup_f64(tolerance);\n\n    svfloat64_t first_block[block_size];\n    for (size_t i = 0; i < block_size; i++) {\n        first_block[i] = svld1_f64(pg, vec + i);\n    }\n\n    for (size_t block = 1; block < num_blocks; block++) {\n        for (size_t i = 0; i < block_size; i++) {\n            svfloat64_t curr_vec = svld1_f64(pg, vec + block * block_size + i);\n            svfloat64_t diff = svsub_f64_x(pg, first_block[i], curr_vec);\n            svfloat64_t abs_diff = svabs_f64_x(pg, diff);\n            svbool_t cmp = svcmple_f64(pg, abs_diff, tol_vec);\n            if (!svptest_all_true(pg, cmp)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || tolerance < 0 || length < block_size || block_size == 0) {\n        return false;\n    }\n\n    size_t vec_len = svcntd();\n    svbool_t pg = svwhilelt_b64(0, block_size);\n    svfloat64_t tol_vec = svdup_f64(tolerance);\n\n    svfloat64_t first_block[block_size];\n    for (size_t i = 0; i < block_size; i += vec_len) {\n        svbool_t pg_i = svwhilelt_b64(i, block_size);\n        first_block[i / vec_len] = svld1_f64(pg_i, vec + i);\n    }\n\n    for (size_t i = block_size; i + block_size <= length; i += block_size) {\n        for (size_t j = 0; j < block_size; j += vec_len) {\n            svbool_t pg_j = svwhilelt_b64(j, block_size);\n            svfloat64_t curr_block = svld1_f64(pg_j, vec + i + j);\n            svfloat64_t first = first_block[j / vec_len];\n            svfloat64_t diff = svsub_f64_x(pg_j, curr_block, first);\n            svfloat64_t abs_diff = svabs_f64_x(pg_j, diff);\n            svbool_t cmp = svcmple_f64(pg_j, abs_diff, tol_vec);\n            if (!svptest_all_true(pg_j, cmp)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (!vec || tolerance < 0 || length < block_size || block_size == 0) {\n        return false;\n    }\n\n    svbool_t pg = svwhilelt_b64(0, block_size);\n    svfloat64_t tol = svdup_f64(tolerance);\n\n    // Load the first block into registers\n    svfloat64_t first_block[block_size];\n    for (size_t i = 0; i < block_size; i++) {\n        first_block[i] = svdup_f64(vec[i]);\n    }\n\n    // Process complete blocks\n    for (size_t i = block_size; i <= length - block_size; i += block_size) {\n        for (size_t j = 0; j < block_size; j++) {\n            svfloat64_t current = svld1_f64(pg, &vec[i + j]);\n            svfloat64_t diff = svsub_f64_x(pg, first_block[j], current);\n            svfloat64_t abs_diff = svabs_f64_x(pg, diff);\n            svbool_t cmp = svcmple_f64(pg, abs_diff, tol);\n            if (!svptest_all_true(pg, cmp)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        svfloat64_t sum = svdup_f64(0.0);\n        const double* row = matrix + i * cols;\n        \n        for (size_t j = 0; j < cols; j += svcntd()) {\n            svbool_t pg = svwhilelt_b64(j, cols);\n            svfloat64_t vec = svld1_f64(pg, row + j);\n            sum = svmla_f64_x(pg, sum, vec, vec);\n        }\n        \n        double row_sum = svaddv_f64(svptrue_b64(), sum);\n        double norm = sqrt(row_sum);\n        result[i] = norm > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        svfloat64_t sum = svdup_f64(0.0);\n        svbool_t pg = svptrue_b64();\n\n        for (size_t j = 0; j < cols; j += svcntd()) {\n            svbool_t pg_loop = svwhilelt_b64(j, cols);\n            svfloat64_t vec = svld1_f64(pg_loop, &matrix[i * cols + j]);\n            sum = svmla_f64_x(pg_loop, sum, vec, vec);\n        }\n\n        svfloat64_t norm = svsqrt_f64_x(pg, sum);\n        svfloat64_t thresh = svld1_f64(pg, &thresholds[i]);\n        svbool_t cmp = svcmpgt_f64(pg, norm, thresh);\n        result[i] = svptest_any(pg, cmp);\n    }\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        svfloat64_t sum = svdup_f64(0.0);\n        const double* row = matrix + i * cols;\n        \n        for (size_t j = 0; j < cols; j += svcntd()) {\n            svbool_t pg = svwhilelt_b64(j, cols);\n            svfloat64_t vec = svld1_f64(pg, row + j);\n            sum = svmla_f64_x(pg, sum, vec, vec);\n        }\n        \n        double row_sum = svaddv_f64(svptrue_b64(), sum);\n        double norm = sqrt(row_sum);\n        result[i] = norm > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        svfloat64_t sum = svdup_f64(0.0);\n        svbool_t pg = svptrue_b64();\n\n        for (size_t j = 0; j < cols; j += svcntd()) {\n            svbool_t pg_loop = svwhilelt_b64(j, cols);\n            svfloat64_t vec = svld1_f64(pg_loop, &matrix[i * cols + j]);\n            sum = svmla_f64_x(pg_loop, sum, vec, vec);\n        }\n\n        sum = svsqrt_f64_x(pg, sum);\n        double row_norm = svaddv_f64(pg, sum);\n        result[i] = row_norm > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        svfloat64_t sum = svdup_f64(0.0);\n        svbool_t pg = svptrue_b64();\n        \n        for (size_t j = 0; j < cols; j += svcntd()) {\n            svbool_t pg_loop = svwhilelt_b64(j, cols);\n            svfloat64_t vec = svld1_f64(pg_loop, &matrix[i * cols + j]);\n            sum = svmla_f64_x(pg_loop, sum, vec, vec);\n        }\n        \n        sum = svsqrt_f64_x(pg, sum);\n        double row_norm = svaddv_f64(pg, sum);\n        result[i] = row_norm > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    for (; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svuint32_t va = svld1_u32(pg, &A[i]);\n        svuint32_t vb = svld1_u32(pg, &B[i]);\n        svuint32_t vc = svorr_z(pg, va, vb);\n        svst1_u32(pg, &C[i], vc);\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    for (; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svuint32_t va = svld1_u32(pg, &A[i]);\n        svuint32_t vb = svld1_u32(pg, &B[i]);\n        svuint32_t vc = svorr_z(pg, va, vb);\n        svst1_u32(pg, &C[i], vc);\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svuint32_t va = svld1_u32(pg, A + i);\n        svuint32_t vb = svld1_u32(pg, B + i);\n        svuint32_t vc = svorr_u32_z(pg, va, vb);\n        svst1_u32(pg, C + i, vc);\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    for (; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svuint32_t va = svld1_u32(pg, A + i);\n        svuint32_t vb = svld1_u32(pg, B + i);\n        svuint32_t vc = svorr_z(pg, va, vb);\n        svst1_u32(pg, C + i, vc);\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svuint32_t va = svld1_u32(pg, &A[i]);\n        svuint32_t vb = svld1_u32(pg, &B[i]);\n        svuint32_t vc = svorr_u32_m(pg, va, vb);\n        svst1_u32(pg, &C[i], vc);\n    }\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n    svbool_t pg = svwhilelt_b8(0, length);\n    \n    for (size_t i = 0; i < length; ) {\n        svint8_t a = svld1_s8(pg, A + i);\n        svint8_t b = svld1_s8(pg, B + i);\n        \n        svint16_t a_ext = svextend_s16_s8(a);\n        svint16_t b_ext = svextend_s16_s8(b);\n        \n        svint16_t a_square = svmul_s16(a_ext, a_ext);\n        svint16_t ab_product = svmul_s16(a_ext, b_ext);\n        \n        sum_squares += svaddv_s16(pg, a_square);\n        sum_products += svaddv_s16(pg, ab_product);\n        \n        i += svcntb();\n        pg = svwhilelt_b8(i, length);\n    }\n    \n    return sum_squares - sum_products;\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n    svbool_t pg = svwhilelt_b8(0, length);\n    \n    for (size_t i = 0; i < length; ) {\n        svint8_t vec_a = svld1_s8(pg, &A[i]);\n        svint8_t vec_b = svld1_s8(pg, &B[i]);\n        \n        svint16_t vec_a_s16 = svunpklo_s16(vec_a);\n        svint16_t vec_b_s16 = svunpklo_s16(vec_b);\n        \n        svint16_t squares_a = svmul_s16_z(pg, vec_a_s16, vec_a_s16);\n        svint16_t squares_b = svmul_s16_z(pg, vec_b_s16, vec_b_s16);\n        svint16_t products = svmul_s16_z(pg, vec_a_s16, vec_b_s16);\n        \n        sum_squares += svaddv_s16(pg, squares_a);\n        sum_squares += svaddv_s16(pg, squares_b);\n        sum_products += svaddv_s16(pg, products);\n        \n        i += svcntb();\n        pg = svwhilelt_b8(i, length);\n    }\n    \n    return sum_squares - sum_products;\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n    svbool_t pg = svwhilelt_b8(0, length);\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svint8_t vec_a = svld1_s8(pg, A);\n        svint8_t vec_b = svld1_s8(pg, B);\n\n        svint16_t vec_a_16 = svmul_s8_z(pg, vec_a, vec_a);\n        svint16_t vec_b_16 = svmul_s8_z(pg, vec_b, vec_b);\n        svint16_t vec_prod_16 = svmul_s8_z(pg, vec_a, vec_b);\n\n        sum_squares += svaddv_s16(pg, vec_a_16);\n        sum_squares += svaddv_s16(pg, vec_b_16);\n        sum_products += svaddv_s16(pg, vec_prod_16);\n\n        A += svcntb();\n        B += svcntb();\n        pg = svwhilelt_b8(A - A, length);\n    }\n\n    return sum_squares - sum_products;\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    svint32_t sum_squares_a = svdup_n_s32(0);\n    svint32_t sum_squares_b = svdup_n_s32(0);\n    svint32_t sum_products = svdup_n_s32(0);\n    \n    svbool_t pg = svwhilelt_b8(0, length);\n    \n    for (size_t i = 0; i < length; i += svcntb()) {\n        pg = svwhilelt_b8(i, length);\n        \n        svint8_t vec_a = svld1_s8(pg, A + i);\n        svint8_t vec_b = svld1_s8(pg, B + i);\n        \n        svint32_t a_ext = svsxth_s32_z(pg, vec_a);\n        svint32_t b_ext = svsxth_s32_z(pg, vec_b);\n        \n        sum_squares_a = svmlal_s32(sum_squares_a, a_ext, a_ext);\n        sum_squares_b = svmlal_s32(sum_squares_b, b_ext, b_ext);\n        sum_products = svmlal_s32(sum_products, a_ext, b_ext);\n    }\n    \n    int64_t total_squares_a = svaddv_s32(svptrue_b32(), sum_squares_a);\n    int64_t total_squares_b = svaddv_s32(svptrue_b32(), sum_squares_b);\n    int64_t total_products = svaddv_s32(svptrue_b32(), sum_products);\n    \n    return (total_squares_a + total_squares_b) - (2 * total_products);\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n    svbool_t pg = svwhilelt_b8(0, length);\n\n    for (size_t i = 0; i < length; ) {\n        svint8_t vec_a = svld1_s8(pg, &A[i]);\n        svint8_t vec_b = svld1_s8(pg, &B[i]);\n\n        svint16_t vec_a_16 = svsxtb_s16(vec_a);\n        svint16_t vec_b_16 = svsxtb_s16(vec_b);\n\n        svint16_t squares_a = svmul_s16(vec_a_16, vec_a_16);\n        svint16_t squares_b = svmul_s16(vec_b_16, vec_b_16);\n        svint16_t products = svmul_s16(vec_a_16, vec_b_16);\n\n        sum_squares += svaddv_s16(pg, squares_a);\n        sum_squares += svaddv_s16(pg, squares_b);\n        sum_products += svaddv_s16(pg, products);\n\n        i += svcntb();\n        pg = svwhilelt_b8(i, length);\n    }\n\n    return sum_squares - sum_products;\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, length);\n        svuint64_t va = svld1_u64(pg, &A[i]);\n        svuint64_t vb = svld1_u64(pg, &B[i]);\n        svuint64_t vnot_b = svnot_u64_z(pg, vb);\n        svuint64_t result = svand_u64_z(pg, va, vnot_b);\n        svst1_u64(pg, &C[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b64();\n    \n    for (; i + svcntd() <= length; i += svcntd()) {\n        svuint64_t a = svld1_u64(pg, &A[i]);\n        svuint64_t b = svld1_u64(pg, &B[i]);\n        svuint64_t b_not = svnot_u64_z(pg, b);\n        svuint64_t result = svand_u64_z(pg, a, b_not);\n        svst1_u64(pg, &C[i], result);\n    }\n    \n    if (i < length) {\n        svbool_t pg_tail = svwhilelt_b64(i, length);\n        svuint64_t a = svld1_u64(pg_tail, &A[i]);\n        svuint64_t b = svld1_u64(pg_tail, &B[i]);\n        svuint64_t b_not = svnot_u64_z(pg_tail, b);\n        svuint64_t result = svand_u64_z(pg_tail, a, b_not);\n        svst1_u64(pg_tail, &C[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, length);\n        svuint64_t va = svld1_u64(pg, &A[i]);\n        svuint64_t vb = svld1_u64(pg, &B[i]);\n        svuint64_t vb_not = svnot_u64_z(pg, vb);\n        svuint64_t vc = svand_u64_z(pg, va, vb_not);\n        svst1_u64(pg, &C[i], vc);\n    }\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, length);\n    \n    for (; i < length; i += svcntd()) {\n        pg = svwhilelt_b64(i, length);\n        svuint64_t va = svld1_u64(pg, A + i);\n        svuint64_t vb = svld1_u64(pg, B + i);\n        svuint64_t vb_neg = svnot_u64_z(pg, vb);\n        svuint64_t result = svand_u64_z(pg, va, vb_neg);\n        svst1_u64(pg, C + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, length);\n    \n    while (i < length) {\n        svuint64_t a = svld1_u64(pg, &A[i]);\n        svuint64_t b = svld1_u64(pg, &B[i]);\n        svuint64_t b_neg = svnot_u64_z(pg, b);\n        svuint64_t result = svand_u64_z(pg, a, b_neg);\n        svst1_u64(pg, &C[i], result);\n        \n        i += svcntd();\n        pg = svwhilelt_b64(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b8(i, length);\n    \n    while (i < length) {\n        svint8_t a = svld1_s8(pg, A + i);\n        svint8_t b = svld1_s8(pg, B + i);\n        \n        svbool_t pos_mask = svand_b_z(pg, svcmpgt_s8(pg, a, 0), svcmpgt_s8(pg, b, 0));\n        svbool_t neg_mask = svand_b_z(pg, svcmplt_s8(pg, a, 0), svcmplt_s8(pg, b, 0));\n        \n        svint8_t result = svsel_s8(pos_mask, svdup_s8(1), svdup_s8(0));\n        result = svsel_s8(neg_mask, svdup_s8(-1), result);\n        \n        svst1_s8(pg, C + i, result);\n        \n        i += svcntb();\n        pg = svwhilelt_b8(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    for (size_t i = 0; i < length; i += svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, length);\n        \n        svint8_t a = svld1_s8(pg, &A[i]);\n        svint8_t b = svld1_s8(pg, &B[i]);\n        \n        svbool_t a_pos = svcmpgt_n_s8(pg, a, 0);\n        svbool_t b_pos = svcmpgt_n_s8(pg, b, 0);\n        svbool_t a_neg = svcmplt_n_s8(pg, a, 0);\n        svbool_t b_neg = svcmplt_n_s8(pg, b, 0);\n        \n        svbool_t both_pos = svand_b_z(pg, a_pos, b_pos);\n        svbool_t both_neg = svand_b_z(pg, a_neg, b_neg);\n        \n        svint8_t result = svsel_s8(both_pos, svdup_n_s8(1),\n                         svsel_s8(both_neg, svdup_n_s8(-1), svdup_n_s8(0)));\n        \n        svst1_s8(pg, &C[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b8(i, length);\n    \n    while (i < length) {\n        svint8_t a = svld1_s8(pg, A + i);\n        svint8_t b = svld1_s8(pg, B + i);\n        \n        svbool_t pos_mask = svand_b_z(pg, svcmpgt_s8(pg, a, 0), svcmpgt_s8(pg, b, 0));\n        svbool_t neg_mask = svand_b_z(pg, svcmplt_s8(pg, a, 0), svcmplt_s8(pg, b, 0));\n        \n        svint8_t result = svsel_s8(pos_mask, svdup_s8(1), svdup_s8(0));\n        result = svsel_s8(neg_mask, svdup_s8(-1), result);\n        \n        svst1_s8(pg, C + i, result);\n        \n        i += svcntb();\n        pg = svwhilelt_b8(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b8(i, length);\n    \n    while (i < length) {\n        svint8_t a = svld1_s8(pg, &A[i]);\n        svint8_t b = svld1_s8(pg, &B[i]);\n        \n        svbool_t pos_mask = svand_b_z(pg, svcmpgt_s8(pg, a, 0), svcmpgt_s8(pg, b, 0));\n        svbool_t neg_mask = svand_b_z(pg, svcmplt_s8(pg, a, 0), svcmplt_s8(pg, b, 0));\n        \n        svint8_t result = svsel_s8(pos_mask, svdup_s8(1), svdup_s8(0));\n        result = svsel_s8(neg_mask, svdup_s8(-1), result);\n        \n        svst1_s8(pg, &C[i], result);\n        \n        i += svcntb();\n        pg = svwhilelt_b8(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    for (; i < length; i += svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, length);\n        \n        svint8_t a = svld1_s8(pg, &A[i]);\n        svint8_t b = svld1_s8(pg, &B[i]);\n        \n        svbool_t pos_mask = svand_b_z(pg, svcmpgt_s8(pg, a, 0), svcmpgt_s8(pg, b, 0));\n        svbool_t neg_mask = svand_b_z(pg, svcmplt_s8(pg, a, 0), svcmplt_s8(pg, b, 0));\n        \n        svint8_t result = svdup_s8(0);\n        result = svsel_s8(pos_mask, svdup_s8(1), result);\n        result = svsel_s8(neg_mask, svdup_s8(-1), result);\n        \n        svst1_s8(pg, &C[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t mid = length / 2;\n    svbool_t pg = svwhilelt_b16(0, length);\n    \n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t mask = svwhilelt_b16(i, length);\n        svuint16_t a = svld1_u16(mask, A + i);\n        svuint16_t b = svld1_u16(mask, B + i);\n        \n        svbool_t before_mid = svwhilelt_b16(i, mid);\n        svbool_t at_mid = svcmpeq_n_u16(mask, svindex_u16(i, 1), mid);\n        svbool_t after_mid = svwhilege_b16(i, mid + 1);\n        \n        svuint16_t result = svsel_u16(at_mid, a,\n                                   svsel_u16(before_mid, sveor_u16_z(mask, a, b),\n                                             svand_u16_z(mask, a, b)));\n        \n        svst1_u16(mask, C + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t mid = length / 2;\n    svbool_t pg = svwhilelt_b16(0, length);\n    \n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t active = svwhilelt_b16(i, length);\n        svuint16_t a = svld1_u16(active, &A[i]);\n        svuint16_t b = svld1_u16(active, &B[i]);\n        \n        svbool_t before_mid = svwhilelt_b16(i, mid);\n        svbool_t at_mid = svcmpeq_u16(active, svindex_u16(i, 1), mid);\n        svbool_t after_mid = svwhilege_b16(i, mid + 1);\n        \n        svuint16_t result = svsel_u16(at_mid, a,\n                            svsel_u16(before_mid, sveor_u16_x(active, a, b),\n                                      svand_u16_x(active, a, b)));\n        \n        svst1_u16(active, &C[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t mid = length / 2;\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b16(i, length);\n    \n    for (; i < length; ) {\n        svuint16_t a = svld1_u16(pg, A + i);\n        svuint16_t b = svld1_u16(pg, B + i);\n        svuint16_t result;\n        \n        svbool_t before_mid = svwhilelt_b16(i, mid);\n        svbool_t at_mid = svcmpeq_u16(pg, svindex_u16(i, 1), mid);\n        svbool_t after_mid = svwhilege_b16(i, mid + 1);\n        \n        svuint16_t xor_result = sveor_u16_z(pg, a, b);\n        svuint16_t and_result = svand_u16_z(pg, a, b);\n        \n        result = svsel_u16(before_mid, xor_result, and_result);\n        result = svsel_u16(at_mid, a, result);\n        \n        svst1_u16(pg, C + i, result);\n        \n        i += svcntw();\n        pg = svwhilelt_b16(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t mid = length / 2;\n    svbool_t pg = svwhilelt_b16(0, length);\n    \n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t p = svwhilelt_b16(i, length);\n        svuint16_t a = svld1_u16(p, &A[i]);\n        svuint16_t b = svld1_u16(p, &B[i]);\n        \n        svbool_t before_mid = svwhilelt_b16(i, mid);\n        svbool_t at_mid = svcmpeq_n_u16(p, svindex_u16(i, 1), mid);\n        svbool_t after_mid = svwhilege_b16(i, mid + 1);\n        \n        svuint16_t result = svsel_u16(at_mid, a,\n                                    svsel_u16(before_mid, \n                                             svxor_u16_x(p, a, b),\n                                             svand_u16_x(p, a, b)));\n        \n        svst1_u16(p, &C[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t mid = length / 2;\n    svbool_t pg = svwhilelt_b16(0, length);\n    \n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t mask = svwhilelt_b16(i, length);\n        svuint16_t vec_a = svld1_u16(mask, &A[i]);\n        svuint16_t vec_b = svld1_u16(mask, &B[i]);\n        svuint16_t result;\n\n        if (i <= mid && mid < i + svcntw()) {\n            svbool_t before_mid = svwhilelt_b16(i, mid);\n            svbool_t at_mid = svcmpeq_u16(mask, svindex_u16(i, 1), mid);\n            svbool_t after_mid = svwhilege_b16(i, mid + 1);\n\n            svuint16_t xor_result = sveor_u16_m(before_mid, vec_a, vec_b);\n            svuint16_t and_result = svand_u16_m(after_mid, vec_a, vec_b);\n            svuint16_t mid_result = svsel_u16(at_mid, vec_a, svdup_u16(0));\n\n            result = svsel_u16(before_mid, xor_result, \n                   svsel_u16(at_mid, mid_result, and_result));\n        } else if (i < mid) {\n            result = sveor_u16_m(mask, vec_a, vec_b);\n        } else if (i > mid) {\n            result = svand_u16_m(mask, vec_a, vec_b);\n        } else {\n            result = vec_a;\n        }\n\n        svst1_u16(mask, &C[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i < total_size; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, total_size);\n        \n        svbool_t c1 = svld1_b8(pg, &cond1[i]);\n        svbool_t c2 = svld1_b8(pg, &cond2[i]);\n        \n        svfloat32_t a_vec = svld1_f32(pg, &A[i]);\n        svfloat32_t b_vec = svld1_f32(pg, &B[i]);\n        svfloat32_t c_vec = svld1_f32(pg, &C[i]);\n        svfloat32_t d_vec = svld1_f32(pg, &D[i]);\n        \n        svbool_t c1_and_c2 = svand_b_z(svptrue_b32(), c1, c2);\n        svbool_t c1_and_not_c2 = svand_b_z(svptrue_b32(), c1, svnot_b_z(pg, c2));\n        svbool_t not_c1_and_c2 = svand_b_z(svptrue_b32(), svnot_b_z(pg, c1), c2);\n        svbool_t not_c1_and_not_c2 = svand_b_z(svptrue_b32(), svnot_b_z(pg, c1), svnot_b_z(pg, c2));\n        \n        svfloat32_t result = svsel_f32(c1_and_c2, a_vec, \n                            svsel_f32(c1_and_not_c2, b_vec, \n                            svsel_f32(not_c1_and_c2, c_vec, d_vec)));\n        \n        svst1_f32(pg, &out[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i < total; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, total);\n\n        svfloat32_t a_vec = svld1_f32(pg, &A[i]);\n        svfloat32_t b_vec = svld1_f32(pg, &B[i]);\n        svfloat32_t c_vec = svld1_f32(pg, &C[i]);\n        svfloat32_t d_vec = svld1_f32(pg, &D[i]);\n\n        svbool_t cond1_vec = svld1_b8(pg, &cond1[i]);\n        svbool_t cond2_vec = svld1_b8(pg, &cond2[i]);\n\n        svbool_t cond1_and_cond2 = svand_b_z(pg, cond1_vec, cond2_vec);\n        svbool_t cond1_and_not_cond2 = svbic_b_z(pg, cond1_vec, cond2_vec);\n        svbool_t not_cond1_and_cond2 = svbic_b_z(pg, cond2_vec, cond1_vec);\n        svbool_t not_cond1_and_not_cond2 = svnot_b_z(pg, svorr_b_z(pg, cond1_vec, cond2_vec));\n\n        svfloat32_t result = svsel_f32(cond1_and_cond2, a_vec, \n                             svsel_f32(cond1_and_not_cond2, b_vec, \n                             svsel_f32(not_cond1_and_cond2, c_vec, d_vec)));\n\n        svst1_f32(pg, &out[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i < total_elements; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n\n        svfloat32_t a_vec = svld1_f32(pg, &A[i]);\n        svfloat32_t b_vec = svld1_f32(pg, &B[i]);\n        svfloat32_t c_vec = svld1_f32(pg, &C[i]);\n        svfloat32_t d_vec = svld1_f32(pg, &D[i]);\n\n        svbool_t cond1_vec = svld1_b8(pg, &cond1[i]);\n        svbool_t cond2_vec = svld1_b8(pg, &cond2[i]);\n\n        svbool_t cond1_and_cond2 = svand_b_z(svptrue_b32(), cond1_vec, cond2_vec);\n        svbool_t cond1_and_not_cond2 = svbic_b_z(svptrue_b32(), cond1_vec, cond2_vec);\n        svbool_t not_cond1_and_cond2 = svbic_b_z(svptrue_b32(), cond2_vec, cond1_vec);\n        svbool_t not_cond1_and_not_cond2 = svnot_b_z(svptrue_b32(), svorr_b_z(svptrue_b32(), cond1_vec, cond2_vec));\n\n        svfloat32_t result = svsel_f32(cond1_and_cond2, a_vec, \n                            svsel_f32(cond1_and_not_cond2, b_vec, \n                            svsel_f32(not_cond1_and_cond2, c_vec, d_vec)));\n\n        svst1_f32(pg, &out[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "<xaiArtifact artifact_id=\"89823f85-1fb3-4a9e-9bd4-ea5eed16088a\" artifact_version_id=\"d4011e0f-99f3-4a27-8c21-702f3367a742\" title=\"tensor_multi_select_simd.c\" contentType=\"text/x-csrc\">\n#include <arm_sve.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i < total_size; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, total_size);\n        \n        svfloat32_t a_vec = svld1_f32(pg, &A[i]);\n        svfloat32_t b_vec = svld1_f32(pg, &B[i]);\n        svfloat32_t c_vec = svld1_f32(pg, &C[i]);\n        svfloat32_t d_vec = svld1_f32(pg, &D[i]);\n        \n        svbool_t cond1_vec = svld1_b8(pg, &cond1[i]);\n        svbool_t cond2_vec = svld1_b8(pg, &cond2[i]);\n        \n        svbool_t cond1_and_cond2 = svand_b_z(pg, cond1_vec, cond2_vec);\n        svbool_t cond1_and_not_cond2 = svbic_b_z(pg, cond1_vec, cond2_vec);\n        svbool_t not_cond1_and_cond2 = svbic_b_z(pg, cond2_vec, cond1_vec);\n        \n        svfloat32_t result = svsel_f32(cond1_and_cond2, a_vec, d_vec);\n        result = svsel_f32(cond1_and_not_cond2, b_vec, result);\n        result = svsel_f32(not_cond1_and_cond2, c_vec, result);\n        \n        svst1_f32(pg, &out[i], result);\n    }\n}\n</xaiArtifact>"}
{"task_id": "SimdBench_45_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i < total_size; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, total_size);\n\n        svfloat32_t a_vec = svld1_f32(pg, &A[i]);\n        svfloat32_t b_vec = svld1_f32(pg, &B[i]);\n        svfloat32_t c_vec = svld1_f32(pg, &C[i]);\n        svfloat32_t d_vec = svld1_f32(pg, &D[i]);\n\n        svbool_t cond1_vec = svld1_b8(pg, &cond1[i]);\n        svbool_t cond2_vec = svld1_b8(pg, &cond2[i]);\n\n        svbool_t cond1_and_cond2 = svand_b_z(svptrue_b32(), cond1_vec, cond2_vec);\n        svbool_t cond1_and_not_cond2 = svbic_b_z(svptrue_b32(), cond1_vec, cond2_vec);\n        svbool_t not_cond1_and_cond2 = svbic_b_z(svptrue_b32(), cond2_vec, cond1_vec);\n        svbool_t not_cond1_and_not_cond2 = svnot_b_z(svptrue_b32(), svorr_b_z(svptrue_b32(), cond1_vec, cond2_vec));\n\n        svfloat32_t result = svsel_f32(cond1_and_cond2, a_vec, \n                           svsel_f32(cond1_and_not_cond2, b_vec, \n                           svsel_f32(not_cond1_and_cond2, c_vec, d_vec)));\n\n        svst1_f32(pg, &out[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    while (i < total_elements) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        svuint32_t vec = svld1_u32(pg, &A[i]);\n        \n        // Count bits using SVE intrinsics\n        svuint32_t count = svcntw_z(pg, vec);\n        \n        // Extract lower 8 bits of count\n        svuint8_t result = svlsr_n_u8_z(pg, svreinterpret_u8_u32(count), 24);\n        \n        // Store result\n        svst1_u8(pg, &out[i], result);\n        \n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    while (i < total_elements) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        svuint32_t vec = svld1_u32(pg, &A[i]);\n\n        svuint32_t count = svcntw_z(pg, vec);\n        svuint32_t temp = vec;\n\n        temp = svlsr_n_u32_z(pg, temp, 1);\n        count = svadd_n_u32_z(pg, count, svcntw_z(pg, temp));\n\n        temp = svlsr_n_u32_z(pg, temp, 1);\n        count = svadd_n_u32_z(pg, count, svcntw_z(pg, temp));\n\n        temp = svlsr_n_u32_z(pg, temp, 1);\n        count = svadd_n_u32_z(pg, count, svcntw_z(pg, temp));\n\n        temp = svlsr_n_u32_z(pg, temp, 1);\n        count = svadd_n_u32_z(pg, count, svcntw_z(pg, temp));\n\n        temp = svlsr_n_u32_z(pg, temp, 1);\n        count = svadd_n_u32_z(pg, count, svcntw_z(pg, temp));\n\n        temp = svlsr_n_u32_z(pg, temp, 1);\n        count = svadd_n_u32_z(pg, count, svcntw_z(pg, temp));\n\n        temp = svlsr_n_u32_z(pg, temp, 1);\n        count = svadd_n_u32_z(pg, count, svcntw_z(pg, temp));\n\n        svuint8_t result = svmov_n_u8_z(pg, count);\n        svst1_u8(pg, &out[i], result);\n\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vec_len = svcntw();\n    svbool_t pg = svptrue_b32();\n\n    for (size_t i = 0; i < total_elements; i += vec_len) {\n        svbool_t mask = svwhilelt_b32(i, total_elements);\n        svuint32_t vec = svld1_u32(mask, &A[i]);\n        \n        svuint32_t count = svcntp_b32(svpopcnt_u32_z(mask, vec));\n        svuint8_t result = svreinterpret_u8_u32(count);\n        \n        svst1_u8(mask, &out[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i < total_elements; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        svuint32_t vec = svld1_u32(pg, &A[i]);\n        \n        svuint32_t count = svcntp_b32(pg, svptrue_b32());\n        svuint8_t result = svdup_n_u8(0);\n        \n        for (int j = 0; j < 32; j++) {\n            svbool_t bit_set = svcmpeq_n_u32(pg, svand_n_u32(pg, vec, 1u << j), 1u << j);\n            result = svadd_n_u8_z(pg, result, svcntp_b8(pg, bit_set));\n        }\n        \n        svst1_u8(pg, &out[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b32(i, total_elements);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t vec = svld1_u32(pg, &A[i]);\n        \n        // Count bits using SVE instructions\n        svuint32_t count = svcntw_z(pg, vec);\n        \n        // Convert to uint8_t and store\n        svuint8_t result = svlsr_n_u8_z(pg, svreinterpret_u8_u32(count), 0);\n        svst1_u8(pg, &out[i], result);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```c\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    for (; i < total_elements; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        svint32_t vec_a = svld1(pg, &A[i]);\n\n        // Compute remainder when divided by 3\n        svint32_t three = svdup_n_s32(3);\n        svint32_t remainder = svmod_n_s32(pg, vec_a, three);\n        svbool_t cond = svcmpeq(pg, remainder, 0);\n\n        // Compute absolute value for elements where condition is true\n        svint32_t abs_val = svabs_s32_m(pg, vec_a, cond);\n\n        // Select between abs_val (where cond is true) and original value (where cond is false)\n        svint32_t result = svsel_s32(cond, abs_val, vec_a);\n\n        // Store the result\n        svst1(pg, &B[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```c\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    for (; i < total_elements; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        svint32_t vec_a = svld1_s32(pg, &A[i]);\n\n        // Compute if elements are divisible by 3\n        svint32_t vec_div3 = svdiv_n_s32_z(pg, vec_a, 3);\n        svint32_t vec_mul3 = svmul_n_s32_z(pg, vec_div3, 3);\n        svbool_t cond = svcmpeq_s32(pg, vec_a, vec_mul3);\n\n        // Compute absolute value for elements where condition is true\n        svint32_t vec_abs = svabs_s32_z(pg, vec_a);\n\n        // Select between abs and original value based on condition\n        svint32_t result = svsel_s32(cond, vec_abs, vec_a);\n\n        // Store result\n        svst1_s32(pg, &B[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```c\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    for (; i < total_elements; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        svint32_t vec_a = svld1_s32(pg, &A[i]);\n        \n        // Compute if elements are divisible by 3\n        svint32_t vec_three = svdup_s32(3);\n        svint32_t vec_rem = svmod_s32_z(pg, vec_a, vec_three);\n        svbool_t cond = svcmpeq_s32(pg, vec_rem, 0);\n        \n        // Compute absolute value for elements where condition is true\n        svint32_t vec_abs = svabs_s32_z(pg, vec_a);\n        \n        // Select between abs and original based on condition\n        svint32_t result = svsel_s32(cond, vec_abs, vec_a);\n        \n        // Store result\n        svst1_s32(pg, &B[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```c\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    for (; i < total_elements; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        svint32_t vec_a = svld1_s32(pg, &A[i]);\n\n        // Compute if elements are divisible by 3\n        svint32_t vec_div3 = svdiv_n_s32_z(pg, vec_a, 3);\n        svint32_t vec_mul3 = svmul_n_s32_z(pg, vec_div3, 3);\n        svbool_t cond = svcmpeq_s32(pg, vec_a, vec_mul3);\n\n        // Compute absolute value for elements where condition is true\n        svint32_t vec_abs = svabs_s32_m(pg, vec_a, cond);\n\n        // Select between abs value and original value based on condition\n        svint32_t result = svsel_s32(cond, vec_abs, vec_a);\n\n        // Store the result\n        svst1_s32(pg, &B[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```c\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    for (; i < total_elements; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        svint32_t vec_a = svld1(pg, &A[i]);\n        \n        // Compute remainder when divided by 3\n        svint32_t three = svdup_n_s32(3);\n        svint32_t remainder = svmod_n_s32(pg, vec_a, three);\n        svbool_t cond = svcmpeq(pg, remainder, 0);\n        \n        // Compute absolute value for elements where condition is true\n        svint32_t abs_val = svabs_s32_m(cond, vec_a);\n        \n        // Select between abs_val and original value based on condition\n        svint32_t result = svsel_s32(cond, abs_val, vec_a);\n        \n        // Store result\n        svst1(pg, &B[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    size_t i = 0;\n\n    do {\n        svuint32_t vec_src = svld1_u32(pg, &src[i]);\n        svuint32_t low_bits = svand_u32_z(pg, vec_src, 0xF);\n        svbool_t cond = svcmpeq_u32(pg, low_bits, 0xF);\n\n        svuint32_t rotated = svror_u32_z(pg, vec_src, rotate_bits);\n        svuint32_t negated = svnot_u32_z(pg, vec_src);\n\n        svuint32_t result = svsel_u32(cond, rotated, negated);\n        svst1_u32(pg, &dst[i], result);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    size_t i = 0;\n\n    do {\n        svuint32_t src_vec = svld1_u32(pg, &src[i]);\n        svuint32_t mask = svand_n_u32_z(pg, src_vec, 0xF);\n        svbool_t cond = svcmpeq_n_u32(pg, mask, 0xF);\n\n        svuint32_t rotated = svror_n_u32_z(pg, src_vec, rotate_bits);\n        svuint32_t negated = svnot_u32_z(pg, src_vec);\n\n        svuint32_t result = svsel_u32(cond, rotated, negated);\n        svst1_u32(pg, &dst[i], result);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n    \n    do {\n        // Load the source vector\n        svuint32_t vec_src = svld1_u32(pg, &src[i]);\n        \n        // Check condition: low 4 bits are all 1 (i.e., src & 0xF == 0xF)\n        svuint32_t mask = svand_n_u32_z(pg, vec_src, 0xF);\n        svbool_t cond = svcmpeq_n_u32(pg, mask, 0xF);\n        \n        // Compute rotation for elements where condition is true\n        svuint32_t rotated = svror_n_u32_z(pg, vec_src, rotate_bits);\n        \n        // Compute bitwise negation for elements where condition is false\n        svuint32_t negated = svnot_u32_z(pg, vec_src);\n        \n        // Select result based on condition\n        svuint32_t result = svsel_u32(cond, rotated, negated);\n        \n        // Store the result to destination\n        svst1_u32(pg, &dst[i], result);\n        \n        // Update the predicate for the next iteration\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n    \n    do {\n        svuint32_t src_vec = svld1_u32(pg, &src[i]);\n        \n        // Check if low 4 bits are all 1 (i.e., src_vec & 0xF == 0xF)\n        svuint32_t low_bits = svand_n_u32_z(pg, src_vec, 0xF);\n        svbool_t cond = svcmpeq_n_u32(pg, low_bits, 0xF);\n        \n        // Compute rotation: (src >> rotate_bits) | (src << (32 - rotate_bits))\n        svuint32_t right_shift = svlsr_n_u32_z(pg, src_vec, rotate_bits);\n        svuint32_t left_shift = svlsl_n_u32_z(pg, src_vec, 32 - rotate_bits);\n        svuint32_t rotated = svorr_u32_z(pg, right_shift, left_shift);\n        \n        // Compute bitwise negation\n        svuint32_t negated = svnot_u32_z(pg, src_vec);\n        \n        // Select result based on condition\n        svuint32_t result = svsel_u32(cond, rotated, negated);\n        \n        // Store result to destination\n        svst1_u32(pg, &dst[i], result);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svuint32_t vec_src = svld1_u32(pg, &src[i]);\n        \n        // Check if low 4 bits are all 1 (0xF)\n        svbool_t cond = svcmpeq_u32(pg, svand_u32_z(pg, vec_src, 0xF), 0xF);\n        \n        // Perform rotation for true condition\n        svuint32_t rotated = svror_n_u32_z(pg, vec_src, rotate_bits);\n        \n        // Perform negation for false condition\n        svuint32_t negated = svnot_u32_z(pg, vec_src);\n        \n        // Select based on condition\n        svuint32_t result = svsel_u32(cond, rotated, negated);\n        \n        // Store result\n        svst1_u32(pg, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    svfloat32_t eps_vec = svdup_f32(epsilon);\n    svfloat32_t neg_eps_vec = svdup_f32(-epsilon);\n    svint8_t one_vec = svdup_s8(1);\n    svint8_t neg_one_vec = svdup_s8(-1);\n    svint8_t zero_vec = svdup_s8(0);\n\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        \n        svfloat32_t a_vec = svld1_f32(pg, A + i);\n        svfloat32_t b_vec = svld1_f32(pg, B + i);\n        \n        svfloat32_t diff = svsub_f32_x(pg, a_vec, b_vec);\n        \n        svbool_t gt_eps = svcmpgt_f32(pg, diff, eps_vec);\n        svbool_t lt_neg_eps = svcmplt_f32(pg, diff, neg_eps_vec);\n        \n        svint8_t result = svsel_s8(gt_eps, one_vec, zero_vec);\n        result = svsel_s8(lt_neg_eps, neg_one_vec, result);\n        \n        svst1_s8(pg, out + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float abs_epsilon = fabsf(epsilon);\n    svfloat32_t eps_vec = svdup_f32(abs_epsilon);\n    svfloat32_t neg_eps_vec = svdup_f32(-abs_epsilon);\n    svfloat32_t one_vec = svdup_f32(1.0f);\n    svfloat32_t neg_one_vec = svdup_f32(-1.0f);\n    svfloat32_t zero_vec = svdup_f32(0.0f);\n\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        \n        svfloat32_t a_vec = svld1_f32(pg, A + i);\n        svfloat32_t b_vec = svld1_f32(pg, B + i);\n        \n        svfloat32_t diff = svsub_f32_z(pg, a_vec, b_vec);\n        \n        svbool_t gt_eps = svcmpgt_f32(pg, diff, eps_vec);\n        svbool_t lt_neg_eps = svcmplt_f32(pg, diff, neg_eps_vec);\n        \n        svfloat32_t result = svsel_f32(gt_eps, one_vec, zero_vec);\n        result = svsel_f32(lt_neg_eps, neg_one_vec, result);\n        \n        svint8_t result_int8 = svcvt_s8_f32_z(pg, result);\n        svst1_s8(pg, out + i, result_int8);\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    svfloat32_t epsilon_vec = svdup_f32(epsilon);\n    svfloat32_t neg_epsilon_vec = svdup_f32(-epsilon);\n    svint8_t one_vec = svdup_s8(1);\n    svint8_t neg_one_vec = svdup_s8(-1);\n    svint8_t zero_vec = svdup_s8(0);\n\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        \n        svfloat32_t a_vec = svld1_f32(pg, &A[i]);\n        svfloat32_t b_vec = svld1_f32(pg, &B[i]);\n        \n        svfloat32_t diff = svsub_f32_x(pg, a_vec, b_vec);\n        \n        svbool_t gt_epsilon = svcmpgt_f32(pg, diff, epsilon_vec);\n        svbool_t lt_neg_epsilon = svcmplt_f32(pg, diff, neg_epsilon_vec);\n        \n        svint8_t result = zero_vec;\n        result = svsel_s8(gt_epsilon, one_vec, result);\n        result = svsel_s8(lt_neg_epsilon, neg_one_vec, result);\n        \n        svst1_s8(pg, &out[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    svfloat32_t eps_vec = svdup_f32(epsilon);\n    svfloat32_t neg_eps_vec = svdup_f32(-epsilon);\n    svfloat32_t one_vec = svdup_f32(1.0f);\n    svfloat32_t neg_one_vec = svdup_f32(-1.0f);\n    svfloat32_t zero_vec = svdup_f32(0.0f);\n    svint8_t one_out_vec = svdup_s8(1);\n    svint8_t neg_one_out_vec = svdup_s8(-1);\n    svint8_t zero_out_vec = svdup_s8(0);\n\n    size_t i = 0;\n    for (; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        \n        svfloat32_t a_vec = svld1_f32(pg, A + i);\n        svfloat32_t b_vec = svld1_f32(pg, B + i);\n        \n        svfloat32_t diff = svsub_f32_z(pg, a_vec, b_vec);\n        \n        svbool_t gt_eps = svcmpgt_f32(pg, diff, eps_vec);\n        svbool_t lt_neg_eps = svcmplt_f32(pg, diff, neg_eps_vec);\n        \n        svint8_t result = svsel_s8(gt_eps, one_out_vec, \n                          svsel_s8(lt_neg_eps, neg_one_out_vec, zero_out_vec));\n        \n        svst1_s8(pg, out + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float abs_epsilon = fabsf(epsilon);\n    svfloat32_t epsilon_vec = svdup_f32(abs_epsilon);\n    svfloat32_t neg_epsilon_vec = svdup_f32(-abs_epsilon);\n    svint8_t one_vec = svdup_s8(1);\n    svint8_t neg_one_vec = svdup_s8(-1);\n    svint8_t zero_vec = svdup_s8(0);\n\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        \n        svfloat32_t a_vec = svld1_f32(pg, A + i);\n        svfloat32_t b_vec = svld1_f32(pg, B + i);\n        \n        svfloat32_t diff = svsub_f32_x(pg, a_vec, b_vec);\n        \n        svbool_t gt_mask = svcmpgt_f32(pg, diff, epsilon_vec);\n        svbool_t lt_mask = svcmplt_f32(pg, diff, neg_epsilon_vec);\n        \n        svint8_t result = svsel_s8(gt_mask, one_vec, zero_vec);\n        result = svsel_s8(lt_mask, neg_one_vec, result);\n        \n        svst1_s8(pg, out + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n    \n    for (; i < size; i += svcntw()) {\n        pg = svwhilelt_b32(i, size);\n        \n        svfloat32_t vec_a = svld1_f32(pg, A + i);\n        \n        svint32_t vec_b = svcvt_s32_f32_m(svundef_s32(), pg, vec_a);\n        \n        svbool_t gt_max = svcmpgt_f32(pg, vec_a, (float)INT32_MAX);\n        svbool_t lt_min = svcmplt_f32(pg, vec_a, (float)INT32_MIN);\n        \n        vec_b = svsel_s32(gt_max, svdup_s32(INT32_MAX), vec_b);\n        vec_b = svsel_s32(lt_min, svdup_s32(INT32_MIN), vec_b);\n        \n        svst1_s32(pg, B + i, vec_b);\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n    \n    for (; i < size; ) {\n        svfloat32_t vec = svld1_f32(pg, A + i);\n        svint32_t result = svcvt_s32_f32_m(svunpklo(svptrue_b32()), vec);\n        \n        svbool_t gt_max = svcmpgt_f32(pg, vec, (float)INT32_MAX);\n        svbool_t lt_min = svcmplt_f32(pg, vec, (float)INT32_MIN);\n        \n        result = svsel_s32(gt_max, svdup_s32(INT32_MAX), result);\n        result = svsel_s32(lt_min, svdup_s32(INT32_MIN), result);\n        \n        svst1_s32(pg, B + i, result);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n    \n    for (; i < size; ) {\n        svfloat32_t vec = svld1_f32(pg, A + i);\n        svint32_t result = svcvt_s32_f32_z(pg, vec);\n        \n        svbool_t gt_max = svcmpgt_f32(pg, vec, (float)INT32_MAX);\n        svbool_t lt_min = svcmplt_f32(pg, vec, (float)INT32_MIN);\n        \n        result = svsel_s32(gt_max, svdup_n_s32(INT32_MAX), result);\n        result = svsel_s32(lt_min, svdup_n_s32(INT32_MIN), result);\n        \n        svst1_s32(pg, B + i, result);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n    \n    for (; i < size; i += svcntw()) {\n        pg = svwhilelt_b32(i, size);\n        \n        svfloat32_t vec_a = svld1_f32(pg, &A[i]);\n        \n        svint32_t vec_b = svcvt_s32_f32_m(svundef_s32(), pg, vec_a);\n        \n        svbool_t gt_max = svcmpgt_f32(pg, vec_a, (float)INT32_MAX);\n        svbool_t lt_min = svcmplt_f32(pg, vec_a, (float)INT32_MIN);\n        \n        vec_b = svsel_s32(gt_max, svdup_s32(INT32_MAX), vec_b);\n        vec_b = svsel_s32(lt_min, svdup_s32(INT32_MIN), vec_b);\n        \n        svst1_s32(pg, &B[i], vec_b);\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n\n    for (; i < size; ) {\n        svfloat32_t vec = svld1_f32(pg, A + i);\n        svint32_t result = svcvt_s32_f32_z(pg, vec);\n        \n        svbool_t gt_max = svcmpgt_f32(pg, vec, (float)INT32_MAX);\n        svbool_t lt_min = svcmplt_f32(pg, vec, (float)INT32_MIN);\n        \n        result = svsel_s32(gt_max, svdup_s32(INT32_MAX), result);\n        result = svsel_s32(lt_min, svdup_s32(INT32_MIN), result);\n        \n        svst1_s32(pg, B + i, result);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    svbool_t pg = svwhilelt_b32(0, size);\n    svfloat32_t scale_vec = svdup_f32((float)scale);\n\n    for (size_t i = 0; i < size; i += svcntw()) {\n        pg = svwhilelt_b32(i, size);\n        svint32_t a_vec = svld1_s32(pg, A + i);\n        svfloat32_t a_float = svcvt_f32_s32_z(pg, a_vec);\n        svfloat32_t result = svmul_f32_z(pg, a_float, scale_vec);\n        svst1_f32(pg, B + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    svfloat32_t scale_vec = svdup_f32((float)scale);\n    size_t i = 0;\n\n    while (i < size) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        svint32_t vec = svld1_s32(pg, A + i);\n        svfloat32_t float_vec = svcvt_f32_s32_z(pg, vec);\n        svfloat32_t scaled_vec = svmul_f32_z(pg, float_vec, scale_vec);\n        svst1_f32(pg, B + i, scaled_vec);\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    svbool_t pg = svwhilelt_b32(0, size);\n    float scale_f = (float)scale;\n\n    for (size_t i = 0; i < size; i += svcntw()) {\n        pg = svwhilelt_b32(i, size);\n        svint32_t vec = svld1_s32(pg, A + i);\n        svfloat32_t vec_f = svcvt_f32_s32_z(pg, vec);\n        vec_f = svmul_f32_z(pg, vec_f, scale_f);\n        svst1_f32(pg, B + i, vec_f);\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    svfloat32_t scale_vec = svdup_f32((float)scale);\n    size_t i = 0;\n\n    for (; svwhilelt_b32(i, size).svcntw; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        svint32_t a_vec = svld1_s32(pg, A + i);\n        svfloat32_t a_float = svcvt_f32_s32_z(pg, a_vec);\n        svfloat32_t result = svmul_f32_z(pg, a_float, scale_vec);\n        svst1_f32(pg, B + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    svbool_t pg = svwhilelt_b32(0, size);\n    svfloat32_t scale_vec = svdup_f32((float)scale);\n\n    for (size_t i = 0; i < size; i += svcntw()) {\n        pg = svwhilelt_b32(i, size);\n        svint32_t a_vec = svld1_s32(pg, A + i);\n        svfloat32_t a_float = svcvt_f32_s32_z(pg, a_vec);\n        svfloat32_t result = svmul_f32_z(pg, a_float, scale_vec);\n        svst1_f32(pg, B + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n\n    for (; i < size; i += svcntw()) {\n        pg = svwhilelt_b32(i, size);\n        \n        svfloat32_t va = svld1_f32(pg, A + i);\n        svfloat32_t vb = svld1_f32(pg, B + i);\n        \n        svfloat32_t vdiv = svdiv_f32_z(pg, va, vb);\n        svint32_t vrounded = svcvt_s32_f32_m(svundef_s32(), pg, svrinta_f32_z(pg, vdiv));\n        \n        svst1_s32(pg, C + i, vrounded);\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    for (; i < size; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        svfloat32_t a = svld1_f32(pg, A + i);\n        svfloat32_t b = svld1_f32(pg, B + i);\n        svfloat32_t div = svdiv_f32_z(pg, a, b);\n        svint32_t rounded = svrinta_z(pg, div);\n        svst1_s32(pg, C + i, rounded);\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        svfloat32_t va = svld1_f32(pg, A + i);\n        svfloat32_t vb = svld1_f32(pg, B + i);\n        svfloat32_t div = svdiv_f32_z(pg, va, vb);\n        svint32_t result = svrinta_z(pg, div);\n        svst1_s32(pg, C + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        svfloat32_t a = svld1_f32(pg, A + i);\n        svfloat32_t b = svld1_f32(pg, B + i);\n        svfloat32_t div = svdiv_f32_z(pg, a, b);\n        svint32_t rounded = svcvtns_s32_f32_z(pg, div);\n        svst1_s32(pg, C + i, rounded);\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n    \n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t a = svld1_f32(pg, A + i);\n        svfloat32_t b = svld1_f32(pg, B + i);\n        \n        svfloat32_t div = svdiv_f32_z(pg, a, b);\n        svint32_t rounded = svrintn_s32_z(pg, div);\n        \n        svst1_s32(pg, C + i, rounded);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, size);\n    \n    for (; i < size; i += svcntd()) {\n        pg = svwhilelt_b64(i, size);\n        \n        svfloat64_t vec_a = svld1_f64(pg, &A[i]);\n        svfloat32_t vec_b = svcvt_f32_f64_z(pg, vec_a);\n        \n        svfloat32_t max_flt = svdup_f32(FLT_MAX);\n        svfloat32_t min_flt = svdup_f32(-FLT_MAX);\n        \n        svbool_t gt_max = svcmpgt_f32(pg, vec_b, max_flt);\n        svbool_t lt_min = svcmplt_f32(pg, vec_b, min_flt);\n        \n        vec_b = svsel_f32(gt_max, max_flt, vec_b);\n        vec_b = svsel_f32(lt_min, min_flt, vec_b);\n        \n        svst1_f32(pg, &B[i], vec_b);\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, size);\n    \n    for (; i < size; ) {\n        svfloat64_t vec_a = svld1_f64(pg, A + i);\n        svfloat32_t vec_b = svcvt_f32_f64_x(pg, vec_a);\n        \n        svfloat32_t max = svdup_f32(FLT_MAX);\n        svfloat32_t min = svdup_f32(-FLT_MAX);\n        \n        vec_b = svmin_f32_x(pg, vec_b, max);\n        vec_b = svmax_f32_x(pg, vec_b, min);\n        \n        svst1_f32(pg, B + i, vec_b);\n        \n        i += svcntd();\n        pg = svwhilelt_b64(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, size);\n    \n    for (; i < size; ) {\n        svfloat64_t vec = svld1_f64(pg, A + i);\n        svfloat32_t result = svcvt_f32_f64_x(pg, vec);\n        \n        svfloat32_t max = svdup_f32(FLT_MAX);\n        svfloat32_t min = svdup_f32(-FLT_MAX);\n        \n        result = svmin_f32_x(pg, result, max);\n        result = svmax_f32_x(pg, result, min);\n        \n        svst1_f32(pg, B + i, result);\n        \n        i += svcntd();\n        pg = svwhilelt_b64(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, size);\n    \n    for (; i < size; ) {\n        svfloat64_t vec_a = svld1_f64(pg, &A[i]);\n        svfloat32_t vec_b = svcvt_f32_f64_x(pg, vec_a);\n        \n        svfloat32_t max = svdup_f32(FLT_MAX);\n        svfloat32_t min = svdup_f32(-FLT_MAX);\n        \n        vec_b = svmin_f32_x(pg, vec_b, max);\n        vec_b = svmax_f32_x(pg, vec_b, min);\n        \n        svst1_f32(pg, &B[i], vec_b);\n        \n        i += svcntd();\n        pg = svwhilelt_b64(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, size);\n    \n    for (; i < size; i += svcntd()) {\n        pg = svwhilelt_b64(i, size);\n        \n        svfloat64_t vec = svld1_f64(pg, A + i);\n        \n        svfloat64_t max = svdup_f64(FLT_MAX);\n        svfloat64_t min = svdup_f64(-FLT_MAX);\n        \n        vec = svmin_f64_m(pg, vec, max);\n        vec = svmax_f64_m(pg, vec, min);\n        \n        svfloat32_t float_vec = svcvt_f32_f64_m(svundef_f32(), pg, vec);\n        \n        svst1_f32(pg, B + i, float_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    for (; i < size; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        svint16_t vec_a = svld1_s16(pg, &A[i]);\n        svint32_t vec_b = svsxt_s32_z(pg, vec_a);\n        svst1_s32(pg, &B[i], vec_b);\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    for (; i < size; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        svint16_t vec = svld1_s16(pg, A + i);\n        svint32_t widened = svsxt_s32_m(svundef_s32(), pg, vec);\n        svst1_s32(pg, B + i, widened);\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b16(i, size);\n    \n    for (; i < size; i += svcntw()) {\n        pg = svwhilelt_b16(i, size);\n        svint16_t vec_a = svld1_s16(pg, A + i);\n        svint32_t vec_b = svsxt_s32_m(svundef_s32(), pg, vec_a);\n        svst1_s32(pg, B + i, vec_b);\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b16(i, size);\n    \n    while (i < size) {\n        svint16_t vec_a = svld1_s16(pg, A + i);\n        svint32_t vec_b = svsxtb_n_s32(vec_a, 0);\n        svst1_s32(pg, B + i, vec_b);\n        i += svcntw();\n        pg = svwhilelt_b16(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        svint16_t vec = svld1_s16(pg, A + i);\n        svint32_t widened = svsxt_s32_m(svundef_s32(), pg, vec);\n        svst1_s32(pg, B + i, widened);\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    svfloat32_t min_vec = svdup_f32(min_val);\n    svfloat32_t max_vec = svdup_f32(max_val);\n    svfloat32_t zero_vec = svdup_f32(0.0f);\n    svfloat32_t one_vec = svdup_f32(1.0f);\n    svfloat32_t range_vec = svsub_f32_x(svptrue_b32(), max_vec, min_vec);\n\n    size_t i = 0;\n    for (; i < size; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        \n        svfloat32_t a_vec = svld1_f32(pg, A + i);\n        svint32_t ctrl_vec = svld1_s32(pg, control + i);\n        \n        svbool_t ctrl_mask = svcmpgt_s32(pg, ctrl_vec, svdup_s32(0));\n        \n        svfloat32_t norm_vec = svsub_f32_x(pg, a_vec, min_vec);\n        norm_vec = svdiv_f32_x(pg, norm_vec, range_vec);\n        norm_vec = svmax_f32_x(pg, norm_vec, zero_vec);\n        norm_vec = svmin_f32_x(pg, norm_vec, one_vec);\n        \n        svfloat32_t result_vec = svsel_f32(ctrl_mask, norm_vec, a_vec);\n        \n        svst1_f32(pg, B + i, result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    svfloat32_t min_vec = svdup_f32(min_val);\n    svfloat32_t max_vec = svdup_f32(max_val);\n    svfloat32_t zero_vec = svdup_f32(0.0f);\n    svfloat32_t one_vec = svdup_f32(1.0f);\n    svfloat32_t range_vec = svsub_f32_x(svptrue_b32(), max_vec, min_vec);\n\n    size_t i = 0;\n    for (; i < size; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        \n        svfloat32_t a_vec = svld1_f32(pg, &A[i]);\n        svint32_t ctrl_vec = svld1_s32(pg, &control[i]);\n        \n        svbool_t mask = svcmpgt_s32(pg, ctrl_vec, svdup_s32(0));\n        \n        svfloat32_t norm_vec = svsub_f32_x(pg, a_vec, min_vec);\n        norm_vec = svdiv_f32_x(pg, norm_vec, range_vec);\n        norm_vec = svmax_f32_x(pg, norm_vec, zero_vec);\n        norm_vec = svmin_f32_x(pg, norm_vec, one_vec);\n        \n        svfloat32_t result_vec = svsel_f32(mask, norm_vec, a_vec);\n        \n        svst1_f32(pg, &B[i], result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float range = max_val - min_val;\n    svfloat32_t min_vec = svdup_f32(min_val);\n    svfloat32_t range_vec = svdup_f32(range);\n    svfloat32_t zero_vec = svdup_f32(0.0f);\n    svfloat32_t one_vec = svdup_f32(1.0f);\n    svbool_t all_true = svptrue_b32();\n\n    for (size_t i = 0; i < size; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        svfloat32_t a_vec = svld1_f32(pg, A + i);\n        svint32_t control_vec = svld1_s32(pg, control + i);\n\n        svbool_t control_mask = svcmpgt(pg, control_vec, svdup_s32(0));\n        svfloat32_t normalized = svsub_f32_x(pg, a_vec, min_vec);\n        normalized = svdiv_f32_x(pg, normalized, range_vec);\n        normalized = svmax_f32_x(pg, normalized, zero_vec);\n        normalized = svmin_f32_x(pg, normalized, one_vec);\n\n        svfloat32_t result = svsel_f32(control_mask, normalized, a_vec);\n        svst1_f32(pg, B + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    svfloat32_t min_vec = svdup_f32(min_val);\n    svfloat32_t max_vec = svdup_f32(max_val);\n    svfloat32_t zero_vec = svdup_f32(0.0f);\n    svfloat32_t one_vec = svdup_f32(1.0f);\n    svfloat32_t range_vec = svsub_f32_x(svptrue_b32(), max_vec, min_vec);\n\n    for (size_t i = 0; i < size; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        \n        svfloat32_t a_vec = svld1_f32(pg, A + i);\n        svint32_t control_vec = svld1_s32(pg, control + i);\n        \n        svbool_t mask = svcmpgt_s32(pg, control_vec, svdup_s32(0));\n        \n        svfloat32_t normalized = svdiv_f32_x(pg, svsub_f32_x(pg, a_vec, min_vec), range_vec);\n        normalized = svmax_f32_x(pg, normalized, zero_vec);\n        normalized = svmin_f32_x(pg, normalized, one_vec);\n        \n        svfloat32_t result = svsel_f32(mask, normalized, a_vec);\n        \n        svst1_f32(pg, B + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    svfloat32_t min_vec = svdup_f32(min_val);\n    svfloat32_t max_vec = svdup_f32(max_val);\n    svfloat32_t zero_vec = svdup_f32(0.0f);\n    svfloat32_t one_vec = svdup_f32(1.0f);\n    svfloat32_t range_vec = svdup_f32(max_val - min_val);\n\n    for (size_t i = 0; i < size; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        \n        svfloat32_t a_vec = svld1_f32(pg, &A[i]);\n        svint32_t ctrl_vec = svld1_s32(pg, &control[i]);\n        \n        svbool_t mask = svcmpgt_s32(pg, ctrl_vec, svdup_s32(0));\n        \n        svfloat32_t norm_vec = svsub_f32_x(pg, a_vec, min_vec);\n        norm_vec = svdiv_f32_x(pg, norm_vec, range_vec);\n        norm_vec = svmax_f32_x(pg, norm_vec, zero_vec);\n        norm_vec = svmin_f32_x(pg, norm_vec, one_vec);\n        \n        svfloat32_t result_vec = svsel_f32(mask, norm_vec, a_vec);\n        \n        svst1_f32(pg, &B[i], result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        svuint32_t vec_a = svld1_u32(pg, A + i);\n        svuint32_t high_bits = svlsr_n_u32_x(pg, vec_a, 16);\n        svfloat32_t float_vec = svcvt_f32_u32_x(pg, high_bits);\n        svfloat32_t sqrt_vec = svsqrt_f32_x(pg, float_vec);\n        svst1_f32(pg, B + i, sqrt_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        svuint32_t vec_a = svld1_u32(pg, &A[i]);\n        svuint32_t vec_a_shifted = svlsr_n_u32_x(pg, vec_a, 16);\n        svfloat32_t vec_float = svcvt_f32_u32_x(pg, vec_a_shifted);\n        svfloat32_t vec_sqrt = svsqrt_f32_x(pg, vec_float);\n        svst1_f32(pg, &B[i], vec_sqrt);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        svuint32_t vec_a = svld1_u32(pg, A + i);\n        svuint32_t high_16 = svlsr_n_u32_x(pg, vec_a, 16);\n        svfloat32_t float_vec = svcvt_f32_u32_x(pg, high_16);\n        svfloat32_t sqrt_vec = svsqrt_f32_x(pg, float_vec);\n        svst1_f32(pg, B + i, sqrt_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    for (; i < size; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        svuint32_t vec = svld1_u32(pg, &A[i]);\n        svuint32_t high16 = svlsr_n_u32_x(pg, vec, 16);\n        svfloat32_t float_vec = svcvt_f32_u32_x(pg, high16);\n        svfloat32_t sqrt_vec = svsqrt_f32_x(pg, float_vec);\n        svst1_f32(pg, &B[i], sqrt_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        svuint32_t vec_a = svld1_u32(pg, A + i);\n        svuint32_t vec_high = svlsr_n_u32_x(pg, vec_a, 16);\n        svfloat32_t vec_float = svcvt_f32_u32_z(pg, vec_high);\n        svfloat32_t vec_sqrt = svsqrt_f32_z(pg, vec_float);\n        svst1_f32(pg, B + i, vec_sqrt);\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    for (; i < size; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        svuint32_t vec = svld1_u32(pg, &A[i]);\n        svfloat32_t float_vec = svreinterpret_f32_u32(vec);\n        svst1_f32(pg, &B[i], float_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    for (; i < size; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        svuint32_t vec = svld1_u32(pg, A + i);\n        svfloat32_t float_vec = svreinterpret_f32_u32(vec);\n        svst1_f32(pg, B + i, float_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        svuint32_t vec = svld1_u32(pg, A + i);\n        svfloat32_t float_vec = svreinterpret_f32_u32(vec);\n        svst1_f32(pg, B + i, float_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n    \n    for (; i < size; i += svcntw()) {\n        pg = svwhilelt_b32(i, size);\n        svuint32_t vec = svld1_u32(pg, &A[i]);\n        svfloat32_t float_vec = svreinterpret_f32_u32(vec);\n        svst1_f32(pg, &B[i], float_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n    \n    while (i < size) {\n        svuint32_t vec = svld1_u32(pg, A + i);\n        svfloat32_t float_vec = svreinterpret_f32_u32(vec);\n        svst1_f32(pg, B + i, float_vec);\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    diff[0] = 0.0f;\n    size_t i = 1;\n    \n    for (; i < size; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        \n        svint32_t a_curr = svld1_s32(pg, &A[i]);\n        svint32_t a_prev = svld1_s32(pg, &A[i-1]);\n        svbool_t cond_vec = svld1_u8(pg, &cond[i]);\n        \n        svint32_t diff_int = svsub_s32_z(pg, a_curr, a_prev);\n        svfloat32_t diff_float = svcvt_f32_s32_z(pg, diff_int);\n        \n        svfloat32_t result = svsel_f32(cond_vec, diff_float, svdup_f32(0.0f));\n        \n        svst1_f32(pg, &diff[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    svbool_t pg = svwhilelt_b32(0, size);\n    size_t i = 0;\n\n    if (size > 0) {\n        diff[0] = 0.0f;\n    }\n\n    for (i = 1; i < size; i += svcntw()) {\n        svbool_t p = svwhilelt_b32(i, size);\n        svint32_t a_curr = svld1_s32(p, &A[i]);\n        svint32_t a_prev = svld1_s32(p, &A[i-1]);\n        svbool_t c = svld1_u8(p, &cond[i]);\n        \n        svint32_t diff_int = svsub_s32_z(p, a_curr, a_prev);\n        svfloat32_t diff_float = svcvt_f32_s32_z(p, diff_int);\n        \n        svfloat32_t result = svsel_f32(c, diff_float, svdup_f32(0.0f));\n        \n        svst1_f32(p, &diff[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    diff[0] = 0.0f;\n    size_t i = 1;\n    svbool_t pg = svwhilelt_b32(i, size);\n    \n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t a_curr = svld1_s32(pg, &A[i]);\n        svint32_t a_prev = svld1_s32(pg, &A[i-1]);\n        svbool_t cond_vec = svld1_u8(pg, &cond[i]);\n        \n        svint32_t diff_int = svsub_s32_z(pg, a_curr, a_prev);\n        svfloat32_t diff_float = svcvt_f32_s32_z(pg, diff_int);\n        \n        svfloat32_t result = svsel_f32(cond_vec, diff_float, svdup_f32(0.0f));\n        \n        svst1_f32(pg, &diff[i], result);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    diff[0] = 0.0f;\n    size_t i = 1;\n    \n    svbool_t pg = svwhilelt_b32(i, size);\n    for (; i < size; i += svcntw()) {\n        pg = svwhilelt_b32(i, size);\n        \n        svint32_t vec_a = svld1_s32(pg, &A[i]);\n        svint32_t vec_a_prev = svld1_s32(pg, &A[i-1]);\n        svbool_t vec_cond = svld1_u8(pg, &cond[i]);\n        \n        svint32_t diff_int = svsub_s32_z(pg, vec_a, vec_a_prev);\n        svfloat32_t diff_float = svcvt_f32_s32_z(pg, diff_int);\n        \n        svfloat32_t result = svsel_f32(vec_cond, diff_float, svdup_f32(0.0f));\n        \n        svst1_f32(pg, &diff[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    svbool_t pg = svptrue_b8();\n    size_t i = 0;\n\n    // Set the first element to 0.0f\n    if (size > 0) {\n        diff[0] = 0.0f;\n        i = 1;\n    }\n\n    // Process the rest of the array using SVE intrinsics\n    for (; i < size; i += svcntw()) {\n        // Create predicate for the current vector length\n        svbool_t pgt = svwhilelt_b32(i, size);\n\n        // Load condition values\n        svbool_t cond_vec = svld1_b8(pgt, &cond[i]);\n\n        // Load current and previous elements of A\n        svint32_t a_curr = svld1_s32(pgt, &A[i]);\n        svint32_t a_prev = svld1_s32(pgt, &A[i - 1]);\n\n        // Compute difference\n        svint32_t diff_int = svsub_s32_x(pgt, a_curr, a_prev);\n\n        // Convert difference to float\n        svfloat32_t diff_float = svcvt_f32_s32_x(pgt, diff_int);\n\n        // Create a vector of 0.0f for false conditions\n        svfloat32_t zero_vec = svdup_f32(0.0f);\n\n        // Select between computed difference and 0.0f based on condition\n        svfloat32_t result = svsel_f32(cond_vec, diff_float, zero_vec);\n\n        // Store the result\n        svst1_f32(pgt, &diff[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, length);\n    \n    do {\n        // Load 32-bit unsigned integers from src\n        svuint32_t vec_src = svld1_u32(pg, &src[i]);\n        \n        // Widen 32-bit to 64-bit\n        svuint64_t vec_dst = svmovlb_u64(vec_src);\n        \n        // Set high 32 bits to 1 by OR-ing with a constant vector\n        svuint64_t high_bits = svdup_u64(0xFFFFFFFF00000000ULL);\n        vec_dst = svorr_u64_z(pg, vec_dst, high_bits);\n        \n        // Store the result to dst\n        svst1_u64(pg, &dst[i], vec_dst);\n        \n        // Update the predicate for the next iteration\n        i += svcntd();\n        pg = svwhilelt_b64(i, length);\n    } while (svptest_any(svptrue_b64(), pg));\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b64();\n    \n    for (; i + svcntd() <= length; i += svcntd()) {\n        svuint32_t vec32 = svld1_u32(pg, &src[i]);\n        svuint64_t vec64 = svcvt_u64_u32_z(pg, vec32);\n        svuint64_t high_bits = svdup_u64(0xFFFFFFFF00000000ULL);\n        svuint64_t result = svorr_u64_z(pg, vec64, high_bits);\n        svst1_u64(pg, &dst[i], result);\n    }\n    \n    // Handle remaining elements\n    if (i < length) {\n        svbool_t pg_rem = svwhilelt_b64(i, length);\n        svuint32_t vec32 = svld1_u32(pg_rem, &src[i]);\n        svuint64_t vec64 = svcvt_u64_u32_z(pg_rem, vec32);\n        svuint64_t high_bits = svdup_u64(0xFFFFFFFF00000000ULL);\n        svuint64_t result = svorr_u64_z(pg_rem, vec64, high_bits);\n        svst1_u64(pg_rem, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b64();\n    \n    for (; i + svcntd() <= length; i += svcntd()) {\n        svuint32_t vec32 = svld1_u32(pg, &src[i]);\n        svuint64_t vec64 = svcvt_u64_u32_z(pg, vec32);\n        svuint64_t high_bits = svdup_u64(0xFFFFFFFF00000000);\n        svuint64_t result = svorr_u64_z(pg, vec64, high_bits);\n        svst1_u64(pg, &dst[i], result);\n    }\n    \n    // Handle remaining elements if length is not a multiple of vector size\n    if (i < length) {\n        svbool_t pg_rem = svwhilelt_b64(i, length);\n        svuint32_t vec32 = svld1_u32(pg_rem, &src[i]);\n        svuint64_t vec64 = svcvt_u64_u32_z(pg_rem, vec32);\n        svuint64_t high_bits = svdup_u64(0xFFFFFFFF00000000);\n        svuint64_t result = svorr_u64_z(pg_rem, vec64, high_bits);\n        svst1_u64(pg_rem, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b64();\n    \n    for (; i + svcntd() <= length; i += svcntd()) {\n        svuint32_t vec32 = svld1_u32(pg, &src[i]);\n        svuint64_t vec64 = svcvt_u64_u32_z(pg, vec32);\n        svuint64_t high_bits = svdup_u64(0xFFFFFFFF00000000ULL);\n        svuint64_t result = svorr_u64_z(pg, vec64, high_bits);\n        svst1_u64(pg, &dst[i], result);\n    }\n    \n    // Handle remaining elements if length is not a multiple of vector length\n    if (i < length) {\n        svbool_t pg_rem = svwhilelt_b64(i, length);\n        svuint32_t vec32 = svld1_u32(pg_rem, &src[i]);\n        svuint64_t vec64 = svcvt_u64_u32_z(pg_rem, vec32);\n        svuint64_t high_bits = svdup_u64(0xFFFFFFFF00000000ULL);\n        svuint64_t result = svorr_u64_z(pg_rem, vec64, high_bits);\n        svst1_u64(pg_rem, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b64();\n    \n    for (; i + svcntd() <= length; i += svcntd()) {\n        svuint32_t vec32 = svld1_u32(pg, &src[i]);\n        svuint64_t vec64 = svcvt_u64_u32_z(pg, vec32);\n        svuint64_t high_bits = svdup_u64(0xFFFFFFFF00000000ULL);\n        svuint64_t result = svorr_u64_z(pg, vec64, high_bits);\n        svst1_u64(pg, &dst[i], result);\n    }\n    \n    // Handle remaining elements if length is not a multiple of vector length\n    if (i < length) {\n        svbool_t pg_rem = svwhilelt_b64(i, length);\n        svuint32_t vec32 = svld1_u32(pg_rem, &src[i]);\n        svuint64_t vec64 = svcvt_u64_u32_z(pg_rem, vec32);\n        svuint64_t high_bits = svdup_u64(0xFFFFFFFF00000000ULL);\n        svuint64_t result = svorr_u64_z(pg_rem, vec64, high_bits);\n        svst1_u64(pg_rem, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c\n#include <arm_sve.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    svbool_t pg = svwhilelt_b16(0, length);\n\n    while (svptest_any(svptrue_b16(), pg)) {\n        svint16_t idx_vec = svld1_s16(pg, index);\n        svbool_t valid_idx = svcmplt_n_s16(pg, idx_vec, length);\n        svfloat64_t data = svld1_gather_s16index_f64(valid_idx, vec, idx_vec);\n        sum_vec = svadd_f64_z(pg, sum_vec, data);\n        index += svcntw();\n        pg = svwhilelt_b16(svcntw(), length);\n    }\n\n    return svaddv_f64(svptrue_b64(), sum_vec);\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c\n#include <arm_sve.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    svbool_t pg = svwhilelt_b16(0, length);\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svuint16_t idx_vec = svld1_s16(pg, index);\n        svbool_t valid_idx = svcmplt_u16(pg, idx_vec, length);\n        \n        svfloat64_t data = svld1_gather_u16index_f64(valid_idx, vec, idx_vec);\n        sum_vec = svadd_f64_z(pg, sum_vec, data);\n\n        index += svcntw();\n        pg = svwhilelt_b16(svcntw(), length);\n    }\n\n    return svaddv_f64(svptrue_b64(), sum_vec);\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c\n#include <arm_sve.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    svbool_t pg = svwhilelt_b16(0, length);\n\n    while (svptest_any(svptrue_b16(), pg)) {\n        svint16_t idx_vec = svld1_s16(pg, index);\n        svbool_t valid_idx = svcmpge(pg, idx_vec, 0);\n        valid_idx = svand_b_z(svptrue_b16(), valid_idx, svcmplt(pg, idx_vec, length));\n\n        svfloat64_t data = svld1_gather_s16index_f64(valid_idx, vec, idx_vec);\n        sum_vec = svadd_m(valid_idx, sum_vec, data);\n\n        index += svcntw();\n        pg = svwhilelt_b16(index - index, length);\n    }\n\n    return svaddv_f64(svptrue_b64(), sum_vec);\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c\n#include <arm_sve.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    svbool_t pg = svwhilelt_b16(0, length);\n\n    while (svptest_any(svptrue_b16(), pg)) {\n        svint16_t idx_vec = svld1_s16(pg, index);\n        svbool_t valid_idx = svcmplt_n_s16(pg, idx_vec, length);\n        svfloat64_t data = svld1_gather_s16index_f64(pg, vec, idx_vec);\n        sum_vec = svsel_f64(valid_idx, svadd_f64_z(pg, sum_vec, data), sum_vec);\n        index += svcntw();\n        pg = svwhilelt_b16(svcntw(), length);\n    }\n\n    return svaddv_f64(svptrue_b64(), sum_vec);\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c\n#include <arm_sve.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    svbool_t pg = svwhilelt_b16(0, length);\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svuint16_t indices = svld1(pg, index);\n        svfloat64_t values = svld1_gather_u16index_f64(pg, vec, indices);\n        sum_vec = svadd_f64_z(pg, sum_vec, values);\n        index += svcntw();\n        pg = svwhilelt_b16(svcntw(), length);\n    }\n\n    return svaddv_f64(svptrue_b64(), sum_vec);\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    svbool_t pg = svptrue_b64();\n\n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            svfloat64_t sum = svdup_f64(0.0);\n\n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj++) {\n                    size_t input_idx = (i + ki) * input_size + (j + kj);\n                    size_t kernel_idx = ki * kernel_size + kj;\n\n                    svfloat64_t input_vec = svdup_f64(input[input_idx]);\n                    svfloat64_t kernel_vec = svdup_f64(kernel[kernel_idx]);\n                    sum = svmla_f64_x(pg, sum, input_vec, kernel_vec);\n                }\n            }\n\n            // Apply ReLU\n            svfloat64_t zero = svdup_f64(0.0);\n            sum = svmax_f64_x(pg, sum, zero);\n\n            // Store result\n            size_t output_idx = i * output_size + j;\n            output[output_idx] = svaddv_f64(pg, sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    \n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            svfloat64_t sum = svdup_f64(0.0);\n            svbool_t pg = svptrue_b64();\n            \n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; kj += svcntd()) {\n                    size_t input_idx = (i + ki) * input_size + (j + kj);\n                    size_t kernel_idx = ki * kernel_size + kj;\n                    \n                    svfloat64_t in_vec = svld1_f64(pg, &input[input_idx]);\n                    svfloat64_t ker_vec = svld1_f64(pg, &kernel[kernel_idx]);\n                    sum = svmla_f64_x(pg, sum, in_vec, ker_vec);\n                }\n            }\n            \n            double conv_sum = svaddv_f64(pg, sum);\n            output[i * output_size + j] = (conv_sum > 0.0) ? conv_sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    svbool_t pg = svwhilelt_b64(0, input_size * input_size);\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            svfloat64_t sum = svdup_f64(0.0);\n            \n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    size_t input_idx = (i + ki) * input_size + (j + kj);\n                    size_t kernel_idx = ki * kernel_size + kj;\n                    \n                    svfloat64_t input_vec = svld1_f64(pg, &input[input_idx]);\n                    svfloat64_t kernel_vec = svdup_f64(kernel[kernel_idx]);\n                    sum = svmla_f64_x(pg, sum, input_vec, kernel_vec);\n                }\n            }\n            \n            svfloat64_t zero = svdup_f64(0.0);\n            sum = svmax_f64_x(pg, sum, zero); // ReLU\n            size_t output_idx = i * output_size + j;\n            svst1_f64(pg, &output[output_idx], sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    svbool_t pg = svptrue_b64();\n\n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            svfloat64_t sum = svdup_f64(0.0);\n            \n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj++) {\n                    size_t input_idx = (i + ki) * input_size + (j + kj);\n                    size_t kernel_idx = ki * kernel_size + kj;\n                    \n                    svfloat64_t input_vec = svld1_f64(pg, &input[input_idx]);\n                    svfloat64_t kernel_vec = svld1_f64(pg, &kernel[kernel_idx]);\n                    sum = svmla_f64_x(pg, sum, input_vec, kernel_vec);\n                }\n            }\n\n            // Apply ReLU\n            svfloat64_t zero = svdup_f64(0.0);\n            sum = svmax_f64_x(pg, sum, zero);\n            \n            // Store result\n            size_t output_idx = i * output_size + j;\n            svst1_f64(pg, &output[output_idx], sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    svbool_t pg = svptrue_b64();\n\n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            svfloat64_t sum_vec = svdup_f64(0.0);\n\n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj++) {\n                    size_t input_idx = (i + ki) * input_size + (j + kj);\n                    size_t kernel_idx = ki * kernel_size + kj;\n                    \n                    svfloat64_t input_vec = svdup_f64(input[input_idx]);\n                    svfloat64_t kernel_vec = svdup_f64(kernel[kernel_idx]);\n                    sum_vec = svmla_f64_x(pg, sum_vec, input_vec, kernel_vec);\n                }\n            }\n\n            // Apply ReLU\n            svfloat64_t zero_vec = svdup_f64(0.0);\n            sum_vec = svmax_f64_x(pg, sum_vec, zero_vec);\n\n            // Store result\n            size_t output_idx = i * output_size + j;\n            output[output_idx] = svaddv_f64(pg, sum_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\nbool has_close_elements_simd(const std::vector<double>& numbers, double threshold) {\n    if (numbers.size() < 2) return false;\n    \n    svbool_t pg = svwhilelt_b64(0, numbers.size());\n    size_t len = svcntd();\n    \n    for (size_t i = 0; i < numbers.size(); i += len) {\n        svbool_t pg_i = svwhilelt_b64(i, numbers.size());\n        svfloat64_t vec_i = svld1_f64(pg_i, &numbers[i]);\n        \n        for (size_t j = i + 1; j < numbers.size(); j += len) {\n            svbool_t pg_j = svwhilelt_b64(j, numbers.size());\n            svfloat64_t vec_j = svld1_f64(pg_j, &numbers[j]);\n            \n            svfloat64_t diff = svabs_f64_z(pg_i, svsub_f64_z(pg_i, vec_i, vec_j));\n            svbool_t cmp = svcmplt_f64(pg_i, diff, svdup_f64(threshold));\n            \n            if (svptest_any(pg_i, cmp)) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n < 2) return false;\n\n    svbool_t pg = svwhilelt_b64(0, n);\n    svfloat64_t thresh_vec = svdup_f64(threshold);\n\n    for (size_t i = 0; i < n - 1; i++) {\n        svfloat64_t vi = svdup_f64(numbers[i]);\n        size_t j = i + 1;\n\n        while (j < n) {\n            svbool_t pg_loop = svwhilelt_b64(j, n);\n            svfloat64_t vj = svld1_f64(pg_loop, &numbers[j]);\n            \n            svfloat64_t diff = svabs_f64_z(pg_loop, svsub_f64_z(pg_loop, vi, vj));\n            svbool_t close = svcmplt_f64(pg_loop, diff, thresh_vec);\n            \n            if (svptest_any(pg_loop, close)) {\n                return true;\n            }\n            \n            j += svcntd();\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n < 2) return false;\n\n    svbool_t pg = svwhilelt_b64(0, n);\n    svfloat64_t thresh_vec = svdup_f64(threshold);\n    \n    for (size_t i = 0; i < n - 1; i++) {\n        svfloat64_t vec_i = svdup_f64(numbers[i]);\n        size_t j = i + 1;\n        \n        while (j < n) {\n            svfloat64_t vec_j = svld1_f64(pg, &numbers[j]);\n            svfloat64_t diff = svabs_f64_x(pg, svsub_f64_x(pg, vec_i, vec_j));\n            svbool_t cmp = svcmplt_f64(pg, diff, thresh_vec);\n            \n            if (svptest_any(pg, cmp)) {\n                return true;\n            }\n            \n            j += svcntd();\n            pg = svwhilelt_b64(j, n);\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    if (numbers.size() < 2) return false;\n\n    svfloat64_t thresh = svdup_f64(threshold);\n    svbool_t pg = svptrue_b64();\n    \n    for (size_t i = 0; i < numbers.size(); ++i) {\n        svfloat64_t vi = svdup_f64(numbers[i]);\n        \n        for (size_t j = i + 1; j < numbers.size(); j += svcntd()) {\n            size_t elements = std::min(svcntd(), numbers.size() - j);\n            pg = svwhilelt_b64(j, numbers.size());\n            \n            svfloat64_t vj = svld1_f64(pg, &numbers[j]);\n            svfloat64_t diff = svabs_f64_z(pg, svsub_f64_z(pg, vi, vj));\n            \n            if (svptest_any(pg, svcmplt_f64(pg, diff, thresh))) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\nbool has_close_elements_simd(const std::vector<double>& numbers, double threshold) {\n    svbool_t pg = svptrue_b64();\n    size_t len = numbers.size();\n    \n    for (size_t i = 0; i < len; i++) {\n        svfloat64_t vi = svdup_f64(numbers[i]);\n        size_t j = i + 1;\n        \n        while (j < len) {\n            // Process vector-length chunks\n            size_t vec_len = svcntd();\n            if (j + vec_len > len) vec_len = len - j;\n            \n            svfloat64_t vj = svld1_f64(pg, &numbers[j]);\n            svfloat64_t diff = svabs_f64_z(pg, svsub_f64_z(pg, vi, vj));\n            svbool_t cmp = svcmplt_f64(pg, diff, threshold);\n            \n            if (svptest_any(pg, cmp)) {\n                return true;\n            }\n            \n            j += vec_len;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nbool below_zero_simd(std::vector<int> operations) {\n    int64_t balance = 0;\n    svbool_t pg = svptrue_b32();\n    \n    size_t len = operations.size();\n    size_t vec_len = svcntw();\n    \n    for (size_t i = 0; i < len; i += vec_len) {\n        size_t remaining = std::min(vec_len, len - i);\n        svbool_t pg_active = svwhilelt_b32(i, len);\n        \n        svint32_t vec = svld1(pg_active, &operations[i]);\n        svint64_t balance_vec = svdup_n_s64(balance);\n        \n        balance_vec = svadd_m(pg_active, balance_vec, svsxtw_z(pg_active, vec));\n        \n        svbool_t negative = svcmplt_s64(pg_active, balance_vec, svdup_n_s64(0));\n        \n        if (svptest_any(pg_active, negative)) {\n            return true;\n        }\n        \n        balance = svlasta(svptrue_b64(), balance_vec);\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    svbool_t pg = svptrue_b32();\n    svint32_t balance = svdup_s32(0);\n    \n    for (size_t i = 0; i < operations.size(); i += svcntw()) {\n        size_t elements = std::min(svcntw(), (int)(operations.size() - i));\n        svbool_t pg_loop = svwhilelt_b32(i, operations.size());\n        \n        svint32_t ops = svld1_s32(pg_loop, &operations[i]);\n        balance = svadd_s32_z(pg_loop, balance, ops);\n        \n        svbool_t negative = svcmplt_s32(pg_loop, balance, svdup_s32(0));\n        if (svptest_any(pg_loop, negative)) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    svbool_t pg = svwhilelt_b32(0, operations.size());\n    svint32_t balance = svdup_s32(0);\n    \n    for (size_t i = 0; i < operations.size(); i += svcntw()) {\n        pg = svwhilelt_b32(i, operations.size());\n        svint32_t ops = svld1_s32(pg, &operations[i]);\n        balance = svadd_m(pg, balance, ops);\n        \n        svbool_t negative = svcmplt_s32(pg, balance, svdup_s32(0));\n        if (svptest_any(pg, negative)) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    svbool_t pg = svptrue_b32();\n    svint32_t balance = svdup_s32(0);\n    \n    for (size_t i = 0; i < operations.size(); i += svcntw()) {\n        svbool_t mask = svwhilelt_b32(i, operations.size());\n        svint32_t ops = svld1_s32(mask, &operations[i]);\n        balance = svadd_m(mask, balance, ops);\n        \n        svbool_t neg = svcmplt_s32(mask, balance, svdup_s32(0));\n        if (svptest_any(pg, neg)) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    svbool_t pg = svptrue_b32();\n    int64_t balance = 0;\n    size_t i = 0;\n    size_t len = operations.size();\n    \n    for (; i + svcntw() <= len; i += svcntw()) {\n        svint32_t vec = svld1_s32(pg, &operations[i]);\n        balance = svaddv_s32(pg, vec, balance);\n        svbool_t neg = svcmplt_s32(pg, svdup_s32(balance), svdup_s32(0));\n        if (svptest_any(pg, neg)) {\n            return true;\n        }\n    }\n    \n    for (; i < len; i++) {\n        balance += operations[i];\n        if (balance < 0) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    if (numbers.empty()) return 0.0;\n\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    svbool_t pg = svwhilelt_b64(0, numbers.size());\n    uint64_t i = 0;\n\n    // Calculate sum\n    while (svptest_any(svptrue_b64(), pg)) {\n        svfloat64_t vec = svld1_f64(pg, &numbers[i]);\n        sum_vec = svadd_f64_z(pg, sum_vec, vec);\n        i += svcntd();\n        pg = svwhilelt_b64(i, numbers.size());\n    }\n\n    // Horizontal sum\n    double sum = svaddv_f64(svptrue_b64(), sum_vec);\n    double mean = sum / numbers.size();\n\n    // Calculate sum of absolute deviations\n    sum_vec = svdup_f64(0.0);\n    pg = svwhilelt_b64(0, numbers.size());\n    i = 0;\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svfloat64_t vec = svld1_f64(pg, &numbers[i]);\n        svfloat64_t diff = svabs_f64_z(pg, svsub_f64_z(pg, vec, svdup_f64(mean)));\n        sum_vec = svadd_f64_z(pg, sum_vec, diff);\n        i += svcntd();\n        pg = svwhilelt_b64(i, numbers.size());\n    }\n\n    // Horizontal sum of absolute deviations\n    double mad_sum = svaddv_f64(svptrue_b64(), sum_vec);\n    return mad_sum / numbers.size();\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    if (numbers.empty()) return 0.0;\n\n    uint64_t len = numbers.size();\n    uint64_t vlen = svcntd();\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    svbool_t pg = svptrue_b64();\n\n    // Calculate sum using SVE\n    for (uint64_t i = 0; i < len; i += vlen) {\n        svbool_t pred = svwhilelt_b64(i, len);\n        svfloat64_t vec = svld1_f64(pred, &numbers[i]);\n        sum_vec = svadd_f64_z(pg, sum_vec, vec);\n    }\n\n    // Horizontal sum\n    double sum = svaddv_f64(pg, sum_vec);\n    double mean = sum / len;\n\n    // Calculate sum of absolute deviations\n    svfloat64_t mean_vec = svdup_f64(mean);\n    svfloat64_t abs_dev_sum = svdup_f64(0.0);\n\n    for (uint64_t i = 0; i < len; i += vlen) {\n        svbool_t pred = svwhilelt_b64(i, len);\n        svfloat64_t vec = svld1_f64(pred, &numbers[i]);\n        svfloat64_t abs_dev = svabs_f64_z(pred, svsub_f64_z(pred, vec, mean_vec));\n        abs_dev_sum = svadd_f64_z(pg, abs_dev_sum, abs_dev);\n    }\n\n    // Horizontal sum of absolute deviations\n    double mad_sum = svaddv_f64(pg, abs_dev_sum);\n    return mad_sum / len;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    if (numbers.empty()) return 0.0;\n\n    uint64_t len = numbers.size();\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    svbool_t pg = svwhilelt_b64(0, len);\n\n    // Calculate sum\n    for (uint64_t i = 0; i < len; i += svcntd()) {\n        svbool_t p = svwhilelt_b64(i, len);\n        svfloat64_t vec = svld1_f64(p, &numbers[i]);\n        sum_vec = svadd_f64_m(p, sum_vec, vec);\n    }\n\n    // Calculate mean\n    double sum = svaddv_f64(svptrue_b64(), sum_vec);\n    double mean = sum / len;\n\n    // Calculate absolute deviations sum\n    svfloat64_t mean_vec = svdup_f64(mean);\n    svfloat64_t abs_dev_sum = svdup_f64(0.0);\n\n    for (uint64_t i = 0; i < len; i += svcntd()) {\n        svbool_t p = svwhilelt_b64(i, len);\n        svfloat64_t vec = svld1_f64(p, &numbers[i]);\n        svfloat64_t abs_dev = svabs_f64_m(p, svsub_f64_m(p, vec, mean_vec));\n        abs_dev_sum = svadd_f64_m(p, abs_dev_sum, abs_dev);\n    }\n\n    // Calculate MAD\n    double abs_dev_total = svaddv_f64(svptrue_b64(), abs_dev_sum);\n    return abs_dev_total / len;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    if (numbers.empty()) return 0.0;\n\n    size_t len = numbers.size();\n    double mean = 0.0;\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    svbool_t pg = svwhilelt_b64(0, len);\n\n    // Calculate sum for mean\n    for (size_t i = 0; i < len; i += svcntd()) {\n        svbool_t p = svwhilelt_b64(i, len);\n        svfloat64_t vec = svld1_f64(p, &numbers[i]);\n        sum_vec = svadd_f64_z(pg, sum_vec, vec);\n    }\n\n    // Horizontal sum for mean\n    double sum = svaddv_f64(pg, sum_vec);\n    mean = sum / len;\n\n    // Calculate sum of absolute deviations\n    svfloat64_t mean_vec = svdup_f64(mean);\n    svfloat64_t abs_sum_vec = svdup_f64(0.0);\n\n    for (size_t i = 0; i < len; i += svcntd()) {\n        svbool_t p = svwhilelt_b64(i, len);\n        svfloat64_t vec = svld1_f64(p, &numbers[i]);\n        svfloat64_t diff = svsub_f64_z(p, vec, mean_vec);\n        svfloat64_t abs_diff = svabs_f64_z(p, diff);\n        abs_sum_vec = svadd_f64_z(pg, abs_sum_vec, abs_diff);\n    }\n\n    // Horizontal sum for MAD\n    double abs_sum = svaddv_f64(pg, abs_sum_vec);\n    return abs_sum / len;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    if (numbers.empty()) return 0.0;\n\n    uint64_t len = numbers.size();\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    svbool_t pg = svwhilelt_b64(0, len);\n\n    // Calculate sum\n    for (uint64_t i = 0; i < len; i += svcntd()) {\n        svbool_t p = svwhilelt_b64(i, len);\n        svfloat64_t vec = svld1_f64(p, &numbers[i]);\n        sum_vec = svadd_f64_m(pg, sum_vec, vec);\n    }\n\n    // Compute mean\n    double sum = svaddv_f64(pg, sum_vec);\n    double mean = sum / len;\n\n    // Calculate absolute deviations sum\n    svfloat64_t mean_vec = svdup_f64(mean);\n    svfloat64_t abs_dev_sum = svdup_f64(0.0);\n\n    for (uint64_t i = 0; i < len; i += svcntd()) {\n        svbool_t p = svwhilelt_b64(i, len);\n        svfloat64_t vec = svld1_f64(p, &numbers[i]);\n        svfloat64_t abs_dev = svabs_f64_m(p, svsub_f64_m(p, vec, mean_vec));\n        abs_dev_sum = svadd_f64_m(pg, abs_dev_sum, abs_dev);\n    }\n\n    // Compute MAD\n    double mad = svaddv_f64(pg, abs_dev_sum) / len;\n    return mad;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimiter) {\n    if (numbers.empty()) return {};\n\n    size_t n = numbers.size();\n    size_t out_size = 2 * n - 1;\n    std::vector<int> result(out_size);\n\n    // Get vector length in elements (assuming int is 32-bit)\n    uint64_t vlen = svcntw();\n    svbool_t pg = svptrue_b32();\n\n    // Prepare delimiter vector\n    svint32_t delim_vec = svdup_s32(delimiter);\n\n    size_t i = 0;\n    for (; i + vlen <= n; i += vlen) {\n        // Load input vector\n        svint32_t in_vec = svld1_s32(pg, &numbers[i]);\n\n        // Calculate output indices\n        size_t out_idx = 2 * i;\n\n        // Store input elements at even indices\n        svst1_s32(pg, &result[out_idx], in_vec);\n\n        // Store delimiters at odd indices\n        svbool_t odd_pg = svptrue_b32();\n        svst1_s32(odd_pg, &result[out_idx + 1], delim_vec);\n    }\n\n    // Handle remaining elements scalarly\n    for (; i < n; i++) {\n        result[2 * i] = numbers[i];\n        if (i < n - 1) {\n            result[2 * i + 1] = delimiter;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    std::vector<int> result;\n    if (numbers.empty()) return result;\n    \n    size_t n = numbers.size();\n    size_t out_size = 2 * n - 1;\n    result.resize(out_size);\n    \n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n    \n    // Process input vector in chunks of vector length\n    for (size_t i = 0; i < n; i += vl) {\n        // Calculate remaining elements\n        size_t remaining = n - i;\n        size_t elements_to_process = std::min(vl, remaining);\n        \n        // Create predicate for active lanes\n        svbool_t active = svwhilelt_b32(i, n);\n        \n        // Load input numbers\n        svint32_t vec_numbers = svld1_s32(active, &numbers[i]);\n        \n        // Store original numbers at even indices (0, 2, 4, ...)\n        size_t out_idx = 2 * i;\n        svst1_s32(active, &result[out_idx], vec_numbers);\n        \n        // Store delimeter at odd indices (1, 3, 5, ...)\n        if (out_idx + 1 < out_size) {\n            svint32_t vec_delimeter = svdup_s32(delimeter);\n            svbool_t next_active = svwhilelt_b32(out_idx + 1, out_size);\n            svst1_s32(next_active, &result[out_idx + 1], vec_delimeter);\n        }\n    }\n    \n    // Handle last delimeter if necessary\n    if (n > 1 && result.size() % 2 == 0) {\n        result.back() = delimeter;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimiter) {\n    std::vector<int> result;\n    size_t len = numbers.size();\n    \n    if (len == 0) return result;\n    \n    // Calculate output size: input_size + (input_size - 1) for delimiters\n    result.resize(len * 2 - 1);\n    \n    // Process vector length\n    svbool_t pg = svwhilelt_b32(0, len);\n    size_t vec_len = svcntw();\n    \n    // Load delimiter into a vector\n    svint32_t delim_vec = svdup_s32(delimiter);\n    \n    size_t i = 0;\n    for (; i + vec_len <= len; i += vec_len) {\n        // Load input vector\n        svint32_t in_vec = svld1_s32(pg, &numbers[i]);\n        \n        // Store input elements at even indices\n        svst1_s32(pg, &result[i * 2], in_vec);\n        \n        // Store delimiters at odd indices\n        if (i + vec_len < len) {\n            svst1_s32(pg, &result[i * 2 + 1], delim_vec);\n        }\n    }\n    \n    // Handle remaining elements scalarly\n    for (; i < len; i++) {\n        result[i * 2] = numbers[i];\n        if (i < len - 1) {\n            result[i * 2 + 1] = delimiter;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) return {};\n\n    size_t n = numbers.size();\n    size_t out_size = n * 2 - 1;\n    std::vector<int> result(out_size);\n\n    // Determine vector length\n    uint64_t vlen = svcntw();\n    svbool_t pg = svptrue_b32();\n\n    // Process input vector in chunks\n    size_t i = 0;\n    for (; i + vlen <= n; i += vlen) {\n        // Load input vector\n        svint32_t vec = svld1(pg, &numbers[i]);\n        \n        // Create delimeter vector\n        svint32_t delim_vec = svdup_n_s32(delimeter);\n        \n        // Store input elements at even indices\n        size_t out_idx = i * 2;\n        svst1(pg, &result[out_idx], vec);\n        \n        // Store delimeter at odd indices\n        svst1(pg, &result[out_idx + 1], delim_vec);\n    }\n\n    // Handle remaining elements\n    if (i < n) {\n        svbool_t remain_pg = svwhilelt_b32(i, n);\n        svint32_t vec = svld1(remain_pg, &numbers[i]);\n        svint32_t delim_vec = svdup_n_s32(delimeter);\n        \n        size_t out_idx = i * 2;\n        svst1(remain_pg, &result[out_idx], vec);\n        if (out_idx + 1 < out_size) {\n            svst1(remain_pg, &result[out_idx + 1], delim_vec);\n        }\n    }\n\n    // If last element is a delimeter, remove it\n    if (out_size > 0 && result[out_size - 1] == delimeter) {\n        result.pop_back();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimiter) {\n    if (numbers.empty()) return {};\n\n    size_t in_len = numbers.size();\n    size_t out_len = in_len * 2 - 1;\n    std::vector<int> result(out_len);\n\n    // Calculate vector length\n    svbool_t pg = svwhilelt_b32(0, in_len);\n    size_t vlen = svcntw();\n\n    // Load delimiter into a vector\n    svint32_t delim_vec = svdup_s32(delimiter);\n\n    size_t i = 0;\n    for (; i + vlen <= in_len; i += vlen) {\n        // Load input vector\n        svint32_t in_vec = svld1_s32(pg, &numbers[i]);\n\n        // Create mask for alternating positions\n        svbool_t even_mask = svzip1_b32(pg, svptrue_b32());\n        svbool_t odd_mask = svnot_b_z(pg, even_mask);\n\n        // Store input values at even indices (0, 2, 4, ...)\n        svst1_s32(even_mask, &result[i * 2], in_vec);\n\n        // Store delimiter at odd indices (1, 3, 5, ...)\n        svst1_s32(odd_mask, &result[i * 2 + 1], delim_vec);\n    }\n\n    // Handle remaining elements scalarly\n    for (; i < in_len; i++) {\n        result[i * 2] = numbers[i];\n        if (i < in_len - 1) {\n            result[i * 2 + 1] = delimiter;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    \n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    svbool_t pg = svwhilelt_b16(0, numbers.size());\n    svint16_t vec;\n    svint64_t sum_vec = svdup_s64(0);\n    svint64_t prod_vec = svdup_s64(1);\n    \n    size_t i = 0;\n    size_t vec_len = svcntw();\n    \n    for (; i + vec_len <= numbers.size(); i += vec_len) {\n        vec = svld1_s16(pg, &numbers[i]);\n        sum_vec = svadd_s64_z(pg, sum_vec, svmul_n_s64_z(pg, svunpklo_s32(vec), 1));\n        prod_vec = svmul_s64_z(pg, prod_vec, svmul_n_s64_z(pg, svunpklo_s32(vec), 1));\n    }\n    \n    sum = svaddv_s64(pg, sum_vec);\n    product = svmulv_s64(pg, prod_vec);\n    \n    // Handle remaining elements\n    for (; i < numbers.size(); i++) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n    \n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    \n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    svbool_t pg = svptrue_b16();\n    size_t len = numbers.size();\n    size_t vl = svcntw();\n    \n    for (size_t i = 0; i < len; i += vl) {\n        svbool_t mask = svwhilelt_b32(i, len);\n        svint16_t vec = svld1_s16(mask, &numbers[i]);\n        \n        // Convert int16 to int64 for sum and product\n        svint64_t vec64 = svextend_s64_z(mask, vec);\n        \n        // Sum reduction\n        sum = svaddv_s64(pg, vec64) + sum;\n        \n        // Product reduction\n        product = svmulv_s64(pg, vec64) * product;\n    }\n    \n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    size_t len = numbers.size();\n    size_t vec_len = svcntw(); // Get vector length in elements (int16_t)\n    svint16_t v_zero = svdup_n_s16(0);\n    svint64_t v_sum = svdup_n_s64(0);\n    svint64_t v_prod = svdup_n_s64(1);\n    svbool_t pg = svptrue_b16();\n\n    size_t i = 0;\n    for (; i + vec_len <= len; i += vec_len) {\n        svint16_t v_num = svld1_s16(pg, &numbers[i]);\n        svint64_t v_num64 = svunpklo_s32(svunpklo_s64(v_num));\n        v_sum = svadd_s64_z(pg, v_sum, v_num64);\n        v_prod = svmul_s64_z(pg, v_prod, v_num64);\n    }\n\n    sum = svaddv_s64(pg, v_sum);\n    product = svmulv_s64(pg, v_prod);\n\n    // Handle remaining elements\n    for (; i < len; ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    \n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    size_t len = numbers.size();\n    size_t vlen = svcntw(); // Get vector length in elements\n    svbool_t pg = svptrue_b32();\n    \n    svint64_t sum_vec = svdup_n_s64(0);\n    svint64_t prod_vec = svdup_n_s64(1);\n    \n    size_t i = 0;\n    for (; i + vlen <= len; i += vlen) {\n        // Load vector of int16_t and convert to int64_t\n        svint16_t vec16 = svld1_s16(pg, &numbers[i]);\n        svint64_t vec64 = svsxt_s64_m(pg, svdup_n_s64(0), vec16);\n        \n        // Accumulate sum\n        sum_vec = svadd_s64_z(pg, sum_vec, vec64);\n        \n        // Accumulate product\n        prod_vec = svmul_s64_z(pg, prod_vec, vec64);\n    }\n    \n    // Reduce sum\n    sum = svaddv_s64(pg, sum_vec);\n    \n    // Reduce product\n    product = svmulv_s64(pg, prod_vec);\n    \n    // Handle remaining elements\n    for (; i < len; i++) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n    \n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    size_t len = numbers.size();\n    size_t vec_len = svcntw(); // Number of 32-bit elements per vector\n    svbool_t pg = svptrue_b32();\n\n    svint32_t sum_vec = svdup_n_s32(0);\n    svint32_t prod_vec = svdup_n_s32(1);\n\n    size_t i = 0;\n    for (; i + vec_len <= len; i += vec_len) {\n        svint32_t vec = svld1_s32(pg, &numbers[i]);\n        sum_vec = svadd_s32_z(pg, sum_vec, vec);\n        prod_vec = svmul_s32_z(pg, prod_vec, vec);\n    }\n\n    // Horizontal reduction for sum\n    sum = svaddv_s32(pg, sum_vec);\n\n    // Horizontal reduction for product\n    product = svmulv_s32(pg, prod_vec);\n\n    // Process remaining elements\n    for (; i < len; ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    size_t len = numbers.size();\n    std::vector<int> result(len);\n    if (len == 0) return result;\n\n    svbool_t pg = svptrue_b32();\n    size_t i = 0;\n    int32_t max_so_far = numbers[0];\n\n    while (i < len) {\n        size_t vl = svcntw();\n        svbool_t active = svwhilelt_b32(i, len);\n        svint32_t vec = svld1_s32(active, &numbers[i]);\n        svint32_t max_vec = svdup_s32(max_so_far);\n        max_vec = svmax_s32_m(active, max_vec, vec);\n        max_so_far = svlastb_s32(active, max_vec);\n        svst1_s32(active, &result[i], max_vec);\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    size_t n = numbers.size();\n    std::vector<int> result(n);\n    if (n == 0) return result;\n\n    // Get the vector length for SVE\n    uint64_t vl = svcntw();\n    svint32_t current_max_vec = svdup_n_s32(numbers[0]);\n    svbool_t pg = svptrue_b32();\n\n    size_t i = 0;\n    for (; i + vl <= n; i += vl) {\n        // Load the current chunk of input data\n        svint32_t data_vec = svld1_s32(pg, &numbers[i]);\n        // Compute rolling maximum using SVE max operation\n        current_max_vec = svmax_s32_m(pg, current_max_vec, data_vec);\n        // Store the result\n        svst1_s32(pg, &result[i], current_max_vec);\n    }\n\n    // Handle remaining elements scalar way if any\n    int current_max = numbers[0];\n    for (size_t j = 0; j < i; j++) {\n        current_max = std::max(current_max, numbers[j]);\n        result[j] = current_max;\n    }\n    for (; i < n; i++) {\n        current_max = std::max(current_max, numbers[i]);\n        result[i] = current_max;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    size_t n = numbers.size();\n    std::vector<int> result(n);\n    if (n == 0) return result;\n\n    // Get the vector length for SVE\n    uint64_t vl = svcntw();\n    svint32_t current_max_vec = svdup_n_s32(numbers[0]);\n    svbool_t pg = svptrue_b32();\n\n    size_t i = 0;\n    for (; i + vl <= n; i += vl) {\n        // Load the current chunk of input data\n        svint32_t input_vec = svld1_s32(pg, &numbers[i]);\n        // Compute rolling max by taking maximum with the previous max vector\n        current_max_vec = svmax_s32_z(pg, current_max_vec, input_vec);\n        // Store the result\n        svst1_s32(pg, &result[i], current_max_vec);\n    }\n\n    // Handle remaining elements scalar-wise\n    int current_max = numbers[0];\n    for (size_t j = 0; j < i; j++) {\n        current_max = std::max(current_max, numbers[j]);\n        result[j] = current_max;\n    }\n    for (; i < n; i++) {\n        current_max = std::max(current_max, numbers[i]);\n        result[i] = current_max;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    size_t n = numbers.size();\n    std::vector<int> result(n);\n    if (n == 0) return result;\n\n    // Get the vector length for SVE\n    uint64_t vl = svcntw();\n    svint32_t max_vec = svdup_n_s32(numbers[0]);\n    size_t i = 0;\n\n    // Process elements in chunks based on vector length\n    for (; i + vl <= n; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t current_vec = svld1_s32(pg, &numbers[i]);\n        max_vec = svmax_s32_m(pg, max_vec, current_vec);\n        svst1_s32(pg, &result[i], max_vec);\n    }\n\n    // Handle remaining elements\n    if (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t current_vec = svld1_s32(pg, &numbers[i]);\n        max_vec = svmax_s32_m(pg, max_vec, current_vec);\n        svst1_s32(pg, &result[i], max_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    size_t n = numbers.size();\n    std::vector<int> result(n);\n    if (n == 0) return result;\n\n    // Get the vector length for SVE\n    uint64_t vl = svcntw();\n    svint32_t max_vec = svdup_n_s32(numbers[0]);\n    size_t i = 0;\n\n    // Process elements in chunks based on vector length\n    for (; i + vl <= n; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t current_vec = svld1_s32(pg, &numbers[i]);\n        max_vec = svmax_s32_m(pg, max_vec, current_vec);\n        svst1_s32(pg, &result[i], max_vec);\n    }\n\n    // Handle remaining elements sequentially\n    int current_max = numbers[0];\n    for (size_t j = 0; j < i && j < n; ++j) {\n        current_max = std::max(current_max, numbers[j]);\n        result[j] = current_max;\n    }\n    for (; i < n; ++i) {\n        current_max = std::max(current_max, numbers[i]);\n        result[i] = current_max;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.size();\n    std::string result(len, '0');\n    \n    // Determine the vector length for SVE\n    uint64_t vec_len = svcntb();\n    size_t i = 0;\n\n    // Process the strings in chunks based on vector length\n    while (i + vec_len <= len) {\n        // Create a predicate for active lanes\n        svbool_t pg = svwhilelt_b8(i, len);\n        \n        // Load chunks of strings a and b into vectors\n        svuint8_t vec_a = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&a[i]));\n        svuint8_t vec_b = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&b[i]));\n        \n        // Perform XOR operation\n        svuint8_t vec_result = sveor_u8_m(pg, vec_a, vec_b);\n        \n        // Store the result back to the output string\n        svst1_u8(pg, reinterpret_cast<uint8_t*>(&result[i]), vec_result);\n        \n        i += vec_len;\n    }\n\n    // Handle remaining elements that don't fit into a full vector\n    for (; i < len; ++i) {\n        result[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.size();\n    std::string result(len, '0');\n    \n    // Determine vector length using SVE\n    uint64_t vlen = svcntb();\n    size_t i = 0;\n\n    // Process input strings in chunks based on vector length\n    while (i + vlen <= len) {\n        // Create predicate for active lanes\n        svbool_t pg = svwhilelt_b8(i, len);\n        \n        // Load chunks of strings a and b into vectors\n        svuint8_t vec_a = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&a[i]));\n        svuint8_t vec_b = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&b[i]));\n        \n        // Perform XOR operation\n        svuint8_t vec_result = sveor_u8_m(pg, vec_a, vec_b);\n        \n        // Convert result back to '0' and '1' characters ('0' is 48, '1' is 49 in ASCII)\n        // If XOR result is 1, set to '1', else '0'\n        svuint8_t vec_zero = svdup_u8(48); // ASCII for '0'\n        svuint8_t vec_one = svdup_u8(49);  // ASCII for '1'\n        svbool_t mask = svcmpeq_u8(pg, vec_result, 49); // Check where result is '1'\n        vec_result = svsel_u8(mask, vec_one, vec_zero);\n        \n        // Store result back to output string\n        svst1_u8(pg, reinterpret_cast<uint8_t*>(&result[i]), vec_result);\n        i += vlen;\n    }\n\n    // Handle remaining elements scalar way\n    for (; i < len; ++i) {\n        result[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.size();\n    std::string result(len, '0');\n    \n    // Determine the vector length for SVE\n    uint64_t vec_len = svcntb();\n    size_t i = 0;\n\n    // Process the strings in chunks based on vector length\n    while (i + vec_len <= len) {\n        // Create predicate for active lanes\n        svbool_t pg = svwhilelt_b8(i, len);\n        \n        // Load chunks of the input strings into vectors\n        svuint8_t vec_a = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&a[i]));\n        svuint8_t vec_b = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&b[i]));\n        \n        // Perform XOR operation\n        svuint8_t vec_result = sveor_u8_m(pg, vec_a, vec_b);\n        \n        // Store the result back to the output string\n        svst1_u8(pg, reinterpret_cast<uint8_t*>(&result[i]), vec_result);\n        \n        i += vec_len;\n    }\n\n    // Handle remaining elements that don't fit into a full vector\n    for (; i < len; ++i) {\n        result[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.size();\n    std::string result(len, '0');\n    \n    // Determine vector length using SVE\n    uint64_t vlen = svcntb();\n    size_t i = 0;\n\n    // Process in chunks based on vector length\n    while (i + vlen <= len) {\n        // Create predicate for active lanes\n        svbool_t pg = svwhilelt_b8(i, len);\n        \n        // Load chunks of strings a and b into vectors\n        svuint8_t vec_a = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&a[i]));\n        svuint8_t vec_b = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&b[i]));\n        \n        // Perform XOR operation\n        svuint8_t vec_result = sveor_u8_m(pg, vec_a, vec_b);\n        \n        // Store result back to output string\n        svst1_u8(pg, reinterpret_cast<uint8_t*>(&result[i]), vec_result);\n        \n        i += vlen;\n    }\n\n    // Handle remaining elements if length is not a multiple of vector length\n    while (i < len) {\n        result[i] = (a[i] == b[i]) ? '0' : '1';\n        i++;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.size();\n    std::string result(len, '0');\n    \n    // Determine vector length using SVE\n    uint64_t vlen = svcntb();\n    size_t i = 0;\n\n    // Process input strings in chunks based on vector length\n    while (i + vlen <= len) {\n        // Create predicate for active lanes\n        svbool_t pg = svwhilelt_b8(i, len);\n        \n        // Load chunks of strings a and b into vectors\n        svuint8_t vec_a = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&a[i]));\n        svuint8_t vec_b = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&b[i]));\n        \n        // Perform XOR operation\n        svuint8_t vec_result = sveor_u8_m(pg, vec_a, vec_b);\n        \n        // Store result back to output string\n        svst1_u8(pg, reinterpret_cast<uint8_t*>(&result[i]), vec_result);\n        \n        i += vlen;\n    }\n\n    // Handle remaining elements scalarly if any\n    for (; i < len; ++i) {\n        result[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) return \"\";\n\n    svbool_t pg = svptrue_b32();\n    uint64_t vlen = svcntw();\n    size_t max_len = 0;\n    size_t max_idx = 0;\n    \n    size_t i = 0;\n    for (; i + vlen <= strings.size(); i += vlen) {\n        svuint32_t lengths = svcntb_n_u32(vlen);\n        \n        for (size_t j = 0; j < vlen; j++) {\n            lengths = svinsr_n_u32(lengths, strings[i + j].length(), j);\n        }\n        \n        uint32_t local_max = svmaxv_u32(pg, lengths);\n        \n        if (local_max > max_len) {\n            max_len = local_max;\n            svbool_t mask = svcmpeq_u32(pg, lengths, local_max);\n            max_idx = i + svlasta_u32(svindex_u32(0, 1), mask);\n        }\n    }\n    \n    for (; i < strings.size(); i++) {\n        if (strings[i].length() > max_len) {\n            max_len = strings[i].length();\n            max_idx = i;\n        }\n    }\n    \n    return strings[max_idx];\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nstd::string longest_simd(const std::vector<std::string>& strings) {\n    if (strings.empty()) return \"\";\n\n    svbool_t pg = svptrue_b8();\n    int64_t max_len = 0;\n    size_t max_idx = 0;\n    size_t vlen = svcntb();\n\n    for (size_t i = 0; i < strings.size(); i += vlen) {\n        size_t remaining = std::min(vlen, strings.size() - i);\n        svbool_t active = svwhilelt_b8(i, i + remaining);\n        \n        // Create vector of lengths\n        int64_t lengths[16] = {0}; // Assuming max vector length\n        for (size_t j = 0; j < remaining && i + j < strings.size(); ++j) {\n            lengths[j] = strings[i + j].length();\n        }\n        \n        svint64_t len_vec = svld1_s64(active, lengths);\n        \n        // Find maximum length in vector\n        svint64_t max_len_vec = svmaxv_s64(pg, len_vec);\n        int64_t curr_max = svlastb_s64(pg, max_len_vec);\n        \n        // Update global maximum if necessary\n        if (curr_max > max_len) {\n            max_len = curr_max;\n            \n            // Find index of first maximum in current vector\n            svbool_t max_mask = sveq_s64(pg, len_vec, svdup_s64(curr_max));\n            uint64_t first_max = svclzb_u64(max_mask);\n            max_idx = i + (first_max >> 3);\n        }\n    }\n\n    return strings[max_idx];\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::string longest_simd(const std::vector<std::string>& strings) {\n    if (strings.empty()) return \"\";\n\n    svbool_t pg = svptrue_b8();\n    uint64_t vlen = svcntb();\n    size_t max_len = 0;\n    size_t max_idx = 0;\n\n    for (size_t i = 0; i < strings.size(); i += vlen) {\n        size_t remaining = strings.size() - i;\n        uint64_t active_lanes = std::min(vlen, remaining);\n        svbool_t active_pg = svwhilelt_b8(i, i + active_lanes);\n\n        svuint64_t lens = svdup_u64(0);\n        for (size_t j = 0; j < active_lanes; ++j) {\n            if (i + j < strings.size()) {\n                lens = svinsr_n_u64(lens, strings[i + j].length(), j);\n            }\n        }\n\n        uint64_t local_max_len = svmaxv_u64(pg, lens);\n        if (local_max_len > max_len) {\n            max_len = local_max_len;\n            svbool_t max_mask = svcmpeq(pg, lens, local_max_len);\n            uint64_t first_max_idx = svcntp_b8(max_mask, svfind_first_set_b8(max_mask));\n            max_idx = i + first_max_idx;\n        }\n    }\n\n    return strings[max_idx];\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n\nstd::string longest_simd(const std::vector<std::string>& strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    svbool_t pg = svptrue_b8();\n    uint64_t vlen = svcntb();\n    size_t n = strings.size();\n    size_t max_len = 0;\n    size_t max_idx = 0;\n\n    // Process strings in chunks that fit into SVE vectors\n    for (size_t i = 0; i < n; i += vlen) {\n        size_t chunk_size = std::min(vlen, n - i);\n        svuint64_t len_vec = svdup_n_u64(0);\n        \n        // Create predicate for valid elements in current chunk\n        svbool_t chunk_pg = svwhilelt_b8(i, i + chunk_size);\n        \n        // Load string lengths into vector\n        for (size_t j = 0; j < chunk_size; ++j) {\n            uint64_t len = strings[i + j].length();\n            len_vec = svsel_u64(svwhilelt_b8(j, j + 1), svdup_n_u64(len), len_vec);\n        }\n\n        // Find maximum length in current chunk\n        uint64_t chunk_max = svmaxv_u64(pg, len_vec);\n\n        // Update global maximum if needed\n        if (chunk_max > max_len) {\n            max_len = chunk_max;\n            \n            // Find index of maximum length in chunk\n            svbool_t max_mask = svcmpeq_u64(chunk_pg, len_vec, chunk_max);\n            uint64_t first_max_idx = svcntp_b8(chunk_pg, max_mask);\n            \n            // Convert to actual index in strings vector\n            max_idx = i + first_max_idx - 1;\n        }\n    }\n\n    return strings[max_idx];\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n\nstd::string longest_simd(const std::vector<std::string>& strings) {\n    if (strings.empty()) return \"\";\n\n    svbool_t pg = svwhilelt_b64(0, strings.size());\n    svuint64_t max_len = svdup_u64(0);\n    svuint64_t max_idx = svdup_u64(0);\n    svuint64_t idx = svindex_u64(0, 1);\n\n    for (size_t i = 0; i < strings.size(); i += svcntd()) {\n        pg = svwhilelt_b64(i, strings.size());\n        svuint64_t lens = svdup_u64(0);\n\n        for (size_t j = 0; j < svcntd() && (i + j) < strings.size(); ++j) {\n            uint64_t len = strings[i + j].length();\n            lens = svsel_u64(svcmpeq_u64(pg, idx, svdup_u64(j)), svdup_u64(len), lens);\n        }\n\n        svbool_t cmp = svcmpgt_u64(pg, lens, max_len);\n        max_len = svsel_u64(cmp, lens, max_len);\n        max_idx = svsel_u64(cmp, svadd_u64_z(pg, idx, svdup_u64(i)), max_idx);\n    }\n\n    uint64_t final_idx = svlasta(svptrue_b64(), max_idx);\n    return strings[final_idx];\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    svbool_t pg = svptrue_b64();\n    svuint64_t va = svdup_u64(a);\n    svuint64_t vb = svdup_u64(b);\n    \n    while (svptest_any(pg, svcmpne_u64(pg, vb, 0))) {\n        svuint64_t t = vb;\n        vb = svsel_u64(svcmpgt_u64(pg, va, vb), svmod_u64(pg, va, vb), vb);\n        va = svsel_u64(svcmpgt_u64(pg, va, vb), va, t);\n    }\n    \n    return svlastb_u64(pg, va);\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    svbool_t pg = svptrue_b64();\n    svuint64_t va = svdup_u64(a);\n    svuint64_t vb = svdup_u64(b);\n    \n    while (svptest_any(pg, svcmpne(pg, vb, 0))) {\n        svuint64_t t = vb;\n        vb = svand_u64_z(pg, va, vb);\n        va = svsub_u64_z(pg, va, svmul_u64_z(pg, vb, svdiv_u64_z(pg, va, vb)));\n        svbool_t zero_mask = svcmpeq(pg, vb, 0);\n        vb = svsel_u64(zero_mask, t, vb);\n    }\n    \n    return svlasta_u64(pg, va);\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    svbool_t pg = svptrue_b64();\n    svuint64_t va = svdup_u64(a);\n    svuint64_t vb = svdup_u64(b);\n    \n    while (svptest_any(pg, svcmpne_u64(pg, vb, 0))) {\n        svuint64_t t = vb;\n        vb = svsel_u64(svcmpgt_u64(pg, va, vb), svmod_u64(pg, va, vb), vb);\n        va = svsel_u64(svcmpgt_u64(pg, va, vb), va, t);\n    }\n    \n    return svlasta_u64(pg, va);\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    svbool_t pg = svptrue_b64();\n    svuint64_t va = svdup_u64(a);\n    svuint64_t vb = svdup_u64(b);\n    \n    while (svptest_any(pg, svcmpne(pg, vb, 0))) {\n        svuint64_t t = vb;\n        vb = svsel_u64(svcmplt(pg, va, vb), svmod_u64(pg, va, vb), vb);\n        va = svsel_u64(svcmplt(pg, va, vb), va, t);\n    }\n    \n    return svmaxv_u64(pg, va);\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    svbool_t pg = svptrue_b64();\n    svuint64_t va = svdup_u64(a);\n    svuint64_t vb = svdup_u64(b);\n    \n    while (svptest_any(pg, svcmpne_u64(pg, vb, 0))) {\n        svuint64_t t = vb;\n        vb = svsel_u64(svcmpgt_u64(pg, va, vb), \n                       svsub_u64_x(pg, va, svmul_u64_x(pg, svdiv_u64_z(pg, va, vb), vb)),\n                       vb);\n        va = svsel_u64(svcmple_u64(pg, va, vb), va, t);\n    }\n    \n    return svlasta_u64(pg, va);\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    float first = 0.0f, second = 0.0f;\n\n    svfloat32_t min_diff_vec = svdup_f32(min_diff);\n    svfloat32_t first_vec = svdup_f32(0.0f);\n    svfloat32_t second_vec = svdup_f32(0.0f);\n\n    for (size_t i = 0; i < n; i++) {\n        svfloat32_t a = svdup_f32(numbers[i]);\n        svbool_t pg = svwhilelt_b32(i + 1, n);\n        svfloat32_t b = svld1_f32(pg, &numbers[i + 1]);\n\n        svfloat32_t diff = svabs_f32_z(pg, svsub_f32_z(pg, a, b));\n        svbool_t cmp = svcmplt_f32(pg, diff, min_diff_vec);\n\n        min_diff_vec = svsel_f32(cmp, svmin_f32_z(pg, diff, min_diff_vec), min_diff_vec);\n\n        svfloat32_t min_a = svsel_f32(cmp, a, first_vec);\n        svfloat32_t max_b = svsel_f32(cmp, b, second_vec);\n\n        svfloat32_t ordered_first = svmin_f32_z(pg, min_a, max_b);\n        svfloat32_t ordered_second = svmax_f32_z(pg, min_a, max_b);\n\n        first_vec = svsel_f32(cmp, ordered_first, first_vec);\n        second_vec = svsel_f32(cmp, ordered_second, second_vec);\n    }\n\n    svbool_t pg = svptrue_b32();\n    first = svlasta_f32(pg, first_vec);\n    second = svlasta_f32(pg, second_vec);\n\n    return {first, second};\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    float min_val = 0.0f, max_val = 0.0f;\n\n    svfloat32_t min_diff_vec = svdup_f32(min_diff);\n    svfloat32_t min_val_vec = svdup_f32(0.0f);\n    svfloat32_t max_val_vec = svdup_f32(0.0f);\n    svbool_t pg = svwhilelt_b32(0, n);\n\n    for (size_t i = 0; i < n - 1; i++) {\n        svfloat32_t a = svdup_f32(numbers[i]);\n        size_t j = i + 1;\n\n        while (j < n) {\n            svbool_t active = svwhilelt_b32(j, n);\n            svfloat32_t b = svld1_f32(active, &numbers[j]);\n            svfloat32_t diff = svabs_f32_z(active, svsub_f32_z(active, a, b));\n            \n            svbool_t cmp = svcmplt_f32(active, diff, min_diff_vec);\n            min_diff_vec = svsel_f32(cmp, diff, min_diff_vec);\n            min_val_vec = svsel_f32(cmp, svdup_f32(numbers[i]), min_val_vec);\n            max_val_vec = svsel_f32(cmp, b, max_val_vec);\n            \n            j += svcntw();\n        }\n    }\n\n    float final_min_diff = svminv_f32(pg, min_diff_vec);\n    float final_min_val = svminv_f32(pg, min_val_vec);\n    float final_max_val = svminv_f32(pg, max_val_vec);\n\n    return {std::min(final_min_val, final_max_val), std::max(final_min_val, final_max_val)};\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n < 2) return {};\n\n    float min_diff = std::numeric_limits<float>::max();\n    float min_val = 0.0f, max_val = 0.0f;\n    \n    svfloat32_t v_min_diff = svdup_f32(min_diff);\n    svfloat32_t v_min_val = svdup_f32(0.0f);\n    svfloat32_t v_max_val = svdup_f32(0.0f);\n    \n    size_t i = 0;\n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svfloat32_t v_nums = svld1_f32(pg, &numbers[i]);\n        \n        for (size_t j = i + 1; j < n; j += svcntw()) {\n            svbool_t pg_j = svwhilelt_b32(j, n);\n            svfloat32_t v_nums_j = svld1_f32(pg_j, &numbers[j]);\n            \n            svfloat32_t v_diff = svabs_f32_x(pg, svsub_f32_x(pg, v_nums, v_nums_j));\n            \n            svbool_t cmp = svcmplt_f32(pg, v_diff, v_min_diff);\n            v_min_diff = svmin_f32_m(cmp, v_diff, v_min_diff);\n            \n            svfloat32_t v_smaller = svmin_f32_x(pg, v_nums, v_nums_j);\n            svfloat32_t v_larger = svmax_f32_x(pg, v_nums, v_nums_j);\n            \n            v_min_val = svsel_f32(cmp, v_smaller, v_min_val);\n            v_max_val = svsel_f32(cmp, v_larger, v_max_val);\n        }\n        \n        i += svcntw();\n    }\n    \n    min_diff = svminv_f32(svptrue_b32(), v_min_diff);\n    min_val = svminv_f32(svptrue_b32(), v_min_val);\n    max_val = svmaxv_f32(svptrue_b32(), v_max_val);\n    \n    return {min_val, max_val};\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    float min_val1 = 0.0f, min_val2 = 0.0f;\n\n    svfloat32_t min_diff_vec = svdup_f32(min_diff);\n    svfloat32_t min_val1_vec = svdup_f32(0.0f);\n    svfloat32_t min_val2_vec = svdup_f32(0.0f);\n\n    size_t vl = svcntw();\n    svbool_t pg = svwhilelt_b32(0, n);\n\n    for (size_t i = 0; i < n; i++) {\n        svfloat32_t val_i = svdup_f32(numbers[i]);\n        svfloat32_t indices = svindex_f32(0, 1);\n        svbool_t pg_inner = svwhilelt_b32(0, n - i - 1);\n\n        size_t j = i + 1;\n        while (j < n) {\n            svfloat32_t val_j = svld1_f32(pg_inner, &numbers[j]);\n            svfloat32_t diff = svabs_f32_x(pg_inner, svsub_f32_x(pg_inner, val_i, val_j));\n\n            svbool_t cmp = svcmplt_f32(pg_inner, diff, min_diff_vec);\n            min_diff_vec = svsel_f32(cmp, diff, min_diff_vec);\n            min_val1_vec = svsel_f32(cmp, val_i, min_val1_vec);\n            min_val2_vec = svsel_f32(cmp, val_j, min_val2_vec);\n\n            j += vl;\n            pg_inner = svwhilelt_b32(j, n);\n        }\n    }\n\n    min_diff = svminv_f32(svptrue_b32(), min_diff_vec);\n    min_val1 = svminv_f32(svptrue_b32(), min_val1_vec);\n    min_val2 = svminv_f32(svptrue_b32(), min_val2_vec);\n\n    if (min_val1 > min_val2) {\n        std::swap(min_val1, min_val2);\n    }\n\n    return {min_val1, min_val2};\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    float smaller = 0.0f, larger = 0.0f;\n    \n    // Ensure at least two elements\n    if (n < 2) {\n        return {0.0f, 0.0f};\n    }\n\n    // Process elements in vector-length chunks\n    svfloat32_t min_diff_vec = svdup_f32(min_diff);\n    svfloat32_t smaller_vec = svdup_f32(0.0f);\n    svfloat32_t larger_vec = svdup_f32(0.0f);\n    \n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, n);\n    \n    for (; i + svcntw() <= n; i += svcntw()) {\n        // Load vector of numbers\n        svfloat32_t vec = svld1_f32(pg, &numbers[i]);\n        \n        // Create shifted vector for comparison\n        svfloat32_t next_vec = svld1_f32(pg, &numbers[i + 1]);\n        \n        // Compute absolute differences\n        svfloat32_t diff = svabs_f32_x(pg, svsub_f32_x(pg, vec, next_vec));\n        \n        // Find minimum difference in this chunk\n        svfloat32_t local_min = svmin_f32_x(pg, diff, min_diff_vec);\n        \n        // Update global min if necessary\n        svbool_t update_mask = svcmplt_f32(pg, local_min, min_diff_vec);\n        min_diff_vec = svsel_f32(update_mask, local_min, min_diff_vec);\n        \n        // Update smaller and larger numbers\n        svfloat32_t local_smaller = svmin_f32_x(pg, vec, next_vec);\n        svfloat32_t local_larger = svmax_f32_x(pg, vec, next_vec);\n        \n        smaller_vec = svsel_f32(update_mask, local_smaller, smaller_vec);\n        larger_vec = svsel_f32(update_mask, local_larger, larger_vec);\n        \n        pg = svwhilelt_b32(i + svcntw(), n);\n    }\n    \n    // Handle remaining elements sequentially\n    for (; i < n - 1; i++) {\n        float diff = std::abs(numbers[i] - numbers[i + 1]);\n        if (diff < min_diff) {\n            min_diff = diff;\n            smaller = std::min(numbers[i], numbers[i + 1]);\n            larger = std::max(numbers[i], numbers[i + 1]);\n        }\n    }\n    \n    // Extract final results from vectors\n    float final_min_diff = svminv_f32(min_diff_vec, pg);\n    if (final_min_diff < min_diff) {\n        smaller = svminv_f32(smaller_vec, pg);\n        larger = svminv_f32(larger_vec, pg);\n    }\n    \n    return {smaller, larger};\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t len = numbers.size();\n    std::vector<float> result(len);\n    \n    // Find min and max using SVE\n    svfloat32_t min_vec = svdup_f32(numbers[0]);\n    svfloat32_t max_vec = svdup_f32(numbers[0]);\n    \n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, len);\n    \n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vec = svld1_f32(pg, &numbers[i]);\n        min_vec = svmin_f32_x(svptrue_b32(), min_vec, vec);\n        max_vec = svmax_f32_x(svptrue_b32(), max_vec, vec);\n        i += svcntw();\n        pg = svwhilelt_b32(i, len);\n    }\n    \n    float min_val = svminv_f32(svptrue_b32(), min_vec);\n    float max_val = svmaxv_f32(svptrue_b32(), max_vec);\n    float scale = (max_val != min_val) ? 1.0f / (max_val - min_val) : 0.0f;\n    \n    // Apply linear transform\n    svfloat32_t min_scalar = svdup_f32(min_val);\n    svfloat32_t scale_scalar = svdup_f32(scale);\n    \n    i = 0;\n    pg = svwhilelt_b32(i, len);\n    \n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vec = svld1_f32(pg, &numbers[i]);\n        svfloat32_t res = svmul_f32_x(pg, svsub_f32_x(pg, vec, min_scalar), scale_scalar);\n        svst1_f32(pg, &result[i], res);\n        i += svcntw();\n        pg = svwhilelt_b32(i, len);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t len = numbers.size();\n    std::vector<float> result(len);\n    \n    // Find min and max using SVE\n    svfloat32_t min_vec = svdup_f32(numbers[0]);\n    svfloat32_t max_vec = svdup_f32(numbers[0]);\n    svbool_t pg = svptrue_b32();\n    \n    size_t i = 0;\n    for (; i + svcntw() <= len; i += svcntw()) {\n        svfloat32_t vec = svld1_f32(pg, &numbers[i]);\n        min_vec = svmin_f32_x(pg, min_vec, vec);\n        max_vec = svmax_f32_x(pg, max_vec, vec);\n    }\n    \n    // Handle remaining elements\n    if (i < len) {\n        svbool_t mask = svwhilelt_b32(i, len);\n        svfloat32_t vec = svld1_f32(mask, &numbers[i]);\n        min_vec = svmin_f32_x(pg, min_vec, vec);\n        max_vec = svmax_f32_x(pg, max_vec, vec);\n    }\n    \n    float min_val = svminv_f32(pg, min_vec);\n    float max_val = svmaxv_f32(pg, max_vec);\n    float scale = 1.0f / (max_val - min_val);\n    \n    // Apply linear transform\n    svfloat32_t min = svdup_f32(min_val);\n    svfloat32_t s = svdup_f32(scale);\n    \n    for (i = 0; i + svcntw() <= len; i += svcntw()) {\n        svfloat32_t vec = svld1_f32(pg, &numbers[i]);\n        vec = svsub_f32_x(pg, vec, min);\n        vec = svmul_f32_x(pg, vec, s);\n        svst1_f32(pg, &result[i], vec);\n    }\n    \n    // Handle remaining elements\n    if (i < len) {\n        svbool_t mask = svwhilelt_b32(i, len);\n        svfloat32_t vec = svld1_f32(mask, &numbers[i]);\n        vec = svsub_f32_x(mask, vec, min);\n        vec = svmul_f32_x(mask, vec, s);\n        svst1_f32(mask, &result[i], vec);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t len = numbers.size();\n    std::vector<float> result(len);\n    \n    // Find min and max using SVE\n    svfloat32_t min_vec = svdup_f32(numbers[0]);\n    svfloat32_t max_vec = svdup_f32(numbers[0]);\n    \n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, len);\n    \n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vec = svld1_f32(pg, &numbers[i]);\n        min_vec = svmin_f32_x(svptrue_b32(), min_vec, vec);\n        max_vec = svmax_f32_x(svptrue_b32(), max_vec, vec);\n        i += svcntw();\n        pg = svwhilelt_b32(i, len);\n    }\n    \n    // Reduce to get final min and max\n    float min_val = svminv_f32(svptrue_b32(), min_vec);\n    float max_val = svmaxv_f32(svptrue_b32(), max_vec);\n    \n    // Compute scale factor\n    float scale = (max_val == min_val) ? 0.0f : 1.0f / (max_val - min_val);\n    svfloat32_t scale_vec = svdup_f32(scale);\n    svfloat32_t min_vec_bcast = svdup_f32(min_val);\n    \n    // Apply linear transform\n    i = 0;\n    pg = svwhilelt_b32(i, len);\n    \n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vec = svld1_f32(pg, &numbers[i]);\n        svfloat32_t res = svsub_f32_x(pg, vec, min_vec_bcast);\n        res = svmul_f32_x(pg, res, scale_vec);\n        svst1_f32(pg, &result[i], res);\n        i += svcntw();\n        pg = svwhilelt_b32(i, len);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t len = numbers.size();\n    std::vector<float> result(len);\n    \n    // Find min and max using SVE\n    svfloat32_t min_vec = svdup_f32(numbers[0]);\n    svfloat32_t max_vec = svdup_f32(numbers[0]);\n    \n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, len);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vec = svld1_f32(pg, &numbers[i]);\n        min_vec = svmin_f32_x(pg, min_vec, vec);\n        max_vec = svmax_f32_x(pg, max_vec, vec);\n        i += svcntw();\n        pg = svwhilelt_b32(i, len);\n    }\n    \n    // Reduce to get scalar min and max\n    float min_val = svminv_f32(svptrue_b32(), min_vec);\n    float max_val = svmaxv_f32(svptrue_b32(), max_vec);\n    float range = max_val - min_val;\n    \n    // Avoid division by zero\n    if (range == 0.0f) {\n        return std::vector<float>(len, 0.0f);\n    }\n    \n    // Apply linear transform: (x - min) / (max - min)\n    svfloat32_t min_broadcast = svdup_f32(min_val);\n    svfloat32_t range_broadcast = svdup_f32(range);\n    \n    i = 0;\n    pg = svwhilelt_b32(i, len);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vec = svld1_f32(pg, &numbers[i]);\n        svfloat32_t scaled = svsub_f32_x(pg, vec, min_broadcast);\n        scaled = svdiv_f32_x(pg, scaled, range_broadcast);\n        svst1_f32(pg, &result[i], scaled);\n        i += svcntw();\n        pg = svwhilelt_b32(i, len);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t len = numbers.size();\n    std::vector<float> result(len);\n    \n    // Find min and max using SVE\n    svfloat32_t min_vec = svdup_f32(numbers[0]);\n    svfloat32_t max_vec = svdup_f32(numbers[0]);\n    svbool_t pg = svwhilelt_b32(0, len);\n    \n    for (size_t i = 0; i < len; i += svcntw()) {\n        svbool_t p = svwhilelt_b32(i, len);\n        svfloat32_t vec = svld1_f32(p, &numbers[i]);\n        min_vec = svmin_f32_m(p, min_vec, vec);\n        max_vec = svmax_f32_m(p, max_vec, vec);\n    }\n    \n    float min_val = svminv_f32(pg, min_vec);\n    float max_val = svmaxv_f32(pg, max_vec);\n    float scale = 1.0f / (max_val - min_val);\n    \n    // Apply linear transform using SVE\n    svfloat32_t min = svdup_f32(min_val);\n    svfloat32_t s = svdup_f32(scale);\n    \n    for (size_t i = 0; i < len; i += svcntw()) {\n        svbool_t p = svwhilelt_b32(i, len);\n        svfloat32_t vec = svld1_f32(p, &numbers[i]);\n        svfloat32_t res = svmul_f32_m(p, svsub_f32_m(p, vec, min), s);\n        svst1_f32(p, &result[i], res);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    svbool_t pg = svptrue_b64();\n    uint64_t max_div = 1;\n    svuint64_t divisors = svindex_u64(1, 1);\n    svuint64_t n_vec = svdup_u64(n);\n    \n    for (uint64_t i = 1; i <= n / 2; i += svcntd()) {\n        svbool_t mask = svcmplt_u64(pg, divisors, n_vec);\n        svuint64_t quotients = svdiv_u64_z(pg, n_vec, divisors);\n        svuint64_t products = svmul_u64_z(pg, quotients, divisors);\n        svbool_t is_divisor = svcmpeq_u64(pg, products, n_vec);\n        \n        svuint64_t valid_divisors = svsel_u64(is_divisor, divisors, svdup_u64(0));\n        max_div = svmaxv_u64(pg, svmax_u64_z(pg, valid_divisors, svdup_u64(max_div)));\n        \n        divisors = svadd_u64_z(pg, divisors, svdup_u64(svcntd()));\n    }\n    \n    return max_div;\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    uint64_t max_divisor = 1;\n    svbool_t pg = svwhilelt_b64(1, n);\n    svuint64_t vec_n = svdup_u64(n);\n    svuint64_t vec_i = svindex_u64(1, 1);\n    svuint64_t vec_ones = svdup_u64(1);\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svbool_t div_mask = svcmpeq_u64(pg, svmod_u64(vec_n, vec_i), svdup_u64(0));\n        svuint64_t divisors = svsel_u64(div_mask, vec_i, vec_ones);\n        max_divisor = svmaxv_u64(pg, svmax_u64(pg, divisors, svdup_u64(max_divisor)));\n        vec_i = svadd_u64_z(pg, vec_i, vec_ones);\n        pg = svwhilelt_b64(svcntd(), n);\n    }\n\n    return max_divisor;\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    svbool_t pg = svptrue_b64();\n    uint64_t max_div = 1;\n    svuint64_t vec_n = svdup_u64(n);\n    svuint64_t vec_i = svindex_u64(2, 1);\n    svuint64_t vec_max_div = svdup_u64(1);\n    \n    while (svptest_any(pg, svwhilele_b64(2, n/2))) {\n        svbool_t div_mask = svcmpeq_u64(pg, svmul_u64(pg, svdiv_u64(pg, vec_n, vec_i), vec_i), vec_n);\n        vec_max_div = svsel_u64(div_mask, vec_i, vec_max_div);\n        vec_i = svadd_u64_x(pg, vec_i, svdup_u64(1));\n    }\n    \n    max_div = svmaxv_u64(pg, vec_max_div);\n    return max_div;\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    uint64_t max_div = 1;\n    svbool_t pg = svwhilelt_b64(2, n);\n    svuint64_t vec_n = svdup_u64(n);\n    svuint64_t vec_i = svindex_u64(2, 1);\n    \n    while (svptest_any(svptrue_b64(), pg)) {\n        svuint64_t quot = svdiv_u64_z(pg, vec_n, vec_i);\n        svbool_t is_divisible = svcmpeq_u64(pg, svmul_u64_z(pg, quot, vec_i), vec_n);\n        \n        svuint64_t candidates = svsel_u64(is_divisible, vec_i, svdup_u64(1));\n        max_div = svmaxv_u64(svptrue_b64(), svmax_u64_z(pg, candidates, svdup_u64(max_div)));\n        \n        vec_i = svadd_u64_z(pg, vec_i, svdup_u64(1));\n        pg = svwhilelt_b64(svlow_u64(vec_i), n);\n    }\n    \n    return max_div;\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    svbool_t pg = svptrue_b64();\n    uint64_t max_divisor = 1;\n    \n    // Create vector with input n\n    svuint64_t vec_n = svdup_u64(n);\n    \n    // Create vector of potential divisors from 2 to n-1\n    uint64_t max_possible_divisor = n - 1;\n    svuint64_t divisors = svindex_u64(2, 1);\n    \n    // Create predicate for divisors <= n-1\n    svbool_t pred = svwhilele_b64(2, max_possible_divisor);\n    \n    while (svptest_any(svptrue_b64(), pred)) {\n        // Calculate remainders\n        svuint64_t remainders = svmod_u64_z(pred, vec_n, divisors);\n        \n        // Find where remainder is 0 (perfect divisors)\n        svbool_t is_divisor = svcmpeq_u64(pred, remainders, svdup_u64(0));\n        \n        // Update max_divisor with largest valid divisor\n        svuint64_t current_divisors = svsel_u64(is_divisor, divisors, svdup_u64(0));\n        max_divisor = svmaxv_u64(pg, svmax_u64_z(pg, current_divisors, svdup_u64(max_divisor)));\n        \n        // Increment divisors\n        divisors = svadd_u64_z(pg, divisors, svdup_u64(svcntd()));\n        \n        // Update predicate\n        pred = svwhilele_b64(svlastb_u64(pg, divisors), max_possible_divisor);\n    }\n    \n    return max_divisor;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n <= 1) return factors;\n\n    // Maximum possible factors for 32-bit int is log2(n) + 1\n    int max_factors = 32;\n    std::vector<int> temp_factors(max_factors);\n    int factor_count = 0;\n\n    // Handle factor 2 separately to simplify vectorization\n    while (n % 2 == 0) {\n        temp_factors[factor_count++] = 2;\n        n /= 2;\n    }\n\n    // Vectorized factorization for odd numbers\n    svbool_t pg = svptrue_b32();\n    svint32_t divisors = svindex_s32(3, 2); // Start from 3, increment by 2\n    svint32_t n_vec = svdup_s32(n);\n\n    while (svcntw() <= max_factors) {\n        svbool_t div_mask = svcmpeq_s32(pg, svmod_s32(n_vec, divisors), svdup_s32(0));\n        if (!svptest_any(pg, div_mask)) {\n            // No divisors found in this batch, increment divisors\n            divisors = svadd_s32_x(pg, divisors, svdup_s32(svcntw() * 2));\n            continue;\n        }\n\n        // Process divisors that divide n\n        while (svptest_any(pg, div_mask)) {\n            int32_t div_array[svcntw()];\n            svst1_s32(pg, div_array, divisors);\n            \n            for (int i = 0; i < svcntw(); i++) {\n                if (svclastb_s32(svptrue_b32(), 0, svdup_s32(i)) && div_array[i] * div_array[i] <= n) {\n                    while (n % div_array[i] == 0) {\n                        temp_factors[factor_count++] = div_array[i];\n                        n /= div_array[i];\n                    }\n                }\n            }\n\n            // Update n_vec and divisors\n            n_vec = svdup_s32(n);\n            divisors = svadd_s32_x(pg, divisors, svdup_s32(svcntw() * 2));\n            div_mask = svcmpeq_s32(pg, svmod_s32(n_vec, divisors), svdup_s32(0));\n        }\n\n        if (n == 1) break;\n    }\n\n    // Handle remaining prime factor\n    if (n > 1) {\n        temp_factors[factor_count++] = n;\n    }\n\n    // Copy to result vector\n    factors.resize(factor_count);\n    for (int i = 0; i < factor_count; i++) {\n        factors[i] = temp_factors[i];\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n <= 1) return factors;\n\n    // Maximum possible factors for 32-bit int is log2(n) + 1\n    const int max_factors = 32;\n    int32_t candidates[max_factors];\n    int count = 0;\n\n    // Initialize candidates with potential factors starting from 2\n    for (int i = 0; i < max_factors; i++) {\n        candidates[i] = i + 2;\n    }\n\n    // Create SVE vector for candidates\n    svint32_t v_candidates = svld1_s32(svptrue_b32(), candidates);\n    svbool_t pg = svptrue_b32();\n\n    int current_n = n;\n    while (current_n > 1) {\n        // Create vector with current_n\n        svint32_t v_n = svdup_s32(current_n);\n        \n        // Compute remainders: n % candidates\n        svint32_t v_rem = svmod_n_s32_x(pg, v_n, v_candidates);\n        \n        // Find candidates where remainder is 0 (potential factors)\n        svbool_t is_factor = svcmpeq_n_s32(pg, v_rem, 0);\n        \n        // Get smallest factor\n        int32_t min_factor = 0;\n        int found = 0;\n        while (svptest_any(pg, is_factor)) {\n            int32_t candidate = svminv_s32_x(pg, svsel_s32(is_factor, v_candidates, svdup_s32(INT32_MAX)));\n            svbool_t is_min_factor = svcmpeq_n_s32(pg, v_candidates, candidate);\n            \n            if (svptest_any(pg, is_min_factor)) {\n                min_factor = candidate;\n                found = 1;\n                break;\n            }\n            // Mask out this candidate to find next smallest\n            is_factor = svbic_b_z(pg, is_factor, is_min_factor);\n        }\n\n        if (found) {\n            factors.push_back(min_factor);\n            current_n /= min_factor;\n            \n            // Update candidates: remove factors <= min_factor\n            svbool_t keep = svcmpgt_n_s32(pg, v_candidates, min_factor);\n            v_candidates = svsel_s32(keep, v_candidates, svdup_s32(min_factor + 1));\n        } else {\n            // No factors found, n is prime\n            if (current_n > 1) {\n                factors.push_back(current_n);\n            }\n            break;\n        }\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n <= 1) return factors;\n\n    // Estimate max factors to size vector\n    int max_factors = 32; // Reasonable upper bound for 32-bit int\n    svbool_t pg = svwhilelt_b32(0, max_factors);\n    \n    // Initialize vectors\n    svint32_t vec_n = svdup_s32(n);\n    svint32_t vec_div = svindex_s32(2, 1); // Start from 2\n    svint32_t vec_factors = svdup_s32(0);\n    svint32_t vec_count = svdup_s32(0);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Check divisibility\n        svbool_t div_mask = svcmpeq_s32(pg, svmod_s32(vec_n, vec_div), svdup_s32(0));\n        \n        // Process divisors\n        while (svptest_any(svptrue_b32(), div_mask)) {\n            svint32_t quotient = svdiv_s32_z(div_mask, vec_n, vec_div);\n            svint32_t is_valid = svcmpeq_s32(div_mask, svmul_s32_z(div_mask, quotient, vec_div), vec_n);\n            \n            // Store factors where valid\n            svbool_t store_mask = svand_b_z(svptrue_b32(), div_mask, svcmpeq_s32(svptrue_b32(), is_valid, svdup_s32(1)));\n            svst1_s32(store_mask, &vec_factors[svcntw()], vec_div);\n            \n            // Update n and count\n            vec_n = svsel_s32(store_mask, quotient, vec_n);\n            vec_count = svadd_s32_z(store_mask, vec_count, svdup_s32(1));\n            \n            // Recheck divisibility\n            div_mask = svcmpeq_s32(pg, svmod_s32(vec_n, vec_div), svdup_s32(0));\n        }\n        \n        // Move to next divisor\n        vec_div = svadd_s32_z(pg, vec_div, svdup_s32(1));\n        \n        // Update predicate for remaining numbers\n        pg = svcmplt_s32(svptrue_b32(), vec_n, svdup_s32(1));\n    }\n\n    // Collect results\n    int32_t temp_factors[max_factors];\n    svst1_s32(svptrue_b32(), temp_factors, vec_factors);\n    \n    // Extract valid factors\n    for (int i = 0; i < max_factors; i++) {\n        if (temp_factors[i] != 0) {\n            factors.push_back(temp_factors[i]);\n        }\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n <= 1) return factors;\n\n    // Maximum possible factors for 32-bit int\n    const int max_factors = 32;\n    int32_t factor_array[max_factors];\n    int factor_count = 0;\n\n    // Initialize SVE vectors\n    svbool_t pg = svwhilelt_b32(0, max_factors);\n    svint32_t v_factors = svdup_s32(0);\n    svint32_t v_n = svdup_s32(n);\n    svint32_t v_divisor = svdup_s32(2);\n    svint32_t v_one = svdup_s32(1);\n    svint32_t v_two = svdup_s32(2);\n\n    while (n > 1) {\n        // Check if divisor divides n\n        svbool_t div_mask = svcmpeq_s32(pg, svmod_s32(v_n, v_divisor), svdup_s32(0));\n        \n        // If divisible, add to factors and divide n\n        if (svptest_any(pg, div_mask)) {\n            if (factor_count < max_factors) {\n                factor_array[factor_count++] = svlastb_s32(pg, v_divisor);\n                n /= svlastb_s32(pg, v_divisor);\n                v_n = svdup_s32(n);\n            } else {\n                break;\n            }\n        } else {\n            // Increment divisor (try next number)\n            v_divisor = svadd_s32_z(pg, v_divisor, v_one);\n            \n            // If divisor is odd, increment by 2\n            svbool_t is_odd = svcmpeq_s32(pg, svmod_s32(v_divisor, v_two), v_one);\n            if (svptest_any(pg, is_odd)) {\n                v_divisor = svadd_s32_z(pg, v_divisor, v_one);\n            }\n        }\n\n        // Stop if divisor exceeds square root of n\n        svbool_t stop_mask = svcmpgt_s32(pg, svmul_s32_z(pg, v_divisor, v_divisor), v_n);\n        if (svptest_any(pg, stop_mask)) {\n            if (n > 1 && factor_count < max_factors) {\n                factor_array[factor_count++] = n;\n            }\n            break;\n        }\n    }\n\n    // Copy factors to output vector\n    factors.assign(factor_array, factor_array + factor_count);\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n <= 1) return factors;\n\n    // Maximum possible factors for 32-bit int is log2(n) + 1\n    const int max_factors = 32;\n    int32_t temp[max_factors];\n    int count = 0;\n\n    // Initialize vector for divisors\n    svbool_t pg = svptrue_b32();\n    svint32_t divisors = svindex_s32(2, 1);\n    svint32_t n_vec = svdup_s32(n);\n\n    // Handle factor 2 separately to optimize for odd numbers\n    while (n % 2 == 0) {\n        temp[count++] = 2;\n        n /= 2;\n    }\n    n_vec = svdup_s32(n);\n\n    // Create vector for checking divisors up to sqrt(n)\n    int sqrt_n = (int)sqrt(n);\n    svint32_t max_div = svdup_s32(sqrt_n);\n\n    // Main factorization loop using SVE\n    while (svcmple_s32(pg, divisors, max_div)) {\n        // Check if divisors divide n evenly\n        svint32_t remainder = svmod_s32_z(pg, n_vec, divisors);\n        svbool_t is_divisor = svcmpeq_s32(pg, remainder, svdup_s32(0));\n\n        // Process divisors that evenly divide n\n        if (svptest_any(pg, is_divisor)) {\n            int32_t div_array[max_factors];\n            svst1_s32(pg, div_array, divisors);\n\n            // Check each lane where divisor was valid\n            for (int i = 0; i < svcntw() && div_array[i] <= sqrt_n; i++) {\n                if (div_array[i] > n) break;\n                if (n % div_array[i] == 0) {\n                    do {\n                        temp[count++] = div_array[i];\n                        n /= div_array[i];\n                    } while (n % div_array[i] == 0);\n                    n_vec = svdup_s32(n);\n                    sqrt_n = (int)sqrt(n);\n                    max_div = svdup_s32(sqrt_n);\n                }\n            }\n        }\n        // Increment divisors\n        divisors = svadd_s32_z(pg, divisors, svdup_s32(1));\n    }\n\n    // If n > 1, it's a prime factor itself\n    if (n > 1) {\n        temp[count++] = n;\n    }\n\n    // Copy results to output vector\n    factors.assign(temp, temp + count);\n    return factors;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    result.reserve(l.size());\n\n    svbool_t pg = svwhilelt_b32(0, l.size());\n    const float *base = l.data();\n    size_t i = 0;\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vec = svld1_f32(pg, base + i);\n        svbool_t mask = svcmpgt_f32(pg, vec, svdup_f32(0.0f));\n        \n        float temp[svcntw()];\n        svst1_f32(pg, temp, svsel_f32(mask, vec, svdup_f32(0.0f)));\n        \n        for (int j = 0; j < svcntw() && (i + j) < l.size(); j++) {\n            if (temp[j] > 0.0f) {\n                result.push_back(temp[j]);\n            }\n        }\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, l.size());\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    result.reserve(l.size());\n\n    svfloat32_t zero = svdup_f32(0.0f);\n    size_t i = 0;\n    size_t vec_len = svcntw();\n\n    for (; i + vec_len <= l.size(); i += vec_len) {\n        svfloat32_t vec = svld1_f32(svptrue_b32(), &l[i]);\n        svbool_t pg = svptrue_b32();\n        svbool_t mask = svcmpgt_f32(pg, vec, zero);\n        \n        float temp[vec_len];\n        svst1_f32(mask, temp, vec);\n        \n        for (size_t j = 0; j < vec_len; j++) {\n            if (svptest_any(svptrue_b32(), mask)) {\n                if (temp[j] > 0.0f) {\n                    result.push_back(temp[j]);\n                }\n            }\n        }\n    }\n\n    for (; i < l.size(); i++) {\n        if (l[i] > 0.0f) {\n            result.push_back(l[i]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    result.reserve(l.size());\n\n    svbool_t pg = svwhilelt_b32(0, l.size());\n    const float *base = l.data();\n    size_t i = 0;\n\n    while (i < l.size()) {\n        svfloat32_t vec = svld1_f32(pg, base + i);\n        svbool_t mask = svcmpgt_f32(pg, vec, svdup_f32(0.0f));\n        \n        float temp[svcntw()];\n        svst1_f32(mask, temp, vec);\n        \n        uint64_t active_lanes = svcntp_b32(mask);\n        for (uint64_t j = 0; j < active_lanes; j++) {\n            if (temp[j] > 0.0f) {\n                result.push_back(temp[j]);\n            }\n        }\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, l.size());\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float>& l) {\n    std::vector<float> result;\n    result.reserve(l.size());\n\n    size_t i = 0;\n    const float* data = l.data();\n    size_t len = l.size();\n    \n    while (i < len) {\n        svbool_t pg = svwhilelt_b32(i, len);\n        svfloat32_t vec = svld1_f32(pg, &data[i]);\n        \n        // Create mask for positive numbers (x > 0)\n        svbool_t pos_mask = svcmpgt_f32(pg, vec, svdup_f32(0.0f));\n        \n        // Store positive numbers using compress\n        svfloat32_t pos_vec = svcompact_f32(pos_mask, vec);\n        \n        // Get number of active elements\n        uint64_t count = svcntp_b32(pg, pos_mask);\n        \n        // Store results to temporary array\n        float temp[svcnt_f32()];\n        svst1_f32(svptrue_b32(), temp, pos_vec);\n        \n        // Copy to result vector\n        for (uint64_t j = 0; j < count; j++) {\n            result.push_back(temp[j]);\n        }\n        \n        i += svcnt_f32();\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    result.reserve(l.size());\n\n    svbool_t pg = svwhilelt_b32(0, (int32_t)l.size());\n    const float *base = l.data();\n    size_t i = 0;\n\n    while (svcntw() * i < l.size()) {\n        svfloat32_t vec = svld1_f32(pg, base + i);\n        svbool_t mask = svcmpgt_f32(pg, vec, svdup_f32(0.0f));\n        \n        float temp[svcntw()];\n        svst1_f32(pg, temp, vec);\n        \n        for (int j = 0; j < svcntw() && (i + j) < l.size(); j++) {\n            if (svptest_nz(pg, mask)[j]) {\n                result.push_back(temp[j]);\n            }\n        }\n        \n        i += svcntw();\n        pg = svwhilelt_b32((int32_t)i, (int32_t)l.size());\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n\n    int64_t sqrt_n = (int64_t)sqrt(n);\n    svbool_t pg = svwhilelt_b64(3, sqrt_n + 1);\n    svint64_t vec_n = svdup_s64(n);\n    svbool_t result = svptrue_b64();\n    \n    for (int64_t i = 3; i <= sqrt_n; i += svcntd() * 2) {\n        svint64_t vec_i = svindex_s64(i, 2);\n        svint64_t vec_mod = svmod_s64_z(pg, vec_n, vec_i);\n        svbool_t is_divisible = svcmpeq_s64(pg, vec_mod, 0);\n        result = svand_b_z(svptrue_b64(), result, svnot_b_z(pg, is_divisible));\n        \n        pg = svwhilelt_b64(i + svcntd() * 2, sqrt_n + 1);\n        if (!svptest_any(svptrue_b64(), pg)) break;\n    }\n    \n    return svptest_last(svptrue_b64(), result);\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n\n    int64_t sqrt_n = (int64_t)sqrt((double)n);\n    svbool_t pg = svwhilelt_b64(3, sqrt_n + 1);\n    svint64_t vec_n = svdup_s64(n);\n    svint64_t vec_i = svindex_s64(3, 2);\n    svbool_t result = svnot_b_z(pg, svfalse());\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svint64_t mod = svmod_s64_z(pg, vec_n, vec_i);\n        svbool_t is_divisible = svcmpeq_s64(pg, mod, 0);\n        result = svand_b_z(svptrue_b64(), result, svnot_b_z(pg, is_divisible));\n        vec_i = svadd_s64_z(pg, vec_i, svdup_s64(svlen_s64(vec_i) * 2));\n        pg = svwhilelt_b64(svminv_s64(vec_i), sqrt_n + 1);\n    }\n\n    return svptest_any(svptrue_b64(), result);\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n\n    int64_t sqrt_n = (int64_t)sqrt((double)n);\n    svbool_t pg = svwhilelt_b64(3, sqrt_n + 1);\n    svint64_t vec_n = svdup_s64(n);\n    svbool_t result = svptrue_b64();\n\n    for (int64_t i = 3; i <= sqrt_n; i += svcntd() * 2) {\n        svint64_t vec_i = svindex_s64(i, 2);\n        svint64_t vec_mod = svmod_s64_z(pg, vec_n, vec_i);\n        svbool_t is_divisible = svcmpeq_s64(pg, vec_mod, 0);\n        result = svand_b_z(svptrue_b64(), result, svnot_b_z(pg, is_divisible));\n        if (!svptest_any(svptrue_b64(), result)) return false;\n        pg = svwhilelt_b64(i + svcntd() * 2, sqrt_n + 1);\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t sqrt_n = (int64_t)sqrt(n);\n    uint64_t vl = svcntd(); // Get vector length for 64-bit elements\n    svbool_t pg = svwhilelt_b64(0, vl); // Predicate for active lanes\n\n    int64_t step = 6;\n    svint64_t vec_i = svindex_s64(5, step); // Start from 5, step by 6\n    svint64_t vec_i_plus_2 = svadd_n_s64_x(pg, vec_i, 2); // Check i+2 alongside i\n\n    while (1) {\n        svbool_t cond_i = svcmple_s64(pg, vec_i, sqrt_n);\n        svbool_t cond_i2 = svcmple_s64(pg, vec_i_plus_2, sqrt_n);\n        svbool_t active = svorr_b_z(pg, cond_i, cond_i2);\n\n        if (!svptest_any(pg, active)) {\n            break;\n        }\n\n        // Check divisibility for i\n        svint64_t remainder_i = svmod_n_s64_z(active, n, vec_i);\n        svbool_t div_i = svcmpeq_s64(active, remainder_i, 0);\n\n        // Check divisibility for i+2\n        svint64_t remainder_i2 = svmod_n_s64_z(active, n, vec_i_plus_2);\n        svbool_t div_i2 = svcmpeq_s64(active, remainder_i2, 0);\n\n        // If any lane finds a divisor, return false\n        svbool_t div_any = svorr_b_z(active, div_i, div_i2);\n        if (svptest_any(active, div_any)) {\n            return false;\n        }\n\n        // Increment vector for next iteration\n        vec_i = svadd_n_s64_x(pg, vec_i, step * vl);\n        vec_i_plus_2 = svadd_n_s64_x(pg, vec_i, 2);\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n\n    int64_t sqrt_n = (int64_t)sqrt((double)n);\n    svbool_t pg = svwhilelt_b64(3, sqrt_n + 1);\n    svint64_t vec_n = svdup_s64(n);\n    svbool_t result = svptrue_b64();\n\n    for (int64_t i = 3; i <= sqrt_n; i += svcntd() * 2) {\n        svint64_t vec_i = svindex_s64(i, 2);\n        svint64_t vec_mod = svmod_s64_x(pg, vec_n, vec_i);\n        svbool_t is_divisible = svcmpeq_s64(pg, vec_mod, 0);\n        result = svand_b_z(svptrue_b64(), result, svnot_b_z(pg, is_divisible));\n\n        if (!svptest_any(svptrue_b64(), result)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string solve_simd(const std::string & s) {\n    std::string result = s;\n    size_t len = s.length();\n    size_t i = 0;\n\n    // Check if string contains any letters\n    svbool_t pg = svwhilelt_b8(i, len);\n    svuint8_t vec_input;\n    svbool_t is_letter = svpfalse();\n    \n    while (i < len) {\n        vec_input = svld1_u8(pg, (const uint8_t*)&s[i]);\n        svbool_t is_lower = svand_b_z(pg, svcmplt_u8(pg, vec_input, svdup_u8('z')), \n                                    svcmpge_u8(pg, vec_input, svdup_u8('a')));\n        svbool_t is_upper = svand_b_z(pg, svcmplt_u8(pg, vec_input, svdup_u8('Z')), \n                                    svcmpge_u8(pg, vec_input, svdup_u8('A')));\n        is_letter = svorr_b_z(pg, is_letter, svorr_b_z(pg, is_lower, is_upper));\n        i += svcntb();\n        pg = svwhilelt_b8(i, len);\n    }\n\n    // If no letters, reverse the string\n    if (!svptest_any(svptrue_b8(), is_letter)) {\n        return std::string(s.rbegin(), s.rend());\n    }\n\n    // Process case conversion using SVE\n    i = 0;\n    pg = svwhilelt_b8(i, len);\n    \n    while (i < len) {\n        vec_input = svld1_u8(pg, (const uint8_t*)&s[i]);\n        \n        // Identify lowercase and uppercase letters\n        svbool_t is_lower = svand_b_z(pg, svcmplt_u8(pg, vec_input, svdup_u8('z')), \n                                    svcmpge_u8(pg, vec_input, svdup_u8('a')));\n        svbool_t is_upper = svand_b_z(pg, svcmplt_u8(pg, vec_input, svdup_u8('Z')), \n                                    svcmpge_u8(pg, vec_input, svdup_u8('A')));\n        \n        // Convert lowercase to uppercase (subtract 32)\n        svuint8_t lower_to_upper = svsub_u8_z(is_lower, vec_input, svdup_u8(32));\n        \n        // Convert uppercase to lowercase (add 32)\n        svuint8_t upper_to_lower = svadd_u8_z(is_upper, vec_input, svdup_u8(32));\n        \n        // Keep non-letters unchanged\n        svbool_t is_not_letter = svnot_b_z(pg, svorr_b_z(pg, is_lower, is_upper));\n        svuint8_t unchanged = svsel_u8(is_not_letter, vec_input, svdup_u8(0));\n        \n        // Combine results\n        svuint8_t result_vec = svsel_u8(is_lower, lower_to_upper, \n                                      svsel_u8(is_upper, upper_to_lower, unchanged));\n        \n        // Store result\n        svst1_u8(pg, (uint8_t*)&result[i], result_vec);\n        \n        i += svcntb();\n        pg = svwhilelt_b8(i, len);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string solve_simd(const std::string & s) {\n    std::string result = s;\n    svbool_t pg = svwhilelt_b8(0, s.length());\n    svuint8_t vec, is_letter, is_lower, is_upper;\n    uint64_t len = s.length();\n    bool has_letters = false;\n\n    // Check for letters\n    for (uint64_t i = 0; i < len; i += svcntb()) {\n        pg = svwhilelt_b8(i, len);\n        vec = svld1_u8(pg, (uint8_t*)&s[i]);\n        is_lower = svcmplt_u8(pg, vec, svdup_u8('z'));\n        is_lower = svcmpge_u8(pg, vec, svdup_u8('a'), is_lower);\n        is_upper = svcmplt_u8(pg, vec, svdup_u8('Z'));\n        is_upper = svcmpge_u8(pg, vec, svdup_u8('A'), is_upper);\n        is_letter = svorr_z(pg, is_lower, is_upper);\n        if (svptest_any(pg, is_letter)) {\n            has_letters = true;\n            break;\n        }\n    }\n\n    if (!has_letters) {\n        // Reverse string if no letters\n        for (uint64_t i = 0; i < len / 2; ++i) {\n            std::swap(result[i], result[len - 1 - i]);\n        }\n        return result;\n    }\n\n    // Process case conversion\n    for (uint64_t i = 0; i < len; i += svcntb()) {\n        pg = svwhilelt_b8(i, len);\n        vec = svld1_u8(pg, (uint8_t*)&s[i]);\n\n        // Identify lowercase and uppercase letters\n        is_lower = svcmplt_u8(pg, vec, svdup_u8('z'));\n        is_lower = svcmpge_u8(pg, vec, svdup_u8('a'), is_lower);\n        is_upper = svcmplt_u8(pg, vec, svdup_u8('Z'));\n        is_upper = svcmpge_u8(pg, vec, svdup_u8('A'), is_upper);\n\n        // Convert lowercase to uppercase: subtract 32\n        svuint8_t to_upper = svsub_u8_z(pg, vec, svdup_u8(32));\n        // Convert uppercase to lowercase: add 32\n        svuint8_t to_lower = svadd_u8_z(pg, vec, svdup_u8(32));\n\n        // Select converted values based on case\n        svuint8_t result_vec = svsel_u8(is_lower, to_upper, vec);\n        result_vec = svsel_u8(is_upper, to_lower, result_vec);\n\n        // Store result\n        svst1_u8(pg, (uint8_t*)&result[i], result_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string solve_simd(const std::string & s) {\n    std::string result = s;\n    int len = s.length();\n    int has_letter = 0;\n    \n    // Check for letters using SVE\n    svbool_t pg = svwhilelt_b8(0, len);\n    svuint8_t vec_input;\n    svbool_t is_letter = svpfalse();\n    \n    for (int i = 0; i < len; i += svcntb()) {\n        pg = svwhilelt_b8(i, len);\n        vec_input = svld1_u8(pg, (uint8_t*)&s[i]);\n        \n        svbool_t is_lower = svand_b_z(svptrue_b8(),\n            svcmplt_u8(pg, vec_input, svdup_u8('z')),\n            svcmpge_u8(pg, vec_input, svdup_u8('a')));\n            \n        svbool_t is_upper = svand_b_z(svptrue_b8(),\n            svcmplt_u8(pg, vec_input, svdup_u8('Z')),\n            svcmpge_u8(pg, vec_input, svdup_u8('A')));\n            \n        is_letter = svorr_b_z(pg, is_letter, svorr_b_z(pg, is_lower, is_upper));\n        \n        // Case conversion: lower to upper (subtract 32), upper to lower (add 32)\n        svuint8_t case_change = svsel_u8(is_lower, svdup_u8(-32), svdup_u8(32));\n        svuint8_t converted = svadd_u8_x(pg, vec_input, case_change);\n        svuint8_t result_vec = svsel_u8(svorr_b_z(pg, is_lower, is_upper), converted, vec_input);\n        \n        svst1_u8(pg, (uint8_t*)&result[i], result_vec);\n    }\n    \n    // Check if any letter was found\n    has_letter = svptest_any(svptrue_b8(), is_letter);\n    \n    // If no letters, reverse the string\n    if (!has_letter) {\n        for (int i = 0; i < len / 2; i++) {\n            std::swap(result[i], result[len - 1 - i]);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string solve_simd(const std::string & s) {\n    std::string result = s;\n    svbool_t pg = svwhilelt_b8(0, s.length());\n    \n    // Check if string contains any letters\n    svbool_t letter_mask = svpfalse();\n    svuint8_t data = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.data()));\n    \n    svbool_t lower_mask = svcmplt_u8(pg, data, svdup_u8('z'));\n    lower_mask = svand_b_z(pg, lower_mask, svcmpge_u8(pg, data, svdup_u8('a')));\n    \n    svbool_t upper_mask = svcmplt_u8(pg, data, svdup_u8('Z'));\n    upper_mask = svand_b_z(pg, upper_mask, svcmpge_u8(pg, data, svdup_u8('A')));\n    \n    letter_mask = svorr_b_z(pg, lower_mask, upper_mask);\n    \n    // If no letters, reverse the string\n    if (!svptest_any(pg, letter_mask)) {\n        return std::string(s.rbegin(), s.rend());\n    }\n    \n    // Process case conversion\n    svuint8_t case_change = svdup_u8(32);\n    \n    // For lowercase to uppercase: subtract 32\n    svbool_t to_upper = lower_mask;\n    svuint8_t upper_result = svsub_u8_m(to_upper, data, case_change);\n    \n    // For uppercase to lowercase: add 32\n    svbool_t to_lower = upper_mask;\n    svuint8_t lower_result = svadd_u8_m(to_lower, data, case_change);\n    \n    // Combine results, keeping non-letters unchanged\n    svuint8_t final = data;\n    final = svsel_u8(to_upper, upper_result, final);\n    final = svsel_u8(to_lower, lower_result, final);\n    \n    // Store result\n    svst1_u8(pg, reinterpret_cast<uint8_t*>(result.data()), final);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string solve_simd(const std::string & s) {\n    std::string result = s;\n    svbool_t pg = svwhilelt_b8(0, s.length());\n    uint64_t len = s.length();\n    bool has_letter = false;\n\n    // Check for letters\n    for (uint64_t i = 0; i < len; i += svcntb()) {\n        svbool_t p = svwhilelt_b8(i, len);\n        svuint8_t vec = svld1_u8(p, (uint8_t*)&s[i]);\n        svbool_t is_lower = svcmplt_u8(p, vec, svdup_u8('z'));\n        svbool_t is_upper = svcmpgt_u8(p, vec, svdup_u8('A'));\n        svbool_t is_letter = svand_b_z(p, is_lower, is_upper);\n        has_letter |= svptest_any(p, is_letter);\n    }\n\n    if (!has_letter) {\n        // Reverse string if no letters\n        for (uint64_t i = 0; i < len / 2; ++i) {\n            std::swap(result[i], result[len - 1 - i]);\n        }\n        return result;\n    }\n\n    // Process case conversion in chunks\n    for (uint64_t i = 0; i < len; i += svcntb()) {\n        svbool_t p = svwhilelt_b8(i, len);\n        \n        // Load input chunk\n        svuint8_t vec = svld1_u8(p, (uint8_t*)&s[i]);\n        \n        // Identify letters\n        svbool_t is_lower = svcmple_u8(p, vec, svdup_u8('z'));\n        svbool_t is_upper = svcmpge_u8(p, vec, svdup_u8('A'));\n        svbool_t is_letter = svand_b_z(p, is_lower, is_upper);\n        \n        // Create masks for upper and lower case letters\n        svbool_t is_lower_letter = svand_b_z(p, is_letter, \n            svcmplt_u8(p, vec, svdup_u8('a')));\n        svbool_t is_upper_letter = svand_b_z(p, is_letter, \n            svcmpgt_u8(p, vec, svdup_u8('Z')));\n        \n        // Convert cases: lower->upper (subtract 32), upper->lower (add 32)\n        svuint8_t to_upper = svsub_u8_m(p, vec, svdup_u8(32));\n        svuint8_t to_lower = svadd_u8_m(p, vec, svdup_u8(32));\n        \n        // Select converted values where applicable\n        svuint8_t result_vec = svsel_u8(is_lower_letter, to_upper, vec);\n        result_vec = svsel_u8(is_upper_letter, to_lower, result_vec);\n        \n        // Store result\n        svst1_u8(p, (uint8_t*)&result[i], result_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t len = l.size();\n    std::vector<int> result = l;\n    std::vector<int> thirds;\n    \n    // Collect elements at indices divisible by 3\n    for (size_t i = 0; i < len; i += 3) {\n        if (i < len) thirds.push_back(l[i]);\n    }\n    \n    // Sort the collected elements\n    std::sort(thirds.begin(), thirds.end());\n    \n    // Vector length in elements (assuming int is 4 bytes)\n    svbool_t pg = svwhilelt_b32(0, len);\n    size_t vlen = svcntw();\n    \n    // Process vectorizable portion\n    size_t i = 0;\n    size_t third_idx = 0;\n    for (; i + vlen <= len; i += vlen) {\n        // Create predicate for indices divisible by 3\n        svbool_t div3_mask = svptrue_b32();\n        uint32_t indices[vlen];\n        for (size_t j = 0; j < vlen; j++) {\n            indices[j] = i + j;\n        }\n        svuint32_t idx_vec = svld1_u32(pg, indices);\n        svuint32_t three = svdup_u32(3);\n        svuint32_t mod = svmul_u32_z(pg, svdiv_u32_z(pg, idx_vec, three), three);\n        div3_mask = svcmpeq_u32(pg, mod, idx_vec);\n        \n        // Load input vector\n        svint32_t vec = svld1_s32(pg, &l[i]);\n        \n        // Create vector with sorted third elements\n        svint32_t third_vec = svdup_s32(thirds[third_idx]);\n        third_idx += svcntp_b32(pg, div3_mask);\n        \n        // Blend original and sorted values\n        svint32_t result_vec = svsel_s32(div3_mask, third_vec, vec);\n        \n        // Store result\n        svst1_s32(pg, &result[i], result_vec);\n    }\n    \n    // Handle remainder\n    for (; i < len; i++) {\n        if (i % 3 == 0 && third_idx < thirds.size()) {\n            result[i] = thirds[third_idx++];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t len = l.size();\n    std::vector<int> result = l;\n    std::vector<int> thirds;\n    \n    // Collect elements at indices divisible by 3\n    for (size_t i = 0; i < len; i += 3) {\n        if (i < len) thirds.push_back(l[i]);\n    }\n    \n    // Sort the collected elements\n    std::sort(thirds.begin(), thirds.end());\n    \n    // Calculate vector length for SVE\n    svbool_t pg = svwhilelt_b32(0, len);\n    size_t vl = svcntw();\n    \n    // Create predicate for indices divisible by 3\n    std::vector<int> indices(len);\n    for (size_t i = 0; i < len; i++) {\n        indices[i] = (i % 3 == 0) ? 1 : 0;\n    }\n    \n    // Load indices into SVE vector\n    svint32_t idx_vec = svld1(pg, indices.data());\n    svbool_t pred = svcmpeq(pg, idx_vec, svdup_s32(1));\n    \n    // Place sorted values back into result\n    size_t third_idx = 0;\n    for (size_t i = 0; i < len; i += 3) {\n        if (i < len && third_idx < thirds.size()) {\n            result[i] = thirds[third_idx++];\n        }\n    }\n    \n    // Use SVE to copy non-third indices\n    svint32_t input_vec = svld1(pg, l.data());\n    svint32_t result_vec = svld1(pg, result.data());\n    result_vec = svsel(pred, result_vec, input_vec);\n    svst1(pg, result.data(), result_vec);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t len = l.size();\n    std::vector<int> result = l;\n    std::vector<int> thirds;\n    \n    // Collect elements at indices divisible by 3\n    for (size_t i = 0; i < len; i += 3) {\n        if (i < len) thirds.push_back(l[i]);\n    }\n    \n    // Sort the collected elements\n    std::sort(thirds.begin(), thirds.end());\n    \n    // Vector length for SVE\n    size_t vl = svcntw();\n    svbool_t pg = svwhilelt_b32(0, len);\n    \n    // Create predicate for indices divisible by 3\n    std::vector<int> indices(len);\n    for (size_t i = 0; i < len; i++) {\n        indices[i] = (i % 3 == 0) ? 1 : 0;\n    }\n    \n    // Load indices into SVE vector\n    svint32_t idx_vec = svld1(pg, indices.data());\n    svbool_t third_mask = svcmpeq(pg, idx_vec, 1);\n    \n    // Place sorted values back into result\n    size_t third_idx = 0;\n    for (size_t i = 0; i < len; i += vl) {\n        pg = svwhilelt_b32(i, len);\n        svint32_t vec = svld1(pg, &l[i]);\n        \n        // Update elements at indices divisible by 3\n        if (third_idx < thirds.size()) {\n            svint32_t sorted_thirds = svdup_n_s32(thirds[third_idx]);\n            vec = svsel(third_mask, sorted_thirds, vec);\n            third_idx++;\n        }\n        \n        // Store result\n        svst1(pg, &result[i], vec);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t len = l.size();\n    std::vector<int> result = l;\n    std::vector<int> thirds;\n    \n    // Collect elements at indices divisible by 3\n    for (size_t i = 0; i < len; i += 3) {\n        thirds.push_back(l[i]);\n    }\n    \n    // Sort the collected elements\n    std::sort(thirds.begin(), thirds.end());\n    \n    // Create predicate for indices divisible by 3\n    svbool_t pg = svptrue_b32();\n    svuint32_t indices = svindex_u32(0, 1);\n    svbool_t third_mask = svcmpeq_n_u32(pg, svand_n_u32_z(pg, indices, 2), 0);\n    \n    // Create vector for sorted thirds\n    size_t third_count = thirds.size();\n    std::vector<int> third_vec(len, 0);\n    for (size_t i = 0, j = 0; i < len; i += 3, j++) {\n        if (j < third_count) third_vec[i] = thirds[j];\n    }\n    \n    // Load input and sorted thirds\n    size_t vl = svcntw();\n    for (size_t i = 0; i < len; i += vl) {\n        svbool_t p = svwhilelt_b32(i, len);\n        svint32_t vec = svld1_s32(p, &l[i]);\n        svint32_t third_vals = svld1_s32(p, &third_vec[i]);\n        \n        // Blend original and sorted values based on third_mask\n        svint32_t blended = svsel_s32(third_mask, third_vals, vec);\n        \n        // Store result\n        svst1_s32(p, &result[i], blended);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t len = l.size();\n    std::vector<int> result = l;\n    std::vector<int> thirds;\n    \n    // Collect elements at indices divisible by 3\n    for (size_t i = 0; i < len; i += 3) {\n        if (i < len) thirds.push_back(l[i]);\n    }\n    \n    // Sort the collected elements\n    std::sort(thirds.begin(), thirds.end());\n    \n    // Get vector length in bytes\n    uint64_t vlen = svcntw();\n    \n    // Create predicate for indices divisible by 3\n    svbool_t pg = svptrue_b32();\n    svuint32_t idx = svindex_u32(0, 1);\n    svuint32_t three = svdup_u32(3);\n    svbool_t mod3 = svcmpeq(pg, svmod_u32(pg, idx, three), 0);\n    \n    // Create vector of sorted thirds\n    std::vector<int> sorted_thirds_vec(len, 0);\n    size_t third_idx = 0;\n    for (size_t i = 0; i < len; i += 3) {\n        if (i < len && third_idx < thirds.size()) {\n            sorted_thirds_vec[i] = thirds[third_idx++];\n        }\n    }\n    \n    // Process vector in chunks\n    for (size_t i = 0; i < len; i += vlen) {\n        svbool_t pg_loop = svwhilelt_b32(i, len);\n        \n        // Load input and sorted thirds\n        svint32_t vec_l = svld1(pg_loop, &l[i]);\n        svint32_t vec_thirds = svld1(pg_loop, &sorted_thirds_vec[i]);\n        \n        // Select elements: use sorted thirds where mod3 is true, else use original\n        svint32_t vec_result = svsel(mod3, vec_thirds, vec_l);\n        \n        // Store result\n        svst1(pg_loop, &result[i], vec_result);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nfloat max_element_simd(std::vector<float> l) {\n    svfloat32_t max_vec = svdup_f32(l[0]);\n    svbool_t pg = svptrue_b32();\n    \n    size_t i = 0;\n    size_t len = l.size();\n    \n    for (; i + svcntw() <= len; i += svcntw()) {\n        svfloat32_t vec = svld1_f32(pg, &l[i]);\n        max_vec = svmax_f32_m(pg, max_vec, vec);\n    }\n    \n    float max_val = svmaxv_f32(pg, max_vec);\n    \n    for (; i < len; i++) {\n        max_val = std::max(max_val, l[i]);\n    }\n    \n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nfloat max_element_simd(std::vector<float> l) {\n    svfloat32_t max_vec = svdup_f32(l[0]);\n    svbool_t pg = svptrue_b32();\n    \n    size_t i = 0;\n    size_t len = l.size();\n    \n    for (; i + svcntw() <= len; i += svcntw()) {\n        svfloat32_t vec = svld1_f32(pg, &l[i]);\n        max_vec = svmax_f32_z(pg, max_vec, vec);\n    }\n    \n    float max_val = svmaxv_f32(pg, max_vec);\n    \n    for (; i < len; i++) {\n        max_val = std::max(max_val, l[i]);\n    }\n    \n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nfloat max_element_simd(std::vector<float> l) {\n    svfloat32_t max_vec = svdup_f32(l[0]);\n    svbool_t pg = svptrue_b32();\n    \n    for (size_t i = 0; i < l.size(); i += svcntw()) {\n        svfloat32_t vec = svld1_f32(pg, &l[i]);\n        max_vec = svmax_f32_m(pg, max_vec, vec);\n    }\n    \n    float max_array[svcntw()];\n    svst1_f32(pg, max_array, max_vec);\n    \n    float max_val = max_array[0];\n    for (size_t i = 1; i < svcntw(); i++) {\n        if (max_array[i] > max_val) {\n            max_val = max_array[i];\n        }\n    }\n    \n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nfloat max_element_simd(std::vector<float> l) {\n    svfloat32_t max_vec = svdup_f32(l[0]);\n    svbool_t pg = svptrue_b32();\n    \n    size_t i = 0;\n    size_t len = l.size();\n    \n    for (; i + svcntw() <= len; i += svcntw()) {\n        svfloat32_t vec = svld1_f32(pg, &l[i]);\n        max_vec = svmax_f32_m(pg, max_vec, vec);\n    }\n    \n    float max_val = svmaxv_f32(pg, max_vec);\n    \n    // Handle remaining elements\n    for (; i < len; i++) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n    \n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nfloat max_element_simd(std::vector<float> l) {\n    svfloat32_t max_vec = svdup_f32(l[0]);\n    svbool_t pg = svptrue_b32();\n    \n    for (size_t i = 0; i < l.size(); i += svcntw()) {\n        svfloat32_t vec = svld1_f32(pg, &l[i]);\n        max_vec = svmax_f32_m(pg, max_vec, vec);\n    }\n    \n    return svmaxv_f32(pg, max_vec);\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    // Process numbers in vector-sized chunks\n    for (int i = 0; i < n; i += svcntw()) {\n        // Create vector of indices\n        svint32_t indices = svindex_s32(i, 1);\n        \n        // Check divisibility by 11\n        svint32_t div11 = svdiv_n_s32_z(pg, indices, 11);\n        svbool_t mod11_zero = svcmpeq_n_s32(pg, svmul_n_s32_z(pg, div11, 11), indices);\n        \n        // Check divisibility by 13\n        svint32_t div13 = svdiv_n_s32_z(pg, indices, 13);\n        svbool_t mod13_zero = svcmpeq_n_s32(pg, svmul_n_s32_z(pg, div13, 13), indices);\n        \n        // Combine divisibility conditions\n        svbool_t divisible = svorr_b_z(pg, mod11_zero, mod13_zero);\n        \n        // Convert numbers to digits for checking 7s\n        while (svptest_any(pg, divisible)) {\n            svint32_t num = svsel_s32(divisible, indices, svdup_n_s32(0));\n            \n            // Count 7s in each number\n            svbool_t active = divisible;\n            while (svptest_any(pg, active)) {\n                svint32_t digits = svmod_n_s32_z(pg, num, 10);\n                svbool_t is_seven = svcmpeq_n_s32(pg, digits, 7);\n                count += svcntp_b32(pg, svand_b_z(pg, active, is_seven));\n                \n                num = svdiv_n_s32_z(pg, num, 10);\n                active = svorr_b_z(pg, active, svcmpeq_n_s32(pg, num, 0));\n            }\n            \n            // Update indices to process next set of divisible numbers\n            divisible = svbic_b_z(pg, divisible, svcmpeq_n_s32(pg, indices, indices));\n        }\n        \n        // Update predicate for next iteration\n        pg = svwhilelt_b32(i + svcntw(), n);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    for (int i = 0; i < n; i += svcntw()) {\n        svbool_t active = svwhilelt_b32(i, n);\n        svuint32_t indices = svindex_u32(i, 1);\n        \n        // Check divisibility by 11\n        svuint32_t div11 = svdiv_n_u32_z(active, indices, 11);\n        svbool_t mod11_zero = svcmpeq_n_u32(active, svmul_n_u32_z(active, div11, 11), indices);\n        \n        // Check divisibility by 13\n        svuint32_t div13 = svdiv_n_u32_z(active, indices, 13);\n        svbool_t mod13_zero = svcmpeq_n_u32(active, svmul_n_u32_z(active, div13, 13), indices);\n        \n        // Combine divisibility conditions\n        svbool_t div_condition = svorr_b_z(active, mod11_zero, mod13_zero);\n        \n        // Convert numbers to digits for checking '7'\n        while (svptest_any(pg, div_condition)) {\n            svuint32_t num = svsel_u32(div_condition, indices, svdup_n_u32(0));\n            svbool_t seven_found = svdup_n_b32(false);\n            \n            // Extract digits\n            while (svptest_any(pg, svcmpne_n_u32(active, num, 0))) {\n                svuint32_t digit = svmod_n_u32_z(active, num, 10);\n                seven_found = svorr_b_z(active, seven_found, svcmpeq_n_u32(active, digit, 7));\n                num = svdiv_n_u32_z(active, num, 10);\n            }\n            \n            // Count numbers containing 7\n            count += svcntp_b32(active, seven_found);\n            \n            // Clear processed numbers\n            div_condition = svbic_b_z(active, div_condition, seven_found);\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    // Process numbers in vector-sized chunks\n    for (int i = 0; i < n; i += svcntw()) {\n        // Create vector of indices\n        svint32_t indices = svindex_s32(i, 1);\n        \n        // Check divisibility by 11\n        svint32_t div11 = svdiv_n_s32_z(pg, indices, 11);\n        svint32_t mul11 = svmul_n_s32_z(pg, div11, 11);\n        svbool_t div11_mask = svcmpeq_s32(pg, indices, mul11);\n        \n        // Check divisibility by 13\n        svint32_t div13 = svdiv_n_s32_z(pg, indices, 13);\n        svint32_t mul13 = svmul_n_s32_z(pg, div13, 13);\n        svbool_t div13_mask = svcmpeq_s32(pg, indices, mul13);\n        \n        // Combine divisibility masks\n        svbool_t div_mask = svorr_b_z(pg, div11_mask, div13_mask);\n        \n        // Process numbers divisible by 11 or 13\n        while (svptest_any(pg, div_mask)) {\n            // Get next divisible number\n            int idx = svclz_b32(div_mask);\n            int num = i + idx;\n            if (num >= n) break;\n            \n            // Count occurrences of digit 7\n            int temp = num;\n            while (temp > 0) {\n                if (temp % 10 == 7) count++;\n                temp /= 10;\n            }\n            \n            // Clear processed bit\n            div_mask = svbic_b_z(pg, div_mask, svptrue_pat_b32(SV_VL1));\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    // Process numbers in vector chunks\n    for (int i = 0; i < n; i += svcntw()) {\n        svbool_t p = svwhilelt_b32(i, n);\n        svuint32_t vec = svindex_u32(i, 1);\n        \n        // Check divisibility by 11\n        svuint32_t div11 = svdiv_n_u32_z(p, vec, 11);\n        svuint32_t mul11 = svmul_n_u32_z(p, div11, 11);\n        svbool_t is_div11 = svcmpeq_u32(p, vec, mul11);\n        \n        // Check divisibility by 13\n        svuint32_t div13 = svdiv_n_u32_z(p, vec, 13);\n        svuint32_t mul13 = svmul_n_u32_z(p, div13, 13);\n        svbool_t is_div13 = svcmpeq_u32(p, vec, mul13);\n        \n        // Combine divisibility conditions\n        svbool_t divisible = svorr_b_z(pg, is_div11, is_div13);\n        \n        // Convert numbers to digits for checking 7s\n        while (svptest_any(pg, divisible)) {\n            uint32_t num = svlastb_u32(divisible, vec);\n            if (svptest_first(pg, divisible)) {\n                // Count 7s in the number\n                while (num > 0) {\n                    if (num % 10 == 7) count++;\n                    num /= 10;\n                }\n            }\n            divisible = svbic_b_z(pg, divisible, svwhilelt_b32(0, 1));\n            vec = svadd_n_u32_z(pg, vec, 1);\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    svbool_t pg = svptrue_b32();\n    \n    // Process numbers in chunks of vector length\n    for (int i = 0; i < n; i += svcntw()) {\n        // Create vector of indices\n        svint32_t indices = svindex_s32(i, 1);\n        \n        // Check divisibility by 11\n        svint32_t div11 = svdiv_n_s32_z(pg, indices, 11);\n        svbool_t mask11 = svcmpeq_n_s32(pg, svmul_n_s32_z(pg, div11, 11), indices);\n        \n        // Check divisibility by 13\n        svint32_t div13 = svdiv_n_s32_z(pg, indices, 13);\n        svbool_t mask13 = svcmpeq_n_s32(pg, svmul_n_s32_z(pg, div13, 13), indices);\n        \n        // Combine masks (divisible by 11 or 13)\n        svbool_t mask = svorr_b_z(pg, mask11, mask13);\n        \n        // Count digit 7 in numbers divisible by 11 or 13\n        while (svptest_any(pg, mask)) {\n            int32_t num = svlasta_s32(svpfalse(), svsel_s32(mask, indices, svdup_n_s32(0)));\n            if (num >= n) break;\n            \n            // Count 7s in the number\n            int temp = num;\n            while (temp > 0) {\n                if (temp % 10 == 7) count++;\n                temp /= 10;\n            }\n            \n            // Clear the processed element\n            svbool_t single = svcmpeq_n_s32(pg, indices, num);\n            mask = svbic_b_z(pg, mask, single);\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t len = l.size();\n    std::vector<float> result = l;\n    \n    // Get vector length in elements\n    int64_t vlen = svcntw();\n    \n    // Process even indices in vector-sized chunks\n    for (size_t i = 0; i < len; i += vlen) {\n        // Create predicate for even indices\n        svbool_t pg = svptrue_b32();\n        svbool_t even_mask = svwhilelt_b32(i, len);\n        pg = svand_b_z(svptrue_b32(), even_mask, svnot_b_z(svptrue_b32(), svcnt_b32(1)));\n        \n        // Load even elements\n        svfloat32_t vec = svld1_f32(pg, &l[i]);\n        \n        // Sort even elements\n        // Create temporary array for sorting\n        std::vector<float> temp(vlen);\n        svst1_f32(pg, &temp[0], vec);\n        \n        // Count valid elements\n        size_t count = svcntp_b32(pg);\n        std::sort(temp.begin(), temp.begin() + count);\n        \n        // Load sorted values back\n        vec = svld1_f32(pg, &temp[0]);\n        \n        // Store back to result\n        svst1_f32(pg, &result[i], vec);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t len = l.size();\n    std::vector<float> result = l;\n    \n    // Handle empty or single-element vectors\n    if (len <= 1) return result;\n\n    // Get vector length in elements\n    uint64_t vlen = svcntw();\n    \n    // Process even indices\n    std::vector<float> even_vals;\n    for (size_t i = 0; i < len; i += 2) {\n        even_vals.push_back(l[i]);\n    }\n    \n    // Sort even values\n    std::sort(even_vals.begin(), even_vals.end());\n    \n    // Create predicate for even indices\n    svbool_t pg = svptrue_b32();\n    svbool_t even_mask = svzip1_b32(pg, svnot_b_z(pg, pg));\n    \n    // Create vector for sorted even values\n    std::vector<float> sorted_even(len, 0.0f);\n    size_t even_idx = 0;\n    for (size_t i = 0; i < len && even_idx < even_vals.size(); i += 2) {\n        sorted_even[i] = even_vals[even_idx++];\n    }\n    \n    // Load input and sorted even values into SVE vectors\n    for (size_t i = 0; i < len; i += vlen) {\n        // Load current chunk of input\n        svfloat32_t vec = svld1_f32(pg, &l[i]);\n        \n        // Load sorted even values\n        svfloat32_t sorted_vec = svld1_f32(pg, &sorted_even[i]);\n        \n        // Blend vectors using even_mask\n        svfloat32_t result_vec = svsel_f32(even_mask, sorted_vec, vec);\n        \n        // Store result\n        svst1_f32(pg, &result[i], result_vec);\n        \n        // Update predicate for remaining elements\n        if (i + vlen > len) {\n            pg = svwhilelt_b32(i, len);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t len = l.size();\n    std::vector<float> result = l;\n    \n    // Handle empty or single-element vectors\n    if (len <= 1) return result;\n    \n    // Calculate number of even-indexed elements\n    size_t even_count = (len + 1) / 2;\n    std::vector<float> even_elements(even_count);\n    \n    // Extract even-indexed elements\n    for (size_t i = 0; i < even_count; i++) {\n        even_elements[i] = l[i * 2];\n    }\n    \n    // Sort even elements\n    std::sort(even_elements.begin(), even_elements.end());\n    \n    // Create predicate for even indices\n    svbool_t pg = svptrue_b32();\n    svbool_t even_mask = svzip1_b32(svptrue_b32(), svpfalse_b());\n    \n    // Process vector in chunks that fit SVE register\n    size_t vec_len = svcntw();\n    std::vector<float> temp(len);\n    \n    for (size_t i = 0; i < len; i += vec_len) {\n        // Load input vector chunk\n        svfloat32_t vec = svld1_f32(pg, &l[i]);\n        \n        // Load sorted even elements for this chunk\n        svfloat32_t even_vec = svld1_f32(pg, &even_elements[i/2]);\n        \n        // Update even indices with sorted values\n        svfloat32_t result_vec = svsel_f32(even_mask, even_vec, vec);\n        \n        // Store result\n        svst1_f32(pg, &temp[i], result_vec);\n    }\n    \n    // Copy results back to output vector\n    for (size_t i = 0; i < len; i++) {\n        result[i] = temp[i];\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t len = l.size();\n    std::vector<float> result = l;\n    \n    // Handle empty or single-element vectors\n    if (len <= 1) return result;\n\n    // Get vector length in elements\n    uint64_t vlen = svcntw();\n    \n    // Process even indices\n    std::vector<float> even_vals;\n    for (size_t i = 0; i < len; i += 2) {\n        even_vals.push_back(l[i]);\n    }\n    \n    // Sort even values\n    std::sort(even_vals.begin(), even_vals.end());\n    \n    // Create SVE predicates for even and odd indices\n    svbool_t even_mask = svptrue_b32();\n    svbool_t odd_mask = svptrue_b32();\n    \n    // Create index vector for interleaving\n    svuint32_t indices = svindex_u32(0, 1);\n    even_mask = svcmpeq_n_u32(svptrue_b32(), svand_n_u32(svptrue_b32(), indices, 1), 0);\n    odd_mask = svcmpeq_n_u32(svptrue_b32(), svand_n_u32(svptrue_b32(), indices, 1), 1);\n    \n    // Process vector in chunks\n    size_t even_idx = 0;\n    for (size_t i = 0; i < len; i += vlen) {\n        // Load input vector chunk\n        svfloat32_t vec = svld1_f32(svptrue_b32(), &l[i]);\n        \n        // Create vector with sorted even values\n        svfloat32_t even_vec = svdup_n_f32(even_vals[even_idx / 2]);\n        even_idx += 2;\n        \n        // Keep original odd values\n        svfloat32_t odd_vec = vec;\n        \n        // Combine using predicates\n        svfloat32_t result_vec = svsel_f32(even_mask, even_vec, odd_vec);\n        \n        // Store result\n        svst1_f32(svptrue_b32(), &result[i], result_vec);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = len - (len % vlen); i < len; i += 2) {\n        result[i] = even_vals[i / 2];\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t len = l.size();\n    std::vector<float> result = l;\n\n    // Ensure vector length is even for paired processing\n    if (len % 2 != 0) {\n        len--;\n    }\n\n    // Calculate number of elements that can be processed per vector\n    size_t vec_len = svcntw(); // Number of 32-bit floats per vector\n    svbool_t pg = svwhilelt_b32(0, len);\n\n    // Process even indices in vectorized manner\n    for (size_t i = 0; i < len; i += vec_len * 2) {\n        // Load even and odd indices\n        svfloat32_t even_vec = svld1_f32(pg, &l[i]);\n        svfloat32_t odd_vec = svld1_f32(pg, &l[i + 1]);\n\n        // Create mask for even indices\n        svbool_t even_mask = svptrue_b32();\n        svbool_t odd_mask = svnot_b_z(pg, even_mask);\n\n        // Sort even indices\n        svfloat32_t sorted_even = svsort_f32(even_vec, pg);\n\n        // Store results: even indices get sorted values, odd indices retain original\n        svst1_f32(pg, &result[i], svsel_f32(even_mask, sorted_even, odd_vec));\n        svst1_f32(pg, &result[i + 1], svsel_f32(odd_mask, sorted_even, odd_vec));\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 3) return false;\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    for (size_t i = 0; i < n - 2; ++i) {\n        for (size_t j = i + 1; j < n - 1; ++j) {\n            int target = -(l[i] + l[j]);\n            \n            svint32_t target_vec = svdup_s32(target);\n            size_t k = j + 1;\n            \n            while (k < n) {\n                size_t vl = svcntw();\n                if (k + vl > n) {\n                    pg = svwhilelt_b32(k, n);\n                    vl = n - k;\n                }\n                \n                svint32_t vec = svld1(pg, &l[k]);\n                svbool_t eq_mask = svcmpeq(pg, vec, target_vec);\n                \n                if (svptest_any(pg, eq_mask)) {\n                    return true;\n                }\n                \n                k += vl;\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 3) return false;\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    for (size_t i = 0; i < n - 2; ++i) {\n        int a = l[i];\n        for (size_t j = i + 1; j < n - 1; ++j) {\n            int b = l[j];\n            int target = -(a + b);\n\n            // Vectorized search for target\n            size_t k = j + 1;\n            while (k < n) {\n                // Determine how many elements can be processed in this iteration\n                size_t remaining = n - k;\n                svbool_t p = svwhilelt_b32(0, remaining);\n                \n                // Load elements into SVE register\n                svint32_t vec = svld1_s32(p, &l[k]);\n                \n                // Compare with target\n                svbool_t eq = svcmpeq_s32(p, vec, target);\n                \n                // Check if any element matches target\n                if (svptest_any(p, eq)) {\n                    return true;\n                }\n                \n                k += svcntw();\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 3) return false;\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    for (size_t i = 0; i < n - 2; ++i) {\n        int a = l[i];\n        for (size_t j = i + 1; j < n - 1; ++j) {\n            int b = l[j];\n            int target = -(a + b);\n            \n            svint32_t v_target = svdup_s32(target);\n            size_t k = j + 1;\n            \n            while (k < n) {\n                size_t vl = svcntw();\n                if (k + vl > n) {\n                    pg = svwhilelt_b32(k, n);\n                    vl = n - k;\n                }\n                \n                svint32_t v_data = svld1(pg, &l[k]);\n                svbool_t eq_mask = svcmpeq(pg, v_data, v_target);\n                \n                if (svptest_any(pg, eq_mask)) {\n                    return true;\n                }\n                \n                k += vl;\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 3) return false;\n\n    size_t n = l.size();\n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    for (size_t i = 0; i < n - 2; ++i) {\n        for (size_t j = i + 1; j < n - 1; ++j) {\n            int target = -(l[i] + l[j]);\n            svint32_t v_target = svdup_s32(target);\n            \n            size_t k = j + 1;\n            while (k < n) {\n                size_t vl = svcntw();\n                if (k + vl > n) vl = n - k;\n                pg = svwhilelt_b32(0, vl);\n                \n                svint32_t v_nums = svld1_s32(pg, &l[k]);\n                svbool_t match = svcmpeq_s32(pg, v_nums, v_target);\n                \n                if (svptest_any(pg, match)) {\n                    return true;\n                }\n                \n                k += vl;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 3) return false;\n\n    // Get the vector length for SVE\n    uint64_t vl = svcntw();\n    svbool_t pg = svptrue_b32();\n\n    // Iterate over all possible triplets using a combination of scalar and vector operations\n    for (size_t i = 0; i < n - 2; ++i) {\n        for (size_t j = i + 1; j < n - 1; ++j) {\n            int target = -(l[i] + l[j]);\n            size_t k = j + 1;\n\n            // Process remaining elements in chunks using SVE\n            while (k < n) {\n                size_t remaining = n - k;\n                svbool_t active = svwhilelt_b32(k, n);\n                svint32_t vec = svld1_s32(active, &l[k]);\n                svbool_t match = sveq_s32(active, vec, target);\n\n                if (svptest_any(pg, match)) {\n                    return true;\n                }\n\n                k += vl;\n                if (k >= n) break;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t len = l.size();\n    std::vector<int> result(len);\n    \n    // Determine the vector length for SVE\n    uint64_t vl = svcntw();\n    svbool_t pg = svptrue_b32();\n    \n    size_t i = 0;\n    for (; i <= len - vl; i += vl) {\n        // Load vector from input\n        svint32_t vec = svld1(pg, &l[i]);\n        // Increment by 1\n        svint32_t inc_vec = svadd_n_s32_z(pg, vec, 1);\n        // Store result\n        svst1(pg, &result[i], inc_vec);\n    }\n    \n    // Handle remaining elements\n    if (i < len) {\n        svbool_t pg_rem = svwhilelt_b32(i, len);\n        svint32_t vec = svld1(pg_rem, &l[i]);\n        svint32_t inc_vec = svadd_n_s32_z(pg_rem, vec, 1);\n        svst1(pg_rem, &result[i], inc_vec);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t len = l.size();\n    std::vector<int> result(len);\n    \n    // Determine the vector length for SVE\n    uint64_t vl = svcntw();\n    svbool_t pg = svptrue_b32();\n    \n    size_t i = 0;\n    for (; i + vl <= len; i += vl) {\n        // Load a vector of integers from the input\n        svint32_t vec = svld1(pg, &l[i]);\n        // Increment the vector by 1\n        svint32_t inc_vec = svadd_n_s32_z(pg, vec, 1);\n        // Store the result back to the output vector\n        svst1(pg, &result[i], inc_vec);\n    }\n    \n    // Handle remaining elements (if any) scalar-wise\n    for (; i < len; i++) {\n        result[i] = l[i] + 1;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t len = l.size();\n    std::vector<int> result(len);\n    size_t vec_len = svcntw(); // Get the number of 32-bit elements per vector\n    svint32_t vec_one = svdup_n_s32(1); // Create a vector of 1s\n    size_t i = 0;\n\n    // Process the input vector in chunks of vector length\n    for (; i + vec_len <= len; i += vec_len) {\n        svbool_t pg = svwhilelt_b32(i, len); // Predicate for active lanes\n        svint32_t vec_data = svld1_s32(pg, &l[i]); // Load input data\n        svint32_t vec_result = svadd_s32_z(pg, vec_data, vec_one); // Add 1 to each element\n        svst1_s32(pg, &result[i], vec_result); // Store result\n    }\n\n    // Handle remaining elements (tail) if any\n    for (; i < len; i++) {\n        result[i] = l[i] + 1;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t len = l.size();\n    std::vector<int> result(len);\n    \n    // Get the vector length for SVE\n    uint64_t vl = svcntw();\n    svint32_t vec_one = svdup_n_s32(1);\n    \n    size_t i = 0;\n    for (; i + vl <= len; i += vl) {\n        // Load vector from input\n        svint32_t vec = svld1_s32(svptrue_b32(), &l[i]);\n        // Increment by 1\n        svint32_t vec_inc = svadd_s32_z(svptrue_b32(), vec, vec_one);\n        // Store result\n        svst1_s32(svptrue_b32(), &result[i], vec_inc);\n    }\n    \n    // Handle remaining elements\n    if (i < len) {\n        svbool_t pg = svwhilelt_b32(i, len);\n        svint32_t vec = svld1_s32(pg, &l[i]);\n        svint32_t vec_inc = svadd_s32_z(pg, vec, vec_one);\n        svst1_s32(pg, &result[i], vec_inc);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t len = l.size();\n    std::vector<int> result(len);\n    \n    // Determine the vector length for SVE\n    uint64_t vl = svcntw();\n    svbool_t pg = svptrue_b32();\n    \n    size_t i = 0;\n    for (; i + vl <= len; i += vl) {\n        // Load a vector of integers from the input\n        svint32_t vec = svld1_s32(pg, &l[i]);\n        // Increment the vector by 1\n        svint32_t incremented = svadd_n_s32_z(pg, vec, 1);\n        // Store the result back to the output vector\n        svst1_s32(pg, &result[i], incremented);\n    }\n    \n    // Handle remaining elements (if any) scalarly\n    for (; i < len; i++) {\n        result[i] = l[i] + 1;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 2) return false;\n\n    // Get the vector length for SVE\n    uint64_t vl = svcntw();\n    svbool_t pg = svwhilelt_b32(0, vl);\n\n    // Process the vector in chunks based on SVE vector length\n    for (size_t i = 0; i < n; i++) {\n        int val = l[i];\n        svint32_t val_vec = svdup_s32(val);\n        size_t j = i + 1;\n\n        // Process remaining elements in chunks\n        while (j < n) {\n            size_t remaining = n - j;\n            svbool_t pred = svwhilelt_b32(0, remaining);\n            svint32_t chunk = svld1_s32(pred, &l[j]);\n            svint32_t sum_vec = svadd_s32_z(pred, val_vec, chunk);\n            svbool_t zero_mask = svcmpeq_s32(pred, sum_vec, 0);\n\n            if (svptest_any(pred, zero_mask)) {\n                return true;\n            }\n            j += vl;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 2) return false;\n\n    // Get the vector length for SVE\n    uint64_t vl = svcntw();\n    svbool_t pg = svwhilelt_b32(0, vl);\n\n    // Process the vector in chunks based on SVE vector length\n    for (size_t i = 0; i < n; i++) {\n        int val = l[i];\n        svint32_t val_vec = svdup_s32(val);\n        size_t j = i + 1;\n\n        // Process remaining elements in chunks\n        while (j < n) {\n            size_t remaining = n - j;\n            svbool_t p = svwhilelt_b32(0, remaining);\n            svint32_t chunk = svld1_s32(p, &l[j]);\n            svint32_t sum_vec = svadd_s32_z(p, val_vec, chunk);\n            svbool_t zero_mask = svcmpeq_s32(p, sum_vec, 0);\n\n            if (svptest_any(p, zero_mask)) {\n                return true;\n            }\n            j += vl;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 2) return false;\n\n    // Get the vector length for SVE\n    uint64_t vl = svcntw();\n    svbool_t pg = svwhilelt_b32(0, vl);\n\n    // Process the vector in chunks based on SVE vector length\n    for (size_t i = 0; i < n; i++) {\n        int val = l[i];\n        svint32_t val_vec = svdup_s32(val);\n        size_t j = i + 1;\n\n        // Process remaining elements in chunks\n        while (j < n) {\n            size_t remaining = n - j;\n            svbool_t p = svwhilelt_b32(0, remaining);\n            svint32_t chunk = svld1_s32(p, &l[j]);\n            svint32_t sum_vec = svadd_s32_z(p, val_vec, chunk);\n            svbool_t zero_mask = svcmpeq_s32(p, sum_vec, 0);\n            if (svptest_any(p, zero_mask)) {\n                return true;\n            }\n            j += svcntw();\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 2) return false;\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    size_t vec_len = svcntw();\n\n    for (size_t i = 0; i < n; i += vec_len) {\n        svbool_t pg_i = svwhilelt_b32(i, n);\n        svint32_t vec_i = svld1(pg_i, &l[i]);\n\n        for (size_t j = i + 1; j < n; j += vec_len) {\n            svbool_t pg_j = svwhilelt_b32(j, n);\n            svint32_t vec_j = svld1(pg_j, &l[j]);\n\n            svint32_t sum = svadd_z(pg_i, vec_i, vec_j);\n            svbool_t zero_mask = svcmpeq(pg_i, sum, 0);\n\n            if (svptest_any(pg_i, zero_mask)) {\n                // Check for distinct elements (not same index)\n                for (size_t k = i; k < std::min(i + vec_len, n); k++) {\n                    for (size_t m = j; m < std::min(j + vec_len, n); m++) {\n                        if (k != m && l[k] + l[m] == 0) {\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    size_t len = l.size();\n    if (len < 2) return false;\n\n    svbool_t pg = svptrue_b32();\n    size_t vec_len = svcntw();\n\n    for (size_t i = 0; i < len; i += vec_len) {\n        size_t elements = std::min(vec_len, len - i);\n        svbool_t pg_active = svwhilelt_b32(i, len);\n        \n        svint32_t vec_a = svld1_s32(pg_active, &l[i]);\n        \n        for (size_t j = 0; j < len; j++) {\n            if (i == j) continue;\n            \n            svint32_t vec_b = svdup_s32(-l[j]);\n            svint32_t sum = svadd_z(pg_active, vec_a, vec_b);\n            \n            svbool_t eq_zero = svcmpeq(pg_active, sum, 0);\n            if (svptest_any(pg_active, eq_zero)) {\n                // Check for distinct elements\n                svbool_t ne_i = svcmpne(pg_active, vec_a, l[j]);\n                if (svptest_any(pg_active, svand_b_z(pg_active, eq_zero, ne_i))) {\n                    return true;\n                }\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    // Handle negative numbers and zero\n    if (x == 0) return \"0\";\n    bool is_negative = x < 0;\n    if (is_negative) x = -x;\n\n    // Maximum digits needed (log_base(x) + 1)\n    const int max_digits = 64; // Sufficient for int64_t in base 2\n    int64_t digits[max_digits] = {0};\n    int digit_count = 0;\n\n    // Vectorized division and remainder calculation\n    svbool_t pg = svwhilelt_b64((uint64_t)0, (uint64_t)max_digits);\n    svint64_t v_x = svdup_s64(x);\n    svint64_t v_base = svdup_s64(base);\n    svint64_t v_digits = svdup_s64(0);\n\n    while (svptest_any(pg, svcmpgt_n_s64(pg, v_x, 0))) {\n        // Compute remainder and quotient\n        svint64_t v_rem = svmod_n_s64_z(pg, v_x, v_base);\n        v_x = svdiv_n_s64_z(pg, v_x, v_base);\n\n        // Store remainder if within bounds\n        if (digit_count < max_digits) {\n            digits[digit_count++] = svlasta_s64(svptrue_b64(), v_rem);\n        }\n    }\n\n    // Convert digits to string\n    std::string result;\n    if (is_negative) result += \"-\";\n    \n    // Append digits in reverse order\n    for (int i = digit_count - 1; i >= 0; --i) {\n        result += (char)('0' + digits[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    \n    bool is_negative = x < 0;\n    uint64_t abs_x = is_negative ? -x : x;\n    \n    // Estimate maximum digits needed (log_base(x) + 1)\n    int max_digits = 64; // Safe upper bound for 64-bit integer\n    std::vector<char> digits(max_digits);\n    int digit_count = 0;\n    \n    // SVE vector for remainders\n    svbool_t pg = svwhilelt_b64(0, max_digits);\n    svuint64_t v_x = svdup_u64(abs_x);\n    svuint64_t v_base = svdup_u64(base);\n    svuint64_t v_digits = svdup_u64(0);\n    \n    while (abs_x > 0 && digit_count < max_digits) {\n        // Compute remainder and quotient in parallel\n        svuint64_t v_rem = svmod_u64_x(pg, v_x, v_base);\n        v_x = svdiv_u64_x(pg, v_x, v_base);\n        \n        // Extract remainder\n        uint64_t rem = svlasta_u64(svptrue_b64(), v_rem);\n        digits[digit_count++] = '0' + rem;\n        abs_x /= base;\n    }\n    \n    // Construct result string\n    std::string result;\n    if (is_negative) result += '-';\n    for (int i = digit_count - 1; i >= 0; --i) {\n        result += digits[i];\n    }\n    \n    return result.empty() ? \"0\" : result;\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    // Handle edge cases\n    if (x == 0) return \"0\";\n    if (base < 2 || base > 10) return \"\";\n\n    // Determine maximum digits needed (log_base(x) + 1)\n    int max_digits = 0;\n    int64_t temp_x = x;\n    while (temp_x > 0) {\n        temp_x /= base;\n        max_digits++;\n    }\n\n    // Initialize result array\n    char result[65]; // Max 64 bits for binary + null terminator\n    int digit_count = 0;\n\n    // SVE vector for remainders\n    svbool_t pg = svwhilelt_b32(0, max_digits);\n    svint64_t vec_x = svdup_s64(x);\n    svint64_t vec_base = svdup_s64(base);\n    svint64_t vec_zero = svdup_s64(0);\n    svint64_t vec_ten = svdup_s64(10);\n\n    // Process digits in parallel\n    while (svptest_any(svptrue_b64(), pg)) {\n        // Compute remainder and quotient\n        svint64_t vec_remainder = svmod_s64_z(pg, vec_x, vec_base);\n        vec_x = svdiv_s64_z(pg, vec_x, vec_base);\n\n        // Convert remainder to char ('0' to '9')\n        svint64_t vec_char = svadd_s64_z(pg, vec_remainder, svdup_s64('0'));\n\n        // Store digits in reverse order\n        int64_t remainder = svlasta_s64(0, vec_remainder);\n        if (remainder < 10) {\n            result[max_digits - digit_count - 1] = static_cast<char>(remainder + '0');\n            digit_count++;\n        }\n\n        // Update predicate for remaining non-zero values\n        pg = svwhilelt_b32(digit_count, max_digits);\n    }\n\n    // Null terminate and return string\n    result[digit_count] = '\\0';\n    return std::string(result);\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    // Handle special cases\n    if (x == 0) return \"0\";\n    \n    // Determine if negative and make x positive\n    bool is_negative = x < 0;\n    if (is_negative) x = -x;\n    \n    // Calculate maximum digits needed (log_base(x) + 1)\n    int max_digits = 0;\n    int64_t temp = x;\n    while (temp > 0) {\n        temp /= base;\n        max_digits++;\n    }\n    \n    // Initialize result array\n    char result[65]; // Max 64 bits + null terminator\n    int pos = max_digits;\n    result[pos] = '\\0';\n    \n    // Vectorized division and remainder\n    svbool_t pg = svwhilelt_b64(0, max_digits);\n    svint64_t vec_x = svdup_s64(x);\n    svint64_t vec_base = svdup_s64(base);\n    svint64_t vec_digits = svdup_s64(0);\n    \n    while (svptest_any(svptrue_b64(), pg)) {\n        // Compute remainder and quotient\n        svint64_t vec_rem = svmod_s64_z(pg, vec_x, vec_base);\n        vec_x = svdiv_s64_z(pg, vec_x, vec_base);\n        \n        // Convert remainder to char\n        svint64_t vec_char = svadd_s64_z(pg, vec_rem, svdup_s64('0'));\n        \n        // Store result (scalar operation for simplicity)\n        pos--;\n        result[pos] = svlasta_s64(0, vec_char);\n        \n        // Update predicate for next iteration\n        pg = svwhilelt_b64(0, pos);\n    }\n    \n    // Add negative sign if needed\n    if (is_negative) {\n        result[--pos] = '-';\n    }\n    \n    return std::string(&result[pos]);\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    \n    bool is_negative = x < 0;\n    if (is_negative) x = -x;\n    \n    // Maximum digits needed for base 2 (worst case)\n    const int max_digits = 64;\n    int8_t digits[max_digits];\n    int digit_count = 0;\n    \n    // Vectorized division and remainder calculation\n    svbool_t pg = svwhilelt_b8(0, max_digits);\n    svint8_t v_base = svdup_s8(base);\n    svint64_t v_x = svdup_s64(x);\n    \n    while (svptest_any(svptrue_b64(), svcmpgt_n_s64(pg, v_x, 0))) {\n        // Compute remainder and quotient in parallel\n        svint64_t v_rem = svmod_n_s64(pg, v_x, base);\n        svint64_t v_quot = svdiv_n_s64(pg, v_x, base);\n        \n        // Store remainder as digit\n        digits[digit_count++] = svlasta(svptrue_b64(), v_rem);\n        \n        // Update x for next iteration\n        v_x = v_quot;\n        \n        // Check if x is zero\n        if (!svptest_any(svptrue_b64(), svcmpgt_n_s64(pg, v_x, 0))) {\n            break;\n        }\n    }\n    \n    // Convert digits to string (in reverse order)\n    std::string result;\n    if (is_negative) result += '-';\n    \n    for (int i = digit_count - 1; i >= 0; --i) {\n        result += (char)(digits[i] + '0');\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    size_t len = text.length();\n    if (len <= 1) return true;\n\n    const char* str = text.c_str();\n    size_t half_len = len / 2;\n    svbool_t pg = svwhilelt_b8(0, half_len);\n    \n    size_t i = 0;\n    while (i < half_len) {\n        svuint8_t left = svld1_u8(pg, (const uint8_t*)(str + i));\n        svuint8_t right = svld1_u8(pg, (const uint8_t*)(str + len - 1 - i));\n        right = svrev_u8(right);\n        \n        svbool_t eq = svcmpeq_u8(pg, left, right);\n        if (!svptest_all(eq)) return false;\n        \n        i += svcntb();\n        pg = svwhilelt_b8(i, half_len);\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    size_t len = text.length();\n    if (len <= 1) return true;\n\n    const char* str = text.c_str();\n    svbool_t pg = svwhilelt_b8(0, len);\n    size_t half = len / 2;\n    \n    for (size_t i = 0; i < half; i += svcntb()) {\n        size_t j = len - svcntb() - i;\n        \n        svuint8_t left = svld1_u8(pg, &str[i]);\n        svuint8_t right = svld1_u8(pg, &str[j]);\n        \n        svuint8_t rev_right = svrev_u8(right);\n        svbool_t cmp = svcmpeq_u8(pg, left, rev_right);\n        \n        if (!svptest_all(cmp)) {\n            return false;\n        }\n        \n        pg = svwhilelt_b8(i + svcntb(), half);\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    size_t len = text.length();\n    if (len <= 1) return true;\n\n    const char* str = text.c_str();\n    size_t half_len = len / 2;\n    svbool_t pg = svwhilelt_b8(0, half_len);\n    \n    size_t i = 0;\n    while (i < half_len) {\n        svuint8_t left = svld1_u8(pg, (const uint8_t*)(str + i));\n        svuint8_t right = svld1_u8(pg, (const uint8_t*)(str + len - i - svcntb()));\n        \n        svuint8_t reversed_right = svrev_u8(right);\n        svbool_t cmp = svcmpeq_u8(pg, left, reversed_right);\n        \n        if (!svptest_all(pg, cmp)) {\n            return false;\n        }\n        \n        i += svcntb();\n        pg = svwhilelt_b8(i, half_len);\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    size_t len = text.length();\n    if (len <= 1) return true;\n\n    const char* str = text.c_str();\n    svbool_t pg = svwhilelt_b8(0, len);\n    size_t vec_len = svcntb();\n\n    for (size_t i = 0; i < len / 2; i += vec_len) {\n        size_t remaining = len / 2 - i;\n        size_t cmp_len = remaining < vec_len ? remaining : vec_len;\n\n        svbool_t pg_cmp = svwhilelt_b8(0, cmp_len);\n        svuint8_t left = svld1_u8(pg_cmp, (const uint8_t*)&str[i]);\n        svuint8_t right = svld1_u8(pg_cmp, (const uint8_t*)&str[len - i - cmp_len]);\n\n        svuint8_t reversed_right = svrev_u8(right);\n        svbool_t cmp = svcmpeq_u8(pg_cmp, left, reversed_right);\n\n        if (!svptest_all(pg_cmp, cmp)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    if (text.empty()) return true;\n    \n    size_t len = text.length();\n    const char* str = text.c_str();\n    \n    // Process in vector-sized chunks\n    svbool_t pg = svwhilelt_b8(0, len);\n    size_t vector_length = svcntb();\n    \n    // Compare characters from both ends\n    size_t i = 0;\n    size_t j = len - 1;\n    \n    while (i < j) {\n        // Load characters from start and end\n        svuint8_t vec_left = svld1_u8(pg, &str[i]);\n        svuint8_t vec_right = svld1_u8(pg, &str[j - vector_length + 1]);\n        \n        // Reverse right vector for comparison\n        svuint8_t vec_right_rev = svrev_u8(vec_right);\n        \n        // Compare vectors\n        svbool_t cmp = svcmpeq_u8(pg, vec_left, vec_right_rev);\n        if (!svptest_all(cmp)) {\n            return false;\n        }\n        \n        i += vector_length;\n        j -= vector_length;\n        pg = svwhilelt_b8(i, len);\n    }\n    \n    // Handle remaining characters in the middle\n    if (i == j) {\n        return true; // Single character in middle\n    }\n    \n    return true; // All comparisons matched\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), ' ');\n    const char *in = s.data();\n    char *out_ptr = out.data();\n    size_t len = s.length();\n    \n    svbool_t pg = svwhilelt_b8(0, len);\n    const svint8_t shift = svdup_s8(-5);\n    const svint8_t mod = svdup_s8(26);\n    const svint8_t a_val = svdup_s8('a');\n\n    for (size_t i = 0; i < len; i += svcntb()) {\n        pg = svwhilelt_b8(i, len);\n        \n        svint8_t vec = svld1_s8(pg, in + i);\n        vec = svsub_s8_x(pg, vec, a_val);\n        vec = svadd_s8_x(pg, vec, shift);\n        vec = svmod_s8_x(pg, vec, mod);\n        vec = svadd_s8_x(pg, vec, a_val);\n        \n        svst1_s8(pg, out_ptr + i, vec);\n    }\n    \n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), ' ');\n    const char *in = s.data();\n    char *out_ptr = out.data();\n    size_t len = s.length();\n    \n    svbool_t pg = svwhilelt_b8(0, len);\n    const svuint8_t shift = svdup_u8(5);\n    const svuint8_t a_val = svdup_u8('a');\n    const svuint8_t z_val = svdup_u8('z');\n    const svuint8_t mod = svdup_u8(26);\n\n    for (size_t i = 0; i < len; i += svcntb()) {\n        pg = svwhilelt_b8(i, len);\n        svuint8_t vec = svld1_u8(pg, in + i);\n        \n        svuint8_t shifted = svsub_u8_x(pg, vec, shift);\n        svuint8_t below_a = svcmplt_u8(pg, shifted, a_val);\n        svuint8_t adjust = svmul_u8_m(pg, below_a, mod);\n        shifted = svadd_u8_m(pg, shifted, adjust);\n        \n        svst1_u8(pg, out_ptr + i, shifted);\n    }\n    \n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), ' ');\n    const char* in = s.data();\n    char* out_ptr = out.data();\n    int len = s.length();\n    \n    svbool_t pg = svwhilelt_b8(0, len);\n    const svint8_t shift = svdup_s8(-5);\n    const svint8_t mod = svdup_s8(26);\n    const svint8_t a_val = svdup_s8('a');\n    \n    for (int i = 0; i < len; ) {\n        svint8_t chars = svld1_s8(pg, in + i);\n        svint8_t sub_a = svsub_s8_x(pg, chars, a_val);\n        svint8_t shifted = svadd_s8_x(pg, sub_a, shift);\n        svint8_t modded = svmod_s8_x(pg, shifted, mod);\n        svint8_t result = svadd_s8_x(pg, modded, a_val);\n        svst1_s8(pg, out_ptr + i, result);\n        \n        i += svcntb();\n        pg = svwhilelt_b8(i, len);\n    }\n    \n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), ' ');\n    const char *in = s.c_str();\n    char *out_ptr = &out[0];\n    size_t len = s.length();\n    \n    svbool_t pg = svwhilelt_b8(0, len);\n    size_t vlen = svcntb();\n    \n    for (size_t i = 0; i < len; i += vlen) {\n        pg = svwhilelt_b8(i, len);\n        \n        svuint8_t vec = svld1_u8(pg, (uint8_t*)(in + i));\n        \n        svuint8_t shifted = svsub_u8_x(pg, vec, svdup_u8(5));\n        svuint8_t mod26 = svand_u8_x(pg, shifted, svdup_u8(25));\n        svuint8_t adjusted = svadd_u8_x(pg, mod26, svdup_u8('a'));\n        \n        svst1_u8(pg, (uint8_t*)(out_ptr + i), adjusted);\n    }\n    \n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), ' ');\n    size_t len = s.length();\n    size_t vlen = svcntb();\n    svbool_t pg = svptrue_b8();\n    \n    size_t i = 0;\n    for (; i + vlen <= len; i += vlen) {\n        svuint8_t vec = svld1_u8(pg, (uint8_t*)&s[i]);\n        svuint8_t shifted = svsub_u8_x(pg, vec, svdup_u8(5));\n        svuint8_t mod = svsub_u8_x(pg, shifted, svdup_u8('a'));\n        mod = svmod_u8_x(pg, mod, svdup_u8(26));\n        svuint8_t result = svadd_u8_x(pg, mod, svdup_u8('a'));\n        svst1_u8(pg, (uint8_t*)&out[i], result);\n    }\n    \n    for (; i < len; i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out[i] = (char)w;\n    }\n    \n    return out;\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    svbool_t pg = svptrue_b32();\n    svint32_t threshold = svdup_s32(t);\n    bool all_below = true;\n\n    for (size_t i = 0; i < l.size(); i += svcntw()) {\n        svbool_t active = svwhilelt_b32(i, l.size());\n        svint32_t vec = svld1_s32(active, &l[i]);\n        svbool_t cmp = svcmplt_s32(active, vec, threshold);\n        if (!svptest_all(active, cmp)) {\n            all_below = false;\n            break;\n        }\n    }\n\n    return all_below;\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    svbool_t pg = svptrue_b32();\n    svint32_t threshold = svdup_s32(t);\n    bool all_below = true;\n    \n    size_t i = 0;\n    size_t len = l.size();\n    \n    for (; i + svcntw() <= len; i += svcntw()) {\n        svint32_t vec = svld1_s32(pg, &l[i]);\n        svbool_t cmp = svcmplt_s32(pg, vec, threshold);\n        if (!svptest_all_true(pg, cmp)) {\n            all_below = false;\n            break;\n        }\n    }\n    \n    for (; i < len; i++) {\n        if (l[i] >= t) {\n            all_below = false;\n            break;\n        }\n    }\n    \n    return all_below;\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    size_t len = l.size();\n    const int *data = l.data();\n    svbool_t pg = svptrue_b32();\n    svint32_t threshold = svdup_s32(t);\n    bool all_below = true;\n\n    for (size_t i = 0; i < len; i += svcntw()) {\n        svbool_t active = svwhilelt_b32(i, len);\n        svint32_t vec = svld1_s32(active, data + i);\n        svbool_t cmp = svcmplt_s32(active, vec, threshold);\n        if (!svptest_all(cmp)) {\n            all_below = false;\n            break;\n        }\n    }\n\n    return all_below;\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    svbool_t pg = svptrue_b32();\n    svint32_t threshold = svdup_s32(t);\n    bool all_below = true;\n    \n    for (size_t i = 0; i < l.size(); i += svcntw()) {\n        svbool_t active = svwhilelt_b32(i, l.size());\n        svint32_t vec = svld1_s32(active, &l[i]);\n        svbool_t cmp = svcmplt_s32(active, vec, threshold);\n        all_below = all_below && svptest_any(pg, cmp);\n    }\n    \n    return all_below;\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    size_t len = l.size();\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, len);\n    \n    while (i < len) {\n        svint32_t vec = svld1(pg, &l[i]);\n        svbool_t cmp = svcmplt_s32(pg, vec, svdup_s32(t));\n        \n        if (!svptest_all(cmp)) {\n            return false;\n        }\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, len);\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int64_t count = 0;\n    svbool_t pg = svwhilelt_b8(0, brackets.size());\n    svint64_t vcount = svdup_s64(0);\n\n    for (size_t i = 0; i < brackets.size(); i += svcntb()) {\n        pg = svwhilelt_b8(i, brackets.size());\n        svuint8_t vdata = svld1_u8(pg, (uint8_t*)&brackets[i]);\n        \n        svbool_t is_open = svcmpeq_u8(pg, vdata, '<');\n        svbool_t is_close = svcmpeq_u8(pg, vdata, '>');\n        \n        vcount = svadd_m(pg, vcount, svsel_s64(is_open, svdup_s64(1), svdup_s64(0)));\n        vcount = svsub_m(pg, vcount, svsel_s64(is_close, svdup_s64(1), svdup_s64(0)));\n        \n        svint64_t min_count = svminv_s64(pg, vcount);\n        if (svlastb_s64(pg, min_count) < 0) {\n            return false;\n        }\n    }\n\n    count = svlastb_s64(pg, svred_s64(pg, vcount));\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t len = brackets.length();\n    if (len == 0) return true;\n    if (len % 2 != 0) return false;\n\n    svbool_t pg = svwhilelt_b8(0, len);\n    svint32_t count = svdup_s32(0);\n    int32_t scalar_count = 0;\n\n    const char* data = brackets.c_str();\n    \n    while (len > 0) {\n        size_t vl = svcntb();\n        if (len < vl) {\n            pg = svwhilelt_b8(0, len);\n        }\n\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)data);\n        \n        svbool_t is_open = svcmpeq_n_u8(pg, chars, '<');\n        svbool_t is_close = svcmpeq_n_u8(pg, chars, '>');\n        \n        svint32_t open_inc = svdup_s32(1);\n        svint32_t close_inc = svdup_s32(-1);\n        \n        count = svsel_s32(is_open, svadd_n_s32_x(pg, count, 1), count);\n        count = svsel_s32(is_close, svsub_n_s32_x(pg, count, 1), count);\n        \n        svbool_t negative = svcmplt_n_s32(pg, count, 0);\n        if (svptest_any(pg, negative)) {\n            return false;\n        }\n\n        data += vl;\n        len -= vl;\n        if (len > 0) {\n            pg = svwhilelt_b8(0, len);\n        }\n    }\n\n    scalar_count = svaddv_s32(svptrue_b32(), count);\n    return scalar_count == 0;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool correct_bracketing_simd(std::string brackets) {\n    const char *str = brackets.c_str();\n    size_t len = brackets.length();\n    int32_t count = 0;\n    svbool_t pg = svwhilelt_b8(0, len);\n    \n    while (len > 0) {\n        // Load chunk of string\n        svint8_t chars = svld1_s8(pg, (int8_t*)str);\n        \n        // Create predicates for '<' and '>'\n        svbool_t is_open = svcmpeq_n_s8(pg, chars, '<');\n        svbool_t is_close = svcmpeq_n_s8(pg, chars, '>');\n        \n        // Count open and close brackets\n        int open_count = svcntp_b8(pg, is_open);\n        int close_count = svcntp_b8(pg, is_close);\n        \n        count += open_count - close_count;\n        \n        // Early exit if count becomes negative\n        if (count < 0) return false;\n        \n        // Move to next chunk\n        size_t processed = svcntb();\n        str += processed;\n        len -= processed;\n        pg = svwhilelt_b8(str - brackets.c_str(), brackets.length());\n    }\n    \n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int64_t count = 0;\n    svbool_t pg = svwhilelt_b8(0, brackets.size());\n    \n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t vec = svld1_u8(pg, (uint8_t*)brackets.data());\n        svbool_t is_open = svcmpeq_u8(pg, vec, '<');\n        svbool_t is_close = svcmpeq_u8(pg, vec, '>');\n        \n        int64_t open_count = svcntp_b8(pg, is_open);\n        int64_t close_count = svcntp_b8(pg, is_close);\n        \n        count += open_count - close_count;\n        if (count < 0) return false;\n        \n        brackets = brackets.substr(svcntb());\n        pg = svwhilelt_b8(0, brackets.size());\n    }\n    \n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    const char* str = brackets.c_str();\n    size_t len = brackets.length();\n    int32_t count = 0;\n    svbool_t pg = svptrue_b8();\n\n    for (size_t i = 0; i < len; i += svcntb()) {\n        size_t remaining = len - i;\n        svbool_t pg_loop = svwhilelt_b8(i, len);\n        \n        svint8_t vec = svld1_s8(pg_loop, &str[i]);\n        svbool_t is_open = svcmpeq_n_s8(pg_loop, vec, '<');\n        svbool_t is_close = svcmpeq_n_s8(pg_loop, vec, '>');\n        \n        count += svcntp_b8(pg_loop, is_open);\n        count -= svcntp_b8(pg_loop, is_close);\n        \n        if (count < 0) {\n            return false;\n        }\n    }\n\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int64_t count = 0;\n    svbool_t pg = svwhilelt_b8(0, brackets.size());\n    \n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t vec = svld1_u8(pg, (const uint8_t*)brackets.data());\n        svbool_t is_open = svcmpeq_u8(pg, vec, '(');\n        svbool_t is_close = svcmpeq_u8(pg, vec, ')');\n        \n        count += svcntp_b8(pg, is_open);\n        count -= svcntp_b8(pg, is_close);\n        \n        if (count < 0) return false;\n        \n        brackets.erase(0, svcntp_b8(pg, svptrue_b8()));\n        pg = svwhilelt_b8(0, brackets.size());\n    }\n    \n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t len = brackets.size();\n    if (len == 0) return true;\n    \n    svbool_t pg = svwhilelt_b8(0, len);\n    svuint8_t vec = svld1_u8(pg, (const uint8_t*)brackets.c_str());\n    \n    svbool_t is_open = svcmpeq_u8(pg, vec, '(');\n    svbool_t is_close = svcmpeq_u8(pg, vec, ')');\n    \n    int32_t open_count = svcntp_b8(pg, is_open);\n    int32_t close_count = svcntp_b8(pg, is_close);\n    \n    if (open_count != close_count) return false;\n    \n    int32_t running_sum = 0;\n    uint64_t i = 0;\n    \n    while (i < len) {\n        pg = svwhilelt_b8(i, len);\n        vec = svld1_u8(pg, (const uint8_t*)(brackets.c_str() + i));\n        \n        svbool_t open_mask = svcmpeq_u8(pg, vec, '(');\n        svbool_t close_mask = svcmpeq_u8(pg, vec, ')');\n        \n        int32_t opens = svcntp_b8(pg, open_mask);\n        int32_t closes = svcntp_b8(pg, close_mask);\n        \n        running_sum += opens;\n        running_sum -= closes;\n        \n        if (running_sum < 0) return false;\n        \n        i += svcntb();\n    }\n    \n    return running_sum == 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t len = brackets.length();\n    if (len == 0) return true;\n    if (len % 2 != 0) return false;\n\n    // Get vector length\n    uint64_t vlen = svcntb();\n    svbool_t pg = svwhilelt_b8(0, len);\n    \n    // Initialize counter for brackets\n    int32_t count = 0;\n    svint32_t v_count = svdup_s32(0);\n    \n    // Process string in vector chunks\n    size_t i = 0;\n    for (; i + vlen <= len; i += vlen) {\n        pg = svwhilelt_b8(i, len);\n        \n        // Load chunk of string\n        svuint8_t v_brackets = svld1_u8(pg, (uint8_t*)&brackets[i]);\n        \n        // Compare for '(' and ')'\n        svbool_t is_open = svcmpeq_u8(pg, v_brackets, '(');\n        svbool_t is_close = svcmpeq_u8(pg, v_brackets, ')');\n        \n        // Increment/decrement counter vector\n        v_count = svadd_m(pg, v_count, svand_z(pg, svdup_s32(1), is_open));\n        v_count = svsub_m(pg, v_count, svand_z(pg, svdup_s32(1), is_close));\n        \n        // Check for negative count (invalid sequence)\n        svbool_t neg = svcmplt_s32(pg, v_count, 0);\n        if (svptest_any(svptrue_b32(), neg)) return false;\n    }\n    \n    // Reduce vector count to scalar\n    count = svaddv_s32(svptrue_b32(), v_count);\n    \n    // Process remaining elements sequentially\n    for (; i < len; i++) {\n        if (brackets[i] == '(') count++;\n        else count--;\n        if (count < 0) return false;\n    }\n    \n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int64_t len = brackets.length();\n    if (len == 0) return true;\n    if (len % 2 != 0) return false;\n\n    svbool_t ptrue = svptrue_b8();\n    int64_t count = 0;\n    int64_t i = 0;\n    svint32_t count_vec = svdup_s32(0);\n\n    while (i < len) {\n        svbool_t pg = svwhilelt_b8(i, len);\n        svuint8_t chars = svld1_u8(pg, (uint8_t*)&brackets[i]);\n\n        svbool_t is_open = svcmpeq_u8(pg, chars, '(');\n        svbool_t is_close = svcmpeq_u8(pg, chars, ')');\n\n        int32_t open_count = svcntp_b8(pg, is_open);\n        int32_t close_count = svcntp_b8(pg, is_close);\n\n        count += open_count - close_count;\n        if (count < 0) return false;\n\n        i += svcntb();\n    }\n\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int64_t count = 0;\n    size_t len = brackets.length();\n    size_t i = 0;\n\n    // Process scalar remainder if length is not multiple of vector length\n    svbool_t pg = svwhilelt_b8(i, len);\n    size_t vlen = svcntb();\n\n    while (i + vlen <= len) {\n        // Load vector of characters\n        svuint8_t vec = svld1_u8(pg, (uint8_t*)&brackets[i]);\n        \n        // Compare for '(' and ')'\n        svbool_t is_open = svcmpeq_n_u8(pg, vec, '(');\n        svbool_t is_close = svcmpeq_n_u8(pg, vec, ')');\n        \n        // Count opening and closing brackets\n        count += svcntp_b8(pg, is_open);\n        count -= svcntp_b8(pg, is_close);\n        \n        // Early exit if count becomes negative\n        if (count < 0) return false;\n        \n        i += vlen;\n        pg = svwhilelt_b8(i, len);\n    }\n\n    // Handle remaining elements scalarly\n    for (; i < len; i++) {\n        if (brackets[i] == '(') count++;\n        else if (brackets[i] == ')') count--;\n        if (count < 0) return false;\n    }\n\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    std::vector<float> result(xs.size() - 1);\n    if (xs.size() <= 1) return result;\n\n    svfloat32_t coeffs, result_vec;\n    svbool_t pg = svptrue_b32();\n    int64_t vector_length = svcntw();\n    int64_t i;\n\n    for (i = 0; i <= xs.size() - 1 - vector_length; i += vector_length) {\n        coeffs = svld1(pg, &xs[i + 1]);\n        svfloat32_t indices = svindex_f32((float)(i + 1), 1.0f);\n        result_vec = svmul_f32_x(pg, coeffs, indices);\n        svst1(pg, &result[i], result_vec);\n    }\n\n    for (; i < xs.size() - 1; i++) {\n        result[i] = xs[i + 1] * (i + 1);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    std::vector<float> result(xs.size() - 1);\n    if (xs.size() <= 1) return result;\n\n    svfloat32_t coeffs, deriv;\n    svbool_t pg = svptrue_b32();\n    int i = 0;\n    int n = xs.size() - 1;\n\n    // Process coefficients in chunks\n    for (; i <= n - svcntw(); i += svcntw()) {\n        // Load indices for multiplication\n        svfloat32_t indices = svindex_f32(i, 1);\n        // Load polynomial coefficients\n        coeffs = svld1_f32(pg, xs.data() + i + 1);\n        // Compute derivative: (n * x^{n-1})\n        deriv = svmul_f32_x(pg, coeffs, indices);\n        // Store results\n        svst1_f32(pg, result.data() + i, deriv);\n    }\n\n    // Handle remaining elements\n    if (i < n) {\n        svbool_t mask = svwhilelt_b32(i, n);\n        svfloat32_t indices = svindex_f32(i, 1);\n        coeffs = svld1_f32(mask, xs.data() + i + 1);\n        deriv = svmul_f32_x(mask, coeffs, indices);\n        svst1_f32(mask, result.data() + i, deriv);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    std::vector<float> result(xs.size() - 1);\n    if (xs.size() <= 1) return result;\n\n    svbool_t pg = svptrue_b32();\n    uint64_t vlen = svcntw();\n    std::vector<float> indices(vlen);\n    for (uint64_t i = 0; i < vlen; i++) indices[i] = i + 1;\n\n    svfloat32_t idx_vec = svld1_f32(pg, indices.data());\n    for (size_t i = 0; i < result.size(); i += vlen) {\n        svbool_t mask = svwhilelt_b32(i, result.size());\n        svfloat32_t coeffs = svld1_f32(mask, xs.data() + i + 1);\n        svfloat32_t deriv = svmul_f32_x(mask, coeffs, idx_vec);\n        svst1_f32(mask, result.data() + i, deriv);\n        idx_vec = svadd_f32_x(pg, idx_vec, svdup_f32(vlen));\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    std::vector<float> result(xs.size() - 1);\n    if (xs.size() <= 1) return result;\n\n    svfloat32_t coeffs = svld1_f32(svptrue_b32(), xs.data());\n    svfloat32_t indices = svindex_f32(0, 1);\n    svfloat32_t deriv = svmul_f32_x(svptrue_b32(), coeffs, indices);\n\n    svfloat32_t shifted = svext_f32(deriv, deriv, 1);\n    svst1_f32(svptrue_b32(), result.data(), shifted);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    std::vector<float> result(xs.size() - 1);\n    if (xs.size() <= 1) return result;\n\n    svbool_t pg = svptrue_b32();\n    uint64_t vlen = svcntw();\n    std::vector<float> indices(xs.size());\n\n    for (size_t i = 0; i < xs.size(); i++) {\n        indices[i] = static_cast<float>(i);\n    }\n\n    for (size_t i = 0; i < result.size(); i += vlen) {\n        svfloat32_t idx_vec = svld1_f32(pg, &indices[i + 1]);\n        svfloat32_t coeff_vec = svld1_f32(pg, &xs[i + 1]);\n        svfloat32_t deriv_vec = svmul_f32_x(pg, idx_vec, coeff_vec);\n        svst1_f32(pg, &result[i], deriv_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    const char *str = s.c_str();\n    int len = s.length();\n    int vowel_count = 0;\n    \n    // Vowel lookup table (a, e, i, o, u)\n    svuint8_t vowels = svdup_u8(0);\n    vowels = svtbl(vowels, svdup_u8('a'), svdup_u8(1));\n    vowels = svtbl(vowels, svdup_u8('e'), svdup_u8(1));\n    vowels = svtbl(vowels, svdup_u8('i'), svdup_u8(1));\n    vowels = svtbl(vowels, svdup_u8('o'), svdup_u8(1));\n    vowels = svtbl(vowels, svdup_u8('u'), svdup_u8(1));\n    \n    // Process string in vector-sized chunks\n    svbool_t pg = svwhilelt_b8(0, len);\n    int i = 0;\n    \n    while (svptest_any(svptrue_b8(), pg)) {\n        // Load string chunk\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)(str + i));\n        \n        // Convert to lowercase\n        svbool_t is_upper = svcmplt_u8(pg, chars, svdup_u8('a'));\n        svuint8_t lower = svsub_u8_x(pg, chars, svdup_u8(32));\n        chars = svsel_u8(is_upper, lower, chars);\n        \n        // Check for vowels\n        svuint8_t is_vowel = svtbl(vowels, chars);\n        vowel_count += svcntp_b8(pg, svcmpeq_u8(pg, is_vowel, svdup_u8(1)));\n        \n        i += svcntb();\n        pg = svwhilelt_b8(i, len);\n    }\n    \n    // Handle 'y' at the end\n    if (len > 0 && (str[len-1] == 'y' || str[len-1] == 'Y')) {\n        vowel_count++;\n    }\n    \n    return vowel_count;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint vowels_count_simd(std::string s) {\n    const char *str = s.c_str();\n    int len = s.length();\n    int vowel_count = 0;\n    \n    // Vowel lookup table (a, e, i, o, u, y)\n    const char vowels[] = {'a', 'e', 'i', 'o', 'u', 'y'};\n    svbool_t pg = svwhilelt_b8(0, len);\n    \n    // Process string in vector chunks\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)str);\n        \n        // Check each character against vowels\n        for (int i = 0; i < 6; i++) {\n            svbool_t match = svcmpeq_u8(pg, chars, svdup_u8(vowels[i]));\n            vowel_count += svcntp_b8(pg, match);\n        }\n        \n        str += svcntb();\n        pg = svwhilelt_b8(str - s.c_str(), len);\n    }\n    \n    // Handle 'y' at the end separately\n    if (len > 0 && (s[len-1] == 'y' || s[len-1] == 'Y')) {\n        vowel_count++;\n    }\n    \n    return vowel_count;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    const char* str = s.c_str();\n    int len = s.length();\n    int vowel_count = 0;\n    \n    // Vowel masks for 'a', 'e', 'i', 'o', 'u'\n    svuint8_t vowels_a = svdup_u8('a');\n    svuint8_t vowels_A = svdup_u8('A');\n    svuint8_t vowels_e = svdup_u8('e');\n    svuint8_t vowels_E = svdup_u8('E');\n    svuint8_t vowels_i = svdup_u8('i');\n    svuint8_t vowels_I = svdup_u8('I');\n    svuint8_t vowels_o = svdup_u8('o');\n    svuint8_t vowels_O = svdup_u8('O');\n    svuint8_t vowels_u = svdup_u8('u');\n    svuint8_t vowels_U = svdup_u8('U');\n    \n    svbool_t pg = svwhilelt_b8(0, len);\n    int i = 0;\n    \n    while (i < len) {\n        // Load string chunk\n        svuint8_t str_vec = svld1_u8(pg, (const uint8_t*)(str + i));\n        \n        // Check for vowels\n        svbool_t is_vowel = svorr_b_z(pg,\n            svorr_b_z(pg,\n                svorr_b_z(pg,\n                    svorr_b_z(pg,\n                        svcmpeq_u8(pg, str_vec, vowels_a),\n                        svcmpeq_u8(pg, str_vec, vowels_A)\n                    ),\n                    svorr_b_z(pg,\n                        svcmpeq_u8(pg, str_vec, vowels_e),\n                        svcmpeq_u8(pg, str_vec, vowels_E)\n                    )\n                ),\n                svorr_b_z(pg,\n                    svorr_b_z(pg,\n                        svcmpeq_u8(pg, str_vec, vowels_i),\n                        svcmpeq_u8(pg, str_vec, vowels_I)\n                    ),\n                    svorr_b_z(pg,\n                        svorr_b_z(pg,\n                            svcmpeq_u8(pg, str_vec, vowels_o),\n                            svcmpeq_u8(pg, str_vec, vowels_O)\n                        ),\n                        svorr_b_z(pg,\n                            svcmpeq_u8(pg, str_vec, vowels_u),\n                            svcmpeq_u8(pg, str_vec, vowels_U)\n                        )\n                    )\n                )\n            ),\n            svpfalse()\n        );\n        \n        // Count matches\n        vowel_count += svcntp_b8(pg, is_vowel);\n        \n        // Advance index\n        i += svcntb();\n        pg = svwhilelt_b8(i, len);\n    }\n    \n    // Check if 'y' or 'Y' is at the end\n    if (len > 0 && (str[len-1] == 'y' || str[len-1] == 'Y')) {\n        vowel_count++;\n    }\n    \n    return vowel_count;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint vowels_count_simd(std::string s) {\n    const char* str = s.c_str();\n    int len = s.length();\n    svbool_t pg = svwhilelt_b8(0, len);\n    int vowel_count = 0;\n    \n    // Vowel masks for 'a', 'e', 'i', 'o', 'u'\n    svuint8_t vowels = svdup_u8(0);\n    vowels = svorr_u8_m(pg, vowels, svcmpeq_u8(pg, svdup_u8('a'), svdup_u8('a')));\n    vowels = svorr_u8_m(pg, vowels, svcmpeq_u8(pg, svdup_u8('e'), svdup_u8('e')));\n    vowels = svorr_u8_m(pg, vowels, svcmpeq_u8(pg, svdup_u8('i'), svdup_u8('i')));\n    vowels = svorr_u8_m(pg, vowels, svcmpeq_u8(pg, svdup_u8('o'), svdup_u8('o')));\n    vowels = svorr_u8_m(pg, vowels, svcmpeq_u8(pg, svdup_u8('u'), svdup_u8('u')));\n    \n    // Convert string to lowercase for case-insensitive comparison\n    svuint8_t input = svld1_u8(pg, (const uint8_t*)str);\n    svuint8_t to_lower = svsub_u8_x(pg, input, svdup_u8(32));\n    svbool_t is_upper = svcmplt_u8(pg, input, svdup_u8('Z'));\n    svbool_t is_letter = svcmpge_u8(pg, input, svdup_u8('A'));\n    is_letter = svand_b_z(pg, is_letter, is_upper);\n    input = svsel_u8(is_letter, to_lower, input);\n    \n    // Count vowels\n    svbool_t is_vowel = svcmpeq_u8(pg, input, vowels);\n    vowel_count += svcntp_b8(pg, is_vowel);\n    \n    // Check if 'y' is at the end\n    if (len > 0 && (str[len-1] == 'y' || str[len-1] == 'Y')) {\n        vowel_count++;\n    }\n    \n    return vowel_count;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    int count = 0;\n    const char *str = s.c_str();\n    size_t len = s.length();\n    svbool_t pg = svwhilelt_b8(0, len);\n    \n    // Vowel masks for 'a', 'e', 'i', 'o', 'u'\n    svuint8_t vowels_a = svdup_u8('a');\n    svuint8_t vowels_e = svdup_u8('e');\n    svuint8_t vowels_i = svdup_u8('i');\n    svuint8_t vowels_o = svdup_u8('o');\n    svuint8_t vowels_u = svdup_u8('u');\n    \n    // Process string in vector-sized chunks\n    size_t i = 0;\n    for (; i < len && svptest_any(svptrue_b8(), pg); i += svcntb()) {\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)(str + i));\n        \n        // Convert to lowercase for case-insensitive comparison\n        svuint8_t is_upper = svcmplt_u8(pg, chars, svdup_u8('a'));\n        svuint8_t to_lower = svadd_u8_x(pg, chars, svdup_u8(32));\n        svuint8_t chars_lower = svsel_u8(is_upper, chars, to_lower);\n        \n        // Check for each vowel\n        svbool_t is_a = svcmpeq_u8(pg, chars_lower, vowels_a);\n        svbool_t is_e = svcmpeq_u8(pg, chars_lower, vowels_e);\n        svbool_t is_i = svcmpeq_u8(pg, chars_lower, vowels_i);\n        svbool_t is_o = svcmpeq_u8(pg, chars_lower, vowels_o);\n        svbool_t is_u = svcmpeq_u8(pg, chars_lower, vowels_u);\n        \n        // Combine vowel matches\n        svbool_t is_vowel = svorr_b_z(pg, is_a, is_e);\n        is_vowel = svorr_b_z(pg, is_vowel, is_i);\n        is_vowel = svorr_b_z(pg, is_vowel, is_o);\n        is_vowel = svorr_b_z(pg, is_vowel, is_u);\n        \n        count += svcntp_b8(pg, is_vowel);\n        \n        pg = svwhilelt_b8(i + svcntb(), len);\n    }\n    \n    // Handle 'y' at the end of string\n    if (len > 0 && (s[len-1] == 'y' || s[len-1] == 'Y')) {\n        count++;\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint digitSum_simd(std::string s) {\n    const char* str = s.c_str();\n    int64_t sum = 0;\n    svbool_t pg = svwhilelt_b8(0, s.length());\n    \n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t vec = svld1_u8(pg, (const uint8_t*)str);\n        svbool_t is_upper = svcmplt_u8(pg, svdup_u8('A'-1), vec);\n        is_upper = svand_b_z(pg, is_upper, svcmplt_u8(pg, vec, svdup_u8('Z'+1)));\n        svuint8_t upper_chars = svsel_u8(is_upper, vec, svdup_u8(0));\n        sum += svaddv_u8(pg, upper_chars);\n        str += svcntb();\n        pg = svwhilelt_b8((uint64_t)(str - s.c_str()), s.length());\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint digitSum_simd(std::string s) {\n    const char* str = s.c_str();\n    int64_t sum = 0;\n    svbool_t pg = svptrue_b8();\n    svuint8_t upper_mask = svdup_u8(0xDF);\n    svuint8_t upper_bound = svdup_u8('Z');\n    svuint8_t lower_bound = svdup_u8('A');\n    \n    for (size_t i = 0; i < s.length(); i += svcntb()) {\n        svbool_t active = svwhilelt_b8(i, s.length());\n        svuint8_t chars = svld1_u8(active, (const uint8_t*)(str + i));\n        \n        // Convert to uppercase for comparison\n        svuint8_t chars_upper = svand_u8_x(pg, chars, upper_mask);\n        \n        // Check if characters are uppercase (A-Z)\n        svbool_t is_upper = svand_b_z(pg, \n            svcmple_u8(pg, chars_upper, upper_bound),\n            svcmpge_u8(pg, chars_upper, lower_bound));\n        \n        // Sum ASCII values of uppercase characters\n        svuint8_t valid_chars = svsel_u8(is_upper, chars, svdup_u8(0));\n        sum += svaddv_u8(pg, valid_chars);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nint digitSum_simd(std::string s) {\n    const char* str = s.c_str();\n    int64_t sum = 0;\n    svbool_t pg = svwhilelt_b8(0, s.length());\n    \n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t vec = svld1_u8(pg, (const uint8_t*)str);\n        svbool_t is_upper = svcmple_n_u8(pg, vec, 'A');\n        is_upper = svand_b_z(svptrue_b8(), is_upper, svcmpge_n_u8(pg, vec, 'Z'));\n        \n        svuint64_t ascii_vals = svsel(is_upper, svmov_n_u64_z(pg, vec), svmov_n_u64(0));\n        sum += svaddv_u64(pg, ascii_vals);\n        \n        str += svcntb();\n        pg = svwhilelt_b8(s.length() - (str - s.c_str()), s.length());\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint digitSum_simd(std::string s) {\n    const char* str = s.c_str();\n    int len = s.length();\n    int sum = 0;\n    \n    svbool_t pg = svwhilelt_b8(0, len);\n    int i = 0;\n    \n    while (i < len) {\n        svint8_t vec = svld1_s8(pg, &str[i]);\n        svbool_t is_upper = svcmplt_s8(pg, svdup_s8('A' - 1), vec);\n        is_upper = svand_b_z(svptrue_b8(), is_upper, svcmplt_s8(pg, vec, svdup_s8('Z' + 1)));\n        \n        svint32_t ascii_vals = svsel_s32(svcvt_bf16_s32_m(svundef_bf16(), pg, is_upper),\n                                        svmovl_s32(pg, vec),\n                                        svdup_s32(0));\n        \n        sum += svaddv_s32(pg, ascii_vals);\n        \n        i += svcntb();\n        pg = svwhilelt_b8(i, len);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint digitSum_simd(std::string s) {\n    const char* str = s.c_str();\n    int64_t sum = 0;\n    svbool_t pg = svwhilelt_b8(0, s.length());\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t vec = svld1_u8(pg, (const uint8_t*)str);\n        svbool_t is_upper = svcmple_n_u8(pg, vec, 'A');\n        is_upper = svand_b_z(svptrue_b8(), is_upper, svcmple_n_u8(pg, vec, 'Z'));\n        svuint8_t masked_vec = svsel_u8(is_upper, vec, svdup_n_u8(0));\n        sum += svaddv_u8(pg, masked_vec);\n        str += svcntb();\n        pg = svwhilelt_b8(s.length() - (str - s.c_str()), s.length());\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n\n    svbool_t pg = svptrue_b32();\n    uint64_t vlen = svcntw();\n    int min_even = INT_MAX;\n    int min_idx = -1;\n    \n    for (size_t i = 0; i < arr.size(); i += vlen) {\n        svbool_t p = svwhilelt_b32(i, arr.size());\n        svint32_t vec = svld1_s32(p, &arr[i]);\n        \n        // Check for even numbers (value % 2 == 0)\n        svint32_t mod2 = svand_s32_z(p, vec, svdup_s32(1));\n        svbool_t even_mask = svcmpeq_s32(p, mod2, svdup_s32(0));\n        \n        // Create index vector\n        svint32_t indices = svindex_s32(i, 1);\n        \n        // Mask out odd numbers\n        svint32_t valid_vals = svsel_s32(even_mask, vec, svdup_s32(INT_MAX));\n        \n        // Find minimum even value\n        int local_min = svminv_s32(p, valid_vals);\n        \n        if (local_min < min_even) {\n            // Find indices where value equals local_min\n            svbool_t min_mask = svcmpeq_s32(p, valid_vals, svdup_s32(local_min));\n            svint32_t min_indices = svsel_s32(min_mask, indices, svdup_s32(INT_MAX));\n            \n            // Get minimum index\n            int local_min_idx = svminv_s32(p, min_indices);\n            \n            if (local_min < min_even || (local_min == min_even && local_min_idx < min_idx)) {\n                min_even = local_min;\n                min_idx = local_min_idx;\n            }\n        }\n    }\n\n    if (min_even == INT_MAX) return {};\n    return {min_even, min_idx};\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n\n    int64_t len = arr.size();\n    svbool_t pg = svwhilelt_b32(0, len);\n    svuint32_t indices = svindex_u32(0, 1);\n    svuint32_t values = svld1_u32(pg, arr.data());\n\n    // Create mask for even values\n    svuint32_t ones = svdup_u32(1);\n    svuint32_t is_even = svbic_u32_z(pg, values, ones);\n    svbool_t even_mask = svcmpeq_u32(pg, is_even, svdup_u32(0));\n\n    // If no even values, return empty\n    if (!svptest_any(pg, even_mask)) return {};\n\n    // Mask out odd values, set to max for min comparison\n    svuint32_t masked_values = svsel_u32(even_mask, values, svdup_u32(UINT32_MAX));\n    \n    // Find minimum even value\n    uint32_t min_val = svminv_u32(even_mask, masked_values);\n    \n    // Find indices where value equals min_val\n    svbool_t min_mask = svcmpeq_u32(pg, values, svdup_u32(min_val));\n    \n    // Get first index of minimum value\n    uint64_t first_idx = svcntp_b32(pg, min_mask);\n    svbool_t first_mask = svwhilelt_b32(0, first_idx);\n    uint32_t min_idx = svlastb_u32(first_mask, indices);\n\n    return {static_cast<int>(min_val), static_cast<int>(min_idx)};\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n\n    int64_t len = arr.size();\n    svbool_t pg = svwhilelt_b32(0, len);\n    svint32_t min_even = svdup_s32(INT32_MAX);\n    svint32_t min_idx = svdup_s32(-1);\n    svint32_t indices = svindex_s32(0, 1);\n    svbool_t even_mask = svptrue_b32();\n    svint32_t zero = svdup_s32(0);\n    \n    for (int64_t i = 0; i < len; i += svcntw()) {\n        pg = svwhilelt_b32(i, len);\n        svint32_t values = svld1_s32(pg, &arr[i]);\n        svbool_t is_even = svcmpeq_n_s32(pg, svand_s32_z(pg, values, svdup_s32(1)), zero);\n        svbool_t update_mask = svand_b_z(pg, is_even, svcmplt_s32(pg, values, min_even));\n        \n        min_even = svsel_s32(update_mask, values, min_even);\n        min_idx = svsel_s32(update_mask, svindex_s32(i, 1), min_idx);\n    }\n\n    int32_t min_val = svminv_s32(svptrue_b32(), min_even);\n    int32_t idx = svminv_s32(svptrue_b32(), min_idx);\n\n    if (min_val == INT32_MAX || (min_val & 1)) return {};\n    return {min_val, idx};\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n\n    int len = arr.size();\n    svbool_t pg = svwhilelt_b32(0, len);\n    svuint32_t indices = svindex_u32(0, 1);\n    svuint32_t values = svld1_u32(pg, arr.data());\n\n    svbool_t even_mask = svcmpeq_n_u32(pg, svand_n_u32_z(pg, values, 1), 0);\n    if (!svptest_any(pg, even_mask)) return {};\n\n    svuint32_t even_values = svsel_u32(even_mask, values, svdup_n_u32(UINT32_MAX));\n    svuint32_t even_indices = svsel_u32(even_mask, indices, svdup_n_u32(UINT32_MAX));\n\n    uint32_t min_value = UINT32_MAX;\n    uint32_t min_index = UINT32_MAX;\n    while (svptest_any(svptrue_b32(), pg)) {\n        uint32_t local_min = svminv_u32(pg, even_values);\n        svbool_t min_mask = svcmpeq_n_u32(pg, even_values, local_min);\n        uint32_t local_index = svminv_u32(svand_b_z(pg, min_mask, pg), even_indices);\n\n        if (local_min < min_value || (local_min == min_value && local_index < min_index)) {\n            min_value = local_min;\n            min_index = local_index;\n        }\n\n        pg = svbic_b_z(pg, pg, min_mask);\n        even_values = svsel_u32(min_mask, svdup_n_u32(UINT32_MAX), even_values);\n    }\n\n    return {static_cast<int>(min_value), static_cast<int>(min_index)};\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n\n    int64_t len = arr.size();\n    svbool_t pg = svwhilelt_b32(0, len);\n    svint32_t min_even = svdup_s32(INT32_MAX);\n    svint32_t min_idx = svdup_s32(-1);\n    svint32_t indices = svindex_s32(0, 1);\n    svbool_t even_mask = svptrue_b32();\n    \n    for (int64_t i = 0; i < len; i += svcntw()) {\n        pg = svwhilelt_b32(i, len);\n        svint32_t values = svld1_s32(pg, &arr[i]);\n        \n        // Check for even numbers (value % 2 == 0)\n        svbool_t is_even = svcmpeq_n_s32(pg, svand_s32_z(pg, values, 1), 0);\n        \n        // Update min_even and min_idx for even values\n        svbool_t lt_min = svcmplt_s32(pg, values, min_even);\n        lt_min = svand_b_z(pg, lt_min, is_even);\n        \n        min_even = svsel_s32(lt_min, values, min_even);\n        min_idx = svsel_s32(lt_min, indices, min_idx);\n        \n        indices = svadd_s32_z(pg, indices, svdup_s32(svcntw()));\n    }\n    \n    // Reduce to find minimum even value and its index\n    int32_t final_min = svminv_s32(pg, min_even);\n    int32_t final_idx = svminv_s32(pg, min_idx);\n    \n    // Check if we found any even numbers\n    if (final_min == INT32_MAX) return {};\n    \n    return {final_min, final_idx};\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint search_simd(std::vector<int> lst) {\n    int max_val = 0;\n    for (int x : lst) {\n        if (x > max_val) max_val = x;\n    }\n    \n    // Create frequency array\n    std::vector<int> freq(max_val + 1, 0);\n    \n    // Count frequencies using SVE\n    svbool_t pg = svwhilelt_b32(0, lst.size());\n    for (size_t i = 0; i < lst.size();) {\n        svint32_t vec = svld1_s32(pg, lst.data() + i);\n        while (svptest_any(svptrue_b32(), pg)) {\n            int idx = svlastb_s32(pg, vec);\n            if (idx <= max_val) {\n                freq[idx]++;\n            }\n            pg = svwhilelt_b32(i += svcntw(), lst.size());\n            vec = svld1_s32(pg, lst.data() + i);\n        }\n    }\n    \n    // Find valid number with frequency >= value\n    int result = -1;\n    svbool_t pg_freq = svwhilelt_b32(1, max_val + 1);\n    svint32_t vec_freq = svld1_s32(pg_freq, freq.data() + 1);\n    svint32_t vec_idx = svindex_s32(1, 1);\n    \n    while (svptest_any(svptrue_b32(), pg_freq)) {\n        svbool_t cmp = svcmpge_s32(pg_freq, vec_freq, vec_idx);\n        int32_t valid = svlastb_s32(cmp, vec_idx);\n        if (valid > result) result = valid;\n        \n        pg_freq = svwhilelt_b32(svlastb_s32(pg_freq, vec_idx) + 1, max_val + 1);\n        vec_freq = svld1_s32(pg_freq, freq.data() + svlastb_s32(pg_freq, vec_idx) + 1);\n        vec_idx = svindex_s32(svlastb_s32(pg_freq, vec_idx) + 1, 1);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint search_simd(std::vector<int> lst) {\n    int max_val = 0;\n    for (int x : lst) {\n        if (x > max_val) max_val = x;\n    }\n    \n    // Create frequency array\n    std::vector<int> freq(max_val + 1, 0);\n    \n    // Count frequencies using SVE\n    svbool_t pg = svwhilelt_b32(0, lst.size());\n    for (size_t i = 0; i < lst.size();) {\n        svint32_t vec = svld1_s32(pg, &lst[i]);\n        while (svptest_any(svptrue_b32(), pg)) {\n            int32_t idx = svlastb_s32(pg, vec);\n            if (idx >= 0 && idx <= max_val) {\n                freq[idx]++;\n            }\n            pg = svwhilelt_b32(i + svcntw(), lst.size());\n            i += svcntw();\n            vec = svld1_s32(pg, &lst[i]);\n        }\n    }\n    \n    // Find valid number using SVE\n    int result = -1;\n    svbool_t pg_freq = svwhilelt_b32(0, max_val + 1);\n    svint32_t vec_freq = svld1_s32(pg_freq, freq.data());\n    svint32_t vec_idx = svindex_s32(0, 1);\n    \n    svbool_t mask = svcmpge_s32(pg_freq, vec_freq, vec_idx);\n    svint32_t valid_nums = svsel_s32(mask, vec_idx, svdup_s32(-1));\n    \n    result = svlastb_s32(pg_freq, valid_nums);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint search_simd(std::vector<int> lst) {\n    // Assume max input value is reasonable (e.g., 100)\n    const int MAX_VALUE = 100;\n    svuint32_t freq = svdup_n_u32(0);\n    svbool_t ptrue = svptrue_b32();\n    \n    // Count frequencies\n    for (size_t i = 0; i < lst.size(); i++) {\n        int val = lst[i];\n        if (val >= MAX_VALUE) continue;\n        \n        svbool_t pg = svptrue_b32();\n        svuint32_t idx = svindex_u32(0, 1);\n        svbool_t cmp = svcmpeq_u32(pg, idx, val);\n        freq = svadd_m(cmp, freq, svdup_n_u32(1));\n    }\n    \n    // Find valid values where frequency >= value\n    int max_valid = -1;\n    svuint32_t idx = svindex_u32(1, 1); // Start from 1\n    svbool_t valid = svcmpge_u32(ptrue, freq, idx);\n    \n    // Get maximum valid value\n    while (svptest_any(ptrue, valid)) {\n        uint32_t candidate = svlastb_u32(valid, idx);\n        if (candidate < MAX_VALUE && svlastb_u32(valid, freq) >= candidate) {\n            max_valid = candidate;\n        }\n        valid = svand_z(ptrue, valid, svcmplt_u32(ptrue, idx, candidate));\n    }\n    \n    return max_valid;\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint search_simd(std::vector<int> lst) {\n    int max_val = 0;\n    for (int x : lst) {\n        if (x > max_val) max_val = x;\n    }\n    \n    // Create frequency array using SVE\n    std::vector<int> freq(max_val + 1, 0);\n    svbool_t pg = svwhilelt_b32(0, (uint32_t)lst.size());\n    \n    for (size_t i = 0; i < lst.size(); i += svcntw()) {\n        pg = svwhilelt_b32(i, (uint32_t)lst.size());\n        svuint32_t indices = svindex_u32(i, 1);\n        svuint32_t values = svld1_u32(pg, &lst[i]);\n        \n        // Update frequencies using gather\n        for (int j = 0; j < svcntw(); j++) {\n            if (i + j >= lst.size()) break;\n            int val = lst[i + j];\n            if (val <= max_val) {\n                freq[val]++;\n            }\n        }\n    }\n    \n    // Find valid numbers where frequency >= value\n    int result = -1;\n    svbool_t pg_freq = svwhilelt_b32(1, max_val + 1);\n    svuint32_t idx = svindex_u32(1, 1);\n    \n    while (svptest_any(svptrue_b32(), pg_freq)) {\n        svuint32_t freq_vec = svld1_u32(pg_freq, &freq[1]);\n        svbool_t valid = svcmpge_u32(pg_freq, freq_vec, idx);\n        \n        // Find maximum valid number\n        uint64_t mask = svcntp_b32(pg_freq, valid);\n        if (mask) {\n            svuint32_t valid_nums = svsel_u32(valid, idx, svdup_u32(0));\n            uint32_t max_valid = svmaxv_u32(pg_freq, valid_nums);\n            if (max_valid > result) result = max_valid;\n        }\n        \n        idx = svadd_u32_x(svptrue_b32(), idx, svdup_u32(svcntw()));\n        pg_freq = svwhilelt_b32(svmaxv_u32(svptrue_b32(), idx), max_val + 1);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nint search_simd(std::vector<int> lst) {\n    int max_val = 0;\n    for (int x : lst) {\n        if (x > max_val) max_val = x;\n    }\n    \n    // Create frequency array using scalar code for simplicity\n    std::vector<int> freq(max_val + 1, 0);\n    for (int x : lst) {\n        freq[x]++;\n    }\n    \n    int result = -1;\n    svbool_t pg = svptrue_b32();\n    \n    // Process frequency array in vector-sized chunks\n    for (size_t i = 1; i <= max_val; i += svcntw()) {\n        // Create index vector\n        svint32_t indices = svindex_s32(i, 1);\n        \n        // Load frequencies\n        svint32_t frequencies = svld1_s32(pg, &freq[i]);\n        \n        // Compare frequency >= value\n        svbool_t mask = svcmpge_s32(pg, frequencies, indices);\n        \n        // Find maximum valid value\n        if (svptest_any(pg, mask)) {\n            svint32_t valid_indices = svsel_s32(mask, indices, svdup_s32(-1));\n            int32_t max_valid = svmaxv_s32(pg, valid_indices);\n            if (max_valid > result) {\n                result = max_valid;\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t vec = svld1_s32(pg, q.data());\n\n    // Check sum <= w\n    int32_t sum = svaddv_s32(pg, vec);\n    if (sum > w) return false;\n\n    // Check if palindromic\n    int half = n / 2;\n    svbool_t pg_half = svwhilelt_b32(0, half);\n    \n    // Load first half\n    svint32_t first_half = svld1_s32(pg_half, q.data());\n    \n    // Load second half in reverse\n    svint32_t indices = svindex_s32(n - 1, -1);\n    svbool_t pg_reverse = svwhilelt_b32(0, half);\n    svint32_t second_half = svld1_gather_s32index_s32(pg_reverse, q.data(), indices);\n\n    // Compare first and second half\n    svbool_t cmp = svcmpeq_s32(pg_half, first_half, second_half);\n    bool is_palindrome = svptest_any(svptrue_b32(), cmp);\n\n    return is_palindrome && (sum <= w);\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    size_t len = q.size();\n    svbool_t pg = svwhilelt_b32(0, len);\n    \n    // Check sum <= w\n    svint32_t vec = svld1_s32(pg, q.data());\n    int32_t sum = svaddv_s32(pg, vec);\n    if (sum > w) return false;\n    \n    // Check if palindromic\n    size_t half_len = (len + 1) / 2;\n    svbool_t pg_half = svwhilelt_b32(0, half_len);\n    \n    svint32_t front = svld1_s32(pg_half, q.data());\n    svint32_t back = svld1_s32(pg_half, q.data() + len - half_len);\n    back = svrev_s32(back);\n    \n    svbool_t cmp = svcmpeq_s32(pg_half, front, back);\n    return svcntp_b32(cmp) == half_len;\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    size_t len = q.size();\n    if (len == 0) return false;\n\n    // Calculate sum using SVE\n    svbool_t pg = svwhilelt_b32(0, len);\n    svint32_t vec_sum = svdup_n_s32(0);\n    size_t i = 0;\n\n    while (i < len) {\n        svbool_t pg_loop = svwhilelt_b32(i, len);\n        svint32_t vec_q = svld1_s32(pg_loop, &q[i]);\n        vec_sum = svadd_m(pg_loop, vec_sum, vec_q);\n        i += svcntw();\n    }\n    int sum = svaddv_s32(svptrue_b32(), vec_sum);\n    if (sum > w) return false;\n\n    // Check if palindromic using SVE\n    size_t half_len = len / 2;\n    i = 0;\n    size_t j = len - 1;\n    svbool_t is_palindrome = svptrue_b32();\n\n    while (i < half_len) {\n        svbool_t pg_i = svwhilelt_b32(i, half_len);\n        svbool_t pg_j = svwhilelt_b32(j - half_len + 1, j + 1);\n        \n        svint32_t vec_left = svld1_s32(pg_i, &q[i]);\n        svint32_t vec_right = svld1_s32(pg_j, &q[j - half_len + 1]);\n        vec_right = svrev_s32(vec_right);\n        \n        svbool_t cmp_eq = svcmpeq_s32(pg_i, vec_left, vec_right);\n        is_palindrome = svand_b_z(svptrue_b32(), is_palindrome, cmp_eq);\n        \n        i += svcntw();\n        j -= svcntw();\n    }\n\n    return svptest_any(svptrue_b32(), is_palindrome);\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    // Check if sum <= w\n    svint32_t vec = svld1_s32(pg, q.data());\n    int32_t sum = svaddv_s32(pg, vec);\n    if (sum > w) return false;\n    \n    // Check if palindromic\n    int half = n / 2;\n    svbool_t pg_half = svwhilelt_b32(0, half);\n    \n    // Load first half\n    svint32_t first_half = svld1_s32(pg_half, q.data());\n    \n    // Load second half in reverse\n    int* second_half_ptr = q.data() + n - 1;\n    svint32_t second_half = svld1_s32(pg_half, second_half_ptr - half + 1);\n    second_half = svrev_s32(second_half);\n    \n    // Compare first and second halves\n    svbool_t cmp = svcmpeq_s32(pg_half, first_half, second_half);\n    bool is_palindrome = svptest_all(cmp);\n    \n    return is_palindrome;\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    // Check sum <= w\n    svint32_t vec = svld1_s32(pg, q.data());\n    int32_t sum = svaddv_s32(pg, vec);\n    if (sum > w) return false;\n    \n    // Check palindrome\n    svbool_t pg_half = svwhilelt_b32(0, (n + 1) / 2);\n    svint32_t front = svld1_s32(pg_half, q.data());\n    \n    // Create reverse indices\n    int32_t reverse_indices[(n + 1) / 2];\n    for (int i = 0; i < (n + 1) / 2; i++) {\n        reverse_indices[i] = n - 1 - i;\n    }\n    svint32_t idx = svld1_s32(pg_half, reverse_indices);\n    svint32_t back = svld1_gather_s32index_s32(pg_half, q.data(), idx);\n    \n    // Compare front and back\n    svbool_t cmp = svcmpeq_s32(pg_half, front, back);\n    return svptest_all(cmp);\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int len = arr.size();\n    int half_len = (len + 1) / 2;\n    int changes = 0;\n    \n    // Process pairs from both ends using SVE\n    for (int i = 0; i < half_len; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, half_len);\n        \n        // Load elements from start and end\n        svint32_t vec_left = svld1(pg, &arr[i]);\n        svint32_t vec_right = svld1(pg, &arr[len - 1 - i]);\n        \n        // Compare elements\n        svbool_t neq_mask = svcmpne(pg, vec_left, vec_right);\n        \n        // Count differences\n        changes += svcntp_b32(pg, neq_mask);\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int half = n / 2;\n    svbool_t pg = svwhilelt_b32(0, half);\n    int changes = 0;\n    \n    // Process pairs of elements from both ends\n    for (int i = 0; i < half; i += svcntw()) {\n        // Load elements from start and end\n        svint32_t vec_left = svld1(pg, &arr[i]);\n        svint32_t vec_right = svld1(pg, &arr[n - 1 - i]);\n        \n        // Compare elements\n        svbool_t cmp = svcmpeq(pg, vec_left, vec_right);\n        \n        // Count mismatches\n        changes += svcntp_b32(pg, svnot_z(pg, cmp));\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int half = n / 2;\n    int changes = 0;\n    \n    // Process pairs of elements from both ends in vectorized manner\n    for (int i = 0; i < half; i += svcntw()) {\n        // Calculate remaining elements\n        int remaining = half - i;\n        svbool_t pg = svwhilelt_b32(i, half);\n        \n        // Load elements from start and end\n        svint32_t vec_left = svld1_s32(pg, &arr[i]);\n        svint32_t vec_right = svld1_s32(pg, &arr[n - 1 - i]);\n        \n        // Compare elements\n        svbool_t cmp = svcmpeq_s32(pg, vec_left, vec_right);\n        \n        // Count mismatches (false values in comparison)\n        changes += svcntp_b32(pg, svnot_b_z(pg, cmp));\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int len = arr.size();\n    int half_len = (len + 1) / 2;\n    int changes = 0;\n    \n    // Process elements in vectorized chunks\n    svbool_t pg = svwhilelt_b32(0, half_len);\n    int i = 0;\n    \n    while (i < half_len) {\n        // Load elements from start and corresponding end\n        svint32_t vec_left = svld1_s32(pg, &arr[i]);\n        svint32_t vec_right = svld1_s32(pg, &arr[len - 1 - i]);\n        \n        // Compare elements\n        svbool_t cmp = svcmpeq_s32(pg, vec_left, vec_right);\n        \n        // Count mismatches (false values in cmp)\n        changes += svcntp_b32(pg, svnot_b_z(pg, cmp));\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, half_len);\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int half = n / 2;\n    int changes = 0;\n    \n    // Get vector length in elements\n    uint64_t vlen = svcntw();\n    \n    // Process pairs from both ends using SVE\n    for (int i = 0; i < half; i += vlen) {\n        // Calculate remaining elements\n        int remaining = half - i;\n        int elements = std::min((int)vlen, remaining);\n        \n        // Create predicate for active lanes\n        svbool_t pg = svwhilelt_b32(i, i + elements);\n        \n        // Load elements from start and end\n        svint32_t vec_start = svld1(pg, &arr[i]);\n        svint32_t vec_end = svld1(pg, &arr[n-1-i]);\n        \n        // Compare elements\n        svbool_t cmp = svcmpeq(pg, vec franchise_start, vec_end);\n        \n        // Count mismatches (false values in comparison)\n        changes += elements - svcntp_b32(pg, cmp);\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    uint64_t vlen = svcntb();\n    svbool_t pg = svptrue_b8();\n    \n    uint64_t sum1 = 0, sum2 = 0;\n    \n    // Process lst1\n    for (size_t i = 0; i < lst1.size(); i += vlen) {\n        uint64_t len = std::min(vlen, lst1.size() - i);\n        svuint64_t lengths = svdup_u64(0);\n        \n        for (uint64_t j = 0; j < len; ++j) {\n            if (i + j < lst1.size()) {\n                lengths = svinsr_n_u64(lengths, lst1[i + j].length(), j);\n            }\n        }\n        \n        sum1 += svaddv_u64(pg, lengths);\n    }\n    \n    // Process lst2\n    for (size_t i = 0; i < lst2.size(); i += vlen) {\n        uint64_t len = std::min(vlen, lst2.size() - i);\n        svuint64_t lengths = svdup_u64(0);\n        \n        for (uint64_t j = 0; j < len; ++j) {\n            if (i + j < lst2.size()) {\n                lengths = svinsr_n_u64(lengths, lst2[i + j].length(), j);\n            }\n        }\n        \n        sum2 += svaddv_u64(pg, lengths);\n    }\n    \n    return (sum1 <= sum2) ? lst1 : lst2;\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string>& lst1, const std::vector<std::string>& lst2) {\n    uint64_t len1 = lst1.size();\n    uint64_t len2 = lst2.size();\n    \n    // Handle empty cases\n    if (len1 == 0 && len2 == 0) return {};\n    if (len1 == 0) return lst2;\n    if (len2 == 0) return lst1;\n\n    // Calculate total string lengths using SVE\n    svbool_t pg = svptrue_b8();\n    svuint64_t sum1 = svdup_u64(0);\n    svuint64_t sum2 = svdup_u64(0);\n\n    // Process lst1\n    for (uint64_t i = 0; i < len1; i++) {\n        uint64_t len = lst1[i].length();\n        svuint64_t len_vec = svdup_u64(len);\n        sum1 = svadd_u64_z(pg, sum1, len_vec);\n    }\n\n    // Process lst2\n    for (uint64_t i = 0; i < len2; i++) {\n        uint64_t len = lst2[i].length();\n        svuint64_t len_vec = svdup_u64(len);\n        sum2 = svadd_u64_z(pg, sum2, len_vec);\n    }\n\n    // Extract sums\n    uint64_t total1 = svlasta_u64(svptrue_b64(), sum1);\n    uint64_t total2 = svlasta_u64(svptrue_b64(), sum2);\n\n    // Compare and return\n    return (total1 <= total2) ? lst1 : lst2;\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nstd::vector<std::string> total_match_simd(const std::vector<std::string>& lst1, const std::vector<std::string>& lst2) {\n    uint64_t len1 = 0, len2 = 0;\n    svbool_t pg = svwhilelt_b64(0, 1);\n\n    // Calculate total length for lst1\n    for (size_t i = 0; i < lst1.size(); i += svcntw()) {\n        svbool_t pm = svwhilelt_b32(i, lst1.size());\n        svuint32_t lengths = svdup_u32(0);\n        \n        for (size_t j = 0; j < svcntw() && (i + j) < lst1.size(); ++j) {\n            lengths = svinsr_n_u32(lengths, lst1[i + j].length());\n        }\n        \n        len1 += svaddv_u32(pm, lengths);\n    }\n\n    // Calculate total length for lst2\n    for (size_t i = 0; i < lst2.size(); i += svcntw()) {\n        svbool_t pm = svwhilelt_b32(i, lst2.size());\n        svuint32_t lengths = svdup_u32(0);\n        \n        for (size_t j = 0; j < svcntw() && (i + j) < lst2.size(); ++j) {\n            lengths = svinsr_n_u32(lengths, lst2[i + j].length());\n        }\n        \n        len2 += svaddv_u32(pm, lengths);\n    }\n\n    return (len1 <= len2) ? lst1 : lst2;\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    uint64_t len1 = 0, len2 = 0;\n    svbool_t pg = svwhilelt_b8(0, lst1.size());\n    \n    // Calculate total length of strings in lst1\n    for (size_t i = 0; i < lst1.size(); i += svcntb()) {\n        pg = svwhilelt_b8(i, lst1.size());\n        svuint64_t lengths = svld1_u64(pg, reinterpret_cast<const uint64_t*>(&lst1[i]));\n        len1 += svaddv_u64(pg, lengths);\n    }\n    \n    // Calculate total length of strings in lst2\n    for (size_t i = 0; i < lst2.size(); i += svcntb()) {\n        pg = svwhilelt_b8(i, lst2.size());\n        svuint64_t lengths = svld1_u64(pg, reinterpret_cast<const uint64_t*>(&lst2[i]));\n        len2 += svaddv_u64(pg, lengths);\n    }\n    \n    // Return the vector with fewer total characters\n    if (len2 < len1) {\n        return lst2;\n    }\n    return lst1;\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string>& lst1, const std::vector<std::string>& lst2) {\n    uint64_t len1 = 0, len2 = 0;\n    svbool_t pg = svwhilelt_b64(0, 1);\n\n    // Calculate total length of strings in lst1\n    for (const auto& str : lst1) {\n        svuint64_t len_vec = svdup_u64(str.length());\n        len1 += svaddv_u64(pg, len_vec);\n    }\n\n    // Calculate total length of strings in lst2\n    for (const auto& str : lst2) {\n        svuint64_t len_vec = svdup_u64(str.length());\n        len2 += svaddv_u64(pg, len_vec);\n    }\n\n    // Return the vector with smaller total length\n    if (len1 <= len2) {\n        return lst1;\n    }\n    return lst2;\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n == 1) return x == 1;\n    if (x == 0 || x == 1) return x == n;\n\n    svbool_t pg = svwhilelt_b64(0, svcntd());\n    svuint64_t v_x = svdup_u64(x);\n    svuint64_t v_n = svdup_u64(n);\n    svuint64_t v_result = svdup_u64(1);\n    svuint64_t v_one = svdup_u64(1);\n    svbool_t v_true = svptrue_b64();\n    \n    uint64_t max_iter = 64; // Enough for uint64_t\n    svuint64_t v_iter = svindex_u64(0, 1);\n    svbool_t v_active = svptrue_b64();\n    \n    while (svptest_any(pg, v_active)) {\n        v_result = svmul_u64_z(v_active, v_result, v_n);\n        svbool_t v_match = svcmpeq_u64(v_active, v_result, v_x);\n        \n        if (svptest_any(pg, v_match)) {\n            return true;\n        }\n        \n        v_iter = svadd_u64_z(v_active, v_iter, v_one);\n        v_active = svcmplt_u64(pg, v_iter, svdup_u64(max_iter));\n        \n        // Early exit if result exceeds x\n        v_active = svand_b_z(pg, v_active, svcmple_u64(pg, v_result, v_x));\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n == 1) return x == 1;\n    if (x == 1) return true;\n    if (n == 0) return false;\n\n    svbool_t pg = svwhilelt_b64(0, svcntd());\n    svuint64_t v_x = svdup_u64(x);\n    svuint64_t v_n = svdup_u64(n);\n    svuint64_t result = svdup_u64(1);\n    svuint64_t temp = svdup_u64(1);\n    \n    while (svptest_any(pg, svcmpne(pg, result, v_x))) {\n        temp = svmul_u64_z(pg, temp, v_n);\n        result = svsel_u64(svcmpeq(pg, temp, v_x), temp, result);\n        if (svptest_any(pg, svcmplt(pg, temp, v_x))) break;\n    }\n    \n    return svptest_any(pg, svcmpeq(pg, result, v_x));\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```c\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n == 0 || x == 0) return false;\n    if (n == 1) return x == 1;\n    if (x == 1) return true;\n\n    svbool_t pg = svwhilelt_b64(0, svcntd());\n    svuint64_t vec_x = svdup_u64(x);\n    svuint64_t vec_n = svdup_u64(n);\n    svuint64_t result = svdup_u64(1);\n    svbool_t active = svdup_b64(true);\n\n    while (svptest_any(pg, active)) {\n        svuint64_t mul = svmul_u64_m(active, result, vec_n);\n        svbool_t overflow = svcmpeq_u64(pg, mul, 0);\n        active = svand_b_z(pg, active, svnot_b_z(pg, overflow));\n\n        svbool_t eq_x = svcmpeq_u64(pg, mul, vec_x);\n        if (svptest_any(pg, eq_x)) {\n            return true;\n        }\n\n        svbool_t gt_x = svcmpgt_u64(pg, mul, vec_x);\n        if (svptest_any(pg, svand_b_z(pg, active, gt_x))) {\n            return false;\n        }\n\n        result = mul;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```c\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (x == 0 || n == 0) return false;\n    if (n == 1) return x == 1;\n\n    svbool_t pg = svwhilelt_b64(0, svcntd());\n    svuint64_t vec_x = svdup_u64(x);\n    svuint64_t vec_n = svdup_u64(n);\n    svuint64_t result = svdup_u64(1);\n    svbool_t is_power = svdup_b64(true);\n\n    while (svptest_any(pg, is_power)) {\n        svuint64_t mul_result = svmul_u64_m(pg, result, vec_n);\n        svbool_t overflow_check = svcmpeq_u64(pg, mul_result, 0);\n        svbool_t eq_check = svcmpeq_u64(pg, mul_result, vec_x);\n        svbool_t gt_check = svcmpgt_u64(pg, mul_result, vec_x);\n\n        is_power = svand_b_z(pg, is_power, svnot_b_z(pg, svorr_b(pg, overflow_check, gt_check)));\n\n        if (svptest_any(pg, eq_check)) {\n            return true;\n        }\n\n        if (!svptest_any(pg, is_power)) {\n            return false;\n        }\n\n        result = mul_result;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```c\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (x == 0 || n == 0) return false;\n    if (n == 1) return x == 1;\n    if (x == 1) return true;\n\n    svbool_t pg = svwhilelt_b64(0, svcntd());\n    svuint64_t vec_x = svdup_u64(x);\n    svuint64_t vec_n = svdup_u64(n);\n    svuint64_t result = svdup_u64(1);\n    svbool_t active = svdup_b64(true);\n\n    while (svptest_any(pg, active)) {\n        svuint64_t mul = svmul_u64_m(active, result, vec_n);\n        svbool_t overflow = svcmpeq_u64(pg, mul, 0);\n        active = svand_b_z(pg, active, svnot_b_z(pg, overflow));\n\n        svbool_t eq_x = svcmpeq_u64(pg, mul, vec_x);\n        if (svptest_any(pg, eq_x)) {\n            return true;\n        }\n\n        svbool_t gt_x = svcmpgt_u64(pg, mul, vec_x);\n        if (svptest_any(pg, svorr_b_z(pg, gt_x, overflow))) {\n            return false;\n        }\n\n        result = mul;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint hex_key_simd(const std::string & num) {\n    if (num.empty()) return 0;\n    \n    svbool_t pg = svwhilelt_b8(0, num.size());\n    svuint8_t vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(num.c_str()));\n    \n    // Create masks for prime digits: 2,3,5,7,B,D (ASCII values)\n    svbool_t prime_mask = svpfalse();\n    const uint8_t primes[] = {'2','3','5','7','B','D'};\n    \n    for (int i = 0; i < 6; i++) {\n        svbool_t eq_mask = svcmpeq_u8(pg, vec, svdup_u8(primes[i]));\n        prime_mask = svorr_b_z(svptrue_b8(), prime_mask, eq_mask);\n    }\n    \n    // Count true values in prime_mask\n    return svcntp_b8(pg, prime_mask);\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint hex_key_simd(const std::string &num) {\n    if (num.empty()) return 0;\n    \n    int count = 0;\n    svbool_t pg = svwhilelt_b8(0, num.length());\n    \n    // Load string into vector\n    svuint8_t vec = svld1_u8(pg, (const uint8_t*)num.c_str());\n    \n    // Create masks for prime digits: 2,3,5,7,B,D\n    svuint8_t primes = svindex_u8(0, 1);\n    svbool_t is_prime = svfalse_b();\n    \n    // Check for 2 (ASCII '2' = 50)\n    svbool_t mask_2 = svcmpeq_u8(pg, vec, 50);\n    is_prime = svorr_b_z(pg, is_prime, mask_2);\n    \n    // Check for 3 (ASCII '3' = 51)\n    svbool_t mask_3 = svcmpeq_u8(pg, vec, 51);\n    is_prime = svorr_b_z(pg, is_prime, mask_3);\n    \n    // Check for 5 (ASCII '5' = 53)\n    svbool_t mask_5 = svcmpeq_u8(pg, vec, 53);\n    is_prime = svorr_b_z(pg, is_prime, mask_5);\n    \n    // Check for 7 (ASCII '7' = 55)\n    svbool_t mask_7 = svcmpeq_u8(pg, vec, 55);\n    is_prime = svorr_b_z(pg, is_prime, mask_7);\n    \n    // Check for B (ASCII 'B' = 66, decimal 11)\n    svbool_t mask_B = svcmpeq_u8(pg, vec, 66);\n    is_prime = svorr_b_z(pg, is_prime, mask_B);\n    \n    // Check for D (ASCII 'D' = 68, decimal 13)\n    svbool_t mask_D = svcmpeq_u8(pg, vec, 68);\n    is_prime = svorr_b_z(pg, is_prime, mask_D);\n    \n    // Count true values in predicate\n    count = svcntp_b8(pg, is_prime);\n    \n    // Handle remaining elements if string length > vector length\n    size_t processed = svcntb();\n    while (processed < num.length()) {\n        pg = svwhilelt_b8(processed, num.length());\n        vec = svld1_u8(pg, (const uint8_t*)num.c_str() + processed);\n        \n        is_prime = svfalse_b();\n        mask_2 = svcmpeq_u8(pg, vec, 50);\n        is_prime = svorr_b_z(pg, is_prime, mask_2);\n        mask_3 = svcmpeq_u8(pg, vec, 51);\n        is_prime = svorr_b_z(pg, is_prime, mask_3);\n        mask_5 = svcmpeq_u8(pg, vec, 53);\n        is_prime = svorr_b_z(pg, is_prime, mask_5);\n        mask_7 = svcmpeq_u8(pg, vec, 55);\n        is_prime = svorr_b_z(pg, is_prime, mask_7);\n        mask_B = svcmpeq_u8(pg, vec, 66);\n        is_prime = svorr_b_z(pg, is_prime, mask_B);\n        mask_D = svcmpeq_u8(pg, vec, 68);\n        is_prime = svorr_b_z(pg, is_prime, mask_D);\n        \n        count += svcntp_b8(pg, is_prime);\n        processed += svcntb();\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint hex_key_simd(const std::string & num) {\n    if (num.empty()) return 0;\n    \n    svbool_t pg = svwhilelt_b8(0, num.length());\n    svuint8_t vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(num.c_str()));\n    \n    // Convert hex chars to values: 0-9 -> 0-9, A-F -> 10-15\n    svbool_t is_digit = svcmple_n_u8(pg, vec, '9');\n    svuint8_t digits = svsub_n_u8_x(pg, vec, '0');\n    svuint8_t letters = svsub_n_u8_x(pg, vec, 'A' - 10);\n    svuint8_t values = svsel_u8(is_digit, digits, letters);\n    \n    // Create mask for prime digits: 2,3,5,7,11(B),13(D)\n    svbool_t prime_mask = svptrue_b8();\n    svuint8_t prime_vals = svindex_u8(0, 1);\n    svbool_t is_prime = svpfalse();\n    \n    // Check against prime values\n    uint8_t primes[] = {2, 3, 5, 7, 11, 13};\n    for (int i = 0; i < 6; i++) {\n        svbool_t match = svcmpeq_n_u8(pg, values, primes[i]);\n        is_prime = svorr_b_z(svptrue_b8(), is_prime, match);\n    }\n    \n    // Count true values in prime mask\n    return svcntp_b8(pg, is_prime);\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint hex_key_simd(const std::string &num) {\n    if (num.empty()) return 0;\n\n    svbool_t pg = svwhilelt_b8(0, num.size());\n    svuint8_t vec = svld1_u8(pg, (const uint8_t*)num.c_str());\n\n    // Create mask for prime digits: 2, 3, 5, 7, B(11), D(13)\n    svbool_t prime_mask = svptrue_b8();\n    svuint8_t prime_digits = svindex_u8(0, 1);\n    \n    // Check for digits 2,3,5,7\n    svbool_t is_2 = svcmpeq_u8(pg, vec, '2');\n    svbool_t is_3 = svcmpeq_u8(pg, vec, '3');\n    svbool_t is_5 = svcmpeq_u8(pg, vec, '5');\n    svbool_t is_7 = svcmpeq_u8(pg, vec, '7');\n    // Check for letters B,D\n    svbool_t is_B = svcmpeq_u8(pg, vec, 'B');\n    svbool_t is_D = svcmpeq_u8(pg, vec, 'D');\n\n    // Combine all prime conditions\n    prime_mask = svorr_z(pg, is_2, is_3);\n    prime_mask = svorr_z(pg, prime_mask, is_5);\n    prime_mask = svorr_z(pg, prime_mask, is_7);\n    prime_mask = svorr_z(pg, prime_mask, is_B);\n    prime_mask = svorr_z(pg, prime_mask, is_D);\n\n    // Count true predicates\n    return svcntp_b8(pg, prime_mask);\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint hex_key_simd(const std::string & num) {\n    if (num.empty()) return 0;\n    \n    // Prime digits in hex: 2, 3, 5, 7, B(=11), D(=13)\n    const uint8_t prime_mask[16] = {\n        0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0\n    };\n    \n    int count = 0;\n    size_t len = num.length();\n    size_t i = 0;\n    \n    // Process vector-sized chunks\n    svbool_t pg = svwhilelt_b8(i, len);\n    while (svptest_any(svptrue_b8(), pg)) {\n        // Load input string chunk\n        svuint8_t vec = svld1_u8(pg, (const uint8_t*)&num[i]);\n        \n        // Convert hex chars to values (0-15)\n        svuint8_t values = svsub_u8_x(pg, vec, svdup_u8('0'));\n        svbool_t is_letter = svcmpge_u8(pg, vec, svdup_u8('A'));\n        values = svsel_u8(is_letter, \n                         svsub_u8_x(pg, values, svdup_u8('A'-'0'-10)),\n                         values);\n        \n        // Check if values are in prime_mask\n        svuint8_t mask_vals = svtbl_u8(svdup_u8_x(prime_mask), values);\n        svbool_t is_prime = svcmpne_u8(pg, mask_vals, svdup_u8(0));\n        \n        // Count primes in this vector\n        count += svcntp_b8(pg, is_prime);\n        \n        // Move to next chunk\n        i += svcntb();\n        pg = svwhilelt_b8(i, len);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool is_happy_simd(const std::string &s) {\n    if (s.length() < 3) return false;\n\n    const char *str = s.c_str();\n    size_t len = s.length();\n    svbool_t pg = svwhilelt_b8(0, len - 2);\n\n    svuint8_t vec1, vec2, vec3;\n    size_t i = 0;\n\n    while (i < len - 2) {\n        // Load three consecutive characters\n        vec1 = svld1_u8(pg, (const uint8_t*)(str + i));\n        vec2 = svld1_u8(pg, (const uint8_t*)(str + i + 1));\n        vec3 = svld1_u8(pg, (const uint8_t*)(str + i + 2));\n\n        // Compare for equality\n        svbool_t eq12 = svcmpeq_u8(pg, vec1, vec2);\n        svbool_t eq13 = svcmpeq_u8(pg, vec1, vec3);\n        svbool_t eq23 = svcmpeq_u8(pg, vec2, vec3);\n\n        // Combine comparisons: any equal characters mean not happy\n        svbool_t any_eq = svorr_b_z(pg, eq12, svorr_b_z(pg, eq13, eq23));\n\n        // If any equal characters found, return false\n        if (svptest_any(pg, any_eq)) {\n            return false;\n        }\n\n        i += svcntb();\n        pg = svwhilelt_b8(i, len - 2);\n    }\n\n    // Check remaining elements sequentially if vector length doesn't align\n    for (; i < len - 2; i++) {\n        if (str[i] == str[i + 1] || str[i] == str[i + 2] || str[i + 1] == str[i + 2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool is_happy_simd(const std::string &s) {\n    if (s.length() < 3) return false;\n\n    const char *str = s.c_str();\n    size_t len = s.length();\n    svbool_t pg = svwhilelt_b8(0, len - 2);\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t vec1 = svld1_u8(pg, (const uint8_t*)str);\n        svuint8_t vec2 = svld1_u8(pg, (const uint8_t*)(str + 1));\n        svuint8_t vec3 = svld1_u8(pg, (const uint8_t*)(str + 2));\n\n        svbool_t cmp1 = svcmpeq_u8(pg, vec1, vec2);\n        svbool_t cmp2 = svcmpeq_u8(pg, vec2, vec3);\n        svbool_t cmp3 = svcmpeq_u8(pg, vec1, vec3);\n\n        svbool_t any_same = svorr_b_z(pg, cmp1, svorr_b_z(pg, cmp2, cmp3));\n\n        if (svptest_any(svptrue_b8(), any_same)) {\n            return false;\n        }\n\n        str += svcntb();\n        pg = svwhilelt_b8(str - s.c_str(), len - 2);\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s) {\n    if (s.length() < 3) return false;\n\n    svbool_t pg = svptrue_b8();\n    size_t len = s.length();\n    size_t i = 0;\n\n    while (i + 2 < len) {\n        size_t vec_len = svcntb();\n        if (i + vec_len * 3 > len) {\n            vec_len = (len - i + 2) / 3;\n        }\n\n        svbool_t p = svwhilelt_b8(i, len - 2);\n        svuint8_t vec1 = svld1_u8(p, (const uint8_t*)&s[i]);\n        svuint8_t vec2 = svld1_u8(p, (const uint8_t*)&s[i + 1]);\n        svuint8_t vec3 = svld1_u8(p, (const uint8_t*)&s[i + 2]);\n\n        svbool_t cmp1 = svcmpeq_u8(p, vec1, vec2);\n        svbool_t cmp2 = svcmpeq_u8(p, vec1, vec3);\n        svbool_t cmp3 = svcmpeq_u8(p, vec2, vec3);\n\n        svbool_t any_same = svorr_b_z(pg, cmp1, svorr_b_z(pg, cmp2, cmp3));\n\n        if (svptest_any(pg, any_same)) {\n            return false;\n        }\n\n        i += vec_len;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_happy_simd(const std::string &s) {\n    if (s.length() < 3) return false;\n    \n    svbool_t pg = svptrue_b8();\n    size_t len = s.length();\n    size_t i = 0;\n    \n    while (i + svcntb() <= len - 2) {\n        svuint8_t vec1 = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&s[i]));\n        svuint8_t vec2 = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&s[i + 1]));\n        svuint8_t vec3 = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&s[i + 2]));\n        \n        svbool_t eq12 = svcmpeq_u8(pg, vec1, vec2);\n        svbool_t eq23 = svcmpeq_u8(pg, vec2, vec3);\n        svbool_t eq13 = svcmpeq_u8(pg, vec1, vec3);\n        \n        svbool_t any_eq = svorr_b_z(pg, eq12, svorr_b_z(pg, eq23, eq13));\n        \n        if (svptest_any(pg, any_eq)) {\n            return false;\n        }\n        \n        i += svcntb();\n    }\n    \n    // Handle remaining elements scalarly\n    for (; i < len - 2; i++) {\n        if (s[i] == s[i + 1] || s[i + 1] == s[i + 2] || s[i] == s[i + 2]) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool is_happy_simd(const std::string & s) {\n    if (s.length() < 3) return false;\n\n    svbool_t pg = svwhilelt_b8(0, s.length() - 2);\n    svuint8_t vec1 = svld1_u8(pg, (uint8_t*)s.data());\n    svuint8_t vec2 = svld1_u8(pg, (uint8_t*)s.data() + 1);\n    svuint8_t vec3 = svld1_u8(pg, (uint8_t*)s.data() + 2);\n\n    svbool_t cmp12 = svcmpeq_u8(pg, vec1, vec2);\n    svbool_t cmp13 = svcmpeq_u8(pg, vec1, vec3);\n    svbool_t cmp23 = svcmpeq_u8(pg, vec2, vec3);\n\n    svbool_t any_equal = svorr_b_z(pg, cmp12, svorr_b_z(pg, cmp13, cmp23));\n\n    return !svptest_any(pg, any_equal);\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool prime_length_simd(const std::string & str) {\n    size_t len = str.length();\n    \n    // Handle small lengths directly\n    if (len < 2) return false;\n    if (len == 2 || len == 3 || len == 5 || len == 7) return true;\n    if (len % 2 == 0) return false;\n    \n    // Create vector for divisors from 3 to sqrt(len)\n    uint64_t sqrt_len = (uint64_t)sqrt((double)len);\n    svbool_t pg = svwhilelt_b64(3ULL, sqrt_len + 1);\n    svuint64_t divisors = svindex_u64(3, 2); // 3, 5, 7, ...\n    \n    // Check if len is divisible by any number in divisors\n    svuint64_t len_vec = svdup_u64(len);\n    svuint64_t remainders = svmod_u64_z(pg, len_vec, divisors);\n    svbool_t is_zero = svcmpeq(pg, remainders, 0);\n    \n    // If any remainder is zero, len is not prime\n    if (svptest_any(svptrue_b64(), is_zero)) {\n        return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool prime_length_simd(const std::string & str) {\n    size_t len = str.length();\n    if (len < 2) return false;\n    \n    // Get vector length in bytes\n    svbool_t pg = svwhilelt_b32(2, (uint32_t)len);\n    int32_t vec_len = svcntw();\n    \n    // Initialize vectors\n    svuint32_t divisors = svindex_u32(2, 1);\n    svuint32_t len_vec = svdup_u32((uint32_t)len);\n    \n    // Check divisibility\n    svbool_t is_divisible = svfalse_b();\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t remainder = svmod_u32_z(pg, len_vec, divisors);\n        svbool_t is_zero = svcmpeq(pg, remainder, 0);\n        is_divisible = svorr_b_z(svptrue_b32(), is_divisible, is_zero);\n        \n        // Early exit if any divisor found\n        if (svptest_any(svptrue_b32(), is_divisible)) {\n            return false;\n        }\n        \n        // Update divisors for next iteration\n        divisors = svadd_u32_z(pg, divisors, svdup_u32(vec_len));\n        pg = svwhilelt_b32(svadd_n_u32_z(pg, svlastb_u32(pg, divisors), 1), (uint32_t)len);\n    }\n    \n    // If no divisors found, length is prime\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool prime_length_simd(const std::string &str) {\n    size_t len = str.length();\n    \n    // Handle small lengths directly\n    if (len < 2) return false;\n    if (len == 2 || len == 3 || len == 5 || len == 7) return true;\n    if (len % 2 == 0) return false;\n\n    // Initialize SVE vectors\n    svbool_t pg = svwhilelt_b64(0, len);\n    uint64_t max_div = len / 2;\n    \n    // Create vector of divisors starting from 3\n    svuint64_t divisors = svindex_u64(3, 2);\n    svbool_t active = svwhilelt_b64(3, max_div);\n    \n    // Create vector with length value\n    svuint64_t len_vec = svdup_u64(len);\n    \n    // Check divisibility\n    svbool_t div_mask = svdiv_u64_z(active, len_vec, divisors);\n    svbool_t is_zero = svcmpeq_u64(active, div_mask, svdup_u64(0));\n    \n    // If any remainder is zero, length is not prime\n    return !svptest_any(pg, is_zero);\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool prime_length_simd(const std::string & str) {\n    size_t len = str.length();\n    \n    // Handle small cases directly\n    if (len < 2) return false;\n    if (len == 2 || len == 3 || len == 5 || len == 7) return true;\n    if (len % 2 == 0 || len % 3 == 0) return false;\n\n    // Create vector predicates\n    svbool_t pg = svwhilelt_b64(0, len);\n    \n    // Initialize vector for numbers to check divisibility\n    uint64_t step = svcntd() * 2; // Two increments per vector\n    svuint64_t divisors = svindex_u64(5, 2);\n    \n    // Check divisibility using SVE\n    while (svptest_any(svptrue_b64(), pg)) {\n        svbool_t div_mask = svcmpeq_u64(pg, svmod_u64(divisors, svdup_u64(len)), 0);\n        if (svptest_any(pg, div_mask)) return false;\n        \n        // Update divisors for next iteration\n        divisors = svadd_u64_z(svptrue_b64(), divisors, step);\n        pg = svwhilelt_b64(svminv_u64(divisors), len);\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool prime_length_simd(const std::string & str) {\n    size_t len = str.length();\n    \n    if (len < 2) return false;\n    \n    // Get vector length in elements (assuming uint32_t for indices)\n    svbool_t pg = svwhilelt_b32(2, (uint32_t)len);\n    uint32_t vlen = svcntw();\n    \n    // Create vector of length value\n    svuint32_t len_vec = svdup_u32((uint32_t)len);\n    \n    // Create vector of indices from 2 to len\n    svuint32_t idx = svindex_u32(2, 1);\n    \n    // Check divisibility: len % idx == 0\n    svuint32_t rem = svmod_u32_z(pg, len_vec, idx);\n    svbool_t is_divisible = svcmpeq(pg, rem, 0);\n    \n    // If any remainder is zero, len is not prime\n    if (svptest_any(pg, is_divisible)) {\n        return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string solve_simd(uint64_t N) {\n    svbool_t pg = svptrue_b8();\n    svuint64_t digits = svdup_u64(0);\n    uint64_t sum = 0;\n    \n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n    \n    std::string binary = \"\";\n    while (sum > 0) {\n        binary = (sum % 2 ? \"1\" : \"0\") + binary;\n        sum /= 2;\n    }\n    \n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string solve_simd(uint64_t N) {\n    // Vector to store digits\n    svuint64_t digits = svdup_u64(0);\n    svbool_t ptrue = svptrue_b64();\n    \n    // Extract digits using division and modulo\n    uint64_t temp = N;\n    int digit_count = 0;\n    uint64_t digit_array[16] = {0}; // Max digits for uint64_t\n    \n    while (temp > 0 && digit_count < 16) {\n        digit_array[digit_count++] = temp % 10;\n        temp /= 10;\n    }\n    \n    // Load digits into SVE vector\n    digits = svld1_u64(ptrue, digit_array);\n    \n    // Sum digits using SVE reduction\n    uint64_t sum = svaddv_u64(ptrue, digits);\n    \n    // Convert sum to binary string\n    std::string result;\n    if (sum == 0) return \"0\";\n    \n    while (sum > 0) {\n        result = (sum % 2 ? \"1\" : \"0\") + result;\n        sum /= 2;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string solve_simd(uint64_t N) {\n    svbool_t pg = svptrue_b8();\n    uint64_t digits[8] = {0};\n    int count = 0;\n\n    // Extract digits\n    while (N > 0 && count < 8) {\n        digits[count++] = N % 10;\n        N /= 10;\n    }\n\n    // Create SVE vector for digits\n    svuint64_t v_digits = svld1_u64(pg, digits);\n    \n    // Sum digits using SVE\n    uint64_t sum = svaddv_u64(pg, v_digits);\n\n    // Convert sum to binary string\n    std::string result = \"\";\n    if (sum == 0) return \"0\";\n    \n    while (sum > 0) {\n        result = (sum % 2 ? \"1\" : \"0\") + result;\n        sum /= 2;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string solve_simd(uint64_t N) {\n    // Initialize SVE vector for digits (0-9)\n    svuint64_t digits = svindex_u64(0, 1);\n    svbool_t pg = svwhilelt_b64(0, 10);\n    \n    // Initialize sum\n    uint64_t sum = 0;\n    \n    // Process digits of N\n    while (N > 0) {\n        uint64_t digit = N % 10;\n        // Create vector with current digit\n        svuint64_t digit_vec = svdup_u64(digit);\n        // Add digit to sum if digit is valid (0-9)\n        svbool_t match = svcmpeq(pg, digits, digit_vec);\n        sum += svcntp_b64(pg, match) * digit;\n        N /= 10;\n    }\n    \n    // Convert sum to binary string\n    std::string binary = \"\";\n    if (sum == 0) return \"0\";\n    \n    while (sum > 0) {\n        binary = (sum % 2 ? \"1\" : \"0\") + binary;\n        sum /= 2;\n    }\n    \n    return binary;\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string solve_simd(uint64_t N) {\n    // Vector to store digits (0-9), max 20 digits for uint64_t\n    svuint64_t digits = svdup_n_u64(0);\n    svbool_t pg = svwhilelt_b64(0, 20);\n    \n    // Extract digits by repeatedly dividing by 10\n    uint64_t temp = N;\n    int idx = 0;\n    while (temp > 0 && idx < 20) {\n        digits = svinsr_n_u64(digits, temp % 10);\n        temp /= 10;\n        idx++;\n    }\n    \n    // Sum all digits in parallel\n    uint64_t sum = svaddv_u64(pg, digits);\n    \n    // Convert sum to binary string\n    std::string result;\n    if (sum == 0) return \"0\";\n    while (sum > 0) {\n        result = (sum % 2 ? \"1\" : \"0\") + result;\n        sum /= 2;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint add_simd(std::vector<int> lst) {\n    int sum = 0;\n    svbool_t pg = svptrue_b32();\n    size_t len = lst.size();\n    size_t i = 0;\n\n    for (; i + svcntw() <= len; i += svcntw()) {\n        svint32_t vec = svld1_s32(pg, &lst[i]);\n        svbool_t odd_idx = svzip1_b32(svnot_b_z(pg, svptrue_b32()), svptrue_b32());\n        svbool_t even_val = svcmpeq_n_s32(pg, svand_s32_z(pg, vec, 1), 0);\n        svbool_t mask = svand_b_z(pg, odd_idx, even_val);\n        svint32_t filtered = svsel_s32(mask, vec, svdup_n_s32(0));\n        sum += svaddv_s32(pg, filtered);\n    }\n\n    for (; i < len; i++) {\n        if (i % 2 == 1 && lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int sum = 0;\n    svbool_t pg = svwhilelt_b32(0, lst.size());\n    svbool_t odd_mask = svdupq_b32(0, 1, 0, 1);\n    svbool_t even_mask = svdupq_b32(0, 0, 0, 0);\n\n    for (size_t i = 0; i < lst.size(); i += svcntw()) {\n        svbool_t p = svwhilelt_b32(i, lst.size());\n        svint32_t vec = svld1_s32(p, &lst[i]);\n        svbool_t is_odd_idx = svand_b_z(pg, p, odd_mask);\n        svbool_t is_even_val = svcmpeq_n_s32(p, svand_s32_z(p, vec, svdup_s32(1)), 0);\n        svbool_t pred = svand_b_z(pg, is_odd_idx, is_even_val);\n        sum += svaddv_s32(pred, vec);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int sum = 0;\n    svbool_t pg = svptrue_b32();\n    int32_t* ptr = lst.data();\n    size_t len = lst.size();\n    \n    svint32_t vsum = svdup_n_s32(0);\n    \n    for (size_t i = 0; i < len; i += svcntw()) {\n        svbool_t pm = svwhilelt_b32(i, len);\n        \n        svint32_t vec = svld1_s32(pm, ptr + i);\n        \n        svbool_t odd_idx = svzip1_b32(svnot_b_z(pg, pm), pm);\n        \n        svbool_t even_val = svcmpeq_n_s32(pm, svand_n_s32_z(pm, vec, 1), 0);\n        \n        svbool_t mask = svand_b_z(pg, odd_idx, even_val);\n        \n        vsum = svadd_m(mask, vsum, vec);\n    }\n    \n    sum = svaddv_s32(pg, vsum);\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int sum = 0;\n    svbool_t pg = svptrue_b32();\n    svint32_t vsum = svdup_s32(0);\n    size_t len = lst.size();\n    size_t i = 0;\n\n    for (; i + svcntw() <= len; i += svcntw()) {\n        svbool_t p_odd = svzip1_b32(svnot_b_z(pg, pg), pg);\n        svint32_t vec = svld1_s32(pg, &lst[i]);\n        svbool_t p_even = svcmpeq_n_s32(pg, svand_n_s32_z(pg, vec, 1), 0);\n        svbool_t p_combine = svand_b_z(pg, p_odd, p_even);\n        vsum = svadd_m(p_combine, vsum, vec);\n    }\n\n    sum = svaddv_s32(svptrue_b32(), vsum);\n\n    for (; i < len; i++) {\n        if (i % 2 == 1 && lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    svbool_t pg = svptrue_b32();\n    svint32_t sum_vec = svdup_n_s32(0);\n    size_t len = lst.size();\n    size_t i = 0;\n\n    // Create predicate for odd indices\n    svbool_t odd_pred = svzip1_b(svfalse_b(), svtrue_b());\n\n    for (; i + svcntw() <= len; i += svcntw()) {\n        svint32_t vec = svld1_s32(pg, &lst[i]);\n        svbool_t even_mask = svcmpeq_n_s32(pg, svand_n_s32_z(pg, vec, 1), 0);\n        svbool_t mask = svand_b_z(pg, even_mask, svtbl_b(odd_pred, svlsr_n_u32_z(pg, svindex_u32(0, 1), 1)));\n        sum_vec = svadd_s32_m(mask, sum_vec, vec);\n    }\n\n    int sum = svaddv_s32(pg, sum_vec);\n\n    // Handle remaining elements\n    for (; i < len; i++) {\n        if (i % 2 == 1 && lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string &s) {\n    std::string result = s;\n    size_t len = s.length();\n    \n    // Create predicate for vector length\n    svbool_t pg = svwhilelt_b8(0, len);\n    \n    // Process string in vector-sized chunks\n    for (size_t i = 0; i < len; i += svcntb()) {\n        // Update predicate for remaining elements\n        pg = svwhilelt_b8(i, len);\n        \n        // Load input chunk\n        svuint8_t vec = svld1_u8(pg, (uint8_t*)&s[i]);\n        \n        // Create mask for lowercase letters (a-z)\n        svbool_t is_lower = svand_b_z(pg, \n            svcmpge_u8(pg, vec, svdup_u8('a')),\n            svcmple_u8(pg, vec, svdup_u8('z')));\n            \n        // Apply rotation: (x - 'a' + 4) % 26 + 'a'\n        svuint8_t shifted = svsub_u8_z(is_lower,\n            svadd_u8_z(is_lower,\n                svsub_u8_z(is_lower, vec, svdup_u8('a')),\n                svdup_u8(4)),\n            svdup_u8(26 * svsel_u8(is_lower, \n                svdiv_u8_z(is_lower, \n                    svadd_u8_z(is_lower, \n                        svsub_u8_z(is_lower, vec, svdup_u8('a')),\n                        svdup_u8(4)),\n                    svdup_u8(26)), \n                svdup_u8(0))));\n                \n        shifted = svadd_u8_z(is_lower, shifted, svdup_u8('a'));\n        \n        // Store result\n        svst1_u8(pg, (uint8_t*)&result[i], \n            svsel_u8(is_lower, shifted, vec));\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    std::string result = s;\n    uint64_t len = s.length();\n    const uint64_t shift = 4; // 2 * 2\n\n    // Process string in chunks based on vector length\n    svbool_t pg = svwhilelt_b8(0, len);\n    uint64_t vlen = svcntb();\n    \n    for (uint64_t i = 0; i < len; i += vlen) {\n        // Update predicate for remaining elements\n        pg = svwhilelt_b8(i, len);\n        \n        // Load input string chunk\n        svuint8_t vec = svld1_u8(pg, (const uint8_t*)&s[i]);\n        \n        // Create mask for lowercase letters (a-z)\n        svbool_t is_lower = svand_b_z(pg, \n            svcmpge_u8(pg, vec, svdup_u8('a')),\n            svcmple_u8(pg, vec, svdup_u8('z')));\n            \n        // Apply shift to lowercase letters\n        svuint8_t shifted = svadd_u8_z(is_lower, vec, svdup_u8(shift));\n        \n        // Handle wrap-around for letters > 'z'\n        svbool_t wrap = svcmpgt_u8(is_lower, shifted, svdup_u8('z'));\n        shifted = svsub_u8_z(wrap, shifted, svdup_u8(26));\n        \n        // Store result\n        svst1_u8(pg, (uint8_t*)&result[i], shifted);\n        \n        // Update vector length for next iteration\n        vlen = svcntb();\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    std::string result = s;\n    uint64_t len = s.length();\n    uint64_t vec_len = svcntb();\n    \n    svbool_t pg = svwhilelt_b8(0, len);\n    for (uint64_t i = 0; i < len; i += vec_len) {\n        svbool_t pg_loop = svwhilelt_b8(i, len);\n        \n        svuint8_t vec = svld1_u8(pg_loop, reinterpret_cast<const uint8_t*>(&s[i]));\n        \n        svuint8_t is_lower = svcmplt_u8(pg_loop, vec, svdup_u8('z'));\n        svuint8_t is_upper = svcmplt_u8(pg_loop, vec, svdup_u8('Z'));\n        \n        svuint8_t shift_vec = svadd_u8_x(pg_loop, vec, svdup_u8(4));\n        \n        svuint8_t wrap_lower = svsub_u8_x(pg_loop, shift_vec, svdup_u8(26));\n        svuint8_t wrap_upper = svsub_u8_x(pg_loop, shift_vec, svdup_u8(26));\n        \n        svuint8_t lower_bound = svsel_u8(is_lower, svdup_u8('a'), svdup_u8('A'));\n        svuint8_t upper_bound = svsel_u8(is_lower, svdup_u8('z'), svdup_u8('Z'));\n        \n        svbool_t needs_wrap = svcmpgt_u8(pg_loop, shift_vec, upper_bound);\n        svuint8_t final_vec = svsel_u8(needs_wrap, wrap_lower, shift_vec);\n        \n        svst1_u8(pg_loop, reinterpret_cast<uint8_t*>(&result[i]), final_vec);\n        \n        pg = svwhilelt_b8(i + vec_len, len);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    std::string result = s;\n    svbool_t pg = svwhilelt_b8(0, s.length());\n    \n    // Process string in vector chunks\n    while (svptest_any(svptrue_b8(), pg)) {\n        // Load input string chunk\n        svuint8_t vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.data() + svcntb() * (svcntw() / svcntb())));\n        \n        // Create mask for lowercase letters (a-z)\n        svbool_t is_lower = svand_b_z(pg, \n            svcmpge_u8(pg, vec, svdup_u8('a')),\n            svcmple_u8(pg, vec, svdup_u8('z'))\n        );\n        \n        // Apply rotation: (x - 'a' + 4) % 26 + 'a' for lowercase\n        svuint8_t rotated = svadd_u8_z(is_lower,\n            svsub_u8_z(is_lower, vec, svdup_u8('a')),\n            svdup_u8(4)\n        );\n        rotated = svmod_u8_z(is_lower, rotated, svdup_u8(26));\n        rotated = svadd_u8_z(is_lower, rotated, svdup_u8('a'));\n        \n        // Preserve non-lowercase characters\n        svuint8_t final = svsel_u8(is_lower, rotated, vec);\n        \n        // Store result\n        svst1_u8(pg, reinterpret_cast<uint8_t*>(result.data() + svcntb() * (svcntw() / svcntb())), final);\n        \n        // Update predicate for next chunk\n        pg = svwhilelt_b8(svcntb() * (svcntw() / svcntb()), s.length());\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    std::string result = s;\n    uint64_t len = s.length();\n    uint64_t vl = svcntb(); // Vector length in bytes\n\n    // Process string in vector-sized chunks\n    for (uint64_t i = 0; i < len; i += vl) {\n        // Create predicate for active lanes\n        svbool_t pg = svwhilelt_b8(i, len);\n        \n        // Load input string chunk\n        svuint8_t vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&s[i]));\n        \n        // Create mask for lowercase letters (a-z)\n        svbool_t is_lower = svand_b_z(svptrue_b8(), \n            svcmpge_u8(pg, vec, svdup_u8('a')),\n            svcmple_u8(pg, vec, svdup_u8('z'))\n        );\n        \n        // Apply rotation: (x - 'a' + 4) % 26 + 'a'\n        svuint8_t shifted = svsub_u8_x(pg, \n            svadd_u8_x(pg, \n                svsub_u8_x(pg, vec, svdup_u8('a')),\n                svdup_u8(4)\n            ),\n            svmul_u8_x(pg, \n                svdiv_u8_x(pg, \n                    svadd_u8_x(pg, \n                        svsub_u8_x(pg, vec, svdup_u8('a')),\n                        svdup_u8(4)\n                    ),\n                    svdup_u8(26)\n                ),\n                svdup_u8(26)\n            )\n        );\n        \n        // Add 'a' back to get final character\n        shifted = svadd_u8_m(is_lower, vec, \n            svadd_u8_x(pg, shifted, svdup_u8('a')));\n        \n        // Store result\n        svst1_u8(pg, reinterpret_cast<uint8_t*>(&result[i]), shifted);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encode_simd(const std::string &message) {\n    std::string result = message;\n    size_t len = message.size();\n    size_t i = 0;\n\n    while (i < len) {\n        svbool_t pg = svwhilelt_b8(i, len);\n        svuint8_t vec = svld1_u8(pg, (const uint8_t*)&message[i]);\n\n        // Swap case: XOR with 32 where letters (a-z or A-Z)\n        svbool_t is_lower = svcmplt_u8(pg, vec, svdup_u8('z'));\n        svbool_t is_upper = svcmpge_u8(pg, vec, svdup_u8('A'));\n        svbool_t is_letter = svand_b_z(pg, is_lower, svcmpge_u8(pg, vec, svdup_u8('a')));\n        is_letter = svorr_b_z(pg, is_letter, svand_b_z(pg, is_upper, svcmplt_u8(pg, vec, svdup_u8('Z'))));\n        svuint8_t case_mask = svdup_u8(32);\n        svuint8_t case_swapped = sveor_u8_m(pg, vec, svand_u8_x(pg, case_mask, svdup_u8(is_letter)));\n\n        // Vowel replacement: check for vowels (a,e,i,o,u,A,E,I,O,U)\n        svbool_t is_vowel = svorr_b_z(pg,\n            svorr_b_z(pg,\n                svorr_b_z(pg,\n                    svorr_b_z(pg,\n                        svcmpeq_u8(pg, vec, svdup_u8('a')),\n                        svcmpeq_u8(pg, vec, svdup_u8('e'))),\n                    svorr_b_z(pg,\n                        svcmpeq_u8(pg, vec, svdup_u8('i')),\n                        svcmpeq_u8(pg, vec, svdup_u8('o')))),\n                svcmpeq_u8(pg, vec, svdup_u8('u'))),\n            svorr_b_z(pg,\n                svorr_b_z(pg,\n                    svorr_b_z(pg,\n                        svcmpeq_u8(pg, vec, svdup_u8('A')),\n                        svcmpeq_u8(pg, vec, svdup_u8('E'))),\n                    svorr_b_z(pg,\n                        svcmpeq_u8(pg, vec, svdup_u8('I')),\n                        svcmpeq_u8(pg, vec, svdup_u8('O')))),\n                svcmpeq_u8(pg, vec, svdup_u8('U'))));\n\n        // Replace vowels with letter 2 positions ahead\n        svuint8_t vowel_shift = svadd_u8_m(pg, case_swapped, svdup_u8(2));\n        svuint8_t final_vec = svsel_u8(is_vowel, vowel_shift, case_swapped);\n\n        // Store result\n        svst1_u8(pg, (uint8_t*)&result[i], final_vec);\n        i += svcntb();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encode_simd(const std::string &message) {\n    std::string result = message;\n    size_t len = message.length();\n    size_t i = 0;\n\n    while (i < len) {\n        // Determine the number of elements that can be processed in one vector\n        uint64_t vlen = svcntb();\n        if (i + vlen > len) {\n            vlen = len - i;\n        }\n\n        // Create a predicate for active lanes\n        svbool_t pg = svwhilelt_b8(i, len);\n\n        // Load input characters\n        svuint8_t vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&message[i]));\n\n        // Swap case: lowercase to uppercase and vice versa\n        svuint8_t is_lower = svcmplt_u8(pg, vec, svdup_u8('z'));\n        svuint8_t is_upper = svcmpge_u8(pg, vec, svdup_u8('A'));\n        svbool_t is_lower_pred = svand_b_z(svptrue_b8(), is_lower, svcmple_u8(pg, vec, svdup_u8('z')));\n        svbool_t is_upper_pred = svand_b_z(svptrue_b8(), is_upper, svcmple_u8(pg, vec, svdup_u8('Z')));\n        \n        svuint8_t case_offset = svsel_u8(is_lower_pred, svdup_u8(-32), svdup_u8(32));\n        svuint8_t case_mask = svsel_u8(svor_b_z(svptrue_b8(), is_lower_pred, is_upper_pred), case_offset, svdup_u8(0));\n        svuint8_t case_swapped = svadd_u8_z(pg, vec, case_mask);\n\n        // Identify vowels\n        svbool_t is_vowel = svpfalse();\n        const char vowels[] = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n        for (char v : vowels) {\n            is_vowel = svor_b_z(pg, is_vowel, svcmpeq_u8(pg, case_swapped, svdup_u8(v)));\n        }\n\n        // Replace vowels with letter 2 places ahead\n        svuint8_t vowel_shift = svadd_u8_z(pg, case_swapped, svdup_u8(2));\n        svuint8_t final_vec = svsel_u8(is_vowel, vowel_shift, case_swapped);\n\n        // Store result\n        svst1_u8(pg, reinterpret_cast<uint8_t*>(&result[i]), final_vec);\n\n        i += vlen;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encode_simd(const std::string &message) {\n    std::string result = message;\n    size_t len = message.length();\n    \n    // Process in vector-sized chunks\n    for (size_t i = 0; i < len; i += svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, len);\n        \n        // Load input chunk\n        svuint8_t vec = svld1_u8(pg, (const uint8_t*)&message[i]);\n        \n        // Create masks for uppercase and lowercase letters\n        svbool_t is_lower = svcmplt_u8(pg, vec, svdup_u8('z'));\n        svbool_t is_upper = svcmpge_u8(pg, vec, svdup_u8('A'));\n        is_lower = svand_b_z(pg, is_lower, svcmpge_u8(pg, vec, svdup_u8('a')));\n        is_upper = svand_b_z(pg, is_upper, svcmplt_u8(pg, vec, svdup_u8('Z')));\n        \n        // Swap case: lower to upper (subtract 32), upper to lower (add 32)\n        svuint8_t swap_case = svsel_u8(\n            is_lower,\n            svsub_u8_z(pg, vec, svdup_u8(32)),\n            svsel_u8(is_upper, svadd_u8_z(pg, vec, svdup_u8(32)), vec)\n        );\n        \n        // Create vowel masks (a,e,i,o,u,A,E,I,O,U)\n        svbool_t is_vowel = svpfalse();\n        for (char v : {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}) {\n            is_vowel = svorr_b_z(pg, is_vowel, svcmpeq_u8(pg, swap_case, svdup_u8(v)));\n        }\n        \n        // Shift vowels by 2 (a->c, e->g, etc.)\n        svuint8_t vowel_shift = svadd_u8_z(pg, swap_case, svdup_u8(2));\n        \n        // Apply vowel shift only to vowels\n        svuint8_t final_vec = svsel_u8(is_vowel, vowel_shift, swap_case);\n        \n        // Store result\n        svst1_u8(pg, (uint8_t*)&result[i], final_vec);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message) {\n    std::string result = message;\n    size_t len = message.size();\n    size_t i = 0;\n\n    for (; i + svcntb() <= len; i += svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, len);\n        \n        // Load input chunk\n        svuint8_t vec = svld1_u8(pg, (uint8_t*)&message[i]);\n        \n        // Swap case: (x ^ 32) toggles case for letters\n        svuint8_t is_lower = svcmplt_u8(pg, vec, svdup_u8('a'));\n        svuint8_t is_upper = svcmpgt_u8(pg, vec, svdup_u8('Z'));\n        svbool_t is_letter = svand_b_z(pg, is_lower, is_upper);\n        svuint8_t case_swap = sveor_u8_m(pg, vec, svdup_u8(32));\n        \n        // Vowel detection and shift\n        svbool_t is_vowel = svorr_b_z(pg,\n            svorr_b_z(pg,\n                svorr_b_z(pg,\n                    svcmpeq_u8(pg, vec, svdup_u8('a')),\n                    svcmpeq_u8(pg, vec, svdup_u8('e'))),\n                svorr_b_z(pg,\n                    svcmpeq_u8(pg, vec, svdup_u8('i')),\n                    svcmpeq_u8(pg, vec, svdup_u8('o')))),\n            svcmpeq_u8(pg, vec, svdup_u8('u')));\n        \n        svuint8_t vowel_shift = svadd_u8_z(pg, vec, svdup_u8(2));\n        \n        // Combine case swap and vowel shift\n        svuint8_t final_vec = svsel_u8(is_vowel, vowel_shift, case_swap);\n        \n        // Store result\n        svst1_u8(pg, (uint8_t*)&result[i], final_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < len; i++) {\n        char c = message[i];\n        // Swap case\n        if (c >= 'a' && c <= 'z') {\n            c = c - 32;\n        } else if (c >= 'A' && c <= 'Z') {\n            c = c + 32;\n        }\n        // Shift vowels\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n            c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            c = c + 2;\n        }\n        result[i] = c;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encode_simd(const std::string &message) {\n    std::string result = message;\n    size_t len = message.length();\n    \n    // Process input in chunks based on vector length\n    svbool_t pg = svwhilelt_b8(0, len);\n    size_t vlen = svcntb();\n    \n    for (size_t i = 0; i < len; i += vlen) {\n        // Update predicate for remaining elements\n        pg = svwhilelt_b8(i, len);\n        \n        // Load input chunk\n        svuint8_t vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&message[i]));\n        \n        // Create masks for lowercase and uppercase\n        svbool_t is_lower = svcmplt_u8(pg, vec, svdup_u8('z'));\n        is_lower = svand_b_z(pg, is_lower, svcmpgt_u8(pg, vec, svdup_u8('a'-1)));\n        \n        svbool_t is_upper = svcmplt_u8(pg, vec, svdup_u8('Z'));\n        is_upper = svand_b_z(pg, is_upper, svcmpgt_u8(pg, vec, svdup_u8('A'-1)));\n        \n        // Swap case: lowercase to uppercase (subtract 32), uppercase to lowercase (add 32)\n        svuint8_t to_upper = svsub_u8_z(pg, vec, svdup_u8(32));\n        svuint8_t to_lower = svadd_u8_z(pg, vec, svdup_u8(32));\n        \n        svuint8_t case_swapped = svsel_u8(is_lower, to_upper, vec);\n        case_swapped = svsel_u8(is_upper, to_lower, case_swapped);\n        \n        // Handle vowel replacement (a->c, e->g, i->k, o->q, u->w)\n        svbool_t is_vowel = svdup_b8(false);\n        const char vowels[] = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n        for (char v : vowels) {\n            is_vowel = svorr_b_z(pg, is_vowel, svcmpeq_u8(pg, case_swapped, svdup_u8(v)));\n        }\n        \n        // Add 2 to vowels\n        svuint8_t vowel_shifted = svadd_u8_z(pg, case_swapped, svdup_u8(2));\n        \n        // Select between shifted vowels and original characters\n        svuint8_t final_vec = svsel_u8(is_vowel, vowel_shifted, case_swapped);\n        \n        // Store result\n        svst1_u8(pg, reinterpret_cast<uint8_t*>(&result[i]), final_vec);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <map>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    svbool_t pg = svptrue_b8();\n    bool first_case_set = false;\n    bool is_upper = false;\n    bool is_lower = false;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        size_t len = key.length();\n        if (len == 0) return false;\n\n        svuint8_t vec = svundef_u8();\n        size_t i = 0;\n\n        // Load string into vector in chunks\n        while (i < len) {\n            size_t remaining = len - i;\n            size_t chunk_size = std::min(remaining, svcntb());\n            \n            // Create a predicate for valid bytes\n            svbool_t load_pg = svwhilelt_b8(i, len);\n            \n            // Load chunk of string\n            if (i + chunk_size <= len) {\n                vec = svld1_u8(load_pg, (uint8_t*)&key[i]);\n            }\n\n            // Check for uppercase (A-Z)\n            svbool_t is_upper_vec = svand_b_z(pg, \n                svcmpge_u8(pg, vec, svdup_u8('A')),\n                svcmple_u8(pg, vec, svdup_u8('Z'))\n            );\n\n            // Check for lowercase (a-z)\n            svbool_t is_lower_vec = svand_b_z(pg, \n                svcmpge_u8(pg, vec, svdup_u8('a')),\n                svcmple_u8(pg, vec, svdup_u8('z'))\n            );\n\n            // Check for non-letter characters\n            svbool_t is_letter = svorr_b_z(pg, is_upper_vec, is_lower_vec);\n            svbool_t is_non_letter = svnot_b_z(pg, is_letter);\n\n            // If any character is neither upper nor lower case, return false\n            if (svptest_any(pg, is_non_letter)) {\n                return false;\n            }\n\n            // On first iteration, set the case based on what's found\n            if (!first_case_set) {\n                is_upper = svptest_any(pg, is_upper_vec);\n                is_lower = svptest_any(pg, is_lower_vec);\n                first_case_set = true;\n                \n                // If neither upper nor lower case letters found, return false\n                if (!is_upper && !is_lower) return false;\n            } else {\n                // For subsequent keys, check consistency\n                if (is_upper && svptest_any(pg, is_lower_vec)) return false;\n                if (is_lower && svptest_any(pg, is_upper_vec)) return false;\n            }\n\n            i += chunk_size;\n        }\n    }\n\n    // Return true only if we found at least one valid case\n    return first_case_set && (is_upper || is_lower);\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <map>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    // Get vector length in bytes\n    int64_t vlen = svcntb();\n    \n    // Initialize flags for case checking\n    bool first_is_upper = false;\n    bool first_is_lower = false;\n    \n    // Process keys in chunks that fit SVE vector length\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        \n        // If key contains non-letters, return false\n        svbool_t pg = svptrue_b8();\n        size_t key_len = key.length();\n        size_t pos = 0;\n        \n        while (pos < key_len) {\n            // Load chunk of string into vector\n            svuint8_t chars = svld1_u8(pg, (uint8_t*)(key.c_str() + pos));\n            \n            // Check if characters are letters\n            svbool_t is_letter = svorr_b_z(pg, \n                svand_b_z(pg, svcmpge_u8(pg, chars, svdup_u8('A')), \n                         svcmple_u8(pg, chars, svdup_u8('Z'))),\n                svand_b_z(pg, svcmpge_u8(pg, chars, svdup_u8('a')), \n                         svcmple_u8(pg, chars, svdup_u8('z'))));\n            \n            // If any character is not a letter, return false\n            if (!svptest_all(pg, is_letter)) {\n                return false;\n            }\n            \n            pos += vlen;\n            if (pos < key_len) {\n                // Update predicate for remaining bytes\n                pg = svwhilelt_b8(pos, key_len);\n            }\n        }\n        \n        // For first key, set case reference\n        if (!first_is_upper && !first_is_lower) {\n            if (!key.empty()) {\n                char c = key[0];\n                first_is_upper = (c >= 'A' && c <= 'Z');\n                first_is_lower = (c >= 'a' && c <= 'z');\n            }\n            continue;\n        }\n        \n        // Check if key matches first key's case\n        bool is_upper = false;\n        bool is_lower = false;\n        if (!key.empty()) {\n            char c = key[0];\n            is_upper = (c >= 'A' && c <= 'Z');\n            is_lower = (c >= 'a' && c <= 'z');\n        }\n        \n        // If case doesn't match first key's case, return false\n        if ((first_is_upper && !is_upper) || (first_is_lower && !is_lower)) {\n            return false;\n        }\n    }\n    \n    return first_is_upper || first_is_lower;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <map>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    // Get vector length\n    uint64_t vlen = svcntb();\n    \n    // Initialize flags for case detection\n    bool has_lower = false;\n    bool has_upper = false;\n    \n    // Process map keys\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        size_t len = key.length();\n        \n        // Process string in vector-sized chunks\n        size_t i = 0;\n        while (i < len) {\n            // Create predicate for valid characters\n            svbool_t pg = svwhilelt_b8(i, len);\n            \n            // Load string chunk\n            svuint8_t chars = svld1_u8(pg, (uint8_t*)&key[i]);\n            \n            // Check for lowercase (a-z)\n            svbool_t is_lower = svand_b_z(pg, \n                svcmpge_u8(pg, chars, svdup_u8('a')),\n                svcmple_u8(pg, chars, svdup_u8('z')));\n            \n            // Check for uppercase (A-Z)\n            svbool_t is_upper = svand_b_z(pg, \n                svcmpge_u8(pg, chars, svdup_u8('A')),\n                svcmple_u8(pg, chars, svdup_u8('Z')));\n            \n            // Check for non-letter characters\n            svbool_t is_non_letter = svnot_b_z(pg, \n                svorr_b_z(pg, is_lower, is_upper));\n            \n            // Update flags\n            has_lower |= svptest_any(pg, is_lower);\n            has_upper |= svptest_any(pg, is_upper);\n            \n            // If non-letter found, return false\n            if (svptest_any(pg, is_non_letter)) {\n                return false;\n            }\n            \n            i += vlen;\n        }\n    }\n    \n    // Return true if all keys are either all lower or all upper\n    return has_lower != has_upper;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <map>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    svbool_t pg = svptrue_b8();\n    bool first_case_set = false;\n    bool is_upper = false;\n    bool result = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        svuint8_t vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(key.c_str()));\n        \n        // Create masks for uppercase (A-Z) and lowercase (a-z)\n        svbool_t is_upper_mask = svand_b_z(pg, \n            svcmpge_u8(pg, vec, svdup_u8('A')),\n            svcmple_u8(pg, vec, svdup_u8('Z')));\n        svbool_t is_lower_mask = svand_b_z(pg, \n            svcmpge_u8(pg, vec, svdup_u8('a')),\n            svcmple_u8(pg, vec, svdup_u8('z')));\n        svbool_t is_letter_mask = svorr_b_z(pg, is_upper_mask, is_lower_mask);\n        \n        // Check if all characters are letters\n        svbool_t is_valid_char = svcmpeq_u8(pg, vec, svdup_u8(0));\n        is_valid_char = svorn_b_z(pg, is_letter_mask, is_valid_char);\n        if (!svptest_all(pg, is_valid_char)) {\n            return false;\n        }\n\n        // Count uppercase and lowercase letters\n        uint64_t upper_count = svcntp_b8(pg, is_upper_mask);\n        uint64_t lower_count = svcntp_b8(pg, is_lower_mask);\n        \n        // If first key, set the case to check\n        if (!first_case_set) {\n            if (upper_count > 0 && lower_count == 0) {\n                is_upper = true;\n            } else if (lower_count > 0 && upper_count == 0) {\n                is_upper = false;\n            } else {\n                return false;\n            }\n            first_case_set = true;\n        } else {\n            // Check consistency with first key's case\n            if (is_upper && (lower_count > 0 || upper_count == 0)) {\n                return false;\n            }\n            if (!is_upper && (upper_count > 0 || lower_count == 0)) {\n                return false;\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <map>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    // Get vector length in bytes\n    svbool_t pg = svwhilelt_b8(0, svcntb());\n    svuint8_t upper_mask = svdup_u8(0xDF); // For converting to uppercase (~0x20)\n    svuint8_t alpha_mask = svdup_u8(0);\n    \n    // Create masks for alphabetic characters\n    svbool_t alpha_pred = svptrue_b8();\n    svuint8_t a_to_z = svdup_u8('a');\n    svuint8_t z_to_a = svdup_u8('z');\n    svuint8_t A_to_Z = svdup_u8('A');\n    svuint8_t Z_to_A = svdup_u8('Z');\n\n    bool first_is_upper = false;\n    bool first_is_lower = false;\n    bool first_checked = false;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        size_t len = key.length();\n        size_t i = 0;\n\n        while (i < len) {\n            // Load string chunk into vector\n            svbool_t load_pred = svwhilelt_b8(i, len);\n            svuint8_t vec = svld1_u8(load_pred, (uint8_t*)&key[i]);\n\n            // Check if characters are alphabetic\n            svbool_t is_lower = svand_b_z(pg, svcmpge_u8(pg, vec, a_to_z), svcmple_u8(pg, vec, z_to_a));\n            svbool_t is_upper = svand_b_z(pg, svcmpge_u8(pg, vec, A_to_Z), svcmple_u8(pg, vec, Z_to_A));\n            svbool_t is_alpha = svorr_b_z(pg, is_lower, is_upper);\n\n            // If any character is non-alphabetic, return false\n            if (!svptest_all(pg, is_alpha)) return false;\n\n            if (!first_checked) {\n                // For first key, determine case\n                first_is_upper = svptest_any(pg, is_upper);\n                first_is_lower = svptest_any(pg, is_lower);\n                first_checked = true;\n            } else {\n                // For subsequent keys, check consistency\n                if (first_is_upper && svptest_any(pg, is_lower)) return false;\n                if (first_is_lower && svptest_any(pg, is_upper)) return false;\n            }\n\n            i += svcntb();\n        }\n    }\n\n    return first_checked;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> result;\n    if (n <= 2) return result;\n\n    // Calculate vector length\n    uint64_t vlen = svcntw();\n    svbool_t pg = svptrue_b32();\n    \n    // Allocate temporary arrays for processing\n    std::vector<int> numbers(n);\n    std::vector<uint8_t> is_prime(n, 1);\n    is_prime[0] = is_prime[1] = 0;\n\n    // Sieve of Eratosthenes with SVE\n    for (int i = 2; i * i < n; ++i) {\n        if (is_prime[i]) {\n            svint32_t vec_i = svdup_n_s32(i);\n            svint32_t vec_ii = svdup_n_s32(i * i);\n            \n            for (int j = i * i; j < n; j += vlen * i) {\n                svint32_t vec_j = svadd_n_s32(svrange_s32(svdup_n_s32(j), svdup_n_s32(i)), 0, vlen);\n                svbool_t mask = svwhilelt_b32(j, n);\n                \n                while (svptest_any(pg, mask)) {\n                    svst1_s32(mask, &is_prime[j], svdup_n_s32(0));\n                    j += vlen * i;\n                    vec_j = svadd_n_s32(vec_j, svdup_n_s32(vlen * i));\n                    mask = svwhilelt_b32(j, n);\n                }\n            }\n        }\n    }\n\n    // Collect prime numbers\n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) {\n            result.push_back(i);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> result;\n    if (n <= 2) return result;\n\n    // Determine vector length and allocate buffer\n    const int64_t vec_len = svcntw();\n    std::vector<int> buffer(n, 0);\n    \n    // Initialize buffer: 0 for composite, 1 for potential primes\n    for (int i = 2; i < n; ++i) {\n        buffer[i] = 1;\n    }\n    \n    // Sieve of Eratosthenes using SVE\n    for (int i = 2; i * i < n; ++i) {\n        if (buffer[i]) {\n            svbool_t pg = svptrue_b32();\n            svint32_t vec_i = svdup_n_s32(i);\n            svint32_t vec_k = svindex_s32(i * i, i);\n            \n            while (svptest_any(pg, svwhilelt_b32(svunpklo_s32(vec_k), n))) {\n                svbool_t mask = svwhilelt_b32(svunpklo_s32(vec_k), n);\n                svst1_s32(pg, &buffer[0] + svunpklo_s32(vec_k)[0], svdup_n_s32(0));\n                vec_k = svadd_n_s32_x(pg, vec_k, i);\n            }\n        }\n    }\n    \n    // Collect primes\n    for (int i = 2; i < n; ++i) {\n        if (buffer[i]) {\n            result.push_back(i);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> result;\n    if (n <= 2) return result;\n\n    // Get vector length in bytes\n    int64_t vlen = svcntw();\n    \n    // Allocate temporary array for potential primes\n    std::vector<int> temp(n);\n    for (int i = 0; i < n; i++) {\n        temp[i] = i;\n    }\n\n    // Create predicate for valid numbers (2 to n-1)\n    svbool_t pg = svptrue_b32();\n    svint32_t numbers = svindex_s32(0, 1);\n    \n    // Process numbers in vector-sized chunks\n    for (int i = 2; i < n; i += vlen) {\n        // Load current batch of numbers\n        svint32_t current = svld1_s32(pg, &temp[i]);\n        \n        // Initialize prime flags (true = potentially prime)\n        svbool_t is_prime = svptrue_b32();\n        \n        // Sieve method: test divisibility for each number up to sqrt(n)\n        for (int j = 2; j * j <= n; j++) {\n            svint32_t divisor = svdup_s32(j);\n            svint32_t remainder = svmod_n_s32_z(pg, current, divisor);\n            svbool_t divides = svcmpeq_n_s32(pg, remainder, 0);\n            \n            // Mark non-prime numbers (exclude j itself)\n            svbool_t not_self = svcmpne_n_s32(pg, current, j);\n            is_prime = svand_b_z(pg, is_prime, svnot_b_z(pg, svand_b_z(pg, divides, not_self)));\n        }\n        \n        // Store prime numbers\n        int32_t indices[vlen];\n        svst1_s32(pg, indices, current);\n        \n        // Collect primes from this batch\n        svbool_t active = svwhilelt_b32(i, n);\n        while (svptest_any(pg, svand_b_z(pg, is_prime, active))) {\n            for (int j = 0; j < vlen && i + j < n; j++) {\n                if (svptest_first(is_prime, svptrue_b32()) && indices[j] >= 2) {\n                    result.push_back(indices[j]);\n                }\n                is_prime = svlsr_n_b32(is_prime, 1);\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> result;\n    if (n <= 2) return result;\n\n    // Allocate temporary array for numbers 2 to n-1\n    std::vector<int> numbers(n-2);\n    for (int i = 0; i < n-2; i++) {\n        numbers[i] = i + 2;\n    }\n\n    // Create mask for prime numbers\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n\n    // Sieve of Eratosthenes using SVE\n    int sqrt_n = sqrt(n);\n    for (int i = 2; i <= sqrt_n; i++) {\n        if (is_prime[i]) {\n            // Create vector of step size i\n            svbool_t pg = svwhilelt_b32(0, n);\n            svint32_t vec_i = svdup_s32(i);\n            svint32_t vec_i2 = svmul_s32_z(pg, vec_i, vec_i);\n\n            // Mark multiples as non-prime\n            for (int j = i * i; j < n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n\n    // Collect prime numbers\n    svbool_t pg = svwhilelt_b32(0, n-2);\n    svint32_t vec_nums = svld1_s32(pg, numbers.data());\n    svbool_t vec_is_prime = svld1_u8(pg, is_prime.data() + 2);\n\n    // Use SVE to select prime numbers\n    int idx = 0;\n    while (svptest_any(svptrue_b32(), vec_is_prime)) {\n        svbool_t active = svwhilelt_b32(idx, n-2);\n        svint32_t primes = svcompact_s32(vec_is_prime, vec_nums);\n        \n        // Store results\n        int count = svcntp_b32(svptrue_b32(), vec_is_prime);\n        int temp[count];\n        svst1_s32(svptrue_b32(), temp, primes);\n        \n        for (int k = 0; k < count && result.size() < n-2; k++) {\n            result.push_back(temp[k]);\n        }\n        \n        idx += count;\n        vec_nums = svld1_s32(active, numbers.data() + idx);\n        vec_is_prime = svld1_u8(active, is_prime.data() + 2 + idx);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> result;\n    if (n <= 2) return result;\n\n    // Get vector length\n    uint64_t vlen = svcntw();\n    \n    // Create predicate for active lanes\n    svbool_t pg = svptrue_b32();\n    \n    // Process numbers in vector-sized chunks\n    for (int i = 2; i < n; i += vlen) {\n        // Create vector of current numbers\n        svint32_t indices = svindex_s32(i, 1);\n        \n        // Initialize is_prime vector\n        svbool_t is_prime = svptrue_b32();\n        \n        // Test primality for each number\n        for (int j = 2; j * j <= i + vlen && j * j < n; j++) {\n            svint32_t j_vec = svdup_s32(j);\n            svint32_t j_squared = svmul_s32_z(pg, j_vec, j_vec);\n            \n            // Check if numbers are divisible by j\n            svbool_t div_mask = svcmpeq_s32(pg, svmul_s32_z(pg, svdiv_s32_z(pg, indices, j_vec), j_vec), indices);\n            // Numbers divisible by j are not prime\n            is_prime = svand_b_z(pg, is_prime, svnot_b_z(pg, div_mask));\n        }\n        \n        // Store prime numbers\n        int32_t temp[vlen];\n        svst1_s32(pg, temp, indices);\n        \n        // Collect results\n        svbool_t active = svand_b_z(pg, is_prime, svcmplt_s32(pg, indices, n));\n        while (svptest_any(pg, active)) {\n            int first_active = svcntp_b32(pg, active);\n            for (int k = 0; k < first_active; k++) {\n                if (temp[k] >= n) break;\n                if (svptest_nth(active, k)) {\n                    result.push_back(temp[k]);\n                }\n            }\n            active = svnot_b_z(pg, active);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint count_upper_simd(const std::string & s) {\n    int count = 0;\n    size_t len = s.length();\n    const char *str = s.c_str();\n    \n    svbool_t pg = svwhilelt_b8(0, len);\n    size_t i = 0;\n    \n    while (i < len) {\n        svuint8_t vec = svld1_u8(pg, (const uint8_t *)(str + i));\n        \n        // Create mask for even indices\n        svbool_t even_mask = svzip1_b(svptrue_b8(), svpfalse_b());\n        even_mask = svand_b_z(svptrue_b8(), even_mask, pg);\n        \n        // Check for uppercase letters (A-Z)\n        svbool_t upper_mask = svand_b_z(\n            svcmpge_u8(pg, vec, svdup_u8('A')),\n            svcmple_u8(pg, vec, svdup_u8('Z')),\n            pg\n        );\n        \n        // Check for vowels (A, E, I, O, U)\n        svbool_t vowel_mask = svorr_b_z(\n            svorr_b_z(\n                svorr_b_z(\n                    svorr_b_z(\n                        svcmpeq_u8(pg, vec, svdup_u8('A')),\n                        svcmpeq_u8(pg, vec, svdup_u8('E')),\n                        pg\n                    ),\n                    svcmpeq_u8(pg, vec, svdup_u8('I')),\n                    pg\n                ),\n                svcmpeq_u8(pg, vec, svdup_u8('O')),\n                pg\n            ),\n            svcmpeq_u8(pg, vec, svdup_u8('U')),\n            pg\n        );\n        \n        // Combine masks: even indices AND uppercase AND vowels\n        svbool_t final_mask = svand_b_z(svand_b_z(even_mask, upper_mask, pg), vowel_mask, pg);\n        \n        // Count true predicates\n        count += svcntp_b8(pg, final_mask);\n        \n        // Update index and predicate\n        i += svcntb();\n        pg = svwhilelt_b8(i, len);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint count_upper_simd(const std::string & s) {\n    const char *str = s.c_str();\n    int len = s.length();\n    int count = 0;\n    \n    svbool_t pg = svwhilelt_b8(0, len);\n    svuint8_t indices = svindex_u8(0, 2);\n    \n    for (int i = 0; i < len; i += svcntb()) {\n        pg = svwhilelt_b8(i, len);\n        svuint8_t vec = svld1_u8(pg, &str[i]);\n        \n        // Check for uppercase letters (A-Z)\n        svbool_t is_upper = svand_b_z(pg, \n            svcmpge_u8(pg, vec, 'A'),\n            svcmple_u8(pg, vec, 'Z')\n        );\n        \n        // Check for vowels (A, E, I, O, U)\n        svbool_t is_vowel = svorr_b_z(pg,\n            svorr_b_z(pg,\n                svorr_b_z(pg,\n                    svorr_b_z(pg,\n                        svcmpeq_u8(pg, vec, 'A'),\n                        svcmpeq_u8(pg, vec, 'E')\n                    ),\n                    svcmpeq_u8(pg, vec, 'I')\n                ),\n                svcmpeq_u8(pg, vec, 'O')\n            ),\n            svcmpeq_u8(pg, vec, 'U')\n        );\n        \n        // Check for even indices\n        svbool_t is_even = svcmpeq_u8(pg, svand_u8_z(pg, indices, 1), 0);\n        \n        // Combine conditions\n        svbool_t match = svand_b_z(pg, svand_b_z(pg, is_upper, is_vowel), is_even);\n        \n        // Count matches\n        count += svcntp_b8(match, match);\n        \n        // Update indices for next iteration\n        indices = svadd_u8_z(pg, indices, svcntb() * 2);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint count_upper_simd(const std::string &s) {\n    int count = 0;\n    const char *str = s.c_str();\n    size_t len = s.length();\n    size_t i = 0;\n\n    // Vectorized processing for even indices\n    svbool_t pg = svwhilelt_b8(i, len);\n    while (svptest_any(svptrue_b8(), pg)) {\n        // Load characters\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)(str + i));\n\n        // Check for even indices (0, 2, 4, ...)\n        svbool_t even_mask = svzip1_b(svptrue_b8(), svpfalse_b());\n        svbool_t valid_mask = svand_b_z(svptrue_b8(), pg, even_mask);\n\n        // Check for uppercase vowels (A, E, I, O, U)\n        svbool_t is_A = svcmpeq_u8(valid_mask, chars, 'A');\n        svbool_t is_E = svcmpeq_u8(valid_mask, chars, 'E');\n        svbool_t is_I = svcmpeq_u8(valid_mask, chars, 'I');\n        svbool_t is_O = svcmpeq_u8(valid_mask, chars, 'O');\n        svbool_t is_U = svcmpeq_u8(valid_mask, chars, 'U');\n\n        // Combine vowel checks\n        svbool_t is_vowel = svorr_b_z(svptrue_b8(), is_A, \n                                    svorr_b_z(svptrue_b8(), is_E,\n                                    svorr_b_z(svptrue_b8(), is_I,\n                                    svorr_b_z(svptrue_b8(), is_O, is_U))));\n\n        // Count valid vowels\n        count += svcntp_b8(is_vowel, is_vowel);\n\n        // Move to next vector (step by vector length)\n        i += svcntb() * 2; // *2 to skip to next even indices\n        pg = svwhilelt_b8(i, len);\n    }\n\n    // Handle remaining characters\n    for (; i < len; i += 2) {\n        char c = str[i];\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n\nint count_upper_simd(const std::string & s) {\n    int count = 0;\n    const char *str = s.c_str();\n    size_t len = s.length();\n    svbool_t pg = svwhilelt_b8(0, len);\n\n    for (size_t i = 0; i < len; i += svcntb()) {\n        svbool_t p = svwhilelt_b8(i, len);\n        svuint8_t vec = svld1_u8(p, (const uint8_t*)(str + i));\n        \n        // Check even indices\n        svbool_t even_mask = svzip1_b(svpfalse_b(), svptrue_b8());\n        \n        // Check for uppercase vowels (A, E, I, O, U)\n        svbool_t is_upper_vowel = svorr_b_z(pg,\n            svorr_b_z(pg,\n                svorr_b_z(pg,\n                    svorr_b_z(pg,\n                        svcmpeq_n_u8(p, vec, 'A'),\n                        svcmpeq_n_u8(p, vec, 'E')\n                    ),\n                    svcmpeq_n_u8(p, vec, 'I')\n                ),\n                svcmpeq_n_u8(p, vec, 'O')\n            ),\n            svcmpeq_n_u8(p, vec, 'U')\n        );\n        \n        // Combine even indices and uppercase vowels\n        svbool_t result_mask = svand_b_z(pg, is_upper_vowel, even_mask);\n        \n        // Count true elements\n        count += svcntp_b8(p, result_mask);\n        \n        pg = svwhilelt_b8(i + svcntb(), len);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint count_upper_simd(const std::string & s) {\n    int count = 0;\n    size_t len = s.length();\n    size_t i = 0;\n\n    // Create predicate for even indices\n    svbool_t pg = svptrue_b8();\n    svbool_t even_pg = svzip1_b8(svptrue_b8(), svpfalse_b8());\n\n    for (; i < len && i + svcntb() <= len; i += svcntb()) {\n        // Load string chunk\n        svuint8_t vec = svld1_u8(pg, (uint8_t*)&s[i]);\n        \n        // Check for uppercase (A-Z)\n        svbool_t is_upper = svand_b_z(pg, svcmpge_u8(pg, vec, 'A'), svcmple_u8(pg, vec, 'Z'));\n        \n        // Check for vowels\n        svbool_t is_vowel = svorr_b_z(pg, \n            svorr_b_z(pg, \n                svorr_b_z(pg, \n                    svorr_b_z(pg, \n                        svcmpeq_u8(pg, vec, 'A'),\n                        svcmpeq_u8(pg, vec, 'E')),\n                    svcmpeq_u8(pg, vec, 'I')),\n                svcmpeq_u8(pg, vec, 'O')),\n            svcmpeq_u8(pg, vec, 'U'));\n\n        // Combine conditions: uppercase AND vowel AND even index\n        svbool_t match = svand_b_z(pg, svand_b_z(pg, is_upper, is_vowel), even_pg);\n        \n        // Count matches\n        count += svcntp_b8(pg, match);\n\n        // Shift even/odd predicate for next iteration\n        even_pg = svnot_b_z(pg, even_pg);\n    }\n\n    // Handle remaining elements scalarly\n    for (; i < len; i += 2) {\n        char c = s[i];\n        if (c >= 'A' && c <= 'Z' && \n            (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U')) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    svbool_t pg = svptrue_b32();\n    int32_t base = n;\n    \n    // Process elements in chunks based on vector length\n    for (int i = 0; i < n; i += svcntw()) {\n        // Create vector for indices\n        svint32_t indices = svindex_s32(i, 1);\n        \n        // Create vector with base value n\n        svint32_t n_vec = svdup_s32(base);\n        \n        // Calculate: if n is odd, add 2*i + 2; if even, add 2*i + 2\n        svint32_t offset = svmul_s32_z(pg, indices, svdup_s32(2));\n        offset = svadd_s32_z(pg, offset, svdup_s32(2));\n        \n        // Result = n + offset\n        svint32_t pile = svadd_s32_z(pg, n_vec, offset);\n        \n        // Store results to memory\n        int remaining = n - i;\n        svbool_t store_pg = svwhilelt_b32(i, n);\n        svst1_s32(store_pg, &result[i], pile);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    svbool_t pg = svptrue_b32();\n    int32_t base = n;\n    \n    for (int i = 0; i < n; i += svcntw()) {\n        svint32_t indices = svindex_s32(i, 1);\n        svint32_t values = svadd_n_s32_z(pg, indices, base);\n        svint32_t is_odd = svand_n_s32_z(pg, values, 1);\n        svint32_t next_num = svadd_n_s32_z(pg, values, svadd_n_s32_z(pg, is_odd, 1));\n        svst1_s32(pg, &result[i], next_num);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    svbool_t pg = svptrue_b32();\n    int32_t base = n;\n    svint32_t vec = svdup_s32(base);\n    \n    for (int i = 0; i < n; i += svcntw()) {\n        svint32_t indices = svindex_s32(i, 1);\n        svint32_t increments = svadd_s32_z(pg, indices, svdup_s32(1));\n        svint32_t is_odd = svand_s32_z(pg, vec, svdup_s32(1));\n        svint32_t offset = svadd_s32_z(pg, increments, is_odd);\n        svint32_t values = svadd_s32_z(pg, vec, svmul_s32_z(pg, offset, svdup_s32(2)));\n        \n        svst1_s32(pg, &result[i], values);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    svbool_t pg = svptrue_b32();\n    int32_t i = 0;\n\n    while (i < n) {\n        svint32_t indices = svindex_s32(i, 1);\n        svint32_t stones = svadd_n_s32_z(pg, indices, n);\n        svint32_t parity = svand_n_s32_z(pg, stones, 1);\n        svint32_t next_num = svadd_n_s32_z(pg, stones, svadd_n_s32_z(pg, parity, 1));\n\n        uint64_t active_lanes = svcntw();\n        int store_count = std::min(static_cast<int>(active_lanes), n - i);\n        svst1_s32(pg, &result[i], next_num);\n\n        i += store_count;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    svbool_t pg = svptrue_b32();\n    int32_t base = n;\n    svint32_t vec = svdup_s32(base);\n    svint32_t increment = svdup_s32(2);\n    svint32_t indices = svindex_s32(0, 1);\n\n    for (int i = 0; i < n; i += svcntw()) {\n        svbool_t mask = svwhilelt_b32(i, n);\n        svint32_t values = svadd_s32_z(mask, vec, svmul_s32_z(mask, indices, increment));\n        svst1_s32(mask, &result[i], values);\n        indices = svadd_s32_z(pg, indices, svdup_s32(svcntw()));\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n\n    int64_t count = m - n + 1;\n    int64_t vector_length = svcntd();\n    svbool_t pg = svwhilelt_b64(0, count);\n    \n    int64_t sum = 0;\n    int64_t i = n;\n    \n    while (i <= m) {\n        svint64_t vec = svindex\u53f8\u9a6c64(i, 1);\n        svint64_t masked_vec = svsel_s64(pg, vec, svdup_s64(0));\n        sum += svaddv_s64(pg, masked_vec);\n        i += vector_length;\n        pg = svwhilelt_b64(i - n, count);\n    }\n    \n    int64_t avg = sum / count;\n    if (avg == 0) return \"0\";\n    \n    std::string binary = \"\";\n    while (avg > 0) {\n        binary = (avg & 1 ? \"1\" : \"0\") + binary;\n        avg >>= 1;\n    }\n    \n    return binary;\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n\n    int64_t count = m - n + 1;\n    svbool_t pg = svwhilelt_b64(n, m + 1);\n    svint64_t vec = svindex_s64(n, 1);\n    int64_t sum = svaddv_s64(pg, vec);\n    int64_t avg = (sum + (count >> 1)) / count;\n\n    std::string binary = \"\";\n    while (avg > 0) {\n        binary = (avg & 1 ? \"1\" : \"0\") + binary;\n        avg >>= 1;\n    }\n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n    \n    int64_t count = m - n + 1;\n    int64_t vector_length = svcntd();\n    int64_t sum = 0;\n    \n    svbool_t pg = svptrue_b64();\n    \n    // Process in vector-sized chunks\n    int64_t i = n;\n    for (; i <= m - vector_length; i += vector_length) {\n        svint64_t vec = svindex_s64(i, 1);\n        sum += svaddv_s64(pg, vec);\n    }\n    \n    // Handle remaining elements\n    for (; i <= m; i++) {\n        sum += i;\n    }\n    \n    // Calculate average and round down\n    int64_t avg = sum / count;\n    \n    // Convert to binary string\n    if (avg == 0) return \"0\";\n    \n    std::string binary = \"\";\n    while (avg > 0) {\n        binary = (avg % 2 ? \"1\" : \"0\") + binary;\n        avg /= 2;\n    }\n    \n    return binary;\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n\n    int64_t count = m - n + 1;\n    svbool_t pg = svwhilelt_b64(n, m + 1);\n    svint64_t vec = svindex_s64(n, 1);\n    int64_t sum = svaddv_s64(pg, vec);\n    int64_t avg = sum / count;\n    \n    if (sum % count * 2 >= count) avg++;\n    \n    if (avg == 0) return \"0\";\n    \n    std::string binary = \"\";\n    while (avg > 0) {\n        binary = (avg & 1 ? \"1\" : \"0\") + binary;\n        avg >>= 1;\n    }\n    \n    return binary;\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n    \n    int64_t count = m - n + 1;\n    svbool_t pg = svwhilelt_b64(n, m + 1);\n    \n    svint64_t vec = svindex_s64(n, 1);\n    int64_t sum = svaddv_s64(pg, vec);\n    \n    int64_t avg = sum / count;\n    if (sum % count >= (count + 1) / 2) avg++;\n    \n    std::string binary = \"\";\n    if (avg == 0) return \"0\";\n    \n    while (avg > 0) {\n        binary = (avg & 1 ? \"1\" : \"0\") + binary;\n        avg >>= 1;\n    }\n    \n    return binary;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    int i = 0;\n    \n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svuint32_t indices = svindex_u32(i + 1, 1);\n        \n        // Compute factorial for even indices and sum for odd indices\n        svuint32_t values = svdup_u32(1);\n        svuint32_t temp = svdup_u32(1);\n        \n        // Compute for each index\n        for (uint32_t j = 1; j <= n; j++) {\n            svbool_t even_mask = svcmpeq_u32(pg, svand_u32_z(pg, indices, svdup_u32(1)), svdup_u32(0));\n            \n            // Update factorial for even indices\n            svuint32_t fact_term = svmul_u32_m(even_mask, temp, svdup_u32(j));\n            temp = svsel_u32(even_mask, fact_term, temp);\n            \n            // Update sum for odd indices\n            svuint32_t sum_term = svadd_u32_m(svnot_b_z(pg, even_mask), values, svdup_u32(j));\n            values = svsel_u32(even_mask, values, sum_term);\n        }\n        \n        // Apply modulo 10000 for factorial results\n        svuint32_t modulo_result = svmod_u32_m(even_mask, temp, svdup_u32(10000));\n        values = svsel_u32(even_mask, modulo_result, values);\n        \n        // Store results\n        svst1_u32(pg, &result[i], values);\n        \n        i += svcntw();\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    int i = 0;\n    \n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svuint32_t indices = svindex_u32(i + 1, 1);\n        \n        // Compute factorial for even indices and sum for odd indices\n        svuint32_t values = svdup_u32(1);\n        svuint32_t temp = svdup_u32(1);\n        \n        // Mask for even indices\n        svbool_t even_mask = svcmpeq_n_u32(pg, svand_n_u32(pg, indices, 1), 0);\n        \n        // Compute factorials for even indices\n        for (uint32_t j = 2; j <= n; j++) {\n            temp = svmul_n_u32_x(pg, temp, j);\n            svbool_t j_mask = svcmple_n_u32(pg, indices, j);\n            values = svsel_u32(svand_m(pg, even_mask, j_mask), temp, values);\n        }\n        \n        // Compute sums for odd indices\n        svuint32_t sums = svdup_u32(0);\n        for (uint32_t j = 1; j <= n; j++) {\n            svbool_t j_mask = svcmple_n_u32(pg, indices, j);\n            sums = svadd_m(svand_m(pg, svnot_b_z(pg, even_mask), j_mask), sums, j);\n        }\n        \n        // Select factorial or sum based on even/odd\n        svuint32_t final_values = svsel_u32(even_mask, svmod_n_u32_x(pg, values, 10000), sums);\n        \n        // Store results\n        svst1(pg, &result[i], final_values);\n        \n        i += svcntw();\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    int i = 0;\n    \n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svuint32_t indices = svindex_u32(i + 1, 1);\n        \n        // Compute factorial for even indices\n        svbool_t even_mask = svcmpeq_n_u32(pg, svand_n_u32_z(pg, indices, 1), 0);\n        svuint32_t fact = svdup_n_u32(1);\n        svuint32_t counter = svdup_n_u32(1);\n        \n        // Iterative factorial computation\n        svbool_t fact_loop = svcmple_n_u32(pg, counter, indices);\n        while (svptest_any(pg, fact_loop)) {\n            fact = svmul_u32_m(fact_loop, fact, counter);\n            counter = svadd_n_u32_m(pg, counter, 1);\n            fact_loop = svcmple_n_u32(pg, counter, indices);\n        }\n        fact = svmod_n_u32_m(pg, fact, 10000);\n        \n        // Compute sum for odd indices\n        svuint32_t sum = svdup_n_u32(0);\n        svuint32_t sum_counter = svdup_n_u32(1);\n        svbool_t sum_loop = svcmple_n_u32(pg, sum_counter, indices);\n        while (svptest_any(pg, sum_loop)) {\n            sum = svadd_u32_m(sum_loop, sum, sum_counter);\n            sum_counter = svadd_n_u32_m(pg, sum_counter, 1);\n            sum_loop = svcmple_n_u32(pg, sum_counter, indices);\n        }\n        \n        // Combine results based on even/odd mask\n        svuint32_t final_result = svsel_u32(even_mask, fact, sum);\n        \n        // Store results\n        svst1_u32(pg, &result[i], final_result);\n        \n        i += svcntw();\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    int i = 0;\n    \n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svuint32_t indices = svindex_u32(i + 1, 1);\n        \n        // Compute factorial for even indices\n        svuint64_t fact = svdup_u64(1);\n        svuint32_t j = svdup_u32(1);\n        svbool_t even = svcmpeq(pg, svand_u32_z(pg, indices, svdup_u32(1)), svdup_u32(0));\n        \n        while (svptest_any(pg, svcmple(pg, j, indices))) {\n            fact = svsel(pg, svmul_u64_z(pg, fact, svadd_u64_z(pg, svdup_u64(0), j)), fact);\n            j = svadd_u32_z(pg, j, svdup_u32(1));\n        }\n        svuint32_t fact_mod = svmod_u32_z(pg, svcvt_u32_u64_z(pg, fact), svdup_u32(10000));\n        \n        // Compute sum for odd indices\n        svuint32_t sum = svdup_u32(0);\n        j = svdup_u32(1);\n        while (svptest_any(pg, svcmple(pg, j, indices))) {\n            sum = svadd_u32_z(pg, sum, j);\n            j = svadd_u32_z(pg, j, svdup_u32(1));\n        }\n        \n        // Select factorial for even, sum for odd\n        svuint32_t values = svsel_u32(even, fact_mod, sum);\n        \n        // Store results\n        svst1_u32(pg, &result[i], values);\n        \n        i += svcntw();\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    int i = 0;\n    \n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t indices = svindex_s32(i + 1, 1);\n        \n        // Calculate sums for odd indices\n        svint32_t sums = svaddv_s32(pg, indices);\n        \n        // Calculate factorials for even indices\n        svint32_t fact = svdup_s32(1);\n        svint32_t temp_indices = indices;\n        svbool_t even_mask = svcmpeq_s32(pg, svand_s32_z(pg, indices, svdup_s32(1)), svdup_s32(0));\n        \n        for (int j = 1; j <= n; j++) {\n            svint32_t j_vec = svdup_s32(j);\n            svbool_t le_mask = svcmple_s32(pg, indices, j_vec);\n            fact = svmul_s32_m(le_mask, fact, svsel_s32(even_mask, indices, svdup_s32(1)));\n        }\n        \n        // Modulo 10000 for factorials\n        fact = svmod_s32_z(pg, fact, svdup_s32(10000));\n        \n        // Select between factorial (even) and sum (odd)\n        svint32_t result_vec = svsel_s32(even_mask, fact, sums);\n        \n        // Store results\n        svst1_s32(pg, &result[i], result_vec);\n        \n        i += svcntw();\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    svbool_t pg = svptrue_b32();\n    int even_count = 0, odd_count = 0;\n    int i = 1;\n\n    while (i <= n) {\n        // Determine vector length\n        int64_t vlen = svcntw();\n        svint32_t vec_i = svindex_s32(i, 1);\n        svbool_t active = svwhilelt_b32(i, n + 1);\n\n        // Convert numbers to check for palindrome\n        svint32_t num = vec_i;\n        svint32_t rev = svdup_n_s32(0);\n\n        // Reverse the number\n        while (svcmplt_n_s32(pg, num, 0) == 0) {\n            svint32_t digit = svmod_n_s32(pg, num, 10);\n            rev = svmad_n_s32(pg, rev, 10, digit);\n            num = svdiv_n_s32(pg, num, 10);\n        }\n\n        // Check if palindrome\n        svbool_t is_palindrome = svcmpeq_s32(pg, vec_i, rev);\n\n        // Check even/odd\n        svbool_t is_even = svcmpeq_s32(pg, svmod_n_s32(pg, vec_i, 2), 0);\n\n        // Count palindromes\n        even_count += svcntp_b32(active && is_palindrome && is_even);\n        odd_count += svcntp_b32(active && is_palindrome && !is_even);\n\n        i += vlen;\n    }\n\n    // Handle remaining elements\n    for (; i <= n; i++) {\n        int num = i, rev = 0, temp = num;\n        while (temp > 0) {\n            rev = rev * 10 + temp % 10;\n            temp /= 10;\n        }\n        if (num == rev) {\n            if (num % 2 == 0) even_count++;\n            else odd_count++;\n        }\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0, odd_count = 0;\n    svbool_t pg = svptrue_b32();\n    \n    // Process numbers up to n\n    for (int i = 1; i <= n; i += svcntw()) {\n        // Create vector of indices\n        svint32_t indices = svindex_s32(i, 1);\n        \n        // Check if indices are within bounds\n        svbool_t mask = svwhilele_b32(i, n);\n        \n        // Convert number to string for palindrome check\n        svint32_t num = indices;\n        svint32_t reversed = svdup_n_s32(0);\n        \n        // Simple palindrome check for single/two-digit numbers\n        // For 1-999, we can reverse by arithmetic\n        svint32_t temp = num;\n        while (svcmplt(pg, temp, 10)) {\n            reversed = svmul_n_s32_x(pg, reversed, 10);\n            reversed = svadd_s32_x(pg, reversed, svmod_n_s32_x(pg, temp, 10));\n            temp = svdiv_n_s32_x(pg, temp, 10);\n        }\n        \n        // Check if number is palindrome\n        svbool_t is_palindrome = svcmpeq(pg, num, reversed);\n        \n        // Check if number is even\n        svbool_t is_even = svcmpeq(pg, svmod_n_s32_x(pg, num, 2), 0);\n        \n        // Combine masks\n        svbool_t even_palindrome = svand_b_z(pg, is_palindrome, is_even);\n        svbool_t odd_palindrome = svand_b_z(pg, is_palindrome, svnot_b_z(pg, is_even));\n        \n        // Count even and odd palindromes\n        even_count += svcntp_b32(pg, svand_b_z(pg, even_palindrome, mask));\n        odd_count += svcntp_b32(pg, svand_b_z(pg, odd_palindrome, mask));\n    }\n    \n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0, odd_count = 0;\n    svbool_t pg = svptrue_b32();\n    \n    // Process single digits (1-9)\n    for (int i = 1; i <= 9 && i <= n; i++) {\n        if (i % 2 == 0) even_count++;\n        else odd_count++;\n    }\n    \n    // Process two-digit numbers\n    if (n >= 10) {\n        svint32_t digits = svindex_s32(1, 1);\n        svint32_t ten = svdup_s32(10);\n        svint32_t hundred = svdup_s32(100);\n        \n        for (int d = 1; d <= 9 && 10*d + d <= n; d++) {\n            // Check two-digit palindromes (11, 22, 33, etc.)\n            int num = 10 * d + d;\n            if (num <= n) {\n                if (num % 2 == 0) even_count++;\n                else odd_count++;\n            }\n            \n            // Process numbers like 10d + d (e.g., 121, 131, etc.)\n            if (n >= 100) {\n                svint32_t base = svdup_s32(100 * d + d);\n                svint32_t inc = svmul_n_s32_x(pg, digits, 10);\n                svint32_t nums = svadd_s32_x(pg, base, inc);\n                \n                svbool_t cmp = svcmple_s32(pg, nums, n);\n                while (svptest_any(pg, cmp)) {\n                    svbool_t valid = svcmplt_s32(pg, nums, n + 1);\n                    svint32_t even_mask = svand_s32_x(pg, nums, svdup_s32(1));\n                    svbool_t is_even = svcmpeq_s32(pg, even_mask, svdup_s32(0));\n                    \n                    even_count += svcntp_b32(pg, svand_b_z(pg, valid, is_even));\n                    odd_count += svcntp_b32(pg, svand_b_z(pg, valid, svnot_b_z(pg, is_even)));\n                    \n                    nums = svadd_s32_x(pg, nums, svdup_s32(100));\n                    cmp = svcmple_s32(pg, nums, n);\n                }\n            }\n        }\n    }\n    \n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0, odd_count = 0;\n    svbool_t pg = svptrue_b32();\n    \n    // Process single-digit numbers (1 to min(9, n))\n    int i = 1;\n    for (; i <= n && i <= 9; i++) {\n        if (i % 2 == 0) even_count++;\n        else odd_count++;\n    }\n    \n    // Process two-digit numbers in vectorized batches\n    if (n > 9) {\n        int start = (i + 15) & ~15; // Align to 16 for vector processing\n        svint32_t v_even = svdup_n_s32(0);\n        svint32_t v_odd = svdup_n_s32(0);\n        \n        for (; i <= n && i < 100; i += svcntw()) {\n            // Create vector of numbers to process\n            svint32_t v_i = svindex_s32(i, 1);\n            \n            // Check if numbers are palindromes (tens digit == ones digit for 2-digit)\n            svint32_t v_tens = svdiv_n_s32_z(pg, v_i, 10);\n            svint32_t v_ones = svsub_s32_z(pg, v_i, svmul_n_s32_z(pg, v_tens, 10));\n            svbool_t is_palindrome = svcmpeq_s32(pg, v_tens, v_ones);\n            \n            // Check even/odd\n            svbool_t is_even = svcmpeq_s32(pg, svand_n_s32_z(pg, v_i, 1), 0);\n            \n            // Count palindromes\n            svbool_t even_palindrome = svand_b_z(pg, is_palindrome, is_even);\n            svbool_t odd_palindrome = svand_b_z(pg, is_palindrome, svnot_b_z(pg, is_even));\n            \n            // Increment counts\n            even_count += svcntp_b32(pg, even_palindrome);\n            odd_count += svcntp_b32(pg, odd_palindrome);\n        }\n        \n        // Handle remaining numbers\n        for (; i <= n && i < 100; i++) {\n            int tens = i / 10;\n            int ones = i % 10;\n            if (tens == ones) {\n                if (i % 2 == 0) even_count++;\n                else odd_count++;\n            }\n        }\n    }\n    \n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0, odd_count = 0;\n    \n    // Process single digits (1 to min(9, n))\n    for (int i = 1; i <= std::min(9, n); i++) {\n        if (i % 2 == 0) even_count++;\n        else odd_count++;\n    }\n    \n    if (n <= 9) return {even_count, odd_count};\n    \n    // Process two-digit numbers (10 to n) using SVE\n    int start = 10;\n    int end = std::min(n, 99);\n    int len = end - start + 1;\n    \n    svbool_t pg = svwhilelt_b32(start, end + 1);\n    svuint32_t vec = svindex_u32(start, 1);\n    \n    // Check if numbers are palindromes\n    svuint32_t tens = svdiv_n_u32_z(pg, vec, 10);\n    svuint32_t ones = svsub_n_u32_z(pg, svmul_n_u32_z(pg, svdiv_n_u32_z(pg, vec, 10), 10), vec);\n    svbool_t is_palindrome = svcmpeq_u32(pg, tens, ones);\n    \n    // Count even and odd palindromes\n    svuint32_t mod2 = svand_n_u32_z(pg, vec, 1);\n    svbool_t is_even = svcmpeq_u32(pg, mod2, 0);\n    svbool_t is_odd = svcmpne_u32(pg, mod2, 0);\n    \n    even_count += svcntp_b32(pg, svand_b_z(pg, is_palindrome, is_even));\n    odd_count += svcntp_b32(pg, svand_b_z(pg, is_palindrome, is_odd));\n    \n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    size_t len = n.size();\n    size_t vl = svcntw();\n    svbool_t pg = svptrue_b32();\n\n    for (size_t i = 0; i < len; i += vl) {\n        size_t elements = std::min(vl, len - i);\n        pg = svwhilelt_b32(i, len);\n        \n        svint32_t vec = svld1(pg, &n[i]);\n        svint32_t sum_digits = svdup_n_s32(0);\n        svint32_t temp = vec;\n\n        while (svcnt_pnz_s32(temp) > 0) {\n            svint32_t digit = svdiv_n_s32(temp, 10);\n            svint32_t rem = svsub_s32(temp, svmul_n_s32(digit, 10));\n            sum_digits = svadd_s32(sum_digits, rem);\n            temp = digit;\n        }\n\n        svbool_t mask = svcmpgt(pg, sum_digits, 0);\n        count += svcntp_b32(pg, mask);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    size_t len = n.size();\n    const int *data = n.data();\n    \n    // Process vectorized chunks\n    svbool_t pg = svwhilelt_b32(0, len);\n    for (size_t i = 0; i < len; i += svcntw()) {\n        // Load vector\n        svint32_t vec = svld1(pg, data + i);\n        \n        // Initialize sum of digits\n        svint32_t sum = svdup_n_s32(0);\n        \n        // Process each number\n        svint32_t abs_vec = svabs_s32_z(pg, vec);\n        \n        // Extract digits and sum them\n        while (svptest_any(pg, svcmpgt_n_s32(pg, abs_vec, 0))) {\n            svint32_t digit = svmod_n_s32_z(pg, abs_vec, 10);\n            sum = svadd_s32_z(pg, sum, digit);\n            abs_vec = svdiv_n_s32_z(pg, abs_vec, 10);\n        }\n        \n        // For negative numbers, make first digit negative\n        svbool_t neg_mask = svcmplt_s32(pg, vec, 0);\n        svint32_t first_digit = svdiv_n_s32_z(pg, vec, svpow2_n_s32(svsub_n_s32_z(pg, svcntw(), 1)));\n        sum = svadd_s32_m(neg_mask, sum, svmul_n_s32_z(pg, first_digit, -1));\n        \n        // Count elements where sum > 0\n        svbool_t sum_gt_zero = svcmpgt_n_s32(pg, sum, 0);\n        count += svcntp_b32(pg, sum_gt_zero);\n        \n        // Update predicate for next iteration\n        pg = svwhilelt_b32(i + svcntw(), len);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    size_t len = n.size();\n    size_t vl = svcntw();\n    svbool_t pg = svptrue_b32();\n\n    for (size_t i = 0; i < len; i += vl) {\n        size_t remaining = std::min(vl, len - i);\n        pg = svwhilelt_b32(i, len);\n        \n        svint32_t vec = svld1_s32(pg, &n[i]);\n        svint32_t abs_vec = svabs_s32_z(pg, vec);\n        \n        svint32_t sum = svdup_s32(0);\n        svint32_t temp = abs_vec;\n        \n        while (svptest_any(svptrue_b32(), svcmpgt_n_s32(pg, temp, 0))) {\n            svint32_t digits = svmod_n_s32_z(pg, temp, 10);\n            sum = svadd_s32_z(pg, sum, digits);\n            temp = svdiv_n_s32_z(pg, temp, 10);\n        }\n        \n        svbool_t neg_mask = svcmplt_s32(pg, vec, 0);\n        svint32_t first_digit = svdiv_n_s32_z(pg, abs_vec, svpow2_n_s32(svsub_n_s32_z(pg, svcntw(), 1)));\n        svint32_t neg_adj = svneg_s32_m(svmov_n_s32(0), neg_mask, first_digit);\n        sum = svadd_s32_m(sum, neg_mask, neg_adj);\n        \n        svbool_t gt_zero = svcmpgt_n_s32(pg, sum, 0);\n        count += svcntp_b32(pg, gt_zero);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    size_t len = n.size();\n    size_t i = 0;\n    \n    // Get vector length in elements\n    int64_t vlen = svcntw();\n    \n    // Process vectorized chunks\n    while (i + vlen <= len) {\n        svbool_t pg = svwhilelt_b32(i, len);\n        svint32_t vec = svld1_s32(pg, &n[i]);\n        \n        // Initialize sum of digits\n        svint32_t sum = svdup_s32(0);\n        \n        // Extract digits and compute their sum\n        svint32_t temp = vec;\n        while (svptrue_b32()) {\n            svint32_t digit = svmod_n_s32(temp, svdup_s32(10));\n            sum = svadd_s32_z(pg, sum, digit);\n            temp = svdiv_n_s32_z(pg, temp, 10);\n            \n            // Continue while any number still has non-zero digits\n            svbool_t non_zero = svcmpne_n_s32(pg, temp, 0);\n            if (!svptest_any(svptrue_b32(), non_zero)) break;\n        }\n        \n        // Count numbers where sum of digits > 0\n        svbool_t gt_zero = svcmpgt_n_s32(pg, sum, 0);\n        count += svcntp_b32(pg, gt_zero);\n        \n        i += vlen;\n    }\n    \n    // Handle remaining elements scalarly\n    for (; i < len; i++) {\n        int num = n[i];\n        int sum = 0;\n        while (num != 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        if (sum > 0) count++;\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    size_t len = n.size();\n    const int *data = n.data();\n\n    // Process vectorized chunks\n    for (size_t i = 0; i < len; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, len);\n        svint32_t vec = svld1(pg, &data[i]);\n\n        // Initialize sum of digits\n        svint32_t sum = svdup_s32(0);\n        svint32_t temp = vec;\n\n        // Handle negative numbers\n        svbool_t neg_mask = svcmplt_s32(pg, vec, svdup_s32(0));\n        svint32_t abs_vec = svabs_s32_m(temp, neg_mask, vec);\n\n        // Extract digits and compute sum\n        while (svptest_any(pg, svcmpne_s32(pg, abs_vec, svdup_s32(0)))) {\n            svint32_t digit = svmod_n_s32(pg, abs_vec, svdup_s32(10));\n            sum = svadd_s32_m(pg, sum, digit);\n            abs_vec = svdiv_n_s32(pg, abs_vec, svdup_s32(10));\n        }\n\n        // Adjust sum for negative numbers\n        svbool_t first_digit_neg = svcmplt_s32(pg, vec, svdup_s32(0));\n        svint32_t first_digit = svmod_n_s32(pg, vec, svdup_s32(10));\n        sum = svsub_s32_m(pg, sum, svmul_n_s32_m(pg, first_digit, 2, first_digit_neg));\n\n        // Count elements with sum > 0\n        svbool_t sum_gt_zero = svcmpgt_s32(pg, sum, svdup_s32(0));\n        count += svcntp_b32(pg, sum_gt_zero);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) return true;\n    \n    uint64_t len = arr.size();\n    if (len == 1) return true;\n    \n    // Find min and max elements to check if sorted array is possible\n    svint32_t vec = svld1(svptrue_b32(), arr.data());\n    int32_t min_val = svminv_s32(svptrue_b32(), vec);\n    int32_t max_val = svmaxv_s32(svptrue_b32(), vec);\n    \n    // Check if min is at end and max at start (impossible case)\n    if (arr[len-1] == min_val && arr[0] == max_val) return false;\n    \n    // Check if array is already sorted or can be sorted\n    svbool_t ptrue = svptrue_b32();\n    svint32_t shifted = svext_s32(vec, vec, 1);\n    svint32_t cmp = svcmplt_s32(ptrue, vec, shifted);\n    \n    // Count number of inversions (where arr[i] > arr[i+1])\n    uint64_t inversion_count = svcntp_b32(ptrue, cmp);\n    \n    // For unique elements, exactly one inversion point is needed for sorting\n    // More than one inversion point means it's impossible to sort with rotations\n    return inversion_count <= 1;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) return true;\n    \n    uint64_t len = arr.size();\n    svbool_t pg = svwhilelt_b32(0, len);\n    \n    // Load array into SVE vector\n    svint32_t vec = svld1(pg, arr.data());\n    \n    // Find min and max elements\n    int32_t min_val = svminv_s32(pg, vec);\n    int32_t max_val = svmaxv_s32(pg, vec);\n    \n    // Create sorted reference vector\n    std::vector<int> sorted(arr);\n    std::sort(sorted.begin(), sorted.end());\n    \n    // Check all possible rotations\n    for (uint64_t i = 0; i < len; i++) {\n        bool is_sorted = true;\n        svbool_t pg_check = svwhilelt_b32(0, len);\n        \n        // Compare rotated vector with sorted vector\n        svint32_t rotated = svext_s32(vec, vec, i);\n        \n        for (uint64_t j = 0; j < len; j += svcntw()) {\n            pg_check = svwhilelt_b32(j, len);\n            svint32_t sorted_chunk = svld1(pg_check, sorted.data() + j);\n            svbool_t cmp = svcmpeq(pg_check, rotated, sorted_chunk);\n            \n            if (!svptest_all(pg_check, cmp)) {\n                is_sorted = false;\n                break;\n            }\n        }\n        \n        if (is_sorted) return true;\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) return true;\n    \n    int n = arr.size();\n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    // Load array into SVE vectors\n    svint32_t vec = svld1_s32(pg, arr.data());\n    \n    // Find min and max elements\n    int min_val = svminv_s32(pg, vec);\n    int max_val = svmaxv_s32(pg, vec);\n    \n    // Find index of minimum element\n    svbool_t min_mask = svcmpeq_s32(pg, vec, min_val);\n    int min_idx = svcntp_b32(min_mask);\n    \n    // Check if array is already sorted\n    svint32_t vec_rotated = vec;\n    bool is_sorted = true;\n    for (int i = 0; i < n-1; i++) {\n        svint32_t next = svext_s32(vec_rotated, vec_rotated, 1);\n        svbool_t cmp = svcmplt_s32(pg, vec_rotated, next);\n        if (!svptest_all(pg, cmp)) {\n            is_sorted = false;\n            break;\n        }\n        vec_rotated = next;\n    }\n    if (is_sorted) return true;\n    \n    // Check if sorting is possible by rotation\n    // Rotate to put min at start\n    svint32_t vec_shifted = svext_s32(vec, vec, min_idx);\n    \n    // Check if the rotated array is sorted\n    is_sorted = true;\n    for (int i = 0; i < n-1; i++) {\n        svint32_t next = svext_s32(vec_shifted, vec_shifted, 1);\n        svbool_t cmp = svcmplt_s32(pg, vec_shifted, next);\n        if (!svptest_all(pg, cmp)) {\n            is_sorted = false;\n            break;\n        }\n        vec_shifted = next;\n    }\n    \n    return is_sorted;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) return true;\n    \n    uint64_t len = arr.size();\n    svbool_t pg = svwhilelt_b32(0, len);\n    \n    // Load array into SVE vector\n    svint32_t vec = svld1_s32(pg, arr.data());\n    \n    // Find min and max elements\n    int32_t min_val = svminv_s32(pg, vec);\n    int32_t max_val = svmaxv_s32(pg, vec);\n    \n    // Find index of minimum element\n    svbool_t min_mask = svcmpeq_s32(pg, vec, min_val);\n    uint64_t min_idx = svcntp_b32(pg, min_mask);\n    \n    // Create rotated vector starting from min element\n    svint32_t rotated = svext_s32(vec, vec, min_idx);\n    \n    // Check if rotated vector is sorted\n    svint32_t shifted = svext_s32(rotated, rotated, 1);\n    svbool_t is_sorted = svcmple_s32(pg, rotated, shifted);\n    \n    // Check if all elements (except last) are in non-decreasing order\n    svbool_t last_mask = svwhilelt_b32(0, len-1);\n    uint64_t sorted_count = svcntp_b32(svptrue_b32(), svand_b_z(pg, is_sorted, last_mask));\n    \n    return sorted_count == (len-1);\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\nbool move_one_ball_simd(std::vector<int> arr) {\n    size_t N = arr.size();\n    if (N <= 1) return true;\n\n    // Find the minimum element to determine the starting point of the sorted sequence\n    int min_val = arr[0];\n    size_t min_idx = 0;\n    for (size_t i = 1; i < N; ++i) {\n        if (arr[i] < min_val) {\n            min_val = arr[i];\n            min_idx = i;\n        }\n    }\n\n    // Check if the sequence starting from min_idx is sorted in non-decreasing order\n    // after a circular shift\n    svbool_t pg = svwhilelt_b32(0, N);\n    size_t vl = svcntw(); // Vector length for 32-bit elements\n    bool is_sorted = true;\n\n    for (size_t i = 0; i < N && is_sorted; i += vl) {\n        size_t remaining = N - i;\n        pg = svwhilelt_b32(i, N);\n        svint32_t vec1 = svundef_s32();\n        svint32_t vec2 = svundef_s32();\n\n        // Load current and next elements with circular indexing\n        for (size_t j = 0; j < vl && j < remaining; ++j) {\n            size_t idx1 = (min_idx + i + j) % N;\n            size_t idx2 = (min_idx + i + j + 1) % N;\n            if (j < remaining) {\n                vec1 = svset_s32(vec1, j, arr[idx1]);\n                vec2 = svset_s32(vec2, j, arr[idx2]);\n            }\n        }\n\n        // Compare current and next elements\n        svbool_t cmp = svcmple_s32(pg, vec1, vec2);\n        if (!svptest_all(pg, cmp)) {\n            is_sorted = false;\n        }\n    }\n\n    return is_sorted;\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t n1 = lst1.size();\n    size_t n2 = lst2.size();\n    size_t total_size = n1 + n2;\n    size_t vec_len = svcntw();\n    svbool_t pg = svptrue_b32();\n    size_t even_count1 = 0, even_count2 = 0;\n\n    // Count even numbers in lst1\n    for (size_t i = 0; i < n1; i += vec_len) {\n        svbool_t active = svwhilelt_b32(i, n1);\n        svint32_t vec = svld1_s32(active, &lst1[i]);\n        svbool_t even_mask = svcmpeq_n_s32(active, svand_n_s32(vec, 1), 0);\n        even_count1 += svcntp_b32(active, even_mask);\n    }\n\n    // Count even numbers in lst2\n    for (size_t i = 0; i < n2; i += vec_len) {\n        svbool_t active = svwhilelt_b32(i, n2);\n        svint32_t vec = svld1_s32(active, &lst2[i]);\n        svbool_t even_mask = svcmpeq_n_s32(active, svand_n_s32(vec, 1), 0);\n        even_count2 += svcntp_b32(active, even_mask);\n    }\n\n    // Total even numbers available\n    size_t total_even = even_count1 + even_count2;\n\n    // If total even numbers are at least the size of lst1, return \"YES\"\n    return (total_even >= n1) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t n1 = lst1.size();\n    size_t n2 = lst2.size();\n    size_t total_size = n1 + n2;\n    svbool_t pg = svptrue_b32();\n    size_t vec_len = svcntw();\n\n    size_t even_count_lst1 = 0;\n    size_t odd_count_lst1 = 0;\n    size_t even_count_lst2 = 0;\n\n    // Process lst1 for even and odd counts using SVE\n    for (size_t i = 0; i < n1; i += vec_len) {\n        svbool_t active = svwhilelt_b32(i, n1);\n        svint32_t vec = svld1_s32(active, &lst1[i]);\n        svbool_t even_mask = svcmpeq_n_s32(active, svand_n_s32(vec, 1), 0);\n        even_count_lst1 += svcntp_b32(active, even_mask);\n        odd_count_lst1 += svcntp_b32(active, svnot_b_z(active, even_mask));\n    }\n\n    // Process lst2 for even count using SVE\n    for (size_t i = 0; i < n2; i += vec_len) {\n        svbool_t active = svwhilelt_b32(i, n2);\n        svint32_t vec = svld1_s32(active, &lst2[i]);\n        svbool_t even_mask = svcmpeq_n_s32(active, svand_n_s32(vec, 1), 0);\n        even_count_lst2 += svcntp_b32(active, even_mask);\n    }\n\n    // Total even numbers available\n    size_t total_even = even_count_lst1 + even_count_lst2;\n\n    // Check if we can make lst1 all even by exchanging\n    if (total_even >= n1) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t n1 = lst1.size();\n    size_t n2 = lst2.size();\n    size_t total_size = n1 + n2;\n    size_t vec_len = svcntw();\n    size_t processed = 0;\n    int even_count1 = 0, even_count2 = 0;\n\n    // Process lst1 for even numbers\n    while (processed < n1) {\n        svbool_t pg = svwhilelt_b32(processed, n1);\n        svint32_t vec = svld1_s32(pg, &lst1[processed]);\n        svint32_t even_mask = svand_n_s32_z(pg, vec, 1);\n        svbool_t is_even = svcmpeq_s32(pg, even_mask, 0);\n        even_count1 += svcntp_b32(pg, is_even);\n        processed += vec_len;\n    }\n\n    processed = 0;\n    // Process lst2 for even numbers\n    while (processed < n2) {\n        svbool_t pg = svwhilelt_b32(processed, n2);\n        svint32_t vec = svld1_s32(pg, &lst2[processed]);\n        svint32_t even_mask = svand_n_s32_z(pg, vec, 1);\n        svbool_t is_even = svcmpeq_s32(pg, even_mask, 0);\n        even_count2 += svcntp_b32(pg, is_even);\n        processed += vec_len;\n    }\n\n    // Total even numbers available\n    int total_even = even_count1 + even_count2;\n\n    // If total even numbers are at least the size of lst1, return \"YES\"\n    return (total_even >= n1) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t n1 = lst1.size();\n    size_t n2 = lst2.size();\n    size_t total_size = n1 + n2;\n    svbool_t pg = svptrue_b32();\n    size_t vec_len = svcntw();\n\n    size_t even_count1 = 0;\n    size_t odd_count1 = 0;\n    size_t even_count2 = 0;\n    size_t odd_count2 = 0;\n\n    // Process lst1\n    for (size_t i = 0; i < n1; i += vec_len) {\n        svbool_t active = svwhilelt_b32(i, n1);\n        svint32_t vec = svld1_s32(active, &lst1[i]);\n        svint32_t mod_vec = svand_s32_z(active, vec, 1);\n        svbool_t even_mask = svcmpeq_s32(active, mod_vec, 0);\n        even_count1 += svcntp_b32(active, even_mask);\n        odd_count1 += svcntp_b32(active, svnot_b_z(active, even_mask));\n    }\n\n    // Process lst2\n    for (size_t i = 0; i < n2; i += vec_len) {\n        svbool_t active = svwhilelt_b32(i, n2);\n        svint32_t vec = svld1_s32(active, &lst2[i]);\n        svint32_t mod_vec = svand_s32_z(active, vec, 1);\n        svbool_t even_mask = svcmpeq_s32(active, mod_vec, 0);\n        even_count2 += svcntp_b32(active, even_mask);\n        odd_count2 += svcntp_b32(active, svnot_b_z(active, even_mask));\n    }\n\n    size_t total_even = even_count1 + even_count2;\n    if (total_even >= n1) {\n        return \"YES\";\n    }\n    return \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t n1 = lst1.size();\n    size_t n2 = lst2.size();\n    size_t total_size = n1 + n2;\n    svbool_t pg = svwhilelt_b32(0, total_size);\n    size_t vec_len = svcntw();\n\n    int even_count_lst1 = 0;\n    int odd_count_lst1 = 0;\n    int even_count_lst2 = 0;\n\n    // Process lst1 for even and odd counts using SVE\n    for (size_t i = 0; i < n1; i += vec_len) {\n        svbool_t p = svwhilelt_b32(i, n1);\n        svint32_t vec = svld1_s32(p, &lst1[i]);\n        svint32_t mod_vec = svand_s32_z(p, vec, 1);\n        svbool_t even_mask = svcmpeq_s32(p, mod_vec, 0);\n        even_count_lst1 += svcntp_b32(p, even_mask);\n    }\n    odd_count_lst1 = n1 - even_count_lst1;\n\n    // Process lst2 for even count using SVE\n    for (size_t i = 0; i < n2; i += vec_len) {\n        svbool_t p = svwhilelt_b32(i, n2);\n        svint32_t vec = svld1_s32(p, &lst2[i]);\n        svint32_t mod_vec = svand_s32_z(p, vec, 1);\n        svbool_t even_mask = svcmpeq_s32(p, mod_vec, 0);\n        even_count_lst2 += svcntp_b32(p, even_mask);\n    }\n\n    // Check if we can make lst1 all even by exchanging with lst2\n    int total_even_available = even_count_lst1 + even_count_lst2;\n    if (total_even_available >= n1) {\n        return \"YES\";\n    }\n    return \"NO\";\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string>& lst) {\n    std::vector<std::string> result;\n    result.reserve(lst.size());\n\n    size_t vec_len = svcntb(); // Get the number of bytes in a vector\n    size_t max_str_len = 0;\n    for (const auto& str : lst) {\n        max_str_len = std::max(max_str_len, str.size());\n    }\n\n    // Process strings in chunks based on vector length\n    for (size_t i = 0; i < lst.size(); ++i) {\n        const std::string& str = lst[i];\n        size_t len = str.size();\n        size_t odd_count = 0;\n\n        size_t j = 0;\n        svbool_t pg = svwhilelt_b8(j, len);\n        for (; j < len; j += vec_len) {\n            // Load characters into a vector\n            svuint8_t chars = svld1_u8(pg, reinterpret_cast<const uint8_t*>(str.data() + j));\n            // Convert ASCII digits to numeric values\n            svuint8_t digits = svsub_n_u8_x(pg, chars, '0');\n            // Check if digits are odd (digit % 2 == 1)\n            svbool_t odd_mask = svcmpeq_n_u8(pg, svand_n_u8_x(pg, digits, 1), 1);\n            // Count the number of odd digits in this vector\n            odd_count += svcntp_b8(pg, odd_mask);\n\n            pg = svwhilelt_b8(j + vec_len, len);\n        }\n\n        // Format the result string\n        std::string res = \"the number of odd elements \" + std::to_string(odd_count) +\n                          \"n the str\" + std::to_string(odd_count) +\n                          \"ng \" + std::to_string(odd_count) +\n                          \" of the \" + std::to_string(odd_count) + \"nput.\";\n        result.push_back(res);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string>& lst) {\n    std::vector<std::string> result(lst.size());\n    svbool_t pg = svwhilelt_b8(0, svcntb());\n    \n    for (size_t i = 0; i < lst.size(); ++i) {\n        const std::string& s = lst[i];\n        int32_t odd_count = 0;\n        size_t len = s.length();\n        \n        // Process string in vector-sized chunks\n        for (size_t j = 0; j < len; j += svcntb()) {\n            size_t remaining = std::min(svcntb(), len - j);\n            svbool_t active = svwhilelt_b8(j, len);\n            \n            // Load chunk of string\n            svuint8_t chars = svld1_u8(active, (const uint8_t*)&s[j]);\n            \n            // Convert ASCII digits to numbers (subtract '0')\n            svuint8_t digits = svsub_u8_x(pg, chars, '0');\n            \n            // Check for odd numbers (1,3,5,7,9)\n            svbool_t is_odd = svcmpeq_n_u8(pg, digits, 1);\n            is_odd = svorr_b_z(pg, is_odd, svcmpeq_n_u8(pg, digits, 3));\n            is_odd = svorr_b_z(pg, is_odd, svcmpeq_n_u8(pg, digits, 5));\n            is_odd = svorr_b_z(pg, is_odd, svcmpeq_n_u8(pg, digits, 7));\n            is_odd = svorr_b_z(pg, is_odd, svcmpeq_n_u8(pg, digits, 9));\n            \n            // Count odd digits in chunk\n            odd_count += svcntp_b8(pg, is_odd);\n        }\n        \n        // Format output string\n        std::string num_str = std::to_string(odd_count);\n        result[i] = \"the number of odd elements \" + num_str + \"n the str\" + num_str + \"ng \" + num_str + \" of the \" + num_str + \"nput.\";\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string>& lst) {\n    std::vector<std::string> result(lst.size());\n    svbool_t pg = svptrue_b8();\n\n    for (size_t i = 0; i < lst.size(); ++i) {\n        const std::string& str = lst[i];\n        int32_t odd_count = 0;\n        size_t len = str.length();\n        size_t j = 0;\n\n        // Process string in vector-sized chunks\n        while (j + svcntb() <= len) {\n            svuint8_t vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&str[j]));\n            svuint8_t digits = svsub_u8_z(pg, vec, '0');\n            svuint8_t odd_mask = svand_u8_z(pg, digits, 1);\n            odd_count += svcntp_b8(pg, svcmpne_n_u8(pg, odd_mask, 0));\n            j += svcntb();\n        }\n\n        // Handle remaining characters\n        for (; j < len; ++j) {\n            if ((str[j] - '0') & 1) {\n                odd_count++;\n            }\n        }\n\n        // Format result string\n        std::string out = \"the number of odd elements 1n the str1ng 1 of the 1nput.\";\n        out[25] = '0' + odd_count;\n        out[33] = '0' + odd_count;\n        out[44] = '0' + odd_count;\n        result[i] = out;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string>& lst) {\n    std::vector<std::string> result(lst.size());\n    svbool_t pg = svwhilelt_b8(0, svcntb());\n\n    for (size_t i = 0; i < lst.size(); ++i) {\n        const std::string& str = lst[i];\n        uint64_t odd_count = 0;\n        size_t j = 0;\n\n        while (j < str.length()) {\n            // Load string characters into vector\n            svuint8_t chars = svld1_u8(pg, (const uint8_t*)&str[j]);\n            \n            // Convert ASCII digits to numeric values (subtract '0')\n            svuint8_t digits = svsub_u8_x(pg, chars, '0');\n            \n            // Check for odd digits (digit % 2 == 1)\n            svuint8_t is_odd = svand_u8_x(pg, digits, svdup_u8(1));\n            svbool_t odd_mask = svcmpeq_u8(pg, is_odd, 1);\n            \n            // Count odd digits in vector\n            odd_count += svcntp_b8(pg, odd_mask);\n            \n            j += svcntb();\n            pg = svwhilelt_b8(j, str.length());\n        }\n\n        // Format result string\n        std::string res = \"the number of odd elements 1n the str1ng 1 of the 1nput.\";\n        res[25] = '0' + odd_count;\n        res[33] = '0' + odd_count;\n        res[43] = '0' + odd_count;\n        result[i] = res;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string>& lst) {\n    std::vector<std::string> result(lst.size());\n    svbool_t pg = svwhilelt_b8(0, lst.size());\n\n    for (size_t i = 0; i < lst.size(); i += svcntb()) {\n        svbool_t active = svwhilelt_b8(i, lst.size());\n        svuint32_t odd_counts = svdup_u32(0);\n\n        // Process each string in the current vector lane\n        for (size_t j = i; j < std::min(i + svcntb(), lst.size()); j++) {\n            const std::string& str = lst[j];\n            uint32_t odd_count = 0;\n\n            // Count odd digits in the string\n            for (char c : str) {\n                if ((c - '0') % 2 == 1) {\n                    odd_count++;\n                }\n            }\n\n            // Store odd count in the vector\n            svbool_t lane_mask = svdup_b8(false);\n            lane_mask = svsel_b(active, svcmpeq_n_u32(active, j - i, j - i), lane_mask);\n            odd_counts = svsel_u32(lane_mask, svdup_u32(odd_count), odd_counts);\n        }\n\n        // Generate result strings for active lanes\n        for (size_t j = i; j < std::min(i + svcntb(), lst.size()); j++) {\n            uint32_t count = svlasta_u32(svpfalse(), svsel_u32(svcmpeq_n_u32(active, j - i, j - i), odd_counts, svdup_u32(0)));\n            result[j] = \"the number of odd elements \" + std::to_string(count) + \"n the str\" + \n                       std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + \n                       std::to_string(count) + \"nput.\";\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    svint64_t min_sum = svdup_s64(INT64_MAX);\n    svbool_t pg = svptrue_b64();\n    size_t n = nums.size();\n    \n    for (size_t i = 0; i < n; ++i) {\n        svint64_t curr_sum = svdup_s64(0);\n        for (size_t j = i; j < n; j += svcntd()) {\n            size_t len = std::min(svcntd(), n - j);\n            svbool_t mask = svwhilelt_b64(j, j + len);\n            svint64_t vec = svld1_s64(mask, &nums[j]);\n            curr_sum = svadd_m(mask, curr_sum, vec);\n            min_sum = svmin_m(pg, min_sum, curr_sum);\n        }\n    }\n    \n    return svminv_s64(pg, min_sum);\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int64_t global_min = INT64_MAX;\n    svbool_t pg = svptrue_b64();\n    size_t n = nums.size();\n    size_t i = 0;\n\n    for (; i + svcntd() <= n; i += svcntd()) {\n        svint64_t vec = svld1_s64(pg, &nums[i]);\n        svint64_t prefix_sum = svdup_s64(0);\n        svint64_t min_sum = svdup_s64(INT64_MAX);\n\n        for (size_t j = i; j < n; j++) {\n            prefix_sum = svadd_s64_z(pg, prefix_sum, svdup_s64(nums[j]));\n            min_sum = svmin_s64_z(pg, min_sum, prefix_sum);\n        }\n\n        int64_t local_min = svminv_s64(pg, min_sum);\n        global_min = std::min(global_min, local_min);\n    }\n\n    // Handle remaining elements\n    for (; i < n; i++) {\n        int64_t sum = 0;\n        for (size_t j = i; j < n; j++) {\n            sum += nums[j];\n            global_min = std::min(global_min, sum);\n        }\n    }\n\n    return global_min;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int64_t global_min = INT64_MAX;\n    size_t n = nums.size();\n    \n    // Process one element at a time for prefix sums\n    int64_t prefix_sum = 0;\n    for (size_t i = 0; i < n; ++i) {\n        prefix_sum += nums[i];\n        global_min = std::min(global_min, prefix_sum);\n        \n        // Reset prefix_sum if positive to consider new subarrays\n        if (prefix_sum > 0) {\n            prefix_sum = 0;\n        }\n    }\n    \n    // Handle case where all elements are negative\n    if (global_min == INT64_MAX) {\n        svint64_t min_vec = svdup_n_s64(INT64_MAX);\n        size_t i = 0;\n        svbool_t pg = svwhilelt_b64(i, n);\n        \n        while (svptest_any(svptrue_b64(), pg)) {\n            svint64_t vec = svld1_s64(pg, &nums[i]);\n            min_vec = svmin_s64_z(pg, min_vec, vec);\n            i += svcntd();\n            pg = svwhilelt_b64(i, n);\n        }\n        \n        global_min = svminv_s64(svptrue_b64(), min_vec);\n    }\n    \n    return global_min;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    svint64_t min_sum = svdup_s64(INT64_MAX);\n    svbool_t pg = svptrue_b64();\n    int64_t global_min = INT64_MAX;\n    \n    for (size_t i = 0; i < nums.size(); i++) {\n        svint64_t current_sum = svdup_s64(0);\n        for (size_t j = i; j < nums.size(); j += svcntd()) {\n            size_t elements = std::min(svcntd(), nums.size() - j);\n            svbool_t mask = svwhilelt_b64(j, nums.size());\n            svint64_t vec = svld1_s64(mask, &nums[j]);\n            current_sum = svadd_s64_z(mask, current_sum, vec);\n            min_sum = svmin_s64_z(mask, min_sum, current_sum);\n        }\n        int64_t local_min = svminv_s64(pg, min_sum);\n        global_min = std::min(global_min, local_min);\n    }\n    \n    return global_min;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    if (nums.empty()) return 0;\n    \n    int64_t global_min = nums[0];\n    svint64_t min_vec = svdup_s64(nums[0]);\n    svint64_t curr_sum_vec = svdup_s64(0);\n    \n    svbool_t pg = svwhilelt_b64(0, nums.size());\n    \n    for (size_t i = 0; i < nums.size();) {\n        svint64_t vec = svld1_s64(pg, &nums[i]);\n        \n        curr_sum_vec = svadd_s64_z(pg, curr_sum_vec, vec);\n        \n        svint64_t local_min = svmin_s64_z(pg, curr_sum_vec, svdup_s64(0));\n        min_vec = svmin_s64_z(pg, min_vec, local_min);\n        \n        svbool_t reset_mask = svcmple_s64(pg, curr_sum_vec, svdup_s64(0));\n        curr_sum_vec = svsel_s64(reset_mask, svdup_s64(0), curr_sum_vec);\n        \n        i += svcntd();\n        pg = svwhilelt_b64(i, nums.size());\n    }\n    \n    int64_t final_min = svminv_s64(svptrue_b64(), min_vec);\n    \n    for (size_t i = 0; i < nums.size(); ++i) {\n        int64_t curr_sum = 0;\n        for (size_t j = i; j < nums.size(); ++j) {\n            curr_sum += nums[j];\n            global_min = std::min(global_min, curr_sum);\n        }\n    }\n    \n    return std::min(global_min, final_min);\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint max_fill_simd(const std::vector<std::vector<int>> &grid, int capacity) {\n    int rows = grid.size();\n    int cols = rows > 0 ? grid[0].size() : 0;\n    int total_fills = 0;\n\n    // Process each row using SVE\n    for (int i = 0; i < rows; ++i) {\n        int water_count = 0;\n        svbool_t pg = svwhilelt_b32(0, cols);\n\n        // Count water units in the row using SVE\n        for (int j = 0; j < cols; j += svcntw()) {\n            // Load predicate for remaining elements\n            pg = svwhilelt_b32(j, cols);\n            \n            // Load row data into vector\n            svuint32_t vec = svld1(pg, &grid[i][j]);\n            \n            // Count ones (water units) in the vector\n            water_count += svcntw(svptrue_b32(), vec);\n        }\n\n        // Calculate fills needed for this row\n        if (water_count > 0) {\n            total_fills += (water_count + capacity - 1) / capacity;\n        }\n    }\n\n    return total_fills;\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint max_fill_simd(const std::vector<std::vector<int>>& grid, int capacity) {\n    int rows = grid.size();\n    int cols = rows > 0 ? grid[0].size() : 0;\n    int total_fills = 0;\n\n    // Process each row\n    for (int i = 0; i < rows; i++) {\n        int row_sum = 0;\n        int j = 0;\n\n        // Process columns using SVE\n        svbool_t pg = svwhilelt_b32(j, cols);\n        while (svptest_any(svptrue_b32(), pg)) {\n            svint32_t water = svld1_s32(pg, &grid[i][j]);\n            row_sum += svsum_s32_z(pg, water);\n            j += svcntw();\n            pg = svwhilelt_b32(j, cols);\n        }\n\n        // Calculate fills needed for this row\n        if (row_sum > 0) {\n            total_fills += (row_sum + capacity - 1) / capacity;\n        }\n    }\n\n    return total_fills;\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    int rows = grid.size();\n    int cols = grid.empty() ? 0 : grid[0].size();\n    int total_trips = 0;\n\n    // Process each row\n    for (int i = 0; i < rows; i++) {\n        int water_count = 0;\n        svbool_t pg = svwhilelt_b32(0, cols);\n        \n        // Count water units in the row using SVE\n        svuint32_t water_vec = svld1_u32(pg, grid[i].data());\n        water_count = svcntw(svptrue_b32(), water_vec);\n        \n        // Calculate trips needed for this row\n        if (water_count > 0) {\n            total_trips += (water_count + capacity - 1) / capacity;\n        }\n    }\n\n    return total_trips;\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint max_fill_simd(const std::vector<std::vector<int>>& grid, int capacity) {\n    int rows = grid.size();\n    if (rows == 0) return 0;\n    int cols = grid[0].size();\n    int total_fills = 0;\n\n    // Process each row using SVE\n    for (int i = 0; i < rows; ++i) {\n        int water_in_row = 0;\n        int j = 0;\n\n        // Process columns in vectorized chunks\n        while (j < cols) {\n            svbool_t pg = svwhilelt_b32(j, cols);\n            svint32_t vec = svld1_s32(pg, &grid[i][j]);\n            water_in_row += svcntw(svptrue_b32(), svcmpeq_n_s32(pg, vec, 1));\n            j += svcntw();\n        }\n\n        // Calculate fills needed for this row\n        if (water_in_row > 0) {\n            total_fills += (water_in_row + capacity - 1) / capacity;\n        }\n    }\n\n    return total_fills;\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint max_fill_simd(const std::vector<std::vector<int> >& grid, int capacity) {\n    int rows = grid.size();\n    if (rows == 0) return 0;\n    int cols = grid[0].size();\n    int total_lowers = 0;\n\n    // Process each row using SVE\n    for (int i = 0; i < rows; i++) {\n        int water_units = 0;\n        svbool_t pg = svptrue_b32();\n        \n        // Process columns in vectorized chunks\n        for (int j = 0; j < cols; j += svcntw()) {\n            // Calculate remaining elements\n            int remaining = cols - j;\n            pg = svwhilelt_b32(j, cols);\n            \n            // Load grid row data into vector\n            svuint32_t vec = svld1_u32(pg, &grid[i][j]);\n            \n            // Count water units (1s) in the vector\n            water_units += svcntp_b32(pg, svcmpeq_n_u32(pg, vec, 1));\n        }\n        \n        // Calculate number of bucket lowers needed for this row\n        if (water_units > 0) {\n            total_lowers += (water_units + capacity - 1) / capacity;\n        }\n    }\n    \n    return total_lowers;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    svbool_t pg = svwhilelt_b16(0, lst.size());\n    uint64_t i = 0;\n\n    do {\n        svint16_t vec = svld1_s16(pg, lst.data() + i);\n        svbool_t even_pos = svzip1_b(svpfalse(), svptrue_b16());\n        svbool_t odd_val = svcmpeq_n_s16(pg, svand_s16(vec, svdup_n_s16(1)), 1);\n        svbool_t mask = svand_b_z(pg, even_pos, odd_val);\n        svint16_t masked_vec = svsel_s16(mask, vec, svdup_n_s16(0));\n        sum += svaddv_s16(pg, masked_vec);\n        i += svcntw();\n        pg = svwhilelt_b16(i, lst.size());\n    } while (svptest_any(svptrue_b16(), pg));\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    svbool_t pg = svptrue_b16();\n    int64_t sum = 0;\n    size_t i = 0;\n    size_t len = lst.size();\n\n    while (i < len) {\n        svint16_t vec = svld1_s16(pg, &lst[i]);\n        svbool_t even_pos = svzip1_b16(svpfalse_b(), svptrue_b16());\n        svbool_t odd_val = svcmpeq_n_s16(pg, svand_s16_z(pg, vec, svdup_n_s16(1)), 1);\n        svbool_t mask = svand_b_z(pg, even_pos, odd_val);\n        \n        svint16_t masked_vec = svsel_s16(mask, vec, svdup_n_s16(0));\n        sum += svaddv_s16(pg, masked_vec);\n        \n        i += svcntw();\n        pg = svwhilelt_b16(i, len);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    svbool_t pg = svptrue_b16();\n    size_t i = 0;\n\n    // Process even indices in chunks using SVE\n    for (; i + svcntw() <= lst.size(); i += svcntw()) {\n        // Load vector from even indices\n        svint16_t vec = svld1_s16(pg, &lst[i]);\n        \n        // Create mask for even positions (0, 2, 4, ...)\n        svbool_t even_pos = svzip1_b(pg, svfalse());\n        \n        // Mask for odd values\n        svbool_t odd_mask = svcmpeq_n_s16(pg, svand_n_s16(pg, vec, 1), 1);\n        \n        // Combine masks: odd values at even positions\n        svbool_t final_mask = svand_b_z(pg, even_pos, odd_mask);\n        \n        // Sum elements where mask is true\n        svint16_t masked_vec = svsel_s16(final_mask, vec, svdup_n_s16(0));\n        sum += svaddv_s16(pg, masked_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < lst.size(); i += 2) {\n        if (lst[i] & 1) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    size_t len = lst.size();\n    svbool_t pg = svwhilelt_b16(0, len);\n    size_t i = 0;\n\n    while (i < len) {\n        // Load vector\n        svint16_t vec = svld1_s16(pg, &lst[i]);\n        \n        // Create mask for even positions\n        svbool_t even_pos = svzip1_b(svptrue_b16(), svpfalse());\n        \n        // Create mask for odd numbers (LSB = 1)\n        svbool_t odd_nums = svand_b_z(svptrue_b16(), vec, svdup_s16(1));\n        \n        // Combine masks: even positions AND odd numbers\n        svbool_t mask = svand_b_z(pg, even_pos, odd_nums);\n        \n        // Select elements that match criteria\n        svint16_t selected = svsel_s16(mask, vec, svdup_s16(0));\n        \n        // Sum selected elements\n        sum += svaddv_s16(pg, selected);\n        \n        // Move to next vector\n        i += svcntw();\n        pg = svwhilelt_b16(i, len);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    svbool_t pg = svptrue_b16();\n    int64_t sum = 0;\n    size_t i = 0;\n    size_t len = lst.size();\n\n    // Process even positions (0-based index) in vectorized manner\n    for (; i + svcntb() <= len; i += svcntb()) {\n        // Load vector\n        svint16_t vec = svld1_s16(pg, &lst[i]);\n        \n        // Create mask for even positions (0-based index)\n        svbool_t even_pos = svzip1_b(svpfalse_b(), svptrue_b16());\n        \n        // Create mask for odd values\n        svint16_t one = svdup_n_s16(1);\n        svbool_t odd_val = svcmpeq_n_s16(pg, svand_s16_z(pg, vec, one), one);\n        \n        // Combine masks: even positions AND odd values\n        svbool_t mask = svand_b_z(pg, even_pos, odd_val);\n        \n        // Sum elements where mask is true\n        sum += svaddv_s16(svand_b_z(pg, mask, pg), vec);\n    }\n\n    // Handle remaining elements scalarly\n    for (; i < len; i += 2) {\n        if (lst[i] & 1) { // Check if odd\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int i = 0;\n    svbool_t pg = svwhilelt_b32(i, k);\n    \n    while (i < k) {\n        svint32_t vec = svld1(pg, &arr[i]);\n        svbool_t mask = svcmple_n_s32(pg, vec, 99);\n        mask = svand_b_z(svptrue_b32(), mask, svcmpge_n_s32(pg, vec, -99));\n        sum += svaddv(mask, vec);\n        i += svcntw();\n        pg = svwhilelt_b32(i, k);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nint add_elements_simd(std::vector<int> arr, int k) {\n    svint32_t sum_vec = svdup_n_s32(0);\n    svbool_t pg = svwhilelt_b32(0, k);\n    \n    for (int i = 0; i < k; i += svcntw()) {\n        svbool_t p = svwhilelt_b32(i, k);\n        svint32_t vec = svld1_s32(p, &arr[i]);\n        \n        // Check if numbers have at most two digits (|x| <= 99)\n        svint32_t abs_vec = svabs_s32_z(p, vec);\n        svbool_t two_digit_mask = svcmple_n_s32(p, abs_vec, 99);\n        \n        // Add elements that satisfy the condition\n        sum_vec = svadd_s32_m(two_digit_mask, sum_vec, vec);\n    }\n    \n    // Reduce sum_vec to a single value\n    int32_t result = svaddv_s32(pg, sum_vec);\n    return result;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    svbool_t pg = svptrue_b32();\n    int sum = 0;\n    int i = 0;\n    svint32_t vsum = svdup_n_s32(0);\n\n    for (; i <= k - svcntw(); i += svcntw()) {\n        svint32_t vec = svld1_s32(pg, &arr[i]);\n        svbool_t mask = svcmplt_n_s32(pg, vec, 100);\n        svint32_t filtered = svsel_s32(mask, vec, svdup_n_s32(0));\n        vsum = svadd_s32_z(pg, vsum, filtered);\n    }\n\n    sum = svaddv_s32(pg, vsum);\n\n    for (; i < k; i++) {\n        if (arr[i] < 100) {\n            sum += arr[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int i = 0;\n    svbool_t pg = svwhilelt_b32(i, k);\n    \n    for (; i < k && svptest_any(svptrue_b32(), pg); i += svcntw()) {\n        svint32_t vec = svld1(pg, &arr[i]);\n        svbool_t mask = svcmplt_n_s32(pg, svabs_s32(pg, vec), 100);\n        sum += svaddv(mask, vec);\n        pg = svwhilelt_b32(i + svcntw(), k);\n    }\n    \n    for (; i < k; i++) {\n        if (abs(arr[i]) < 100) {\n            sum += arr[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int i = 0;\n    svbool_t pg = svwhilelt_b32(i, k);\n    \n    while (i < k) {\n        svint32_t vec = svld1(pg, &arr[i]);\n        svbool_t mask = svcmplt_n_s32(pg, vec, 100);\n        svint32_t filtered = svsel(mask, vec, svdup_n_s32(0));\n        sum += svaddv(pg, filtered);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, k);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    if (lst.size() <= 1) return true;\n\n    svbool_t pg = svptrue_b32();\n    size_t len = lst.size();\n    size_t vec_len = svcntw();\n\n    for (size_t i = 0; i < len - 1; i += vec_len) {\n        size_t elements = std::min(vec_len, len - 1 - i);\n        svbool_t active = svwhilelt_b32(i, i + elements);\n\n        svint32_t curr = svld1_s32(active, &lst[i]);\n        svint32_t next = svld1_s32(active, &lst[i + 1]);\n\n        // Check if current >= next (not strictly ascending or duplicates)\n        svbool_t not_ascending = svcmple_s32(active, curr, next);\n        \n        // Check for duplicates (curr == next)\n        svbool_t duplicates = svcmpeq_s32(active, curr, next);\n        \n        if (svptest_any(pg, not_ascending) || svptest_any(pg, duplicates)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    if (lst.size() <= 1) return true;\n\n    svbool_t pg = svptrue_b32();\n    size_t len = lst.size();\n    size_t vlen = svcntw();\n    bool sorted = true;\n    bool no_dups = true;\n\n    for (size_t i = 0; i < len - 1; i += vlen) {\n        size_t elements = std::min(vlen, len - 1 - i);\n        pg = svwhilelt_b32(i, len - 1);\n\n        svint32_t curr = svld1_s32(pg, &lst[i]);\n        svint32_t next = svld1_s32(pg, &lst[i + 1]);\n\n        // Check if ascending (curr < next)\n        svbool_t ascending = svcmplt_s32(pg, curr, next);\n        // Check for duplicates (curr == next)\n        svbool_t equal = svcmpeq_s32(pg, curr, next);\n\n        // If any pair is not ascending, mark as not sorted\n        if (!svptest_all(pg, ascending)) {\n            sorted = false;\n        }\n\n        // If any pair is equal, mark as having duplicates\n        if (svptest_any(pg, equal)) {\n            no_dups = false;\n        }\n\n        // Early exit if both conditions fail\n        if (!sorted && !no_dups) {\n            return false;\n        }\n    }\n\n    // Check for duplicates in the last element if needed\n    if (no_dups && len > 1) {\n        if (lst[len - 1] == lst[len - 2]) {\n            no_dups = false;\n        }\n    }\n\n    return sorted && no_dups;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    if (lst.size() <= 1) return true;\n    \n    svbool_t pg = svwhilelt_b32(0, lst.size() - 1);\n    size_t vlen = svcntw();\n    \n    for (size_t i = 0; i < lst.size() - 1; i += vlen) {\n        // Load current and next elements\n        svint32_t curr = svld1_s32(pg, &lst[i]);\n        svint32_t next = svld1_s32(pg, &lst[i + 1]);\n        \n        // Check if current >= next (not strictly ascending or duplicates)\n        svbool_t not_ascending = svcmple_s32(pg, next, curr);\n        \n        // Check for duplicates (curr == next)\n        svbool_t duplicates = svcmpeq_s32(pg, curr, next);\n        \n        // Combine conditions: not ascending or duplicates\n        svbool_t invalid = svorr_z(pg, not_ascending, duplicates);\n        \n        if (svptest_any(pg, invalid)) {\n            return false;\n        }\n        \n        // Update predicate for remaining elements\n        pg = svwhilelt_b32(i + vlen, lst.size() - 1);\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool is_sorted_simd(const std::vector<int>& lst) {\n    if (lst.size() <= 1) return true;\n\n    svbool_t pg = svptrue_b32();\n    size_t len = lst.size();\n    size_t vlen = svcntw();\n    bool is_sorted = true;\n\n    for (size_t i = 0; i < len - 1; i += vlen) {\n        size_t elements = std::min(vlen, len - 1 - i);\n        pg = svwhilelt_b32(i, len - 1);\n\n        svuint32_t curr = svld1(pg, &lst[i]);\n        svuint32_t next = svld1(pg, &lst[i + 1]);\n\n        // Check if curr >= next (not strictly ascending or duplicates)\n        svbool_t ge_mask = svcmplt(pg, next, curr);\n        svbool_t eq_mask = svcmpeq(pg, curr, next);\n\n        // If any curr >= next, sequence is not sorted or has duplicates\n        if (svptest_any(pg, svorr_z(pg, ge_mask, eq_mask))) {\n            is_sorted = false;\n            break;\n        }\n    }\n\n    // Handle remaining elements scalarly if any\n    if (is_sorted && (len % vlen != 0 || len < vlen)) {\n        for (size_t i = (len - 1) - ((len - 1) % vlen); i < len - 1; i++) {\n            if (lst[i] >= lst[i + 1]) {\n                is_sorted = false;\n                break;\n            }\n        }\n    }\n\n    return is_sorted;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    if (lst.size() <= 1) return true;\n\n    svbool_t pg = svptrue_b32();\n    size_t len = lst.size();\n    size_t vlen = svcntw();\n    bool sorted = true;\n\n    for (size_t i = 0; i < len - 1; i += vlen) {\n        size_t elements = std::min(vlen, len - 1 - i);\n        pg = svwhilelt_b32(i, len - 1);\n\n        svint32_t current = svld1_s32(pg, &lst[i]);\n        svint32_t next = svld1_s32(pg, &lst[i + 1]);\n\n        // Check for ascending order\n        svbool_t not_ascending = svcmplt_s32(pg, next, current);\n        if (svptest_any(pg, not_ascending)) {\n            sorted = false;\n            break;\n        }\n\n        // Check for duplicates\n        svbool_t duplicates = svcmpeq_s32(pg, current, next);\n        if (svptest_any(pg, duplicates)) {\n            sorted = false;\n            break;\n        }\n    }\n\n    return sorted;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    svbool_t pg = svwhilelt_b32(0, arr.size());\n    svint32_t vec = svld1_s32(pg, arr.data());\n    \n    // Compute absolute values (magnitudes)\n    svint32_t abs_vec = svabs_s32_z(pg, vec);\n    \n    // Sum of magnitudes\n    int32_t sum = svaddv_s32(pg, abs_vec);\n    \n    // Compute signs: -1, 0, 1\n    svint32_t signs = svsel_s32(\n        svcmpeq_n_s32(pg, vec, 0),\n        svdup_n_s32(0),\n        svsel_s32(\n            svcmpge_n_s32(pg, vec, 0),\n            svdup_n_s32(1),\n            svdup_n_s32(-1)\n        )\n    );\n    \n    // Product of signs\n    int32_t sign_prod = svmulv_s32(pg, signs);\n    \n    return sum * sign_prod;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    svbool_t pg = svwhilelt_b32(0, arr.size());\n    svint32_t vec_sum = svdup_n_s32(0);\n    svint32_t vec_sign = svdup_n_s32(1);\n    \n    const int *ptr = arr.data();\n    size_t i = 0;\n    \n    while (i < arr.size()) {\n        svint32_t vec = svld1_s32(pg, ptr + i);\n        \n        svint32_t abs_vec = svabs_s32_z(pg, vec);\n        vec_sum = svadd_s32_z(pg, vec_sum, abs_vec);\n        \n        svbool_t zero_mask = svcmpeq_n_s32(pg, vec, 0);\n        svbool_t neg_mask = svcmplt_n_s32(pg, vec, 0);\n        \n        svint32_t sign = svsel_s32(zero_mask, svdup_n_s32(0),\n                         svsel_s32(neg_mask, svdup_n_s32(-1), svdup_n_s32(1)));\n        vec_sign = svmul_s32_z(pg, vec_sign, sign);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, arr.size());\n    }\n    \n    int32_t sum = svaddv_s32(svptrue_b32(), vec_sum);\n    int32_t sign_prod = svmulv_s32(svptrue_b32(), vec_sign);\n    \n    return sum * sign_prod;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    svbool_t pg = svptrue_b32();\n    int64_t sum = 0;\n    int64_t sign_product = 1;\n    size_t i = 0;\n    size_t len = arr.size();\n\n    while (i < len) {\n        svint32_t vec = svld1_s32(pg, &arr[i]);\n        svbool_t active = svwhilelt_b32(i, len);\n\n        // Compute magnitudes\n        svint32_t abs_vec = svabs_s32_z(pg, vec);\n        sum += svaddv_s32(active, abs_vec);\n\n        // Compute signs: 1 for positive, -1 for negative, 0 for zero\n        svint32_t signs = svdup_n_s32(0);\n        signs = svsel_s32(svcgt_s32_z(pg, vec, svdup_n_s32(0)), svdup_n_s32(1), signs);\n        signs = svsel_s32(svclt_s32_z(pg, vec, svdup_n_s32(0)), svdup_n_s32(-1), signs);\n\n        // Multiply signs for active lanes\n        sign_product *= svmulv_s32(active, signs);\n\n        i += svcntw();\n    }\n\n    // Handle zero case: if any number is zero, result is zero\n    if (sign_product == 0) return 0;\n\n    return sum * sign_product;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    svbool_t pg = svptrue_b32();\n    int64_t sum = 0;\n    int64_t sign_prod = 1;\n    \n    size_t i = 0;\n    size_t len = arr.size();\n    \n    while (i < len) {\n        svint32_t vec = svld1_s32(pg, &arr[i]);\n        \n        // Compute absolute values\n        svint32_t abs_vec = svabs_s32_z(pg, vec);\n        \n        // Compute signs: 1, -1, or 0\n        svint32_t sign = svsel_s32(\n            svcmpeq_n_s32(pg, vec, 0),\n            svdup_n_s32(0),\n            svsel_s32(\n                svcmpgt_n_s32(pg, vec, 0),\n                svdup_n_s32(1),\n                svdup_n_s32(-1)\n            )\n        );\n        \n        // Sum absolute values\n        sum += svaddv_s32(pg, abs_vec);\n        \n        // Product of signs\n        sign_prod *= svmulv_s32(pg, sign);\n        \n        i += svcntw();\n    }\n    \n    return sum * sign_prod;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    svbool_t pg = svwhilelt_b32(0, arr.size());\n    svint32_t vsum = svdup_n_s32(0);\n    svint32_t vsign = svdup_n_s32(1);\n    size_t i = 0;\n\n    while (i < arr.size()) {\n        svint32_t vec = svld1_s32(pg, &arr[i]);\n        vsum = svadd_s32_z(pg, vsum, svabs_s32_z(pg, vec));\n        \n        svint32_t sign = svdup_n_s32(1);\n        sign = svsel_s32(svcmplt_s32(pg, vec, svdup_n_s32(0)), svdup_n_s32(-1), sign);\n        sign = svsel_s32(svcmpeq_s32(pg, vec, svdup_n_s32(0)), svdup_n_s32(0), sign);\n        vsign = svmul_s32_z(pg, vsign, sign);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, arr.size());\n    }\n\n    int32_t total_sum = svaddv_s32(svptrue_b32(), vsum);\n    int32_t total_sign = svmulv_s32(svptrue_b32(), vsign);\n\n    return total_sum * total_sign;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>> &grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k, INT_MAX);\n    \n    // Flatten grid for vectorized processing\n    std::vector<int> flat_grid(N * N);\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            flat_grid[i * N + j] = grid[i][j];\n        }\n    }\n    \n    // Process possible starting positions\n    for (int start = 0; start < N * N; ++start) {\n        int row = start / N;\n        int col = start % N;\n        std::vector<int> curr_path(k);\n        curr_path[0] = grid[row][col];\n        \n        // For k=1, just compare single values\n        if (k == 1) {\n            if (grid[row][col] < result[0]) {\n                result[0] = grid[row][col];\n            }\n            continue;\n        }\n        \n        // Generate paths of length k\n        std::vector<std::pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        for (int step = 1; step < k; ++step) {\n            int min_val = INT_MAX;\n            svbool_t pg = svwhilelt_b32(0, directions.size());\n            svint32_t min_vals = svdup_s32(INT_MAX);\n            \n            // Process directions in parallel\n            for (int d = 0; d < directions.size(); ++d) {\n                int new_row = row + directions[d].first;\n                int new_col = col + directions[d].second;\n                \n                if (new_row >= 0 && new_row < N && new_col >= 0 && new_col < N) {\n                    int val = grid[new_row][new_col];\n                    svint32_t curr_val = svdup_s32(val);\n                    min_vals = svmin_s32_z(pg, min_vals, curr_val);\n                    if (val < min_val) {\n                        min_val = val;\n                    }\n                }\n            }\n            \n            curr_path[step] = min_val;\n            // Update position to the cell with minimum value\n            for (int d = 0; d < directions.size(); ++d) {\n                int new_row = row + directions[d].first;\n                int new_col = col + directions[d].second;\n                if (new_row >= 0 && new_row < N && new_col >= 0 && new_col < N) {\n                    if (grid[new_row][new_col] == min_val) {\n                        row = new_row;\n                        col = new_col;\n                        break;\n                    }\n                }\n            }\n        }\n        \n        // Compare paths lexicographically using SVE\n        svbool_t pg = svwhilelt_b32(0, k);\n        svint32_t curr_vec = svld1_s32(pg, curr_path.data());\n        svint32_t result_vec = svld1_s32(pg, result.data());\n        svbool_t cmp = svcmplt_s32(pg, curr_vec, result_vec);\n        \n        if (svptest_any(svptrue_b32(), cmp)) {\n            result = curr_path;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>>& grid, int k) {\n    int n = grid.size();\n    std::vector<int> result(k, INT_MAX);\n    std::vector<int> current_path(k);\n    \n    // Flatten grid for SIMD processing\n    std::vector<int> flat_grid(n * n);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            flat_grid[i * n + j] = grid[i][j];\n        }\n    }\n    \n    // Possible moves: right, down, left, up\n    const int moves[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    \n    // Process all starting positions\n    for (int start = 0; start < n * n; ++start) {\n        int row = start / n;\n        int col = start % n;\n        current_path[0] = flat_grid[start];\n        \n        // Handle k=1 case\n        if (k == 1) {\n            if (current_path[0] < result[0]) {\n                result[0] = current_path[0];\n            }\n            continue;\n        }\n        \n        // Generate paths of length k\n        std::vector<int> path_indices(k);\n        path_indices[0] = start;\n        \n        // Use SVE for path evaluation\n        svbool_t pg = svptrue_b32();\n        svint32_t min_vec = svdup_s32(INT_MAX);\n        \n        // Recursive path exploration\n        auto explore = [&](int pos, int idx, auto&& explore_ref) -> void {\n            if (idx == k) {\n                // Compare current path with result using SVE\n                svint32_t curr_vec = svld1_s32(pg, current_path.data());\n                svint32_t res_vec = svld1_s32(pg, result.data());\n                svbool_t lt_mask = svcmplt_s32(pg, curr_vec, res_vec);\n                \n                // Find first position where paths differ\n                int first_diff = k;\n                for (int i = 0; i < k; ++i) {\n                    if (current_path[i] != result[i]) {\n                        first_diff = i;\n                        break;\n                    }\n                }\n                \n                // Update result if current path is lexicographically smaller\n                if (first_diff < k && current_path[first_diff] < result[first_diff]) {\n                    for (int i = 0; i < k; ++i) {\n                        result[i] = current_path[i];\n                    }\n                }\n                return;\n            }\n            \n            // Try all possible moves\n            int curr_row = path_indices[idx - 1] / n;\n            int curr_col = path_indices[idx - 1] % n;\n            \n            // Use SVE to process moves\n            svint32_t row_vec = svdup_s32(curr_row);\n            svint32_t col_vec = svdup_s32(curr_col);\n            svint32_t move_row_vec = svld1_s32(pg, &moves[0][0]);\n            svint32_t move_col_vec = svld1_s32(pg, &moves[0][1]);\n            \n            svint32_t new_row_vec = svadd_s32_z(pg, row_vec, move_row_vec);\n            svint32_t new_col_vec = svadd_s32_z(pg, col_vec, move_col_vec);\n            \n            // Check valid moves\n            svbool_t valid_mask = svand_b_z(\n                pg,\n                svcmplt_s32(pg, new_row_vec, svdup_s32(n)),\n                svcmpge_s32(pg, new_row_vec, svdup_s32(0))\n            );\n            valid_mask = svand_b_z(\n                valid_mask,\n                svcmplt_s32(pg, new_col_vec, svdup_s32(n)),\n                svcmpge_s32(pg, new_col_vec, svdup_s32(0))\n            );\n            \n            // Process valid moves\n            while (svptest_any(pg, valid_mask)) {\n                for (int i = 0; i < 4; ++i) {\n                    if (svclastb_b32(svptrue_b32(), valid_mask)) {\n                        int new_row = curr_row + moves[i][0];\n                        int new_col = curr_col + moves[i][1];\n                        if (new_row >= 0 && new_row < n && new_col >= 0 && new_col < n) {\n                            path_indices[idx] = new_row * n + new_col;\n                            current_path[idx] = flat_grid[path_indices[idx]];\n                            explore_ref(pos + 1, idx + 1, explore_ref);\n                        }\n                    }\n                    valid_mask = svbic_b_z(pg, valid_mask, svptrue_b32());\n                }\n            }\n        };\n        \n        // Start path exploration\n        explore(1, 1, explore);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>> &grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k, INT_MAX);\n    std::vector<int> current(k);\n    int min_val = INT_MAX;\n    \n    // Flatten grid for vectorized processing\n    std::vector<int> flat_grid(N * N);\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            flat_grid[i * N + j] = grid[i][j];\n            min_val = std::min(min_val, grid[i][j]);\n        }\n    }\n    \n    // Early return for k=1\n    if (k == 1) {\n        return {min_val};\n    }\n\n    // SVE vector length\n    svbool_t pg = svwhilelt_b32(0, N * N);\n    svint32_t v_min = svdup_s32(INT_MAX);\n    \n    // Find minimum starting point\n    for (int i = 0; i < N * N; i += svcntw()) {\n        svint32_t v_grid = svld1(pg, &flat_grid[i]);\n        v_min = svmin_s32_z(pg, v_min, v_grid);\n    }\n    \n    int start_idx = 0;\n    for (int i = 0; i < N * N; i++) {\n        if (flat_grid[i] == svminv_s32(pg, v_min)) {\n            start_idx = i;\n            break;\n        }\n    }\n    \n    int start_row = start_idx / N;\n    int start_col = start_idx % N;\n    \n    // Directions for neighboring cells (up, right, down, left)\n    const int dr[4] = {-1, 0, 1, 0};\n    const int dc[4] = {0, 1, 0, -1};\n    \n    // Initialize result with first path found\n    current[0] = grid[start_row][start_col];\n    for (int step = 1; step < k; step++) {\n        int r = (step == 1) ? start_row : (start_row + dr[0]) % N;\n        int c = (step == 1) ? start_col : (start_col + dc[0]) % N;\n        if (r < 0) r += N;\n        if (c < 0) c += N;\n        current[step] = grid[r][c];\n    }\n    result = current;\n    \n    // Vectorized path comparison\n    svint32_t v_result = svld1(pg, result.data());\n    \n    // Try all possible starting positions\n    for (int i = 0; i < N * N; i++) {\n        int row = i / N;\n        int col = i % N;\n        \n        // Skip if starting value is already larger than current minimum\n        if (grid[row][col] > result[0]) continue;\n        \n        current[0] = grid[row][col];\n        \n        // Generate all possible paths from this starting point\n        for (int step = 1; step < k; step++) {\n            svint32_t v_neighbors = svdup_s32(INT_MAX);\n            svbool_t valid_pg = svptrue_b32();\n            \n            // Check all four directions\n            for (int d = 0; d < 4; d++) {\n                int new_row = row + dr[d];\n                int new_col = col + dc[d];\n                \n                if (new_row >= 0 && new_row < N && new_col >= 0 && new_col < N) {\n                    int neighbor_val = grid[new_row][new_col];\n                    svint32_t v_temp = svdup_s32(neighbor_val);\n                    v_neighbors = svmin_s32_z(valid_pg, v_neighbors, v_temp);\n                }\n            }\n            \n            int min_neighbor = svminv_s32(valid_pg, v_neighbors);\n            for (int d = 0; d < 4; d++) {\n                int new_row = row + dr[d];\n                int new_col = col + dc[d];\n                if (new_row >= 0 && new_row < N && new_col >= 0 && new_col < N) {\n                    if (grid[new_row][new_col] == min_neighbor) {\n                        row = new_row;\n                        col = new_col;\n                        break;\n                    }\n                }\n            }\n            current[step] = min_neighbor;\n        }\n        \n        // Vectorized comparison of paths\n        svint32_t v_current = svld1(pg, current.data());\n        svbool_t cmp = svcmplt_s32(pg, v_current, v_result);\n        \n        if (svptest_any(svptrue_b32(), cmp)) {\n            v_result = v_current;\n            result = current;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>> &grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k, INT_MAX);\n    std::vector<int> current(k);\n    \n    // Flatten grid for SIMD processing\n    std::vector<int> flat_grid(N * N);\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            flat_grid[i * N + j] = grid[i][j];\n        }\n    }\n    \n    // Directions for adjacent cells (up, right, down, left)\n    int dr[] = {-1, 0, 1, 0};\n    int dc[] = {0, 1, 0, -1};\n    \n    // Process each starting position\n    for (int start_r = 0; start_r < N; ++start_r) {\n        for (int start_c = 0; start_c < N; ++start_c) {\n            current[0] = grid[start_r][start_c];\n            \n            // Generate paths of length k\n            std::vector<int> path(k);\n            path[0] = start_r * N + start_c;\n            \n            // Use SVE for path exploration\n            svbool_t pg = svptrue_b32();\n            svint32_t min_path = svdup_n_s32(INT_MAX);\n            \n            for (int step = 1; step < k; ++step) {\n                svint32_t candidates = svdup_n_s32(INT_MAX);\n                \n                // Check all four directions\n                for (int d = 0; d < 4; ++d) {\n                    int nr = start_r + dr[d] * step;\n                    int nc = start_c + dc[d] * step;\n                    \n                    // Validate move\n                    if (nr >= 0 && nr < N && nc >= 0 && nc < N) {\n                        int val = grid[nr][nc];\n                        svint32_t curr_val = svdup_n_s32(val);\n                        candidates = svmin_s32_z(pg, candidates, curr_val);\n                    }\n                }\n                \n                // Store minimum value for this step\n                int min_val = svminv_s32(pg, candidates);\n                current[step] = min_val;\n                \n                // Update min_path if current is lexicographically smaller\n                svint32_t curr_path = svld1_s32(pg, current.data());\n                min_path = svmin_s32_z(pg, min_path, curr_path);\n            }\n            \n            // Compare and update result\n            std::vector<int> temp(k);\n            svst1_s32(pg, temp.data(), min_path);\n            if (temp < result) {\n                result = temp;\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>> &grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k, INT_MAX);\n    std::vector<int> current(k);\n    \n    // Flatten grid for SIMD processing\n    std::vector<int> flat_grid(N * N);\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            flat_grid[i * N + j] = grid[i][j];\n        }\n    }\n    \n    // Possible moves: right, down, left, up\n    int dr[] = {0, 1, 0, -1};\n    int dc[] = {1, 0, -1, 0};\n    \n    // Process all starting positions\n    for (int start_r = 0; start_r < N; start_r++) {\n        for (int start_c = 0; start_c < N; start_c++) {\n            current[0] = grid[start_r][start_c];\n            \n            // For k=1, just check starting position\n            if (k == 1) {\n                if (current[0] < result[0]) {\n                    result[0] = current[0];\n                }\n                continue;\n            }\n            \n            // Generate paths of length k\n            std::vector<int> path(k);\n            path[0] = start_r * N + start_c;\n            \n            // SIMD-optimized path exploration\n            svbool_t pg = svptrue_b32();\n            svint32_t min_vals = svdup_n_s32(INT_MAX);\n            \n            for (int step = 1; step < k; step++) {\n                int curr_pos = path[step - 1];\n                int r = curr_pos / N;\n                int c = curr_pos % N;\n                \n                // Load possible next values\n                int next_vals[4] = {INT_MAX, INT_MAX, INT_MAX, INT_MAX};\n                int valid_moves = 0;\n                \n                // Check all four directions\n                for (int d = 0; d < 4; d++) {\n                    int nr = r + dr[d];\n                    int nc = c + dc[d];\n                    if (nr >= 0 && nr < N && nc >= 0 && nc < N) {\n                        next_vals[valid_moves++] = grid[nr][nc];\n                    }\n                }\n                \n                // Create SVE vector for comparison\n                svint32_t vals_vec = svld1_s32(pg, next_vals);\n                min_vals = svmin_s32_z(pg, min_vals, vals_vec);\n                \n                // Find minimum value among valid moves\n                int min_val = INT_MAX;\n                for (int i = 0; i < valid_moves; i++) {\n                    if (next_vals[i] < min_val) {\n                        min_val = next_vals[i];\n                        path[step] = (r + dr[i]) * N + (c + dc[i]);\n                    }\n                }\n                current[step] = min_val;\n            }\n            \n            // Compare with current minimum path\n            bool update = false;\n            for (int i = 0; i < k; i++) {\n                if (current[i] < result[i]) {\n                    update = true;\n                    break;\n                } else if (current[i] > result[i]) {\n                    break;\n                }\n            }\n            if (update) {\n                result = current;\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t digits_simd(uint64_t n) {\n    if (n == 0) return 0;\n\n    // Initialize result\n    uint64_t result = 1;\n    svbool_t pg = svwhilelt_b64(0, 1);\n    \n    // Process digits\n    while (n > 0) {\n        uint64_t digit = n % 10;\n        \n        // Create vector with single digit\n        svuint64_t vec_digit = svdup_u64(digit);\n        \n        // Check if digit is odd (digit % 2 == 1)\n        svbool_t is_odd = svcmpeq_n_u64(pg, svand_n_u64_z(pg, vec_digit, 1), 1);\n        \n        // If digit is odd, multiply result\n        if (svptest_any(pg, is_odd)) {\n            result *= digit;\n        } else {\n            // If even digit found, reset result to 0\n            result = 0;\n        }\n        \n        n /= 10;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t digits_simd(uint64_t n) {\n    svbool_t pg = svptrue_b8();\n    svuint64_t result = svdup_u64(1);\n    svbool_t odd_mask = svptrue_b8();\n    int has_odd = 0;\n\n    while (n > 0) {\n        uint64_t digit = n % 10;\n        svuint64_t digit_vec = svdup_u64(digit);\n        svbool_t is_odd = svcmpeq_n_u64(pg, svand_n_u64_z(pg, digit_vec, 1), 1);\n        \n        if (svptest_any(pg, is_odd)) {\n            has_odd = 1;\n            result = svmul_u64_m(odd_mask, result, digit_vec);\n            odd_mask = svsel_u64(is_odd, pg, odd_mask);\n        }\n        \n        n /= 10;\n    }\n\n    if (!has_odd) {\n        return 0;\n    }\n\n    return svlasta_u64(pg, result);\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t digits_simd(uint64_t n) {\n    svbool_t pg = svptrue_b8();\n    svuint64_t result = svdup_u64(1);\n    svuint64_t zero = svdup_u64(0);\n    svuint64_t ten = svdup_u64(10);\n    \n    while (n > 0) {\n        svuint64_t digit = svdup_u64(n % 10);\n        svbool_t odd_mask = svcmpeq_n_u64(pg, svand_u64_x(pg, digit, svdup_u64(1)), 1);\n        result = svsel_u64(odd_mask, svmul_u64_x(pg, result, digit), result);\n        n /= 10;\n    }\n    \n    svbool_t all_even = svcmpeq_n_u64(pg, result, 1);\n    return svsel_u64(all_even, zero, result)[0];\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t digits_simd(uint64_t n) {\n    svbool_t pg = svwhilelt_b64(0, 10);\n    svuint64_t digits = svdup_u64(0);\n    svuint64_t result = svdup_u64(1);\n    svbool_t odd_mask;\n\n    while (n > 0) {\n        uint64_t digit = n % 10;\n        digits = svinsr_n_u64(digits, digit);\n        n /= 10;\n    }\n\n    odd_mask = svcmpeq_n_u64(pg, svand_n_u64_z(pg, digits, 1), 1);\n    result = svsel_u64(odd_mask, svmul_u64_z(pg, result, digits), result);\n\n    svbool_t all_even = svnot_b_z(pg, odd_mask);\n    if (svptest_any(pg, all_even)) {\n        return 0;\n    }\n\n    return svmulv_u64(pg, result);\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t digits_simd(uint64_t n) {\n    svbool_t pg = svptrue_b8();\n    svuint64_t vec = svdup_u64(n);\n    svuint64_t result = svdup_u64(1);\n    svbool_t odd_mask = svptrue_b8();\n    \n    while (svptest_any(pg, svcmpne_n_u64(pg, vec, 0))) {\n        svuint64_t digit = svmod_n_u64(pg, vec, 10);\n        vec = svdiv_n_u64(pg, vec, 10);\n        \n        svbool_t is_odd = svcmpeq_n_u64(pg, svand_n_u64(pg, digit, 1), 1);\n        odd_mask = svand_b_z(pg, odd_mask, is_odd);\n        result = svsel_u64(is_odd, svmul_u64(pg, result, digit), result);\n    }\n    \n    svbool_t all_even = svnot_b_z(pg, odd_mask);\n    result = svsel_u64(all_even, svdup_u64(0), result);\n    \n    return svlasta_u64(pg, result);\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <cmath>\n\nuint64_t sum_squares_simd(const std::vector<float>& lst) {\n    uint64_t sum = 0;\n    svfloat32_t vec;\n    svbool_t pg = svptrue_b32();\n    size_t i = 0;\n\n    for (; i + svcntw() <= lst.size(); i += svcntw()) {\n        vec = svld1_f32(pg, &lst[i]);\n        svint32_t ceil_vec = svceil_s32_z(pg, vec);\n        svint32_t square_vec = svmul_s32_z(pg, ceil_vec, ceil_vec);\n        sum += svaddv_s32(pg, square_vec);\n    }\n\n    for (; i < lst.size(); i++) {\n        int ceil_val = std::ceil(lst[i]);\n        sum += ceil_val * ceil_val;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    svfloat32_t vec;\n    svbool_t pg = svptrue_b32();\n    \n    size_t i = 0;\n    size_t vec_len = svcntw();\n    \n    for (; i + vec_len <= lst.size(); i += vec_len) {\n        vec = svld1_f32(pg, &lst[i]);\n        vec = svceil_f32_z(pg, vec);\n        vec = svmul_f32_z(pg, vec, vec);\n        sum += svaddv_f32(pg, vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < lst.size(); i++) {\n        float val = ceilf(lst[i]);\n        sum += val * val;\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    svbool_t pg = svptrue_b32();\n    size_t i = 0;\n    \n    for (; i + svcntw() <= lst.size(); i += svcntw()) {\n        svfloat32_t vec = svld1_f32(pg, &lst[i]);\n        svfloat32_t ceil_vec = svceil_f32_z(pg, vec);\n        svint32_t int_vec = svcvt_s32_f32_z(pg, ceil_vec);\n        svint32_t sq_vec = svmul_s32_z(pg, int_vec, int_vec);\n        sum += svaddv_s32(pg, sq_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < lst.size(); i++) {\n        int ceil_val = std::ceil(lst[i]);\n        sum += ceil_val * ceil_val;\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    svfloat32_t vec;\n    svint32_t ceil_vec;\n    svuint64_t square_vec;\n    svbool_t pg = svptrue_b32();\n    \n    for (size_t i = 0; i < lst.size(); i += svcntw()) {\n        size_t remaining = std::min(svcntw(), lst.size() - i);\n        pg = svwhilelt_b32(i, lst.size());\n        \n        vec = svld1_f32(pg, &lst[i]);\n        ceil_vec = svcvt_s32_f32_x(pg, svceil_f32_x(pg, vec));\n        square_vec = svmul_s32_z(pg, ceil_vec, ceil_vec);\n        \n        sum += svaddv_u64(pg, square_vec);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cmath>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    svfloat32_t vec;\n    svbool_t pg = svptrue_b32();\n    size_t i = 0;\n\n    for (; i + svcntw() <= lst.size(); i += svcntw()) {\n        vec = svld1_f32(pg, &lst[i]);\n        vec = svceil_f32_x(pg, vec);\n        svint32_t int_vec = svcvt_s32_f32_x(pg, vec);\n        svint32_t squared = svmul_s32_x(pg, int_vec, int_vec);\n        sum += svaddv_s32(pg, squared);\n    }\n\n    for (; i < lst.size(); i++) {\n        int32_t val = std::ceil(lst[i]);\n        sum += val * val;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    if (arr.size() <= 1) return -1;\n    \n    svbool_t pg = svwhilelt_b32(0, arr.size() - 1);\n    int max_idx = -1;\n    \n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec = svld1_s32(pg, arr.data());\n        svint32_t vec_next = svld1_s32(pg, arr.data() + 1);\n        \n        svbool_t cmp = svcmplt_s32(pg, vec_next, vec);\n        \n        if (svptest_any(svptrue_b32(), cmp)) {\n            uint64_t mask = svcntp_b32(svptrue_b32(), cmp);\n            int idx = svlastb_s32(svptrue_b32(), svindex_s32(0, 1));\n            max_idx = std::max(max_idx, idx);\n        }\n        \n        pg = svwhilelt_b32(svcntp_b32(svptrue_b32(), pg), arr.size() - 1);\n    }\n    \n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    if (arr.size() < 2) return -1;\n    \n    int len = arr.size();\n    int max_idx = -1;\n    \n    // Process elements in vector-sized chunks\n    svbool_t pg = svwhilelt_b32(0, len-1);\n    int i = 0;\n    \n    while (i < len-1) {\n        // Load current and next elements\n        svint32_t curr = svld1_s32(pg, arr.data() + i);\n        svint32_t next = svld1_s32(pg, arr.data() + i + 1);\n        \n        // Compare if current >= next\n        svbool_t cmp = svcmplt_s32(pg, next, curr);\n        \n        // Find indices where condition is true\n        if (svptest_any(pg, cmp)) {\n            // Get first true index\n            uint64_t mask = svcntp_b32(pg, cmp);\n            if (mask) {\n                // Find last true index in this chunk\n                svbool_t last = svbrkb_b_z(svptrue_b32(), cmp);\n                int chunk_idx = svcntp_b32(pg, last) - 1;\n                max_idx = i + chunk_idx;\n            }\n        }\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, len-1);\n    }\n    \n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    if (arr.size() <= 1) return -1;\n    \n    int max_index = -1;\n    svbool_t pg = svwhilelt_b32(0, (int)arr.size()-1);\n    \n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec = svld1_s32(pg, arr.data() + svcntw());\n        svint32_t vec_next = svld1_s32(pg, arr.data() + 1 + svcntw());\n        \n        svbool_t mask = svcmplt_s32(pg, vec_next, vec);\n        \n        if (svptest_any(svptrue_b32(), mask)) {\n            svint32_t indices = svindex_s32(svcntw(), 1);\n            svint32_t masked_indices = svsel_s32(mask, indices, svdup_s32(-1));\n            max_index = std::max(max_index, svmaxv_s32(svptrue_b32(), masked_indices));\n        }\n        \n        pg = svwhilelt_b32(svcntw(), (int)arr.size()-1);\n    }\n    \n    return max_index;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    if (arr.size() < 2) return -1;\n    \n    int max_idx = -1;\n    svbool_t pg = svwhilelt_b32(0, arr.size() - 1);\n    \n    // Load pairs of adjacent elements\n    svint32_t vec_curr = svld1(pg, arr.data());\n    svint32_t vec_next = svld1(pg, arr.data() + 1);\n    \n    // Compare if current element >= next element\n    svbool_t cmp = svcmpge(pg, vec_curr, vec_next);\n    \n    // Find indices where condition is true\n    uint64_t mask = svcntp_b32(svptrue_b32(), cmp);\n    if (mask > 0) {\n        // Get last true index\n        svbool_t active = cmp;\n        while (svptest_any(svptrue_b32(), active)) {\n            max_idx = svlastb_b32(active, svindex_s32(0, 1));\n            active = svbrkb_b_z(svptrue_b32(), active);\n        }\n    }\n    \n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    if (arr.size() < 2) return -1;\n\n    int max_idx = -1;\n    svbool_t pg = svwhilelt_b32(0, arr.size() - 1);\n    \n    // Load pairs of consecutive elements\n    svint32_t vec_curr = svld1_s32(pg, arr.data());\n    svint32_t vec_next = svld1_s32(pg, arr.data() + 1);\n    \n    // Compare if current element >= next element\n    svbool_t cmp = svcmplt_s32(pg, vec_curr, vec_next);\n    \n    // Find last true index\n    uint64_t mask = svcntp_b32(svptrue_b32(), cmp);\n    if (mask > 0) {\n        max_idx = svlastb_s32(svptrue_b32(), svindex_s32(0, 1), cmp);\n    }\n    \n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    svbool_t pg = svptrue_b32();\n    int32_t max_neg = 0;\n    int32_t min_pos = 0;\n\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    svint32_t max_neg_vec = svdup_n_s32(INT32_MIN);\n    svint32_t min_pos_vec = svdup_n_s32(INT32_MAX);\n    svbool_t neg_mask = svptrue_b32();\n    svbool_t pos_mask = svptrue_b32();\n\n    size_t i = 0;\n    size_t len = lst.size();\n    size_t vl = svcntw();\n\n    for (; i + vl <= len; i += vl) {\n        svint32_t vec = svld1_s32(pg, &lst[i]);\n        svbool_t neg_cond = svcmplt_n_s32(pg, vec, 0);\n        svbool_t pos_cond = svcmpgt_n_s32(pg, vec, 0);\n\n        max_neg_vec = svsel_s32(neg_cond, svmax_s32_m(neg_cond, max_neg_vec, vec), max_neg_vec);\n        min_pos_vec = svsel_s32(pos_cond, svmin_s32_m(pos_cond, min_pos_vec, vec), min_pos_vec);\n\n        neg_mask = svorr_b_z(pg, neg_mask, neg_cond);\n        pos_mask = svorr_b_z(pg, pos_mask, pos_cond);\n    }\n\n    // Handle remaining elements\n    if (i < len) {\n        svbool_t rem_pg = svwhilelt_b32(i, len);\n        svint32_t vec = svld1_s32(rem_pg, &lst[i]);\n        svbool_t neg_cond = svcmplt_n_s32(rem_pg, vec, 0);\n        svbool_t pos_cond = svcmpgt_n_s32(rem_pg, vec, 0);\n\n        max_neg_vec = svsel_s32(neg_cond, svmax_s32_m(neg_cond, max_neg_vec, vec), max_neg_vec);\n        min_pos_vec = svsel_s32(pos_cond, svmin_s32_m(pos_cond, min_pos_vec, vec), min_pos_vec);\n\n        neg_mask = svorr_b_z(pg, neg_mask, neg_cond);\n        pos_mask = svorr_b_z(pg, pos_mask, pos_cond);\n    }\n\n    // Reduce vectors to scalars\n    max_neg = svmaxv_s32(pg, max_neg_vec);\n    min_pos = svminv_s32(pg, min_pos_vec);\n\n    // Check if any negative or positive numbers were found\n    if (!svptest_any(pg, neg_mask)) {\n        max_neg = 0;\n    }\n    if (!svptest_any(pg, pos_mask)) {\n        min_pos = 0;\n    }\n\n    return {max_neg, min_pos};\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    svint32_t max_neg = svdup_n_s32(0);\n    svint32_t min_pos = svdup_n_s32(0);\n    svbool_t pg = svptrue_b32();\n    int has_neg = 0, has_pos = 0;\n\n    for (size_t i = 0; i < lst.size(); i += svcntw()) {\n        svbool_t pg_loop = svwhilelt_b32(i, lst.size());\n        svint32_t vec = svld1_s32(pg_loop, &lst[i]);\n\n        // Negative numbers\n        svbool_t neg_mask = svcmplt_s32(pg_loop, vec, svdup_n_s32(0));\n        if (svptest_any(pg_loop, neg_mask)) {\n            has_neg = 1;\n            max_neg = svsel_s32(neg_mask, svmax_s32_m(neg_mask, max_neg, vec), max_neg);\n        }\n\n        // Positive numbers\n        svbool_t pos_mask = svcmpgt_s32(pg_loop, vec, svdup_n_s32(0));\n        if (svptest_any(pg_loop, pos_mask)) {\n            has_pos = 1;\n            min_pos = svsel_s32(pos_mask, \n                               svmin_s32_m(pos_mask, \n                                          min_pos, \n                                          svsel_s32(pos_mask, vec, svdup_n_s32(INT32_MAX))), \n                               min_pos);\n        }\n    }\n\n    int result_max_neg = has_neg ? svmaxv_s32(pg, max_neg) : 0;\n    int result_min_pos = has_pos ? svminv_s32(pg, min_pos) : 0;\n\n    return {result_max_neg, result_min_pos};\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    int64_t max_neg = 0, min_pos = 0;\n    svbool_t pg = svwhilelt_b64(0, lst.size());\n    \n    if (!lst.empty()) {\n        svint64_t neg_max = svdup_s64(INT64_MIN);\n        svint64_t pos_min = svdup_s64(INT64_MAX);\n        svbool_t neg_mask = svptrue_b64();\n        svbool_t pos_mask = svptrue_b64();\n        \n        for (size_t i = 0; i < lst.size(); i += svcntd()) {\n            pg = svwhilelt_b64(i, lst.size());\n            svint64_t vec = svld1_s64(pg, &lst[i]);\n            \n            svbool_t is_neg = svcmplt_s64(pg, vec, svdup_s64(0));\n            svbool_t is_pos = svcmpgt_s64(pg, vec, svdup_s64(0));\n            \n            neg_max = svsel_s64(is_neg, svmax_s64_m(neg_mask, neg_max, vec), neg_max);\n            pos_min = svsel_s64(is_pos, svmin_s64_m(pos_mask, pos_min, vec), pos_min);\n        }\n        \n        max_neg = svmaxv_s64(svptrue_b64(), neg_max);\n        min_pos = svminv_s64(svptrue_b64(), pos_min);\n        \n        if (max_neg == INT64_MIN) max_neg = 0;\n        if (min_pos == INT64_MAX) min_pos = 0;\n    }\n    \n    return {static_cast<int>(max_neg), static_cast<int>(min_pos)};\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    int64_t max_neg = 0;\n    int64_t min_pos = 0;\n\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    svbool_t pg = svwhilelt_b32(0, lst.size());\n    svint32_t vec_max_neg = svdup_s32(INT32_MIN);\n    svint32_t vec_min_pos = svdup_s32(INT32_MAX);\n    svbool_t neg_mask = svptrue_b32();\n    svbool_t pos_mask = svptrue_b32();\n\n    for (size_t i = 0; i < lst.size(); i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, lst.size());\n        svint32_t vec = svld1_s32(pg, &lst[i]);\n\n        svbool_t is_neg = svcmplt_s32(pg, vec, svdup_s32(0));\n        svbool_t is_pos = svcmpgt_s32(pg, vec, svdup_s32(0));\n\n        vec_max_neg = svsel_s32(is_neg, svmax_s32_m(is_neg, vec_max_neg, vec), vec_max_neg);\n        vec_min_pos = svsel_s32(is_pos, svmin_s32_m(is_pos, vec_min_pos, vec), vec_min_pos);\n\n        neg_mask = svorr_b_z(svptrue_b32(), neg_mask, is_neg);\n        pos_mask = svorr_b_z(svptrue_b32(), pos_mask, is_pos);\n    }\n\n    if (svptest_any(svptrue_b32(), neg_mask)) {\n        max_neg = svmaxv_s32(svptrue_b32(), vec_max_neg);\n    }\n    if (svptest_any(svptrue_b32(), pos_mask)) {\n        min_pos = svminv_s32(svptrue_b32(), vec_min_pos);\n    }\n\n    return {static_cast<int>(max_neg), static_cast<int>(min_pos)};\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    svint32_t max_neg = svdup_n_s32(0);\n    svint32_t min_pos = svdup_n_s32(0);\n    svbool_t pg = svptrue_b32();\n    \n    int max_negative = 0;\n    int min_positive = 0;\n    bool has_neg = false;\n    bool has_pos = false;\n\n    for (size_t i = 0; i < lst.size(); i += svcntw()) {\n        svbool_t pm = svwhilelt_b32(i, lst.size());\n        svint32_t vec = svld1_s32(pm, &lst[i]);\n        \n        // Find negative numbers\n        svbool_t neg_mask = svcmplt_s32(pm, vec, svdup_n_s32(0));\n        if (svptest_any(pm, neg_mask)) {\n            max_neg = svsel_s32(neg_mask, svmax_s32_m(neg_mask, max_neg, vec), max_neg);\n            has_neg = true;\n        }\n        \n        // Find positive numbers\n        svbool_t pos_mask = svcmpgt_s32(pm, vec, svdup_n_s32(0));\n        if (svptest_any(pm, pos_mask)) {\n            if (!has_pos) {\n                min_pos = vec;\n                has_pos = true;\n            }\n            min_pos = svsel_s32(pos_mask, svmin_s32_m(pos_mask, min_pos, vec), min_pos);\n        }\n    }\n\n    if (has_neg) {\n        max_negative = svmaxv_s32(pg, max_neg);\n    }\n    if (has_pos) {\n        min_positive = svminv_s32(pg, min_pos);\n    }\n\n    return {max_negative, min_positive};\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n    \n    svbool_t pg = svwhilelt_b64(1, n + 1);\n    svuint64_t vec = svindex_u64(1, 1);\n    svuint64_t fact = svdup_u64(1);\n    \n    while (svptest_any(svptrue_b64(), pg)) {\n        svuint64_t temp = fact;\n        for (uint64_t i = 1; i <= n; i++) {\n            svbool_t mask = svcmpeq_u64(pg, vec, svdup_u64(i));\n            temp = svsel_u64(mask, svmul_u64_z(pg, temp, vec), temp);\n        }\n        fact = temp;\n        pg = svwhilelt_b64(svaddv_u64(svptrue_b64(), vec) + 1, n + 1);\n        vec = svadd_u64_z(svptrue_b64(), vec, svdup_u64(1));\n    }\n    \n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; i++) {\n        result *= svmulv_u64(svptrue_b64(), fact);\n        fact = svdiv_u64_z(svptrue_b64(), fact, svdup_u64(i));\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n    \n    svbool_t pg = svwhilelt_b64(0, n);\n    svuint64_t vec = svindex_u64(1, 1);\n    svuint64_t result = svdup_u64(1);\n    \n    // Compute factorials for 1 to n\n    for (uint64_t i = 1; i <= n; i++) {\n        svuint64_t fact = svdup_u64(1);\n        svuint64_t counter = svindex_u64(1, 1);\n        svbool_t mask = svwhilele_b64(1, i);\n        \n        // Calculate factorial for current i\n        while (svptest_any(pg, mask)) {\n            fact = svmul_u64_m(mask, fact, counter);\n            counter = svadd_u64_m(mask, counter, svdup_u64(1));\n            mask = svwhilele_b64(svminv_u64(svadd_n_u64_x(pg, svmax_u64_m(mask, counter, mask), 1), i);\n        }\n        \n        // Accumulate product of factorials\n        result = svmul_u64_m(pg, result, fact);\n    }\n    \n    // Reduce vector to single value\n    uint64_t final = 1;\n    while (svtest_any(pg)) {\n        uint64_t lane = svlasta_u64(pg, result);\n        final *= lane;\n        pg = svwhilelt_b64(svlastb_u64(pg), n);\n    }\n    \n    return final;\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n    \n    svbool_t pg = svwhilelt_b64(1, n + 1);\n    svuint64_t vec = svindex_u64(1, 1);\n    svuint64_t factorial = svdup_u64(1);\n    \n    while (svptest_any(svptrue_b64(), pg)) {\n        svuint64_t temp = svdup_u64(1);\n        svuint64_t counter = svindex_u64(1, 1);\n        svbool_t pg_inner = svwhilelt_b64(1, svmaxv_u64(pg, vec));\n        \n        while (svptest_any(svptrue_b64(), pg_inner)) {\n            temp = svmul_u64_z(pg_inner, temp, counter);\n            counter = svadd_u64_z(pg_inner, counter, svdup_u64(1));\n            pg_inner = svwhilelt_b64(svminv_u64(pg_inner, counter), svmaxv_u64(pg, vec));\n        }\n        \n        factorial = svmul_u64_z(pg, factorial, temp);\n        vec = svsub_u64_z(pg, vec, svdup_u64(1));\n        pg = svwhilelt_b64(1, svmaxv_u64(pg, vec) + 1);\n    }\n    \n    return svmulv_u64(svptrue_b64(), factorial);\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    uint64_t result = 1;\n    svbool_t pg = svwhilelt_b64(1, n + 1);\n    \n    // Create vector of numbers from 1 to n\n    svuint64_t vec = svindex_u64(1, 1);\n    \n    // Calculate factorials iteratively\n    for (uint64_t i = 1; i <= n; i++) {\n        svuint64_t fact = svdup_u64(1);\n        svbool_t inner_pg = svwhilelt_b64(1, i + 1);\n        svuint64_t inner_vec = svindex_u64(1, 1);\n        \n        // Compute factorial for current i\n        while (svptest_any(svptrue_b64(), inner_pg)) {\n            fact = svmul_u64_z(inner_pg, fact, inner_vec);\n            inner_vec = svadd_u64_z(inner_pg, inner_vec, svdup_u64(1));\n            inner_pg = svwhilelt_b64(svlow_u64(inner_vec), i + 1);\n        }\n        \n        // Get last element of factorial vector\n        uint64_t fact_i = svlasta(svptrue_b64(), fact);\n        result *= fact_i;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    svbool_t pg = svptrue_b64();\n    uint64_t result = 1;\n    \n    // Create vector of numbers from 1 to n\n    svuint64_t vec = svindex_u64(1, 1);\n    svuint64_t factorial = svdup_u64(1);\n    \n    // Compute factorials iteratively\n    for (uint64_t i = 1; i <= n; i++) {\n        // Compute factorial for current number\n        svuint64_t current = svdup_u64(i);\n        svuint64_t indices = svindex_u64(1, 1);\n        svuint64_t temp = svdup_u64(1);\n        \n        // Calculate single factorial\n        svbool_t mask = svwhilele_b64(1, i);\n        while (svptest_any(pg, mask)) {\n            temp = svmul_u64_m(mask, temp, indices);\n            indices = svadd_u64_z(pg, indices, svdup_u64(1));\n            mask = svwhilele_b64(svminv_u64(mask, indices), i);\n        }\n        \n        // Multiply result with current factorial\n        factorial = svmul_u64_m(pg, factorial, svsel_u64(\n            svcmpeq_u64(pg, vec, current), \n            temp, \n            svdup_u64(1)\n        ));\n        \n        // Update result\n        result *= svmulv_u64(pg, factorial);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint sum_squares_simd(const std::vector<int>& lst) {\n    int64_t sum = 0;\n    size_t len = lst.size();\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b32(i, len);\n\n    for (; i < len; ) {\n        svint32_t vec = svld1_s32(pg, &lst[i]);\n\n        svbool_t idx_mod3 = svptrue_b32();\n        svbool_t idx_mod4 = svptrue_b32();\n        svbool_t idx_not_mod3 = svptrue_b32();\n\n        svuint32_t indices = svindex_u32(i, 1);\n        svuint32_t mod3 = svmul_n_u32_z(pg, indices, 3);\n        svuint32_t mod4 = svmul_n_u32_z(pg, indices, 4);\n\n        idx_mod3 = svcmpeq_n_u32(pg, svdiv_n_u32_z(pg, indices, 3), mod3);\n        idx_mod4 = svcmpeq_n_u32(pg, svdiv_n_u32_z(pg, indices, 4), mod4);\n        idx_not_mod3 = svcmpeq_n_u32(pg, svdiv_n_u32_z(pg, indices, 3), mod3);\n\n        svbool_t mod4_not_mod3 = svand_b_z(pg, idx_mod4, svnot_b_z(pg, idx_not_mod3));\n        svbool_t mod3_only = svand_b_z(pg, idx_mod3, svnot_b_z(pg, idx_mod4));\n\n        svint32_t squared = svmul_s32_z(mod3_only, vec, vec);\n        svint32_t cubed = svmul_s32_z(mod4_not_mod3, svmul_s32_z(mod4_not_mod3, vec, vec), vec);\n\n        svint32_t result = svsel_s32(mod3_only, squared, vec);\n        result = svsel_s32(mod4_not_mod3, cubed, result);\n\n        sum += svaddv_s32(pg, result);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, len);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int>& lst) {\n    int64_t sum = 0;\n    svint32_t sum_vec = svdup_n_s32(0);\n    svbool_t pg = svwhilelt_b32(0, lst.size());\n\n    for (size_t i = 0; i < lst.size(); i += svcntw()) {\n        pg = svwhilelt_b32(i, lst.size());\n        \n        svint32_t vec = svld1_s32(pg, &lst[i]);\n        \n        // Create predicates for indices multiple of 3 and 4\n        svbool_t mod3 = svdup_b32(false);\n        svbool_t mod4 = svdup_b32(false);\n        \n        // Calculate indices for current vector\n        svint32_t indices = svindex_s32(i, 1);\n        \n        // Check multiples of 3\n        svint32_t div3 = svdiv_n_s32_z(pg, indices, 3);\n        svint32_t mul3 = svmul_n_s32_z(pg, div3, 3);\n        mod3 = svcmpeq_s32(pg, indices, mul3);\n        \n        // Check multiples of 4\n        svint32_t div4 = svdiv_n_s32_z(pg, indices, 4);\n        svint32_t mul4 = svmul_n_s32_z(pg, div4, 4);\n        mod4 = svcmpeq_s32(pg, indices, mul4);\n        \n        // For indices that are multiple of both 3 and 4, only apply cube (multiple of 4)\n        svbool_t mod3_only = svbic_b_z(pg, mod3, mod4);\n        \n        // Square elements where index is multiple of 3 (and not 4)\n        svint32_t squared = svmul_s32_z(mod3_only, vec, vec);\n        \n        // Cube elements where index is multiple of 4\n        svint32_t cubed = svmul_s32_z(mod4, vec, svmul_s32_z(pg, vec, vec));\n        \n        // Select squared values where mod3_only is true\n        svint32_t result = svsel_s32(mod3_only, squared, vec);\n        \n        // Select cubed values where mod4 is true\n        result = svsel_s32(mod4, cubed, result);\n        \n        // Accumulate sum\n        sum_vec = svadd_s32_z(pg, sum_vec, result);\n    }\n    \n    // Reduce sum_vec to scalar\n    sum = svaddv_s32(svptrue_b32(), sum_vec);\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint sum_squares_simd(const std::vector<int>& lst) {\n    int64_t sum = 0;\n    size_t len = lst.size();\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b32(i, len);\n    for (; i < len; i += svcntw()) {\n        svbool_t p3 = svptrue_b32();\n        svbool_t p4 = svptrue_b32();\n        \n        // Create predicates for indices multiple of 3 and 4\n        svuint32_t indices = svindex_u32(i, 1);\n        svuint32_t mod3 = svmls_n_u32_x(pg, svmul_n_u32_x(pg, indices, 0x55555555), indices, 0x55555555);\n        svuint32_t mod4 = svmls_n_u32_x(pg, svmul_n_u32_x(pg, indices, 0x40000000), indices, 0x40000000);\n        p3 = svcmpeq_n_u32(pg, mod3, 0);\n        p4 = svcmpeq_n_u32(pg, mod4, 0);\n        \n        // Load input vector\n        svint32_t vec = svld1_s32(pg, &lst[i]);\n        \n        // Square elements where index % 3 == 0\n        svint32_t squared = svmul_s32_x(pg, vec, vec);\n        \n        // Cube elements where index % 4 == 0 and not % 3 == 0\n        svbool_t p4_not_p3 = svbic_b_z(pg, p4, p3);\n        svint32_t cubed = svmul_s32_x(pg, squared, vec);\n        \n        // Select squared, cubed, or original values\n        svint32_t result = svsel_s32(p4_not_p3, cubed, svsel_s32(p3, squared, vec));\n        \n        // Accumulate sum\n        sum += svaddv_s32(pg, result);\n        \n        pg = svwhilelt_b32(i + svcntw(), len);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint sum_squares_simd(const std::vector<int>& lst) {\n    int64_t sum = 0;\n    const int* data = lst.data();\n    size_t len = lst.size();\n    \n    svbool_t pg = svwhilelt_b32(0, len);\n    size_t i = 0;\n    \n    while (i < len) {\n        // Create predicates for indices multiple of 3 and 4\n        svbool_t pred_m3 = svptrue_b32();\n        svbool_t pred_m4 = svptrue_b32();\n        svbool_t pred_m3_not_m4 = svptrue_b32();\n        \n        // Generate index vector\n        svuint32_t indices = svindex_u32(i, 1);\n        \n        // Check multiples of 3\n        svuint32_t three = svdup_u32(3);\n        svbool_t mod3_zero = svcmpeq_n_u32(pg, svmod_u32(indices, three), 0);\n        \n        // Check multiples of 4\n        svuint32_t four = svdup_u32(4);\n        svbool_t mod4_zero = svcmpeq_n_u32(pg, svmod_u32(indices, four), 0);\n        \n        // Combine predicates: multiple of 3 AND NOT multiple of 4\n        pred_m3_not_m4 = svand_b_z(pg, mod3_zero, svnot_b_z(pg, mod4_zero));\n        \n        // Load input vector\n        svint32_t vec = svld1_s32(pg, data + i);\n        \n        // Square elements where index is multiple of 3 (and not 4)\n        svint32_t squared = svmul_s32_z(pred_m3_not_m4, vec, vec);\n        \n        // Cube elements where index is multiple of 4\n        svint32_t cubed = svmul_s32_z(mod4_zero, vec, svmul_s32_z(pg, vec, vec));\n        \n        // Select squared, cubed, or original values based on predicates\n        svint32_t result = svsel_s32(mod4_zero, cubed, \n                          svsel_s32(pred_m3_not_m4, squared, vec));\n        \n        // Accumulate sum\n        sum += svaddv_s32(pg, result);\n        \n        // Advance index\n        i += svcntw();\n        pg = svwhilelt_b32(i, len);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int>& lst) {\n    int64_t sum = 0;\n    size_t len = lst.size();\n    size_t i = 0;\n\n    // Process vector in SVE chunks\n    svbool_t pg = svwhilelt_b32(i, len);\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load input data\n        svint32_t vec = svld1(pg, &lst[i]);\n\n        // Create predicates for indices\n        svuint32_t indices = svindex_u32(i, 1);\n        svbool_t mod3 = svcmpeq(pg, svurem_nu32(pg, indices, svdup_u32(3)), 0);\n        svbool_t mod4 = svcmpeq(pg, svurem_nu32(pg, indices, svdup_u32(4)), 0);\n        svbool_t mod3_not4 = svbic_b_z(pg, mod3, mod4);\n\n        // Square elements where index % 3 == 0 and not % 4 == 0\n        svint32_t squared = svmul_z(mod3_not4, vec, vec);\n        \n        // Cube elements where index % 4 == 0\n        svint32_t cubed = svmul_z(mod4, vec, svmul_z(pg, vec, vec));\n\n        // Select between original, squared, and cubed values\n        svint32_t result = svsel(mod4, cubed, svsel(mod3_not4, squared, vec));\n\n        // Accumulate sum\n        sum += svaddv(pg, result);\n\n        // Move to next chunk\n        i += svcntw();\n        pg = svwhilelt_b32(i, len);\n    }\n\n    // Handle remaining elements scalarly\n    for (; i < len; ++i) {\n        if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n\n    for (; i + svcntw() <= nums.size(); i += svcntw()) {\n        svint32_t vec = svld1_s32(pg, &nums[i]);\n        \n        // Check if numbers are greater than 10\n        svbool_t gt_10 = svcmpgt_s32(pg, vec, 10);\n        \n        // Get absolute values for digit checks\n        svint32_t abs_vec = svabs_s32_z(pg, vec);\n        \n        // Extract last digit (abs_vec % 10)\n        svint32_t last_digit = svmod_n_s32_z(pg, abs_vec, 10);\n        \n        // Check if last digit is odd (1,3,5,7,9)\n        svbool_t last_odd = svorr_z(pg,\n            svorr_z(pg,\n                svorr_z(pg,\n                    svcmpeq_s32(pg, last_digit, 1),\n                    svcmpeq_s32(pg, last_digit, 3)),\n                svorr_z(pg,\n                    svcmpeq_s32(pg, last_digit, 5),\n                    svcmpeq_s32(pg, last_digit, 7))),\n            svcmpeq_s32(pg, last_digit, 9));\n        \n        // Extract first digit (abs_vec / 10 until single digit)\n        svint32_t first_digit = abs_vec;\n        svbool_t active = svptrue_b32();\n        while (svptest_any(pg, svcmpge_s32(active, first_digit, 10))) {\n            first_digit = svdiv_n_s32_z(active, first_digit, 10);\n        }\n        \n        // Check if first digit is odd\n        svbool_t first_odd = svorr_z(pg,\n            svorr_z(pg,\n                svorr_z(pg,\n                    svcmpeq_s32(pg, first_digit, 1),\n                    svcmpeq_s32(pg, first_digit, 3)),\n                svorr_z(pg,\n                    svcmpeq_s32(pg, first_digit, 5),\n                    svcmpeq_s32(pg, first_digit, 7))),\n            svcmpeq_s32(pg, first_digit, 9));\n        \n        // Combine conditions: greater than 10 AND first digit odd AND last digit odd\n        svbool_t result = svand_z(pg, svand_z(pg, gt_10, first_odd), last_odd);\n        \n        // Count true predicates\n        count += svcntp_b32(pg, result);\n    }\n\n    // Handle remaining elements\n    for (; i < nums.size(); i++) {\n        int num = nums[i];\n        int abs_num = std::abs(num);\n        int last_digit = abs_num % 10;\n        int first_digit = abs_num;\n        while (first_digit >= 10) {\n            first_digit /= 10;\n        }\n        bool is_last_odd = (last_digit == 1 || last_digit == 3 || last_digit == 5 || \n                          last_digit == 7 || last_digit == 9);\n        bool is_first_odd = (first_digit == 1 || first_digit == 3 || first_digit == 5 || \n                           first_digit == 7 || first_digit == 9);\n        if (num > 10 && is_first_odd && is_last_odd) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n\n    for (; i + svcntw() <= nums.size(); i += svcntw()) {\n        svint32_t vec = svld1_s32(pg, &nums[i]);\n        \n        // Check if numbers are greater than 10\n        svbool_t gt_10 = svcmpgt_s32(pg, vec, 10);\n        \n        // Get absolute values for digit checking\n        svint32_t abs_vec = svabs_s32_z(pg, vec);\n        \n        // Extract first and last digits\n        svint32_t last_digit = svmod_n_s32_z(pg, abs_vec, 10);\n        \n        // To get first digit, repeatedly divide by 10 until single digit\n        svint32_t temp = abs_vec;\n        svbool_t non_zero = svcmpgt_s32(pg, temp, 0);\n        while (svptest_any(pg, non_zero)) {\n            temp = svdiv_n_s32_z(pg, temp, 10);\n            non_zero = svcmpgt_s32(pg, temp, 0);\n        }\n        svint32_t first_digit = temp;\n        \n        // Check if digits are odd (1,3,5,7,9)\n        svbool_t last_odd = svorr_z(pg, \n            svorr_z(pg,\n                svcmpeq_s32(pg, last_digit, 1),\n                svcmpeq_s32(pg, last_digit, 3)),\n            svorr_z(pg,\n                svorr_z(pg,\n                    svcmpeq_s32(pg, last_digit, 5),\n                    svcmpeq_s32(pg, last_digit, 7)),\n                svcmpeq_s32(pg, last_digit, 9)));\n                \n        svbool_t first_odd = svorr_z(pg,\n            svorr_z(pg,\n                svcmpeq_s32(pg, first_digit, 1),\n                svcmpeq_s32(pg, first_digit, 3)),\n            svorr_z(pg,\n                svorr_z(pg,\n                    svcmpeq_s32(pg, first_digit, 5),\n                    svcmpeq_s32(pg, first_digit, 7)),\n                svcmpeq_s32(pg, first_digit, 9)));\n        \n        // Combine conditions\n        svbool_t valid = svand_z(pg, svand_z(pg, gt_10, first_odd), last_odd);\n        \n        // Count valid elements\n        count += svcntp_b32(pg, valid);\n    }\n\n    // Handle remaining elements scalarly\n    for (; i < nums.size(); i++) {\n        int num = nums[i];\n        if (num > 10) {\n            int abs_num = abs(num);\n            int last = abs_num % 10;\n            int first = abs_num;\n            while (first >= 10) first /= 10;\n            \n            bool is_odd = (n % 2 == 1);\n            if (is_odd(last) && is_odd(first)) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n\n    for (; i + svcntw() <= nums.size(); i += svcntw()) {\n        svint32_t vec = svld1(pg, &nums[i]);\n        \n        // Check if numbers are greater than 10\n        svbool_t gt_10 = svcmpgt(pg, vec, 10);\n        \n        // Get absolute values for digit checking\n        svint32_t abs_vec = svabs_s32_z(pg, vec);\n        \n        // Extract last digit (abs_vec % 10)\n        svint32_t last_digit = svmod_n_s32_z(pg, abs_vec, 10);\n        \n        // Extract first digit by repeatedly dividing by 10\n        svint32_t temp = abs_vec;\n        svint32_t first_digit = abs_vec;\n        while (svmaxv_s32(pg, temp) >= 10) {\n            temp = svdiv_n_s32_z(pg, temp, 10);\n            first_digit = temp;\n        }\n        \n        // Check if digits are odd (1,3,5,7,9)\n        svbool_t last_odd = svcmpeq_n_s32(pg, last_digit, 1);\n        last_odd = svor_b_z(pg, last_odd, svcmpeq_n_s32(pg, last_digit, 3));\n        last_odd = svor_b_z(pg, last_odd, svcmpeq_n_s32(pg, last_digit, 5));\n        last_odd = svor_b_z(pg, last_odd, svcmpeq_n_s32(pg, last_digit, 7));\n        last_odd = svor_b_z(pg, last_odd, svcmpeq_n_s32(pg, last_digit, 9));\n        \n        svbool_t first_odd = svcmpeq_n_s32(pg, first_digit, 1);\n        first_odd = svor_b_z(pg, first_odd, svcmpeq_n_s32(pg, first_digit, 3));\n        first_odd = svor_b_z(pg, first_odd, svcmpeq_n_s32(pg, first_digit, 5));\n        first_odd = svor_b_z(pg, first_odd, svcmpeq_n_s32(pg, first_digit, 7));\n        first_odd = svor_b_z(pg, first_odd, svcmpeq_n_s32(pg, first_digit, 9));\n        \n        // Combine conditions\n        svbool_t mask = svand_b_z(pg, gt_10, svand_b_z(pg, first_odd, last_odd));\n        \n        // Count true predicates\n        count += svcntp_b32(pg, mask);\n    }\n\n    // Handle remaining elements\n    for (; i < nums.size(); i++) {\n        int num = nums[i];\n        if (num > 10) {\n            int abs_num = std::abs(num);\n            int last_digit = abs_num % 10;\n            int first_digit = abs_num;\n            while (first_digit >= 10) {\n                first_digit /= 10;\n            }\n            if ((last_digit % 2 == 1) && (first_digit % 2 == 1)) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint specialFilter_simd(const std::vector<int>& nums) {\n    int count = 0;\n    size_t len = nums.size();\n    svbool_t pg = svwhilelt_b32(0, len);\n    \n    for (size_t i = 0; i < len; i += svcntw()) {\n        svbool_t p = svwhilelt_b32(i, len);\n        svint32_t vec = svld1_s32(p, &nums[i]);\n        \n        // Check if numbers are greater than 10\n        svbool_t gt10 = svcmpgt(p, vec, 10);\n        \n        // Get absolute values for digit checking\n        svint32_t abs_vec = svabs_s32_z(p, vec);\n        \n        // Extract first and last digits\n        svint32_t last_digit = svmod_n_s32_z(p, abs_vec, 10);\n        \n        // Calculate first digit by repeatedly dividing by 10\n        svint32_t temp = abs_vec;\n        svint32_t first_digit = abs_vec;\n        svbool_t non_zero = svcmpgt(p, temp, 0);\n        while (svptest_any(p, non_zero)) {\n            temp = svdiv_n_s32_z(p, temp, 10);\n            first_digit = svsel_s32(non_zero, temp, first_digit);\n            non_zero = svcmpgt(p, temp, 0);\n        }\n        \n        // Check if digits are odd (1,3,5,7,9)\n        svbool_t last_odd = svcmpeq_n_s32(p, last_digit, 1);\n        last_odd = svor_z(p, last_odd, svcmpeq_n_s32(p, last_digit, 3));\n        last_odd = svor_z(p, last_odd, svcmpeq_n_s32(p, last_digit, 5));\n        last_odd = svor_z(p, last_odd, svcmpeq_n_s32(p, last_digit, 7));\n        last_odd = svor_z(p, last_odd, svcmpeq_n_s32(p, last_digit, 9));\n        \n        svbool_t first_odd = svcmpeq_n_s32(p, first_digit, 1);\n        first_odd = svor_z(p, first_odd, svcmpeq_n_s32(p, first_digit, 3));\n        first_odd = svor_z(p, first_odd, svcmpeq_n_s32(p, first_digit, 5));\n        first_odd = svor_z(p, first_odd, svcmpeq_n_s32(p, first_digit, 7));\n        first_odd = svor_z(p, first_odd, svcmpeq_n_s32(p, first_digit, 9));\n        \n        // Combine conditions\n        svbool_t valid = svand_z(p, gt10, svand_z(p, first_odd, last_odd));\n        \n        // Count valid elements\n        count += svcntp_b32(p, valid);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int>& nums) {\n    int count = 0;\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, nums.size());\n\n    for (; i < nums.size(); ) {\n        svint32_t vec = svld1_s32(pg, &nums[i]);\n        \n        // Check if numbers are greater than 10\n        svbool_t gt10 = svcmpgt_s32(pg, vec, 10);\n        \n        // Extract first and last digits\n        svint32_t abs_vec = svabs_s32_z(pg, vec);\n        svint32_t last_digit = svmod_n_s32_z(pg, abs_vec, 10);\n        \n        // Calculate first digit by repeatedly dividing by 10\n        svint32_t first_digit = abs_vec;\n        svint32_t div = svdup_n_s32(10);\n        svbool_t non_zero = svcmpgt_s32(pg, first_digit, 0);\n        while (svptest_any(pg, non_zero)) {\n            first_digit = svdiv_n_s32_z(pg, first_digit, 10);\n            non_zero = svcmpgt_s32(pg, first_digit, 0);\n        }\n        \n        // Check if digits are odd (1,3,5,7,9)\n        svbool_t last_odd = svorr_z(pg,\n            svorr_z(pg,\n                svorr_z(pg,\n                    svcmpeq_s32(pg, last_digit, 1),\n                    svcmpeq_s32(pg, last_digit, 3)),\n                svorr_z(pg,\n                    svcmpeq_s32(pg, last_digit, 5),\n                    svcmpeq_s32(pg, last_digit, 7))),\n            svcmpeq_s32(pg, last_digit, 9));\n            \n        svbool_t first_odd = svorr_z(pg,\n            svorr_z(pg,\n                svorr_z(pg,\n                    svcmpeq_s32(pg, first_digit, 1),\n                    svcmpeq_s32(pg, first_digit, 3)),\n                svorr_z(pg,\n                    svcmpeq_s32(pg, first_digit, 5),\n                    svcmpeq_s32(pg, first_digit, 7))),\n            svcmpeq_s32(pg, first_digit, 9));\n        \n        // Combine conditions\n        svbool_t valid = svand_z(pg, svand_z(pg, gt10, first_odd), last_odd);\n        \n        // Count true predicates\n        count += svcntp_b32(pg, valid);\n        \n        // Update loop\n        i += svcntw();\n        pg = svwhilelt_b32(i, nums.size());\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    uint64_t *a = (uint64_t *)malloc(n * sizeof(uint64_t));\n    uint64_t count = 0;\n\n    // Generate array a using SVE\n    svbool_t pg = svwhilelt_b64(0, n);\n    for (uint64_t i = 0; i < n; i += svcntd()) {\n        svuint64_t indices = svindex_u64(i, 1);\n        svbool_t mask = svwhilelt_b64(i, n);\n        svuint64_t i_vec = svmul_u64_z(mask, indices, indices);\n        svuint64_t sub = svsub_u64_z(mask, i_vec, indices);\n        svuint64_t result = svadd_u64_z(mask, sub, 1);\n        svst1_u64(mask, &a[i], result);\n    }\n\n    // Count triples\n    for (uint64_t i = 0; i < n - 2; i++) {\n        for (uint64_t j = i + 1; j < n - 1; j++) {\n            svbool_t pk = svwhilelt_b64(j + 1, n);\n            svuint64_t sum_ij = svdup_u64(a[i] + a[j]);\n            svuint64_t k_vec = svld1_u64(pk, &a[j + 1]);\n            svuint64_t sum = svadd_u64_z(pk, sum_ij, k_vec);\n            svuint64_t mod = svmul_u64_z(pk, sum, 0x5555555555555555ULL); // Approx 1/3\n            svuint64_t mul3 = svmul_u64_z(pk, mod, 3);\n            svbool_t is_multiple = svcmpeq_u64(pk, sum, mul3);\n            count += svcntp_b64(is_multiple);\n        }\n    }\n\n    free(a);\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    uint64_t *a = (uint64_t *)malloc(n * sizeof(uint64_t));\n    uint64_t count = 0;\n    \n    // Generate array a using SVE\n    svbool_t pg = svwhilelt_b64(0, n);\n    uint64_t i = 0;\n    while (svptest_any(svptrue_b64(), pg)) {\n        svuint64_t indices = svindex_u64(i, 1);\n        svuint64_t i_squared = svmul_u64_z(pg, indices, indices);\n        svuint64_t i_minus_one = svsub_u64_z(pg, indices, 1);\n        svuint64_t result = svadd_u64_z(pg, svsub_u64_z(pg, i_squared, i_minus_one), 1);\n        svst1_u64(pg, &a[i], result);\n        i += svcntd();\n        pg = svwhilelt_b64(i, n);\n    }\n\n    // Count triples\n    for (uint64_t i = 0; i < n - 2; i++) {\n        for (uint64_t j = i + 1; j < n - 1; j++) {\n            uint64_t sum_ij = a[i] + a[j];\n            svbool_t pg = svwhilelt_b64(j + 1, n);\n            svuint64_t vec_k = svindex_u64(j + 1, 1);\n            svuint64_t vec_a = svld1_u64(pg, &a[j + 1]);\n            svuint64_t sum = svadd_u64_z(pg, vec_a, sum_ij);\n            svuint64_t mod3 = svmod_u64_z(pg, sum, 3);\n            svbool_t is_multiple = svcmpeq_u64(pg, mod3, 0);\n            count += svcntp_b64(is_multiple);\n        }\n    }\n\n    free(a);\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    uint64_t count = 0;\n    svbool_t pg = svwhilelt_b64(0, n);\n    \n    // Allocate array for a\n    uint64_t *a = (uint64_t *)malloc(n * sizeof(uint64_t));\n    \n    // Compute a[i] = i*i - i + 1 vectorized\n    for (uint64_t i = 0; i < n; i += svcntd()) {\n        svbool_t p = svwhilelt_b64(i, n);\n        svuint64_t idx = svindex_u64(i, 1);\n        svuint64_t idx_sq = svmul_u64_z(p, idx, idx);\n        svuint64_t idx_minus_one = svsub_u64_z(p, idx, 1);\n        svuint64_t result = svsub_u64_z(p, idx_sq, idx_minus_one);\n        result = svadd_u64_z(p, result, 1);\n        svst1_u64(p, &a[i], result);\n    }\n    \n    // Count triples\n    for (uint64_t i = 0; i < n-2; i++) {\n        for (uint64_t j = i+1; j < n-1; j++) {\n            svbool_t p = svwhilelt_b64(j+1, n);\n            svuint64_t aj = svdup_u64(a[j]);\n            svuint64_t ai = svdup_u64(a[i]);\n            svuint64_t sum_ij = svadd_u64_z(p, ai, aj);\n            \n            uint64_t k = j + 1;\n            for (; k < n; k += svcntd()) {\n                p = svwhilelt_b64(k, n);\n                svuint64_t ak = svld1_u64(p, &a[k]);\n                svuint64_t sum = svadd_u64_z(p, sum_ij, ak);\n                \n                // Check if sum is divisible by 3\n                svuint64_t mod3 = svmod_u64_z(p, sum, 3);\n                svbool_t is_div3 = svcmpeq_u64(p, mod3, 0);\n                \n                // Count true predicates\n                count += svcntp_b64(p, is_div3);\n            }\n        }\n    }\n    \n    free(a);\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    uint64_t *a = (uint64_t *)malloc(n * sizeof(uint64_t));\n    uint64_t count = 0;\n    \n    // Generate array a using SVE\n    uint64_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, n);\n    while (svptest_any(svptrue_b64(), pg)) {\n        svuint64_t vi = svindex_u64(i, 1);\n        svuint64_t vsq = svmul_u64_z(pg, vi, vi);\n        svuint64_t vsub = svsub_u64_z(pg, vsq, vi);\n        svuint64_t vres = svadd_u64_z(pg, vsub, 1);\n        svst1_u64(pg, &a[i], vres);\n        i += svcntd();\n        pg = svwhilelt_b64(i, n);\n    }\n    \n    // Count triples\n    for (uint64_t i = 0; i < n - 2; i++) {\n        for (uint64_t j = i + 1; j < n - 1; j++) {\n            uint64_t sum_ij = a[i] + a[j];\n            uint64_t k = j + 1;\n            pg = svwhilelt_b64(k, n);\n            \n            while (svptest_any(svptrue_b64(), pg)) {\n                svuint64_t vk = svld1_u64(pg, &a[k]);\n                svuint64_t vsum = svadd_u64_z(pg, vk, sum_ij);\n                svuint64_t vmod = svmul_u64_z(pg, vsum, 0x5555555555555555); // Approx div by 3\n                svbool_t pmod = svcmpeq_u64(pg, vmod, svmul_u64_z(pg, vmod, 3));\n                count += svcntp_b64(svptrue_b64(), pmod);\n                k += svcntd();\n                pg = svwhilelt_b64(k, n);\n            }\n        }\n    }\n    \n    free(a);\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    uint64_t *a = (uint64_t *)malloc(n * sizeof(uint64_t));\n    uint64_t count = 0;\n\n    // Generate array a using SVE\n    svbool_t pg = svwhilelt_b64(0, n);\n    for (uint64_t i = 0; i < n; i += svcntd()) {\n        svuint64_t idx = svindex_u64(i, 1);\n        svbool_t mask = svwhilelt_b64(i, n);\n        svuint64_t i_squared = svmul_u64_z(mask, idx, idx);\n        svuint64_t i_minus_one = svsub_u64_z(mask, idx, 1);\n        svuint64_t result = svadd_u64_z(mask, i_squared, 1);\n        result = svsub_u64_z(mask, result, i_minus_one);\n        svst1_u64(pg, &a[i], result);\n    }\n\n    // Count triples\n    for (uint64_t i = 0; i < n - 2; i++) {\n        svbool_t pg_j = svwhilelt_b64(i + 1, n - 1);\n        for (uint64_t j = i + 1; j < n - 1; j += svcntd()) {\n            svuint64_t a_i = svdup_u64(a[i]);\n            svuint64_t j_idx = svindex_u64(j, 1);\n            svbool_t mask_j = svwhilelt_b64(j, n - 1);\n            \n            svbool_t pg_k = svwhilelt_b64(j + 1, n);\n            for (uint64_t k = j + 1; k < n; k += svcntd()) {\n                svuint64_t a_j = svld1_u64(mask_j, &a[j]);\n                svuint64_t k_idx = svindex_u64(k, 1);\n                svbool_t mask_k = svwhilelt_b64(k, n);\n                svuint64_t a_k = svld1_u64(mask_k, &a[k]);\n\n                svuint64_t sum = svadd_u64_z(mask_k, a_i, a_j);\n                sum = svadd_u64_z(mask_k, sum, a_k);\n                svuint64_t mod3 = svmod_u64_z(mask_k, sum, 3);\n                svbool_t is_multiple = svcmpeq_u64(mask_k, mod3, 0);\n                count += svcntp_b64(mask_k, is_multiple);\n            }\n        }\n    }\n\n    free(a);\n    return count;\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    // Create a vector of n values\n    svbool_t pg = svwhilelt_b32(0, 1);\n    svint32_t vn = svdup_s32(n);\n    \n    // Initialize result vector with y\n    svint32_t result = svdup_s32(y);\n    \n    // Check if n is less than 2 (not prime)\n    if (n < 2) {\n        return y;\n    }\n    \n    // Create vector for loop counter (2 to sqrt(n))\n    int32_t sqrt_n = (int32_t)sqrt((double)n);\n    svint32_t v_i = svindex_s32(2, 1);\n    svbool_t pcmp = svwhilele_b32(2, sqrt_n);\n    \n    // Check divisibility\n    while (svptest_any(svptrue_b32(), pcmp)) {\n        // Create vector of remainders\n        svint32_t v_rem = svmod_n_s32_x(pcmp, vn, v_i);\n        \n        // Check if any remainder is 0\n        svbool_t is_divisible = svcmpeq(pcmp, v_rem, 0);\n        \n        if (svptest_any(pcmp, is_divisible)) {\n            return y;\n        }\n        \n        // Increment counter\n        v_i = svadd_n_s32_x(pcmp, v_i, 1);\n        pcmp = svwhilele_b32(svlastb(pcmp, v_i), sqrt_n);\n    }\n    \n    // If we get here, n is prime, return x\n    return x;\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    // Create predicate for active lanes\n    svbool_t pg = svptrue_b32();\n    \n    // Broadcast inputs to vectors\n    svint32_t vn = svdup_n_s32(n);\n    svint32_t vx = svdup_n_s32(x);\n    svint32_t vy = svdup_n_s32(y);\n    \n    // Initialize result vector\n    svint32_t result = vy;\n    \n    // Check if n >= 2 (prerequisite for prime)\n    svbool_t ge_2 = svcmpge(pg, vn, svdup_n_s32(2));\n    \n    if (svptest_any(pg, ge_2)) {\n        // Check divisibility up to sqrt(n)\n        int sqrt_n = (int)sqrt((double)n);\n        svbool_t is_prime = svptrue_b32();\n        \n        for (int i = 2; i <= sqrt_n; i++) {\n            svint32_t vi = svdup_n_s32(i);\n            svint32_t rem = svmod_n_s32(pg, vn, vi);\n            svbool_t div = svcmpeq(pg, rem, svdup_n_s32(0));\n            is_prime = svand_b_z(pg, is_prime, svnot_b_z(pg, div));\n        }\n        \n        // If n is prime, select x; else select y\n        result = svsel_s32(is_prime, vx, vy);\n    }\n    \n    // Return first element of result vector\n    return svlasta_s32(pg, result);\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    svbool_t pg = svwhilelt_b32(0, 1);\n    svint32_t vn = svdup_s32(n);\n    svint32_t vx = svdup_s32(x);\n    svint32_t vy = svdup_s32(y);\n    \n    svbool_t is_prime = svptrue_b32();\n    \n    // Check if n < 2\n    svbool_t less_than_two = svcmplt_s32(pg, vn, svdup_s32(2));\n    is_prime = svbic_b_z(pg, is_prime, less_than_two);\n    \n    // Check divisibility from 2 to sqrt(n)\n    int sqrt_n = (int)sqrt((double)n);\n    for (int i = 2; i <= sqrt_n; i++) {\n        svint32_t vi = svdup_s32(i);\n        svint32_t rem = svmod_n_s32_z(pg, vn, vi);\n        svbool_t divisible = svcmpeq_s32(pg, rem, svdup_s32(0));\n        is_prime = svbic_b_z(pg, is_prime, divisible);\n    }\n    \n    // Select x if prime, y otherwise\n    svint32_t result = svsel_s32(is_prime, vx, vy);\n    \n    // Extract scalar result\n    return svlasta_s32(pg, result);\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    if (n <= 1) return y;\n    \n    // Create predicate for vectorized operations\n    svbool_t pg = svwhilelt_b32(2u, (uint32_t)n);\n    \n    // Initialize count of divisors\n    svuint32_t divisors = svdup_u32(0);\n    \n    // Vector of indices from 2 to n-1\n    svuint32_t indices = svindex_u32(2, 1);\n    \n    // Check divisibility\n    while (svptest_any(svptrue_b32(), pg)) {\n        svbool_t div_mask = svcmpeq_u32(pg, svmul_u32_z(pg, svdiv_u32_z(pg, svdup_u32(n), indices), indices), svdup_u32(n));\n        divisors = svadd_u32_m(pg, divisors, svsel_u32(div_mask, svdup_u32(1), svdup_u32(0)));\n        indices = svadd_u32_z(pg, indices, svdup_u32(svlen_u32(indices)));\n        pg = svwhilelt_b32(svlastb_u32(svptrue_b32(), indices), (uint32_t)n);\n    }\n    \n    // Sum all divisors\n    uint32_t div_count = svaddv_u32(svptrue_b32(), divisors);\n    \n    // Return x if prime (only 2 divisors: 1 and n), y otherwise\n    return (div_count == 0) ? x : y;\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    svbool_t pg = svptrue_b32();\n    \n    // Broadcast inputs to vectors\n    svint32_t vn = svdup_s32(n);\n    svint32_t vx = svdup_s32(x);\n    svint32_t vy = svdup_s32(y);\n    \n    // Initialize result vector\n    svint32_t result = vy;\n    \n    // Check if n < 2 (not prime)\n    svbool_t not_prime = svcmplt_s32(pg, vn, svdup_s32(2));\n    \n    // Check if n is even and not 2 (not prime)\n    svint32_t two = svdup_s32(2);\n    svbool_t is_even = svcmpeq_s32(pg, svand_s32_z(pg, vn, two), svdup_s32(0));\n    svbool_t is_not_two = svcmpne_s32(pg, vn, two);\n    not_prime = svorr_b_z(pg, not_prime, svand_b_z(pg, is_even, is_not_two));\n    \n    // Check divisibility up to sqrt(n)\n    int sqrt_n = (int)sqrt((double)n);\n    svint32_t i = svindex_s32(3, 1);\n    svbool_t prime_mask = svptrue_b32();\n    \n    while (svptest_any(pg, svcmple_s32(pg, i, svdup_s32(sqrt_n)))) {\n        svbool_t divisible = svcmpeq_s32(pg, svmod_s32_z(pg, vn, i), svdup_s32(0));\n        prime_mask = svand_b_z(pg, prime_mask, svnot_b_z(pg, divisible));\n        i = svadd_s32_z(pg, i, svdup_s32(1));\n    }\n    \n    // Combine prime conditions\n    prime_mask = svand_b_z(pg, prime_mask, svnot_b_z(pg, not_prime));\n    \n    // Select x if prime, y otherwise\n    result = svsel_s32(prime_mask, vx, vy);\n    \n    // Return first element of result vector\n    return svlasta_s32(svptrue_b32(), result);\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nuint64_t double_the_difference_simd(const std::vector<float>& lst) {\n    uint64_t sum = 0;\n    svbool_t pg = svptrue_b32();\n    \n    size_t i = 0;\n    for (; i + svcntw() <= lst.size(); i += svcntw()) {\n        svfloat32_t vec = svld1_f32(pg, &lst[i]);\n        \n        // Check for integers (fractional part == 0)\n        svfloat32_t floor_vec = svfloor_f32_x(pg, vec);\n        svbool_t is_int = svcmpeq_f32(pg, vec, floor_vec);\n        \n        // Check for positive numbers\n        svbool_t is_positive = svcmpgt_f32(pg, vec, svdup_f32(0.0f));\n        \n        // Check for odd numbers\n        svfloat32_t mod_vec = svfmod_n_f32_x(pg, vec, svdup_f32(2.0f));\n        svbool_t is_odd = svcmpeq_f32(pg, mod_vec, svdup_f32(1.0f));\n        \n        // Combine conditions: integer, positive, and odd\n        svbool_t mask = svand_b_z(pg, is_int, svand_b_z(pg, is_positive, is_odd));\n        \n        // Square the valid numbers\n        svfloat32_t squared = svmul_f32_m(mask, vec, vec);\n        \n        // Sum the squares\n        sum += svaddv_f32(mask, squared);\n    }\n    \n    // Handle remaining elements scalarly\n    for (; i < lst.size(); i++) {\n        float val = lst[i];\n        if (val > 0 && val == (int)val && (int)val % 2 == 1) {\n            sum += val * val;\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    if (lst.empty()) return 0;\n    \n    uint64_t sum = 0;\n    const float *data = lst.data();\n    size_t len = lst.size();\n    \n    svfloat32_t v_zero = svdup_f32(0.0f);\n    svfloat32_t v_sum = svdup_f32(0.0f);\n    svbool_t pg = svwhilelt_b32(0, len);\n    \n    for (size_t i = 0; i < len; i += svcntw()) {\n        pg = svwhilelt_b32(i, len);\n        svfloat32_t v_data = svld1_f32(pg, &data[i]);\n        \n        // Check for integers (equal to their floor)\n        svfloat32_t v_floor = svrintz_f32_x(pg, v_data);\n        svbool_t is_int = svcmpeq_f32(pg, v_data, v_floor);\n        \n        // Check for positive numbers\n        svbool_t is_positive = svcmpgt_f32(pg, v_data, v_zero);\n        \n        // Check for odd numbers\n        svfloat32_t v_mod = svfmod_f32_x(pg, v_data, svdup_f32(2.0f));\n        svbool_t is_odd = svcmpeq_f32(pg, v_mod, svdup_f32(1.0f));\n        \n        // Combine conditions: integer, positive, and odd\n        svbool_t mask = svand_b_z(pg, is_int, is_positive);\n        mask = svand_b_z(pg, mask, is_odd);\n        \n        // Calculate square for valid numbers\n        svfloat32_t v_square = svmul_f32_m(mask, v_data, v_data);\n        \n        // Accumulate sum\n        v_sum = svadd_f32_m(pg, v_sum, v_square);\n    }\n    \n    // Reduce sum across vector\n    sum = svaddv_f32(svptrue_b32(), v_sum);\n    \n    // Process remaining elements\n    for (size_t i = len - (len % svcntw()); i < len; i++) {\n        float val = data[i];\n        if (val >= 0 && val == (int)val && ((int)val % 2) == 1) {\n            sum += val * val;\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nuint64_t double_the_difference_simd(const std::vector<float>& lst) {\n    uint64_t sum = 0;\n    svbool_t pg = svptrue_b32();\n    size_t i = 0;\n\n    for (; i + svcntw() <= lst.size(); i += svcntw()) {\n        svfloat32_t vec = svld1_f32(pg, &lst[i]);\n        svbool_t is_int = svcmpeq_f32(pg, vec, svrintz_f32(pg, vec));\n        svbool_t is_positive = svcmpgt_f32(pg, vec, svdup_f32(0.0f));\n        svbool_t is_odd = svcmpeq_f32(pg, svfmod_f32(pg, vec, svdup_f32(2.0f)), svdup_f32(1.0f));\n        svbool_t mask = svand_b_z(pg, is_int, svand_b_z(pg, is_positive, is_odd));\n        svfloat32_t squared = svmul_f32_z(mask, vec, vec);\n        sum += svaddv_f32(mask, squared);\n    }\n\n    // Handle remaining elements\n    for (; i < lst.size(); ++i) {\n        float val = lst[i];\n        if (val > 0 && val == (int)val && (int)val % 2 == 1) {\n            sum += val * val;\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    svfloat32_t sum_vec = svdup_f32(0.0f);\n    svbool_t pg = svwhilelt_b32(0, lst.size());\n    \n    for (size_t i = 0; i < lst.size(); i += svcntw()) {\n        pg = svwhilelt_b32(i, lst.size());\n        svfloat32_t vec = svld1_f32(pg, &lst[i]);\n        \n        // Check for positive integers\n        svfloat32_t floor_vec = svrintz_f32_x(pg, vec);\n        svbool_t is_int = svcmpeq_f32(pg, vec, floor_vec);\n        svbool_t is_positive = svcmpgt_f32(pg, vec, svdup_f32(0.0f));\n        svbool_t is_odd = svcmpeq_f32(pg, svmod_f32_x(pg, vec, svdup_f32(2.0f)), svdup_f32(1.0f));\n        \n        // Combine conditions\n        svbool_t mask = svand_b_z(pg, svand_b_z(pg, is_int, is_positive), is_odd);\n        \n        // Square valid numbers\n        svfloat32_t squared = svmul_f32_m(mask, vec, vec);\n        \n        // Accumulate sum\n        sum_vec = svadd_f32_m(pg, sum_vec, squared);\n    }\n    \n    // Reduce sum\n    sum = svaddv_f32(svptrue_b32(), sum_vec);\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    svfloat32_t zero = svdup_f32(0.0f);\n    svbool_t pg = svptrue_b32();\n    \n    for (size_t i = 0; i < lst.size(); i += svcntw()) {\n        svbool_t active = svwhilelt_b32(i, lst.size());\n        svfloat32_t vec = svld1_f32(active, &lst[i]);\n        \n        // Check for non-negative numbers\n        svbool_t non_neg_mask = svcmpge(active, vec, zero);\n        \n        // Check for integer values (equal to floor)\n        svfloat32_t floor_vec = svfloor_f32_z(active, vec);\n        svbool_t int_mask = svcmpeq(active, vec, floor_vec);\n        \n        // Check for odd numbers\n        svfloat32_t mod_vec = svfmod_f32_z(active, vec, svdup_f32(2.0f));\n        svbool_t odd_mask = svcmpeq(active, mod_vec, svdup_f32(1.0f));\n        \n        // Combine masks: non-negative, integer, and odd\n        svbool_t final_mask = svand_b_z(active, non_neg_mask, svand_b_z(active, int_mask, odd_mask));\n        \n        // Square the valid numbers\n        svfloat32_t squared = svmul_f32_z(final_mask, vec, vec);\n        \n        // Accumulate sum\n        sum += svaddv_f32(final_mask, squared);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t len = game.size();\n    std::vector<int> result(len);\n    \n    size_t vl = svcntw();\n    svbool_t pg = svptrue_b32();\n    \n    for (size_t i = 0; i < len; i += vl) {\n        svbool_t pm = svwhilelt_b32(i, len);\n        \n        svint32_t game_vec = svld1_s32(pm, &game[i]);\n        svint32_t guess_vec = svld1_s32(pm, &guess[i]);\n        \n        svint32_t diff = svsub_s32_z(pm, game_vec, guess_vec);\n        svint32_t abs_diff = svabs_s32_z(pm, diff);\n        \n        svst1_s32(pm, &result[i], abs_diff);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t len = game.size();\n    std::vector<int> result(len);\n    \n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, len);\n    \n    while (i < len) {\n        // Load vectors\n        svint32_t game_vec = svld1_s32(pg, &game[i]);\n        svint32_t guess_vec = svld1_s32(pg, &guess[i]);\n        \n        // Calculate absolute difference\n        svint32_t diff = svsub_s32_z(pg, game_vec, guess_vec);\n        svint32_t abs_diff = svabs_s32_z(pg, diff);\n        \n        // Store result\n        svst1_s32(pg, &result[i], abs_diff);\n        \n        // Update index and predicate\n        i += svcntw();\n        pg = svwhilelt_b32(i, len);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t len = game.size();\n    std::vector<int> result(len);\n    \n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, len);\n    \n    for (; i < len; ) {\n        svint32_t game_vec = svld1_s32(pg, &game[i]);\n        svint32_t guess_vec = svld1_s32(pg, &guess[i]);\n        \n        svint32_t diff = svsub_s32_z(pg, game_vec, guess_vec);\n        svint32_t abs_diff = svabs_s32_z(pg, diff);\n        \n        svst1_s32(pg, &result[i], abs_diff);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, len);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result(game.size());\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, game.size());\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t game_vec = svld1_s32(pg, &game[i]);\n        svint32_t guess_vec = svld1_s32(pg, &guess[i]);\n        svint32_t diff = svsub_s32_z(pg, game_vec, guess_vec);\n        svint32_t abs_diff = svabs_s32_z(pg, diff);\n        svst1_s32(pg, &result[i], abs_diff);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, game.size());\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "<xaiArtifact artifact_id=\"c2f24788-ef3f-4d9c-ae02-f1c4c9201717\" artifact_version_id=\"92b9502e-6088-409a-8c96-d8b184916d90\" title=\"compare_simd.cpp\" contentType=\"text/x-c++src\">\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t len = game.size();\n    std::vector<int> result(len);\n    \n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, len);\n    \n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t game_vec = svld1(pg, &game[i]);\n        svint32_t guess_vec = svld1(pg, &guess[i]);\n        \n        svint32_t diff = svsub_z(pg, game_vec, guess_vec);\n        svint32_t abs_diff = svabs_z(pg, diff);\n        \n        svst1(pg, &result[i], abs_diff);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, len);\n    }\n    \n    return result;\n}\n</xaiArtifact>"}

{"task_id": "SimdBench_0", "completion": "```c\nvoid conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0", "completion": "```c\nvoid conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0", "completion": "```c\nvoid conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0", "completion": "```c\nvoid conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0", "completion": "```c\nvoid conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_1", "completion": "```c\nvoid load_modify_store(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int element = src[i];\n        int scaled = element * scale;\n        int tmp1 = scaled >> 3;\n        int tmp2 = scaled << 3;\n        int result = (scaled + tmp1 * tmp2) / 7;\n        dst[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_1", "completion": "```c\nvoid load_modify_store(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int element = src[i];\n        int scaled = element * scale;\n        int tmp1 = scaled >> 3;\n        int tmp2 = scaled << 3;\n        int result = (scaled + tmp1 * tmp2) / 7;\n        dst[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_1", "completion": "```c\nvoid load_modify_store(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int element = src[i];\n        int prod = element * scale;\n        int tmp1 = prod >> 3;\n        int tmp2 = prod << 3;\n        int result = (prod + tmp1 * tmp2) / 7;\n        dst[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_1", "completion": "```c\nvoid load_modify_store(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int element = src[i];\n        int scaled = element * scale;\n        int tmp1 = scaled >> 3;\n        int tmp2 = scaled << 3;\n        int result = (scaled + tmp1 * tmp2) / 7;\n        dst[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_1", "completion": "```c\nvoid load_modify_store(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int element = src[i];\n        int scaled = element * scale;\n        int tmp1 = scaled >> 3;\n        int tmp2 = scaled << 3;\n        int result = (scaled + tmp1 * tmp2) / 7;\n        dst[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_2", "completion": "```c\nvoid strided_load_store(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; r++) {\n        dst[r] = src[r * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2", "completion": "```c\nvoid strided_load_store(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; r++) {\n        dst[r] = src[r * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2", "completion": "```c\nvoid strided_load_store(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; r++) {\n        dst[r] = src[r * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2", "completion": "```c\nvoid strided_load_store(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; r++) {\n        dst[r] = src[r * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2", "completion": "```c\nvoid strided_load_store(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; r++) {\n        dst[r] = src[r * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_3", "completion": "```c\nvoid indexed_access(const float *src, const int *indices, float *dst, size_t length) {\n    // Gather operation: copy values from src to dst using indices as read locations\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = src[indices[i]];\n    }\n    \n    // Scatter operation: copy values from src to dst using indices as write locations\n    for (size_t i = 0; i < length; i++) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3", "completion": "```c\nvoid indexed_access(const float *src, const int *indices, float *dst, size_t length) {\n    // Gather operation: copy values from src to dst using indices as read locations\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = src[indices[i]];\n    }\n    \n    // Scatter operation: copy values from src to dst using indices as write locations\n    for (size_t i = 0; i < length; i++) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3", "completion": "```c\nvoid indexed_access(const float *src, const int *indices, float *dst, size_t length) {\n    // Gather operation: copy values from src to dst using indices as read locations\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = src[indices[i]];\n    }\n    \n    // Scatter operation: copy values from src to dst using indices as write locations\n    for (size_t i = 0; i < length; i++) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3", "completion": "```c\nvoid indexed_access(const float *src, const int *indices, float *dst, size_t length) {\n    // Gather operation: copy values from src to dst using indices as read locations\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = src[indices[i]];\n    }\n    \n    // Scatter operation: copy values from src to dst using indices as write locations\n    for (size_t i = 0; i < length; i++) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3", "completion": "```c\nvoid indexed_access(const float *src, const int *indices, float *dst, size_t length) {\n    // Gather operation: copy values from src to dst using indices as read locations\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = src[indices[i]];\n    }\n    \n    // Scatter operation: copy values from src to dst using indices as write locations\n    for (size_t i = 0; i < length; i++) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_4", "completion": "```c\nvoid range_reverse(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start < end) {\n        int16_t temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n```"}
{"task_id": "SimdBench_4", "completion": "```c\nvoid range_reverse(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start < end) {\n        int16_t temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n```"}
{"task_id": "SimdBench_4", "completion": "```c\nvoid range_reverse(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start < end) {\n        int16_t temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n```"}
{"task_id": "SimdBench_4", "completion": "```c\nvoid range_reverse(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start < end) {\n        int16_t temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n```"}
{"task_id": "SimdBench_4", "completion": "```c\nvoid range_reverse(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start < end) {\n        int16_t temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n```"}
{"task_id": "SimdBench_5", "completion": "```c\nvoid extract_tensor_slice(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    size_t start_idx = slice_idx * slice_size;\n    \n    for (size_t i = 0; i < slice_size; i++) {\n        slice[i] = tensor[start_idx + i];\n    }\n}\n```"}
{"task_id": "SimdBench_5", "completion": "```c\nvoid extract_tensor_slice(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    size_t start_idx = slice_idx * slice_size;\n    for (size_t i = 0; i < slice_size; i++) {\n        slice[i] = tensor[start_idx + i];\n    }\n}\n```"}
{"task_id": "SimdBench_5", "completion": "```c\nvoid extract_tensor_slice(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    size_t start_idx = slice_idx * slice_size;\n    for (size_t i = 0; i < slice_size; i++) {\n        slice[i] = tensor[start_idx + i];\n    }\n}\n```"}
{"task_id": "SimdBench_5", "completion": "```c\nvoid extract_tensor_slice(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    size_t start_idx = slice_idx * slice_size;\n    for (size_t i = 0; i < slice_size; i++) {\n        slice[i] = tensor[start_idx + i];\n    }\n}\n```"}
{"task_id": "SimdBench_5", "completion": "```c\nvoid extract_tensor_slice(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    size_t start_idx = slice_idx * slice_size;\n    for (size_t i = 0; i < slice_size; i++) {\n        slice[i] = tensor[start_idx + i];\n    }\n}\n```"}
{"task_id": "SimdBench_6", "completion": "```c\nvoid blocked_matrix_transpose(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    size_t i, j, bi, bj;\n    for (i = 0; i < rows; i += block_size) {\n        for (j = 0; j < cols; j += block_size) {\n            size_t i_end = (i + block_size < rows) ? i + block_size : rows;\n            size_t j_end = (j + block_size < cols) ? j + block_size : cols;\n            for (bi = i; bi < i_end; bi++) {\n                for (bj = j; bj < j_end; bj++) {\n                    dst[bj * rows + bi] = src[bi * cols + bj];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6", "completion": "```c\nvoid blocked_matrix_transpose(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    size_t i, j, bi, bj;\n    size_t row_block, col_block;\n    \n    for (i = 0; i < rows; i += block_size) {\n        for (j = 0; j < cols; j += block_size) {\n            row_block = (i + block_size > rows) ? rows - i : block_size;\n            col_block = (j + block_size > cols) ? cols - j : block_size;\n            \n            for (bi = 0; bi < row_block; bi++) {\n                for (bj = 0; bj < col_block; bj++) {\n                    size_t src_idx = (i + bi) * cols + (j + bj);\n                    size_t dst_idx = (j + bj) * rows + (i + bi);\n                    dst[dst_idx] = src[src_idx];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6", "completion": "```c\nvoid blocked_matrix_transpose(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    size_t i, j, bi, bj;\n    size_t row_block, col_block;\n    \n    for (i = 0; i < rows; i += block_size) {\n        for (j = 0; j < cols; j += block_size) {\n            row_block = (i + block_size > rows) ? rows - i : block_size;\n            col_block = (j + block_size > cols) ? cols - j : block_size;\n            \n            for (bi = 0; bi < row_block; bi++) {\n                for (bj = 0; bj < col_block; bj++) {\n                    size_t src_idx = (i + bi) * cols + (j + bj);\n                    size_t dst_idx = (j + bj) * rows + (i + bi);\n                    dst[dst_idx] = src[src_idx];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6", "completion": "```c\nvoid blocked_matrix_transpose(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    size_t i, j, bi, bj;\n    for (i = 0; i < rows; i += block_size) {\n        for (j = 0; j < cols; j += block_size) {\n            size_t i_end = (i + block_size < rows) ? i + block_size : rows;\n            size_t j_end = (j + block_size < cols) ? j + block_size : cols;\n            for (bi = i; bi < i_end; bi++) {\n                for (bj = j; bj < j_end; bj++) {\n                    dst[bj * rows + bi] = src[bi * cols + bj];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6", "completion": "```c\nvoid blocked_matrix_transpose(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    size_t i, j, bi, bj;\n    size_t row_block, col_block;\n    \n    for (row_block = 0; row_block < rows; row_block += block_size) {\n        for (col_block = 0; col_block < cols; col_block += block_size) {\n            size_t row_end = (row_block + block_size < rows) ? row_block + block_size : rows;\n            size_t col_end = (col_block + block_size < cols) ? col_block + block_size : cols;\n            \n            for (i = row_block; i < row_end; i++) {\n                for (j = col_block; j < col_end; j++) {\n                    dst[j * rows + i] = src[i * cols + j];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_7", "completion": "```c\nfloat diagonal_sum_3d(const float *array, size_t dim) {\n    float sum = 0.0f;\n    for (size_t i = 0; i < dim; i++) {\n        sum += array[i * dim * dim + i * dim + i];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7", "completion": "```c\nfloat diagonal_sum_3d(const float *array, size_t dim) {\n    float sum = 0.0f;\n    for (size_t i = 0; i < dim; i++) {\n        sum += array[i * dim * dim + i * dim + i];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7", "completion": "```c\nfloat diagonal_sum_3d(const float *array, size_t dim) {\n    float sum = 0.0f;\n    for (size_t i = 0; i < dim; i++) {\n        size_t index = i * dim * dim + i * dim + i;\n        sum += array[index];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7", "completion": "```c\nfloat diagonal_sum_3d(const float *array, size_t dim) {\n    float sum = 0.0f;\n    for (size_t i = 0; i < dim; i++) {\n        size_t index = i * dim * dim + i * dim + i;\n        sum += array[index];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7", "completion": "```c\nfloat diagonal_sum_3d(const float *array, size_t dim) {\n    float sum = 0.0f;\n    for (size_t i = 0; i < dim; i++) {\n        size_t index = i * dim * dim + i * dim + i;\n        sum += array[index];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_8", "completion": "```c\nvoid conditional_scale(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t i, j;\n    for (i = 0; i < rows; i++) {\n        for (j = 0; j < cols; j++) {\n            size_t index = i * cols + j;\n            dst[index] = src[index] > threshold ? src[index] * scale : src[index];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8", "completion": "```c\nvoid conditional_scale(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    for (size_t i = 0; i < total_elements; i++) {\n        if (src[i] > threshold) {\n            dst[i] = src[i] * scale;\n        } else {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8", "completion": "```c\nvoid conditional_scale(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    for (size_t i = 0; i < total_elements; i++) {\n        if (src[i] > threshold) {\n            dst[i] = src[i] * scale;\n        } else {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8", "completion": "```c\nvoid conditional_scale(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    for (size_t i = 0; i < total_elements; i++) {\n        if (src[i] > threshold) {\n            dst[i] = src[i] * scale;\n        } else {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8", "completion": "```c\nvoid conditional_scale(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    for (size_t i = 0; i < total_elements; i++) {\n        if (src[i] > threshold) {\n            dst[i] = src[i] * scale;\n        } else {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9", "completion": "```c\nvoid reorder_matrix_rows(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j++) {\n            dst[i * cols + j] = src[indices[i] * cols + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9", "completion": "```c\nvoid reorder_matrix_rows(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t src_row = indices[i];\n        for (size_t j = 0; j < cols; j++) {\n            dst[i * cols + j] = src[src_row * cols + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9", "completion": "```c\nvoid reorder_matrix_rows(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t src_row = indices[i];\n        for (size_t j = 0; j < cols; j++) {\n            dst[i * cols + j] = src[src_row * cols + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9", "completion": "```c\nvoid reorder_matrix_rows(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t src_row = indices[i];\n        for (size_t j = 0; j < cols; j++) {\n            dst[i * cols + j] = src[src_row * cols + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9", "completion": "```c\nvoid reorder_matrix_rows(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t src_row = indices[i];\n        for (size_t j = 0; j < cols; j++) {\n            dst[i * cols + j] = src[src_row * cols + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_10", "completion": "```c\nvoid vector_vector_add(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10", "completion": "```c\nvoid vector_vector_add(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10", "completion": "```c\nvoid vector_vector_add(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = ((src1[i] + src2[i]) + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10", "completion": "```c\nvoid vector_vector_add(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = ((src1[i] + src2[i]) + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10", "completion": "```c\nvoid vector_vector_add(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_11", "completion": "```c\nint vector_even_min(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n    \n    int min = -1;\n    int found = 0;\n    \n    for (size_t i = 0; i < length; i += 2) {\n        if (!found || src[i] < min) {\n            min = src[i];\n            found = 1;\n        }\n    }\n    \n    return found ? min : -1;\n}\n```"}
{"task_id": "SimdBench_11", "completion": "```c\nint vector_even_min(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n    \n    int min = -1;\n    int found = 0;\n    \n    for (size_t i = 0; i < length; i += 2) {\n        if (!found || src[i] < min) {\n            min = src[i];\n            found = 1;\n        }\n    }\n    \n    return found ? min : -1;\n}\n```"}
{"task_id": "SimdBench_11", "completion": "```c\nint vector_even_min(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n    \n    int min = -1;\n    int found = 0;\n    \n    for (size_t i = 0; i < length; i += 2) {\n        if (!found || src[i] < min) {\n            min = src[i];\n            found = 1;\n        }\n    }\n    \n    return found ? min : -1;\n}\n```"}
{"task_id": "SimdBench_11", "completion": "```c\nint vector_even_min(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n    \n    int min = -1;\n    int found = 0;\n    \n    for (size_t i = 0; i < length; i += 2) {\n        if (!found || src[i] < min) {\n            min = src[i];\n            found = 1;\n        }\n    }\n    \n    return found ? min : -1;\n}\n```"}
{"task_id": "SimdBench_11", "completion": "```c\nint vector_even_min(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n    \n    int min = -1;\n    int found = 0;\n    \n    for (size_t i = 0; i < length; i += 2) {\n        if (!found || src[i] < min) {\n            min = src[i];\n            found = 1;\n        }\n    }\n    \n    return found ? min : -1;\n}\n```"}
{"task_id": "SimdBench_12", "completion": "```c\nvoid mixed_right_shift(const int *src, int *dst, uint8_t shift, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int arith_shift = src[i] >> shift;\n        unsigned int logical_shift = (unsigned int)src[i] >> shift;\n        dst[i] = arith_shift + (int)logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12", "completion": "```c\nvoid mixed_right_shift(const int *src, int *dst, uint8_t shift, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int arith_shift = src[i] >> shift;\n        unsigned int logical_shift = (unsigned int)src[i] >> shift;\n        dst[i] = arith_shift + (int)logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12", "completion": "```c\nvoid mixed_right_shift(const int *src, int *dst, uint8_t shift, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int arithmetic_shift = src[i] >> shift;\n        unsigned int logical_shift = (unsigned int)src[i] >> shift;\n        dst[i] = arithmetic_shift + (int)logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12", "completion": "```c\nvoid mixed_right_shift(const int *src, int *dst, uint8_t shift, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int arithmetic_shift = src[i] >> shift;\n        unsigned int logical_shift = (unsigned int)src[i] >> shift;\n        dst[i] = arithmetic_shift + (int)logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12", "completion": "```c\nvoid mixed_right_shift(const int *src, int *dst, uint8_t shift, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int arithmetic_shift = src[i] >> shift;\n        unsigned int logical_shift = (unsigned int)src[i] >> shift;\n        dst[i] = arithmetic_shift + (int)logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_13", "completion": "```c\nint64_t matrix_sum(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < rows * cols; i++) {\n        sum += matrix[i];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13", "completion": "```c\nint64_t matrix_sum(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < rows * cols; i++) {\n        sum += matrix[i];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13", "completion": "```c\nint64_t matrix_sum(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < rows * cols; i++) {\n        sum += matrix[i];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13", "completion": "```c\nint64_t matrix_sum(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < rows * cols; i++) {\n        sum += matrix[i];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13", "completion": "```c\nint64_t matrix_sum(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < rows * cols; i++) {\n        sum += matrix[i];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_14", "completion": "```c\nsize_t argmax(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n    \n    size_t max_index = 0;\n    int8_t max_value = src[0];\n    \n    for (size_t i = 1; i < length; i++) {\n        if (src[i] > max_value) {\n            max_value = src[i];\n            max_index = i;\n        }\n    }\n    \n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14", "completion": "```c\nsize_t argmax(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n    \n    size_t max_index = 0;\n    int8_t max_value = src[0];\n    \n    for (size_t i = 1; i < length; i++) {\n        if (src[i] > max_value) {\n            max_value = src[i];\n            max_index = i;\n        }\n    }\n    \n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14", "completion": "```c\nsize_t argmax(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n    size_t max_idx = 0;\n    int8_t max_val = src[0];\n    for (size_t i = 1; i < length; i++) {\n        if (src[i] > max_val) {\n            max_val = src[i];\n            max_idx = i;\n        }\n    }\n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_14", "completion": "```c\nsize_t argmax(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n    \n    size_t max_index = 0;\n    int8_t max_value = src[0];\n    \n    for (size_t i = 1; i < length; i++) {\n        if (src[i] > max_value) {\n            max_value = src[i];\n            max_index = i;\n        }\n    }\n    \n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14", "completion": "```c\nsize_t argmax(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n    \n    size_t max_index = 0;\n    int8_t max_value = src[0];\n    \n    for (size_t i = 1; i < length; i++) {\n        if (src[i] > max_value) {\n            max_value = src[i];\n            max_index = i;\n        }\n    }\n    \n    return max_index;\n}\n```"}
{"task_id": "SimdBench_15", "completion": "```c\nvoid vector_blend(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (i & mask) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15", "completion": "```c\nvoid vector_blend(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (i & mask) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15", "completion": "```c\nvoid vector_blend(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (i & mask) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15", "completion": "```c\nvoid vector_blend(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (i & mask) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15", "completion": "```c\nvoid vector_blend(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (i & mask) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_16", "completion": "```c\nvoid population_count(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t num = src[i];\n        uint32_t count = 0;\n        while (num) {\n            count += num & 1;\n            num >>= 1;\n        }\n        dst[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_16", "completion": "```c\nvoid population_count(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t num = src[i];\n        uint32_t count = 0;\n        while (num) {\n            count += num & 1;\n            num >>= 1;\n        }\n        dst[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_16", "completion": "```c\nvoid population_count(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t num = src[i];\n        uint32_t count = 0;\n        while (num) {\n            count += num & 1;\n            num >>= 1;\n        }\n        dst[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_16", "completion": "```c\nvoid population_count(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t num = src[i];\n        uint32_t count = 0;\n        while (num) {\n            count += num & 1;\n            num >>= 1;\n        }\n        dst[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_16", "completion": "```c\nvoid population_count(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t num = src[i];\n        uint32_t count = 0;\n        while (num) {\n            count += num & 1;\n            num >>= 1;\n        }\n        dst[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_17", "completion": "```c\nvoid saturating_add(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t sum = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = (sum > UINT16_MAX) ? UINT16_MAX : (uint16_t)sum;\n    }\n}\n```"}
{"task_id": "SimdBench_17", "completion": "```c\nvoid saturating_add(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t sum = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = (sum > UINT16_MAX) ? UINT16_MAX : (uint16_t)sum;\n    }\n}\n```"}
{"task_id": "SimdBench_17", "completion": "```c\nvoid saturating_add(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t sum = (uint32_t)src1[i] + src2[i];\n        dst[i] = (sum > UINT16_MAX) ? UINT16_MAX : (uint16_t)sum;\n    }\n}\n```"}
{"task_id": "SimdBench_17", "completion": "```c\nvoid saturating_add(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t sum = (uint32_t)src1[i] + src2[i];\n        dst[i] = (sum > UINT16_MAX) ? UINT16_MAX : (uint16_t)sum;\n    }\n}\n```"}
{"task_id": "SimdBench_17", "completion": "```c\nvoid saturating_add(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t sum = (uint32_t)src1[i] + src2[i];\n        dst[i] = (sum > UINT16_MAX) ? UINT16_MAX : (uint16_t)sum;\n    }\n}\n```"}
{"task_id": "SimdBench_18", "completion": "```c\nvoid range_matrix_mul(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                double a_val = A[i * n + k];\n                double b_val = B[k * p + j];\n                if (a_val >= -100.0 && a_val <= 100.0 && b_val >= -100.0 && b_val <= 100.0) {\n                    sum += a_val * b_val;\n                }\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18", "completion": "```c\nvoid range_matrix_mul(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                double a_val = A[i * n + k];\n                double b_val = B[k * p + j];\n                if (a_val >= -100.0 && a_val <= 100.0 && b_val >= -100.0 && b_val <= 100.0) {\n                    sum += a_val * b_val;\n                }\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18", "completion": "```c\nvoid range_matrix_mul(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                double a_val = A[i * n + k];\n                double b_val = B[k * p + j];\n                if (a_val >= -100.0 && a_val <= 100.0 && b_val >= -100.0 && b_val <= 100.0) {\n                    sum += a_val * b_val;\n                }\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18", "completion": "```c\nvoid range_matrix_mul(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                double a_val = A[i * n + k];\n                double b_val = B[k * p + j];\n                if (a_val >= -100.0 && a_val <= 100.0 && b_val >= -100.0 && b_val <= 100.0) {\n                    sum += a_val * b_val;\n                }\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18", "completion": "```c\nvoid range_matrix_mul(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                double a_val = A[i * n + k];\n                double b_val = B[k * p + j];\n                if (a_val >= -100.0 && a_val <= 100.0 && b_val >= -100.0 && b_val <= 100.0) {\n                    sum += a_val * b_val;\n                }\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19", "completion": "```c\nvoid tensor_add_3d(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_size; i++) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19", "completion": "```c\nvoid tensor_add_3d(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_size; i++) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19", "completion": "```c\nvoid tensor_add_3d(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_size; i++) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19", "completion": "```c\nvoid tensor_add_3d(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_size; i++) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19", "completion": "```c\nvoid tensor_add_3d(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_size; i++) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_20", "completion": "```c\nvoid vector_add_round_nearest(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20", "completion": "```c\nvoid vector_add_round_nearest(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20", "completion": "```c\nvoid vector_add_round_nearest(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20", "completion": "```c\nvoid vector_add_round_nearest(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20", "completion": "```c\nvoid vector_add_round_nearest(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_21", "completion": "```c\nvoid vector_mul_round_up(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (i % 2 == 0 && fabs(src1[i] - src2[i]) <= 50.0f) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21", "completion": "```c\nvoid vector_mul_round_up(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (i % 2 == 0 && fabs(src1[i] - src2[i]) <= 50.0f) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21", "completion": "```c\nvoid vector_mul_round_up(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (i % 2 == 0 && fabs(src1[i] - src2[i]) <= 50.0f) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21", "completion": "```c\nvoid vector_mul_round_up(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (i % 2 == 0 && fabs(src1[i] - src2[i]) <= 50.0f) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21", "completion": "```c\nvoid vector_mul_round_up(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (i % 2 == 0 && fabs(src1[i] - src2[i]) <= 50.0f) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_22", "completion": "```c\nvoid matrix_scalar_mul(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    for (size_t i = 0; i < total_elements; i++) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22", "completion": "```c\nvoid matrix_scalar_mul(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    for (size_t i = 0; i < total_elements; i++) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22", "completion": "```c\nvoid matrix_scalar_mul(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    for (size_t i = 0; i < total_elements; i++) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22", "completion": "```c\nvoid matrix_scalar_mul(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    for (size_t i = 0; i < total_elements; i++) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22", "completion": "```c\nvoid matrix_scalar_mul(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    for (size_t i = 0; i < total_elements; i++) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_23", "completion": "```c\nvoid matrix_normalize_rows(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float sum_squares = 0.0f;\n        for (size_t j = 0; j < n; j++) {\n            float val = mat[i * n + j];\n            sum_squares += val * val;\n        }\n        float norm = sqrtf(sum_squares);\n        if (norm > 0.0f) {\n            for (size_t j = 0; j < n; j++) {\n                mat[i * n + j] /= norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23", "completion": "```c\nvoid matrix_normalize_rows(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float sum_squares = 0.0f;\n        for (size_t j = 0; j < n; j++) {\n            float val = mat[i * n + j];\n            sum_squares += val * val;\n        }\n        float norm = sqrtf(sum_squares);\n        if (norm > 0.0f) {\n            for (size_t j = 0; j < n; j++) {\n                mat[i * n + j] /= norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23", "completion": "```c\nvoid matrix_normalize_rows(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float sum_squares = 0.0f;\n        for (size_t j = 0; j < n; j++) {\n            float val = mat[i * n + j];\n            sum_squares += val * val;\n        }\n        float norm = sqrtf(sum_squares);\n        if (norm > 0.0f) {\n            for (size_t j = 0; j < n; j++) {\n                mat[i * n + j] /= norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23", "completion": "```c\nvoid matrix_normalize_rows(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float sum_squares = 0.0f;\n        for (size_t j = 0; j < n; j++) {\n            float val = mat[i * n + j];\n            sum_squares += val * val;\n        }\n        float norm = sqrtf(sum_squares);\n        if (norm > 0.0f) {\n            for (size_t j = 0; j < n; j++) {\n                mat[i * n + j] /= norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23", "completion": "```c\nvoid matrix_normalize_rows(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        // Calculate L2 norm for the current row\n        float sum_squares = 0.0f;\n        for (size_t j = 0; j < n; j++) {\n            float val = mat[i * n + j];\n            sum_squares += val * val;\n        }\n        float norm = sqrtf(sum_squares);\n        \n        // Avoid division by zero\n        if (norm > 0.0f) {\n            // Normalize the row by dividing each element by the norm\n            for (size_t j = 0; j < n; j++) {\n                mat[i * n + j] /= norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24", "completion": "```c\nvoid matrix_mul_round_int(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24", "completion": "```c\nvoid matrix_mul_round_int(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24", "completion": "```c\nvoid matrix_mul_round_int(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24", "completion": "```c\nvoid matrix_mul_round_int(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24", "completion": "```c\nvoid matrix_mul_round_int(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25", "completion": "```c\nvoid matrix_transpose_round_quarter(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j++) {\n            float val = src[i * cols + j];\n            float rounded = roundf(val * 4.0f) / 4.0f;\n            dst[j * rows + i] = rounded;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25", "completion": "```c\nvoid matrix_transpose_round_quarter(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j++) {\n            float val = src[i * cols + j];\n            float rounded = roundf(val * 4.0f) / 4.0f;\n            dst[j * rows + i] = rounded;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25", "completion": "```c\nvoid matrix_transpose_round_quarter(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j++) {\n            float value = src[i * cols + j];\n            float rounded = roundf(value * 4.0f) / 4.0f;\n            dst[j * rows + i] = rounded;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25", "completion": "```c\nvoid matrix_transpose_round_quarter(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j++) {\n            float value = src[i * cols + j];\n            float rounded = roundf(value * 4.0f) / 4.0f;\n            dst[j * rows + i] = rounded;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25", "completion": "```c\nvoid matrix_transpose_round_quarter(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j++) {\n            float val = src[i * cols + j];\n            dst[j * rows + i] = roundf(val * 4.0f) / 4.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26", "completion": "```c\nvoid tensor3d_sub_round_zero(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_size; i++) {\n        float diff = tensor1[i] - tensor2[i];\n        dst[i] = (diff >= 0) ? (float)((int)diff) : (float)((int)(diff - 0.999999f));\n    }\n}\n```"}
{"task_id": "SimdBench_26", "completion": "```c\nvoid tensor3d_sub_round_zero(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_size; i++) {\n        float diff = tensor1[i] - tensor2[i];\n        dst[i] = (diff >= 0) ? (float)((int)diff) : (float)((int)diff);\n    }\n}\n```"}
{"task_id": "SimdBench_26", "completion": "```c\nvoid tensor3d_sub_round_zero(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_size; i++) {\n        float result = tensor1[i] - tensor2[i];\n        dst[i] = (result >= 0) ? (float)((int)result) : (float)((int)result);\n    }\n}\n```"}
{"task_id": "SimdBench_26", "completion": "```c\nvoid tensor3d_sub_round_zero(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_size; i++) {\n        float diff = tensor1[i] - tensor2[i];\n        dst[i] = (diff >= 0) ? (float)((int)diff) : (float)((int)diff);\n    }\n}\n```"}
{"task_id": "SimdBench_26", "completion": "```c\nvoid tensor3d_sub_round_zero(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_size; i++) {\n        float diff = tensor1[i] - tensor2[i];\n        dst[i] = (diff >= 0) ? (float)((int)diff) : (float)((int)(diff - 0.999999f));\n    }\n}\n```"}
{"task_id": "SimdBench_27", "completion": "```c\nvoid matrix_hadamard_product(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    for (size_t i = 0; i < total_elements; i++) {\n        dst[i] = mat1[i] * mat2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_27", "completion": "```c\nvoid matrix_hadamard_product(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    for (size_t i = 0; i < total_elements; i++) {\n        dst[i] = mat1[i] * mat2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_27", "completion": "```c\nvoid matrix_hadamard_product(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    for (size_t i = 0; i < total_elements; i++) {\n        dst[i] = mat1[i] * mat2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_27", "completion": "```c\nvoid matrix_hadamard_product(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    for (size_t i = 0; i < total_elements; i++) {\n        dst[i] = mat1[i] * mat2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_27", "completion": "```c\nvoid matrix_hadamard_product(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    for (size_t i = 0; i < total_elements; i++) {\n        dst[i] = mat1[i] * mat2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_28", "completion": "```c\nvoid matrix_vector_mul(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float sum = 0.0f;\n        for (size_t j = 0; j < n; j++) {\n            sum += mat[i * n + j] * vec[j];\n        }\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28", "completion": "```c\nvoid matrix_vector_mul(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float sum = 0.0f;\n        for (size_t j = 0; j < n; j++) {\n            sum += mat[i * n + j] * vec[j];\n        }\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28", "completion": "```c\nvoid matrix_vector_mul(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float sum = 0.0f;\n        for (size_t j = 0; j < n; j++) {\n            sum += mat[i * n + j] * vec[j];\n        }\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28", "completion": "```c\nvoid matrix_vector_mul(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float sum = 0.0f;\n        for (size_t j = 0; j < n; j++) {\n            sum += mat[i * n + j] * vec[j];\n        }\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28", "completion": "```c\nvoid matrix_vector_mul(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float sum = 0.0f;\n        for (size_t j = 0; j < n; j++) {\n            sum += mat[i * n + j] * vec[j];\n        }\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_29", "completion": "```c\ndouble matrix_average(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    size_t total_elements = m * n;\n    \n    for (size_t i = 0; i < total_elements; i++) {\n        sum += mat[i];\n    }\n    \n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29", "completion": "```c\ndouble matrix_average(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    size_t total_elements = m * n;\n    \n    for (size_t i = 0; i < total_elements; i++) {\n        sum += mat[i];\n    }\n    \n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29", "completion": "```c\ndouble matrix_average(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    size_t total_elements = m * n;\n    \n    for (size_t i = 0; i < total_elements; i++) {\n        sum += mat[i];\n    }\n    \n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29", "completion": "```c\ndouble matrix_average(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    size_t total_elements = m * n;\n    \n    for (size_t i = 0; i < total_elements; i++) {\n        sum += mat[i];\n    }\n    \n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29", "completion": "```c\ndouble matrix_average(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    size_t total_elements = m * n;\n    \n    for (size_t i = 0; i < total_elements; i++) {\n        sum += mat[i];\n    }\n    \n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_30", "completion": "```c\nbool matrix_rows_sorted_verify(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        bool ascending = directions[i];\n        for (size_t j = 0; j < cols - 1; j++) {\n            size_t index = i * cols + j;\n            if (ascending) {\n                if (matrix[index] > matrix[index + 1]) {\n                    return false;\n                }\n            } else {\n                if (matrix[index] < matrix[index + 1]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30", "completion": "```c\nbool matrix_rows_sorted_verify(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        bool shouldAscend = directions[i];\n        for (size_t j = 0; j < cols - 1; j++) {\n            size_t index = i * cols + j;\n            if (shouldAscend) {\n                if (matrix[index] > matrix[index + 1]) {\n                    return false;\n                }\n            } else {\n                if (matrix[index] < matrix[index + 1]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30", "completion": "```c\nbool matrix_rows_sorted_verify(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        bool ascending = directions[i];\n        for (size_t j = 0; j < cols - 1; j++) {\n            size_t index = i * cols + j;\n            if (ascending) {\n                if (matrix[index] > matrix[index + 1]) {\n                    return false;\n                }\n            } else {\n                if (matrix[index] < matrix[index + 1]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30", "completion": "```c\nbool matrix_rows_sorted_verify(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        bool shouldAscend = directions[i];\n        for (size_t j = 0; j < cols - 1; j++) {\n            size_t index = i * cols + j;\n            if (shouldAscend) {\n                if (matrix[index] > matrix[index + 1]) {\n                    return false;\n                }\n            } else {\n                if (matrix[index] < matrix[index + 1]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30", "completion": "```c\nbool matrix_rows_sorted_verify(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        bool ascending = directions[i];\n        for (size_t j = 0; j < cols - 1; j++) {\n            size_t index = i * cols + j;\n            if (ascending) {\n                if (matrix[index] > matrix[index + 1]) {\n                    return false;\n                }\n            } else {\n                if (matrix[index] < matrix[index + 1]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_31", "completion": "```c\nvoid nearest_multiple(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int16_t value = src[i];\n        int16_t quotient = value / base;\n        dst[i] = quotient * base;\n    }\n}\n```"}
{"task_id": "SimdBench_31", "completion": "```c\nvoid nearest_multiple(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int16_t value = src[i];\n        int16_t quotient = value / base;\n        dst[i] = quotient * base;\n    }\n}\n```"}
{"task_id": "SimdBench_31", "completion": "```c\nvoid nearest_multiple(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int16_t value = src[i];\n        int16_t quotient = value / base;\n        dst[i] = quotient * base;\n    }\n}\n```"}
{"task_id": "SimdBench_31", "completion": "```c\nvoid nearest_multiple(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int16_t value = src[i];\n        int16_t quotient = value / base;\n        dst[i] = quotient * base;\n    }\n}\n```"}
{"task_id": "SimdBench_31", "completion": "```c\nvoid nearest_multiple(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int16_t value = src[i];\n        int16_t quotient = value / base;\n        dst[i] = quotient * base;\n    }\n}\n```"}
{"task_id": "SimdBench_32", "completion": "```c\nbool matrix_has_row(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        bool row_matches = true;\n        for (size_t j = 0; j < cols; j++) {\n            if (matrix[i * cols + j] != vector[j]) {\n                row_matches = false;\n                break;\n            }\n        }\n        if (row_matches) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32", "completion": "```c\nbool matrix_has_row(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        bool row_matches = true;\n        for (size_t j = 0; j < cols; j++) {\n            if (matrix[i * cols + j] != vector[j]) {\n                row_matches = false;\n                break;\n            }\n        }\n        if (row_matches) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32", "completion": "```c\nbool matrix_has_row(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        bool row_matches = true;\n        for (size_t j = 0; j < cols; j++) {\n            if (matrix[i * cols + j] != vector[j]) {\n                row_matches = false;\n                break;\n            }\n        }\n        if (row_matches) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32", "completion": "```c\nbool matrix_has_row(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        bool row_matches = true;\n        for (size_t j = 0; j < cols; j++) {\n            if (matrix[i * cols + j] != vector[j]) {\n                row_matches = false;\n                break;\n            }\n        }\n        if (row_matches) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32", "completion": "```c\nbool matrix_has_row(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        bool row_matches = true;\n        for (size_t j = 0; j < cols; j++) {\n            if (matrix[i * cols + j] != vector[j]) {\n                row_matches = false;\n                break;\n            }\n        }\n        if (row_matches) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_33", "completion": "```c\nsize_t tensor_4d_equal_count(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n    for (size_t i = 0; i < total_elements; i++) {\n        if (A[i] == B[i]) {\n            equal_count++;\n        }\n    }\n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_33", "completion": "```c\nsize_t tensor_4d_equal_count(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n    for (size_t i = 0; i < total_elements; i++) {\n        if (A[i] == B[i]) {\n            equal_count++;\n        }\n    }\n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_33", "completion": "```c\nsize_t tensor_4d_equal_count(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n    for (size_t i = 0; i < total_elements; i++) {\n        if (A[i] == B[i]) {\n            equal_count++;\n        }\n    }\n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_33", "completion": "```c\nsize_t tensor_4d_equal_count(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n    for (size_t i = 0; i < total_elements; i++) {\n        if (A[i] == B[i]) {\n            equal_count++;\n        }\n    }\n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_33", "completion": "```c\nsize_t tensor_4d_equal_count(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n    for (size_t i = 0; i < total_elements; i++) {\n        if (A[i] == B[i]) {\n            equal_count++;\n        }\n    }\n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_34", "completion": "```c\nvoid axm_abs(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; i++) {\n        int64_t temp = a * x[i];\n        y[i] = (temp < 0) ? -temp : temp;\n    }\n}\n```"}
{"task_id": "SimdBench_34", "completion": "```c\nvoid axm_abs(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; i++) {\n        int64_t temp = a * x[i];\n        y[i] = (temp < 0) ? -temp : temp;\n    }\n}\n```"}
{"task_id": "SimdBench_34", "completion": "```c\nvoid axm_abs(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; i++) {\n        int64_t temp = a * x[i];\n        y[i] = (temp < 0) ? -temp : temp;\n    }\n}\n```"}
{"task_id": "SimdBench_34", "completion": "```c\nvoid axm_abs(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; i++) {\n        int64_t temp = a * x[i];\n        y[i] = (temp < 0) ? -temp : temp;\n    }\n}\n```"}
{"task_id": "SimdBench_34", "completion": "```c\nvoid axm_abs(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; i++) {\n        int64_t temp = a * x[i];\n        y[i] = (temp < 0) ? -temp : temp;\n    }\n}\n```"}
{"task_id": "SimdBench_35", "completion": "```c\nMinMaxPair min_max_pair(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    result.min_num = vec[0];\n    result.max_num = vec[0];\n    \n    for (size_t i = 1; i < length; i++) {\n        if (vec[i] < result.min_num) {\n            result.min_num = vec[i];\n        }\n        if (vec[i] > result.max_num) {\n            result.max_num = vec[i];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35", "completion": "```c\nMinMaxPair min_max_pair(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    result.min_num = vec[0];\n    result.max_num = vec[0];\n    \n    for (size_t i = 1; i < length; i++) {\n        if (vec[i] < result.min_num) {\n            result.min_num = vec[i];\n        }\n        if (vec[i] > result.max_num) {\n            result.max_num = vec[i];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35", "completion": "```c\nMinMaxPair min_max_pair(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    result.min_num = vec[0];\n    result.max_num = vec[0];\n    \n    for (size_t i = 1; i < length; i++) {\n        if (vec[i] < result.min_num) {\n            result.min_num = vec[i];\n        }\n        if (vec[i] > result.max_num) {\n            result.max_num = vec[i];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35", "completion": "```c\nMinMaxPair min_max_pair(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    result.min_num = vec[0];\n    result.max_num = vec[0];\n    \n    for (size_t i = 1; i < length; i++) {\n        if (vec[i] < result.min_num) {\n            result.min_num = vec[i];\n        }\n        if (vec[i] > result.max_num) {\n            result.max_num = vec[i];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35", "completion": "```c\nMinMaxPair min_max_pair(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    result.min_num = vec[0];\n    result.max_num = vec[0];\n    \n    for (size_t i = 1; i < length; i++) {\n        if (vec[i] < result.min_num) {\n            result.min_num = vec[i];\n        }\n        if (vec[i] > result.max_num) {\n            result.max_num = vec[i];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_36", "completion": "```c\nbool matrix_rows_strictly_increasing(const int* matrix, size_t rows, size_t cols) {\n    // Check if matrix is empty\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n    \n    // Iterate through each row\n    for (size_t i = 0; i < rows; i++) {\n        // Check each element in the row with the next element\n        for (size_t j = 0; j < cols - 1; j++) {\n            // Calculate the index in the 1D array representation\n            size_t current_index = i * cols + j;\n            size_t next_index = i * cols + j + 1;\n            \n            // If current element is not less than the next element, row is not strictly increasing\n            if (matrix[current_index] >= matrix[next_index]) {\n                return false;\n            }\n        }\n    }\n    \n    // If all rows are strictly increasing, return true\n    return true;\n}\n```"}
{"task_id": "SimdBench_36", "completion": "```c\nbool matrix_rows_strictly_increasing(const int* matrix, size_t rows, size_t cols) {\n    // Check if matrix is empty\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n    \n    // Iterate through each row\n    for (size_t i = 0; i < rows; i++) {\n        // Check each element in the row with the next element\n        for (size_t j = 0; j < cols - 1; j++) {\n            // Calculate the index in the 1D array representation\n            size_t current_index = i * cols + j;\n            size_t next_index = i * cols + j + 1;\n            \n            // If current element is not less than the next element, row is not strictly increasing\n            if (matrix[current_index] >= matrix[next_index]) {\n                return false;\n            }\n        }\n    }\n    \n    // If all rows are strictly increasing, return true\n    return true;\n}\n```"}
{"task_id": "SimdBench_36", "completion": "```c\nbool matrix_rows_strictly_increasing(const int* matrix, size_t rows, size_t cols) {\n    // Check if matrix is empty\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n    \n    // Iterate through each row\n    for (size_t i = 0; i < rows; i++) {\n        // Check each element in the row with the next element\n        for (size_t j = 0; j < cols - 1; j++) {\n            // Calculate the index in the 1D array representation\n            size_t current_index = i * cols + j;\n            size_t next_index = i * cols + j + 1;\n            \n            // If current element is not less than the next element, row is not strictly increasing\n            if (matrix[current_index] >= matrix[next_index]) {\n                return false;\n            }\n        }\n    }\n    \n    // If all rows are strictly increasing, return true\n    return true;\n}\n```"}
{"task_id": "SimdBench_36", "completion": "```c\nbool matrix_rows_strictly_increasing(const int* matrix, size_t rows, size_t cols) {\n    // Check if matrix is empty\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n    \n    // Iterate through each row\n    for (size_t i = 0; i < rows; i++) {\n        // Check each element in the row with the next element\n        for (size_t j = 0; j < cols - 1; j++) {\n            // Calculate the index in the 1D array representation\n            size_t current_index = i * cols + j;\n            size_t next_index = i * cols + j + 1;\n            \n            // If current element is not less than the next element, row is not strictly increasing\n            if (matrix[current_index] >= matrix[next_index]) {\n                return false;\n            }\n        }\n    }\n    \n    // If all rows are strictly increasing, return true\n    return true;\n}\n```"}
{"task_id": "SimdBench_36", "completion": "```c\nbool matrix_rows_strictly_increasing(const int* matrix, size_t rows, size_t cols) {\n    // Check if matrix is empty\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n    \n    // Iterate through each row\n    for (size_t i = 0; i < rows; i++) {\n        // Check each element in the row with the next element\n        for (size_t j = 0; j < cols - 1; j++) {\n            // Calculate the index in the 1D array representation\n            size_t current_index = i * cols + j;\n            size_t next_index = i * cols + j + 1;\n            \n            // If current element is not less than the next element, row is not strictly increasing\n            if (matrix[current_index] >= matrix[next_index]) {\n                return false;\n            }\n        }\n    }\n    \n    // If all rows are strictly increasing, return true\n    return true;\n}\n```"}
{"task_id": "SimdBench_37", "completion": "```c\nbool matrix_blocks_equal(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    // Check if block_size is valid and matrix can be divided into blocks\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t blocks_row = rows / block_size;\n    size_t blocks_col = cols / block_size;\n\n    // Compare each block with the first block\n    for (size_t br = 0; br < blocks_row; br++) {\n        for (size_t bc = 0; bc < blocks_col; bc++) {\n            // Skip the first block (br=0, bc=0) as it's the reference\n            if (br == 0 && bc == 0) continue;\n\n            // Check each element in the current block against the first block\n            for (size_t i = 0; i < block_size; i++) {\n                for (size_t j = 0; j < block_size; j++) {\n                    size_t curr_row = br * block_size + i;\n                    size_t curr_col = bc * block_size + j;\n                    size_t ref_row = i;\n                    size_t ref_col = j;\n\n                    if (matrix[curr_row * cols + curr_col] != matrix[ref_row * cols + ref_col]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37", "completion": "```c\nbool matrix_blocks_equal(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    // Check if block_size is valid and matrix can be divided into blocks of block_size\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t block_rows = rows / block_size;\n    size_t block_cols = cols / block_size;\n\n    // Compare each block with the first block\n    for (size_t br = 0; br < block_rows; br++) {\n        for (size_t bc = 0; bc < block_cols; bc++) {\n            // Skip the first block as it is the reference\n            if (br == 0 && bc == 0) continue;\n\n            // Check each element in the current block against the first block\n            for (size_t i = 0; i < block_size; i++) {\n                for (size_t j = 0; j < block_size; j++) {\n                    size_t ref_idx = i * cols + j; // Index in first block\n                    size_t curr_idx = (br * block_size + i) * cols + (bc * block_size + j); // Index in current block\n                    if (matrix[ref_idx] != matrix[curr_idx]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37", "completion": "```c\nbool matrix_blocks_equal(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    // Check if block_size is valid and matrix can be divided into blocks of block_size\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t block_rows = rows / block_size;\n    size_t block_cols = cols / block_size;\n\n    // Compare each block with the first block\n    for (size_t br = 0; br < block_rows; br++) {\n        for (size_t bc = 0; bc < block_cols; bc++) {\n            // Skip the first block (br=0, bc=0) as it is the reference\n            if (br == 0 && bc == 0) continue;\n\n            // Check each element in the current block against the first block\n            for (size_t i = 0; i < block_size; i++) {\n                for (size_t j = 0; j < block_size; j++) {\n                    size_t current_row = br * block_size + i;\n                    size_t current_col = bc * block_size + j;\n                    size_t first_row = i;\n                    size_t first_col = j;\n\n                    if (matrix[current_row * cols + current_col] != \n                        matrix[first_row * cols + first_col]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37", "completion": "```c\nbool matrix_blocks_equal(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    // Check if block_size is valid and matrix can be divided into blocks of block_size\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t blocks_per_row = cols / block_size;\n    size_t blocks_per_col = rows / block_size;\n\n    // If there's only one block, it's trivially equal to itself\n    if (blocks_per_row == 1 && blocks_per_col == 1) {\n        return true;\n    }\n\n    // Compare each block with the first block\n    for (size_t block_row = 0; block_row < blocks_per_col; block_row++) {\n        for (size_t block_col = 0; block_col < blocks_per_row; block_col++) {\n            // Skip the first block (0,0) as it's the reference\n            if (block_row == 0 && block_col == 0) {\n                continue;\n            }\n\n            // Check each element in the current block against the first block\n            for (size_t i = 0; i < block_size; i++) {\n                for (size_t j = 0; j < block_size; j++) {\n                    size_t current_row = block_row * block_size + i;\n                    size_t current_col = block_col * block_size + j;\n                    size_t first_block_row = i;\n                    size_t first_block_col = j;\n\n                    if (matrix[current_row * cols + current_col] != \n                        matrix[first_block_row * cols + first_block_col]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37", "completion": "```c\nbool matrix_blocks_equal(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    // Check if block_size is valid and matrix can be divided into blocks of block_size\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t block_rows = rows / block_size;\n    size_t block_cols = cols / block_size;\n\n    // Compare each block with the first block\n    for (size_t br = 0; br < block_rows; br++) {\n        for (size_t bc = 0; bc < block_cols; bc++) {\n            // Skip the first block (br=0, bc=0) as it's the reference\n            if (br == 0 && bc == 0) continue;\n\n            // Check each element in the current block against the first block\n            for (size_t i = 0; i < block_size; i++) {\n                for (size_t j = 0; j < block_size; j++) {\n                    size_t curr_row = br * block_size + i;\n                    size_t curr_col = bc * block_size + j;\n                    size_t ref_row = i;\n                    size_t ref_col = j;\n\n                    if (matrix[curr_row * cols + curr_col] != matrix[ref_row * cols + ref_col]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38", "completion": "```c\nbool vector_block_equal(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == NULL || tolerance < 0 || length == 0 || block_size == 0 || block_size > length) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 1) {\n        return false;\n    }\n\n    for (size_t block = 1; block < num_blocks; ++block) {\n        for (size_t i = 0; i < block_size; ++i) {\n            size_t idx = block * block_size + i;\n            double diff = fabs(vec[i] - vec[idx]);\n            if (diff > tolerance) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_38", "completion": "```c\nbool vector_block_equal(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == NULL || tolerance < 0 || length == 0 || block_size == 0 || block_size > length) {\n        return false;\n    }\n    \n    size_t num_blocks = length / block_size;\n    if (num_blocks < 1) {\n        return false;\n    }\n    \n    for (size_t block = 1; block < num_blocks; ++block) {\n        for (size_t i = 0; i < block_size; ++i) {\n            size_t idx = block * block_size + i;\n            if (fabs(vec[idx] - vec[i]) > tolerance) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_38", "completion": "```c\nbool vector_block_equal(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == NULL || tolerance < 0 || length == 0 || block_size == 0 || block_size > length) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 1) {\n        return false;\n    }\n\n    for (size_t block = 1; block < num_blocks; ++block) {\n        for (size_t i = 0; i < block_size; ++i) {\n            size_t idx = block * block_size + i;\n            double diff = fabs(vec[i] - vec[idx]);\n            if (diff > tolerance) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38", "completion": "```c\nbool vector_block_equal(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == NULL || tolerance < 0 || length == 0 || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 1) {\n        return false;\n    }\n\n    for (size_t block = 1; block < num_blocks; ++block) {\n        for (size_t i = 0; i < block_size; ++i) {\n            size_t idx = block * block_size + i;\n            double diff = fabs(vec[i] - vec[idx]);\n            if (diff > tolerance) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_38", "completion": "```c\nbool vector_block_equal(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == NULL || tolerance < 0 || length == 0 || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 1) {\n        return false;\n    }\n\n    for (size_t block = 1; block < num_blocks; ++block) {\n        for (size_t i = 0; i < block_size; ++i) {\n            size_t idx = block * block_size + i;\n            double diff = fabs(vec[i] - vec[idx]);\n            if (diff > tolerance) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_39", "completion": "```c\nvoid matrix_row_norm_compare(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        double sum_squares = 0.0;\n        for (size_t j = 0; j < cols; j++) {\n            double val = matrix[i * cols + j];\n            sum_squares += val * val;\n        }\n        double norm = sqrt(sum_squares);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39", "completion": "```c\nvoid matrix_row_norm_compare(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        double sum_squares = 0.0;\n        for (size_t j = 0; j < cols; j++) {\n            double val = matrix[i * cols + j];\n            sum_squares += val * val;\n        }\n        double norm = sqrt(sum_squares);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39", "completion": "```c\nvoid matrix_row_norm_compare(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        double sum_squares = 0.0;\n        for (size_t j = 0; j < cols; j++) {\n            double val = matrix[i * cols + j];\n            sum_squares += val * val;\n        }\n        double norm = sqrt(sum_squares);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39", "completion": "```c\nvoid matrix_row_norm_compare(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        double sum_squares = 0.0;\n        for (size_t j = 0; j < cols; j++) {\n            double val = matrix[i * cols + j];\n            sum_squares += val * val;\n        }\n        double norm = sqrt(sum_squares);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39", "completion": "```c\nvoid matrix_row_norm_compare(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        double sum_squares = 0.0;\n        for (size_t j = 0; j < cols; j++) {\n            double val = matrix[i * cols + j];\n            sum_squares += val * val;\n        }\n        double norm = sqrt(sum_squares);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_40", "completion": "```c\nvoid tensor_bitwise_or(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40", "completion": "```c\nvoid tensor_bitwise_or(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40", "completion": "```c\nvoid tensor_bitwise_or(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40", "completion": "```c\nvoid tensor_bitwise_or(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40", "completion": "```c\nvoid tensor_bitwise_or(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_41", "completion": "```c\nint64_t squarediff(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares_A = 0;\n    int64_t sum_squares_B = 0;\n    int64_t sum_products = 0;\n    \n    for (size_t i = 0; i < length; i++) {\n        sum_squares_A += (int64_t)A[i] * A[i];\n        sum_squares_B += (int64_t)B[i] * B[i];\n        sum_products += (int64_t)A[i] * B[i];\n    }\n    \n    return (sum_squares_A + sum_squares_B) - 2 * sum_products;\n}\n```"}
{"task_id": "SimdBench_41", "completion": "```c\nint64_t squarediff(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares_A = 0;\n    int64_t sum_squares_B = 0;\n    int64_t sum_products = 0;\n    \n    for (size_t i = 0; i < length; i++) {\n        sum_squares_A += (int64_t)A[i] * A[i];\n        sum_squares_B += (int64_t)B[i] * B[i];\n        sum_products += (int64_t)A[i] * B[i];\n    }\n    \n    return (sum_squares_A + sum_squares_B) - 2 * sum_products;\n}\n```"}
{"task_id": "SimdBench_41", "completion": "```c\nint64_t squarediff(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares_A = 0;\n    int64_t sum_squares_B = 0;\n    int64_t sum_products = 0;\n    \n    for (size_t i = 0; i < length; i++) {\n        sum_squares_A += (int64_t)A[i] * A[i];\n        sum_squares_B += (int64_t)B[i] * B[i];\n        sum_products += (int64_t)A[i] * B[i];\n    }\n    \n    return (sum_squares_A + sum_squares_B) - 2 * sum_products;\n}\n```"}
{"task_id": "SimdBench_41", "completion": "```c\nint64_t squarediff(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares_A = 0;\n    int64_t sum_squares_B = 0;\n    int64_t sum_products = 0;\n    \n    for (size_t i = 0; i < length; i++) {\n        sum_squares_A += (int64_t)A[i] * A[i];\n        sum_squares_B += (int64_t)B[i] * B[i];\n        sum_products += (int64_t)A[i] * B[i];\n    }\n    \n    return (sum_squares_A + sum_squares_B) - 2 * sum_products;\n}\n```"}
{"task_id": "SimdBench_41", "completion": "```c\nint64_t squarediff(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares_A = 0;\n    int64_t sum_squares_B = 0;\n    int64_t sum_products = 0;\n    \n    for (size_t i = 0; i < length; i++) {\n        sum_squares_A += (int64_t)A[i] * A[i];\n        sum_squares_B += (int64_t)B[i] * B[i];\n        sum_products += (int64_t)A[i] * B[i];\n    }\n    \n    return (sum_squares_A + sum_squares_B) - 2 * sum_products;\n}\n```"}
{"task_id": "SimdBench_42", "completion": "```c\nvoid tensor_bit_clear(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42", "completion": "```c\nvoid tensor_bit_clear(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42", "completion": "```c\nvoid tensor_bit_clear(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42", "completion": "```c\nvoid tensor_bit_clear(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42", "completion": "```c\nvoid tensor_bit_clear(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_43", "completion": "```c\nvoid tensor_three_valued_logic(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43", "completion": "```c\nvoid tensor_three_valued_logic(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43", "completion": "```c\nvoid tensor_three_valued_logic(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43", "completion": "```c\nvoid tensor_three_valued_logic(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43", "completion": "```c\nvoid tensor_three_valued_logic(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44", "completion": "```c\nvoid tensor_bit_op(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    for (size_t i = 0; i < length; i++) {\n        if (i < midpoint) {\n            C[i] = A[i] ^ B[i];\n        } else if (i == midpoint) {\n            C[i] = A[i];\n        } else {\n            C[i] = A[i] & B[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44", "completion": "```c\nvoid tensor_bit_op(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    for (size_t i = 0; i < length; i++) {\n        if (i < midpoint) {\n            C[i] = A[i] ^ B[i];\n        } else if (i == midpoint) {\n            C[i] = A[i];\n        } else {\n            C[i] = A[i] & B[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44", "completion": "```c\nvoid tensor_bit_op(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t mid = length / 2;\n    for (size_t i = 0; i < length; i++) {\n        if (i < mid) {\n            C[i] = A[i] ^ B[i];\n        } else if (i == mid) {\n            C[i] = A[i];\n        } else {\n            C[i] = A[i] & B[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44", "completion": "```c\nvoid tensor_bit_op(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t mid = length / 2;\n    for (size_t i = 0; i < length; i++) {\n        if (i < mid) {\n            C[i] = A[i] ^ B[i];\n        } else if (i == mid) {\n            C[i] = A[i];\n        } else {\n            C[i] = A[i] & B[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44", "completion": "```c\nvoid tensor_bit_op(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    for (size_t i = 0; i < length; i++) {\n        if (i < midpoint) {\n            C[i] = A[i] ^ B[i];\n        } else if (i == midpoint) {\n            C[i] = A[i];\n        } else {\n            C[i] = A[i] & B[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45", "completion": "```c\nvoid tensor_multi_select(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    for (size_t idx = 0; idx < total_size; idx++) {\n        if (cond1[idx] && cond2[idx]) {\n            out[idx] = A[idx];\n        } else if (cond1[idx] && !cond2[idx]) {\n            out[idx] = B[idx];\n        } else if (!cond1[idx] && cond2[idx]) {\n            out[idx] = C[idx];\n        } else {\n            out[idx] = D[idx];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45", "completion": "```c\nvoid tensor_multi_select(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    for (size_t idx = 0; idx < total_size; idx++) {\n        if (cond1[idx] && cond2[idx]) {\n            out[idx] = A[idx];\n        } else if (cond1[idx] && !cond2[idx]) {\n            out[idx] = B[idx];\n        } else if (!cond1[idx] && cond2[idx]) {\n            out[idx] = C[idx];\n        } else {\n            out[idx] = D[idx];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45", "completion": "```c\nvoid tensor_multi_select(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    for (size_t idx = 0; idx < total_size; idx++) {\n        if (cond1[idx] && cond2[idx]) {\n            out[idx] = A[idx];\n        } else if (cond1[idx] && !cond2[idx]) {\n            out[idx] = B[idx];\n        } else if (!cond1[idx] && cond2[idx]) {\n            out[idx] = C[idx];\n        } else {\n            out[idx] = D[idx];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45", "completion": "```c\nvoid tensor_multi_select(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    for (size_t idx = 0; idx < total_size; idx++) {\n        if (cond1[idx] && cond2[idx]) {\n            out[idx] = A[idx];\n        } else if (cond1[idx] && !cond2[idx]) {\n            out[idx] = B[idx];\n        } else if (!cond1[idx] && cond2[idx]) {\n            out[idx] = C[idx];\n        } else {\n            out[idx] = D[idx];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45", "completion": "```c\nvoid tensor_multi_select(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    for (size_t idx = 0; idx < total_size; idx++) {\n        if (cond1[idx] && cond2[idx]) {\n            out[idx] = A[idx];\n        } else if (cond1[idx] && !cond2[idx]) {\n            out[idx] = B[idx];\n        } else if (!cond1[idx] && cond2[idx]) {\n            out[idx] = C[idx];\n        } else {\n            out[idx] = D[idx];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_46", "completion": "```c\nvoid tensor_bit_count(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; i++) {\n        uint32_t value = A[i];\n        uint8_t count = 0;\n        while (value) {\n            count += value & 1;\n            value >>= 1;\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_46", "completion": "```c\nvoid tensor_bit_count(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; i++) {\n        uint32_t value = A[i];\n        uint8_t count = 0;\n        while (value) {\n            count += value & 1;\n            value >>= 1;\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_46", "completion": "```c\nvoid tensor_bit_count(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; i++) {\n        uint32_t value = A[i];\n        uint8_t count = 0;\n        while (value) {\n            count += value & 1;\n            value >>= 1;\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_46", "completion": "```c\nvoid tensor_bit_count(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; i++) {\n        uint32_t value = A[i];\n        uint8_t count = 0;\n        while (value) {\n            count += value & 1;\n            value >>= 1;\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_46", "completion": "```c\nvoid tensor_bit_count(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; i++) {\n        uint32_t value = A[i];\n        uint8_t count = 0;\n        while (value) {\n            count += value & 1;\n            value >>= 1;\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_47", "completion": "```c\nvoid matrix_conditional_abs(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    for (size_t i = 0; i < total_elements; i++) {\n        if (A[i] % 3 == 0) {\n            B[i] = (A[i] < 0) ? -A[i] : A[i];\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47", "completion": "```c\nvoid matrix_conditional_abs(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    for (size_t i = 0; i < total_elements; i++) {\n        if (A[i] % 3 == 0) {\n            B[i] = (A[i] < 0) ? -A[i] : A[i];\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47", "completion": "```c\nvoid matrix_conditional_abs(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    for (size_t i = 0; i < total_elements; i++) {\n        if (A[i] % 3 == 0) {\n            B[i] = (A[i] < 0) ? -A[i] : A[i];\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47", "completion": "```c\nvoid matrix_conditional_abs(const int* A, int* B, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows * cols; i++) {\n        B[i] = (A[i] % 3 == 0) ? abs(A[i]) : A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_47", "completion": "```c\nvoid matrix_conditional_abs(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    for (size_t i = 0; i < total_elements; i++) {\n        if (A[i] % 3 == 0) {\n            B[i] = (A[i] < 0) ? -A[i] : A[i];\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48", "completion": "```c\nvoid matrix_conditional_bit_rotate(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if ((src[i] & 0xF) == 0xF) {\n            dst[i] = (src[i] >> rotate_bits) | (src[i] << (32 - rotate_bits));\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48", "completion": "```c\nvoid matrix_conditional_bit_rotate(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if ((src[i] & 0xF) == 0xF) {\n            dst[i] = (src[i] >> rotate_bits) | (src[i] << (32 - rotate_bits));\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48", "completion": "```c\nvoid matrix_conditional_bit_rotate(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if ((src[i] & 0xF) == 0xF) {\n            dst[i] = (src[i] >> rotate_bits) | (src[i] << (32 - rotate_bits));\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48", "completion": "```c\nvoid matrix_conditional_bit_rotate(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if ((src[i] & 0xF) == 0xF) {\n            dst[i] = (src[i] >> rotate_bits) | (src[i] << (32 - rotate_bits));\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48", "completion": "```c\nvoid matrix_conditional_bit_rotate(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if ((src[i] & 0xF) == 0xF) {\n            dst[i] = (src[i] >> rotate_bits) | (src[i] << (32 - rotate_bits));\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49", "completion": "```c\nvoid tensor_ternary_compare(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float abs_epsilon = epsilon > 0 ? epsilon : -epsilon;\n    for (size_t i = 0; i < length; i++) {\n        float diff = A[i] - B[i];\n        if (diff > abs_epsilon) {\n            out[i] = 1;\n        } else if (diff < -abs_epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49", "completion": "```c\nvoid tensor_ternary_compare(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float abs_epsilon = epsilon >= 0 ? epsilon : -epsilon;\n    for (size_t i = 0; i < length; i++) {\n        float diff = A[i] - B[i];\n        if (diff > abs_epsilon) {\n            out[i] = 1;\n        } else if (diff < -abs_epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49", "completion": "```c\nvoid tensor_ternary_compare(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float abs_epsilon = epsilon > 0 ? epsilon : -epsilon;\n    for (size_t i = 0; i < length; i++) {\n        float diff = A[i] - B[i];\n        if (diff > abs_epsilon) {\n            out[i] = 1;\n        } else if (diff < -abs_epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49", "completion": "```c\nvoid tensor_ternary_compare(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float abs_epsilon = epsilon > 0 ? epsilon : -epsilon;\n    for (size_t i = 0; i < length; i++) {\n        float diff = A[i] - B[i];\n        if (diff > abs_epsilon) {\n            out[i] = 1;\n        } else if (diff < -abs_epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49", "completion": "```c\nvoid tensor_ternary_compare(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float abs_epsilon = epsilon > 0 ? epsilon : -epsilon;\n    for (size_t i = 0; i < length; i++) {\n        float diff = A[i] - B[i];\n        if (diff > abs_epsilon) {\n            out[i] = 1;\n        } else if (diff < -abs_epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50", "completion": "```c\nvoid float_to_int_saturate(const float* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (A[i] < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50", "completion": "```c\nvoid float_to_int_saturate(const float* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (A[i] < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50", "completion": "```c\nvoid float_to_int_saturate(const float* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (A[i] < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50", "completion": "```c\nvoid float_to_int_saturate(const float* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (A[i] < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50", "completion": "```c\nvoid float_to_int_saturate(const float* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (A[i] < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_51", "completion": "```c\nvoid int_to_float_scaled(const int32_t* A, int8_t scale, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51", "completion": "```c\nvoid int_to_float_scaled(const int32_t* A, int8_t scale, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51", "completion": "```c\nvoid int_to_float_scaled(const int32_t* A, int8_t scale, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51", "completion": "```c\nvoid int_to_float_scaled(const int32_t* A, int8_t scale, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51", "completion": "```c\nvoid int_to_float_scaled(const int32_t* A, int8_t scale, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_52", "completion": "```c\nvoid float_div_round(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (B[i] != 0.0f) {\n            float result = A[i] / B[i];\n            if (result > INT32_MAX) {\n                C[i] = INT32_MAX;\n            } else if (result < INT32_MIN) {\n                C[i] = INT32_MIN;\n            } else {\n                C[i] = (int32_t)(result + (result >= 0 ? 0.5f : -0.5f));\n            }\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_52", "completion": "```c\nvoid float_div_round(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        float result = A[i] / B[i];\n        C[i] = (int32_t)(result >= 0 ? result + 0.5f : result - 0.5f);\n    }\n}\n```"}
{"task_id": "SimdBench_52", "completion": "```c\nvoid float_div_round(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        float result = A[i] / B[i];\n        if (result > INT32_MAX) {\n            C[i] = INT32_MAX;\n        } else if (result < INT32_MIN) {\n            C[i] = INT32_MIN;\n        } else {\n            C[i] = (int32_t)(result + (result >= 0 ? 0.5f : -0.5f));\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_52", "completion": "```c\nvoid float_div_round(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (B[i] != 0.0f) {\n            float result = A[i] / B[i];\n            if (result > INT32_MAX) {\n                C[i] = INT32_MAX;\n            } else if (result < INT32_MIN) {\n                C[i] = INT32_MIN;\n            } else {\n                C[i] = (int32_t)(result + (result >= 0 ? 0.5f : -0.5f));\n            }\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_52", "completion": "```c\nvoid float_div_round(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (B[i] != 0.0f) {\n            float result = A[i] / B[i];\n            if (result > INT32_MAX) {\n                C[i] = INT32_MAX;\n            } else if (result < INT32_MIN) {\n                C[i] = INT32_MIN;\n            } else {\n                C[i] = (int32_t)(result + (result >= 0 ? 0.5f : -0.5f));\n            }\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53", "completion": "```c\nvoid double_to_float_saturate(const double* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53", "completion": "```c\nvoid double_to_float_saturate(const double* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53", "completion": "```c\nvoid double_to_float_saturate(const double* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53", "completion": "```c\nvoid double_to_float_saturate(const double* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53", "completion": "```c\nvoid double_to_float_saturate(const double* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_54", "completion": "```c\nvoid int16_to_int32(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54", "completion": "```c\nvoid int16_to_int32(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54", "completion": "```c\nvoid int16_to_int32(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54", "completion": "```c\nvoid int16_to_int32(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54", "completion": "```c\nvoid int16_to_int32(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_55", "completion": "```c\nvoid conditional_normalize(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    for (size_t i = 0; i < size; i++) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            if (val < 0.0f) {\n                val = 0.0f;\n            } else if (val > 1.0f) {\n                val = 1.0f;\n            }\n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55", "completion": "```c\nvoid conditional_normalize(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float range = max_val - min_val;\n    for (size_t i = 0; i < size; i++) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / range;\n            if (val < 0.0f) {\n                val = 0.0f;\n            } else if (val > 1.0f) {\n                val = 1.0f;\n            }\n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55", "completion": "```c\nvoid conditional_normalize(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float range = max_val - min_val;\n    for (size_t i = 0; i < size; i++) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / range;\n            if (val < 0.0f) {\n                val = 0.0f;\n            } else if (val > 1.0f) {\n                val = 1.0f;\n            }\n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55", "completion": "```c\nvoid conditional_normalize(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float range = max_val - min_val;\n    for (size_t i = 0; i < size; i++) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / range;\n            if (val < 0.0f) {\n                val = 0.0f;\n            } else if (val > 1.0f) {\n                val = 1.0f;\n            }\n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55", "completion": "```c\nvoid conditional_normalize(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float range = max_val - min_val;\n    for (size_t i = 0; i < size; i++) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / range;\n            if (val < 0.0f) {\n                val = 0.0f;\n            } else if (val > 1.0f) {\n                val = 1.0f;\n            }\n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_56", "completion": "```c\nvoid int_to_float_sqrt(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        uint32_t high_bits = A[i] >> 16;\n        B[i] = sqrtf((float)high_bits);\n    }\n}\n```"}
{"task_id": "SimdBench_56", "completion": "```c\nvoid int_to_float_sqrt(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        uint32_t high_bits = A[i] >> 16;\n        float temp = (float)high_bits;\n        B[i] = sqrtf(temp);\n    }\n}\n```"}
{"task_id": "SimdBench_56", "completion": "```c\nvoid int_to_float_sqrt(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        uint32_t high_bits = A[i] >> 16;\n        B[i] = sqrtf((float)high_bits);\n    }\n}\n```"}
{"task_id": "SimdBench_56", "completion": "```c\nvoid int_to_float_sqrt(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        uint32_t high_bits = A[i] >> 16;\n        float temp = (float)high_bits;\n        B[i] = sqrtf(temp);\n    }\n}\n```"}
{"task_id": "SimdBench_56", "completion": "```c\nvoid int_to_float_sqrt(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        uint32_t high_bits = A[i] >> 16;\n        B[i] = sqrtf((float)high_bits);\n    }\n}\n```"}
{"task_id": "SimdBench_57", "completion": "```c\nvoid int_bits_to_float(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        union {\n            uint32_t u;\n            float f;\n        } pun;\n        pun.u = A[i];\n        B[i] = pun.f;\n    }\n}\n```"}
{"task_id": "SimdBench_57", "completion": "```c\nvoid int_bits_to_float(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        union {\n            uint32_t u;\n            float f;\n        } pun;\n        pun.u = A[i];\n        B[i] = pun.f;\n    }\n}\n```"}
{"task_id": "SimdBench_57", "completion": "```c\nvoid int_bits_to_float(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        union {\n            uint32_t u;\n            float f;\n        } pun;\n        pun.u = A[i];\n        B[i] = pun.f;\n    }\n}\n```"}
{"task_id": "SimdBench_57", "completion": "```c\nvoid int_bits_to_float(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        union {\n            uint32_t u;\n            float f;\n        } pun;\n        pun.u = A[i];\n        B[i] = pun.f;\n    }\n}\n```"}
{"task_id": "SimdBench_57", "completion": "```c\nvoid int_bits_to_float(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        union {\n            uint32_t u;\n            float f;\n        } pun;\n        pun.u = A[i];\n        B[i] = pun.f;\n    }\n}\n```"}
{"task_id": "SimdBench_58", "completion": "```c\nvoid conditional_diff(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    diff[0] = 0.0f;\n    for (size_t i = 1; i < size; i++) {\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i-1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58", "completion": "```c\nvoid conditional_diff(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    diff[0] = 0.0f;\n    for (size_t i = 1; i < size; i++) {\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i-1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58", "completion": "```c\nvoid conditional_diff(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    diff[0] = 0.0f;\n    for (size_t i = 1; i < size; i++) {\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i-1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58", "completion": "```c\nvoid conditional_diff(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    diff[0] = 0.0f;\n    for (size_t i = 1; i < size; i++) {\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i-1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58", "completion": "```c\nvoid conditional_diff(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    diff[0] = 0.0f;\n    for (size_t i = 1; i < size; i++) {\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i-1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_59", "completion": "```c\nvoid widening_uint(const uint32_t* src, uint64_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = ((uint64_t)0xFFFFFFFF << 32) | src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_59", "completion": "```c\nvoid widening_uint(const uint32_t* src, uint64_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = ((uint64_t)0xFFFFFFFF << 32) | src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_59", "completion": "```c\nvoid widening_uint(const uint32_t* src, uint64_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = ((uint64_t)0xFFFFFFFF << 32) | (uint64_t)src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_59", "completion": "```c\nvoid widening_uint(const uint32_t* src, uint64_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = ((uint64_t)0xFFFFFFFF << 32) | src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_59", "completion": "```c\nvoid widening_uint(const uint32_t* src, uint64_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = ((uint64_t)0xFFFFFFFF << 32) | src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_60", "completion": "```c\ndouble indexed_sum(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    for (size_t i = 0; i < length; i++) {\n        if (index[i] >= 0 && index[i] < length) {\n            sum += vec[index[i]];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60", "completion": "```c\ndouble indexed_sum(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    for (size_t i = 0; i < length; i++) {\n        if (index[i] >= 0 && index[i] < length) {\n            sum += vec[index[i]];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60", "completion": "```c\ndouble indexed_sum(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    for (size_t i = 0; i < length; i++) {\n        if (index[i] >= 0 && index[i] < length) {\n            sum += vec[index[i]];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60", "completion": "```c\ndouble indexed_sum(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    for (size_t i = 0; i < length; i++) {\n        if (index[i] >= 0 && index[i] < length) {\n            sum += vec[index[i]];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60", "completion": "```c\ndouble indexed_sum(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    for (size_t i = 0; i < length; i++) {\n        if (index[i] >= 0 && index[i] < length) {\n            sum += vec[index[i]];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_61", "completion": "```c\nvoid simple_conv2d(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    \n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            double sum = 0.0;\n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj++) {\n                    size_t input_idx = (i + ki) * input_size + (j + kj);\n                    size_t kernel_idx = ki * kernel_size + kj;\n                    sum += input[input_idx] * kernel[kernel_idx];\n                }\n            }\n            // Apply ReLU activation: max(0, sum)\n            output[i * output_size + j] = (sum > 0.0) ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61", "completion": "```c\nvoid simple_conv2d(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    \n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            double sum = 0.0;\n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj++) {\n                    size_t input_idx = (i + ki) * input_size + (j + kj);\n                    size_t kernel_idx = ki * kernel_size + kj;\n                    sum += input[input_idx] * kernel[kernel_idx];\n                }\n            }\n            // Apply ReLU activation: max(0, sum)\n            size_t output_idx = i * output_size + j;\n            output[output_idx] = (sum > 0.0) ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61", "completion": "```c\nvoid simple_conv2d(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    \n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            double sum = 0.0;\n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj++) {\n                    size_t input_idx = (i + ki) * input_size + (j + kj);\n                    size_t kernel_idx = ki * kernel_size + kj;\n                    sum += input[input_idx] * kernel[kernel_idx];\n                }\n            }\n            // Apply ReLU activation: max(0, sum)\n            size_t output_idx = i * output_size + j;\n            output[output_idx] = (sum > 0.0) ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61", "completion": "```c\nvoid simple_conv2d(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    \n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            double sum = 0.0;\n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj++) {\n                    size_t input_idx = (i + ki) * input_size + (j + kj);\n                    size_t kernel_idx = ki * kernel_size + kj;\n                    sum += input[input_idx] * kernel[kernel_idx];\n                }\n            }\n            // Apply ReLU activation: max(0, sum)\n            output[i * output_size + j] = (sum > 0.0) ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61", "completion": "```c\nvoid simple_conv2d(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    \n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            double sum = 0.0;\n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj++) {\n                    size_t input_idx = (i + ki) * input_size + (j + kj);\n                    size_t kernel_idx = ki * kernel_size + kj;\n                    sum += input[input_idx] * kernel[kernel_idx];\n                }\n            }\n            // Apply ReLU activation: max(0, sum)\n            output[i * output_size + j] = (sum > 0.0) ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_62", "completion": "```cpp\nbool has_close_elements(const std::vector<double>& numbers, double threshold) {\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            if (std::abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62", "completion": "```cpp\nbool has_close_elements(const std::vector<double>& numbers, double threshold) {\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            if (std::abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62", "completion": "```cpp\nbool has_close_elements(const std::vector<double>& numbers, double threshold) {\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            if (std::abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62", "completion": "```cpp\nbool has_close_elements(const std::vector<double>& numbers, double threshold) {\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            if (std::abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62", "completion": "```cpp\nbool has_close_elements(const std::vector<double>& numbers, double threshold) {\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            if (std::abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63", "completion": "```cpp\nbool below_zero(std::vector<int> operations) {\n    int balance = 0;\n    for (int op : operations) {\n        balance += op;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63", "completion": "```cpp\nbool below_zero(std::vector<int> operations) {\n    int balance = 0;\n    for (int op : operations) {\n        balance += op;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63", "completion": "```cpp\nbool below_zero(std::vector<int> operations) {\n    int balance = 0;\n    for (int op : operations) {\n        balance += op;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63", "completion": "```cpp\nbool below_zero(std::vector<int> operations) {\n    int balance = 0;\n    for (int op : operations) {\n        balance += op;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63", "completion": "```cpp\nbool below_zero(std::vector<int> operations) {\n    int balance = 0;\n    for (int op : operations) {\n        balance += op;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_64", "completion": "```cpp\ndouble mean_absolute_deviation(std::vector<double> numbers) {\n    if (numbers.empty()) return 0.0;\n    \n    double sum = 0.0;\n    for (double num : numbers) {\n        sum += num;\n    }\n    double mean = sum / numbers.size();\n    \n    double mad_sum = 0.0;\n    for (double num : numbers) {\n        mad_sum += std::abs(num - mean);\n    }\n    \n    return mad_sum / numbers.size();\n}\n```"}
{"task_id": "SimdBench_64", "completion": "```cpp\ndouble mean_absolute_deviation(std::vector<double> numbers) {\n    if (numbers.empty()) return 0.0;\n    \n    double sum = 0.0;\n    for (double num : numbers) {\n        sum += num;\n    }\n    double mean = sum / numbers.size();\n    \n    double mad_sum = 0.0;\n    for (double num : numbers) {\n        mad_sum += std::abs(num - mean);\n    }\n    return mad_sum / numbers.size();\n}\n```"}
{"task_id": "SimdBench_64", "completion": "```cpp\ndouble mean_absolute_deviation(std::vector<double> numbers) {\n    if (numbers.empty()) return 0.0;\n    \n    double sum = 0.0;\n    for (double num : numbers) {\n        sum += num;\n    }\n    double mean = sum / numbers.size();\n    \n    double mad_sum = 0.0;\n    for (double num : numbers) {\n        mad_sum += std::abs(num - mean);\n    }\n    return mad_sum / numbers.size();\n}\n```"}
{"task_id": "SimdBench_64", "completion": "```cpp\ndouble mean_absolute_deviation(std::vector<double> numbers) {\n    if (numbers.empty()) return 0.0;\n    \n    double sum = 0.0;\n    for (double num : numbers) {\n        sum += num;\n    }\n    double mean = sum / numbers.size();\n    \n    double mad_sum = 0.0;\n    for (double num : numbers) {\n        mad_sum += std::abs(num - mean);\n    }\n    \n    return mad_sum / numbers.size();\n}\n```"}
{"task_id": "SimdBench_64", "completion": "```cpp\ndouble mean_absolute_deviation(std::vector<double> numbers) {\n    if (numbers.empty()) return 0.0;\n    \n    double sum = 0.0;\n    for (double num : numbers) {\n        sum += num;\n    }\n    double mean = sum / numbers.size();\n    \n    double mad_sum = 0.0;\n    for (double num : numbers) {\n        mad_sum += std::abs(num - mean);\n    }\n    return mad_sum / numbers.size();\n}\n```"}
{"task_id": "SimdBench_65", "completion": "```cpp\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter) {\n    if (numbers.size() <= 1) {\n        return numbers;\n    }\n    std::vector<int> result;\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        result.push_back(numbers[i]);\n        result.push_back(delimeter);\n    }\n    result.push_back(numbers.back());\n    return result;\n}\n```"}
{"task_id": "SimdBench_65", "completion": "```cpp\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter) {\n    if (numbers.size() <= 1) {\n        return numbers;\n    }\n    std::vector<int> result;\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        result.push_back(numbers[i]);\n        result.push_back(delimeter);\n    }\n    result.push_back(numbers.back());\n    return result;\n}\n```"}
{"task_id": "SimdBench_65", "completion": "```cpp\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter) {\n    if (numbers.size() <= 1) {\n        return numbers;\n    }\n    std::vector<int> result;\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        result.push_back(numbers[i]);\n        result.push_back(delimeter);\n    }\n    result.push_back(numbers.back());\n    return result;\n}\n```"}
{"task_id": "SimdBench_65", "completion": "```cpp\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter) {\n    if (numbers.size() <= 1) {\n        return numbers;\n    }\n    std::vector<int> result;\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        result.push_back(numbers[i]);\n        result.push_back(delimeter);\n    }\n    result.push_back(numbers.back());\n    return result;\n}\n```"}
{"task_id": "SimdBench_65", "completion": "```cpp\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter) {\n    if (numbers.size() <= 1) {\n        return numbers;\n    }\n    std::vector<int> result;\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        result.push_back(numbers[i]);\n        result.push_back(delimeter);\n    }\n    result.push_back(numbers.back());\n    return result;\n}\n```"}
{"task_id": "SimdBench_66", "completion": "```cpp\nstd::vector<int64_t> sum_product(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    for (auto num : numbers) {\n        sum += num;\n        product *= num;\n    }\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66", "completion": "```cpp\nstd::vector<int64_t> sum_product(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    for (auto num : numbers) {\n        sum += num;\n        product *= num;\n    }\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66", "completion": "```cpp\nstd::vector<int64_t> sum_product(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    for (auto num : numbers) {\n        sum += num;\n        product *= num;\n    }\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66", "completion": "```cpp\nstd::vector<int64_t> sum_product(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    for (auto num : numbers) {\n        sum += num;\n        product *= num;\n    }\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66", "completion": "```cpp\nstd::vector<int64_t> sum_product(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    for (auto num : numbers) {\n        sum += num;\n        product *= num;\n    }\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_67", "completion": "```cpp\nstd::vector<int> rolling_max(std::vector<int> numbers) {\n    std::vector<int> result;\n    if (numbers.empty()) return result;\n    \n    int current_max = numbers[0];\n    result.push_back(current_max);\n    \n    for (size_t i = 1; i < numbers.size(); ++i) {\n        if (numbers[i] > current_max) {\n            current_max = numbers[i];\n        }\n        result.push_back(current_max);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_67", "completion": "```cpp\nstd::vector<int> rolling_max(std::vector<int> numbers) {\n    std::vector<int> result;\n    if (numbers.empty()) return result;\n    \n    int current_max = numbers[0];\n    result.push_back(current_max);\n    \n    for (size_t i = 1; i < numbers.size(); ++i) {\n        current_max = std::max(current_max, numbers[i]);\n        result.push_back(current_max);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_67", "completion": "```cpp\nstd::vector<int> rolling_max(std::vector<int> numbers) {\n    std::vector<int> result;\n    if (numbers.empty()) return result;\n    \n    int current_max = numbers[0];\n    result.push_back(current_max);\n    \n    for (size_t i = 1; i < numbers.size(); ++i) {\n        if (numbers[i] > current_max) {\n            current_max = numbers[i];\n        }\n        result.push_back(current_max);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_67", "completion": "```cpp\nstd::vector<int> rolling_max(std::vector<int> numbers) {\n    std::vector<int> result;\n    if (numbers.empty()) return result;\n    \n    int current_max = numbers[0];\n    result.push_back(current_max);\n    \n    for (size_t i = 1; i < numbers.size(); ++i) {\n        if (numbers[i] > current_max) {\n            current_max = numbers[i];\n        }\n        result.push_back(current_max);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_67", "completion": "```cpp\nstd::vector<int> rolling_max(std::vector<int> numbers) {\n    std::vector<int> result;\n    if (numbers.empty()) return result;\n    \n    int current_max = numbers[0];\n    result.push_back(current_max);\n    \n    for (size_t i = 1; i < numbers.size(); ++i) {\n        if (numbers[i] > current_max) {\n            current_max = numbers[i];\n        }\n        result.push_back(current_max);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_68", "completion": "```cpp\nstd::string string_xor(std::string a, std::string b) {\n    std::string result = \"\";\n    for(size_t i = 0; i < a.length(); i++) {\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_68", "completion": "```cpp\nstd::string string_xor(std::string a, std::string b) {\n    std::string result = \"\";\n    for(size_t i = 0; i < a.length(); i++) {\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_68", "completion": "```cpp\nstd::string string_xor(std::string a, std::string b) {\n    std::string result = \"\";\n    for(size_t i = 0; i < a.length(); i++) {\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_68", "completion": "```cpp\nstd::string string_xor(std::string a, std::string b) {\n    std::string result = \"\";\n    for(size_t i = 0; i < a.length(); i++) {\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_68", "completion": "```cpp\nstd::string string_xor(std::string a, std::string b) {\n    std::string result = \"\";\n    for(size_t i = 0; i < a.length(); i++) {\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_69", "completion": "```cpp\nstd::string longest(const std::vector<std::string>& strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n    std::string longestStr = strings[0];\n    for (const auto& str : strings) {\n        if (str.length() > longestStr.length()) {\n            longestStr = str;\n        }\n    }\n    return longestStr;\n}\n```"}
{"task_id": "SimdBench_69", "completion": "```cpp\nstd::string longest(const std::vector<std::string>& strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n    std::string longestStr = strings[0];\n    for (const auto& str : strings) {\n        if (str.length() > longestStr.length()) {\n            longestStr = str;\n        }\n    }\n    return longestStr;\n}\n```"}
{"task_id": "SimdBench_69", "completion": "```cpp\nstd::string longest(const std::vector<std::string> & strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n    std::string longestStr = strings[0];\n    for (const auto& str : strings) {\n        if (str.length() > longestStr.length()) {\n            longestStr = str;\n        }\n    }\n    return longestStr;\n}\n```"}
{"task_id": "SimdBench_69", "completion": "```cpp\nstd::string longest(const std::vector<std::string>& strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n    std::string longestStr = strings[0];\n    for (const auto& str : strings) {\n        if (str.length() > longestStr.length()) {\n            longestStr = str;\n        }\n    }\n    return longestStr;\n}\n```"}
{"task_id": "SimdBench_69", "completion": "```cpp\nstd::string longest(const std::vector<std::string>& strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n    std::string longestStr = strings[0];\n    for (const auto& str : strings) {\n        if (str.length() > longestStr.length()) {\n            longestStr = str;\n        }\n    }\n    return longestStr;\n}\n```"}
{"task_id": "SimdBench_70", "completion": "```c\nuint64_t greatest_common_divisor(uint64_t a, uint64_t b) {\n    while (b != 0) {\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_70", "completion": "```c\nuint64_t greatest_common_divisor(uint64_t a, uint64_t b) {\n    while (b != 0) {\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_70", "completion": "```c\nuint64_t greatest_common_divisor(uint64_t a, uint64_t b) {\n    while (b != 0) {\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_70", "completion": "```c\nuint64_t greatest_common_divisor(uint64_t a, uint64_t b) {\n    while (b != 0) {\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_70", "completion": "```c\nuint64_t greatest_common_divisor(uint64_t a, uint64_t b) {\n    while (b != 0) {\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_71", "completion": "```cpp\nstd::vector<float> find_closest_elements(std::vector<float> numbers) {\n    float min_diff = std::numeric_limits<float>::max();\n    float first = numbers[0];\n    float second = numbers[1];\n    \n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                first = std::min(numbers[i], numbers[j]);\n                second = std::max(numbers[i], numbers[j]);\n            }\n        }\n    }\n    \n    return {first, second};\n}\n```"}
{"task_id": "SimdBench_71", "completion": "```cpp\nstd::vector<float> find_closest_elements(std::vector<float> numbers) {\n    float min_diff = std::numeric_limits<float>::max();\n    float first = numbers[0];\n    float second = numbers[1];\n    \n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                first = std::min(numbers[i], numbers[j]);\n                second = std::max(numbers[i], numbers[j]);\n            }\n        }\n    }\n    \n    return {first, second};\n}\n```"}
{"task_id": "SimdBench_71", "completion": "```cpp\nstd::vector<float> find_closest_elements(std::vector<float> numbers) {\n    float min_diff = std::numeric_limits<float>::max();\n    float first = numbers[0];\n    float second = numbers[1];\n    \n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                first = std::min(numbers[i], numbers[j]);\n                second = std::max(numbers[i], numbers[j]);\n            }\n        }\n    }\n    \n    return {first, second};\n}\n```"}
{"task_id": "SimdBench_71", "completion": "```cpp\nstd::vector<float> find_closest_elements(std::vector<float> numbers) {\n    float min_diff = std::numeric_limits<float>::max();\n    float first = numbers[0];\n    float second = numbers[1];\n    \n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                first = std::min(numbers[i], numbers[j]);\n                second = std::max(numbers[i], numbers[j]);\n            }\n        }\n    }\n    \n    return {first, second};\n}\n```"}
{"task_id": "SimdBench_71", "completion": "```cpp\nstd::vector<float> find_closest_elements(std::vector<float> numbers) {\n    float min_diff = std::numeric_limits<float>::max();\n    float first = numbers[0];\n    float second = numbers[1];\n    \n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                first = std::min(numbers[i], numbers[j]);\n                second = std::max(numbers[i], numbers[j]);\n            }\n        }\n    }\n    \n    return {first, second};\n}\n```"}
{"task_id": "SimdBench_72", "completion": "```cpp\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    if (numbers.size() < 2) {\n        return numbers;\n    }\n    \n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    \n    if (min_val == max_val) {\n        return std::vector<float>(numbers.size(), 0.0f);\n    }\n    \n    float range = max_val - min_val;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        numbers[i] = (numbers[i] - min_val) / range;\n    }\n    \n    return numbers;\n}\n```"}
{"task_id": "SimdBench_72", "completion": "```cpp\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    if (numbers.size() < 2) {\n        return numbers;\n    }\n    \n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    \n    if (min_val == max_val) {\n        return std::vector<float>(numbers.size(), 0.0f);\n    }\n    \n    float range = max_val - min_val;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        numbers[i] = (numbers[i] - min_val) / range;\n    }\n    \n    return numbers;\n}\n```"}
{"task_id": "SimdBench_72", "completion": "```cpp\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    if (numbers.size() < 2) {\n        return numbers;\n    }\n    \n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    \n    if (min_val == max_val) {\n        return std::vector<float>(numbers.size(), 0.0f);\n    }\n    \n    float range = max_val - min_val;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        numbers[i] = (numbers[i] - min_val) / range;\n    }\n    \n    return numbers;\n}\n```"}
{"task_id": "SimdBench_72", "completion": "```cpp\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    if (numbers.size() < 2) {\n        return numbers;\n    }\n    \n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    \n    if (min_val == max_val) {\n        return std::vector<float>(numbers.size(), 0.0f);\n    }\n    \n    float range = max_val - min_val;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        numbers[i] = (numbers[i] - min_val) / range;\n    }\n    \n    return numbers;\n}\n```"}
{"task_id": "SimdBench_72", "completion": "```cpp\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    if (numbers.size() < 2) {\n        return numbers;\n    }\n    \n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    \n    if (min_val == max_val) {\n        return std::vector<float>(numbers.size(), 0.0f);\n    }\n    \n    float range = max_val - min_val;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        numbers[i] = (numbers[i] - min_val) / range;\n    }\n    \n    return numbers;\n}\n```"}
{"task_id": "SimdBench_73", "completion": "```c\nuint64_t largest_divisor(uint64_t n) {\n    for (uint64_t i = n / 2; i >= 1; i--) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return 1;\n}\n```"}
{"task_id": "SimdBench_73", "completion": "```c\nuint64_t largest_divisor(uint64_t n) {\n    for (uint64_t i = n / 2; i >= 1; i--) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return 1;\n}\n```"}
{"task_id": "SimdBench_73", "completion": "```c\nuint64_t largest_divisor(uint64_t n) {\n    for (uint64_t i = n / 2; i >= 1; i--) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return 1;\n}\n```"}
{"task_id": "SimdBench_73", "completion": "```c\nuint64_t largest_divisor(uint64_t n) {\n    for (uint64_t i = n / 2; i > 0; i--) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return 1;\n}\n```"}
{"task_id": "SimdBench_73", "completion": "```c\nuint64_t largest_divisor(uint64_t n) {\n    for (uint64_t i = n / 2; i > 0; i--) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return 1;\n}\n```"}
{"task_id": "SimdBench_74", "completion": "```cpp\nstd::vector<int> factorize(int n) {\n    std::vector<int> factors;\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n = n / 2;\n    }\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n = n / i;\n        }\n    }\n    if (n > 2) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74", "completion": "```cpp\nstd::vector<int> factorize(int n) {\n    std::vector<int> factors;\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n = n / 2;\n    }\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n = n / i;\n        }\n    }\n    if (n > 2) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74", "completion": "```cpp\nstd::vector<int> factorize(int n) {\n    std::vector<int> factors;\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n = n / 2;\n    }\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n = n / i;\n        }\n    }\n    if (n > 2) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74", "completion": "```cpp\nstd::vector<int> factorize(int n) {\n    std::vector<int> factors;\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n = n / 2;\n    }\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n = n / i;\n        }\n    }\n    if (n > 2) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74", "completion": "```cpp\nstd::vector<int> factorize(int n) {\n    std::vector<int> factors;\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n = n / 2;\n    }\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n = n / i;\n        }\n    }\n    if (n > 2) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n```"}
{"task_id": "SimdBench_75", "completion": "```cpp\nstd::vector<float> get_positive(const std::vector<float>& l) {\n    std::vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75", "completion": "```cpp\nstd::vector<float> get_positive(const std::vector<float>& l) {\n    std::vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75", "completion": "```cpp\nstd::vector<float> get_positive(const std::vector<float>& l) {\n    std::vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75", "completion": "```cpp\nstd::vector<float> get_positive(const std::vector<float>& l) {\n    std::vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75", "completion": "```cpp\nstd::vector<float> get_positive(const std::vector<float>& l) {\n    std::vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_76", "completion": "```cpp\nbool is_prime(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    \n    for (int64_t i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76", "completion": "```cpp\nbool is_prime(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    \n    for (int64_t i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76", "completion": "```cpp\nbool is_prime(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    \n    for (int64_t i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76", "completion": "```cpp\nbool is_prime(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    \n    for (int64_t i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76", "completion": "```cpp\nbool is_prime(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    \n    for (int64_t i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_77", "completion": "```cpp\nstd::string solve(const std::string & s) {\n    std::string result = s;\n    bool hasLetter = false;\n    \n    for (char c : s) {\n        if (isalpha(c)) {\n            hasLetter = true;\n            break;\n        }\n    }\n    \n    if (!hasLetter) {\n        std::reverse(result.begin(), result.end());\n    } else {\n        for (char &c : result) {\n            if (isalpha(c)) {\n                c = isupper(c) ? tolower(c) : toupper(c);\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_77", "completion": "```cpp\nstd::string solve(const std::string & s) {\n    std::string result = s;\n    bool hasLetter = false;\n    \n    for (char c : s) {\n        if (isalpha(c)) {\n            hasLetter = true;\n            break;\n        }\n    }\n    \n    if (!hasLetter) {\n        std::reverse(result.begin(), result.end());\n    } else {\n        for (char &c : result) {\n            if (isalpha(c)) {\n                c = isupper(c) ? tolower(c) : toupper(c);\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_77", "completion": "```cpp\nstd::string solve(const std::string & s) {\n    std::string result = s;\n    bool hasLetter = false;\n    \n    for (char c : s) {\n        if (isalpha(c)) {\n            hasLetter = true;\n            break;\n        }\n    }\n    \n    if (!hasLetter) {\n        std::reverse(result.begin(), result.end());\n    } else {\n        for (char &c : result) {\n            if (isalpha(c)) {\n                c = isupper(c) ? tolower(c) : toupper(c);\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_77", "completion": "```cpp\nstd::string solve(const std::string & s) {\n    std::string result = s;\n    bool hasLetter = false;\n    \n    for (char c : s) {\n        if (isalpha(c)) {\n            hasLetter = true;\n            break;\n        }\n    }\n    \n    if (!hasLetter) {\n        std::reverse(result.begin(), result.end());\n    } else {\n        for (char &c : result) {\n            if (isalpha(c)) {\n                c = isupper(c) ? tolower(c) : toupper(c);\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_77", "completion": "```cpp\nstd::string solve(const std::string & s) {\n    std::string result = s;\n    bool hasLetter = false;\n    \n    for (char c : s) {\n        if (isalpha(c)) {\n            hasLetter = true;\n            break;\n        }\n    }\n    \n    if (!hasLetter) {\n        std::reverse(result.begin(), result.end());\n    } else {\n        for (char &c : result) {\n            if (isalpha(c)) {\n                c = isupper(c) ? tolower(c) : toupper(c);\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_78", "completion": "```cpp\nstd::vector<int> sort_third(std::vector<int> l) {\n    std::vector<int> third_vals;\n    for (size_t i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            third_vals.push_back(l[i]);\n        }\n    }\n    std::sort(third_vals.begin(), third_vals.end());\n    std::vector<int> result = l;\n    size_t third_idx = 0;\n    for (size_t i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            result[i] = third_vals[third_idx];\n            third_idx++;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_78", "completion": "```cpp\nstd::vector<int> sort_third(std::vector<int> l) {\n    std::vector<int> thirds;\n    for (size_t i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            thirds.push_back(l[i]);\n        }\n    }\n    std::sort(thirds.begin(), thirds.end());\n    size_t third_index = 0;\n    for (size_t i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            l[i] = thirds[third_index];\n            third_index++;\n        }\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_78", "completion": "```cpp\nstd::vector<int> sort_third(std::vector<int> l) {\n    std::vector<int> third;\n    for (size_t i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            third.push_back(l[i]);\n        }\n    }\n    std::sort(third.begin(), third.end());\n    std::vector<int> result = l;\n    size_t third_index = 0;\n    for (size_t i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            result[i] = third[third_index];\n            third_index++;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_78", "completion": "```cpp\nstd::vector<int> sort_third(std::vector<int> l) {\n    std::vector<int> third_indices;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            third_indices.push_back(l[i]);\n        }\n    }\n    std::sort(third_indices.begin(), third_indices.end());\n    size_t third_idx = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            l[i] = third_indices[third_idx];\n            ++third_idx;\n        }\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_78", "completion": "```cpp\nstd::vector<int> sort_third(std::vector<int> l) {\n    std::vector<int> third_indices;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            third_indices.push_back(l[i]);\n        }\n    }\n    std::sort(third_indices.begin(), third_indices.end());\n    size_t third_idx = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            l[i] = third_indices[third_idx];\n            ++third_idx;\n        }\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_79", "completion": "```cpp\nfloat max_element(std::vector<float> l){\n    float max = l[0];\n    for(size_t i = 1; i < l.size(); i++){\n        if(l[i] > max){\n            max = l[i];\n        }\n    }\n    return max;\n}\n```"}
{"task_id": "SimdBench_79", "completion": "```cpp\nfloat max_element(std::vector<float> l){\n    float max = l[0];\n    for(size_t i = 1; i < l.size(); i++){\n        if(l[i] > max){\n            max = l[i];\n        }\n    }\n    return max;\n}\n```"}
{"task_id": "SimdBench_79", "completion": "```cpp\nfloat max_element(std::vector<float> l){\n    float max = l[0];\n    for(size_t i = 1; i < l.size(); i++){\n        if(l[i] > max){\n            max = l[i];\n        }\n    }\n    return max;\n}\n```"}
{"task_id": "SimdBench_79", "completion": "```cpp\nfloat max_element(std::vector<float> l){\n    float max = l[0];\n    for(size_t i = 1; i < l.size(); i++){\n        if(l[i] > max){\n            max = l[i];\n        }\n    }\n    return max;\n}\n```"}
{"task_id": "SimdBench_79", "completion": "```cpp\nfloat max_element(std::vector<float> l){\n    float max = l[0];\n    for(size_t i = 1; i < l.size(); i++){\n        if(l[i] > max){\n            max = l[i];\n        }\n    }\n    return max;\n}\n```"}
{"task_id": "SimdBench_80", "completion": "```c\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int num = i;\n            while (num > 0) {\n                if (num % 10 == 7) {\n                    count++;\n                }\n                num /= 10;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80", "completion": "```c\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int num = i;\n            while (num > 0) {\n                if (num % 10 == 7) {\n                    count++;\n                }\n                num /= 10;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80", "completion": "```c\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int num = i;\n            while (num > 0) {\n                if (num % 10 == 7) {\n                    count++;\n                }\n                num /= 10;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80", "completion": "```c\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int num = i;\n            while (num > 0) {\n                if (num % 10 == 7) {\n                    count++;\n                }\n                num /= 10;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80", "completion": "```c\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int num = i;\n            while (num > 0) {\n                if (num % 10 == 7) {\n                    count++;\n                }\n                num /= 10;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_81", "completion": "```cpp\nstd::vector<float> sort_even(std::vector<float> l) {\n    std::vector<float> even_values;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_values.push_back(l[i]);\n    }\n    std::sort(even_values.begin(), even_values.end());\n    size_t even_index = 0;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        l[i] = even_values[even_index++];\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_81", "completion": "```cpp\nstd::vector<float> sort_even(std::vector<float> l) {\n    std::vector<float> even_indices;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        if (i < l.size()) {\n            even_indices.push_back(l[i]);\n        }\n    }\n    std::sort(even_indices.begin(), even_indices.end());\n    size_t even_idx = 0;\n    for (size_t i = 0; i < l.size(); i++) {\n        if (i % 2 == 0 && even_idx < even_indices.size()) {\n            l[i] = even_indices[even_idx];\n            even_idx++;\n        }\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_81", "completion": "```cpp\nstd::vector<float> sort_even(std::vector<float> l) {\n    std::vector<float> even_values;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        if (i < l.size()) {\n            even_values.push_back(l[i]);\n        }\n    }\n    std::sort(even_values.begin(), even_values.end());\n    size_t even_index = 0;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        if (i < l.size()) {\n            l[i] = even_values[even_index];\n            even_index++;\n        }\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_81", "completion": "```cpp\nstd::vector<float> sort_even(std::vector<float> l) {\n    std::vector<float> even_values;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        if (i < l.size()) {\n            even_values.push_back(l[i]);\n        }\n    }\n    std::sort(even_values.begin(), even_values.end());\n    size_t even_index = 0;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        if (i < l.size()) {\n            l[i] = even_values[even_index];\n            even_index++;\n        }\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_81", "completion": "```cpp\nstd::vector<float> sort_even(std::vector<float> l) {\n    std::vector<float> even_indices;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        if (i < l.size()) {\n            even_indices.push_back(l[i]);\n        }\n    }\n    std::sort(even_indices.begin(), even_indices.end());\n    size_t even_index = 0;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        if (i < l.size()) {\n            l[i] = even_indices[even_index];\n            even_index++;\n        }\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_82", "completion": "```cpp\nbool triples_sum_to_zero(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n    \n    for (int i = 0; i < n - 2; i++) {\n        for (int j = i + 1; j < n - 1; j++) {\n            for (int k = j + 1; k < n; k++) {\n                if (l[i] + l[j] + l[k] == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82", "completion": "```cpp\nbool triples_sum_to_zero(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n    \n    for (int i = 0; i < n - 2; i++) {\n        for (int j = i + 1; j < n - 1; j++) {\n            for (int k = j + 1; k < n; k++) {\n                if (l[i] + l[j] + l[k] == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82", "completion": "```cpp\nbool triples_sum_to_zero(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n    \n    for (int i = 0; i < n - 2; i++) {\n        for (int j = i + 1; j < n - 1; j++) {\n            for (int k = j + 1; k < n; k++) {\n                if (l[i] + l[j] + l[k] == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82", "completion": "```cpp\nbool triples_sum_to_zero(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n    \n    for (int i = 0; i < n - 2; i++) {\n        for (int j = i + 1; j < n - 1; j++) {\n            for (int k = j + 1; k < n; k++) {\n                if (l[i] + l[j] + l[k] == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82", "completion": "```cpp\nbool triples_sum_to_zero(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n    \n    for (int i = 0; i < n - 2; i++) {\n        for (int j = i + 1; j < n - 1; j++) {\n            for (int k = j + 1; k < n; k++) {\n                if (l[i] + l[j] + l[k] == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_83", "completion": "```cpp\nstd::vector<int> incr_list(std::vector<int> l) {\n    for (int& num : l) {\n        num += 1;\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_83", "completion": "```cpp\nstd::vector<int> incr_list(std::vector<int> l) {\n    for (int& num : l) {\n        num += 1;\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_83", "completion": "```cpp\nstd::vector<int> incr_list(std::vector<int> l) {\n    for (int& num : l) {\n        num += 1;\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_83", "completion": "```cpp\nstd::vector<int> incr_list(std::vector<int> l) {\n    for (int& num : l) {\n        num += 1;\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_83", "completion": "```cpp\nstd::vector<int> incr_list(std::vector<int> l) {\n    for (int& num : l) {\n        num += 1;\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_84", "completion": "```cpp\nbool pairs_sum_to_zero(std::vector<int> l) {\n    std::unordered_set<int> seen;\n    for (int num : l) {\n        if (seen.count(-num)) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84", "completion": "```cpp\nbool pairs_sum_to_zero(std::vector<int> l) {\n    std::unordered_set<int> seen;\n    for (int num : l) {\n        if (seen.count(-num)) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84", "completion": "```cpp\nbool pairs_sum_to_zero(std::vector<int> l) {\n    std::unordered_set<int> seen;\n    for (int num : l) {\n        if (seen.count(-num)) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84", "completion": "```cpp\nbool pairs_sum_to_zero(std::vector<int> l) {\n    std::unordered_set<int> seen;\n    for (int num : l) {\n        if (seen.count(-num)) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84", "completion": "```cpp\nbool pairs_sum_to_zero(std::vector<int> l) {\n    std::unordered_set<int> seen;\n    for (int num : l) {\n        if (seen.count(-num)) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_85", "completion": "```cpp\nstd::string change_base(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    std::string result = \"\";\n    while (x > 0) {\n        result = std::to_string(x % base) + result;\n        x /= base;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_85", "completion": "```cpp\nstd::string change_base(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    std::string result;\n    while (x > 0) {\n        result = std::to_string(x % base) + result;\n        x /= base;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_85", "completion": "```cpp\nstd::string change_base(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    std::string result = \"\";\n    while (x > 0) {\n        result = std::to_string(x % base) + result;\n        x /= base;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_85", "completion": "```cpp\nstd::string change_base(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    std::string result = \"\";\n    while (x > 0) {\n        result = std::to_string(x % base) + result;\n        x /= base;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_85", "completion": "```cpp\nstd::string change_base(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    std::string result = \"\";\n    while (x > 0) {\n        result = std::to_string(x % base) + result;\n        x /= base;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_86", "completion": "```cpp\nbool is_palindrome(std::string text) {\n    int left = 0;\n    int right = text.length() - 1;\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_86", "completion": "```cpp\nbool is_palindrome(std::string text) {\n    int left = 0;\n    int right = text.length() - 1;\n    \n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_86", "completion": "```cpp\nbool is_palindrome(std::string text) {\n    int left = 0;\n    int right = text.length() - 1;\n    \n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_86", "completion": "```cpp\nbool is_palindrome(std::string text) {\n    int left = 0;\n    int right = text.length() - 1;\n    \n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_86", "completion": "```cpp\nbool is_palindrome(std::string text) {\n    int left = 0;\n    int right = text.length() - 1;\n    \n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_87", "completion": "```cpp\nstd::string decode_shift(std::string s){\n    std::string out;\n    int i;\n    for (i=0; i<s.length(); i++)\n    {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';   \n        out = out + (char)w;\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_87", "completion": "```cpp\nstd::string decode_shift(std::string s){\n    std::string out;\n    int i;\n    for (i=0; i<s.length(); i++)\n    {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';   \n        out = out + (char)w;\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_87", "completion": "```cpp\nstd::string decode_shift(std::string s){\n    std::string out;\n    int i;\n    for (i=0; i<s.length(); i++)\n    {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';   \n        out = out + (char)w;\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_87", "completion": "```cpp\nstd::string decode_shift(std::string s){\n    std::string out;\n    int i;\n    for (i=0; i<s.length(); i++)\n    {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';   \n        out = out + (char)w;\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_87", "completion": "```cpp\nstd::string decode_shift(std::string s){\n    std::string out;\n    int i;\n    for (i=0; i<s.length(); i++)\n    {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';   \n        out = out + (char)w;\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_88", "completion": "```cpp\nbool below_threshold(std::vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88", "completion": "```cpp\nbool below_threshold(std::vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88", "completion": "```cpp\nbool below_threshold(std::vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88", "completion": "```cpp\nbool below_threshold(std::vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88", "completion": "```cpp\nbool below_threshold(std::vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_89", "completion": "```cpp\nbool correct_bracketing(std::string brackets) {\n    int count = 0;\n    for (char c : brackets) {\n        if (c == '<') {\n            count++;\n        } else if (c == '>') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_89", "completion": "```cpp\nbool correct_bracketing(std::string brackets) {\n    int count = 0;\n    for (char c : brackets) {\n        if (c == '<') {\n            count++;\n        } else if (c == '>') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_89", "completion": "```cpp\nbool correct_bracketing(std::string brackets) {\n    int count = 0;\n    for (char c : brackets) {\n        if (c == '<') {\n            count++;\n        } else if (c == '>') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_89", "completion": "```cpp\nbool correct_bracketing(std::string brackets) {\n    int count = 0;\n    for (char c : brackets) {\n        if (c == '<') {\n            count++;\n        } else if (c == '>') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_89", "completion": "```cpp\nbool correct_bracketing(std::string brackets) {\n    int count = 0;\n    for (char c : brackets) {\n        if (c == '<') {\n            count++;\n        } else if (c == '>') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_90", "completion": "```cpp\nbool correct_bracketing(std::string brackets) {\n    int count = 0;\n    for (char c : brackets) {\n        if (c == '(') {\n            count++;\n        } else if (c == ')') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_90", "completion": "```cpp\nbool correct_bracketing(std::string brackets) {\n    int count = 0;\n    for (char c : brackets) {\n        if (c == '(') {\n            count++;\n        } else if (c == ')') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_90", "completion": "```cpp\nbool correct_bracketing(std::string brackets) {\n    int count = 0;\n    for (char c : brackets) {\n        if (c == '(') {\n            count++;\n        } else if (c == ')') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_90", "completion": "```cpp\nbool correct_bracketing(std::string brackets) {\n    int count = 0;\n    for (char c : brackets) {\n        if (c == '(') {\n            count++;\n        } else if (c == ')') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_90", "completion": "```cpp\nbool correct_bracketing(std::string brackets) {\n    int count = 0;\n    for (char c : brackets) {\n        if (c == '(') {\n            count++;\n        } else if (c == ')') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_91", "completion": "```cpp\nstd::vector<float> derivative(std::vector<float> xs) {\n    std::vector<float> result;\n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_91", "completion": "```cpp\nstd::vector<float> derivative(std::vector<float> xs) {\n    std::vector<float> result;\n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_91", "completion": "```cpp\nstd::vector<float> derivative(std::vector<float> xs) {\n    std::vector<float> result;\n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_91", "completion": "```cpp\nstd::vector<float> derivative(std::vector<float> xs) {\n    std::vector<float> result;\n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_91", "completion": "```cpp\nstd::vector<float> derivative(std::vector<float> xs) {\n    std::vector<float> result;\n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_92", "completion": "```cpp\nint vowels_count(std::string s) {\n    int count = 0;\n    for (size_t i = 0; i < s.length(); i++) {\n        char c = tolower(s[i]);\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n        else if (c == 'y' && i == s.length() - 1) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_92", "completion": "```cpp\nint vowels_count(std::string s) {\n    int count = 0;\n    int len = s.length();\n    \n    for (int i = 0; i < len; i++) {\n        char c = tolower(s[i]);\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n        else if (c == 'y' && i == len - 1) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_92", "completion": "```cpp\nint vowels_count(std::string s) {\n    int count = 0;\n    for (size_t i = 0; i < s.length(); i++) {\n        char c = tolower(s[i]);\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n        else if (c == 'y' && i == s.length() - 1) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_92", "completion": "```cpp\nint vowels_count(std::string s) {\n    int count = 0;\n    for (size_t i = 0; i < s.length(); i++) {\n        char c = tolower(s[i]);\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n        else if (c == 'y' && i == s.length() - 1) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_92", "completion": "```cpp\nint vowels_count(std::string s) {\n    int count = 0;\n    for (size_t i = 0; i < s.length(); i++) {\n        char c = tolower(s[i]);\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n        else if (c == 'y' && i == s.length() - 1) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_93", "completion": "```cpp\nint digitSum(std::string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93", "completion": "```cpp\nint digitSum(std::string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93", "completion": "```cpp\nint digitSum(std::string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93", "completion": "```cpp\nint digitSum(std::string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93", "completion": "```cpp\nint digitSum(std::string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_94", "completion": "```cpp\nstd::vector<int> pluck(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n    \n    int smallestEven = -1;\n    int smallestIndex = -1;\n    \n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            if (smallestEven == -1 || arr[i] < smallestEven) {\n                smallestEven = arr[i];\n                smallestIndex = i;\n            }\n        }\n    }\n    \n    if (smallestEven == -1) {\n        return {};\n    }\n    \n    return {smallestEven, smallestIndex};\n}\n```"}
{"task_id": "SimdBench_94", "completion": "```cpp\nstd::vector<int> pluck(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n    \n    int smallestEven = -1;\n    int smallestIndex = -1;\n    \n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            if (smallestEven == -1 || arr[i] < smallestEven) {\n                smallestEven = arr[i];\n                smallestIndex = i;\n            }\n        }\n    }\n    \n    if (smallestEven == -1) {\n        return {};\n    }\n    \n    return {smallestEven, smallestIndex};\n}\n```"}
{"task_id": "SimdBench_94", "completion": "```cpp\nstd::vector<int> pluck(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n    \n    int smallestEven = -1;\n    int smallestIndex = -1;\n    \n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            if (smallestEven == -1 || arr[i] < smallestEven) {\n                smallestEven = arr[i];\n                smallestIndex = i;\n            }\n        }\n    }\n    \n    if (smallestEven == -1) {\n        return {};\n    }\n    \n    return {smallestEven, smallestIndex};\n}\n```"}
{"task_id": "SimdBench_94", "completion": "```cpp\nstd::vector<int> pluck(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n    \n    int smallestEven = -1;\n    int smallestIndex = -1;\n    \n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            if (smallestEven == -1 || arr[i] < smallestEven) {\n                smallestEven = arr[i];\n                smallestIndex = i;\n            }\n        }\n    }\n    \n    if (smallestEven == -1) {\n        return {};\n    }\n    \n    return {smallestEven, smallestIndex};\n}\n```"}
{"task_id": "SimdBench_94", "completion": "```cpp\nstd::vector<int> pluck(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n    \n    int smallestEven = -1;\n    int smallestIndex = -1;\n    \n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            if (smallestEven == -1 || arr[i] < smallestEven) {\n                smallestEven = arr[i];\n                smallestIndex = i;\n            }\n        }\n    }\n    \n    if (smallestEven == -1) {\n        return {};\n    }\n    \n    return {smallestEven, smallestIndex};\n}\n```"}
{"task_id": "SimdBench_95", "completion": "```cpp\nint search(std::vector<int> lst) {\n    std::unordered_map<int, int> freq;\n    for (int num : lst) {\n        freq[num]++;\n    }\n    int result = -1;\n    for (auto& pair : freq) {\n        if (pair.first <= pair.second && pair.first > result) {\n            result = pair.first;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_95", "completion": "```cpp\nint search(std::vector<int> lst) {\n    std::unordered_map<int, int> freq;\n    for (int num : lst) {\n        freq[num]++;\n    }\n    int maxVal = -1;\n    for (auto& pair : freq) {\n        if (pair.first <= pair.second && pair.first > maxVal) {\n            maxVal = pair.first;\n        }\n    }\n    return maxVal;\n}\n```"}
{"task_id": "SimdBench_95", "completion": "```cpp\nint search(std::vector<int> lst) {\n    std::unordered_map<int, int> freq;\n    for (int num : lst) {\n        freq[num]++;\n    }\n    int maxVal = -1;\n    for (auto& pair : freq) {\n        if (pair.first <= pair.second && pair.first > maxVal) {\n            maxVal = pair.first;\n        }\n    }\n    return maxVal;\n}\n```"}
{"task_id": "SimdBench_95", "completion": "```cpp\nint search(std::vector<int> lst) {\n    std::unordered_map<int, int> freq;\n    for (int num : lst) {\n        freq[num]++;\n    }\n    int maxVal = -1;\n    for (auto& pair : freq) {\n        if (pair.first <= pair.second && pair.first > maxVal) {\n            maxVal = pair.first;\n        }\n    }\n    return maxVal;\n}\n```"}
{"task_id": "SimdBench_95", "completion": "```cpp\nint search(std::vector<int> lst) {\n    std::unordered_map<int, int> freq;\n    for (int num : lst) {\n        freq[num]++;\n    }\n    int maxVal = -1;\n    for (auto& pair : freq) {\n        if (pair.first <= pair.second && pair.first > maxVal) {\n            maxVal = pair.first;\n        }\n    }\n    return maxVal;\n}\n```"}
{"task_id": "SimdBench_96", "completion": "```cpp\nbool will_it_fly(std::vector<int> q, int w) {\n    int sum = 0;\n    int n = q.size();\n    \n    // Check if sum of elements is within weight limit\n    for(int num : q) {\n        sum += num;\n    }\n    if(sum > w) return false;\n    \n    // Check if the vector is palindromic (balanced)\n    for(int i = 0; i < n/2; i++) {\n        if(q[i] != q[n-1-i]) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_96", "completion": "```cpp\nbool will_it_fly(std::vector<int> q, int w) {\n    int sum = 0;\n    int n = q.size();\n    \n    // Check if sum of elements is less than or equal to w\n    for(int num : q) {\n        sum += num;\n    }\n    if(sum > w) return false;\n    \n    // Check if the vector is palindromic (balanced)\n    for(int i = 0; i < n/2; i++) {\n        if(q[i] != q[n-1-i]) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_96", "completion": "```cpp\nbool will_it_fly(std::vector<int> q, int w) {\n    int sum = 0;\n    int n = q.size();\n    \n    // Check if sum of elements is within weight limit\n    for(int num : q) {\n        sum += num;\n    }\n    if(sum > w) return false;\n    \n    // Check if the vector is palindromic (balanced)\n    for(int i = 0; i < n/2; i++) {\n        if(q[i] != q[n-1-i]) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_96", "completion": "```cpp\nbool will_it_fly(std::vector<int> q, int w) {\n    int sum = 0;\n    int n = q.size();\n    \n    // Check if sum of elements is within weight limit\n    for(int num : q) {\n        sum += num;\n    }\n    if(sum > w) return false;\n    \n    // Check if the vector is palindromic (balanced)\n    for(int i = 0; i < n/2; i++) {\n        if(q[i] != q[n-1-i]) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_96", "completion": "```cpp\nbool will_it_fly(std::vector<int> q, int w) {\n    int sum = 0;\n    int n = q.size();\n    \n    // Check if sum of elements is within weight limit\n    for(int num : q) {\n        sum += num;\n    }\n    if(sum > w) return false;\n    \n    // Check if the vector is palindromic (balanced)\n    for(int i = 0; i < n/2; i++) {\n        if(q[i] != q[n-1-i]) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_97", "completion": "```cpp\nint smallest_change(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    for (int i = 0; i < n / 2; i++) {\n        if (arr[i] != arr[n - 1 - i]) {\n            changes++;\n        }\n    }\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97", "completion": "```cpp\nint smallest_change(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    for (int i = 0; i < n / 2; i++) {\n        if (arr[i] != arr[n - 1 - i]) {\n            changes++;\n        }\n    }\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97", "completion": "```cpp\nint smallest_change(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    for (int i = 0; i < n / 2; i++) {\n        if (arr[i] != arr[n - 1 - i]) {\n            changes++;\n        }\n    }\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97", "completion": "```cpp\nint smallest_change(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    for (int i = 0; i < n / 2; i++) {\n        if (arr[i] != arr[n - 1 - i]) {\n            changes++;\n        }\n    }\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97", "completion": "```cpp\nint smallest_change(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    for (int i = 0; i < n / 2; i++) {\n        if (arr[i] != arr[n - 1 - i]) {\n            changes++;\n        }\n    }\n    return changes;\n}\n```"}
{"task_id": "SimdBench_98", "completion": "```cpp\nstd::vector<std::string> total_match(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    int total1 = 0;\n    for (const auto& str : lst1) {\n        total1 += str.length();\n    }\n    \n    int total2 = 0;\n    for (const auto& str : lst2) {\n        total2 += str.length();\n    }\n    \n    if (total1 <= total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98", "completion": "```cpp\nstd::vector<std::string> total_match(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    int total1 = 0;\n    for (const auto& str : lst1) {\n        total1 += str.length();\n    }\n    int total2 = 0;\n    for (const auto& str : lst2) {\n        total2 += str.length();\n    }\n    if (total1 <= total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98", "completion": "```cpp\nstd::vector<std::string> total_match(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    int total1 = 0;\n    for (const auto& str : lst1) {\n        total1 += str.length();\n    }\n    \n    int total2 = 0;\n    for (const auto& str : lst2) {\n        total2 += str.length();\n    }\n    \n    if (total1 <= total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98", "completion": "```cpp\nstd::vector<std::string> total_match(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    int total1 = 0;\n    for (const auto& str : lst1) {\n        total1 += str.length();\n    }\n    \n    int total2 = 0;\n    for (const auto& str : lst2) {\n        total2 += str.length();\n    }\n    \n    if (total1 <= total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98", "completion": "```cpp\nstd::vector<std::string> total_match(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    int count1 = 0;\n    for (const auto& str : lst1) {\n        count1 += str.length();\n    }\n    \n    int count2 = 0;\n    for (const auto& str : lst2) {\n        count2 += str.length();\n    }\n    \n    if (count1 <= count2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_99", "completion": "```c\nbool is_simple_power(uint64_t x, uint64_t n) {\n    if (n == 1) return x == 1;\n    if (n == 0) return false;\n    uint64_t temp = n;\n    while (temp < x) {\n        if (temp > UINT64_MAX / n) return false;\n        temp *= n;\n    }\n    return temp == x;\n}\n```"}
{"task_id": "SimdBench_99", "completion": "```c\nbool is_simple_power(uint64_t x, uint64_t n) {\n    if (n == 1) return x == 1;\n    if (x == 1) return true;\n    if (n == 0) return false;\n    \n    uint64_t temp = n;\n    while (temp < x) {\n        if (temp > UINT64_MAX / n) return false;\n        temp *= n;\n    }\n    return temp == x;\n}\n```"}
{"task_id": "SimdBench_99", "completion": "```c\nbool is_simple_power(uint64_t x, uint64_t n) {\n    if (n == 1) return x == 1;\n    if (n == 0) return false;\n    if (x == 1) return true;\n    if (x == 0) return false;\n    \n    uint64_t temp = n;\n    while (temp < x) {\n        if (temp > UINT64_MAX / n) return false;\n        temp *= n;\n    }\n    return temp == x;\n}\n```"}
{"task_id": "SimdBench_99", "completion": "```c\nbool is_simple_power(uint64_t x, uint64_t n) {\n    if (n == 1) return x == 1;\n    if (n == 0) return false;\n    if (x == 1) return true;\n    if (x == 0) return false;\n    \n    uint64_t temp = n;\n    while (temp < x) {\n        if (temp > UINT64_MAX / n) return false;\n        temp *= n;\n    }\n    return temp == x;\n}\n```"}
{"task_id": "SimdBench_99", "completion": "```c\nbool is_simple_power(uint64_t x, uint64_t n) {\n    if (n == 1) return x == 1;\n    if (n == 0) return false;\n    \n    uint64_t temp = n;\n    while (temp < x) {\n        if (temp > UINT64_MAX / n) return false;\n        temp *= n;\n    }\n    return temp == x;\n}\n```"}
{"task_id": "SimdBench_100", "completion": "```cpp\nint hex_key(const std::string & num) {\n    int count = 0;\n    for (char c : num) {\n        int value;\n        if (c >= '0' && c <= '9') {\n            value = c - '0';\n        } else {\n            value = 10 + (c - 'A');\n        }\n        if (value > 1 && (value == 2 || value == 3 || value == 5 || value == 7 || value == 11 || value == 13)) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_100", "completion": "```cpp\nint hex_key(const std::string & num) {\n    int count = 0;\n    for (char c : num) {\n        int value;\n        if (c >= '0' && c <= '9') {\n            value = c - '0';\n        } else {\n            value = 10 + (c - 'A');\n        }\n        if (value > 1 && (value == 2 || value == 3 || value == 5 || value == 7 || value == 11 || value == 13)) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_100", "completion": "```cpp\nint hex_key(const std::string & num) {\n    int count = 0;\n    for (char c : num) {\n        int value;\n        if (c >= '0' && c <= '9') {\n            value = c - '0';\n        } else {\n            value = 10 + (c - 'A');\n        }\n        if (value > 1 && (value == 2 || value == 3 || value == 5 || value == 7 || value == 11 || value == 13)) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_100", "completion": "```cpp\nint hex_key(const std::string & num) {\n    int count = 0;\n    for (char c : num) {\n        int value;\n        if (c >= '0' && c <= '9') {\n            value = c - '0';\n        } else {\n            value = 10 + (c - 'A');\n        }\n        if (value > 1 && (value == 2 || value == 3 || value == 5 || value == 7 || value == 11 || value == 13)) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_100", "completion": "```cpp\nint hex_key(const std::string & num) {\n    int count = 0;\n    for (char c : num) {\n        int value;\n        if (c >= '0' && c <= '9') {\n            value = c - '0';\n        } else {\n            value = 10 + (c - 'A');\n        }\n        if (value > 1 && (value == 2 || value == 3 || value == 5 || value == 7 || value == 11 || value == 13)) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_101", "completion": "```cpp\nbool is_happy(const std::string & s) {\n    if (s.length() < 3) {\n        return false;\n    }\n    for (size_t i = 0; i < s.length() - 2; i++) {\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_101", "completion": "```cpp\nbool is_happy(const std::string & s) {\n    if (s.length() < 3) {\n        return false;\n    }\n    for (size_t i = 0; i < s.length() - 2; i++) {\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_101", "completion": "```cpp\nbool is_happy(const std::string & s) {\n    if (s.length() < 3) {\n        return false;\n    }\n    for (size_t i = 0; i < s.length() - 2; i++) {\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_101", "completion": "``` ```cpp\nbool is_happy(const std::string & s) {\n    if (s.length() < 3) {\n        return false;\n    }\n    for (size_t i = 0; i < s.length() - 2; ++i) {\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_101", "completion": "```cpp\nbool is_happy(const std::string & s) {\n    if (s.length() < 3) {\n        return false;\n    }\n    for (size_t i = 0; i < s.length() - 2; i++) {\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_102", "completion": "```cpp\nbool prime_length(const std::string & str) {\n    int len = str.length();\n    if (len <= 1) return false;\n    if (len == 2) return true;\n    if (len % 2 == 0) return false;\n    for (int i = 3; i * i <= len; i += 2) {\n        if (len % i == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_102", "completion": "```cpp\nbool prime_length(const std::string & str) {\n    int len = str.length();\n    if (len <= 1) return false;\n    if (len == 2) return true;\n    if (len % 2 == 0) return false;\n    for (int i = 3; i * i <= len; i += 2) {\n        if (len % i == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_102", "completion": "```cpp\nbool prime_length(const std::string & str) {\n    int len = str.length();\n    if (len <= 1) return false;\n    if (len == 2) return true;\n    if (len % 2 == 0) return false;\n    for (int i = 3; i * i <= len; i += 2) {\n        if (len % i == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_102", "completion": "```cpp\nbool prime_length(const std::string & str) {\n    int len = str.length();\n    if (len <= 1) return false;\n    if (len == 2) return true;\n    if (len % 2 == 0) return false;\n    for (int i = 3; i * i <= len; i += 2) {\n        if (len % i == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_102", "completion": "```cpp\nbool prime_length(const std::string & str) {\n    int len = str.length();\n    if (len <= 1) return false;\n    if (len == 2) return true;\n    if (len % 2 == 0) return false;\n    for (int i = 3; i * i <= len; i += 2) {\n        if (len % i == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_103", "completion": "```cpp\nstd::string solve(uint64_t N) {\n    int sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n    std::string binary = \"\";\n    if (sum == 0) return \"0\";\n    while (sum > 0) {\n        binary = std::to_string(sum % 2) + binary;\n        sum /= 2;\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103", "completion": "```cpp\nstd::string solve(uint64_t N) {\n    int sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n    std::string binary = \"\";\n    if (sum == 0) return \"0\";\n    while (sum > 0) {\n        binary = std::to_string(sum % 2) + binary;\n        sum /= 2;\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103", "completion": "```cpp\nstd::string solve(uint64_t N) {\n    int sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n    std::string binary = \"\";\n    if (sum == 0) return \"0\";\n    while (sum > 0) {\n        binary = std::to_string(sum % 2) + binary;\n        sum /= 2;\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103", "completion": "```cpp\nstd::string solve(uint64_t N) {\n    int sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n    std::string binary = \"\";\n    if (sum == 0) return \"0\";\n    while (sum > 0) {\n        binary = std::to_string(sum % 2) + binary;\n        sum /= 2;\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103", "completion": "```cpp\nstd::string solve(uint64_t N) {\n    int sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n    std::string binary = \"\";\n    if (sum == 0) return \"0\";\n    while (sum > 0) {\n        binary = std::to_string(sum % 2) + binary;\n        sum /= 2;\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_104", "completion": "```cpp\nint add(std::vector<int> lst) {\n    int sum = 0;\n    for (int i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104", "completion": "```cpp\nint add(std::vector<int> lst) {\n    int sum = 0;\n    for (int i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104", "completion": "```cpp\nint add(std::vector<int> lst) {\n    int sum = 0;\n    for (int i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104", "completion": "```cpp\nint add(std::vector<int> lst) {\n    int sum = 0;\n    for (int i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104", "completion": "```cpp\nint add(std::vector<int> lst) {\n    int sum = 0;\n    for (int i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_105", "completion": "```cpp\nstd::string encrypt(const std::string & s) {\n    std::string result = \"\";\n    for (char c : s) {\n        if (isalpha(c)) {\n            char base = isupper(c) ? 'A' : 'a';\n            result += static_cast<char>(base + (c - base + 4) % 26);\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_105", "completion": "```cpp\nstd::string encrypt(const std::string & s){\n    std::string result = \"\";\n    for (char c : s) {\n        if (isalpha(c)) {\n            char base = isupper(c) ? 'A' : 'a';\n            result += static_cast<char>(base + (c - base + 4) % 26);\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_105", "completion": "```cpp\nstd::string encrypt(const std::string & s){\n    std::string result = \"\";\n    for(char c : s) {\n        if(isalpha(c)) {\n            char base = isupper(c) ? 'A' : 'a';\n            result += static_cast<char>(base + (c - base + 4) % 26);\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_105", "completion": "```cpp\nstd::string encrypt(const std::string & s){\n    std::string result = \"\";\n    for(char c : s) {\n        if(isalpha(c)) {\n            char base = isupper(c) ? 'A' : 'a';\n            result += static_cast<char>(base + (c - base + 4) % 26);\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_105", "completion": "```cpp\nstd::string encrypt(const std::string & s) {\n    std::string result = \"\";\n    for (char c : s) {\n        if (isalpha(c)) {\n            char base = isupper(c) ? 'A' : 'a';\n            result += static_cast<char>(base + (c - base + 4) % 26);\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_106", "completion": "```cpp\nstd::string encode(const std::string & message) {\n    std::string result = \"\";\n    for (char c : message) {\n        if (isalpha(c)) {\n            char newChar = isupper(c) ? tolower(c) : toupper(c);\n            if (newChar == 'a' || newChar == 'e' || newChar == 'i' || newChar == 'o' || newChar == 'u' ||\n                newChar == 'A' || newChar == 'E' || newChar == 'I' || newChar == 'O' || newChar == 'U') {\n                newChar = newChar + 2;\n            }\n            result += newChar;\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_106", "completion": "```cpp\nstd::string encode(const std::string & message) {\n    std::string result = \"\";\n    for (char c : message) {\n        if (isalpha(c)) {\n            char swapped = isupper(c) ? tolower(c) : toupper(c);\n            if (swapped == 'a' || swapped == 'e' || swapped == 'i' || swapped == 'o' || swapped == 'u' ||\n                swapped == 'A' || swapped == 'E' || swapped == 'I' || swapped == 'O' || swapped == 'U') {\n                if (swapped == 'u') swapped = 'w';\n                else if (swapped == 'U') swapped = 'W';\n                else if (swapped == 'o') swapped = 'q';\n                else if (swapped == 'O') swapped = 'Q';\n                else if (swapped == 'i') swapped = 'k';\n                else if (swapped == 'I') swapped = 'K';\n                else if (swapped == 'e') swapped = 'g';\n                else if (swapped == 'E') swapped = 'G';\n                else if (swapped == 'a') swapped = 'c';\n                else if (swapped == 'A') swapped = 'C';\n            }\n            result += swapped;\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_106", "completion": "```cpp\nstd::string encode(const std::string & message) {\n    std::string result = \"\";\n    for (char c : message) {\n        if (isalpha(c)) {\n            // Swap case\n            if (isupper(c)) {\n                c = tolower(c);\n            } else {\n                c = toupper(c);\n            }\n            // Replace vowels with letter 2 places ahead\n            if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n                c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n                c = c + 2;\n            }\n        }\n        result += c;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_106", "completion": "```cpp\nstd::string encode(const std::string & message) {\n    std::string result = \"\";\n    for (char c : message) {\n        if (isalpha(c)) {\n            // Swap case\n            if (isupper(c)) {\n                c = tolower(c);\n            } else {\n                c = toupper(c);\n            }\n            // Replace vowels with letter 2 places ahead\n            if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n                c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n                c = c + 2;\n            }\n        }\n        result += c;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_106", "completion": "```cpp\nstd::string encode(const std::string & message) {\n    std::string result = \"\";\n    for (char c : message) {\n        if (isalpha(c)) {\n            char swapped = isupper(c) ? tolower(c) : toupper(c);\n            if (swapped == 'a' || swapped == 'e' || swapped == 'i' || swapped == 'o' || swapped == 'u' ||\n                swapped == 'A' || swapped == 'E' || swapped == 'I' || swapped == 'O' || swapped == 'U') {\n                if (swapped == 'u') swapped = 'w';\n                else if (swapped == 'U') swapped = 'W';\n                else if (swapped == 'o') swapped = 'q';\n                else if (swapped == 'O') swapped = 'Q';\n                else swapped += 2;\n            }\n            result += swapped;\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_107", "completion": "```cpp\nbool check_dict_case(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n    \n    bool isLower = true;\n    bool isUpper = true;\n    \n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        bool currentLower = true;\n        bool currentUpper = true;\n        \n        for (char c : key) {\n            if (!isalpha(c)) {\n                return false;\n            }\n            if (islower(c)) {\n                currentUpper = false;\n            }\n            if (isupper(c)) {\n                currentLower = false;\n            }\n        }\n        \n        if (!currentLower && !currentUpper) {\n            return false;\n        }\n        \n        isLower = isLower && currentLower;\n        isUpper = isUpper && currentUpper;\n    }\n    \n    return isLower || isUpper;\n}\n```"}
{"task_id": "SimdBench_107", "completion": "```cpp\nbool check_dict_case(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n    \n    bool isLower = true;\n    bool isUpper = true;\n    \n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        bool keyIsLower = true;\n        bool keyIsUpper = true;\n        \n        for (char c : key) {\n            if (!isalpha(c)) {\n                return false;\n            }\n            if (islower(c)) {\n                keyIsUpper = false;\n            }\n            if (isupper(c)) {\n                keyIsLower = false;\n            }\n        }\n        \n        if (!keyIsLower && !keyIsUpper) {\n            return false;\n        }\n        \n        if (!keyIsLower) {\n            isLower = false;\n        }\n        if (!keyIsUpper) {\n            isUpper = false;\n        }\n    }\n    \n    return isLower || isUpper;\n}\n```"}
{"task_id": "SimdBench_107", "completion": "```cpp\nbool check_dict_case(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n    \n    bool isLower = true;\n    bool isUpper = true;\n    \n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        \n        // Check if all characters in the key are lowercase\n        for (char c : key) {\n            if (!islower(c)) {\n                isLower = false;\n            }\n            if (!isupper(c)) {\n                isUpper = false;\n            }\n        }\n        \n        // If a key contains non-letters, return false\n        for (char c : key) {\n            if (!isalpha(c)) {\n                return false;\n            }\n        }\n    }\n    \n    return isLower || isUpper;\n}\n```"}
{"task_id": "SimdBench_107", "completion": "```cpp\nbool check_dict_case(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n    \n    bool isLower = true;\n    bool isUpper = true;\n    \n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        bool currentLower = true;\n        bool currentUpper = true;\n        \n        for (char c : key) {\n            if (!isalpha(c)) {\n                return false;\n            }\n            if (islower(c)) {\n                currentUpper = false;\n            }\n            if (isupper(c)) {\n                currentLower = false;\n            }\n        }\n        \n        if (!currentLower && !currentUpper) {\n            return false;\n        }\n        \n        isLower = isLower && currentLower;\n        isUpper = isUpper && currentUpper;\n    }\n    \n    return isLower || isUpper;\n}\n```"}
{"task_id": "SimdBench_107", "completion": "```cpp\nbool check_dict_case(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n    \n    bool isLower = true;\n    bool isUpper = true;\n    \n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        \n        // Check if key contains only alphabetic characters\n        bool hasAlpha = false;\n        for (char c : key) {\n            if (std::isalpha(c)) {\n                hasAlpha = true;\n                if (!std::islower(c)) {\n                    isLower = false;\n                }\n                if (!std::isupper(c)) {\n                    isUpper = false;\n                }\n            }\n        }\n        \n        // If key has no alphabetic characters, return false\n        if (!hasAlpha) {\n            return false;\n        }\n    }\n    \n    // Return true if all keys are either all lowercase or all uppercase\n    return isLower || isUpper;\n}\n```"}
{"task_id": "SimdBench_108", "completion": "```cpp\nstd::vector<int> count_up_to(int n) {\n    std::vector<int> primes;\n    if (n <= 2) {\n        return primes;\n    }\n    \n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n    \n    for (int i = 2; i * i < n; i++) {\n        if (is_prime[i]) {\n            for (int j = i * i; j < n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n    \n    for (int i = 2; i < n; i++) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n    \n    return primes;\n}\n```"}
{"task_id": "SimdBench_108", "completion": "```cpp\nstd::vector<int> count_up_to(int n) {\n    std::vector<int> primes;\n    if (n <= 2) {\n        return primes;\n    }\n    \n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n    \n    for (int i = 2; i * i < n; i++) {\n        if (is_prime[i]) {\n            for (int j = i * i; j < n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n    \n    for (int i = 2; i < n; i++) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n    \n    return primes;\n}\n```"}
{"task_id": "SimdBench_108", "completion": "```cpp\nstd::vector<int> count_up_to(int n) {\n    std::vector<int> primes;\n    if (n <= 2) {\n        return primes;\n    }\n    \n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n    \n    for (int i = 2; i * i < n; i++) {\n        if (is_prime[i]) {\n            for (int j = i * i; j < n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n    \n    for (int i = 2; i < n; i++) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n    \n    return primes;\n}\n```"}
{"task_id": "SimdBench_108", "completion": "```cpp\nstd::vector<int> count_up_to(int n) {\n    std::vector<int> primes;\n    if (n <= 2) {\n        return primes;\n    }\n    \n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n    \n    for (int i = 2; i * i < n; i++) {\n        if (is_prime[i]) {\n            for (int j = i * i; j < n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n    \n    for (int i = 2; i < n; i++) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n    \n    return primes;\n}\n```"}
{"task_id": "SimdBench_108", "completion": "```cpp\nstd::vector<int> count_up_to(int n) {\n    if (n <= 2) return {};\n    \n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n    \n    for (int i = 2; i * i < n; i++) {\n        if (is_prime[i]) {\n            for (int j = i * i; j < n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n    \n    std::vector<int> result;\n    for (int i = 2; i < n; i++) {\n        if (is_prime[i]) {\n            result.push_back(i);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_109", "completion": "```cpp\nint count_upper(const std::string & s) {\n    int count = 0;\n    for (size_t i = 0; i < s.length(); i += 2) {\n        if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_109", "completion": "```cpp\nint count_upper(const std::string & s) {\n    int count = 0;\n    for (size_t i = 0; i < s.length(); i += 2) {\n        if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_109", "completion": "```cpp\nint count_upper(const std::string & s) {\n    int count = 0;\n    for (size_t i = 0; i < s.length(); i += 2) {\n        if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_109", "completion": "```cpp\nint count_upper(const std::string & s) {\n    int count = 0;\n    for (size_t i = 0; i < s.length(); i += 2) {\n        if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_109", "completion": "```cpp\nint count_upper(const std::string & s) {\n    int count = 0;\n    for (size_t i = 0; i < s.length(); i += 2) {\n        if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_110", "completion": "```cpp\nstd::vector<int> make_a_pile(int n) {\n    std::vector<int> result;\n    int current = n;\n    for (int i = 0; i < n; ++i) {\n        result.push_back(current);\n        if (current % 2 == 0) {\n            current += 2;\n        } else {\n            current += 2;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_110", "completion": "```cpp\nstd::vector<int> make_a_pile(int n) {\n    std::vector<int> pile;\n    int current = n;\n    for (int i = 0; i < n; ++i) {\n        pile.push_back(current);\n        if (current % 2 == 0) {\n            current += 2;\n        } else {\n            current += 2;\n        }\n    }\n    return pile;\n}\n```"}
{"task_id": "SimdBench_110", "completion": "```cpp\nstd::vector<int> make_a_pile(int n) {\n    std::vector<int> pile;\n    int current = n;\n    for (int i = 0; i < n; ++i) {\n        pile.push_back(current);\n        if (current % 2 == 0) {\n            current += 2;\n        } else {\n            current += 2;\n        }\n    }\n    return pile;\n}\n```"}
{"task_id": "SimdBench_110", "completion": "```cpp\nstd::vector<int> make_a_pile(int n) {\n    std::vector<int> pile;\n    int current = n;\n    for (int i = 0; i < n; ++i) {\n        pile.push_back(current);\n        if (current % 2 == 0) {\n            current += 2;\n        } else {\n            current += 2;\n        }\n    }\n    return pile;\n}\n```"}
{"task_id": "SimdBench_110", "completion": "```cpp\nstd::vector<int> make_a_pile(int n) {\n    std::vector<int> pile;\n    int current = n;\n    for (int i = 0; i < n; ++i) {\n        pile.push_back(current);\n        if (current % 2 == 0) {\n            current += 2;\n        } else {\n            current += 2;\n        }\n    }\n    return pile;\n}\n```"}
{"task_id": "SimdBench_111", "completion": "```cpp\nstd::string rounded_avg(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n    int64_t count = m - n + 1;\n    int64_t sum = (n + m) * count / 2;\n    int64_t avg = sum / count;\n    std::string binary = \"\";\n    if (avg == 0) {\n        return \"0\";\n    }\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_111", "completion": "```cpp\nstd::string rounded_avg(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n    int64_t count = m - n + 1;\n    int64_t sum = (n + m) * count / 2;\n    int64_t avg = sum / count;\n    if (sum % count != 0 && (sum % count) * 2 >= count) {\n        avg++;\n    }\n    std::string binary = \"\";\n    if (avg == 0) {\n        return \"0\";\n    }\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_111", "completion": "```cpp\nstd::string rounded_avg(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n    int64_t count = m - n + 1;\n    int64_t sum = (n + m) * count / 2;\n    int64_t avg = sum / count;\n    if (sum % count != 0 && (sum % count) * 2 >= count) {\n        avg++;\n    }\n    std::string binary = \"\";\n    if (avg == 0) {\n        return \"0\";\n    }\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_111", "completion": "```cpp\nstd::string rounded_avg(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n    int64_t count = m - n + 1;\n    int64_t sum = (n + m) * count / 2;\n    int64_t avg = sum / count;\n    std::string binary = \"\";\n    if (avg == 0) {\n        return \"0\";\n    }\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_111", "completion": "```cpp\nstd::string rounded_avg(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n    int64_t count = m - n + 1;\n    int64_t sum = (n + m) * count / 2;\n    int64_t avg = sum / count;\n    if (sum % count != 0 && (sum % count) * 2 >= count) {\n        avg++;\n    }\n    std::string binary = \"\";\n    if (avg == 0) {\n        return \"0\";\n    }\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_112", "completion": "```cpp\nstd::vector<int> func(int n) {\n    std::vector<int> result(n);\n    long long fact = 1;\n    for(int i = 1; i <= n; i++) {\n        if(i % 2 == 0) {\n            fact = (fact * i) % 10000;\n            result[i-1] = fact;\n        } else {\n            result[i-1] = (i * (i + 1)) / 2;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_112", "completion": "```cpp\nstd::vector<int> func(int n) {\n    std::vector<int> result(n);\n    long long fact = 1;\n    for(int i = 1; i <= n; i++) {\n        if(i % 2 == 0) {\n            fact = (fact * i) % 10000;\n            result[i-1] = fact;\n        } else {\n            result[i-1] = (i * (i + 1)) / 2;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_112", "completion": "```cpp\nstd::vector<int> func(int n) {\n    std::vector<int> result(n);\n    long long fact = 1;\n    for(int i = 1; i <= n; i++) {\n        if(i % 2 == 0) {\n            fact = (fact * i) % 10000;\n            result[i-1] = fact;\n        } else {\n            result[i-1] = (i * (i + 1)) / 2;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_112", "completion": "```cpp\nstd::vector<int> func(int n) {\n    std::vector<int> result(n);\n    long long fact = 1;\n    for(int i = 1; i <= n; i++) {\n        if(i % 2 == 0) {\n            fact = (fact * i) % 10000;\n            result[i-1] = fact;\n        } else {\n            result[i-1] = (i * (i + 1)) / 2;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_112", "completion": "```cpp\nstd::vector<int> func(int n) {\n    std::vector<int> result(n);\n    long long fact = 1;\n    for(int i = 1; i <= n; i++) {\n        if(i % 2 == 0) {\n            fact = (fact * i) % 10000;\n            result[i-1] = fact;\n        } else {\n            result[i-1] = (i * (i + 1)) / 2;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_113", "completion": "```cpp\nstd::vector<int> even_odd_palindrome(int n) {\n    int evenCount = 0;\n    int oddCount = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        if (isPalindrome(i)) {\n            if (i % 2 == 0) {\n                evenCount++;\n            } else {\n                oddCount++;\n            }\n        }\n    }\n    \n    return {evenCount, oddCount};\n}\n\nbool isPalindrome(int num) {\n    std::string s = std::to_string(num);\n    int left = 0;\n    int right = s.length() - 1;\n    \n    while (left < right) {\n        if (s[left] != s[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_113", "completion": "```cpp\nstd::vector<int> even_odd_palindrome(int n) {\n    int evenCount = 0;\n    int oddCount = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        if (isPalindrome(i)) {\n            if (i % 2 == 0) {\n                evenCount++;\n            } else {\n                oddCount++;\n            }\n        }\n    }\n    \n    return {evenCount, oddCount};\n}\n\nbool isPalindrome(int num) {\n    std::string str = std::to_string(num);\n    int left = 0;\n    int right = str.length() - 1;\n    \n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_113", "completion": "```cpp\nstd::vector<int> even_odd_palindrome(int n) {\n    int evenCount = 0;\n    int oddCount = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        if (isPalindrome(i)) {\n            if (i % 2 == 0) {\n                evenCount++;\n            } else {\n                oddCount++;\n            }\n        }\n    }\n    \n    return {evenCount, oddCount};\n}\n\nbool isPalindrome(int num) {\n    std::string s = std::to_string(num);\n    int left = 0;\n    int right = s.length() - 1;\n    \n    while (left < right) {\n        if (s[left] != s[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_113", "completion": "```cpp\nstd::vector<int> even_odd_palindrome(int n) {\n    int evenCount = 0;\n    int oddCount = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        if (isPalindrome(i)) {\n            if (i % 2 == 0) {\n                evenCount++;\n            } else {\n                oddCount++;\n            }\n        }\n    }\n    \n    return {evenCount, oddCount};\n}\n\nbool isPalindrome(int num) {\n    std::string str = std::to_string(num);\n    int left = 0;\n    int right = str.length() - 1;\n    \n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_113", "completion": "```cpp\nstd::vector<int> even_odd_palindrome(int n) {\n    int evenCount = 0;\n    int oddCount = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        if (isPalindrome(i)) {\n            if (i % 2 == 0) {\n                evenCount++;\n            } else {\n                oddCount++;\n            }\n        }\n    }\n    \n    return {evenCount, oddCount};\n}\n\nbool isPalindrome(int num) {\n    std::string str = std::to_string(num);\n    int left = 0;\n    int right = str.length() - 1;\n    \n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_114", "completion": "```cpp\nint count_nums(std::vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        int sum = 0;\n        if (num == 0) continue;\n        while (num != 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        if (sum > 0) count++;\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_114", "completion": "```cpp\nint count_nums(std::vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        int sum = 0;\n        if (num == 0) continue;\n        while (num != 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        if (sum > 0) count++;\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_114", "completion": "```cpp\nint count_nums(std::vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        int sum = 0;\n        if (num == 0) continue;\n        while (num != 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        if (sum > 0) count++;\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_114", "completion": "```cpp\nint count_nums(std::vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        int sum = 0;\n        if (num == 0) continue;\n        while (num != 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        if (sum > 0) count++;\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_114", "completion": "```cpp\nint count_nums(std::vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        int sum = 0;\n        if (num == 0) continue;\n        while (num != 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        if (sum > 0) count++;\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_115", "completion": "```cpp\nbool move_one_ball(std::vector<int> arr) {\n    if (arr.empty()) return true;\n    \n    int n = arr.size();\n    vector<int> sorted = arr;\n    sort(sorted.begin(), sorted.end());\n    \n    for (int i = 0; i < n; i++) {\n        bool match = true;\n        for (int j = 0; j < n; j++) {\n            if (arr[(i + j) % n] != sorted[j]) {\n                match = false;\n                break;\n            }\n        }\n        if (match) return true;\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_115", "completion": "```cpp\nbool move_one_ball(std::vector<int> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    if (n <= 1) return true;\n    \n    int min_idx = 0;\n    for (int i = 1; i < n; i++) {\n        if (arr[i] < arr[min_idx]) {\n            min_idx = i;\n        }\n    }\n    \n    bool is_sorted = true;\n    for (int i = 0; i < n - 1; i++) {\n        int curr_idx = (min_idx + i) % n;\n        int next_idx = (min_idx + i + 1) % n;\n        if (arr[curr_idx] > arr[next_idx]) {\n            is_sorted = false;\n            break;\n        }\n    }\n    \n    return is_sorted;\n}\n```"}
{"task_id": "SimdBench_115", "completion": "```cpp\nbool move_one_ball(std::vector<int> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    if (n == 1) return true;\n    \n    int min_idx = 0;\n    for (int i = 1; i < n; i++) {\n        if (arr[i] < arr[min_idx]) {\n            min_idx = i;\n        }\n    }\n    \n    if (min_idx == 0) {\n        for (int i = 1; i < n; i++) {\n            if (arr[i] < arr[i-1]) return false;\n        }\n        return true;\n    }\n    \n    if (min_idx == n-1) {\n        for (int i = 1; i < n-1; i++) {\n            if (arr[i] < arr[i-1]) return false;\n        }\n        if (arr[0] < arr[n-2]) return false;\n        return true;\n    }\n    \n    for (int i = min_idx; i < n-1; i++) {\n        if (arr[i+1] < arr[i]) return false;\n    }\n    for (int i = 0; i < min_idx-1; i++) {\n        if (arr[i+1] < arr[i]) return false;\n    }\n    if (arr[0] < arr[n-1]) return false;\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_115", "completion": "```cpp\nbool move_one_ball(std::vector<int> arr) {\n    if (arr.empty()) return true;\n    \n    int n = arr.size();\n    int min_idx = 0;\n    for (int i = 1; i < n; i++) {\n        if (arr[i] < arr[min_idx]) {\n            min_idx = i;\n        }\n    }\n    \n    for (int i = 0; i < n - 1; i++) {\n        if (arr[(min_idx + i) % n] > arr[(min_idx + i + 1) % n]) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_115", "completion": "```cpp\nbool move_one_ball(std::vector<int> arr) {\n    if (arr.empty()) return true;\n    int n = arr.size();\n    if (n == 1) return true;\n    \n    int min_idx = 0;\n    for (int i = 1; i < n; i++) {\n        if (arr[i] < arr[min_idx]) {\n            min_idx = i;\n        }\n    }\n    \n    if (min_idx == 0) {\n        for (int i = 1; i < n; i++) {\n            if (arr[i] < arr[i-1]) return false;\n        }\n        return true;\n    }\n    \n    if (min_idx == n-1) {\n        for (int i = 1; i < n-1; i++) {\n            if (arr[i] < arr[i-1]) return false;\n        }\n        if (arr[0] < arr[n-2]) return false;\n        return true;\n    }\n    \n    for (int i = min_idx; i < n-1; i++) {\n        if (arr[i+1] < arr[i]) return false;\n    }\n    for (int i = 0; i < min_idx-1; i++) {\n        if (arr[i+1] < arr[i]) return false;\n    }\n    if (arr[0] < arr[n-1]) return false;\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_116", "completion": "```cpp\nstd::string myexchange(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int oddCount1 = 0;\n    int evenCount2 = 0;\n    \n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            oddCount1++;\n        }\n    }\n    \n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            evenCount2++;\n        }\n    }\n    \n    if (evenCount2 >= oddCount1) {\n        return \"YES\";\n    }\n    return \"NO\";\n}\n```"}
{"task_id": "SimdBench_116", "completion": "```cpp\nstd::string myexchange(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int oddCount1 = 0;\n    int evenCount2 = 0;\n    \n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            oddCount1++;\n        }\n    }\n    \n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            evenCount2++;\n        }\n    }\n    \n    if (evenCount2 >= oddCount1) {\n        return \"YES\";\n    }\n    return \"NO\";\n}\n```"}
{"task_id": "SimdBench_116", "completion": "```cpp\nstd::string myexchange(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int oddCount1 = 0;\n    int evenCount2 = 0;\n    \n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            oddCount1++;\n        }\n    }\n    \n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            evenCount2++;\n        }\n    }\n    \n    if (evenCount2 >= oddCount1) {\n        return \"YES\";\n    }\n    return \"NO\";\n}\n```"}
{"task_id": "SimdBench_116", "completion": "```cpp\nstd::string myexchange(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int oddCount1 = 0;\n    int evenCount2 = 0;\n    \n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            oddCount1++;\n        }\n    }\n    \n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            evenCount2++;\n        }\n    }\n    \n    if (evenCount2 >= oddCount1) {\n        return \"YES\";\n    }\n    return \"NO\";\n}\n```"}
{"task_id": "SimdBench_116", "completion": "```cpp\nstd::string myexchange(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int count_odd1 = 0;\n    int count_even2 = 0;\n    \n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            count_odd1++;\n        }\n    }\n    \n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            count_even2++;\n        }\n    }\n    \n    if (count_even2 >= count_odd1) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_117", "completion": "```cpp\nstd::vector<std::string> odd_count(const std::vector<std::string>& lst) {\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        int oddCount = 0;\n        for (char c : str) {\n            if ((c - '0') % 2 == 1) {\n                oddCount++;\n            }\n        }\n        std::string output = \"the number of odd elements xn the strxng x of the xnput.\";\n        for (char& c : output) {\n            if (c == 'x') {\n                c = '0' + oddCount;\n            }\n        }\n        result.push_back(output);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117", "completion": "```cpp\nstd::vector<std::string> odd_count(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        int odd_count = 0;\n        for (char c : lst[i]) {\n            if ((c - '0') % 2 == 1) {\n                odd_count++;\n            }\n        }\n        std::string s = \"the number of odd elements \" + std::to_string(odd_count) + \n                        \"n the str\" + std::to_string(odd_count) + \n                        \"ng \" + std::to_string(odd_count) + \n                        \" of the \" + std::to_string(odd_count) + \"nput.\";\n        result.push_back(s);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117", "completion": "```cpp\nstd::vector<std::string> odd_count(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        int odd_count = 0;\n        for (char c : lst[i]) {\n            if ((c - '0') % 2 != 0) {\n                odd_count++;\n            }\n        }\n        std::string s = \"the number of odd elements \" + std::to_string(odd_count) + \n                       \"n the str\" + std::to_string(odd_count) + \n                       \"ng \" + std::to_string(odd_count) + \n                       \" of the \" + std::to_string(odd_count) + \"nput.\";\n        result.push_back(s);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117", "completion": "```cpp\nstd::vector<std::string> odd_count(const std::vector<std::string>& lst) {\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        int oddCount = 0;\n        for (char c : str) {\n            if ((c - '0') % 2 == 1) {\n                oddCount++;\n            }\n        }\n        std::string output = \"the number of odd elements xn the strxng x of the xnput.\";\n        for (char& c : output) {\n            if (c == 'x') {\n                c = '0' + oddCount;\n            }\n        }\n        result.push_back(output);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117", "completion": "```cpp\nstd::vector<std::string> odd_count(const std::vector<std::string>& lst) {\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        int oddCount = 0;\n        for (char c : str) {\n            if ((c - '0') % 2 == 1) {\n                oddCount++;\n            }\n        }\n        std::string output = \"the number of odd elements xn the strxng x of the xnput.\";\n        for (char& c : output) {\n            if (c == 'x') {\n                c = '0' + oddCount;\n            }\n        }\n        result.push_back(output);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_118", "completion": "```cpp\nint64_t minSubArraySum(const std::vector<int64_t>& nums) {\n    int64_t min_sum = nums[0];\n    int64_t curr_sum = nums[0];\n    \n    for (size_t i = 1; i < nums.size(); ++i) {\n        curr_sum = std::min(nums[i], curr_sum + nums[i]);\n        min_sum = std::min(min_sum, curr_sum);\n    }\n    \n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118", "completion": "```cpp\nint64_t minSubArraySum(const std::vector<int64_t>& nums) {\n    int64_t minSum = nums[0];\n    int64_t currentSum = nums[0];\n    \n    for (size_t i = 1; i < nums.size(); ++i) {\n        currentSum = std::min(nums[i], currentSum + nums[i]);\n        minSum = std::min(minSum, currentSum);\n    }\n    \n    return minSum;\n}\n```"}
{"task_id": "SimdBench_118", "completion": "```cpp\nint64_t minSubArraySum(const std::vector<int64_t>& nums) {\n    if (nums.empty()) return 0;\n    \n    int64_t minSum = nums[0];\n    int64_t currentSum = nums[0];\n    \n    for (size_t i = 1; i < nums.size(); ++i) {\n        currentSum = std::min(nums[i], currentSum + nums[i]);\n        minSum = std::min(minSum, currentSum);\n    }\n    \n    return minSum;\n}\n```"}
{"task_id": "SimdBench_118", "completion": "```cpp\nint64_t minSubArraySum(const std::vector<int64_t>& nums) {\n    int64_t minSum = nums[0];\n    int64_t currentSum = nums[0];\n    \n    for (size_t i = 1; i < nums.size(); ++i) {\n        currentSum = std::min(nums[i], currentSum + nums[i]);\n        minSum = std::min(minSum, currentSum);\n    }\n    \n    return minSum;\n}\n```"}
{"task_id": "SimdBench_118", "completion": "```cpp\nint64_t minSubArraySum(const std::vector<int64_t>& nums) {\n    int64_t minSum = nums[0];\n    int64_t currentSum = nums[0];\n    \n    for (size_t i = 1; i < nums.size(); ++i) {\n        currentSum = std::min(nums[i], currentSum + nums[i]);\n        minSum = std::min(minSum, currentSum);\n    }\n    \n    return minSum;\n}\n```"}
{"task_id": "SimdBench_119", "completion": "```cpp\nint max_fill(const std::vector<std::vector<int>>& grid, int capacity) {\n    int rows = grid.size();\n    if (rows == 0) return 0;\n    int cols = grid[0].size();\n    int total_lowers = 0;\n    \n    for (int j = 0; j < cols; j++) {\n        int water_in_column = 0;\n        for (int i = 0; i < rows; i++) {\n            water_in_column += grid[i][j];\n        }\n        if (water_in_column > 0) {\n            total_lowers += (water_in_column + capacity - 1) / capacity;\n        }\n    }\n    \n    return total_lowers;\n}\n```"}
{"task_id": "SimdBench_119", "completion": "```cpp\nint max_fill(const std::vector<std::vector<int>>& grid, int capacity) {\n    int total_lowers = 0;\n    int rows = grid.size();\n    if (rows == 0) return 0;\n    int cols = grid[0].size();\n    \n    for (int j = 0; j < cols; ++j) {\n        int water_in_column = 0;\n        for (int i = 0; i < rows; ++i) {\n            water_in_column += grid[i][j];\n        }\n        if (water_in_column > 0) {\n            total_lowers += (water_in_column + capacity - 1) / capacity;\n        }\n    }\n    \n    return total_lowers;\n}\n```"}
{"task_id": "SimdBench_119", "completion": "```cpp\nint max_fill(const std::vector<std::vector<int>>& grid, int capacity) {\n    int rows = grid.size();\n    if (rows == 0) return 0;\n    int cols = grid[0].size();\n    int totalLowerings = 0;\n    \n    // Iterate through each column (well)\n    for (int j = 0; j < cols; ++j) {\n        int waterInWell = 0;\n        // Count total water units in current well\n        for (int i = 0; i < rows; ++i) {\n            waterInWell += grid[i][j];\n        }\n        // Calculate number of times bucket needs to be lowered for this well\n        totalLowerings += (waterInWell + capacity - 1) / capacity;\n    }\n    \n    return totalLowerings;\n}\n```"}
{"task_id": "SimdBench_119", "completion": "```cpp\nint max_fill(const std::vector<std::vector<int>>& grid, int capacity) {\n    int rows = grid.size();\n    if (rows == 0) return 0;\n    int cols = grid[0].size();\n    int total_lowers = 0;\n    \n    for (int j = 0; j < cols; ++j) {\n        int water_in_column = 0;\n        for (int i = 0; i < rows; ++i) {\n            water_in_column += grid[i][j];\n        }\n        if (water_in_column > 0) {\n            total_lowers += (water_in_column + capacity - 1) / capacity;\n        }\n    }\n    \n    return total_lowers;\n}\n```"}
{"task_id": "SimdBench_119", "completion": "```cpp\nint max_fill(const std::vector<std::vector<int>>& grid, int capacity) {\n    int rows = grid.size();\n    if (rows == 0) return 0;\n    int cols = grid[0].size();\n    int total_lowers = 0;\n    \n    for (int j = 0; j < cols; ++j) {\n        int water_in_column = 0;\n        for (int i = 0; i < rows; ++i) {\n            water_in_column += grid[i][j];\n        }\n        if (water_in_column > 0) {\n            total_lowers += (water_in_column + capacity - 1) / capacity;\n        }\n    }\n    \n    return total_lowers;\n}\n```"}
{"task_id": "SimdBench_120", "completion": "```cpp\nint64_t solution(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120", "completion": "```cpp\nint64_t solution(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120", "completion": "```cpp\nint64_t solution(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120", "completion": "```cpp\nint64_t solution(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120", "completion": "```cpp\nint64_t solution(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121", "completion": "```cpp\nint add_elements(std::vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; i++) {\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121", "completion": "```cpp\nint add_elements(std::vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; i++) {\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121", "completion": "```cpp\nint add_elements(std::vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; i++) {\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121", "completion": "```cpp\nint add_elements(std::vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; i++) {\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121", "completion": "```cpp\nint add_elements(std::vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; i++) {\n        if (arr[i] >= 0 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_122", "completion": "```cpp\nbool is_sorted(const std::vector<int>& lst) {\n    if (lst.size() <= 1) return true;\n    \n    for (size_t i = 0; i < lst.size() - 1; ++i) {\n        if (lst[i] > lst[i + 1]) return false;\n    }\n    \n    for (size_t i = 0; i < lst.size() - 2; ++i) {\n        if (lst[i] == lst[i + 1] && lst[i] == lst[i + 2]) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_122", "completion": "```cpp\nbool is_sorted(const std::vector<int>& lst) {\n    if (lst.size() <= 1) return true;\n    \n    for (size_t i = 0; i < lst.size() - 1; ++i) {\n        if (lst[i] > lst[i + 1]) return false;\n        if (i < lst.size() - 2 && lst[i] == lst[i + 1] && lst[i + 1] == lst[i + 2]) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_122", "completion": "```cpp\nbool is_sorted(const std::vector<int>& lst) {\n    if (lst.size() <= 1) return true;\n    \n    for (size_t i = 0; i < lst.size() - 1; ++i) {\n        if (lst[i] > lst[i + 1]) return false;\n        if (i < lst.size() - 2 && lst[i] == lst[i + 1] && lst[i + 1] == lst[i + 2]) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_122", "completion": "```cpp\nbool is_sorted(const std::vector<int>& lst) {\n    if (lst.size() <= 1) return true;\n    \n    for (size_t i = 0; i < lst.size() - 1; ++i) {\n        if (lst[i] > lst[i + 1]) return false;\n    }\n    \n    for (size_t i = 0; i < lst.size() - 2; ++i) {\n        if (lst[i] == lst[i + 1] && lst[i] == lst[i + 2]) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_122", "completion": "```cpp\nbool is_sorted(const std::vector<int>& lst) {\n    if (lst.size() <= 1) return true;\n    \n    for (size_t i = 0; i < lst.size() - 1; ++i) {\n        if (lst[i] > lst[i + 1]) return false;\n        if (i < lst.size() - 2 && lst[i] == lst[i + 1] && lst[i + 1] == lst[i + 2]) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_123", "completion": "```cpp\nint prod_signs(const std::vector<int>& arr) {\n    if (arr.empty()) return -32768;\n    \n    long long sum_magnitudes = 0;\n    long long product_signs = 1;\n    \n    for (int num : arr) {\n        sum_magnitudes += std::abs(num);\n        if (num > 0) {\n            product_signs *= 1;\n        } else if (num < 0) {\n            product_signs *= -1;\n        } else {\n            product_signs *= 0;\n        }\n    }\n    \n    return static_cast<int>(sum_magnitudes * product_signs);\n}\n```"}
{"task_id": "SimdBench_123", "completion": "```cpp\nint prod_signs(const std::vector<int>& arr) {\n    if (arr.empty()) return -32768;\n    \n    long long sum_magnitudes = 0;\n    long long product_signs = 1;\n    \n    for (int num : arr) {\n        if (num == 0) {\n            product_signs = 0;\n        } else {\n            sum_magnitudes += std::abs(num);\n            product_signs *= (num > 0) ? 1 : -1;\n        }\n    }\n    \n    return static_cast<int>(sum_magnitudes * product_signs);\n}\n```"}
{"task_id": "SimdBench_123", "completion": "```cpp\nint prod_signs(const std::vector<int>& arr) {\n    if (arr.empty()) return -32768;\n    \n    long long sum_magnitudes = 0;\n    long long product_signs = 1;\n    \n    for (int num : arr) {\n        sum_magnitudes += std::abs(num);\n        if (num > 0) {\n            product_signs *= 1;\n        } else if (num < 0) {\n            product_signs *= -1;\n        } else {\n            product_signs *= 0;\n        }\n    }\n    \n    return static_cast<int>(sum_magnitudes * product_signs);\n}\n```"}
{"task_id": "SimdBench_123", "completion": "```cpp\nint prod_signs(const std::vector<int>& arr) {\n    if (arr.empty()) return -32768;\n    \n    long long sum_magnitudes = 0;\n    long long product_signs = 1;\n    \n    for (int num : arr) {\n        if (num == 0) {\n            product_signs = 0;\n        } else {\n            sum_magnitudes += std::abs(num);\n            product_signs *= (num > 0 ? 1 : -1);\n        }\n    }\n    \n    return static_cast<int>(sum_magnitudes * product_signs);\n}\n```"}
{"task_id": "SimdBench_123", "completion": "```cpp\nint prod_signs(const std::vector<int>& arr) {\n    if (arr.empty()) return -32768;\n    \n    long long sum_magnitudes = 0;\n    long long product_signs = 1;\n    \n    for (int num : arr) {\n        if (num == 0) {\n            product_signs = 0;\n        } else {\n            sum_magnitudes += std::abs(num);\n            product_signs *= (num > 0 ? 1 : -1);\n        }\n    }\n    \n    return static_cast<int>(sum_magnitudes * product_signs);\n}\n```"}
{"task_id": "SimdBench_124", "completion": "```cpp\nstd::vector<int> minPath(const std::vector<std::vector<int>>& grid, int k) {\n    int n = grid.size();\n    if (k == 1) {\n        int minVal = INT_MAX;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                minVal = std::min(minVal, grid[i][j]);\n            }\n        }\n        return {minVal};\n    }\n    \n    using State = std::tuple<int, int, int, std::vector<int>>;\n    auto cmp = [](const State& a, const State& b) {\n        return std::get<3>(a) > std::get<3>(b);\n    };\n    std::priority_queue<State, std::vector<State>, decltype(cmp)> pq(cmp);\n    \n    std::set<std::tuple<int, int, std::vector<int>>> visited;\n    \n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            std::vector<int> path = {grid[i][j]};\n            pq.push({i, j, 1, path});\n        }\n    }\n    \n    int dx[4] = {0, 0, 1, -1};\n    int dy[4] = {1, -1, 0, 0};\n    \n    while (!pq.empty()) {\n        auto [x, y, len, path] = pq.top();\n        pq.pop();\n        \n        if (len == k) {\n            return path;\n        }\n        \n        for (int d = 0; d < 4; ++d) {\n            int nx = x + dx[d];\n            int ny = y + dy[d];\n            if (nx >= 0 && nx < n && ny >= 0 && ny < n) {\n                std::vector<int> newPath = path;\n                newPath.push_back(grid[nx][ny]);\n                auto state = std::make_tuple(nx, ny, newPath);\n                if (visited.find(state) == visited.end()) {\n                    visited.insert(state);\n                    pq.push({nx, ny, len + 1, newPath});\n                }\n            }\n        }\n    }\n    return {};\n}\n```"}
{"task_id": "SimdBench_124", "completion": "```cpp\nstd::vector<int> minPath(const std::vector<std::vector<int>>& grid, int k) {\n    int n = grid.size();\n    if (k == 1) {\n        int minVal = INT_MAX;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                minVal = std::min(minVal, grid[i][j]);\n            }\n        }\n        return {minVal};\n    }\n    \n    std::vector<int> result;\n    int minVal = INT_MAX;\n    int startI = 0, startJ = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (grid[i][j] < minVal) {\n                minVal = grid[i][j];\n                startI = i;\n                startJ = j;\n            }\n        }\n    }\n    \n    result.push_back(minVal);\n    int currI = startI, currJ = startJ;\n    std::vector<std::pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    \n    for (int step = 1; step < k; ++step) {\n        int nextVal = INT_MAX;\n        int nextI = currI, nextJ = currJ;\n        for (auto& dir : directions) {\n            int ni = currI + dir.first;\n            int nj = currJ + dir.second;\n            if (ni >= 0 && ni < n && nj >= 0 && nj < n && grid[ni][nj] < nextVal) {\n                nextVal = grid[ni][nj];\n                nextI = ni;\n                nextJ = nj;\n            }\n        }\n        result.push_back(nextVal);\n        currI = nextI;\n        currJ = nextJ;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_124", "completion": "```cpp\nstd::vector<int> minPath(const std::vector<std::vector<int>>& grid, int k) {\n    int n = grid.size();\n    if (k == 1) {\n        int minVal = INT_MAX;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                minVal = std::min(minVal, grid[i][j]);\n            }\n        }\n        return {minVal};\n    }\n    \n    std::vector<int> result;\n    int minVal = INT_MAX;\n    int startI = 0, startJ = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (grid[i][j] < minVal) {\n                minVal = grid[i][j];\n                startI = i;\n                startJ = j;\n            }\n        }\n    }\n    \n    result.push_back(minVal);\n    int currentI = startI;\n    int currentJ = startJ;\n    std::vector<std::pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    \n    for (int step = 1; step < k; ++step) {\n        int nextVal = INT_MAX;\n        int nextI = currentI;\n        int nextJ = currentJ;\n        for (auto& dir : directions) {\n            int ni = currentI + dir.first;\n            int nj = currentJ + dir.second;\n            if (ni >= 0 && ni < n && nj >= 0 && nj < n) {\n                if (grid[ni][nj] < nextVal) {\n                    nextVal = grid[ni][nj];\n                    nextI = ni;\n                    nextJ = nj;\n                }\n            }\n        }\n        result.push_back(nextVal);\n        currentI = nextI;\n        currentJ = nextJ;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_124", "completion": "```cpp\nstd::vector<int> minPath(const std::vector<std::vector<int>>& grid, int k) {\n    int n = grid.size();\n    if (k == 1) {\n        int minVal = INT_MAX;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                minVal = std::min(minVal, grid[i][j]);\n            }\n        }\n        return {minVal};\n    }\n    \n    using State = std::tuple<int, int, int, std::vector<int>>;\n    auto cmp = [](const State& a, const State& b) {\n        return std::get<3>(a) > std::get<3>(b);\n    };\n    std::priority_queue<State, std::vector<State>, decltype(cmp)> pq(cmp);\n    \n    std::set<std::tuple<int, int, std::vector<int>>> visited;\n    \n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            std::vector<int> path = {grid[i][j]};\n            pq.push({i, j, 1, path});\n        }\n    }\n    \n    int dx[4] = {0, 0, 1, -1};\n    int dy[4] = {1, -1, 0, 0};\n    \n    while (!pq.empty()) {\n        auto [x, y, len, path] = pq.top();\n        pq.pop();\n        \n        if (len == k) {\n            return path;\n        }\n        \n        for (int d = 0; d < 4; ++d) {\n            int nx = x + dx[d];\n            int ny = y + dy[d];\n            if (nx >= 0 && nx < n && ny >= 0 && ny < n) {\n                std::vector<int> newPath = path;\n                newPath.push_back(grid[nx][ny]);\n                auto state = std::make_tuple(nx, ny, newPath);\n                if (visited.find(state) == visited.end()) {\n                    visited.insert(state);\n                    pq.push({nx, ny, len + 1, newPath});\n                }\n            }\n        }\n    }\n    return {};\n}\n```"}
{"task_id": "SimdBench_124", "completion": "```cpp\nstd::vector<int> minPath(const std::vector<std::vector<int>>& grid, int k) {\n    int n = grid.size();\n    if (k == 1) {\n        int minVal = INT_MAX;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                minVal = std::min(minVal, grid[i][j]);\n            }\n        }\n        return {minVal};\n    }\n    \n    using State = std::tuple<int, int, int, std::vector<int>>;\n    auto cmp = [](const State& a, const State& b) {\n        return std::get<3>(a) > std::get<3>(b);\n    };\n    std::priority_queue<State, std::vector<State>, decltype(cmp)> pq(cmp);\n    \n    std::vector<std::vector<bool>> visited(n, std::vector<bool>(n, false));\n    int dx[4] = {0, 0, 1, -1};\n    int dy[4] = {1, -1, 0, 0};\n    \n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            pq.push({i, j, 1, {grid[i][j]}});\n        }\n    }\n    \n    while (!pq.empty()) {\n        auto [x, y, steps, path] = pq.top();\n        pq.pop();\n        \n        if (steps == k) {\n            return path;\n        }\n        \n        for (int d = 0; d < 4; ++d) {\n            int nx = x + dx[d];\n            int ny = y + dy[d];\n            if (nx >= 0 && nx < n && ny >= 0 && ny < n) {\n                std::vector<int> newPath = path;\n                newPath.push_back(grid[nx][ny]);\n                pq.push({nx, ny, steps + 1, newPath});\n            }\n        }\n    }\n    \n    return {};\n}\n```"}
{"task_id": "SimdBench_125", "completion": "```c\nuint64_t digits(uint64_t n) {\n    uint64_t product = 1;\n    int has_odd = 0;\n    \n    while (n > 0) {\n        uint64_t digit = n % 10;\n        if (digit % 2 == 1) {\n            product *= digit;\n            has_odd = 1;\n        }\n        n /= 10;\n    }\n    \n    return has_odd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_125", "completion": "```c\nuint64_t digits(uint64_t n) {\n    uint64_t product = 1;\n    int has_odd = 0;\n    \n    while (n > 0) {\n        uint64_t digit = n % 10;\n        if (digit % 2 == 1) {\n            product *= digit;\n            has_odd = 1;\n        }\n        n /= 10;\n    }\n    \n    return has_odd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_125", "completion": "```c\nuint64_t digits(uint64_t n) {\n    uint64_t product = 1;\n    int has_odd = 0;\n    \n    while (n > 0) {\n        uint64_t digit = n % 10;\n        if (digit % 2 == 1) {\n            product *= digit;\n            has_odd = 1;\n        }\n        n /= 10;\n    }\n    \n    return has_odd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_125", "completion": "```c\nuint64_t digits(uint64_t n) {\n    uint64_t product = 1;\n    int has_odd = 0;\n    \n    while (n > 0) {\n        uint64_t digit = n % 10;\n        if (digit % 2 == 1) {\n            product *= digit;\n            has_odd = 1;\n        }\n        n /= 10;\n    }\n    \n    return has_odd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_125", "completion": "```c\nuint64_t digits(uint64_t n) {\n    uint64_t product = 1;\n    int has_odd = 0;\n    \n    while (n > 0) {\n        uint64_t digit = n % 10;\n        if (digit % 2 == 1) {\n            product *= digit;\n            has_odd = 1;\n        }\n        n /= 10;\n    }\n    \n    return has_odd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_126", "completion": "```cpp\nuint64_t sum_squares(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    for (float num : lst) {\n        int ceil_num = static_cast<int>(std::ceil(num));\n        sum += static_cast<uint64_t>(ceil_num * ceil_num);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126", "completion": "```cpp\nuint64_t sum_squares(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    for (float num : lst) {\n        int ceil_num = static_cast<int>(std::ceil(num));\n        sum += static_cast<uint64_t>(ceil_num * ceil_num);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126", "completion": "```cpp\nuint64_t sum_squares(const std::vector<float>& lst) {\n    uint64_t sum = 0;\n    for (float num : lst) {\n        int ceil_num = static_cast<int>(std::ceil(num));\n        sum += static_cast<uint64_t>(ceil_num * ceil_num);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126", "completion": "```cpp\nuint64_t sum_squares(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    for (float num : lst) {\n        int ceil_num = static_cast<int>(std::ceil(num));\n        sum += static_cast<uint64_t>(ceil_num * ceil_num);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126", "completion": "```cpp\nuint64_t sum_squares(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    for (float num : lst) {\n        int ceil_num = static_cast<int>(std::ceil(num));\n        sum += static_cast<uint64_t>(ceil_num * ceil_num);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_127", "completion": "```cpp\nint can_arrange(const std::vector<int>& arr) {\n    for (size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            return static_cast<int>(i);\n        }\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_127", "completion": "```cpp\nint can_arrange(const std::vector<int>& arr) {\n    for (size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            return static_cast<int>(i);\n        }\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_127", "completion": "```cpp\nint can_arrange(const std::vector<int>& arr) {\n    for (size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            return static_cast<int>(i);\n        }\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_127", "completion": "```cpp\nint can_arrange(const std::vector<int>& arr) {\n    for (size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            return static_cast<int>(i);\n        }\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_127", "completion": "```cpp\nint can_arrange(const std::vector<int>& arr) {\n    for (size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            return static_cast<int>(i);\n        }\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_128", "completion": "```cpp\nstd::vector<int> largest_smallest_integers(const std::vector<int>& lst) {\n    int largest_negative = 0;\n    int smallest_positive = 0;\n    \n    for (int num : lst) {\n        if (num < 0 && (largest_negative == 0 || num > largest_negative)) {\n            largest_negative = num;\n        }\n        if (num > 0 && (smallest_positive == 0 || num < smallest_positive)) {\n            smallest_positive = num;\n        }\n    }\n    \n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_128", "completion": "```cpp\nstd::vector<int> largest_smallest_integers(const std::vector<int>& lst) {\n    int largest_negative = 0;\n    int smallest_positive = 0;\n    \n    for (int num : lst) {\n        if (num < 0 && (largest_negative == 0 || num > largest_negative)) {\n            largest_negative = num;\n        }\n        if (num > 0 && (smallest_positive == 0 || num < smallest_positive)) {\n            smallest_positive = num;\n        }\n    }\n    \n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_128", "completion": "```cpp\nstd::vector<int> largest_smallest_integers(const std::vector<int>& lst) {\n    int largest_neg = 0;\n    int smallest_pos = 0;\n    \n    for (int num : lst) {\n        if (num < 0 && (largest_neg == 0 || num > largest_neg)) {\n            largest_neg = num;\n        }\n        if (num > 0 && (smallest_pos == 0 || num < smallest_pos)) {\n            smallest_pos = num;\n        }\n    }\n    \n    return {largest_neg, smallest_pos};\n}\n```"}
{"task_id": "SimdBench_128", "completion": "```cpp\nstd::vector<int> largest_smallest_integers(const std::vector<int>& lst) {\n    int largest_negative = 0;\n    int smallest_positive = 0;\n    \n    for (int num : lst) {\n        if (num < 0 && (largest_negative == 0 || num > largest_negative)) {\n            largest_negative = num;\n        }\n        if (num > 0 && (smallest_positive == 0 || num < smallest_positive)) {\n            smallest_positive = num;\n        }\n    }\n    \n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_128", "completion": "```cpp\nstd::vector<int> largest_smallest_integers(const std::vector<int>& lst) {\n    int largestNegative = 0;\n    int smallestPositive = 0;\n    \n    for (int num : lst) {\n        if (num < 0 && (largestNegative == 0 || num > largestNegative)) {\n            largestNegative = num;\n        }\n        if (num > 0 && (smallestPositive == 0 || num < smallestPositive)) {\n            smallestPositive = num;\n        }\n    }\n    \n    return {largestNegative, smallestPositive};\n}\n```"}
{"task_id": "SimdBench_129", "completion": "```c\nuint64_t special_factorial(uint64_t n) {\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; i++) {\n        uint64_t factorial = 1;\n        for (uint64_t j = 1; j <= i; j++) {\n            factorial *= j;\n        }\n        result *= factorial;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_129", "completion": "```c\nuint64_t special_factorial(uint64_t n) {\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; i++) {\n        uint64_t factorial = 1;\n        for (uint64_t j = 1; j <= i; j++) {\n            factorial *= j;\n        }\n        result *= factorial;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_129", "completion": "```c\nuint64_t special_factorial(uint64_t n) {\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; i++) {\n        uint64_t factorial = 1;\n        for (uint64_t j = 1; j <= i; j++) {\n            factorial *= j;\n        }\n        result *= factorial;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_129", "completion": "```c\nuint64_t special_factorial(uint64_t n) {\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; i++) {\n        uint64_t factorial = 1;\n        for (uint64_t j = 1; j <= i; j++) {\n            factorial *= j;\n        }\n        result *= factorial;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_129", "completion": "```c\nuint64_t special_factorial(uint64_t n) {\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; i++) {\n        uint64_t factorial = 1;\n        for (uint64_t j = 1; j <= i; j++) {\n            factorial *= j;\n        }\n        result *= factorial;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_130", "completion": "```cpp\nint sum_squares(const std::vector<int> & lst){\n    long long sum = 0;\n    for(size_t i = 0; i < lst.size(); ++i){\n        if(i % 3 == 0){\n            sum += static_cast<long long>(lst[i]) * lst[i];\n        }\n        else if(i % 4 == 0){\n            sum += static_cast<long long>(lst[i]) * lst[i] * lst[i];\n        }\n        else{\n            sum += lst[i];\n        }\n    }\n    return static_cast<int>(sum);\n}\n```"}
{"task_id": "SimdBench_130", "completion": "```cpp\nint sum_squares(const std::vector<int> & lst) {\n    long long sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            sum += static_cast<long long>(lst[i]) * lst[i];\n        } else if (i % 4 == 0) {\n            sum += static_cast<long long>(lst[i]) * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n    return static_cast<int>(sum);\n}\n```"}
{"task_id": "SimdBench_130", "completion": "```cpp\nint sum_squares(const std::vector<int> & lst) {\n    long long sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0 && i % 4 == 0) {\n            sum += static_cast<long long>(lst[i]) * lst[i] * lst[i];\n        }\n        else if (i % 3 == 0) {\n            sum += static_cast<long long>(lst[i]) * lst[i];\n        }\n        else if (i % 4 == 0) {\n            sum += static_cast<long long>(lst[i]) * lst[i] * lst[i];\n        }\n        else {\n            sum += lst[i];\n        }\n    }\n    return static_cast<int>(sum);\n}\n```"}
{"task_id": "SimdBench_130", "completion": "```cpp\nint sum_squares(const std::vector<int> & lst) {\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0 && i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        }\n        else if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        }\n        else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        }\n        else {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130", "completion": "```cpp\nint sum_squares(const std::vector<int> & lst){\n    int sum = 0;\n    for(size_t i = 0; i < lst.size(); i++){\n        if(i % 3 == 0){\n            sum += lst[i] * lst[i];\n        }\n        else if(i % 4 == 0){\n            sum += lst[i] * lst[i] * lst[i];\n        }\n        else{\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_131", "completion": "```cpp\nint specialFilter(const std::vector<int>& nums) {\n    int count = 0;\n    for (int num : nums) {\n        if (num > 10) {\n            std::string numStr = std::to_string(std::abs(num));\n            int firstDigit = numStr[0] - '0';\n            int lastDigit = numStr.back() - '0';\n            if (firstDigit % 2 == 1 && lastDigit % 2 == 1) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_131", "completion": "```cpp\nint specialFilter(const std::vector<int>& nums) {\n    int count = 0;\n    for (int num : nums) {\n        if (num > 10) {\n            std::string numStr = std::to_string(std::abs(num));\n            int firstDigit = numStr[0] - '0';\n            int lastDigit = numStr.back() - '0';\n            if (firstDigit % 2 == 1 && lastDigit % 2 == 1) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_131", "completion": "```cpp\nint specialFilter(const std::vector<int>& nums) {\n    int count = 0;\n    for (int num : nums) {\n        if (num > 10) {\n            std::string numStr = std::to_string(std::abs(num));\n            char firstDigit = numStr[0];\n            char lastDigit = numStr.back();\n            if ((firstDigit - '0') % 2 == 1 && (lastDigit - '0') % 2 == 1) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_131", "completion": "```cpp\nint specialFilter(const std::vector<int>& nums) {\n    int count = 0;\n    for (int num : nums) {\n        if (num > 10) {\n            std::string numStr = std::to_string(std::abs(num));\n            char firstDigit = numStr[0];\n            char lastDigit = numStr.back();\n            if ((firstDigit - '0') % 2 == 1 && (lastDigit - '0') % 2 == 1) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_131", "completion": "```cpp\nint specialFilter(const std::vector<int>& nums) {\n    int count = 0;\n    for (int num : nums) {\n        if (num > 10) {\n            std::string numStr = std::to_string(std::abs(num));\n            int firstDigit = numStr[0] - '0';\n            int lastDigit = numStr.back() - '0';\n            if (firstDigit % 2 == 1 && lastDigit % 2 == 1) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_132", "completion": "```cpp\nuint64_t get_max_triples(uint64_t n) {\n    if (n < 3) return 0;\n    \n    // Count numbers in each remainder class modulo 3\n    uint64_t count[3] = {0};\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t val = i * i - i + 1;\n        count[val % 3]++;\n    }\n    \n    // Calculate total triples for each combination of remainders that sum to multiple of 3\n    uint64_t result = 0;\n    \n    // Case 1: All three numbers have remainder 0\n    result += (count[0] * (count[0] - 1) * (count[0] - 2)) / 6;\n    \n    // Case 2: All three numbers have remainder 1\n    result += (count[1] * (count[1] - 1) * (count[1] - 2)) / 6;\n    \n    // Case 3: All three numbers have remainder 2\n    result += (count[2] * (count[2] - 1) * (count[2] - 2)) / 6;\n    \n    // Case 4: One number from each remainder class (0,1,2)\n    result += count[0] * count[1] * count[2];\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_132", "completion": "```cpp\nuint64_t get_max_triples(uint64_t n) {\n    if (n < 3) return 0;\n    \n    // Count numbers in each remainder class modulo 3\n    uint64_t count[3] = {0};\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t val = i * i - i + 1;\n        count[val % 3]++;\n    }\n    \n    // Calculate combinations for each possible triplet of remainders that sum to 0 mod 3\n    uint64_t result = 0;\n    \n    // Case 1: All three numbers have remainder 0\n    result += (count[0] * (count[0] - 1) * (count[0] - 2)) / 6;\n    \n    // Case 2: All three numbers have remainder 1\n    result += (count[1] * (count[1] - 1) * (count[1] - 2)) / 6;\n    \n    // Case 3: All three numbers have remainder 2\n    result += (count[2] * (count[2] - 1) * (count[2] - 2)) / 6;\n    \n    // Case 4: One number from each remainder class (0,1,2)\n    result += count[0] * count[1] * count[2];\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_132", "completion": "```cpp\nuint64_t get_max_triples(uint64_t n) {\n    if (n < 3) return 0;\n    \n    // Count numbers in each remainder class modulo 3\n    uint64_t count[3] = {0};\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t val = i * i - i + 1;\n        count[val % 3]++;\n    }\n    \n    // Calculate total number of valid triples\n    uint64_t result = 0;\n    \n    // Case 1: All three numbers have remainder 0\n    result += (count[0] * (count[0] - 1) * (count[0] - 2)) / 6;\n    \n    // Case 2: All three numbers have remainder 1\n    result += (count[1] * (count[1] - 1) * (count[1] - 2)) / 6;\n    \n    // Case 3: All three numbers have remainder 2\n    result += (count[2] * (count[2] - 1) * (count[2] - 2)) / 6;\n    \n    // Case 4: One number from each remainder class (0,1,2)\n    result += count[0] * count[1] * count[2];\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_132", "completion": "```cpp\nuint64_t get_max_triples(uint64_t n) {\n    if (n < 3) return 0;\n    \n    // Count numbers in each remainder class modulo 3\n    uint64_t count[3] = {0};\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t val = i * i - i + 1;\n        count[val % 3]++;\n    }\n    \n    // Calculate total valid triples\n    uint64_t result = 0;\n    \n    // Case 1: All three numbers have remainder 0\n    result += (count[0] * (count[0] - 1) * (count[0] - 2)) / 6;\n    \n    // Case 2: All three numbers have remainder 1\n    result += (count[1] * (count[1] - 1) * (count[1] - 2)) / 6;\n    \n    // Case 3: All three numbers have remainder 2\n    result += (count[2] * (count[2] - 1) * (count[2] - 2)) / 6;\n    \n    // Case 4: One number from each remainder class (0,1,2)\n    result += count[0] * count[1] * count[2];\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_132", "completion": "```cpp\nuint64_t get_max_triples(uint64_t n) {\n    if (n < 3) return 0;\n    \n    uint64_t count[3] = {0};\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t val = i * i - i + 1;\n        count[val % 3]++;\n    }\n    \n    uint64_t result = 0;\n    result += count[0] * (count[0] - 1) * (count[0] - 2) / 6;\n    result += count[1] * count[2] * count[0];\n    result += count[1] * (count[1] - 1) * (count[1] - 2) / 6;\n    result += count[2] * (count[2] - 1) * (count[2] - 2) / 6;\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_133", "completion": "```c\nint x_or_y(int n, int x, int y) {\n    if (n <= 1) return y;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return y;\n    }\n    return x;\n}\n```"}
{"task_id": "SimdBench_133", "completion": "```c\nint x_or_y(int n, int x, int y) {\n    if (n <= 1) return y;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return y;\n    }\n    return x;\n}\n```"}
{"task_id": "SimdBench_133", "completion": "```c\nint x_or_y(int n, int x, int y) {\n    if (n <= 1) return y;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return y;\n    }\n    return x;\n}\n```"}
{"task_id": "SimdBench_133", "completion": "```c\nint x_or_y(int n, int x, int y) {\n    int is_prime = 1;\n    if (n <= 1) {\n        is_prime = 0;\n    }\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) {\n            is_prime = 0;\n            break;\n        }\n    }\n    return is_prime ? x : y;\n}\n```"}
{"task_id": "SimdBench_133", "completion": "```c\nint x_or_y(int n, int x, int y) {\n    if (n <= 1) return y;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return y;\n    }\n    return x;\n}\n```"}
{"task_id": "SimdBench_134", "completion": "```cpp\nuint64_t double_the_difference(const std::vector<float>& lst) {\n    uint64_t sum = 0;\n    for (float num : lst) {\n        if (num > 0 && num == static_cast<int>(num) && static_cast<int>(num) % 2 == 1) {\n            sum += static_cast<uint64_t>(num * num);\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134", "completion": "```cpp\nuint64_t double_the_difference(const std::vector<float>& lst) {\n    uint64_t sum = 0;\n    for (float num : lst) {\n        if (num > 0 && num == static_cast<int>(num) && static_cast<int>(num) % 2 == 1) {\n            sum += static_cast<uint64_t>(num * num);\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134", "completion": "```cpp\nuint64_t double_the_difference(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    for (float num : lst) {\n        if (num > 0 && num == static_cast<int>(num) && static_cast<int>(num) % 2 == 1) {\n            sum += static_cast<uint64_t>(num * num);\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134", "completion": "```cpp\nuint64_t double_the_difference(const std::vector<float>& lst) {\n    uint64_t sum = 0;\n    for (float num : lst) {\n        if (num > 0 && num == static_cast<int>(num) && static_cast<int>(num) % 2 == 1) {\n            sum += static_cast<uint64_t>(num * num);\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134", "completion": "```cpp\nuint64_t double_the_difference(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    for (float num : lst) {\n        if (num > 0 && num == static_cast<int>(num) && static_cast<int>(num) % 2 == 1) {\n            sum += static_cast<uint64_t>(num * num);\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_135", "completion": "```cpp\nstd::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result;\n    for(size_t i = 0; i < game.size(); i++) {\n        result.push_back(std::abs(game[i] - guess[i]));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135", "completion": "```cpp\nstd::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result;\n    for(size_t i = 0; i < game.size(); i++) {\n        result.push_back(std::abs(game[i] - guess[i]));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135", "completion": "```cpp\nstd::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result;\n    for(size_t i = 0; i < game.size(); i++) {\n        result.push_back(std::abs(game[i] - guess[i]));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135", "completion": "```cpp\nstd::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result;\n    for(size_t i = 0; i < game.size(); i++) {\n        result.push_back(std::abs(game[i] - guess[i]));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135", "completion": "```cpp\nstd::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result;\n    for(size_t i = 0; i < game.size(); i++) {\n        result.push_back(std::abs(game[i] - guess[i]));\n    }\n    return result;\n}\n```"}

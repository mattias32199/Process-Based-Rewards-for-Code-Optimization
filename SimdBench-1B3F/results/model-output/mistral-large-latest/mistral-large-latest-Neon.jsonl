{"task_id": "SimdBench_0_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i;\n    for (i = 0; i <= length - 2; i += 2) {\n        uint64x2_t vmask = vld1q_dup_u64((uint64_t *)(&mask[i]));\n        uint64x2_t vsrc = vld1q_u64((uint64_t *)(&src[i]));\n        uint64x2_t vdst = vld1q_u64((uint64_t *)(&dst[i]));\n\n        uint64x2_t vresult = vbslq_u64(vmask, vsrc, vdst);\n        vst1q_u64((uint64_t *)(&dst[i]), vresult);\n    }\n\n    for (; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i;\n    for (i = 0; i <= length - 2; i += 2) {\n        uint64x2_t src_val = vld1q_u64((const uint64_t *)&src[i]);\n        uint64x2_t dst_val = vld1q_u64((uint64_t *)&dst[i]);\n        uint64x2_t mask_val = vld1q_u64((const uint64_t *)&mask[i]);\n\n        uint64x2_t result = vbslq_u64(mask_val, src_val, dst_val);\n        vst1q_u64((uint64_t *)&dst[i], result);\n    }\n\n    if (i < length) {\n        dst[i] = mask[i] ? src[i] : dst[i];\n    }\n}\n```"}
{"task_id": "SimdBench_0_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i;\n    for (i = 0; i <= length - 2; i += 2) {\n        uint64x2_t src_val = vld1q_dup_s64((const int64_t *)&src[i]);\n        uint64x2_t dst_val = vld1q_dup_s64((const int64_t *)&dst[i]);\n        uint64x2_t mask_val = vld1q_dup_u64((const uint64_t *)&mask[i]);\n\n        uint64x2_t result = vbslq_u64(mask_val, src_val, dst_val);\n\n        vst1q_s64((int64_t *)&dst[i], result);\n    }\n\n    if (i < length) {\n        dst[i] = mask[i] ? src[i] : dst[i];\n    }\n}\n```"}
{"task_id": "SimdBench_0_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i;\n    for (i = 0; i <= length - 2; i += 2) {\n        uint64x2_t vmask = vld1q_dup_u64((uint64_t*)&mask[i]);\n        int64x2_t vsrc = vld1q_s64(&src[i]);\n        int64x2_t vdst = vld1q_s64(&dst[i]);\n\n        uint64x2_t vmask_and = vandq_u64(vmask, vreinterpretq_u64_s64(vsrc));\n        int64x2_t vresult = vorrq_s64(vdst, vreinterpretq_s64_u64(vmask_and));\n\n        vst1q_s64(&dst[i], vresult);\n    }\n\n    for (; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i;\n    for (i = 0; i <= length - 2; i += 2) {\n        uint64x2_t src_val = vld1q_u64((uint64_t *)&src[i]);\n        uint64x2_t dst_val = vld1q_u64((uint64_t *)&dst[i]);\n        uint64x2_t mask_val = vld1q_u64((uint64_t *)&mask[i]);\n\n        uint64x2_t result = vbslq_u64(mask_val, src_val, dst_val);\n\n        vst1q_u64((uint64_t *)&dst[i], result);\n    }\n\n    if (i < length) {\n        dst[i] = mask[i] ? src[i] : dst[i];\n    }\n}\n```"}
{"task_id": "SimdBench_1_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    int32x4_t vscale = vdupq_n_s32(scale);\n    int32x4_t vseven = vdupq_n_s32(7);\n\n    for (size_t i = 0; i < length; i += 4) {\n        int32x4_t vsrc = vld1q_s32(&src[i]);\n        int32x4_t vprod = vmulq_s32(vsrc, vscale);\n        int32x4_t vtmp1 = vshrq_n_s32(vprod, 3);\n        int32x4_t vtmp2 = vshlq_n_s32(vprod, 3);\n        int32x4_t vresult = vaddq_s32(vprod, vmulq_s32(vtmp1, vtmp2));\n        vresult = vdivq_s32(vresult, vseven);\n        vst1q_s32(&dst[i], vresult);\n    }\n}\n```"}
{"task_id": "SimdBench_1_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    int32x4_t vscale = vdupq_n_s32(scale);\n    int32x4_t vseven = vdupq_n_s32(7);\n\n    size_t i;\n    for (i = 0; i + 3 < length; i += 4) {\n        int32x4_t vsrc = vld1q_s32(&src[i]);\n        int32x4_t vprod = vmulq_s32(vsrc, vscale);\n        int32x4_t vtmp1 = vshrq_n_s32(vprod, 3);\n        int32x4_t vtmp2 = vshlq_n_s32(vprod, 3);\n        int32x4_t vresult = vaddq_s32(vprod, vmulq_s32(vtmp1, vtmp2));\n        vresult = vqrshlq_s32(vresult, vseven);\n        vst1q_s32(&dst[i], vresult);\n    }\n\n    for (; i < length; ++i) {\n        int element = src[i];\n        int tmp1 = (element * scale) >> 3;\n        int tmp2 = (element * scale) << 3;\n        int result = (element * scale + tmp1 * tmp2) / 7;\n        dst[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_1_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    int32x4_t vscale = vdupq_n_s32(scale);\n    int32x4_t vseven = vdupq_n_s32(7);\n\n    for (size_t i = 0; i < length; i += 4) {\n        int32x4_t vsrc = vld1q_s32(&src[i]);\n        int32x4_t vtmp = vmulq_s32(vsrc, vscale);\n\n        int32x4_t vtmp1 = vshrq_n_s32(vtmp, 3);\n        int32x4_t vtmp2 = vshlq_n_s32(vtmp, 3);\n\n        int32x4_t vresult = vmlaq_s32(vtmp, vtmp1, vtmp2);\n        vresult = vqdmulhq_s32(vresult, vseven);\n\n        vst1q_s32(&dst[i], vresult);\n    }\n}\n```"}
{"task_id": "SimdBench_1_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    int32x4_t vscale = vdupq_n_s32(scale);\n    size_t i;\n\n    for (i = 0; i + 3 < length; i += 4) {\n        int32x4_t vsrc = vld1q_s32(&src[i]);\n        int32x4_t vtmp = vmulq_s32(vsrc, vscale);\n\n        int32x4_t vtmp1 = vshrq_n_s32(vtmp, 3);\n        int32x4_t vtmp2 = vshlq_n_s32(vtmp, 3);\n\n        int32x4_t vresult = vmlaq_s32(vtmp, vtmp1, vtmp2);\n        vresult = vqrshrn_n_s32(vresult, 7);\n\n        vst1q_s32(&dst[i], vresult);\n    }\n\n    for (; i < length; ++i) {\n        int tmp = src[i] * scale;\n        int tmp1 = (tmp >> 3);\n        int tmp2 = (tmp << 3);\n        dst[i] = (tmp + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    int32x4_t vscale = vdupq_n_s32(scale);\n    int32x4_t vseven = vdupq_n_s32(7);\n\n    for (size_t i = 0; i < length; i += 4) {\n        int32x4_t vsrc = vld1q_s32(&src[i]);\n        int32x4_t vtmp = vmulq_s32(vsrc, vscale);\n\n        int32x4_t vtmp1 = vshrq_n_s32(vtmp, 3);\n        int32x4_t vtmp2 = vshlq_n_s32(vtmp, 3);\n\n        int32x4_t vresult = vmlaq_s32(vtmp, vtmp1, vtmp2);\n        vresult = vqrshrn_n_s64(vmovl_s32(vresult), 7);\n\n        vst1q_s32(&dst[i], vresult);\n    }\n}\n```"}
{"task_id": "SimdBench_2_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; r += 2) {\n        float64x2_t vec = vld1q_f64(&src[(r * cols + stride)]);\n        vst1q_f64(&dst[r], vec);\n    }\n}\n```"}
{"task_id": "SimdBench_2_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; r += 2) {\n        float64x2_t vec = vld1q_f64(&src[(r * cols + stride)]);\n        vst1q_f64(&dst[r], vec);\n    }\n}\n```"}
{"task_id": "SimdBench_2_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; r += 2) {\n        float64x2_t vec = vld1q_f64(&src[r * cols + stride]);\n        vst1q_f64(&dst[r], vec);\n    }\n}\n```"}
{"task_id": "SimdBench_2_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; r += 2) {\n        float64x2_t vec = vld1q_f64(&src[(r * cols + stride)]);\n        vst1q_f64(&dst[r], vec);\n    }\n}\n```"}
{"task_id": "SimdBench_2_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; ++r) {\n        size_t index = r * cols + stride;\n        float64x1_t value = vld1_f64(&src[index]);\n        vst1_f64(&dst[r], value);\n    }\n}\n```"}
{"task_id": "SimdBench_3_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i;\n    for (i = 0; i <= length - 4; i += 4) {\n        uint32x4_t idx = vld1q_u32((const uint32_t*)&indices[i]);\n        float32x4_t val = vld1q_f32(&src[vgetq_lane_u32(idx, 0)]);\n        val = vsetq_lane_f32(src[vgetq_lane_u32(idx, 1)], val, 1);\n        val = vsetq_lane_f32(src[vgetq_lane_u32(idx, 2)], val, 2);\n        val = vsetq_lane_f32(src[vgetq_lane_u32(idx, 3)], val, 3);\n        vst1q_f32(&dst[i], val);\n\n        idx = vld1q_u32((const uint32_t*)&indices[i]);\n        dst[vgetq_lane_u32(idx, 0)] = src[i];\n        dst[vgetq_lane_u32(idx, 1)] = src[i + 1];\n        dst[vgetq_lane_u32(idx, 2)] = src[i + 2];\n        dst[vgetq_lane_u32(idx, 3)] = src[i + 3];\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = src[indices[i]];\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i;\n    for (i = 0; i + 3 < length; i += 4) {\n        int32x4_t idx = vld1q_s32(&indices[i]);\n        float32x4_t val = vld1q_f32(&src[vgetq_lane_s32(idx, 0)]);\n        val = vsetq_lane_f32(src[vgetq_lane_s32(idx, 1)], val, 1);\n        val = vsetq_lane_f32(src[vgetq_lane_s32(idx, 2)], val, 2);\n        val = vsetq_lane_f32(src[vgetq_lane_s32(idx, 3)], val, 3);\n        vst1q_f32(&dst[i], val);\n\n        float32x4_t val_scatter = vld1q_f32(&src[i]);\n        dst[vgetq_lane_s32(idx, 0)] = vgetq_lane_f32(val_scatter, 0);\n        dst[vgetq_lane_s32(idx, 1)] = vgetq_lane_f32(val_scatter, 1);\n        dst[vgetq_lane_s32(idx, 2)] = vgetq_lane_f32(val_scatter, 2);\n        dst[vgetq_lane_s32(idx, 3)] = vgetq_lane_f32(val_scatter, 3);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = src[indices[i]];\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i;\n    for (i = 0; i <= length - 4; i += 4) {\n        uint32x4_t idx = vld1q_u32((const uint32_t *) &indices[i]);\n        float32x4_t val = vld1q_f32(&src[vgetq_lane_u32(idx, 0)]);\n        val = vsetq_lane_f32(src[vgetq_lane_u32(idx, 1)], val, 1);\n        val = vsetq_lane_f32(src[vgetq_lane_u32(idx, 2)], val, 2);\n        val = vsetq_lane_f32(src[vgetq_lane_u32(idx, 3)], val, 3);\n        vst1q_f32(&dst[i], val);\n\n        float32x4_t val_scatter = vld1q_f32(&src[i]);\n        dst[vgetq_lane_u32(idx, 0)] = vgetq_lane_f32(val_scatter, 0);\n        dst[vgetq_lane_u32(idx, 1)] = vgetq_lane_f32(val_scatter, 1);\n        dst[vgetq_lane_u32(idx, 2)] = vgetq_lane_f32(val_scatter, 2);\n        dst[vgetq_lane_u32(idx, 3)] = vgetq_lane_f32(val_scatter, 3);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = src[indices[i]];\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i;\n    for (i = 0; i <= length - 4; i += 4) {\n        uint32x4_t idx = vld1q_u32((const uint32_t *) &indices[i]);\n        float32x4_t val = vld1q_f32(&src[vgetq_lane_u32(idx, 0)]);\n        vst1q_f32(&dst[i], val);\n\n        val = vld1q_f32(&src[vgetq_lane_u32(idx, 1)]);\n        vst1q_f32(&dst[i + 1], val);\n\n        val = vld1q_f32(&src[vgetq_lane_u32(idx, 2)]);\n        vst1q_f32(&dst[i + 2], val);\n\n        val = vld1q_f32(&src[vgetq_lane_u32(idx, 3)]);\n        vst1q_f32(&dst[i + 3], val);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = src[indices[i]];\n    }\n\n    for (i = 0; i <= length - 4; i += 4) {\n        uint32x4_t idx = vld1q_u32((const uint32_t *) &indices[i]);\n        float32x4_t val = vld1q_f32(&src[i]);\n        vst1q_f32(&dst[vgetq_lane_u32(idx, 0)], val);\n\n        val = vld1q_f32(&src[i + 1]);\n        vst1q_f32(&dst[vgetq_lane_u32(idx, 1)], val);\n\n        val = vld1q_f32(&src[i + 2]);\n        vst1q_f32(&dst[vgetq_lane_u32(idx, 2)], val);\n\n        val = vld1q_f32(&src[i + 3]);\n        vst1q_f32(&dst[vgetq_lane_u32(idx, 3)], val);\n    }\n\n    for (; i < length; ++i) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i;\n    for (i = 0; i <= length - 4; i += 4) {\n        uint32x4_t idx = vld1q_u32((const uint32_t *) &indices[i]);\n        float32x4_t val = vld1q_f32(&src[vgetq_lane_u32(idx, 0)]);\n        val = vsetq_lane_f32(src[vgetq_lane_u32(idx, 1)], val, 1);\n        val = vsetq_lane_f32(src[vgetq_lane_u32(idx, 2)], val, 2);\n        val = vsetq_lane_f32(src[vgetq_lane_u32(idx, 3)], val, 3);\n        vst1q_f32(&dst[i], val);\n\n        idx = vld1q_u32((const uint32_t *) &indices[i]);\n        dst[vgetq_lane_u32(idx, 0)] = src[i];\n        dst[vgetq_lane_u32(idx, 1)] = src[i + 1];\n        dst[vgetq_lane_u32(idx, 2)] = src[i + 2];\n        dst[vgetq_lane_u32(idx, 3)] = src[i + 3];\n    }\n\n    for (; i < length; i++) {\n        dst[i] = src[indices[i]];\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_4_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t length = end - start + 1;\n    uint64_t i = 0;\n\n    if (length <= 0) return;\n\n    for (i = 0; i + 7 < length; i += 8) {\n        int16x8_t vec1 = vld1q_s16(&arr[start + i]);\n        int16x8_t vec2 = vld1q_s16(&arr[end - i]);\n        vst1q_s16(&arr[start + i], vec2);\n        vst1q_s16(&arr[end - i], vec1);\n    }\n\n    for (; i < length; i++) {\n        int16_t temp = arr[start + i];\n        arr[start + i] = arr[end - i];\n        arr[end - i] = temp;\n    }\n}\n```"}
{"task_id": "SimdBench_4_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t length = end - start + 1;\n    uint64_t i = 0;\n\n    if (length <= 0) return;\n\n    for (i = 0; i < length / 8; i++) {\n        int16x8_t vec1 = vld1q_s16(&arr[start + i * 8]);\n        int16x8_t vec2 = vld1q_s16(&arr[end - i * 8]);\n        vst1q_s16(&arr[start + i * 8], vec2);\n        vst1q_s16(&arr[end - i * 8], vec1);\n    }\n\n    for (i = length / 8 * 8; i < length / 2; i++) {\n        int16_t temp = arr[start + i];\n        arr[start + i] = arr[end - i];\n        arr[end - i] = temp;\n    }\n}\n```"}
{"task_id": "SimdBench_4_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t length = end - start + 1;\n    uint64_t i = 0;\n\n    if (length <= 8) {\n        for (i = 0; i < length / 2; ++i) {\n            int16_t temp = arr[start + i];\n            arr[start + i] = arr[end - i];\n            arr[end - i] = temp;\n        }\n        return;\n    }\n\n    uint64_t j = length - 8;\n    for (i = 0; i < length / 2; i += 8, j -= 8) {\n        int16x8_t vec1 = vld1q_s16(&arr[start + i]);\n        int16x8_t vec2 = vld1q_s16(&arr[end - i]);\n        vst1q_s16(&arr[start + i], vec2);\n        vst1q_s16(&arr[end - i], vec1);\n    }\n\n    if (length % 16 != 0) {\n        for (i = length / 2 * 8; i < length / 2; ++i) {\n            int16_t temp = arr[start + i];\n            arr[start + i] = arr[end - i];\n            arr[end - i] = temp;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_4_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t length = end - start + 1;\n    uint64_t i = 0;\n\n    if (length <= 8) {\n        for (i = 0; i < length / 2; ++i) {\n            int16_t temp = arr[start + i];\n            arr[start + i] = arr[end - i];\n            arr[end - i] = temp;\n        }\n        return;\n    }\n\n    uint64_t j = 0;\n    for (i = start; i < (start + length / 2) - 7; i += 8, j += 8) {\n        int16x8_t vec1 = vld1q_s16(&arr[i]);\n        int16x8_t vec2 = vld1q_s16(&arr[end - j]);\n        vst1q_s16(&arr[i], vec2);\n        vst1q_s16(&arr[end - j], vec1);\n    }\n\n    for (; i < (start + length / 2); ++i, ++j) {\n        int16_t temp = arr[i];\n        arr[i] = arr[end - j];\n        arr[end - j] = temp;\n    }\n}\n```"}
{"task_id": "SimdBench_4_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t length = end - start + 1;\n    uint64_t i = 0;\n\n    if (length <= 8) {\n        for (i = start; i <= end; ++i) {\n            int16_t temp = arr[i];\n            arr[i] = arr[end - (i - start)];\n            arr[end - (i - start)] = temp;\n        }\n        return;\n    }\n\n    uint64_t j = end;\n    for (i = start; i < j; ) {\n        int16x8_t v1 = vld1q_s16(&arr[i]);\n        int16x8_t v2 = vld1q_s16(&arr[j - 7]);\n\n        vst1q_s16(&arr[i], v2);\n        vst1q_s16(&arr[j - 7], v1);\n\n        i += 8;\n        j -= 8;\n    }\n\n    if (i < j) {\n        for (; i <= j; ++i, --j) {\n            int16_t temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    const uint8_t *tensor_slice = tensor + slice_idx * slice_size;\n\n    size_t i, j;\n    for (i = 0; i < dim1; ++i) {\n        for (j = 0; j < dim2; j += 16) {\n            uint8x16_t data = vld1q_u8(&tensor_slice[i * dim2 + j]);\n            vst1q_u8(&slice[i * dim2 + j], data);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    const uint8_t *tensor_slice = tensor + slice_idx * slice_size;\n\n    size_t i = 0;\n    for (; i <= slice_size - 16; i += 16) {\n        uint8x16_t data = vld1q_u8(&tensor_slice[i]);\n        vst1q_u8(&slice[i], data);\n    }\n    for (; i < slice_size; ++i) {\n        slice[i] = tensor_slice[i];\n    }\n}\n```"}
{"task_id": "SimdBench_5_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    const uint8_t *tensor_slice = tensor + slice_idx * slice_size;\n\n    size_t i, j;\n    for (i = 0; i < dim1; ++i) {\n        for (j = 0; j < dim2; j += 16) {\n            uint8x16_t data = vld1q_u8(&tensor_slice[i * dim2 + j]);\n            vst1q_u8(&slice[i * dim2 + j], data);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    const uint8_t *tensor_slice = tensor + slice_idx * slice_size;\n\n    size_t i, j;\n    for (i = 0; i < dim1; ++i) {\n        for (j = 0; j < dim2; j += 16) {\n            uint8x16_t data = vld1q_u8(&tensor_slice[i * dim2 + j]);\n            vst1q_u8(&slice[i * dim2 + j], data);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    const uint8_t *tensor_slice = tensor + slice_idx * slice_size;\n\n    size_t i, j;\n    for (i = 0; i < dim1; ++i) {\n        for (j = 0; j < dim2; j += 16) {\n            uint8x16_t data = vld1q_u8(&tensor_slice[i * dim2 + j]);\n            vst1q_u8(&slice[i * dim2 + j], data);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t ii = i; ii < i + block_size && ii < rows; ++ii) {\n                for (size_t jj = j; jj < j + block_size && jj < cols; jj += 8) {\n                    int16x8_t data = vld1q_s16(&src[ii * cols + jj]);\n                    vst1q_s16(&dst[jj * rows + ii], data);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t k = i; k < i + block_size && k < rows; ++k) {\n                for (size_t l = j; l < j + block_size && l < cols; l += 8) {\n                    int16x8_t row = vld1q_s16(&src[k * cols + l]);\n                    vst1q_s16(&dst[l * rows + k], row);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t k = i; k < i + block_size && k < rows; ++k) {\n                for (size_t l = j; l < j + block_size && l < cols; l += 8) {\n                    int16x8_t row = vld1q_s16(&src[k * cols + l]);\n                    vst1q_s16(&dst[l * rows + k], row);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t k = i; k < i + block_size && k < rows; ++k) {\n                for (size_t l = j; l < j + block_size && l < cols; l += 8) {\n                    int16x8_t data = vld1q_s16(&src[k * cols + l]);\n                    vst1q_s16(&dst[l * rows + k], data);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t k = i; k < i + block_size && k < rows; ++k) {\n                for (size_t l = j; l < j + block_size && l < cols; l += 8) {\n                    int16x8_t row = vld1q_s16(&src[k * cols + l]);\n                    vst1q_s16(&dst[l * rows + k], row);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_7_Neon", "completion": "```c\n#include <arm_neon.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    size_t i;\n    float32x4_t sumv = vdupq_n_f32(0.0f);\n\n    for (i = 0; i <= dim - 4; i += 4) {\n        size_t index = i * (dim * dim + dim + 1);\n        float32x4_t data = vld1q_f32(&array[index]);\n        sumv = vaddq_f32(sumv, data);\n    }\n\n    float sum[4];\n    vst1q_f32(sum, sumv);\n    float total = sum[0] + sum[1] + sum[2] + sum[3];\n\n    for (; i < dim; i++) {\n        size_t index = i * (dim * dim + dim + 1);\n        total += array[index];\n    }\n\n    return total;\n}\n```"}
{"task_id": "SimdBench_7_Neon", "completion": "```c\n#include <arm_neon.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    size_t i;\n    float32x4_t sumv = vdupq_n_f32(0.0f);\n    float sum = 0.0f;\n\n    for (i = 0; i <= dim - 4; i += 4) {\n        size_t index = i * (dim * dim + dim + 1);\n        float32x4_t data = vld1q_f32(&array[index]);\n        sumv = vaddq_f32(sumv, data);\n    }\n\n    sum += vgetq_lane_f32(sumv, 0);\n    sum += vgetq_lane_f32(sumv, 1);\n    sum += vgetq_lane_f32(sumv, 2);\n    sum += vgetq_lane_f32(sumv, 3);\n\n    for (; i < dim; i++) {\n        size_t index = i * (dim * dim + dim + 1);\n        sum += array[index];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_Neon", "completion": "```c\n#include <arm_neon.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    size_t i;\n    float32x4_t sum_vec = vdupq_n_f32(0.0f);\n\n    for (i = 0; i < dim; i++) {\n        size_t index = i + dim * i + dim * dim * i;\n        float32x4_t data_vec = vld1q_f32(&array[index]);\n        sum_vec = vaddq_f32(sum_vec, data_vec);\n    }\n\n    float sum[4];\n    vst1q_f32(sum, sum_vec);\n\n    return sum[0] + sum[1] + sum[2] + sum[3];\n}\n```"}
{"task_id": "SimdBench_7_Neon", "completion": "```c\n#include <arm_neon.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    size_t i;\n    float32x4_t sumv = vdupq_n_f32(0.0f);\n    float sum = 0.0f;\n\n    for (i = 0; i < dim; i += 4) {\n        float32x4_t vec = vld1q_f32(&array[i * (dim * dim + dim + 1)]);\n        sumv = vaddq_f32(sumv, vec);\n    }\n\n    float32x2_t sumv_low = vadd_f32(vget_low_f32(sumv), vget_high_f32(sumv));\n    sum = vget_lane_f32(vpadd_f32(sumv_low, sumv_low), 0);\n\n    for (; i < dim; i++) {\n        sum += array[i * (dim * dim + dim + 1)];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_Neon", "completion": "```c\n#include <arm_neon.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float32x4_t sum_vec = vdupq_n_f32(0.0f);\n    size_t i = 0;\n\n    for (; i <= dim - 4; i += 4) {\n        size_t index = i * (dim * dim + dim + 1);\n        float32x4_t data_vec = vld1q_f32(&array[index]);\n        sum_vec = vaddq_f32(sum_vec, data_vec);\n    }\n\n    float sum = vaddvq_f32(sum_vec);\n\n    for (; i < dim; ++i) {\n        size_t index = i * (dim * dim + dim + 1);\n        sum += array[index];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_8_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t i;\n\n    double threshold_vec[2] = {threshold, threshold};\n    double scale_vec[2] = {scale, scale};\n\n    float64x2_t vthreshold = vld1q_f64(threshold_vec);\n    float64x2_t vscale = vld1q_f64(scale_vec);\n\n    for (i = 0; i < total_elements - 1; i += 2) {\n        float64x2_t vsrc = vld1q_f64(&src[i]);\n        uint64x2_t mask = vcgtq_f64(vsrc, vthreshold);\n\n        float64x2_t vscaled = vmulq_f64(vsrc, vscale);\n        float64x2_t vresult = vbslq_f64(mask, vscaled, vsrc);\n\n        vst1q_f64(&dst[i], vresult);\n    }\n\n    if (i < total_elements) {\n        dst[i] = (src[i] > threshold) ? src[i] * scale : src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_8_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t i;\n\n    double *src_end = src + total_elements;\n    float64x2_t vthreshold = vdupq_n_f64(threshold);\n    float64x2_t vscale = vdupq_n_f64(scale);\n\n    for (i = 0; i < total_elements - 1; i += 2) {\n        float64x2_t vsrc = vld1q_f64(src + i);\n        uint64x2_t mask = vcgtq_f64(vsrc, vthreshold);\n\n        float64x2_t vscaled = vmulq_f64(vsrc, vscale);\n        float64x2_t vresult = vbslq_f64(mask, vscaled, vsrc);\n\n        vst1q_f64(dst + i, vresult);\n    }\n\n    if (i < total_elements) {\n        dst[i] = (src[i] > threshold) ? src[i] * scale : src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_8_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t i;\n\n    double threshold_vec[2] = {threshold, threshold};\n    double scale_vec[2] = {scale, scale};\n\n    float64x2_t vthreshold = vld1q_f64(threshold_vec);\n    float64x2_t vscale = vld1q_f64(scale_vec);\n\n    for (i = 0; i < total_elements - 1; i += 2) {\n        float64x2_t vsrc = vld1q_f64(&src[i]);\n        uint64x2_t mask = vcgtq_f64(vsrc, vthreshold);\n\n        float64x2_t vscaled = vmulq_f64(vsrc, vscale);\n        float64x2_t vresult = vbslq_f64(mask, vscaled, vsrc);\n\n        vst1q_f64(&dst[i], vresult);\n    }\n\n    if (i < total_elements) {\n        if (src[i] > threshold) {\n            dst[i] = src[i] * scale;\n        } else {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t i;\n\n    double threshold_vec[2] = {threshold, threshold};\n    double scale_vec[2] = {scale, scale};\n\n    for (i = 0; i < total_elements - 1; i += 2) {\n        float64x2_t vsrc = vld1q_f64(&src[i]);\n        float64x2_t vthreshold = vld1q_f64(threshold_vec);\n        float64x2_t vscale = vld1q_f64(scale_vec);\n\n        uint64x2_t mask = vcgtq_f64(vsrc, vthreshold);\n        float64x2_t vscaled = vmulq_f64(vsrc, vscale);\n\n        float64x2_t vresult = vbslq_f64(mask, vscaled, vsrc);\n        vst1q_f64(&dst[i], vresult);\n    }\n\n    if (i < total_elements) {\n        dst[i] = (src[i] > threshold) ? src[i] * scale : src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_8_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t i;\n\n    double threshold_vec[2] = {threshold, threshold};\n    double scale_vec[2] = {scale, scale};\n\n    for (i = 0; i < total_elements - 1; i += 2) {\n        float64x2_t vsrc = vld1q_f64(&src[i]);\n        float64x2_t vthreshold = vld1q_f64(threshold_vec);\n        float64x2_t vscale = vld1q_f64(scale_vec);\n\n        uint64x2_t mask = vcgtq_f64(vsrc, vthreshold);\n        float64x2_t vscaled = vmulq_f64(vsrc, vscale);\n        float64x2_t vresult = vbslq_f64(mask, vscaled, vsrc);\n\n        vst1q_f64(&dst[i], vresult);\n    }\n\n    if (i < total_elements) {\n        dst[i] = (src[i] > threshold) ? src[i] * scale : src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_9_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; ++i) {\n        size_t src_row_idx = indices[i] * cols;\n        size_t dst_row_idx = i * cols;\n        size_t j = 0;\n\n        for (; j <= cols - 2; j += 2) {\n            float64x2_t v = vld1q_f64(&src[src_row_idx + j]);\n            vst1q_f64(&dst[dst_row_idx + j], v);\n        }\n\n        for (; j < cols; ++j) {\n            dst[dst_row_idx + j] = src[src_row_idx + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; ++i) {\n        size_t idx = indices[i] * cols;\n        size_t dst_idx = i * cols;\n\n        for (size_t j = 0; j < cols; j += 2) {\n            float64x2_t vec = vld1q_f64(&src[idx + j]);\n            vst1q_f64(&dst[dst_idx + j], vec);\n        }\n\n        if (cols % 2 != 0) {\n            dst[dst_idx + cols - 1] = src[idx + cols - 1];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; ++i) {\n        size_t idx = indices[i];\n        for (size_t j = 0; j < cols; j += 2) {\n            float64x2_t vec = vld1q_f64(&src[idx * cols + j]);\n            vst1q_f64(&dst[i * cols + j], vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; ++i) {\n        size_t idx = indices[i];\n        for (size_t j = 0; j < cols; j += 2) {\n            float64x2_t vec = vld1q_f64(&src[idx * cols + j]);\n            vst1q_f64(&dst[i * cols + j], vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; ++i) {\n        size_t idx = indices[i] * cols;\n        size_t dst_idx = i * cols;\n        size_t j = 0;\n\n        for (; j <= cols - 2; j += 2) {\n            float64x2_t v = vld1q_f64(&src[idx + j]);\n            vst1q_f64(&dst[dst_idx + j], v);\n        }\n\n        if (j < cols) {\n            dst[dst_idx + j] = src[idx + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_10_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    int64x2_t v_scalar = vdupq_n_s64(scalar);\n    int64x2_t v_two = vdupq_n_s64(2);\n\n    for (size_t i = 0; i < length; i += 2) {\n        int64x2_t v_src1 = vld1q_s64(&src1[i]);\n        int64x2_t v_src2 = vld1q_s64(&src2[i]);\n\n        int64x2_t v_add = vaddq_s64(v_src1, v_src2);\n        int64x2_t v_add_scalar = vaddq_s64(v_add, v_scalar);\n        int64x2_t v_result = vqrshrq_n_s64(v_add_scalar, 1);\n\n        vst1q_s64(&dst[i], v_result);\n    }\n}\n```"}
{"task_id": "SimdBench_10_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    int64x2_t v_scalar = vdupq_n_s64(scalar);\n    size_t i;\n\n    for (i = 0; i <= length - 2; i += 2) {\n        int64x2_t v_src1 = vld1q_s64(&src1[i]);\n        int64x2_t v_src2 = vld1q_s64(&src2[i]);\n        int64x2_t v_add = vaddq_s64(v_src1, v_src2);\n        v_add = vaddq_s64(v_add, v_scalar);\n        v_add = vshrq_n_s64(v_add, 1);\n        vst1q_s64(&dst[i], v_add);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = (src1[i] + src2[i] + scalar) >> 1;\n    }\n}\n```"}
{"task_id": "SimdBench_10_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    int64x2_t v_scalar = vdupq_n_s64(scalar);\n    size_t i;\n\n    for (i = 0; i <= length - 2; i += 2) {\n        int64x2_t v_src1 = vld1q_s64(&src1[i]);\n        int64x2_t v_src2 = vld1q_s64(&src2[i]);\n        int64x2_t v_add = vaddq_s64(v_src1, v_src2);\n        v_add = vaddq_s64(v_add, v_scalar);\n        int64x2_t v_result = vshrq_n_s64(v_add, 1);\n        vst1q_s64(&dst[i], v_result);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = (src1[i] + src2[i] + scalar) >> 1;\n    }\n}\n```"}
{"task_id": "SimdBench_10_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    int64x2_t v_scalar = vdupq_n_s64(scalar);\n    int64x2_t v_two = vdupq_n_s64(2);\n\n    for (size_t i = 0; i < length; i += 2) {\n        int64x2_t v_src1 = vld1q_s64(&src1[i]);\n        int64x2_t v_src2 = vld1q_s64(&src2[i]);\n\n        int64x2_t v_add = vaddq_s64(v_src1, v_src2);\n        v_add = vaddq_s64(v_add, v_scalar);\n        v_add = vqrshlq_s64(v_add, v_two);\n\n        vst1q_s64(&dst[i], v_add);\n    }\n}\n```"}
{"task_id": "SimdBench_10_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    int64x2_t v_scalar = vdupq_n_s64(scalar);\n    int64x2_t v_two = vdupq_n_s64(2);\n\n    for (size_t i = 0; i < length; i += 2) {\n        int64x2_t v_src1 = vld1q_s64(&src1[i]);\n        int64x2_t v_src2 = vld1q_s64(&src2[i]);\n\n        int64x2_t v_add = vaddq_s64(v_src1, v_src2);\n        v_add = vaddq_s64(v_add, v_scalar);\n        v_add = vshrq_n_s64(v_add, 1);\n\n        vst1q_s64(&dst[i], v_add);\n    }\n}\n```"}
{"task_id": "SimdBench_11_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stddef.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    int32x4_t min_vec = vdupq_n_s32(INT32_MAX);\n    int min_val = INT32_MAX;\n\n    for (size_t i = 0; i < length; i += 8) {\n        int32x4_t vec1 = vld1q_s32(&src[i]);\n        int32x4_t vec2 = vld1q_s32(&src[i + 4]);\n\n        int32x4_t even_vec1 = vandq_s32(vec1, vdupq_n_s32(0xFFFFFFFE));\n        int32x4_t even_vec2 = vandq_s32(vec2, vdupq_n_s32(0xFFFFFFFE));\n\n        min_vec = vminq_s32(min_vec, even_vec1);\n        min_vec = vminq_s32(min_vec, even_vec2);\n    }\n\n    int32_t tmp[4];\n    vst1q_s32(tmp, min_vec);\n\n    for (int i = 0; i < 4; ++i) {\n        if (tmp[i] < min_val) {\n            min_val = tmp[i];\n        }\n    }\n\n    return min_val == INT32_MAX ? -1 : min_val;\n}\n```"}
{"task_id": "SimdBench_11_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <limits.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    int32x4_t vmin = vdupq_n_s32(INT_MAX);\n    size_t i;\n\n    for (i = 0; i <= length - 8; i += 8) {\n        int32x4_t v1 = vld1q_s32(&src[i]);\n        int32x4_t v2 = vld1q_s32(&src[i + 4]);\n\n        int32x4_t veven1 = vandq_s32(v1, vdupq_n_s32(1));\n        int32x4_t veven2 = vandq_s32(v2, vdupq_n_s32(1));\n\n        veven1 = vceqq_s32(veven1, vdupq_n_s32(0));\n        veven2 = vceqq_s32(veven2, vdupq_n_s32(0));\n\n        v1 = vbslq_s32(veven1, v1, vdupq_n_s32(INT_MAX));\n        v2 = vbslq_s32(veven2, v2, vdupq_n_s32(INT_MAX));\n\n        vmin = vminq_s32(vmin, v1);\n        vmin = vminq_s32(vmin, v2);\n    }\n\n    if (i < length) {\n        int32x4_t v = vld1q_s32(&src[i]);\n        int32x4_t veven = vandq_s32(v, vdupq_n_s32(1));\n        veven = vceqq_s32(veven, vdupq_n_s32(0));\n        v = vbslq_s32(veven, v, vdupq_n_s32(INT_MAX));\n        vmin = vminq_s32(vmin, v);\n    }\n\n    int32_t min_vals[4];\n    vst1q_s32(min_vals, vmin);\n\n    int min_val = INT_MAX;\n    for (i = 0; i < 4; i++) {\n        if (min_vals[i] < min_val) {\n            min_val = min_vals[i];\n        }\n    }\n\n    return min_val == INT_MAX ? -1 : min_val;\n}\n```"}
{"task_id": "SimdBench_11_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    int32x4_t min_vec = vld1q_dup_s32(&src[0]);\n    int min_val = src[0];\n\n    for (size_t i = 2; i < length; i += 4) {\n        int32x4_t vec = vld1q_s32(&src[i]);\n        min_vec = vminq_s32(min_vec, vec);\n    }\n\n    int32_t min_vals[4];\n    vst1q_s32(min_vals, min_vec);\n\n    for (int i = 0; i < 4; i++) {\n        if (min_vals[i] < min_val) {\n            min_val = min_vals[i];\n        }\n    }\n\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    int32x4_t min_vec = vdupq_n_s32(INT32_MAX);\n    int min_val = INT32_MAX;\n\n    for (size_t i = 0; i < length - 3; i += 4) {\n        int32x4_t vec = vld1q_s32(&src[i]);\n        int32x4_t even_vec = vandq_s32(vec, vdupq_n_s32(0xAAAAAAAA)); // Mask to keep even numbers\n        min_vec = vminq_s32(min_vec, even_vec);\n    }\n\n    int32_t min_arr[4];\n    vst1q_s32(min_arr, min_vec);\n\n    for (int i = 0; i < 4; ++i) {\n        if (min_arr[i] < min_val && min_arr[i] != 0) {\n            min_val = min_arr[i];\n        }\n    }\n\n    for (size_t i = (length & ~3); i < length; ++i) {\n        if (src[i] % 2 == 0 && src[i] < min_val) {\n            min_val = src[i];\n        }\n    }\n\n    return min_val == INT32_MAX ? -1 : min_val;\n}\n```"}
{"task_id": "SimdBench_11_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <limits.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    int32x4_t min_vec = vdupq_n_s32(INT_MAX);\n    int min_val = INT_MAX;\n\n    for (size_t i = 0; i < length - 3; i += 4) {\n        int32x4_t vec = vld1q_s32(&src[i]);\n        int32x4_t even_vec = vandq_s32(vec, vdupq_n_s32(1));\n        even_vec = vceqq_s32(even_vec, vdupq_n_s32(0));\n        vec = vbslq_s32(even_vec, vec, vdupq_n_s32(INT_MAX));\n        min_vec = vminq_s32(min_vec, vec);\n    }\n\n    int32_t tmp[4];\n    vst1q_s32(tmp, min_vec);\n    for (int i = 0; i < 4; ++i) {\n        if (tmp[i] < min_val) min_val = tmp[i];\n    }\n\n    for (size_t i = (length / 4) * 4; i < length; ++i) {\n        if (src[i] % 2 == 0 && src[i] < min_val) {\n            min_val = src[i];\n        }\n    }\n\n    return min_val == INT_MAX ? -1 : min_val;\n}\n```"}
{"task_id": "SimdBench_12_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i;\n    for (i = 0; i + 3 < length; i += 4) {\n        int32x4_t vsrc = vld1q_s32(&src[i]);\n        int32x4_t varith = vshrq_n_s32(vsrc, shift);\n        uint32x4_t vlogic = vshrq_n_u32(vreinterpretq_u32_s32(vsrc), shift);\n        vst1q_s32(&dst[i], vaddq_s32(varith, vreinterpretq_s32_u32(vlogic)));\n    }\n\n    for (; i < length; i++) {\n        int arith = src[i] >> shift;\n        unsigned int logic = (unsigned int)src[i] >> shift;\n        dst[i] = arith + (int)logic;\n    }\n}\n```"}
{"task_id": "SimdBench_12_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i;\n    for (i = 0; i + 3 < length; i += 4) {\n        int32x4_t v = vld1q_s32(&src[i]);\n        int32x4_t arith_shift = vshrq_n_s32(v, shift);\n        uint32x4_t logical_shift = vshrq_n_u32(vreinterpretq_u32_s32(v), shift);\n        vst1q_s32(&dst[i], vaddq_s32(arith_shift, vreinterpretq_s32_u32(logical_shift)));\n    }\n    for (; i < length; i++) {\n        int arith_shift = src[i] >> shift;\n        int logical_shift = (unsigned int)src[i] >> shift;\n        dst[i] = arith_shift + logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i;\n    for (i = 0; i + 3 < length; i += 4) {\n        int32x4_t v = vld1q_s32(&src[i]);\n        int32x4_t arith_shift = vshrq_n_s32(v, shift);\n        uint32x4_t logical_shift = vshrq_n_u32(vreinterpretq_u32_s32(v), shift);\n        vst1q_s32(&dst[i], vaddq_s32(arith_shift, vreinterpretq_s32_u32(logical_shift)));\n    }\n\n    for (; i < length; i++) {\n        int arith_shift = src[i] >> shift;\n        int logical_shift = (unsigned int)src[i] >> shift;\n        dst[i] = arith_shift + logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i;\n    for (i = 0; i + 3 < length; i += 4) {\n        int32x4_t v = vld1q_s32(&src[i]);\n        int32x4_t arith_shift = vshrq_n_s32(v, shift);\n        uint32x4_t logical_shift = vshrq_n_u32(vreinterpretq_u32_s32(v), shift);\n        vst1q_s32(&dst[i], vaddq_s32(arith_shift, vreinterpretq_s32_u32(logical_shift)));\n    }\n    for (; i < length; i++) {\n        int arith_shift = src[i] >> shift;\n        int logical_shift = (unsigned int)src[i] >> shift;\n        dst[i] = arith_shift + logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i;\n    uint32x4_t vshift = vdupq_n_u32(shift);\n\n    for (i = 0; i <= length - 4; i += 4) {\n        int32x4_t vsrc = vld1q_s32(&src[i]);\n        int32x4_t varith_shift = vshrq_n_s32(vsrc, shift);\n        uint32x4_t vlogic_shift = vshrq_n_u32(vreinterpretq_u32_s32(vsrc), shift);\n        int32x4_t vresult = vaddq_s32(varith_shift, vreinterpretq_s32_u32(vlogic_shift));\n        vst1q_s32(&dst[i], vresult);\n    }\n\n    for (; i < length; i++) {\n        int arith_shift = src[i] >> shift;\n        uint32_t logic_shift = (uint32_t)src[i] >> shift;\n        dst[i] = arith_shift + (int)logic_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_13_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    int64_t sum = 0;\n\n    size_t i;\n    for (i = 0; i <= total_elements - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&matrix[i]);\n        sum_vec = vaddq_s32(sum_vec, vec);\n    }\n\n    int32_t temp[4];\n    vst1q_s32(temp, sum_vec);\n    for (int j = 0; j < 4; j++) {\n        sum += temp[j];\n    }\n\n    for (; i < total_elements; i++) {\n        sum += matrix[i];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    int64_t sum = 0;\n\n    size_t i;\n    for (i = 0; i <= total_elements - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&matrix[i]);\n        sum_vec = vaddq_s32(sum_vec, vec);\n    }\n\n    int32_t temp[4];\n    vst1q_s32(temp, sum_vec);\n    for (int j = 0; j < 4; j++) {\n        sum += temp[j];\n    }\n\n    for (; i < total_elements; i++) {\n        sum += matrix[i];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    int64_t sum = 0;\n\n    size_t i;\n    for (i = 0; i <= total_elements - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&matrix[i]);\n        sum_vec = vaddq_s32(sum_vec, vec);\n    }\n\n    int32_t temp[4];\n    vst1q_s32(temp, sum_vec);\n    for (int j = 0; j < 4; j++) {\n        sum += temp[j];\n    }\n\n    for (; i < total_elements; i++) {\n        sum += matrix[i];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    int64_t sum = 0;\n\n    size_t i;\n    for (i = 0; i <= total_elements - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&matrix[i]);\n        sum_vec = vaddq_s32(sum_vec, vec);\n    }\n\n    int32_t temp[4];\n    vst1q_s32(temp, sum_vec);\n    for (int j = 0; j < 4; j++) {\n        sum += temp[j];\n    }\n\n    for (; i < total_elements; i++) {\n        sum += matrix[i];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    int64_t sum = 0;\n\n    size_t i;\n    for (i = 0; i <= total_elements - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&matrix[i]);\n        sum_vec = vaddq_s32(sum_vec, vec);\n    }\n\n    int32_t temp[4];\n    vst1q_s32(temp, sum_vec);\n    for (int j = 0; j < 4; j++) {\n        sum += temp[j];\n    }\n\n    for (; i < total_elements; i++) {\n        sum += matrix[i];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_14_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stddef.h>\n#include <stdint.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    int8x16_t max_vec = vdupq_n_s8(INT8_MIN);\n    size_t max_index = 0;\n    int8x16_t current_vec;\n\n    for (size_t i = 0; i <= length - 16; i += 16) {\n        current_vec = vld1q_s8(&src[i]);\n        uint8x16_t mask = vcgtq_s8(current_vec, max_vec);\n        if (vmaxvq_u8(mask) > 0) {\n            max_vec = current_vec;\n            max_index = i + vmaxvq_u8(vmulq_n_u8(mask, vdupq_n_u8(1)));\n        }\n    }\n\n    int8_t max_val = vmaxvq_s8(max_vec);\n\n    for (size_t i = (length & ~15); i < length; ++i) {\n        if (src[i] > max_val) {\n            max_val = src[i];\n            max_index = i;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_Neon", "completion": "```c\n#include <arm_neon.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    int8x16_t max_vec = vld1q_s8(src);\n    uint8x16_t max_idx_vec = vdupq_n_u8(0);\n    size_t max_idx = 0;\n\n    for (size_t i = 16; i <= length - 16; i += 16, src += 16) {\n        int8x16_t current_vec = vld1q_s8(src);\n        uint8x16_t cmp_vec = vcgtq_s8(current_vec, max_vec);\n\n        uint8x16_t idx_vec = vdupq_n_u8(i);\n        idx_vec = vaddq_u8(idx_vec, vdupq_n_u8(0));\n\n        max_idx_vec = vbslq_u8(cmp_vec, idx_vec, max_idx_vec);\n        max_vec = vbslq_s8(cmp_vec, current_vec, max_vec);\n    }\n\n    int8_t max_val = vmaxvq_s8(max_vec);\n    uint8_t max_idx_val = vmaxvq_u8(max_idx_vec);\n\n    for (size_t i = (length & ~15); i < length; ++i) {\n        if (src[i] > max_val) {\n            max_val = src[i];\n            max_idx = i;\n        }\n    }\n\n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_14_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stddef.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    int8x16_t max_val = vdupq_n_s8(INT8_MIN);\n    size_t max_index = 0;\n    int8x16_t current_val;\n\n    for (size_t i = 0; i <= length - 16; i += 16) {\n        current_val = vld1q_s8(&src[i]);\n        uint8x16_t mask = vcgtq_s8(current_val, max_val);\n        if (vmaxvq_u8(mask) > 0) {\n            max_val = current_val;\n            max_index = i + vminvq_u8(vmulq_u8(mask, vld1q_u8(range)));\n        }\n    }\n\n    int8_t max_scalar = INT8_MIN;\n    for (size_t i = (length & ~15); i < length; ++i) {\n        if (src[i] > max_scalar) {\n            max_scalar = src[i];\n            max_index = i;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_Neon", "completion": "```c\n#include <arm_neon.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    int8x16_t max_vec = vld1q_s8(src);\n    uint8x16_t max_idx_vec = vdupq_n_u8(0);\n    size_t max_idx = 0;\n\n    for (size_t i = 16; i <= length - 16; i += 16) {\n        int8x16_t current_vec = vld1q_s8(&src[i]);\n        uint8x16_t cmp_mask = vcgtq_s8(current_vec, max_vec);\n\n        if (vmaxvq_u8(cmp_mask) > 0) {\n            max_vec = current_vec;\n            max_idx_vec = vaddq_u8(max_idx_vec, vdupq_n_u8(16));\n            max_idx = i;\n        }\n    }\n\n    int8_t max_val = vmaxvq_s8(max_vec);\n    for (size_t i = (length & ~15); i < length; ++i) {\n        if (src[i] > max_val) {\n            max_val = src[i];\n            max_idx = i;\n        }\n    }\n\n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_14_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stddef.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    int8x8_t max_val = vdup_n_s8(INT8_MIN);\n    size_t max_idx = 0;\n\n    for (size_t i = 0; i < length; i += 8) {\n        int8x8_t chunk = vld1_s8(&src[i]);\n        uint8x8_t mask = vcgt_s8(chunk, max_val);\n\n        if (vmax_s8(mask) > 0) {\n            max_val = chunk;\n            max_idx = i + vmaxv_u8(mask) - 1;\n        }\n    }\n\n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_15_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i;\n    uint16x8_t vmask = vdupq_n_u16(mask);\n\n    for (i = 0; i <= length - 8; i += 8) {\n        uint16x8_t vindex = vaddq_u16(vdupq_n_u16(i), vdupq_n_u16(0, 1, 2, 3, 4, 5, 6, 7));\n        uint16x8_t vsrc1 = vld1q_u16(&src1[i]);\n        uint16x8_t vsrc2 = vld1q_u16(&src2[i]);\n        uint16x8_t vcond = vandq_u16(vindex, vmask);\n        uint16x8_t vblend = vbslq_u16(vcond, vsrc1, vsrc2);\n        vst1q_u16(&dst[i], vblend);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = (i & mask) ? src1[i] : src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_15_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i;\n    for (i = 0; i + 7 < length; i += 8) {\n        uint16x8_t src1_val = vld1q_u16(&src1[i]);\n        uint16x8_t src2_val = vld1q_u16(&src2[i]);\n        uint16x8_t result = {0};\n\n        uint16x8_t mask_val = {\n            (i & mask) ? 0xFFFF : 0,\n            (i + 1 & mask) ? 0xFFFF : 0,\n            (i + 2 & mask) ? 0xFFFF : 0,\n            (i + 3 & mask) ? 0xFFFF : 0,\n            (i + 4 & mask) ? 0xFFFF : 0,\n            (i + 5 & mask) ? 0xFFFF : 0,\n            (i + 6 & mask) ? 0xFFFF : 0,\n            (i + 7 & mask) ? 0xFFFF : 0\n        };\n\n        result = vbslq_u16(mask_val, src1_val, src2_val);\n        vst1q_u16(&dst[i], result);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = (i & mask) ? src1[i] : src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_15_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i;\n    for (i = 0; i <= length - 8; i += 8) {\n        uint16x8_t src1_val = vld1q_u16(&src1[i]);\n        uint16x8_t src2_val = vld1q_u16(&src2[i]);\n        uint16x8_t mask_val = vdupq_n_u16(mask);\n        uint16x8_t index_val = vld1q_u16(&dst[i]);\n        uint16x8_t and_result = vandq_u16(index_val, mask_val);\n        uint16x8_t blend_mask = vcgtq_u16(and_result, vdupq_n_u16(0));\n        uint16x8_t result = vbslq_u16(blend_mask, src1_val, src2_val);\n        vst1q_u16(&dst[i], result);\n    }\n\n    for (; i < length; ++i) {\n        uint16_t src1_val = src1[i];\n        uint16_t src2_val = src2[i];\n        uint16_t index_val = i;\n        uint16_t and_result = index_val & mask;\n        uint16_t result = (and_result != 0) ? src1_val : src2_val;\n        dst[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_15_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i;\n    uint16x8_t vmask = vdupq_n_u16(mask);\n\n    for (i = 0; i <= length - 8; i += 8) {\n        uint16x8_t vindex = vaddq_u16(vindex, vdupq_n_u16(8));\n        uint16x8_t vsrc1 = vld1q_u16(&src1[i]);\n        uint16x8_t vsrc2 = vld1q_u16(&src2[i]);\n        uint16x8_t vcond = vandq_u16(vindex, vmask);\n        uint16x8_t vresult = vbslq_u16(vcond, vsrc1, vsrc2);\n        vst1q_u16(&dst[i], vresult);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = (i & mask) ? src1[i] : src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_15_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i;\n    for (i = 0; i + 7 < length; i += 8) {\n        uint16x8_t src1_vec = vld1q_u16(&src1[i]);\n        uint16x8_t src2_vec = vld1q_u16(&src2[i]);\n        uint16x8_t mask_vec = vdupq_n_u16(mask);\n        uint16x8_t index_vec = vld1q_u16(&dst[i]);\n\n        uint16x8_t and_result = vandq_u16(index_vec, mask_vec);\n        uint16x8_t blend_mask = vceqq_u16(and_result, vdupq_n_u16(0));\n\n        uint16x8_t result = vbslq_u16(blend_mask, src2_vec, src1_vec);\n\n        vst1q_u16(&dst[i], result);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = ((i & mask) != 0) ? src1[i] : src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_16_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i;\n    for (i = 0; i <= length - 4; i += 4) {\n        uint32x4_t v = vld1q_u32(&src[i]);\n        uint32x4_t count = vcntq_u32(v);\n        vst1q_u32(&dst[i], count);\n    }\n\n    for (; i < length; ++i) {\n        uint32_t v = src[i];\n        uint32_t count = __builtin_popcount(v);\n        dst[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_16_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i;\n    for (i = 0; i + 3 < length; i += 4) {\n        uint32x4_t v = vld1q_u32(&src[i]);\n        uint32x4_t count = vcntq_u32(v);\n        vst1q_u32(&dst[i], count);\n    }\n    for (; i < length; ++i) {\n        uint32_t v = src[i];\n        uint32_t count = __builtin_popcount(v);\n        dst[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_16_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i;\n    for (i = 0; i + 3 < length; i += 4) {\n        uint32x4_t v = vld1q_u32(&src[i]);\n        uint32x4_t count = vcntq_u32(v);\n        vst1q_u32(&dst[i], count);\n    }\n\n    for (; i < length; ++i) {\n        uint32_t v = src[i];\n        uint32_t count = __builtin_popcount(v);\n        dst[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_16_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i;\n    for (i = 0; i <= length - 4; i += 4) {\n        uint32x4_t v = vld1q_u32(&src[i]);\n        uint32x4_t count = vcntq_u32(v);\n        vst1q_u32(&dst[i], count);\n    }\n    for (; i < length; ++i) {\n        uint32_t v = src[i];\n        uint32_t count = __builtin_popcount(v);\n        dst[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_16_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i;\n    for (i = 0; i <= length - 4; i += 4) {\n        uint32x4_t v = vld1q_u32(&src[i]);\n        uint32x4_t count = vcntq_u32(v);\n        vst1q_u32(&dst[i], count);\n    }\n\n    for (; i < length; ++i) {\n        uint32_t v = src[i];\n        uint32_t count = __builtin_popcount(v);\n        dst[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_17_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i;\n    for (i = 0; i <= length - 8; i += 8) {\n        uint16x8_t v1 = vld1q_u16(&src1[i]);\n        uint16x8_t v2 = vld1q_u16(&src2[i]);\n        uint16x8_t result = vqaddq_u16(v1, v2);\n        vst1q_u16(&dst[i], result);\n    }\n    for (; i < length; ++i) {\n        uint16_t result = src1[i] + src2[i];\n        if (result < src1[i]) {\n            result = UINT16_MAX;\n        }\n        dst[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_17_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i;\n    for (i = 0; i <= length - 8; i += 8) {\n        uint16x8_t v1 = vld1q_u16(&src1[i]);\n        uint16x8_t v2 = vld1q_u16(&src2[i]);\n        uint16x8_t result = vqaddq_u16(v1, v2);\n        vst1q_u16(&dst[i], result);\n    }\n    for (; i < length; ++i) {\n        uint16_t result = src1[i] + src2[i];\n        if (result < src1[i]) {\n            result = UINT16_MAX;\n        }\n        dst[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_17_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i;\n    for (i = 0; i <= length - 8; i += 8) {\n        uint16x8_t v1 = vld1q_u16(&src1[i]);\n        uint16x8_t v2 = vld1q_u16(&src2[i]);\n        uint16x8_t result = vqaddq_u16(v1, v2);\n        vst1q_u16(&dst[i], result);\n    }\n    for (; i < length; ++i) {\n        uint16_t result = src1[i] + src2[i];\n        if (result < src1[i]) {\n            result = UINT16_MAX;\n        }\n        dst[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_17_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i;\n    for (i = 0; i <= length - 8; i += 8) {\n        uint16x8_t v1 = vld1q_u16(&src1[i]);\n        uint16x8_t v2 = vld1q_u16(&src2[i]);\n        uint16x8_t result = vqaddq_u16(v1, v2);\n        vst1q_u16(&dst[i], result);\n    }\n    for (; i < length; ++i) {\n        uint16_t result = src1[i] + src2[i];\n        if (result < src1[i]) {\n            result = UINT16_MAX;\n        }\n        dst[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_17_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i;\n    for (i = 0; i <= length - 8; i += 8) {\n        uint16x8_t v1 = vld1q_u16(&src1[i]);\n        uint16x8_t v2 = vld1q_u16(&src2[i]);\n        uint16x8_t result = vqaddq_u16(v1, v2);\n        vst1q_u16(&dst[i], result);\n    }\n\n    for (; i < length; ++i) {\n        uint16_t result = src1[i] + src2[i];\n        if (result < src1[i]) {\n            result = UINT16_MAX;\n        }\n        dst[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_18_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stddef.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k += 2) {\n                double2_t a_val = vld1q_f64(&A[i * n + k]);\n                double2_t b_val = vld1q_f64(&B[k * p + j]);\n\n                int2_t mask_a = vcgtq_f64(a_val, vdupq_n_f64(-100.0));\n                mask_a = vandq_s64(mask_a, vcltq_f64(a_val, vdupq_n_f64(100.0)));\n\n                int2_t mask_b = vcgtq_f64(b_val, vdupq_n_f64(-100.0));\n                mask_b = vandq_s64(mask_b, vcltq_f64(b_val, vdupq_n_f64(100.0)));\n\n                int2_t mask = vandq_s64(mask_a, mask_b);\n\n                double2_t prod = vmulq_f64(a_val, b_val);\n                prod = vbslq_f64(mask, prod, vdupq_n_f64(0.0));\n\n                sum += vgetq_lane_f64(prod, 0) + vgetq_lane_f64(prod, 1);\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k += 2) {\n                double2_t a_vec = vld1q_f64(&A[i * n + k]);\n                double2_t b_vec = vld1q_f64(&B[k * p + j]);\n\n                uint64x2_t mask_a = vcgtq_f64(a_vec, vdupq_n_f64(-100.0));\n                mask_a = vandq_u64(mask_a, vcltq_f64(a_vec, vdupq_n_f64(100.0)));\n\n                uint64x2_t mask_b = vcgtq_f64(b_vec, vdupq_n_f64(-100.0));\n                mask_b = vandq_u64(mask_b, vcltq_f64(b_vec, vdupq_n_f64(100.0)));\n\n                uint64x2_t mask = vandq_u64(mask_a, mask_b);\n\n                double2_t prod = vmulq_f64(a_vec, b_vec);\n                prod = vbslq_f64(mask, prod, vdupq_n_f64(0.0));\n\n                sum += vgetq_lane_f64(prod, 0) + vgetq_lane_f64(prod, 1);\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stddef.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k += 2) {\n                double2_t a_val = vld1q_f64(&A[i * n + k]);\n                double2_t b_val = vld1q_f64(&B[k * p + j]);\n\n                uint64x2_t mask_a = vcgtq_f64(a_val, vdupq_n_f64(-100.0));\n                mask_a = vandq_u64(mask_a, vcltq_f64(a_val, vdupq_n_f64(100.0)));\n\n                uint64x2_t mask_b = vcgtq_f64(b_val, vdupq_n_f64(-100.0));\n                mask_b = vandq_u64(mask_b, vcltq_f64(b_val, vdupq_n_f64(100.0)));\n\n                uint64x2_t mask = vandq_u64(mask_a, mask_b);\n\n                double2_t prod = vmulq_f64(a_val, b_val);\n                prod = vbslq_f64(mask, prod, vdupq_n_f64(0.0));\n\n                sum += vgetq_lane_f64(prod, 0) + vgetq_lane_f64(prod, 1);\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k += 2) {\n                double2_t a_val = vld1q_f64(&A[i * n + k]);\n                double2_t b_val = vld1q_f64(&B[k * p + j]);\n\n                double2_t mask_a = vandq_f64(vcgeq_f64(a_val, vdupq_n_f64(-100)), vcleq_f64(a_val, vdupq_n_f64(100)));\n                double2_t mask_b = vandq_f64(vcgeq_f64(b_val, vdupq_n_f64(-100)), vcleq_f64(b_val, vdupq_n_f64(100)));\n\n                double2_t mask = vandq_f64(mask_a, mask_b);\n                double2_t prod = vmulq_f64(a_val, b_val);\n                prod = vmulq_f64(prod, mask);\n\n                sum += vgetq_lane_f64(prod, 0) + vgetq_lane_f64(prod, 1);\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stddef.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k += 2) {\n                double2_t a_vec = vld1q_f64(&A[i * n + k]);\n                double2_t b_vec = vld1q_f64(&B[k * p + j]);\n\n                uint64x2_t mask_a = vcgtq_f64(a_vec, vdupq_n_f64(-100.0));\n                mask_a = vandq_u64(mask_a, vcltq_f64(a_vec, vdupq_n_f64(100.0)));\n\n                uint64x2_t mask_b = vcgtq_f64(b_vec, vdupq_n_f64(-100.0));\n                mask_b = vandq_u64(mask_b, vcltq_f64(b_vec, vdupq_n_f64(100.0)));\n\n                uint64x2_t mask = vandq_u64(mask_a, mask_b);\n\n                double2_t prod = vmulq_f64(a_vec, b_vec);\n                prod = vbslq_f64(mask, prod, vdupq_n_f64(0.0));\n\n                sum += vgetq_lane_f64(prod, 0) + vgetq_lane_f64(prod, 1);\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t i;\n\n    for (i = 0; i <= total_size - 2; i += 2) {\n        int64x2_t va = vld1q_s64(&A[i]);\n        int64x2_t vb = vld1q_s64(&B[i]);\n        int64x2_t vc = vaddq_s64(va, vb);\n        vst1q_s64(&C[i], vc);\n    }\n\n    if (i < total_size) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t i;\n\n    for (i = 0; i < total_size - 1; i += 2) {\n        int64x2_t va = vld1q_s64(&A[i]);\n        int64x2_t vb = vld1q_s64(&B[i]);\n        int64x2_t vc = vaddq_s64(va, vb);\n        vst1q_s64(&C[i], vc);\n    }\n\n    if (i < total_size) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t i;\n\n    for (i = 0; i <= total_size - 2; i += 2) {\n        int64x2_t va = vld1q_s64(&A[i]);\n        int64x2_t vb = vld1q_s64(&B[i]);\n        int64x2_t vc = vaddq_s64(va, vb);\n        vst1q_s64(&C[i], vc);\n    }\n\n    if (i < total_size) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t i;\n\n    for (i = 0; i <= total_size - 2; i += 2) {\n        int64x2_t va = vld1q_s64(&A[i]);\n        int64x2_t vb = vld1q_s64(&B[i]);\n        int64x2_t vc = vaddq_s64(va, vb);\n        vst1q_s64(&C[i], vc);\n    }\n\n    if (i < total_size) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t i;\n\n    for (i = 0; i < total_size - 1; i += 2) {\n        int64x2_t va = vld1q_s64(&A[i]);\n        int64x2_t vb = vld1q_s64(&B[i]);\n        int64x2_t vc = vaddq_s64(va, vb);\n        vst1q_s64(&C[i], vc);\n    }\n\n    if (i < total_size) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_20_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    for (i = 0; i <= length - 4; i += 4) {\n        float32x4_t v1 = vld1q_f32(&src1[i]);\n        float32x4_t v2 = vld1q_f32(&src2[i]);\n        float32x4_t v3 = vaddq_f32(v1, v2);\n        float32x4_t v4 = vrndq_f32(v3);\n        vst1q_f32(&dst[i], v4);\n    }\n\n    for (; i < length; ++i) {\n        float result = src1[i] + src2[i];\n        dst[i] = roundf(result);\n    }\n}\n```"}
{"task_id": "SimdBench_20_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    for (i = 0; i <= length - 4; i += 4) {\n        float32x4_t v1 = vld1q_f32(&src1[i]);\n        float32x4_t v2 = vld1q_f32(&src2[i]);\n        float32x4_t result = vaddq_f32(v1, v2);\n        result = vrndq_f32(result);\n        vst1q_f32(&dst[i], result);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = nearbyintf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    for (i = 0; i <= length - 4; i += 4) {\n        float32x4_t v1 = vld1q_f32(&src1[i]);\n        float32x4_t v2 = vld1q_f32(&src2[i]);\n        float32x4_t result = vaddq_f32(v1, v2);\n        result = vrndq_f32(result);\n        vst1q_f32(&dst[i], result);\n    }\n    for (; i < length; ++i) {\n        dst[i] = nearbyintf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    for (i = 0; i <= length - 4; i += 4) {\n        float32x4_t v1 = vld1q_f32(&src1[i]);\n        float32x4_t v2 = vld1q_f32(&src2[i]);\n        float32x4_t vsum = vaddq_f32(v1, v2);\n        float32x4_t vround = vrndq_f32(vsum);\n        vst1q_f32(&dst[i], vround);\n    }\n    for (; i < length; ++i) {\n        dst[i] = nearbyintf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    for (i = 0; i <= length - 4; i += 4) {\n        float32x4_t v1 = vld1q_f32(&src1[i]);\n        float32x4_t v2 = vld1q_f32(&src2[i]);\n        float32x4_t vsum = vaddq_f32(v1, v2);\n        float32x4_t vround = vrndq_f32(vsum);\n        vst1q_f32(&dst[i], vround);\n    }\n    for (; i < length; ++i) {\n        dst[i] = nearbyintf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_21_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    float32x4_t v_50 = vdupq_n_f32(50.0f);\n    float32x4_t v_neg_1 = vdupq_n_f32(-1.0f);\n\n    for (size_t i = 0; i < length; i += 4) {\n        float32x4_t v1 = vld1q_f32(&src1[i]);\n        float32x4_t v2 = vld1q_f32(&src2[i]);\n\n        float32x4_t v_diff = vabsq_f32(vsubq_f32(v1, v2));\n        uint32x4_t v_mask = vcleq_f32(v_diff, v_50);\n\n        float32x4_t v_mul = vmulq_f32(v1, v2);\n        float32x4_t v_round = vrndpq_f32(v_mul);\n\n        float32x4_t v_result = vbslq_f32(v_mask, v_round, v_neg_1);\n\n        vst1q_f32(&dst[i], v_result);\n    }\n\n    for (size_t i = 0; i < length; i += 2) {\n        if (i + 1 < length && (i % 2 == 0)) {\n            dst[i + 1] = ceilf(src1[i + 1] * src2[i + 1]);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    float32x4_t v_abs_diff_limit = vdupq_n_f32(50.0f);\n    float32x4_t v_negative_one = vdupq_n_f32(-1.0f);\n\n    for (i = 0; i < length - 3; i += 4) {\n        if (i % 2 == 0) {\n            float32x4_t v_src1 = vld1q_f32(&src1[i]);\n            float32x4_t v_src2 = vld1q_f32(&src2[i]);\n            float32x4_t v_abs_diff = vabsq_f32(vsubq_f32(v_src1, v_src2));\n            uint32x4_t v_mask = vcleq_f32(v_abs_diff, v_abs_diff_limit);\n\n            float32x4_t v_result = vmulq_f32(v_src1, v_src2);\n            v_result = vbslq_f32(v_mask, v_result, v_negative_one);\n            v_result = vrndpq_f32(v_result);\n\n            vst1q_f32(&dst[i], v_result);\n        } else {\n            vst1q_f32(&dst[i], v_negative_one);\n        }\n    }\n\n    for (; i < length; i++) {\n        if (i % 2 == 0 && fabsf(src1[i] - src2[i]) <= 50.0f) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    float32x4_t v_abs_diff_limit = vdupq_n_f32(50.0f);\n    float32x4_t v_negative_one = vdupq_n_f32(-1.0f);\n\n    for (size_t i = 0; i < length; i += 4) {\n        float32x4_t v_src1 = vld1q_f32(&src1[i]);\n        float32x4_t v_src2 = vld1q_f32(&src2[i]);\n\n        float32x4_t v_abs_diff = vabsq_f32(vsubq_f32(v_src1, v_src2));\n        uint32x4_t v_mask = vcleq_f32(v_abs_diff, v_abs_diff_limit);\n\n        float32x4_t v_result = vmulq_f32(v_src1, v_src2);\n        v_result = vbslq_f32(v_mask, v_result, v_negative_one);\n\n        if (i % 2 == 0) {\n            v_result = vrndpq_f32(v_result);\n        } else {\n            v_result = v_negative_one;\n        }\n\n        vst1q_f32(&dst[i], v_result);\n    }\n}\n```"}
{"task_id": "SimdBench_21_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    float32x4_t v_abs_diff_max = vdupq_n_f32(50.0f);\n    float32x4_t v_negative_one = vdupq_n_f32(-1.0f);\n\n    for (i = 0; i < length - 3; i += 4) {\n        if (i % 2 == 0) {\n            float32x4_t v_src1 = vld1q_f32(&src1[i]);\n            float32x4_t v_src2 = vld1q_f32(&src2[i]);\n            float32x4_t v_abs_diff = vabsq_f32(vsubq_f32(v_src1, v_src2));\n\n            uint32x4_t v_mask = vcleq_f32(v_abs_diff, v_abs_diff_max);\n            float32x4_t v_mul = vmulq_f32(v_src1, v_src2);\n            float32x4_t v_result = vbslq_f32(v_mask, v_mul, v_negative_one);\n\n            v_result = vrndpq_f32(v_result); // Round up toward positive infinity\n            vst1q_f32(&dst[i], v_result);\n        } else {\n            vst1q_f32(&dst[i], v_negative_one);\n        }\n    }\n\n    for (; i < length; i++) {\n        if (i % 2 == 0 && fabsf(src1[i] - src2[i]) <= 50.0f) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    float32x4_t v_abs_diff_limit = vdupq_n_f32(50.0f);\n    float32x4_t v_negative_one = vdupq_n_f32(-1.0f);\n\n    for (i = 0; i < length - 3; i += 4) {\n        if (i % 2 == 0) {\n            float32x4_t v_src1 = vld1q_f32(&src1[i]);\n            float32x4_t v_src2 = vld1q_f32(&src2[i]);\n            float32x4_t v_abs_diff = vabsq_f32(vsubq_f32(v_src1, v_src2));\n\n            uint32x4_t v_mask = vcleq_f32(v_abs_diff, v_abs_diff_limit);\n            float32x4_t v_result = vmulq_f32(v_src1, v_src2);\n            v_result = vbslq_f32(v_mask, v_result, v_negative_one);\n\n            v_result = vrndpq_f32(v_result); // Round up toward positive infinity\n            vst1q_f32(&dst[i], v_result);\n        } else {\n            vst1q_f32(&dst[i], v_negative_one);\n        }\n    }\n\n    for (; i < length; i++) {\n        if (i % 2 == 0 && fabsf(src1[i] - src2[i]) <= 50.0f) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_22_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    float64x2_t vscalar = vdupq_n_f64(scalar);\n\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < n; j += 2) {\n            float64x2_t vmat = vld1q_f64(&mat[i * n + j]);\n            float64x2_t vresult = vmulq_f64(vmat, vscalar);\n            vst1q_f64(&dst[i * n + j], vresult);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_22_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    float64x2_t v_scalar = vdupq_n_f64(scalar);\n\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < n; j += 2) {\n            float64x2_t v_mat = vld1q_f64(&mat[i * n + j]);\n            float64x2_t v_result = vmulq_f64(v_mat, v_scalar);\n            vst1q_f64(&dst[i * n + j], v_result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_22_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    float64x2_t vscalar = vdupq_n_f64(scalar);\n\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < n; j += 2) {\n            float64x2_t vmat = vld1q_f64(&mat[i * n + j]);\n            float64x2_t vresult = vmulq_f64(vmat, vscalar);\n            vst1q_f64(&dst[i * n + j], vresult);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_22_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    float64x2_t vscalar = vdupq_n_f64(scalar);\n\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < n; j += 2) {\n            float64x2_t vmat = vld1q_f64(&mat[i * n + j]);\n            float64x2_t vresult = vmulq_f64(vmat, vscalar);\n            vst1q_f64(&dst[i * n + j], vresult);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_22_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t i, j;\n    float64x2_t v_scalar = vdupq_n_f64(scalar);\n\n    for (i = 0; i < m; ++i) {\n        for (j = 0; j < n; j += 2) {\n            float64x2_t v_mat = vld1q_f64(&mat[i * n + j]);\n            float64x2_t v_result = vmulq_f64(v_mat, v_scalar);\n            vst1q_f64(&dst[i * n + j], v_result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float* row = mat + i * n;\n        float32x4_t sum = vdupq_n_f32(0.0f);\n        size_t j;\n\n        for (j = 0; j <= n - 4; j += 4) {\n            float32x4_t chunk = vld1q_f32(&row[j]);\n            sum = vaddq_f32(sum, vmulq_f32(chunk, chunk));\n        }\n\n        float temp[4];\n        vst1q_f32(temp, sum);\n        float row_sum = temp[0] + temp[1] + temp[2] + temp[3];\n\n        for (; j < n; ++j) {\n            row_sum += row[j] * row[j];\n        }\n\n        float norm = 1.0f / sqrtf(row_sum);\n        float32x4_t norm_vec = vdupq_n_f32(norm);\n\n        for (j = 0; j <= n - 4; j += 4) {\n            float32x4_t chunk = vld1q_f32(&row[j]);\n            chunk = vmulq_f32(chunk, norm_vec);\n            vst1q_f32(&row[j], chunk);\n        }\n\n        for (; j < n; ++j) {\n            row[j] *= norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float* row = mat + i * n;\n        float32x4_t sum = vdupq_n_f32(0.0f);\n        size_t j;\n\n        for (j = 0; j <= n - 4; j += 4) {\n            float32x4_t chunk = vld1q_f32(row + j);\n            sum = vaddq_f32(sum, vmulq_f32(chunk, chunk));\n        }\n\n        float temp[4];\n        vst1q_f32(temp, sum);\n        float row_sum = temp[0] + temp[1] + temp[2] + temp[3];\n\n        for (; j < n; ++j) {\n            row_sum += row[j] * row[j];\n        }\n\n        float norm = 1.0f / sqrtf(row_sum);\n        float32x4_t norm_vec = vdupq_n_f32(norm);\n\n        for (j = 0; j <= n - 4; j += 4) {\n            float32x4_t chunk = vld1q_f32(row + j);\n            chunk = vmulq_f32(chunk, norm_vec);\n            vst1q_f32(row + j, chunk);\n        }\n\n        for (; j < n; ++j) {\n            row[j] *= norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float sum = 0.0f;\n        float* row = mat + i * n;\n\n        // Calculate the sum of squares of the row elements\n        for (size_t j = 0; j < n; j += 4) {\n            float32x4_t v = vld1q_f32(&row[j]);\n            float32x4_t v_sq = vmulq_f32(v, v);\n            float32x2_t v_sq_low = vget_low_f32(v_sq);\n            float32x2_t v_sq_high = vget_high_f32(v_sq);\n            v_sq_low = vpadd_f32(v_sq_low, v_sq_low);\n            v_sq_high = vpadd_f32(v_sq_high, v_sq_high);\n            v_sq_low = vpadd_f32(v_sq_low, v_sq_high);\n            sum += vget_lane_f32(vpadd_f32(v_sq_low, v_sq_low), 0);\n        }\n\n        // Calculate the L^2 norm\n        float norm = sqrtf(sum);\n\n        // Normalize the row elements\n        for (size_t j = 0; j < n; j += 4) {\n            float32x4_t v = vld1q_f32(&row[j]);\n            float32x4_t norm_v = vdupq_n_f32(norm);\n            float32x4_t normalized = vdivq_f32(v, norm_v);\n            vst1q_f32(&row[j], normalized);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float* row = mat + i * n;\n        float32x4_t sum = vdupq_n_f32(0.0f);\n        size_t j;\n\n        for (j = 0; j <= n - 4; j += 4) {\n            float32x4_t data = vld1q_f32(row + j);\n            sum = vaddq_f32(sum, vmulq_f32(data, data));\n        }\n\n        float temp[4];\n        vst1q_f32(temp, sum);\n        float row_sum = temp[0] + temp[1] + temp[2] + temp[3];\n\n        for (; j < n; ++j) {\n            row_sum += row[j] * row[j];\n        }\n\n        float norm = 1.0f / sqrtf(row_sum);\n        float32x4_t norm_vec = vdupq_n_f32(norm);\n\n        for (j = 0; j <= n - 4; j += 4) {\n            float32x4_t data = vld1q_f32(row + j);\n            data = vmulq_f32(data, norm_vec);\n            vst1q_f32(row + j, data);\n        }\n\n        for (; j < n; ++j) {\n            row[j] *= norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float* row = mat + i * n;\n        float32x4_t sum = vdupq_n_f32(0.0f);\n        size_t j;\n\n        for (j = 0; j <= n - 4; j += 4) {\n            float32x4_t data = vld1q_f32(row + j);\n            sum = vaddq_f32(sum, vmulq_f32(data, data));\n        }\n\n        float temp[4];\n        vst1q_f32(temp, sum);\n        float row_sum = temp[0] + temp[1] + temp[2] + temp[3];\n\n        for (; j < n; ++j) {\n            row_sum += row[j] * row[j];\n        }\n\n        float norm = 1.0f / sqrtf(row_sum);\n        float32x4_t norm_vec = vdupq_n_f32(norm);\n\n        for (j = 0; j <= n - 4; j += 4) {\n            float32x4_t data = vld1q_f32(row + j);\n            data = vmulq_f32(data, norm_vec);\n            vst1q_f32(row + j, data);\n        }\n\n        for (; j < n; ++j) {\n            row[j] *= norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            float64x2_t sum = vdupq_n_f64(0);\n            for (size_t k = 0; k < n; k += 2) {\n                float64x2_t a = vld1q_dup_f64(&mat1[i * n + k]);\n                float64x2_t b = vld1q_f64(&mat2[k * p + j]);\n                sum = vaddq_f64(sum, vmulq_f64(a, b));\n            }\n            float64x2_t rounded = vrndiq_f64(sum);\n            vst1q_f64(&dst[i * p + j], rounded);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            float64x2_t sum = vdupq_n_f64(0);\n            for (size_t k = 0; k < n; k += 2) {\n                float64x2_t a = vld1q_dup_f64(&mat1[i * n + k]);\n                float64x2_t b = vld1q_dup_f64(&mat2[k * p + j]);\n                sum = vaddq_f64(sum, vmulq_f64(a, b));\n            }\n            float64x1_t result = vadd_f64(vget_high_f64(sum), vget_low_f64(sum));\n            dst[i * p + j] = nearbyint(vget_lane_f64(result, 0));\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            float64x2_t sum = vdupq_n_f64(0);\n            for (size_t k = 0; k < n; k += 2) {\n                float64x2_t a = vld1q_f64(&mat1[i * n + k]);\n                float64x2_t b = vld1q_f64(&mat2[k * p + j]);\n                sum = vaddq_f64(sum, vmulq_f64(a, b));\n            }\n            float64x1_t sum_low = vadd_f64(vget_low_f64(sum), vget_high_f64(sum));\n            double result;\n            vst1_f64(&result, sum_low);\n            dst[i * p + j] = round(result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            float64x2_t sum = vdupq_n_f64(0);\n            for (size_t k = 0; k < n; k += 2) {\n                float64x2_t a = vld1q_dup_f64(&mat1[i * n + k]);\n                float64x2_t b = vld1q_dup_f64(&mat2[k * p + j]);\n                sum = vaddq_f64(sum, vmulq_f64(a, b));\n            }\n            float64x1_t result = vadd_f64(vget_high_f64(sum), vget_low_f64(sum));\n            dst[i * p + j] = round(vget_lane_f64(result, 0));\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            float64x2_t sum = vdupq_n_f64(0);\n            for (size_t k = 0; k < n; k += 2) {\n                float64x2_t a = vld1q_f64(&mat1[i * n + k]);\n                float64x2_t b = vld1q_f64(&mat2[k * p + j]);\n                sum = vaddq_f64(sum, vmulq_f64(a, b));\n            }\n            float64x2_t result = vrndq_f64(sum);\n            vst1q_f64(&dst[i * p + j], result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    float32x4_t vmagic = vdupq_n_f32(4.0f);\n    float32x4_t vmagic_half = vdupq_n_f32(2.0f);\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; j += 4) {\n            float32x4_t vsrc = vld1q_f32(&src[i * cols + j]);\n            float32x4_t scaled = vmulq_f32(vsrc, vmagic);\n            float32x4_t rounded = vrndq_f32(scaled);\n            float32x4_t result = vdivq_f32(rounded, vmagic_half);\n            vst1q_f32(&dst[j * rows + i], result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    float32x4_t v_quarter = vdupq_n_f32(0.25f);\n    float32x4_t v_half = vdupq_n_f32(0.5f);\n\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; j += 4) {\n            float32x4_t v_src = vld1q_f32(&src[i * cols + j]);\n            float32x4_t v_rounded = vrndq_f32(vmlaq_f32(v_half, v_src, v_quarter));\n            vst1q_f32(&dst[j * rows + i], v_rounded);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    const float quarter = 0.25f;\n    float32x4_t vquarter = vdupq_n_f32(quarter);\n    float32x4_t vtwo = vdupq_n_f32(2.0f);\n\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            float32x4_t vsrc = vld1q_f32(&src[j * rows + i]);\n            float32x4_t vrounded = vrndq_f32(vaddq_f32(vmulq_f32(vsrc, vtwo), vquarter));\n            vst1q_f32(&dst[i * cols + j], vrounded);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    float32x4_t quarter = vdupq_n_f32(0.25f);\n    float32x4_t half = vdupq_n_f32(0.5f);\n\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; j += 4) {\n            float32x4_t row_data = vld1q_f32(&src[i * cols + j]);\n            float32x4_t rounded = vmlaq_f32(vsubq_f32(row_data, half), quarter, vcvtq_f32_s32(vcvtq_s32_f32(vaddq_f32(row_data, half))));\n\n            float temp[4];\n            vst1q_f32(temp, rounded);\n\n            for (size_t k = 0; k < 4; ++k) {\n                if (j + k < cols) {\n                    dst[(j + k) * rows + i] = temp[k];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    float32x4_t v0_25 = vdupq_n_f32(0.25f);\n    float32x4_t v0_5 = vdupq_n_f32(0.5f);\n    float32x4_t v0_75 = vdupq_n_f32(0.75f);\n\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            float32x4_t v = vld1q_f32(&src[i * cols + j]);\n            float32x4_t frac = vsubq_f32(v, vcvtq_f32_s32(vcvtq_s32_f32(v)));\n\n            uint32x4_t mask0 = vcgeq_f32(frac, v0_5);\n            uint32x4_t mask1 = vcltq_f32(frac, v0_5) & vcgeq_f32(frac, v0_25);\n            uint32x4_t mask2 = vcltq_f32(frac, v0_25) & vcgeq_f32(frac, v0_75);\n\n            float32x4_t rounded = vbslq_f32(mask0, vaddq_f32(v, v0_5), v);\n            rounded = vbslq_f32(mask1, vaddq_f32(rounded, v0_25), rounded);\n            rounded = vbslq_f32(mask2, vsubq_f32(rounded, v0_25), rounded);\n\n            vst1q_f32(&dst[j * rows + i], rounded);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t i;\n\n    for (i = 0; i < total_size - 3; i += 4) {\n        float32x4_t v1 = vld1q_f32(&tensor1[i]);\n        float32x4_t v2 = vld1q_f32(&tensor2[i]);\n        float32x4_t result = vsubq_f32(v1, v2);\n        int32x4_t rounded = vrndq_f32(result);\n        vst1q_f32(&dst[i], rounded);\n    }\n\n    for (; i < total_size; ++i) {\n        float result = tensor1[i] - tensor2[i];\n        dst[i] = (result > 0) ? floorf(result) : ceilf(result);\n    }\n}\n```"}
{"task_id": "SimdBench_26_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t i;\n\n    for (i = 0; i < total_size - 3; i += 4) {\n        float32x4_t v1 = vld1q_f32(&tensor1[i]);\n        float32x4_t v2 = vld1q_f32(&tensor2[i]);\n        float32x4_t vsub = vsubq_f32(v1, v2);\n        int32x4_t vround = vcvtq_s32_f32(vsub);\n        float32x4_t vresult = vcvtq_f32_s32(vround);\n        vst1q_f32(&dst[i], vresult);\n    }\n\n    for (; i < total_size; ++i) {\n        float result = tensor1[i] - tensor2[i];\n        dst[i] = (result > 0) ? floorf(result) : ceilf(result);\n    }\n}\n```"}
{"task_id": "SimdBench_26_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t i;\n\n    for (i = 0; i + 3 < total_size; i += 4) {\n        float32x4_t v1 = vld1q_f32(&tensor1[i]);\n        float32x4_t v2 = vld1q_f32(&tensor2[i]);\n        float32x4_t vsub = vsubq_f32(v1, v2);\n        int32x4_t vround = vcvtq_s32_f32(vsub);\n        vst1q_f32(&dst[i], vcvtq_f32_s32(vround));\n    }\n\n    for (; i < total_size; ++i) {\n        float result = tensor1[i] - tensor2[i];\n        dst[i] = (result > 0) ? floorf(result) : ceilf(result);\n    }\n}\n```"}
{"task_id": "SimdBench_26_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t i;\n\n    for (i = 0; i + 3 < total_size; i += 4) {\n        float32x4_t v1 = vld1q_f32(&tensor1[i]);\n        float32x4_t v2 = vld1q_f32(&tensor2[i]);\n        float32x4_t result = vsubq_f32(v1, v2);\n        int32x4_t rounded = vrndq_f32(result);\n        vst1q_f32(&dst[i], rounded);\n    }\n\n    for (; i < total_size; ++i) {\n        float result = tensor1[i] - tensor2[i];\n        dst[i] = nearbyintf(result);\n    }\n}\n```"}
{"task_id": "SimdBench_26_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t i;\n\n    for (i = 0; i <= total_size - 4; i += 4) {\n        float32x4_t v1 = vld1q_f32(&tensor1[i]);\n        float32x4_t v2 = vld1q_f32(&tensor2[i]);\n        float32x4_t vsub = vsubq_f32(v1, v2);\n        int32x4_t vround = vrndq_f32(vsub);\n        vst1q_f32(&dst[i], vcvtq_f32_s32(vround));\n    }\n\n    for (; i < total_size; ++i) {\n        float result = tensor1[i] - tensor2[i];\n        dst[i] = (result > 0) ? floorf(result) : ceilf(result);\n    }\n}\n```"}
{"task_id": "SimdBench_27_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < n; j += 2) {\n            float64x2_t v1 = vld1q_f64(&mat1[i * n + j]);\n            float64x2_t v2 = vld1q_f64(&mat2[i * n + j]);\n            float64x2_t result = vmulq_f64(v1, v2);\n            vst1q_f64(&dst[i * n + j], result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_27_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < n; j += 2) {\n            float64x2_t v1 = vld1q_f64(&mat1[i * n + j]);\n            float64x2_t v2 = vld1q_f64(&mat2[i * n + j]);\n            float64x2_t result = vmulq_f64(v1, v2);\n            vst1q_f64(&dst[i * n + j], result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_27_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t i, j;\n    for (i = 0; i < m; ++i) {\n        for (j = 0; j < n; j += 2) {\n            float64x2_t v1 = vld1q_f64(&mat1[i * n + j]);\n            float64x2_t v2 = vld1q_f64(&mat2[i * n + j]);\n            float64x2_t result = vmulq_f64(v1, v2);\n            vst1q_f64(&dst[i * n + j], result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_27_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t i, j;\n    for (i = 0; i < m; ++i) {\n        for (j = 0; j < n; j += 2) {\n            float64x2_t v1 = vld1q_f64(&mat1[i * n + j]);\n            float64x2_t v2 = vld1q_f64(&mat2[i * n + j]);\n            float64x2_t result = vmulq_f64(v1, v2);\n            vst1q_f64(&dst[i * n + j], result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_27_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t i, j;\n    for (i = 0; i < m; ++i) {\n        for (j = 0; j < n; j += 2) {\n            float64x2_t v1 = vld1q_f64(&mat1[i * n + j]);\n            float64x2_t v2 = vld1q_f64(&mat2[i * n + j]);\n            float64x2_t result = vmulq_f64(v1, v2);\n            vst1q_f64(&dst[i * n + j], result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_28_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    size_t i, j;\n    for (i = 0; i < m; ++i) {\n        float32x4_t sum = vdupq_n_f32(0.0f);\n        for (j = 0; j < n; j += 4) {\n            float32x4_t vec_chunk = vld1q_f32(&vec[j]);\n            float32x4_t mat_chunk = vld1q_f32(&mat[i * n + j]);\n            sum = vmlaq_f32(sum, mat_chunk, vec_chunk);\n        }\n        float temp[4];\n        vst1q_f32(temp, sum);\n        dst[i] = temp[0] + temp[1] + temp[2] + temp[3];\n    }\n}\n```"}
{"task_id": "SimdBench_28_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    size_t i, j;\n    for (i = 0; i < m; ++i) {\n        float32x4_t sum = vdupq_n_f32(0.0f);\n        for (j = 0; j < n; j += 4) {\n            float32x4_t vecVals = vld1q_f32(&vec[j]);\n            float32x4_t matVals = vld1q_f32(&mat[i * n + j]);\n            sum = vmlaq_f32(sum, matVals, vecVals);\n        }\n        float temp[4];\n        vst1q_f32(temp, sum);\n        dst[i] = temp[0] + temp[1] + temp[2] + temp[3];\n    }\n}\n```"}
{"task_id": "SimdBench_28_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    size_t i, j;\n    for (i = 0; i < m; ++i) {\n        float32x4_t sum = vdupq_n_f32(0.0f);\n        for (j = 0; j < n; j += 4) {\n            float32x4_t vec_chunk = vld1q_f32(&vec[j]);\n            float32x4_t mat_chunk = vld1q_f32(&mat[i * n + j]);\n            sum = vmlaq_f32(sum, vec_chunk, mat_chunk);\n        }\n        float32x2_t sum_low = vadd_f32(vget_low_f32(sum), vget_high_f32(sum));\n        float32x2_t sum_final = vpadd_f32(sum_low, sum_low);\n        dst[i] = vget_lane_f32(sum_final, 0);\n    }\n}\n```"}
{"task_id": "SimdBench_28_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    size_t i, j;\n    for (i = 0; i < m; ++i) {\n        float32x4_t sum = vdupq_n_f32(0.0f);\n        for (j = 0; j < n; j += 4) {\n            float32x4_t vec_chunk = vld1q_f32(&vec[j]);\n            float32x4_t mat_chunk = vld1q_f32(&mat[i * n + j]);\n            sum = vmlaq_f32(sum, mat_chunk, vec_chunk);\n        }\n        float32x2_t sum_low = vadd_f32(vget_low_f32(sum), vget_high_f32(sum));\n        float32x2_t sum_final = vpadd_f32(sum_low, sum_low);\n        dst[i] = vget_lane_f32(sum_final, 0);\n    }\n}\n```"}
{"task_id": "SimdBench_28_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    size_t i, j;\n    for (i = 0; i < m; ++i) {\n        float32x4_t sum = vdupq_n_f32(0.0f);\n        for (j = 0; j < n; j += 4) {\n            float32x4_t vecVal = vld1q_f32(&vec[j]);\n            float32x4_t matVal = vld1q_f32(&mat[i * n + j]);\n            sum = vmlaq_f32(sum, matVal, vecVal);\n        }\n        float32x2_t sum_low = vadd_f32(vget_low_f32(sum), vget_high_f32(sum));\n        float32x2_t sum_final = vpadd_f32(sum_low, sum_low);\n        dst[i] = vget_lane_f32(sum_final, 0);\n    }\n}\n```"}
{"task_id": "SimdBench_29_Neon", "completion": "```c\n#include <arm_neon.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    double sum = 0.0;\n\n    size_t i = 0;\n    for (; i <= total_elements - 2; i += 2) {\n        float64x2_t v = vld1q_f64(&mat[i]);\n        float64x2_t sum_v = vaddq_f64(v, v);\n        sum += vgetq_lane_f64(sum_v, 0) + vgetq_lane_f64(sum_v, 1);\n    }\n\n    for (; i < total_elements; ++i) {\n        sum += mat[i];\n    }\n\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_Neon", "completion": "```c\n#include <arm_neon.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    double sum = 0.0;\n\n    size_t i = 0;\n    for (; i <= total_elements - 2; i += 2) {\n        float64x2_t v = vld1q_f64(&mat[i]);\n        float64x2_t sum_v = vaddq_f64(v, v);\n        sum += vgetq_lane_f64(sum_v, 0) + vgetq_lane_f64(sum_v, 1);\n    }\n\n    for (; i < total_elements; ++i) {\n        sum += mat[i];\n    }\n\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_Neon", "completion": "```c\n#include <arm_neon.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t totalElements = m * n;\n    double sum = 0.0;\n\n    size_t i = 0;\n    for (; i <= totalElements - 2; i += 2) {\n        float64x2_t v = vld1q_f64(&mat[i]);\n        float64x2_t sum_v = vaddq_f64(vld1q_f64(&sum), v);\n        vst1q_f64(&sum, sum_v);\n    }\n\n    for (; i < totalElements; ++i) {\n        sum += mat[i];\n    }\n\n    return sum / totalElements;\n}\n```"}
{"task_id": "SimdBench_29_Neon", "completion": "```c\n#include <arm_neon.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i;\n    double sum = 0.0;\n    double sum_temp = 0.0;\n\n    for (i = 0; i < total_elements - 1; i += 2) {\n        double2_t v = vld1q_f64(&mat[i]);\n        double2_t sum_v = vaddq_f64(v, v);\n        sum_temp += vgetq_lane_f64(sum_v, 0) + vgetq_lane_f64(sum_v, 1);\n    }\n\n    if (i < total_elements) {\n        sum_temp += mat[i];\n    }\n\n    sum = sum_temp;\n\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_Neon", "completion": "```c\n#include <arm_neon.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    double sum = 0.0;\n\n    size_t i = 0;\n    for (; i <= total_elements - 2; i += 2) {\n        float64x2_t v = vld1q_f64(&mat[i]);\n        float64x2_t sum_v = vaddq_f64(v, v);\n        sum += vgetq_lane_f64(sum_v, 0) + vgetq_lane_f64(sum_v, 1);\n    }\n\n    for (; i < total_elements; ++i) {\n        sum += mat[i];\n    }\n\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_30_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool ascending = directions[i];\n        size_t j;\n        for (j = 0; j <= cols - 4; j += 4) {\n            int32x4_t v1 = vld1q_s32(&matrix[i * cols + j]);\n            int32x4_t v2 = vld1q_s32(&matrix[i * cols + j + 1]);\n            uint32x4_t cmp;\n            if (ascending) {\n                cmp = vcltq_s32(v1, v2);\n            } else {\n                cmp = vcgtq_s32(v1, v2);\n            }\n            if (vminvq_u32(cmp) == 0) {\n                return false;\n            }\n        }\n        for (; j < cols - 1; ++j) {\n            if ((ascending && matrix[i * cols + j] > matrix[i * cols + j + 1]) ||\n                (!ascending && matrix[i * cols + j] < matrix[i * cols + j + 1])) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool ascending = directions[i];\n        for (size_t j = 0; j < cols - 3; j += 4) {\n            int32x4_t v = vld1q_s32(&matrix[i * cols + j]);\n            int32x4_t next_v = vld1q_s32(&matrix[i * cols + j + 1]);\n\n            uint32x4_t cmp;\n            if (ascending) {\n                cmp = vcleq_s32(v, next_v);\n            } else {\n                cmp = vcleq_s32(next_v, v);\n            }\n\n            if (!vgetq_lane_u32(cmp, 0) || !vgetq_lane_u32(cmp, 1) || !vgetq_lane_u32(cmp, 2) || !vgetq_lane_u32(cmp, 3)) {\n                return false;\n            }\n        }\n\n        for (size_t j = (cols / 4) * 4; j < cols - 1; ++j) {\n            if (ascending && matrix[i * cols + j] > matrix[i * cols + j + 1]) {\n                return false;\n            }\n            if (!ascending && matrix[i * cols + j] < matrix[i * cols + j + 1]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool ascending = directions[i];\n        size_t j;\n        for (j = 0; j <= cols - 4; j += 4) {\n            int32x4_t v = vld1q_s32(&matrix[i * cols + j]);\n            int32x4_t next_v = vld1q_s32(&matrix[i * cols + j + 1]);\n            uint32x4_t cmp;\n            if (ascending) {\n                cmp = vcleq_s32(v, next_v);\n            } else {\n                cmp = vcleq_s32(next_v, v);\n            }\n            if (!vminvq_u32(cmp)) {\n                return false;\n            }\n        }\n        for (; j < cols - 1; ++j) {\n            if (ascending && matrix[i * cols + j] > matrix[i * cols + j + 1]) {\n                return false;\n            }\n            if (!ascending && matrix[i * cols + j] < matrix[i * cols + j + 1]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool ascending = directions[i];\n        size_t j;\n        for (j = 0; j <= cols - 4; j += 4) {\n            int32x4_t v1 = vld1q_s32(&matrix[i * cols + j]);\n            int32x4_t v2 = vld1q_s32(&matrix[i * cols + j + 1]);\n            uint32x4_t cmp;\n            if (ascending) {\n                cmp = vcleq_s32(v1, v2);\n            } else {\n                cmp = vcgeq_s32(v1, v2);\n            }\n            if (!vminvq_u32(cmp)) {\n                return false;\n            }\n        }\n        for (; j < cols - 1; ++j) {\n            if (ascending && matrix[i * cols + j] > matrix[i * cols + j + 1]) {\n                return false;\n            }\n            if (!ascending && matrix[i * cols + j] < matrix[i * cols + j + 1]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool isAscending = directions[i];\n        for (size_t j = 0; j < cols - 3; j += 4) {\n            int32x4_t v = vld1q_s32(&matrix[i * cols + j]);\n            int32x4_t next_v = vld1q_s32(&matrix[i * cols + j + 1]);\n\n            uint32x4_t cmp;\n            if (isAscending) {\n                cmp = vcleq_s32(v, next_v);\n            } else {\n                cmp = vcgeq_s32(v, next_v);\n            }\n\n            if (!vminvq_u32(cmp)) {\n                return false;\n            }\n        }\n\n        for (size_t j = (cols & ~3); j < cols - 1; ++j) {\n            if ((isAscending && matrix[i * cols + j] > matrix[i * cols + j + 1]) ||\n                (!isAscending && matrix[i * cols + j] < matrix[i * cols + j + 1])) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_31_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stddef.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    int16x8_t vbase = vdupq_n_s16(base);\n    size_t i;\n\n    for (i = 0; i <= length - 8; i += 8) {\n        int16x8_t vsrc = vld1q_s16(&src[i]);\n        int16x8_t vrem = vqsubq_s16(vsrc, vdupq_n_s16(vsrc[0] % base));\n        vst1q_s16(&dst[i], vrem);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = src[i] - (src[i] % base);\n    }\n}\n```"}
{"task_id": "SimdBench_31_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    int16x8_t vbase = vdupq_n_s16(base);\n    size_t i;\n\n    for (i = 0; i + 7 < length; i += 8) {\n        int16x8_t vsrc = vld1q_s16(&src[i]);\n        int16x8_t vrem = vqsubq_s16(vsrc, vqdmulhq_s16(vsrc, vbase));\n        int16x8_t vresult = vqsubq_s16(vsrc, vrem);\n        vst1q_s16(&dst[i], vresult);\n    }\n\n    for (; i < length; i++) {\n        int16_t rem = src[i] % base;\n        dst[i] = src[i] - rem;\n    }\n}\n```"}
{"task_id": "SimdBench_31_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stddef.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    int16x8_t vbase = vdupq_n_s16(base);\n    size_t i;\n\n    for (i = 0; i + 7 < length; i += 8) {\n        int16x8_t vsrc = vld1q_s16(&src[i]);\n        int16x8_t vrem = vqsubq_s16(vsrc, vqdmulhq_s16(vsrc, vbase));\n        int16x8_t vdst = vqsubq_s16(vsrc, vrem);\n        vst1q_s16(&dst[i], vdst);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = (src[i] / base) * base;\n    }\n}\n```"}
{"task_id": "SimdBench_31_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stddef.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    int16x8_t vbase = vdupq_n_s16(base);\n    size_t i;\n\n    for (i = 0; i + 7 < length; i += 8) {\n        int16x8_t vsrc = vld1q_s16(&src[i]);\n        int16x8_t vrem = vqsubq_s16(vsrc, vqdmulhq_s16(vsrc, vbase));\n        int16x8_t vdst = vqsubq_s16(vsrc, vrem);\n        vst1q_s16(&dst[i], vdst);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = (src[i] / base) * base;\n    }\n}\n```"}
{"task_id": "SimdBench_31_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    int16x8_t vbase = vdupq_n_s16(base);\n    size_t i;\n\n    for (i = 0; i <= length - 8; i += 8) {\n        int16x8_t vsrc = vld1q_s16(&src[i]);\n        int16x8_t vrem = vqsubq_s16(vsrc, vqdmulhq_s16(vsrc, vbase));\n        int16x8_t vdst = vqsubq_s16(vsrc, vrem);\n        vst1q_s16(&dst[i], vdst);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = (src[i] / base) * base;\n    }\n}\n```"}
{"task_id": "SimdBench_32_Neon", "completion": "```c\n#include <arm_neon.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    size_t cols_aligned = cols & ~(sizeof(float64x2_t) / sizeof(double) - 1);\n    float64x2_t vec0 = vld1q_f64(vector);\n    float64x2_t vec1 = vld1q_f64(vector + 2);\n\n    for (size_t i = 0; i < rows; ++i) {\n        bool match = true;\n        for (size_t j = 0; j < cols_aligned; j += 4) {\n            float64x2_t mat0 = vld1q_f64(&matrix[j]);\n            float64x2_t mat1 = vld1q_f64(&matrix[j + 2]);\n\n            uint64x2_t cmp0 = vceqq_f64(mat0, vec0);\n            uint64x2_t cmp1 = vceqq_f64(mat1, vec1);\n\n            if (vaddvq_u64(vpaddq_u64(cmp0, cmp1)) != (sizeof(float64x2_t) / sizeof(double))) {\n                match = false;\n                break;\n            }\n        }\n\n        if (match) {\n            for (size_t j = cols_aligned; j < cols; ++j) {\n                if (matrix[j] != vector[j]) {\n                    match = false;\n                    break;\n                }\n            }\n            if (match) {\n                return true;\n            }\n        }\n\n        matrix += cols;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_Neon", "completion": "```c\n#include <arm_neon.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    size_t cols_aligned = cols & ~(size_t)1; // Ensure cols is even for SIMD operations\n    float64x2_t vec0 = vld1q_f64(vector);\n    float64x2_t vec1 = vld1q_f64(vector + 2);\n\n    for (size_t i = 0; i < rows; ++i) {\n        bool match = true;\n        for (size_t j = 0; j < cols_aligned; j += 2) {\n            float64x2_t mat = vld1q_f64(&matrix[i * cols + j]);\n            uint64x2_t cmp0 = vceqq_f64(mat, vec0);\n            uint64x2_t cmp1 = vceqq_f64(vld1q_f64(&matrix[i * cols + j + 2]), vec1);\n            if (vgetq_lane_u64(vpminq_u64(cmp0, cmp1), 0) == 0) {\n                match = false;\n                break;\n            }\n        }\n        if (match && (cols % 2 != 0)) {\n            if (matrix[i * cols + cols - 1] != vector[cols - 1]) {\n                match = false;\n            }\n        }\n        if (match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_Neon", "completion": "```c\n#include <arm_neon.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    size_t cols_aligned = cols & ~(size_t)1; // Ensure cols is even for SIMD operations\n    float64x2_t vec = vld1q_f64(vector);\n\n    for (size_t i = 0; i < rows; ++i) {\n        bool match = true;\n        for (size_t j = 0; j < cols_aligned; j += 2) {\n            float64x2_t mat = vld1q_f64(&matrix[i * cols + j]);\n            uint64x2_t cmp = vceqq_f64(mat, vec);\n            if (vgetq_lane_u64(cmp, 0) == 0 || vgetq_lane_u64(cmp, 1) == 0) {\n                match = false;\n                break;\n            }\n        }\n        if (match && (cols % 2 != 0)) {\n            if (matrix[i * cols + cols - 1] != vector[cols - 1]) {\n                match = false;\n            }\n        }\n        if (match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    size_t cols_aligned = cols & ~(size_t)1; // Ensure cols is even for SIMD processing\n    float64x2_t vec = vld1q_f64(vector);\n\n    for (size_t i = 0; i < rows; ++i) {\n        bool match = true;\n        for (size_t j = 0; j < cols_aligned; j += 2) {\n            float64x2_t mat = vld1q_f64(&matrix[i * cols + j]);\n            uint64x2_t cmp = vceqq_f64(mat, vec);\n            if (vgetq_lane_u64(cmp, 0) == 0 || vgetq_lane_u64(cmp, 1) == 0) {\n                match = false;\n                break;\n            }\n        }\n        if (match && (cols % 2 != 0)) {\n            if (matrix[i * cols + cols - 1] != vector[cols - 1]) {\n                match = false;\n            }\n        }\n        if (match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    size_t cols_aligned = cols & ~(size_t)1; // Ensure cols is even for SIMD processing\n    float64x2_t vec = vld1q_f64(vector);\n\n    for (size_t i = 0; i < rows; ++i) {\n        bool match = true;\n        for (size_t j = 0; j < cols_aligned; j += 2) {\n            float64x2_t mat = vld1q_f64(&matrix[i * cols + j]);\n            uint64x2_t cmp = vceqq_f64(mat, vec);\n            if (vgetq_lane_u64(cmp, 0) == 0 || vgetq_lane_u64(cmp, 1) == 0) {\n                match = false;\n                break;\n            }\n        }\n        if (match && (cols % 2 != 0)) {\n            if (matrix[i * cols + cols - 1] != vector[cols - 1]) {\n                match = false;\n            }\n        }\n        if (match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_33_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stddef.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    size_t i = 0;\n    for (; i <= total_elements - 16; i += 16) {\n        uint8x16_t va = vld1q_u8(&A[i]);\n        uint8x16_t vb = vld1q_u8(&B[i]);\n        uint8x16_t vc = vceqq_u8(va, vb);\n        uint8x8_t vc_low = vget_low_u8(vc);\n        uint8x8_t vc_high = vget_high_u8(vc);\n        count += vaddvq_u8(vc_low) + vaddvq_u8(vc_high);\n    }\n\n    for (; i < total_elements; ++i) {\n        if (A[i] == B[i]) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stddef.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t totalElements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    size_t i;\n    for (i = 0; i <= totalElements - 16; i += 16) {\n        uint8x16_t va = vld1q_u8(&A[i]);\n        uint8x16_t vb = vld1q_u8(&B[i]);\n        uint8x16_t vc = vceqq_u8(va, vb);\n        uint8_t result[16];\n        vst1q_u8(result, vc);\n\n        for (int j = 0; j < 16; j++) {\n            count += result[j];\n        }\n    }\n\n    for (; i < totalElements; i++) {\n        count += (A[i] == B[i]);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stddef.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t totalElements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    size_t i;\n    for (i = 0; i <= totalElements - 16; i += 16) {\n        uint8x16_t va = vld1q_u8(&A[i]);\n        uint8x16_t vb = vld1q_u8(&B[i]);\n        uint8x16_t vc = vceqq_u8(va, vb);\n        uint8x8_t vc_low = vget_low_u8(vc);\n        uint8x8_t vc_high = vget_high_u8(vc);\n        count += vaddvq_u8(vc);\n    }\n\n    for (; i < totalElements; ++i) {\n        if (A[i] == B[i]) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stddef.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    size_t i = 0;\n    for (; i <= total_elements - 16; i += 16) {\n        uint8x16_t va = vld1q_u8(&A[i]);\n        uint8x16_t vb = vld1q_u8(&B[i]);\n        uint8x16_t vc = vceqq_u8(va, vb);\n        uint8x8_t vc_low = vget_low_u8(vc);\n        uint8x8_t vc_high = vget_high_u8(vc);\n        count += vaddv_u8(vc_low) + vaddv_u8(vc_high);\n    }\n\n    for (; i < total_elements; ++i) {\n        if (A[i] == B[i]) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stddef.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    size_t i = 0;\n    for (; i <= total_elements - 16; i += 16) {\n        uint8x16_t va = vld1q_u8(&A[i]);\n        uint8x16_t vb = vld1q_u8(&B[i]);\n        uint8x16_t vc = vceqq_u8(va, vb);\n        uint8x8_t vc_low = vget_low_u8(vc);\n        uint8x8_t vc_high = vget_high_u8(vc);\n        count += vaddv_u8(vc_low) + vaddv_u8(vc_high);\n    }\n\n    for (; i < total_elements; ++i) {\n        if (A[i] == B[i]) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_34_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    int64x2_t va = vdupq_n_s64(a);\n\n    for (size_t i = 0; i < length; i += 2) {\n        int64x2_t vx = vld1q_s64(&x[i]);\n        int64x2_t vy = vld1q_s64(&y[i]);\n\n        int64x2_t vax = vmulq_s64(va, vx);\n        int64x2_t vabs_vy = vabsq_s64(vy);\n        int64x2_t vresult = vsubq_s64(vax, vabs_vy);\n\n        vst1q_s64(&y[i], vresult);\n    }\n}\n```"}
{"task_id": "SimdBench_34_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i;\n    int64x2_t va = vdupq_n_s64(a);\n\n    for (i = 0; i < length; i += 2) {\n        int64x2_t vx = vld1q_s64(&x[i]);\n        int64x2_t vy = vld1q_s64(&y[i]);\n\n        int64x2_t vax = vmulq_s64(va, vx);\n        int64x2_t vabs_y = vabsq_s64(vy);\n        int64x2_t vresult = vsubq_s64(vax, vabs_y);\n\n        vst1q_s64(&y[i], vresult);\n    }\n}\n```"}
{"task_id": "SimdBench_34_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i;\n    int64x2_t va = vdupq_n_s64(a);\n\n    for (i = 0; i < length; i += 2) {\n        int64x2_t vx = vld1q_s64(&x[i]);\n        int64x2_t vy = vld1q_s64(&y[i]);\n\n        int64x2_t vax = vmulq_s64(va, vx);\n        int64x2_t vabs_vy = vabsq_s64(vy);\n        int64x2_t vresult = vsubq_s64(vax, vabs_vy);\n\n        vst1q_s64(&y[i], vresult);\n    }\n}\n```"}
{"task_id": "SimdBench_34_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    int64x2_t va = vdupq_n_s64(a);\n\n    for (size_t i = 0; i < length; i += 2) {\n        int64x2_t vx = vld1q_s64(&x[i]);\n        int64x2_t vy = vld1q_s64(&y[i]);\n\n        int64x2_t vax = vmulq_s64(va, vx);\n        int64x2_t vabs_y = vabsq_s64(vy);\n        int64x2_t vresult = vsubq_s64(vax, vabs_y);\n\n        vst1q_s64(&y[i], vresult);\n    }\n}\n```"}
{"task_id": "SimdBench_34_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    int64x2_t va = vdupq_n_s64(a);\n\n    for (size_t i = 0; i < length; i += 2) {\n        int64x2_t vx = vld1q_s64(&x[i]);\n        int64x2_t vy = vld1q_s64(&y[i]);\n\n        int64x2_t vax = vmulq_s64(va, vx);\n        int64x2_t vabs_vy = vabsq_s64(vy);\n        int64x2_t vresult = vsubq_s64(vax, vabs_vy);\n\n        vst1q_s64(&y[i], vresult);\n    }\n}\n```"}
{"task_id": "SimdBench_35_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stddef.h>\n#include <stdint.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    int16x8_t vmin = vld1q_s16(vec);\n    int16x8_t vmax = vmin;\n\n    size_t i;\n    for (i = 8; i + 7 < length; i += 8) {\n        int16x8_t v = vld1q_s16(&vec[i]);\n        vmin = vminq_s16(vmin, v);\n        vmax = vmaxq_s16(vmax, v);\n    }\n\n    int16_t min_arr[8];\n    int16_t max_arr[8];\n    vst1q_s16(min_arr, vmin);\n    vst1q_s16(max_arr, vmax);\n\n    int16_t min_num = min_arr[0];\n    int16_t max_num = max_arr[0];\n\n    for (size_t j = 1; j < 8; ++j) {\n        if (min_arr[j] < min_num) min_num = min_arr[j];\n        if (max_arr[j] > max_num) max_num = max_arr[j];\n    }\n\n    for (; i < length; ++i) {\n        if (vec[i] < min_num) min_num = vec[i];\n        if (vec[i] > max_num) max_num = vec[i];\n    }\n\n    MinMaxPair result = {min_num, max_num};\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stddef.h>\n#include <stdint.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    int16x8_t vmin = vld1q_dup_s16(&vec[0]);\n    int16x8_t vmax = vmin;\n\n    for (size_t i = 0; i <= length - 8; i += 8) {\n        int16x8_t v = vld1q_s16(&vec[i]);\n        vmin = vminq_s16(vmin, v);\n        vmax = vmaxq_s16(vmax, v);\n    }\n\n    int16_t min_arr[8], max_arr[8];\n    vst1q_s16(min_arr, vmin);\n    vst1q_s16(max_arr, vmax);\n\n    int16_t min_num = min_arr[0];\n    int16_t max_num = max_arr[0];\n\n    for (int i = 1; i < 8; ++i) {\n        if (min_arr[i] < min_num) min_num = min_arr[i];\n        if (max_arr[i] > max_num) max_num = max_arr[i];\n    }\n\n    for (size_t i = (length / 8) * 8; i < length; ++i) {\n        if (vec[i] < min_num) min_num = vec[i];\n        if (vec[i] > max_num) max_num = vec[i];\n    }\n\n    return (MinMaxPair){min_num, max_num};\n}\n```"}
{"task_id": "SimdBench_35_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    int16x8_t vmin = vdupq_n_s16(INT16_MAX);\n    int16x8_t vmax = vdupq_n_s16(INT16_MIN);\n\n    for (size_t i = 0; i <= length - 8; i += 8) {\n        int16x8_t v = vld1q_s16(&vec[i]);\n        vmin = vminq_s16(vmin, v);\n        vmax = vmaxq_s16(vmax, v);\n    }\n\n    int16_t min_arr[8], max_arr[8];\n    vst1q_s16(min_arr, vmin);\n    vst1q_s16(max_arr, vmax);\n\n    int16_t min_num = INT16_MAX;\n    int16_t max_num = INT16_MIN;\n\n    for (int i = 0; i < 8; ++i) {\n        if (min_arr[i] < min_num) min_num = min_arr[i];\n        if (max_arr[i] > max_num) max_num = max_arr[i];\n    }\n\n    for (size_t i = (length / 8) * 8; i < length; ++i) {\n        if (vec[i] < min_num) min_num = vec[i];\n        if (vec[i] > max_num) max_num = vec[i];\n    }\n\n    MinMaxPair result = {min_num, max_num};\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    int16x8_t vmin = vld1q_dup_s16(&vec[0]);\n    int16x8_t vmax = vld1q_dup_s16(&vec[0]);\n\n    for (size_t i = 0; i < length; i += 8) {\n        int16x8_t chunk = vld1q_s16(&vec[i]);\n        vmin = vminq_s16(vmin, chunk);\n        vmax = vmaxq_s16(vmax, chunk);\n    }\n\n    int16_t min_values[8];\n    int16_t max_values[8];\n    vst1q_s16(min_values, vmin);\n    vst1q_s16(max_values, vmax);\n\n    int16_t min_num = min_values[0];\n    int16_t max_num = max_values[0];\n\n    for (int i = 1; i < 8; ++i) {\n        if (min_values[i] < min_num) min_num = min_values[i];\n        if (max_values[i] > max_num) max_num = max_values[i];\n    }\n\n    return (MinMaxPair){min_num, max_num};\n}\n```"}
{"task_id": "SimdBench_35_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    int16x8_t vmin = vld1q_dup_s16(&vec[0]);\n    int16x8_t vmax = vmin;\n\n    for (size_t i = 0; i <= length - 8; i += 8) {\n        int16x8_t v = vld1q_s16(&vec[i]);\n        vmin = vminq_s16(vmin, v);\n        vmax = vmaxq_s16(vmax, v);\n    }\n\n    int16_t min_arr[8], max_arr[8];\n    vst1q_s16(min_arr, vmin);\n    vst1q_s16(max_arr, vmax);\n\n    int16_t min_num = min_arr[0];\n    int16_t max_num = max_arr[0];\n\n    for (size_t i = 0; i < 8; ++i) {\n        if (min_arr[i] < min_num) min_num = min_arr[i];\n        if (max_arr[i] > max_num) max_num = max_arr[i];\n    }\n\n    for (size_t i = length - (length % 8); i < length; ++i) {\n        if (vec[i] < min_num) min_num = vec[i];\n        if (vec[i] > max_num) max_num = vec[i];\n    }\n\n    return (MinMaxPair){min_num, max_num};\n}\n```"}
{"task_id": "SimdBench_36_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    for (size_t i = 0; i < rows; ++i) {\n        size_t j;\n        int32x4_t prev = vld1q_s32(&matrix[i * cols]);\n        int32x4_t current;\n\n        for (j = 1; j + 3 < cols; j += 4) {\n            current = vld1q_s32(&matrix[i * cols + j]);\n            uint32x4_t cmp = vcltq_s32(prev, current);\n            if (vminvq_u32(cmp) == 0) return false;\n            prev = current;\n        }\n\n        for (; j < cols; ++j) {\n            if (matrix[i * cols + j] <= matrix[i * cols + j - 1]) return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    for (size_t i = 0; i < rows; ++i) {\n        size_t j;\n        int32x4_t prev = vld1q_s32(&matrix[i * cols]);\n        int32x4_t current;\n\n        for (j = 1; j + 3 < cols; j += 4) {\n            current = vld1q_s32(&matrix[i * cols + j]);\n            uint32x4_t cmp = vcltq_s32(prev, current);\n            if (vminvq_u32(cmp) == 0) {\n                return false;\n            }\n            prev = current;\n        }\n\n        for (; j < cols; ++j) {\n            if (matrix[i * cols + j] <= matrix[i * cols + j - 1]) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols - 3; j += 4) {\n            int32x4_t v = vld1q_s32(&matrix[i * cols + j]);\n            int32x4_t next_v = vld1q_s32(&matrix[i * cols + j + 1]);\n            uint32x4_t cmp = vcltq_s32(v, next_v);\n            if (vminvq_u32(cmp) == 0) {\n                return false;\n            }\n        }\n        for (size_t j = (cols / 4) * 4; j < cols - 1; ++j) {\n            if (matrix[i * cols + j] >= matrix[i * cols + j + 1]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols - 3; j += 4) {\n            int32x4_t vec = vld1q_s32(&matrix[i * cols + j]);\n            int32x4_t vec_next = vld1q_s32(&matrix[i * cols + j + 1]);\n            uint32x4_t cmp = vcltq_s32(vec, vec_next);\n            if (vminvq_u32(cmp) == 0) {\n                return false;\n            }\n        }\n        for (size_t j = (cols / 4) * 4; j < cols - 1; ++j) {\n            if (matrix[i * cols + j] >= matrix[i * cols + j + 1]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    for (size_t i = 0; i < rows; ++i) {\n        size_t j;\n        int32x4_t prev = vld1q_s32(&matrix[i * cols]);\n        int32x4_t current;\n\n        for (j = 1; j + 3 < cols; j += 4) {\n            current = vld1q_s32(&matrix[i * cols + j]);\n            uint32x4_t cmp = vcltq_s32(prev, current);\n            if (vminvq_u32(cmp) == 0) {\n                return false;\n            }\n            prev = current;\n        }\n\n        for (; j < cols; ++j) {\n            if (matrix[i * cols + j - 1] >= matrix[i * cols + j]) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n    size_t num_elements_block = block_size * block_size;\n\n    for (size_t i = 1; i < num_blocks_row; ++i) {\n        for (size_t j = 0; j < num_blocks_col; ++j) {\n            for (size_t k = 0; k < num_elements_block; k += 4) {\n                int32x4_t first_block_vec = vld1q_s32(&matrix[k]);\n                int32x4_t current_block_vec = vld1q_s32(&matrix[(i * block_size * cols) + (j * block_size * block_size) + k]);\n\n                uint32x4_t diff = vceqq_s32(first_block_vec, current_block_vec);\n                if (vaddvq_u32(diff) != 4) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    for (size_t j = 1; j < num_blocks_col; ++j) {\n        for (size_t k = 0; k < num_elements_block; k += 4) {\n            int32x4_t first_block_vec = vld1q_s32(&matrix[k]);\n            int32x4_t current_block_vec = vld1q_s32(&matrix[(j * block_size * block_size) + k]);\n\n            uint32x4_t diff = vceqq_s32(first_block_vec, current_block_vec);\n            if (vaddvq_u32(diff) != 4) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n#include <stddef.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_rows = rows / block_size;\n    size_t num_blocks_cols = cols / block_size;\n    size_t block_elements = block_size * block_size;\n\n    for (size_t i = 1; i < num_blocks_rows * num_blocks_cols; ++i) {\n        for (size_t j = 0; j < block_elements; j += 4) {\n            int32x4_t first_block_vec = vld1q_s32(&matrix[j]);\n            int32x4_t current_block_vec = vld1q_s32(&matrix[i * block_elements + j]);\n\n            uint32x4_t diff = vceqq_s32(first_block_vec, current_block_vec);\n            if (vaddvq_u32(diff) != 4) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n    size_t block_elements = block_size * block_size;\n\n    int32x4_t first_block[block_elements / 4];\n    for (size_t i = 0; i < block_elements / 4; ++i) {\n        first_block[i] = vld1q_s32(&matrix[i * 4]);\n    }\n\n    for (size_t b_row = 0; b_row < num_blocks_row; ++b_row) {\n        for (size_t b_col = 0; b_col < num_blocks_col; ++b_col) {\n            if (b_row == 0 && b_col == 0) continue;\n\n            for (size_t i = 0; i < block_elements / 4; ++i) {\n                size_t index = (b_row * block_size * cols) + (b_col * block_size) + (i * 4);\n                int32x4_t current_block = vld1q_s32(&matrix[index]);\n\n                uint32x4_t diff = vceqq_s32(first_block[i], current_block);\n                if (vaddvq_u32(diff) != 4) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size <= 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n    size_t block_elements = block_size * block_size;\n\n    int32x4_t first_block[block_elements / 4];\n    for (size_t i = 0; i < block_size; ++i) {\n        for (size_t j = 0; j < block_size; j += 4) {\n            first_block[(i * block_size + j) / 4] = vld1q_s32(&matrix[i * cols + j]);\n        }\n    }\n\n    for (size_t b_row = 0; b_row < num_blocks_row; ++b_row) {\n        for (size_t b_col = 0; b_col < num_blocks_col; ++b_col) {\n            if (b_row == 0 && b_col == 0) continue;\n\n            for (size_t i = 0; i < block_size; ++i) {\n                for (size_t j = 0; j < block_size; j += 4) {\n                    size_t index = (b_row * block_size + i) * cols + (b_col * block_size + j);\n                    int32x4_t current_block = vld1q_s32(&matrix[index]);\n                    if (!vceqq_s32(first_block[(i * block_size + j) / 4], current_block)) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n#include <stddef.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n    size_t block_elements = block_size * block_size;\n\n    for (size_t i = 1; i < num_blocks_row; ++i) {\n        for (size_t j = 0; j < num_blocks_col; ++j) {\n            for (size_t k = 0; k < block_elements; k += 4) {\n                int32x4_t first_block_vec = vld1q_s32(&matrix[k]);\n                int32x4_t current_block_vec = vld1q_s32(&matrix[(i * block_size * cols) + (j * block_size * block_size) + k]);\n\n                uint32x4_t diff = vceqq_s32(first_block_vec, current_block_vec);\n                if (vaddvq_u32(diff) != 4) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    for (size_t j = 1; j < num_blocks_col; ++j) {\n        for (size_t k = 0; k < block_elements; k += 4) {\n            int32x4_t first_block_vec = vld1q_s32(&matrix[k]);\n            int32x4_t current_block_vec = vld1q_s32(&matrix[(j * block_size * block_size) + k]);\n\n            uint32x4_t diff = vceqq_s32(first_block_vec, current_block_vec);\n            if (vaddvq_u32(diff) != 4) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n#include <stddef.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == NULL || length == 0 || block_size == 0 || block_size > length) {\n        return false;\n    }\n\n    size_t full_blocks = length / block_size;\n    if (full_blocks == 0) {\n        return false;\n    }\n\n    float64x2_t tol_vec = vdupq_n_f64(tolerance);\n    float64x2_t zero_vec = vdupq_n_f64(0.0);\n\n    for (size_t i = 0; i < block_size; i += 2) {\n        float64x2_t first_block_vec = vld1q_f64(&vec[i]);\n\n        for (size_t j = block_size; j < full_blocks * block_size; j += block_size) {\n            float64x2_t current_block_vec = vld1q_f64(&vec[j + i]);\n            float64x2_t diff = vabsq_f64(vsubq_f64(first_block_vec, current_block_vec));\n            uint64x2_t cmp = vcgtq_f64(diff, tol_vec);\n\n            if (vgetq_lane_u64(cmp, 0) || vgetq_lane_u64(cmp, 1)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == NULL || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    size_t full_blocks = length / block_size;\n    if (full_blocks < 2) {\n        return false;\n    }\n\n    double* first_block = (double*)vec;\n    float64x2_t tol = vdupq_n_f64(tolerance);\n\n    for (size_t i = 1; i < full_blocks; ++i) {\n        double* current_block = (double*)(vec + i * block_size);\n\n        for (size_t j = 0; j < block_size; j += 2) {\n            float64x2_t first_val = vld1q_f64(&first_block[j]);\n            float64x2_t current_val = vld1q_f64(&current_block[j]);\n            float64x2_t diff = vabsq_f64(vsubq_f64(first_val, current_val));\n            uint64x2_t cmp = vcgtq_f64(diff, tol);\n\n            if (vgetq_lane_u64(cmp, 0) || vgetq_lane_u64(cmp, 1)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == NULL || length == 0 || block_size == 0 || block_size > length) {\n        return false;\n    }\n\n    size_t full_blocks = length / block_size;\n    if (full_blocks == 0) {\n        return false;\n    }\n\n    size_t i;\n    for (i = 0; i < block_size; i += 2) {\n        float64x2_t first_block = vld1q_f64(&vec[i]);\n        size_t j;\n        for (j = 1; j < full_blocks; j++) {\n            float64x2_t current_block = vld1q_f64(&vec[j * block_size + i]);\n            float64x2_t diff = vabsq_f64(vsubq_f64(first_block, current_block));\n            uint64x2_t mask = vcgtq_f64(diff, vld1q_f64(&tolerance));\n            if (vaddvq_u64(mask) != 0) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n#include <stddef.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == NULL || length == 0 || block_size == 0 || block_size > length) {\n        return false;\n    }\n\n    size_t full_blocks = length / block_size;\n    if (full_blocks == 0) {\n        return false;\n    }\n\n    float64x2_t tol = vdupq_n_f64(tolerance);\n    float64x2_t zero = vdupq_n_f64(0.0);\n\n    for (size_t i = 0; i < block_size; i += 2) {\n        float64x2_t first_block = vld1q_f64(&vec[i]);\n\n        for (size_t j = 1; j < full_blocks; ++j) {\n            float64x2_t current_block = vld1q_f64(&vec[j * block_size + i]);\n            float64x2_t diff = vabsq_f64(vsubq_f64(first_block, current_block));\n            uint64x2_t cmp = vcgtq_f64(diff, tol);\n\n            if (vgetq_lane_u64(cmp, 0) || vgetq_lane_u64(cmp, 1)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == NULL || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    size_t full_blocks = length / block_size;\n    if (full_blocks == 0) {\n        return false;\n    }\n\n    size_t i;\n    for (i = 0; i < block_size; i += 2) {\n        float64x2_t first_block_val = vld1q_f64(&vec[i]);\n        size_t j;\n        for (j = 1; j < full_blocks; j++) {\n            float64x2_t current_block_val = vld1q_f64(&vec[j * block_size + i]);\n            float64x2_t diff = vabsq_f64(vsubq_f64(first_block_val, current_block_val));\n            uint64x2_t mask = vcgtq_f64(diff, vdupq_n_f64(tolerance));\n            if (vgetq_lane_u64(mask, 0) || vgetq_lane_u64(mask, 1)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_39_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        double sum = 0.0;\n        size_t j = 0;\n\n        // Process pairs of elements using NEON intrinsics\n        for (; j < cols - 1; j += 2) {\n            double2_t v = vld1q_f64(&matrix[i * cols + j]);\n            double2_t sq = vmulq_f64(v, v);\n            sum += vgetq_lane_f64(sq, 0) + vgetq_lane_f64(sq, 1);\n        }\n\n        // Process remaining element if the number of columns is odd\n        if (j < cols) {\n            sum += matrix[i * cols + j] * matrix[i * cols + j];\n        }\n\n        double norm = sqrt(sum);\n        result[i] = norm > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_39_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        double sum = 0.0;\n        size_t j = 0;\n\n        // Process pairs of elements using NEON intrinsics\n        for (; j <= cols - 2; j += 2) {\n            double2_t v = vld1q_f64(&matrix[i * cols + j]);\n            double2_t sq = vmulq_f64(v, v);\n            sum += vgetq_lane_f64(sq, 0) + vgetq_lane_f64(sq, 1);\n        }\n\n        // Process remaining element if the number of columns is odd\n        if (j < cols) {\n            sum += matrix[i * cols + j] * matrix[i * cols + j];\n        }\n\n        double norm = sqrt(sum);\n        result[i] = norm > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_39_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        double sum = 0.0;\n        size_t j = 0;\n\n        // Process pairs of elements using NEON intrinsics\n        for (; j < cols - 1; j += 2) {\n            float64x2_t vec = vld1q_f64(&matrix[i * cols + j]);\n            vec = vmulq_f64(vec, vec);\n            float64x2_t sum_vec = vaddq_f64(vgetq_lane_f64(vec, 0), vgetq_lane_f64(vec, 1));\n            sum += vgetq_lane_f64(sum_vec, 0) + vgetq_lane_f64(sum_vec, 1);\n        }\n\n        // Process remaining element if the number of columns is odd\n        if (j < cols) {\n            sum += matrix[i * cols + j] * matrix[i * cols + j];\n        }\n\n        double norm = sqrt(sum);\n        result[i] = norm > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_39_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        double sum = 0.0;\n        size_t j = 0;\n\n        // Process 2 elements at a time using NEON\n        for (; j < cols - 1; j += 2) {\n            float64x2_t vec = vld1q_f64(&matrix[i * cols + j]);\n            float64x2_t sqr = vmulq_f64(vec, vec);\n            double temp[2];\n            vst1q_f64(temp, sqr);\n            sum += temp[0] + temp[1];\n        }\n\n        // Process remaining element if any\n        if (j < cols) {\n            sum += matrix[i * cols + j] * matrix[i * cols + j];\n        }\n\n        double norm = sqrt(sum);\n        result[i] = norm > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_39_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        double sum = 0.0;\n        size_t j = 0;\n\n        // Process pairs of elements using NEON intrinsics\n        for (; j < cols - 1; j += 2) {\n            float64x2_t vec = vld1q_f64(&matrix[i * cols + j]);\n            vec = vmulq_f64(vec, vec);\n            float64x2_t sum_vec = vaddq_f64(vgetq_lane_f64(vec, 0), vgetq_lane_f64(vec, 1));\n            sum += vgetq_lane_f64(sum_vec, 0) + vgetq_lane_f64(sum_vec, 1);\n        }\n\n        // Process remaining element if the number of columns is odd\n        if (j < cols) {\n            sum += matrix[i * cols + j] * matrix[i * cols + j];\n        }\n\n        result[i] = sqrt(sum) > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i;\n    for (i = 0; i <= length - 4; i += 4) {\n        uint32x4_t va = vld1q_u32(&A[i]);\n        uint32x4_t vb = vld1q_u32(&B[i]);\n        uint32x4_t vc = vorrq_u32(va, vb);\n        vst1q_u32(&C[i], vc);\n    }\n    for (; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i;\n    for (i = 0; i <= length - 4; i += 4) {\n        uint32x4_t va = vld1q_u32(&A[i]);\n        uint32x4_t vb = vld1q_u32(&B[i]);\n        uint32x4_t vc = vorrq_u32(va, vb);\n        vst1q_u32(&C[i], vc);\n    }\n    for (; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i;\n    for (i = 0; i <= length - 4; i += 4) {\n        uint32x4_t va = vld1q_u32(&A[i]);\n        uint32x4_t vb = vld1q_u32(&B[i]);\n        uint32x4_t vc = vorrq_u32(va, vb);\n        vst1q_u32(&C[i], vc);\n    }\n    for (; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i;\n    for (i = 0; i <= length - 4; i += 4) {\n        uint32x4_t va = vld1q_u32(&A[i]);\n        uint32x4_t vb = vld1q_u32(&B[i]);\n        uint32x4_t vc = vorrq_u32(va, vb);\n        vst1q_u32(&C[i], vc);\n    }\n    for (; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i;\n    for (i = 0; i <= length - 4; i += 4) {\n        uint32x4_t va = vld1q_u32(&A[i]);\n        uint32x4_t vb = vld1q_u32(&B[i]);\n        uint32x4_t vc = vorrq_u32(va, vb);\n        vst1q_u32(&C[i], vc);\n    }\n    for (; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_41_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_sq = 0;\n    int64_t sum_prod = 0;\n\n    size_t i;\n    for (i = 0; i <= length - 16; i += 16) {\n        int8x16_t va = vld1q_s8(&A[i]);\n        int8x16_t vb = vld1q_s8(&B[i]);\n\n        int16x8_t va_low = vmovl_s8(vget_low_s8(va));\n        int16x8_t va_high = vmovl_s8(vget_high_s8(va));\n        int16x8_t vb_low = vmovl_s8(vget_low_s8(vb));\n        int16x8_t vb_high = vmovl_s8(vget_high_s8(vb));\n\n        int32x4_t va_low_sq = vmull_s16(va_low, va_low);\n        int32x4_t va_high_sq = vmull_s16(va_high, va_high);\n        int32x4_t vb_low_sq = vmull_s16(vb_low, vb_low);\n        int32x4_t vb_high_sq = vmull_s16(vb_high, vb_high);\n\n        int32x4_t prod_low = vmull_s16(va_low, vb_low);\n        int32x4_t prod_high = vmull_s16(va_high, vb_high);\n\n        sum_sq += vaddvq_s32(vaddq_s32(va_low_sq, va_high_sq)) + vaddvq_s32(vaddq_s32(vb_low_sq, vb_high_sq));\n        sum_prod += vaddvq_s32(vaddq_s32(prod_low, prod_high));\n    }\n\n    for (; i < length; ++i) {\n        sum_sq += A[i] * A[i] + B[i] * B[i];\n        sum_prod += A[i] * B[i];\n    }\n\n    return sum_sq - 2 * sum_prod;\n}\n```"}
{"task_id": "SimdBench_41_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_sq = 0;\n    int64_t sum_prod = 0;\n\n    size_t i;\n    for (i = 0; i <= length - 16; i += 16) {\n        int8x16_t va = vld1q_s8(&A[i]);\n        int8x16_t vb = vld1q_s8(&B[i]);\n\n        int16x8_t va_low = vmovl_s8(vget_low_s8(va));\n        int16x8_t va_high = vmovl_s8(vget_high_s8(va));\n        int16x8_t vb_low = vmovl_s8(vget_low_s8(vb));\n        int16x8_t vb_high = vmovl_s8(vget_high_s8(vb));\n\n        int32x4_t va_low_sq = vmull_s16(va_low, va_low);\n        int32x4_t va_high_sq = vmull_s16(va_high, va_high);\n        int32x4_t vb_low_sq = vmull_s16(vb_low, vb_low);\n        int32x4_t vb_high_sq = vmull_s16(vb_high, vb_high);\n\n        int32x4_t prod_low = vmull_s16(va_low, vb_low);\n        int32x4_t prod_high = vmull_s16(va_high, vb_high);\n\n        sum_sq += vaddvq_s32(vaddq_s32(va_low_sq, va_high_sq)) + vaddvq_s32(vaddq_s32(vb_low_sq, vb_high_sq));\n        sum_prod += vaddvq_s32(vaddq_s32(prod_low, prod_high));\n    }\n\n    for (; i < length; ++i) {\n        sum_sq += A[i] * A[i] + B[i] * B[i];\n        sum_prod += A[i] * B[i];\n    }\n\n    return sum_sq - 2 * sum_prod;\n}\n```"}
{"task_id": "SimdBench_41_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_sq = 0;\n    int64_t sum_prod = 0;\n\n    size_t i;\n    for (i = 0; i <= length - 16; i += 16) {\n        int8x16_t va = vld1q_s8(&A[i]);\n        int8x16_t vb = vld1q_s8(&B[i]);\n\n        int16x8_t va_low = vmovl_s8(vget_low_s8(va));\n        int16x8_t va_high = vmovl_s8(vget_high_s8(va));\n        int16x8_t vb_low = vmovl_s8(vget_low_s8(vb));\n        int16x8_t vb_high = vmovl_s8(vget_high_s8(vb));\n\n        int32x4_t va_low_sq = vmull_s16(va_low, va_low);\n        int32x4_t va_high_sq = vmull_s16(va_high, va_high);\n        int32x4_t vb_low_sq = vmull_s16(vb_low, vb_low);\n        int32x4_t vb_high_sq = vmull_s16(vb_high, vb_high);\n\n        int32x4_t prod_low = vmull_s16(va_low, vb_low);\n        int32x4_t prod_high = vmull_s16(va_high, vb_high);\n\n        sum_sq += vaddvq_s32(vaddq_s32(va_low_sq, va_high_sq)) + vaddvq_s32(vaddq_s32(vb_low_sq, vb_high_sq));\n        sum_prod += vaddvq_s32(vaddq_s32(prod_low, prod_high));\n    }\n\n    for (; i < length; ++i) {\n        sum_sq += A[i] * A[i] + B[i] * B[i];\n        sum_prod += A[i] * B[i];\n    }\n\n    return sum_sq - 2 * sum_prod;\n}\n```"}
{"task_id": "SimdBench_41_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_sq = 0;\n    int64_t sum_prod = 0;\n\n    size_t i = 0;\n    for (; i <= length - 16; i += 16) {\n        int8x16_t va = vld1q_s8(&A[i]);\n        int8x16_t vb = vld1q_s8(&B[i]);\n\n        int16x8_t va_low = vmovl_s8(vget_low_s8(va));\n        int16x8_t va_high = vmovl_s8(vget_high_s8(va));\n        int16x8_t vb_low = vmovl_s8(vget_low_s8(vb));\n        int16x8_t vb_high = vmovl_s8(vget_high_s8(vb));\n\n        int32x4_t va_low_sq = vmull_s16(va_low, va_low);\n        int32x4_t va_high_sq = vmull_s16(va_high, va_high);\n        int32x4_t vb_low_sq = vmull_s16(vb_low, vb_low);\n        int32x4_t vb_high_sq = vmull_s16(vb_high, vb_high);\n\n        int32x4_t prod_low = vmull_s16(va_low, vb_low);\n        int32x4_t prod_high = vmull_s16(va_high, vb_high);\n\n        sum_sq += vaddvq_s32(vaddq_s32(va_low_sq, va_high_sq)) + vaddvq_s32(vaddq_s32(vb_low_sq, vb_high_sq));\n        sum_prod += vaddvq_s32(vaddq_s32(prod_low, prod_high));\n    }\n\n    for (; i < length; ++i) {\n        sum_sq += A[i] * A[i] + B[i] * B[i];\n        sum_prod += A[i] * B[i];\n    }\n\n    return sum_sq - 2 * sum_prod;\n}\n```"}
{"task_id": "SimdBench_41_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_sq = 0;\n    int64_t sum_prod = 0;\n\n    size_t i;\n    for (i = 0; i <= length - 16; i += 16) {\n        int8x16_t va = vld1q_s8(&A[i]);\n        int8x16_t vb = vld1q_s8(&B[i]);\n\n        int16x8_t va_low = vmovl_s8(vget_low_s8(va));\n        int16x8_t va_high = vmovl_s8(vget_high_s8(va));\n        int16x8_t vb_low = vmovl_s8(vget_low_s8(vb));\n        int16x8_t vb_high = vmovl_s8(vget_high_s8(vb));\n\n        int32x4_t va_low_sq = vmull_s16(va_low, va_low);\n        int32x4_t va_high_sq = vmull_s16(va_high, va_high);\n        int32x4_t vb_low_sq = vmull_s16(vb_low, vb_low);\n        int32x4_t vb_high_sq = vmull_s16(vb_high, vb_high);\n\n        int32x4_t prod_low = vmull_s16(va_low, vb_low);\n        int32x4_t prod_high = vmull_s16(va_high, vb_high);\n\n        sum_sq += vaddvq_s32(vaddq_s32(va_low_sq, va_high_sq)) + vaddvq_s32(vaddq_s32(vb_low_sq, vb_high_sq));\n        sum_prod += vaddvq_s32(vaddq_s32(prod_low, prod_high));\n    }\n\n    for (; i < length; ++i) {\n        sum_sq += A[i] * A[i] + B[i] * B[i];\n        sum_prod += A[i] * B[i];\n    }\n\n    return sum_sq - 2 * sum_prod;\n}\n```"}
{"task_id": "SimdBench_42_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i;\n    for (i = 0; i <= length - 2; i += 2) {\n        uint64x2_t va = vld1q_u64(&A[i]);\n        uint64x2_t vb = vld1q_u64(&B[i]);\n        uint64x2_t vb_neg = vmvnq_u64(vb);\n        uint64x2_t vc = vandq_u64(va, vb_neg);\n        vst1q_u64(&C[i], vc);\n    }\n\n    if (i < length) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i;\n    for (i = 0; i <= length - 2; i += 2) {\n        uint64x2_t va = vld1q_u64(&A[i]);\n        uint64x2_t vb = vld1q_u64(&B[i]);\n        uint64x2_t vc = vandq_u64(va, vmvnq_u64(vb));\n        vst1q_u64(&C[i], vc);\n    }\n\n    if (i < length) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i;\n    for (i = 0; i <= length - 2; i += 2) {\n        uint64x2_t va = vld1q_u64(&A[i]);\n        uint64x2_t vb = vld1q_u64(&B[i]);\n        uint64x2_t vb_neg = vmvnq_u64(vb);\n        uint64x2_t vc = vandq_u64(va, vb_neg);\n        vst1q_u64(&C[i], vc);\n    }\n\n    if (i < length) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i;\n    for (i = 0; i <= length - 2; i += 2) {\n        uint64x2_t va = vld1q_u64(&A[i]);\n        uint64x2_t vb = vld1q_u64(&B[i]);\n        uint64x2_t vc = vandq_u64(va, vmvnq_u64(vb));\n        vst1q_u64(&C[i], vc);\n    }\n    if (i < length) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i;\n    for (i = 0; i <= length - 2; i += 2) {\n        uint64x2_t va = vld1q_u64(&A[i]);\n        uint64x2_t vb = vld1q_u64(&B[i]);\n        uint64x2_t vb_not = vmvnq_u64(vb);\n        uint64x2_t vc = vandq_u64(va, vb_not);\n        vst1q_u64(&C[i], vc);\n    }\n\n    if (i < length) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_43_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i;\n    for (i = 0; i <= length - 16; i += 16) {\n        int8x16_t va = vld1q_s8(&A[i]);\n        int8x16_t vb = vld1q_s8(&B[i]);\n\n        uint8x16_t vpos = vcgtq_s8(va, vdupq_n_s8(0));\n        uint8x16_t vneg = vcltq_s8(va, vdupq_n_s8(0));\n        uint8x16_t vpos_b = vcgtq_s8(vb, vdupq_n_s8(0));\n        uint8x16_t vneg_b = vcltq_s8(vb, vdupq_n_s8(0));\n\n        uint8x16_t vboth_pos = vandq_u8(vpos, vpos_b);\n        uint8x16_t vboth_neg = vandq_u8(vneg, vneg_b);\n\n        int8x16_t vresult = vdupq_n_s8(0);\n        vresult = vbslq_s8(vboth_pos, vdupq_n_s8(1), vresult);\n        vresult = vbslq_s8(vboth_neg, vdupq_n_s8(-1), vresult);\n\n        vst1q_s8(&C[i], vresult);\n    }\n\n    for (; i < length; ++i) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i;\n    for (i = 0; i <= length - 16; i += 16) {\n        int8x16_t va = vld1q_s8(&A[i]);\n        int8x16_t vb = vld1q_s8(&B[i]);\n\n        uint8x16_t vpos = vcgtq_s8(va, vdupq_n_s8(0));\n        uint8x16_t vneg = vcltq_s8(va, vdupq_n_s8(0));\n        uint8x16_t vpos_b = vcgtq_s8(vb, vdupq_n_s8(0));\n        uint8x16_t vneg_b = vcltq_s8(vb, vdupq_n_s8(0));\n\n        uint8x16_t vboth_pos = vandq_u8(vpos, vpos_b);\n        uint8x16_t vboth_neg = vandq_u8(vneg, vneg_b);\n\n        int8x16_t vresult = vdupq_n_s8(0);\n        vresult = vbslq_s8(vboth_pos, vdupq_n_s8(1), vresult);\n        vresult = vbslq_s8(vboth_neg, vdupq_n_s8(-1), vresult);\n\n        vst1q_s8(&C[i], vresult);\n    }\n\n    for (; i < length; ++i) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i;\n    for (i = 0; i <= length - 16; i += 16) {\n        int8x16_t va = vld1q_s8(&A[i]);\n        int8x16_t vb = vld1q_s8(&B[i]);\n\n        uint8x16_t vpos = vcgtq_s8(va, vdupq_n_s8(0));\n        uint8x16_t vneg = vcltq_s8(va, vdupq_n_s8(0));\n        uint8x16_t vpos_b = vcgtq_s8(vb, vdupq_n_s8(0));\n        uint8x16_t vneg_b = vcltq_s8(vb, vdupq_n_s8(0));\n\n        uint8x16_t vboth_pos = vandq_u8(vpos, vpos_b);\n        uint8x16_t vboth_neg = vandq_u8(vneg, vneg_b);\n\n        int8x16_t vresult = vdupq_n_s8(0);\n        vresult = vbslq_s8(vboth_pos, vdupq_n_s8(1), vresult);\n        vresult = vbslq_s8(vboth_neg, vdupq_n_s8(-1), vresult);\n\n        vst1q_s8(&C[i], vresult);\n    }\n\n    for (; i < length; ++i) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i;\n    for (i = 0; i <= length - 16; i += 16) {\n        int8x16_t va = vld1q_s8(&A[i]);\n        int8x16_t vb = vld1q_s8(&B[i]);\n\n        uint8x16_t vpos = vcgtq_s8(va, vdupq_n_s8(0));\n        uint8x16_t vneg = vcltq_s8(va, vdupq_n_s8(0));\n        uint8x16_t vpos_b = vcgtq_s8(vb, vdupq_n_s8(0));\n        uint8x16_t vneg_b = vcltq_s8(vb, vdupq_n_s8(0));\n\n        uint8x16_t vboth_pos = vandq_u8(vpos, vpos_b);\n        uint8x16_t vboth_neg = vandq_u8(vneg, vneg_b);\n\n        int8x16_t vresult = vdupq_n_s8(0);\n        vresult = vbslq_s8(vboth_pos, vdupq_n_s8(1), vresult);\n        vresult = vbslq_s8(vboth_neg, vdupq_n_s8(-1), vresult);\n\n        vst1q_s8(&C[i], vresult);\n    }\n\n    for (; i < length; ++i) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i;\n    for (i = 0; i <= length - 16; i += 16) {\n        int8x16_t va = vld1q_s8(&A[i]);\n        int8x16_t vb = vld1q_s8(&B[i]);\n\n        uint8x16_t vpos = vcgtq_s8(va, vdupq_n_s8(0));\n        uint8x16_t vneg = vcltq_s8(va, vdupq_n_s8(0));\n        uint8x16_t vpos_b = vcgtq_s8(vb, vdupq_n_s8(0));\n        uint8x16_t vneg_b = vcltq_s8(vb, vdupq_n_s8(0));\n\n        uint8x16_t vboth_pos = vandq_u8(vpos, vpos_b);\n        uint8x16_t vboth_neg = vandq_u8(vneg, vneg_b);\n\n        int8x16_t vresult = vdupq_n_s8(0);\n        vresult = vbslq_s8(vboth_pos, vdupq_n_s8(1), vresult);\n        vresult = vbslq_s8(vboth_neg, vdupq_n_s8(-1), vresult);\n\n        vst1q_s8(&C[i], vresult);\n    }\n\n    for (; i < length; ++i) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stddef.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t mid = length / 2;\n    size_t i = 0;\n\n    for (; i <= mid - 8; i += 8) {\n        uint16x8_t va = vld1q_u16(&A[i]);\n        uint16x8_t vb = vld1q_u16(&B[i]);\n        uint16x8_t vc = veorq_u16(va, vb);\n        vst1q_u16(&C[i], vc);\n    }\n\n    for (; i < mid; i++) {\n        C[i] = A[i] ^ B[i];\n    }\n\n    C[mid] = A[mid];\n\n    for (; i <= mid + 7; i += 8) {\n        uint16x8_t va = vld1q_u16(&A[i]);\n        uint16x8_t vb = vld1q_u16(&B[i]);\n        uint16x8_t vc = vandq_u16(va, vb);\n        vst1q_u16(&C[i], vc);\n    }\n\n    for (; i < length; i++) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_44_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stddef.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t mid = length / 2;\n    size_t i = 0;\n\n    for (; i <= mid - 8; i += 8) {\n        uint16x8_t va = vld1q_u16(&A[i]);\n        uint16x8_t vb = vld1q_u16(&B[i]);\n        uint16x8_t vc = veorq_u16(va, vb);\n        vst1q_u16(&C[i], vc);\n    }\n\n    for (; i < mid; i++) {\n        C[i] = A[i] ^ B[i];\n    }\n\n    C[mid] = A[mid];\n\n    for (; i <= mid + 7; i += 8) {\n        uint16x8_t va = vld1q_u16(&A[i]);\n        uint16x8_t vb = vld1q_u16(&B[i]);\n        uint16x8_t vc = vandq_u16(va, vb);\n        vst1q_u16(&C[i], vc);\n    }\n\n    for (; i < length; i++) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_44_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stddef.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t mid = length / 2;\n    size_t i = 0;\n\n    for (; i <= mid - 8; i += 8) {\n        uint16x8_t va = vld1q_u16(&A[i]);\n        uint16x8_t vb = vld1q_u16(&B[i]);\n        uint16x8_t vc = veorq_u16(va, vb);\n        vst1q_u16(&C[i], vc);\n    }\n\n    for (; i < mid; i++) {\n        C[i] = A[i] ^ B[i];\n    }\n\n    C[mid] = A[mid];\n\n    for (; i <= mid + 7; i += 8) {\n        uint16x8_t va = vld1q_u16(&A[i]);\n        uint16x8_t vb = vld1q_u16(&B[i]);\n        uint16x8_t vc = vandq_u16(va, vb);\n        vst1q_u16(&C[i], vc);\n    }\n\n    for (; i < length; i++) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_44_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stddef.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t mid = length / 2;\n    size_t i = 0;\n\n    for (; i <= mid - 8; i += 8) {\n        uint16x8_t va = vld1q_u16(&A[i]);\n        uint16x8_t vb = vld1q_u16(&B[i]);\n        uint16x8_t vc = veorq_u16(va, vb);\n        vst1q_u16(&C[i], vc);\n    }\n\n    for (; i < mid; i++) {\n        C[i] = A[i] ^ B[i];\n    }\n\n    C[mid] = A[mid];\n\n    for (; i <= mid + 7; i += 8) {\n        uint16x8_t va = vld1q_u16(&A[i]);\n        uint16x8_t vb = vld1q_u16(&B[i]);\n        uint16x8_t vc = vandq_u16(va, vb);\n        vst1q_u16(&C[i], vc);\n    }\n\n    for (; i < length; i++) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_44_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t mid = length / 2;\n    size_t i = 0;\n\n    for (; i <= mid - 8; i += 8) {\n        uint16x8_t va = vld1q_u16(&A[i]);\n        uint16x8_t vb = vld1q_u16(&B[i]);\n        uint16x8_t vc = veorq_u16(va, vb);\n        vst1q_u16(&C[i], vc);\n    }\n\n    for (; i < mid; i++) {\n        C[i] = A[i] ^ B[i];\n    }\n\n    C[mid] = A[mid];\n\n    for (; i <= mid + 8; i += 8) {\n        uint16x8_t va = vld1q_u16(&A[i]);\n        uint16x8_t vb = vld1q_u16(&B[i]);\n        uint16x8_t vc = vandq_u16(va, vb);\n        vst1q_u16(&C[i], vc);\n    }\n\n    for (; i < length; i++) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_45_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n\n    for (size_t i = 0; i < total_size; i += 4) {\n        float32x4_t vA = vld1q_f32(&A[i]);\n        float32x4_t vB = vld1q_f32(&B[i]);\n        float32x4_t vC = vld1q_f32(&C[i]);\n        float32x4_t vD = vld1q_f32(&D[i]);\n\n        uint32x4_t vCond1 = vld1q_u32((uint32_t*)&cond1[i]);\n        uint32x4_t vCond2 = vld1q_u32((uint32_t*)&cond2[i]);\n\n        uint32x4_t vNotCond1 = vmvnq_u32(vCond1);\n        uint32x4_t vNotCond2 = vmvnq_u32(vCond2);\n\n        float32x4_t vOut1 = vbslq_f32(vCond2, vA, vB);\n        float32x4_t vOut2 = vbslq_f32(vCond2, vC, vD);\n\n        float32x4_t vOut = vbslq_f32(vCond1, vOut1, vOut2);\n\n        vst1q_f32(&out[i], vOut);\n    }\n}\n```"}
{"task_id": "SimdBench_45_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n\n    for (size_t i = 0; i < total_size; i += 4) {\n        float32x4_t va = vld1q_f32(&A[i]);\n        float32x4_t vb = vld1q_f32(&B[i]);\n        float32x4_t vc = vld1q_f32(&C[i]);\n        float32x4_t vd = vld1q_f32(&D[i]);\n\n        uint32x4_t vcond1 = vld1q_u32((uint32_t*)&cond1[i]);\n        uint32x4_t vcond2 = vld1q_u32((uint32_t*)&cond2[i]);\n\n        uint32x4_t vmask1 = vandq_u32(vcond1, vcond2);\n        uint32x4_t vmask2 = vandq_u32(vcond1, vmvnq_u32(vcond2));\n        uint32x4_t vmask3 = vandq_u32(vmvnq_u32(vcond1), vcond2);\n        uint32x4_t vmask4 = vandq_u32(vmvnq_u32(vcond1), vmvnq_u32(vcond2));\n\n        float32x4_t vout1 = vbslq_f32(vmask1, va, vb);\n        float32x4_t vout2 = vbslq_f32(vmask2, vout1, vc);\n        float32x4_t vout = vbslq_f32(vmask3, vout2, vd);\n\n        vst1q_f32(&out[i], vout);\n    }\n}\n```"}
{"task_id": "SimdBench_45_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n\n    for (size_t i = 0; i < total_size; i += 4) {\n        float32x4_t vA = vld1q_f32(&A[i]);\n        float32x4_t vB = vld1q_f32(&B[i]);\n        float32x4_t vC = vld1q_f32(&C[i]);\n        float32x4_t vD = vld1q_f32(&D[i]);\n\n        uint32x4_t vCond1 = vld1q_u32((uint32_t*)&cond1[i]);\n        uint32x4_t vCond2 = vld1q_u32((uint32_t*)&cond2[i]);\n\n        uint32x4_t vNotCond1 = vmvnq_u32(vCond1);\n        uint32x4_t vNotCond2 = vmvnq_u32(vCond2);\n\n        float32x4_t vOut = vbslq_f32(vCond1, vbslq_f32(vCond2, vA, vB), vbslq_f32(vCond2, vC, vD));\n\n        vst1q_f32(&out[i], vOut);\n    }\n}\n```"}
{"task_id": "SimdBench_45_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n\n    for (size_t i = 0; i < total_size; i += 4) {\n        float32x4_t vA = vld1q_f32(&A[i]);\n        float32x4_t vB = vld1q_f32(&B[i]);\n        float32x4_t vC = vld1q_f32(&C[i]);\n        float32x4_t vD = vld1q_f32(&D[i]);\n\n        uint32x4_t vCond1 = vld1q_u32((uint32_t*)&cond1[i]);\n        uint32x4_t vCond2 = vld1q_u32((uint32_t*)&cond2[i]);\n\n        uint32x4_t vNotCond1 = vmvnq_u32(vCond1);\n        uint32x4_t vNotCond2 = vmvnq_u32(vCond2);\n\n        float32x4_t vOut = vbslq_f32(vCond1, vbslq_f32(vCond2, vA, vB), vbslq_f32(vCond2, vC, vD));\n\n        vst1q_f32(&out[i], vOut);\n    }\n}\n```"}
{"task_id": "SimdBench_45_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n\n    for (size_t i = 0; i < total_size; i += 4) {\n        float32x4_t vA = vld1q_f32(&A[i]);\n        float32x4_t vB = vld1q_f32(&B[i]);\n        float32x4_t vC = vld1q_f32(&C[i]);\n        float32x4_t vD = vld1q_f32(&D[i]);\n\n        uint32x4_t vCond1 = vld1q_u32((uint32_t *)&cond1[i]);\n        uint32x4_t vCond2 = vld1q_u32((uint32_t *)&cond2[i]);\n\n        uint32x4_t vCond1And2 = vandq_u32(vCond1, vCond2);\n        uint32x4_t vCond1AndNot2 = vandq_u32(vCond1, vmvnq_u32(vCond2));\n        uint32x4_t vNotCond1And2 = vandq_u32(vmvnq_u32(vCond1), vCond2);\n        uint32x4_t vNotCond1AndNot2 = vandq_u32(vmvnq_u32(vCond1), vmvnq_u32(vCond2));\n\n        float32x4_t vOut = vbslq_f32(vCond1And2, vA, vB);\n        vOut = vbslq_f32(vCond1AndNot2, vOut, vC);\n        vOut = vbslq_f32(vNotCond1And2, vOut, vD);\n\n        vst1q_f32(&out[i], vOut);\n    }\n}\n```"}
{"task_id": "SimdBench_46_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n\n    for (size_t i = 0; i < total_size; i += 4) {\n        uint32x4_t v = vld1q_u32(&A[i]);\n\n        uint32x4_t v1 = vandq_u32(v, vsetq_lane_u32(0x55555555, v, 0));\n        uint32x4_t v2 = vandq_u32(vsrq_n_u32(v, 1), vsetq_lane_u32(0x55555555, v, 0));\n        uint32x4_t v3 = vaddq_u32(v1, v2);\n\n        uint32x4_t v4 = vandq_u32(v3, vsetq_lane_u32(0x33333333, v, 0));\n        uint32x4_t v5 = vandq_u32(vsrq_n_u32(v3, 2), vsetq_lane_u32(0x33333333, v, 0));\n        uint32x4_t v6 = vaddq_u32(v4, v5);\n\n        uint32x4_t v7 = vsrq_n_u32(v6, 4);\n        uint32x4_t v8 = vaddq_u32(v6, v7);\n\n        uint32x4_t v9 = vandq_u32(v8, vsetq_lane_u32(0x0F0F0F0F, v, 0));\n        uint32x4_t v10 = vsrq_n_u32(v8, 8);\n        uint32x4_t v11 = vaddq_u32(v9, v10);\n\n        uint8x8_t result = vmovn_u16(vmovn_u32(v11));\n\n        vst1_lane_u32((uint32_t*)&out[i], vget_low_u32(v11), 0);\n        vst1_lane_u32((uint32_t*)&out[i + 1], vget_low_u32(v11), 1);\n        vst1_lane_u32((uint32_t*)&out[i + 2], vget_low_u32(v11), 2);\n        vst1_lane_u32((uint32_t*)&out[i + 3], vget_low_u32(v11), 3);\n    }\n}\n```"}
{"task_id": "SimdBench_46_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n\n    for (size_t i = 0; i < total_size; i += 4) {\n        uint32x4_t v = vld1q_u32(&A[i]);\n\n        uint32x4_t v1 = vandq_u32(v, vsetq_lane_u32(0x55555555, v, 0));\n        uint32x4_t v2 = vandq_u32(vsrq_n_u32(v, 1), vsetq_lane_u32(0x55555555, v, 0));\n        uint32x4_t v3 = vaddq_u32(v1, v2);\n\n        uint32x4_t v4 = vandq_u32(v3, vsetq_lane_u32(0x33333333, v, 0));\n        uint32x4_t v5 = vandq_u32(vsrq_n_u32(v3, 2), vsetq_lane_u32(0x33333333, v, 0));\n        uint32x4_t v6 = vaddq_u32(v4, v5);\n\n        uint32x4_t v7 = vsrq_n_u32(v6, 4);\n        uint32x4_t v8 = vaddq_u32(v6, v7);\n\n        uint32x4_t v9 = vandq_u32(v8, vsetq_lane_u32(0x0F0F0F0F, v, 0));\n        uint32x4_t v10 = vsrq_n_u32(v8, 8);\n        uint32x4_t v11 = vaddq_u32(v9, v10);\n\n        uint8x8_t result = vmovn_u16(vmovn_u32(v11));\n\n        vst1_lane_u32((uint32_t*)&out[i], v11, 0);\n        vst1_lane_u32((uint32_t*)&out[i + 1], v11, 1);\n        vst1_lane_u32((uint32_t*)&out[i + 2], v11, 2);\n        vst1_lane_u32((uint32_t*)&out[i + 3], v11, 3);\n    }\n}\n```"}
{"task_id": "SimdBench_46_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t i;\n\n    for (i = 0; i < total_size - 3; i += 4) {\n        uint32x4_t v = vld1q_u32(&A[i]);\n\n        uint32x4_t v1 = vandq_u32(v, vsetq_lane_u32(0x55555555, v, 0));\n        uint32x4_t v2 = vandq_u32(vsrq_n_u32(v, 1), vsetq_lane_u32(0x55555555, v, 0));\n        uint32x4_t v3 = vaddq_u32(v1, v2);\n\n        uint32x4_t v4 = vandq_u32(v3, vsetq_lane_u32(0x33333333, v, 0));\n        uint32x4_t v5 = vandq_u32(vsrq_n_u32(v3, 2), vsetq_lane_u32(0x33333333, v, 0));\n        uint32x4_t v6 = vaddq_u32(v4, v5);\n\n        uint32x4_t v7 = vsrq_n_u32(v6, 4);\n        uint32x4_t v8 = vaddq_u32(v6, v7);\n\n        uint32x4_t v9 = vandq_u32(v8, vsetq_lane_u32(0x0F0F0F0F, v, 0));\n        uint32x4_t v10 = vsrq_n_u32(v8, 8);\n        uint32x4_t v11 = vaddq_u32(v9, v10);\n\n        uint8x8_t result = vmovn_u16(vmovn_u32(v11));\n\n        vst1_u8(&out[i], result);\n    }\n\n    for (; i < total_size; ++i) {\n        uint32_t v = A[i];\n        v = v - ((v >> 1) & 0x55555555);\n        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n        v = (v + (v >> 4)) & 0x0F0F0F0F;\n        v = v + (v >> 8);\n        v = v + (v >> 16);\n        out[i] = v & 0x3F;\n    }\n}\n```"}
{"task_id": "SimdBench_46_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n\n    for (size_t i = 0; i < total_size; i += 4) {\n        uint32x4_t v = vld1q_u32(&A[i]);\n\n        uint32x4_t v1 = vandq_u32(v, vsetq_lane_u32(0x55555555, v, 0));\n        uint32x4_t v2 = vandq_u32(v, vsetq_lane_u32(0x33333333, v, 0));\n        uint32x4_t v4 = vandq_u32(v, vsetq_lane_u32(0x0F0F0F0F, v, 0));\n\n        v1 = vaddq_u32(v1, vshrq_n_u32(v1, 1));\n        v2 = vaddq_u32(v2, vshrq_n_u32(v2, 2));\n        v4 = vaddq_u32(v4, vshrq_n_u32(v4, 4));\n\n        v1 = vandq_u32(v1, vsetq_lane_u32(0x33333333, v1, 0));\n        v1 = vaddq_u32(v1, vshrq_n_u32(v1, 2));\n        v1 = vandq_u32(v1, vsetq_lane_u32(0x0F0F0F0F, v1, 0));\n        v1 = vaddq_u32(v1, vshrq_n_u32(v1, 4));\n\n        v1 = vandq_u32(v1, vsetq_lane_u32(0x00FF00FF, v1, 0));\n        v1 = vaddq_u32(v1, vshrq_n_u32(v1, 8));\n        v1 = vandq_u32(v1, vsetq_lane_u32(0x0000FFFF, v1, 0));\n        v1 = vaddq_u32(v1, vshrq_n_u32(v1, 16));\n\n        uint8x8_t result = vmovn_u16(vmovn_u32(v1));\n\n        vst1_u8(&out[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_46_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n\n    for (size_t i = 0; i < total_size; i += 4) {\n        uint32x4_t v = vld1q_u32(&A[i]);\n\n        uint32x4_t v1 = vandq_u32(v, vsetq_lane_u32(0x55555555, v, 0));\n        uint32x4_t v2 = vandq_u32(v, vsetq_lane_u32(0x33333333, v, 0));\n        uint32x4_t v3 = vandq_u32(v, vsetq_lane_u32(0x0F0F0F0F, v, 0));\n        uint32x4_t v4 = vandq_u32(v, vsetq_lane_u32(0x00FF00FF, v, 0));\n        uint32x4_t v5 = vandq_u32(v, vsetq_lane_u32(0x0000FFFF, v, 0));\n\n        v1 = vaddq_u32(v1, vshrq_n_u32(v1, 1));\n        v2 = vaddq_u32(v2, vshrq_n_u32(v2, 2));\n        v3 = vaddq_u32(v3, vshrq_n_u32(v3, 4));\n        v4 = vaddq_u32(v4, vshrq_n_u32(v4, 8));\n        v5 = vaddq_u32(v5, vshrq_n_u32(v5, 16));\n\n        uint32x4_t result = vaddq_u32(v1, v2);\n        result = vaddq_u32(result, v3);\n        result = vaddq_u32(result, v4);\n        result = vaddq_u32(result, v5);\n\n        uint8x8_t narrowed = vmovn_u16(vmovn_u32(result));\n        vst1_u8(&out[i], narrowed);\n    }\n}\n```"}
{"task_id": "SimdBench_47_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i;\n\n    int32x4_t v3 = vdupq_n_s32(3);\n    int32x4_t vneg1 = vdupq_n_s32(-1);\n\n    for (i = 0; i < total_elements - 3; i += 4) {\n        int32x4_t vA = vld1q_s32(&A[i]);\n        uint32x4_t vAbs = vabsq_s32(vA);\n        int32x4_t vMod = vmodq_s32(vA, v3);\n        uint32x4_t vMask = vceqq_s32(vMod, vdupq_n_s32(0));\n        int32x4_t vResult = vbslq_s32(vMask, vAbs, vA);\n        vst1q_s32(&B[i], vResult);\n    }\n\n    for (; i < total_elements; ++i) {\n        B[i] = (A[i] % 3 == 0) ? abs(A[i]) : A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_47_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i;\n\n    for (i = 0; i < total_elements - 3; i += 4) {\n        int32x4_t vA = vld1q_s32(&A[i]);\n        int32x4_t vB;\n\n        uint32x4_t vMask = vcgtq_s32(vA, vdupq_n_s32(0));\n        int32x4_t vAbs = vabsq_s32(vA);\n        int32x4_t vMod3 = vandq_s32(vA, vdupq_n_s32(3));\n        uint32x4_t vCond = vceqq_s32(vMod3, vdupq_n_s32(0));\n\n        vB = vbslq_s32(vCond, vAbs, vA);\n\n        vst1q_s32(&B[i], vB);\n    }\n\n    for (; i < total_elements; ++i) {\n        B[i] = (A[i] % 3 == 0) ? abs(A[i]) : A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_47_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i;\n\n    for (i = 0; i < total_elements - 3; i += 4) {\n        int32x4_t vA = vld1q_s32(&A[i]);\n        int32x4_t vMask = vcgeq_s32(vA, vdupq_n_s32(0));\n        int32x4_t vDiv3 = vdupq_n_s32(3);\n        int32x4_t vRem = vreinterpretq_s32_u32(vmodq_u32(vreinterpretq_u32_s32(vA), vreinterpretq_u32_s32(vDiv3)));\n        uint32x4_t vCond = vceqq_u32(vRem, vdupq_n_u32(0));\n        int32x4_t vAbs = vabsq_s32(vA);\n        int32x4_t vResult = vbslq_s32(vCond, vAbs, vA);\n        vst1q_s32(&B[i], vResult);\n    }\n\n    for (; i < total_elements; ++i) {\n        B[i] = (A[i] % 3 == 0) ? abs(A[i]) : A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_47_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i;\n\n    for (i = 0; i < total_elements - 3; i += 4) {\n        int32x4_t vA = vld1q_s32(&A[i]);\n        int32x4_t vB;\n\n        int32x4_t vMod3 = vdupq_n_s32(3);\n        int32x4_t vRem = vmodq_s32(vA, vMod3);\n        uint32x4_t vMask = vceqq_s32(vRem, vdupq_n_s32(0));\n\n        int32x4_t vAbs = vabsq_s32(vA);\n        vB = vbslq_s32(vMask, vAbs, vA);\n\n        vst1q_s32(&B[i], vB);\n    }\n\n    for (; i < total_elements; ++i) {\n        B[i] = (A[i] % 3 == 0) ? abs(A[i]) : A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_47_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i;\n\n    for (i = 0; i < total_elements - 3; i += 4) {\n        int32x4_t vA = vld1q_s32(&A[i]);\n        int32x4_t vMask = vdupq_n_s32(3);\n        uint32x4_t vDivisible = vceqq_s32(vmodq_s32(vA, vMask), vdupq_n_s32(0));\n        int32x4_t vAbs = vabsq_s32(vA);\n        int32x4_t vResult = vbslq_s32(vDivisible, vAbs, vA);\n        vst1q_s32(&B[i], vResult);\n    }\n\n    for (; i < total_elements; ++i) {\n        B[i] = (A[i] % 3 == 0) ? abs(A[i]) : A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_48_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    uint32x4_t mask = vdupq_n_u32(0xF);\n    uint32x4_t rotate_vector = vdupq_n_u32(rotate_bits);\n    size_t i;\n\n    for (i = 0; i + 3 < length; i += 4) {\n        uint32x4_t src_vector = vld1q_u32(&src[i]);\n        uint32x4_t condition = vtstq_u32(src_vector, mask);\n        uint32x4_t rotated = vsriq_n_u32(src_vector, src_vector, rotate_bits);\n        uint32x4_t negated = vmvnq_u32(src_vector);\n        uint32x4_t result = vbslq_u32(condition, rotated, negated);\n        vst1q_u32(&dst[i], result);\n    }\n\n    for (; i < length; ++i) {\n        uint32_t value = src[i];\n        if ((value & 0xF) == 0xF) {\n            dst[i] = (value >> rotate_bits) | (value << (32 - rotate_bits));\n        } else {\n            dst[i] = ~value;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    uint32x4_t mask = vdupq_n_u32(0x0F);\n    uint32x4_t rotate_vector = vdupq_n_u32(rotate_bits);\n    size_t i;\n\n    for (i = 0; i <= length - 4; i += 4) {\n        uint32x4_t src_vec = vld1q_u32(&src[i]);\n        uint32x4_t condition = vtstq_u32(src_vec, mask);\n        uint32x4_t rotated = vsriq_n_u32(src_vec, src_vec, rotate_bits);\n        uint32x4_t negated = vmvnq_u32(src_vec);\n        uint32x4_t result = vbslq_u32(condition, rotated, negated);\n        vst1q_u32(&dst[i], result);\n    }\n\n    for (; i < length; ++i) {\n        uint32_t value = src[i];\n        if ((value & 0x0F) == 0x0F) {\n            dst[i] = (value >> rotate_bits) | (value << (32 - rotate_bits));\n        } else {\n            dst[i] = ~value;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    uint32x4_t mask = vdupq_n_u32(0x0F);\n    uint32x4_t rotate_vector = vdupq_n_u32(rotate_bits);\n    size_t i;\n\n    for (i = 0; i <= length - 4; i += 4) {\n        uint32x4_t src_vector = vld1q_u32(&src[i]);\n        uint32x4_t condition = vtstq_u32(src_vector, mask);\n        uint32x4_t rotated = vsriq_n_u32(src_vector, src_vector, rotate_bits);\n        uint32x4_t negated = vmvnq_u32(src_vector);\n        uint32x4_t result = vbslq_u32(condition, rotated, negated);\n        vst1q_u32(&dst[i], result);\n    }\n\n    for (; i < length; ++i) {\n        uint32_t value = src[i];\n        if ((value & 0x0F) == 0x0F) {\n            dst[i] = (value >> rotate_bits) | (value << (32 - rotate_bits));\n        } else {\n            dst[i] = ~value;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    uint32x4_t mask = vdupq_n_u32(0xF);\n    uint32x4_t rotate_vector = vdupq_n_u32(rotate_bits);\n    size_t i;\n\n    for (i = 0; i <= length - 4; i += 4) {\n        uint32x4_t src_vector = vld1q_u32(&src[i]);\n        uint32x4_t condition = vtstq_u32(src_vector, mask);\n        uint32x4_t rotated = vrshlq_u32(src_vector, rotate_vector);\n        uint32x4_t negated = vmvnq_u32(src_vector);\n        uint32x4_t result = vbslq_u32(condition, rotated, negated);\n        vst1q_u32(&dst[i], result);\n    }\n\n    for (; i < length; ++i) {\n        uint32_t value = src[i];\n        if ((value & 0xF) == 0xF) {\n            dst[i] = (value >> rotate_bits) | (value << (32 - rotate_bits));\n        } else {\n            dst[i] = ~value;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    uint32x4_t mask = vdupq_n_u32(0xF);\n    uint32x4_t rotate_vector = vdupq_n_u32(rotate_bits);\n    size_t i;\n\n    for (i = 0; i <= length - 4; i += 4) {\n        uint32x4_t src_vector = vld1q_u32(&src[i]);\n        uint32x4_t low_bits = vandq_u32(src_vector, mask);\n        uint32x4_t condition = vceqq_u32(low_bits, mask);\n\n        uint32x4_t rotated = vsraq_n_u32(src_vector, src_vector, rotate_bits);\n        uint32x4_t negated = vmvnq_u32(src_vector);\n\n        uint32x4_t result = vbslq_u32(condition, rotated, negated);\n        vst1q_u32(&dst[i], result);\n    }\n\n    for (; i < length; ++i) {\n        uint32_t value = src[i];\n        if ((value & 0xF) == 0xF) {\n            dst[i] = (value >> rotate_bits) | (value << (32 - rotate_bits));\n        } else {\n            dst[i] = ~value;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float32x4_t v_epsilon = vdupq_n_f32(epsilon);\n    float32x4_t v_neg_epsilon = vdupq_n_f32(-epsilon);\n    float32x4_t v_zero = vdupq_n_f32(0.0f);\n\n    size_t i;\n    for (i = 0; i <= length - 4; i += 4) {\n        float32x4_t v_a = vld1q_f32(&A[i]);\n        float32x4_t v_b = vld1q_f32(&B[i]);\n        float32x4_t v_diff = vsubq_f32(v_a, v_b);\n\n        uint32x4_t v_cmp_gt = vcgtq_f32(v_diff, v_epsilon);\n        uint32x4_t v_cmp_lt = vcltq_f32(v_diff, v_neg_epsilon);\n\n        int8x8_t v_out_lo = vcombine_s8(\n            vreinterpret_s8_u8(vshr_n_u8(vreinterpret_u8_u32(v_cmp_gt), 7)),\n            vreinterpret_s8_u8(vshl_n_u8(vreinterpret_u8_u32(v_cmp_lt), 1))\n        );\n        int8x8_t v_out_hi = vdup_n_s8(0);\n        int8x16_t v_out = vcombine_s8(v_out_lo, v_out_hi);\n\n        vst1q_s8(&out[i], v_out);\n    }\n\n    for (; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > epsilon) {\n            out[i] = 1;\n        } else if (diff < -epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float32x4_t eps_v = vdupq_n_f32(epsilon);\n    float32x4_t neg_eps_v = vdupq_n_f32(-epsilon);\n    float32x4_t zero_v = vdupq_n_f32(0.0f);\n\n    size_t i;\n    for (i = 0; i <= length - 4; i += 4) {\n        float32x4_t a_v = vld1q_f32(&A[i]);\n        float32x4_t b_v = vld1q_f32(&B[i]);\n        float32x4_t diff_v = vsubq_f32(a_v, b_v);\n\n        uint32x4_t cmp_gt_v = vcgtq_f32(diff_v, eps_v);\n        uint32x4_t cmp_lt_v = vcltq_f32(diff_v, neg_eps_v);\n\n        int8x8_t cmp_gt_8x8 = vreinterpret_s8_u32(cmp_gt_v);\n        int8x8_t cmp_lt_8x8 = vreinterpret_s8_u32(cmp_lt_v);\n\n        int8x8_t result_v = vdup_n_s8(0);\n        result_v = vbsl_s8(cmp_gt_8x8, vdup_n_s8(1), result_v);\n        result_v = vbsl_s8(cmp_lt_8x8, vdup_n_s8(-1), result_v);\n\n        int8x8_t mask_v = vreinterpret_s8_u32(vceqq_f32(diff_v, zero_v));\n        result_v = vbsl_s8(mask_v, vdup_n_s8(0), result_v);\n\n        vst1_s8(&out[i], result_v);\n    }\n\n    for (; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > epsilon) {\n            out[i] = 1;\n        } else if (diff < -epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float32x4_t v_epsilon = vdupq_n_f32(epsilon);\n    float32x4_t v_neg_epsilon = vdupq_n_f32(-epsilon);\n    float32x4_t v_zero = vdupq_n_f32(0.0f);\n\n    size_t i;\n    for (i = 0; i <= length - 4; i += 4) {\n        float32x4_t v_a = vld1q_f32(&A[i]);\n        float32x4_t v_b = vld1q_f32(&B[i]);\n        float32x4_t v_diff = vsubq_f32(v_a, v_b);\n\n        uint32x4_t v_cmp_gt = vcgtq_f32(v_diff, v_epsilon);\n        uint32x4_t v_cmp_lt = vcltq_f32(v_diff, v_neg_epsilon);\n\n        int8x8_t v_out_low = vmovn_u32((uint32x4_t)vsubq_f32(vdupq_n_f32(2.0f), vcvtq_f32_u32(v_cmp_gt)));\n        int8x8_t v_out_high = vmovn_u32((uint32x4_t)vsubq_f32(vdupq_n_f32(2.0f), vcvtq_f32_u32(v_cmp_lt)));\n\n        int8x8_t v_out = vsub_u8(v_out_low, v_out_high);\n\n        vst1_s8(&out[i], v_out);\n    }\n\n    for (; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > epsilon) {\n            out[i] = 1;\n        } else if (diff < -epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float32x4_t v_epsilon = vdupq_n_f32(epsilon);\n    float32x4_t v_neg_epsilon = vdupq_n_f32(-epsilon);\n    float32x4_t v_zero = vdupq_n_f32(0.0f);\n\n    size_t i;\n    for (i = 0; i <= length - 4; i += 4) {\n        float32x4_t v_a = vld1q_f32(&A[i]);\n        float32x4_t v_b = vld1q_f32(&B[i]);\n        float32x4_t v_diff = vsubq_f32(v_a, v_b);\n\n        uint32x4_t v_cmp_gt = vcgtq_f32(v_diff, v_epsilon);\n        uint32x4_t v_cmp_lt = vcltq_f32(v_diff, v_neg_epsilon);\n\n        int8x8_t v_out_low = vcombine_s8(\n            vreinterpret_s8_u8(vmovn_u16(vreinterpret_u16_u32(v_cmp_gt))),\n            vreinterpret_s8_u8(vmovn_u16(vreinterpret_u16_u32(v_cmp_lt)))\n        );\n        int8x8_t v_out_high = vcombine_s8(\n            vreinterpret_s8_u8(vmovn_u16(vreinterpret_u16_u32(v_cmp_gt))),\n            vreinterpret_s8_u8(vmovn_u16(vreinterpret_u16_u32(v_cmp_lt)))\n        );\n\n        int8x16_t v_out = vcombine_s8(v_out_low, v_out_high);\n\n        vst1q_s8(&out[i], v_out);\n    }\n\n    for (; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > epsilon) {\n            out[i] = 1;\n        } else if (diff < -epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float32x4_t v_epsilon = vdupq_n_f32(epsilon);\n    float32x4_t v_neg_epsilon = vdupq_n_f32(-epsilon);\n    float32x4_t v_zero = vdupq_n_f32(0.0f);\n\n    size_t i;\n    for (i = 0; i <= length - 4; i += 4) {\n        float32x4_t v_a = vld1q_f32(&A[i]);\n        float32x4_t v_b = vld1q_f32(&B[i]);\n        float32x4_t v_diff = vsubq_f32(v_a, v_b);\n\n        uint32x4_t v_cmp_gt = vcgtq_f32(v_diff, v_epsilon);\n        uint32x4_t v_cmp_lt = vcltq_f32(v_diff, v_neg_epsilon);\n\n        int8x8_t v_out_low = vcombine_s8(\n            vreinterpret_s8_u8(vmovn_u16(vreinterpretq_u16_u32(v_cmp_gt))),\n            vreinterpret_s8_u8(vmovn_u16(vreinterpretq_u16_u32(v_cmp_lt)))\n        );\n\n        int8x8_t v_out_high = vcombine_s8(\n            vreinterpret_s8_u8(vmovn_u16(vreinterpretq_u16_u32(v_cmp_gt))),\n            vreinterpret_s8_u8(vmovn_u16(vreinterpretq_u16_u32(v_cmp_lt)))\n        );\n\n        int8x16_t v_out = vcombine_s8(v_out_low, v_out_high);\n\n        vst1q_s8(&out[i], v_out);\n    }\n\n    for (; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > epsilon) {\n            out[i] = 1;\n        } else if (diff < -epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    float32x4_t vmax = vdupq_n_f32(INT32_MAX);\n    float32x4_t vmin = vdupq_n_f32(INT32_MIN);\n\n    for (size_t i = 0; i < size; i += 4) {\n        float32x4_t vA = vld1q_f32(&A[i]);\n        vA = vmaxq_f32(vA, vmin);\n        vA = vminq_f32(vA, vmax);\n        int32x4_t vB = vcvtq_s32_f32(vA);\n        vst1q_s32(&B[i], vB);\n    }\n}\n```"}
{"task_id": "SimdBench_50_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    float32x4_t vmax = vdupq_n_f32(INT32_MAX);\n    float32x4_t vmin = vdupq_n_f32(INT32_MIN);\n\n    for (size_t i = 0; i < size; i += 4) {\n        float32x4_t vA = vld1q_f32(&A[i]);\n        vA = vmaxq_f32(vA, vmin);\n        vA = vminq_f32(vA, vmax);\n        int32x4_t vB = vcvtq_s32_f32(vA);\n        vst1q_s32(&B[i], vB);\n    }\n\n    // Handle remaining elements if size is not a multiple of 4\n    for (size_t i = (size & ~3); i < size; ++i) {\n        float value = A[i];\n        if (value > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (value < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)value;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    float32x4_t v_max = vdupq_n_f32(INT32_MAX);\n    float32x4_t v_min = vdupq_n_f32(INT32_MIN);\n\n    for (size_t i = 0; i < size; i += 4) {\n        float32x4_t v_a = vld1q_f32(&A[i]);\n        v_a = vmaxq_f32(v_a, v_min);\n        v_a = vminq_f32(v_a, v_max);\n        int32x4_t v_b = vcvtq_s32_f32(v_a);\n        vst1q_s32(&B[i], v_b);\n    }\n\n    // Handle remaining elements if size is not a multiple of 4\n    for (size_t i = (size & ~3); i < size; ++i) {\n        float value = A[i];\n        if (value > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (value < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)value;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    float32x4_t vmax = vdupq_n_f32(INT32_MAX);\n    float32x4_t vmin = vdupq_n_f32(INT32_MIN);\n\n    for (size_t i = 0; i < size; i += 4) {\n        float32x4_t vA = vld1q_f32(&A[i]);\n        vA = vmaxq_f32(vA, vmin);\n        vA = vminq_f32(vA, vmax);\n        int32x4_t vB = vcvtq_s32_f32(vA);\n        vst1q_s32(&B[i], vB);\n    }\n}\n```"}
{"task_id": "SimdBench_50_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    float32x4_t v_max = vdupq_n_f32(INT32_MAX);\n    float32x4_t v_min = vdupq_n_f32(INT32_MIN);\n\n    for (size_t i = 0; i < size; i += 4) {\n        float32x4_t v_a = vld1q_f32(&A[i]);\n        v_a = vmaxq_f32(v_a, v_min);\n        v_a = vminq_f32(v_a, v_max);\n        int32x4_t v_b = vcvtq_s32_f32(v_a);\n        vst1q_s32(&B[i], v_b);\n    }\n}\n```"}
{"task_id": "SimdBench_51_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    float32x4_t scale_vec = vdupq_n_f32((float)scale);\n\n    for (size_t i = 0; i < size; i += 4) {\n        int32x4_t int_vec = vld1q_s32(&A[i]);\n        float32x4_t float_vec = vcvtq_f32_s32(int_vec);\n        float_vec = vmulq_f32(float_vec, scale_vec);\n        vst1q_f32(&B[i], float_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_51_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    float32x4_t vscale = vdupq_n_f32((float)scale);\n    size_t i;\n\n    for (i = 0; i + 3 < size; i += 4) {\n        int32x4_t vA = vld1q_s32(&A[i]);\n        float32x4_t vB = vcvtq_f32_s32(vA);\n        vB = vmulq_f32(vB, vscale);\n        vst1q_f32(&B[i], vB);\n    }\n\n    for (; i < size; ++i) {\n        B[i] = (float)A[i] * (float)scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    float32x4_t vscale = vdupq_n_f32((float)scale);\n    size_t i;\n\n    for (i = 0; i <= size - 4; i += 4) {\n        int32x4_t vA = vld1q_s32(&A[i]);\n        float32x4_t vB = vcvtq_f32_s32(vA);\n        vB = vmulq_f32(vB, vscale);\n        vst1q_f32(&B[i], vB);\n    }\n\n    for (; i < size; ++i) {\n        B[i] = (float)A[i] * (float)scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    float32x4_t scale_vec = vdupq_n_f32((float)scale);\n\n    for (size_t i = 0; i < size; i += 4) {\n        int32x4_t int_vec = vld1q_s32(&A[i]);\n        float32x4_t float_vec = vcvtq_f32_s32(int_vec);\n        float_vec = vmulq_f32(float_vec, scale_vec);\n        vst1q_f32(&B[i], float_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_51_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    float32x4_t vscale = vdupq_n_f32((float)scale);\n    size_t i;\n\n    for (i = 0; i <= size - 4; i += 4) {\n        int32x4_t vA = vld1q_s32(&A[i]);\n        float32x4_t vB = vcvtq_f32_s32(vA);\n        vB = vmulq_f32(vB, vscale);\n        vst1q_f32(&B[i], vB);\n    }\n\n    for (; i < size; ++i) {\n        B[i] = (float)A[i] * (float)scale;\n    }\n}\n```"}
{"task_id": "SimdBench_52_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i;\n    for (i = 0; i <= size - 4; i += 4) {\n        float32x4_t va = vld1q_f32(&A[i]);\n        float32x4_t vb = vld1q_f32(&B[i]);\n        float32x4_t vc = vdivq_f32(va, vb);\n        int32x4_t vd = vcvtq_s32_f32(vc);\n        vst1q_s32(&C[i], vd);\n    }\n\n    for (; i < size; ++i) {\n        C[i] = lrintf(A[i] / B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_52_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i;\n    for (i = 0; i <= size - 4; i += 4) {\n        float32x4_t va = vld1q_f32(&A[i]);\n        float32x4_t vb = vld1q_f32(&B[i]);\n        float32x4_t vc = vdivq_f32(va, vb);\n        int32x4_t vi = vrndq_f32(vc);\n        vst1q_s32(&C[i], vi);\n    }\n    for (; i < size; ++i) {\n        C[i] = lrintf(A[i] / B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_52_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i;\n    for (i = 0; i + 3 < size; i += 4) {\n        float32x4_t va = vld1q_f32(&A[i]);\n        float32x4_t vb = vld1q_f32(&B[i]);\n        float32x4_t vc = vdivq_f32(va, vb);\n        int32x4_t vd = vrndq_s32_f32(vc);\n        vst1q_s32(&C[i], vd);\n    }\n    for (; i < size; ++i) {\n        C[i] = lrintf(A[i] / B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_52_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i;\n    for (i = 0; i <= size - 4; i += 4) {\n        float32x4_t va = vld1q_f32(&A[i]);\n        float32x4_t vb = vld1q_f32(&B[i]);\n        float32x4_t vc = vdivq_f32(va, vb);\n        int32x4_t vr = vrndq_f32(vc);\n        vst1q_s32(&C[i], vr);\n    }\n    for (; i < size; ++i) {\n        C[i] = lrintf(A[i] / B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_52_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i;\n    for (i = 0; i <= size - 4; i += 4) {\n        float32x4_t va = vld1q_f32(&A[i]);\n        float32x4_t vb = vld1q_f32(&B[i]);\n        float32x4_t vc = vdivq_f32(va, vb);\n        int32x4_t vd = vcvtq_s32_f32(vc);\n        vst1q_s32(&C[i], vd);\n    }\n\n    for (; i < size; ++i) {\n        C[i] = (int32_t)((A[i] / B[i]) + 0.5f);\n    }\n}\n```"}
{"task_id": "SimdBench_53_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i;\n    float32x4_t v_max = vdupq_n_f32(FLT_MAX);\n    float32x4_t v_min = vdupq_n_f32(-FLT_MAX);\n\n    for (i = 0; i <= size - 2; i += 2) {\n        float64x2_t v_d = vld1q_f64(&A[i]);\n        float32x4_t v_f = vcvtq_f32_f64(v_d);\n\n        v_f = vmaxq_f32(v_f, v_min);\n        v_f = vminq_f32(v_f, v_max);\n\n        vst1q_f32(&B[i * 2], v_f);\n    }\n\n    if (i < size) {\n        float64x1_t v_d = vld1_f64(&A[i]);\n        float32x2_t v_f = vcvt_f32_f64(v_d);\n\n        v_f = vmax_f32(v_f, vget_low_f32(v_min));\n        v_f = vmin_f32(v_f, vget_low_f32(v_max));\n\n        vst1_f32(&B[i * 2], v_f);\n    }\n}\n```"}
{"task_id": "SimdBench_53_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i;\n    float32x4_t v_max = vdupq_n_f32(FLT_MAX);\n    float32x4_t v_min = vdupq_n_f32(-FLT_MAX);\n\n    for (i = 0; i <= size - 2; i += 2) {\n        float64x2_t v_A = vld1q_f64(&A[i]);\n        float32x4_t v_B = vcombine_f32(vmov_n_f32(A[i]), vmov_n_f32(A[i + 1]));\n        v_B = vcvt_f32_f64(v_A);\n        v_B = vmaxq_f32(v_B, v_min);\n        v_B = vminq_f32(v_B, v_max);\n        vst1q_f32(&B[i], v_B);\n    }\n\n    if (i < size) {\n        B[i] = (A[i] > FLT_MAX) ? FLT_MAX : (A[i] < -FLT_MAX) ? -FLT_MAX : (float)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_53_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i;\n    float32x4_t v_flt_max = vdupq_n_f32(FLT_MAX);\n    float32x4_t v_neg_flt_max = vdupq_n_f32(-FLT_MAX);\n\n    for (i = 0; i <= size - 2; i += 2) {\n        float64x2_t v_double = vld1q_f64(&A[i]);\n        float32x4_t v_float = vcvtq_f32_f64(v_double);\n\n        uint32x4_t v_mask_max = vcgtq_f32(v_float, v_flt_max);\n        uint32x4_t v_mask_min = vcltq_f32(v_float, v_neg_flt_max);\n\n        v_float = vbslq_f32(v_mask_max, v_flt_max, v_float);\n        v_float = vbslq_f32(v_mask_min, v_neg_flt_max, v_float);\n\n        vst1q_f32(&B[i * 2], v_float);\n    }\n\n    if (i < size) {\n        B[i] = (A[i] > FLT_MAX) ? FLT_MAX : (A[i] < -FLT_MAX) ? -FLT_MAX : (float)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_53_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i;\n    float32x4_t v_flt_max = vdupq_n_f32(FLT_MAX);\n    float32x4_t v_neg_flt_max = vdupq_n_f32(-FLT_MAX);\n\n    for (i = 0; i < size - 1; i += 2) {\n        float64x2_t v_double = vld1q_f64(&A[i]);\n        float32x4_t v_float = vcvtq_f32_f64(v_double);\n\n        float32x4_t v_max = vmaxq_f32(v_float, v_neg_flt_max);\n        float32x4_t v_min = vminq_f32(v_max, v_flt_max);\n\n        vst1q_f32(&B[i * 2], v_min);\n    }\n\n    if (i < size) {\n        B[size - 1] = (A[size - 1] > FLT_MAX) ? FLT_MAX : (A[size - 1] < -FLT_MAX) ? -FLT_MAX : (float)A[size - 1];\n    }\n}\n```"}
{"task_id": "SimdBench_53_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i;\n    float32x4_t v_flt_max = vdupq_n_f32(FLT_MAX);\n    float32x4_t v_neg_flt_max = vdupq_n_f32(-FLT_MAX);\n\n    for (i = 0; i <= size - 2; i += 2) {\n        float64x2_t v_double = vld1q_f64(&A[i]);\n        float32x4_t v_float = vcvtq_f32_f64(v_double);\n\n        float32x4_t v_mask_max = vcgtq_f32(v_float, v_flt_max);\n        float32x4_t v_mask_min = vcltq_f32(v_float, v_neg_flt_max);\n\n        v_float = vbslq_f32(v_mask_max, v_flt_max, v_float);\n        v_float = vbslq_f32(v_mask_min, v_neg_flt_max, v_float);\n\n        vst1q_f32(&B[i * 2], v_float);\n    }\n\n    if (i < size) {\n        B[i] = (A[i] > FLT_MAX) ? FLT_MAX : (A[i] < -FLT_MAX) ? -FLT_MAX : (float)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i;\n    for (i = 0; i <= size - 8; i += 8) {\n        int16x8_t vA = vld1q_s16(&A[i]);\n        int32x4_t vB_low = vmovl_s16(vget_low_s16(vA));\n        int32x4_t vB_high = vmovl_s16(vget_high_s16(vA));\n        vst1q_s32(&B[i], vB_low);\n        vst1q_s32(&B[i + 4], vB_high);\n    }\n    for (; i < size; ++i) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i;\n    for (i = 0; i <= size - 8; i += 8) {\n        int16x8_t v = vld1q_s16(&A[i]);\n        int32x4_t v_low = vmovl_s16(vget_low_s16(v));\n        int32x4_t v_high = vmovl_s16(vget_high_s16(v));\n        vst1q_s32(&B[i], v_low);\n        vst1q_s32(&B[i + 4], v_high);\n    }\n    for (; i < size; ++i) {\n        B[i] = A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i;\n    for (i = 0; i <= size - 8; i += 8) {\n        int16x8_t vA = vld1q_s16(&A[i]);\n        int32x4_t vB_low = vmovl_s16(vget_low_s16(vA));\n        int32x4_t vB_high = vmovl_s16(vget_high_s16(vA));\n        vst1q_s32(&B[i], vB_low);\n        vst1q_s32(&B[i + 4], vB_high);\n    }\n    for (; i < size; ++i) {\n        B[i] = A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i;\n    for (i = 0; i <= size - 8; i += 8) {\n        int16x8_t v = vld1q_s16(&A[i]);\n        int32x4_t low = vmovl_s16(vget_low_s16(v));\n        int32x4_t high = vmovl_s16(vget_high_s16(v));\n        vst1q_s32(&B[i], low);\n        vst1q_s32(&B[i + 4], high);\n    }\n    for (; i < size; ++i) {\n        B[i] = A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i;\n    for (i = 0; i <= size - 8; i += 8) {\n        int16x8_t v = vld1q_s16(&A[i]);\n        int32x4_t low = vmovl_s16(vget_low_s16(v));\n        int32x4_t high = vmovl_s16(vget_high_s16(v));\n        vst1q_s32(&B[i], low);\n        vst1q_s32(&B[i + 4], high);\n    }\n    for (; i < size; ++i) {\n        B[i] = A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_55_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float32x4_t vmin = vdupq_n_f32(min_val);\n    float32x4_t vmax = vdupq_n_f32(max_val);\n    float32x4_t vrange = vsubq_f32(vmax, vmin);\n    float32x4_t vzero = vdupq_n_f32(0.0f);\n    float32x4_t vone = vdupq_n_f32(1.0f);\n\n    for (size_t i = 0; i < size; i += 4) {\n        float32x4_t va = vld1q_f32(&A[i]);\n        int32x4_t vcontrol = vld1q_s32(&control[i]);\n\n        uint32x4_t vmask = vcgtq_s32(vcontrol, vdupq_n_s32(0));\n        float32x4_t vnorm = vdivq_f32(vsubq_f32(va, vmin), vrange);\n        vnorm = vmaxq_f32(vminq_f32(vnorm, vzero), vone);\n\n        float32x4_t vresult = vbslq_f32(vmask, vnorm, va);\n        vst1q_f32(&B[i], vresult);\n    }\n}\n```"}
{"task_id": "SimdBench_55_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stddef.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float32x4_t vmin = vdupq_n_f32(min_val);\n    float32x4_t vmax = vdupq_n_f32(max_val);\n    float32x4_t vrange = vsubq_f32(vmax, vmin);\n    float32x4_t vzero = vdupq_n_f32(0.0f);\n    float32x4_t vone = vdupq_n_f32(1.0f);\n\n    for (size_t i = 0; i < size; i += 4) {\n        float32x4_t va = vld1q_f32(&A[i]);\n        int32x4_t vcontrol = vld1q_s32(&control[i]);\n\n        uint32x4_t vmask = vcgtq_s32(vcontrol, vdupq_n_s32(0));\n        float32x4_t vnorm = vsubq_f32(va, vmin);\n        vnorm = vdivq_f32(vnorm, vrange);\n        vnorm = vmaxq_f32(vnorm, vzero);\n        vnorm = vminq_f32(vnorm, vone);\n\n        float32x4_t vresult = vbslq_f32(vmask, vnorm, va);\n        vst1q_f32(&B[i], vresult);\n    }\n}\n```"}
{"task_id": "SimdBench_55_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float32x4_t vmin = vdupq_n_f32(min_val);\n    float32x4_t vmax = vdupq_n_f32(max_val);\n    float32x4_t vrange = vsubq_f32(vmax, vmin);\n    float32x4_t vzero = vdupq_n_f32(0.0f);\n    float32x4_t vone = vdupq_n_f32(1.0f);\n\n    for (size_t i = 0; i < size; i += 4) {\n        float32x4_t va = vld1q_f32(&A[i]);\n        int32x4_t vcontrol = vld1q_s32(&control[i]);\n\n        uint32x4_t vmask = vcgtq_s32(vcontrol, vdupq_n_s32(0));\n        float32x4_t vnorm = vsubq_f32(va, vmin);\n        vnorm = vdivq_f32(vnorm, vrange);\n        vnorm = vmaxq_f32(vnorm, vzero);\n        vnorm = vminq_f32(vnorm, vone);\n\n        float32x4_t vresult = vbslq_f32(vmask, vnorm, va);\n        vst1q_f32(&B[i], vresult);\n    }\n}\n```"}
{"task_id": "SimdBench_55_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stddef.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float32x4_t vmin = vdupq_n_f32(min_val);\n    float32x4_t vmax = vdupq_n_f32(max_val);\n    float32x4_t vrange = vsubq_f32(vmax, vmin);\n    float32x4_t vzero = vdupq_n_f32(0.0f);\n    float32x4_t vone = vdupq_n_f32(1.0f);\n\n    for (size_t i = 0; i < size; i += 4) {\n        float32x4_t va = vld1q_f32(&A[i]);\n        int32x4_t vcontrol = vld1q_s32(&control[i]);\n\n        uint32x4_t vmask = vcgtq_s32(vcontrol, vdupq_n_s32(0));\n        float32x4_t vnorm = vdivq_f32(vsubq_f32(va, vmin), vrange);\n        vnorm = vmaxq_f32(vminq_f32(vnorm, vzero), vone);\n\n        float32x4_t vresult = vbslq_f32(vmask, vnorm, va);\n        vst1q_f32(&B[i], vresult);\n    }\n}\n```"}
{"task_id": "SimdBench_55_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float32x4_t vmin = vdupq_n_f32(min_val);\n    float32x4_t vmax = vdupq_n_f32(max_val);\n    float32x4_t vrange = vsubq_f32(vmax, vmin);\n    float32x4_t vzero = vdupq_n_f32(0.0f);\n    float32x4_t vone = vdupq_n_f32(1.0f);\n\n    for (size_t i = 0; i < size; i += 4) {\n        float32x4_t va = vld1q_f32(&A[i]);\n        int32x4_t vcontrol = vld1q_s32(&control[i]);\n\n        uint32x4_t vmask = vcgtq_s32(vcontrol, vdupq_n_s32(0));\n        float32x4_t vnorm = vsubq_f32(va, vmin);\n        vnorm = vdivq_f32(vnorm, vrange);\n        vnorm = vmaxq_f32(vnorm, vzero);\n        vnorm = vminq_f32(vnorm, vone);\n\n        float32x4_t vresult = vbslq_f32(vmask, vnorm, va);\n        vst1q_f32(&B[i], vresult);\n    }\n}\n```"}
{"task_id": "SimdBench_56_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    for (i = 0; i + 3 < size; i += 4) {\n        uint32x4_t vA = vld1q_u32(&A[i]);\n        uint16x4_t vHigh = vshrn_n_u32(vA, 16);\n        float32x4_t vFloat = vcvtq_f32_u32(vmovl_u16(vHigh));\n        vFloat = vsqrtq_f32(vFloat);\n        vst1q_f32(&B[i], vFloat);\n    }\n\n    for (; i < size; ++i) {\n        uint16_t high = A[i] >> 16;\n        float floatVal = (float)high;\n        B[i] = sqrtf(floatVal);\n    }\n}\n```"}
{"task_id": "SimdBench_56_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    for (i = 0; i + 3 < size; i += 4) {\n        uint32x4_t vA = vld1q_u32(&A[i]);\n        uint16x4_t vHigh = vshrn_n_u32(vA, 16);\n        float32x4_t vFloat = vcvtq_f32_u32(vmovl_u16(vHigh));\n        vFloat = vsqrtq_f32(vFloat);\n        vst1q_f32(&B[i], vFloat);\n    }\n\n    for (; i < size; ++i) {\n        uint16_t high = A[i] >> 16;\n        float floatVal = (float)high;\n        B[i] = sqrtf(floatVal);\n    }\n}\n```"}
{"task_id": "SimdBench_56_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    for (i = 0; i + 3 < size; i += 4) {\n        uint32x4_t v_A = vld1q_u32(&A[i]);\n        uint16x4_t v_high = vshrn_n_u32(v_A, 16);\n        float32x4_t v_float = vcvtq_f32_u32(vmovl_u16(v_high));\n        float32x4_t v_sqrt = vsqrtq_f32(v_float);\n        vst1q_f32(&B[i], v_sqrt);\n    }\n    for (; i < size; ++i) {\n        uint16_t high = A[i] >> 16;\n        float value = sqrtf((float)high);\n        B[i] = value;\n    }\n}\n```"}
{"task_id": "SimdBench_56_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    for (i = 0; i + 3 < size; i += 4) {\n        uint32x4_t vA = vld1q_u32(&A[i]);\n        uint16x4_t vHigh = vshrn_n_u32(vA, 16);\n        float32x4_t vFloat = vcvtq_f32_u32(vmovl_u16(vHigh));\n        vFloat = vsqrtq_f32(vFloat);\n        vst1q_f32(&B[i], vFloat);\n    }\n    for (; i < size; ++i) {\n        uint32_t value = A[i];\n        uint16_t high = value >> 16;\n        float floatValue = (float)high;\n        B[i] = sqrtf(floatValue);\n    }\n}\n```"}
{"task_id": "SimdBench_56_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    for (i = 0; i + 3 < size; i += 4) {\n        uint32x4_t vA = vld1q_u32(&A[i]);\n        uint16x4_t vHigh = vshrn_n_u32(vA, 16);\n        float32x4_t vFloat = vcvtq_f32_u32(vmovl_u16(vHigh));\n        vFloat = vsqrtq_f32(vFloat);\n        vst1q_f32(&B[i], vFloat);\n    }\n    for (; i < size; ++i) {\n        uint16_t high = A[i] >> 16;\n        float floatVal = (float)high;\n        B[i] = sqrtf(floatVal);\n    }\n}\n```"}
{"task_id": "SimdBench_57_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    for (i = 0; i + 3 < size; i += 4) {\n        uint32x4_t v = vld1q_u32(&A[i]);\n        vst1q_f32(&B[i], vreinterpretq_f32_u32(v));\n    }\n    for (; i < size; i++) {\n        uint32x2_t v = vld1_u32(&A[i]);\n        vst1_f32(&B[i], vreinterpret_f32_u32(v));\n    }\n}\n```"}
{"task_id": "SimdBench_57_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    for (i = 0; i + 3 < size; i += 4) {\n        uint32x4_t v = vld1q_u32(&A[i]);\n        vst1q_f32(&B[i], vreinterpretq_f32_u32(v));\n    }\n    for (; i < size; i++) {\n        uint32x2_t v = vld1_u32(&A[i]);\n        vst1_f32(&B[i], vreinterpret_f32_u32(v));\n    }\n}\n```"}
{"task_id": "SimdBench_57_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    for (i = 0; i + 3 < size; i += 4) {\n        uint32x4_t v = vld1q_u32(&A[i]);\n        vst1q_f32(&B[i], vreinterpretq_f32_u32(v));\n    }\n    for (; i < size; i++) {\n        uint32_t v = A[i];\n        B[i] = *(float*)&v;\n    }\n}\n```"}
{"task_id": "SimdBench_57_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    for (i = 0; i + 3 < size; i += 4) {\n        uint32x4_t v = vld1q_u32(&A[i]);\n        vst1q_f32(&B[i], vreinterpretq_f32_u32(v));\n    }\n    for (; i < size; i++) {\n        B[i] = *(float*)&A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_57_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    for (i = 0; i <= size - 4; i += 4) {\n        uint32x4_t v = vld1q_u32(&A[i]);\n        vst1q_f32(&B[i], vreinterpretq_f32_u32(v));\n    }\n    for (; i < size; ++i) {\n        uint32x2_t v = vld1_u32(&A[i]);\n        vst1_f32(&B[i], vreinterpret_f32_u32(v));\n    }\n}\n```"}
{"task_id": "SimdBench_58_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    diff[0] = 0.0f;\n\n    for (size_t i = 1; i < size; i += 4) {\n        uint32x4_t cond_mask = vld1q_u32((const uint32_t*)&cond[i]);\n        int32x4_t A_curr = vld1q_s32(&A[i]);\n        int32x4_t A_prev = vld1q_s32(&A[i - 1]);\n\n        int32x4_t diff_int = vsubq_s32(A_curr, A_prev);\n        float32x4_t diff_float = vcvtq_f32_s32(diff_int);\n\n        uint32x4_t zero_mask = vceqq_s32(vreinterpretq_s32_u32(cond_mask), vdupq_n_u32(0));\n        float32x4_t zero_float = vdupq_n_f32(0.0f);\n\n        diff_float = vbslq_f32(zero_mask, zero_float, diff_float);\n\n        vst1q_f32(&diff[i], diff_float);\n    }\n}\n```"}
{"task_id": "SimdBench_58_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    diff[0] = 0.0f;\n\n    for (size_t i = 1; i < size; i += 4) {\n        uint32x4_t cond_mask = vld1q_u32((const uint32_t*)&cond[i]);\n        int32x4_t A_curr = vld1q_s32(&A[i]);\n        int32x4_t A_prev = vld1q_s32(&A[i - 1]);\n\n        int32x4_t diff_int = vsubq_s32(A_curr, A_prev);\n        float32x4_t diff_float = vcvtq_f32_s32(diff_int);\n\n        uint32x4_t zero_mask = vmvnq_u32(cond_mask);\n        float32x4_t zero_float = vreinterpretq_f32_u32(zero_mask);\n\n        float32x4_t result = vbslq_f32(cond_mask, diff_float, zero_float);\n\n        vst1q_f32(&diff[i], result);\n    }\n\n    for (size_t i = size; i < size + 3; ++i) {\n        if (i < size) {\n            diff[i] = cond[i] ? (float)(A[i] - A[i - 1]) : 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    diff[0] = 0.0f;\n\n    for (size_t i = 1; i < size; i += 4) {\n        uint32x4_t cond_mask = vld1q_u32((const uint32_t*)&cond[i]);\n        int32x4_t A_curr = vld1q_s32(&A[i]);\n        int32x4_t A_prev = vld1q_s32(&A[i - 1]);\n\n        int32x4_t diff_int = vsubq_s32(A_curr, A_prev);\n        float32x4_t diff_float = vcvtq_f32_s32(diff_int);\n\n        uint32x4_t zero_mask = vmvnq_u32(cond_mask);\n        float32x4_t zero_float = vreinterpretq_f32_u32(zero_mask);\n\n        diff_float = vbslq_f32(cond_mask, diff_float, vdupq_n_f32(0.0f));\n\n        vst1q_f32(&diff[i], diff_float);\n    }\n}\n```"}
{"task_id": "SimdBench_58_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    diff[0] = 0.0f;\n\n    for (size_t i = 1; i < size; i += 4) {\n        uint32x4_t cond_mask = vld1q_u32((const uint32_t*)&cond[i]);\n        int32x4_t A_curr = vld1q_s32(&A[i]);\n        int32x4_t A_prev = vld1q_s32(&A[i - 1]);\n        int32x4_t diff_int = vsubq_s32(A_curr, A_prev);\n\n        float32x4_t diff_float = vcvtq_f32_s32(diff_int);\n        float32x4_t zero_float = vdupq_n_f32(0.0f);\n\n        diff_float = vbslq_f32(cond_mask, diff_float, zero_float);\n\n        vst1q_f32(&diff[i], diff_float);\n    }\n\n    for (size_t i = size - (size % 4); i < size; ++i) {\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i - 1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    diff[0] = 0.0f;\n\n    for (size_t i = 1; i < size; i += 4) {\n        uint32x4_t cond_mask = vld1q_u32((const uint32_t*)&cond[i]);\n        int32x4_t A_prev = vld1q_s32(&A[i-1]);\n        int32x4_t A_curr = vld1q_s32(&A[i]);\n\n        int32x4_t diff_int = vsubq_s32(A_curr, A_prev);\n        float32x4_t diff_float = vcvtq_f32_s32(diff_int);\n\n        uint32x4_t zero_mask = vmvnq_u32(cond_mask);\n        float32x4_t zero_float = vreinterpretq_f32_u32(zero_mask);\n\n        diff_float = vbslq_f32(cond_mask, diff_float, vdupq_n_f32(0.0f));\n\n        vst1q_f32(&diff[i], diff_float);\n    }\n}\n```"}
{"task_id": "SimdBench_59_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    uint32x4_t mask_low = vdupq_n_u32(0xFFFFFFFF);\n    uint32x4_t mask_high = vdupq_n_u32(0x00000001);\n\n    for (size_t i = 0; i < length; i += 4) {\n        uint32x4_t src_vec = vld1q_u32(&src[i]);\n        uint64x2_t low_vec = vmovl_u32(vget_low_u32(src_vec));\n        uint64x2_t high_vec = vmovl_u32(vget_high_u32(src_vec));\n\n        low_vec = vorrq_u64(low_vec, vreinterpretq_u64_u32(mask_high));\n        high_vec = vorrq_u64(high_vec, vreinterpretq_u64_u32(mask_high));\n\n        vst1q_u64(&dst[i], low_vec);\n        vst1q_u64(&dst[i + 2], high_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_59_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    uint32x4_t mask = vdupq_n_u32(0xFFFFFFFF);\n    size_t i;\n\n    for (i = 0; i <= length - 4; i += 4) {\n        uint32x4_t vsrc = vld1q_u32(&src[i]);\n        uint64x2_t low = vmovl_u32(vget_low_u32(vsrc));\n        uint64x2_t high = vmovl_u32(vget_high_u32(vsrc));\n        low = vorrq_u64(low, vreinterpretq_u64_u32(mask));\n        high = vorrq_u64(high, vreinterpretq_u64_u32(mask));\n        vst1q_u64(&dst[i], low);\n        vst1q_u64(&dst[i + 2], high);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = src[i] | 0xFFFFFFFF00000000;\n    }\n}\n```"}
{"task_id": "SimdBench_59_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    uint32x4_t mask = vdupq_n_u32(0xFFFFFFFF);\n    size_t i;\n\n    for (i = 0; i <= length - 4; i += 4) {\n        uint32x4_t vsrc = vld1q_u32(&src[i]);\n        uint64x2_t low = vmovl_u32(vget_low_u32(vsrc));\n        uint64x2_t high = vmovl_u32(vget_high_u32(vsrc));\n        low = vorr_u64(low, vreinterpretq_u64_u32(mask));\n        high = vorr_u64(high, vreinterpretq_u64_u32(mask));\n        vst1q_u64(&dst[i], low);\n        vst1q_u64(&dst[i + 2], high);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = src[i] | 0xFFFFFFFF00000000;\n    }\n}\n```"}
{"task_id": "SimdBench_59_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    uint32x4_t v_mask = vdupq_n_u32(0xFFFFFFFF);\n    uint64x2_t v_high_mask = vdupq_n_u64(0xFFFFFFFF00000000);\n\n    size_t i;\n    for (i = 0; i <= length - 4; i += 4) {\n        uint32x4_t v_src = vld1q_u32(&src[i]);\n        uint32x4_t v_src_masked = vorrq_u32(v_src, v_mask);\n        uint64x2_t v_dst_low = vmovl_u32(vget_low_u32(v_src_masked));\n        uint64x2_t v_dst_high = vmovl_u32(vget_high_u32(v_src_masked));\n        v_dst_low = vorrq_u64(v_dst_low, v_high_mask);\n        v_dst_high = vorrq_u64(v_dst_high, v_high_mask);\n        vst1q_u64(&dst[i], v_dst_low);\n        vst1q_u64(&dst[i + 2], v_dst_high);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = (uint64_t)src[i] | 0xFFFFFFFF00000000;\n    }\n}\n```"}
{"task_id": "SimdBench_59_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    uint32x4_t mask = vdupq_n_u32(0xFFFFFFFF);\n    size_t i;\n\n    for (i = 0; i + 3 < length; i += 4) {\n        uint32x4_t vsrc = vld1q_u32(&src[i]);\n        uint64x2_t vdst_low = vmovl_u32(vget_low_u32(vsrc));\n        uint64x2_t vdst_high = vmovl_u32(vget_high_u32(vsrc));\n\n        vdst_low = vorrq_u64(vdst_low, vreinterpretq_u64_u32(mask));\n        vdst_high = vorrq_u64(vdst_high, vreinterpretq_u64_u32(mask));\n\n        vst1q_u64(&dst[i], vdst_low);\n        vst1q_u64(&dst[i + 2], vdst_high);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = src[i] | 0xFFFFFFFF00000000;\n    }\n}\n```"}
{"task_id": "SimdBench_60_Neon", "completion": "```c\n#include <arm_neon.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    float64x2_t sum_vec = vdupq_n_f64(0.0);\n    float64x2_t temp_vec;\n\n    for (size_t i = 0; i < length; i += 2) {\n        if (i + 1 < length) {\n            temp_vec = vld1q_f64(&vec[index[i]]);\n            temp_vec = vaddq_f64(temp_vec, vld1q_f64(&vec[index[i + 1]]));\n        } else {\n            temp_vec = vld1q_lane_f64(&vec[index[i]], temp_vec, 0);\n        }\n        sum_vec = vaddq_f64(sum_vec, temp_vec);\n    }\n\n    double sum[2];\n    vst1q_f64(sum, sum_vec);\n    return sum[0] + sum[1];\n}\n```"}
{"task_id": "SimdBench_60_Neon", "completion": "```c\n#include <arm_neon.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    size_t i = 0;\n\n    for (; i <= length - 2; i += 2) {\n        int16x4_t idx = vld1_s16(&index[i]);\n        int32x2_t idx_lo = vmovl_s16(vget_low_s16(idx));\n\n        float64x2_t vec0 = vld1q_f64(&vec[idx_lo[0]]);\n        float64x2_t vec1 = vld1q_f64(&vec[idx_lo[1]]);\n\n        float64x2_t sum_vec = vaddq_f64(vec0, vec1);\n        sum += vgetq_lane_f64(sum_vec, 0);\n        sum += vgetq_lane_f64(sum_vec, 1);\n    }\n\n    for (; i < length; ++i) {\n        sum += vec[index[i]];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60_Neon", "completion": "```c\n#include <arm_neon.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    float64x2_t sum_vec = vdupq_n_f64(0.0);\n    float64x2_t temp_vec;\n\n    for (size_t i = 0; i < length; i += 2) {\n        if (i + 1 < length) {\n            temp_vec = vld1q_lane_f64(&vec[index[i]], temp_vec, 0);\n            temp_vec = vld1q_lane_f64(&vec[index[i + 1]], temp_vec, 1);\n            sum_vec = vaddq_f64(sum_vec, temp_vec);\n        } else {\n            temp_vec = vld1q_lane_f64(&vec[index[i]], temp_vec, 0);\n            sum_vec = vaddq_f64(sum_vec, temp_vec);\n        }\n    }\n\n    double sum[2];\n    vst1q_f64(sum, sum_vec);\n    return sum[0] + sum[1];\n}\n```"}
{"task_id": "SimdBench_60_Neon", "completion": "```c\n#include <arm_neon.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    size_t i;\n\n    for (i = 0; i <= length - 2; i += 2) {\n        int16x4_t idx = vld1_s16(&index[i]);\n        int32x2_t idx_lo = vmovl_s16(vget_low_s16(idx));\n\n        float64x2_t vec0 = vld1q_f64(&vec[idx_lo[0]]);\n        float64x2_t vec1 = vld1q_f64(&vec[idx_lo[1]]);\n\n        float64x2_t sum_vec = vaddq_f64(vec0, vec1);\n        sum += vgetq_lane_f64(sum_vec, 0) + vgetq_lane_f64(sum_vec, 1);\n    }\n\n    for (; i < length; ++i) {\n        sum += vec[index[i]];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60_Neon", "completion": "```c\n#include <arm_neon.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    size_t i = 0;\n\n    for (; i <= length - 2; i += 2) {\n        int16x4_t idx = vld1_s16(&index[i]);\n        int32x2_t idx_lo = vmovl_s16(vget_low_s16(idx));\n\n        float64x2_t vec0 = vld1q_f64(&vec[idx_lo[0]]);\n        float64x2_t vec1 = vld1q_f64(&vec[idx_lo[1]]);\n\n        float64x2_t sum_vec = vaddq_f64(vec0, vec1);\n        sum += vgetq_lane_f64(sum_vec, 0) + vgetq_lane_f64(sum_vec, 1);\n    }\n\n    for (; i < length; ++i) {\n        sum += vec[index[i]];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_61_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    size_t kernel_flat_size = kernel_size * kernel_size;\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < kernel_size; ++k) {\n                for (size_t l = 0; l < kernel_size; ++l) {\n                    sum += input[(i + k) * input_size + (j + l)] * kernel[k * kernel_size + l];\n                }\n            }\n            output[i * output_size + j] = fmax(0, sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    size_t output_stride = output_size;\n    size_t input_stride = input_size;\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double32x2_t sum = vdup_n_f64(0.0);\n\n            for (size_t k = 0; k < kernel_size; ++k) {\n                for (size_t l = 0; l < kernel_size; ++l) {\n                    double32x2_t input_val = vld1_dup_f64(&input[(i + k) * input_stride + j + l]);\n                    double32x2_t kernel_val = vld1_dup_f64(&kernel[k * kernel_size + l]);\n                    sum = vadd_f64(sum, vmul_f64(input_val, kernel_val));\n                }\n            }\n\n            double32x2_t relu_sum = vmax_f64(sum, vdup_n_f64(0.0));\n            vst1_f64(&output[i * output_stride + j], relu_sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    size_t output_stride = output_size;\n    size_t input_stride = input_size;\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double32x2_t sum = vdup_n_f64(0.0);\n\n            for (size_t k = 0; k < kernel_size; ++k) {\n                for (size_t l = 0; l < kernel_size; ++l) {\n                    double32x2_t input_val = vld1_dup_f64(&input[(i + k) * input_stride + (j + l)]);\n                    double32x2_t kernel_val = vld1_dup_f64(&kernel[k * kernel_size + l]);\n                    sum = vadd_f64(sum, vmul_f64(input_val, kernel_val));\n                }\n            }\n\n            double32x2_t relu = vmax_f64(sum, vdup_n_f64(0.0));\n            vst1_f64(&output[i * output_stride + j], relu);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    size_t output_stride = output_size;\n    size_t input_stride = input_size;\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double32x2_t sum = vdup_n_f64(0.0);\n\n            for (size_t k = 0; k < kernel_size; ++k) {\n                for (size_t l = 0; l < kernel_size; ++l) {\n                    double32x2_t input_val = vld1_dup_f64(&input[(i + k) * input_stride + j + l]);\n                    double32x2_t kernel_val = vld1_dup_f64(&kernel[k * kernel_size + l]);\n                    sum = vadd_f64(sum, vmul_f64(input_val, kernel_val));\n                }\n            }\n\n            double32x2_t relu = vmax_f64(sum, vdup_n_f64(0.0));\n            vst1_f64(&output[i * output_stride + j], relu);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    size_t kernel_flat_size = kernel_size * kernel_size;\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double32x2_t sum = vdup_n_f64(0.0);\n\n            for (size_t k = 0; k < kernel_size; ++k) {\n                for (size_t l = 0; l < kernel_size; ++l) {\n                    size_t input_idx = (i + k) * input_size + (j + l);\n                    size_t kernel_idx = k * kernel_size + l;\n\n                    double32x2_t input_val = vld1_dup_f64(&input[input_idx]);\n                    double32x2_t kernel_val = vld1_dup_f64(&kernel[kernel_idx]);\n\n                    sum = vadd_f64(sum, vmul_f64(input_val, kernel_val));\n                }\n            }\n\n            double32x2_t relu_sum = vmax_f64(sum, vdup_n_f64(0.0));\n            size_t output_idx = i * output_size + j;\n            vst1_f64(&output[output_idx], relu_sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_62_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nbool has_close_elements_simd(const std::vector<double> &numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n < 2) return false;\n\n    float64x2_t threshold_vec = vdupq_n_f64(threshold);\n    bool close_found = false;\n\n    for (size_t i = 0; i < n - 1; ++i) {\n        float64x2_t num1 = vdupq_n_f64(numbers[i]);\n        for (size_t j = i + 1; j < n; ++j) {\n            float64x2_t num2 = vdupq_n_f64(numbers[j]);\n            float64x2_t diff = vabsq_f64(vsubq_f64(num1, num2));\n            uint64x2_t mask = vcltq_f64(diff, threshold_vec);\n            if (vgetq_lane_u64(mask, 0) || vgetq_lane_u64(mask, 1)) {\n                close_found = true;\n                break;\n            }\n        }\n        if (close_found) break;\n    }\n\n    return close_found;\n}\n```"}
{"task_id": "SimdBench_62_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nbool has_close_elements_simd(const std::vector<double> &numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n < 2) return false;\n\n    double threshold_squared = threshold * threshold;\n    float32x4_t threshold_vec = vdupq_n_f32(threshold_squared);\n\n    for (size_t i = 0; i < n - 1; ++i) {\n        float32x4_t num_vec = vdupq_n_f32(numbers[i]);\n\n        for (size_t j = i + 1; j < n; ++j) {\n            float32x4_t diff_vec = vsubq_f32(vdupq_n_f32(numbers[j]), num_vec);\n            float32x4_t dist_vec = vmulq_f32(diff_vec, diff_vec);\n\n            uint32x4_t mask = vcleq_f32(dist_vec, threshold_vec);\n            if (vgetq_lane_u32(mask, 0) || vgetq_lane_u32(mask, 1) || vgetq_lane_u32(mask, 2) || vgetq_lane_u32(mask, 3)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nbool has_close_elements_simd(const std::vector<double>& numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n < 2) return false;\n\n    double threshold_squared = threshold * threshold;\n    float32x4_t threshold_vec = vdupq_n_f32(threshold_squared);\n\n    for (size_t i = 0; i < n - 1; ++i) {\n        float32x4_t num1_vec = vdupq_n_f32(numbers[i]);\n\n        for (size_t j = i + 1; j < n; ++j) {\n            float32x4_t num2_vec = vdupq_n_f32(numbers[j]);\n            float32x4_t diff_vec = vsubq_f32(num1_vec, num2_vec);\n            float32x4_t dist_vec = vmulq_f32(diff_vec, diff_vec);\n\n            uint32x4_t mask = vcleq_f32(dist_vec, threshold_vec);\n            if (vgetq_lane_u32(mask, 0) || vgetq_lane_u32(mask, 1) || vgetq_lane_u32(mask, 2) || vgetq_lane_u32(mask, 3)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nbool has_close_elements_simd(const std::vector<double>& numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n < 2) return false;\n\n    float64x2_t threshold_vec = vdupq_n_f64(threshold);\n    float64x2_t zero_vec = vdupq_n_f64(0.0);\n\n    for (size_t i = 0; i < n; i += 2) {\n        for (size_t j = i + 2; j < n; j += 2) {\n            float64x2_t vec1 = vld1q_f64(&numbers[i]);\n            float64x2_t vec2 = vld1q_f64(&numbers[j]);\n\n            float64x2_t diff = vabsq_f64(vsubq_f64(vec1, vec2));\n            uint64x2_t cmp = vcleq_f64(diff, threshold_vec);\n\n            if (vgetq_lane_u64(cmp, 0) || vgetq_lane_u64(cmp, 1)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nbool has_close_elements_simd(const std::vector<double> &numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n < 2) return false;\n\n    float64x2_t threshold_vec = vdupq_n_f64(threshold);\n    bool close_found = false;\n\n    for (size_t i = 0; i < n - 1; ++i) {\n        float64x2_t num1 = vdupq_n_f64(numbers[i]);\n        for (size_t j = i + 1; j < n; ++j) {\n            float64x2_t num2 = vdupq_n_f64(numbers[j]);\n            float64x2_t diff = vabsq_f64(vsubq_f64(num1, num2));\n            uint64x2_t mask = vcltq_f64(diff, threshold_vec);\n            if (vgetq_lane_u64(mask, 0) || vgetq_lane_u64(mask, 1)) {\n                close_found = true;\n                break;\n            }\n        }\n        if (close_found) break;\n    }\n\n    return close_found;\n}\n```"}
{"task_id": "SimdBench_63_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int32x4_t balance = vdupq_n_s32(0);\n    size_t i;\n\n    for (i = 0; i <= operations.size() - 4; i += 4) {\n        int32x4_t ops = vld1q_s32(&operations[i]);\n        balance = vaddq_s32(balance, ops);\n        int32x4_t mask = vcltq_s32(balance, vdupq_n_s32(0));\n        if (vgetq_lane_s32(mask, 0) || vgetq_lane_s32(mask, 1) || vgetq_lane_s32(mask, 2) || vgetq_lane_s32(mask, 3)) {\n            return true;\n        }\n    }\n\n    int remaining_balance = vgetq_lane_s32(balance, 0) + vgetq_lane_s32(balance, 1) + vgetq_lane_s32(balance, 2) + vgetq_lane_s32(balance, 3);\n\n    for (; i < operations.size(); ++i) {\n        remaining_balance += operations[i];\n        if (remaining_balance < 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int32x4_t balance = vdupq_n_s32(0);\n    size_t i;\n\n    for (i = 0; i <= operations.size() - 4; i += 4) {\n        int32x4_t ops = vld1q_s32(&operations[i]);\n        balance = vaddq_s32(balance, ops);\n        int32x4_t mask = vcltq_s32(balance, vdupq_n_s32(0));\n        if (vminvq_u32(vreinterpretq_u32_s32(mask))) {\n            return true;\n        }\n    }\n\n    int32_t balance_sum = vaddvq_s32(balance);\n    for (; i < operations.size(); ++i) {\n        balance_sum += operations[i];\n        if (balance_sum < 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int32x4_t balance = vdupq_n_s32(0);\n    size_t i;\n\n    for (i = 0; i <= operations.size() - 4; i += 4) {\n        int32x4_t ops = vld1q_s32(&operations[i]);\n        balance = vaddq_s32(balance, ops);\n        int32x4_t mask = vcltq_s32(balance, vdupq_n_s32(0));\n        if (vgetq_lane_s32(mask, 0) || vgetq_lane_s32(mask, 1) || vgetq_lane_s32(mask, 2) || vgetq_lane_s32(mask, 3)) {\n            return true;\n        }\n    }\n\n    int remaining_balance = vgetq_lane_s32(balance, 0) + vgetq_lane_s32(balance, 1) + vgetq_lane_s32(balance, 2) + vgetq_lane_s32(balance, 3);\n\n    for (; i < operations.size(); ++i) {\n        remaining_balance += operations[i];\n        if (remaining_balance < 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int32x4_t balance = vdupq_n_s32(0);\n    size_t i;\n\n    for (i = 0; i <= operations.size() - 4; i += 4) {\n        int32x4_t ops = vld1q_s32(&operations[i]);\n        balance = vaddq_s32(balance, ops);\n        int32x4_t mask = vcltq_s32(balance, vdupq_n_s32(0));\n        if (vminvq_u32(vreinterpretq_u32_s32(mask))) {\n            return true;\n        }\n    }\n\n    int remaining_balance = vgetq_lane_s32(balance, 0) + vgetq_lane_s32(balance, 1) + vgetq_lane_s32(balance, 2) + vgetq_lane_s32(balance, 3);\n\n    for (; i < operations.size(); ++i) {\n        remaining_balance += operations[i];\n        if (remaining_balance < 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int32x4_t balance = vdupq_n_s32(0);\n    int32x4_t zero = vdupq_n_s32(0);\n    size_t i;\n\n    for (i = 0; i <= operations.size() - 4; i += 4) {\n        int32x4_t ops = vld1q_s32(&operations[i]);\n        balance = vaddq_s32(balance, ops);\n        int32x4_t mask = vcltq_s32(balance, zero);\n        if (vgetq_lane_s32(mask, 0) || vgetq_lane_s32(mask, 1) || vgetq_lane_s32(mask, 2) || vgetq_lane_s32(mask, 3)) {\n            return true;\n        }\n    }\n\n    int remaining_balance = vgetq_lane_s32(balance, 0) + vgetq_lane_s32(balance, 1) +\n                            vgetq_lane_s32(balance, 2) + vgetq_lane_s32(balance, 3);\n\n    for (; i < operations.size(); ++i) {\n        remaining_balance += operations[i];\n        if (remaining_balance < 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_64_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    double sum = 0.0;\n    for (size_t i = 0; i < n; ++i) {\n        sum += numbers[i];\n    }\n    double mean = sum / n;\n\n    double sum_abs_dev = 0.0;\n    size_t i = 0;\n    for (; i <= n - 2; i += 2) {\n        float32x2_t v = vld1_f64(&numbers[i]);\n        float32x2_t mean_v = vdup_n_f64(mean);\n        float32x2_t diff = vabs_f64(vsub_f64(v, mean_v));\n        sum_abs_dev += vget_lane_f64(diff, 0) + vget_lane_f64(diff, 1);\n    }\n    for (; i < n; ++i) {\n        sum_abs_dev += std::abs(numbers[i] - mean);\n    }\n\n    return sum_abs_dev / n;\n}\n```"}
{"task_id": "SimdBench_64_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    double sum = 0.0;\n    for (size_t i = 0; i < n; ++i) {\n        sum += numbers[i];\n    }\n    double mean = sum / n;\n\n    double mad = 0.0;\n    size_t i = 0;\n    for (; i <= n - 4; i += 4) {\n        float32x4_t v = vld1q_f32(&numbers[i]);\n        float32x4_t mean_v = vdupq_n_f32(mean);\n        float32x4_t diff = vabsq_f32(vsubq_f32(v, mean_v));\n        mad += vgetq_lane_f32(diff, 0);\n        mad += vgetq_lane_f32(diff, 1);\n        mad += vgetq_lane_f32(diff, 2);\n        mad += vgetq_lane_f32(diff, 3);\n    }\n    for (; i < n; ++i) {\n        mad += std::abs(numbers[i] - mean);\n    }\n\n    return mad / n;\n}\n```"}
{"task_id": "SimdBench_64_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    double sum = 0.0;\n    for (size_t i = 0; i < n; ++i) {\n        sum += numbers[i];\n    }\n    double mean = sum / n;\n\n    double mad = 0.0;\n    size_t i = 0;\n    for (; i <= n - 4; i += 4) {\n        float32x4_t vmean = vdupq_n_f32(mean);\n        float32x4_t vnum = vld1q_f32(&numbers[i]);\n        float32x4_t vdiff = vabsq_f32(vsubq_f32(vnum, vmean));\n        mad += vgetq_lane_f32(vdiff, 0);\n        mad += vgetq_lane_f32(vdiff, 1);\n        mad += vgetq_lane_f32(vdiff, 2);\n        mad += vgetq_lane_f32(vdiff, 3);\n    }\n    for (; i < n; ++i) {\n        mad += std::abs(numbers[i] - mean);\n    }\n\n    return mad / n;\n}\n```"}
{"task_id": "SimdBench_64_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    double sum = 0.0;\n    for (size_t i = 0; i < n; ++i) {\n        sum += numbers[i];\n    }\n    double mean = sum / n;\n\n    double sum_abs_dev = 0.0;\n    size_t i = 0;\n\n    for (; i <= n - 4; i += 4) {\n        float32x4_t vmean = vdupq_n_f32(mean);\n        float32x4_t vnum = vld1q_f32(&numbers[i]);\n        float32x4_t vdiff = vabsq_f32(vsubq_f32(vnum, vmean));\n        float32x2_t vsum = vadd_f32(vget_low_f32(vdiff), vget_high_f32(vdiff));\n        vsum = vpadd_f32(vsum, vsum);\n        sum_abs_dev += vget_lane_f32(vsum, 0);\n    }\n\n    for (; i < n; ++i) {\n        sum_abs_dev += std::abs(numbers[i] - mean);\n    }\n\n    return sum_abs_dev / n;\n}\n```"}
{"task_id": "SimdBench_64_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    double sum = 0.0;\n    for (size_t i = 0; i < n; ++i) {\n        sum += numbers[i];\n    }\n    double mean = sum / n;\n\n    double mad = 0.0;\n    size_t i = 0;\n    for (; i <= n - 4; i += 4) {\n        float32x4_t vmean = vdupq_n_f32(mean);\n        float32x4_t v = vld1q_f32(&numbers[i]);\n        float32x4_t vdiff = vabsq_f32(vsubq_f32(v, vmean));\n        mad += vgetq_lane_f32(vdiff, 0);\n        mad += vgetq_lane_f32(vdiff, 1);\n        mad += vgetq_lane_f32(vdiff, 2);\n        mad += vgetq_lane_f32(vdiff, 3);\n    }\n    for (; i < n; ++i) {\n        mad += std::abs(numbers[i] - mean);\n    }\n\n    return mad / n;\n}\n```"}
{"task_id": "SimdBench_65_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    size_t n = numbers.size();\n    std::vector<int> result((n * 2) - 1);\n\n    int32x4_t delim_vec = vdupq_n_s32(delimeter);\n    int32x4_t num_vec;\n\n    size_t i = 0, j = 0;\n    for (; i <= n - 4; i += 4, j += 8) {\n        num_vec = vld1q_s32(&numbers[i]);\n        vst1q_s32(&result[j], num_vec);\n        vst1q_s32(&result[j + 4], delim_vec);\n    }\n\n    for (; i < n; ++i, j += 2) {\n        result[j] = numbers[i];\n        if (j + 1 < result.size()) {\n            result[j + 1] = delimeter;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimiter) {\n    size_t n = numbers.size();\n    std::vector<int> result((n * 2) - 1);\n\n    int32x4_t v_delimiter = vdupq_n_s32(delimiter);\n    int32x4_t v_num1, v_num2;\n    int32x4_t v_result1, v_result2;\n\n    size_t i = 0;\n    for (; i <= n - 4; i += 4) {\n        v_num1 = vld1q_s32(&numbers[i]);\n        v_num2 = vld1q_s32(&numbers[i + 4]);\n\n        v_result1 = vcombine_s32(vget_low_s32(v_num1), vget_low_s32(v_delimiter));\n        v_result2 = vcombine_s32(vget_high_s32(v_num1), vget_low_s32(v_delimiter));\n\n        vst1q_s32(&result[i * 2], v_result1);\n        vst1q_s32(&result[i * 2 + 4], v_result2);\n    }\n\n    for (; i < n; ++i) {\n        result[i * 2] = numbers[i];\n        if (i * 2 + 1 < result.size()) {\n            result[i * 2 + 1] = delimiter;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimiter) {\n    size_t n = numbers.size();\n    std::vector<int> result((n * 2) - 1);\n\n    int32x4_t v_delimiter = vdupq_n_s32(delimiter);\n    size_t i = 0;\n\n    for (; i <= n - 4; i += 4) {\n        int32x4_t v_num = vld1q_s32(&numbers[i]);\n        vst1q_s32(&result[i * 2], v_num);\n        vst1q_s32(&result[i * 2 + 4], v_delimiter);\n    }\n\n    for (; i < n; ++i) {\n        result[i * 2] = numbers[i];\n        if (i * 2 + 1 < result.size()) {\n            result[i * 2 + 1] = delimiter;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    size_t n = numbers.size();\n    std::vector<int> result((n * 2) - 1);\n\n    int32x4_t delim_vec = vdupq_n_s32(delimeter);\n    int32x4_t num_vec;\n\n    size_t i = 0, j = 0;\n    for (; i <= n - 4; i += 4, j += 8) {\n        num_vec = vld1q_s32(&numbers[i]);\n        vst1q_s32(&result[j], num_vec);\n        vst1q_s32(&result[j + 4], delim_vec);\n    }\n\n    for (; i < n; ++i, j += 2) {\n        result[j] = numbers[i];\n        if (i != n - 1) {\n            result[j + 1] = delimeter;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    size_t n = numbers.size();\n    std::vector<int> result((n * 2) - 1);\n\n    int32x4_t delim_vec = vdupq_n_s32(delimeter);\n    int32x4_t num_vec;\n\n    size_t i = 0, j = 0;\n    for (; i <= n - 4; i += 4, j += 8) {\n        num_vec = vld1q_s32(&numbers[i]);\n        vst1q_s32(&result[j], num_vec);\n        vst1q_s32(&result[j + 4], delim_vec);\n    }\n\n    for (; i < n; ++i, j += 2) {\n        result[j] = numbers[i];\n        if (j + 1 < result.size()) {\n            result[j + 1] = delimeter;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_66_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    size_t vec_size = numbers.size();\n\n    if (vec_size == 0) {\n        return {0, 1};\n    }\n\n    int16x8_t vec_sum = vdupq_n_s16(0);\n    int16x8_t vec_product = vdupq_n_s16(1);\n    int16x8_t vec_one = vdupq_n_s16(1);\n\n    size_t i;\n    for (i = 0; i <= vec_size - 8; i += 8) {\n        int16x8_t vec = vld1q_s16(&numbers[i]);\n        vec_sum = vaddq_s16(vec_sum, vec);\n        vec_product = vmulq_s16(vec_product, vec);\n    }\n\n    int16_t temp_sum[8];\n    int16_t temp_product[8];\n    vst1q_s16(temp_sum, vec_sum);\n    vst1q_s16(temp_product, vec_product);\n\n    for (int j = 0; j < 8; ++j) {\n        sum += temp_sum[j];\n        product *= temp_product[j];\n    }\n\n    for (; i < vec_size; ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    size_t vec_size = numbers.size();\n\n    if (vec_size == 0) {\n        return {0, 1};\n    }\n\n    int16x8_t vec_sum = vdupq_n_s16(0);\n    int16x8_t vec_product = vdupq_n_s16(1);\n    int16x8_t vec_one = vdupq_n_s16(1);\n\n    for (size_t i = 0; i < vec_size; i += 8) {\n        int16x8_t chunk = vld1q_s16(&numbers[i]);\n        vec_sum = vaddq_s16(vec_sum, chunk);\n        vec_product = vmulq_s16(vec_product, chunk);\n    }\n\n    int16_t temp_sum[8];\n    int16_t temp_product[8];\n    vst1q_s16(temp_sum, vec_sum);\n    vst1q_s16(temp_product, vec_product);\n\n    for (int i = 0; i < 8; ++i) {\n        sum += temp_sum[i];\n        product *= temp_product[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    size_t vec_size = numbers.size();\n\n    if (vec_size == 0) {\n        return {0, 1};\n    }\n\n    int16x8_t vec_sum = vdupq_n_s16(0);\n    int16x8_t vec_product = vdupq_n_s16(1);\n    int16x8_t vec_one = vdupq_n_s16(1);\n\n    for (size_t i = 0; i < vec_size; i += 8) {\n        int16x8_t chunk = vld1q_s16(&numbers[i]);\n        vec_sum = vaddq_s16(vec_sum, chunk);\n        vec_product = vmulq_s16(vec_product, chunk);\n    }\n\n    int16_t temp_sum[8];\n    int16_t temp_product[8];\n    vst1q_s16(temp_sum, vec_sum);\n    vst1q_s16(temp_product, vec_product);\n\n    for (int i = 0; i < 8; ++i) {\n        sum += temp_sum[i];\n        product *= temp_product[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    size_t vec_size = numbers.size();\n\n    if (vec_size == 0) {\n        return {0, 1};\n    }\n\n    int16x8_t vec_sum = vdupq_n_s16(0);\n    int16x8_t vec_product = vdupq_n_s16(1);\n    int16x8_t vec_one = vdupq_n_s16(1);\n\n    size_t i;\n    for (i = 0; i <= vec_size - 8; i += 8) {\n        int16x8_t vec = vld1q_s16(&numbers[i]);\n        vec_sum = vaddq_s16(vec_sum, vec);\n        vec_product = vmulq_s16(vec_product, vec);\n    }\n\n    int16_t temp_sum[8];\n    int16_t temp_product[8];\n    vst1q_s16(temp_sum, vec_sum);\n    vst1q_s16(temp_product, vec_product);\n\n    for (int j = 0; j < 8; ++j) {\n        sum += temp_sum[j];\n        product *= temp_product[j];\n    }\n\n    for (; i < vec_size; ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    if (numbers.empty()) {\n        return {sum, product};\n    }\n\n    int16x8_t vec_sum = vdupq_n_s16(0);\n    int16x8_t vec_product = vdupq_n_s16(1);\n    int16x8_t vec_one = vdupq_n_s16(1);\n\n    size_t i;\n    for (i = 0; i <= numbers.size() - 8; i += 8) {\n        int16x8_t vec = vld1q_s16(&numbers[i]);\n        vec_sum = vaddq_s16(vec_sum, vec);\n        vec_product = vmulq_s16(vec_product, vec);\n    }\n\n    int16_t temp_sum[8];\n    int16_t temp_product[8];\n    vst1q_s16(temp_sum, vec_sum);\n    vst1q_s16(temp_product, vec_product);\n\n    for (int j = 0; j < 8; ++j) {\n        sum += temp_sum[j];\n        product *= temp_product[j];\n    }\n\n    for (; i < numbers.size(); ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_67_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    std::vector<int> result(numbers.size());\n    int32x4_t max_vec = vdupq_n_s32(INT32_MIN);\n    int32x4_t current_vec;\n\n    for (size_t i = 0; i < numbers.size(); i += 4) {\n        size_t remaining = numbers.size() - i;\n        if (remaining >= 4) {\n            current_vec = vld1q_s32(&numbers[i]);\n            max_vec = vmaxq_s32(max_vec, current_vec);\n            vst1q_s32(&result[i], max_vec);\n        } else {\n            int32x4_t temp_vec = vdupq_n_s32(INT32_MIN);\n            for (size_t j = 0; j < remaining; ++j) {\n                temp_vec = vsetq_lane_s32(numbers[i + j], temp_vec, j);\n            }\n            max_vec = vmaxq_s32(max_vec, temp_vec);\n            for (size_t j = 0; j < remaining; ++j) {\n                result[i + j] = vgetq_lane_s32(max_vec, j);\n            }\n            break;\n        }\n    }\n\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        result[i] = std::max(result[i], result[i - 1]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    std::vector<int> result(numbers.size());\n    int32x4_t max_vec = vdupq_n_s32(INT32_MIN);\n    int32x4_t current_vec;\n\n    for (size_t i = 0; i < numbers.size(); i += 4) {\n        current_vec = vld1q_s32(&numbers[i]);\n        max_vec = vmaxq_s32(max_vec, current_vec);\n        vst1q_s32(&result[i], max_vec);\n\n        int32x2_t max_half = vmax_s32(vget_low_s32(max_vec), vget_high_s32(max_vec));\n        int32_t max_val = std::max(vget_lane_s32(max_half, 0), vget_lane_s32(max_half, 1));\n\n        for (size_t j = i; j < i + 4 && j < numbers.size(); ++j) {\n            result[j] = max_val;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    std::vector<int> result(numbers.size());\n    int32x4_t max_vec = vdupq_n_s32(INT32_MIN);\n    int32x4_t curr_vec;\n    int32_t max_val = INT32_MIN;\n\n    for (size_t i = 0; i < numbers.size(); i += 4) {\n        size_t remaining = numbers.size() - i;\n        if (remaining >= 4) {\n            curr_vec = vld1q_s32(&numbers[i]);\n            max_vec = vmaxq_s32(max_vec, curr_vec);\n            vst1q_s32(&result[i], max_vec);\n        } else {\n            for (size_t j = 0; j < remaining; ++j) {\n                max_val = std::max(max_val, numbers[i + j]);\n                result[i + j] = max_val;\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    std::vector<int> result(numbers.size());\n    int32x4_t max_vec = vdupq_n_s32(INT32_MIN);\n    int32x4_t current_vec;\n    int max_val = INT32_MIN;\n\n    for (size_t i = 0; i < numbers.size(); i += 4) {\n        size_t remaining = numbers.size() - i;\n        if (remaining >= 4) {\n            current_vec = vld1q_s32(&numbers[i]);\n            max_vec = vmaxq_s32(max_vec, current_vec);\n            vst1q_s32(&result[i], max_vec);\n        } else {\n            for (size_t j = 0; j < remaining; ++j) {\n                max_val = std::max(max_val, numbers[i + j]);\n                result[i + j] = max_val;\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    std::vector<int> result(numbers.size());\n    int32x4_t max_vec = vdupq_n_s32(INT32_MIN);\n    int32x4_t curr_vec;\n    int32_t max_val = INT32_MIN;\n\n    for (size_t i = 0; i < numbers.size(); i += 4) {\n        size_t remaining = numbers.size() - i;\n        if (remaining >= 4) {\n            curr_vec = vld1q_s32(&numbers[i]);\n            max_vec = vmaxq_s32(max_vec, curr_vec);\n            vst1q_s32(&result[i], max_vec);\n        } else {\n            for (size_t j = 0; j < remaining; ++j) {\n                max_val = std::max(max_val, numbers[i + j]);\n                result[i + j] = max_val;\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n#include <cstring>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t length = a.length();\n    std::string result(length, ' ');\n\n    size_t i;\n    for (i = 0; i <= length - 16; i += 16) {\n        uint8x16_t va = vld1q_u8(&a[i]);\n        uint8x16_t vb = vld1q_u8(&b[i]);\n        uint8x16_t vx = veorq_u8(va, vb);\n        vst1q_u8(&result[i], vx);\n    }\n\n    for (; i < length; ++i) {\n        result[i] = a[i] ^ b[i];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n#include <cstring>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t length = a.length();\n    std::string result(length, '0');\n\n    size_t i = 0;\n    for (; i <= length - 16; i += 16) {\n        uint8x16_t va = vld1q_u8(&a[i]);\n        uint8x16_t vb = vld1q_u8(&b[i]);\n        uint8x16_t vxor = veorq_u8(va, vb);\n        vst1q_u8(&result[i], vxor);\n    }\n\n    for (; i < length; ++i) {\n        result[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n#include <cstring>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t length = a.length();\n    std::string result(length, ' ');\n\n    size_t i = 0;\n    for (; i <= length - 16; i += 16) {\n        uint8x16_t va = vld1q_u8(&a[i]);\n        uint8x16_t vb = vld1q_u8(&b[i]);\n        uint8x16_t vxor = veorq_u8(va, vb);\n        vst1q_u8(&result[i], vxor);\n    }\n\n    for (; i < length; ++i) {\n        result[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n#include <cstring>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t length = a.length();\n    std::string result(length, ' ');\n\n    size_t i = 0;\n    for (; i <= length - 16; i += 16) {\n        uint8x16_t va = vld1q_u8(&a[i]);\n        uint8x16_t vb = vld1q_u8(&b[i]);\n        uint8x16_t vx = veorq_u8(va, vb);\n        vst1q_u8(&result[i], vx);\n    }\n\n    for (; i < length; ++i) {\n        result[i] = a[i] ^ b[i];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n#include <cstring>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t length = a.length();\n    std::string result(length, ' ');\n\n    size_t i;\n    for (i = 0; i <= length - 16; i += 16) {\n        uint8x16_t va = vld1q_u8((uint8_t*)&a[i]);\n        uint8x16_t vb = vld1q_u8((uint8_t*)&b[i]);\n        uint8x16_t vxor = veorq_u8(va, vb);\n        vst1q_u8((uint8_t*)&result[i], vxor);\n    }\n\n    for (; i < length; ++i) {\n        result[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_69_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::string longest_simd(const std::vector<std::string> &strings) {\n    if (strings.empty()) {\n        return {};\n    }\n\n    std::string longest = strings[0];\n    size_t max_length = longest.length();\n\n    size_t vector_size = strings.size();\n    size_t i = 1;\n\n    for (; i + 3 < vector_size; i += 4) {\n        uint32x4_t lengths = {\n            static_cast<uint32_t>(strings[i].length()),\n            static_cast<uint32_t>(strings[i + 1].length()),\n            static_cast<uint32_t>(strings[i + 2].length()),\n            static_cast<uint32_t>(strings[i + 3].length())\n        };\n\n        uint32_t max_in_block = vmaxvq_u32(lengths);\n\n        if (max_in_block > max_length) {\n            if (static_cast<uint32_t>(strings[i].length()) == max_in_block) {\n                longest = strings[i];\n                max_length = max_in_block;\n            } else if (static_cast<uint32_t>(strings[i + 1].length()) == max_in_block) {\n                longest = strings[i + 1];\n                max_length = max_in_block;\n            } else if (static_cast<uint32_t>(strings[i + 2].length()) == max_in_block) {\n                longest = strings[i + 2];\n                max_length = max_in_block;\n            } else if (static_cast<uint32_t>(strings[i + 3].length()) == max_in_block) {\n                longest = strings[i + 3];\n                max_length = max_in_block;\n            }\n        }\n    }\n\n    for (; i < vector_size; ++i) {\n        if (strings[i].length() > max_length) {\n            longest = strings[i];\n            max_length = strings[i].length();\n        }\n    }\n\n    return longest;\n}\n```"}
{"task_id": "SimdBench_69_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::string longest_simd(const std::vector<std::string> &strings) {\n    if (strings.empty()) {\n        return {};\n    }\n\n    std::string longest = strings[0];\n    size_t max_length = longest.length();\n\n    for (size_t i = 1; i < strings.size(); i += 4) {\n        uint32x4_t lengths = {\n            static_cast<uint32_t>(strings[i].length()),\n            static_cast<uint32_t>(i + 1 < strings.size() ? strings[i + 1].length() : 0),\n            static_cast<uint32_t>(i + 2 < strings.size() ? strings[i + 2].length() : 0),\n            static_cast<uint32_t>(i + 3 < strings.size() ? strings[i + 3].length() : 0)\n        };\n\n        uint32x4_t max_len_vec = vdupq_n_u32(max_length);\n        uint32x4_t compare = vcgtq_u32(lengths, max_len_vec);\n\n        uint64_t mask = vgetq_lane_u64(vreinterpretq_u64_u32(compare), 0);\n\n        if (mask != 0) {\n            if (mask & 0xFFFFFFFF) {\n                longest = strings[i];\n                max_length = lengths[0];\n            } else if (mask & 0xFFFFFFFF00000000) {\n                longest = strings[i + 1];\n                max_length = lengths[1];\n            } else if (mask & 0xFFFFFFFF0000000000000000) {\n                longest = strings[i + 2];\n                max_length = lengths[2];\n            } else {\n                longest = strings[i + 3];\n                max_length = lengths[3];\n            }\n        }\n    }\n\n    return longest;\n}\n```"}
{"task_id": "SimdBench_69_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::string longest_simd(const std::vector<std::string> &strings) {\n    if (strings.empty()) {\n        return {};\n    }\n\n    std::string longest = strings[0];\n    size_t max_length = longest.length();\n\n    size_t vector_size = strings.size();\n    size_t i = 0;\n\n    // Process 4 strings at a time using NEON intrinsics\n    for (; i <= vector_size - 4; i += 4) {\n        uint32x4_t lengths = {\n            static_cast<uint32_t>(strings[i].length()),\n            static_cast<uint32_t>(strings[i + 1].length()),\n            static_cast<uint32_t>(strings[i + 2].length()),\n            static_cast<uint32_t>(strings[i + 3].length())\n        };\n\n        uint32_t max_in_group = vmaxvq_u32(lengths);\n\n        if (static_cast<size_t>(max_in_group) > max_length) {\n            if (static_cast<uint32_t>(strings[i].length()) == max_in_group) {\n                longest = strings[i];\n                max_length = max_in_group;\n            } else if (static_cast<uint32_t>(strings[i + 1].length()) == max_in_group) {\n                longest = strings[i + 1];\n                max_length = max_in_group;\n            } else if (static_cast<uint32_t>(strings[i + 2].length()) == max_in_group) {\n                longest = strings[i + 2];\n                max_length = max_in_group;\n            } else if (static_cast<uint32_t>(strings[i + 3].length()) == max_in_group) {\n                longest = strings[i + 3];\n                max_length = max_in_group;\n            }\n        }\n    }\n\n    // Process remaining strings\n    for (; i < vector_size; ++i) {\n        if (strings[i].length() > max_length) {\n            longest = strings[i];\n            max_length = strings[i].length();\n        }\n    }\n\n    return longest;\n}\n```"}
{"task_id": "SimdBench_69_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::string longest_simd(const std::vector<std::string> &strings) {\n    if (strings.empty()) {\n        return {};\n    }\n\n    std::string longest = strings[0];\n    size_t max_length = longest.length();\n\n    size_t vector_size = strings.size();\n    size_t i = 1;\n\n    for (; i + 3 < vector_size; i += 4) {\n        uint32x4_t lengths = {\n            static_cast<uint32_t>(strings[i].length()),\n            static_cast<uint32_t>(strings[i + 1].length()),\n            static_cast<uint32_t>(strings[i + 2].length()),\n            static_cast<uint32_t>(strings[i + 3].length())\n        };\n\n        uint32_t max_in_chunk = vmaxvq_u32(lengths);\n\n        if (max_in_chunk > max_length) {\n            if (static_cast<uint32_t>(strings[i].length()) == max_in_chunk) {\n                longest = strings[i];\n                max_length = max_in_chunk;\n            } else if (static_cast<uint32_t>(strings[i + 1].length()) == max_in_chunk) {\n                longest = strings[i + 1];\n                max_length = max_in_chunk;\n            } else if (static_cast<uint32_t>(strings[i + 2].length()) == max_in_chunk) {\n                longest = strings[i + 2];\n                max_length = max_in_chunk;\n            } else if (static_cast<uint32_t>(strings[i + 3].length()) == max_in_chunk) {\n                longest = strings[i + 3];\n                max_length = max_in_chunk;\n            }\n        }\n    }\n\n    for (; i < vector_size; ++i) {\n        if (strings[i].length() > max_length) {\n            longest = strings[i];\n            max_length = strings[i].length();\n        }\n    }\n\n    return longest;\n}\n```"}
{"task_id": "SimdBench_69_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::string longest_simd(const std::vector<std::string> &strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    std::string longest = strings[0];\n    size_t max_length = longest.length();\n\n    size_t vector_size = strings.size();\n    size_t i = 1;\n\n    for (; i + 3 < vector_size; i += 4) {\n        uint32x4_t lengths = {\n            static_cast<uint32_t>(strings[i].length()),\n            static_cast<uint32_t>(strings[i + 1].length()),\n            static_cast<uint32_t>(strings[i + 2].length()),\n            static_cast<uint32_t>(strings[i + 3].length())\n        };\n\n        uint32_t max_in_group = vmaxvq_u32(lengths);\n\n        if (max_in_group > max_length) {\n            if (max_in_group == strings[i].length()) {\n                longest = strings[i];\n                max_length = max_in_group;\n            } else if (max_in_group == strings[i + 1].length()) {\n                longest = strings[i + 1];\n                max_length = max_in_group;\n            } else if (max_in_group == strings[i + 2].length()) {\n                longest = strings[i + 2];\n                max_length = max_in_group;\n            } else {\n                longest = strings[i + 3];\n                max_length = max_in_group;\n            }\n        }\n    }\n\n    for (; i < vector_size; ++i) {\n        if (strings[i].length() > max_length) {\n            longest = strings[i];\n            max_length = strings[i].length();\n        }\n    }\n\n    return longest;\n}\n```"}
{"task_id": "SimdBench_70_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    uint64x2_t v_a = vdupq_n_u64(a);\n    uint64x2_t v_b = vdupq_n_u64(b);\n\n    while (true) {\n        uint64x2_t v_mod = v_a % v_b;\n        if (vgetq_lane_u64(v_mod, 0) == 0 && vgetq_lane_u64(v_mod, 1) == 0) {\n            return vgetq_lane_u64(v_b, 0);\n        }\n        v_a = v_b;\n        v_b = v_mod;\n    }\n}\n```"}
{"task_id": "SimdBench_70_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    uint64x2_t v_a = vdupq_n_u64(a);\n    uint64x2_t v_b = vdupq_n_u64(b);\n\n    while (true) {\n        uint64x2_t v_r = v_a % v_b;\n        if (vgetq_lane_u64(v_r, 0) == 0 && vgetq_lane_u64(v_r, 1) == 0) {\n            return vgetq_lane_u64(v_b, 0);\n        }\n        v_a = v_b;\n        v_b = v_r;\n    }\n}\n```"}
{"task_id": "SimdBench_70_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    uint64x2_t v_a = vdupq_n_u64(a);\n    uint64x2_t v_b = vdupq_n_u64(b);\n\n    while (true) {\n        uint64x2_t v_r = vsubq_u64(v_a, v_b);\n        uint64x2_t v_zero = vdupq_n_u64(0);\n        uint64x2_t v_mask = vcltq_u64(v_r, v_zero);\n\n        v_a = vbslq_u64(v_mask, v_b, v_a);\n        v_b = vbslq_u64(v_mask, v_a, v_r);\n\n        if (vgetq_lane_u64(v_b, 0) == 0) {\n            return vgetq_lane_u64(v_a, 0);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_70_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    uint64x2_t v_a = vdupq_n_u64(a);\n    uint64x2_t v_b = vdupq_n_u64(b);\n    uint64x2_t v_zero = vdupq_n_u64(0);\n\n    while (true) {\n        uint64x2_t v_rem = vabdq_u64(v_a, v_b);\n        uint64x2_t v_cmp = vcgtq_u64(v_rem, v_zero);\n\n        if (vgetq_lane_u64(v_cmp, 0) == 0 && vgetq_lane_u64(v_cmp, 1) == 0) {\n            break;\n        }\n\n        v_a = v_b;\n        v_b = v_rem;\n    }\n\n    return vgetq_lane_u64(v_b, 0);\n}\n```"}
{"task_id": "SimdBench_70_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    uint64x2_t v_a = vdupq_n_u64(a);\n    uint64x2_t v_b = vdupq_n_u64(b);\n    uint64x2_t v_zero = vdupq_n_u64(0);\n\n    while (true) {\n        uint64x2_t v_rem = vsubq_u64(v_a, vmlaq_u64(v_zero, v_b, vdupq_n_u64(v_a / v_b)));\n        v_a = v_b;\n        v_b = v_rem;\n\n        uint64_t rem0 = vgetq_lane_u64(v_rem, 0);\n        uint64_t rem1 = vgetq_lane_u64(v_rem, 1);\n\n        if (rem0 == 0 && rem1 == 0) {\n            return vgetq_lane_u64(v_a, 0);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_71_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <limits>\n#include <cmath>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    if (numbers.size() < 2) {\n        return {};\n    }\n\n    float32x4_t min_diff = vdupq_n_f32(std::numeric_limits<float>::max());\n    float32x2_t closest_pair = vdup_n_f32(std::numeric_limits<float>::max());\n\n    size_t n = numbers.size();\n    for (size_t i = 0; i < n - 1; i += 4) {\n        float32x4_t vec1 = vld1q_f32(&numbers[i]);\n        for (size_t j = i + 1; j < n; j += 4) {\n            float32x4_t vec2 = vld1q_f32(&numbers[j]);\n            float32x4_t diff = vabsq_f32(vsubq_f32(vec1, vec2));\n            uint32x4_t mask = vcltq_f32(diff, min_diff);\n            if (vgetq_lane_u32(mask, 0) || vgetq_lane_u32(mask, 1) || vgetq_lane_u32(mask, 2) || vgetq_lane_u32(mask, 3)) {\n                min_diff = diff;\n                closest_pair = vdup_n_f32(std::min(numbers[i], numbers[j]));\n            }\n        }\n    }\n\n    float min_val = vget_lane_f32(closest_pair, 0);\n    float second_val = min_val + vget_lane_f32(min_diff, 0);\n\n    return {min_val, second_val};\n}\n```"}
{"task_id": "SimdBench_71_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <limits>\n#include <cmath>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    if (numbers.size() < 2) {\n        return {};\n    }\n\n    float32x4_t min_diff = vdupq_n_f32(std::numeric_limits<float>::max());\n    float32x2_t closest_pair = vdup_n_f32(std::numeric_limits<float>::max());\n\n    for (size_t i = 0; i < numbers.size() - 1; i += 4) {\n        float32x4_t vec1 = vld1q_f32(&numbers[i]);\n        float32x4_t vec2 = vld1q_f32(&numbers[i + 1]);\n\n        float32x4_t diff = vabsq_f32(vsubq_f32(vec1, vec2));\n        uint32x4_t mask = vcltq_f32(diff, min_diff);\n\n        if (vgetq_lane_u32(mask, 0) || vgetq_lane_u32(mask, 1) || vgetq_lane_u32(mask, 2) || vgetq_lane_u32(mask, 3)) {\n            min_diff = diff;\n            closest_pair = vget_low_f32(vec1);\n        }\n    }\n\n    float min_val = vget_lane_f32(closest_pair, 0);\n    float max_val = vget_lane_f32(closest_pair, 1);\n\n    if (min_val > max_val) {\n        std::swap(min_val, max_val);\n    }\n\n    return {min_val, max_val};\n}\n```"}
{"task_id": "SimdBench_71_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <limits>\n#include <cmath>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    if (numbers.size() < 2) {\n        return {};\n    }\n\n    float32x4_t min_diff = vdupq_n_f32(std::numeric_limits<float>::max());\n    float32x2_t closest_pair = vdup_n_f32(std::numeric_limits<float>::max());\n\n    for (size_t i = 0; i < numbers.size() - 1; i += 4) {\n        float32x4_t vec1 = vld1q_f32(&numbers[i]);\n        float32x4_t vec2 = vld1q_f32(&numbers[i + 1]);\n\n        float32x4_t diff = vabsq_f32(vsubq_f32(vec1, vec2));\n        uint32x4_t mask = vcltq_f32(diff, min_diff);\n\n        if (vgetq_lane_u32(mask, 0) || vgetq_lane_u32(mask, 1) || vgetq_lane_u32(mask, 2) || vgetq_lane_u32(mask, 3)) {\n            min_diff = diff;\n            closest_pair = vget_low_f32(vec1);\n        }\n    }\n\n    float min_val1 = vget_lane_f32(closest_pair, 0);\n    float min_val2 = vget_lane_f32(closest_pair, 1);\n\n    if (min_val1 > min_val2) {\n        std::swap(min_val1, min_val2);\n    }\n\n    return {min_val1, min_val2};\n}\n```"}
{"task_id": "SimdBench_71_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <limits>\n#include <cmath>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    if (numbers.size() < 2) {\n        return {};\n    }\n\n    float32x4_t min_diff = vdupq_n_f32(std::numeric_limits<float>::max());\n    float32x2_t closest_pair = vdup_n_f32(std::numeric_limits<float>::max());\n\n    size_t n = numbers.size();\n    for (size_t i = 0; i < n - 1; i += 4) {\n        float32x4_t vec1 = vld1q_f32(&numbers[i]);\n        for (size_t j = i + 1; j < n; j += 4) {\n            float32x4_t vec2 = vld1q_f32(&numbers[j]);\n            float32x4_t diff = vabsq_f32(vsubq_f32(vec1, vec2));\n            uint32x4_t mask = vcltq_f32(diff, min_diff);\n            if (vgetq_lane_u32(mask, 0) || vgetq_lane_u32(mask, 1) || vgetq_lane_u32(mask, 2) || vgetq_lane_u32(mask, 3)) {\n                min_diff = vminq_f32(min_diff, diff);\n                float32x4_t min_vec1 = vbslq_f32(mask, vec1, vdupq_n_f32(std::numeric_limits<float>::max()));\n                float32x4_t min_vec2 = vbslq_f32(mask, vec2, vdupq_n_f32(std::numeric_limits<float>::max()));\n                closest_pair = vpmin_f32(vget_low_f32(min_vec1), vget_low_f32(min_vec2));\n            }\n        }\n    }\n\n    float min1 = vget_lane_f32(closest_pair, 0);\n    float min2 = vget_lane_f32(closest_pair, 1);\n    if (min1 > min2) {\n        std::swap(min1, min2);\n    }\n\n    return {min1, min2};\n}\n```"}
{"task_id": "SimdBench_71_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <limits>\n#include <cmath>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    if (numbers.size() < 2) {\n        return {};\n    }\n\n    float32x4_t min_diff = vdupq_n_f32(std::numeric_limits<float>::max());\n    float32x2_t closest_pair = vdup_n_f32(std::numeric_limits<float>::max());\n\n    for (size_t i = 0; i < numbers.size() - 1; i += 4) {\n        float32x4_t vec1 = vld1q_f32(&numbers[i]);\n        float32x4_t vec2 = vld1q_f32(&numbers[i + 1]);\n\n        float32x4_t diff = vabsq_f32(vsubq_f32(vec1, vec2));\n        uint32x4_t mask = vcltq_f32(diff, min_diff);\n\n        if (vgetq_lane_u32(mask, 0) || vgetq_lane_u32(mask, 1) || vgetq_lane_u32(mask, 2) || vgetq_lane_u32(mask, 3)) {\n            min_diff = diff;\n            closest_pair = vget_low_f32(vec1);\n        }\n    }\n\n    float min_val1 = vget_lane_f32(closest_pair, 0);\n    float min_val2 = vget_lane_f32(closest_pair, 1);\n\n    if (min_val1 > min_val2) {\n        std::swap(min_val1, min_val2);\n    }\n\n    return {min_val1, min_val2};\n}\n```"}
{"task_id": "SimdBench_72_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n\n    std::vector<float> rescaled(n);\n\n    for (size_t i = 0; i < n; i += 4) {\n        float32x4_t v = vld1q_f32(&numbers[i]);\n        float32x4_t min_v = vdupq_n_f32(min_val);\n        float32x4_t range_v = vdupq_n_f32(range);\n\n        float32x4_t scaled = vsubq_f32(v, min_v);\n        scaled = vdivq_f32(scaled, range_v);\n\n        vst1q_f32(&rescaled[i], scaled);\n    }\n\n    return rescaled;\n}\n```"}
{"task_id": "SimdBench_72_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n\n    std::vector<float> rescaled(n);\n\n    float32x4_t vmin = vdupq_n_f32(min_val);\n    float32x4_t vrange = vdupq_n_f32(range);\n    float32x4_t vone = vdupq_n_f32(1.0f);\n\n    for (size_t i = 0; i < n; i += 4) {\n        float32x4_t v = vld1q_f32(&numbers[i]);\n        float32x4_t vsub = vsubq_f32(v, vmin);\n        float32x4_t vdiv = vdivq_f32(vsub, vrange);\n        vst1q_f32(&rescaled[i], vdiv);\n    }\n\n    return rescaled;\n}\n```"}
{"task_id": "SimdBench_72_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    if (numbers.size() < 2) return numbers;\n\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n\n    std::vector<float> result(numbers.size());\n\n    float32x4_t vmin = vdupq_n_f32(min_val);\n    float32x4_t vrange = vdupq_n_f32(range);\n    float32x4_t vone = vdupq_n_f32(1.0f);\n\n    for (size_t i = 0; i < numbers.size(); i += 4) {\n        float32x4_t vnum = vld1q_f32(&numbers[i]);\n        float32x4_t vsub = vsubq_f32(vnum, vmin);\n        float32x4_t vdiv = vdivq_f32(vsub, vrange);\n        vst1q_f32(&result[i], vdiv);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n\n    std::vector<float> result(n);\n\n    for (size_t i = 0; i < n; i += 4) {\n        float32x4_t v = vld1q_f32(&numbers[i]);\n        float32x4_t min_v = vdupq_n_f32(min_val);\n        float32x4_t max_v = vdupq_n_f32(max_val);\n        float32x4_t range_v = vdupq_n_f32(range);\n\n        float32x4_t scaled = vsubq_f32(v, min_v);\n        scaled = vdivq_f32(scaled, range_v);\n\n        vst1q_f32(&result[i], scaled);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n\n    std::vector<float> result(n);\n\n    float32x4_t vmin = vdupq_n_f32(min_val);\n    float32x4_t vrange = vdupq_n_f32(range);\n    float32x4_t vone = vdupq_n_f32(1.0f);\n\n    for (size_t i = 0; i < n; i += 4) {\n        float32x4_t vnum = vld1q_f32(&numbers[i]);\n        float32x4_t vsub = vsubq_f32(vnum, vmin);\n        float32x4_t vdiv = vdivq_f32(vsub, vrange);\n        vst1q_f32(&result[i], vdiv);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_73_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    uint64x2_t n_vec = vdupq_n_u64(n);\n    uint64x2_t divisors = vdupq_n_u64(1);\n    uint64x2_t ones = vdupq_n_u64(1);\n    uint64x2_t increments = vdupq_n_u64(1);\n\n    for (uint64_t i = 1; i < n; i += 2) {\n        divisors = vaddq_u64(divisors, increments);\n        uint64x2_t remainders = vreinterpretq_u64_u32(vremq_u32(vreinterpretq_u32_u64(n_vec), vreinterpretq_u32_u64(divisors)));\n        uint64x2_t mask = vceqq_u64(remainders, vdupq_n_u64(0));\n\n        if (vgetq_lane_u64(mask, 0) || vgetq_lane_u64(mask, 1)) {\n            if (vgetq_lane_u64(mask, 0)) {\n                return vgetq_lane_u64(divisors, 0);\n            }\n            if (vgetq_lane_u64(mask, 1)) {\n                return vgetq_lane_u64(divisors, 1);\n            }\n        }\n    }\n\n    return 1;\n}\n```"}
{"task_id": "SimdBench_73_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    uint64x2_t n_vec = vdupq_n_u64(n);\n    uint64x2_t divisors = vdupq_n_u64(1);\n    uint64x2_t ones = vdupq_n_u64(1);\n    uint64x2_t increment = vdupq_n_u64(1);\n\n    for (uint64_t i = 1; i < n; i += 2) {\n        divisors = vaddq_u64(divisors, increment);\n        uint64x2_t remainder = vmodq_u64(n_vec, divisors);\n\n        uint64x2_t mask = vceqq_u64(remainder, vdupq_n_u64(0));\n        if (vgetq_lane_u64(mask, 0) || vgetq_lane_u64(mask, 1)) {\n            uint64_t div1 = vgetq_lane_u64(divisors, 0);\n            uint64_t div2 = vgetq_lane_u64(divisors, 1);\n            if (div1 < n && n % div1 == 0) return div1;\n            if (div2 < n && n % div2 == 0) return div2;\n        }\n    }\n    return 1;\n}\n```"}
{"task_id": "SimdBench_73_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    uint64x2_t n_vec = vdupq_n_u64(n);\n    uint64x2_t divisors = vdupq_n_u64(1);\n    uint64x2_t ones = vdupq_n_u64(1);\n    uint64x2_t increment = vdupq_n_u64(1);\n\n    for (uint64_t i = n / 2; i > 0; i -= 2) {\n        divisors = vaddq_u64(divisors, increment);\n        uint64x2_t rem = vreinterpretq_u64_u32(vremq_u32(vreinterpretq_u32_u64(n_vec), vreinterpretq_u32_u64(divisors)));\n        uint64x2_t mask = vceqq_u64(rem, vdupq_n_u64(0));\n\n        if (vgetq_lane_u64(mask, 0) || vgetq_lane_u64(mask, 1)) {\n            if (vgetq_lane_u64(mask, 0)) {\n                return vgetq_lane_u64(divisors, 0);\n            }\n            if (vgetq_lane_u64(mask, 1)) {\n                return vgetq_lane_u64(divisors, 1);\n            }\n        }\n    }\n    return 1;\n}\n```"}
{"task_id": "SimdBench_73_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    uint64x2_t n_vec = vdupq_n_u64(n);\n    uint64x2_t divisors = vdupq_n_u64(1);\n    uint64x2_t ones = vdupq_n_u64(1);\n    uint64x2_t increment = vdupq_n_u64(1);\n\n    for (uint64_t i = 2; i < n; i += 2) {\n        divisors = vaddq_u64(divisors, increment);\n        uint64x2_t remainder = vreinterpretq_u64_u32(vremq_u32(vreinterpretq_u32_u64(n_vec), vreinterpretq_u32_u64(divisors)));\n        uint64x2_t mask = vceqq_u64(remainder, vdupq_n_u64(0));\n\n        if (vgetq_lane_u64(mask, 0) || vgetq_lane_u64(mask, 1)) {\n            uint64_t div1 = vgetq_lane_u64(divisors, 0);\n            uint64_t div2 = vgetq_lane_u64(divisors, 1);\n            if (div1 < n && n % div1 == 0) return div1;\n            if (div2 < n && n % div2 == 0) return div2;\n        }\n    }\n\n    return 1;\n}\n```"}
{"task_id": "SimdBench_73_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    uint64x2_t n_vec = vdupq_n_u64(n);\n    uint64x2_t divisor_vec = vdupq_n_u64(n / 2);\n    uint64x2_t one_vec = vdupq_n_u64(1);\n    uint64x2_t zero_vec = vdupq_n_u64(0);\n\n    while (true) {\n        uint64x2_t remainder_vec = vsubq_u64(n_vec, vmulq_u64(divisor_vec, vdupq_n_u64(2)));\n        uint64x2_t mask_vec = vcgtq_u64(remainder_vec, zero_vec);\n\n        if (vgetq_lane_u64(mask_vec, 0) == 0 && vgetq_lane_u64(mask_vec, 1) == 0) {\n            break;\n        }\n\n        divisor_vec = vsubq_u64(divisor_vec, one_vec);\n    }\n\n    return vgetq_lane_u64(divisor_vec, 0);\n}\n```"}
{"task_id": "SimdBench_74_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n <= 1) return factors;\n\n    int32x4_t vn = vdupq_n_s32(n);\n    int32x4_t vtwo = vdupq_n_s32(2);\n    int32x4_t vthree = vdupq_n_s32(3);\n    int32x4_t vfive = vdupq_n_s32(5);\n    int32x4_t vseven = vdupq_n_s32(7);\n\n    uint32x4_t vmask = vcgtq_s32(vn, vtwo);\n    while (vgetq_lane_u32(vmask, 0) && vgetq_lane_u32(vmask, 1) && vgetq_lane_u32(vmask, 2) && vgetq_lane_u32(vmask, 3)) {\n        int32x4_t vrem = vn % vtwo;\n        vmask = vceqq_s32(vrem, vdupq_n_s32(0));\n        if (vgetq_lane_u32(vmask, 0) && vgetq_lane_u32(vmask, 1) && vgetq_lane_u32(vmask, 2) && vgetq_lane_u32(vmask, 3)) {\n            vn = vn / vtwo;\n            factors.push_back(2);\n        } else {\n            break;\n        }\n    }\n\n    vmask = vcgtq_s32(vn, vthree);\n    while (vgetq_lane_u32(vmask, 0) && vgetq_lane_u32(vmask, 1) && vgetq_lane_u32(vmask, 2) && vgetq_lane_u32(vmask, 3)) {\n        int32x4_t vrem = vn % vthree;\n        vmask = vceqq_s32(vrem, vdupq_n_s32(0));\n        if (vgetq_lane_u32(vmask, 0) && vgetq_lane_u32(vmask, 1) && vgetq_lane_u32(vmask, 2) && vgetq_lane_u32(vmask, 3)) {\n            vn = vn / vthree;\n            factors.push_back(3);\n        } else {\n            break;\n        }\n    }\n\n    vmask = vcgtq_s32(vn, vfive);\n    while (vgetq_lane_u32(vmask, 0) && vgetq_lane_u32(vmask, 1) && vgetq_lane_u32(vmask, 2) && vgetq_lane_u32(vmask, 3)) {\n        int32x4_t vrem = vn % vfive;\n        vmask = vceqq_s32(vrem, vdupq_n_s32(0));\n        if (vgetq_lane_u32(vmask, 0) && vgetq_lane_u32(vmask, 1) && vgetq_lane_u32(vmask, 2) && vgetq_lane_u32(vmask, 3)) {\n            vn = vn / vfive;\n            factors.push_back(5);\n        } else {\n            break;\n        }\n    }\n\n    vmask = vcgtq_s32(vn, vseven);\n    while (vgetq_lane_u32(vmask, 0) && vgetq_lane_u32(vmask, 1) && vgetq_lane_u32(vmask, 2) && vgetq_lane_u32(vmask, 3)) {\n        int32x4_t vrem = vn % vseven;\n        vmask = vceqq_s32(vrem, vdupq_n_s32(0));\n        if (vgetq_lane_u32(vmask, 0) && vgetq_lane_u32(vmask, 1) && vgetq_lane_u32(vmask, 2) && vgetq_lane_u32(vmask, 3)) {\n            vn = vn / vseven;\n            factors.push_back(7);\n        } else {\n            break;\n        }\n    }\n\n    int remainder = vgetq_lane_s32(vn, 0);\n    if (remainder > 1) {\n        factors.push_back(remainder);\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n <= 1) return factors;\n\n    int32x4_t vn = vdupq_n_s32(n);\n    int32x4_t vtwo = vdupq_n_s32(2);\n    int32x4_t vthree = vdupq_n_s32(3);\n    int32x4_t vfive = vdupq_n_s32(5);\n    int32x4_t vseven = vdupq_n_s32(7);\n\n    int32x4_t vmask = vdupq_n_s32(1);\n    uint32x4_t vzero = vdupq_n_u32(0);\n\n    while (vgetq_lane_s32(vn, 0) % 2 == 0) {\n        factors.push_back(2);\n        vn = vdivq_s32(vn, vtwo);\n    }\n\n    while (vgetq_lane_s32(vn, 0) % 3 == 0) {\n        factors.push_back(3);\n        vn = vdivq_s32(vn, vthree);\n    }\n\n    while (vgetq_lane_s32(vn, 0) % 5 == 0) {\n        factors.push_back(5);\n        vn = vdivq_n_s32(vn, 5);\n    }\n\n    while (vgetq_lane_s32(vn, 0) % 7 == 0) {\n        factors.push_back(7);\n        vn = vdivq_n_s32(vn, 7);\n    }\n\n    for (int i = 11; i <= std::sqrt(n); i += 2) {\n        int32x4_t vi = vdupq_n_s32(i);\n        while (vgetq_lane_s32(vn, 0) % i == 0) {\n            factors.push_back(i);\n            vn = vdivq_s32(vn, vi);\n        }\n    }\n\n    if (vgetq_lane_s32(vn, 0) > 1) {\n        factors.push_back(vgetq_lane_s32(vn, 0));\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n <= 1) return factors;\n\n    int32x4_t vn = vdupq_n_s32(n);\n    int32x4_t vtwo = vdupq_n_s32(2);\n    int32x4_t vthree = vdupq_n_s32(3);\n    int32x4_t vfive = vdupq_n_s32(5);\n    int32x4_t vseven = vdupq_n_s32(7);\n\n    uint32x4_t vmask = vcgtq_s32(vn, vtwo);\n    while (vgetq_lane_u32(vmask, 0) && vgetq_lane_u32(vmask, 1) && vgetq_lane_u32(vmask, 2) && vgetq_lane_u32(vmask, 3)) {\n        int32x4_t vrem = vn % vtwo;\n        vmask = vceqq_s32(vrem, vdupq_n_s32(0));\n        if (vgetq_lane_u32(vmask, 0) && vgetq_lane_u32(vmask, 1) && vgetq_lane_u32(vmask, 2) && vgetq_lane_u32(vmask, 3)) {\n            vn = vn / vtwo;\n            factors.push_back(2);\n        } else {\n            break;\n        }\n    }\n\n    vmask = vcgtq_s32(vn, vthree);\n    while (vgetq_lane_u32(vmask, 0) && vgetq_lane_u32(vmask, 1) && vgetq_lane_u32(vmask, 2) && vgetq_lane_u32(vmask, 3)) {\n        int32x4_t vrem = vn % vthree;\n        vmask = vceqq_s32(vrem, vdupq_n_s32(0));\n        if (vgetq_lane_u32(vmask, 0) && vgetq_lane_u32(vmask, 1) && vgetq_lane_u32(vmask, 2) && vgetq_lane_u32(vmask, 3)) {\n            vn = vn / vthree;\n            factors.push_back(3);\n        } else {\n            break;\n        }\n    }\n\n    vmask = vcgtq_s32(vn, vfive);\n    while (vgetq_lane_u32(vmask, 0) && vgetq_lane_u32(vmask, 1) && vgetq_lane_u32(vmask, 2) && vgetq_lane_u32(vmask, 3)) {\n        int32x4_t vrem = vn % vfive;\n        vmask = vceqq_s32(vrem, vdupq_n_s32(0));\n        if (vgetq_lane_u32(vmask, 0) && vgetq_lane_u32(vmask, 1) && vgetq_lane_u32(vmask, 2) && vgetq_lane_u32(vmask, 3)) {\n            vn = vn / vfive;\n            factors.push_back(5);\n        } else {\n            break;\n        }\n    }\n\n    vmask = vcgtq_s32(vn, vseven);\n    while (vgetq_lane_u32(vmask, 0) && vgetq_lane_u32(vmask, 1) && vgetq_lane_u32(vmask, 2) && vgetq_lane_u32(vmask, 3)) {\n        int32x4_t vrem = vn % vseven;\n        vmask = vceqq_s32(vrem, vdupq_n_s32(0));\n        if (vgetq_lane_u32(vmask, 0) && vgetq_lane_u32(vmask, 1) && vgetq_lane_u32(vmask, 2) && vgetq_lane_u32(vmask, 3)) {\n            vn = vn / vseven;\n            factors.push_back(7);\n        } else {\n            break;\n        }\n    }\n\n    int remainder = vgetq_lane_s32(vn, 0);\n    if (remainder > 1) {\n        for (int i = 7; i <= sqrt(remainder); i += 2) {\n            while (remainder % i == 0) {\n                factors.push_back(i);\n                remainder /= i;\n            }\n        }\n        if (remainder > 1) {\n            factors.push_back(remainder);\n        }\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n <= 1) return factors;\n\n    int32x4_t vn = vdupq_n_s32(n);\n    int32x4_t vtwo = vdupq_n_s32(2);\n    int32x4_t vthree = vdupq_n_s32(3);\n    int32x4_t vfive = vdupq_n_s32(5);\n    int32x4_t vseven = vdupq_n_s32(7);\n\n    int32x4_t vfactor = vtwo;\n    int32x4_t vrem = vn;\n\n    while (true) {\n        int32x4_t vdiv = vdivq_s32(vrem, vfactor);\n        int32x4_t vmod = vmulq_s32(vdiv, vfactor);\n        vrem = vsubq_s32(vrem, vmod);\n\n        int32_t rem[4];\n        vst1q_s32(rem, vrem);\n\n        if (rem[0] == 0 && rem[1] == 0 && rem[2] == 0 && rem[3] == 0) {\n            int32_t factor[4];\n            vst1q_s32(factor, vfactor);\n            for (int i = 0; i < 4; ++i) {\n                if (factor[i] != 1) {\n                    factors.push_back(factor[i]);\n                }\n            }\n            vfactor = vmulq_s32(vfactor, vfactor);\n        } else {\n            vfactor = vaddq_s32(vfactor, vtwo);\n            if (vfactor[0] > vseven[0]) {\n                break;\n            }\n        }\n    }\n\n    if (n > 1) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n <= 1) return factors;\n\n    int32x4_t vn = vdupq_n_s32(n);\n    int32x4_t vtwo = vdupq_n_s32(2);\n    int32x4_t vthree = vdupq_n_s32(3);\n    int32x4_t vfive = vdupq_n_s32(5);\n    int32x4_t vseven = vdupq_n_s32(7);\n\n    uint32x4_t vmask = vcgtq_s32(vn, vdupq_n_s32(1));\n    while (vgetq_lane_u32(vmask, 0) && vgetq_lane_u32(vmask, 1) && vgetq_lane_u32(vmask, 2) && vgetq_lane_u32(vmask, 3)) {\n        if (vgetq_lane_u32(vandq_u32(vmask, vceqq_s32(vmodq_s32(vn, vtwo), vdupq_n_s32(0))), 0)) {\n            factors.push_back(2);\n            vn = vdivq_s32(vn, vtwo);\n        } else if (vgetq_lane_u32(vandq_u32(vmask, vceqq_s32(vmodq_s32(vn, vthree), vdupq_n_s32(0))), 0)) {\n            factors.push_back(3);\n            vn = vdivq_s32(vn, vthree);\n        } else if (vgetq_lane_u32(vandq_u32(vmask, vceqq_s32(vmodq_s32(vn, vfive), vdupq_n_s32(0))), 0)) {\n            factors.push_back(5);\n            vn = vdivq_s32(vn, vfive);\n        } else if (vgetq_lane_u32(vandq_u32(vmask, vceqq_s32(vmodq_s32(vn, vseven), vdupq_n_s32(0))), 0)) {\n            factors.push_back(7);\n            vn = vdivq_s32(vn, vseven);\n        } else {\n            break;\n        }\n        vmask = vcgtq_s32(vn, vdupq_n_s32(1));\n    }\n\n    int remainder = vgetq_lane_s32(vn, 0);\n    if (remainder > 1) {\n        for (int i = 11; i <= std::sqrt(remainder); i += 2) {\n            while (remainder % i == 0) {\n                factors.push_back(i);\n                remainder /= i;\n            }\n        }\n        if (remainder > 1) {\n            factors.push_back(remainder);\n        }\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_75_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    size_t size = l.size();\n    size_t i = 0;\n\n    for (; i <= size - 4; i += 4) {\n        float32x4_t v = vld1q_f32(&l[i]);\n        uint32x4_t mask = vcgtq_f32(v, vdupq_n_f32(0.0f));\n        float32x4_t pos = vbslq_f32(mask, v, vdupq_n_f32(0.0f));\n\n        float temp[4];\n        vst1q_f32(temp, pos);\n\n        for (int j = 0; j < 4; ++j) {\n            if (temp[j] > 0.0f) {\n                result.push_back(temp[j]);\n            }\n        }\n    }\n\n    for (; i < size; ++i) {\n        if (l[i] > 0.0f) {\n            result.push_back(l[i]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    size_t size = l.size();\n    size_t i = 0;\n\n    for (; i <= size - 4; i += 4) {\n        float32x4_t v = vld1q_f32(&l[i]);\n        uint32x4_t mask = vcgtq_f32(v, vdupq_n_f32(0.0f));\n        float32x4_t positive = vbslq_f32(mask, v, vdupq_n_f32(0.0f));\n\n        float temp[4];\n        vst1q_f32(temp, positive);\n\n        for (int j = 0; j < 4; ++j) {\n            if (temp[j] > 0.0f) {\n                result.push_back(temp[j]);\n            }\n        }\n    }\n\n    for (; i < size; ++i) {\n        if (l[i] > 0.0f) {\n            result.push_back(l[i]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    size_t size = l.size();\n    float32x4_t zero = vdupq_n_f32(0.0f);\n\n    for (size_t i = 0; i < size; i += 4) {\n        float32x4_t chunk = vld1q_f32(&l[i]);\n        uint32x4_t mask = vcgtq_f32(chunk, zero);\n        float32x4_t positive = vbslq_f32(mask, chunk, zero);\n\n        float temp[4];\n        vst1q_f32(temp, positive);\n\n        for (int j = 0; j < 4; ++j) {\n            if (temp[j] > 0.0f) {\n                result.push_back(temp[j]);\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    size_t size = l.size();\n    size_t i = 0;\n\n    for (; i <= size - 4; i += 4) {\n        float32x4_t v = vld1q_f32(&l[i]);\n        uint32x4_t mask = vcgtq_f32(v, vdupq_n_f32(0.0f));\n        float32x4_t positive = vbslq_f32(mask, v, vdupq_n_f32(0.0f));\n\n        float temp[4];\n        vst1q_f32(temp, positive);\n\n        for (int j = 0; j < 4; ++j) {\n            if (temp[j] > 0.0f) {\n                result.push_back(temp[j]);\n            }\n        }\n    }\n\n    for (; i < size; ++i) {\n        if (l[i] > 0.0f) {\n            result.push_back(l[i]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    size_t size = l.size();\n    float32x4_t zero = vdupq_n_f32(0.0f);\n\n    for (size_t i = 0; i < size; i += 4) {\n        float32x4_t chunk = vld1q_f32(&l[i]);\n        uint32x4_t mask = vcgtq_f32(chunk, zero);\n        float32x4_t positiveChunk = vbslq_f32(mask, chunk, zero);\n\n        float temp[4];\n        vst1q_f32(temp, positiveChunk);\n\n        for (int j = 0; j < 4; ++j) {\n            if (temp[j] > 0.0f) {\n                result.push_back(temp[j]);\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_76_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n#include <math.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t sqrt_n = (int64_t)sqrt(n);\n    int64_t stride = 8;\n    int64_t i;\n\n    for (i = 5; i <= sqrt_n; i += stride) {\n        int32x4_t v = {i, i + 2, i + 4, i + 6};\n        int32x4_t mod_v = {n % i, n % (i + 2), n % (i + 4), n % (i + 6)};\n\n        uint32x4_t zero_v = {0, 0, 0, 0};\n        uint32x4_t cmp_v = vceqq_s32(mod_v, zero_v);\n\n        if (vaddvq_u32(cmp_v) > 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n#include <math.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t sqrt_n = (int64_t)sqrt(n);\n    int64_t i = 5;\n\n    uint32x4_t v_i = {5, 7, 11, 13};\n    uint32x4_t v_n = vdupq_n_u32(n);\n    uint32x4_t v_one = vdupq_n_u32(1);\n\n    while (i <= sqrt_n) {\n        uint32x4_t v_mod = vmodq_u32(v_n, v_i);\n        uint32x4_t v_cmp = vceqq_u32(v_mod, vdupq_n_u32(0));\n\n        if (vaddvq_u32(v_cmp) > 0) {\n            return false;\n        }\n\n        v_i = vaddq_u32(v_i, vdupq_n_u32(6));\n        i += 6;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n#include <math.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t sqrt_n = (int64_t)sqrt(n);\n    int64_t i = 5;\n\n    int64x2_t vn = vdupq_n_s64(n);\n    int64x2_t vi = vdupq_n_s64(i);\n    int64x2_t vinc = {6, 6};\n\n    while (i <= sqrt_n) {\n        int64x2_t vmod1 = vn % vi;\n        int64x2_t vmod2 = vn % (vi + vinc);\n\n        uint64x2_t vcmp1 = vceqq_s64(vmod1, vdupq_n_s64(0));\n        uint64x2_t vcmp2 = vceqq_s64(vmod2, vdupq_n_s64(0));\n\n        if (vgetq_lane_u64(vcmp1, 0) || vgetq_lane_u64(vcmp1, 1) ||\n            vgetq_lane_u64(vcmp2, 0) || vgetq_lane_u64(vcmp2, 1)) {\n            return false;\n        }\n\n        vi = vaddq_s64(vi, vinc);\n        i += 6;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n#include <math.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t sqrt_n = (int64_t)sqrt(n);\n    int64_t i = 5;\n\n    uint32x4_t vn = vdupq_n_u32(n);\n    uint32x4_t vi = vdupq_n_u32(i);\n    uint32x4_t vone = vdupq_n_u32(1);\n    uint32x4_t vtwo = vdupq_n_u32(2);\n    uint32x4_t vfour = vdupq_n_u32(4);\n\n    for (; i <= sqrt_n; i += 4) {\n        uint32x4_t vmod1 = vmodq_u32(vn, vi);\n        uint32x4_t vmod2 = vmodq_u32(vn, vaddq_u32(vi, vtwo));\n        vi = vaddq_u32(vi, vfour);\n\n        uint32x4_t vcmp1 = vceqq_u32(vmod1, vdupq_n_u32(0));\n        uint32x4_t vcmp2 = vceqq_u32(vmod2, vdupq_n_u32(0));\n\n        if (vmaxvq_u32(vcmp1) || vmaxvq_u32(vcmp2)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n#include <math.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t sqrt_n = (int64_t)sqrt(n);\n    int64_t i = 5;\n\n    uint32x4_t vn = vdupq_n_u32(n);\n    uint32x4_t vi = vdupq_n_u32(i);\n    uint32x4_t vone = vdupq_n_u32(1);\n    uint32x4_t vtwo = vdupq_n_u32(2);\n    uint32x4_t vfour = vdupq_n_u32(4);\n\n    for (; i <= sqrt_n; i += 4) {\n        uint32x4_t vmod1 = vmodq_u32(vn, vi);\n        uint32x4_t vmod2 = vmodq_u32(vn, vaddq_u32(vi, vtwo));\n        vi = vaddq_u32(vi, vfour);\n\n        uint32x4_t vcmp1 = vceqq_u32(vmod1, vdupq_n_u32(0));\n        uint32x4_t vcmp2 = vceqq_u32(vmod2, vdupq_n_u32(0));\n\n        if (vmaxvq_u32(vcmp1) || vmaxvq_u32(vcmp2)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_77_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n#include <cstring>\n#include <cctype>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s) {\n    size_t len = s.length();\n    std::string result(len, ' ');\n    bool hasLetter = false;\n\n    for (size_t i = 0; i < len; i++) {\n        if (std::isalpha(s[i])) {\n            hasLetter = true;\n            break;\n        }\n    }\n\n    if (!hasLetter) {\n        std::reverse_copy(s.begin(), s.end(), result.begin());\n        return result;\n    }\n\n    size_t i = 0;\n    for (; i <= len - 16; i += 16) {\n        uint8x16_t chunk = vld1q_u8(&s[i]);\n        uint8x16_t isLower = vandq_u8(chunk, vdupq_n_u8(' '));\n        uint8x16_t isUpper = vandq_u8(chunk, vdupq_n_u8(' '));\n        uint8x16_t isAlpha = vorrq_u8(isLower, isUpper);\n        uint8x16_t toggled = veorq_u8(chunk, vdupq_n_u8(32));\n        uint8x16_t resultChunk = vbslq_u8(isAlpha, toggled, chunk);\n        vst1q_u8(&result[i], resultChunk);\n    }\n\n    for (; i < len; i++) {\n        if (std::isalpha(s[i])) {\n            result[i] = std::isupper(s[i]) ? std::tolower(s[i]) : std::toupper(s[i]);\n        } else {\n            result[i] = s[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n#include <cstring>\n#include <algorithm>\n\nstd::string solve_simd(const std::string &s) {\n    size_t len = s.length();\n    std::string result(len, ' ');\n    bool hasLetter = false;\n\n    for (size_t i = 0; i < len; i += 16) {\n        size_t blockSize = std::min(len - i, static_cast<size_t>(16));\n        uint8x16_t chunk = vld1q_u8(&s[i]);\n        uint8x16_t mask_lower = vdupq_n_u8('a' - 'A');\n        uint8x16_t mask_upper = vdupq_n_u8('A' - 'a');\n\n        uint8x16_t is_lower = vandq_u8(chunk, vdupq_n_u8(0x20));\n        uint8x16_t is_upper = vandq_u8(chunk, vdupq_n_u8(0xDF));\n\n        uint8x16_t lower_to_upper = vqsubq_u8(chunk, is_lower);\n        uint8x16_t upper_to_lower = vqaddq_u8(chunk, is_upper);\n\n        uint8x16_t result_chunk = vorrq_u8(vandq_u8(chunk, vdupq_n_u8(~0x60)), vandq_u8(lower_to_upper, vdupq_n_u8(0x60)));\n        result_chunk = vorrq_u8(result_chunk, vandq_u8(upper_to_lower, vdupq_n_u8(0x60)));\n\n        vst1q_u8(&result[i], result_chunk);\n\n        if (!hasLetter) {\n            hasLetter = std::any_of(result.begin() + i, result.begin() + i + blockSize, [](char c) {\n                return std::isalpha(c);\n            });\n        }\n    }\n\n    if (!hasLetter) {\n        std::reverse(result.begin(), result.end());\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n#include <cstring>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s) {\n    size_t len = s.length();\n    std::string result(len, ' ');\n    bool hasLetter = false;\n\n    for (size_t i = 0; i < len; i += 16) {\n        size_t blockSize = std::min(len - i, static_cast<size_t>(16));\n        uint8x16_t chunk = vld1q_u8(&s[i]);\n        uint8x16_t mask = vdupq_n_u8('a' - 'A');\n\n        uint8x16_t isLower = vandq_u8(vsubq_u8(chunk, vdupq_n_u8('a')), vdupq_n_u8(0x20));\n        uint8x16_t isUpper = vandq_u8(vsubq_u8(chunk, vdupq_n_u8('A')), vdupq_n_u8(0x20));\n        uint8x16_t isLetter = vorrq_u8(isLower, isUpper);\n\n        hasLetter |= vmaxvq_u8(isLetter) != 0;\n\n        uint8x16_t toggled = veorq_u8(chunk, isLetter);\n        vst1q_u8(&result[i], toggled);\n    }\n\n    if (!hasLetter) {\n        std::reverse(result.begin(), result.end());\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n#include <cstring>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s) {\n    size_t len = s.length();\n    std::string result(len, ' ');\n\n    bool hasLetter = false;\n    for (size_t i = 0; i < len; ++i) {\n        if (isalpha(s[i])) {\n            hasLetter = true;\n            break;\n        }\n    }\n\n    if (!hasLetter) {\n        std::reverse_copy(s.begin(), s.end(), result.begin());\n        return result;\n    }\n\n    for (size_t i = 0; i < len; i += 16) {\n        size_t blockSize = std::min(len - i, size_t(16));\n        uint8x16_t chunk = vld1q_u8(&s[i]);\n\n        uint8x16_t isLower = vandq_u8(chunk, vdupq_n_u8('a' - 'A'));\n        uint8x16_t isUpper = vandq_u8(chunk, vdupq_n_u8('A' - 'a'));\n        uint8x16_t isAlpha = vorrq_u8(isLower, isUpper);\n\n        uint8x16_t toggled = veorq_u8(chunk, vdupq_n_u8('a' - 'A'));\n        uint8x16_t resultChunk = vbslq_u8(isAlpha, toggled, chunk);\n\n        vst1q_u8(&result[i], resultChunk);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n#include <cstring>\n#include <algorithm>\n\nstd::string solve_simd(const std::string &s) {\n    size_t len = s.length();\n    std::string result(len, ' ');\n\n    bool hasLetter = false;\n    for (size_t i = 0; i < len; ++i) {\n        if (isalpha(s[i])) {\n            hasLetter = true;\n            break;\n        }\n    }\n\n    if (!hasLetter) {\n        std::reverse_copy(s.begin(), s.end(), result.begin());\n        return result;\n    }\n\n    for (size_t i = 0; i < len; i += 16) {\n        size_t blockSize = std::min(len - i, static_cast<size_t>(16));\n        uint8x16_t chunk = vld1q_u8(&s[i]);\n\n        uint8x16_t isLower = vandq_u8(chunk, vdupq_n_u8(' '));\n        uint8x16_t isUpper = vandq_u8(chunk, vdupq_n_u8('_'));\n\n        uint8x16_t toUpper = vandq_u8(chunk, vdupq_n_u8(~(' ')));\n        uint8x16_t toLower = vorrq_u8(chunk, vdupq_n_u8(' '));\n\n        uint8x16_t resultChunk = vorrq_u8(vandq_u8(isLower, toUpper), vandq_u8(isUpper, toLower));\n\n        vst1q_u8(&result[i], resultChunk);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    std::vector<int> sorted_third;\n    for (size_t i = 2; i < l.size(); i += 3) {\n        sorted_third.push_back(l[i]);\n    }\n\n    std::sort(sorted_third.begin(), sorted_third.end());\n\n    size_t sorted_index = 0;\n    for (size_t i = 2; i < l.size(); i += 3) {\n        l[i] = sorted_third[sorted_index++];\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_78_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    std::vector<int> divisible_by_three;\n\n    for (size_t i = 2; i < l.size(); i += 3) {\n        divisible_by_three.push_back(l[i]);\n    }\n\n    std::sort(divisible_by_three.begin(), divisible_by_three.end());\n\n    size_t index = 0;\n    for (size_t i = 2; i < l.size(); i += 3) {\n        l[i] = divisible_by_three[index++];\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_78_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    std::vector<int> sorted_third_elements;\n\n    for (size_t i = 2; i < l.size(); i += 3) {\n        sorted_third_elements.push_back(l[i]);\n    }\n\n    std::sort(sorted_third_elements.begin(), sorted_third_elements.end());\n\n    size_t sorted_index = 0;\n    for (size_t i = 2; i < l.size(); i += 3) {\n        l[i] = sorted_third_elements[sorted_index++];\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_78_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    std::vector<int> sorted_third;\n    for (size_t i = 2; i < l.size(); i += 3) {\n        sorted_third.push_back(l[i]);\n    }\n\n    std::sort(sorted_third.begin(), sorted_third.end());\n\n    size_t sorted_index = 0;\n    for (size_t i = 2; i < l.size(); i += 3) {\n        l[i] = sorted_third[sorted_index++];\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_78_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    std::vector<int> sorted_third;\n    for (size_t i = 2; i < l.size(); i += 3) {\n        sorted_third.push_back(l[i]);\n    }\n\n    std::sort(sorted_third.begin(), sorted_third.end());\n\n    size_t sorted_index = 0;\n    for (size_t i = 2; i < l.size(); i += 3) {\n        l[i] = sorted_third[sorted_index++];\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_79_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nfloat max_element_simd(std::vector<float> l) {\n    if (l.empty()) return NAN;\n\n    float32x4_t vmax = vdupq_n_f32(l[0]);\n    size_t i;\n    for (i = 0; i <= l.size() - 4; i += 4) {\n        float32x4_t v = vld1q_f32(&l[i]);\n        vmax = vmaxq_f32(vmax, v);\n    }\n\n    float max_val = std::max({vgetq_lane_f32(vmax, 0), vgetq_lane_f32(vmax, 1), vgetq_lane_f32(vmax, 2), vgetq_lane_f32(vmax, 3)});\n\n    for (; i < l.size(); ++i) {\n        max_val = std::max(max_val, l[i]);\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nfloat max_element_simd(std::vector<float> l) {\n    if (l.empty()) {\n        return NAN;\n    }\n\n    float32x4_t max_vec = vdupq_n_f32(l[0]);\n    size_t i;\n    for (i = 0; i <= l.size() - 4; i += 4) {\n        float32x4_t vec = vld1q_f32(&l[i]);\n        max_vec = vmaxq_f32(max_vec, vec);\n    }\n\n    float max_val = vmaxvq_f32(max_vec);\n\n    for (; i < l.size(); ++i) {\n        max_val = std::max(max_val, l[i]);\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nfloat max_element_simd(std::vector<float> l) {\n    if (l.empty()) return NAN;\n\n    float32x4_t vmax = vdupq_n_f32(l[0]);\n    size_t i;\n    for (i = 0; i <= l.size() - 4; i += 4) {\n        float32x4_t v = vld1q_f32(&l[i]);\n        vmax = vmaxq_f32(vmax, v);\n    }\n\n    float max_val = std::max({vgetq_lane_f32(vmax, 0), vgetq_lane_f32(vmax, 1), vgetq_lane_f32(vmax, 2), vgetq_lane_f32(vmax, 3)});\n\n    for (; i < l.size(); ++i) {\n        max_val = std::max(max_val, l[i]);\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nfloat max_element_simd(std::vector<float> l) {\n    if (l.empty()) {\n        return NAN;\n    }\n\n    float32x4_t vmax = vdupq_n_f32(std::numeric_limits<float>::lowest());\n    size_t i;\n\n    for (i = 0; i <= l.size() - 4; i += 4) {\n        float32x4_t v = vld1q_f32(&l[i]);\n        vmax = vmaxq_f32(vmax, v);\n    }\n\n    float max_val = std::max({vgetq_lane_f32(vmax, 0), vgetq_lane_f32(vmax, 1), vgetq_lane_f32(vmax, 2), vgetq_lane_f32(vmax, 3)});\n\n    for (; i < l.size(); ++i) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nfloat max_element_simd(std::vector<float> l) {\n    if (l.empty()) {\n        return NAN;\n    }\n\n    float32x4_t vmax = vdupq_n_f32(l[0]);\n    size_t i;\n    for (i = 0; i <= l.size() - 4; i += 4) {\n        float32x4_t v = vld1q_f32(&l[i]);\n        vmax = vmaxq_f32(vmax, v);\n    }\n\n    float max_val = vgetq_lane_f32(vmax, 0);\n    max_val = std::max(max_val, vgetq_lane_f32(vmax, 1));\n    max_val = std::max(max_val, vgetq_lane_f32(vmax, 2));\n    max_val = std::max(max_val, vgetq_lane_f32(vmax, 3));\n\n    for (; i < l.size(); ++i) {\n        max_val = std::max(max_val, l[i]);\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_80_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    int32x4_t v11 = vdupq_n_s32(11);\n    int32x4_t v13 = vdupq_n_s32(13);\n    int32x4_t v7 = vdupq_n_s32(7);\n    int32x4_t v0 = vdupq_n_s32(0);\n\n    for (int i = 0; i < n; i += 4) {\n        int32x4_t v = vld1q_s32(&i);\n        int32x4_t vmod11 = vmodq_s32(v, v11);\n        int32x4_t vmod13 = vmodq_s32(v, v13);\n        uint32x4_t vmask11 = vceqq_s32(vmod11, v0);\n        uint32x4_t vmask13 = vceqq_s32(vmod13, v0);\n        uint32x4_t vmask = vorrq_u32(vmask11, vmask13);\n\n        int mask = vaddvq_u32(vmask);\n        while (mask) {\n            int index = __builtin_ctz(mask);\n            int num = i + index;\n            while (num > 0) {\n                if (num % 10 == 7) {\n                    count++;\n                }\n                num /= 10;\n            }\n            mask &= ~(1 << index);\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdio.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    int32x4_t v11 = vdupq_n_s32(11);\n    int32x4_t v13 = vdupq_n_s32(13);\n    int32x4_t v7 = vdupq_n_s32(7);\n    int32x4_t v0 = vdupq_n_s32(0);\n    int32x4_t v1 = vdupq_n_s32(1);\n\n    for (int i = 0; i < n; i += 4) {\n        int32x4_t vn = vld1q_s32(&i);\n        int32x4_t vmod11 = vmodq_s32(vn, v11);\n        int32x4_t vmod13 = vmodq_s32(vn, v13);\n        uint32x4_t vmask11 = vceqq_s32(vmod11, v0);\n        uint32x4_t vmask13 = vceqq_s32(vmod13, v0);\n        uint32x4_t vmask = vorrq_u32(vmask11, vmask13);\n\n        int32x4_t vdiv = vdivq_s32(vn, v10);\n        int32x4_t vrem = vmodq_s32(vn, v10);\n        uint32x4_t vmask7 = vceqq_s32(vrem, v7);\n        vmask = vandq_u32(vmask, vmask7);\n\n        int mask = vaddvq_s32(vmask);\n        count += __builtin_popcount(mask);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    int32x4_t v11 = vdupq_n_s32(11);\n    int32x4_t v13 = vdupq_n_s32(13);\n    int32x4_t v7 = vdupq_n_s32(7);\n    int32x4_t v0 = vdupq_n_s32(0);\n\n    for (int i = 0; i < n; i += 4) {\n        int32x4_t v = vld1q_s32(&i);\n        int32x4_t vmod11 = vmodq_s32(v, v11);\n        int32x4_t vmod13 = vmodq_s32(v, v13);\n        uint32x4_t vmask11 = vceqq_s32(vmod11, v0);\n        uint32x4_t vmask13 = vceqq_s32(vmod13, v0);\n        uint32x4_t vmask = vorrq_u32(vmask11, vmask13);\n\n        int32x4_t vdiv = vdivq_s32(v, v7);\n        int32x4_t vrem = vmlsq_s32(v, vdiv, v7);\n        uint32x4_t vmask7 = vceqq_s32(vrem, v0);\n\n        vmask = vandq_u32(vmask, vmask7);\n\n        uint32x4_t vcount = vaddq_u32(vdupq_n_u32(0), vmask);\n        count += vaddvq_u32(vcount);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdio.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    int32x4_t v11 = vdupq_n_s32(11);\n    int32x4_t v13 = vdupq_n_s32(13);\n    int32x4_t v7 = vdupq_n_s32(7);\n    int32x4_t v0 = vdupq_n_s32(0);\n\n    for (int i = 0; i < n; i += 4) {\n        int32x4_t v = vld1q_s32(&i);\n        int32x4_t vmod11 = vmodq_s32(v, v11);\n        int32x4_t vmod13 = vmodq_s32(v, v13);\n        uint32x4_t vmask11 = vceqq_s32(vmod11, v0);\n        uint32x4_t vmask13 = vceqq_s32(vmod13, v0);\n        uint32x4_t vmask = vorrq_u32(vmask11, vmask13);\n\n        int32x4_t vdiv = vdivq_s32(v, v7);\n        int32x4_t vrem = vmlsq_s32(v, vdiv, v7);\n        uint32x4_t vmask7 = vceqq_s32(vrem, v0);\n\n        vmask = vandq_u32(vmask, vmask7);\n\n        int mask = vaddvq_s32(vmovn_s64(vpaddlq_s32(vreinterpretq_s32_u32(vmask))));\n        count += __builtin_popcount(mask);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdio.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    int32x4_t v11 = vdupq_n_s32(11);\n    int32x4_t v13 = vdupq_n_s32(13);\n    int32x4_t v7 = vdupq_n_s32(7);\n    int32x4_t v0 = vdupq_n_s32(0);\n    int32x4_t v1 = vdupq_n_s32(1);\n\n    for (int i = 0; i < n; i += 4) {\n        int32x4_t vn = vld1q_s32(&i);\n        int32x4_t vmod11 = vmodq_s32(vn, v11);\n        int32x4_t vmod13 = vmodq_s32(vn, v13);\n        uint32x4_t vmask11 = vceqq_s32(vmod11, v0);\n        uint32x4_t vmask13 = vceqq_s32(vmod13, v0);\n        uint32x4_t vmask = vorrq_u32(vmask11, vmask13);\n\n        int mask[4];\n        vst1q_s32(mask, vreinterpretq_s32_u32(vmask));\n\n        for (int j = 0; j < 4; j++) {\n            if (mask[j]) {\n                int num = i + j;\n                while (num > 0) {\n                    if (num % 10 == 7) {\n                        count++;\n                    }\n                    num /= 10;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_81_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    std::vector<float> even_elements;\n\n    // Extract even indexed elements\n    for (size_t i = 0; i < n; i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    // Sort even indexed elements using std::sort\n    std::sort(even_elements.begin(), even_elements.end());\n\n    // Place sorted even indexed elements back into the original vector\n    size_t even_index = 0;\n    for (size_t i = 0; i < n; i += 2) {\n        l[i] = even_elements[even_index++];\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_81_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    std::vector<float> even_elements;\n\n    // Extract even index elements\n    for (size_t i = 0; i < n; i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    // Sort even index elements using std::sort\n    std::sort(even_elements.begin(), even_elements.end());\n\n    // Place sorted even index elements back into the original vector\n    size_t even_index = 0;\n    for (size_t i = 0; i < n; i += 2) {\n        l[i] = even_elements[even_index++];\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_81_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    std::vector<float> even_indices;\n\n    for (size_t i = 0; i < n; i += 2) {\n        even_indices.push_back(l[i]);\n    }\n\n    std::sort(even_indices.begin(), even_indices.end());\n\n    size_t even_index = 0;\n    for (size_t i = 0; i < n; i += 2) {\n        l[i] = even_indices[even_index++];\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_81_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    std::vector<float> even_elements;\n\n    // Extract even index elements\n    for (size_t i = 0; i < n; i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    // Sort even index elements using std::sort\n    std::sort(even_elements.begin(), even_elements.end());\n\n    // Place sorted even index elements back into the original vector\n    size_t even_index = 0;\n    for (size_t i = 0; i < n; i += 2) {\n        l[i] = even_elements[even_index++];\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_81_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    std::vector<float> even_indices;\n\n    for (size_t i = 0; i < n; i += 2) {\n        even_indices.push_back(l[i]);\n    }\n\n    std::sort(even_indices.begin(), even_indices.end());\n\n    size_t even_index = 0;\n    for (size_t i = 0; i < n; i += 2) {\n        l[i] = even_indices[even_index++];\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_82_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    int32x4_t zero = vdupq_n_s32(0);\n\n    for (int i = 0; i < n - 2; i++) {\n        int32x4_t vi = vdupq_n_s32(l[i]);\n\n        for (int j = i + 1; j < n - 1; j++) {\n            int32x4_t vj = vdupq_n_s32(l[j]);\n            int32x4_t vij = vaddq_s32(vi, vj);\n\n            for (int k = j + 1; k < n; k++) {\n                int32x4_t vk = vld1q_dup_s32(&l[k]);\n                int32x4_t vijk = vaddq_s32(vij, vk);\n\n                uint32x4_t mask = vceqq_s32(vijk, zero);\n                if (vgetq_lane_u32(mask, 0) & vgetq_lane_u32(mask, 1) & vgetq_lane_u32(mask, 2) & vgetq_lane_u32(mask, 3)) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    for (int i = 0; i < n - 2; i++) {\n        int32x4_t vi = vdupq_n_s32(l[i]);\n        for (int j = i + 1; j < n - 1; j++) {\n            int32x4_t vj = vdupq_n_s32(l[j]);\n            int32x4_t vij = vaddq_s32(vi, vj);\n            for (int k = j + 1; k < n; k++) {\n                int32x4_t vk = vdupq_n_s32(l[k]);\n                int32x4_t vijk = vaddq_s32(vij, vk);\n                uint32x4_t vcmp = vceqq_s32(vijk, vdupq_n_s32(0));\n                if (vgetq_lane_u32(vcmp, 0) && vgetq_lane_u32(vcmp, 1) && vgetq_lane_u32(vcmp, 2) && vgetq_lane_u32(vcmp, 3)) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    int32x4_t v0, v1, v2;\n    for (int i = 0; i < n - 2; i += 4) {\n        v0 = vld1q_s32(&l[i]);\n        for (int j = i + 1; j < n - 1; j += 4) {\n            v1 = vld1q_s32(&l[j]);\n            for (int k = j + 1; k < n; k += 4) {\n                v2 = vld1q_s32(&l[k]);\n                int32x4_t sum = vaddq_s32(v0, vaddq_s32(v1, v2));\n                uint32x4_t zero = vceqq_s32(sum, vdupq_n_s32(0));\n                if (vgetq_lane_u32(zero, 0) || vgetq_lane_u32(zero, 1) || vgetq_lane_u32(zero, 2) || vgetq_lane_u32(zero, 3)) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    int32x4_t zero = vdupq_n_s32(0);\n\n    for (int i = 0; i < n - 2; i++) {\n        int32x4_t vi = vdupq_n_s32(l[i]);\n\n        for (int j = i + 1; j < n - 1; j++) {\n            int32x4_t vj = vdupq_n_s32(l[j]);\n            int32x4_t vij = vaddq_s32(vi, vj);\n\n            for (int k = j + 1; k < n; k++) {\n                int32x4_t vk = vld1q_dup_s32(&l[k]);\n                int32x4_t vijk = vaddq_s32(vij, vk);\n\n                uint32x4_t mask = vceqq_s32(vijk, zero);\n                if (vgetq_lane_u32(mask, 0) & vgetq_lane_u32(mask, 1) & vgetq_lane_u32(mask, 2) & vgetq_lane_u32(mask, 3)) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    for (int i = 0; i < n - 2; i++) {\n        int32x4_t vi = vdupq_n_s32(l[i]);\n\n        for (int j = i + 1; j < n - 1; j++) {\n            int32x4_t vj = vdupq_n_s32(l[j]);\n            int32x4_t vij = vaddq_s32(vi, vj);\n\n            for (int k = j + 1; k < n; k++) {\n                int32x4_t vk = vdupq_n_s32(l[k]);\n                int32x4_t vijk = vaddq_s32(vij, vk);\n                uint32x4_t vzero = vceqq_s32(vijk, vdupq_n_s32(0));\n\n                if (vgetq_lane_u32(vzero, 0) && vgetq_lane_u32(vzero, 1) && vgetq_lane_u32(vzero, 2) && vgetq_lane_u32(vzero, 3)) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_83_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    std::vector<int> result(l.size());\n    int32x4_t v_increment = vdupq_n_s32(1);\n\n    for (size_t i = 0; i < l.size(); i += 4) {\n        int32x4_t v = vld1q_s32(&l[i]);\n        v = vaddq_s32(v, v_increment);\n        vst1q_s32(&result[i], v);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    std::vector<int> result(l.size());\n    int32x4_t v_increment = vdupq_n_s32(1);\n\n    for (size_t i = 0; i < l.size(); i += 4) {\n        int32x4_t v = vld1q_s32(&l[i]);\n        v = vaddq_s32(v, v_increment);\n        vst1q_s32(&result[i], v);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    std::vector<int> result(l.size());\n    int32x4_t v_increment = vdupq_n_s32(1);\n\n    for (size_t i = 0; i < l.size(); i += 4) {\n        int32x4_t v = vld1q_s32(&l[i]);\n        v = vaddq_s32(v, v_increment);\n        vst1q_s32(&result[i], v);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    std::vector<int> result(l.size());\n    int32x4_t v_increment = vdupq_n_s32(1);\n\n    for (size_t i = 0; i < l.size(); i += 4) {\n        int32x4_t v = vld1q_s32(&l[i]);\n        v = vaddq_s32(v, v_increment);\n        vst1q_s32(&result[i], v);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    std::vector<int> result(l.size());\n    int32x4_t v_increment = vdupq_n_s32(1);\n\n    for (size_t i = 0; i < l.size(); i += 4) {\n        int32x4_t v = vld1q_s32(&l[i]);\n        v = vaddq_s32(v, v_increment);\n        vst1q_s32(&result[i], v);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_84_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 2) return false;\n\n    int32x4_t zero = vdupq_n_s32(0);\n    int32x4_t v1, v2;\n\n    for (int i = 0; i < n - 3; i += 4) {\n        v1 = vld1q_s32(&l[i]);\n        for (int j = i + 4; j < n; j += 4) {\n            v2 = vld1q_s32(&l[j]);\n            int32x4_t sum = vaddq_s32(v1, v2);\n            uint32x4_t mask = vceqq_s32(sum, zero);\n            if (vmaxvq_u32(mask) > 0) return true;\n        }\n        for (int j = i + 4; j < n; j++) {\n            int32x4_t v2 = vdupq_n_s32(l[j]);\n            int32x4_t sum = vaddq_s32(v1, v2);\n            uint32x4_t mask = vceqq_s32(sum, zero);\n            if (vmaxvq_u32(mask) > 0) return true;\n        }\n    }\n\n    for (int i = (n & ~3); i < n - 1; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (l[i] + l[j] == 0) return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 2) return false;\n\n    int32x4_t zero = vdupq_n_s32(0);\n    int32x4_t v1, v2;\n\n    for (int i = 0; i < n - 3; i += 4) {\n        v1 = vld1q_s32(&l[i]);\n        for (int j = i + 4; j < n - 3; j += 4) {\n            v2 = vld1q_s32(&l[j]);\n            int32x4_t sum = vaddq_s32(v1, v2);\n            uint32x4_t mask = vceqq_s32(sum, zero);\n            if (vmaxvq_u32(mask) > 0) return true;\n        }\n        for (int j = i + 4; j < n; j++) {\n            if (l[i] + l[j] == 0 || l[i + 1] + l[j] == 0 || l[i + 2] + l[j] == 0 || l[i + 3] + l[j] == 0) return true;\n        }\n    }\n\n    for (int i = n - n % 4; i < n - 1; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (l[i] + l[j] == 0) return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 2) return false;\n\n    int32x4_t vec1, vec2;\n    int32x4_t zero = vdupq_n_s32(0);\n    uint32x4_t mask;\n\n    for (int i = 0; i < n - 3; i += 4) {\n        vec1 = vld1q_s32(&l[i]);\n        for (int j = i + 4; j < n - 3; j += 4) {\n            vec2 = vld1q_s32(&l[j]);\n            int32x4_t sum = vaddq_s32(vec1, vec2);\n            uint32x4_t cmp = vceqq_s32(sum, zero);\n            if (vgetq_lane_u32(cmp, 0) || vgetq_lane_u32(cmp, 1) || vgetq_lane_u32(cmp, 2) || vgetq_lane_u32(cmp, 3)) {\n                return true;\n            }\n        }\n\n        for (int j = (n / 4) * 4; j < n; j++) {\n            int32x4_t sum = vaddq_s32(vec1, vdupq_n_s32(l[j]));\n            uint32x4_t cmp = vceqq_s32(sum, zero);\n            if (vgetq_lane_u32(cmp, 0) || vgetq_lane_u32(cmp, 1) || vgetq_lane_u32(cmp, 2) || vgetq_lane_u32(cmp, 3)) {\n                return true;\n            }\n        }\n    }\n\n    for (int i = (n / 4) * 4; i < n - 1; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (l[i] + l[j] == 0) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 2) return false;\n\n    int32x4_t zero = vdupq_n_s32(0);\n    int32x4_t neg_zero = vdupq_n_s32(0);\n\n    for (int i = 0; i < n; i += 4) {\n        int32x4_t vec = vld1q_s32(&l[i]);\n        int32x4_t neg_vec = vnegq_s32(vec);\n\n        for (int j = i + 4; j < n; j += 4) {\n            int32x4_t vec2 = vld1q_s32(&l[j]);\n            uint32x4_t cmp1 = vceqq_s32(vec2, neg_vec);\n            uint32x4_t cmp2 = vceqq_s32(vec, vnegq_s32(vec2));\n\n            if (vaddvq_u32(cmp1) > 0 || vaddvq_u32(cmp2) > 0) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 2) return false;\n\n    int32x4_t zero = vdupq_n_s32(0);\n    int32x4_t neg_zero = vdupq_n_s32(0);\n\n    for (int i = 0; i < n; i += 4) {\n        int32x4_t vec = vld1q_s32(&l[i]);\n        int32x4_t neg_vec = vnegq_s32(vec);\n\n        for (int j = i + 4; j < n; j += 4) {\n            int32x4_t vec2 = vld1q_s32(&l[j]);\n            uint32x4_t cmp1 = vceqq_s32(vec2, neg_vec);\n            uint32x4_t cmp2 = vceqq_s32(vec, vrev64q_s32(neg_vec));\n\n            if (vmaxvq_u32(cmp1) || vmaxvq_u32(cmp2)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_85_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n#include <cstdint>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (base < 2 || base > 9) return \"\";\n    if (x == 0) return \"0\";\n\n    std::string result = \"\";\n    while (x > 0) {\n        int64x2_t x_vec = vdupq_n_s64(x);\n        int64x2_t base_vec = vdupq_n_s64(base);\n        int64x2_t rem_vec = vqdmulhq_s64(x_vec, base_vec);\n        int64x2_t quo_vec = vqdmulhq_s64(x_vec, base_vec);\n\n        int64_t rem = vgetq_lane_s64(rem_vec, 0);\n        int64_t quo = vgetq_lane_s64(quo_vec, 0);\n\n        result = std::to_string(rem) + result;\n        x = quo;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n#include <cstdint>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (base < 2 || base > 9) return \"\";\n    if (x == 0) return \"0\";\n\n    std::string result = \"\";\n    while (x > 0) {\n        int64x1_t vx = vdup_n_s64(x);\n        int64x1_t vbase = vdup_n_s64(base);\n        int64x1_t remainder = vreinterpret_s64_s32(vremq_s32(vreinterpret_s32_s64(vx), vreinterpret_s32_s64(vbase)));\n        x = vget_lane_s64(vdivq_s64(vx, vbase), 0);\n        result = std::to_string(vget_lane_s64(remainder, 0)) + result;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n#include <cstdint>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (base < 2 || base > 9) return \"\";\n    if (x == 0) return \"0\";\n\n    std::string result = \"\";\n    while (x > 0) {\n        int64x1_t x_vec = vdup_n_s64(x);\n        int64x1_t base_vec = vdup_n_s64(base);\n        int64x1_t rem_vec = vreinterpret_s64_u64(vremq_u64(vreinterpret_u64_s64(x_vec), vreinterpret_u64_s64(base_vec)));\n        int64_t rem = vget_lane_s64(rem_vec, 0);\n\n        result = std::to_string(rem) + result;\n        x /= base;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n#include <cstdint>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (base < 2 || base > 9) return \"\";\n    if (x == 0) return \"0\";\n\n    std::string result = \"\";\n    while (x > 0) {\n        int64x1_t vx = vdup_n_s64(x);\n        int64x1_t vbase = vdup_n_s64(base);\n        int64x1_t remainder = vreinterpret_s64_s32(vrem_s32(vreinterpret_s32_s64(vx), vreinterpret_s32_s64(vbase)));\n        int64x1_t quotient = vreinterpret_s64_s32(vdiv_s32(vreinterpret_s32_s64(vx), vreinterpret_s32_s64(vbase)));\n\n        x = vget_lane_s64(quotient, 0);\n        result = std::to_string(vget_lane_s64(remainder, 0)) + result;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n#include <cstdint>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (base < 2 || base > 9) return \"\";\n    if (x == 0) return \"0\";\n\n    std::string result = \"\";\n    while (x > 0) {\n        int64x2_t x_vec = vdupq_n_s64(x);\n        int64x2_t base_vec = vdupq_n_s64(base);\n        int64x2_t rem_vec = vreinterpretq_s64_u64(vshrq_n_u64(vreinterpretq_u64_s64(x_vec), 63));\n        int64x2_t div_vec = vqdmulhq_s64(x_vec, base_vec);\n\n        int64_t rem = vgetq_lane_s64(rem_vec, 0);\n        x = vgetq_lane_s64(div_vec, 0);\n\n        result = std::to_string(rem) + result;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_86_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    int len = text.length();\n    if (len == 0) return true;\n\n    char* str = const_cast<char*>(text.c_str());\n    int i = 0;\n    int j = len - 1;\n\n    for (; i < j && (j - i + 1) >= 16; i += 16, j -= 16) {\n        uint8x16_t v1 = vld1q_u8(&str[i]);\n        uint8x16_t v2 = vld1q_u8(&str[j - 15]);\n        v2 = vrev1q_u8(v2);\n\n        uint8x16_t result = vceqq_u8(v1, v2);\n        if (vminvq_u8(result) == 0) return false;\n    }\n\n    for (; i < j; i++, j--) {\n        if (str[i] != str[j]) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    int len = text.length();\n    if (len == 0) return true;\n\n    int i = 0;\n    int j = len - 1;\n\n    while (i < j) {\n        uint8x16_t v1 = vld1q_u8(&text[i]);\n        uint8x16_t v2 = vld1q_u8(&text[j - 15]);\n\n        uint8x16_t eq = vceqq_u8(v1, v2);\n        uint64x2_t eq_pair = vpaddlq_u32(vpaddlq_u16(vpaddlq_u8(eq)));\n\n        if (vgetq_lane_u64(eq_pair, 0) != 16 || vgetq_lane_u64(eq_pair, 1) != 16) {\n            return false;\n        }\n\n        i += 16;\n        j -= 16;\n    }\n\n    while (i < j) {\n        if (text[i++] != text[j--]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    int len = text.length();\n    if (len == 0) return true;\n\n    const char* data = text.c_str();\n    int i = 0;\n    int j = len - 1;\n\n    for (; i < j && (j - i + 1) >= 16; i += 16, j -= 16) {\n        uint8x16_t front = vld1q_u8(&data[i]);\n        uint8x16_t back = vld1q_u8(&data[j - 15]);\n        back = vrev64q_u8(vcombine_u8(vget_high_u8(back), vget_low_u8(back)));\n\n        uint8x16_t diff = veorq_u8(front, back);\n        uint64x2_t zero = vmovq_n_u64(0);\n        uint64x2_t mask = vreinterpretq_u64_u8(diff);\n\n        if (vaddvq_u64(mask) != vaddvq_u64(zero)) {\n            return false;\n        }\n    }\n\n    for (; i < j; i++, j--) {\n        if (data[i] != data[j]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    size_t len = text.length();\n    if (len == 0) return true;\n\n    const char* data = text.c_str();\n    size_t i = 0;\n    size_t j = len - 1;\n\n    while (i < j) {\n        uint8x16_t v1 = vld1q_u8(&data[i]);\n        uint8x16_t v2 = vld1q_u8(&data[j - 15]);\n\n        uint8x16_t eq = vceqq_u8(v1, v2);\n        uint64x2_t eq_pair = vpaddlq_u32(vpaddlq_u16(vpaddlq_u8(eq)));\n\n        if (vgetq_lane_u64(eq_pair, 0) != 16 || vgetq_lane_u64(eq_pair, 1) != 16) {\n            return false;\n        }\n\n        i += 16;\n        j -= 16;\n    }\n\n    while (i < j) {\n        if (data[i] != data[j]) {\n            return false;\n        }\n        i++;\n        j--;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    int len = text.length();\n    if (len == 0) return true;\n\n    char* str = &text[0];\n    int i = 0;\n    int j = len - 1;\n\n    while (i < j) {\n        uint8x16_t v1 = vld1q_u8(&str[i]);\n        uint8x16_t v2 = vld1q_u8(&str[j - 15]);\n\n        uint8x16_t vrev = vrev64q_u8(v2);\n        uint8x16_t vcmp = vceqq_u8(v1, vrev);\n\n        uint64x2_t vmask = vpaddlq_u32(vpaddlq_u16(vpaddlq_u8(vcmp)));\n        uint64_t mask = vgetq_lane_u64(vmask, 0) & vgetq_lane_u64(vmask, 1);\n\n        if (mask != 0xFFFF) {\n            return false;\n        }\n\n        i += 16;\n        j -= 16;\n    }\n\n    while (i < j) {\n        if (str[i++] != str[j--]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_87_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), ' ');\n    int i;\n\n    uint8x16_t v_5 = vdupq_n_u8(5);\n    uint8x16_t v_26 = vdupq_n_u8(26);\n    uint8x16_t v_a = vdupq_n_u8('a');\n\n    for (i = 0; i <= s.length() - 16; i += 16) {\n        uint8x16_t chunk = vld1q_u8(&s[i]);\n        uint8x16_t decoded = vqsubq_u8(chunk, v_5);\n        uint8x16_t adjusted = vqaddq_u8(decoded, v_26);\n        adjusted = vqsubq_u8(adjusted, v_a);\n        adjusted = vmodq_u8(adjusted, v_26);\n        adjusted = vqaddq_u8(adjusted, v_a);\n        vst1q_u8(&out[i], adjusted);\n    }\n\n    for (; i < s.length(); ++i) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out[i] = (char)w;\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), ' ');\n    uint8x16_t v_5 = vdupq_n_u8(5);\n    uint8x16_t v_26 = vdupq_n_u8(26);\n    uint8x16_t v_a = vdupq_n_u8('a');\n\n    for (size_t i = 0; i < s.length(); i += 16) {\n        uint8x16_t chunk = vld1q_u8(&s[i]);\n        uint8x16_t decoded = vqsubq_u8(chunk, v_5);\n        uint8x16_t adjusted = vqaddq_u8(decoded, v_26 * vcltq_u8(decoded, v_a));\n        vst1q_u8(&out[i], adjusted);\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), ' ');\n    int i;\n\n    uint8x16_t v_5 = vdupq_n_u8(5);\n    uint8x16_t v_26 = vdupq_n_u8(26);\n    uint8x16_t v_a = vdupq_n_u8('a');\n\n    for (i = 0; i <= s.length() - 16; i += 16) {\n        uint8x16_t chunk = vld1q_u8(&s[i]);\n        uint8x16_t decoded = vsubq_u8(chunk, v_5);\n        uint8x16_t adjusted = vaddq_u8(decoded, v_26);\n        uint8x16_t result = vsubq_u8(adjusted, v_a);\n        result = vmodq_u8(result, v_26);\n        result = vaddq_u8(result, v_a);\n        vst1q_u8(&out[i], result);\n    }\n\n    for (; i < s.length(); ++i) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out[i] = (char)w;\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n#include <cstring>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), ' ');\n    const int vector_size = 16;\n    const int shift = 5;\n    const uint8x16_t vec_shift = vdupq_n_u8(shift);\n    const uint8x16_t vec_a = vdupq_n_u8('a');\n    const uint8x16_t vec_26 = vdupq_n_u8(26);\n\n    for (size_t i = 0; i < s.length(); i += vector_size) {\n        size_t remaining = s.length() - i;\n        size_t chunk_size = (remaining >= vector_size) ? vector_size : remaining;\n\n        uint8x16_t vec_input = vld1q_u8(s.data() + i);\n        uint8x16_t vec_output = vqsubq_u8(vec_input, vec_shift);\n        vec_output = vqaddq_u8(vec_output, vec_26);\n        vec_output = vqsubq_u8(vec_output, vec_a);\n        vec_output = vqaddq_u8(vec_output, vec_a);\n\n        vst1q_u8(const_cast<char*>(out.data()) + i, vec_output);\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n#include <cstring>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), ' ');\n    const int vector_size = 16; // Size of the NEON vector register\n    const int shift = 5;\n\n    for (size_t i = 0; i < s.length(); i += vector_size) {\n        size_t remaining = s.length() - i;\n        size_t chunk_size = remaining < vector_size ? remaining : vector_size;\n\n        // Load the chunk into a NEON vector\n        uint8x16_t chunk = vld1q_u8(&s[i]);\n\n        // Subtract the shift value\n        uint8x16_t shifted = vsubq_u8(chunk, vdupq_n_u8(shift));\n\n        // Adjust for wrapping around the alphabet\n        uint8x16_t adjusted = vaddq_u8(shifted, vdupq_n_u8('a'));\n        uint8x16_t mask = vdupq_n_u8(26);\n        uint8x16_t mod = vsubq_u8(adjusted, vmulq_u8(vdivq_u8(vsubq_u8(adjusted, vdupq_n_u8('a')), mask), mask));\n\n        // Store the result back into the output string\n        vst1q_u8(&out[i], mod);\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_88_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    int32x4_t vt = vdupq_n_s32(t);\n    size_t size = l.size();\n    size_t i;\n\n    for (i = 0; i <= size - 4; i += 4) {\n        int32x4_t vl = vld1q_s32(&l[i]);\n        uint32x4_t vcmp = vcltq_s32(vl, vt);\n        if (vminvq_u32(vcmp) == 0) {\n            return false;\n        }\n    }\n\n    for (; i < size; ++i) {\n        if (l[i] >= t) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_88_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    int size = l.size();\n    int32x4_t vt = vdupq_n_s32(t);\n    int32x4_t vmax = vdupq_n_s32(INT32_MIN);\n\n    for (int i = 0; i < size; i += 4) {\n        int32x4_t vl = vld1q_s32(&l[i]);\n        int32x4_t vcmp = vmaxq_s32(vl, vt);\n        vmax = vmaxq_s32(vmax, vcmp);\n    }\n\n    int32_t max_vals[4];\n    vst1q_s32(max_vals, vmax);\n\n    return max_vals[0] < t && max_vals[1] < t && max_vals[2] < t && max_vals[3] < t;\n}\n```"}
{"task_id": "SimdBench_88_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    int32x4_t vt = vdupq_n_s32(t);\n    int32x4_t vmax = vdupq_n_s32(std::numeric_limits<int>::min());\n\n    for (size_t i = 0; i < l.size(); i += 4) {\n        int32x4_t vl = vld1q_s32(&l[i]);\n        int32x4_t vcmp = vcgtq_s32(vl, vt);\n        vmax = vmaxq_s32(vmax, vcmp);\n    }\n\n    uint32x4_t vmax_reinterpret = vreinterpretq_u32_s32(vmax);\n    uint32_t max_values[4];\n    vst1q_u32(max_values, vmax_reinterpret);\n\n    return (max_values[0] | max_values[1] | max_values[2] | max_values[3]) == 0;\n}\n```"}
{"task_id": "SimdBench_88_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    int32x4_t vt = vdupq_n_s32(t);\n    size_t size = l.size();\n    size_t i;\n    int32x4_t vmax = vdupq_n_s32(INT32_MIN);\n\n    for (i = 0; i <= size - 4; i += 4) {\n        int32x4_t vl = vld1q_s32(&l[i]);\n        int32x4_t vcmp = vcltq_s32(vl, vt);\n        if (vminvq_u32(vcmp) == 0) {\n            return false;\n        }\n    }\n\n    for (; i < size; ++i) {\n        if (l[i] >= t) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_88_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    int32x4_t vt = vdupq_n_s32(t);\n    int32x4_t vmax = vdupq_n_s32(INT32_MIN);\n    size_t i;\n\n    for (i = 0; i <= l.size() - 4; i += 4) {\n        int32x4_t vl = vld1q_s32(&l[i]);\n        int32x4_t vcmp = vmaxq_s32(vl, vt);\n        vmax = vmaxq_s32(vmax, vcmp);\n    }\n\n    for (; i < l.size(); ++i) {\n        if (l[i] >= t) {\n            return false;\n        }\n    }\n\n    int32_t max_values[4];\n    vst1q_s32(max_values, vmax);\n\n    for (int j = 0; j < 4; ++j) {\n        if (max_values[j] >= t) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_89_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int len = brackets.length();\n    int balance = 0;\n\n    for (int i = 0; i < len; i += 16) {\n        int chunk_size = std::min(16, len - i);\n        uint8x16_t chunk = vld1q_u8(&brackets[i]);\n\n        uint8x16_t open_bracket = vdupq_n_u8('<');\n        uint8x16_t close_bracket = vdupq_n_u8('>');\n\n        uint8x16_t open_mask = vceqq_u8(chunk, open_bracket);\n        uint8x16_t close_mask = vceqq_u8(chunk, close_bracket);\n\n        int open_count = vaddvq_u8(open_mask);\n        int close_count = vaddvq_u8(close_mask);\n\n        balance += open_count - close_count;\n\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int length = brackets.length();\n    int balance = 0;\n\n    for (int i = 0; i < length; i += 16) {\n        int chunk_size = std::min(16, length - i);\n        uint8x16_t chunk = vld1q_u8(reinterpret_cast<const uint8_t*>(&brackets[i]));\n\n        uint8x16_t open_bracket = vdupq_n_u8('<');\n        uint8x16_t close_bracket = vdupq_n_u8('>');\n\n        uint8x16_t open_mask = vceqq_u8(chunk, open_bracket);\n        uint8x16_t close_mask = vceqq_u8(chunk, close_bracket);\n\n        int open_count = vaddvq_u8(open_mask);\n        int close_count = vaddvq_u8(close_mask);\n\n        balance += open_count - close_count;\n\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int length = brackets.length();\n    int balance = 0;\n\n    for (int i = 0; i < length; i += 16) {\n        int chunk_size = std::min(16, length - i);\n        uint8x16_t chunk = vld1q_u8(reinterpret_cast<const uint8_t*>(&brackets[i]));\n\n        uint8x16_t open_bracket = vdupq_n_u8('<');\n        uint8x16_t close_bracket = vdupq_n_u8('>');\n\n        uint8x16_t open_mask = vceqq_u8(chunk, open_bracket);\n        uint8x16_t close_mask = vceqq_u8(chunk, close_bracket);\n\n        int open_count = vaddvq_u8(open_mask);\n        int close_count = vaddvq_u8(close_mask);\n\n        balance += open_count - close_count;\n\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int len = brackets.length();\n    int balance = 0;\n\n    for (int i = 0; i < len; i += 16) {\n        uint8x16_t chunk = vld1q_u8(reinterpret_cast<const uint8_t*>(&brackets[i]));\n        uint8x16_t open = vdupq_n_u8('<');\n        uint8x16_t close = vdupq_n_u8('>');\n\n        uint8x16_t open_mask = vceqq_u8(chunk, open);\n        uint8x16_t close_mask = vceqq_u8(chunk, close);\n\n        int open_count = vaddvq_u8(open_mask);\n        int close_count = vaddvq_u8(close_mask);\n\n        balance += open_count - close_count;\n\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int length = brackets.length();\n    int balance = 0;\n\n    for (int i = 0; i < length; i += 16) {\n        int remaining = length - i;\n        int chunk_size = remaining < 16 ? remaining : 16;\n\n        uint8x16_t chunk = vld1q_u8(brackets.data() + i);\n        uint8x16_t open_bracket = vdupq_n_u8('<');\n        uint8x16_t close_bracket = vdupq_n_u8('>');\n\n        uint8x16_t open_mask = vceqq_u8(chunk, open_bracket);\n        uint8x16_t close_mask = vceqq_u8(chunk, close_bracket);\n\n        int open_count = 0;\n        int close_count = 0;\n\n        for (int j = 0; j < chunk_size; j++) {\n            if (open_mask[j]) open_count++;\n            if (close_mask[j]) close_count++;\n        }\n\n        balance += open_count - close_count;\n\n        if (balance < 0) return false;\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int len = brackets.length();\n    if (len % 16 != 0) {\n        brackets += std::string(16 - len % 16, ' ');\n        len = brackets.length();\n    }\n\n    int16x8_t open_brackets = vdupq_n_s16(0);\n    int16x8_t close_brackets = vdupq_n_s16(0);\n\n    for (int i = 0; i < len; i += 16) {\n        uint8x16_t chunk = vld1q_u8(&brackets[i]);\n\n        int16x8_t open_count = vdupq_n_s16(0);\n        int16x8_t close_count = vdupq_n_s16(0);\n\n        uint8x16_t open_mask = vdupq_n_u8('(');\n        uint8x16_t close_mask = vdupq_n_u8(')');\n\n        uint8x16_t open_matches = vceqq_u8(chunk, open_mask);\n        uint8x16_t close_matches = vceqq_u8(chunk, close_mask);\n\n        open_count = vaddq_s16(open_count, vreinterpretq_s16_u16(vmovl_u8(open_matches)));\n        close_count = vaddq_s16(close_count, vreinterpretq_s16_u16(vmovl_u8(close_matches)));\n\n        open_brackets = vaddq_s16(open_brackets, open_count);\n        close_brackets = vaddq_s16(close_brackets, close_count);\n    }\n\n    int16x8_t balance = vsubq_s16(open_brackets, close_brackets);\n    int16_t balance_sum = vaddvq_s16(balance);\n\n    return balance_sum == 0;\n}\n```"}
{"task_id": "SimdBench_90_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int len = brackets.length();\n    if (len % 16 != 0) {\n        brackets += std::string(16 - len % 16, ' ');\n        len = brackets.length();\n    }\n\n    int16x8_t open_brackets = vdupq_n_s16('(');\n    int16x8_t close_brackets = vdupq_n_s16(')');\n    int16x8_t zero = vdupq_n_s16(0);\n    int16x8_t balance = zero;\n\n    for (int i = 0; i < len; i += 16) {\n        uint8x16_t chunk = vld1q_u8(&brackets[i]);\n        int16x8_t chunk_low = vreinterpretq_s16_u16(vmovl_u8(vget_low_u8(chunk)));\n        int16x8_t chunk_high = vreinterpretq_s16_u16(vmovl_u8(vget_high_u8(chunk)));\n\n        int16x8_t open_matches_low = vceqq_s16(chunk_low, open_brackets);\n        int16x8_t close_matches_low = vceqq_s16(chunk_low, close_brackets);\n        int16x8_t open_matches_high = vceqq_s16(chunk_high, open_brackets);\n        int16x8_t close_matches_high = vceqq_s16(chunk_high, close_brackets);\n\n        int16x8_t balance_low = vsubq_s16(vaddq_s16(balance, open_matches_low), close_matches_low);\n        int16x8_t balance_high = vsubq_s16(vaddq_s16(balance, open_matches_high), close_matches_high);\n\n        balance = vaddq_s16(balance_low, balance_high);\n\n        if (vminvq_s16(balance) < 0) {\n            return false;\n        }\n    }\n\n    int16x8_t final_balance = vpaddq_s16(balance, balance);\n    final_balance = vpaddq_s16(final_balance, final_balance);\n    final_balance = vpaddq_s16(final_balance, final_balance);\n\n    return vgetq_lane_s16(final_balance, 0) == 0;\n}\n```"}
{"task_id": "SimdBench_90_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int len = brackets.length();\n    if (len % 16 != 0) {\n        brackets += std::string(16 - len % 16, ' ');\n        len = brackets.length();\n    }\n\n    int16x8_t open = vdupq_n_s16('(');\n    int16x8_t close = vdupq_n_s16(')');\n    int16x8_t zero = vdupq_n_s16(0);\n    int16x8_t balance = vdupq_n_s16(0);\n\n    for (int i = 0; i < len; i += 16) {\n        uint8x16_t chunk = vld1q_u8(&brackets[i]);\n        int16x8_t chunk_low = vreinterpretq_s16_u16(vmovl_u8(vget_low_u8(chunk)));\n        int16x8_t chunk_high = vreinterpretq_s16_u16(vmovl_u8(vget_high_u8(chunk)));\n\n        int16x8_t opens_low = vceqq_s16(chunk_low, open);\n        int16x8_t closes_low = vceqq_s16(chunk_low, close);\n        int16x8_t opens_high = vceqq_s16(chunk_high, open);\n        int16x8_t closes_high = vceqq_s16(chunk_high, close);\n\n        balance = vaddq_s16(vsubq_s16(balance, closes_low), opens_low);\n        balance = vaddq_s16(vsubq_s16(balance, closes_high), opens_high);\n\n        int16x8_t negative = vcltq_s16(balance, zero);\n        if (vmaxvq_u16(vreinterpretq_u16_s16(negative)) > 0) {\n            return false;\n        }\n    }\n\n    int16_t result[8];\n    vst1q_s16(result, balance);\n    return result[0] == 0 && result[1] == 0 && result[2] == 0 && result[3] == 0 &&\n           result[4] == 0 && result[5] == 0 && result[6] == 0 && result[7] == 0;\n}\n```"}
{"task_id": "SimdBench_90_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int len = brackets.length();\n    if (len % 16 != 0) {\n        brackets += std::string(16 - len % 16, ' ');\n        len = brackets.length();\n    }\n\n    int32x4_t balance = vdupq_n_s32(0);\n    int32x4_t increment = vdupq_n_s32(0);\n\n    for (int i = 0; i < len; i += 16) {\n        uint8x16_t chunk = vld1q_u8(&brackets[i]);\n        uint8x16_t is_open = vceqq_u8(chunk, vdupq_n_u8('('));\n        uint8x16_t is_close = vceqq_u8(chunk, vdupq_n_u8(')'));\n\n        int16x8_t open_count = vaddl_u8(vget_low_u8(is_open), vget_high_u8(is_open));\n        int16x8_t close_count = vaddl_u8(vget_low_u8(is_close), vget_high_u8(is_close));\n\n        int32x4_t open_count32 = vaddl_u16(vget_low_u16(open_count), vget_high_u16(open_count));\n        int32x4_t close_count32 = vaddl_u16(vget_low_u16(close_count), vget_high_u16(close_count));\n\n        increment = vsubq_s32(open_count32, close_count32);\n        balance = vaddq_s32(balance, increment);\n\n        int32x4_t min_balance = vminq_s32(balance, vdupq_n_s32(0));\n        if (vgetq_lane_s32(min_balance, 0) < 0 || vgetq_lane_s32(min_balance, 1) < 0 ||\n            vgetq_lane_s32(min_balance, 2) < 0 || vgetq_lane_s32(min_balance, 3) < 0) {\n            return false;\n        }\n    }\n\n    int32x4_t final_balance = vaddvq_s32(balance);\n    return vgetq_lane_s32(final_balance, 0) == 0;\n}\n```"}
{"task_id": "SimdBench_90_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int length = brackets.length();\n    if (length % 16 != 0) {\n        return false;\n    }\n\n    int16x8_t opening = vdupq_n_s16('(');\n    int16x8_t closing = vdupq_n_s16(')');\n    int16x8_t zero = vdupq_n_s16(0);\n    int16x8_t balance = zero;\n\n    for (int i = 0; i < length; i += 16) {\n        uint8x16_t chunk = vld1q_u8(&brackets[i]);\n        int16x8_t low = vreinterpretq_s16_u16(vmovl_u8(vget_low_u8(chunk)));\n        int16x8_t high = vreinterpretq_s16_u16(vmovl_u8(vget_high_u8(chunk)));\n\n        int16x8_t opens_low = vceqq_s16(low, opening);\n        int16x8_t closes_low = vceqq_s16(low, closing);\n        int16x8_t opens_high = vceqq_s16(high, opening);\n        int16x8_t closes_high = vceqq_s16(high, closing);\n\n        balance = vaddq_s16(balance, vsubq_s16(opens_low, closes_low));\n        balance = vaddq_s16(balance, vsubq_s16(opens_high, closes_high));\n\n        int16x8_t negative = vshrq_n_s16(balance, 15);\n        if (vgetq_lane_s16(negative, 0) != 0 || vgetq_lane_s16(negative, 1) != 0 ||\n            vgetq_lane_s16(negative, 2) != 0 || vgetq_lane_s16(negative, 3) != 0 ||\n            vgetq_lane_s16(negative, 4) != 0 || vgetq_lane_s16(negative, 5) != 0 ||\n            vgetq_lane_s16(negative, 6) != 0 || vgetq_lane_s16(negative, 7) != 0) {\n            return false;\n        }\n    }\n\n    int16x8_t total_balance = vaddvq_s16(balance);\n    return vgetq_lane_s16(total_balance, 0) == 0;\n}\n```"}
{"task_id": "SimdBench_91_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    size_t n = xs.size() - 1;\n    std::vector<float> result(n);\n\n    float32x4_t vscale = vdupq_n_f32(1.0f);\n    float32x4_t vone = vdupq_n_f32(1.0f);\n\n    for (size_t i = 0; i < n; i += 4) {\n        float32x4_t vx = vld1q_f32(&xs[i + 1]);\n        float32x4_t vindex = {static_cast<float>(i + 1), static_cast<float>(i + 2), static_cast<float>(i + 3), static_cast<float>(i + 4)};\n        float32x4_t vresult = vmulq_f32(vx, vindex);\n        vst1q_f32(&result[i], vresult);\n    }\n\n    for (size_t i = n; i < xs.size() - 1; ++i) {\n        result[i] = xs[i + 1] * static_cast<float>(i + 1);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    std::vector<float> result;\n    size_t n = xs.size();\n\n    if (n <= 1) return result;\n\n    float32x4_t vscale = vdupq_n_f32(1.0f);\n    float32x4_t vx1, vx2, vx3, vx4;\n    float32x4_t vresult1, vresult2, vresult3, vresult4;\n\n    for (size_t i = 1; i < n; i += 4) {\n        float coeff1 = (i < n) ? xs[i] * i : 0.0f;\n        float coeff2 = ((i + 1) < n) ? xs[i + 1] * (i + 1) : 0.0f;\n        float coeff3 = ((i + 2) < n) ? xs[i + 2] * (i + 2) : 0.0f;\n        float coeff4 = ((i + 3) < n) ? xs[i + 3] * (i + 3) : 0.0f;\n\n        vx1 = vdupq_n_f32(coeff1);\n        vx2 = vdupq_n_f32(coeff2);\n        vx3 = vdupq_n_f32(coeff3);\n        vx4 = vdupq_n_f32(coeff4);\n\n        vresult1 = vmulq_f32(vx1, vscale);\n        vresult2 = vmulq_f32(vx2, vscale);\n        vresult3 = vmulq_f32(vx3, vscale);\n        vresult4 = vmulq_f32(vx4, vscale);\n\n        result.push_back(vgetq_lane_f32(vresult1, 0));\n        result.push_back(vgetq_lane_f32(vresult2, 0));\n        result.push_back(vgetq_lane_f32(vresult3, 0));\n        result.push_back(vgetq_lane_f32(vresult4, 0));\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    std::vector<float> result;\n    size_t n = xs.size();\n\n    if (n <= 1) return result;\n\n    float32x4_t coeff = vdupq_n_f32(1.0f);\n    float32x4_t inc = vdupq_n_f32(1.0f);\n    float32x4_t x_vec;\n\n    for (size_t i = 1; i < n; i += 4) {\n        x_vec = vmulq_f32(coeff, inc);\n        coeff = vaddq_f32(coeff, inc);\n\n        float32x4_t xs_vec = vld1q_f32(&xs[i]);\n        float32x4_t result_vec = vmulq_f32(xs_vec, x_vec);\n\n        float result_arr[4];\n        vst1q_f32(result_arr, result_vec);\n\n        for (int j = 0; j < 4 && i + j < n; ++j) {\n            result.push_back(result_arr[j]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    std::vector<float> result;\n    size_t n = xs.size();\n\n    if (n <= 1) return result;\n\n    float32x4_t vscale = vdupq_n_f32(1.0f);\n    float32x4_t vx1, vx2, vx3, vx4;\n    float32x4_t vresult1, vresult2, vresult3, vresult4;\n    size_t i;\n\n    for (i = 1; i + 3 < n; i += 4) {\n        vx1 = vld1q_f32(&xs[i]);\n        vx2 = vld1q_f32(&xs[i + 1]);\n        vx3 = vld1q_f32(&xs[i + 2]);\n        vx4 = vld1q_f32(&xs[i + 3]);\n\n        vresult1 = vmulq_f32(vx1, vscale);\n        vresult2 = vmulq_f32(vx2, vscale);\n        vresult3 = vmulq_f32(vx3, vscale);\n        vresult4 = vmulq_f32(vx4, vscale);\n\n        vscale = vaddq_f32(vscale, vdupq_n_f32(4.0f));\n\n        vst1q_f32(&result[i - 1], vresult1);\n        vst1q_f32(&result[i], vresult2);\n        vst1q_f32(&result[i + 1], vresult3);\n        vst1q_f32(&result[i + 2], vresult4);\n    }\n\n    for (; i < n; ++i) {\n        result.push_back(xs[i] * static_cast<float>(i));\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    size_t n = xs.size() - 1;\n    std::vector<float> result(n);\n\n    float32x4_t vscale = vdupq_n_f32(1.0f);\n    float32x4_t vone = vdupq_n_f32(1.0f);\n\n    for (size_t i = 0; i < n; i += 4) {\n        float32x4_t vx = vld1q_f32(&xs[i + 1]);\n        float32x4_t vindex = {(float)(i + 1), (float)(i + 2), (float)(i + 3), (float)(i + 4)};\n        float32x4_t vresult = vmulq_f32(vx, vindex);\n        vst1q_f32(&result[i], vresult);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_92_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n#include <cctype>\n\nint vowels_count_simd(std::string s) {\n    int count = 0;\n    size_t len = s.length();\n    char *str = const_cast<char*>(s.c_str());\n\n    // Define vowel masks\n    uint8x16_t vowels = { 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U', 0, 0, 0, 0, 0, 0 };\n    uint8x16_t y_mask = vdupq_n_u8('y');\n    uint8x16_t Y_mask = vdupq_n_u8('Y');\n\n    size_t i;\n    for (i = 0; i <= len - 16; i += 16) {\n        uint8x16_t chunk = vld1q_u8(&str[i]);\n        uint8x16_t is_vowel = vceqq_u8(chunk, vowels);\n\n        // Check for 'y' or 'Y' at the end of the string\n        if (i + 16 == len) {\n            is_vowel = vmaxq_u8(is_vowel, vceqq_u8(chunk, y_mask));\n            is_vowel = vmaxq_u8(is_vowel, vceqq_u8(chunk, Y_mask));\n        }\n\n        uint8x16_t vowel_count = vaddvq_u8(is_vowel);\n        count += vgetq_lane_u8(vowel_count, 0);\n    }\n\n    // Handle remaining characters\n    for (; i < len; ++i) {\n        char c = str[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n            c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ||\n            (c == 'y' && i == len - 1) || (c == 'Y' && i == len - 1)) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n#include <cctype>\n\nint vowels_count_simd(std::string s) {\n    int count = 0;\n    size_t len = s.length();\n    char *str = const_cast<char*>(s.c_str());\n\n    // Define vowels and convert to lowercase\n    uint8x16_t vowels = vdupq_n_u8('a');\n    uint8x16_t vowels_e = vdupq_n_u8('e');\n    uint8x16_t vowels_i = vdupq_n_u8('i');\n    uint8x16_t vowels_o = vdupq_n_u8('o');\n    uint8x16_t vowels_u = vdupq_n_u8('u');\n\n    for (size_t i = 0; i < len; i += 16) {\n        size_t remaining = len - i;\n        size_t chunk_size = remaining < 16 ? remaining : 16;\n\n        uint8x16_t chunk = vld1q_u8(str + i);\n        uint8x16_t lower_chunk = vdupq_n_u8(0);\n\n        for (size_t j = 0; j < chunk_size; ++j) {\n            lower_chunk = vsetq_lane_u8(std::tolower(str[i + j]), lower_chunk, j);\n        }\n\n        uint8x16_t is_vowel_a = vceqq_u8(lower_chunk, vowels);\n        uint8x16_t is_vowel_e = vceqq_u8(lower_chunk, vowels_e);\n        uint8x16_t is_vowel_i = vceqq_u8(lower_chunk, vowels_i);\n        uint8x16_t is_vowel_o = vceqq_u8(lower_chunk, vowels_o);\n        uint8x16_t is_vowel_u = vceqq_u8(lower_chunk, vowels_u);\n\n        uint8x16_t is_vowel = vorrq_u8(vorrq_u8(vorrq_u8(vorrq_u8(is_vowel_a, is_vowel_e), is_vowel_i), is_vowel_o), is_vowel_u);\n\n        uint8_t vowel_mask[16];\n        vst1q_u8(vowel_mask, is_vowel);\n\n        for (size_t j = 0; j < chunk_size; ++j) {\n            if (vowel_mask[j]) {\n                count++;\n            }\n        }\n    }\n\n    // Check if 'y' is at the end of the string\n    if (!s.empty() && std::tolower(s.back()) == 'y') {\n        count++;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n#include <cstring>\n\nint vowels_count_simd(std::string s) {\n    int count = 0;\n    size_t len = s.length();\n    char *str = const_cast<char*>(s.c_str());\n\n    uint8x16_t vowels = vld1q_u8(\"aeiouAEIOUaeiouAEIOU\");\n    uint8x16_t y_char = vld1q_u8(\"yYyYyYyYyYyYyYyY\");\n\n    for (size_t i = 0; i <= len - 16; i += 16) {\n        uint8x16_t chunk = vld1q_u8(str + i);\n        uint8x16_t is_vowel = vceqq_u8(chunk, vowels);\n        count += vaddvq_u8(is_vowel);\n    }\n\n    for (size_t i = len - (len % 16); i < len; ++i) {\n        if (strchr(\"aeiouAEIOU\", str[i]) != nullptr) {\n            count++;\n        }\n    }\n\n    if (str[len - 1] == 'y' || str[len - 1] == 'Y') {\n        count++;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n#include <cstring>\n\nint vowels_count_simd(std::string s) {\n    int count = 0;\n    size_t len = s.length();\n    char *str = const_cast<char*>(s.c_str());\n\n    uint8x16_t vowels = {0, 'a', 0, 'e', 0, 'i', 0, 'o', 0, 'u', 0, 0, 0, 0, 0, 0};\n    uint8x16_t y_vowel = {0, 'y', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n\n    for (size_t i = 0; i <= len - 16; i += 16) {\n        uint8x16_t chunk = vld1q_u8(&str[i]);\n        uint8x16_t mask_vowels = vceqq_u8(chunk, vowels);\n        uint8x16_t mask_y = vceqq_u8(chunk, y_vowel);\n\n        count += vaddvq_u8(mask_vowels);\n\n        if (i + 15 == len - 1 && str[len - 1] == 'y') {\n            count += vaddvq_u8(mask_y);\n        }\n    }\n\n    for (size_t i = (len / 16) * 16; i < len; ++i) {\n        if (strchr(\"aeiou\", str[i]) != nullptr) {\n            count++;\n        } else if (i == len - 1 && str[i] == 'y') {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n#include <cstring>\n\nint vowels_count_simd(std::string s) {\n    int count = 0;\n    size_t len = s.length();\n    char *str = const_cast<char*>(s.c_str());\n\n    uint8x16_t vowels = vld1q_u8(\"aeiouAEIOUaeiouAEIOU\");\n    uint8x16_t y_vowel = vld1q_u8(\"yY\");\n\n    for (size_t i = 0; i <= len - 16; i += 16) {\n        uint8x16_t chunk = vld1q_u8(str + i);\n        uint8x16_t is_vowel = vandq_u8(chunk, vowels);\n        uint8x16_t mask = vceqq_u8(is_vowel, vowels);\n        count += vaddvq_u8(mask);\n    }\n\n    for (size_t i = (len / 16) * 16; i < len; ++i) {\n        if (strchr(\"aeiouAEIOU\", str[i]) != nullptr) {\n            count++;\n        }\n    }\n\n    if (len > 0 && (str[len - 1] == 'y' || str[len - 1] == 'Y')) {\n        count++;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_93_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    size_t len = s.length();\n    size_t i = 0;\n\n    // Process 16 characters at a time using NEON\n    for (; i <= len - 16; i += 16) {\n        uint8x16_t chunk = vld1q_u8(&s[i]);\n        uint8x16_t is_upper = vandq_u8(chunk, vdupq_n_u8('Z' - 'A' + 1));\n        is_upper = vcgeq_u8(is_upper, vdupq_n_u8('A'));\n        is_upper = vandq_u8(is_upper, vcleq_u8(chunk, vdupq_n_u8('Z')));\n\n        uint8x16_t upper_chars = vandq_u8(chunk, is_upper);\n        int16x8_t upper_sums = vpaddlq_u8(upper_chars);\n        int32x4_t upper_sums2 = vpaddlq_u16(upper_sums);\n        int64x2_t upper_sums3 = vpaddlq_u32(upper_sums2);\n        int64_t upper_sum = vaddvq_u64(upper_sums3);\n\n        sum += (int)upper_sum;\n    }\n\n    // Process remaining characters\n    for (; i < len; ++i) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            sum += s[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    size_t len = s.length();\n    size_t i = 0;\n\n    // Process 16 characters at a time using NEON\n    for (; i <= len - 16; i += 16) {\n        uint8x16_t chunk = vld1q_u8(&s[i]);\n        uint8x16_t is_upper = vandq_u8(chunk, vdupq_n_u8('Z' - 'A' + 1));\n        is_upper = vcgtq_u8(is_upper, vdupq_n_u8('Z' - 'A'));\n        uint8x16_t upper_chars = vandq_u8(chunk, is_upper);\n        int16x8_t sum1 = vpaddlq_u8(upper_chars);\n        int32x4_t sum2 = vpaddlq_u16(sum1);\n        int64x2_t sum3 = vpaddlq_u32(sum2);\n        sum += vgetq_lane_u64(vpaddq_u64(sum3, sum3), 0);\n    }\n\n    // Process remaining characters\n    for (; i < len; ++i) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            sum += s[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    size_t len = s.length();\n    size_t i = 0;\n\n    // Process 16 characters at a time using NEON\n    for (; i <= len - 16; i += 16) {\n        uint8x16_t chunk = vld1q_u8(&s[i]);\n        uint8x16_t is_upper = vandq_u8(chunk, vdupq_n_u8('Z' - 'A' + 1));\n        is_upper = vcgtq_u8(is_upper, vdupq_n_u8('Z' - 'A'));\n        uint8x16_t upper_chars = vandq_u8(chunk, is_upper);\n        int16x8_t sum_low = vpaddlq_u8(upper_chars);\n        int32x4_t sum_mid = vpaddlq_u16(sum_low);\n        int32x4_t sum_high = vpaddlq_u16(vextq_u16(sum_low, sum_low, 8));\n        sum += vaddvq_u32(sum_mid) + vaddvq_u32(sum_high);\n    }\n\n    // Process remaining characters\n    for (; i < len; ++i) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            sum += s[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    size_t len = s.length();\n    size_t i = 0;\n\n    // Process 16 characters at a time using NEON intrinsics\n    for (; i <= len - 16; i += 16) {\n        uint8x16_t chunk = vld1q_u8(&s[i]);\n        uint8x16_t is_upper = vandq_u8(chunk, vdupq_n_u8(0xDF));\n        uint8x16_t upper_mask = vcgeq_u8(is_upper, vdupq_n_u8('A'));\n        upper_mask = vandq_u8(upper_mask, vcltq_u8(is_upper, vdupq_n_u8('Z' + 1)));\n        uint8x16_t upper_chars = vandq_u8(chunk, upper_mask);\n\n        int8x16_t ascii_values = vreinterpretq_s8_u8(upper_chars);\n        int16x8_t sum1 = vpaddq_s16(vpaddlq_s8(ascii_values));\n        int32x4_t sum2 = vpaddq_s32(vpaddlq_s16(sum1));\n        int64x2_t sum3 = vpaddq_s64(vpaddlq_s32(sum2));\n        sum += vgetq_lane_s64(sum3, 0) + vgetq_lane_s64(sum3, 1);\n    }\n\n    // Process remaining characters\n    for (; i < len; ++i) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            sum += s[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    size_t len = s.length();\n    size_t i = 0;\n\n    // Process 16 characters at a time using NEON\n    for (; i <= len - 16; i += 16) {\n        uint8x16_t chunk = vld1q_u8(&s[i]);\n        uint8x16_t is_upper = vandq_u8(chunk, vdupq_n_u8('A'));\n        uint8x16_t mask = vcgtq_u8(chunk, vdupq_n_u8('@'));\n        is_upper = vandq_u8(is_upper, mask);\n        uint8x16_t upper_chars = vandq_u8(chunk, is_upper);\n        int16x8_t sum1 = vpaddlq_u8(upper_chars);\n        int32x4_t sum2 = vpaddlq_u16(sum1);\n        int64x2_t sum3 = vpaddlq_u32(sum2);\n        sum += vgetq_lane_u64(sum3, 0) + vgetq_lane_u64(sum3, 1);\n    }\n\n    // Process remaining characters\n    for (; i < len; ++i) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            sum += s[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_94_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <limits.h>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n\n    int32x4_t min_even_val = {INT_MAX, INT_MAX, INT_MAX, INT_MAX};\n    int32x4_t min_even_idx = {INT_MAX, INT_MAX, INT_MAX, INT_MAX};\n    int32x4_t zero_val = {0, 0, 0, 0};\n    int32x4_t idx_val = {0, 1, 2, 3};\n\n    for (size_t i = 0; i < arr.size(); i += 4) {\n        int32x4_t chunk = vld1q_s32(&arr[i]);\n        int32x4_t even_mask = vandq_s32(chunk, vdupq_n_s32(1));\n        int32x4_t is_even = vceqq_s32(even_mask, zero_val);\n\n        int32x4_t current_idx = vaddq_s32(idx_val, vdupq_n_s32(i));\n        int32x4_t min_val = vminq_s32(chunk, min_even_val);\n        int32x4_t min_idx = vbslq_s32(is_even, current_idx, min_even_idx);\n\n        min_even_val = vbslq_s32(vcltq_s32(min_val, min_even_val), min_val, min_even_val);\n        min_even_idx = vbslq_s32(vcltq_s32(min_val, min_even_val), min_idx, min_even_idx);\n    }\n\n    int min_val[4];\n    int min_idx[4];\n    vst1q_s32(min_val, min_even_val);\n    vst1q_s32(min_idx, min_even_idx);\n\n    int smallest_val = INT_MAX;\n    int smallest_idx = INT_MAX;\n    for (int i = 0; i < 4; ++i) {\n        if (min_val[i] < smallest_val) {\n            smallest_val = min_val[i];\n            smallest_idx = min_idx[i];\n        }\n    }\n\n    if (smallest_val == INT_MAX) return {};\n    return {smallest_val, smallest_idx};\n}\n```"}
{"task_id": "SimdBench_94_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <limits.h>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n\n    int32x4_t min_even_val = {INT_MAX, INT_MAX, INT_MAX, INT_MAX};\n    int32x4_t min_even_idx = {INT_MAX, INT_MAX, INT_MAX, INT_MAX};\n    int32x4_t zero_val = {0, 0, 0, 0};\n    int32x4_t idx_val = {0, 1, 2, 3};\n\n    for (size_t i = 0; i < arr.size(); i += 4) {\n        int32x4_t chunk = vld1q_s32(&arr[i]);\n        int32x4_t even_mask = vandq_s32(chunk, zero_val);\n        uint32x4_t cmp_mask = vceqq_s32(even_mask, zero_val);\n\n        int32x4_t min_cmp = vminq_s32(chunk, min_even_val);\n        uint32x4_t min_mask = vceqq_s32(min_cmp, min_even_val);\n\n        min_even_val = vbslq_s32(min_mask, chunk, min_even_val);\n        min_even_idx = vbslq_s32(min_mask, idx_val, min_even_idx);\n\n        idx_val = vaddq_s32(idx_val, vdupq_n_s32(4));\n    }\n\n    int min_val = INT_MAX;\n    int min_idx = INT_MAX;\n\n    int32_t min_vals[4];\n    int32_t min_idxs[4];\n\n    vst1q_s32(min_vals, min_even_val);\n    vst1q_s32(min_idxs, min_even_idx);\n\n    for (int i = 0; i < 4; ++i) {\n        if (min_vals[i] < min_val) {\n            min_val = min_vals[i];\n            min_idx = min_idxs[i];\n        }\n    }\n\n    if (min_val == INT_MAX) return {};\n\n    return {min_val, min_idx};\n}\n```"}
{"task_id": "SimdBench_94_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <limits.h>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n\n    int32x4_t min_even_val = {INT_MAX, INT_MAX, INT_MAX, INT_MAX};\n    int32x4_t min_even_idx = {INT_MAX, INT_MAX, INT_MAX, INT_MAX};\n    int32x4_t even_mask = {2, 2, 2, 2};\n\n    for (size_t i = 0; i < arr.size(); i += 4) {\n        int32x4_t chunk = vld1q_s32(&arr[i]);\n        int32x4_t even_check = vandq_s32(chunk, even_mask);\n        uint32x4_t is_even = vceqq_s32(even_check, vdupq_n_s32(0));\n\n        int32x4_t indices = {i, i + 1, i + 2, i + 3};\n        int32x4_t min_vals = vminq_s32(chunk, min_even_val);\n        int32x4_t min_idxs = vbslq_s32(is_even, indices, min_even_idx);\n\n        min_even_val = vbslq_s32(vcltq_s32(chunk, min_even_val), min_vals, min_even_val);\n        min_even_idx = vbslq_s32(vcltq_s32(chunk, min_even_val), min_idxs, min_even_idx);\n    }\n\n    int min_val = INT_MAX;\n    int min_idx = INT_MAX;\n    int32_t temp_val[4];\n    int32_t temp_idx[4];\n    vst1q_s32(temp_val, min_even_val);\n    vst1q_s32(temp_idx, min_even_idx);\n\n    for (int i = 0; i < 4; ++i) {\n        if (temp_val[i] < min_val) {\n            min_val = temp_val[i];\n            min_idx = temp_idx[i];\n        }\n    }\n\n    if (min_val == INT_MAX) return {};\n    return {min_val, min_idx};\n}\n```"}
{"task_id": "SimdBench_94_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <limits.h>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n\n    int32x4_t min_even_val = vdupq_n_s32(INT_MAX);\n    int32x4_t min_even_idx = vdupq_n_s32(INT_MAX);\n    int min_val = INT_MAX;\n    int min_idx = INT_MAX;\n\n    for (size_t i = 0; i < arr.size(); i += 4) {\n        int32x4_t chunk = vld1q_s32(&arr[i]);\n        int32x4_t even_mask = vandq_s32(chunk, vdupq_n_s32(1));\n        int32x4_t is_even = vceqq_s32(even_mask, vdupq_n_s32(0));\n\n        int32x4_t even_vals = vbslq_s32(is_even, chunk, vdupq_n_s32(INT_MAX));\n        int32x4_t indices = vaddq_s32(vdupq_n_s32(i), vld1q_s32(&arr[i]));\n\n        int32x4_t min_vals = vminq_s32(min_even_val, even_vals);\n        int32x4_t min_inds = vbslq_s32(vcltq_s32(even_vals, min_even_val), indices, min_even_idx);\n\n        min_even_val = min_vals;\n        min_even_idx = min_inds;\n    }\n\n    int32_t min_vals[4];\n    int32_t min_inds[4];\n    vst1q_s32(min_vals, min_even_val);\n    vst1q_s32(min_inds, min_even_idx);\n\n    for (int i = 0; i < 4; ++i) {\n        if (min_vals[i] < min_val) {\n            min_val = min_vals[i];\n            min_idx = min_inds[i];\n        }\n    }\n\n    if (min_val == INT_MAX) return {};\n    return {min_val, min_idx};\n}\n```"}
{"task_id": "SimdBench_94_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <limits.h>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n\n    int32x4_t min_even_vec = {INT_MAX, INT_MAX, INT_MAX, INT_MAX};\n    int min_even = INT_MAX;\n    int min_index = -1;\n\n    for (size_t i = 0; i < arr.size(); i += 4) {\n        int32x4_t chunk = vld1q_s32(&arr[i]);\n        int32x4_t even_mask = vandq_s32(chunk, vdupq_n_s32(1));\n        int32x4_t even_chunk = vbicq_s32(chunk, even_mask);\n\n        int32x4_t min_chunk = vminq_s32(even_chunk, min_even_vec);\n        min_even_vec = min_chunk;\n\n        int32_t temp[4];\n        vst1q_s32(temp, min_chunk);\n\n        for (int j = 0; j < 4; ++j) {\n            if (temp[j] < min_even && temp[j] != INT_MAX) {\n                min_even = temp[j];\n                min_index = i + j;\n            }\n        }\n    }\n\n    if (min_index == -1) return {};\n    return {min_even, min_index};\n}\n```"}
{"task_id": "SimdBench_95_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    if (lst.empty()) return -1;\n\n    const int max_val = *std::max_element(lst.begin(), lst.end());\n    std::vector<int> frequency(max_val + 1, 0);\n\n    int32x4_t vzero = vdupq_n_s32(0);\n    int32x4_t vone = vdupq_n_s32(1);\n\n    for (size_t i = 0; i < lst.size(); i += 4) {\n        int32x4_t v = vld1q_s32(&lst[i]);\n        int32x4_t vinc = vdupq_n_s32(1);\n\n        for (int j = 0; j < 4; ++j) {\n            int val = vgetq_lane_s32(v, j);\n            if (i + j < lst.size()) {\n                frequency[val]++;\n            }\n        }\n    }\n\n    int result = -1;\n    for (int i = 1; i <= max_val; ++i) {\n        if (frequency[i] >= i) {\n            result = i;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_95_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    if (lst.empty()) return -1;\n\n    std::sort(lst.begin(), lst.end());\n\n    int max_freq = -1;\n    int current_value = lst[0];\n    int current_count = 0;\n\n    for (size_t i = 0; i < lst.size(); i += 4) {\n        uint32x4_t v = vld1q_u32(&lst[i]);\n        uint32x4_t cmp = vceqq_u32(v, vdupq_n_u32(current_value));\n        uint32x4_t mask = vandq_u32(cmp, vdupq_n_u32(1));\n        uint32_t count = vaddvq_u32(mask);\n\n        current_count += count;\n\n        if (current_count >= current_value && current_value > max_freq) {\n            max_freq = current_value;\n        }\n\n        if (i + 4 >= lst.size() || lst[i + 4] != current_value) {\n            current_value = lst[i + 4];\n            current_count = 0;\n        }\n    }\n\n    return max_freq;\n}\n```"}
{"task_id": "SimdBench_95_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    if (lst.empty()) return -1;\n\n    const int max_val = *std::max_element(lst.begin(), lst.end());\n    std::vector<int> count(max_val + 1, 0);\n\n    int32x4_t vzero = vdupq_n_s32(0);\n    int32x4_t vone = vdupq_n_s32(1);\n\n    for (size_t i = 0; i < lst.size(); i += 4) {\n        int32x4_t v = vld1q_s32(&lst[i]);\n        int32x4_t vinc = vdupq_n_s32(1);\n\n        for (int j = 1; j <= max_val; ++j) {\n            int32x4_t vcmp = vceqq_s32(v, vdupq_n_s32(j));\n            int32x4_t vcount = vaddq_s32(vzero, vandq_s32(vcmp, vinc));\n\n            int32_t count_lane[4];\n            vst1q_s32(count_lane, vcount);\n\n            for (int k = 0; k < 4; ++k) {\n                if (i + k < lst.size()) {\n                    count[j] += count_lane[k];\n                }\n            }\n        }\n    }\n\n    int result = -1;\n    for (int i = 1; i <= max_val; ++i) {\n        if (count[i] >= i) {\n            result = std::max(result, i);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_95_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    if (lst.empty()) return -1;\n\n    // Sort the vector to bring identical elements together\n    std::sort(lst.begin(), lst.end());\n\n    int max_freq = -1;\n    int current_count = 1;\n\n    for (size_t i = 1; i <= lst.size(); ++i) {\n        if (i == lst.size() || lst[i] != lst[i - 1]) {\n            if (current_count >= lst[i - 1] && lst[i - 1] > max_freq) {\n                max_freq = lst[i - 1];\n            }\n            current_count = 1;\n        } else {\n            ++current_count;\n        }\n    }\n\n    return max_freq;\n}\n```"}
{"task_id": "SimdBench_95_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    if (lst.empty()) return -1;\n\n    std::sort(lst.begin(), lst.end());\n\n    int max_freq = -1;\n    int current_value = lst[0];\n    int current_count = 0;\n\n    for (size_t i = 0; i < lst.size(); i += 4) {\n        int32x4_t v = vld1q_s32(&lst[i]);\n        int32x4_t count = vceqq_s32(v, vdupq_n_s32(current_value));\n\n        int32x2_t count_low = vadd_s32(vget_low_s32(count), vget_high_s32(count));\n        int32x2_t count_sum = vpadd_s32(count_low, count_low);\n        current_count += vget_lane_s32(count_sum, 0);\n\n        if (i + 4 >= lst.size() || lst[i + 4] != current_value) {\n            if (current_count >= current_value && current_value > max_freq) {\n                max_freq = current_value;\n            }\n            if (i + 4 < lst.size()) {\n                current_value = lst[i + 4];\n                current_count = 0;\n            }\n        }\n    }\n\n    return max_freq;\n}\n```"}
{"task_id": "SimdBench_96_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    bool balanced = true;\n\n    for (int i = 0; i < n; i += 4) {\n        int32x4_t chunk = vld1q_s32(&q[i]);\n        sum_vec = vaddq_s32(sum_vec, chunk);\n\n        if (i < n / 2) {\n            int32x4_t chunk_rev = vld1q_s32(&q[n - i - 4]);\n            uint32x4_t diff = vceqq_s32(chunk, chunk_rev);\n            if (vgetq_lane_u32(diff, 0) == 0 || vgetq_lane_u32(diff, 1) == 0 || vgetq_lane_u32(diff, 2) == 0 || vgetq_lane_u32(diff, 3) == 0) {\n                balanced = false;\n            }\n        }\n    }\n\n    int sum[4];\n    vst1q_s32(sum, sum_vec);\n    int total_sum = sum[0] + sum[1] + sum[2] + sum[3];\n\n    return balanced && (total_sum <= w);\n}\n```"}
{"task_id": "SimdBench_96_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    int32x4_t sum = vdupq_n_s32(0);\n\n    for (size_t i = 0; i < n; i += 4) {\n        int32x4_t chunk = vld1q_s32(&q[i]);\n        sum = vaddq_s32(sum, chunk);\n    }\n\n    int total_sum = vgetq_lane_s32(sum, 0) + vgetq_lane_s32(sum, 1) + vgetq_lane_s32(sum, 2) + vgetq_lane_s32(sum, 3);\n\n    if (total_sum > w) {\n        return false;\n    }\n\n    for (size_t i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - i - 1]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_96_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    int32x4_t sum = vmovq_n_s32(0);\n\n    for (size_t i = 0; i < n; i += 4) {\n        int32x4_t chunk = vld1q_s32(&q[i]);\n        sum = vaddq_s32(sum, chunk);\n    }\n\n    int total_sum = vaddvq_s32(sum);\n    if (total_sum > w) {\n        return false;\n    }\n\n    for (size_t i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - i - 1]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_96_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    int32x4_t sum = vdupq_n_s32(0);\n\n    for (size_t i = 0; i < n; i += 4) {\n        int32x4_t chunk = vld1q_s32(&q[i]);\n        sum = vaddq_s32(sum, chunk);\n    }\n\n    int32_t total_sum[4];\n    vst1q_s32(total_sum, sum);\n    int total = total_sum[0] + total_sum[1] + total_sum[2] + total_sum[3];\n\n    if (total > w) {\n        return false;\n    }\n\n    for (size_t i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - i - 1]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_96_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    int32x4_t vw = vdupq_n_s32(w);\n    int32x4_t vsum = vdupq_n_s32(0);\n    int32x4_t vzero = vdupq_n_s32(0);\n\n    for (int i = 0; i < n; i += 4) {\n        int32x4_t vq = vld1q_s32(&q[i]);\n        vsum = vaddq_s32(vsum, vq);\n    }\n\n    int sum = vaddvq_s32(vsum);\n    if (sum > w) return false;\n\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - i - 1]) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_97_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    int i = 0;\n    int j = n - 1;\n\n    for (; i < j && (j - i + 1) >= 4; i += 4, j -= 4) {\n        int32x4_t v1 = vld1q_s32(&arr[i]);\n        int32x4_t v2 = vld1q_s32(&arr[j - 3]);\n        v2 = vrev64q_s32(v2);\n\n        uint32x4_t diff = vceqq_s32(v1, v2);\n        uint32x4_t mask = vdupq_n_u32(0xFFFFFFFF);\n        uint32x4_t result = vandq_u32(diff, mask);\n\n        int32x4_t sum = vaddvq_u32(result);\n        changes += 4 - vgetq_lane_u32(sum, 0);\n    }\n\n    for (; i < j; i++, j--) {\n        if (arr[i] != arr[j]) {\n            changes++;\n        }\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    int32x4_t v_zero = vdupq_n_s32(0);\n    int32x4_t v_one = vdupq_n_s32(1);\n\n    for (int i = 0; i < n / 2; i += 4) {\n        int32x4_t v_left = vld1q_s32(&arr[i]);\n        int32x4_t v_right = vld1q_s32(&arr[n - i - 4]);\n        int32x4_t v_rev_right = vrev64q_s32(vcombine_s32(vget_high_s32(v_right), vget_low_s32(v_right)));\n\n        uint32x4_t v_cmp = vceqq_s32(v_left, v_rev_right);\n        int32x4_t v_changes = vsubq_s32(v_one, vreinterpretq_s32_u32(v_cmp));\n\n        changes += vaddvq_s32(v_changes);\n    }\n\n    for (int i = (n / 2) * 4; i < n / 2; ++i) {\n        if (arr[i] != arr[n - i - 1]) {\n            ++changes;\n        }\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    for (int i = 0; i < n / 2; i += 4) {\n        int32x4_t v1 = vld1q_s32(&arr[i]);\n        int32x4_t v2 = vld1q_s32(&arr[n - i - 4]);\n        uint32x4_t diff = vceqq_s32(v1, vrev64q_s32(v2));\n        int mask = vaddvq_u32(diff);\n        changes += __builtin_popcount(~mask);\n    }\n\n    for (int i = (n / 2) * 2; i < n / 2; ++i) {\n        if (arr[i] != arr[n - i - 1]) {\n            ++changes;\n        }\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    int32x4_t v_zero = vdupq_n_s32(0);\n    int32x4_t v_changes = v_zero;\n\n    for (int i = 0; i < n / 2; i += 4) {\n        int32x4_t v_left = vld1q_s32(&arr[i]);\n        int32x4_t v_right = vld1q_s32(&arr[n - i - 1]);\n\n        uint32x4_t v_cmp = vceqq_s32(v_left, v_right);\n        int32x4_t v_diff = vsubq_s32(v_zero, v_cmp);\n\n        v_changes = vaddq_s32(v_changes, v_diff);\n    }\n\n    int32_t changes_array[4];\n    vst1q_s32(changes_array, v_changes);\n\n    changes = changes_array[0] + changes_array[1] + changes_array[2] + changes_array[3];\n\n    for (int i = (n / 2) * 4; i < n / 2; ++i) {\n        if (arr[i] != arr[n - i - 1]) {\n            ++changes;\n        }\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    for (int i = 0; i < n / 2; i += 4) {\n        int32x4_t v1 = vld1q_s32(&arr[i]);\n        int32x4_t v2 = vld1q_s32(&arr[n - i - 4]);\n        v2 = vrev64q_s32(v2);\n\n        uint32x4_t diff = vceqq_s32(v1, v2);\n        uint32_t mask = vaddvq_u32(diff);\n\n        changes += 4 - __builtin_popcount(mask);\n    }\n\n    for (int i = (n / 2) * 2; i < n / 2; ++i) {\n        if (arr[i] != arr[n - i - 1]) {\n            ++changes;\n        }\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_98_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    uint32_t total_chars_lst1 = 0;\n    uint32_t total_chars_lst2 = 0;\n\n    for (const auto& str : lst1) {\n        uint32_t len = str.length();\n        uint32x4_t len_vec = vdupq_n_u32(len);\n        total_chars_lst1 += vaddvq_u32(len_vec);\n    }\n\n    for (const auto& str : lst2) {\n        uint32_t len = str.length();\n        uint32x4_t len_vec = vdupq_n_u32(len);\n        total_chars_lst2 += vaddvq_u32(len_vec);\n    }\n\n    if (total_chars_lst1 < total_chars_lst2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n#include <numeric>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    uint32_t totalChars1 = 0;\n    uint32_t totalChars2 = 0;\n\n    for (const auto& str : lst1) {\n        uint32x4_t chars = {str.length(), str.length(), str.length(), str.length()};\n        uint32x4_t sum = vpaddq_u32(chars);\n        totalChars1 += vgetq_lane_u32(sum, 0) + vgetq_lane_u32(sum, 1) + vgetq_lane_u32(sum, 2) + vgetq_lane_u32(sum, 3);\n    }\n\n    for (const auto& str : lst2) {\n        uint32x4_t chars = {str.length(), str.length(), str.length(), str.length()};\n        uint32x4_t sum = vpaddq_u32(chars);\n        totalChars2 += vgetq_lane_u32(sum, 0) + vgetq_lane_u32(sum, 1) + vgetq_lane_u32(sum, 2) + vgetq_lane_u32(sum, 3);\n    }\n\n    if (totalChars1 < totalChars2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n#include <numeric>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    uint32_t total1 = 0;\n    uint32_t total2 = 0;\n\n    for (const auto& str : lst1) {\n        uint32x4_t len = vdupq_n_u32(str.length());\n        total1 += vaddvq_u32(len);\n    }\n\n    for (const auto& str : lst2) {\n        uint32x4_t len = vdupq_n_u32(str.length());\n        total2 += vaddvq_u32(len);\n    }\n\n    if (total1 < total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    uint32_t totalChars1 = 0;\n    uint32_t totalChars2 = 0;\n\n    for (const auto& str : lst1) {\n        uint32_t len = str.length();\n        uint32x4_t vlen = vdupq_n_u32(len);\n        totalChars1 += vaddvq_u32(vlen);\n    }\n\n    for (const auto& str : lst2) {\n        uint32_t len = str.length();\n        uint32x4_t vlen = vdupq_n_u32(len);\n        totalChars2 += vaddvq_u32(vlen);\n    }\n\n    if (totalChars1 < totalChars2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n#include <numeric>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    auto count_chars = [](const std::vector<std::string> & lst) {\n        uint32_t total = 0;\n        uint32x4_t total_vec = vdupq_n_u32(0);\n        for (const auto & str : lst) {\n            uint32_t len = str.length();\n            total_vec = vaddq_u32(total_vec, vdupq_n_u32(len));\n        }\n        total = vaddvq_u32(total_vec);\n        return total;\n    };\n\n    uint32_t total1 = count_chars(lst1);\n    uint32_t total2 = count_chars(lst2);\n\n    return (total1 < total2) ? lst1 : (total2 < total1) ? lst2 : lst1;\n}\n```"}
{"task_id": "SimdBench_99_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n#include <stdint.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (x == 1 && n == 1) return true;\n    if (n == 1) return false;\n\n    uint64x2_t vx = vdupq_n_u64(x);\n    uint64x2_t vn = vdupq_n_u64(n);\n    uint64x2_t vone = vdupq_n_u64(1);\n    uint64x2_t vresult = vone;\n\n    for (int i = 0; i < 64; i++) {\n        if (vgetq_lane_u64(vresult, 0) == x || vgetq_lane_u64(vresult, 1) == x) {\n            return true;\n        }\n        vresult = vmulq_u64(vresult, vn);\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (x == 1 && n == 1) return true;\n    if (n == 1 && x != 1) return false;\n\n    uint64x2_t vn = vdupq_n_u64(n);\n    uint64x2_t vx = vdupq_n_u64(x);\n    uint64x2_t vone = vdupq_n_u64(1);\n    uint64x2_t vresult = vone;\n\n    for (uint64_t i = 0; i < 64; i++) {\n        if (vgetq_lane_u64(vresult, 0) == x || vgetq_lane_u64(vresult, 1) == x) {\n            return true;\n        }\n        vresult = vmulq_u64(vresult, vn);\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (x == 1 && n == 1) return true;\n    if (n == 1) return false;\n\n    uint64x2_t vx = vdupq_n_u64(x);\n    uint64x2_t vn = vdupq_n_u64(n);\n    uint64x2_t v1 = vdupq_n_u64(1);\n    uint64x2_t vresult = v1;\n\n    for (int i = 0; i < 64; i++) {\n        if (vgetq_lane_u64(vresult, 0) == x || vgetq_lane_u64(vresult, 1) == x) {\n            return true;\n        }\n        vresult = vmulq_u64(vresult, vn);\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (x == 1 && n == 1) return true;\n    if (n == 1) return false;\n\n    uint64x2_t vx = vdupq_n_u64(x);\n    uint64x2_t vn = vdupq_n_u64(n);\n    uint64x2_t vone = vdupq_n_u64(1);\n    uint64x2_t vresult = vone;\n\n    for (int i = 0; i < 64; i++) {\n        if (vgetq_lane_u64(vresult, 0) == x || vgetq_lane_u64(vresult, 1) == x) {\n            return true;\n        }\n        vresult = vmulq_u64(vresult, vn);\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (x == 1 && n == 1) return true;\n    if (n == 1) return false;\n\n    uint64x2_t vn = vdupq_n_u64(n);\n    uint64x2_t vx = vdupq_n_u64(x);\n    uint64x2_t vone = vdupq_n_u64(1);\n    uint64x2_t vresult = vone;\n\n    for (int i = 0; i < 64; i++) {\n        if (vgetq_lane_u64(vresult, 0) == x || vgetq_lane_u64(vresult, 1) == x) {\n            return true;\n        }\n        vresult = vmulq_u64(vresult, vn);\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_100_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nint hex_key_simd(const std::string &num) {\n    const char *hexChars = num.c_str();\n    int count = 0;\n    size_t length = num.length();\n\n    uint8x16_t primeMask = vdupq_n_u8(0);\n    primeMask = vsetq_lane_u8(1, primeMask, '2');\n    primeMask = vsetq_lane_u8(1, primeMask, '3');\n    primeMask = vsetq_lane_u8(1, primeMask, '5');\n    primeMask = vsetq_lane_u8(1, primeMask, '7');\n    primeMask = vsetq_lane_u8(1, primeMask, 'B');\n    primeMask = vsetq_lane_u8(1, primeMask, 'D');\n\n    for (size_t i = 0; i < length; i += 16) {\n        size_t remaining = length - i;\n        size_t chunkSize = (remaining >= 16) ? 16 : remaining;\n\n        uint8x16_t chunk = vld1q_u8(hexChars + i);\n        uint8x16_t masked = vandq_u8(chunk, primeMask);\n\n        uint8x16_t result = vceqq_u8(masked, primeMask);\n        uint64x2_t sum = vpaddlq_u32(vpaddlq_u16(vpaddlq_u8(result)));\n        sum = vaddq_u64(vgetq_high_u64(sum), vgetq_low_u64(sum));\n        count += vgetq_lane_u64(sum, 0);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nint hex_key_simd(const std::string &num) {\n    const char *hexChars = num.c_str();\n    int count = 0;\n    size_t length = num.length();\n\n    uint8x16_t prime_mask = vdupq_n_u8(0);\n    prime_mask = vsetq_lane_u8(1, prime_mask, '2');\n    prime_mask = vsetq_lane_u8(1, prime_mask, '3');\n    prime_mask = vsetq_lane_u8(1, prime_mask, '5');\n    prime_mask = vsetq_lane_u8(1, prime_mask, '7');\n    prime_mask = vsetq_lane_u8(1, prime_mask, 'B');\n    prime_mask = vsetq_lane_u8(1, prime_mask, 'D');\n\n    for (size_t i = 0; i < length; i += 16) {\n        size_t chunk_size = std::min(length - i, static_cast<size_t>(16));\n        uint8x16_t chunk = vld1q_u8(&hexChars[i]);\n        uint8x16_t masked = vandq_u8(chunk, prime_mask);\n        uint8x16_t result = vceqq_u8(masked, prime_mask);\n\n        uint64x2_t reduced = vpaddlq_u32(vpaddlq_u16(vpaddlq_u8(result)));\n        count += vgetq_lane_u64(reduced, 0) + vgetq_lane_u64(reduced, 1);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nint hex_key_simd(const std::string &num) {\n    const char *hexChars = num.c_str();\n    size_t length = num.length();\n    int count = 0;\n\n    uint8x16_t prime_mask = {\n        0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0\n    };\n\n    for (size_t i = 0; i <= length - 16; i += 16) {\n        uint8x16_t chunk = vld1q_u8(&hexChars[i]);\n        uint8x16_t is_prime = vandq_u8(chunk, prime_mask);\n        uint8x16_t result = vcgeq_u8(is_prime, vdupq_n_u8(1));\n        count += vaddvq_u8(result);\n    }\n\n    for (size_t i = (length / 16) * 16; i < length; ++i) {\n        char c = hexChars[i];\n        if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nint hex_key_simd(const std::string &num) {\n    const char *hexChars = num.c_str();\n    size_t length = num.length();\n    int count = 0;\n\n    uint8x16_t prime_mask = {\n        0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0\n    };\n\n    for (size_t i = 0; i < length; i += 16) {\n        size_t chunk_size = (length - i < 16) ? length - i : 16;\n        uint8x16_t chunk = vld1q_u8(&hexChars[i]);\n\n        uint8x16_t is_prime = vandq_u8(chunk, prime_mask);\n        uint8x16_t result = vceqq_u8(is_prime, prime_mask);\n\n        uint64x2_t sum = vpaddlq_u32(vpaddlq_u16(vpaddlq_u8(result)));\n        count += vgetq_lane_u64(sum, 0) + vgetq_lane_u64(sum, 1);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nint hex_key_simd(const std::string &num) {\n    const char *hexChars = num.c_str();\n    int length = num.length();\n    int count = 0;\n\n    uint8x16_t primeMask = vdupq_n_u8(0);\n    primeMask = vsetq_lane_u8(1, primeMask, '2');\n    primeMask = vsetq_lane_u8(1, primeMask, '3');\n    primeMask = vsetq_lane_u8(1, primeMask, '5');\n    primeMask = vsetq_lane_u8(1, primeMask, '7');\n    primeMask = vsetq_lane_u8(1, primeMask, 'B');\n    primeMask = vsetq_lane_u8(1, primeMask, 'D');\n\n    for (int i = 0; i < length; i += 16) {\n        int chunkSize = std::min(16, length - i);\n        uint8x16_t chunk = vld1q_u8(hexChars + i);\n        uint8x16_t masked = vandq_u8(chunk, primeMask);\n        uint8x16_t result = vceqq_u8(masked, primeMask);\n\n        uint64x2_t reduced = vpaddlq_u32(vpaddlq_u16(vpaddlq_u8(result)));\n        count += vgetq_lane_u64(reduced, 0) + vgetq_lane_u64(reduced, 1);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_101_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nbool is_happy_simd(const std::string &s) {\n    if (s.length() < 3) {\n        return false;\n    }\n\n    uint8x16_t prev_prev = vdupq_n_u8(0);\n    uint8x16_t prev = vdupq_n_u8(0);\n    uint8x16_t current = vdupq_n_u8(0);\n\n    prev_prev = vsetq_lane_u8(s[0], prev_prev, 0);\n    prev = vsetq_lane_u8(s[1], prev, 0);\n\n    for (size_t i = 2; i < s.length(); ++i) {\n        current = vsetq_lane_u8(s[i], current, 0);\n\n        uint8x16_t distinct1 = vceqq_u8(prev_prev, prev);\n        uint8x16_t distinct2 = vceqq_u8(prev, current);\n        uint8x16_t distinct3 = vceqq_u8(prev_prev, current);\n\n        uint8x16_t distinct = vorrq_u8(distinct1, distinct2);\n        distinct = vorrq_u8(distinct, distinct3);\n\n        if (vgetq_lane_u8(distinct, 0)) {\n            return false;\n        }\n\n        prev_prev = prev;\n        prev = current;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nbool is_happy_simd(const std::string &s) {\n    if (s.length() < 3) {\n        return false;\n    }\n\n    size_t len = s.length();\n    const char* str = s.c_str();\n\n    for (size_t i = 0; i <= len - 3; i += 3) {\n        uint8x8_t chunk = vld1_u8(&str[i]);\n        uint8x8_t distinct = vtbl2_u8(chunk, vcreate_u8(0x0302010003020100ULL));\n\n        uint8x8_t mask1 = vceq_u8(vget_low_u8(distinct), vget_high_u8(distinct));\n        uint8x8_t mask2 = vceq_u8(vget_low_u8(distinct), vdup_n_u8(distinct[2]));\n        uint8x8_t mask3 = vceq_u8(vget_high_u8(distinct), vdup_n_u8(distinct[2]));\n\n        uint8x8_t result = vorr_u8(vorr_u8(mask1, mask2), mask3);\n\n        if (vget_lane_u8(result, 0) || vget_lane_u8(result, 1) || vget_lane_u8(result, 2)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s) {\n    if (s.length() < 3) {\n        return false;\n    }\n\n    size_t len = s.length();\n    const char* str = s.c_str();\n\n    for (size_t i = 0; i <= len - 3; i += 3) {\n        uint8x8_t chunk = vld1_u8(&str[i]);\n        uint8x8_t distinct = vtbl1_u8(chunk, vcreate_u8(0x0302010003020100ULL));\n\n        uint8x8_t mask1 = vceq_u8(vget_low_u8(distinct), vget_high_u8(distinct));\n        uint8x8_t mask2 = vceq_u8(vget_low_u8(distinct), vdup_n_u8(distinct[0]));\n        uint8x8_t mask3 = vceq_u8(vget_high_u8(distinct), vdup_n_u8(distinct[1]));\n\n        uint64_t result = vget_lane_u64(vreinterpret_u64_u8(vand_u8(vand_u8(mask1, mask2), mask3)), 0);\n\n        if (result != 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <cstring>\n\nbool is_happy_simd(const std::string &s) {\n    if (s.length() < 3) {\n        return false;\n    }\n\n    size_t len = s.length();\n    const char* str = s.c_str();\n\n    for (size_t i = 0; i <= len - 3; i += 3) {\n        uint8x8_t chunk = vld1_u8(&str[i]);\n        uint8x8_t distinct = vtbl1_u8(chunk, vcreate_u8(0x0302010003020100ULL));\n\n        uint8x8_t mask = vceq_u8(distinct, chunk);\n        if (vget_lane_u8(mask, 0) && vget_lane_u8(mask, 1) && vget_lane_u8(mask, 2)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nbool is_happy_simd(const std::string &s) {\n    if (s.length() < 3) {\n        return false;\n    }\n\n    size_t len = s.length();\n    const char* str = s.c_str();\n\n    for (size_t i = 0; i <= len - 3; i += 3) {\n        uint8x8_t chunk = vld1_u8(&str[i]);\n        uint8x8_t distinct = vtbl1_u8(chunk, vcreate_u8(0x0302010006050400ULL));\n\n        uint8x8_t mask = vceq_u8(chunk, distinct);\n        if (vget_lane_u8(mask, 0) && vget_lane_u8(mask, 1) && vget_lane_u8(mask, 2)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <cstring>\n#include <cmath>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length_simd(const std::string & str) {\n    int len = str.length();\n    return is_prime(len);\n}\n```"}
{"task_id": "SimdBench_102_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <cstring>\n#include <cmath>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length_simd(const std::string & str) {\n    int len = str.length();\n    return is_prime(len);\n}\n```"}
{"task_id": "SimdBench_102_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <cstring>\n#include <cmath>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length_simd(const std::string & str) {\n    int len = str.length();\n    return is_prime(len);\n}\n```"}
{"task_id": "SimdBench_102_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <cstring>\n#include <cmath>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length_simd(const std::string & str) {\n    int len = str.length();\n    return is_prime(len);\n}\n```"}
{"task_id": "SimdBench_102_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <cstring>\n#include <cmath>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length_simd(const std::string & str) {\n    int len = str.length();\n    return is_prime(len);\n}\n```"}
{"task_id": "SimdBench_103_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nstd::string solve_simd(uint64_t N) {\n    uint32x4_t v = vdupq_n_u32(0);\n    uint32x4_t vN = vdupq_n_u32(N);\n\n    while (N > 0) {\n        uint32x4_t digit = vandq_u32(vN, vdupq_n_u32(0xF));\n        v = vaddq_u32(v, digit);\n        vN = vshrq_n_u32(vN, 4);\n        N /= 10;\n    }\n\n    uint32_t sum = vgetq_lane_u32(v, 0) + vgetq_lane_u32(v, 1) + vgetq_lane_u32(v, 2) + vgetq_lane_u32(v, 3);\n\n    std::string binary = \"\";\n    while (sum > 0) {\n        binary = (sum % 2 == 0 ? \"0\" : \"1\") + binary;\n        sum /= 2;\n    }\n\n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_103_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n#include <cstdint>\n\nstd::string solve_simd(uint64_t N) {\n    uint32x2_t v = vdup_n_u32(0);\n    while (N > 0) {\n        uint32x2_t digits = vdup_n_u32(N % 10);\n        v = vadd_u32(v, digits);\n        N /= 10;\n    }\n\n    uint32_t sum = vget_lane_u32(v, 0) + vget_lane_u32(v, 1);\n\n    std::string binary = \"\";\n    while (sum > 0) {\n        binary = (sum % 2 == 0 ? \"0\" : \"1\") + binary;\n        sum /= 2;\n    }\n\n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_103_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nstd::string solve_simd(uint64_t N) {\n    uint64_t sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n\n    uint64x1_t sum_vector = vcreate_u64(sum);\n    uint64x1_t mask = vcreate_u64(1);\n    std::string binary_string = \"\";\n\n    for (int i = 0; i < 64; ++i) {\n        uint64x1_t result = vand_u64(sum_vector, mask);\n        uint64_t bit = vget_lane_u64(result, 0);\n        binary_string = (bit ? \"1\" : \"0\") + binary_string;\n        sum_vector = vshr_n_u64(sum_vector, 1);\n    }\n\n    // Remove leading zeros\n    size_t start = binary_string.find('1');\n    if (start != std::string::npos) {\n        return binary_string.substr(start);\n    }\n    return \"0\";\n}\n```"}
{"task_id": "SimdBench_103_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n#include <cstdint>\n\nstd::string solve_simd(uint64_t N) {\n    uint64_t sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n\n    std::string binary_result = \"\";\n    while (sum > 0) {\n        binary_result = (sum % 2 == 0 ? \"0\" : \"1\") + binary_result;\n        sum /= 2;\n    }\n\n    return binary_result.empty() ? \"0\" : binary_result;\n}\n```"}
{"task_id": "SimdBench_103_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nstd::string solve_simd(uint64_t N) {\n    uint64_t sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n\n    uint64x1_t sum_vector = vdup_n_u64(sum);\n    uint64x1_t mask = vdup_n_u64(1);\n    std::string binary_string = \"\";\n\n    for (int i = 0; i < 64; ++i) {\n        uint64x1_t result = vand_u64(sum_vector, mask);\n        if (vget_lane_u64(result, 0) == 1) {\n            binary_string = \"1\" + binary_string;\n        } else {\n            binary_string = \"0\" + binary_string;\n        }\n        sum_vector = vshr_n_u64(sum_vector, 1);\n    }\n\n    // Remove leading zeros\n    size_t start = binary_string.find('1');\n    if (start != std::string::npos) {\n        return binary_string.substr(start);\n    }\n    return \"0\";\n}\n```"}
{"task_id": "SimdBench_104_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    int sum = 0;\n\n    for (size_t i = 1; i < lst.size(); i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        int32x4_t even_mask = vdupq_n_s32(1);\n        uint32x4_t even_vec = vandq_u32(vreinterpretq_u32_s32(vec), vreinterpretq_u32_s32(even_mask));\n        even_vec = vceqq_s32(vreinterpretq_s32_u32(even_vec), vdupq_n_s32(0));\n        vec = vandq_s32(vec, even_vec);\n        sum_vec = vaddq_s32(sum_vec, vec);\n    }\n\n    sum += vgetq_lane_s32(sum_vec, 0);\n    sum += vgetq_lane_s32(sum_vec, 1);\n    sum += vgetq_lane_s32(sum_vec, 2);\n    sum += vgetq_lane_s32(sum_vec, 3);\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    int sum = 0;\n\n    for (size_t i = 1; i < lst.size(); i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        int32x4_t even_mask = vdupq_n_s32(1);\n        uint32x4_t even_vec = vandq_u32(vreinterpretq_u32_s32(vec), vreinterpretq_u32_s32(even_mask));\n        int32x4_t even_elements = vreinterpretq_s32_u32(vceqq_s32(even_vec, vdupq_n_s32(0)));\n        sum_vec = vaddq_s32(sum_vec, even_elements);\n    }\n\n    sum += vgetq_lane_s32(sum_vec, 0);\n    sum += vgetq_lane_s32(sum_vec, 1);\n    sum += vgetq_lane_s32(sum_vec, 2);\n    sum += vgetq_lane_s32(sum_vec, 3);\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int32x4_t sumv = vdupq_n_s32(0);\n    int sum = 0;\n\n    for (size_t i = 1; i < lst.size(); i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        int32x4_t mask = vdupq_n_s32(1);\n        uint32x4_t even_mask = vceqzq_s32(vandq_s32(vec, mask));\n        int32x4_t even_elements = vbslq_s32(even_mask, vec, vdupq_n_s32(0));\n        sumv = vaddq_s32(sumv, even_elements);\n    }\n\n    sum += vgetq_lane_s32(sumv, 0);\n    sum += vgetq_lane_s32(sumv, 1);\n    sum += vgetq_lane_s32(sumv, 2);\n    sum += vgetq_lane_s32(sumv, 3);\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int32x4_t sumv = vdupq_n_s32(0);\n    int sum = 0;\n\n    for (size_t i = 1; i < lst.size(); i += 4) {\n        int32x4_t chunk = vld1q_s32(&lst[i]);\n        int32x4_t mask = vdupq_n_s32(1);\n        int32x4_t even = vandq_s32(chunk, mask);\n        even = vceqq_s32(even, vdupq_n_s32(0));\n        sumv = vaddq_s32(sumv, vandq_s32(chunk, even));\n    }\n\n    sum += vgetq_lane_s32(sumv, 0);\n    sum += vgetq_lane_s32(sumv, 1);\n    sum += vgetq_lane_s32(sumv, 2);\n    sum += vgetq_lane_s32(sumv, 3);\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    int sum = 0;\n\n    for (size_t i = 1; i < lst.size(); i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        int32x4_t even_mask = vdupq_n_s32(1);\n        uint32x4_t even_vec = vandq_u32(vreinterpretq_u32_s32(vec), vreinterpretq_u32_s32(even_mask));\n        even_vec = vceqq_s32(vreinterpretq_s32_u32(even_vec), vdupq_n_s32(0));\n        vec = vbslq_s32(even_vec, vec, vdupq_n_s32(0));\n        sum_vec = vaddq_s32(sum_vec, vec);\n    }\n\n    sum += vgetq_lane_s32(sum_vec, 0);\n    sum += vgetq_lane_s32(sum_vec, 1);\n    sum += vgetq_lane_s32(sum_vec, 2);\n    sum += vgetq_lane_s32(sum_vec, 3);\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_105_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n#include <cstring>\n\nstd::string encrypt_simd(const std::string &s) {\n    std::string result(s.size(), '\\0');\n    size_t len = s.size();\n    size_t i = 0;\n\n    uint8x16_t v_shift = vdupq_n_u8(4); // Shift value for each byte\n\n    for (; i <= len - 16; i += 16) {\n        uint8x16_t v_input = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n        uint8x16_t v_output = vaddq_u8(v_input, v_shift);\n\n        // Handle wrap-around for characters beyond 'z'\n        uint8x16_t v_mask = vcgtq_u8(v_output, vdupq_n_u8('z'));\n        v_output = vbslq_u8(v_mask, vsubq_u8(v_output, vdupq_n_u8(26)), v_output);\n\n        // Handle wrap-around for characters beyond 'Z' and before 'a'\n        v_mask = vcgtq_u8(v_output, vdupq_n_u8('Z')) & vcltq_u8(v_output, vdupq_n_u8('a'));\n        v_output = vbslq_u8(v_mask, vsubq_u8(v_output, vdupq_n_u8(26)), v_output);\n\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), v_output);\n    }\n\n    // Handle remaining characters\n    for (; i < len; ++i) {\n        char c = s[i];\n        if (c >= 'a' && c <= 'z') {\n            c = (c - 'a' + 4) % 26 + 'a';\n        } else if (c >= 'A' && c <= 'Z') {\n            c = (c - 'A' + 4) % 26 + 'A';\n        }\n        result[i] = c;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n#include <cstring>\n\nstd::string encrypt_simd(const std::string &s) {\n    std::string result(s.size(), '\\0');\n    size_t len = s.size();\n    size_t i = 0;\n\n    for (; i <= len - 16; i += 16) {\n        uint8x16_t chunk = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n        uint8x16_t encrypted_chunk = vaddq_u8(chunk, vdupq_n_u8(8));\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), encrypted_chunk);\n    }\n\n    for (; i < len; ++i) {\n        result[i] = s[i] + 8;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n#include <cstring>\n\nstd::string encrypt_simd(const std::string &s) {\n    size_t length = s.length();\n    std::string encrypted(length, '\\0');\n\n    size_t i = 0;\n    for (; i <= length - 16; i += 16) {\n        uint8x16_t chunk = vld1q_u8(&s[i]);\n        uint8x16_t encrypted_chunk = vqaddq_u8(chunk, vdupq_n_u8(4)); // Shift by 4\n        vst1q_u8(&encrypted[i], encrypted_chunk);\n    }\n\n    for (; i < length; ++i) {\n        encrypted[i] = s[i] + 4; // Shift by 4\n    }\n\n    return encrypted;\n}\n```"}
{"task_id": "SimdBench_105_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n#include <cstring>\n\nstd::string encrypt_simd(const std::string &s) {\n    std::string result(s.size(), '\\0');\n    size_t len = s.size();\n    size_t i = 0;\n\n    for (; i <= len - 16; i += 16) {\n        uint8x16_t chunk = vld1q_u8(&s[i]);\n        uint8x16_t encrypted_chunk = vqaddq_u8(chunk, vdupq_n_u8(4));\n        vst1q_u8(&result[i], encrypted_chunk);\n    }\n\n    for (; i < len; ++i) {\n        result[i] = s[i] + 4;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n#include <cstring>\n\nstd::string encrypt_simd(const std::string &s) {\n    size_t length = s.length();\n    std::string encrypted(length, ' ');\n\n    size_t i = 0;\n    for (; i <= length - 16; i += 16) {\n        uint8x16_t chunk = vld1q_u8(&s[i]);\n        uint8x16_t encrypted_chunk = vaddq_u8(chunk, vdupq_n_u8(8));\n        vst1q_u8(&encrypted[i], encrypted_chunk);\n    }\n\n    for (; i < length; ++i) {\n        encrypted[i] = s[i] + 8;\n    }\n\n    return encrypted;\n}\n```"}
{"task_id": "SimdBench_106_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n#include <cctype>\n\nstd::string encode_simd(const std::string &message) {\n    std::string encoded(message.size(), ' ');\n    size_t len = message.size();\n\n    for (size_t i = 0; i < len; i += 16) {\n        size_t block_size = (len - i < 16) ? len - i : 16;\n        uint8x16_t chunk = vld1q_u8(&message[i]);\n\n        uint8x16_t is_lower = vcltq_u8(chunk, vdupq_n_u8('a' - 1));\n        uint8x16_t is_upper = vcltq_u8(chunk, vdupq_n_u8('A' - 1));\n        uint8x16_t is_letter = vorrq_u8(is_lower, is_upper);\n\n        uint8x16_t to_upper = vandq_u8(chunk, vdupq_n_u8(~('a' - 'A')));\n        uint8x16_t to_lower = vorrq_u8(chunk, vdupq_n_u8('a' - 'A'));\n\n        uint8x16_t swapped_case = vbslq_u8(is_letter, to_upper, to_lower);\n\n        uint8x16_t vowels = vdupq_n_u8('a');\n        vowels = vsetq_lane_u8('e', vowels, 1);\n        vowels = vsetq_lane_u8('i', vowels, 2);\n        vowels = vsetq_lane_u8('o', vowels, 3);\n        vowels = vsetq_lane_u8('u', vowels, 4);\n\n        uint8x16_t is_vowel = vceqq_u8(chunk, vowels);\n        uint8x16_t replaced_vowels = vaddq_u8(chunk, vdupq_n_u8(2));\n\n        uint8x16_t result = vbslq_u8(is_vowel, replaced_vowels, swapped_case);\n\n        vst1q_u8(&encoded[i], result);\n    }\n\n    return encoded;\n}\n```"}
{"task_id": "SimdBench_106_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n#include <cctype>\n\nstd::string encode_simd(const std::string &message) {\n    std::string encoded(message.size(), ' ');\n    size_t len = message.size();\n    size_t i = 0;\n\n    for (; i <= len - 16; i += 16) {\n        uint8x16_t chunk = vld1q_u8(&message[i]);\n\n        // Swap case\n        uint8x16_t is_lower = vcgtq_u8(chunk, vdupq_n_u8('Z'));\n        uint8x16_t is_upper = vcgtq_u8(vdupq_n_u8('a'), chunk);\n        uint8x16_t is_alpha = vandq_u8(is_lower, is_upper);\n        uint8x16_t swapped_case = vorrq_u8(vandq_u8(is_alpha, vxorq_u8(chunk, vdupq_n_u8(32))), vandq_u8(vmvnq_u8(is_alpha), chunk));\n\n        // Replace vowels\n        uint8x16_t is_a = vceqq_u8(chunk, vdupq_n_u8('a'));\n        uint8x16_t is_e = vceqq_u8(chunk, vdupq_n_u8('e'));\n        uint8x16_t is_i = vceqq_u8(chunk, vdupq_n_u8('i'));\n        uint8x16_t is_o = vceqq_u8(chunk, vdupq_n_u8('o'));\n        uint8x16_t is_u = vceqq_u8(chunk, vdupq_n_u8('u'));\n        uint8x16_t is_vowel = vorrq_u8(vorrq_u8(vorrq_u8(is_a, is_e), vorrq_u8(is_i, is_o)), is_u);\n        uint8x16_t replaced_vowels = vorrq_u8(vandq_u8(is_vowel, vaddq_u8(chunk, vdupq_n_u8(2))), vandq_u8(vmvnq_u8(is_vowel), chunk));\n\n        // Combine results\n        uint8x16_t result = vorrq_u8(vandq_u8(is_vowel, replaced_vowels), vandq_u8(vmvnq_u8(is_vowel), swapped_case));\n\n        vst1q_u8(&encoded[i], result);\n    }\n\n    // Handle remaining characters\n    for (; i < len; ++i) {\n        char c = message[i];\n        if (islower(c)) {\n            c = toupper(c);\n        } else if (isupper(c)) {\n            c = tolower(c);\n        }\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            c += 2;\n        }\n        encoded[i] = c;\n    }\n\n    return encoded;\n}\n```"}
{"task_id": "SimdBench_106_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n#include <cstring>\n\nstd::string encode_simd(const std::string &message) {\n    std::string encoded(message.size(), ' ');\n    size_t len = message.size();\n\n    uint8x16_t vowels = vdupq_n_u8(0);\n    vowels = vsetq_lane_u8('a', vowels, 0);\n    vowels = vsetq_lane_u8('e', vowels, 1);\n    vowels = vsetq_lane_u8('i', vowels, 2);\n    vowels = vsetq_lane_u8('o', vowels, 3);\n    vowels = vsetq_lane_u8('u', vowels, 4);\n    vowels = vsetq_lane_u8('A', vowels, 5);\n    vowels = vsetq_lane_u8('E', vowels, 6);\n    vowels = vsetq_lane_u8('I', vowels, 7);\n    vowels = vsetq_lane_u8('O', vowels, 8);\n    vowels = vsetq_lane_u8('U', vowels, 9);\n\n    uint8x16_t replacements = vdupq_n_u8(0);\n    replacements = vsetq_lane_u8('c', replacements, 0);\n    replacements = vsetq_lane_u8('g', replacements, 1);\n    replacements = vsetq_lane_u8('k', replacements, 2);\n    replacements = vsetq_lane_u8('q', replacements, 3);\n    replacements = vsetq_lane_u8('w', replacements, 4);\n    replacements = vsetq_lane_u8('C', replacements, 5);\n    replacements = vsetq_lane_u8('G', replacements, 6);\n    replacements = vsetq_lane_u8('K', replacements, 7);\n    replacements = vsetq_lane_u8('Q', replacements, 8);\n    replacements = vsetq_lane_u8('W', replacements, 9);\n\n    for (size_t i = 0; i < len; i += 16) {\n        size_t block_size = (len - i < 16) ? len - i : 16;\n        uint8x16_t chunk = vld1q_u8(message.data() + i);\n\n        uint8x16_t is_vowel = vceqq_u8(chunk, vowels);\n        uint8x16_t replaced = vbslq_u8(is_vowel, replacements, chunk);\n\n        uint8x16_t is_lower = vandq_u8(chunk, vdupq_n_u8(0x20));\n        uint8x16_t swapped_case = veorq_u8(chunk, is_lower);\n\n        uint8x16_t result = vbslq_u8(is_vowel, replaced, swapped_case);\n\n        vst1q_u8(const_cast<char*>(encoded.data()) + i, result);\n    }\n\n    return encoded;\n}\n```"}
{"task_id": "SimdBench_106_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n#include <cctype>\n\nstd::string encode_simd(const std::string &message) {\n    std::string encoded(message.size(), ' ');\n    size_t len = message.size();\n\n    for (size_t i = 0; i < len; i += 16) {\n        size_t chunk_size = (len - i < 16) ? len - i : 16;\n        uint8x16_t chunk = vld1q_u8(&message[i]);\n\n        uint8x16_t is_lower = vcltq_u8(chunk, vdupq_n_u8('a'));\n        uint8x16_t is_upper = vcltq_u8(chunk, vdupq_n_u8('A'));\n\n        uint8x16_t to_upper = vandq_u8(chunk, vdupq_n_u8(0xDF));\n        uint8x16_t to_lower = vandq_u8(chunk, vdupq_n_u8(0xBF));\n\n        uint8x16_t vowels = vdupq_n_u8('a');\n        uint8x16_t is_vowel = vorrq_u8(veq_u8(chunk, vdupq_n_u8('a')), veq_u8(chunk, vdupq_n_u8('e')));\n        is_vowel = vorrq_u8(is_vowel, veq_u8(chunk, vdupq_n_u8('i')));\n        is_vowel = vorrq_u8(is_vowel, veq_u8(chunk, vdupq_n_u8('o')));\n        is_vowel = vorrq_u8(is_vowel, veq_u8(chunk, vdupq_n_u8('u')));\n        is_vowel = vorrq_u8(is_vowel, veq_u8(chunk, vdupq_n_u8('A')));\n        is_vowel = vorrq_u8(is_vowel, veq_u8(chunk, vdupq_n_u8('E')));\n        is_vowel = vorrq_u8(is_vowel, veq_u8(chunk, vdupq_n_u8('I')));\n        is_vowel = vorrq_u8(is_vowel, veq_u8(chunk, vdupq_n_u8('O')));\n        is_vowel = vorrq_u8(is_vowel, veq_u8(chunk, vdupq_n_u8('U')));\n\n        uint8x16_t replace_vowel = vaddq_u8(chunk, vdupq_n_u8(2));\n\n        uint8x16_t result = vbslq_u8(is_lower, to_upper, to_lower);\n        result = vbslq_u8(is_vowel, replace_vowel, result);\n\n        vst1q_u8(&encoded[i], result);\n    }\n\n    return encoded;\n}\n```"}
{"task_id": "SimdBench_106_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n#include <cctype>\n\nstd::string encode_simd(const std::string &message) {\n    std::string encoded(message.size(), ' ');\n    size_t i = 0;\n\n    for (; i <= message.size() - 16; i += 16) {\n        uint8x16_t chunk = vld1q_u8(&message[i]);\n\n        uint8x16_t is_lower = vcltq_u8(chunk, vdupq_n_u8('a' - 1));\n        uint8x16_t is_upper = vcltq_u8(chunk, vdupq_n_u8('A' - 1));\n        uint8x16_t is_alpha = vorrq_u8(is_lower, is_upper);\n\n        uint8x16_t to_upper = vandq_u8(chunk, vdupq_n_u8(' '));\n        uint8x16_t to_lower = vandq_u8(chunk, vdupq_n_u8(' '));\n\n        uint8x16_t vowels = vdupq_n_u8(0);\n        vowels = vsetq_lane_u8(vowels, 'a', 0);\n        vowels = vsetq_lane_u8(vowels, 'e', 1);\n        vowels = vsetq_lane_u8(vowels, 'i', 2);\n        vowels = vsetq_lane_u8(vowels, 'o', 3);\n        vowels = vsetq_lane_u8(vowels, 'u', 4);\n        vowels = vsetq_lane_u8(vowels, 'A', 5);\n        vowels = vsetq_lane_u8(vowels, 'E', 6);\n        vowels = vsetq_lane_u8(vowels, 'I', 7);\n        vowels = vsetq_lane_u8(vowels, 'O', 8);\n        vowels = vsetq_lane_u8(vowels, 'U', 9);\n\n        uint8x16_t is_vowel = vceqq_u8(chunk, vowels);\n        uint8x16_t replace_vowel = vaddq_u8(chunk, vdupq_n_u8(2));\n\n        uint8x16_t result = vbslq_u8(is_vowel, replace_vowel, chunk);\n        result = vbslq_u8(is_lower, to_upper, result);\n        result = vbslq_u8(is_upper, to_lower, result);\n\n        vst1q_u8(&encoded[i], result);\n    }\n\n    for (; i < message.size(); ++i) {\n        char c = message[i];\n        if (std::islower(c)) {\n            c = std::toupper(c);\n        } else if (std::isupper(c)) {\n            c = std::tolower(c);\n        }\n        if (std::strchr(\"aeiouAEIOU\", c)) {\n            c += 2;\n        }\n        encoded[i] = c;\n    }\n\n    return encoded;\n}\n```"}
{"task_id": "SimdBench_107_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_map_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        size_t len = key.length();\n        size_t i;\n\n        for (i = 0; i <= len - 16; i += 16) {\n            uint8x16_t chunk = vld1q_u8(&key[i]);\n            uint8x16_t lower_mask = vcgtq_u8(chunk, vdupq_n_u8('Z'));\n            uint8x16_t upper_mask = vcltq_u8(chunk, vdupq_n_u8('a'));\n            uint8x16_t alpha_mask = vorrq_u8(lower_mask, upper_mask);\n\n            if (vminvq_u8(alpha_mask) == 0) {\n                all_lower = false;\n                all_upper = false;\n                break;\n            }\n\n            uint8x16_t lower_case = vandq_u8(chunk, vdupq_n_u8(' '));\n            if (vminvq_u8(lower_case) != 0) {\n                all_upper = false;\n            }\n\n            uint8x16_t upper_case = vandq_u8(chunk, vdupq_n_u8('_'));\n            if (vminvq_u8(upper_case) != 0) {\n                all_lower = false;\n            }\n        }\n\n        for (; i < len; ++i) {\n            if (!std::isalpha(key[i])) {\n                all_lower = false;\n                all_upper = false;\n                break;\n            }\n            if (std::islower(key[i])) {\n                all_upper = false;\n            } else {\n                all_lower = false;\n            }\n        }\n\n        if (!all_lower && !all_upper) return false;\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_map_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        size_t len = key.length();\n\n        for (size_t i = 0; i < len; i += 16) {\n            size_t chunk_size = (len - i < 16) ? len - i : 16;\n            uint8x16_t chunk = vld1q_u8(reinterpret_cast<const uint8_t*>(key.data()) + i);\n\n            uint8x16_t lower_mask = vcgtq_u8(chunk, vdupq_n_u8('Z'));\n            uint8x16_t upper_mask = vcltq_u8(chunk, vdupq_n_u8('a'));\n\n            uint8x16_t lower_case = vandq_u8(chunk, lower_mask);\n            uint8x16_t upper_case = vandq_u8(chunk, upper_mask);\n\n            if (vmaxvq_u8(lower_case) > 'z' || vminvq_u8(lower_case) < 'a') {\n                all_lower = false;\n            }\n            if (vmaxvq_u8(upper_case) > 'Z' || vminvq_u8(upper_case) < 'A') {\n                all_upper = false;\n            }\n\n            if (!all_lower && !all_upper) return false;\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_map_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        size_t len = key.length();\n\n        for (size_t i = 0; i < len; i += 16) {\n            size_t chunk_size = std::min(len - i, 16UL);\n            uint8x16_t chunk = vld1q_u8(key.data() + i);\n\n            uint8x16_t lower_mask = vcgtq_u8(chunk, vdupq_n_u8('Z'));\n            uint8x16_t upper_mask = vcltq_u8(chunk, vdupq_n_u8('a'));\n\n            if (vminvq_u8(lower_mask) == 0) {\n                all_lower = false;\n            }\n            if (vminvq_u8(upper_mask) == 0) {\n                all_upper = false;\n            }\n\n            if (!all_lower && !all_upper) {\n                return false;\n            }\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        size_t len = key.length();\n\n        for (size_t i = 0; i < len; i += 16) {\n            size_t chunk_size = (len - i < 16) ? len - i : 16;\n            uint8x16_t chunk = vld1q_u8(reinterpret_cast<const uint8_t*>(&key[i]));\n\n            uint8x16_t lower_mask = vcgtq_u8(chunk, vdupq_n_u8('Z'));\n            uint8x16_t upper_mask = vcltq_u8(chunk, vdupq_n_u8('a'));\n\n            uint8x16_t lower_case = vandq_u8(chunk, lower_mask);\n            uint8x16_t upper_case = vandq_u8(chunk, upper_mask);\n\n            if (vmaxvq_u8(lower_case) > 'z' || vminvq_u8(lower_case) < 'a') {\n                all_lower = false;\n            }\n            if (vmaxvq_u8(upper_case) > 'Z' || vminvq_u8(upper_case) < 'A') {\n                all_upper = false;\n            }\n\n            if (!all_lower && !all_upper) return false;\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_map_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        size_t len = key.length();\n\n        for (size_t i = 0; i < len; i += 16) {\n            size_t chunk_size = (len - i < 16) ? len - i : 16;\n            uint8x16_t chunk = vld1q_u8(reinterpret_cast<const uint8_t*>(key.data()) + i);\n\n            uint8x16_t lower_mask = vcgtq_u8(chunk, vdupq_n_u8('Z'));\n            uint8x16_t upper_mask = vcltq_u8(chunk, vdupq_n_u8('a'));\n\n            uint8x16_t not_lower = vmvnq_u8(lower_mask);\n            uint8x16_t not_upper = vmvnq_u8(upper_mask);\n\n            if (vminvq_u8(not_lower)) all_lower = false;\n            if (vminvq_u8(not_upper)) all_upper = false;\n\n            if (!all_lower && !all_upper) return false;\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_108_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n < 2) return primes;\n\n    bool is_prime[n];\n    for (int i = 2; i < n; ++i) is_prime[i] = true;\n\n    int sqrt_n = static_cast<int>(sqrt(n));\n    for (int i = 2; i <= sqrt_n; ++i) {\n        if (is_prime[i]) {\n            for (int j = i * i; j < n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n\n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n < 2) return primes;\n\n    bool is_prime[n];\n    for (int i = 2; i < n; ++i) is_prime[i] = true;\n\n    int sqrt_n = static_cast<int>(sqrt(n));\n    for (int i = 2; i <= sqrt_n; ++i) {\n        if (is_prime[i]) {\n            for (int j = i * i; j < n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n\n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n < 2) return primes;\n\n    bool is_prime[n];\n    for (int i = 2; i < n; ++i) is_prime[i] = true;\n\n    int sqrt_n = static_cast<int>(sqrt(n));\n    for (int i = 2; i <= sqrt_n; ++i) {\n        if (is_prime[i]) {\n            for (int j = i * i; j < n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n\n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n < 2) return primes;\n\n    bool is_prime[n];\n    for (int i = 2; i < n; ++i) is_prime[i] = true;\n\n    int sqrt_n = static_cast<int>(sqrt(n));\n    for (int i = 2; i <= sqrt_n; ++i) {\n        if (is_prime[i]) {\n            for (int j = i * i; j < n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n\n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n < 2) return primes;\n\n    bool is_prime[n];\n    for (int i = 2; i < n; ++i) is_prime[i] = true;\n\n    int sqrt_n = static_cast<int>(sqrt(n));\n    for (int i = 2; i <= sqrt_n; ++i) {\n        if (is_prime[i]) {\n            for (int j = i * i; j < n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n\n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_109_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nint count_upper_simd(const std::string &s) {\n    int count = 0;\n    size_t len = s.length();\n    const char *str = s.c_str();\n\n    uint8x16_t vowels = vdupq_n_u8(0);\n    vowels = vsetq_lane_u8('A', vowels, 0);\n    vowels = vsetq_lane_u8('E', vowels, 1);\n    vowels = vsetq_lane_u8('I', vowels, 2);\n    vowels = vsetq_lane_u8('O', vowels, 3);\n    vowels = vsetq_lane_u8('U', vowels, 4);\n\n    for (size_t i = 0; i < len; i += 16) {\n        size_t remaining = len - i;\n        uint8x16_t chunk = vld1q_u8(&str[i]);\n        uint8x16_t mask = vceqq_u8(chunk, vowels);\n\n        uint8x8_t lower = vget_low_u8(mask);\n        uint8x8_t upper = vget_high_u8(mask);\n\n        uint64_t low_sum = vaddv_u8(lower);\n        uint64_t high_sum = vaddv_u8(upper);\n\n        count += (low_sum + high_sum) & 0x0101010101010101;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nint count_upper_simd(const std::string & s) {\n    int count = 0;\n    size_t len = s.length();\n    const char* data = s.c_str();\n\n    uint8x16_t vowels = {0, 'A', 0, 0, 'E', 0, 0, 'I', 0, 0, 0, 'O', 0, 0, 0, 'U'};\n    uint8x16_t mask = vdupq_n_u8(1);\n\n    for (size_t i = 0; i < len; i += 16) {\n        uint8x16_t chunk = vld1q_u8(&data[i]);\n        uint8x16_t even_indices = vandq_u8(chunk, vdupq_n_u8(0xAA));\n        uint8x16_t is_vowel = vceqq_u8(even_indices, vowels);\n        uint8x16_t result = vandq_u8(is_vowel, mask);\n\n        uint8_t temp[16];\n        vst1q_u8(temp, result);\n\n        for (size_t j = 0; j < 16; j += 2) {\n            if (temp[j]) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nint count_upper_simd(const std::string &s) {\n    int count = 0;\n    size_t len = s.length();\n    const char* str = s.c_str();\n\n    uint8x16_t vowels = {0, 'A', 0, 0, 'E', 0, 0, 'I', 0, 0, 'O', 0, 0, 'U', 0, 0};\n    uint8x16_t mask = vdupq_n_u8(170); // 170 = 'A' | 'E' | 'I' | 'O' | 'U'\n\n    for (size_t i = 0; i < len; i += 16) {\n        uint8x16_t chunk = vld1q_u8(&str[i]);\n        uint8x16_t even_indices = vandq_u8(chunk, vdupq_n_u8(0xAA)); // Mask for even indices\n        uint8x16_t uppercase = vandq_u8(even_indices, mask);\n        uint8x16_t matches = vceqq_u8(uppercase, vowels);\n        uint8x16_t reduced = vaddvq_u8(matches);\n        count += vgetq_lane_u8(reduced, 0) + vgetq_lane_u8(reduced, 1) + vgetq_lane_u8(reduced, 2) + vgetq_lane_u8(reduced, 3);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nint count_upper_simd(const std::string &s) {\n    int count = 0;\n    size_t len = s.length();\n    const char *str = s.c_str();\n\n    uint8x16_t vowels = {0, 'A', 0, 0, 'E', 0, 0, 0, 'I', 0, 0, 0, 'O', 0, 0, 0, 'U'};\n    uint8x16_t mask = vdupq_n_u8(1);\n    uint8x16_t even_mask = {1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0};\n\n    for (size_t i = 0; i <= len - 16; i += 16) {\n        uint8x16_t chunk = vld1q_u8(&str[i]);\n        uint8x16_t is_vowel = vceqq_u8(chunk, vowels);\n        uint8x16_t is_even = vandq_u8(is_vowel, even_mask);\n        uint8x16_t result = vandq_u8(is_even, mask);\n        count += vaddvq_u8(result);\n    }\n\n    for (size_t i = (len / 16) * 16; i < len; i += 2) {\n        if (i % 2 == 0 && (str[i] == 'A' || str[i] == 'E' || str[i] == 'I' || str[i] == 'O' || str[i] == 'U')) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nint count_upper_simd(const std::string & s) {\n    int count = 0;\n    size_t len = s.length();\n    const char* data = s.c_str();\n\n    uint8x16_t vowels = vdupq_n_u8(0);\n    vowels = vsetq_lane_u8('A', vowels, 0);\n    vowels = vsetq_lane_u8('E', vowels, 1);\n    vowels = vsetq_lane_u8('I', vowels, 2);\n    vowels = vsetq_lane_u8('O', vowels, 3);\n    vowels = vsetq_lane_u8('U', vowels, 4);\n\n    for (size_t i = 0; i < len; i += 16) {\n        size_t remaining = len - i;\n        uint8x16_t chunk = vld1q_u8(data + i);\n        uint8x16_t mask = vceqq_u8(chunk, vowels);\n\n        uint8x8_t mask_low = vget_low_u8(mask);\n        uint8x8_t mask_high = vget_high_u8(mask);\n\n        uint64_t low_bits = vaddlvq_u8(mask_low);\n        uint64_t high_bits = vaddlvq_u8(mask_high);\n\n        count += (low_bits & 0x5555555555555555) + (high_bits & 0x5555555555555555);\n\n        if (remaining < 16) {\n            for (size_t j = i + 16; j < len; j += 2) {\n                if (s[j] == 'A' || s[j] == 'E' || s[j] == 'I' || s[j] == 'O' || s[j] == 'U') {\n                    count++;\n                }\n            }\n            break;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_110_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result;\n    int32x4_t vn = vdupq_n_s32(n);\n    int32x4_t vinc = vdupq_n_s32((n % 2 == 0) ? 2 : 1);\n\n    for (int i = 0; i < n; i += 4) {\n        vn = vaddq_s32(vn, vinc);\n        int32x4_t vtemp = vn;\n\n        result.push_back(vgetq_lane_s32(vtemp, 0));\n        if (i + 1 < n) result.push_back(vgetq_lane_s32(vtemp, 1));\n        if (i + 2 < n) result.push_back(vgetq_lane_s32(vtemp, 2));\n        if (i + 3 < n) result.push_back(vgetq_lane_s32(vtemp, 3));\n\n        vinc = vaddq_s32(vinc, vdupq_n_s32(2));\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cstdint>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result;\n    result.reserve(n);\n\n    int32x4_t vn = vdupq_n_s32(n);\n    int32x4_t increment = vdupq_n_s32((n % 2 == 0) ? 2 : 1);\n\n    for (int i = 0; i < n; i += 4) {\n        vn = vaddq_s32(vn, increment);\n        int32_t temp[4];\n        vst1q_s32(temp, vn);\n\n        for (int j = 0; j < 4 && (i + j) < n; ++j) {\n            result.push_back(temp[j]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result;\n    result.reserve(n);\n\n    int32x4_t current = vdupq_n_s32(n);\n    int32x4_t increment = vdupq_n_s32((n % 2 == 0) ? 2 : 2);\n\n    for (int i = 0; i < n; i += 4) {\n        vst1q_s32(&result[i], current);\n        current = vaddq_s32(current, increment);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> pile;\n    pile.push_back(n);\n\n    int32x4_t current = vdupq_n_s32(n);\n    int32x4_t increment = vdupq_n_s32(n % 2 == 0 ? 2 : 1);\n\n    for (int i = 1; i < n; i++) {\n        current = vaddq_s32(current, increment);\n        int32x2_t low = vget_low_s32(current);\n        int32x2_t high = vget_high_s32(current);\n\n        pile.push_back(vget_lane_s32(low, 0));\n        if (i + 1 < n) pile.push_back(vget_lane_s32(low, 1));\n        if (i + 2 < n) pile.push_back(vget_lane_s32(high, 0));\n        if (i + 3 < n) pile.push_back(vget_lane_s32(high, 1));\n\n        increment = vaddq_s32(increment, vdupq_n_s32(2));\n    }\n\n    return pile;\n}\n```"}
{"task_id": "SimdBench_110_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> pile(n);\n    int32x4_t vn = vdupq_n_s32(n);\n    int32x4_t vinc = vdupq_n_s32((n % 2 == 0) ? 2 : 1);\n\n    for (int i = 0; i < n; i += 4) {\n        vst1q_s32(&pile[i], vn);\n        vn = vaddq_s32(vn, vinc);\n        vinc = vaddq_s32(vinc, vdupq_n_s32(2));\n    }\n\n    return pile;\n}\n```"}
{"task_id": "SimdBench_111_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n#include <cmath>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n\n    int64_t count = m - n + 1;\n    int64_t sum = 0;\n\n    int64x2_t vn = vdupq_n_s64(n);\n    int64x2_t vm = vdupq_n_s64(m);\n    int64x2_t vone = vdupq_n_s64(1);\n    int64x2_t vcount = vdupq_n_s64(count);\n\n    int64x2_t vsum = vdupq_n_s64(0);\n    int64x2_t vstep = vdupq_n_s64(2);\n\n    for (int64_t i = n; i <= m; i += 2) {\n        int64x2_t vi = vaddq_s64(vn, vmulq_s64(vstep, vdupq_n_s64(i - n)));\n        vsum = vaddq_s64(vsum, vi);\n    }\n\n    sum = vgetq_lane_s64(vsum, 0) + vgetq_lane_s64(vsum, 1);\n\n    int64_t avg = sum / count;\n    if (sum % count != 0) {\n        avg++;\n    }\n\n    std::string binary = \"\";\n    while (avg > 0) {\n        binary = (avg % 2 == 0 ? \"0\" : \"1\") + binary;\n        avg /= 2;\n    }\n\n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_111_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n#include <cmath>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n\n    int64_t count = m - n + 1;\n    int64_t sum = (count * (n + m)) / 2;\n    int64_t avg = sum / count;\n\n    int64x2_t avg_vec = vdupq_n_s64(avg);\n    int64x2_t one_vec = vdupq_n_s64(1);\n    int64x2_t half_vec = vdupq_n_s64(0.5);\n\n    int64x2_t floor_avg_vec = vcvtq_s64_f64(vaddq_f64(vcvtq_f64_s64(avg_vec), half_vec));\n    floor_avg_vec = vsubq_s64(floor_avg_vec, one_vec);\n\n    int64_t floor_avg = vgetq_lane_s64(floor_avg_vec, 0);\n\n    std::string binary = \"\";\n    for (int64_t i = floor_avg; i > 0; i /= 2) {\n        binary = (i % 2 == 0 ? \"0\" : \"1\") + binary;\n    }\n\n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_111_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <cstdint>\n#include <string>\n#include <cmath>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n\n    int64_t count = m - n + 1;\n    int64_t sum = 0;\n\n    int64_t i = n;\n    int64x2_t sum_vec = vdupq_n_s64(0);\n    int64x2_t inc_vec = vdupq_n_s64(1);\n\n    for (; i <= m - 1; i += 2) {\n        int64x2_t vec = vcreate_s64(i);\n        sum_vec = vaddq_s64(sum_vec, vec);\n    }\n\n    sum = vgetq_lane_s64(sum_vec, 0) + vgetq_lane_s64(sum_vec, 1);\n\n    if (i <= m) {\n        sum += i;\n    }\n\n    int64_t avg = sum / count;\n    std::string binary_result = \"\";\n\n    if (avg == 0) {\n        return \"0\";\n    }\n\n    while (avg > 0) {\n        binary_result = (avg % 2 == 0 ? \"0\" : \"1\") + binary_result;\n        avg /= 2;\n    }\n\n    return binary_result;\n}\n```"}
{"task_id": "SimdBench_111_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <cmath>\n#include <string>\n#include <bitset>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n\n    int64_t count = m - n + 1;\n    int64_t sum = 0;\n\n    int64x2_t vn = vdupq_n_s64(n);\n    int64x2_t vm = vdupq_n_s64(m);\n    int64x2_t vcount = vdupq_n_s64(count);\n    int64x2_t vsum = vdupq_n_s64(0);\n\n    for (int64_t i = n; i <= m; i += 2) {\n        int64x2_t vi = vdupq_n_s64(i);\n        int64x2_t vi_next = vdupq_n_s64(i + 1);\n        vsum = vaddq_s64(vsum, vi);\n        if (i + 1 <= m) {\n            vsum = vaddq_s64(vsum, vi_next);\n        }\n    }\n\n    sum = vgetq_lane_s64(vsum, 0) + vgetq_lane_s64(vsum, 1);\n    int64_t avg = std::floor(static_cast<double>(sum) / count);\n\n    std::bitset<64> binary(avg);\n    std::string binary_string = binary.to_string();\n\n    // Remove leading zeros\n    size_t start = binary_string.find('1');\n    if (start != std::string::npos) {\n        return binary_string.substr(start);\n    }\n    return \"0\";\n}\n```"}
{"task_id": "SimdBench_111_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n#include <cmath>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n\n    int64_t count = m - n + 1;\n    int64_t sum = (count * (n + m)) / 2;\n    int64_t avg = sum / count;\n\n    int64x2_t vn = vdupq_n_s64(n);\n    int64x2_t vm = vdupq_n_s64(m);\n    int64x2_t vcount = vdupq_n_s64(count);\n    int64x2_t vsum = vmulq_s64(vaddq_s64(vn, vm), vcount);\n    vsum = vshrq_n_s64(vsum, 1);\n    int64x2_t vavg = vshrq_n_s64(vsum, vclzq_s64(vcount));\n\n    avg = vgetq_lane_s64(vavg, 0);\n\n    std::string binary = \"\";\n    while (avg > 0) {\n        binary = (avg % 2 == 0 ? \"0\" : \"1\") + binary;\n        avg /= 2;\n    }\n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_112_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    int32x4_t sum_vector = {0, 0, 0, 0};\n    int32x4_t fact_vector = {1, 1, 1, 1};\n    int32x4_t mod_vector = {10000, 10000, 10000, 10000};\n\n    for (int i = 1; i <= n; i++) {\n        if (i % 4 == 0) {\n            sum_vector = vaddq_s32(sum_vector, (int32x4_t){i-3, i-2, i-1, i});\n            fact_vector = vmulq_s32(fact_vector, (int32x4_t){i-3, i-2, i-1, i});\n            fact_vector = vandq_s32(fact_vector, mod_vector);\n\n            result[i-4] = (i-4) % 2 == 0 ? vgetq_lane_s32(fact_vector, 3) : vgetq_lane_s32(sum_vector, 3);\n            result[i-3] = (i-3) % 2 == 0 ? vgetq_lane_s32(fact_vector, 2) : vgetq_lane_s32(sum_vector, 2);\n            result[i-2] = (i-2) % 2 == 0 ? vgetq_lane_s32(fact_vector, 1) : vgetq_lane_s32(sum_vector, 1);\n            result[i-1] = (i-1) % 2 == 0 ? vgetq_lane_s32(fact_vector, 0) : vgetq_lane_s32(sum_vector, 0);\n\n            sum_vector = (int32x4_t){0, 0, 0, 0};\n            fact_vector = (int32x4_t){1, 1, 1, 1};\n        }\n    }\n\n    for (int i = (n / 4) * 4 + 1; i <= n; i++) {\n        if (i % 2 == 0) {\n            int fact = 1;\n            for (int j = 1; j <= i; j++) {\n                fact = (fact * j) % 10000;\n            }\n            result[i-1] = fact;\n        } else {\n            result[i-1] = (i * (i + 1)) / 2;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n\n    int32x4_t v_sum = vmovq_n_s32(0);\n    int32x4_t v_fact = vmovq_n_s32(1);\n    int32x4_t v_one = vmovq_n_s32(1);\n    int32x4_t v_mod = vmovq_n_s32(10000);\n\n    for (int i = 1; i <= n; i++) {\n        if (i % 2 == 0) {\n            v_fact = vmulq_n_s32(v_fact, i);\n            v_fact = vmulq_n_s32(v_fact, i + 1);\n            v_fact = vmulq_n_s32(v_fact, i + 2);\n            v_fact = vmulq_n_s32(v_fact, i + 3);\n            v_fact = vmodq_s32(v_fact, v_mod);\n\n            result[i - 1] = vgetq_lane_s32(v_fact, 0);\n            result[i] = vgetq_lane_s32(v_fact, 1);\n            result[i + 1] = vgetq_lane_s32(v_fact, 2);\n            result[i + 2] = vgetq_lane_s32(v_fact, 3);\n\n            i += 3;\n        } else {\n            v_sum = vaddq_n_s32(v_sum, i);\n            v_sum = vaddq_n_s32(v_sum, i + 1);\n            v_sum = vaddq_n_s32(v_sum, i + 2);\n            v_sum = vaddq_n_s32(v_sum, i + 3);\n\n            result[i - 1] = vgetq_lane_s32(v_sum, 0);\n            result[i] = vgetq_lane_s32(v_sum, 1);\n            result[i + 1] = vgetq_lane_s32(v_sum, 2);\n            result[i + 2] = vgetq_lane_s32(v_sum, 3);\n\n            i += 3;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n\n    int32x4_t sum_vector = {0, 0, 0, 0};\n    int32x4_t fact_vector = {1, 1, 1, 1};\n    int32x4_t mod_vector = {10000, 10000, 10000, 10000};\n\n    for (int i = 1; i <= n; i += 4) {\n        int32x4_t i_vector = {i, i+1, i+2, i+3};\n        int32x4_t even_mask = vandq_u32(i_vector, (int32x4_t){1, 1, 1, 1});\n\n        int32x4_t sum_vector_next = vaddq_u32(sum_vector, i_vector);\n        int32x4_t fact_vector_next = vmulq_u32(fact_vector, i_vector);\n\n        int32x4_t result_vector = vbslq_u32(even_mask, vqrdmulhq_n_s32(fact_vector_next, mod_vector), sum_vector_next);\n\n        int32_t temp[4];\n        vst1q_s32(temp, result_vector);\n\n        for (int j = 0; j < 4 && (i + j) <= n; ++j) {\n            result[i + j - 1] = temp[j];\n        }\n\n        sum_vector = sum_vector_next;\n        fact_vector = fact_vector_next;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    int32x4_t sum_vector = {0, 0, 0, 0};\n    int32x4_t fact_vector = {1, 1, 1, 1};\n    int32x4_t mod_vector = {10000, 10000, 10000, 10000};\n\n    for (int i = 1; i <= n; i += 4) {\n        int32x4_t i_vector = {i, i + 1, i + 2, i + 3};\n        int32x4_t even_mask = vandq_u32(i_vector, (int32x4_t){1, 1, 1, 1});\n\n        int32x4_t sum_vector_new = vaddq_s32(sum_vector, i_vector);\n        int32x4_t fact_vector_new = vmulq_s32(fact_vector, i_vector);\n\n        int32x4_t result_vector = vbslq_s32(even_mask, vqrdmulhq_n_s32(fact_vector_new, mod_vector), sum_vector_new);\n\n        int32x2_t low_half = vget_low_s32(result_vector);\n        int32x2_t high_half = vget_high_s32(result_vector);\n\n        result[i - 1] = vget_lane_s32(low_half, 0);\n        if (i < n) result[i] = vget_lane_s32(low_half, 1);\n        if (i + 1 < n) result[i + 1] = vget_lane_s32(high_half, 0);\n        if (i + 2 < n) result[i + 2] = vget_lane_s32(high_half, 1);\n\n        sum_vector = sum_vector_new;\n        fact_vector = fact_vector_new;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    int32x4_t v_sum = vmovq_n_s32(0);\n    int32x4_t v_fact = vmovq_n_s32(1);\n    int32x4_t v_one = vmovq_n_s32(1);\n    int32x4_t v_two = vmovq_n_s32(2);\n    int32x4_t v_mod = vmovq_n_s32(10000);\n\n    for (int i = 1; i <= n; i += 4) {\n        int32x4_t v_i = vmovq_n_s32(i);\n        int32x4_t v_mask = vandq_s32(v_i, v_one);\n\n        int32x4_t v_even = vceqq_s32(v_mask, vmovq_n_s32(0));\n        int32x4_t v_odd = vmvnq_s32(v_even);\n\n        int32x4_t v_fact_next = vmulq_s32(v_fact, vaddq_s32(v_i, v_one));\n        v_fact_next = vandq_s32(v_fact_next, v_mod);\n\n        int32x4_t v_sum_next = vaddq_s32(v_sum, vaddq_s32(v_i, v_one));\n\n        int32x4_t v_result = vorrq_s32(vandq_s32(v_even, v_fact_next), vandq_s32(v_odd, v_sum_next));\n\n        vst1q_s32(&result[i-1], v_result);\n\n        v_fact = v_fact_next;\n        v_sum = v_sum_next;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_113_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    int16x8_t v_even = vdupq_n_s16(0);\n    int16x8_t v_odd = vdupq_n_s16(0);\n\n    for (int i = 1; i <= n; i++) {\n        int num = i;\n        int reversed = 0;\n        int original = num;\n\n        while (num != 0) {\n            int digit = num % 10;\n            reversed = reversed * 10 + digit;\n            num /= 10;\n        }\n\n        if (original == reversed) {\n            if (original % 2 == 0) {\n                v_even = vaddq_s16(v_even, vdupq_n_s16(1));\n            } else {\n                v_odd = vaddq_s16(v_odd, vdupq_n_s16(1));\n            }\n        }\n    }\n\n    even_count = vaddvq_s16(v_even);\n    odd_count = vaddvq_s16(v_odd);\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cstring>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int32x4_t v_even = vdupq_n_s32(0);\n    int32x4_t v_odd = vdupq_n_s32(0);\n    int32x4_t v_one = vdupq_n_s32(1);\n    int32x4_t v_two = vdupq_n_s32(2);\n\n    for (int i = 1; i <= n; i += 4) {\n        int32x4_t v_i = vmovq_n_s32(i);\n        int32x4_t v_rev = vrev64q_s32(v_i);\n\n        uint32x4_t v_mask = vcltq_s32(v_i, vdupq_n_s32(10));\n        v_rev = vbslq_s32(v_mask, v_i, v_rev);\n\n        uint32x4_t v_eq = vceqq_s32(v_i, v_rev);\n        int32x4_t v_even_mask = vandq_s32(v_eq, vdupq_n_s32(~1));\n        int32x4_t v_odd_mask = vandq_s32(v_eq, vdupq_n_s32(1));\n\n        v_even = vaddq_s32(v_even, vandq_s32(v_even_mask, v_one));\n        v_odd = vaddq_s32(v_odd, vandq_s32(v_odd_mask, v_one));\n    }\n\n    int even_count = vaddvq_s32(v_even);\n    int odd_count = vaddvq_s32(v_odd);\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int32x4_t v_even = vdupq_n_s32(0);\n    int32x4_t v_odd = vdupq_n_s32(0);\n    int32x4_t v_one = vdupq_n_s32(1);\n    int32x4_t v_two = vdupq_n_s32(2);\n\n    for (int i = 1; i <= n; i += 4) {\n        int32x4_t v_i = vdupq_n_s32(i);\n        int32x4_t v_rev_i = vrev64q_s32(v_i);\n\n        uint32x4_t v_mask = vcltq_s32(v_i, vdupq_n_s32(n + 1));\n        int32x4_t v_palindrome = vandq_s32(vceqq_s32(v_i, v_rev_i), v_mask);\n\n        int32x4_t v_even_palindrome = vandq_s32(v_palindrome, vceqq_s32(vandq_s32(v_i, v_one), vdupq_n_s32(0)));\n        int32x4_t v_odd_palindrome = vandq_s32(v_palindrome, vceqq_s32(vandq_s32(v_i, v_one), v_one));\n\n        v_even = vaddq_s32(v_even, v_even_palindrome);\n        v_odd = vaddq_s32(v_odd, v_odd_palindrome);\n    }\n\n    int even_count = vaddvq_s32(v_even);\n    int odd_count = vaddvq_s32(v_odd);\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    int32x4_t v_even = vdupq_n_s32(0);\n    int32x4_t v_odd = vdupq_n_s32(0);\n\n    for (int i = 1; i <= n; i += 4) {\n        int32x4_t v_i = {i, i+1, i+2, i+3};\n        int32x4_t v_rev = {reverse_int(i), reverse_int(i+1), reverse_int(i+2), reverse_int(i+3)};\n\n        uint32x4_t v_mask = vceqq_s32(v_i, v_rev);\n        int32x4_t v_even_mask = vandq_s32(v_mask, vdupq_n_s32(1));\n        int32x4_t v_odd_mask = vandq_s32(v_mask, vdupq_n_s32(2));\n\n        v_even = vaddq_s32(v_even, v_even_mask);\n        v_odd = vaddq_s32(v_odd, v_odd_mask);\n    }\n\n    even_count = vaddvq_s32(v_even);\n    odd_count = vaddvq_s32(v_odd);\n\n    return {even_count, odd_count};\n}\n\nint reverse_int(int num) {\n    int reversed = 0;\n    while (num > 0) {\n        reversed = reversed * 10 + num % 10;\n        num /= 10;\n    }\n    return reversed;\n}\n```"}
{"task_id": "SimdBench_113_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    int32x4_t v_even = vdupq_n_s32(0);\n    int32x4_t v_odd = vdupq_n_s32(0);\n\n    for (int i = 1; i <= n; i += 4) {\n        int32x4_t v_i = {i, i+1, i+2, i+3};\n        int32x4_t v_rev_i = {reverse_digits(i), reverse_digits(i+1), reverse_digits(i+2), reverse_digits(i+3)};\n\n        uint32x4_t v_mask = vceqq_s32(v_i, v_rev_i);\n        int32x4_t v_even_mask = vandq_s32(v_mask, vdupq_n_s32(1));\n        int32x4_t v_odd_mask = vandq_s32(v_mask, vdupq_n_s32(2));\n\n        v_even = vaddq_s32(v_even, v_even_mask);\n        v_odd = vaddq_s32(v_odd, v_odd_mask);\n    }\n\n    even_count = vaddvq_s32(v_even);\n    odd_count = vaddvq_s32(v_odd);\n\n    return {even_count, odd_count};\n}\n\nint reverse_digits(int num) {\n    int rev = 0;\n    while (num > 0) {\n        rev = rev * 10 + num % 10;\n        num = num / 10;\n    }\n    return rev;\n}\n```"}
{"task_id": "SimdBench_114_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    size_t size = n.size();\n    size_t i = 0;\n\n    for (; i <= size - 4; i += 4) {\n        int32x4_t v = vld1q_s32(&n[i]);\n        int32x4_t sum_digits = vdupq_n_s32(0);\n\n        // Extract digits and sum them\n        int32x4_t v_abs = vabsq_s32(v);\n        int32x4_t v_1000 = vdupq_n_s32(1000);\n        int32x4_t v_100 = vdupq_n_s32(100);\n        int32x4_t v_10 = vdupq_n_s32(10);\n        int32x4_t v_1 = vdupq_n_s32(1);\n\n        int32x4_t thousands = vqdmulhq_s32(v_abs, v_1000);\n        int32x4_t hundreds = vqdmulhq_s32(v_abs, v_100);\n        int32x4_t tens = vqdmulhq_s32(v_abs, v_10);\n        int32x4_t ones = vqdmulhq_s32(v_abs, v_1);\n\n        sum_digits = vaddq_s32(sum_digits, thousands);\n        sum_digits = vaddq_s32(sum_digits, hundreds);\n        sum_digits = vaddq_s32(sum_digits, tens);\n        sum_digits = vaddq_s32(sum_digits, ones);\n\n        // Check if sum of digits is greater than 0\n        uint32x4_t mask = vcgtq_s32(sum_digits, vdupq_n_s32(0));\n        count += vaddvq_u32(mask);\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        int num = n[i];\n        int sum_digits = 0;\n        bool negative = num < 0;\n        num = abs(num);\n\n        while (num > 0) {\n            sum_digits += num % 10;\n            num /= 10;\n        }\n\n        if (negative) {\n            sum_digits -= 1;\n        }\n\n        if (sum_digits > 0) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    size_t size = n.size();\n    size_t i = 0;\n\n    for (; i <= size - 4; i += 4) {\n        int32x4_t v = vld1q_s32(&n[i]);\n        int32x4_t sums = v;\n\n        // Calculate the sum of digits for each element in the vector\n        sums = vabsq_s32(sums);\n        sums = vsetq_lane_s32(sums[0] / 1000 + (sums[0] / 100) % 10 + (sums[0] / 10) % 10 + sums[0] % 10, sums, 0);\n        sums = vsetq_lane_s32(sums[1] / 1000 + (sums[1] / 100) % 10 + (sums[1] / 10) % 10 + sums[1] % 10, sums, 1);\n        sums = vsetq_lane_s32(sums[2] / 1000 + (sums[2] / 100) % 10 + (sums[2] / 10) % 10 + sums[2] % 10, sums, 2);\n        sums = vsetq_lane_s32(sums[3] / 1000 + (sums[3] / 100) % 10 + (sums[3] / 10) % 10 + sums[3] % 10, sums, 3);\n\n        uint32x4_t mask = vcgtq_s32(sums, vdupq_n_s32(0));\n        uint32x4_t mask_sum = vaddvq_u32(mask);\n        count += vgetq_lane_u32(mask_sum, 0);\n    }\n\n    for (; i < size; ++i) {\n        int num = n[i];\n        int sum = 0;\n        bool negative = num < 0;\n        if (negative) num = -num;\n\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n\n        if (negative) sum -= 2 * (sum % 10);\n\n        if (sum > 0) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    size_t size = n.size();\n    size_t i = 0;\n\n    if (size >= 4) {\n        int32x4_t vsum = vdupq_n_s32(0);\n        int32x4_t vone = vdupq_n_s32(1);\n\n        for (; i <= size - 4; i += 4) {\n            int32x4_t v = vld1q_s32(&n[i]);\n            int32x4_t vabs = vabsq_s32(v);\n            int32x4_t vdigitsum = vdupq_n_s32(0);\n\n            for (int j = 0; j < 10; ++j) {\n                int32x4_t vmod = vmodq_s32(vabs, vdupq_n_s32(10));\n                vdigitsum = vaddq_s32(vdigitsum, vmod);\n                vabs = vdivq_s32(vabs, vdupq_n_s32(10));\n            }\n\n            uint32x4_t vmask = vcgtq_s32(vdigitsum, vdupq_n_s32(0));\n            int32x4_t vcount = vaddq_s32(vsum, vandq_s32(vone, (int32x4_t)vmask));\n            vsum = vcount;\n        }\n\n        count += vaddvq_s32(vsum);\n    }\n\n    for (; i < size; ++i) {\n        int num = n[i];\n        int sum = 0;\n        int temp = abs(num);\n\n        while (temp > 0) {\n            sum += temp % 10;\n            temp /= 10;\n        }\n\n        if (sum > 0) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    size_t size = n.size();\n    size_t i;\n\n    int32x4_t v_zero = vdupq_n_s32(0);\n    int32x4_t v_sum;\n    int32x4_t v_num;\n    uint32x4_t v_mask;\n    int32x4_t v_result;\n\n    for (i = 0; i <= size - 4; i += 4) {\n        v_num = vld1q_s32(&n[i]);\n        v_sum = vdupq_n_s32(0);\n\n        // Handle negative numbers\n        int32x4_t v_neg_mask = vcgtq_s32(v_zero, v_num);\n        v_num = vbslq_s32(v_neg_mask, vnegq_s32(v_num), v_num);\n\n        // Sum digits\n        for (int j = 0; j < 10; ++j) {\n            int32x4_t v_digits = vandq_s32(v_num, vdupq_n_s32(9));\n            v_sum = vaddq_s32(v_sum, v_digits);\n            v_num = vshrq_n_s32(v_num, 1);\n            v_num = vshrq_n_s32(v_num, 2);\n        }\n\n        v_mask = vcgtq_s32(v_sum, v_zero);\n        v_result = vandq_s32(v_num, v_mask);\n\n        int32_t result[4];\n        vst1q_s32(result, v_result);\n\n        for (int j = 0; j < 4; ++j) {\n            if (result[j] > 0) {\n                count++;\n            }\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        int num = n[i];\n        int sum = 0;\n\n        // Handle negative numbers\n        if (num < 0) {\n            num = -num;\n        }\n\n        // Sum digits\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n\n        if (sum > 0) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    size_t size = n.size();\n    int32x4_t v_zero = vdupq_n_s32(0);\n\n    for (size_t i = 0; i < size; i += 4) {\n        int32x4_t v = vld1q_s32(&n[i]);\n        int32x4_t v_abs = vabsq_s32(v);\n\n        int16x4_t v_low = vmovn_s32(v_abs);\n        int16x4_t v_high = vshrn_n_s32(v_abs, 16);\n\n        int16x8_t v_combined = vcombine_s16(v_low, v_high);\n        int8x8_t v_digits_low = vmovn_s16(v_combined);\n        int8x8_t v_digits_high = vshrn_n_s16(v_combined, 8);\n\n        int8x16_t v_all_digits = vcombine_s8(v_digits_low, v_digits_high);\n\n        uint8x16_t v_sum_digits = vaddq_u8(v_all_digits, vdupq_n_u8(0));\n        uint16x8_t v_sum_digits_pair = vpaddlq_u8(v_sum_digits);\n        uint32x4_t v_sum_digits_word = vpaddlq_u16(v_sum_digits_pair);\n        uint32x2_t v_sum_digits_final = vpaddlq_u32(v_sum_digits_word);\n\n        uint32_t sum_digits = vgetq_lane_u32(v_sum_digits_final, 0) + vgetq_lane_u32(v_sum_digits_final, 1);\n\n        if (sum_digits > 0) {\n            count += 4;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_115_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) return true;\n\n    int n = arr.size();\n    std::vector<int> sorted_arr = arr;\n    std::sort(sorted_arr.begin(), sorted_arr.end());\n\n    for (int i = 0; i < n; ++i) {\n        bool is_sorted = true;\n        for (int j = 0; j < n; j += 4) {\n            int32x4_t v1 = vld1q_s32(&arr[(j + i) % n]);\n            int32x4_t v2 = vld1q_s32(&sorted_arr[j]);\n            uint32x4_t diff = vceqq_s32(v1, v2);\n            if (vminvq_u32(diff) == 0) {\n                is_sorted = false;\n                break;\n            }\n        }\n        if (is_sorted) return true;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_115_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) return true;\n\n    int n = arr.size();\n    std::vector<int> sorted_arr = arr;\n    std::sort(sorted_arr.begin(), sorted_arr.end());\n\n    for (int i = 0; i < n; ++i) {\n        bool is_sorted = true;\n        for (int j = 0; j < n; j += 4) {\n            int32x4_t v1 = vld1q_s32(&arr[(j + i) % n]);\n            int32x4_t v2 = vld1q_s32(&sorted_arr[j]);\n            uint32x4_t cmp = vceqq_s32(v1, v2);\n            if (vminvq_u32(cmp) == 0) {\n                is_sorted = false;\n                break;\n            }\n        }\n        if (is_sorted) return true;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_115_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) return true;\n\n    int n = arr.size();\n    std::vector<int> sorted_arr = arr;\n    std::sort(sorted_arr.begin(), sorted_arr.end());\n\n    for (int i = 0; i < n; ++i) {\n        bool is_sorted = true;\n        for (int j = 0; j < n; j += 4) {\n            int32x4_t vec = vld1q_s32(&arr[j]);\n            int32x4_t sorted_vec = vld1q_s32(&sorted_arr[j]);\n            uint32x4_t cmp = vceqq_s32(vec, sorted_vec);\n            if (vaddvq_u32(cmp) != 4) {\n                is_sorted = false;\n                break;\n            }\n        }\n        if (is_sorted) return true;\n        std::rotate(arr.rbegin(), arr.rbegin() + 1, arr.rend());\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_115_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) return true;\n\n    int n = arr.size();\n    std::vector<int> sorted_arr = arr;\n    std::sort(sorted_arr.begin(), sorted_arr.end());\n\n    for (int i = 0; i < n; ++i) {\n        bool is_sorted = true;\n        for (int j = 0; j < n; j += 4) {\n            int32x4_t vec = vld1q_s32(&arr[(j + i) % n]);\n            int32x4_t sorted_vec = vld1q_s32(&sorted_arr[j]);\n            uint32x4_t cmp = vceqq_s32(vec, sorted_vec);\n            if (vaddvq_u32(cmp) != 4) {\n                is_sorted = false;\n                break;\n            }\n        }\n        if (is_sorted) return true;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_115_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) return true;\n\n    int n = arr.size();\n    std::vector<int> sorted_arr = arr;\n    std::sort(sorted_arr.begin(), sorted_arr.end());\n\n    int32x4_t v_sorted;\n    int32x4_t v_arr;\n    int32x4_t v_result;\n\n    for (int i = 0; i < n; i++) {\n        bool is_sorted = true;\n\n        for (int j = 0; j < n; j += 4) {\n            v_sorted = vld1q_s32(&sorted_arr[j]);\n            v_arr = vld1q_s32(&arr[(j + i) % n]);\n            v_result = vceqq_s32(v_sorted, v_arr);\n\n            if (vgetq_lane_s32(v_result, 0) == 0 ||\n                vgetq_lane_s32(v_result, 1) == 0 ||\n                vgetq_lane_s32(v_result, 2) == 0 ||\n                vgetq_lane_s32(v_result, 3) == 0) {\n                is_sorted = false;\n                break;\n            }\n        }\n\n        if (is_sorted) return true;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_116_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int32x4_t v1, v2;\n    uint32x4_t mask1, mask2;\n    uint32x4_t result1, result2;\n    bool hasOdd1 = false, hasEven2 = false;\n\n    for (size_t i = 0; i < lst1.size(); i += 4) {\n        v1 = vld1q_s32(&lst1[i]);\n        mask1 = vreinterpretq_u32_s32(v1);\n        result1 = vandq_u32(mask1, vdupq_n_u32(1));\n        if (vmaxvq_u32(result1) == 1) {\n            hasOdd1 = true;\n            break;\n        }\n    }\n\n    for (size_t i = 0; i < lst2.size(); i += 4) {\n        v2 = vld1q_s32(&lst2[i]);\n        mask2 = vreinterpretq_u32_s32(v2);\n        result2 = vandq_u32(mask2, vdupq_n_u32(1));\n        if (vminvq_u32(result2) == 0) {\n            hasEven2 = true;\n            break;\n        }\n    }\n\n    if (hasOdd1 && !hasEven2) {\n        return \"NO\";\n    } else {\n        return \"YES\";\n    }\n}\n```"}
{"task_id": "SimdBench_116_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int32x4_t v1, v2;\n    uint32x4_t even_mask = vdupq_n_u32(1);\n    uint32x4_t result1, result2;\n    uint32x4_t zero = vdupq_n_u32(0);\n    uint32x4_t all_even = vdupq_n_u32(0xFFFFFFFF);\n\n    size_t i;\n    for (i = 0; i <= lst1.size() - 4; i += 4) {\n        v1 = vld1q_s32(&lst1[i]);\n        v2 = vld1q_s32(&lst2[i]);\n        result1 = vandq_u32(vreinterpretq_u32_s32(v1), even_mask);\n        result2 = vandq_u32(vreinterpretq_u32_s32(v2), even_mask);\n        if (vceqq_u32(result1, zero) != all_even && vceqq_u32(result2, zero) != all_even) {\n            return \"NO\";\n        }\n    }\n\n    for (; i < lst1.size(); ++i) {\n        if (lst1[i] % 2 != 0 && lst2[i] % 2 != 0) {\n            return \"NO\";\n        }\n    }\n\n    return \"YES\";\n}\n```"}
{"task_id": "SimdBench_116_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int32x4_t v1, v2;\n    uint32x4_t mask1, mask2;\n    int size = lst1.size();\n    int i;\n\n    for (i = 0; i <= size - 4; i += 4) {\n        v1 = vld1q_s32(&lst1[i]);\n        v2 = vld1q_s32(&lst2[i]);\n        mask1 = vceqq_s32(v1, vshlq_n_s32(vandq_s32(v1, vdupq_n_s32(1)), 31));\n        mask2 = vceqq_s32(v2, vshlq_n_s32(vandq_s32(v2, vdupq_n_s32(1)), 31));\n\n        if (vmaxvq_u32(vorrq_u32(mask1, mask2)) == 0) {\n            return \"NO\";\n        }\n    }\n\n    for (; i < size; ++i) {\n        if ((lst1[i] & 1) && (lst2[i] & 1)) {\n            return \"NO\";\n        }\n    }\n\n    return \"YES\";\n}\n```"}
{"task_id": "SimdBench_116_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int32x4_t v1, v2;\n    uint32x4_t mask1, mask2;\n    bool possible = true;\n\n    for (size_t i = 0; i < lst1.size(); i += 4) {\n        v1 = vld1q_s32(&lst1[i]);\n        v2 = vld1q_s32(&lst2[i]);\n\n        mask1 = vreinterpretq_u32_s32(v1);\n        mask2 = vreinterpretq_u32_s32(v2);\n\n        mask1 = vandq_u32(mask1, vdupq_n_u32(1));\n        mask2 = vandq_u32(mask2, vdupq_n_u32(1));\n\n        if (vmaxvq_u32(mask1) == 1 && vmaxvq_u32(mask2) == 1) {\n            possible = false;\n            break;\n        }\n    }\n\n    return possible ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int32x4_t v1, v2;\n    uint32x4_t even_mask = vdupq_n_u32(1);\n    uint32x4_t result1, result2;\n    bool all_even_possible = false;\n\n    for (size_t i = 0; i <= lst1.size() - 4; i += 4) {\n        v1 = vld1q_s32(&lst1[i]);\n        result1 = vandq_u32(vreinterpretq_u32_s32(v1), even_mask);\n        if (vaddvq_u32(result1) == 0) {\n            all_even_possible = true;\n            break;\n        }\n    }\n\n    if (!all_even_possible) {\n        for (size_t i = 0; i <= lst2.size() - 4; i += 4) {\n            v2 = vld1q_s32(&lst2[i]);\n            result2 = vandq_u32(vreinterpretq_u32_s32(v2), even_mask);\n            if (vaddvq_u32(result2) == 0) {\n                all_even_possible = true;\n                break;\n            }\n        }\n    }\n\n    if (all_even_possible) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_117_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n#include <cstdint>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    result.reserve(lst.size());\n\n    for (const auto& str : lst) {\n        uint32_t odd_count = 0;\n        size_t len = str.length();\n        size_t i = 0;\n\n        // Process 16 characters at a time using NEON\n        for (; i <= len - 16; i += 16) {\n            uint8x16_t chunk = vld1q_u8(&str[i]);\n            uint8x16_t odd_mask = vandq_u8(chunk, vdupq_n_u8(1));\n            uint8x16_t odd_bits = vshrq_n_u8(odd_mask, 7);\n            odd_count += vaddvq_u8(odd_bits);\n        }\n\n        // Process remaining characters\n        for (; i < len; ++i) {\n            if ((str[i] - '0') % 2 != 0) {\n                odd_count++;\n            }\n        }\n\n        result.push_back(\"the number of odd elements \" + std::to_string(odd_count) + \"n the str\" + std::to_string(odd_count) + \"ng \" + std::to_string(odd_count) + \" of the \" + std::to_string(odd_count) + \"nput.\");\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n#include <cstring>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    result.reserve(lst.size());\n\n    for (const auto& str : lst) {\n        size_t length = str.length();\n        size_t odd_count = 0;\n\n        size_t i = 0;\n        for (; i <= length - 16; i += 16) {\n            uint8x16_t chunk = vld1q_u8(str.data() + i);\n            uint8x16_t odd_mask = vdupq_n_u8(1);\n            uint8x16_t is_odd = vandq_u8(chunk, odd_mask);\n            uint8x16_t odd_count_vec = vcgeq_u8(is_odd, vdupq_n_u8(1));\n            odd_count += vaddvq_u8(odd_count_vec);\n        }\n\n        for (; i < length; ++i) {\n            if ((str[i] - '0') % 2 != 0) {\n                odd_count++;\n            }\n        }\n\n        std::string output = \"the number of odd elements \";\n        output += std::to_string(odd_count);\n        output += \"n the str\";\n        output += std::to_string(odd_count);\n        output += \"ng \";\n        output += std::to_string(odd_count);\n        output += \" of the \";\n        output += std::to_string(odd_count);\n        output += \"nput.\";\n\n        result.push_back(output);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    result.reserve(lst.size());\n\n    for (const auto& str : lst) {\n        uint32_t count = 0;\n        size_t len = str.length();\n        size_t i = 0;\n\n        for (; i <= len - 16; i += 16) {\n            uint8x16_t chunk = vld1q_u8(&str[i]);\n            uint8x16_t odd_mask = vdupq_n_u8(1);\n            uint8x16_t is_odd = vandq_u8(chunk, odd_mask);\n            uint8x16_t odd_count = vcgeq_u8(is_odd, odd_mask);\n            count += vaddvq_u8(odd_count);\n        }\n\n        for (; i < len; ++i) {\n            if ((str[i] - '0') % 2 != 0) {\n                count++;\n            }\n        }\n\n        std::string output = \"the number of odd elements \";\n        output += std::to_string(count);\n        output += \"n the str\";\n        output += std::to_string(count);\n        output += \"ng \";\n        output += std::to_string(count);\n        output += \" of the \";\n        output += std::to_string(count);\n        output += \"nput.\";\n\n        result.push_back(output);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std<std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    result.reserve(lst.size());\n\n    for (const auto& str : lst) {\n        uint8x16_t odd_mask = vdupq_n_u8(1); // Mask for odd digits: '1', '3', '5', '7', '9'\n        uint8x16_t even_mask = vdupq_n_u8(2); // Mask for even digits: '0', '2', '4', '6', '8'\n        uint8x16_t digit_mask = vdupq_n_u8(0x0F); // Mask to isolate the lower 4 bits\n\n        size_t len = str.length();\n        size_t i = 0;\n        uint32_t odd_count = 0;\n\n        for (; i <= len - 16; i += 16) {\n            uint8x16_t chunk = vld1q_u8(&str[i]);\n            uint8x16_t digits = vandq_u8(chunk, digit_mask);\n            uint8x16_t odds = vceqq_u8(vandq_u8(digits, odd_mask), odd_mask);\n            odd_count += vaddvq_u8(odds);\n        }\n\n        for (; i < len; ++i) {\n            if ((str[i] - '0') % 2 == 1) {\n                ++odd_count;\n            }\n        }\n\n        std::string output = \"the number of odd elements \";\n        output += std::to_string(odd_count);\n        output += \"n the str\";\n        output += std::to_string(odd_count);\n        output += \"ng \";\n        output += std::to_string(odd_count);\n        output += \" of the \";\n        output += std::to_string(odd_count);\n        output += \"nput.\";\n\n        result.push_back(output);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n#include <cstring>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    result.reserve(lst.size());\n\n    for (const auto& str : lst) {\n        size_t length = str.length();\n        size_t odd_count = 0;\n\n        size_t i = 0;\n        for (; i <= length - 16; i += 16) {\n            uint8x16_t chunk = vld1q_u8(str.data() + i);\n            uint8x16_t odd_mask = vdupq_n_u8(1);\n            uint8x16_t is_odd = vandq_u8(chunk, odd_mask);\n            uint8x16_t odd_bits = vshrq_n_u8(is_odd, 7);\n            odd_count += vaddvq_u8(odd_bits);\n        }\n\n        for (; i < length; ++i) {\n            if ((str[i] - '0') % 2 != 0) {\n                ++odd_count;\n            }\n        }\n\n        std::string output = \"the number of odd elements \";\n        output += std::to_string(odd_count);\n        output += \"n the str\";\n        output += std::to_string(odd_count);\n        output += \"ng \";\n        output += std::to_string(odd_count);\n        output += \" of the \";\n        output += std::to_string(odd_count);\n        output += \"nput.\";\n\n        result.push_back(output);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_118_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <limits.h>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    if (nums.empty()) return 0;\n\n    int64_t global_min = LLONG_MAX;\n    int64_t current_sum = 0;\n    int64_t min_sum = LLONG_MAX;\n\n    size_t i = 0;\n    size_t n = nums.size();\n\n    int64x2_t v_current_sum = vdupq_n_s64(0);\n    int64x2_t v_min_sum = vdupq_n_s64(LLONG_MAX);\n\n    for (; i <= n - 2; i += 2) {\n        int64x2_t v_nums = vld1q_s64(&nums[i]);\n        v_current_sum = vaddq_s64(v_current_sum, v_nums);\n\n        int64_t current_sum_0 = vgetq_lane_s64(v_current_sum, 0);\n        int64_t current_sum_1 = vgetq_lane_s64(v_current_sum, 1);\n\n        if (current_sum_0 < min_sum) min_sum = current_sum_0;\n        if (current_sum_1 < min_sum) min_sum = current_sum_1;\n\n        if (current_sum_0 < 0) current_sum_0 = 0;\n        if (current_sum_1 < 0) current_sum_1 = 0;\n\n        v_current_sum = vsetq_lane_s64(current_sum_0, v_current_sum, 0);\n        v_current_sum = vsetq_lane_s64(current_sum_1, v_current_sum, 1);\n    }\n\n    current_sum = vgetq_lane_s64(v_current_sum, 0) + vgetq_lane_s64(v_current_sum, 1);\n\n    for (; i < n; ++i) {\n        current_sum += nums[i];\n        if (current_sum < min_sum) min_sum = current_sum;\n        if (current_sum < 0) current_sum = 0;\n    }\n\n    if (min_sum < global_min) global_min = min_sum;\n\n    return global_min;\n}\n```"}
{"task_id": "SimdBench_118_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <limits.h>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    if (nums.empty()) return 0;\n\n    int64_t minSum = LLONG_MAX;\n    int64_t currentSum = 0;\n    size_t i = 0;\n\n    int64x2_t vminSum = vdupq_n_s64(LLONG_MAX);\n    int64x2_t vcurrentSum = vdupq_n_s64(0);\n    int64x2_t vnums;\n\n    for (; i <= nums.size() - 2; i += 2) {\n        vnums = vld1q_s64(&nums[i]);\n        vcurrentSum = vaddq_s64(vcurrentSum, vnums);\n        vminSum = vminq_s64(vminSum, vcurrentSum);\n\n        if (vcurrentSum[0] > 0) vcurrentSum = vsetq_lane_s64(0, vcurrentSum, 0);\n        if (vcurrentSum[1] > 0) vcurrentSum = vsetq_lane_s64(0, vcurrentSum, 1);\n    }\n\n    minSum = std::min(minSum, vgetq_lane_s64(vminSum, 0));\n    minSum = std::min(minSum, vgetq_lane_s64(vminSum, 1));\n\n    for (; i < nums.size(); ++i) {\n        currentSum += nums[i];\n        minSum = std::min(minSum, currentSum);\n        if (currentSum > 0) currentSum = 0;\n    }\n\n    return minSum;\n}\n```"}
{"task_id": "SimdBench_118_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <limits.h>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    if (nums.empty()) return 0;\n\n    int64_t global_min = LLONG_MAX;\n    int64_t current_sum = 0;\n    int64_t min_sum = LLONG_MAX;\n\n    size_t i = 0;\n    size_t n = nums.size();\n\n    int64x2_t v_current_sum = vdupq_n_s64(0);\n    int64x2_t v_min_sum = vdupq_n_s64(LLONG_MAX);\n\n    for (; i <= n - 2; i += 2) {\n        int64x2_t v_nums = vld1q_s64(&nums[i]);\n        v_current_sum = vaddq_s64(v_current_sum, v_nums);\n\n        int64_t current_sum_0 = vgetq_lane_s64(v_current_sum, 0);\n        int64_t current_sum_1 = vgetq_lane_s64(v_current_sum, 1);\n\n        if (current_sum_0 < min_sum) min_sum = current_sum_0;\n        if (current_sum_1 < min_sum) min_sum = current_sum_1;\n\n        if (current_sum_0 < 0) current_sum_0 = 0;\n        if (current_sum_1 < 0) current_sum_1 = 0;\n\n        v_current_sum = vsetq_lane_s64(current_sum_0, v_current_sum, 0);\n        v_current_sum = vsetq_lane_s64(current_sum_1, v_current_sum, 1);\n    }\n\n    if (i < n) {\n        current_sum += nums[i];\n        if (current_sum < min_sum) min_sum = current_sum;\n        if (current_sum < 0) current_sum = 0;\n    }\n\n    if (min_sum == LLONG_MAX) min_sum = current_sum;\n\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <limits.h>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    if (nums.empty()) return 0;\n\n    int64_t global_min = LLONG_MAX;\n    int64_t current_sum = 0;\n    int64_t min_sum = LLONG_MAX;\n\n    size_t i = 0;\n    size_t n = nums.size();\n\n    int64x2_t vglobal_min = vdupq_n_s64(LLONG_MAX);\n    int64x2_t vcurrent_sum = vdupq_n_s64(0);\n    int64x2_t vmin_sum = vdupq_n_s64(LLONG_MAX);\n\n    for (; i <= n - 2; i += 2) {\n        int64x2_t vnums = vld1q_s64(&nums[i]);\n        vcurrent_sum = vaddq_s64(vcurrent_sum, vnums);\n        vglobal_min = vminq_s64(vglobal_min, vcurrent_sum);\n        vmin_sum = vminq_s64(vmin_sum, vglobal_min);\n        vcurrent_sum = vmaxq_s64(vdupq_n_s64(0), vcurrent_sum);\n    }\n\n    global_min = std::min(global_min, vgetq_lane_s64(vmin_sum, 0));\n    global_min = std::min(global_min, vgetq_lane_s64(vmin_sum, 1));\n\n    for (; i < n; ++i) {\n        current_sum += nums[i];\n        min_sum = std::min(min_sum, current_sum);\n        current_sum = std::max((int64_t)0, current_sum);\n    }\n\n    global_min = std::min(global_min, min_sum);\n\n    return global_min;\n}\n```"}
{"task_id": "SimdBench_118_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <limits.h>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    if (nums.empty()) return 0;\n\n    int64_t global_min = LLONG_MAX;\n    int64_t current_sum = 0;\n    int64_t min_sum = LLONG_MAX;\n\n    size_t i = 0;\n    size_t n = nums.size();\n\n    int64x2_t v_current_sum = vdupq_n_s64(0);\n    int64x2_t v_min_sum = vdupq_n_s64(LLONG_MAX);\n\n    for (; i <= n - 2; i += 2) {\n        int64x2_t v_nums = vld1q_s64(&nums[i]);\n        v_current_sum = vaddq_s64(v_current_sum, v_nums);\n\n        int64_t current_sum_0 = vgetq_lane_s64(v_current_sum, 0);\n        int64_t current_sum_1 = vgetq_lane_s64(v_current_sum, 1);\n\n        if (current_sum_0 < min_sum) {\n            min_sum = current_sum_0;\n        }\n        if (current_sum_1 < min_sum) {\n            min_sum = current_sum_1;\n        }\n\n        if (current_sum_0 < 0) {\n            current_sum_0 = 0;\n        }\n        if (current_sum_1 < 0) {\n            current_sum_1 = 0;\n        }\n\n        v_current_sum = vsetq_lane_s64(current_sum_0, v_current_sum, 0);\n        v_current_sum = vsetq_lane_s64(current_sum_1, v_current_sum, 1);\n    }\n\n    if (min_sum < global_min) {\n        global_min = min_sum;\n    }\n\n    for (; i < n; ++i) {\n        current_sum += nums[i];\n        if (current_sum < global_min) {\n            global_min = current_sum;\n        }\n        if (current_sum < 0) {\n            current_sum = 0;\n        }\n    }\n\n    return global_min;\n}\n```"}
{"task_id": "SimdBench_119_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int>> &grid, int capacity) {\n    int total_buckets = 0;\n    size_t rows = grid.size();\n    size_t cols = grid[0].size();\n\n    for (size_t i = 0; i < rows; ++i) {\n        size_t j = 0;\n        uint8x16_t accum = vdupq_n_u8(0);\n        uint8x16_t cap = vdupq_n_u8(capacity);\n\n        for (; j <= cols - 16; j += 16) {\n            uint8x16_t chunk = vld1q_u8(&grid[i][j]);\n            accum = vaddq_u8(accum, chunk);\n\n            uint8x16_t mask = vcgtq_u8(accum, cap);\n            if (vmaxvq_u8(mask) > 0) {\n                total_buckets += vaddvq_u8(vshrq_n_u8(vaddq_u8(accum, vdupq_n_u8(capacity - 1)), 3));\n                accum = vsubq_u8(accum, vmulq_u8(cap, mask));\n            }\n        }\n\n        uint8_t partial_sum = 0;\n        for (; j < cols; ++j) {\n            partial_sum += grid[i][j];\n            if (partial_sum >= capacity) {\n                total_buckets += partial_sum / capacity;\n                partial_sum %= capacity;\n            }\n        }\n\n        total_buckets += (vaddvq_u8(accum) + partial_sum + capacity - 1) / capacity;\n    }\n\n    return total_buckets;\n}\n```"}
{"task_id": "SimdBench_119_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int>> &grid, int capacity) {\n    int total_buckets = 0;\n    size_t rows = grid.size();\n    size_t cols = grid[0].size();\n\n    for (size_t i = 0; i < rows; i += 4) {\n        for (size_t j = 0; j < cols; j += 4) {\n            uint8x16_t chunk1 = vld1q_u8(&grid[i][j]);\n            uint8x16_t chunk2 = vld1q_u8(&grid[i+1][j]);\n            uint8x16_t chunk3 = vld1q_u8(&grid[i+2][j]);\n            uint8x16_t chunk4 = vld1q_u8(&grid[i+3][j]);\n\n            uint8x16_t sum1 = vaddq_u8(chunk1, chunk2);\n            uint8x16_t sum2 = vaddq_u8(chunk3, chunk4);\n            uint8x16_t sum = vaddq_u8(sum1, sum2);\n\n            uint16x8_t sum_high = vpaddlq_u8(sum);\n            uint16x8_t sum_low = vpaddlq_u8(sum);\n            uint32x4_t sum_32 = vpaddlq_u16(sum_high);\n            uint32x4_t sum_32_low = vpaddlq_u16(sum_low);\n            uint64x2_t sum_64 = vpaddlq_u32(sum_32);\n            uint64x2_t sum_64_low = vpaddlq_u32(sum_32_low);\n            uint64_t total = vaddvq_u64(sum_64) + vaddvq_u64(sum_64_low);\n\n            total_buckets += (total + capacity - 1) / capacity;\n        }\n    }\n\n    return total_buckets;\n}\n```"}
{"task_id": "SimdBench_119_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int>> &grid, int capacity) {\n    int rows = grid.size();\n    int cols = grid[0].size();\n    int total_buckets = 0;\n\n    for (int i = 0; i < rows; i += 4) {\n        int remaining_rows = rows - i;\n        if (remaining_rows >= 4) {\n            uint8x16_t row1 = vld1q_u8(grid[i].data());\n            uint8x16_t row2 = vld1q_u8(grid[i + 1].data());\n            uint8x16_t row3 = vld1q_u8(grid[i + 2].data());\n            uint8x16_t row4 = vld1q_u8(grid[i + 3].data());\n\n            uint8x16_t sum1 = vaddq_u8(row1, row2);\n            uint8x16_t sum2 = vaddq_u8(row3, row4);\n            uint8x16_t sum = vaddq_u8(sum1, sum2);\n\n            uint16x8_t sum_high = vpaddlq_u8(sum);\n            uint16x8_t sum_low = vpaddlq_u8(sum_high);\n            uint32x4_t sum_32 = vpaddlq_u16(sum_low);\n            uint32x2_t sum_64 = vpaddlq_u32(sum_32);\n            uint64_t sum_total = vgetq_lane_u64(vreinterpretq_u64_u32(sum_64), 0);\n\n            total_buckets += (sum_total + capacity - 1) / capacity;\n        } else {\n            for (int j = i; j < rows; ++j) {\n                int row_sum = 0;\n                for (int k = 0; k < cols; ++k) {\n                    row_sum += grid[j][k];\n                }\n                total_buckets += (row_sum + capacity - 1) / capacity;\n            }\n        }\n    }\n\n    return total_buckets;\n}\n```"}
{"task_id": "SimdBench_119_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int>> &grid, int capacity) {\n    int rows = grid.size();\n    int cols = grid[0].size();\n    int total_buckets = 0;\n\n    for (int i = 0; i < rows; i += 4) {\n        int remaining_rows = rows - i;\n        if (remaining_rows >= 4) {\n            uint8x16_t row1 = vld1q_u8(grid[i].data());\n            uint8x16_t row2 = vld1q_u8(grid[i + 1].data());\n            uint8x16_t row3 = vld1q_u8(grid[i + 2].data());\n            uint8x16_t row4 = vld1q_u8(grid[i + 3].data());\n\n            uint8x16_t sum1 = vaddq_u8(row1, row2);\n            uint8x16_t sum2 = vaddq_u8(row3, row4);\n            uint8x16_t sum = vaddq_u8(sum1, sum2);\n\n            uint16x8_t sum_high = vpaddlq_u8(sum);\n            uint16x8_t sum_low = vpaddlq_u8(sum);\n            uint32x4_t sum_32 = vpaddlq_u16(sum_high);\n            uint32x4_t sum_32_low = vpaddlq_u16(sum_low);\n            uint64x2_t sum_64 = vpaddlq_u32(sum_32);\n            uint64x2_t sum_64_low = vpaddlq_u32(sum_32_low);\n            uint64_t sum_total = vaddvq_u64(sum_64) + vaddvq_u64(sum_64_low);\n\n            total_buckets += (sum_total + capacity - 1) / capacity;\n        } else {\n            for (int j = i; j < rows; ++j) {\n                int row_sum = 0;\n                for (int k = 0; k < cols; ++k) {\n                    row_sum += grid[j][k];\n                }\n                total_buckets += (row_sum + capacity - 1) / capacity;\n            }\n        }\n    }\n\n    return total_buckets;\n}\n```"}
{"task_id": "SimdBench_119_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int>> &grid, int capacity) {\n    int total_buckets = 0;\n    size_t rows = grid.size();\n    size_t cols = grid[0].size();\n\n    for (size_t i = 0; i < rows; ++i) {\n        size_t j = 0;\n        uint8x16_t accum = vdupq_n_u8(0);\n        uint8x16_t cap = vdupq_n_u8(capacity);\n\n        for (; j <= cols - 16; j += 16) {\n            uint8x16_t chunk = vld1q_u8(&grid[i][j]);\n            accum = vaddq_u8(accum, chunk);\n\n            uint8x16_t mask = vcgtq_u8(accum, cap);\n            if (vmaxvq_u8(mask) > 0) {\n                accum = vsubq_u8(accum, cap);\n                total_buckets++;\n            }\n        }\n\n        uint8_t remaining[16] = {0};\n        for (size_t k = 0; k < cols % 16; ++k) {\n            remaining[k] = grid[i][j + k];\n        }\n\n        uint8x16_t chunk = vld1q_u8(remaining);\n        accum = vaddq_u8(accum, chunk);\n\n        while (true) {\n            uint8x16_t mask = vcgtq_u8(accum, cap);\n            if (vmaxvq_u8(mask) == 0) break;\n            accum = vsubq_u8(accum, cap);\n            total_buckets++;\n        }\n\n        total_buckets += (vmaxvq_u8(accum) + capacity - 1) / capacity;\n    }\n\n    return total_buckets;\n}\n```"}
{"task_id": "SimdBench_120_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    size_t n = lst.size();\n\n    int16x8_t vec_odd = vdupq_n_s16(1);\n    int16x8_t vec_even_pos = vdupq_n_s16(2);\n    int16x8_t vec_zero = vdupq_n_s16(0);\n\n    for (size_t i = 0; i < n - 7; i += 8) {\n        int16x8_t vec = vld1q_s16(&lst[i]);\n        uint16x8_t vec_odd_mask = vceqq_s16(vandq_s16(vec, vec_odd), vec_odd);\n        uint16x8_t vec_even_pos_mask = vceqq_s16(vandq_s16(vaddq_s16(vdupq_n_s16(i), vindex_s16(0, 8)), vec_even_pos), vec_zero);\n        uint16x8_t vec_mask = vandq_u16(vec_odd_mask, vec_even_pos_mask);\n        int16x8_t vec_masked = vandq_s16(vec, vreinterpretq_s16_u16(vec_mask));\n        int32x4_t vec_sum = vpaddlq_s16(vec_masked);\n        vec_sum = vpaddlq_s32(vec_sum);\n        sum += vgetq_lane_s32(vec_sum, 0) + vgetq_lane_s32(vec_sum, 1);\n    }\n\n    for (size_t i = (n & ~7); i < n; i += 2) {\n        if (i % 2 == 0 && lst[i] % 2 == 1) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    size_t n = lst.size();\n\n    int16x8_t vec_odd = vdupq_n_s16(1);\n    int16x8_t vec_even_pos = vdupq_n_s16(2);\n\n    for (size_t i = 0; i < n - 7; i += 8) {\n        int16x8_t vec = vld1q_s16(&lst[i]);\n        uint16x8_t vec_odd_mask = vcgtq_s16(vandq_s16(vec, vec_odd), vdupq_n_s16(0));\n        uint16x8_t vec_even_pos_mask = vcgtq_s16(vandq_s16(vaddq_s16(vdupq_n_s16(i), vdupq_n_s16(0)), vec_even_pos), vdupq_n_s16(0));\n        uint16x8_t vec_mask = vandq_u16(vec_odd_mask, vec_even_pos_mask);\n        int16x8_t vec_masked = vandq_s16(vec, (int16x8_t)vec_mask);\n        int64x2_t vec_sum = vpaddlq_s32(vpaddlq_s16(vec_masked));\n        sum += vgetq_lane_s64(vec_sum, 0) + vgetq_lane_s64(vec_sum, 1);\n    }\n\n    for (size_t i = (n & ~7); i < n; i += 2) {\n        if (i % 2 == 0 && lst[i] % 2 == 1) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    size_t n = lst.size();\n\n    size_t i = 2; // Start from the first even index (index 2)\n    for (; i + 7 < n; i += 8) {\n        int16x8_t data = vld1q_s16(&lst[i]);\n        int16x8_t mask = vdupq_n_s16(1); // Mask for odd numbers\n        uint16x8_t odd_mask = vandq_u16(vreinterpretq_u16_s16(data), vdupq_n_u16(1));\n        int16x8_t odd_data = vreinterpretq_s16_u16(vandq_u16(odd_mask, vreinterpretq_u16_s16(mask)));\n        int32x4_t low_sum = vpadd_s32(vpaddl_s16(vget_low_s16(odd_data)), vpaddl_s16(vget_high_s16(odd_data)));\n        int32x2_t high_sum = vpadd_s32(vget_low_s32(low_sum), vget_high_s32(low_sum));\n        sum += vget_lane_s32(vpadd_s32(high_sum, high_sum), 0);\n    }\n\n    for (; i < n; i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    size_t n = lst.size();\n\n    int16x8_t vec;\n    int16x8_t mask = vdupq_n_s16(1); // Mask to check if the number is odd\n    int16x8_t even_pos_mask = {0, 1, 0, 1, 0, 1, 0, 1}; // Mask for even positions\n    int64x2_t sum_vec = vdupq_n_s64(0);\n\n    for (size_t i = 0; i < n - 7; i += 8) {\n        vec = vld1q_s16(&lst[i]);\n        int16x8_t odd_elements = vandq_s16(vec, mask);\n        int16x8_t even_pos_elements = vandq_s16(vec, even_pos_mask);\n        int16x8_t result = vandq_s16(odd_elements, even_pos_elements);\n        int32x4_t low = vmovl_s16(vget_low_s16(result));\n        int32x4_t high = vmovl_s16(vget_high_s16(result));\n        int64x2_t low_sum = vpaddlq_s32(low);\n        int64x2_t high_sum = vpaddlq_s32(high);\n        sum_vec = vaddq_s64(sum_vec, low_sum);\n        sum_vec = vaddq_s64(sum_vec, high_sum);\n    }\n\n    sum += vgetq_lane_s64(sum_vec, 0) + vgetq_lane_s64(sum_vec, 1);\n\n    for (size_t i = (n & ~7); i < n; i += 2) {\n        if (i % 2 == 0 && lst[i] % 2 == 1) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    size_t n = lst.size();\n\n    int16x8_t vec_odd = vdupq_n_s16(1);\n    int16x8_t vec_even_pos = vdupq_n_s16(2);\n\n    for (size_t i = 0; i < n - 7; i += 8) {\n        int16x8_t vec = vld1q_s16(&lst[i]);\n        int16x8_t vec_odd_mask = vandq_s16(vec, vec_odd);\n        int16x8_t vec_even_pos_mask = vandq_s16(vdupq_n_s16(i), vec_even_pos);\n        int16x8_t vec_result = vandq_s16(vec_odd_mask, vec_even_pos_mask);\n\n        int16x4_t low = vget_low_s16(vec_result);\n        int16x4_t high = vget_high_s16(vec_result);\n\n        sum += vaddv_s16(low) + vaddv_s16(high);\n    }\n\n    for (size_t i = (n & ~7); i < n; i += 2) {\n        if (i % 2 == 0 && lst[i] % 2 == 1) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int32x4_t vsum = vdupq_n_s32(0);\n    int32x4_t vk = vdupq_n_s32(99);\n    int32x4_t vzero = vdupq_n_s32(0);\n\n    for (int i = 0; i < k; i += 4) {\n        int32x4_t v = vld1q_s32(&arr[i]);\n        uint32x4_t vabs = vabsq_s32(v);\n        uint32x4_t vmask = vcleq_s32(vabs, vk);\n        int32x4_t vmasked = vbslq_s32(vmask, v, vzero);\n        vsum = vaddq_s32(vsum, vmasked);\n    }\n\n    int sum = vgetq_lane_s32(vsum, 0) + vgetq_lane_s32(vsum, 1) + vgetq_lane_s32(vsum, 2) + vgetq_lane_s32(vsum, 3);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int32x4_t vsum = vdupq_n_s32(0);\n    int32x4_t vk = vdupq_n_s32(99);\n\n    for (int i = 0; i < k; i += 4) {\n        int32x4_t vdata = vld1q_s32(&arr[i]);\n        int32x4_t vmask = vcleq_s32(vdata, vk);\n        vdata = vandq_s32(vdata, vmask);\n        vsum = vaddq_s32(vsum, vdata);\n    }\n\n    sum += vgetq_lane_s32(vsum, 0);\n    sum += vgetq_lane_s32(vsum, 1);\n    sum += vgetq_lane_s32(vsum, 2);\n    sum += vgetq_lane_s32(vsum, 3);\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    int32x4_t mask = vdupq_n_s32(99);\n    int sum = 0;\n\n    for (int i = 0; i < k; i += 4) {\n        int32x4_t chunk = vld1q_s32(&arr[i]);\n        int32x4_t compare_result = vcleq_s32(chunk, mask);\n        int32x4_t filtered_chunk = vandq_s32(chunk, compare_result);\n        sum_vec = vaddq_s32(sum_vec, filtered_chunk);\n    }\n\n    sum += vgetq_lane_s32(sum_vec, 0);\n    sum += vgetq_lane_s32(sum_vec, 1);\n    sum += vgetq_lane_s32(sum_vec, 2);\n    sum += vgetq_lane_s32(sum_vec, 3);\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int32x4_t vsum = vdupq_n_s32(0);\n    int32x4_t vk = vdupq_n_s32(99);\n    int32x4_t vzero = vdupq_n_s32(0);\n\n    int i = 0;\n    for (; i <= k - 4; i += 4) {\n        int32x4_t v = vld1q_s32(&arr[i]);\n        uint32x4_t vabs = vabsq_s32(v);\n        int32x4_t vcmp = vcleq_s32(vabs, vk);\n        vsum = vaddq_s32(vsum, vandq_s32(v, vcmp));\n    }\n\n    int sum = vaddvq_s32(vsum);\n\n    for (; i < k; ++i) {\n        if (arr[i] <= 99 && arr[i] >= -99) {\n            sum += arr[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int32x4_t vsum = vdupq_n_s32(0);\n    int32x4_t vk = vdupq_n_s32(100);\n    int32x4_t vmask = vdupq_n_s32(99);\n\n    for (int i = 0; i < k; i += 4) {\n        int32x4_t vdata = vld1q_s32(&arr[i]);\n        int32x4_t vcmp = vcleq_s32(vdata, vk);\n        vdata = vandq_s32(vdata, vcmp);\n        vdata = vandq_s32(vdata, vmask);\n        vsum = vaddq_s32(vsum, vdata);\n    }\n\n    int sum = vgetq_lane_s32(vsum, 0) + vgetq_lane_s32(vsum, 1) + vgetq_lane_s32(vsum, 2) + vgetq_lane_s32(vsum, 3);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_122_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int>& lst) {\n    if (lst.size() <= 1) return true;\n\n    size_t i = 0;\n    int32x4_t prev = vdupq_n_s32(lst[0]);\n    int32x4_t current;\n    uint32x4_t cmp_gt, cmp_eq;\n    uint32x4_t mask_gt = vdupq_n_u32(0xFFFFFFFF);\n    uint32x4_t mask_eq = vdupq_n_u32(0);\n    bool sorted = true;\n    bool duplicate = false;\n\n    for (i = 1; i <= lst.size() - 4; i += 4) {\n        current = vld1q_s32(&lst[i]);\n        cmp_gt = vcgtq_s32(current, prev);\n        cmp_eq = vceqq_s32(current, prev);\n\n        if (vminvq_u32(cmp_gt) != 0xFFFFFFFF) {\n            sorted = false;\n            break;\n        }\n\n        if (vmaxvq_u32(cmp_eq) == 0xFFFFFFFF) {\n            duplicate = true;\n            break;\n        }\n\n        prev = current;\n    }\n\n    if (sorted && !duplicate) {\n        for (; i < lst.size(); ++i) {\n            if (lst[i] <= lst[i - 1]) {\n                sorted = false;\n                break;\n            }\n        }\n    }\n\n    return sorted && !duplicate;\n}\n```"}
{"task_id": "SimdBench_122_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    if (lst.size() <= 1) return true;\n\n    size_t i = 0;\n    int32x4_t prev = vdupq_n_s32(lst[0]);\n    int32x4_t current;\n    uint32x4_t compare_gt;\n    uint32x4_t compare_eq;\n    uint32x4_t compare_result;\n\n    for (; i <= lst.size() - 4; i += 4) {\n        current = vld1q_s32(&lst[i]);\n        compare_gt = vcgtq_s32(current, prev);\n        compare_eq = vceqq_s32(current, prev);\n        compare_result = vorrq_u32(compare_gt, compare_eq);\n\n        if (vminvq_u32(compare_result) == 0) {\n            return false;\n        }\n\n        prev = current;\n    }\n\n    for (; i < lst.size(); ++i) {\n        if (lst[i] < lst[i - 1]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int>& lst) {\n    if (lst.size() <= 1) return true;\n\n    size_t n = lst.size();\n    size_t i = 0;\n    int32x4_t prev = vld1q_dup_s32(&lst[0]);\n    int32x4_t curr;\n    uint32x4_t cmp;\n\n    for (i = 1; i <= n - 4; i += 4) {\n        curr = vld1q_s32(&lst[i]);\n        cmp = vcltq_s32(vsubq_s32(curr, prev), vdupq_n_s32(1));\n        if (vminvq_u32(cmp) == 0) return false;\n        prev = curr;\n    }\n\n    for (; i < n; ++i) {\n        if (lst[i] < lst[i - 1]) return false;\n    }\n\n    std::vector<int> unique_count(2048, 0);\n    for (const int& num : lst) {\n        unique_count[num]++;\n        if (unique_count[num] > 2) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int>& lst) {\n    if (lst.size() <= 1) return true;\n\n    size_t i;\n    int32x4_t prev = vdupq_n_s32(lst[0]);\n    int32x4_t curr;\n    uint32x4_t cmp;\n\n    for (i = 1; i < lst.size(); i += 4) {\n        curr = vld1q_s32(&lst[i]);\n        cmp = vcltq_s32(prev, curr);\n        if (vgetq_lane_u32(cmp, 0) && vgetq_lane_u32(cmp, 1) && vgetq_lane_u32(cmp, 2) && vgetq_lane_u32(cmp, 3)) {\n            return false;\n        }\n        prev = curr;\n    }\n\n    if (i > lst.size()) {\n        for (size_t j = i - 4; j < lst.size(); ++j) {\n            if (lst[j] > lst[j + 1]) {\n                return false;\n            }\n        }\n    }\n\n    std::vector<int> counts(1000001, 0);\n    for (const int& num : lst) {\n        counts[num]++;\n        if (counts[num] > 2) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int>& lst) {\n    if (lst.size() <= 1) return true;\n\n    size_t i = 0;\n    int32x4_t prev = vld1q_dup_s32(&lst[0]);\n    int32x4_t current;\n    uint32x4_t diff;\n    uint32x4_t zero = vdupq_n_u32(0);\n    uint32x4_t one = vdupq_n_u32(1);\n\n    for (; i <= lst.size() - 4; i += 4) {\n        current = vld1q_s32(&lst[i]);\n        diff = vcltq_s32(vsubq_s32(current, prev), one);\n        if (vmaxvq_u32(diff) == 0) return false;\n        prev = current;\n    }\n\n    for (; i < lst.size(); ++i) {\n        if (lst[i] < lst[i - 1]) return false;\n    }\n\n    std::vector<int> unique_count(lst.size(), 0);\n    for (const auto& num : lst) {\n        unique_count[num]++;\n        if (unique_count[num] > 2) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_123_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    int32x4_t prod_vec = vdupq_n_s32(1);\n    int32x4_t zero_vec = vdupq_n_s32(0);\n    int32x4_t one_vec = vdupq_n_s32(1);\n    int32x4_t neg_one_vec = vdupq_n_s32(-1);\n\n    size_t i;\n    for (i = 0; i <= arr.size() - 4; i += 4) {\n        int32x4_t chunk = vld1q_s32(&arr[i]);\n        int32x4_t sign_chunk = vbslq_s32(vcltq_s32(chunk, zero_vec), neg_one_vec, one_vec);\n        sign_chunk = vbslq_s32(vceqq_s32(chunk, zero_vec), zero_vec, sign_chunk);\n\n        prod_vec = vmulq_s32(prod_vec, sign_chunk);\n        sum_vec = vaddq_s32(sum_vec, vabsq_s32(chunk));\n    }\n\n    int32_t sum = vaddvq_s32(sum_vec);\n    int32_t prod = vaddvq_s32(prod_vec);\n\n    for (; i < arr.size(); ++i) {\n        int num = arr[i];\n        int sign = (num > 0) - (num < 0);\n        prod *= sign;\n        sum += abs(num);\n    }\n\n    return sum * prod;\n}\n```"}
{"task_id": "SimdBench_123_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    int32x4_t prod_vec = vdupq_n_s32(1);\n    int32x4_t zero_vec = vdupq_n_s32(0);\n    int32x4_t one_vec = vdupq_n_s32(1);\n    int32x4_t neg_one_vec = vdupq_n_s32(-1);\n\n    size_t i;\n    for (i = 0; i <= arr.size() - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&arr[i]);\n        int32x4_t abs_vec = vabsq_s32(vec);\n        int32x4_t sign_vec = vbslq_s32(vcltq_s32(vec, zero_vec), neg_one_vec, one_vec);\n\n        sum_vec = vaddq_s32(sum_vec, abs_vec);\n        prod_vec = vmulq_s32(prod_vec, sign_vec);\n    }\n\n    int sum = vaddvq_s32(sum_vec);\n    int prod = vaddvq_s32(prod_vec);\n\n    for (; i < arr.size(); ++i) {\n        int val = arr[i];\n        sum += std::abs(val);\n        prod *= (val < 0) ? -1 : 1;\n    }\n\n    return sum * prod;\n}\n```"}
{"task_id": "SimdBench_123_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    int32x4_t prod_vec = vdupq_n_s32(1);\n    int32x4_t zero_vec = vdupq_n_s32(0);\n    int32x4_t one_vec = vdupq_n_s32(1);\n    int32x4_t neg_one_vec = vdupq_n_s32(-1);\n\n    size_t i;\n    for (i = 0; i <= arr.size() - 4; i += 4) {\n        int32x4_t chunk = vld1q_s32(&arr[i]);\n        int32x4_t sign_chunk = vbslq_s32(vcltq_s32(chunk, zero_vec), neg_one_vec, one_vec);\n        sign_chunk = vbslq_s32(vceqq_s32(chunk, zero_vec), zero_vec, sign_chunk);\n\n        sum_vec = vaddq_s32(sum_vec, vabsq_s32(chunk));\n        prod_vec = vmulq_s32(prod_vec, sign_chunk);\n    }\n\n    int32_t sum = vaddvq_s32(sum_vec);\n    int32_t prod = vaddvq_s32(prod_vec);\n\n    for (; i < arr.size(); ++i) {\n        int val = arr[i];\n        int sign = (val > 0) ? 1 : (val < 0) ? -1 : 0;\n        sum += abs(val);\n        prod *= sign;\n    }\n\n    return sum * prod;\n}\n```"}
{"task_id": "SimdBench_123_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    int32x4_t prod_vec = vdupq_n_s32(1);\n    int32x4_t zero_vec = vdupq_n_s32(0);\n    int32x4_t one_vec = vdupq_n_s32(1);\n    int32x4_t neg_one_vec = vdupq_n_s32(-1);\n\n    size_t i;\n    for (i = 0; i <= arr.size() - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&arr[i]);\n        int32x4_t abs_vec = vabsq_s32(vec);\n        int32x4_t sign_vec = vbslq_s32(vcltq_s32(vec, zero_vec), neg_one_vec, one_vec);\n\n        sum_vec = vaddq_s32(sum_vec, abs_vec);\n        prod_vec = vmulq_s32(prod_vec, sign_vec);\n    }\n\n    int32_t sum[4];\n    int32_t prod[4];\n    vst1q_s32(sum, sum_vec);\n    vst1q_s32(prod, prod_vec);\n\n    int total_sum = sum[0] + sum[1] + sum[2] + sum[3];\n    int total_prod = prod[0] * prod[1] * prod[2] * prod[3];\n\n    for (; i < arr.size(); ++i) {\n        int val = arr[i];\n        total_sum += std::abs(val);\n        total_prod *= (val < 0) ? -1 : 1;\n    }\n\n    return total_sum * total_prod;\n}\n```"}
{"task_id": "SimdBench_123_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    int32x4_t prod_vec = vdupq_n_s32(1);\n    int32x4_t zero_vec = vdupq_n_s32(0);\n    int32x4_t one_vec = vdupq_n_s32(1);\n    int32x4_t neg_one_vec = vdupq_n_s32(-1);\n\n    size_t i;\n    for (i = 0; i <= arr.size() - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&arr[i]);\n        int32x4_t abs_vec = vabsq_s32(vec);\n        int32x4_t sign_vec = vbslq_s32(vceqq_s32(vec, zero_vec), zero_vec,\n                                       vbslq_s32(vcltq_s32(vec, zero_vec), neg_one_vec, one_vec));\n\n        sum_vec = vaddq_s32(sum_vec, abs_vec);\n        prod_vec = vmulq_s32(prod_vec, sign_vec);\n    }\n\n    int sum = vaddvq_s32(sum_vec);\n    int prod = vaddvq_s32(prod_vec);\n\n    for (; i < arr.size(); ++i) {\n        int val = arr[i];\n        sum += std::abs(val);\n        if (val == 0) continue;\n        prod *= (val > 0) ? 1 : -1;\n    }\n\n    return sum * prod;\n}\n```"}
{"task_id": "SimdBench_124_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <limits.h>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>> &grid, int k) {\n    int N = grid.size();\n    std::vector<int> minPath(k, INT_MAX);\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            std::vector<int> currentPath = {grid[i][j]};\n            int cx = i, cy = j;\n            int steps = 1;\n\n            while (steps < k) {\n                int minVal = INT_MAX;\n                int nextX = -1, nextY = -1;\n\n                int32x4_t currentVal = vdupq_n_s32(grid[cx][cy]);\n\n                if (cx > 0) {\n                    int32x4_t neighborVal = vdupq_n_s32(grid[cx - 1][cy]);\n                    int32x4_t minV = vminq_s32(currentVal, neighborVal);\n                    if (vgetq_lane_s32(minV, 0) < minVal) {\n                        minVal = grid[cx - 1][cy];\n                        nextX = cx - 1;\n                        nextY = cy;\n                    }\n                }\n                if (cx < N - 1) {\n                    int32x4_t neighborVal = vdupq_n_s32(grid[cx + 1][cy]);\n                    int32x4_t minV = vminq_s32(currentVal, neighborVal);\n                    if (vgetq_lane_s32(minV, 0) < minVal) {\n                        minVal = grid[cx + 1][cy];\n                        nextX = cx + 1;\n                        nextY = cy;\n                    }\n                }\n                if (cy > 0) {\n                    int32x4_t neighborVal = vdupq_n_s32(grid[cx][cy - 1]);\n                    int32x4_t minV = vminq_s32(currentVal, neighborVal);\n                    if (vgetq_lane_s32(minV, 0) < minVal) {\n                        minVal = grid[cx][cy - 1];\n                        nextX = cx;\n                        nextY = cy - 1;\n                    }\n                }\n                if (cy < N - 1) {\n                    int32x4_t neighborVal = vdupq_n_s32(grid[cx][cy + 1]);\n                    int32x4_t minV = vminq_s32(currentVal, neighborVal);\n                    if (vgetq_lane_s32(minV, 0) < minVal) {\n                        minVal = grid[cx][cy + 1];\n                        nextX = cx;\n                        nextY = cy + 1;\n                    }\n                }\n\n                currentPath.push_back(minVal);\n                cx = nextX;\n                cy = nextY;\n                ++steps;\n            }\n\n            if (std::lexicographical_compare(currentPath.begin(), currentPath.end(), minPath.begin(), minPath.end())) {\n                minPath = currentPath;\n            }\n        }\n    }\n\n    return minPath;\n}\n```"}
{"task_id": "SimdBench_124_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <limits.h>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>> &grid, int k) {\n    int N = grid.size();\n    std::vector<int> minPath(k, INT_MAX);\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            std::vector<int> currentPath = {grid[i][j]};\n            dfs_simd(grid, i, j, currentPath, minPath, k, N);\n        }\n    }\n\n    minPath.resize(k);\n    return minPath;\n}\n\nvoid dfs_simd(const std::vector<std::vector<int>> &grid, int x, int y, std::vector<int> &currentPath, std::vector<int> &minPath, int k, int N) {\n    if (currentPath.size() == k) {\n        if (std::lexicographical_compare(currentPath.begin(), currentPath.end(), minPath.begin(), minPath.end())) {\n            minPath = currentPath;\n        }\n        return;\n    }\n\n    int32x4_t currentPathVec = vld1q_dup_s32(&currentPath.back());\n    int32x4_t minPathVec = vld1q_dup_s32(&minPath.back());\n\n    if (vgetq_lane_s32(currentPathVec, 0) >= vgetq_lane_s32(minPathVec, 0)) {\n        return;\n    }\n\n    static const int dx[] = {-1, 1, 0, 0};\n    static const int dy[] = {0, 0, -1, 1};\n\n    for (int d = 0; d < 4; ++d) {\n        int nx = x + dx[d];\n        int ny = y + dy[d];\n        if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n            currentPath.push_back(grid[nx][ny]);\n            dfs_simd(grid, nx, ny, currentPath, minPath, k, N);\n            currentPath.pop_back();\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_124_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <limits.h>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>> &grid, int k) {\n    int N = grid.size();\n    std::vector<int> minPath(k, INT_MAX);\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            std::vector<int> currentPath = {grid[i][j]};\n            dfs_simd(grid, i, j, k, 1, currentPath, minPath);\n        }\n    }\n\n    return minPath;\n}\n\nvoid dfs_simd(const std::vector<std::vector<int>> &grid, int x, int y, int k, int len, std::vector<int> &currentPath, std::vector<int> &minPath) {\n    if (len == k) {\n        if (std::lexicographical_compare(currentPath.begin(), currentPath.end(), minPath.begin(), minPath.end())) {\n            minPath = currentPath;\n        }\n        return;\n    }\n\n    int N = grid.size();\n    int32x4_t currentPathVec = vld1q_dup_s32(&currentPath[len - 1]);\n    int32x4_t minPathVec = vld1q_dup_s32(&minPath[len - 1]);\n\n    if (vgetq_lane_s32(currentPathVec, 0) > vgetq_lane_s32(minPathVec, 0)) {\n        return;\n    }\n\n    static const int dx[] = {-1, 1, 0, 0};\n    static const int dy[] = {0, 0, -1, 1};\n\n    for (int d = 0; d < 4; ++d) {\n        int nx = x + dx[d];\n        int ny = y + dy[d];\n        if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n            currentPath.push_back(grid[nx][ny]);\n            dfs_simd(grid, nx, ny, k, len + 1, currentPath, minPath);\n            currentPath.pop_back();\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_124_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <limits.h>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>> &grid, int k) {\n    int N = grid.size();\n    std::vector<int> minPath(k, INT_MAX);\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            std::vector<int> currentPath = {grid[i][j]};\n            dfs_simd(grid, i, j, currentPath, minPath, k, N);\n        }\n    }\n\n    minPath.resize(k);\n    return minPath;\n}\n\nvoid dfs_simd(const std::vector<std::vector<int>> &grid, int x, int y, std::vector<int> &currentPath, std::vector<int> &minPath, int k, int N) {\n    if (currentPath.size() == k) {\n        if (std::lexicographical_compare(currentPath.begin(), currentPath.end(), minPath.begin(), minPath.end())) {\n            minPath = currentPath;\n        }\n        return;\n    }\n\n    int32x4_t currentPathVec = vld1q_dup_s32(&currentPath.back());\n    int32x4_t minPathVec = vld1q_dup_s32(&minPath.back());\n\n    static const int dx[] = {0, 1, 0, -1};\n    static const int dy[] = {1, 0, -1, 0};\n\n    for (int d = 0; d < 4; ++d) {\n        int nx = x + dx[d];\n        int ny = y + dy[d];\n        if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n            currentPath.push_back(grid[nx][ny]);\n            dfs_simd(grid, nx, ny, currentPath, minPath, k, N);\n            currentPath.pop_back();\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_124_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <limits.h>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>> &grid, int k) {\n    int N = grid.size();\n    std::vector<int> minPath(k, INT_MAX);\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            std::vector<int> currentPath = {grid[i][j]};\n            dfs_simd(grid, i, j, currentPath, k, minPath);\n        }\n    }\n\n    minPath.resize(k);\n    return minPath;\n}\n\nvoid dfs_simd(const std::vector<std::vector<int>> &grid, int x, int y, std::vector<int> &currentPath, int k, std::vector<int> &minPath) {\n    if (currentPath.size() == k) {\n        if (std::lexicographical_compare(currentPath.begin(), currentPath.end(), minPath.begin(), minPath.end())) {\n            minPath = currentPath;\n        }\n        return;\n    }\n\n    int N = grid.size();\n    int32x4_t pathVec = vdupq_n_s32(INT_MAX);\n    int32x4_t currentVec = vld1q_s32(currentPath.data());\n\n    static const int dx[] = {0, 1, 0, -1};\n    static const int dy[] = {1, 0, -1, 0};\n\n    for (int d = 0; d < 4; ++d) {\n        int nx = x + dx[d];\n        int ny = y + dy[d];\n        if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n            int nextVal = grid[nx][ny];\n            int32x4_t nextVec = vsetq_lane_s32(nextVal, currentVec, 3);\n            if (vgetq_lane_s32(nextVec, 3) < vgetq_lane_s32(pathVec, 3)) {\n                currentPath.push_back(nextVal);\n                dfs_simd(grid, nx, ny, currentPath, k, minPath);\n                currentPath.pop_back();\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_125_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nuint64_t digits_simd(uint64_t n) {\n    uint64_t product = 1;\n    uint64_t has_odd = 0;\n\n    while (n > 0) {\n        uint64_t digit = n % 10;\n        n /= 10;\n\n        uint64x1_t v_digit = vdup_n_u64(digit);\n        uint64x1_t v_odd_mask = vdup_n_u64(1);\n        uint64x1_t v_is_odd = vand_u64(v_digit, v_odd_mask);\n\n        if (vget_lane_u64(v_is_odd, 0) == 1) {\n            product *= digit;\n            has_odd = 1;\n        }\n    }\n\n    return has_odd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_125_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nuint64_t digits_simd(uint64_t n) {\n    uint64_t product = 1;\n    uint64_t has_odd = 0;\n\n    while (n > 0) {\n        uint64_t digit = n % 10;\n        n /= 10;\n\n        uint64x1_t digit_vec = vdup_n_u64(digit);\n        uint64x1_t odd_mask = vdup_n_u64(1);\n        uint64x1_t is_odd = vand_u64(digit_vec, odd_mask);\n\n        if (vget_lane_u64(is_odd, 0) == 1) {\n            product *= digit;\n            has_odd = 1;\n        }\n    }\n\n    return has_odd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_125_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nuint64_t digits_simd(uint64_t n) {\n    uint64_t product = 1;\n    uint64_t has_odd = 0;\n\n    while (n > 0) {\n        uint64_t digit = n % 10;\n        n /= 10;\n\n        uint64x1_t v_digit = vdup_n_u64(digit);\n        uint64x1_t v_odd_mask = vdup_n_u64(1);\n\n        uint64x1_t v_is_odd = vand_u64(v_digit, v_odd_mask);\n        uint64_t is_odd = vget_lane_u64(v_is_odd, 0);\n\n        if (is_odd) {\n            product *= digit;\n            has_odd = 1;\n        }\n    }\n\n    return has_odd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_125_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nuint64_t digits_simd(uint64_t n) {\n    uint64_t product = 1;\n    uint64_t has_odd = 0;\n\n    while (n > 0) {\n        uint64_t digit = n % 10;\n        n /= 10;\n\n        if (digit % 2 != 0) {\n            product *= digit;\n            has_odd = 1;\n        }\n    }\n\n    return has_odd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_125_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nuint64_t digits_simd(uint64_t n) {\n    uint64_t product = 1;\n    uint64_t has_odd = 0;\n\n    while (n > 0) {\n        uint64_t digit = n % 10;\n        n /= 10;\n\n        uint64x1_t v_digit = vdup_n_u64(digit);\n        uint64x1_t v_odd_mask = vdup_n_u64(1);\n\n        uint64x1_t v_is_odd = vand_u64(v_digit, v_odd_mask);\n        uint64_t is_odd = vget_lane_u64(v_is_odd, 0);\n\n        if (is_odd) {\n            product *= digit;\n            has_odd = 1;\n        }\n    }\n\n    return has_odd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_126_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    size_t size = lst.size();\n    size_t i = 0;\n\n    float32x4_t vsum = vdupq_n_f32(0.0f);\n\n    for (; i <= size - 4; i += 4) {\n        float32x4_t v = vld1q_f32(&lst[i]);\n        v = vaddq_f32(v, vdupq_n_f32(0.5f));\n        v = vcvtq_f32_s32(vcvtq_s32_f32(v));\n        v = vmulq_f32(v, v);\n        vsum = vaddq_f32(vsum, v);\n    }\n\n    float tmp[4];\n    vst1q_f32(tmp, vsum);\n    sum = tmp[0] + tmp[1] + tmp[2] + tmp[3];\n\n    for (; i < size; ++i) {\n        float val = std::ceil(lst[i]);\n        sum += val * val;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    size_t size = lst.size();\n    size_t i = 0;\n\n    float32x4_t vsum = vdupq_n_f32(0.0f);\n\n    for (; i <= size - 4; i += 4) {\n        float32x4_t v = vld1q_f32(&lst[i]);\n        v = vaddq_f32(v, vdupq_n_f32(0.5f));\n        v = vcvtq_f32_s32(vcvtq_s32_f32(v));\n        v = vmulq_f32(v, v);\n        vsum = vaddq_f32(vsum, v);\n    }\n\n    float tmp[4];\n    vst1q_f32(tmp, vsum);\n    sum = tmp[0] + tmp[1] + tmp[2] + tmp[3];\n\n    for (; i < size; ++i) {\n        float val = lst[i];\n        val = std::ceil(val);\n        sum += val * val;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    size_t size = lst.size();\n    size_t i;\n\n    float32x4_t vsum = vdupq_n_f32(0.0f);\n\n    for (i = 0; i <= size - 4; i += 4) {\n        float32x4_t v = vld1q_f32(&lst[i]);\n        v = vrndq_f32(v); // Round to nearest integer\n        v = vmaxq_f32(v, v); // Ensure all values are positive\n        v = vmulq_f32(v, v); // Square the values\n        vsum = vaddq_f32(vsum, v); // Accumulate the sum\n    }\n\n    float tmp[4];\n    vst1q_f32(tmp, vsum);\n    sum = tmp[0] + tmp[1] + tmp[2] + tmp[3];\n\n    for (; i < size; ++i) {\n        float val = std::ceil(lst[i]);\n        sum += val * val;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    size_t size = lst.size();\n    size_t i = 0;\n\n    float32x4_t vsum = vdupq_n_f32(0.0f);\n\n    for (; i <= size - 4; i += 4) {\n        float32x4_t v = vld1q_f32(&lst[i]);\n        v = vaddq_f32(v, vdupq_n_f32(0.5f));\n        v = vcvtq_f32_s32(vcvtq_s32_f32(v));\n        v = vmulq_f32(v, v);\n        vsum = vaddq_f32(vsum, v);\n    }\n\n    float tmp[4];\n    vst1q_f32(tmp, vsum);\n    sum = tmp[0] + tmp[1] + tmp[2] + tmp[3];\n\n    for (; i < size; ++i) {\n        float val = std::ceil(lst[i]);\n        sum += val * val;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    size_t size = lst.size();\n    size_t i = 0;\n\n    float32x4_t vsum = vdupq_n_f32(0.0f);\n\n    for (; i <= size - 4; i += 4) {\n        float32x4_t v = vld1q_f32(&lst[i]);\n        v = vaddq_f32(v, vdupq_n_f32(0.5f));\n        v = vcvtq_f32_s32(vcvtq_s32_f32(v));\n        v = vmulq_f32(v, v);\n        vsum = vaddq_f32(vsum, v);\n    }\n\n    float tmp[4];\n    vst1q_f32(tmp, vsum);\n    sum = tmp[0] + tmp[1] + tmp[2] + tmp[3];\n\n    for (; i < size; ++i) {\n        float val = std::ceil(lst[i]);\n        sum += val * val;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_127_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    int result = -1;\n\n    for (int i = 0; i < n - 3; i += 4) {\n        int32x4_t v = vld1q_s32(&arr[i]);\n        int32x4_t v_next = vld1q_s32(&arr[i + 1]);\n\n        uint32x4_t cmp = vcgeq_s32(v, v_next);\n        uint32_t mask = vgetq_lane_u32(vreinterpretq_u32_u64(vcntq_u32(cmp)), 0);\n\n        if (mask != 0) {\n            if (mask & (1 << 0)) result = i + 1;\n            if (mask & (1 << 1)) result = i + 2;\n            if (mask & (1 << 2)) result = i + 3;\n        }\n    }\n\n    for (int i = n - (n % 4); i < n - 1; ++i) {\n        if (arr[i] >= arr[i + 1]) {\n            result = i + 1;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n < 2) return -1;\n\n    int32x4_t prev = vld1q_dup_s32(&arr[0]);\n    int result = -1;\n\n    for (int i = 1; i < n; i += 4) {\n        int32x4_t current = vld1q_s32(&arr[i]);\n        uint32x4_t cmp = vcltq_s32(current, prev);\n\n        if (vgetq_lane_u32(cmp, 0) || vgetq_lane_u32(cmp, 1) || vgetq_lane_u32(cmp, 2) || vgetq_lane_u32(cmp, 3)) {\n            for (int j = 0; j < 4; j++) {\n                if (i + j < n && arr[i + j] < arr[i + j - 1]) {\n                    result = i + j;\n                }\n            }\n            return result;\n        }\n\n        prev = current;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int>& arr) {\n    int n = arr.size();\n    if (n < 2) return -1;\n\n    int32x4_t prev = vld1q_s32(&arr[0]);\n    int result = -1;\n\n    for (int i = 4; i < n; i += 4) {\n        int32x4_t current = vld1q_s32(&arr[i]);\n        uint32x4_t cmp = vcltq_s32(current, prev);\n\n        if (vgetq_lane_u32(cmp, 0) || vgetq_lane_u32(cmp, 1) || vgetq_lane_u32(cmp, 2) || vgetq_lane_u32(cmp, 3)) {\n            for (int j = 0; j < 4; ++j) {\n                if (arr[i + j] < arr[i + j - 1]) {\n                    result = i + j;\n                }\n            }\n            return result;\n        }\n        prev = current;\n    }\n\n    for (int i = n - (n % 4); i < n; ++i) {\n        if (arr[i] < arr[i - 1]) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n```"}
{"task_id": "SimdBench_127_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n < 2) return -1;\n\n    int32x4_t prev = vld1q_s32(&arr[0]);\n    int result = -1;\n\n    for (int i = 4; i < n; i += 4) {\n        int32x4_t current = vld1q_s32(&arr[i]);\n        uint32x4_t cmp = vcltq_s32(current, prev);\n        if (vgetq_lane_u32(cmp, 0) || vgetq_lane_u32(cmp, 1) || vgetq_lane_u32(cmp, 2) || vgetq_lane_u32(cmp, 3)) {\n            for (int j = 0; j < 4; ++j) {\n                if (arr[i + j] < arr[i + j - 1]) {\n                    result = i + j;\n                }\n            }\n            return result;\n        }\n        prev = current;\n    }\n\n    for (int i = n - (n % 4); i < n; ++i) {\n        if (arr[i] < arr[i - 1]) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n```"}
{"task_id": "SimdBench_127_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n < 2) return -1;\n\n    int32x4_t prev = vld1q_s32(&arr[0]);\n    int index = -1;\n\n    for (int i = 4; i < n; i += 4) {\n        int32x4_t current = vld1q_s32(&arr[i]);\n        uint32x4_t cmp = vcltq_s32(current, prev);\n        if (vgetq_lane_u32(cmp, 0) || vgetq_lane_u32(cmp, 1) || vgetq_lane_u32(cmp, 2) || vgetq_lane_u32(cmp, 3)) {\n            for (int j = 0; j < 4; ++j) {\n                if (vgetq_lane_u32(cmp, j)) {\n                    index = i + j;\n                    break;\n                }\n            }\n            break;\n        }\n        prev = current;\n    }\n\n    if (index == -1) {\n        for (int i = n - (n % 4); i < n; ++i) {\n            if (arr[i] < arr[i - 1]) {\n                index = i;\n                break;\n            }\n        }\n    }\n\n    return index;\n}\n```"}
{"task_id": "SimdBench_128_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cstdint>\n#include <algorithm>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) return {0, 0};\n\n    int32x4_t vmax_neg = vdupq_n_s32(INT32_MIN);\n    int32x4_t vmin_pos = vdupq_n_s32(INT32_MAX);\n    int32x4_t vzero = vdupq_n_s32(0);\n\n    bool has_neg = false;\n    bool has_pos = false;\n\n    size_t i;\n    for (i = 0; i <= lst.size() - 4; i += 4) {\n        int32x4_t v = vld1q_s32(&lst[i]);\n        int32x4_t vmask_neg = vcltq_s32(v, vzero);\n        int32x4_t vmask_pos = vcgtq_s32(v, vzero);\n\n        int32x4_t vneg = vbslq_s32(vmask_neg, v, vmax_neg);\n        int32x4_t vpos = vbslq_s32(vmask_pos, v, vmin_pos);\n\n        vmax_neg = vmaxq_s32(vmax_neg, vneg);\n        vmin_pos = vminq_s32(vmin_pos, vpos);\n\n        has_neg |= vmaxvq_u32(vmask_neg) != 0;\n        has_pos |= vmaxvq_u32(vmask_pos) != 0;\n    }\n\n    int max_neg = INT32_MIN;\n    int min_pos = INT32_MAX;\n\n    if (has_neg) {\n        int32_t aligned_max_neg[4];\n        vst1q_s32(aligned_max_neg, vmax_neg);\n        for (int j = 0; j < 4; ++j) {\n            if (aligned_max_neg[j] < 0) {\n                max_neg = std::max(max_neg, aligned_max_neg[j]);\n            }\n        }\n    }\n\n    if (has_pos) {\n        int32_t aligned_min_pos[4];\n        vst1q_s32(aligned_min_pos, vmin_pos);\n        for (int j = 0; j < 4; ++j) {\n            if (aligned_min_pos[j] > 0) {\n                min_pos = std::min(min_pos, aligned_min_pos[j]);\n            }\n        }\n    }\n\n    for (; i < lst.size(); ++i) {\n        if (lst[i] < 0) {\n            max_neg = std::max(max_neg, lst[i]);\n        } else if (lst[i] > 0) {\n            min_pos = std::min(min_pos, lst[i]);\n        }\n    }\n\n    if (!has_neg) max_neg = 0;\n    if (!has_pos) min_pos = 0;\n\n    return {max_neg, min_pos};\n}\n```"}
{"task_id": "SimdBench_128_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cstdint>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    int32x4_t vmax_neg = vdupq_n_s32(INT32_MIN);\n    int32x4_t vmin_pos = vdupq_n_s32(INT32_MAX);\n    int32x4_t vzero = vdupq_n_s32(0);\n\n    bool has_negative = false;\n    bool has_positive = false;\n\n    for (size_t i = 0; i < lst.size(); i += 4) {\n        int32x4_t v = vld1q_s32(&lst[i]);\n        int32x4_t vneg = vcltq_s32(v, vzero);\n        int32x4_t vpos = vcgtq_s32(v, vzero);\n\n        vmax_neg = vbslq_s32(vneg, vmaxq_s32(vmax_neg, v), vmax_neg);\n        vmin_pos = vbslq_s32(vpos, vminq_s32(vmin_pos, v), vmin_pos);\n\n        has_negative |= vmax_neg != vdupq_n_s32(INT32_MIN);\n        has_positive |= vmin_pos != vdupq_n_s32(INT32_MAX);\n    }\n\n    int32_t max_neg = INT32_MIN;\n    int32_t min_pos = INT32_MAX;\n\n    if (has_negative) {\n        int32_t tmp[4];\n        vst1q_s32(tmp, vmax_neg);\n        for (int i = 0; i < 4; ++i) {\n            if (tmp[i] < 0 && tmp[i] > max_neg) {\n                max_neg = tmp[i];\n            }\n        }\n    }\n\n    if (has_positive) {\n        int32_t tmp[4];\n        vst1q_s32(tmp, vmin_pos);\n        for (int i = 0; i < 4; ++i) {\n            if (tmp[i] > 0 && tmp[i] < min_pos) {\n                min_pos = tmp[i];\n            }\n        }\n    }\n\n    if (!has_negative) max_neg = 0;\n    if (!has_positive) min_pos = 0;\n\n    return {max_neg, min_pos};\n}\n```"}
{"task_id": "SimdBench_128_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cstdint>\n#include <algorithm>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) return {0, 0};\n\n    int32x4_t vmax_neg = vdupq_n_s32(INT32_MIN);\n    int32x4_t vmin_pos = vdupq_n_s32(INT32_MAX);\n    int32_t max_neg = INT32_MIN;\n    int32_t min_pos = INT32_MAX;\n    bool has_neg = false;\n    bool has_pos = false;\n\n    size_t i;\n    for (i = 0; i <= lst.size() - 4; i += 4) {\n        int32x4_t v = vld1q_s32(&lst[i]);\n        int32x4_t vmask_neg = vcltq_s32(v, vdupq_n_s32(0));\n        int32x4_t vmask_pos = vcgtq_s32(v, vdupq_n_s32(0));\n\n        int32x4_t vneg = vbslq_s32(vmask_neg, v, vdupq_n_s32(INT32_MIN));\n        int32x4_t vpos = vbslq_s32(vmask_pos, v, vdupq_n_s32(INT32_MAX));\n\n        vmax_neg = vmaxq_s32(vmax_neg, vneg);\n        vmin_pos = vminq_s32(vmin_pos, vpos);\n\n        has_neg |= vmaxvq_u32(vmovn_u64(vreinterpretq_u64_s32(vmask_neg))) != 0;\n        has_pos |= vmaxvq_u32(vmovn_u64(vreinterpretq_u64_s32(vmask_pos))) != 0;\n    }\n\n    int32_t max_neg_local[4];\n    int32_t min_pos_local[4];\n    vst1q_s32(max_neg_local, vmax_neg);\n    vst1q_s32(min_pos_local, vmin_pos);\n\n    for (int j = 0; j < 4; ++j) {\n        if (max_neg_local[j] != INT32_MIN) {\n            max_neg = std::max(max_neg, max_neg_local[j]);\n        }\n        if (min_pos_local[j] != INT32_MAX) {\n            min_pos = std::min(min_pos, min_pos_local[j]);\n        }\n    }\n\n    for (; i < lst.size(); ++i) {\n        if (lst[i] < 0) {\n            max_neg = std::max(max_neg, lst[i]);\n            has_neg = true;\n        } else if (lst[i] > 0) {\n            min_pos = std::min(min_pos, lst[i]);\n            has_pos = true;\n        }\n    }\n\n    if (!has_neg) max_neg = 0;\n    if (!has_pos) min_pos = 0;\n\n    return {max_neg, min_pos};\n}\n```"}
{"task_id": "SimdBench_128_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    int32x4_t vmax_neg = vdupq_n_s32(INT32_MIN);\n    int32x4_t vmin_pos = vdupq_n_s32(INT32_MAX);\n    int32x4_t vzero = vdupq_n_s32(0);\n\n    bool has_negative = false;\n    bool has_positive = false;\n\n    for (size_t i = 0; i < lst.size(); i += 4) {\n        int32x4_t v = vld1q_s32(&lst[i]);\n        int32x4_t vmask_neg = vcltq_s32(v, vzero);\n        int32x4_t vmask_pos = vcgtq_s32(v, vzero);\n\n        vmax_neg = vbslq_s32(vmask_neg, vmaxq_s32(vmax_neg, v), vmax_neg);\n        vmin_pos = vbslq_s32(vmask_pos, vminq_s32(vmin_pos, v), vmin_pos);\n\n        has_negative |= vmaxvq_u32(vmask_neg) != 0;\n        has_positive |= vmaxvq_u32(vmask_pos) != 0;\n    }\n\n    int max_neg = has_negative ? std::max({vgetq_lane_s32(vmax_neg, 0), vgetq_lane_s32(vmax_neg, 1), vgetq_lane_s32(vmax_neg, 2), vgetq_lane_s32(vmax_neg, 3)}) : 0;\n    int min_pos = has_positive ? std::min({vgetq_lane_s32(vmin_pos, 0), vgetq_lane_s32(vmin_pos, 1), vgetq_lane_s32(vmin_pos, 2), vgetq_lane_s32(vmin_pos, 3)}) : 0;\n\n    return {max_neg, min_pos};\n}\n```"}
{"task_id": "SimdBench_128_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) return {0, 0};\n\n    int32x4_t vmax_neg = vdupq_n_s32(INT32_MIN);\n    int32x4_t vmin_pos = vdupq_n_s32(INT32_MAX);\n    int32x4_t vzero = vdupq_n_s32(0);\n\n    bool has_neg = false;\n    bool has_pos = false;\n\n    for (size_t i = 0; i < lst.size(); i += 4) {\n        int32x4_t v = vld1q_s32(&lst[i]);\n        int32x4_t vmask_neg = vcltq_s32(v, vzero);\n        int32x4_t vmask_pos = vcgtq_s32(v, vzero);\n\n        int32x4_t vmax_neg_local = vbslq_s32(vmask_neg, v, vmax_neg);\n        int32x4_t vmin_pos_local = vbslq_s32(vmask_pos, v, vmin_pos);\n\n        vmax_neg = vmaxq_s32(vmax_neg, vmax_neg_local);\n        vmin_pos = vminq_s32(vmin_pos, vmin_pos_local);\n\n        has_neg |= vmax_neg_local[0] != INT32_MIN || vmax_neg_local[1] != INT32_MIN || vmax_neg_local[2] != INT32_MIN || vmax_neg_local[3] != INT32_MIN;\n        has_pos |= vmin_pos_local[0] != INT32_MAX || vmin_pos_local[1] != INT32_MAX || vmin_pos_local[2] != INT32_MAX || vmin_pos_local[3] != INT32_MAX;\n    }\n\n    int max_neg = has_neg ? std::max({vgetq_lane_s32(vmax_neg, 0), vgetq_lane_s32(vmax_neg, 1), vgetq_lane_s32(vmax_neg, 2), vgetq_lane_s32(vmax_neg, 3)}) : 0;\n    int min_pos = has_pos ? std::min({vgetq_lane_s32(vmin_pos, 0), vgetq_lane_s32(vmin_pos, 1), vgetq_lane_s32(vmin_pos, 2), vgetq_lane_s32(vmin_pos, 3)}) : 0;\n\n    return {max_neg, min_pos};\n}\n```"}
{"task_id": "SimdBench_129_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    uint64x2_t result = vdupq_n_u64(1);\n    uint64x2_t factorial = vdupq_n_u64(1);\n\n    for (uint64_t i = 1; i <= n; ++i) {\n        factorial = vmulq_u64(factorial, vdupq_n_u64(i));\n        result = vmulq_u64(result, factorial);\n    }\n\n    return vgetq_lane_u64(result, 0);\n}\n```"}
{"task_id": "SimdBench_129_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    uint64_t result = 1;\n    uint64x2_t v_result = vdupq_n_u64(1);\n\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64x2_t v_i = vdupq_n_u64(i);\n        v_result = vmulq_u64(v_result, v_i);\n        result *= i;\n    }\n\n    result *= vgetq_lane_u64(v_result, 0) * vgetq_lane_u64(v_result, 1);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    uint64_t result = 1;\n    uint64x2_t factorial_vec = vdupq_n_u64(1);\n\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64x2_t i_vec = vdupq_n_u64(i);\n        factorial_vec = vmulq_u64(factorial_vec, i_vec);\n\n        uint64_t factorial = vgetq_lane_u64(factorial_vec, 0);\n        result *= factorial;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    uint64x2_t result = vdupq_n_u64(1);\n    uint64x2_t factorial = vdupq_n_u64(1);\n\n    for (uint64_t i = 1; i <= n; ++i) {\n        factorial = vmulq_u64(factorial, vdupq_n_u64(i));\n        result = vmulq_u64(result, factorial);\n    }\n\n    return vgetq_lane_u64(result, 0);\n}\n```"}
{"task_id": "SimdBench_129_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    uint64x2_t result = vdupq_n_u64(1);\n    uint64x2_t factorial = vdupq_n_u64(1);\n\n    for (uint64_t i = 1; i <= n; ++i) {\n        factorial = vmulq_u64(factorial, vdupq_n_u64(i));\n        result = vmulq_u64(result, factorial);\n    }\n\n    return vgetq_lane_u64(result, 0);\n}\n```"}
{"task_id": "SimdBench_130_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> &lst) {\n    int sum = 0;\n    size_t size = lst.size();\n    int32x4_t vsum = vdupq_n_s32(0);\n\n    for (size_t i = 0; i < size; i += 4) {\n        int32x4_t v = vld1q_s32(&lst[i]);\n        int32x4_t v_squared = vmulq_s32(v, v);\n        int32x4_t v_cubed = vmulq_s32(v_squared, v);\n\n        int32x4_t v_result = v;\n\n        if (i % 3 == 0) {\n            v_result = v_squared;\n        }\n        if (i % 4 == 0 && i % 3 != 0) {\n            v_result = v_cubed;\n        }\n\n        vsum = vaddq_s32(vsum, v_result);\n    }\n\n    int32_t result[4];\n    vst1q_s32(result, vsum);\n    for (int i = 0; i < 4; ++i) {\n        sum += result[i];\n    }\n\n    for (size_t i = (size / 4) * 4; i < size; ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    int sum = 0;\n    size_t size = lst.size();\n    size_t i = 0;\n\n    int32x4_t v_sum = vdupq_n_s32(0);\n    int32x4_t v_three = vdupq_n_s32(3);\n    int32x4_t v_four = vdupq_n_s32(4);\n\n    for (; i <= size - 4; i += 4) {\n        int32x4_t v = vld1q_s32(&lst[i]);\n        int32x4_t v_idx = vdupq_n_s32(i);\n        int32x4_t v_idx_3 = vaddq_s32(v_idx, v_three);\n        int32x4_t v_idx_4 = vaddq_s32(v_idx, v_four);\n\n        uint32x4_t v_mask_3 = vcgtq_s32(v_idx_3, vdupq_n_s32(0));\n        uint32x4_t v_mask_4 = vcgtq_s32(v_idx_4, vdupq_n_s32(0));\n\n        int32x4_t v_sq = vmulq_s32(v, v);\n        int32x4_t v_cb = vmulq_s32(v_sq, v);\n\n        int32x4_t v_result = vbslq_s32(v_mask_3, v_sq, v);\n        v_result = vbslq_s32(v_mask_4, v_cb, v_result);\n\n        v_sum = vaddq_s32(v_sum, v_result);\n    }\n\n    sum += vgetq_lane_s32(v_sum, 0);\n    sum += vgetq_lane_s32(v_sum, 1);\n    sum += vgetq_lane_s32(v_sum, 2);\n    sum += vgetq_lane_s32(v_sum, 3);\n\n    for (; i < size; ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> &lst) {\n    int sum = 0;\n    size_t size = lst.size();\n    int32x4_t vsum = vdupq_n_s32(0);\n\n    for (size_t i = 0; i < size; i += 4) {\n        int32x4_t v = vld1q_s32(&lst[i]);\n        int32x4_t v_squared = vmulq_s32(v, v);\n        int32x4_t v_cubed = vmulq_s32(v_squared, v);\n\n        int32x4_t v_result = v;\n\n        if (i % 3 == 0) {\n            v_result = v_squared;\n        }\n        if (i % 4 == 0 && i % 3 != 0) {\n            v_result = v_cubed;\n        }\n\n        vsum = vaddq_s32(vsum, v_result);\n    }\n\n    int32_t tmp[4];\n    vst1q_s32(tmp, vsum);\n    sum = tmp[0] + tmp[1] + tmp[2] + tmp[3];\n\n    for (size_t i = (size / 4) * 4; i < size; ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> &lst) {\n    int sum = 0;\n    size_t size = lst.size();\n    int32x4_t vsum = vdupq_n_s32(0);\n\n    for (size_t i = 0; i < size - 3; i += 4) {\n        int32x4_t v = vld1q_s32(&lst[i]);\n        int32x4_t v_squared = vmulq_s32(v, v);\n        int32x4_t v_cubed = vmulq_s32(v_squared, v);\n\n        int32x4_t v_result = v;\n\n        if (i % 3 == 0) {\n            v_result = v_squared;\n        }\n        if (i % 4 == 0 && i % 3 != 0) {\n            v_result = v_cubed;\n        }\n\n        vsum = vaddq_s32(vsum, v_result);\n    }\n\n    int32_t tmp[4];\n    vst1q_s32(tmp, vsum);\n    sum += tmp[0] + tmp[1] + tmp[2] + tmp[3];\n\n    for (size_t i = (size / 4) * 4; i < size; ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    int sum = 0;\n    size_t n = lst.size();\n\n    for (size_t i = 0; i < n; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        int32x4_t result = vec;\n\n        if (i % 3 == 0) {\n            result = vmulq_s32(vec, vec);\n        } else if (i % 4 == 0 && i % 3 != 0) {\n            result = vmulq_s32(vec, vmulq_s32(vec, vec));\n        }\n\n        int32x2_t low = vget_low_s32(result);\n        int32x2_t high = vget_high_s32(result);\n\n        sum += vget_lane_s32(low, 0) + vget_lane_s32(low, 1) + vget_lane_s32(high, 0) + vget_lane_s32(high, 1);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_131_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> &nums) {\n    int count = 0;\n    size_t size = nums.size();\n    size_t i = 0;\n\n    int32x4_t v10 = vdupq_n_s32(10);\n    uint32x4_t vodd_mask = vdupq_n_u32(0xAAAAAAAA);\n\n    for (; i <= size - 4; i += 4) {\n        int32x4_t v = vld1q_s32(&nums[i]);\n        uint32x4_t vabs = vabsq_s32(v);\n        uint32x4_t vfirst_digit = vshrq_n_u32(vabs, 28);\n        uint32x4_t vlast_digit = vandq_u32(vabs, vdupq_n_u32(9));\n        uint32x4_t vfirst_odd = vandq_u32(vfirst_digit, vodd_mask);\n        uint32x4_t vlast_odd = vandq_u32(vlast_digit, vodd_mask);\n        uint32x4_t vboth_odd = vandq_u32(vfirst_odd, vlast_odd);\n        uint32x4_t vgt10 = vcgtq_s32(v, v10);\n        uint32x4_t vmask = vandq_u32(vboth_odd, vgt10);\n\n        uint64x2_t vcount = vpaddlq_u32(vmask);\n        vcount = vaddq_u64(vcount, vcount);\n        count += vgetq_lane_u64(vcount, 0);\n    }\n\n    for (; i < size; ++i) {\n        int num = nums[i];\n        int abs_num = abs(num);\n        int first_digit = abs_num;\n        while (first_digit >= 10) first_digit /= 10;\n        int last_digit = abs_num % 10;\n        if (num > 10 && (first_digit & 1) && (last_digit & 1)) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> &nums) {\n    int count = 0;\n    size_t size = nums.size();\n    size_t i = 0;\n\n    int32x4_t v10 = vdupq_n_s32(10);\n    int32x4_t v1 = vdupq_n_s32(1);\n    int32x4_t v3 = vdupq_n_s32(3);\n    int32x4_t v5 = vdupq_n_s32(5);\n    int32x4_t v7 = vdupq_n_s32(7);\n    int32x4_t v9 = vdupq_n_s32(9);\n\n    for (; i <= size - 4; i += 4) {\n        int32x4_t v = vld1q_s32(&nums[i]);\n        int32x4_t v_abs = vabsq_s32(v);\n\n        uint32x4_t v_gt10 = vcgtq_s32(v_abs, v10);\n\n        int32x4_t v_first_digit = vshrq_n_s32(v_abs, 28);\n        int32x4_t v_last_digit = vandq_s32(v_abs, vdupq_n_s32(9));\n\n        uint32x4_t v_first_odd = vorrq_u32(\n            vorrq_u32(\n                vceqq_s32(v_first_digit, v1),\n                vceqq_s32(v_first_digit, v3)\n            ),\n            vorrq_u32(\n                vceqq_s32(v_first_digit, v5),\n                vceqq_s32(v_first_digit, v7)\n            )\n        );\n\n        uint32x4_t v_last_odd = vorrq_u32(\n            vorrq_u32(\n                vceqq_s32(v_last_digit, v1),\n                vceqq_s32(v_last_digit, v3)\n            ),\n            vorrq_u32(\n                vceqq_s32(v_last_digit, v5),\n                vceqq_s32(v_last_digit, v7)\n            )\n        );\n\n        uint32x4_t v_both_odd = vandq_u32(v_first_odd, v_last_odd);\n        uint32x4_t v_result = vandq_u32(v_gt10, v_both_odd);\n\n        uint64x2_t v_count = vpaddlq_u32(v_result);\n        v_count = vpaddlq_u64(v_count);\n        count += vgetq_lane_u64(v_count, 0);\n    }\n\n    for (; i < size; ++i) {\n        int num = nums[i];\n        int abs_num = abs(num);\n        if (abs_num > 10) {\n            int first_digit = abs_num;\n            while (first_digit >= 10) {\n                first_digit /= 10;\n            }\n            int last_digit = abs_num % 10;\n            if ((first_digit == 1 || first_digit == 3 || first_digit == 5 || first_digit == 7 || first_digit == 9) &&\n                (last_digit == 1 || last_digit == 3 || last_digit == 5 || last_digit == 7 || last_digit == 9)) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> &nums) {\n    int count = 0;\n    size_t size = nums.size();\n    size_t i = 0;\n\n    int32x4_t v10 = vdupq_n_s32(10);\n    int32x4_t v1 = vdupq_n_s32(1);\n    int32x4_t v3 = vdupq_n_s32(3);\n    int32x4_t v5 = vdupq_n_s32(5);\n    int32x4_t v7 = vdupq_n_s32(7);\n    int32x4_t v9 = vdupq_n_s32(9);\n\n    for (; i <= size - 4; i += 4) {\n        int32x4_t v = vld1q_s32(&nums[i]);\n        int32x4_t v_abs = vabsq_s32(v);\n\n        uint32x4_t v_gt_10 = vcgtq_s32(v_abs, v10);\n\n        int32x4_t v_first_digit = vandq_s32(v_abs, vdupq_n_s32(0xF));\n        int32x4_t v_last_digit = vandq_s32(v_abs, vdupq_n_s32(0xF0000000));\n\n        uint32x4_t v_first_odd = vorrq_u32(\n            veq_u32(v_first_digit, vreinterpretq_u32_s32(v1)),\n            vorrq_u32(\n                veq_u32(v_first_digit, vreinterpretq_u32_s32(v3)),\n                vorrq_u32(\n                    veq_u32(v_first_digit, vreinterpretq_u32_s32(v5)),\n                    vorrq_u32(\n                        veq_u32(v_first_digit, vreinterpretq_u32_s32(v7)),\n                        veq_u32(v_first_digit, vreinterpretq_u32_s32(v9))\n                    )\n                )\n            )\n        );\n\n        uint32x4_t v_last_odd = vorrq_u32(\n            veq_u32(v_last_digit, vreinterpretq_u32_s32(v1)),\n            vorrq_u32(\n                veq_u32(v_last_digit, vreinterpretq_u32_s32(v3)),\n                vorrq_u32(\n                    veq_u32(v_last_digit, vreinterpretq_u32_s32(v5)),\n                    vorrq_u32(\n                        veq_u32(v_last_digit, vreinterpretq_u32_s32(v7)),\n                        veq_u32(v_last_digit, vreinterpretq_u32_s32(v9))\n                    )\n                )\n            )\n        );\n\n        uint32x4_t v_both_odd = vandq_u32(v_first_odd, v_last_odd);\n        uint32x4_t v_result = vandq_u32(v_gt_10, v_both_odd);\n\n        uint32x4_t v_count = vaddq_u32(v_result, v_result);\n        v_count = vaddq_u32(v_count, v_count);\n        v_count = vaddq_u32(v_count, v_count);\n\n        count += vgetq_lane_u32(v_count, 0);\n    }\n\n    for (; i < size; ++i) {\n        int num = nums[i];\n        int abs_num = abs(num);\n        if (abs_num > 10) {\n            int first_digit = abs_num % 10;\n            int last_digit = abs_num / 10000000;\n            if ((first_digit == 1 || first_digit == 3 || first_digit == 5 || first_digit == 7 || first_digit == 9) &&\n                (last_digit == 1 || last_digit == 3 || last_digit == 5 || last_digit == 7 || last_digit == 9)) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    size_t size = nums.size();\n    size_t i = 0;\n\n    int32x4_t v10 = vdupq_n_s32(10);\n    int32x4_t v1 = vdupq_n_s32(1);\n    int32x4_t v3 = vdupq_n_s32(3);\n    int32x4_t v5 = vdupq_n_s32(5);\n    int32x4_t v7 = vdupq_n_s32(7);\n    int32x4_t v9 = vdupq_n_s32(9);\n\n    for (; i <= size - 4; i += 4) {\n        int32x4_t v = vld1q_s32(&nums[i]);\n\n        uint32x4_t abs_v = vabsq_s32(v);\n        int32x4_t last_digit = vandq_s32(abs_v, vdupq_n_s32(9));\n        int32x4_t first_digit = vshrq_n_s32(abs_v, vdupq_n_s32(31));\n\n        uint32x4_t mask_last = vorrq_s32(\n            veq_s32(last_digit, v1),\n            vorrq_s32(\n                veq_s32(last_digit, v3),\n                vorrq_s32(\n                    veq_s32(last_digit, v5),\n                    vorrq_s32(\n                        veq_s32(last_digit, v7),\n                        veq_s32(last_digit, v9)\n                    )\n                )\n            )\n        );\n\n        uint32x4_t mask_first = vorrq_s32(\n            veq_s32(first_digit, v1),\n            vorrq_s32(\n                veq_s32(first_digit, v3),\n                vorrq_s32(\n                    veq_s32(first_digit, v5),\n                    vorrq_s32(\n                        veq_s32(first_digit, v7),\n                        veq_s32(first_digit, v9)\n                    )\n                )\n            )\n        );\n\n        uint32x4_t mask_greater_than_10 = vcgtq_s32(v, v10);\n        uint32x4_t mask = vandq_u32(vandq_u32(mask_last, mask_first), mask_greater_than_10);\n\n        int32x4_t mask_count = vandq_s32(vdupq_n_s32(1), mask);\n        count += vaddvq_s32(mask_count);\n    }\n\n    for (; i < size; ++i) {\n        int num = nums[i];\n        int abs_num = abs(num);\n        int last_digit = abs_num % 10;\n        int first_digit = abs_num;\n        while (first_digit >= 10) {\n            first_digit /= 10;\n        }\n\n        if (num > 10 &&\n            (last_digit == 1 || last_digit == 3 || last_digit == 5 || last_digit == 7 || last_digit == 9) &&\n            (first_digit == 1 || first_digit == 3 || first_digit == 5 || first_digit == 7 || first_digit == 9)) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    size_t size = nums.size();\n    size_t i = 0;\n\n    int32x4_t v10 = vdupq_n_s32(10);\n    int32x4_t v1 = vdupq_n_s32(1);\n    int32x4_t v3 = vdupq_n_s32(3);\n    int32x4_t v5 = vdupq_n_s32(5);\n    int32x4_t v7 = vdupq_n_s32(7);\n    int32x4_t v9 = vdupq_n_s32(9);\n\n    for (; i <= size - 4; i += 4) {\n        int32x4_t v = vld1q_s32(&nums[i]);\n\n        uint32x4_t v_abs = vabsq_s32(v);\n        int32x4_t v_gt10 = vcgtq_s32(v_abs, v10);\n\n        int32x4_t v_first_digit = v;\n        int32x4_t v_last_digit = v;\n\n        while (vcmpq_s32(v_first_digit, v10) != 0) {\n            v_first_digit = vshrq_n_s32(v_first_digit, 1);\n        }\n\n        v_last_digit = vandq_s32(v_last_digit, vdupq_n_s32(0xF));\n\n        uint32x4_t v_odd_first = vorrq_s32(\n            vceqq_s32(v_first_digit, v1),\n            vorrq_s32(\n                vceqq_s32(v_first_digit, v3),\n                vorrq_s32(\n                    vceqq_s32(v_first_digit, v5),\n                    vorrq_s32(\n                        vceqq_s32(v_first_digit, v7),\n                        vceqq_s32(v_first_digit, v9)\n                    )\n                )\n            )\n        );\n\n        uint32x4_t v_odd_last = vorrq_s32(\n            vceqq_s32(v_last_digit, v1),\n            vorrq_s32(\n                vceqq_s32(v_last_digit, v3),\n                vorrq_s32(\n                    vceqq_s32(v_last_digit, v5),\n                    vorrq_s32(\n                        vceqq_s32(v_last_digit, v7),\n                        vceqq_s32(v_last_digit, v9)\n                    )\n                )\n            )\n        );\n\n        uint32x4_t v_odd_both = vandq_u32(v_odd_first, v_odd_last);\n        uint32x4_t v_result = vandq_u32(v_gt10, v_odd_both);\n\n        int32x4_t v_mask = vreinterpretq_s32_u32(v_result);\n        int mask = vaddvq_s32(v_mask);\n        count += __builtin_popcount(mask);\n    }\n\n    for (; i < size; ++i) {\n        int num = nums[i];\n        int abs_num = std::abs(num);\n        if (abs_num > 10) {\n            int first_digit = abs_num;\n            while (first_digit >= 10) {\n                first_digit /= 10;\n            }\n            int last_digit = abs_num % 10;\n            if ((first_digit % 2 != 0) && (last_digit % 2 != 0)) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n#include <stdlib.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    uint32_t *a = (uint32_t *)malloc(n * sizeof(uint32_t));\n    for (uint32_t i = 1; i <= n; ++i) {\n        a[i-1] = i * i - i + 1;\n    }\n\n    uint64_t count = 0;\n    for (uint32_t i = 0; i < n - 2; ++i) {\n        for (uint32_t j = i + 1; j < n - 1; ++j) {\n            uint32x4_t aj = vdupq_n_u32(a[j]);\n            uint32x4_t ai = vdupq_n_u32(a[i]);\n            uint32x4_t sum_ij = vaddq_u32(ai, aj);\n\n            for (uint32_t k = j + 1; k < n; ++k) {\n                uint32x4_t ak = vdupq_n_u32(a[k]);\n                uint32x4_t sum_ijk = vaddq_u32(sum_ij, ak);\n                uint32x4_t mod3 = vandq_u32(sum_ijk, vdupq_n_u32(3));\n\n                uint64_t mask = vaddvq_u32(vceqq_u32(mod3, vdupq_n_u32(0)));\n                count += mask >> 31;\n            }\n        }\n    }\n\n    free(a);\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n#include <stdlib.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    uint32_t *a = (uint32_t *)malloc(n * sizeof(uint32_t));\n    for (uint64_t i = 1; i <= n; ++i) {\n        a[i-1] = i * i - i + 1;\n    }\n\n    uint64_t count = 0;\n    for (uint64_t i = 0; i < n - 2; ++i) {\n        for (uint64_t j = i + 1; j < n - 1; ++j) {\n            uint32x4_t aj = vdupq_n_u32(a[j]);\n            uint32x4_t ai = vdupq_n_u32(a[i]);\n            uint32x4_t sum_ij = vaddq_u32(ai, aj);\n\n            for (uint64_t k = j + 1; k < n; k += 4) {\n                uint32x4_t ak = vld1q_u32(&a[k]);\n                uint32x4_t sum_ijk = vaddq_u32(sum_ij, ak);\n                uint32x4_t mod3 = vandq_u32(sum_ijk, vdupq_n_u32(3));\n                uint64x2_t mask = vreinterpretq_u64_u32(vceqq_u32(mod3, vdupq_n_u32(0)));\n\n                uint64_t mask_val = vgetq_lane_u64(vreinterpretq_u64_u32(vandq_u32(vdupq_n_u32(1), vreinterpretq_u32_u64(mask))), 0) +\n                                   vgetq_lane_u64(vreinterpretq_u64_u32(vandq_u32(vdupq_n_u32(1), vreinterpretq_u32_u64(mask))), 1);\n\n                count += __builtin_popcountll(mask_val);\n            }\n        }\n    }\n\n    free(a);\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n#include <stdlib.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    uint32_t *a = (uint32_t *)malloc(n * sizeof(uint32_t));\n    for (uint64_t i = 1; i <= n; ++i) {\n        a[i-1] = i * i - i + 1;\n    }\n\n    uint64_t count = 0;\n    for (uint64_t i = 0; i < n - 2; ++i) {\n        for (uint64_t j = i + 1; j < n - 1; ++j) {\n            uint32x4_t aj = vld1q_dup_u32(&a[j]);\n            uint32x4_t ai = vld1q_dup_u32(&a[i]);\n            uint32x4_t sum_ij = vaddq_u32(ai, aj);\n\n            for (uint64_t k = j + 1; k < n; ++k) {\n                uint32x4_t ak = vld1q_dup_u32(&a[k]);\n                uint32x4_t sum_ijk = vaddq_u32(sum_ij, ak);\n                uint32x4_t mod3 = vandq_u32(sum_ijk, vdupq_n_u32(3));\n\n                uint64_t mask = vmoveq_u32(vgetq_lane_u32(mod3, 0), 0);\n                count += mask;\n            }\n        }\n    }\n\n    free(a);\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n#include <stdlib.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    uint32_t *a = (uint32_t *)malloc(n * sizeof(uint32_t));\n    for (uint32_t i = 1; i <= n; ++i) {\n        a[i-1] = i * i - i + 1;\n    }\n\n    uint64_t count = 0;\n    for (uint32_t i = 0; i < n - 2; ++i) {\n        for (uint32_t j = i + 1; j < n - 1; ++j) {\n            uint32x4_t aj = vdupq_n_u32(a[j]);\n            uint32x4_t ai = vdupq_n_u32(a[i]);\n            uint32x4_t sum_ij = vaddq_u32(ai, aj);\n\n            for (uint32_t k = j + 1; k < n; ++k) {\n                uint32x4_t ak = vdupq_n_u32(a[k]);\n                uint32x4_t sum_ijk = vaddq_u32(sum_ij, ak);\n                uint32x4_t mod3 = vandq_u32(sum_ijk, vdupq_n_u32(3));\n\n                if (vgetq_lane_u32(mod3, 0) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    free(a);\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n#include <stdlib.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    if (n < 3) return 0;\n\n    uint32_t *a = (uint32_t *)malloc(n * sizeof(uint32_t));\n    for (uint32_t i = 1; i <= n; ++i) {\n        a[i-1] = i * i - i + 1;\n    }\n\n    uint64_t count = 0;\n    uint32x4_t v3 = vdupq_n_u32(3);\n\n    for (uint32_t i = 0; i < n - 2; ++i) {\n        for (uint32_t j = i + 1; j < n - 1; ++j) {\n            uint32x4_t vaj = vdupq_n_u32(a[j]);\n            uint32x4_t vai = vdupq_n_u32(a[i]);\n            uint32x4_t vsum_ij = vaddq_u32(vai, vaj);\n\n            for (uint32_t k = j + 1; k < n; k += 4) {\n                uint32x4_t vak = vld1q_u32(&a[k]);\n                uint32x4_t vsum = vaddq_u32(vsum_ij, vak);\n                uint32x4_t vmod = vmodq_u32(vsum, v3);\n\n                uint64x2_t vzero = vmovq_n_u64(0);\n                uint32x4_t vmask = vceqq_u32(vmod, vzero);\n                uint64_t mask = vaddvq_u32(vmask);\n\n                count += __builtin_popcountll(mask);\n            }\n        }\n    }\n\n    free(a);\n    return count;\n}\n```"}
{"task_id": "SimdBench_133_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nint x_or_y_simd(int n, int x, int y) {\n    int32x4_t vn = vdupq_n_s32(n);\n    int32x4_t vx = vdupq_n_s32(x);\n    int32x4_t vy = vdupq_n_s32(y);\n\n    uint32x4_t vmask = vceqq_s32(vn, vn); // Create a mask with all elements set to true\n    int32x4_t vprime = vdupq_n_s32(is_prime(n) ? x : y);\n\n    int32x4_t vresult = vbslq_s32(vmask, vprime, vy);\n\n    return vgetq_lane_s32(vresult, 0);\n}\n```"}
{"task_id": "SimdBench_133_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nint x_or_y_simd(int n, int x, int y) {\n    int32x4_t vn = vdupq_n_s32(n);\n    int32x4_t vx = vdupq_n_s32(x);\n    int32x4_t vy = vdupq_n_s32(y);\n\n    uint32x4_t vmask = vceqq_s32(vn, vn); // Create a mask with all elements set to true\n    int32x4_t vresult = vbslq_s32(vmask, vx, vy); // Select x if mask is true, otherwise y\n\n    int result[4];\n    vst1q_s32(result, vresult);\n\n    return is_prime(n) ? result[0] : result[1];\n}\n```"}
{"task_id": "SimdBench_133_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nint x_or_y_simd(int n, int x, int y) {\n    int32x4_t vn = vdupq_n_s32(n);\n    int32x4_t vx = vdupq_n_s32(x);\n    int32x4_t vy = vdupq_n_s32(y);\n\n    uint32x4_t vmask = vceqq_s32(vn, vn); // Create a mask with all elements set to true\n    int32x4_t vprime = vdupq_n_s32(is_prime(n) ? x : y);\n\n    int32x4_t vresult = vbslq_s32(vmask, vx, vy);\n\n    int result[4];\n    vst1q_s32(result, vresult);\n\n    return result[0];\n}\n```"}
{"task_id": "SimdBench_133_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nint x_or_y_simd(int n, int x, int y) {\n    int32x4_t n_vec = vdupq_n_s32(n);\n    int32x4_t x_vec = vdupq_n_s32(x);\n    int32x4_t y_vec = vdupq_n_s32(y);\n\n    uint32x4_t prime_mask = vdupq_n_u32(is_prime(n) ? -1 : 0);\n    int32x4_t result_vec = vbslq_s32(prime_mask, x_vec, y_vec);\n\n    int result;\n    vst1q_lane_s32(&result, result_vec, 0);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_133_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nint x_or_y_simd(int n, int x, int y) {\n    int32x4_t vn = vdupq_n_s32(n);\n    int32x4_t vx = vdupq_n_s32(x);\n    int32x4_t vy = vdupq_n_s32(y);\n\n    uint32x4_t vmask = vceqq_s32(vn, vn); // Create a mask with all elements set to true\n    int32x4_t vresult = vbslq_s32(vmask, vx, vy); // Select elements from vx or vy based on the mask\n\n    // Extract the first element from the result vector\n    int result;\n    vst1q_lane_s32(&result, vresult, 0);\n\n    return is_prime(n) ? x : y;\n}\n```"}
{"task_id": "SimdBench_134_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    size_t size = lst.size();\n\n    if (size == 0) return 0;\n\n    float32x4_t vsum = vdupq_n_f32(0.0f);\n    float32x4_t vone = vdupq_n_f32(1.0f);\n\n    for (size_t i = 0; i < size; i += 4) {\n        float32x4_t v = vld1q_f32(&lst[i]);\n        uint32x4_t vi = vcvtq_u32_f32(v);\n        uint32x4_t vodd = vandq_u32(vi, vdupq_n_u32(1));\n        uint32x4_t vmask = vceqq_u32(vodd, vdupq_n_u32(1));\n        float32x4_t vmaskf = vcvtq_f32_u32(vmask);\n        float32x4_t vsquare = vmulq_f32(v, v);\n        vsum = vaddq_f32(vsum, vmulq_f32(vsquare, vmaskf));\n    }\n\n    float tmp[4];\n    vst1q_f32(tmp, vsum);\n    sum = tmp[0] + tmp[1] + tmp[2] + tmp[3];\n\n    return static_cast<uint64_t>(sum);\n}\n```"}
{"task_id": "SimdBench_134_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    size_t size = lst.size();\n\n    if (size == 0) return 0;\n\n    float32x4_t v_zero = vdupq_n_f32(0.0f);\n    float32x4_t v_one = vdupq_n_f32(1.0f);\n    float32x4_t v_two = vdupq_n_f32(2.0f);\n    uint32x4_t v_mask_odd = vmovq_n_u32(1);\n\n    for (size_t i = 0; i < size; i += 4) {\n        float32x4_t v = vld1q_f32(&lst[i]);\n\n        uint32x4_t v_int = vcvtq_u32_f32(v);\n        uint32x4_t v_odd = vandq_u32(v_int, v_mask_odd);\n        uint32x4_t v_cmp = vceqq_u32(v_odd, v_mask_odd);\n\n        float32x4_t v_sq = vmulq_f32(v, v);\n        float32x4_t v_masked_sq = vbslq_f32(v_cmp, v_sq, v_zero);\n\n        float32x2_t v_low = vget_low_f32(v_masked_sq);\n        float32x2_t v_high = vget_high_f32(v_masked_sq);\n\n        sum += vget_lane_f32(vpadd_f32(v_low, v_high), 0);\n        sum += vget_lane_f32(vpadd_f32(v_low, v_high), 1);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    size_t size = lst.size();\n\n    if (size == 0) return 0;\n\n    float32x4_t vsum = vdupq_n_f32(0.0f);\n    float32x4_t vone = vdupq_n_f32(1.0f);\n\n    for (size_t i = 0; i <= size - 4; i += 4) {\n        float32x4_t v = vld1q_f32(&lst[i]);\n        uint32x4_t vi = vcvtq_u32_f32(v);\n        uint32x4_t vodd = vandq_u32(vi, vdupq_n_u32(1));\n        uint32x4_t vmask = vceqq_u32(vodd, vdupq_n_u32(1));\n        float32x4_t vmaskf = vcvtq_f32_u32(vmask);\n        float32x4_t vsquare = vmulq_f32(v, v);\n        vsum = vaddq_f32(vsum, vmulq_f32(vsquare, vmaskf));\n    }\n\n    float tmp[4];\n    vst1q_f32(tmp, vsum);\n    sum = tmp[0] + tmp[1] + tmp[2] + tmp[3];\n\n    for (size_t i = (size & ~3); i < size; ++i) {\n        int val = static_cast<int>(lst[i]);\n        if (val > 0 && val % 2 == 1) {\n            sum += val * val;\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    size_t size = lst.size();\n\n    if (size == 0) return 0;\n\n    float32x4_t vsum = vdupq_n_f32(0.0f);\n    float32x4_t vone = vdupq_n_f32(1.0f);\n\n    for (size_t i = 0; i < size - 3; i += 4) {\n        float32x4_t v = vld1q_f32(&lst[i]);\n        uint32x4_t vi = vcvtq_u32_f32(v);\n        uint32x4_t vodd = vandq_u32(vi, vdupq_n_u32(1));\n        uint32x4_t vmask = vceqq_u32(vodd, vdupq_n_u32(1));\n        float32x4_t vmasked = vbslq_f32(vmask, v, vdupq_n_f32(0.0f));\n        vmasked = vmulq_f32(vmasked, vmasked);\n        vsum = vaddq_f32(vsum, vmasked);\n    }\n\n    float tmp[4];\n    vst1q_f32(tmp, vsum);\n    sum = tmp[0] + tmp[1] + tmp[2] + tmp[3];\n\n    for (size_t i = (size & ~3); i < size; ++i) {\n        int val = static_cast<int>(lst[i]);\n        if (val > 0 && val % 2 == 1) {\n            sum += val * val;\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    size_t size = lst.size();\n\n    if (size == 0) return 0;\n\n    float32x4_t vsum = vdupq_n_f32(0.0f);\n    float32x4_t vone = vdupq_n_f32(1.0f);\n\n    for (size_t i = 0; i < size; i += 4) {\n        float32x4_t v = vld1q_f32(&lst[i]);\n        uint32x4_t vi = vcvtq_u32_f32(v);\n        uint32x4_t vodd = vandq_u32(vi, vdupq_n_u32(1));\n        uint32x4_t vmask = vceqq_u32(vodd, vdupq_n_u32(1));\n        float32x4_t vmaskf = vcvtq_f32_u32(vmask);\n        float32x4_t vsquare = vmulq_f32(v, v);\n        vsum = vaddq_f32(vsum, vmulq_f32(vsquare, vmaskf));\n    }\n\n    float tmp[4];\n    vst1q_f32(tmp, vsum);\n    for (int i = 0; i < 4; ++i) {\n        sum += static_cast<uint64_t>(tmp[i]);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_135_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t size = game.size();\n    std::vector<int> result(size);\n\n    for (size_t i = 0; i < size; i += 4) {\n        int32x4_t game_vec = vld1q_s32(&game[i]);\n        int32x4_t guess_vec = vld1q_s32(&guess[i]);\n        int32x4_t diff_vec = vabsq_s32(vsubq_s32(game_vec, guess_vec));\n        vst1q_s32(&result[i], diff_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cstdlib>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t length = game.size();\n    std::vector<int> result(length);\n\n    for (size_t i = 0; i < length; i += 4) {\n        int32x4_t game_vec = vld1q_s32(&game[i]);\n        int32x4_t guess_vec = vld1q_s32(&guess[i]);\n        int32x4_t diff_vec = vabsq_s32(vsubq_s32(game_vec, guess_vec));\n        vst1q_s32(&result[i], diff_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cstdlib>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t length = game.size();\n    std::vector<int> result(length);\n\n    for (size_t i = 0; i < length; i += 4) {\n        int32x4_t v_game = vld1q_s32(&game[i]);\n        int32x4_t v_guess = vld1q_s32(&guess[i]);\n        int32x4_t v_diff = vabdq_s32(v_game, v_guess);\n        vst1q_s32(&result[i], v_diff);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cstdlib>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t size = game.size();\n    std::vector<int> result(size);\n\n    for (size_t i = 0; i < size; i += 4) {\n        int32x4_t v_game = vld1q_s32(&game[i]);\n        int32x4_t v_guess = vld1q_s32(&guess[i]);\n        int32x4_t v_diff = vabdq_s32(v_game, v_guess);\n        vst1q_s32(&result[i], v_diff);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cstdlib>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t n = game.size();\n    std::vector<int> result(n);\n\n    for (size_t i = 0; i < n; i += 4) {\n        int32x4_t v_game = vld1q_s32(&game[i]);\n        int32x4_t v_guess = vld1q_s32(&guess[i]);\n        int32x4_t v_diff = vabsq_s32(vsubq_s32(v_game, v_guess));\n        vst1q_s32(&result[i], v_diff);\n    }\n\n    return result;\n}\n```"}

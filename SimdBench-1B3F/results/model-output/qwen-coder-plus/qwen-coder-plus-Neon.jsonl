{"task_id": "SimdBench_0_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 2; i += 2) {\n        int64x2_t src_vec = vld1q_s64(&src[i]);\n        int64x2_t dst_vec = vld1q_s64(&dst[i]);\n        uint8x16_t mask_vec = vld1q_u8((const uint8_t *)&mask[i]);\n        uint8x16_t mask_expanded = vcombine_u8(vdupq_lane_u8(vget_low_u8(mask_vec), 0),\n                                              vdupq_lane_u8(vget_high_u8(mask_vec), 0));\n        int64x2_t result_vec = vbslq_s64(mask_expanded, src_vec, dst_vec);\n        vst1q_s64(&dst[i], result_vec);\n    }\n    for (; i < length; i++) {\n        dst[i] = mask[i] ? src[i] : dst[i];\n    }\n}\n```"}
{"task_id": "SimdBench_0_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 2; i += 2) {\n        int64x2_t src_vec = vld1q_s64(&src[i]);\n        int64x2_t dst_vec = vld1q_s64(&dst[i]);\n        uint8x16_t mask_vec = vld1q_u8((const uint8_t*)&mask[i]);\n        uint8x16_t mask_expanded = vcombine_u8(vdupq_lane_u8(vget_low_u8(mask_vec), 0),\n                                              vdupq_lane_u8(vget_high_u8(mask_vec), 0));\n        int64x2_t result_vec = vbslq_s64(mask_expanded, src_vec, dst_vec);\n        vst1q_s64(&dst[i], result_vec);\n    }\n    for (; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 2; i += 2) {\n        int64x2_t src_vec = vld1q_s64(&src[i]);\n        int64x2_t dst_vec = vld1q_s64(&dst[i]);\n        uint8x16_t mask_vec = vreinterpretq_u8_u64(vld1q_u64(reinterpret_cast<const uint64_t*>(&mask[i])));\n        uint8x16_t mask_expanded = vcombine_u8(vdupb_lane_u8(vget_low_u8(mask_vec), 0),\n                                               vdupb_lane_u8(vget_high_u8(mask_vec), 0));\n        int64x2_t result_vec = vbslq_s64(mask_expanded, src_vec, dst_vec);\n        vst1q_s64(&dst[i], result_vec);\n    }\n    for (; i < length; ++i) {\n        dst[i] = mask[i] ? src[i] : dst[i];\n    }\n}\n```"}
{"task_id": "SimdBench_0_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 2; i += 2) {\n        int64x2_t src_vec = vld1q_s64(&src[i]);\n        int64x2_t dst_vec = vld1q_s64(&dst[i]);\n        uint8x16_t mask_vec = vld1q_u8((const uint8_t*)&mask[i]);\n        uint8x16_t mask_expanded = vcombine_u8(vdupq_lane_u8(vget_low_u8(mask_vec), 0),\n                                              vdupq_lane_u8(vget_high_u8(mask_vec), 0));\n        int64x2_t result_vec = vbslq_s64(mask_expanded, src_vec, dst_vec);\n        vst1q_s64(&dst[i], result_vec);\n    }\n    for (; i < length; ++i) {\n        dst[i] = mask[i] ? src[i] : dst[i];\n    }\n}\n```"}
{"task_id": "SimdBench_0_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 2; i += 2) {\n        int64x2_t src_vec = vld1q_s64(&src[i]);\n        int64x2_t dst_vec = vld1q_s64(&dst[i]);\n        uint8x16_t mask_vec = vld1q_u8((const uint8_t*)&mask[i]);\n        uint8x16_t mask_wide = vreinterpretq_u8_u64(vshrq_n_u64(vreinterpretq_u64_u8(mask_vec), 7));\n        int64x2_t result_vec = vbslq_s64(mask_wide, src_vec, dst_vec);\n        vst1q_s64(&dst[i], result_vec);\n    }\n    for (; i < length; i++) {\n        dst[i] = mask[i] ? src[i] : dst[i];\n    }\n}\n```"}
{"task_id": "SimdBench_1_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    int32x4_t v_scale = vdupq_n_s32(scale);\n    size_t i = 0;\n\n    for (; i <= length - 4; i += 4) {\n        int32x4_t v_src = vld1q_s32(&src[i]);\n        int32x4_t v_tmp1 = vrshlq_s32(vmulq_s32(v_src, v_scale), vdupq_n_s32(3));\n        int32x4_t v_tmp2 = vshlq_s32(vmulq_s32(v_src, v_scale), vdupq_n_s32(3));\n        int32x4_t v_result = vdivq_s32(vaddq_s32(vmulq_s32(v_src, v_scale), vmulq_s32(v_tmp1, v_tmp2)), vdupq_n_s32(7));\n        vst1q_s32(&dst[i], v_result);\n    }\n\n    for (; i < length; i++) {\n        int32_t element = src[i];\n        int32_t tmp1 = (element * scale) >> 3;\n        int32_t tmp2 = (element * scale) << 3;\n        dst[i] = (element * scale + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    int32x4_t v_scale = vdupq_n_s32(scale);\n    size_t i = 0;\n\n    for (; i <= length - 4; i += 4) {\n        int32x4_t v_src = vld1q_s32(&src[i]);\n        int32x4_t v_tmp1 = vrshlq_s32(vmulq_s32(v_src, v_scale), vdupq_n_s32(3));\n        int32x4_t v_tmp2 = vshlq_s32(vmulq_s32(v_src, v_scale), vdupq_n_s32(3));\n        int32x4_t v_result = vdivq_s32(vaddq_s32(vmulq_s32(v_src, v_scale), vmulq_s32(v_tmp1, v_tmp2)), vdupq_n_s32(7));\n        vst1q_s32(&dst[i], v_result);\n    }\n\n    for (; i < length; i++) {\n        int32_t element = src[i];\n        int32_t tmp1 = (element * scale) >> 3;\n        int32_t tmp2 = (element * scale) << 3;\n        dst[i] = (element * scale + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    int32x4_t v_scale = vdupq_n_s32(scale);\n    size_t i = 0;\n\n    for (; i <= length - 4; i += 4) {\n        int32x4_t v_src = vld1q_s32(&src[i]);\n        int32x4_t v_tmp1 = vrshlq_s32(vmulq_s32(v_src, v_scale), vdupq_n_s32(3));\n        int32x4_t v_tmp2 = vshlq_s32(vmulq_s32(v_src, v_scale), vdupq_n_s32(3));\n        int32x4_t v_result = vdivq_s32(vaddq_s32(vmulq_s32(v_src, v_scale), vmulq_s32(v_tmp1, v_tmp2)), vdupq_n_s32(7));\n        vst1q_s32(&dst[i], v_result);\n    }\n\n    for (; i < length; i++) {\n        int32_t element = src[i];\n        int32_t tmp1 = (element * scale) >> 3;\n        int32_t tmp2 = (element * scale) << 3;\n        dst[i] = (element * scale + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    int32x4_t v_scale = vdupq_n_s32(scale);\n    size_t i = 0;\n\n    for (; i <= length - 4; i += 4) {\n        int32x4_t v_src = vld1q_s32(&src[i]);\n        int32x4_t v_tmp1 = vrshlq_s32(vmulq_s32(v_src, v_scale), vdupq_n_s32(3));\n        int32x4_t v_tmp2 = vshlq_s32(vmulq_s32(v_src, v_scale), vdupq_n_s32(3));\n        int32x4_t v_result = vdivq_s32(vaddq_s32(vmulq_s32(v_src, v_scale), vmulq_s32(v_tmp1, v_tmp2)), vdupq_n_s32(7));\n        vst1q_s32(&dst[i], v_result);\n    }\n\n    for (; i < length; i++) {\n        int32_t tmp1 = (src[i] * scale) >> 3;\n        int32_t tmp2 = (src[i] * scale) << 3;\n        dst[i] = (src[i] * scale + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    int32x4_t v_scale = vdupq_n_s32(scale);\n    size_t i = 0;\n\n    for (; i <= length - 4; i += 4) {\n        int32x4_t v_src = vld1q_s32(&src[i]);\n        int32x4_t v_tmp1 = vrshlq_s32(vmulq_s32(v_src, v_scale), vdupq_n_s32(3));\n        int32x4_t v_tmp2 = vshlq_s32(vmulq_s32(v_src, v_scale), vdupq_n_s32(3));\n        int32x4_t v_result = vdivq_s32(vaddq_s32(vmulq_s32(v_src, v_scale), vmulq_s32(v_tmp1, v_tmp2)), vdupq_n_s32(7));\n        vst1q_s32(&dst[i], v_result);\n    }\n\n    for (; i < length; i++) {\n        int32_t tmp1 = (src[i] * scale) >> 3;\n        int32_t tmp2 = (src[i] * scale) << 3;\n        dst[i] = (src[i] * scale + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_2_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t i = 0;\n    for (; i <= rows - 2; i += 2) {\n        uint64_t index1 = (i * cols + stride);\n        uint64_t index2 = ((i + 1) * cols + stride);\n        float64x2_t values = vld1q_f64(&src[index1]);\n        vst1q_f64(&dst[i], values);\n    }\n    for (; i < rows; i++) {\n        dst[i] = src[i * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t i = 0;\n    for (; i <= rows - 2; i += 2) {\n        uint64_t index1 = (i * cols + stride);\n        uint64_t index2 = ((i + 1) * cols + stride);\n        float64x2_t values = vld1q_f64(&src[index1]);\n        vst1q_f64(&dst[i], values);\n    }\n    for (; i < rows; i++) {\n        dst[i] = src[i * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t i = 0;\n    for (; i <= rows - 2; i += 2) {\n        uint64_t index1 = (i * cols + stride);\n        uint64_t index2 = ((i + 1) * cols + stride);\n        float64x2_t values = vld1q_f64(&src[index1]);\n        vst1q_f64(&dst[i], values);\n    }\n    for (; i < rows; i++) {\n        dst[i] = src[i * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t i = 0;\n    for (; i <= rows - 2; i += 2) {\n        uint64_t index1 = (i * cols + stride);\n        uint64_t index2 = ((i + 1) * cols + stride);\n        float64x2_t values = vld1q_f64(&src[index1]);\n        vst1q_f64(&dst[i], values);\n    }\n    for (; i < rows; i++) {\n        dst[i] = src[i * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2_Neon", "completion": "```c\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t i = 0;\n    for (; i <= rows - 2; i += 2) {\n        uint64x2_t indices = vcreate_u64(((i + 1) * cols + stride) | ((i * cols + stride) << 32));\n        uint64x2_t offsets = vmull_u32(vreinterpret_u32_u64(indices), vdup_n_u32(sizeof(double)));\n        float64x2_t values = vld1q_f64((const float64_t*)((const char*)src + vgetq_lane_u64(offsets, 0)));\n        values = vsetq_lane_f64(*(const double*)((const char*)src + vgetq_lane_u64(offsets, 1)), values, 1);\n        vst1q_f64(&dst[i], values);\n    }\n    for (; i < rows; i++) {\n        dst[i] = src[i * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_3_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        // Load 4 indices\n        int32x4_t idx = vld1q_s32(&indices[i]);\n        \n        // Gather 4 elements from src using indices\n        float32x4_t gathered = vld1q_gather_elements_f32(src, idx);\n        \n        // Scatter 4 elements to dst using indices\n        vst1q_scatter_elements_f32(dst, gathered, idx);\n        \n        // Directly copy 4 elements from src to dst for gather operation\n        vst1q_f32(&dst[i], gathered);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; ++i) {\n        dst[i] = src[indices[i]];\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        uint32x4_t idx = vld1q_u32(reinterpret_cast<const uint32_t*>(indices + i));\n        float32x4_t gathered_values = vld1q_gather_f32(src, idx);\n        vst1q_f32(dst + i, gathered_values);\n        vst1q_scatter_f32(dst, idx, gathered_values);\n    }\n    for (; i < length; ++i) {\n        dst[i] = src[indices[i]];\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        uint32x4_t idx = vld1q_u32((const uint32_t *)&indices[i]);\n        float32x4_t gathered = vld1q_gather_f32(src, idx);\n        vst1q_f32(&dst[i], gathered);\n\n        vst1q_scatter_f32(dst, idx, gathered);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = src[indices[i]];\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        // Load 4 indices\n        int32x4_t idx = vld1q_s32(&indices[i]);\n        \n        // Gather 4 elements from src using the indices\n        float32x4_t gathered = vld1q_gather_f32(src, idx);\n        \n        // Scatter 4 elements to dst using the indices\n        vst1q_scatter_f32(dst, idx, gathered);\n        \n        // Directly copy 4 elements from src to dst for gather operation\n        vst1q_f32(&dst[i], gathered);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; ++i) {\n        int idx = indices[i];\n        dst[i] = src[idx]; // Gather operation\n        dst[idx] = src[i]; // Scatter operation\n    }\n}\n```"}
{"task_id": "SimdBench_3_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        // Load 4 indices\n        int32x4_t idx = vld1q_s32(&indices[i]);\n        \n        // Gather 4 elements from src using the indices\n        float32x4_t gathered = vld1q_gather_elements_f32(src, idx);\n        \n        // Scatter 4 elements to dst using the indices\n        vst1q_scatter_elements_f32(dst, gathered, idx);\n        \n        // Directly copy 4 elements from src to dst for gather operation\n        vst1q_f32(&dst[i], gathered);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; ++i) {\n        dst[i] = src[indices[i]];\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_4_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start + 7 < end) {\n        int16x8_t v1 = vld1q_s16(&arr[start]);\n        int16x8_t v2 = vld1q_s16(&arr[end - 7]);\n\n        int16x8_t v1_rev = vrev64q_s16(vcombine_s16(vget_high_s16(v1), vget_low_s16(v1)));\n        int16x8_t v2_rev = vrev64q_s16(vcombine_s16(vget_high_s16(v2), vget_low_s16(v2)));\n\n        vst1q_s16(&arr[start], v2_rev);\n        vst1q_s16(&arr[end - 7], v1_rev);\n\n        start += 8;\n        end -= 8;\n    }\n\n    while (start < end) {\n        int16_t temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n```"}
{"task_id": "SimdBench_4_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start + 7 < end) {\n        int16x8_t v1 = vld1q_s16(&arr[start]);\n        int16x8_t v2 = vld1q_s16(&arr[end - 7]);\n\n        int16x8_t v1_rev = vrev64q_s16(vcombine_s16(vget_high_s16(v1), vget_low_s16(v1)));\n        int16x8_t v2_rev = vrev64q_s16(vcombine_s16(vget_high_s16(v2), vget_low_s16(v2)));\n\n        vst1q_s16(&arr[start], v2_rev);\n        vst1q_s16(&arr[end - 7], v1_rev);\n\n        start += 8;\n        end -= 8;\n    }\n\n    while (start < end) {\n        int16_t temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n```"}
{"task_id": "SimdBench_4_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start + 7 < end) {\n        int16x8_t v1 = vld1q_s16(&arr[start]);\n        int16x8_t v2 = vld1q_s16(&arr[end - 7]);\n\n        int16x8_t v1_rev = vrev64q_s16(vcombine_s16(vget_high_s16(v1), vget_low_s16(v1)));\n        int16x8_t v2_rev = vrev64q_s16(vcombine_s16(vget_high_s16(v2), vget_low_s16(v2)));\n\n        vst1q_s16(&arr[start], v2_rev);\n        vst1q_s16(&arr[end - 7], v1_rev);\n\n        start += 8;\n        end -= 8;\n    }\n\n    while (start < end) {\n        int16_t temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n```"}
{"task_id": "SimdBench_4_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start + 7 < end) {\n        int16x8_t v1 = vld1q_s16(&arr[start]);\n        int16x8_t v2 = vld1q_s16(&arr[end - 7]);\n\n        int16x8_t v1_rev = vrev64q_s16(vcombine_s16(vget_high_s16(v1), vget_low_s16(v1)));\n        int16x8_t v2_rev = vrev64q_s16(vcombine_s16(vget_high_s16(v2), vget_low_s16(v2)));\n\n        vst1q_s16(&arr[start], v2_rev);\n        vst1q_s16(&arr[end - 7], v1_rev);\n\n        start += 8;\n        end -= 8;\n    }\n\n    while (start < end) {\n        int16_t temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n```"}
{"task_id": "SimdBench_4_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start < end) {\n        uint64_t s = start;\n        uint64_t e = end;\n\n        // Load 8 elements from the start and end positions\n        int16x8_t vstart = vld1q_s16(&arr[s]);\n        int16x8_t vend = vld1q_s16(&arr[e - 7]);\n\n        // Reverse the elements in the vectors\n        int16x8_t vrev_start = vrev64q_s16(vcombine_s16(vget_high_s16(vend), vget_low_s16(vend)));\n        int16x8_t vrev_end = vrev64q_s16(vcombine_s16(vget_high_s16(vstart), vget_low_s16(vstart)));\n\n        // Store the reversed elements back to the array\n        vst1q_s16(&arr[s], vrev_start);\n        vst1q_s16(&arr[e - 7], vrev_end);\n\n        // Move the start and end indices\n        start += 8;\n        end -= 8;\n    }\n\n    // Handle the remaining elements if the range is not a multiple of 8\n    while (start < end) {\n        int16_t temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n```"}
{"task_id": "SimdBench_5_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t total_elements_per_slice = dim1 * dim2;\n    const uint8_t *src = tensor + slice_idx * total_elements_per_slice;\n\n    for (size_t i = 0; i < total_elements_per_slice; i += 16) {\n        uint8x16_t v = vld1q_u8(src + i);\n        vst1q_u8(slice + i, v);\n    }\n}\n```"}
{"task_id": "SimdBench_5_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t total_elements_per_slice = dim1 * dim2;\n    const uint8_t *src = tensor + slice_idx * total_elements_per_slice;\n\n    for (size_t i = 0; i < total_elements_per_slice; i += 16) {\n        uint8x16_t v = vld1q_u8(src + i);\n        vst1q_u8(slice + i, v);\n    }\n}\n```"}
{"task_id": "SimdBench_5_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t total_elements_per_slice = dim1 * dim2;\n    const uint8_t *src = tensor + slice_idx * total_elements_per_slice;\n\n    for (size_t i = 0; i < total_elements_per_slice; i += 16) {\n        uint8x16_t v = vld1q_u8(src + i);\n        vst1q_u8(slice + i, v);\n    }\n}\n```"}
{"task_id": "SimdBench_5_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t total_elements_per_slice = dim1 * dim2;\n    const uint8_t *src = tensor + slice_idx * total_elements_per_slice;\n\n    for (size_t i = 0; i < total_elements_per_slice; i += 16) {\n        uint8x16_t v = vld1q_u8(src + i);\n        vst1q_u8(slice + i, v);\n    }\n}\n```"}
{"task_id": "SimdBench_5_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t total_elements_per_slice = dim1 * dim2;\n    const uint8_t *src = tensor + slice_idx * total_elements_per_slice;\n    size_t i = 0;\n\n    for (; i <= total_elements_per_slice - 16; i += 16) {\n        uint8x16_t v = vld1q_u8(src + i);\n        vst1q_u8(slice + i, v);\n    }\n\n    for (; i < total_elements_per_slice; i++) {\n        slice[i] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_6_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t bi = 0; bi < block_size && i + bi < rows; ++bi) {\n                for (size_t bj = 0; bj < block_size && j + bj < cols; bj += 8) {\n                    int16x8_t vec = vld1q_s16(&src[(i + bi) * cols + j + bj]);\n                    vst1q_s16(&dst[(j + bj) * rows + i + bi], vec);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t bi = 0; bi < block_size && i + bi < rows; ++bi) {\n                for (size_t bj = 0; bj < block_size && j + bj < cols; bj += 8) {\n                    int16x8_t row = vld1q_s16(&src[(i + bi) * cols + j + bj]);\n                    vst1q_s16(&dst[(j + bj) * rows + i + bi], row);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t bi = 0; bi < block_size && i + bi < rows; ++bi) {\n                for (size_t bj = 0; bj < block_size && j + bj < cols; bj += 8) {\n                    int16x8_t vec = vld1q_s16(&src[(i + bi) * cols + j + bj]);\n                    vst1q_s16(&dst[(j + bj) * rows + i + bi], vec);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_Neon", "completion": "```c\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t bi = 0; bi < block_size && i + bi < rows; ++bi) {\n                for (size_t bj = 0; bj < block_size && j + bj < cols; bj += 8) {\n                    int16x8_t vec = vld1q_s16(&src[(i + bi) * cols + j + bj]);\n                    vst1q_s16(&dst[(j + bj) * rows + i + bi], vec);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t bi = 0; bi < block_size && i + bi < rows; ++bi) {\n                for (size_t bj = 0; bj < block_size && j + bj < cols; bj += 8) {\n                    int16x8_t vec = vld1q_s16(&src[(i + bi) * cols + j + bj]);\n                    vst1q_s16(&dst[(j + bj) * rows + i + bi], vec);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_7_Neon", "completion": "```c\n#include <arm_neon.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float32x4_t sum = vdupq_n_f32(0.0f);\n    size_t i;\n\n    for (i = 0; i <= dim - 4; i += 4) {\n        float32x4_t values = vld1q_f32(&array[i * dim * dim + i * dim + i]);\n        sum = vaddq_f32(sum, values);\n    }\n\n    float32x2_t sum2 = vadd_f32(vget_low_f32(sum), vget_high_f32(sum));\n    float32x2_t sum3 = vpadd_f32(sum2, sum2);\n    float result = vget_lane_f32(sum3, 0);\n\n    for (; i < dim; ++i) {\n        result += array[i * dim * dim + i * dim + i];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_7_Neon", "completion": "```c\n#include <arm_neon.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float32x4_t sum = vdupq_n_f32(0.0f);\n    size_t i;\n\n    for (i = 0; i <= dim - 4; i += 4) {\n        float32x4_t values = vld1q_f32(&array[i * dim * dim + i * dim + i]);\n        sum = vaddq_f32(sum, values);\n    }\n\n    float32x2_t sum2 = vadd_f32(vget_low_f32(sum), vget_high_f32(sum));\n    float32x2_t sum3 = vpadd_f32(sum2, sum2);\n    float result = vget_lane_f32(sum3, 0);\n\n    for (; i < dim; ++i) {\n        result += array[i * dim * dim + i * dim + i];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_7_Neon", "completion": "```c\n#include <arm_neon.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float32x4_t sum = vdupq_n_f32(0.0f);\n    size_t i;\n\n    for (i = 0; i <= dim - 4; i += 4) {\n        float32x4_t values = vld1q_f32(&array[i * dim * dim + i * dim + i]);\n        sum = vaddq_f32(sum, values);\n    }\n\n    float32x2_t sum2 = vadd_f32(vget_low_f32(sum), vget_high_f32(sum));\n    float32x2_t sum3 = vpadd_f32(sum2, sum2);\n    float result = vget_lane_f32(sum3, 0);\n\n    for (; i < dim; ++i) {\n        result += array[i * dim * dim + i * dim + i];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_7_Neon", "completion": "```c\n#include <arm_neon.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float32x4_t sum = vdupq_n_f32(0.0f);\n    size_t i;\n\n    for (i = 0; i <= dim - 4; i += 4) {\n        float32x4_t values = vld1q_f32(&array[i * dim * dim + i * dim + i]);\n        sum = vaddq_f32(sum, values);\n    }\n\n    float32x2_t sum2 = vadd_f32(vget_low_f32(sum), vget_high_f32(sum));\n    float32x2_t sum3 = vpadd_f32(sum2, sum2);\n    float result = vget_lane_f32(sum3, 0);\n\n    for (; i < dim; ++i) {\n        result += array[i * dim * dim + i * dim + i];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_7_Neon", "completion": "```c\n#include <arm_neon.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float32x4_t sum = vdupq_n_f32(0.0f);\n    size_t i;\n\n    for (i = 0; i <= dim - 4; i += 4) {\n        float32x4_t values = vld1q_f32(&array[i * dim * dim + i * dim + i]);\n        sum = vaddq_f32(sum, values);\n    }\n\n    float32x2_t sum2 = vadd_f32(vget_low_f32(sum), vget_high_f32(sum));\n    float32x2_t sum3 = vpadd_f32(sum2, sum2);\n    float result = vget_lane_f32(sum3, 0);\n\n    for (; i < dim; ++i) {\n        result += array[i * dim * dim + i * dim + i];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_8_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    float64x2_t v_threshold = vdupq_n_f64(threshold);\n    float64x2_t v_scale = vdupq_n_f64(scale);\n\n    for (; i <= total_elements - 2; i += 2) {\n        float64x2_t v_src = vld1q_f64(&src[i]);\n        uint64x2_t v_mask = vcgtq_f64(v_src, v_threshold);\n        float64x2_t v_scaled = vmulq_f64(v_src, v_scale);\n        float64x2_t v_result = vbslq_f64(v_mask, v_scaled, v_src);\n        vst1q_f64(&dst[i], v_result);\n    }\n\n    // Handle any remaining elements\n    for (; i < total_elements; ++i) {\n        dst[i] = src[i] > threshold ? src[i] * scale : src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_8_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    float64x2_t v_threshold = vdupq_n_f64(threshold);\n    float64x2_t v_scale = vdupq_n_f64(scale);\n\n    for (; i <= total_elements - 2; i += 2) {\n        float64x2_t v_src = vld1q_f64(&src[i]);\n        uint64x2_t v_mask = vcgtq_f64(v_src, v_threshold);\n        float64x2_t v_scaled = vmulq_f64(v_src, v_scale);\n        float64x2_t v_result = vbslq_f64(v_mask, v_scaled, v_src);\n        vst1q_f64(&dst[i], v_result);\n    }\n\n    // Handle any remaining elements\n    for (; i < total_elements; ++i) {\n        dst[i] = src[i] > threshold ? src[i] * scale : src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_8_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    float64x2_t v_threshold = vdupq_n_f64(threshold);\n    float64x2_t v_scale = vdupq_n_f64(scale);\n\n    for (; i <= total_elements - 2; i += 2) {\n        float64x2_t v_src = vld1q_f64(&src[i]);\n        uint64x2_t v_mask = vcgtq_f64(v_src, v_threshold);\n        float64x2_t v_scaled = vmulq_f64(v_src, v_scale);\n        float64x2_t v_result = vbslq_f64(v_mask, v_scaled, v_src);\n        vst1q_f64(&dst[i], v_result);\n    }\n\n    // Handle any remaining elements\n    for (; i < total_elements; ++i) {\n        dst[i] = src[i] > threshold ? src[i] * scale : src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_8_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    float64x2_t v_threshold = vdupq_n_f64(threshold);\n    float64x2_t v_scale = vdupq_n_f64(scale);\n\n    for (; i <= total_elements - 2; i += 2) {\n        float64x2_t v_src = vld1q_f64(&src[i]);\n        uint64x2_t v_mask = vcgtq_f64(v_src, v_threshold);\n        float64x2_t v_scaled = vmulq_f64(v_src, v_scale);\n        float64x2_t v_result = vbslq_f64(v_mask, v_scaled, v_src);\n        vst1q_f64(&dst[i], v_result);\n    }\n\n    // Handle any remaining elements\n    for (; i < total_elements; ++i) {\n        dst[i] = src[i] > threshold ? src[i] * scale : src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_8_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    float64x2_t v_threshold = vdupq_n_f64(threshold);\n    float64x2_t v_scale = vdupq_n_f64(scale);\n\n    for (; i <= total_elements - 2; i += 2) {\n        float64x2_t v_src = vld1q_f64(&src[i]);\n        uint64x2_t v_mask = vcgtq_f64(v_src, v_threshold);\n        float64x2_t v_scaled = vmulq_f64(v_src, v_scale);\n        float64x2_t v_result = vbslq_f64(v_mask, v_scaled, v_src);\n        vst1q_f64(&dst[i], v_result);\n    }\n\n    // Handle any remaining elements\n    for (; i < total_elements; ++i) {\n        dst[i] = src[i] > threshold ? src[i] * scale : src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_9_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; ++i) {\n        size_t index = indices[i];\n        for (size_t j = 0; j < cols; j += 2) {\n            uint64x2_t src_vec = vld1q_u64((const uint64_t *)&src[index * cols + j]);\n            vst1q_u64((uint64_t *)&dst[i * cols + j], src_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; ++i) {\n        size_t index = indices[i];\n        for (size_t j = 0; j < cols; j += 2) {\n            uint64x2_t src_vec = vld1q_u64((const uint64_t *)&src[index * cols + j]);\n            vst1q_u64((uint64_t *)&dst[i * cols + j], src_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; ++i) {\n        size_t index = indices[i];\n        for (size_t j = 0; j < cols; j += 2) {\n            uint64x2_t src_vec = vld1q_u64((const uint64_t *)&src[index * cols + j]);\n            vst1q_u64((uint64_t *)&dst[i * cols + j], src_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; ++i) {\n        size_t index = indices[i];\n        for (size_t j = 0; j < cols; j += 2) {\n            uint64x2_t src_vec = vld1q_u64((const uint64_t *)&src[index * cols + j]);\n            vst1q_u64((uint64_t *)&dst[i * cols + j], src_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; ++i) {\n        size_t index = indices[i];\n        for (size_t j = 0; j < cols; j += 2) {\n            uint64x2_t src_vec = vld1q_u64((const uint64_t *)&src[index * cols + j]);\n            vst1q_u64((uint64_t *)&dst[i * cols + j], src_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_10_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i;\n    int64x2_t v_scalar = vdupq_n_s64(scalar);\n\n    for (i = 0; i <= length - 2; i += 2) {\n        int64x2_t v_src1 = vld1q_s64(&src1[i]);\n        int64x2_t v_src2 = vld1q_s64(&src2[i]);\n        int64x2_t v_sum = vaddq_s64(v_src1, v_src2);\n        int64x2_t v_result = vaddq_s64(v_sum, v_scalar);\n        int64x2_t v_final = vrshrq_n_s64(v_result, 1);\n        vst1q_s64(&dst[i], v_final);\n    }\n\n    // Handle the remaining elements\n    for (; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) >> 1;\n    }\n}\n```"}
{"task_id": "SimdBench_10_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i;\n    int64x2_t v_scalar = vdupq_n_s64(scalar);\n\n    for (i = 0; i <= length - 2; i += 2) {\n        int64x2_t v_src1 = vld1q_s64(&src1[i]);\n        int64x2_t v_src2 = vld1q_s64(&src2[i]);\n        int64x2_t v_sum = vaddq_s64(v_src1, v_src2);\n        int64x2_t v_result = vaddq_s64(v_sum, v_scalar);\n        int64x2_t v_final = vrshrq_n_s64(v_result, 1);\n        vst1q_s64(&dst[i], v_final);\n    }\n\n    // Handle the remaining elements\n    for (; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) >> 1;\n    }\n}\n```"}
{"task_id": "SimdBench_10_Neon", "completion": "```c\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i;\n    int64x2_t v_scalar = vdupq_n_s64(scalar);\n\n    for (i = 0; i <= length - 2; i += 2) {\n        int64x2_t v_src1 = vld1q_s64(&src1[i]);\n        int64x2_t v_src2 = vld1q_s64(&src2[i]);\n        int64x2_t v_sum = vaddq_s64(v_src1, v_src2);\n        int64x2_t v_result = vaddq_s64(v_sum, v_scalar);\n        int64x2_t v_final = vrshrq_n_s64(v_result, 1);\n        vst1q_s64(&dst[i], v_final);\n    }\n\n    // Handle the remaining elements\n    for (; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) >> 1;\n    }\n}\n```"}
{"task_id": "SimdBench_10_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i;\n    int64x2_t v_scalar = vdupq_n_s64(scalar);\n\n    for (i = 0; i <= length - 2; i += 2) {\n        int64x2_t v_src1 = vld1q_s64(&src1[i]);\n        int64x2_t v_src2 = vld1q_s64(&src2[i]);\n        int64x2_t v_sum = vaddq_s64(v_src1, v_src2);\n        int64x2_t v_result = vaddq_s64(v_sum, v_scalar);\n        int64x2_t v_final = vrshrq_n_s64(v_result, 1);\n        vst1q_s64(&dst[i], v_final);\n    }\n\n    // Handle the remaining elements\n    for (; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) >> 1;\n    }\n}\n```"}
{"task_id": "SimdBench_10_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i;\n    int64x2_t v_scalar = vdupq_n_s64(scalar);\n\n    for (i = 0; i <= length - 2; i += 2) {\n        int64x2_t v_src1 = vld1q_s64(&src1[i]);\n        int64x2_t v_src2 = vld1q_s64(&src2[i]);\n        int64x2_t v_sum = vaddq_s64(v_src1, v_src2);\n        int64x2_t v_result = vaddq_s64(v_sum, v_scalar);\n        int64x2_t v_final = vrshrq_n_s64(v_result, 1);\n        vst1q_s64(&dst[i], v_final);\n    }\n\n    // Handle the remaining elements\n    for (; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) >> 1;\n    }\n}\n```"}
{"task_id": "SimdBench_11_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    int32x4_t min_vec = vdupq_n_s32(INT32_MAX);\n    int i;\n\n    for (i = 0; i <= length - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&src[i]);\n        int32x2_t vec_low = vget_low_s32(vec);\n        int32x2_t vec_high = vget_high_s32(vec);\n\n        int32x2_t even_low = vsetq_lane_s32(vgetq_lane_s32(vec, 0), vec_low, 0);\n        int32x2_t even_high = vsetq_lane_s32(vgetq_lane_s32(vec, 2), vec_high, 0);\n\n        int32x2_t even_combined = vcombine_s32(even_low, even_high);\n        int32x2_t min_pair = vpmin_s32(even_combined, even_combined);\n        int32x2_t min_scalar = vpmin_s32(min_pair, min_pair);\n\n        min_vec = vminq_s32(min_vec, vcombine_s32(min_scalar, min_scalar));\n    }\n\n    int32x2_t min_pair = vpmin_s32(vget_low_s32(min_vec), vget_high_s32(min_vec));\n    int32x2_t min_scalar = vpmin_s32(min_pair, min_pair);\n\n    int min_val = vget_lane_s32(min_scalar, 0);\n\n    for (; i < length; i += 2) {\n        if (src[i] < min_val) {\n            min_val = src[i];\n        }\n    }\n\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    int32x4_t min_vec = vdupq_n_s32(INT32_MAX);\n    int i;\n\n    for (i = 0; i <= length - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&src[i]);\n        int32x2_t even_elements = vuzpq_s32(vget_low_s32(vec), vget_high_s32(vec)).val[0];\n        min_vec = vminq_s32(min_vec, even_elements);\n    }\n\n    int32x2_t min_pair = vpmin_s32(vget_low_s32(min_vec), vget_high_s32(min_vec));\n    int32x2_t min_result = vpmin_s32(min_pair, min_pair);\n\n    int min_value = vget_lane_s32(min_result, 0);\n\n    for (; i < length; i += 2) {\n        if (src[i] < min_value) {\n            min_value = src[i];\n        }\n    }\n\n    return min_value;\n}\n```"}
{"task_id": "SimdBench_11_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    int32x4_t min_vec = vdupq_n_s32(INT32_MAX);\n    size_t i = 0;\n\n    // Process 4 elements at a time\n    for (; i <= length - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&src[i]);\n        int32x2_t even_elements = vuzpq_s32(vec, vec).val[0];\n        min_vec = vminq_s32(min_vec, vcombine_s32(even_elements, even_elements));\n    }\n\n    // Find the minimum in the remaining elements\n    int32_t min_val = vgetq_lane_s32(min_vec, 0);\n    for (; i < length; i += 2) {\n        if (src[i] < min_val) {\n            min_val = src[i];\n        }\n    }\n\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    int32x4_t min_vec = vdupq_n_s32(INT32_MAX);\n    int32_t result = INT32_MAX;\n\n    for (size_t i = 0; i <= length - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&src[i]);\n        int32x4_t even_mask = vcreate_s32(0xFFFFFFFFFFFFFFFF);\n        int32x4_t even_vec = vandq_s32(vec, even_mask);\n        min_vec = vminq_s32(min_vec, even_vec);\n    }\n\n    int32x2_t min_pair1 = vpmin_s32(vget_low_s32(min_vec), vget_high_s32(min_vec));\n    int32x2_t min_pair2 = vpmin_s32(min_pair1, min_pair1);\n    vst1_s32(&result, min_pair2);\n\n    for (size_t i = (length & ~3); i < length; i++) {\n        if (src[i] < result) {\n            result = src[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_11_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    int32x4_t min_vec = vdupq_n_s32(INT32_MAX);\n    int i;\n\n    for (i = 0; i <= length - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&src[i]);\n        int32x2_t even_elements = vuzpq_s32(vec, vec).val[0];\n        min_vec = vminq_s32(min_vec, even_elements);\n    }\n\n    int32x2_t min_pair = vpmin_s32(vget_low_s32(min_vec), vget_high_s32(min_vec));\n    int32x2_t min_result = vpmin_s32(min_pair, min_pair);\n    int min_value = vget_lane_s32(min_result, 0);\n\n    for (; i < length; i += 2) {\n        if (src[i] < min_value) {\n            min_value = src[i];\n        }\n    }\n\n    return min_value;\n}\n```"}
{"task_id": "SimdBench_12_Neon", "completion": "```c\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        int32x4_t src_vec = vld1q_s32(&src[i]);\n        int32x4_t arith_shifted = vshrq_n_s32(src_vec, shift);\n        uint32x4_t logic_shifted = vreinterpretq_u32_s32(vshrq_n_u32(vreinterpretq_u32_s32(src_vec), shift));\n        int32x4_t result = vaddq_s32(arith_shifted, vreinterpretq_s32_u32(logic_shifted));\n        vst1q_s32(&dst[i], result);\n    }\n    for (; i < length; i++) {\n        int arith_shifted = src[i] >> shift;\n        unsigned int logic_shifted = (unsigned int)src[i] >> shift;\n        dst[i] = arith_shifted + (int)logic_shifted;\n    }\n}\n```"}
{"task_id": "SimdBench_12_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        int32x4_t src_vec = vld1q_s32(&src[i]);\n        int32x4_t arith_shifted = vshrq_n_s32(src_vec, shift);\n        uint32x4_t logic_shifted = vreinterpretq_u32_s32(vshrq_n_u32(vreinterpretq_u32_s32(src_vec), shift));\n        int32x4_t result = vaddq_s32(arith_shifted, vreinterpretq_s32_u32(logic_shifted));\n        vst1q_s32(&dst[i], result);\n    }\n    for (; i < length; i++) {\n        int32_t arith_shifted = src[i] >> shift;\n        uint32_t logic_shifted = (uint32_t)src[i] >> shift;\n        dst[i] = arith_shifted + (int32_t)logic_shifted;\n    }\n}\n```"}
{"task_id": "SimdBench_12_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        int32x4_t src_vec = vld1q_s32(&src[i]);\n        int32x4_t arith_shifted = vshrq_n_s32(src_vec, shift);\n        uint32x4_t logic_shifted = vreinterpretq_u32_s32(vshrq_n_u32(vreinterpretq_u32_s32(src_vec), shift));\n        int32x4_t result = vaddq_s32(arith_shifted, vreinterpretq_s32_u32(logic_shifted));\n        vst1q_s32(&dst[i], result);\n    }\n    for (; i < length; i++) {\n        int arith_shifted = src[i] >> shift;\n        unsigned int logic_shifted = (unsigned int)src[i] >> shift;\n        dst[i] = arith_shifted + (int)logic_shifted;\n    }\n}\n```"}
{"task_id": "SimdBench_12_Neon", "completion": "```c\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        int32x4_t src_vec = vld1q_s32(&src[i]);\n        int32x4_t arith_shifted = vshrq_n_s32(src_vec, shift);\n        uint32x4_t logic_shifted = vreinterpretq_u32_s32(vshrq_n_u32(vreinterpretq_u32_s32(src_vec), shift));\n        int32x4_t result = vaddq_s32(arith_shifted, vreinterpretq_s32_u32(logic_shifted));\n        vst1q_s32(&dst[i], result);\n    }\n    for (; i < length; i++) {\n        int arith_shifted = src[i] >> shift;\n        unsigned int logic_shifted = (unsigned int)src[i] >> shift;\n        dst[i] = arith_shifted + (int)logic_shifted;\n    }\n}\n```"}
{"task_id": "SimdBench_12_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        int32x4_t src_vec = vld1q_s32(&src[i]);\n        int32x4_t arith_shifted = vshrq_n_s32(src_vec, shift);\n        uint32x4_t logic_shifted = vreinterpretq_u32_s32(vshrq_n_u32(vreinterpretq_u32_s32(src_vec), shift));\n        int32x4_t result = vaddq_s32(arith_shifted, vreinterpretq_s32_u32(logic_shifted));\n        vst1q_s32(&dst[i], result);\n    }\n    for (; i < length; i++) {\n        int32_t arith_shifted = src[i] >> shift;\n        uint32_t logic_shifted = (uint32_t)src[i] >> shift;\n        dst[i] = arith_shifted + (int32_t)logic_shifted;\n    }\n}\n```"}
{"task_id": "SimdBench_13_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    // Process 4 elements at a time\n    for (; i <= total_elements - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&matrix[i]);\n        int64x2_t sum_vec = vpaddlq_s32(vec);\n        sum += vaddvq_s64(sum_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < total_elements; ++i) {\n        sum += matrix[i];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    // Process 4 elements at a time\n    for (; i <= total_elements - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&matrix[i]);\n        int64x2_t sum_vec = vpaddlq_s32(vec);\n        sum += vpadalq_s64(vcreate_s64(0), sum_vec)[0];\n    }\n\n    // Handle remaining elements\n    for (; i < total_elements; ++i) {\n        sum += matrix[i];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    // Process 4 elements at a time\n    for (; i <= total_elements - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&matrix[i]);\n        int64x2_t sum_vec = vpaddlq_s32(vec);\n        sum += vaddvq_s64(sum_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < total_elements; ++i) {\n        sum += matrix[i];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    // Process 4 elements at a time\n    for (; i <= total_elements - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&matrix[i]);\n        int64x2_t sum_vec = vpaddlq_s32(vec);\n        sum += vaddvq_s64(sum_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < total_elements; ++i) {\n        sum += matrix[i];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    // Process 4 elements at a time\n    for (; i <= total_elements - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&matrix[i]);\n        int64x2_t sum_vec = vpaddlq_s32(vec);\n        sum += vaddvq_s64(sum_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < total_elements; ++i) {\n        sum += matrix[i];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_14_Neon", "completion": "```c\n#include <arm_neon.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    int8x16_t max_vec = vdupq_n_s8(src[0]);\n    uint16x8_t idx_vec = vreinterpretq_u16_u8(vcreate_u8(0x0F0E0D0C0B0A09080706050403020100));\n    uint16x8_t max_idx_vec = idx_vec;\n    size_t i = 0;\n\n    for (; i <= length - 16; i += 16) {\n        int8x16_t current_vec = vld1q_s8(&src[i]);\n        uint16x8_t current_idx_vec = vaddq_u16(idx_vec, vreinterpretq_u16_u8(vcreate_u8(i)));\n\n        uint16x8_t gt_mask = vreinterpretq_u16_u8(vcgtq_s8(current_vec, max_vec));\n        max_vec = vmaxq_s8(max_vec, current_vec);\n        max_idx_vec = vbslq_u16(gt_mask, current_idx_vec, max_idx_vec);\n\n        idx_vec = vaddq_u16(idx_vec, vdupq_n_u16(16));\n    }\n\n    int8_t max_values[16];\n    uint16_t max_indices[8];\n    vst1q_s8(max_values, max_vec);\n    vst1q_u16(max_indices, max_idx_vec);\n\n    int8_t max_val = max_values[0];\n    size_t max_idx = max_indices[0];\n\n    for (size_t j = 1; j < 8; ++j) {\n        if (max_values[j] > max_val) {\n            max_val = max_values[j];\n            max_idx = max_indices[j];\n        }\n    }\n\n    for (; i < length; ++i) {\n        if (src[i] > max_val) {\n            max_val = src[i];\n            max_idx = i;\n        }\n    }\n\n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_14_Neon", "completion": "```c\n#include <arm_neon.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    int8x16_t max_vec = vdupq_n_s8(src[0]);\n    uint16x8_t idx_vec = vreinterpretq_u16_u8(vcreate_u8(0x0F0E0D0C0B0A09080706050403020100));\n    uint16x8_t max_idx_vec = idx_vec;\n    size_t i = 0;\n\n    for (; i <= length - 16; i += 16) {\n        int8x16_t current_vec = vld1q_s8(&src[i]);\n        uint16x8_t current_idx_vec = vaddq_u16(idx_vec, vreinterpretq_u16_u8(vcreate_u8(i)));\n\n        uint16x8_t gt_mask = vreinterpretq_u16_u8(vcgtq_s8(current_vec, max_vec));\n        max_vec = vmaxq_s8(max_vec, current_vec);\n        max_idx_vec = vbslq_u16(gt_mask, current_idx_vec, max_idx_vec);\n\n        idx_vec = vaddq_u16(idx_vec, vdupq_n_u16(16));\n    }\n\n    int8_t max_values[16];\n    uint16_t max_indices[8];\n    vst1q_s8(max_values, max_vec);\n    vst1q_u16(max_indices, max_idx_vec);\n\n    int8_t max_val = max_values[0];\n    size_t max_idx = max_indices[0];\n\n    for (size_t j = 1; j < 8; ++j) {\n        if (max_values[j] > max_val) {\n            max_val = max_values[j];\n            max_idx = max_indices[j];\n        }\n    }\n\n    for (; i < length; ++i) {\n        if (src[i] > max_val) {\n            max_val = src[i];\n            max_idx = i;\n        }\n    }\n\n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_14_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    int8x16_t max_vec = vdupq_n_s8(src[0]);\n    uint16x8_t idx_vec = vreinterpretq_u16_u8(vcreate_u8(0x0F0E0D0C0B0A09080706050403020100));\n    uint16x8_t max_idx_vec = idx_vec;\n    size_t i = 0;\n\n    for (; i <= length - 16; i += 16) {\n        int8x16_t current_vec = vld1q_s8(&src[i]);\n        uint16x8_t current_idx_vec = vaddq_u16(idx_vec, vreinterpretq_u16_u8(vcreate_u8(i)));\n\n        uint16x8_t gt_mask = vcgtq_s8(current_vec, max_vec);\n        max_vec = vmaxq_s8(max_vec, current_vec);\n        max_idx_vec = vbslq_u16(gt_mask, current_idx_vec, max_idx_vec);\n\n        idx_vec = vaddq_u16(idx_vec, vdupq_n_u16(16));\n    }\n\n    int8_t max_values[16];\n    uint16_t max_indices[8];\n    vst1q_s8(max_values, max_vec);\n    vst1q_u16(max_indices, max_idx_vec);\n\n    int8_t max_val = max_values[0];\n    size_t max_idx = max_indices[0];\n\n    for (size_t j = 1; j < 8; ++j) {\n        if (max_values[j] > max_val) {\n            max_val = max_values[j];\n            max_idx = max_indices[j];\n        }\n    }\n\n    for (; i < length; ++i) {\n        if (src[i] > max_val) {\n            max_val = src[i];\n            max_idx = i;\n        }\n    }\n\n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_14_Neon", "completion": "```c\n#include <arm_neon.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    int8x16_t max_vec = vdupq_n_s8(src[0]);\n    uint16x8_t idx_vec = vreinterpretq_u16_u8(vcreate_u8(0x0F0E0D0C0B0A09080706050403020100));\n    uint16x8_t max_idx_vec = idx_vec;\n    size_t i = 0;\n\n    for (; i <= length - 16; i += 16) {\n        int8x16_t current_vec = vld1q_s8(&src[i]);\n        uint8x16_t cmp_vec = vcgtq_s8(current_vec, max_vec);\n        max_vec = vmaxq_s8(max_vec, current_vec);\n        uint16x8_t new_idx_vec = vaddq_u16(idx_vec, vreinterpretq_u16_u8(vcreate_u8(i)));\n        max_idx_vec = vbslq_u16(cmp_vec, new_idx_vec, max_idx_vec);\n        idx_vec = vaddq_u16(idx_vec, vdupq_n_u16(16));\n    }\n\n    int8_t max_val = vgetq_lane_s8(max_vec, 0);\n    size_t max_idx = vgetq_lane_u16(max_idx_vec, 0);\n\n    for (; i < length; ++i) {\n        if (src[i] > max_val) {\n            max_val = src[i];\n            max_idx = i;\n        }\n    }\n\n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_14_Neon", "completion": "```c\n#include <arm_neon.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    int8x16_t max_vec = vdupq_n_s8(src[0]);\n    uint16x8_t idx_vec = vreinterpretq_u16_u8(vcreate_u8(0x0F0E0D0C0B0A09080706050403020100));\n    uint16x8_t max_idx_vec = idx_vec;\n    size_t i = 0;\n\n    for (; i <= length - 16; i += 16) {\n        int8x16_t current_vec = vld1q_s8(&src[i]);\n        uint16x8_t current_idx_vec = vaddq_u16(idx_vec, vreinterpretq_u16_u8(vcreate_u8(i)));\n\n        uint16x8_t gt_mask = vreinterpretq_u16_u8(vcgtq_s8(current_vec, max_vec));\n        max_vec = vmaxq_s8(max_vec, current_vec);\n        max_idx_vec = vbslq_u16(gt_mask, current_idx_vec, max_idx_vec);\n\n        idx_vec = vaddq_u16(idx_vec, vdupq_n_u16(16));\n    }\n\n    int8_t max_values[16];\n    uint16_t max_indices[8];\n    vst1q_s8(max_values, max_vec);\n    vst1q_u16(max_indices, max_idx_vec);\n\n    int8_t max_val = max_values[0];\n    size_t max_idx = max_indices[0];\n\n    for (size_t j = 1; j < 8; ++j) {\n        if (max_values[j] > max_val) {\n            max_val = max_values[j];\n            max_idx = max_indices[j];\n        }\n    }\n\n    for (; i < length; ++i) {\n        if (src[i] > max_val) {\n            max_val = src[i];\n            max_idx = i;\n        }\n    }\n\n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_15_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    uint16x8_t v_mask = vdupq_n_u16(mask);\n\n    for (; i <= length - 8; i += 8) {\n        uint16x8_t v_index = vaddq_u16(vld1q_u16((const uint16_t*)&i), vcreate_u16(0x0706050403020100));\n        uint16x8_t v_and_result = vandq_u16(v_index, v_mask);\n        uint16x8_t v_src1 = vld1q_u16(&src1[i]);\n        uint16x8_t v_src2 = vld1q_u16(&src2[i]);\n        uint16x8_t v_cmp_result = vceqq_u16(v_and_result, vdupq_n_u16(0));\n        uint16x8_t v_result = vbslq_u16(v_cmp_result, v_src2, v_src1);\n        vst1q_u16(&dst[i], v_result);\n    }\n\n    for (; i < length; i++) {\n        if ((i & mask) != 0) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 8; i += 8) {\n        uint16x8_t v_src1 = vld1q_u16(&src1[i]);\n        uint16x8_t v_src2 = vld1q_u16(&src2[i]);\n        uint16x8_t v_index = vdupq_n_u16(i);\n        uint16x8_t v_mask = vdupq_n_u16(mask);\n        uint16x8_t v_and_result = vandq_u16(v_index, v_mask);\n        uint16x8_t v_cmp_result = vceqq_u16(v_and_result, vdupq_n_u16(0));\n        uint16x8_t v_selected = vbslq_u16(v_cmp_result, v_src2, v_src1);\n        vst1q_u16(&dst[i], v_selected);\n    }\n    for (; i < length; i++) {\n        dst[i] = ((i & mask) == 0) ? src2[i] : src1[i];\n    }\n}\n```"}
{"task_id": "SimdBench_15_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 8; i += 8) {\n        uint16x8_t v_src1 = vld1q_u16(&src1[i]);\n        uint16x8_t v_src2 = vld1q_u16(&src2[i]);\n        uint16x8_t v_index = vdupq_n_u16(i);\n        uint16x8_t v_mask = vdupq_n_u16(mask);\n        uint16x8_t v_and_result = vandq_u16(v_index, v_mask);\n        uint16x8_t v_cmp_result = vceqq_u16(v_and_result, vdupq_n_u16(0));\n        uint16x8_t v_selected = vbslq_u16(v_cmp_result, v_src2, v_src1);\n        vst1q_u16(&dst[i], v_selected);\n    }\n    for (; i < length; i++) {\n        dst[i] = ((i & mask) == 0) ? src2[i] : src1[i];\n    }\n}\n```"}
{"task_id": "SimdBench_15_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 8; i += 8) {\n        uint16x8_t v_src1 = vld1q_u16(&src1[i]);\n        uint16x8_t v_src2 = vld1q_u16(&src2[i]);\n        uint16x8_t v_index = vdupq_n_u16(i);\n        uint16x8_t v_mask = vdupq_n_u16(mask);\n        uint16x8_t v_and_result = vandq_u16(v_index, v_mask);\n        uint16x8_t v_cmp_result = vceqq_u16(v_and_result, vdupq_n_u16(0));\n        uint16x8_t v_selected = vbslq_u16(v_cmp_result, v_src2, v_src1);\n        vst1q_u16(&dst[i], v_selected);\n    }\n    for (; i < length; i++) {\n        dst[i] = ((i & mask) == 0) ? src2[i] : src1[i];\n    }\n}\n```"}
{"task_id": "SimdBench_15_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    uint16x8_t v_mask = vmovq_n_u16(mask);\n\n    for (; i <= length - 8; i += 8) {\n        uint16x8_t v_index = vaddq_u16(vcreate_u16(((uint64_t)i << 48) | ((uint64_t)(i+1) << 32) | ((uint64_t)(i+2) << 16) | (i+3)),\n                                        vcreate_u16(((uint64_t)(i+4) << 48) | ((uint64_t)(i+5) << 32) | ((uint64_t)(i+6) << 16) | (i+7)));\n        uint16x8_t v_and_result = vandq_u16(v_index, v_mask);\n        uint16x8_t v_src1 = vld1q_u16(&src1[i]);\n        uint16x8_t v_src2 = vld1q_u16(&src2[i]);\n        uint16x8_t v_cmp_result = vceqq_u16(v_and_result, vmovq_n_u16(0));\n        uint16x8_t v_result = vbslq_u16(v_cmp_result, v_src2, v_src1);\n        vst1q_u16(&dst[i], v_result);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = ((i & mask) == 0) ? src2[i] : src1[i];\n    }\n}\n```"}
{"task_id": "SimdBench_16_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        uint32x4_t input = vld1q_u32(&src[i]);\n        uint32x4_t ones = vcntq_u32(input);\n        vst1q_u32(&dst[i], ones);\n    }\n    for (; i < length; ++i) {\n        dst[i] = __builtin_popcount(src[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_16_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 8; i += 8) {\n        uint32x4_t v1 = vld1q_u32(&src[i]);\n        uint32x4_t v2 = vld1q_u32(&src[i + 4]);\n\n        uint32x4_t popcnt1 = vcntq_u32(v1);\n        uint32x4_t popcnt2 = vcntq_u32(v2);\n\n        vst1q_u32(&dst[i], popcnt1);\n        vst1q_u32(&dst[i + 4], popcnt2);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = __builtin_popcount(src[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_16_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        uint32x4_t input = vld1q_u32(&src[i]);\n        uint32x4_t ones = vcntq_u32(input);\n        vst1q_u32(&dst[i], ones);\n    }\n    for (; i < length; ++i) {\n        dst[i] = __builtin_popcount(src[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_16_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        uint32x4_t input = vld1q_u32(&src[i]);\n        uint32x4_t ones = vcntq_u32(input);\n        vst1q_u32(&dst[i], ones);\n    }\n    for (; i < length; ++i) {\n        dst[i] = __builtin_popcount(src[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_16_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        uint32x4_t input = vld1q_u32(&src[i]);\n        uint32x4_t ones = vcntq_u32(input);\n        vst1q_u32(&dst[i], ones);\n    }\n    for (; i < length; ++i) {\n        dst[i] = __builtin_popcount(src[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_17_Neon", "completion": "```cpp\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 8; i += 8) {\n        uint16x8_t vec1 = vld1q_u16(&src1[i]);\n        uint16x8_t vec2 = vld1q_u16(&src2[i]);\n        uint16x8_t result = vqaddq_u16(vec1, vec2);\n        vst1q_u16(&dst[i], result);\n    }\n    for (; i < length; i++) {\n        dst[i] = src1[i] + src2[i] > UINT16_MAX ? UINT16_MAX : src1[i] + src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_17_Neon", "completion": "```c\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 8; i += 8) {\n        uint16x8_t vec1 = vld1q_u16(&src1[i]);\n        uint16x8_t vec2 = vld1q_u16(&src2[i]);\n        uint16x8_t result = vqaddq_u16(vec1, vec2);\n        vst1q_u16(&dst[i], result);\n    }\n    for (; i < length; i++) {\n        dst[i] = src1[i] + src2[i] > UINT16_MAX ? UINT16_MAX : src1[i] + src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_17_Neon", "completion": "```c\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 8; i += 8) {\n        uint16x8_t vec1 = vld1q_u16(&src1[i]);\n        uint16x8_t vec2 = vld1q_u16(&src2[i]);\n        uint16x8_t result = vqaddq_u16(vec1, vec2);\n        vst1q_u16(&dst[i], result);\n    }\n    for (; i < length; i++) {\n        dst[i] = src1[i] + src2[i] > UINT16_MAX ? UINT16_MAX : src1[i] + src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_17_Neon", "completion": "```c\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i;\n    for (i = 0; i <= length - 8; i += 8) {\n        uint16x8_t vec1 = vld1q_u16(&src1[i]);\n        uint16x8_t vec2 = vld1q_u16(&src2[i]);\n        uint16x8_t result = vqaddq_u16(vec1, vec2);\n        vst1q_u16(&dst[i], result);\n    }\n    for (; i < length; i++) {\n        dst[i] = src1[i] + src2[i] > UINT16_MAX ? UINT16_MAX : src1[i] + src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_17_Neon", "completion": "```c\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 8; i += 8) {\n        uint16x8_t vec1 = vld1q_u16(&src1[i]);\n        uint16x8_t vec2 = vld1q_u16(&src2[i]);\n        uint16x8_t result = vqaddq_u16(vec1, vec2);\n        vst1q_u16(&dst[i], result);\n    }\n    for (; i < length; i++) {\n        dst[i] = src1[i] + src2[i] > UINT16_MAX ? UINT16_MAX : src1[i] + src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_18_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    double min_val = -100.0;\n    double max_val = 100.0;\n    float64x2_t v_min = vdupq_n_f64(min_val);\n    float64x2_t v_max = vdupq_n_f64(max_val);\n\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            float64x2_t sum = vdupq_n_f64(0.0);\n            size_t k = 0;\n            for (; k <= n - 2; k += 2) {\n                float64x2_t va = vld1q_f64(&A[i * n + k]);\n                float64x2_t vb = vld1q_f64(&B[j + k * p]);\n                uint64x2_t mask_a = vcgeq_f64(va, v_min) & vcleq_f64(va, v_max);\n                uint64x2_t mask_b = vcgeq_f64(vb, v_min) & vcleq_f64(vb, v_max);\n                uint64x2_t mask = mask_a & mask_b;\n                float64x2_t prod = vmulq_f64(va, vb);\n                float64x2_t masked_prod = vreinterpretq_f64_u64(vandq_u64(vreinterpretq_u64_f64(prod), mask));\n                sum = vaddq_f64(sum, masked_prod);\n            }\n            double temp_sum[2];\n            vst1q_f64(temp_sum, sum);\n            C[i * p + j] = temp_sum[0] + temp_sum[1];\n\n            for (; k < n; ++k) {\n                double a = A[i * n + k];\n                double b = B[j + k * p];\n                if (a >= min_val && a <= max_val && b >= min_val && b <= max_val) {\n                    C[i * p + j] += a * b;\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    double min_val = -100.0;\n    double max_val = 100.0;\n    float64x2_t v_min = vdupq_n_f64(min_val);\n    float64x2_t v_max = vdupq_n_f64(max_val);\n\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            float64x2_t sum = vdupq_n_f64(0.0);\n            size_t k = 0;\n            for (; k <= n - 2; k += 2) {\n                float64x2_t va = vld1q_f64(&A[i * n + k]);\n                float64x2_t vb = vld1q_f64(&B[k * p + j]);\n\n                uint64x2_t mask_a = vcgeq_f64(va, v_min) & vcleq_f64(va, v_max);\n                uint64x2_t mask_b = vcgeq_f64(vb, v_min) & vcleq_f64(vb, v_max);\n\n                va = vbslq_f64(mask_a, va, vdupq_n_f64(0.0));\n                vb = vbslq_f64(mask_b, vb, vdupq_n_f64(0.0));\n\n                sum = vfmaq_f64(sum, va, vb);\n            }\n            double temp_sum[2];\n            vst1q_f64(temp_sum, sum);\n            C[i * p + j] = temp_sum[0] + temp_sum[1];\n\n            for (; k < n; ++k) {\n                double a = A[i * n + k];\n                double b = B[k * p + j];\n                if (a >= min_val && a <= max_val && b >= min_val && b <= max_val) {\n                    C[i * p + j] += a * b;\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    double min_val = -100.0;\n    double max_val = 100.0;\n    float64x2_t v_min = vdupq_n_f64(min_val);\n    float64x2_t v_max = vdupq_n_f64(max_val);\n\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            float64x2_t sum = vdupq_n_f64(0.0);\n            size_t k = 0;\n            for (; k <= n - 2; k += 2) {\n                float64x2_t va = vld1q_f64(&A[i * n + k]);\n                float64x2_t vb = vld1q_f64(&B[k * p + j]);\n\n                uint64x2_t mask_a = vcgeq_f64(va, v_min) & vcleq_f64(va, v_max);\n                uint64x2_t mask_b = vcgeq_f64(vb, v_min) & vcleq_f64(vb, v_max);\n\n                va = vbslq_f64(mask_a, va, vdupq_n_f64(0.0));\n                vb = vbslq_f64(mask_b, vb, vdupq_n_f64(0.0));\n\n                sum = vfmaq_f64(sum, va, vb);\n            }\n            double temp_sum[2];\n            vst1q_f64(temp_sum, sum);\n            C[i * p + j] = temp_sum[0] + temp_sum[1];\n\n            for (; k < n; ++k) {\n                double a = A[i * n + k];\n                double b = B[k * p + j];\n                if (a >= min_val && a <= max_val && b >= min_val && b <= max_val) {\n                    C[i * p + j] += a * b;\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    double min_val = -100.0;\n    double max_val = 100.0;\n    float64x2_t v_min = vdupq_n_f64(min_val);\n    float64x2_t v_max = vdupq_n_f64(max_val);\n\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            float64x2_t sum = vdupq_n_f64(0.0);\n            size_t k = 0;\n            for (; k <= n - 2; k += 2) {\n                float64x2_t va = vld1q_f64(&A[i * n + k]);\n                float64x2_t vb = vld1q_f64(&B[k * p + j]);\n\n                uint64x2_t mask_a = vcgeq_f64(va, v_min) & vcleq_f64(va, v_max);\n                uint64x2_t mask_b = vcgeq_f64(vb, v_min) & vcleq_f64(vb, v_max);\n\n                va = vbslq_f64(mask_a, va, vdupq_n_f64(0.0));\n                vb = vbslq_f64(mask_b, vb, vdupq_n_f64(0.0));\n\n                sum = vfmaq_f64(sum, va, vb);\n            }\n            double temp_sum[2];\n            vst1q_f64(temp_sum, sum);\n            C[i * p + j] = temp_sum[0] + temp_sum[1];\n\n            for (; k < n; ++k) {\n                double a = A[i * n + k];\n                double b = B[k * p + j];\n                if (a >= min_val && a <= max_val && b >= min_val && b <= max_val) {\n                    C[i * p + j] += a * b;\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    double min_val = -100.0;\n    double max_val = 100.0;\n    float64x2_t v_min = vdupq_n_f64(min_val);\n    float64x2_t v_max = vdupq_n_f64(max_val);\n\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            float64x2_t sum = vdupq_n_f64(0.0);\n            size_t k = 0;\n            for (; k <= n - 2; k += 2) {\n                float64x2_t va = vld1q_f64(&A[i * n + k]);\n                float64x2_t vb = vld1q_f64(&B[k * p + j]);\n\n                uint64x2_t mask_a = vcgeq_f64(va, v_min) & vcleq_f64(va, v_max);\n                uint64x2_t mask_b = vcgeq_f64(vb, v_min) & vcleq_f64(vb, v_max);\n\n                va = vbslq_f64(mask_a, va, vdupq_n_f64(0.0));\n                vb = vbslq_f64(mask_b, vb, vdupq_n_f64(0.0));\n\n                sum = vfmaq_f64(sum, va, vb);\n            }\n            double temp_sum[2];\n            vst1q_f64(temp_sum, sum);\n            C[i * p + j] = temp_sum[0] + temp_sum[1];\n\n            for (; k < n; ++k) {\n                double a = A[i * n + k];\n                double b = B[k * p + j];\n                if (a >= min_val && a <= max_val && b >= min_val && b <= max_val) {\n                    C[i * p + j] += a * b;\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19_Neon", "completion": "```cpp\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i <= total_elements - 2; i += 2) {\n        int64x2_t vecA = vld1q_s64(&A[i]);\n        int64x2_t vecB = vld1q_s64(&B[i]);\n        int64x2_t vecC = vaddq_s64(vecA, vecB);\n        vst1q_s64(&C[i], vecC);\n    }\n\n    // Handle any remaining elements\n    for (; i < total_elements; ++i) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19_Neon", "completion": "```cpp\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i <= total_elements - 2; i += 2) {\n        int64x2_t vecA = vld1q_s64(&A[i]);\n        int64x2_t vecB = vld1q_s64(&B[i]);\n        int64x2_t vecC = vaddq_s64(vecA, vecB);\n        vst1q_s64(&C[i], vecC);\n    }\n\n    // Handle any remaining elements\n    for (; i < total_elements; ++i) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19_Neon", "completion": "```cpp\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i <= total_elements - 2; i += 2) {\n        int64x2_t vecA = vld1q_s64(&A[i]);\n        int64x2_t vecB = vld1q_s64(&B[i]);\n        int64x2_t vecC = vaddq_s64(vecA, vecB);\n        vst1q_s64(&C[i], vecC);\n    }\n\n    // Handle any remaining elements\n    for (; i < total_elements; ++i) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19_Neon", "completion": "```cpp\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i <= total_elements - 2; i += 2) {\n        int64x2_t vecA = vld1q_s64(&A[i]);\n        int64x2_t vecB = vld1q_s64(&B[i]);\n        int64x2_t vecC = vaddq_s64(vecA, vecB);\n        vst1q_s64(&C[i], vecC);\n    }\n\n    // Handle any remaining elements\n    for (; i < total_elements; ++i) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19_Neon", "completion": "```cpp\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i <= total_elements - 2; i += 2) {\n        int64x2_t vecA = vld1q_s64(&A[i]);\n        int64x2_t vecB = vld1q_s64(&B[i]);\n        int64x2_t vecC = vaddq_s64(vecA, vecB);\n        vst1q_s64(&C[i], vecC);\n    }\n\n    // Handle any remaining elements\n    for (; i < total_elements; ++i) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_20_Neon", "completion": "```cpp\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        float32x4_t vec1 = vld1q_f32(&src1[i]);\n        float32x4_t vec2 = vld1q_f32(&src2[i]);\n        float32x4_t sum = vaddq_f32(vec1, vec2);\n        int32x4_t rounded_sum = vrndnq_s32_f32(sum);\n        float32x4_t result = vcvtq_f32_s32(rounded_sum);\n        vst1q_f32(&dst[i], result);\n    }\n    for (; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20_Neon", "completion": "```c\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    for (i = 0; i <= length - 4; i += 4) {\n        float32x4_t vec1 = vld1q_f32(&src1[i]);\n        float32x4_t vec2 = vld1q_f32(&src2[i]);\n        float32x4_t sum = vaddq_f32(vec1, vec2);\n        int32x4_t rounded = vrndnq_s32_f32(sum);\n        float32x4_t result = vcvtq_f32_s32(rounded);\n        vst1q_f32(&dst[i], result);\n    }\n    for (; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    for (i = 0; i <= length - 4; i += 4) {\n        float32x4_t vec1 = vld1q_f32(&src1[i]);\n        float32x4_t vec2 = vld1q_f32(&src2[i]);\n        float32x4_t sum = vaddq_f32(vec1, vec2);\n        int32x4_t rounded_sum = vrndnq_s32_f32(sum);\n        float32x4_t result = vcvtq_f32_s32(rounded_sum);\n        vst1q_f32(&dst[i], result);\n    }\n    for (; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20_Neon", "completion": "```cpp\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        float32x4_t vec1 = vld1q_f32(&src1[i]);\n        float32x4_t vec2 = vld1q_f32(&src2[i]);\n        float32x4_t sum = vaddq_f32(vec1, vec2);\n        int32x4_t rounded = vrndnq_s32_f32(sum);\n        float32x4_t result = vcvtq_f32_s32(rounded);\n        vst1q_f32(&dst[i], result);\n    }\n    for (; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    for (i = 0; i <= length - 4; i += 4) {\n        float32x4_t vec1 = vld1q_f32(&src1[i]);\n        float32x4_t vec2 = vld1q_f32(&src2[i]);\n        float32x4_t sum = vaddq_f32(vec1, vec2);\n        int32x4_t rounded_sum = vrndnq_s32_f32(sum);\n        vst1q_f32(&dst[i], vcvtq_f32_s32(rounded_sum));\n    }\n    for (; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_21_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length){\n    float32x4_t threshold = vdupq_n_f32(50.0f);\n    float32x4_t neg_one = vdupq_n_f32(-1.0f);\n    float32x4_t two = vdupq_n_f32(2.0f);\n    float32x4_t zero = vdupq_n_f32(0.0f);\n\n    for (size_t i = 0; i < length; i += 8) {\n        float32x4_t s1_1 = vld1q_f32(&src1[i]);\n        float32x4_t s2_1 = vld1q_f32(&src2[i]);\n        float32x4_t s1_2 = vld1q_f32(&src1[i + 4]);\n        float32x4_t s2_2 = vld1q_f32(&src2[i + 4]);\n\n        uint32x4_t idx_mask_1 = vcgeq_f32(vreinterpretq_f32_u32(vmovq_n_u32(i)), zero);\n        uint32x4_t idx_mask_2 = vcgeq_f32(vreinterpretq_f32_u32(vmovq_n_u32(i + 4)), zero);\n\n        float32x4_t diff_1 = vabsq_f32(vsubq_f32(s1_1, s2_1));\n        float32x4_t diff_2 = vabsq_f32(vsubq_f32(s1_2, s2_2));\n\n        uint32x4_t cond_1 = vandq_u32(vcgeq_f32(diff_1, threshold), idx_mask_1);\n        uint32x4_t cond_2 = vandq_u32(vcgeq_f32(diff_2, threshold), idx_mask_2);\n\n        float32x4_t mul_1 = vmulq_f32(s1_1, s2_1);\n        float32x4_t mul_2 = vmulq_f32(s1_2, s2_2);\n\n        float32x4_t rounded_1 = vaddq_f32(mul_1, vsubq_f32(vrecpeq_f32(mul_1), vrecpsq_f32(vrecpeq_f32(mul_1), mul_1)));\n        float32x4_t rounded_2 = vaddq_f32(mul_2, vsubq_f32(vrecpeq_f32(mul_2), vrecpsq_f32(vrecpeq_f32(mul_2), mul_2)));\n\n        float32x4_t result_1 = vbslq_f32(cond_1, rounded_1, neg_one);\n        float32x4_t result_2 = vbslq_f32(cond_2, rounded_2, neg_one);\n\n        vst1q_f32(&dst[i], result_1);\n        vst1q_f32(&dst[i + 4], result_2);\n    }\n}\n```"}
{"task_id": "SimdBench_21_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length){\n    float32x4_t threshold = vdupq_n_f32(50.0f);\n    float32x4_t neg_one = vdupq_n_f32(-1.0f);\n    float32x4_t two = vdupq_n_f32(2.0f);\n    float32x4_t zero = vdupq_n_f32(0.0f);\n\n    for (size_t i = 0; i < length; i += 8) {\n        float32x4_t s1_1 = vld1q_f32(&src1[i]);\n        float32x4_t s2_1 = vld1q_f32(&src2[i]);\n        float32x4_t s1_2 = vld1q_f32(&src1[i + 4]);\n        float32x4_t s2_2 = vld1q_f32(&src2[i + 4]);\n\n        uint32x4_t idx_mask_1 = vcgeq_f32(vreinterpretq_f32_u32(vandq_u32(vreinterpretq_u32_f32(vdupq_n_f32(i)), vreinterpretq_u32_f32(two))), zero);\n        uint32x4_t idx_mask_2 = vcgeq_f32(vreinterpretq_f32_u32(vandq_u32(vreinterpretq_u32_f32(vdupq_n_f32(i + 4)), vreinterpretq_u32_f32(two))), zero);\n\n        float32x4_t diff_1 = vabsq_f32(vsubq_f32(s1_1, s2_1));\n        float32x4_t diff_2 = vabsq_f32(vsubq_f32(s1_2, s2_2));\n\n        uint32x4_t cond_mask_1 = vandq_u32(idx_mask_1, vcleq_f32(diff_1, threshold));\n        uint32x4_t cond_mask_2 = vandq_u32(idx_mask_2, vcleq_f32(diff_2, threshold));\n\n        float32x4_t mul_1 = vmulq_f32(s1_1, s2_1);\n        float32x4_t mul_2 = vmulq_f32(s1_2, s2_2);\n\n        float32x4_t result_1 = vbslq_f32(cond_mask_1, vreinterpretq_f32_u32(vaddq_u32(vreinterpretq_u32_f32(mul_1), vreinterpretq_u32_f32(vrecpeq_f32(vsubq_f32(vrecpeq_f32(mul_1), zero))))), neg_one);\n        float32x4_t result_2 = vbslq_f32(cond_mask_2, vreinterpretq_f32_u32(vaddq_u32(vreinterpretq_u32_f32(mul_2), vreinterpretq_u32_f32(vrecpeq_f32(vsubq_f32(vrecpeq_f32(mul_2), zero))))), neg_one);\n\n        vst1q_f32(&dst[i], result_1);\n        vst1q_f32(&dst[i + 4], result_2);\n    }\n}\n```"}
{"task_id": "SimdBench_21_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length){\n    float32x4_t threshold = vdupq_n_f32(50.0f);\n    float32x4_t neg_one = vdupq_n_f32(-1.0f);\n    float32x4_t two = vdupq_n_f32(2.0f);\n    float32x4_t zero = vdupq_n_f32(0.0f);\n\n    for (size_t i = 0; i < length; i += 8) {\n        float32x4_t s1_0 = vld1q_f32(&src1[i]);\n        float32x4_t s2_0 = vld1q_f32(&src2[i]);\n        float32x4_t s1_1 = vld1q_f32(&src1[i + 4]);\n        float32x4_t s2_1 = vld1q_f32(&src2[i + 4]);\n\n        uint32x4_t idx_0 = vcgtq_f32(vdupq_n_f32(i), zero);\n        uint32x4_t idx_1 = vcgtq_f32(vdupq_n_f32(i + 4), zero);\n\n        idx_0 = vandq_u32(idx_0, vceqq_f32(vmodq_f32(vdupq_n_f32(i), two), zero));\n        idx_1 = vandq_u32(idx_1, vceqq_f32(vmodq_f32(vdupq_n_f32(i + 4), two), zero));\n\n        float32x4_t diff_0 = vabsq_f32(vsubq_f32(s1_0, s2_0));\n        float32x4_t diff_1 = vabsq_f32(vsubq_f32(s1_1, s2_1));\n\n        uint32x4_t cond_0 = vcleq_f32(diff_0, threshold);\n        uint32x4_t cond_1 = vcleq_f32(diff_1, threshold);\n\n        cond_0 = vandq_u32(cond_0, idx_0);\n        cond_1 = vandq_u32(cond_1, idx_1);\n\n        float32x4_t mul_0 = vmulq_f32(s1_0, s2_0);\n        float32x4_t mul_1 = vmulq_f32(s1_1, s2_1);\n\n        float32x4_t result_0 = vbslq_f32(cond_0, mul_0, neg_one);\n        float32x4_t result_1 = vbslq_f32(cond_1, mul_1, neg_one);\n\n        result_0 = vcvtaq_f32_f32(result_0);\n        result_1 = vcvtaq_f32_f32(result_1);\n\n        vst1q_f32(&dst[i], result_0);\n        vst1q_f32(&dst[i + 4], result_1);\n    }\n}\n```"}
{"task_id": "SimdBench_21_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length){\n    float32x4_t threshold = vdupq_n_f32(50.0f);\n    float32x4_t minus_one = vdupq_n_f32(-1.0f);\n    float32x4_t two = vdupq_n_f32(2.0f);\n    float32x4_t zero = vdupq_n_f32(0.0f);\n\n    for (size_t i = 0; i < length; i += 8) {\n        float32x4_t s1_1 = vld1q_f32(&src1[i]);\n        float32x4_t s2_1 = vld1q_f32(&src2[i]);\n        float32x4_t s1_2 = vld1q_f32(&src1[i + 4]);\n        float32x4_t s2_2 = vld1q_f32(&src2[i + 4]);\n\n        uint32x4_t idx_mask_1 = vcgeq_f32(vreinterpretq_f32_u32(vmovq_n_u32(i)), zero);\n        uint32x4_t idx_mask_2 = vcgeq_f32(vreinterpretq_f32_u32(vmovq_n_u32(i + 4)), zero);\n\n        float32x4_t diff_1 = vabsq_f32(vsubq_f32(s1_1, s2_1));\n        float32x4_t diff_2 = vabsq_f32(vsubq_f32(s1_2, s2_2));\n\n        uint32x4_t cond_1 = vandq_u32(vcgeq_f32(diff_1, threshold), idx_mask_1);\n        uint32x4_t cond_2 = vandq_u32(vcgeq_f32(diff_2, threshold), idx_mask_2);\n\n        float32x4_t mul_1 = vmulq_f32(s1_1, s2_1);\n        float32x4_t mul_2 = vmulq_f32(s1_2, s2_2);\n\n        float32x4_t rounded_1 = vaddq_f32(mul_1, vsubq_f32(vrecpeq_f32(mul_1), vrecpsq_f32(vrecpeq_f32(mul_1), mul_1)));\n        float32x4_t rounded_2 = vaddq_f32(mul_2, vsubq_f32(vrecpeq_f32(mul_2), vrecpsq_f32(vrecpeq_f32(mul_2), mul_2)));\n\n        float32x4_t result_1 = vbslq_f32(cond_1, rounded_1, minus_one);\n        float32x4_t result_2 = vbslq_f32(cond_2, rounded_2, minus_one);\n\n        vst1q_f32(&dst[i], result_1);\n        vst1q_f32(&dst[i + 4], result_2);\n    }\n}\n```"}
{"task_id": "SimdBench_21_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length){\n    float32x4_t threshold = vdupq_n_f32(50.0f);\n    float32x4_t minus_one = vdupq_n_f32(-1.0f);\n    float32x4_t two = vdupq_n_f32(2.0f);\n    float32x4_t zero = vdupq_n_f32(0.0f);\n\n    for (size_t i = 0; i < length; i += 8) {\n        float32x4_t s1_1 = vld1q_f32(&src1[i]);\n        float32x4_t s2_1 = vld1q_f32(&src2[i]);\n        float32x4_t s1_2 = vld1q_f32(&src1[i + 4]);\n        float32x4_t s2_2 = vld1q_f32(&src2[i + 4]);\n\n        uint32x4_t idx_mask_1 = vcgeq_f32(vreinterpretq_f32_u32(vmovq_n_u32(i)), zero);\n        uint32x4_t idx_mask_2 = vcgeq_f32(vreinterpretq_f32_u32(vmovq_n_u32(i + 4)), zero);\n\n        float32x4_t diff_1 = vabsq_f32(vsubq_f32(s1_1, s2_1));\n        float32x4_t diff_2 = vabsq_f32(vsubq_f32(s1_2, s2_2));\n\n        uint32x4_t cond_1 = vandq_u32(vcgeq_f32(diff_1, threshold), idx_mask_1);\n        uint32x4_t cond_2 = vandq_u32(vcgeq_f32(diff_2, threshold), idx_mask_2);\n\n        float32x4_t mul_1 = vmulq_f32(s1_1, s2_1);\n        float32x4_t mul_2 = vmulq_f32(s1_2, s2_2);\n\n        float32x4_t rounded_1 = vaddq_f32(mul_1, vsubq_f32(vrecpeq_f32(mul_1), vrecpsq_f32(vrecpeq_f32(mul_1), mul_1)));\n        float32x4_t rounded_2 = vaddq_f32(mul_2, vsubq_f32(vrecpeq_f32(mul_2), vrecpsq_f32(vrecpeq_f32(mul_2), mul_2)));\n\n        float32x4_t result_1 = vbslq_f32(cond_1, rounded_1, minus_one);\n        float32x4_t result_2 = vbslq_f32(cond_2, rounded_2, minus_one);\n\n        vst1q_f32(&dst[i], result_1);\n        vst1q_f32(&dst[i + 4], result_2);\n    }\n}\n```"}
{"task_id": "SimdBench_22_Neon", "completion": "```cpp\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    uint64_t num_elements = m * n;\n    uint64_t num_simd_elements = num_elements / 2; // Each NEON register holds 2 double elements\n\n    float64x2_t scalar_vec = vdupq_n_f64(scalar);\n\n    for (uint64_t i = 0; i < num_simd_elements; ++i) {\n        float64x2_t mat_vec = vld1q_f64(mat + 2 * i);\n        float64x2_t result_vec = vmulq_f64(mat_vec, scalar_vec);\n        vst1q_f64(dst + 2 * i, result_vec);\n    }\n\n    // Handle remaining elements\n    for (uint64_t i = 2 * num_simd_elements; i < num_elements; ++i) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    uint64_t num_elements = m * n;\n    uint64_t i = 0;\n\n    float64x2_t scalar_vec = vdupq_n_f64(scalar);\n\n    for (; i <= num_elements - 2; i += 2) {\n        float64x2_t mat_vec = vld1q_f64(&mat[i]);\n        float64x2_t result_vec = vmulq_f64(mat_vec, scalar_vec);\n        vst1q_f64(&dst[i], result_vec);\n    }\n\n    for (; i < num_elements; i++) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    uint64_t num_elements = m * n;\n    uint64_t i = 0;\n\n    float64x2_t scalar_vec = vdupq_n_f64(scalar);\n\n    for (; i <= num_elements - 2; i += 2) {\n        float64x2_t mat_vec = vld1q_f64(&mat[i]);\n        float64x2_t result_vec = vmulq_f64(mat_vec, scalar_vec);\n        vst1q_f64(&dst[i], result_vec);\n    }\n\n    for (; i < num_elements; i++) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    uint64_t num_elements = m * n;\n    uint64_t i = 0;\n\n    // Load scalar into a NEON register\n    float64x2_t scalar_vec = vdupq_n_f64(scalar);\n\n    // Process 2 elements at a time\n    for (; i <= num_elements - 2; i += 2) {\n        float64x2_t mat_vec = vld1q_f64(&mat[i]);\n        float64x2_t result_vec = vmulq_f64(mat_vec, scalar_vec);\n        vst1q_f64(&dst[i], result_vec);\n    }\n\n    // Handle any remaining elements\n    for (; i < num_elements; i++) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    uint64_t num_elements = m * n;\n    uint64_t i = 0;\n\n    float64x2_t scalar_vec = vdupq_n_f64(scalar);\n\n    for (; i <= num_elements - 2; i += 2) {\n        float64x2_t mat_vec = vld1q_f64(&mat[i]);\n        float64x2_t result_vec = vmulq_f64(mat_vec, scalar_vec);\n        vst1q_f64(&dst[i], result_vec);\n    }\n\n    for (; i < num_elements; i++) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_23_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float* row = mat + i * n;\n        float32x4_t sum = vdupq_n_f32(0.0f);\n\n        // Calculate the sum of squares\n        for (size_t j = 0; j <= n - 4; j += 4) {\n            float32x4_t vec = vld1q_f32(&row[j]);\n            sum = vfmaq_f32(sum, vec, vec);\n        }\n\n        // Handle remaining elements\n        float remaining_sum = 0.0f;\n        for (size_t j = (n & ~3); j < n; ++j) {\n            remaining_sum += row[j] * row[j];\n        }\n        sum = vaddq_f32(sum, vsetq_lane_f32(remaining_sum, vdupq_n_f32(0.0f), 0));\n\n        // Sum up all elements in sum vector\n        float32x2_t sum_pair = vpadd_f32(vget_low_f32(sum), vget_high_f32(sum));\n        float32x2_t sum_scalar = vpadd_f32(sum_pair, sum_pair);\n        float l2_norm = vget_lane_f32(sum_scalar, 0);\n        l2_norm = 1.0f / sqrtf(l2_norm);\n\n        // Normalize the row\n        for (size_t j = 0; j <= n - 4; j += 4) {\n            float32x4_t vec = vld1q_f32(&row[j]);\n            vec = vmulq_f32(vec, vdupq_n_f32(l2_norm));\n            vst1q_f32(&row[j], vec);\n        }\n\n        // Handle remaining elements\n        for (size_t j = (n & ~3); j < n; ++j) {\n            row[j] *= l2_norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float32x4_t sum = vdupq_n_f32(0.0f);\n        size_t j = 0;\n\n        // Process 4 elements at a time\n        for (; j <= n - 4; j += 4) {\n            float32x4_t vec = vld1q_f32(&mat[i * n + j]);\n            vec = vmulq_f32(vec, vec);\n            sum = vaddq_f32(sum, vec);\n        }\n\n        // Sum up the partial sums\n        float32x2_t sum2 = vadd_f32(vget_low_f32(sum), vget_high_f32(sum));\n        float32x2_t sum3 = vpadd_f32(sum2, sum2);\n        float l2_norm = vget_lane_f32(sum3, 0);\n\n        // Add remaining elements\n        for (; j < n; ++j) {\n            float val = mat[i * n + j];\n            l2_norm += val * val;\n        }\n\n        l2_norm = sqrtf(l2_norm);\n\n        // Normalize the row\n        j = 0;\n        for (; j <= n - 4; j += 4) {\n            float32x4_t vec = vld1q_f32(&mat[i * n + j]);\n            vec = vdivq_f32(vec, vdupq_n_f32(l2_norm));\n            vst1q_f32(&mat[i * n + j], vec);\n        }\n\n        // Handle remaining elements\n        for (; j < n; ++j) {\n            mat[i * n + j] /= l2_norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float* row = mat + i * n;\n        float32x4_t sum = vdupq_n_f32(0.0f);\n\n        // Calculate the sum of squares\n        for (size_t j = 0; j <= n - 4; j += 4) {\n            float32x4_t vec = vld1q_f32(&row[j]);\n            sum = vfmaq_f32(sum, vec, vec);\n        }\n\n        // Handle remaining elements\n        float remaining_sum = 0.0f;\n        for (size_t j = (n & ~3); j < n; ++j) {\n            remaining_sum += row[j] * row[j];\n        }\n        sum = vaddq_f32(sum, vsetq_lane_f32(remaining_sum, vdupq_n_f32(0.0f), 0));\n\n        // Sum up all the elements in sum vector\n        float32x2_t sum_low = vadd_f32(vget_low_f32(sum), vget_high_f32(sum));\n        float32x2_t sum_high = vext_f32(sum_low, sum_low, 1);\n        float32x2_t total_sum = vadd_f32(sum_low, sum_high);\n        float l2_norm = vget_lane_f32(total_sum, 0);\n        l2_norm = 1.0f / sqrtf(l2_norm);\n\n        // Normalize the row\n        for (size_t j = 0; j <= n - 4; j += 4) {\n            float32x4_t vec = vld1q_f32(&row[j]);\n            vec = vmulq_f32(vec, vdupq_n_f32(l2_norm));\n            vst1q_f32(&row[j], vec);\n        }\n\n        // Handle remaining elements\n        for (size_t j = (n & ~3); j < n; ++j) {\n            row[j] *= l2_norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float32x4_t sum = vdupq_n_f32(0.0f);\n        size_t j = 0;\n\n        // Process 4 elements at a time\n        for (; j <= n - 4; j += 4) {\n            float32x4_t vec = vld1q_f32(&mat[i * n + j]);\n            float32x4_t vec_squared = vmulq_f32(vec, vec);\n            sum = vaddq_f32(sum, vec_squared);\n        }\n\n        // Sum up the remaining elements\n        float32_t temp_sum[4];\n        vst1q_f32(temp_sum, sum);\n        float row_norm = temp_sum[0] + temp_sum[1] + temp_sum[2] + temp_sum[3];\n\n        for (; j < n; ++j) {\n            float val = mat[i * n + j];\n            row_norm += val * val;\n        }\n\n        row_norm = sqrtf(row_norm);\n\n        // Normalize the row\n        j = 0;\n        for (; j <= n - 4; j += 4) {\n            float32x4_t vec = vld1q_f32(&mat[i * n + j]);\n            float32x4_t normalized_vec = vdivq_f32(vec, vdupq_n_f32(row_norm));\n            vst1q_f32(&mat[i * n + j], normalized_vec);\n        }\n\n        for (; j < n; ++j) {\n            mat[i * n + j] /= row_norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float* row = mat + i * n;\n        float32x4_t sum = vdupq_n_f32(0.0f);\n\n        // Calculate the sum of squares\n        for (size_t j = 0; j <= n - 4; j += 4) {\n            float32x4_t vec = vld1q_f32(row + j);\n            sum = vfmaq_f32(sum, vec, vec);\n        }\n\n        // Handle remaining elements\n        float remaining_sum = 0.0f;\n        for (size_t j = (n & ~3); j < n; ++j) {\n            remaining_sum += row[j] * row[j];\n        }\n        sum = vaddq_f32(sum, vsetq_lane_f32(remaining_sum, vdupq_n_f32(0.0f), 0));\n\n        // Sum up all the elements in sum vector\n        float32x2_t sum_low = vadd_f32(vget_low_f32(sum), vget_high_f32(sum));\n        float32x2_t sum_high = vext_f32(sum_low, sum_low, 1);\n        float32x2_t total_sum = vadd_f32(sum_low, sum_high);\n        float l2_norm = vget_lane_f32(total_sum, 0);\n        l2_norm = 1.0f / sqrtf(l2_norm);\n\n        // Normalize the row\n        for (size_t j = 0; j <= n - 4; j += 4) {\n            float32x4_t vec = vld1q_f32(row + j);\n            vec = vmulq_f32(vec, vdupq_n_f32(l2_norm));\n            vst1q_f32(row + j, vec);\n        }\n\n        // Handle remaining elements\n        for (size_t j = (n & ~3); j < n; ++j) {\n            row[j] *= l2_norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; j += 2) {\n            float64x2_t sum = vdupq_n_f64(0.0);\n            for (size_t k = 0; k < n; k += 2) {\n                float64x2_t a = vld1q_f64(&mat1[i * n + k]);\n                float64x2_t b = vld1q_f64(&mat2[k * p + j]);\n                sum = vfmaq_f64(sum, a, b);\n            }\n            int64x2_t rounded_sum = vrndiq_s64(vcvtnq_f64_s64(sum));\n            vst1q_f64(&dst[i * p + j], vcvtq_f64_s64(rounded_sum));\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; j += 2) {\n            float64x2_t sum = vdupq_n_f64(0.0);\n            for (size_t k = 0; k < n; k += 2) {\n                float64x2_t a = vld1q_f64(&mat1[i * n + k]);\n                float64x2_t b = vld1q_f64(&mat2[k * p + j]);\n                sum = vfmaq_f64(sum, a, b);\n            }\n            int64x2_t rounded_sum = vrndiq_s64(vcvtnq_f64_s64(sum));\n            vst1q_f64(&dst[i * p + j], vcvtq_f64_s64(rounded_sum));\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; j += 2) {\n            float64x2_t sum = vdupq_n_f64(0.0);\n            for (size_t k = 0; k < n; k += 2) {\n                float64x2_t a = vld1q_f64(&mat1[i * n + k]);\n                float64x2_t b = vld1q_f64(&mat2[k * p + j]);\n                sum = vfmaq_f64(sum, a, b);\n            }\n            int64x2_t rounded_sum = vrndiq_s64(vcvtnq_f64_s64(sum));\n            vst1q_f64(&dst[i * p + j], vcvtq_f64_s64(rounded_sum));\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; j += 2) {\n            float64x2_t sum = vdupq_n_f64(0.0);\n            for (size_t k = 0; k < n; k += 2) {\n                float64x2_t a = vld1q_f64(&mat1[i * n + k]);\n                float64x2_t b = vld1q_f64(&mat2[k * p + j]);\n                sum = vfmaq_f64(sum, a, b);\n            }\n            int64x2_t rounded_sum = vrndiq_s64(vcvtnq_f64_s64(sum));\n            vst1q_f64(&dst[i * p + j], vcvtq_f64_s64(rounded_sum));\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; j += 2) {\n            float64x2_t sum = vdupq_n_f64(0.0);\n            for (size_t k = 0; k < n; k += 2) {\n                float64x2_t a = vld1q_f64(&mat1[i * n + k]);\n                float64x2_t b = vld1q_f64(&mat2[k * p + j]);\n                sum = vfmaq_f64(sum, a, b);\n            }\n            int64x2_t rounded_sum = vrndiq_s64(vcvtnq_f64_s64(sum));\n            vst1q_f64(&dst[i * p + j], vcvtq_f64_s64(rounded_sum));\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t c = 0; c < cols; c += 4) {\n        for (size_t r = 0; r < rows; r++) {\n            float32x4_t row = vld1q_f32(&src[r * cols + c]);\n            float32x4_t quarter = vdupq_n_f32(0.25f);\n            float32x4_t rounded = vrndnq_f32(vmulq_f32(row, vrecpeq_f32(quarter)));\n            float32x4_t result = vmulq_f32(rounded, quarter);\n            vst1q_f32(&dst[c * rows + r], result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    float32x4_t quarter = vdupq_n_f32(0.25f);\n    float32x4_t half = vdupq_n_f32(0.5f);\n\n    for (size_t c = 0; c < cols; c += 4) {\n        for (size_t r = 0; r < rows; r++) {\n            float32x4_t row = vld1q_f32(&src[r * cols + c]);\n            float32x4_t rounded = vrndnq_f32(vaddq_f32(row, half));\n            float32x4_t quarter_rounded = vmulq_f32(vrndnq_f32(vmulq_f32(rounded, quarter)), vrecpeq_f32(quarter));\n            vst1q_f32(&dst[c * rows + r], quarter_rounded);\n        }\n    }\n\n    // Handle remaining columns (if cols % 4 != 0)\n    for (size_t c = (cols / 4) * 4; c < cols; c++) {\n        for (size_t r = 0; r < rows; r++) {\n            float val = src[r * cols + c];\n            float rounded = roundf(val + 0.5f);\n            float quarter_rounded = roundf(rounded * 4.0f) / 4.0f;\n            dst[c * rows + r] = quarter_rounded;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i += 4) {\n        for (size_t j = 0; j < cols; j++) {\n            float32x4_t row0 = vld1q_f32(&src[i * cols + j]);\n            float32x4_t row1 = vld1q_f32(&src[(i + 1) * cols + j]);\n            float32x4_t row2 = vld1q_f32(&src[(i + 2) * cols + j]);\n            float32x4_t row3 = vld1q_f32(&src[(i + 3) * cols + j]);\n\n            float32x4x4_t transpose = vtrnq_f32(vtrnq_f32(row0, row1).val[0], vtrnq_f32(row2, row3).val[0]);\n            float32x4_t col0 = vcombine_f32(vget_low_f32(transpose.val[0]), vget_low_f32(transpose.val[2]));\n            float32x4_t col1 = vcombine_f32(vget_high_f32(transpose.val[0]), vget_high_f32(transpose.val[2]));\n            float32x4_t col2 = vcombine_f32(vget_low_f32(transpose.val[1]), vget_low_f32(transpose.val[3]));\n            float32x4_t col3 = vcombine_f32(vget_high_f32(transpose.val[1]), vget_high_f32(transpose.val[3]));\n\n            float32x4_t quarter = vdupq_n_f32(0.25f);\n            col0 = vrndnq_f32(vmulq_f32(col0, vrecpeq_f32(quarter)));\n            col1 = vrndnq_f32(vmulq_f32(col1, vrecpeq_f32(quarter)));\n            col2 = vrndnq_f32(vmulq_f32(col2, vrecpeq_f32(quarter)));\n            col3 = vrndnq_f32(vmulq_f32(col3, vrecpeq_f32(quarter)));\n\n            vst1q_f32(&dst[j * rows + i], col0);\n            vst1q_f32(&dst[j * rows + i + 1], col1);\n            vst1q_f32(&dst[j * rows + i + 2], col2);\n            vst1q_f32(&dst[j * rows + i + 3], col3);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t c = 0; c < cols; c += 4) {\n        for (size_t r = 0; r < rows; r++) {\n            float32x4_t row = vld1q_f32(&src[r * cols + c]);\n            float32x4_t quarter = vdupq_n_f32(0.25f);\n            float32x4_t rounded = vrndnq_f32(vmulq_f32(row, vrecpeq_f32(quarter)));\n            vst1q_f32(&dst[c * rows + r], rounded);\n        }\n    }\n\n    // Handle remaining columns (if cols % 4 != 0)\n    for (size_t c = (cols / 4) * 4; c < cols; c++) {\n        for (size_t r = 0; r < rows; r++) {\n            float value = src[r * cols + c];\n            float rounded_value = roundf(value * 4.0f) / 4.0f;\n            dst[c * rows + r] = rounded_value;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t c = 0; c < cols; c += 4) {\n        for (size_t r = 0; r < rows; r++) {\n            float32x4_t row = vld1q_f32(&src[r * cols + c]);\n            float32x4_t quarter = vdupq_n_f32(0.25f);\n            float32x4_t half = vdupq_n_f32(0.5f);\n            float32x4_t rounded = vrndnq_f32(vaddq_f32(row, vmulq_f32(vmodq_f32(row, quarter), half)));\n            vst1q_f32(&dst[c * rows + r], rounded);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26_Neon", "completion": "```c\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i <= total_elements - 4; i += 4) {\n        float32x4_t vec1 = vld1q_f32(&tensor1[i]);\n        float32x4_t vec2 = vld1q_f32(&tensor2[i]);\n        float32x4_t result = vsubq_f32(vec1, vec2);\n        int32x4_t rounded_result = vcvtq_s32_f32(result);\n        float32x4_t final_result = vcvtq_f32_s32(rounded_result);\n        vst1q_f32(&dst[i], final_result);\n    }\n\n    for (; i < total_elements; ++i) {\n        dst[i] = (float)((int)(tensor1[i] - tensor2[i]));\n    }\n}\n```"}
{"task_id": "SimdBench_26_Neon", "completion": "```cpp\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i <= total_elements - 4; i += 4) {\n        float32x4_t vec1 = vld1q_f32(&tensor1[i]);\n        float32x4_t vec2 = vld1q_f32(&tensor2[i]);\n        float32x4_t result = vsubq_f32(vec1, vec2);\n        int32x4_t rounded_result = vcvtq_s32_f32(result);\n        vst1q_f32(&dst[i], vcvtq_f32_s32(rounded_result));\n    }\n\n    for (; i < total_elements; ++i) {\n        dst[i] = (float)((int)tensor1[i] - (int)tensor2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_26_Neon", "completion": "```cpp\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i <= total_elements - 4; i += 4) {\n        float32x4_t vec1 = vld1q_f32(&tensor1[i]);\n        float32x4_t vec2 = vld1q_f32(&tensor2[i]);\n        float32x4_t result = vsubq_f32(vec1, vec2);\n        int32x4_t rounded_result = vcvtq_s32_f32(result);\n        vst1q_f32(&dst[i], vcvtq_f32_s32(rounded_result));\n    }\n\n    for (; i < total_elements; ++i) {\n        dst[i] = (float)((int)tensor1[i] - (int)tensor2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_26_Neon", "completion": "```cpp\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i <= total_elements - 4; i += 4) {\n        float32x4_t vec1 = vld1q_f32(&tensor1[i]);\n        float32x4_t vec2 = vld1q_f32(&tensor2[i]);\n        float32x4_t result = vsubq_f32(vec1, vec2);\n        int32x4_t rounded_result = vcvtq_s32_f32(result);\n        vst1q_f32(&dst[i], vcvtq_f32_s32(rounded_result));\n    }\n\n    for (; i < total_elements; ++i) {\n        dst[i] = static_cast<float>(static_cast<int>(tensor1[i] - tensor2[i]));\n    }\n}\n```"}
{"task_id": "SimdBench_26_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i <= total_elements - 4; i += 4) {\n        float32x4_t vec1 = vld1q_f32(&tensor1[i]);\n        float32x4_t vec2 = vld1q_f32(&tensor2[i]);\n        float32x4_t result = vsubq_f32(vec1, vec2);\n        int32x4_t rounded_result = vcvtq_s32_f32(result);\n        float32x4_t final_result = vcvtq_f32_s32(rounded_result);\n        vst1q_f32(&dst[i], final_result);\n    }\n\n    for (; i < total_elements; ++i) {\n        dst[i] = (float)((int)tensor1[i] - (int)tensor2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_27_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i = 0;\n\n    // Process 2 elements at a time (since each NEON register holds 2 doubles)\n    for (; i <= total_elements - 2; i += 2) {\n        float64x2_t vec1 = vld1q_f64(&mat1[i]);\n        float64x2_t vec2 = vld1q_f64(&mat2[i]);\n        float64x2_t result = vmulq_f64(vec1, vec2);\n        vst1q_f64(&dst[i], result);\n    }\n\n    // Handle any remaining elements\n    for (; i < total_elements; ++i) {\n        dst[i] = mat1[i] * mat2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_27_Neon", "completion": "```c\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i = 0;\n\n    for (; i <= total_elements - 2; i += 2) {\n        float64x2_t vec1 = vld1q_f64(&mat1[i]);\n        float64x2_t vec2 = vld1q_f64(&mat2[i]);\n        float64x2_t result = vmulq_f64(vec1, vec2);\n        vst1q_f64(&dst[i], result);\n    }\n\n    // Handle any remaining elements\n    for (; i < total_elements; ++i) {\n        dst[i] = mat1[i] * mat2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_27_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i = 0;\n\n    // Process 2 elements at a time (since each NEON register holds 2 doubles)\n    for (; i <= total_elements - 2; i += 2) {\n        float64x2_t vec1 = vld1q_f64(&mat1[i]);\n        float64x2_t vec2 = vld1q_f64(&mat2[i]);\n        float64x2_t result = vmulq_f64(vec1, vec2);\n        vst1q_f64(&dst[i], result);\n    }\n\n    // Handle any remaining elements\n    for (; i < total_elements; ++i) {\n        dst[i] = mat1[i] * mat2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_27_Neon", "completion": "```c\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i = 0;\n\n    for (; i <= total_elements - 2; i += 2) {\n        float64x2_t vec1 = vld1q_f64(&mat1[i]);\n        float64x2_t vec2 = vld1q_f64(&mat2[i]);\n        float64x2_t result = vmulq_f64(vec1, vec2);\n        vst1q_f64(&dst[i], result);\n    }\n\n    // Handle any remaining elements\n    for (; i < total_elements; ++i) {\n        dst[i] = mat1[i] * mat2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_27_Neon", "completion": "```c\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i = 0;\n\n    for (; i <= total_elements - 2; i += 2) {\n        float64x2_t vec1 = vld1q_f64(&mat1[i]);\n        float64x2_t vec2 = vld1q_f64(&mat2[i]);\n        float64x2_t result = vmulq_f64(vec1, vec2);\n        vst1q_f64(&dst[i], result);\n    }\n\n    // Handle any remaining elements\n    for (; i < total_elements; ++i) {\n        dst[i] = mat1[i] * mat2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_28_Neon", "completion": "```c\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float32x4_t sum = vdupq_n_f32(0.0f);\n        size_t j = 0;\n        for (; j <= n - 4; j += 4) {\n            float32x4_t mat_row = vld1q_f32(&mat[i * n + j]);\n            float32x4_t vec_col = vld1q_f32(&vec[j]);\n            sum = vfmaq_f32(sum, mat_row, vec_col);\n        }\n        float32_t sum_scalar[4];\n        vst1q_f32(sum_scalar, sum);\n        float result = sum_scalar[0] + sum_scalar[1] + sum_scalar[2] + sum_scalar[3];\n        for (; j < n; j++) {\n            result += mat[i * n + j] * vec[j];\n        }\n        dst[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_28_Neon", "completion": "```cpp\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float32x4_t sum = vdupq_n_f32(0.0f);\n        size_t j = 0;\n        for (; j <= n - 4; j += 4) {\n            float32x4_t mat_row = vld1q_f32(&mat[i * n + j]);\n            float32x4_t vec_col = vld1q_f32(&vec[j]);\n            sum = vfmaq_f32(sum, mat_row, vec_col);\n        }\n        float32_t sum_scalar[4];\n        vst1q_f32(sum_scalar, sum);\n        float result = sum_scalar[0] + sum_scalar[1] + sum_scalar[2] + sum_scalar[3];\n        for (; j < n; ++j) {\n            result += mat[i * n + j] * vec[j];\n        }\n        dst[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_28_Neon", "completion": "```cpp\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float32x4_t sum = vmovq_n_f32(0.0f);\n        size_t j = 0;\n        for (; j <= n - 4; j += 4) {\n            float32x4_t mat_row = vld1q_f32(&mat[i * n + j]);\n            float32x4_t vec_col = vld1q_f32(&vec[j]);\n            sum = vfmaq_f32(sum, mat_row, vec_col);\n        }\n        float32_t sum_scalar[4];\n        vst1q_f32(sum_scalar, sum);\n        float result = sum_scalar[0] + sum_scalar[1] + sum_scalar[2] + sum_scalar[3];\n        for (; j < n; ++j) {\n            result += mat[i * n + j] * vec[j];\n        }\n        dst[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_28_Neon", "completion": "```cpp\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float32x4_t sum = vmovq_n_f32(0.0f);\n        size_t j = 0;\n        for (; j <= n - 4; j += 4) {\n            float32x4_t mat_row = vld1q_f32(&mat[i * n + j]);\n            float32x4_t vec_col = vld1q_f32(&vec[j]);\n            sum = vfmaq_f32(sum, mat_row, vec_col);\n        }\n        float32_t sum_scalar[4];\n        vst1q_f32(sum_scalar, sum);\n        float result = sum_scalar[0] + sum_scalar[1] + sum_scalar[2] + sum_scalar[3];\n        for (; j < n; ++j) {\n            result += mat[i * n + j] * vec[j];\n        }\n        dst[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_28_Neon", "completion": "```c\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float32x4_t sum = vdupq_n_f32(0.0f);\n        size_t j = 0;\n        for (; j <= n - 4; j += 4) {\n            float32x4_t mat_row = vld1q_f32(&mat[i * n + j]);\n            float32x4_t vec_col = vld1q_f32(&vec[j]);\n            sum = vfmaq_f32(sum, mat_row, vec_col);\n        }\n        float32_t sum_scalar[4];\n        vst1q_f32(sum_scalar, sum);\n        float result = sum_scalar[0] + sum_scalar[1] + sum_scalar[2] + sum_scalar[3];\n        for (; j < n; ++j) {\n            result += mat[i * n + j] * vec[j];\n        }\n        dst[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_29_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    size_t total_elements = m * n;\n    size_t i = 0;\n\n    // Process 2 elements at a time\n    for (; i <= total_elements - 2; i += 2) {\n        float64x2_t vec = vld1q_f64(&mat[i]);\n        sum += vaddvq_f64(vec);\n    }\n\n    // Handle remaining elements\n    for (; i < total_elements; ++i) {\n        sum += mat[i];\n    }\n\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    size_t total_elements = m * n;\n    size_t i = 0;\n\n    // Process 4 elements at a time\n    for (; i <= total_elements - 4; i += 4) {\n        float64x2_t vec1 = vld1q_f64(mat + i);\n        float64x2_t vec2 = vld1q_f64(mat + i + 2);\n        float64x2_t sum_vec = vaddq_f64(vec1, vec2);\n        float64x2_t pairwise_sum = vpaddq_f64(sum_vec, sum_vec);\n        sum += vgetq_lane_f64(pairwise_sum, 0);\n    }\n\n    // Process remaining elements\n    for (; i < total_elements; ++i) {\n        sum += mat[i];\n    }\n\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    size_t total_elements = m * n;\n    size_t i = 0;\n\n    // Process 2 elements at a time using NEON\n    for (; i <= total_elements - 2; i += 2) {\n        float64x2_t vec = vld1q_f64(&mat[i]);\n        sum += vaddvq_f64(vec);\n    }\n\n    // Handle any remaining elements\n    for (; i < total_elements; ++i) {\n        sum += mat[i];\n    }\n\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_Neon", "completion": "```c\n#include <arm_neon.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    size_t total_elements = m * n;\n    size_t i = 0;\n\n    // Process 4 elements at a time\n    for (; i <= total_elements - 4; i += 4) {\n        float64x2_t vec1 = vld1q_f64(&mat[i]);\n        float64x2_t vec2 = vld1q_f64(&mat[i + 2]);\n        float64x2_t sum_vec = vaddq_f64(vec1, vec2);\n        sum += vgetq_lane_f64(sum_vec, 0) + vgetq_lane_f64(sum_vec, 1);\n    }\n\n    // Process remaining elements\n    for (; i < total_elements; ++i) {\n        sum += mat[i];\n    }\n\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    size_t total_elements = m * n;\n    size_t i = 0;\n\n    // Process 4 elements at a time\n    for (; i <= total_elements - 4; i += 4) {\n        float64x2_t vec1 = vld1q_f64(mat + i);\n        float64x2_t vec2 = vld1q_f64(mat + i + 2);\n        float64x2_t sum_vec = vaddq_f64(vec1, vec2);\n        sum += vgetq_lane_f64(sum_vec, 0) + vgetq_lane_f64(sum_vec, 1);\n    }\n\n    // Process remaining elements\n    for (; i < total_elements; ++i) {\n        sum += mat[i];\n    }\n\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_30_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        uint8x16_t mask = vdupq_n_u8(0xFF);\n        int32x4_t prev = vld1q_s32(row);\n        size_t j = 4;\n\n        if (directions[i]) {\n            // Ascending order\n            for (; j <= cols - 4; j += 4) {\n                int32x4_t curr = vld1q_s32(row + j);\n                uint32x4_t cmp = vcgtq_s32(prev, curr);\n                mask = vandq_u8(mask, vmovn_u16(vmovn_u32(cmp)));\n                prev = curr;\n            }\n        } else {\n            // Descending order\n            for (; j <= cols - 4; j += 4) {\n                int32x4_t curr = vld1q_s32(row + j);\n                uint32x4_t cmp = vcltq_s32(prev, curr);\n                mask = vandq_u8(mask, vmovn_u16(vmovn_u32(cmp)));\n                prev = curr;\n            }\n        }\n\n        // Check remaining elements\n        for (; j < cols; ++j) {\n            if ((directions[i] && row[j - 1] > row[j]) || (!directions[i] && row[j - 1] < row[j])) {\n                return false;\n            }\n        }\n\n        // Check if all elements in mask are set\n        if (vminv_u8(mask) == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        uint8x16_t mask = vdupq_n_u8(0xFF);\n        int32x4_t prev = vld1q_s32(row);\n        size_t j = 4;\n\n        if (directions[i]) {\n            // Ascending order\n            for (; j <= cols - 4; j += 4) {\n                int32x4_t curr = vld1q_s32(row + j);\n                uint32x4_t cmp = vcgtq_s32(prev, curr);\n                mask = vandq_u8(mask, vreinterpretq_u8_u32(cmp));\n                prev = curr;\n            }\n        } else {\n            // Descending order\n            for (; j <= cols - 4; j += 4) {\n                int32x4_t curr = vld1q_s32(row + j);\n                uint32x4_t cmp = vcltq_s32(prev, curr);\n                mask = vandq_u8(mask, vreinterpretq_u8_u32(cmp));\n                prev = curr;\n            }\n        }\n\n        // Check remaining elements\n        for (; j < cols; ++j) {\n            if ((directions[i] && row[j - 1] > row[j]) || (!directions[i] && row[j - 1] < row[j])) {\n                return false;\n            }\n        }\n\n        // Check if all elements in mask are zero\n        if (vmaxvq_u8(mask) != 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        uint8x16_t mask = vdupq_n_u8(0xFF);\n        int32x4_t prev = vld1q_s32(row);\n        size_t j = 4;\n\n        if (directions[i]) {\n            // Ascending order\n            for (; j <= cols - 4; j += 4) {\n                int32x4_t curr = vld1q_s32(row + j);\n                uint32x4_t cmp = vcgtq_s32(prev, curr);\n                mask = vandq_u8(mask, vreinterpretq_u8_u32(cmp));\n                prev = curr;\n            }\n        } else {\n            // Descending order\n            for (; j <= cols - 4; j += 4) {\n                int32x4_t curr = vld1q_s32(row + j);\n                uint32x4_t cmp = vcltq_s32(prev, curr);\n                mask = vandq_u8(mask, vreinterpretq_u8_u32(cmp));\n                prev = curr;\n            }\n        }\n\n        // Check remaining elements\n        for (; j < cols; ++j) {\n            if ((directions[i] && row[j - 1] > row[j]) || (!directions[i] && row[j - 1] < row[j])) {\n                return false;\n            }\n        }\n\n        // Check if all elements in mask are zero (indicating sorted)\n        if (vmaxvq_u8(mask) != 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        uint8x16_t mask = vdupq_n_u8(0xFF);\n        int32x4_t prev = vld1q_s32(row);\n        size_t j = 4;\n\n        if (directions[i]) {\n            // Ascending order\n            for (; j <= cols - 4; j += 4) {\n                int32x4_t curr = vld1q_s32(row + j);\n                uint32x4_t cmp = vcgtq_s32(prev, curr);\n                mask = vandq_u8(mask, vmovn_u16(vmovn_u32(cmp)));\n                prev = curr;\n            }\n        } else {\n            // Descending order\n            for (; j <= cols - 4; j += 4) {\n                int32x4_t curr = vld1q_s32(row + j);\n                uint32x4_t cmp = vcltq_s32(prev, curr);\n                mask = vandq_u8(mask, vmovn_u16(vmovn_u32(cmp)));\n                prev = curr;\n            }\n        }\n\n        // Check remaining elements\n        for (; j < cols; ++j) {\n            if ((directions[i] && row[j - 1] > row[j]) || (!directions[i] && row[j - 1] < row[j])) {\n                return false;\n            }\n        }\n\n        // Check if all elements in mask are set\n        if (vminv_u8(mask) == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        uint8x16_t mask = vdupq_n_u8(0xFF);\n        int32x4_t prev = vld1q_s32(row);\n        size_t j = 4;\n\n        if (directions[i]) {\n            // Ascending order\n            for (; j <= cols - 4; j += 4) {\n                int32x4_t curr = vld1q_s32(row + j);\n                uint32x4_t cmp = vcgtq_s32(prev, curr);\n                mask = vandq_u8(mask, vreinterpretq_u8_u32(cmp));\n                prev = curr;\n            }\n        } else {\n            // Descending order\n            for (; j <= cols - 4; j += 4) {\n                int32x4_t curr = vld1q_s32(row + j);\n                uint32x4_t cmp = vcltq_s32(prev, curr);\n                mask = vandq_u8(mask, vreinterpretq_u8_u32(cmp));\n                prev = curr;\n            }\n        }\n\n        // Check remaining elements\n        for (; j < cols; ++j) {\n            if ((directions[i] && row[j - 1] > row[j]) || (!directions[i] && row[j - 1] < row[j])) {\n                return false;\n            }\n        }\n\n        // Check if all elements in mask are zero\n        if (vmaxvq_u8(mask) != 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_31_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    int16x8_t vbase = vdupq_n_s16(base);\n    size_t i = 0;\n\n    for (; i <= length - 8; i += 8) {\n        int16x8_t vsrc = vld1q_s16(&src[i]);\n        int16x8_t vdiv = vshrq_n_s16(vsrc, 15); // Sign extend division result\n        int16x8_t vmul = vmulq_s16(vdiv, vbase);\n        int16x8_t vcmp = vcgtq_s16(vmul, vsrc);\n        int16x8_t vsub = vsubq_s16(vmul, vbase);\n        int16x8_t vres = vbslq_s16(vcmp, vsub, vmul);\n        vst1q_s16(&dst[i], vres);\n    }\n\n    for (; i < length; i++) {\n        int16_t val = src[i];\n        int16_t div = val / base;\n        int16_t mul = div * base;\n        if (mul > val) {\n            mul -= base;\n        }\n        dst[i] = mul;\n    }\n}\n```"}
{"task_id": "SimdBench_31_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    int16x8_t vbase = vdupq_n_s16(base);\n    size_t i = 0;\n\n    for (; i <= length - 8; i += 8) {\n        int16x8_t vsrc = vld1q_s16(&src[i]);\n        int16x8_t vdiv = vshrq_n_s16(vsrc, 15); // Sign extend division result\n        int16x8_t vmul = vmulq_s16(vdiv, vbase);\n        int16x8_t vcmp = vcgtq_s16(vmul, vsrc);\n        int16x8_t vsub = vsubq_s16(vmul, vbase);\n        int16x8_t vres = vbslq_s16(vcmp, vsub, vmul);\n        vst1q_s16(&dst[i], vres);\n    }\n\n    for (; i < length; i++) {\n        int16_t val = src[i];\n        int16_t div = val / base;\n        int16_t mul = div * base;\n        if (mul > val) {\n            mul -= base;\n        }\n        dst[i] = mul;\n    }\n}\n```"}
{"task_id": "SimdBench_31_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    int16x8_t vbase = vdupq_n_s16(base);\n    size_t i;\n    for (i = 0; i <= length - 8; i += 8) {\n        int16x8_t vsrc = vld1q_s16(&src[i]);\n        int16x8_t vdiv = vshrq_n_s16(vsrc, 15); // Sign extend division result\n        int16x8_t vmul = vmulq_s16(vdiv, vbase);\n        int16x8_t vcmp = vcgtq_s16(vmul, vsrc);\n        int16x8_t vsub = vsubq_s16(vmul, vbase);\n        int16x8_t vres = vbslq_s16(vcmp, vsub, vmul);\n        vst1q_s16(&dst[i], vres);\n    }\n    for (; i < length; i++) {\n        int16_t val = src[i];\n        int16_t div = val / base;\n        int16_t mul = div * base;\n        if (mul > val) {\n            mul -= base;\n        }\n        dst[i] = mul;\n    }\n}\n```"}
{"task_id": "SimdBench_31_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    int16x8_t vbase = vdupq_n_s16(base);\n    size_t i = 0;\n    for (; i <= length - 8; i += 8) {\n        int16x8_t vsrc = vld1q_s16(&src[i]);\n        int16x8_t vdiv = vshrq_n_s16(vsrc, 15); // Sign extend division result\n        int16x8_t vmul = vmulq_s16(vdiv, vbase);\n        int16x8_t vcmp = vcgtq_s16(vmul, vsrc);\n        int16x8_t vsub = vsubq_s16(vmul, vbase);\n        int16x8_t vres = vbslq_s16(vcmp, vsub, vmul);\n        vst1q_s16(&dst[i], vres);\n    }\n    for (; i < length; i++) {\n        int16_t val = src[i];\n        int16_t div = val / base;\n        int16_t mul = div * base;\n        if (mul > val) {\n            mul -= base;\n        }\n        dst[i] = mul;\n    }\n}\n```"}
{"task_id": "SimdBench_31_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    int16x8_t vbase = vdupq_n_s16(base);\n    size_t i = 0;\n    for (; i <= length - 8; i += 8) {\n        int16x8_t vsrc = vld1q_s16(&src[i]);\n        int16x8_t vdiv = vshrq_n_s16(vsrc, 15); // Sign extend division result\n        int16x8_t vmul = vmulq_s16(vdiv, vbase);\n        int16x8_t vcmp = vcgtq_s16(vmul, vsrc);\n        int16x8_t vsub = vsubq_s16(vmul, vbase);\n        int16x8_t vres = vbslq_s16(vcmp, vsub, vmul);\n        vst1q_s16(&dst[i], vres);\n    }\n    for (; i < length; ++i) {\n        int16_t val = src[i];\n        int16_t div = val / base;\n        int16_t mul = div * base;\n        if (mul > val) {\n            mul -= base;\n        }\n        dst[i] = mul;\n    }\n}\n```"}
{"task_id": "SimdBench_32_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const double* matrix_row = matrix + i * cols;\n        size_t j = 0;\n        for (; j <= cols - 2; j += 2) {\n            float64x2_t row_vec = vld1q_f64(matrix_row + j);\n            float64x2_t vec_vec = vld1q_f64(vector + j);\n            uint64x2_t cmp_result = vceqq_f64(row_vec, vec_vec);\n            if (vgetq_lane_u64(cmp_result, 0) && vgetq_lane_u64(cmp_result, 1)) {\n                continue;\n            } else {\n                break;\n            }\n        }\n        if (j == cols) {\n            return true;\n        }\n        // Check remaining elements if cols is odd\n        for (; j < cols; ++j) {\n            if (matrix_row[j] != vector[j]) {\n                break;\n            }\n        }\n        if (j == cols) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const double* matrix_row = matrix + i * cols;\n        size_t j = 0;\n        for (; j <= cols - 2; j += 2) {\n            float64x2_t row_vec = vld1q_f64(matrix_row + j);\n            float64x2_t vec_vec = vld1q_f64(vector + j);\n            uint64x2_t cmp_result = vceqq_f64(row_vec, vec_vec);\n            if (vgetq_lane_u64(cmp_result, 0) && vgetq_lane_u64(cmp_result, 1)) {\n                continue;\n            } else {\n                break;\n            }\n        }\n        if (j == cols) {\n            return true;\n        }\n        // Check remaining elements if cols is odd\n        for (; j < cols; ++j) {\n            if (matrix_row[j] != vector[j]) {\n                break;\n            }\n        }\n        if (j == cols) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const double* matrix_row = matrix + i * cols;\n        size_t j = 0;\n        for (; j <= cols - 2; j += 2) {\n            float64x2_t row_vec = vld1q_f64(matrix_row + j);\n            float64x2_t vec_vec = vld1q_f64(vector + j);\n            uint64x2_t eq_vec = vceqq_f64(row_vec, vec_vec);\n            if (vgetq_lane_u64(eq_vec, 0) && vgetq_lane_u64(eq_vec, 1)) {\n                continue;\n            } else {\n                break;\n            }\n        }\n        if (j == cols) {\n            return true;\n        }\n        // Check remaining elements if cols is odd\n        for (; j < cols; ++j) {\n            if (matrix_row[j] != vector[j]) {\n                break;\n            }\n        }\n        if (j == cols) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const double* matrix_row = matrix + i * cols;\n        size_t j = 0;\n        for (; j <= cols - 2; j += 2) {\n            float64x2_t row_vec = vld1q_f64(matrix_row + j);\n            float64x2_t vec_vec = vld1q_f64(vector + j);\n            uint64x2_t cmp_result = vceqq_f64(row_vec, vec_vec);\n            if (vgetq_lane_u64(cmp_result, 0) && vgetq_lane_u64(cmp_result, 1)) {\n                continue;\n            } else {\n                break;\n            }\n        }\n        if (j == cols) {\n            return true;\n        }\n        // Check remaining elements if cols is odd\n        for (; j < cols; ++j) {\n            if (matrix_row[j] != vector[j]) {\n                break;\n            }\n        }\n        if (j == cols) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const double* matrix_row = matrix + i * cols;\n        size_t j = 0;\n        for (; j <= cols - 2; j += 2) {\n            float64x2_t row_vec = vld1q_f64(matrix_row + j);\n            float64x2_t vec = vld1q_f64(vector + j);\n            uint64x2_t eq = vceqq_f64(row_vec, vec);\n            if (vgetq_lane_u64(eq, 0) && vgetq_lane_u64(eq, 1)) {\n                continue;\n            } else {\n                break;\n            }\n        }\n        if (j == cols) {\n            return true;\n        }\n        // Check remaining elements if cols is odd\n        for (; j < cols; ++j) {\n            if (matrix_row[j] != vector[j]) {\n                break;\n            }\n        }\n        if (j == cols) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_33_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    size_t i = 0;\n\n    for (; i <= total_elements - 16; i += 16) {\n        uint8x16_t vecA = vld1q_u8(A + i);\n        uint8x16_t vecB = vld1q_u8(B + i);\n        uint8x16_t eq = vceqq_u8(vecA, vecB);\n        uint16x8_t eq8 = vcntq_u8(eq);\n        uint16x4_t eq4 = vpadd_u16(vget_low_u16(eq8), vget_high_u16(eq8));\n        uint16_t eq2 = vget_lane_u16(vpadd_u16(eq4, eq4), 0);\n        count += eq2;\n    }\n\n    for (; i < total_elements; ++i) {\n        count += (A[i] == B[i]);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    size_t i = 0;\n\n    for (; i <= total_elements - 16; i += 16) {\n        uint8x16_t vecA = vld1q_u8(A + i);\n        uint8x16_t vecB = vld1q_u8(B + i);\n        uint8x16_t eq = vceqq_u8(vecA, vecB);\n        uint16x8_t eq8 = vcntq_u8(eq);\n        uint16x4_t eq4 = vpadd_u16(vget_low_u16(eq8), vget_high_u16(eq8));\n        uint16_t eq2 = vget_lane_u16(vpadd_u16(eq4, eq4), 0);\n        count += eq2;\n    }\n\n    for (; i < total_elements; ++i) {\n        count += (A[i] == B[i]);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    size_t i = 0;\n\n    for (; i <= total_elements - 16; i += 16) {\n        uint8x16_t vecA = vld1q_u8(A + i);\n        uint8x16_t vecB = vld1q_u8(B + i);\n        uint8x16_t eq = vceqq_u8(vecA, vecB);\n        uint16x8_t eq8 = vcntq_u8(eq);\n        uint16x4_t eq4 = vpadd_u16(vget_low_u16(eq8), vget_high_u16(eq8));\n        uint16x2_t eq2 = vpadd_u16(vget_low_u16(eq4), vget_high_u16(eq4));\n        count += vget_lane_u16(eq2, 0) + vget_lane_u16(eq2, 1);\n    }\n\n    for (; i < total_elements; ++i) {\n        count += (A[i] == B[i]);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    size_t i = 0;\n\n    for (; i <= total_elements - 16; i += 16) {\n        uint8x16_t vecA = vld1q_u8(A + i);\n        uint8x16_t vecB = vld1q_u8(B + i);\n        uint8x16_t eq = vceqq_u8(vecA, vecB);\n        uint16x8_t eq8 = vcntq_u8(eq);\n        uint16x4_t eq4 = vpadd_u16(vget_low_u16(eq8), vget_high_u16(eq8));\n        uint16_t eq2 = vaddv_u16(eq4);\n        count += eq2;\n    }\n\n    for (; i < total_elements; ++i) {\n        count += (A[i] == B[i]);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    size_t i = 0;\n\n    for (; i <= total_elements - 16; i += 16) {\n        uint8x16_t vecA = vld1q_u8(A + i);\n        uint8x16_t vecB = vld1q_u8(B + i);\n        uint8x16_t eq = vceqq_u8(vecA, vecB);\n        uint16x8_t eq8 = vcntq_u8(eq);\n        uint16x4_t eq4 = vpadd_u16(vget_low_u16(eq8), vget_high_u16(eq8));\n        uint16_t eq2 = vpadd_u16(eq4, eq4)[0];\n        count += eq2;\n    }\n\n    for (; i < total_elements; ++i) {\n        count += (A[i] == B[i]);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_34_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    int64x2_t vec_a = vdupq_n_s64(a);\n\n    for (; i <= length - 2; i += 2) {\n        int64x2_t vec_x = vld1q_s64(&x[i]);\n        int64x2_t vec_y = vld1q_s64(&y[i]);\n        int64x2_t vec_mul = vmulq_s64(vec_a, vec_x);\n        int64x2_t vec_abs = vabsq_s64(vec_y);\n        int64x2_t vec_res = vsubq_s64(vec_abs, vec_mul);\n        vst1q_s64(&y[i], vec_res);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        y[i] = llabs(y[i]) - a * x[i];\n    }\n}\n```"}
{"task_id": "SimdBench_34_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    int64x2_t vec_a = vdupq_n_s64(a);\n\n    for (; i <= length - 2; i += 2) {\n        int64x2_t vec_x = vld1q_s64(&x[i]);\n        int64x2_t vec_y = vld1q_s64(&y[i]);\n        int64x2_t vec_mul = vmulq_s64(vec_a, vec_x);\n        int64x2_t vec_abs = vabsq_s64(vec_y);\n        int64x2_t vec_res = vsubq_s64(vec_abs, vec_mul);\n        vst1q_s64(&y[i], vec_res);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        y[i] = llabs(y[i]) - a * x[i];\n    }\n}\n```"}
{"task_id": "SimdBench_34_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    int64x2_t vec_a = vdupq_n_s64(a);\n\n    for (; i <= length - 2; i += 2) {\n        int64x2_t vec_x = vld1q_s64(&x[i]);\n        int64x2_t vec_y = vld1q_s64(&y[i]);\n        int64x2_t vec_mul = vmulq_s64(vec_a, vec_x);\n        int64x2_t vec_abs = vabsq_s64(vec_y);\n        int64x2_t vec_sub = vsubq_s64(vec_abs, vec_mul);\n        vst1q_s64(&y[i], vec_sub);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        y[i] = llabs(y[i]) - a * x[i];\n    }\n}\n```"}
{"task_id": "SimdBench_34_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    int64x2_t vec_a = vdupq_n_s64(a);\n\n    for (; i <= length - 2; i += 2) {\n        int64x2_t vec_x = vld1q_s64(&x[i]);\n        int64x2_t vec_y = vld1q_s64(&y[i]);\n        int64x2_t vec_mul = vmulq_s64(vec_a, vec_x);\n        int64x2_t vec_abs = vabsq_s64(vec_y);\n        int64x2_t vec_res = vsubq_s64(vec_abs, vec_mul);\n        vst1q_s64(&y[i], vec_res);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        y[i] = llabs(y[i]) - a * x[i];\n    }\n}\n```"}
{"task_id": "SimdBench_34_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    int64x2_t vec_a = vdupq_n_s64(a);\n\n    for (; i <= length - 2; i += 2) {\n        int64x2_t vec_x = vld1q_s64(&x[i]);\n        int64x2_t vec_y = vld1q_s64(&y[i]);\n        int64x2_t vec_mul = vmulq_s64(vec_a, vec_x);\n        int64x2_t vec_abs = vabsq_s64(vec_y);\n        int64x2_t vec_sub = vsubq_s64(vec_abs, vec_mul);\n        vst1q_s64(&y[i], vec_sub);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        y[i] = llabs(y[i]) - a * x[i];\n    }\n}\n```"}
{"task_id": "SimdBench_35_Neon", "completion": "```c\n#include <arm_neon.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    int16x8_t min_val = vdupq_n_s16(INT16_MAX);\n    int16x8_t max_val = vdupq_n_s16(INT16_MIN);\n\n    size_t i = 0;\n    for (; i <= length - 8; i += 8) {\n        int16x8_t current = vld1q_s16(&vec[i]);\n        min_val = vminq_s16(min_val, current);\n        max_val = vmaxq_s16(max_val, current);\n    }\n\n    int16x4_t min_val_low = vmin_s16(vget_low_s16(min_val), vget_high_s16(min_val));\n    int16x4_t max_val_low = vmax_s16(vget_low_s16(max_val), vget_high_s16(max_val));\n\n    int16x2_t min_val_pair = vmin_s16(vget_low_s16(min_val_low), vrev64_s16(vget_low_s16(min_val_low)));\n    int16x2_t max_val_pair = vmax_s16(vget_low_s16(max_val_low), vrev64_s16(vget_low_s16(max_val_low)));\n\n    int16x2_t min_val_final = vmin_s16(min_val_pair, vrev16_s16(min_val_pair));\n    int16x2_t max_val_final = vmax_s16(max_val_pair, vrev16_s16(max_val_pair));\n\n    int16_t min_result = vget_lane_s16(min_val_final, 0);\n    int16_t max_result = vget_lane_s16(max_val_final, 0);\n\n    for (; i < length; ++i) {\n        if (vec[i] < min_result) min_result = vec[i];\n        if (vec[i] > max_result) max_result = vec[i];\n    }\n\n    return (MinMaxPair){min_result, max_result};\n}\n```"}
{"task_id": "SimdBench_35_Neon", "completion": "```c\n#include <arm_neon.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    int16x8_t min_val = vdupq_n_s16(INT16_MAX);\n    int16x8_t max_val = vdupq_n_s16(INT16_MIN);\n\n    size_t i = 0;\n    for (; i <= length - 8; i += 8) {\n        int16x8_t current = vld1q_s16(&vec[i]);\n        min_val = vminq_s16(min_val, current);\n        max_val = vmaxq_s16(max_val, current);\n    }\n\n    int16x4_t min_val_low = vget_low_s16(min_val);\n    int16x4_t min_val_high = vget_high_s16(min_val);\n    int16x4_t max_val_low = vget_low_s16(max_val);\n    int16x4_t max_val_high = vget_high_s16(max_val);\n\n    min_val_low = vpmin_s16(min_val_low, min_val_high);\n    max_val_low = vpmax_s16(max_val_low, max_val_high);\n\n    min_val_low = vpmin_s16(min_val_low, min_val_low);\n    max_val_low = vpmax_s16(max_val_low, max_val_low);\n\n    min_val_low = vpmin_s16(min_val_low, min_val_low);\n    max_val_low = vpmax_s16(max_val_low, max_val_low);\n\n    int16_t min_result = vget_lane_s16(min_val_low, 0);\n    int16_t max_result = vget_lane_s16(max_val_low, 0);\n\n    for (; i < length; ++i) {\n        if (vec[i] < min_result) min_result = vec[i];\n        if (vec[i] > max_result) max_result = vec[i];\n    }\n\n    return (MinMaxPair){min_result, max_result};\n}\n```"}
{"task_id": "SimdBench_35_Neon", "completion": "```c\n#include <arm_neon.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    int16x8_t min_val = vdupq_n_s16(INT16_MAX);\n    int16x8_t max_val = vdupq_n_s16(INT16_MIN);\n\n    size_t i = 0;\n    for (; i <= length - 8; i += 8) {\n        int16x8_t current = vld1q_s16(&vec[i]);\n        min_val = vminq_s16(min_val, current);\n        max_val = vmaxq_s16(max_val, current);\n    }\n\n    int16x4_t min_val_low = vmin_s16(vget_low_s16(min_val), vget_high_s16(min_val));\n    int16x4_t max_val_low = vmax_s16(vget_low_s16(max_val), vget_high_s16(max_val));\n\n    int16x2_t min_val_pair = vmin_s16(vget_low_s16(min_val_low), vrev64_s16(vget_low_s16(min_val_low)));\n    int16x2_t max_val_pair = vmax_s16(vget_low_s16(max_val_low), vrev64_s16(vget_low_s16(max_val_low)));\n\n    int16x2_t min_val_final = vmin_s16(min_val_pair, vrev16_s16(min_val_pair));\n    int16x2_t max_val_final = vmax_s16(max_val_pair, vrev16_s16(max_val_pair));\n\n    int16_t min_result = vget_lane_s16(min_val_final, 0);\n    int16_t max_result = vget_lane_s16(max_val_final, 0);\n\n    for (; i < length; ++i) {\n        if (vec[i] < min_result) min_result = vec[i];\n        if (vec[i] > max_result) max_result = vec[i];\n    }\n\n    return (MinMaxPair){min_result, max_result};\n}\n```"}
{"task_id": "SimdBench_35_Neon", "completion": "```c\n#include <arm_neon.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    int16x8_t v_min = vdupq_n_s16(INT16_MAX);\n    int16x8_t v_max = vdupq_n_s16(INT16_MIN);\n\n    size_t i = 0;\n    for (; i <= length - 8; i += 8) {\n        int16x8_t v = vld1q_s16(&vec[i]);\n        v_min = vminq_s16(v_min, v);\n        v_max = vmaxq_s16(v_max, v);\n    }\n\n    int16x4_t v_min_low = vget_low_s16(v_min);\n    int16x4_t v_min_high = vget_high_s16(v_min);\n    int16x4_t v_max_low = vget_low_s16(v_max);\n    int16x4_t v_max_high = vget_high_s16(v_max);\n\n    v_min_low = vmin_s16(v_min_low, v_min_high);\n    v_max_low = vmax_s16(v_max_low, v_max_high);\n\n    int16x2_t v_min_p = vpmin_s16(v_min_low, v_min_low);\n    int16x2_t v_max_p = vpmax_s16(v_max_low, v_max_low);\n\n    int16x2_t v_min_final = vpmin_s16(v_min_p, v_min_p);\n    int16x2_t v_max_final = vpmax_s16(v_max_p, v_max_p);\n\n    int16_t min_num = vget_lane_s16(v_min_final, 0);\n    int16_t max_num = vget_lane_s16(v_max_final, 0);\n\n    for (; i < length; ++i) {\n        if (vec[i] < min_num) min_num = vec[i];\n        if (vec[i] > max_num) max_num = vec[i];\n    }\n\n    return (MinMaxPair){min_num, max_num};\n}\n```"}
{"task_id": "SimdBench_35_Neon", "completion": "```c\n#include <arm_neon.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    int16x8_t min_val = vdupq_n_s16(INT16_MAX);\n    int16x8_t max_val = vdupq_n_s16(INT16_MIN);\n\n    size_t i = 0;\n    for (; i <= length - 8; i += 8) {\n        int16x8_t current = vld1q_s16(&vec[i]);\n        min_val = vminq_s16(min_val, current);\n        max_val = vmaxq_s16(max_val, current);\n    }\n\n    int16x4_t min_val_low = vmin_s16(vget_low_s16(min_val), vget_high_s16(min_val));\n    int16x4_t max_val_low = vmax_s16(vget_low_s16(max_val), vget_high_s16(max_val));\n\n    int16x2_t min_val_pair = vmin_s16(vget_low_s16(min_val_low), vrev64_s16(vget_low_s16(min_val_low)));\n    int16x2_t max_val_pair = vmax_s16(vget_low_s16(max_val_low), vrev64_s16(vget_low_s16(max_val_low)));\n\n    int16x2_t min_val_final = vmin_s16(min_val_pair, vrev16_s16(min_val_pair));\n    int16x2_t max_val_final = vmax_s16(max_val_pair, vrev16_s16(max_val_pair));\n\n    int16_t min_result = vget_lane_s16(min_val_final, 0);\n    int16_t max_result = vget_lane_s16(max_val_final, 0);\n\n    for (; i < length; ++i) {\n        if (vec[i] < min_result) min_result = vec[i];\n        if (vec[i] > max_result) max_result = vec[i];\n    }\n\n    return (MinMaxPair){min_result, max_result};\n}\n```"}
{"task_id": "SimdBench_36_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        size_t j = 0;\n\n        int32x4_t prev = vld1q_s32(row);\n        for (j = 4; j <= cols - 4; j += 4) {\n            int32x4_t curr = vld1q_s32(row + j);\n            uint32x4_t cmp = vcgtq_s32(curr, prev);\n            if (vmovmskq_u32(cmp) != 0xF) {\n                return false;\n            }\n            prev = curr;\n        }\n\n        for (; j < cols; ++j) {\n            if (row[j] <= row[j - 1]) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        size_t j = 0;\n\n        int32x4_t prev = vld1q_s32(row);\n        for (j = 4; j <= cols - 4; j += 4) {\n            int32x4_t curr = vld1q_s32(row + j);\n            uint32x4_t cmp = vcgtq_s32(curr, prev);\n            if (vmovmskq_u32(cmp) != 0xF) {\n                return false;\n            }\n            prev = curr;\n        }\n\n        for (; j < cols; ++j) {\n            if (row[j] <= row[j - 1]) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        size_t j = 0;\n\n        for (; j <= cols - 4; j += 4) {\n            int32x4_t current = vld1q_s32(row + j);\n            int32x4_t next = vld1q_s32(row + j + 1);\n            uint32x4_t cmp = vcgtq_s32(next, current);\n            if (vmovmskq_u32(cmp) != 0xF) {\n                return false;\n            }\n        }\n\n        for (; j < cols - 1; ++j) {\n            if (row[j] >= row[j + 1]) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        size_t j = 0;\n\n        int32x4_t prev = vld1q_s32(row);\n        for (j = 4; j <= cols - 4; j += 4) {\n            int32x4_t curr = vld1q_s32(row + j);\n            uint32x4_t cmp = vcgtq_s32(curr, prev);\n            if (vmovmskq_u32(cmp) != 0xF) {\n                return false;\n            }\n            prev = curr;\n        }\n\n        for (; j < cols; ++j) {\n            if (row[j] <= row[j - 1]) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        size_t j = 0;\n\n        int32x4_t prev = vld1q_s32(row);\n        for (j = 4; j <= cols - 4; j += 4) {\n            int32x4_t curr = vld1q_s32(row + j);\n            uint32x4_t cmp = vcgtq_s32(curr, prev);\n            if (vmovmskq_u32(cmp) != 0xF) {\n                return false;\n            }\n            prev = curr;\n        }\n\n        for (; j < cols; ++j) {\n            if (row[j] <= row[j - 1]) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n\n    int32x4_t first_block[4];\n    for (size_t i = 0; i < block_size; ++i) {\n        first_block[i] = vld1q_s32(matrix + i * cols);\n    }\n\n    for (size_t block_row = 0; block_row < num_blocks_row; ++block_row) {\n        for (size_t block_col = 0; block_col < num_blocks_col; ++block_col) {\n            if (block_row == 0 && block_col == 0) {\n                continue;\n            }\n\n            int32x4_t current_block[4];\n            for (size_t i = 0; i < block_size; ++i) {\n                current_block[i] = vld1q_s32(matrix + (block_row * block_size + i) * cols + block_col * block_size);\n            }\n\n            uint32x4_t cmp_result[4];\n            for (size_t i = 0; i < block_size; ++i) {\n                cmp_result[i] = vceqq_s32(first_block[i], current_block[i]);\n            }\n\n            uint32_t all_equal = 0xFFFFFFFF;\n            for (size_t i = 0; i < block_size; ++i) {\n                all_equal &= vgetq_lane_u32(cmp_result[i], 0) & vgetq_lane_u32(cmp_result[i], 1) &\n                             vgetq_lane_u32(cmp_result[i], 2) & vgetq_lane_u32(cmp_result[i], 3);\n            }\n\n            if (all_equal != 0xFFFFFFFF) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n\n    int32x4_t first_block[4];\n    for (size_t i = 0; i < block_size; ++i) {\n        first_block[i] = vld1q_s32(matrix + i * cols);\n    }\n\n    for (size_t block_row = 0; block_row < num_blocks_row; ++block_row) {\n        for (size_t block_col = 0; block_col < num_blocks_col; ++block_col) {\n            if (block_row == 0 && block_col == 0) {\n                continue;\n            }\n\n            int32x4_t current_block[4];\n            for (size_t i = 0; i < block_size; ++i) {\n                current_block[i] = vld1q_s32(matrix + (block_row * block_size + i) * cols + block_col * block_size);\n            }\n\n            uint32x4_t result[4];\n            for (size_t i = 0; i < block_size; ++i) {\n                result[i] = vceqq_s32(first_block[i], current_block[i]);\n            }\n\n            uint32_t all_equal = 0xFFFFFFFF;\n            for (size_t i = 0; i < block_size; ++i) {\n                all_equal &= vgetq_lane_u32(result[i], 0) & vgetq_lane_u32(result[i], 1) & vgetq_lane_u32(result[i], 2) & vgetq_lane_u32(result[i], 3);\n            }\n\n            if (all_equal != 0xFFFFFFFF) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n\n    int32x4_t first_block[4];\n    for (size_t i = 0; i < block_size; ++i) {\n        first_block[i] = vld1q_s32(matrix + i * cols);\n    }\n\n    for (size_t block_row = 0; block_row < num_blocks_row; ++block_row) {\n        for (size_t block_col = 0; block_col < num_blocks_col; ++block_col) {\n            if (block_row == 0 && block_col == 0) {\n                continue;\n            }\n\n            int32x4_t current_block[4];\n            for (size_t i = 0; i < block_size; ++i) {\n                current_block[i] = vld1q_s32(matrix + (block_row * block_size + i) * cols + block_col * block_size);\n            }\n\n            uint32x4_t result[4];\n            for (size_t i = 0; i < block_size; ++i) {\n                result[i] = vceqq_s32(first_block[i], current_block[i]);\n            }\n\n            uint32_t all_equal = 0xFFFFFFFF;\n            for (size_t i = 0; i < block_size; ++i) {\n                all_equal &= vgetq_lane_u32(result[i], 0) & vgetq_lane_u32(result[i], 1) & vgetq_lane_u32(result[i], 2) & vgetq_lane_u32(result[i], 3);\n            }\n\n            if (all_equal != 0xFFFFFFFF) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n\n    for (size_t block_row = 0; block_row < num_blocks_row; ++block_row) {\n        for (size_t block_col = 0; block_col < num_blocks_col; ++block_col) {\n            const int* block_start = matrix + (block_row * block_size * cols) + (block_col * block_size);\n            const int* first_block = matrix;\n\n            for (size_t i = 0; i < block_size; ++i) {\n                int32x4_t block_vec = vld1q_s32(block_start + i * cols);\n                int32x4_t first_block_vec = vld1q_s32(first_block + i * cols);\n\n                uint32x4_t cmp_result = vceqq_s32(block_vec, first_block_vec);\n                uint32_t all_equal = vmovn_u64(vand_u64(vreinterpret_u64_u32(vget_low_u32(cmp_result)), vreinterpret_u64_u32(vget_high_u32(cmp_result))));\n\n                if (all_equal != 0xFFFFFFFF) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n\n    int32x4_t first_block[4];\n    for (size_t i = 0; i < block_size; ++i) {\n        first_block[i] = vld1q_s32(matrix + i * cols);\n    }\n\n    for (size_t block_row = 0; block_row < num_blocks_row; ++block_row) {\n        for (size_t block_col = 0; block_col < num_blocks_col; ++block_col) {\n            if (block_row == 0 && block_col == 0) {\n                continue;\n            }\n\n            int32x4_t current_block[4];\n            for (size_t i = 0; i < block_size; ++i) {\n                current_block[i] = vld1q_s32(matrix + (block_row * block_size + i) * cols + block_col * block_size);\n            }\n\n            uint32x4_t cmp_result[4];\n            for (size_t i = 0; i < block_size; ++i) {\n                cmp_result[i] = vceqq_s32(first_block[i], current_block[i]);\n            }\n\n            uint32x4_t all_ones = vdupq_n_u32(0xFFFFFFFF);\n            for (size_t i = 0; i < block_size; ++i) {\n                if (!vgetq_lane_u32(vceqq_u32(cmp_result[i], all_ones), 0) ||\n                    !vgetq_lane_u32(vceqq_u32(cmp_result[i], all_ones), 1) ||\n                    !vgetq_lane_u32(vceqq_u32(cmp_result[i], all_ones), 2) ||\n                    !vgetq_lane_u32(vceqq_u32(cmp_result[i], all_ones), 3)) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (!vec || length < block_size || block_size == 0) {\n        return false;\n    }\n\n    uint64_t num_blocks = length / block_size;\n    if (num_blocks == 0) {\n        return false;\n    }\n\n    float64x2_t tolerance_vec = vdupq_n_f64(tolerance);\n    float64x2_t first_block = vld1q_f64(vec);\n\n    for (uint64_t i = 1; i < num_blocks; ++i) {\n        const double* current_block = vec + i * block_size;\n        float64x2_t current_block_vec = vld1q_f64(current_block);\n\n        float64x2_t diff = vabsq_f64(vsubq_f64(current_block_vec, first_block));\n        uint32x2_t mask = vcleq_f64(diff, tolerance_vec);\n\n        if (vgetq_lane_u32(mask, 0) == 0 || vgetq_lane_u32(mask, 1) == 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (!vec || length < block_size || block_size == 0) {\n        return false;\n    }\n\n    uint64_t num_blocks = length / block_size;\n    if (num_blocks == 0) {\n        return false;\n    }\n\n    float64x2_t tolerance_vec = vdupq_n_f64(tolerance);\n    float64x2_t first_block = vld1q_f64(vec);\n\n    for (uint64_t i = 1; i < num_blocks; ++i) {\n        const double* current_block = vec + i * block_size;\n        float64x2_t current_block_vec = vld1q_f64(current_block);\n\n        float64x2_t diff = vabsq_f64(vsubq_f64(current_block_vec, first_block));\n        uint32x2_t mask = vcleq_f64(diff, tolerance_vec);\n\n        if (vgetq_lane_u32(mask, 0) == 0 || vgetq_lane_u32(mask, 1) == 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (!vec || length < block_size || block_size == 0) {\n        return false;\n    }\n\n    uint64_t num_blocks = length / block_size;\n    if (num_blocks == 0) {\n        return false;\n    }\n\n    float64x2_t tolerance_vec = vdupq_n_f64(tolerance);\n    float64x2_t first_block = vld1q_f64(vec);\n\n    for (uint64_t i = 1; i < num_blocks; ++i) {\n        const double* current_block = vec + i * block_size;\n        float64x2_t current_block_vec = vld1q_f64(current_block);\n\n        float64x2_t diff = vabsq_f64(vsubq_f64(current_block_vec, first_block));\n        uint32x2_t mask = vcleq_f64(diff, tolerance_vec);\n\n        if (vgetq_lane_u32(mask, 0) == 0 || vgetq_lane_u32(mask, 1) == 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (!vec || length < block_size || block_size == 0) {\n        return false;\n    }\n\n    uint64_t num_blocks = length / block_size;\n    if (num_blocks == 0) {\n        return false;\n    }\n\n    float64x2_t tolerance_vec = vdupq_n_f64(tolerance);\n    float64x2_t first_block = vld1q_f64(vec);\n\n    for (uint64_t i = 1; i < num_blocks; ++i) {\n        const double* current_block = vec + i * block_size;\n        float64x2_t current_block_vec = vld1q_f64(current_block);\n\n        float64x2_t diff = vabsq_f64(vsubq_f64(current_block_vec, first_block));\n        uint32x2_t mask = vcleq_f64(diff, tolerance_vec);\n\n        if (vgetq_lane_u32(mask, 0) == 0 || vgetq_lane_u32(mask, 1) == 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (!vec || length < block_size || block_size == 0) {\n        return false;\n    }\n\n    uint64_t num_blocks = length / block_size;\n    if (num_blocks == 0) {\n        return false;\n    }\n\n    float64x2_t tolerance_vec = vdupq_n_f64(tolerance);\n    float64x2_t first_block = vld1q_f64(vec);\n\n    for (uint64_t i = 1; i < num_blocks; ++i) {\n        const double* current_block = vec + i * block_size;\n        float64x2_t current_block_vec = vld1q_f64(current_block);\n\n        float64x2_t diff = vabsq_f64(vsubq_f64(current_block_vec, first_block));\n        uint32x2_t mask = vcleq_f64(diff, tolerance_vec);\n\n        if (vgetq_lane_u32(mask, 0) == 0 || vgetq_lane_u32(mask, 1) == 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_39_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        double sum = 0.0;\n        size_t j = 0;\n\n        // Process 2 elements at a time\n        for (; j <= cols - 2; j += 2) {\n            float64x2_t row_elements = vld1q_f64(&matrix[i * cols + j]);\n            row_elements = vmulq_f64(row_elements, row_elements);\n            sum += vaddvq_f64(row_elements);\n        }\n\n        // Handle remaining elements\n        for (; j < cols; ++j) {\n            double element = matrix[i * cols + j];\n            sum += element * element;\n        }\n\n        double norm = sqrt(sum);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        double sum = 0.0;\n        size_t j = 0;\n        for (; j <= cols - 2; j += 2) {\n            float64x2_t row = vld1q_f64(matrix + i * cols + j);\n            row = vmulq_f64(row, row);\n            sum += vaddvq_f64(row);\n        }\n        for (; j < cols; ++j) {\n            double val = matrix[i * cols + j];\n            sum += val * val;\n        }\n        double norm = sqrt(sum);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        double sum = 0.0;\n        size_t j = 0;\n\n        for (; j <= cols - 2; j += 2) {\n            float64x2_t row_vec = vld1q_f64(matrix + i * cols + j);\n            row_vec = vmulq_f64(row_vec, row_vec);\n            sum += vaddvq_f64(row_vec);\n        }\n\n        for (; j < cols; ++j) {\n            double val = matrix[i * cols + j];\n            sum += val * val;\n        }\n\n        double norm = sqrt(sum);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        double sum = 0.0;\n        size_t j = 0;\n\n        for (; j <= cols - 2; j += 2) {\n            float64x2_t row = vld1q_f64(matrix + i * cols + j);\n            row = vmulq_f64(row, row);\n            sum += vaddvq_f64(row);\n        }\n\n        for (; j < cols; ++j) {\n            double val = matrix[i * cols + j];\n            sum += val * val;\n        }\n\n        double norm = sqrt(sum);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        double sum = 0.0;\n        size_t j = 0;\n\n        // Process 2 elements at a time using NEON\n        for (; j <= cols - 2; j += 2) {\n            float64x2_t row_vec = vld1q_f64(&matrix[i * cols + j]);\n            row_vec = vmulq_f64(row_vec, row_vec);\n            sum += vaddvq_f64(row_vec);\n        }\n\n        // Handle remaining elements\n        for (; j < cols; ++j) {\n            double val = matrix[i * cols + j];\n            sum += val * val;\n        }\n\n        double norm = sqrt(sum);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_40_Neon", "completion": "```c\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        uint32x4_t vecA = vld1q_u32(&A[i]);\n        uint32x4_t vecB = vld1q_u32(&B[i]);\n        uint32x4_t vecResult = vorrq_u32(vecA, vecB);\n        vst1q_u32(&C[i], vecResult);\n    }\n    for (; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_Neon", "completion": "```cpp\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        uint32x4_t vecA = vld1q_u32(&A[i]);\n        uint32x4_t vecB = vld1q_u32(&B[i]);\n        uint32x4_t vecResult = vorrq_u32(vecA, vecB);\n        vst1q_u32(&C[i], vecResult);\n    }\n    for (; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_Neon", "completion": "```cpp\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        uint32x4_t vecA = vld1q_u32(&A[i]);\n        uint32x4_t vecB = vld1q_u32(&B[i]);\n        uint32x4_t vecResult = vorrq_u32(vecA, vecB);\n        vst1q_u32(&C[i], vecResult);\n    }\n    for (; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_Neon", "completion": "```c\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        uint32x4_t vecA = vld1q_u32(&A[i]);\n        uint32x4_t vecB = vld1q_u32(&B[i]);\n        uint32x4_t vecResult = vorrq_u32(vecA, vecB);\n        vst1q_u32(&C[i], vecResult);\n    }\n    for (; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_Neon", "completion": "```c\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        uint32x4_t vecA = vld1q_u32(&A[i]);\n        uint32x4_t vecB = vld1q_u32(&B[i]);\n        uint32x4_t vecResult = vorrq_u32(vecA, vecB);\n        vst1q_u32(&C[i], vecResult);\n    }\n    for (; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_41_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_of_squares = 0;\n    int64_t sum_of_products = 0;\n\n    size_t i = 0;\n    for (; i <= length - 16; i += 16) {\n        int8x16_t vecA = vld1q_s8(A + i);\n        int8x16_t vecB = vld1q_s8(B + i);\n\n        int16x8_t prod_low = vmull_s8(vget_low_s8(vecA), vget_low_s8(vecB));\n        int16x8_t prod_high = vmull_s8(vget_high_s8(vecA), vget_high_s8(vecB));\n\n        int16x8_t square_low_A = vmull_s8(vget_low_s8(vecA), vget_low_s8(vecA));\n        int16x8_t square_high_A = vmull_s8(vget_high_s8(vecA), vget_high_s8(vecA));\n\n        int16x8_t square_low_B = vmull_s8(vget_low_s8(vecB), vget_low_s8(vecB));\n        int16x8_t square_high_B = vmull_s8(vget_high_s8(vecB), vget_high_s8(vecB));\n\n        int32x4_t sum_prod_low = vpaddlq_s16(prod_low);\n        int32x4_t sum_prod_high = vpaddlq_s16(prod_high);\n\n        int32x4_t sum_square_low_A = vpaddlq_s16(square_low_A);\n        int32x4_t sum_square_high_A = vpaddlq_s16(square_high_A);\n\n        int32x4_t sum_square_low_B = vpaddlq_s16(square_low_B);\n        int32x4_t sum_square_high_B = vpaddlq_s16(square_high_B);\n\n        int64x2_t sum_prod = vpaddlq_s32(sum_prod_low);\n        int64x2_t sum_square_A = vpaddlq_s32(vaddq_s32(sum_square_low_A, sum_square_high_A));\n        int64x2_t sum_square_B = vpaddlq_s32(vaddq_s32(sum_square_low_B, sum_square_high_B));\n\n        sum_prod = vpadalq_s64(sum_prod, sum_prod_high);\n        sum_square_A = vpadalq_s64(sum_square_A, sum_square_high_A);\n        sum_square_B = vpadalq_s64(sum_square_B, sum_square_high_B);\n\n        sum_of_products += vgetq_lane_s64(sum_prod, 0) + vgetq_lane_s64(sum_prod, 1);\n        sum_of_squares += vgetq_lane_s64(sum_square_A, 0) + vgetq_lane_s64(sum_square_A, 1);\n        sum_of_squares += vgetq_lane_s64(sum_square_B, 0) + vgetq_lane_s64(sum_square_B, 1);\n    }\n\n    for (; i < length; ++i) {\n        int16_t a = A[i];\n        int16_t b = B[i];\n        sum_of_squares += a * a + b * b;\n        sum_of_products += a * b;\n    }\n\n    return sum_of_squares - sum_of_products;\n}\n```"}
{"task_id": "SimdBench_41_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_of_squares = 0;\n    int64_t sum_of_products = 0;\n\n    size_t i = 0;\n    for (; i <= length - 16; i += 16) {\n        int8x16_t vecA = vld1q_s8(A + i);\n        int8x16_t vecB = vld1q_s8(B + i);\n\n        int16x8_t prod_low = vmull_s8(vget_low_s8(vecA), vget_low_s8(vecB));\n        int16x8_t prod_high = vmull_s8(vget_high_s8(vecA), vget_high_s8(vecB));\n\n        int16x8_t square_low_A = vmull_s8(vget_low_s8(vecA), vget_low_s8(vecA));\n        int16x8_t square_high_A = vmull_s8(vget_high_s8(vecA), vget_high_s8(vecA));\n\n        int16x8_t square_low_B = vmull_s8(vget_low_s8(vecB), vget_low_s8(vecB));\n        int16x8_t square_high_B = vmull_s8(vget_high_s8(vecB), vget_high_s8(vecB));\n\n        int32x4_t sum_prod_low = vpaddlq_s16(prod_low);\n        int32x4_t sum_prod_high = vpaddlq_s16(prod_high);\n\n        int32x4_t sum_square_low_A = vpaddlq_s16(square_low_A);\n        int32x4_t sum_square_high_A = vpaddlq_s16(square_high_A);\n\n        int32x4_t sum_square_low_B = vpaddlq_s16(square_low_B);\n        int32x4_t sum_square_high_B = vpaddlq_s16(square_high_B);\n\n        int64x2_t sum_prod = vpaddlq_s32(sum_prod_low);\n        int64x2_t sum_square_A = vpaddlq_s32(vaddq_s32(sum_square_low_A, sum_square_high_A));\n        int64x2_t sum_square_B = vpaddlq_s32(vaddq_s32(sum_square_low_B, sum_square_high_B));\n\n        sum_prod = vpadalq_s64(sum_prod, sum_prod_high);\n        sum_square_A = vpadalq_s64(sum_square_A, sum_square_high_A);\n        sum_square_B = vpadalq_s64(sum_square_B, sum_square_high_B);\n\n        sum_of_products += vgetq_lane_s64(sum_prod, 0) + vgetq_lane_s64(sum_prod, 1);\n        sum_of_squares += vgetq_lane_s64(sum_square_A, 0) + vgetq_lane_s64(sum_square_A, 1) +\n                          vgetq_lane_s64(sum_square_B, 0) + vgetq_lane_s64(sum_square_B, 1);\n    }\n\n    for (; i < length; ++i) {\n        int32_t a = A[i];\n        int32_t b = B[i];\n        sum_of_squares += a * a + b * b;\n        sum_of_products += a * b;\n    }\n\n    return sum_of_squares - sum_of_products;\n}\n```"}
{"task_id": "SimdBench_41_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_of_squares = 0;\n    int64_t sum_of_products = 0;\n\n    size_t i = 0;\n    for (; i <= length - 16; i += 16) {\n        int8x16_t vecA = vld1q_s8(A + i);\n        int8x16_t vecB = vld1q_s8(B + i);\n\n        int16x8_t prod_low = vmull_s8(vget_low_s8(vecA), vget_low_s8(vecB));\n        int16x8_t prod_high = vmull_s8(vget_high_s8(vecA), vget_high_s8(vecB));\n\n        int16x8_t square_low_A = vmull_s8(vget_low_s8(vecA), vget_low_s8(vecA));\n        int16x8_t square_high_A = vmull_s8(vget_high_s8(vecA), vget_high_s8(vecA));\n\n        int16x8_t square_low_B = vmull_s8(vget_low_s8(vecB), vget_low_s8(vecB));\n        int16x8_t square_high_B = vmull_s8(vget_high_s8(vecB), vget_high_s8(vecB));\n\n        int32x4_t sum_prod_low = vpaddlq_s16(prod_low);\n        int32x4_t sum_prod_high = vpaddlq_s16(prod_high);\n\n        int32x4_t sum_square_low_A = vpaddlq_s16(square_low_A);\n        int32x4_t sum_square_high_A = vpaddlq_s16(square_high_A);\n\n        int32x4_t sum_square_low_B = vpaddlq_s16(square_low_B);\n        int32x4_t sum_square_high_B = vpaddlq_s16(square_high_B);\n\n        int64x2_t sum_prod = vpaddlq_s32(sum_prod_low);\n        int64x2_t sum_square_A = vpaddlq_s32(sum_square_low_A);\n        int64x2_t sum_square_B = vpaddlq_s32(sum_square_low_B);\n\n        sum_prod = vpadalq_s32(sum_prod, sum_prod_high);\n        sum_square_A = vpadalq_s32(sum_square_A, sum_square_high_A);\n        sum_square_B = vpadalq_s32(sum_square_B, sum_square_high_B);\n\n        sum_of_products += vgetq_lane_s64(sum_prod, 0) + vgetq_lane_s64(sum_prod, 1);\n        sum_of_squares += vgetq_lane_s64(sum_square_A, 0) + vgetq_lane_s64(sum_square_A, 1);\n        sum_of_squares += vgetq_lane_s64(sum_square_B, 0) + vgetq_lane_s64(sum_square_B, 1);\n    }\n\n    for (; i < length; ++i) {\n        int16_t a = A[i];\n        int16_t b = B[i];\n        sum_of_squares += a * a + b * b;\n        sum_of_products += a * b;\n    }\n\n    return sum_of_squares - sum_of_products;\n}\n```"}
{"task_id": "SimdBench_41_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_of_squares = 0;\n    int64_t sum_of_products = 0;\n\n    size_t i = 0;\n    for (; i <= length - 16; i += 16) {\n        int8x16_t vecA = vld1q_s8(A + i);\n        int8x16_t vecB = vld1q_s8(B + i);\n\n        int16x8_t prod_low = vmull_s8(vget_low_s8(vecA), vget_low_s8(vecB));\n        int16x8_t prod_high = vmull_s8(vget_high_s8(vecA), vget_high_s8(vecB));\n\n        int16x8_t square_low_A = vmull_s8(vget_low_s8(vecA), vget_low_s8(vecA));\n        int16x8_t square_high_A = vmull_s8(vget_high_s8(vecA), vget_high_s8(vecA));\n\n        int16x8_t square_low_B = vmull_s8(vget_low_s8(vecB), vget_low_s8(vecB));\n        int16x8_t square_high_B = vmull_s8(vget_high_s8(vecB), vget_high_s8(vecB));\n\n        int32x4_t sum_prod_low = vpaddlq_s16(prod_low);\n        int32x4_t sum_prod_high = vpaddlq_s16(prod_high);\n\n        int32x4_t sum_square_low_A = vpaddlq_s16(square_low_A);\n        int32x4_t sum_square_high_A = vpaddlq_s16(square_high_A);\n\n        int32x4_t sum_square_low_B = vpaddlq_s16(square_low_B);\n        int32x4_t sum_square_high_B = vpaddlq_s16(square_high_B);\n\n        int64x2_t sum_prod = vpaddlq_s32(sum_prod_low);\n        int64x2_t sum_square_A = vpaddlq_s32(vaddq_s32(sum_square_low_A, sum_square_high_A));\n        int64x2_t sum_square_B = vpaddlq_s32(vaddq_s32(sum_square_low_B, sum_square_high_B));\n\n        sum_prod = vpadalq_s64(sum_prod, sum_prod_high);\n        sum_square_A = vpadalq_s64(sum_square_A, sum_square_high_A);\n        sum_square_B = vpadalq_s64(sum_square_B, sum_square_high_B);\n\n        sum_of_products += vgetq_lane_s64(sum_prod, 0) + vgetq_lane_s64(sum_prod, 1);\n        sum_of_squares += vgetq_lane_s64(sum_square_A, 0) + vgetq_lane_s64(sum_square_A, 1) +\n                          vgetq_lane_s64(sum_square_B, 0) + vgetq_lane_s64(sum_square_B, 1);\n    }\n\n    for (; i < length; ++i) {\n        int16_t a = A[i];\n        int16_t b = B[i];\n        sum_of_squares += a * a + b * b;\n        sum_of_products += a * b;\n    }\n\n    return sum_of_squares - sum_of_products;\n}\n```"}
{"task_id": "SimdBench_41_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_of_squares = 0;\n    int64_t sum_of_products = 0;\n\n    size_t i = 0;\n    for (; i <= length - 16; i += 16) {\n        int8x16_t vecA = vld1q_s8(A + i);\n        int8x16_t vecB = vld1q_s8(B + i);\n\n        int16x8_t prod_low = vmull_s8(vget_low_s8(vecA), vget_low_s8(vecB));\n        int16x8_t prod_high = vmull_s8(vget_high_s8(vecA), vget_high_s8(vecB));\n\n        int16x8_t square_low_A = vmull_s8(vget_low_s8(vecA), vget_low_s8(vecA));\n        int16x8_t square_high_A = vmull_s8(vget_high_s8(vecA), vget_high_s8(vecA));\n\n        int16x8_t square_low_B = vmull_s8(vget_low_s8(vecB), vget_low_s8(vecB));\n        int16x8_t square_high_B = vmull_s8(vget_high_s8(vecB), vget_high_s8(vecB));\n\n        int32x4_t sum_prod_low = vpaddlq_s16(prod_low);\n        int32x4_t sum_prod_high = vpaddlq_s16(prod_high);\n\n        int32x4_t sum_square_low_A = vpaddlq_s16(square_low_A);\n        int32x4_t sum_square_high_A = vpaddlq_s16(square_high_A);\n\n        int32x4_t sum_square_low_B = vpaddlq_s16(square_low_B);\n        int32x4_t sum_square_high_B = vpaddlq_s16(square_high_B);\n\n        int64x2_t sum_prod = vpaddlq_s32(sum_prod_low);\n        int64x2_t sum_square_A = vpaddlq_s32(sum_square_low_A);\n        int64x2_t sum_square_B = vpaddlq_s32(sum_square_low_B);\n\n        sum_prod = vpadalq_s32(sum_prod, sum_prod_high);\n        sum_square_A = vpadalq_s32(sum_square_A, sum_square_high_A);\n        sum_square_B = vpadalq_s32(sum_square_B, sum_square_high_B);\n\n        sum_of_products += vgetq_lane_s64(sum_prod, 0) + vgetq_lane_s64(sum_prod, 1);\n        sum_of_squares += vgetq_lane_s64(sum_square_A, 0) + vgetq_lane_s64(sum_square_A, 1);\n        sum_of_squares += vgetq_lane_s64(sum_square_B, 0) + vgetq_lane_s64(sum_square_B, 1);\n    }\n\n    for (; i < length; ++i) {\n        int16_t a = A[i];\n        int16_t b = B[i];\n        sum_of_squares += a * a + b * b;\n        sum_of_products += a * b;\n    }\n\n    return sum_of_squares - sum_of_products;\n}\n```"}
{"task_id": "SimdBench_42_Neon", "completion": "```cpp\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 2; i += 2) {\n        uint64x2_t vecA = vld1q_u64(&A[i]);\n        uint64x2_t vecB = vld1q_u64(&B[i]);\n        uint64x2_t vecNotB = vmvnq_u64(vecB);\n        uint64x2_t result = vandq_u64(vecA, vecNotB);\n        vst1q_u64(&C[i], result);\n    }\n    for (; i < length; i++) {\n        C[i] = A[i] & (~B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_42_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 2; i += 2) {\n        uint64x2_t vecA = vld1q_u64(&A[i]);\n        uint64x2_t vecB = vld1q_u64(&B[i]);\n        uint64x2_t vecNotB = vmvnq_u64(vecB);\n        uint64x2_t result = vandq_u64(vecA, vecNotB);\n        vst1q_u64(&C[i], result);\n    }\n    for (; i < length; i++) {\n        C[i] = A[i] & (~B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_42_Neon", "completion": "```cpp\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 2; i += 2) {\n        uint64x2_t vecA = vld1q_u64(&A[i]);\n        uint64x2_t vecB = vld1q_u64(&B[i]);\n        uint64x2_t vecNotB = vmvnq_u64(vecB);\n        uint64x2_t result = vandq_u64(vecA, vecNotB);\n        vst1q_u64(&C[i], result);\n    }\n    for (; i < length; i++) {\n        C[i] = A[i] & (~B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_42_Neon", "completion": "```cpp\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 2; i += 2) {\n        uint64x2_t vecA = vld1q_u64(&A[i]);\n        uint64x2_t vecB = vld1q_u64(&B[i]);\n        uint64x2_t vecNotB = vmvnq_u64(vecB);\n        uint64x2_t result = vandq_u64(vecA, vecNotB);\n        vst1q_u64(&C[i], result);\n    }\n    for (; i < length; i++) {\n        C[i] = A[i] & (~B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_42_Neon", "completion": "```cpp\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 2; i += 2) {\n        uint64x2_t vecA = vld1q_u64(&A[i]);\n        uint64x2_t vecB = vld1q_u64(&B[i]);\n        uint64x2_t vecNotB = vmvnq_u64(vecB);\n        uint64x2_t result = vandq_u64(vecA, vecNotB);\n        vst1q_u64(&C[i], result);\n    }\n    for (; i < length; i++) {\n        C[i] = A[i] & (~B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_43_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 16; i += 16) {\n        int8x16_t a = vld1q_s8(A + i);\n        int8x16_t b = vld1q_s8(B + i);\n\n        uint8x16_t a_pos = vcgtq_s8(a, vdupq_n_s8(0));\n        uint8x16_t b_pos = vcgtq_s8(b, vdupq_n_s8(0));\n        uint8x16_t a_neg = vcltq_s8(a, vdupq_n_s8(0));\n        uint8x16_t b_neg = vcltq_s8(b, vdupq_n_s8(0));\n\n        uint8x16_t both_pos = vandq_u8(a_pos, b_pos);\n        uint8x16_t both_neg = vandq_u8(a_neg, b_neg);\n\n        int8x16_t result = vbslq_s8(both_pos, vdupq_n_s8(1), vdupq_n_s8(0));\n        result = vbslq_s8(both_neg, vdupq_n_s8(-1), result);\n\n        vst1q_s8(C + i, result);\n    }\n\n    for (; i < length; ++i) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 16; i += 16) {\n        int8x16_t vecA = vld1q_s8(A + i);\n        int8x16_t vecB = vld1q_s8(B + i);\n\n        uint8x16_t maskPosA = vcgtq_s8(vecA, vdupq_n_s8(0));\n        uint8x16_t maskPosB = vcgtq_s8(vecB, vdupq_n_s8(0));\n        uint8x16_t maskNegA = vcltq_s8(vecA, vdupq_n_s8(0));\n        uint8x16_t maskNegB = vcltq_s8(vecB, vdupq_n_s8(0));\n\n        uint8x16_t maskBothPos = vandq_u8(maskPosA, maskPosB);\n        uint8x16_t maskBothNeg = vandq_u8(maskNegA, maskNegB);\n\n        int8x16_t resultPos = vreinterpretq_s8_u8(vandq_u8(maskBothPos, vdupq_n_u8(1)));\n        int8x16_t resultNeg = vreinterpretq_s8_u8(vandq_u8(maskBothNeg, vdupq_n_u8(255)));\n\n        int8x16_t result = vorrq_s8(resultPos, veorq_s8(resultNeg, vdupq_n_s8(-1)));\n\n        vst1q_s8(C + i, result);\n    }\n\n    for (; i < length; i++) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 16; i += 16) {\n        int8x16_t a = vld1q_s8(A + i);\n        int8x16_t b = vld1q_s8(B + i);\n\n        uint8x16_t a_pos = vcgtq_s8(a, vdupq_n_s8(0));\n        uint8x16_t b_pos = vcgtq_s8(b, vdupq_n_s8(0));\n        uint8x16_t a_neg = vcltq_s8(a, vdupq_n_s8(0));\n        uint8x16_t b_neg = vcltq_s8(b, vdupq_n_s8(0));\n\n        uint8x16_t both_pos = vandq_u8(a_pos, b_pos);\n        uint8x16_t both_neg = vandq_u8(a_neg, b_neg);\n\n        int8x16_t result = veorq_s8(vreinterpretq_s8_u8(both_pos), vreinterpretq_s8_u8(both_neg));\n        result = vsubq_s8(result, vreinterpretq_s8_u8(both_neg));\n\n        vst1q_s8(C + i, result);\n    }\n\n    for (; i < length; ++i) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 16; i += 16) {\n        int8x16_t a = vld1q_s8(A + i);\n        int8x16_t b = vld1q_s8(B + i);\n\n        uint8x16_t mask_pos_a = vcgtq_s8(a, vdupq_n_s8(0));\n        uint8x16_t mask_pos_b = vcgtq_s8(b, vdupq_n_s8(0));\n        uint8x16_t mask_neg_a = vcltq_s8(a, vdupq_n_s8(0));\n        uint8x16_t mask_neg_b = vcltq_s8(b, vdupq_n_s8(0));\n\n        uint8x16_t mask_both_pos = vandq_u8(mask_pos_a, mask_pos_b);\n        uint8x16_t mask_both_neg = vandq_u8(mask_neg_a, mask_neg_b);\n\n        int8x16_t result_pos = vandq_s8(vreinterpretq_s8_u8(mask_both_pos), vdupq_n_s8(1));\n        int8x16_t result_neg = vandq_s8(vreinterpretq_s8_u8(mask_both_neg), vdupq_n_s8(-1));\n        int8x16_t result_zero = veorq_s8(result_pos, result_neg);\n\n        vst1q_s8(C + i, result_zero);\n    }\n\n    for (; i < length; ++i) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 16; i += 16) {\n        int8x16_t a = vld1q_s8(A + i);\n        int8x16_t b = vld1q_s8(B + i);\n\n        uint8x16_t a_pos = vcgtq_s8(a, vdupq_n_s8(0));\n        uint8x16_t b_pos = vcgtq_s8(b, vdupq_n_s8(0));\n        uint8x16_t a_neg = vcltq_s8(a, vdupq_n_s8(0));\n        uint8x16_t b_neg = vcltq_s8(b, vdupq_n_s8(0));\n\n        uint8x16_t pos_mask = vandq_u8(a_pos, b_pos);\n        uint8x16_t neg_mask = vandq_u8(a_neg, b_neg);\n\n        int8x16_t result = veorq_s8(vreinterpretq_s8_u8(pos_mask), vreinterpretq_s8_u8(neg_mask));\n        result = vsubq_s8(result, vreinterpretq_s8_u8(neg_mask));\n\n        vst1q_s8(C + i, result);\n    }\n\n    for (; i < length; i++) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t i = 0;\n\n    // Process elements before the midpoint\n    for (; i <= midpoint - 8; i += 8) {\n        uint16x8_t vecA = vld1q_u16(&A[i]);\n        uint16x8_t vecB = vld1q_u16(&B[i]);\n        uint16x8_t vecXOR = veorq_u16(vecA, vecB);\n        uint16x8_t vecAND = vandq_u16(vecA, vecB);\n        uint16x8_t result = vbslq_u16(vceqq_u16(vdupq_n_u16(midpoint), vaddq_u16(vdupq_n_u16(i), vcreate_u16(0x00070006000500040003000200010000))),\n                                      vecA, vbslq_u16(vcleq_u16(vdupq_n_u16(midpoint - 1), vaddq_u16(vdupq_n_u16(i), vcreate_u16(0x00070006000500040003000200010000))),\n                                                      vecXOR, vecAND));\n        vst1q_u16(&C[i], result);\n    }\n\n    // Handle remaining elements before the midpoint\n    for (; i < midpoint; ++i) {\n        if (i == midpoint - 1) {\n            C[i] = A[i];\n        } else {\n            C[i] = (A[i] ^ B[i]) & A[i];\n        }\n    }\n\n    // Handle the midpoint element\n    C[midpoint] = A[midpoint];\n\n    // Process elements after the midpoint\n    for (i = midpoint + 1; i <= length - 8; i += 8) {\n        uint16x8_t vecA = vld1q_u16(&A[i]);\n        uint16x8_t vecB = vld1q_u16(&B[i]);\n        uint16x8_t vecXOR = veorq_u16(vecA, vecB);\n        vst1q_u16(&C[i], vecXOR);\n    }\n\n    // Handle remaining elements after the midpoint\n    for (; i < length; ++i) {\n        C[i] = A[i] ^ B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_44_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t i = 0;\n\n    // Process elements before the midpoint\n    for (; i + 7 < midpoint; i += 8) {\n        uint16x8_t vecA = vld1q_u16(&A[i]);\n        uint16x8_t vecB = vld1q_u16(&B[i]);\n        uint16x8_t vecXOR = veorq_u16(vecA, vecB);\n        uint16x8_t vecAND = vandq_u16(vecA, vecB);\n        uint16x8_t result = vbslq_u16(vceqq_u16(vecA, vecB), vecA, veorq_u16(vecXOR, vecAND));\n        vst1q_u16(&C[i], result);\n    }\n\n    // Handle remaining elements before the midpoint\n    for (; i < midpoint; ++i) {\n        C[i] = (A[i] == B[i]) ? A[i] : (A[i] ^ B[i]) & (A[i] & B[i]);\n    }\n\n    // Copy elements at and after the midpoint from A to C\n    for (; i < length; ++i) {\n        C[i] = A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_44_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t i = 0;\n\n    // Process elements before the midpoint\n    for (; i + 7 < midpoint; i += 8) {\n        uint16x8_t vecA = vld1q_u16(&A[i]);\n        uint16x8_t vecB = vld1q_u16(&B[i]);\n        uint16x8_t vecXOR = veorq_u16(vecA, vecB);\n        uint16x8_t vecAND = vandq_u16(vecA, vecB);\n        uint16x8_t result = vbslq_u16(vceqq_u16(vecA, vecB), vecA, veorq_u16(vecXOR, vecAND));\n        vst1q_u16(&C[i], result);\n    }\n\n    // Handle remaining elements before the midpoint\n    for (; i < midpoint; ++i) {\n        C[i] = (A[i] == B[i]) ? A[i] : (A[i] ^ B[i]) & (A[i] & B[i]);\n    }\n\n    // Copy elements after the midpoint\n    for (; i < length; ++i) {\n        C[i] = A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_44_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t i = 0;\n\n    // Process elements before the midpoint\n    for (; i <= midpoint - 8; i += 8) {\n        uint16x8_t vecA = vld1q_u16(&A[i]);\n        uint16x8_t vecB = vld1q_u16(&B[i]);\n        uint16x8_t vecXOR = veorq_u16(vecA, vecB);\n        uint16x8_t vecAND = vandq_u16(vecA, vecB);\n        uint16x8_t result = vbslq_u16(vceqq_u16(vdupq_n_u16(midpoint), vaddq_u16(vdupq_n_u16(i), vcreate_u16(0x0007000600050004ULL))), vecA, vbslq_u16(vcleq_u16(vdupq_n_u16(midpoint - 1), vaddq_u16(vdupq_n_u16(i), vcreate_u16(0x0007000600050004ULL))), vecXOR, vecAND));\n        vst1q_u16(&C[i], result);\n    }\n\n    // Handle remaining elements before the midpoint\n    for (; i < midpoint; ++i) {\n        if (i == midpoint - 1) {\n            C[i] = A[i] & B[i];\n        } else {\n            C[i] = A[i] ^ B[i];\n        }\n    }\n\n    // Handle the midpoint element\n    C[midpoint] = A[midpoint];\n\n    // Process elements after the midpoint\n    for (i = midpoint + 1; i <= length - 8; i += 8) {\n        uint16x8_t vecA = vld1q_u16(&A[i]);\n        uint16x8_t vecB = vld1q_u16(&B[i]);\n        uint16x8_t vecAND = vandq_u16(vecA, vecB);\n        vst1q_u16(&C[i], vecAND);\n    }\n\n    // Handle remaining elements after the midpoint\n    for (; i < length; ++i) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_44_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t i = 0;\n\n    // Process elements before the midpoint\n    for (; i <= midpoint - 8; i += 8) {\n        uint16x8_t vecA = vld1q_u16(&A[i]);\n        uint16x8_t vecB = vld1q_u16(&B[i]);\n        uint16x8_t vecXOR = veorq_u16(vecA, vecB);\n        uint16x8_t vecAND = vandq_u16(vecA, vecB);\n        uint16x8_t result = vbslq_u16(vceqq_u16(vdupq_n_u16(midpoint), vaddq_u16(vdupq_n_u16(i), vcreate_u16(0x00070006000500040003000200010000))),\n                                      vecA, vbslq_u16(vcleq_u16(vdupq_n_u16(midpoint - 1), vaddq_u16(vdupq_n_u16(i), vcreate_u16(0x00070006000500040003000200010000))),\n                                                      vecXOR, vecAND));\n        vst1q_u16(&C[i], result);\n    }\n\n    // Handle remaining elements before the midpoint\n    for (; i < midpoint; ++i) {\n        if (i == midpoint - 1) {\n            C[i] = A[i];\n        } else {\n            C[i] = (A[i] ^ B[i]) & A[i];\n        }\n    }\n\n    // Handle the midpoint element\n    C[midpoint] = A[midpoint];\n\n    // Process elements after the midpoint\n    for (i = midpoint + 1; i <= length - 8; i += 8) {\n        uint16x8_t vecA = vld1q_u16(&A[i]);\n        uint16x8_t vecB = vld1q_u16(&B[i]);\n        uint16x8_t vecAND = vandq_u16(vecA, vecB);\n        vst1q_u16(&C[i], vecAND);\n    }\n\n    // Handle remaining elements after the midpoint\n    for (; i < length; ++i) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_45_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i <= total_elements - 4; i += 4) {\n        uint32x4_t c1 = vld1q_u32((const uint32_t*)(cond1 + i));\n        uint32x4_t c2 = vld1q_u32((const uint32_t*)(cond2 + i));\n\n        uint32x4_t mask1 = vandq_u32(c1, c2);\n        uint32x4_t mask2 = vbicq_u32(c1, c2);\n        uint32x4_t mask3 = vbicq_u32(c2, c1);\n\n        float32x4_t a = vld1q_f32(A + i);\n        float32x4_t b = vld1q_f32(B + i);\n        float32x4_t c = vld1q_f32(C + i);\n        float32x4_t d = vld1q_f32(D + i);\n\n        float32x4_t result1 = vbslq_f32(mask1, a, b);\n        float32x4_t result2 = vbslq_f32(mask2, result1, c);\n        float32x4_t result3 = vbslq_f32(mask3, result2, d);\n\n        vst1q_f32(out + i, result3);\n    }\n\n    for (; i < total_elements; ++i) {\n        if (cond1[i] && cond2[i]) {\n            out[i] = A[i];\n        } else if (cond1[i]) {\n            out[i] = B[i];\n        } else if (cond2[i]) {\n            out[i] = C[i];\n        } else {\n            out[i] = D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i <= total_elements - 4; i += 4) {\n        uint32x4_t c1 = vld1q_u32((const uint32_t*)(cond1 + i));\n        uint32x4_t c2 = vld1q_u32((const uint32_t*)(cond2 + i));\n\n        uint32x4_t c1_true = vceqq_u32(c1, vdupq_n_u32(1));\n        uint32x4_t c2_true = vceqq_u32(c2, vdupq_n_u32(1));\n\n        uint32x4_t mask_ab = vandq_u32(c1_true, c2_true);\n        uint32x4_t mask_ac = vandq_u32(c1_true, vmvnq_u32(c2_true));\n        uint32x4_t mask_cd = vandq_u32(vmvnq_u32(c1_true), c2_true);\n\n        float32x4_t a = vld1q_f32(A + i);\n        float32x4_t b = vld1q_f32(B + i);\n        float32x4_t c = vld1q_f32(C + i);\n        float32x4_t d = vld1q_f32(D + i);\n\n        float32x4_t ab = vbslq_f32(mask_ab, a, b);\n        float32x4_t ac = vbslq_f32(mask_ac, ab, c);\n        float32x4_t cd = vbslq_f32(mask_cd, ac, d);\n\n        vst1q_f32(out + i, cd);\n    }\n\n    for (; i < total_elements; ++i) {\n        if (cond1[i] && cond2[i]) {\n            out[i] = A[i];\n        } else if (cond1[i]) {\n            out[i] = B[i];\n        } else if (cond2[i]) {\n            out[i] = C[i];\n        } else {\n            out[i] = D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i <= total_elements - 4; i += 4) {\n        uint32x4_t c1 = vld1q_u32((const uint32_t*)(cond1 + i));\n        uint32x4_t c2 = vld1q_u32((const uint32_t*)(cond2 + i));\n\n        uint32x4_t mask1 = vandq_u32(c1, c2);\n        uint32x4_t mask2 = vbicq_u32(c1, c2);\n        uint32x4_t mask3 = vbicq_u32(c2, c1);\n\n        float32x4_t a = vld1q_f32(A + i);\n        float32x4_t b = vld1q_f32(B + i);\n        float32x4_t c = vld1q_f32(C + i);\n        float32x4_t d = vld1q_f32(D + i);\n\n        float32x4_t result1 = vbslq_f32(mask1, a, b);\n        float32x4_t result2 = vbslq_f32(mask2, result1, c);\n        float32x4_t result3 = vbslq_f32(mask3, result2, d);\n\n        vst1q_f32(out + i, result3);\n    }\n\n    for (; i < total_elements; ++i) {\n        if (cond1[i] && cond2[i]) {\n            out[i] = A[i];\n        } else if (cond1[i]) {\n            out[i] = B[i];\n        } else if (cond2[i]) {\n            out[i] = C[i];\n        } else {\n            out[i] = D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i <= total_elements - 4; i += 4) {\n        uint32x4_t c1 = vld1q_u32((const uint32_t*)(cond1 + i));\n        uint32x4_t c2 = vld1q_u32((const uint32_t*)(cond2 + i));\n\n        uint32x4_t mask1 = vandq_u32(c1, c2);\n        uint32x4_t mask2 = vbicq_u32(c1, c2);\n        uint32x4_t mask3 = vbicq_u32(c2, c1);\n\n        float32x4_t a = vld1q_f32(A + i);\n        float32x4_t b = vld1q_f32(B + i);\n        float32x4_t c = vld1q_f32(C + i);\n        float32x4_t d = vld1q_f32(D + i);\n\n        float32x4_t result1 = vbslq_f32(mask1, a, b);\n        float32x4_t result2 = vbslq_f32(mask2, result1, c);\n        float32x4_t result3 = vbslq_f32(mask3, result2, d);\n\n        vst1q_f32(out + i, result3);\n    }\n\n    for (; i < total_elements; ++i) {\n        if (cond1[i] && cond2[i]) {\n            out[i] = A[i];\n        } else if (cond1[i]) {\n            out[i] = B[i];\n        } else if (cond2[i]) {\n            out[i] = C[i];\n        } else {\n            out[i] = D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i <= total_elements - 4; i += 4) {\n        uint32x4_t c1 = vld1q_u32((const uint32_t*)(cond1 + i));\n        uint32x4_t c2 = vld1q_u32((const uint32_t*)(cond2 + i));\n\n        uint32x4_t mask1 = vandq_u32(c1, c2);\n        uint32x4_t mask2 = vbicq_u32(c1, c2);\n        uint32x4_t mask3 = vbicq_u32(c2, c1);\n\n        float32x4_t a = vld1q_f32(A + i);\n        float32x4_t b = vld1q_f32(B + i);\n        float32x4_t c = vld1q_f32(C + i);\n        float32x4_t d = vld1q_f32(D + i);\n\n        float32x4_t result1 = vbslq_f32(mask1, a, b);\n        float32x4_t result2 = vbslq_f32(mask2, result1, c);\n        float32x4_t result3 = vbslq_f32(mask3, result2, d);\n\n        vst1q_f32(out + i, result3);\n    }\n\n    for (; i < total_elements; ++i) {\n        if (cond1[i] && cond2[i]) {\n            out[i] = A[i];\n        } else if (cond1[i]) {\n            out[i] = B[i];\n        } else if (cond2[i]) {\n            out[i] = C[i];\n        } else {\n            out[i] = D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_46_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i <= total_elements - 16; i += 16) {\n        uint32x4_t a0 = vld1q_u32(A + i);\n        uint32x4_t a1 = vld1q_u32(A + i + 4);\n        uint32x4_t a2 = vld1q_u32(A + i + 8);\n        uint32x4_t a3 = vld1q_u32(A + i + 12);\n\n        uint8x16_t cnt0 = vcntq_u8(vreinterpretq_u8_u32(a0));\n        uint8x16_t cnt1 = vcntq_u8(vreinterpretq_u8_u32(a1));\n        uint8x16_t cnt2 = vcntq_u8(vreinterpretq_u8_u32(a2));\n        uint8x16_t cnt3 = vcntq_u8(vreinterpretq_u8_u32(a3));\n\n        uint8x16_t sum0 = vpaddq_u8(cnt0, cnt1);\n        uint8x16_t sum1 = vpaddq_u8(cnt2, cnt3);\n        uint8x16_t sum2 = vpaddq_u8(sum0, sum1);\n\n        vst1q_u8(out + i, sum2);\n    }\n\n    for (; i < total_elements; ++i) {\n        out[i] = __builtin_popcount(A[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_46_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i <= total_elements - 16; i += 16) {\n        uint32x4_t a0 = vld1q_u32(A + i);\n        uint32x4_t a1 = vld1q_u32(A + i + 4);\n        uint32x4_t a2 = vld1q_u32(A + i + 8);\n        uint32x4_t a3 = vld1q_u32(A + i + 12);\n\n        uint8x16_t bit_count0 = vcntq_u8(vreinterpretq_u8_u32(a0));\n        uint8x16_t bit_count1 = vcntq_u8(vreinterpretq_u8_u32(a1));\n        uint8x16_t bit_count2 = vcntq_u8(vreinterpretq_u8_u32(a2));\n        uint8x16_t bit_count3 = vcntq_u8(vreinterpretq_u8_u32(a3));\n\n        uint16x8_t sum0 = vpaddlq_u8(bit_count0);\n        uint16x8_t sum1 = vpaddlq_u8(bit_count1);\n        uint16x8_t sum2 = vpaddlq_u8(bit_count2);\n        uint16x8_t sum3 = vpaddlq_u8(bit_count3);\n\n        uint32x4_t sum0_32 = vpaddlq_u16(sum0);\n        uint32x4_t sum1_32 = vpaddlq_u16(sum1);\n        uint32x4_t sum2_32 = vpaddlq_u16(sum2);\n        uint32x4_t sum3_32 = vpaddlq_u16(sum3);\n\n        uint8x16_t final_sum = vcombine_u8(vmovn_u16(vcombine_u32(sum0_32, sum1_32)),\n                                           vmovn_u16(vcombine_u32(sum2_32, sum3_32)));\n\n        vst1q_u8(out + i, final_sum);\n    }\n\n    for (; i < total_elements; ++i) {\n        out[i] = __builtin_popcount(A[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_46_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i <= total_elements - 16; i += 16) {\n        uint32x4_t a0 = vld1q_u32(A + i);\n        uint32x4_t a1 = vld1q_u32(A + i + 4);\n        uint32x4_t a2 = vld1q_u32(A + i + 8);\n        uint32x4_t a3 = vld1q_u32(A + i + 12);\n\n        uint8x16_t bit_count = vcntq_u8(vreinterpretq_u8_u32(a0));\n        bit_count = vaddq_u8(bit_count, vreinterpretq_u8_u32(a1));\n        bit_count = vaddq_u8(bit_count, vreinterpretq_u8_u32(a2));\n        bit_count = vaddq_u8(bit_count, vreinterpretq_u8_u32(a3));\n\n        vst1q_u8(out + i, bit_count);\n    }\n\n    for (; i < total_elements; ++i) {\n        out[i] = __builtin_popcount(A[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_46_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i <= total_elements - 16; i += 16) {\n        uint32x4_t a0 = vld1q_u32(A + i);\n        uint32x4_t a1 = vld1q_u32(A + i + 4);\n        uint32x4_t a2 = vld1q_u32(A + i + 8);\n        uint32x4_t a3 = vld1q_u32(A + i + 12);\n\n        uint8x16_t cnt0 = vcntq_u8(vreinterpretq_u8_u32(a0));\n        uint8x16_t cnt1 = vcntq_u8(vreinterpretq_u8_u32(a1));\n        uint8x16_t cnt2 = vcntq_u8(vreinterpretq_u8_u32(a2));\n        uint8x16_t cnt3 = vcntq_u8(vreinterpretq_u8_u32(a3));\n\n        uint8x16_t sum0 = vpaddq_u8(cnt0, cnt1);\n        uint8x16_t sum1 = vpaddq_u8(cnt2, cnt3);\n        uint8x16_t sum2 = vpaddq_u8(sum0, sum1);\n\n        vst1q_u8(out + i, sum2);\n    }\n\n    for (; i < total_elements; ++i) {\n        out[i] = __builtin_popcount(A[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_46_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i <= total_elements - 16; i += 16) {\n        uint32x4_t a0 = vld1q_u32(A + i);\n        uint32x4_t a1 = vld1q_u32(A + i + 4);\n        uint32x4_t a2 = vld1q_u32(A + i + 8);\n        uint32x4_t a3 = vld1q_u32(A + i + 12);\n\n        uint8x16_t bit_count = vcntq_u8(vreinterpretq_u8_u32(a0));\n        bit_count = vaddq_u8(bit_count, vreinterpretq_u8_u32(a1));\n        bit_count = vaddq_u8(bit_count, vreinterpretq_u8_u32(a2));\n        bit_count = vaddq_u8(bit_count, vreinterpretq_u8_u32(a3));\n\n        vst1q_u8(out + i, bit_count);\n    }\n\n    for (; i < total_elements; ++i) {\n        out[i] = __builtin_popcount(A[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_47_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    for (; i <= total_elements - 4; i += 4) {\n        int32x4_t vec_a = vld1q_s32(&A[i]);\n        int32x4_t vec_mod = vandq_s32(vec_a, vdupq_n_s32(2));\n        uint32x4_t vec_mask = vceqq_s32(vec_mod, vdupq_n_s32(0));\n        int32x4_t vec_abs = vabsq_s32(vec_a);\n        int32x4_t vec_result = vbslq_s32(vec_mask, vec_abs, vec_a);\n        vst1q_s32(&B[i], vec_result);\n    }\n\n    for (; i < total_elements; ++i) {\n        B[i] = (A[i] % 3 == 0) ? abs(A[i]) : A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_47_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    for (; i <= total_elements - 4; i += 4) {\n        int32x4_t vec_a = vld1q_s32(&A[i]);\n        int32x4_t vec_mod = vandq_s32(vec_a, vdupq_n_s32(2));\n        uint32x4_t vec_mask = vceqq_s32(vec_mod, vdupq_n_s32(0));\n        int32x4_t vec_abs = vabsq_s32(vec_a);\n        int32x4_t vec_result = vbslq_s32(vec_mask, vec_abs, vec_a);\n        vst1q_s32(&B[i], vec_result);\n    }\n\n    for (; i < total_elements; ++i) {\n        B[i] = (A[i] % 3 == 0) ? abs(A[i]) : A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_47_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    for (; i <= total_elements - 4; i += 4) {\n        int32x4_t vec_a = vld1q_s32(&A[i]);\n        int32x4_t vec_mod3 = veorq_s32(vandq_s32(vec_a, vdupq_n_s32(3)), vdupq_n_s32(3));\n        uint32x4_t vec_mask = vceqq_s32(vec_mod3, vdupq_n_s32(0));\n        int32x4_t vec_abs = vabsq_s32(vec_a);\n        int32x4_t vec_result = vbslq_s32(vec_mask, vec_abs, vec_a);\n        vst1q_s32(&B[i], vec_result);\n    }\n\n    for (; i < total_elements; ++i) {\n        B[i] = (A[i] % 3 == 0) ? abs(A[i]) : A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_47_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    for (; i <= total_elements - 4; i += 4) {\n        int32x4_t vec_a = vld1q_s32(&A[i]);\n        int32x4_t vec_mod3 = veorq_s32(vandq_s32(vec_a, vdupq_n_s32(3)), vdupq_n_s32(3));\n        uint32x4_t vec_mask = vceqq_s32(vec_mod3, vdupq_n_s32(0));\n        int32x4_t vec_abs = vabsq_s32(vec_a);\n        int32x4_t vec_result = vbslq_s32(vec_mask, vec_abs, vec_a);\n        vst1q_s32(&B[i], vec_result);\n    }\n\n    for (; i < total_elements; ++i) {\n        B[i] = (A[i] % 3 == 0) ? abs(A[i]) : A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_47_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    for (; i <= total_elements - 4; i += 4) {\n        int32x4_t vec_a = vld1q_s32(&A[i]);\n        int32x4_t vec_mod3 = veorq_s32(vandq_s32(vec_a, vdupq_n_s32(3)), vdupq_n_s32(3));\n        uint32x4_t vec_mask = vceqq_s32(vec_mod3, vdupq_n_s32(0));\n        int32x4_t vec_abs = vabsq_s32(vec_a);\n        int32x4_t vec_result = vbslq_s32(vec_mask, vec_abs, vec_a);\n        vst1q_s32(&B[i], vec_result);\n    }\n\n    for (; i < total_elements; ++i) {\n        B[i] = (A[i] % 3 == 0) ? abs(A[i]) : A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_48_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    uint32x4_t ones = vdupq_n_u32(0xF);\n    uint32x4_t mask = vdupq_n_u32(0xFFFFFFFF);\n    uint32x4_t rotate_mask = vdupq_n_u32(rotate_bits);\n\n    for (size_t i = 0; i < length; i += 4) {\n        uint32x4_t src_vec = vld1q_u32(&src[i]);\n        uint32x4_t low_bits = vandq_u32(src_vec, ones);\n        uint32x4_t condition = vceqq_u32(low_bits, ones);\n        uint32x4_t rotated = vextq_u32(src_vec, src_vec, 16 - (rotate_bits % 32));\n        uint32x4_t negated = vmvnq_u32(src_vec);\n        uint32x4_t result = vbslq_u32(condition, rotated, negated);\n        vst1q_u32(&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_48_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    uint32x4_t ones = vdupq_n_u32(0xF);\n    uint32x4_t mask = vdupq_n_u32(0xFFFFFFFF);\n    uint32x4_t rotate_mask = vdupq_n_u32(rotate_bits);\n\n    for (size_t i = 0; i < length; i += 4) {\n        uint32x4_t src_vec = vld1q_u32(&src[i]);\n        uint32x4_t low_4_bits = vandq_u32(src_vec, ones);\n        uint32x4_t condition = vceqq_u32(low_4_bits, ones);\n\n        uint32x4_t rotated = vshrq_n_u32(src_vec, 32 - rotate_bits);\n        rotated = vorrq_u32(rotated, vshlq_n_u32(src_vec, rotate_bits));\n\n        uint32x4_t negated = vmvnq_u32(src_vec);\n\n        uint32x4_t result = vbslq_u32(condition, rotated, negated);\n\n        vst1q_u32(&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_48_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    uint32x4_t ones = vdupq_n_u32(0xF);\n    uint32x4_t mask = vdupq_n_u32(0xFFFFFFFF);\n    uint32x4_t rotate_mask = vdupq_n_u32(rotate_bits);\n\n    for (size_t i = 0; i < length; i += 4) {\n        uint32x4_t src_vec = vld1q_u32(&src[i]);\n        uint32x4_t low_4_bits = vandq_u32(src_vec, ones);\n        uint32x4_t condition = vceqq_u32(low_4_bits, ones);\n\n        uint32x4_t rotated = vshrq_n_u32(src_vec, 32 - rotate_bits);\n        rotated = vorrq_u32(rotated, vshlq_n_u32(src_vec, rotate_bits));\n\n        uint32x4_t negated = vmvnq_u32(src_vec);\n\n        uint32x4_t result = vbslq_u32(condition, rotated, negated);\n\n        vst1q_u32(&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_48_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    uint32x4_t v_rotate_bits = vdupq_n_u32(rotate_bits);\n    uint32x4_t v_mask = vdupq_n_u32(0xF);\n    uint32x4_t v_ones = vdupq_n_u32(0xF);\n\n    for (size_t i = 0; i < length; i += 4) {\n        uint32x4_t v_src = vld1q_u32(&src[i]);\n        uint32x4_t v_low_4_bits = vandq_u32(v_src, v_mask);\n        uint32x4_t v_condition = vceqq_u32(v_low_4_bits, v_ones);\n\n        uint32x4_t v_rotated = vextq_u32(v_src, vshlq_n_u32(v_src, 32 - rotate_bits), 4 - rotate_bits / 8);\n        uint32x4_t v_negated = vmvnq_u32(v_src);\n\n        uint32x4_t v_result = vbslq_u32(v_condition, v_rotated, v_negated);\n        vst1q_u32(&dst[i], v_result);\n    }\n}\n```"}
{"task_id": "SimdBench_48_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t i = 0;\n    uint32x4_t vrotate_bits = vdupq_n_u32(rotate_bits);\n    uint32x4_t vmask = vdupq_n_u32(0xF);\n\n    for (; i <= length - 4; i += 4) {\n        uint32x4_t vsrc = vld1q_u32(&src[i]);\n        uint32x4_t vlow4bits = vandq_u32(vsrc, vmask);\n        uint32x4_t vcondition = vceqq_u32(vlow4bits, vmask);\n        uint32x4_t vrotated = vshrq_n_u32(vsrc, 32 - rotate_bits);\n        vrotated = vorrq_u32(vrotated, vshlq_n_u32(vsrc, rotate_bits));\n        uint32x4_t vnegated = vmvnq_u32(vsrc);\n        uint32x4_t vresult = vbslq_u32(vcondition, vrotated, vnegated);\n        vst1q_u32(&dst[i], vresult);\n    }\n\n    for (; i < length; i++) {\n        uint32_t element = src[i];\n        if ((element & 0xF) == 0xF) {\n            dst[i] = (element >> (32 - rotate_bits)) | (element << rotate_bits);\n        } else {\n            dst[i] = ~element;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float32x4_t vec_epsilon = vdupq_n_f32(fabsf(epsilon));\n    float32x4_t vec_zero = vdupq_n_f32(0.0f);\n    int8x16_t vec_one = vdupq_n_s8(1);\n    int8x16_t vec_neg_one = vdupq_n_s8(-1);\n    int8x16_t vec_zero_out = vdupq_n_s8(0);\n\n    size_t i = 0;\n    for (; i <= length - 16; i += 16) {\n        float32x4_t vec_a0 = vld1q_f32(&A[i]);\n        float32x4_t vec_b0 = vld1q_f32(&B[i]);\n        float32x4_t vec_diff0 = vsubq_f32(vec_a0, vec_b0);\n        uint32x4_t vec_mask_gt0 = vcgtq_f32(vec_diff0, vec_epsilon);\n        uint32x4_t vec_mask_lt0 = vcltq_f32(vec_diff0, vmulq_n_f32(vec_epsilon, -1.0f));\n\n        float32x4_t vec_a1 = vld1q_f32(&A[i + 4]);\n        float32x4_t vec_b1 = vld1q_f32(&B[i + 4]);\n        float32x4_t vec_diff1 = vsubq_f32(vec_a1, vec_b1);\n        uint32x4_t vec_mask_gt1 = vcgtq_f32(vec_diff1, vec_epsilon);\n        uint32x4_t vec_mask_lt1 = vcltq_f32(vec_diff1, vmulq_n_f32(vec_epsilon, -1.0f));\n\n        float32x4_t vec_a2 = vld1q_f32(&A[i + 8]);\n        float32x4_t vec_b2 = vld1q_f32(&B[i + 8]);\n        float32x4_t vec_diff2 = vsubq_f32(vec_a2, vec_b2);\n        uint32x4_t vec_mask_gt2 = vcgtq_f32(vec_diff2, vec_epsilon);\n        uint32x4_t vec_mask_lt2 = vcltq_f32(vec_diff2, vmulq_n_f32(vec_epsilon, -1.0f));\n\n        float32x4_t vec_a3 = vld1q_f32(&A[i + 12]);\n        float32x4_t vec_b3 = vld1q_f32(&B[i + 12]);\n        float32x4_t vec_diff3 = vsubq_f32(vec_a3, vec_b3);\n        uint32x4_t vec_mask_gt3 = vcgtq_f32(vec_diff3, vec_epsilon);\n        uint32x4_t vec_mask_lt3 = vcltq_f32(vec_diff3, vmulq_n_f32(vec_epsilon, -1.0f));\n\n        int8x16_t vec_result = vec_zero_out;\n        vec_result = vbslq_s8(vec_mask_gt0, vec_one, vec_result);\n        vec_result = vbslq_s8(vec_mask_lt0, vec_neg_one, vec_result);\n        vec_result = vbslq_s8(vec_mask_gt1, vec_one, vec_result);\n        vec_result = vbslq_s8(vec_mask_lt1, vec_neg_one, vec_result);\n        vec_result = vbslq_s8(vec_mask_gt2, vec_one, vec_result);\n        vec_result = vbslq_s8(vec_mask_lt2, vec_neg_one, vec_result);\n        vec_result = vbslq_s8(vec_mask_gt3, vec_one, vec_result);\n        vec_result = vbslq_s8(vec_mask_lt3, vec_neg_one, vec_result);\n\n        vst1q_s8(&out[i], vec_result);\n    }\n\n    for (; i < length; i++) {\n        float diff = A[i] - B[i];\n        if (diff > fabsf(epsilon)) {\n            out[i] = 1;\n        } else if (diff < -fabsf(epsilon)) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float32x4_t vec_epsilon = vdupq_n_f32(fabsf(epsilon));\n    float32x4_t vec_zero = vdupq_n_f32(0.0f);\n    int8x16_t vec_one = vdupq_n_s8(1);\n    int8x16_t vec_neg_one = vdupq_n_s8(-1);\n    int8x16_t vec_zero_out = vdupq_n_s8(0);\n\n    size_t i = 0;\n    for (; i <= length - 16; i += 16) {\n        float32x4_t vec_a0 = vld1q_f32(&A[i]);\n        float32x4_t vec_b0 = vld1q_f32(&B[i]);\n        float32x4_t vec_diff0 = vsubq_f32(vec_a0, vec_b0);\n        uint32x4_t vec_mask_gt0 = vcgtq_f32(vec_diff0, vec_epsilon);\n        uint32x4_t vec_mask_lt0 = vcltq_f32(vec_diff0, vmulq_n_f32(vec_epsilon, -1.0f));\n\n        float32x4_t vec_a1 = vld1q_f32(&A[i + 4]);\n        float32x4_t vec_b1 = vld1q_f32(&B[i + 4]);\n        float32x4_t vec_diff1 = vsubq_f32(vec_a1, vec_b1);\n        uint32x4_t vec_mask_gt1 = vcgtq_f32(vec_diff1, vec_epsilon);\n        uint32x4_t vec_mask_lt1 = vcltq_f32(vec_diff1, vmulq_n_f32(vec_epsilon, -1.0f));\n\n        float32x4_t vec_a2 = vld1q_f32(&A[i + 8]);\n        float32x4_t vec_b2 = vld1q_f32(&B[i + 8]);\n        float32x4_t vec_diff2 = vsubq_f32(vec_a2, vec_b2);\n        uint32x4_t vec_mask_gt2 = vcgtq_f32(vec_diff2, vec_epsilon);\n        uint32x4_t vec_mask_lt2 = vcltq_f32(vec_diff2, vmulq_n_f32(vec_epsilon, -1.0f));\n\n        float32x4_t vec_a3 = vld1q_f32(&A[i + 12]);\n        float32x4_t vec_b3 = vld1q_f32(&B[i + 12]);\n        float32x4_t vec_diff3 = vsubq_f32(vec_a3, vec_b3);\n        uint32x4_t vec_mask_gt3 = vcgtq_f32(vec_diff3, vec_epsilon);\n        uint32x4_t vec_mask_lt3 = vcltq_f32(vec_diff3, vmulq_n_f32(vec_epsilon, -1.0f));\n\n        int8x16_t vec_result = vec_zero_out;\n        vec_result = vbslq_s8(vec_mask_gt0, vec_one, vec_result);\n        vec_result = vbslq_s8(vec_mask_lt0, vec_neg_one, vec_result);\n        vec_result = vbslq_s8(vec_mask_gt1, vec_one, vec_result);\n        vec_result = vbslq_s8(vec_mask_lt1, vec_neg_one, vec_result);\n        vec_result = vbslq_s8(vec_mask_gt2, vec_one, vec_result);\n        vec_result = vbslq_s8(vec_mask_lt2, vec_neg_one, vec_result);\n        vec_result = vbslq_s8(vec_mask_gt3, vec_one, vec_result);\n        vec_result = vbslq_s8(vec_mask_lt3, vec_neg_one, vec_result);\n\n        vst1q_s8(&out[i], vec_result);\n    }\n\n    for (; i < length; i++) {\n        float diff = A[i] - B[i];\n        if (diff > fabsf(epsilon)) {\n            out[i] = 1;\n        } else if (diff < -fabsf(epsilon)) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_Neon", "completion": "```c\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float32x4_t vec_epsilon = vdupq_n_f32(fabsf(epsilon));\n    size_t i = 0;\n\n    for (; i <= length - 4; i += 4) {\n        float32x4_t vec_A = vld1q_f32(&A[i]);\n        float32x4_t vec_B = vld1q_f32(&B[i]);\n\n        float32x4_t diff = vsubq_f32(vec_A, vec_B);\n        uint32x4_t gt_mask = vcgtq_f32(diff, vec_epsilon);\n        uint32x4_t lt_mask = vcltq_f32(diff, vmulq_n_f32(vec_epsilon, -1.0f));\n\n        int32x4_t result = veorq_s32(vreinterpretq_s32_u32(gt_mask), vreinterpretq_s32_u32(lt_mask));\n        result = vsubq_s32(result, vreinterpretq_s32_u32(lt_mask));\n\n        int8x16_t packed_result = vqmovn_s16(vcombine_s16(vqmovn_s32(result), vqmovn_s32(vshrq_n_s32(result, 16))));\n        vst1_s8(&out[i], vget_low_s8(packed_result));\n    }\n\n    for (; i < length; i++) {\n        float diff = A[i] - B[i];\n        if (diff > fabsf(epsilon)) {\n            out[i] = 1;\n        } else if (diff < -fabsf(epsilon)) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float32x4_t vec_epsilon = vdupq_n_f32(fabsf(epsilon));\n    float32x4_t vec_zero = vdupq_n_f32(0.0f);\n    int8x16_t vec_one = vdupq_n_s8(1);\n    int8x16_t vec_neg_one = vdupq_n_s8(-1);\n    int8x16_t vec_zero_out = vdupq_n_s8(0);\n\n    size_t i = 0;\n    for (; i <= length - 16; i += 16) {\n        float32x4_t vec_a0 = vld1q_f32(&A[i]);\n        float32x4_t vec_b0 = vld1q_f32(&B[i]);\n        float32x4_t vec_diff0 = vsubq_f32(vec_a0, vec_b0);\n        uint32x4_t vec_gt0 = vcgtq_f32(vec_diff0, vec_epsilon);\n        uint32x4_t vec_lt0 = vcltq_f32(vec_diff0, vmulq_n_f32(vec_epsilon, -1.0f));\n\n        float32x4_t vec_a1 = vld1q_f32(&A[i + 4]);\n        float32x4_t vec_b1 = vld1q_f32(&B[i + 4]);\n        float32x4_t vec_diff1 = vsubq_f32(vec_a1, vec_b1);\n        uint32x4_t vec_gt1 = vcgtq_f32(vec_diff1, vec_epsilon);\n        uint32x4_t vec_lt1 = vcltq_f32(vec_diff1, vmulq_n_f32(vec_epsilon, -1.0f));\n\n        float32x4_t vec_a2 = vld1q_f32(&A[i + 8]);\n        float32x4_t vec_b2 = vld1q_f32(&B[i + 8]);\n        float32x4_t vec_diff2 = vsubq_f32(vec_a2, vec_b2);\n        uint32x4_t vec_gt2 = vcgtq_f32(vec_diff2, vec_epsilon);\n        uint32x4_t vec_lt2 = vcltq_f32(vec_diff2, vmulq_n_f32(vec_epsilon, -1.0f));\n\n        float32x4_t vec_a3 = vld1q_f32(&A[i + 12]);\n        float32x4_t vec_b3 = vld1q_f32(&B[i + 12]);\n        float32x4_t vec_diff3 = vsubq_f32(vec_a3, vec_b3);\n        uint32x4_t vec_gt3 = vcgtq_f32(vec_diff3, vec_epsilon);\n        uint32x4_t vec_lt3 = vcltq_f32(vec_diff3, vmulq_n_f32(vec_epsilon, -1.0f));\n\n        int8x16_t vec_result = vec_zero_out;\n        vec_result = vbslq_s8(vec_gt0, vec_one, vec_result);\n        vec_result = vbslq_s8(vec_lt0, vec_neg_one, vec_result);\n        vec_result = vbslq_s8(vec_gt1, vec_one, vec_result);\n        vec_result = vbslq_s8(vec_lt1, vec_neg_one, vec_result);\n        vec_result = vbslq_s8(vec_gt2, vec_one, vec_result);\n        vec_result = vbslq_s8(vec_lt2, vec_neg_one, vec_result);\n        vec_result = vbslq_s8(vec_gt3, vec_one, vec_result);\n        vec_result = vbslq_s8(vec_lt3, vec_neg_one, vec_result);\n\n        vst1q_s8(&out[i], vec_result);\n    }\n\n    for (; i < length; i++) {\n        float diff = A[i] - B[i];\n        if (diff > fabsf(epsilon)) {\n            out[i] = 1;\n        } else if (diff < -fabsf(epsilon)) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float32x4_t vec_epsilon = vdupq_n_f32(fabsf(epsilon));\n    float32x4_t vec_zero = vdupq_n_f32(0.0f);\n    int8x16_t vec_one = vdupq_n_s8(1);\n    int8x16_t vec_neg_one = vdupq_n_s8(-1);\n    int8x16_t vec_zero_out = vdupq_n_s8(0);\n\n    size_t i = 0;\n    for (; i <= length - 16; i += 16) {\n        float32x4_t vec_a0 = vld1q_f32(&A[i]);\n        float32x4_t vec_b0 = vld1q_f32(&B[i]);\n        float32x4_t vec_diff0 = vsubq_f32(vec_a0, vec_b0);\n        uint32x4_t vec_gt0 = vcgtq_f32(vec_diff0, vec_epsilon);\n        uint32x4_t vec_lt0 = vcltq_f32(vec_diff0, vmulq_n_f32(vec_epsilon, -1.0f));\n\n        float32x4_t vec_a1 = vld1q_f32(&A[i + 4]);\n        float32x4_t vec_b1 = vld1q_f32(&B[i + 4]);\n        float32x4_t vec_diff1 = vsubq_f32(vec_a1, vec_b1);\n        uint32x4_t vec_gt1 = vcgtq_f32(vec_diff1, vec_epsilon);\n        uint32x4_t vec_lt1 = vcltq_f32(vec_diff1, vmulq_n_f32(vec_epsilon, -1.0f));\n\n        float32x4_t vec_a2 = vld1q_f32(&A[i + 8]);\n        float32x4_t vec_b2 = vld1q_f32(&B[i + 8]);\n        float32x4_t vec_diff2 = vsubq_f32(vec_a2, vec_b2);\n        uint32x4_t vec_gt2 = vcgtq_f32(vec_diff2, vec_epsilon);\n        uint32x4_t vec_lt2 = vcltq_f32(vec_diff2, vmulq_n_f32(vec_epsilon, -1.0f));\n\n        float32x4_t vec_a3 = vld1q_f32(&A[i + 12]);\n        float32x4_t vec_b3 = vld1q_f32(&B[i + 12]);\n        float32x4_t vec_diff3 = vsubq_f32(vec_a3, vec_b3);\n        uint32x4_t vec_gt3 = vcgtq_f32(vec_diff3, vec_epsilon);\n        uint32x4_t vec_lt3 = vcltq_f32(vec_diff3, vmulq_n_f32(vec_epsilon, -1.0f));\n\n        int8x16_t vec_result = vec_zero_out;\n        vec_result = vbslq_s8(vec_gt0, vec_one, vec_result);\n        vec_result = vbslq_s8(vec_lt0, vec_neg_one, vec_result);\n        vec_result = vbslq_s8(vec_gt1, vec_one, vec_result);\n        vec_result = vbslq_s8(vec_lt1, vec_neg_one, vec_result);\n        vec_result = vbslq_s8(vec_gt2, vec_one, vec_result);\n        vec_result = vbslq_s8(vec_lt2, vec_neg_one, vec_result);\n        vec_result = vbslq_s8(vec_gt3, vec_one, vec_result);\n        vec_result = vbslq_s8(vec_lt3, vec_neg_one, vec_result);\n\n        vst1q_s8(&out[i], vec_result);\n    }\n\n    for (; i < length; i++) {\n        float diff = A[i] - B[i];\n        if (diff > fabsf(epsilon)) {\n            out[i] = 1;\n        } else if (diff < -fabsf(epsilon)) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    const float32x4_t max_val = vdupq_n_f32(INT32_MAX);\n    const float32x4_t min_val = vdupq_n_f32(INT32_MIN);\n\n    for (; i <= size - 4; i += 4) {\n        float32x4_t input = vld1q_f32(&A[i]);\n        int32x4_t saturated = vcvtq_s32_f32(vmaxq_f32(vminq_f32(input, max_val), min_val));\n        vst1q_s32(&B[i], saturated);\n    }\n\n    for (; i < size; i++) {\n        float val = A[i];\n        int32_t saturated_val = (val > INT32_MAX) ? INT32_MAX : (val < INT32_MIN) ? INT32_MIN : (int32_t)val;\n        B[i] = saturated_val;\n    }\n}\n```"}
{"task_id": "SimdBench_50_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    const size_t chunk_size = 4; // Process 4 elements at a time\n\n    // Vector limits\n    float32x4_t max_limit = vdupq_n_f32(INT32_MAX);\n    float32x4_t min_limit = vdupq_n_f32(INT32_MIN);\n\n    for (; i <= size - chunk_size; i += chunk_size) {\n        float32x4_t input = vld1q_f32(&A[i]);\n        int32x4_t saturated = vcvtq_s32_f32(vmaxq_f32(vminq_f32(input, max_limit), min_limit));\n        vst1q_s32(&B[i], saturated);\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        float val = A[i];\n        if (val > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (val < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    const size_t chunk_size = 4; // Process 4 elements at a time\n    int32x4_t int32_max = vdupq_n_s32(INT32_MAX);\n    int32x4_t int32_min = vdupq_n_s32(INT32_MIN);\n\n    for (; i <= size - chunk_size; i += chunk_size) {\n        float32x4_t input = vld1q_f32(&A[i]);\n        int32x4_t output = vcvtq_s32_f32(input);\n        output = vmaxq_s32(output, int32_min);\n        output = vminq_s32(output, int32_max);\n        vst1q_s32(&B[i], output);\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        float val = A[i];\n        if (val > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (val < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    const size_t chunk_size = 4; // Process 4 elements at a time\n    int32x4_t int32_max = vdupq_n_s32(INT32_MAX);\n    int32x4_t int32_min = vdupq_n_s32(INT32_MIN);\n\n    for (; i <= size - chunk_size; i += chunk_size) {\n        float32x4_t input = vld1q_f32(&A[i]);\n        int32x4_t output = vcvtq_s32_f32(input);\n        output = vmaxq_s32(output, int32_min);\n        output = vminq_s32(output, int32_max);\n        vst1q_s32(&B[i], output);\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        float val = A[i];\n        if (val > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (val < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    const size_t chunk_size = 4; // Process 4 elements at a time\n\n    for (; i <= size - chunk_size; i += chunk_size) {\n        float32x4_t vec_a = vld1q_f32(&A[i]);\n        int32x4_t vec_b = vcvtq_s32_f32(vec_a);\n        vec_b = vmaxq_s32(vec_b, vdupq_n_s32(INT32_MIN));\n        vec_b = vminq_s32(vec_b, vdupq_n_s32(INT32_MAX));\n        vst1q_s32(&B[i], vec_b);\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        float val = A[i];\n        if (val > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (val < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_51_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    int32x4_t int_vec;\n    float32x4_t float_vec, scale_vec = vdupq_n_f32(scale);\n\n    size_t i;\n    for (i = 0; i <= size - 4; i += 4) {\n        int_vec = vld1q_s32(&A[i]);\n        float_vec = vcvtq_f32_s32(int_vec);\n        float_vec = vmulq_f32(float_vec, scale_vec);\n        vst1q_f32(&B[i], float_vec);\n    }\n\n    for (; i < size; i++) {\n        B[i] = A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    int32_t scale_int = scale;\n    int32x4_t scale_vec = vdupq_n_s32(scale_int);\n    float32x4_t scale_float_vec = vcvtq_f32_s32(scale_vec);\n\n    size_t i;\n    for (i = 0; i <= size - 4; i += 4) {\n        int32x4_t int_vec = vld1q_s32(&A[i]);\n        float32x4_t float_vec = vcvtq_f32_s32(int_vec);\n        float_vec = vmulq_f32(float_vec, scale_float_vec);\n        vst1q_f32(&B[i], float_vec);\n    }\n\n    for (; i < size; i++) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    int8x8_t scale_vec = vdup_n_s8(scale);\n    size_t i = 0;\n    for (; i <= size - 8; i += 8) {\n        int32x4_t a1 = vld1q_s32(A + i);\n        int32x4_t a2 = vld1q_s32(A + i + 4);\n        int16x8_t a16 = vcombine_s16(vmovn_s32(a1), vmovn_s32(a2));\n        int8x8_t a8 = vmovn_s16(a16);\n        int8x8_t scaled_a8 = vmul_s8(a8, scale_vec);\n        int16x8_t scaled_a16 = vmovl_s8(scaled_a8);\n        int32x4_t scaled_a1 = vmovl_s16(vget_low_s16(scaled_a16));\n        int32x4_t scaled_a2 = vmovl_s16(vget_high_s16(scaled_a16));\n        float32x4_t b1 = vcvtq_f32_s32(scaled_a1);\n        float32x4_t b2 = vcvtq_f32_s32(scaled_a2);\n        vst1q_f32(B + i, b1);\n        vst1q_f32(B + i + 4, b2);\n    }\n    for (; i < size; ++i) {\n        B[i] = static_cast<float>(A[i]) * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    int32x4_t int_vec;\n    float32x4_t float_vec, scale_vec = vdupq_n_f32(scale);\n\n    size_t i;\n    for (i = 0; i <= size - 4; i += 4) {\n        int_vec = vld1q_s32(A + i);\n        float_vec = vcvtq_f32_s32(int_vec);\n        float_vec = vmulq_f32(float_vec, scale_vec);\n        vst1q_f32(B + i, float_vec);\n    }\n\n    for (; i < size; i++) {\n        B[i] = A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    int32x4_t int_vec;\n    float32x4_t float_vec, scale_vec = vdupq_n_f32(scale);\n\n    size_t i;\n    for (i = 0; i <= size - 4; i += 4) {\n        int_vec = vld1q_s32(A + i);\n        float_vec = vcvtq_f32_s32(int_vec);\n        float_vec = vmulq_f32(float_vec, scale_vec);\n        vst1q_f32(B + i, float_vec);\n    }\n\n    for (; i < size; i++) {\n        B[i] = A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_52_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i;\n    for (i = 0; i <= size - 4; i += 4) {\n        float32x4_t vecA = vld1q_f32(&A[i]);\n        float32x4_t vecB = vld1q_f32(&B[i]);\n        float32x4_t vecResult = vdivq_f32(vecA, vecB);\n        int32x4_t vecRounded = vcvtnq_s32_f32(vecResult);\n        vst1q_s32(&C[i], vecRounded);\n    }\n    for (; i < size; i++) {\n        C[i] = lrintf(A[i] / B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_52_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i;\n    for (i = 0; i <= size - 4; i += 4) {\n        float32x4_t vecA = vld1q_f32(&A[i]);\n        float32x4_t vecB = vld1q_f32(&B[i]);\n        float32x4_t vecResult = vdivq_f32(vecA, vecB);\n        int32x4_t vecRounded = vcvtnq_s32_f32(vecResult);\n        vst1q_s32(&C[i], vecRounded);\n    }\n    for (; i < size; i++) {\n        C[i] = lrintf(A[i] / B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_52_Neon", "completion": "```c\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i;\n    for (i = 0; i <= size - 4; i += 4) {\n        float32x4_t vecA = vld1q_f32(&A[i]);\n        float32x4_t vecB = vld1q_f32(&B[i]);\n        float32x4_t vecResult = vdivq_f32(vecA, vecB);\n        int32x4_t vecRounded = vcvtnq_s32_f32(vecResult);\n        vst1q_s32(&C[i], vecRounded);\n    }\n    for (; i < size; i++) {\n        C[i] = lrintf(A[i] / B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_52_Neon", "completion": "```c\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    for (; i <= size - 4; i += 4) {\n        float32x4_t vecA = vld1q_f32(&A[i]);\n        float32x4_t vecB = vld1q_f32(&B[i]);\n        float32x4_t vecResult = vdivq_f32(vecA, vecB);\n        int32x4_t vecRounded = vcvtnq_s32_f32(vecResult);\n        vst1q_s32(&C[i], vecRounded);\n    }\n    for (; i < size; i++) {\n        C[i] = (int32_t)roundf(A[i] / B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_52_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    for (; i <= size - 4; i += 4) {\n        float32x4_t vecA = vld1q_f32(&A[i]);\n        float32x4_t vecB = vld1q_f32(&B[i]);\n        float32x4_t vecResult = vdivq_f32(vecA, vecB);\n        int32x4_t vecIntResult = vcvtq_s32_f32(vrndnq_f32(vecResult));\n        vst1q_s32(&C[i], vecIntResult);\n    }\n    for (; i < size; i++) {\n        C[i] = (int32_t)roundf(A[i] / B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_53_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    float32x4_t max_float = vdupq_n_f32(FLT_MAX);\n    float32x4_t min_float = vdupq_n_f32(-FLT_MAX);\n\n    for (; i <= size - 8; i += 8) {\n        float32x4_t result1, result2;\n        float64x2_t input1 = vld1q_f64(&A[i]);\n        float64x2_t input2 = vld1q_f64(&A[i + 2]);\n        float64x2_t input3 = vld1q_f64(&A[i + 4]);\n        float64x2_t input4 = vld1q_f64(&A[i + 6]);\n\n        float32x2_t temp1 = vcvt_f32_f64(input1);\n        float32x2_t temp2 = vcvt_f32_f64(input2);\n        float32x2_t temp3 = vcvt_f32_f64(input3);\n        float32x2_t temp4 = vcvt_f32_f64(input4);\n\n        result1 = vcombine_f32(temp1, temp2);\n        result2 = vcombine_f32(temp3, temp4);\n\n        result1 = vmaxq_f32(vminq_f32(result1, max_float), min_float);\n        result2 = vmaxq_f32(vminq_f32(result2, max_float), min_float);\n\n        vst1q_f32(&B[i], result1);\n        vst1q_f32(&B[i + 4], result2);\n    }\n\n    for (; i < size; ++i) {\n        double value = A[i];\n        if (value > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (value < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)value;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    float32x4_t max_float = vdupq_n_f32(FLT_MAX);\n    float32x4_t min_float = vdupq_n_f32(-FLT_MAX);\n\n    for (; i <= size - 8; i += 8) {\n        float32x4_t result_low, result_high;\n        float64x2_t input_low = vld1q_f64(&A[i]);\n        float64x2_t input_high = vld1q_f64(&A[i + 2]);\n\n        float32x4_t temp_low = vcvt_f32_f64(input_low);\n        float32x4_t temp_high = vcvt_f32_f64(input_high);\n\n        input_low = vld1q_f64(&A[i + 4]);\n        input_high = vld1q_f64(&A[i + 6]);\n\n        temp_low = vcombine_f32(vmin_f32(vmax_f32(temp_low, min_float), max_float),\n                                vmin_f32(vmax_f32(temp_high, min_float), max_float));\n\n        temp_high = vcvt_f32_f64(input_low);\n        result_high = vcvt_f32_f64(input_high);\n\n        result_high = vcombine_f32(vmin_f32(vmax_f32(temp_high, min_float), max_float),\n                                  vmin_f32(vmax_f32(result_high, min_float), max_float));\n\n        vst1q_f32(&B[i], temp_low);\n        vst1q_f32(&B[i + 4], result_high);\n    }\n\n    for (; i < size; ++i) {\n        double value = A[i];\n        if (value > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (value < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)value;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    float32x4_t max_float = vdupq_n_f32(FLT_MAX);\n    float32x4_t min_float = vdupq_n_f32(-FLT_MAX);\n\n    for (; i <= size - 8; i += 8) {\n        float64x2_t a0 = vld1q_f64(&A[i]);\n        float64x2_t a1 = vld1q_f64(&A[i + 2]);\n        float64x2_t a2 = vld1q_f64(&A[i + 4]);\n        float64x2_t a3 = vld1q_f64(&A[i + 6]);\n\n        float32x4_t b0 = vcvtq_f32_f64(a0);\n        float32x4_t b1 = vcvtq_f32_f64(a1);\n        float32x4_t b2 = vcvtq_f32_f64(a2);\n        float32x4_t b3 = vcvtq_f32_f64(a3);\n\n        b0 = vmaxq_f32(b0, min_float);\n        b0 = vminq_f32(b0, max_float);\n        b1 = vmaxq_f32(b1, min_float);\n        b1 = vminq_f32(b1, max_float);\n        b2 = vmaxq_f32(b2, min_float);\n        b2 = vminq_f32(b2, max_float);\n        b3 = vmaxq_f32(b3, min_float);\n        b3 = vminq_f32(b3, max_float);\n\n        float32x4x2_t b_interleaved = vzipq_f32(b0, b2);\n        float32x4x2_t c_interleaved = vzipq_f32(b1, b3);\n\n        vst1q_f32(&B[i], b_interleaved.val[0]);\n        vst1q_f32(&B[i + 4], b_interleaved.val[1]);\n        vst1q_f32(&B[i + 8], c_interleaved.val[0]);\n        vst1q_f32(&B[i + 12], c_interleaved.val[1]);\n    }\n\n    for (; i < size; ++i) {\n        double val = A[i];\n        if (val > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (val < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    float32x4_t max_float = vdupq_n_f32(FLT_MAX);\n    float32x4_t min_float = vdupq_n_f32(-FLT_MAX);\n\n    for (; i <= size - 8; i += 8) {\n        float32x4_t result_low, result_high;\n        float64x2_t input_low = vld1q_f64(A + i);\n        float64x2_t input_high = vld1q_f64(A + i + 2);\n\n        result_low = vcvt_f32_f64(input_low);\n        result_high = vcvt_f32_f64(input_high);\n\n        input_low = vld1q_f64(A + i + 4);\n        input_high = vld1q_f64(A + i + 6);\n\n        result_low = vmaxq_f32(result_low, min_float);\n        result_high = vmaxq_f32(result_high, min_float);\n\n        result_low = vminq_f32(result_low, max_float);\n        result_high = vminq_f32(result_high, max_float);\n\n        float32x4_t combined_result = vcombine_f32(result_low, result_high);\n\n        result_low = vcvt_f32_f64(input_low);\n        result_high = vcvt_f32_f64(input_high);\n\n        result_low = vmaxq_f32(result_low, min_float);\n        result_high = vmaxq_f32(result_high, min_float);\n\n        result_low = vminq_f32(result_low, max_float);\n        result_high = vminq_f32(result_high, max_float);\n\n        combined_result = vcombine_f32(combined_result, vcombine_f32(result_low, result_high));\n\n        vst1q_f32(B + i, combined_result);\n    }\n\n    for (; i < size; ++i) {\n        double value = A[i];\n        if (value > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (value < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)value;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    float32x4_t max_float = vdupq_n_f32(FLT_MAX);\n    float32x4_t min_float = vdupq_n_f32(-FLT_MAX);\n\n    for (; i <= size - 8; i += 8) {\n        float32x4_t result_low, result_high;\n        float64x2_t input_low = vld1q_f64(&A[i]);\n        float64x2_t input_high = vld1q_f64(&A[i + 2]);\n\n        float32x2_t temp_low = vcvt_f32_f64(input_low);\n        float32x2_t temp_high = vcvt_f32_f64(input_high);\n\n        input_low = vld1q_f64(&A[i + 4]);\n        input_high = vld1q_f64(&A[i + 6]);\n\n        temp_low = vmax_f32(vmin_f32(temp_low, max_float), min_float);\n        temp_high = vmax_f32(vmin_f32(temp_high, max_float), min_float);\n\n        result_low = vcombine_f32(temp_low, temp_high);\n\n        temp_low = vcvt_f32_f64(input_low);\n        temp_high = vcvt_f32_f64(input_high);\n\n        temp_low = vmax_f32(vmin_f32(temp_low, max_float), min_float);\n        temp_high = vmax_f32(vmin_f32(temp_high, max_float), min_float);\n\n        result_high = vcombine_f32(temp_low, temp_high);\n\n        vst1q_f32(&B[i], result_low);\n        vst1q_f32(&B[i + 4], result_high);\n    }\n\n    for (; i < size; ++i) {\n        double value = A[i];\n        if (value > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (value < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)value;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_54_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i;\n    for (i = 0; i <= size - 8; i += 8) {\n        int16x8_t input = vld1q_s16(A + i);\n        int32x4_t output_low = vmovl_s16(vget_low_s16(input));\n        int32x4_t output_high = vmovl_s16(vget_high_s16(input));\n        vst1q_s32(B + i, output_low);\n        vst1q_s32(B + i + 4, output_high);\n    }\n    for (; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54_Neon", "completion": "```c\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i;\n    for (i = 0; i <= size - 8; i += 8) {\n        int16x8_t input = vld1q_s16(&A[i]);\n        int32x4_t output_low = vmovl_s16(vget_low_s16(input));\n        int32x4_t output_high = vmovl_s16(vget_high_s16(input));\n        vst1q_s32(&B[i], output_low);\n        vst1q_s32(&B[i + 4], output_high);\n    }\n    for (; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54_Neon", "completion": "```c\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i;\n    for (i = 0; i <= size - 8; i += 8) {\n        int16x8_t input = vld1q_s16(A + i);\n        int32x4_t output_low = vmovl_s16(vget_low_s16(input));\n        int32x4_t output_high = vmovl_s16(vget_high_s16(input));\n        vst1q_s32(B + i, output_low);\n        vst1q_s32(B + i + 4, output_high);\n    }\n    for (; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54_Neon", "completion": "```cpp\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    for (; i <= size - 8; i += 8) {\n        int16x8_t input = vld1q_s16(&A[i]);\n        int32x4_t output1 = vmovl_s16(vget_low_s16(input));\n        int32x4_t output2 = vmovl_s16(vget_high_s16(input));\n        vst1q_s32(&B[i], output1);\n        vst1q_s32(&B[i + 4], output2);\n    }\n    for (; i < size; ++i) {\n        B[i] = static_cast<int32_t>(A[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_54_Neon", "completion": "```cpp\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    for (; i <= size - 8; i += 8) {\n        int16x8_t input = vld1q_s16(A + i);\n        int32x4_t output1 = vmovl_s16(vget_low_s16(input));\n        int32x4_t output2 = vmovl_s16(vget_high_s16(input));\n        vst1q_s32(B + i, output1);\n        vst1q_s32(B + i + 4, output2);\n    }\n    for (; i < size; ++i) {\n        B[i] = static_cast<int32_t>(A[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_55_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float32x4_t v_min = vdupq_n_f32(min_val);\n    float32x4_t v_max = vdupq_n_f32(max_val);\n    float32x4_t v_one = vdupq_n_f32(1.0f);\n    float32x4_t v_zero = vdupq_n_f32(0.0f);\n\n    size_t i = 0;\n    for (; i <= size - 4; i += 4) {\n        int32x4_t v_control = vld1q_s32(control + i);\n        uint32x4_t mask_gt_zero = vcgtq_s32(v_control, vdupq_n_s32(0));\n\n        float32x4_t v_a = vld1q_f32(A + i);\n        float32x4_t v_normalized = vsubq_f32(v_a, v_min);\n        v_normalized = vdivq_f32(v_normalized, vsubq_f32(v_max, v_min));\n        v_normalized = vmaxq_f32(v_normalized, v_zero);\n        v_normalized = vminq_f32(v_normalized, v_one);\n\n        float32x4_t v_result = vbslq_f32(mask_gt_zero, v_normalized, v_a);\n        vst1q_f32(B + i, v_result);\n    }\n\n    for (; i < size; ++i) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            val = val < 0.0f ? 0.0f : val;\n            val = val > 1.0f ? 1.0f : val;\n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float32x4_t v_min = vdupq_n_f32(min_val);\n    float32x4_t v_max = vdupq_n_f32(max_val);\n    float32x4_t v_one = vdupq_n_f32(1.0f);\n    float32x4_t v_zero = vdupq_n_f32(0.0f);\n\n    size_t i = 0;\n    for (; i <= size - 4; i += 4) {\n        int32x4_t v_control = vld1q_s32(control + i);\n        uint32x4_t mask_gt_zero = vcgtq_s32(v_control, vdupq_n_s32(0));\n\n        float32x4_t v_a = vld1q_f32(A + i);\n        float32x4_t v_normalized = vsubq_f32(v_a, v_min);\n        v_normalized = vdivq_f32(v_normalized, vsubq_f32(v_max, v_min));\n        v_normalized = vmaxq_f32(v_normalized, v_zero);\n        v_normalized = vminq_f32(v_normalized, v_one);\n\n        float32x4_t v_result = vbslq_f32(mask_gt_zero, v_normalized, v_a);\n        vst1q_f32(B + i, v_result);\n    }\n\n    for (; i < size; i++) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            val = val < 0.0f ? 0.0f : val;\n            val = val > 1.0f ? 1.0f : val;\n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float32x4_t v_min = vdupq_n_f32(min_val);\n    float32x4_t v_max = vdupq_n_f32(max_val);\n    float32x4_t v_one = vdupq_n_f32(1.0f);\n    float32x4_t v_zero = vdupq_n_f32(0.0f);\n\n    size_t i = 0;\n    for (; i <= size - 4; i += 4) {\n        int32x4_t v_control = vld1q_s32(control + i);\n        uint32x4_t mask_gt_zero = vcgtq_s32(v_control, vdupq_n_s32(0));\n\n        float32x4_t v_a = vld1q_f32(A + i);\n        float32x4_t v_normalized = vsubq_f32(v_a, v_min);\n        v_normalized = vdivq_f32(v_normalized, vsubq_f32(v_max, v_min));\n        v_normalized = vmaxq_f32(v_normalized, v_zero);\n        v_normalized = vminq_f32(v_normalized, v_one);\n\n        float32x4_t v_result = vbslq_f32(mask_gt_zero, v_normalized, v_a);\n        vst1q_f32(B + i, v_result);\n    }\n\n    for (; i < size; i++) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            val = val < 0.0f ? 0.0f : val;\n            val = val > 1.0f ? 1.0f : val;\n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float32x4_t v_min = vdupq_n_f32(min_val);\n    float32x4_t v_max = vdupq_n_f32(max_val);\n    float32x4_t v_one = vdupq_n_f32(1.0f);\n    float32x4_t v_zero = vdupq_n_f32(0.0f);\n\n    size_t i = 0;\n    for (; i <= size - 4; i += 4) {\n        int32x4_t v_control = vld1q_s32(control + i);\n        uint32x4_t mask_gt_zero = vcgtq_s32(v_control, vdupq_n_s32(0));\n\n        float32x4_t v_a = vld1q_f32(A + i);\n        float32x4_t v_normalized = vsubq_f32(v_a, v_min);\n        v_normalized = vdivq_f32(v_normalized, vsubq_f32(v_max, v_min));\n        v_normalized = vmaxq_f32(v_normalized, v_zero);\n        v_normalized = vminq_f32(v_normalized, v_one);\n\n        float32x4_t v_result = vbslq_f32(mask_gt_zero, v_normalized, v_a);\n        vst1q_f32(B + i, v_result);\n    }\n\n    for (; i < size; i++) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            val = val < 0.0f ? 0.0f : val;\n            val = val > 1.0f ? 1.0f : val;\n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float32x4_t v_min = vdupq_n_f32(min_val);\n    float32x4_t v_max = vdupq_n_f32(max_val);\n    float32x4_t v_one = vdupq_n_f32(1.0f);\n    float32x4_t v_zero = vdupq_n_f32(0.0f);\n\n    size_t i = 0;\n    for (; i <= size - 4; i += 4) {\n        int32x4_t v_control = vld1q_s32(control + i);\n        uint32x4_t mask_gt_zero = vcgtq_s32(v_control, vdupq_n_s32(0));\n\n        float32x4_t v_a = vld1q_f32(A + i);\n        float32x4_t v_normalized = vsubq_f32(v_a, v_min);\n        v_normalized = vdivq_f32(v_normalized, vsubq_f32(v_max, v_min));\n\n        v_normalized = vmaxq_f32(v_normalized, v_zero);\n        v_normalized = vminq_f32(v_normalized, v_one);\n\n        float32x4_t v_result = vbslq_f32(mask_gt_zero, v_normalized, v_a);\n        vst1q_f32(B + i, v_result);\n    }\n\n    for (; i < size; i++) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            val = val < 0.0f ? 0.0f : val;\n            val = val > 1.0f ? 1.0f : val;\n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_56_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    for (; i <= size - 4; i += 4) {\n        uint32x4_t input = vld1q_u32(A + i);\n        uint32x4_t high_bits = vshrq_n_u32(input, 16);\n        float32x4_t float_values = vcvtq_f32_u32(high_bits);\n        float32x4_t sqrt_values = vsqrtq_f32(float_values);\n        vst1q_f32(B + i, sqrt_values);\n    }\n    for (; i < size; i++) {\n        uint32_t high_bits = A[i] >> 16;\n        float float_value = (float)high_bits;\n        B[i] = sqrtf(float_value);\n    }\n}\n```"}
{"task_id": "SimdBench_56_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    for (; i <= size - 4; i += 4) {\n        uint32x4_t input = vld1q_u32(A + i);\n        uint32x4_t high_bits = vshrq_n_u32(input, 16);\n        float32x4_t float_values = vcvtq_f32_u32(high_bits);\n        float32x4_t sqrt_values = vsqrtq_f32(float_values);\n        vst1q_f32(B + i, sqrt_values);\n    }\n    for (; i < size; i++) {\n        uint32_t high_bits = A[i] >> 16;\n        float float_value = (float)high_bits;\n        B[i] = sqrtf(float_value);\n    }\n}\n```"}
{"task_id": "SimdBench_56_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    for (; i <= size - 4; i += 4) {\n        uint32x4_t input = vld1q_u32(A + i);\n        uint32x4_t high_bits = vshrq_n_u32(input, 16);\n        float32x4_t float_values = vcvtq_f32_u32(high_bits);\n        float32x4_t sqrt_values = vsqrtq_f32(float_values);\n        vst1q_f32(B + i, sqrt_values);\n    }\n    for (; i < size; ++i) {\n        uint32_t high_bits = A[i] >> 16;\n        float float_value = (float)high_bits;\n        B[i] = sqrtf(float_value);\n    }\n}\n```"}
{"task_id": "SimdBench_56_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    for (; i <= size - 4; i += 4) {\n        uint32x4_t input = vld1q_u32(A + i);\n        uint32x4_t high_bits = vshrq_n_u32(input, 16);\n        float32x4_t float_values = vcvtq_f32_u32(high_bits);\n        float32x4_t sqrt_values = vsqrtq_f32(float_values);\n        vst1q_f32(B + i, sqrt_values);\n    }\n    for (; i < size; ++i) {\n        uint32_t high_bits = A[i] >> 16;\n        float float_value = (float)high_bits;\n        B[i] = sqrtf(float_value);\n    }\n}\n```"}
{"task_id": "SimdBench_56_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    for (; i <= size - 4; i += 4) {\n        uint32x4_t input = vld1q_u32(A + i);\n        uint32x4_t high_bits = vshrq_n_u32(input, 16);\n        float32x4_t float_values = vcvtq_f32_u32(high_bits);\n        float32x4_t sqrt_values = vsqrtq_f32(float_values);\n        vst1q_f32(B + i, sqrt_values);\n    }\n    for (; i < size; ++i) {\n        uint32_t high_bits = A[i] >> 16;\n        float float_value = (float)high_bits;\n        B[i] = sqrtf(float_value);\n    }\n}\n```"}
{"task_id": "SimdBench_57_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    for (; i <= size - 4; i += 4) {\n        uint32x4_t int_vec = vld1q_u32(&A[i]);\n        float32x4_t float_vec = vreinterpretq_f32_u32(int_vec);\n        vst1q_f32(&B[i], float_vec);\n    }\n    for (; i < size; i++) {\n        B[i] = reinterpret_cast<const float&>(A[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_57_Neon", "completion": "```c\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    for (; i <= size - 4; i += 4) {\n        uint32x4_t int_vec = vld1q_u32(&A[i]);\n        float32x4_t float_vec = vreinterpretq_f32_u32(int_vec);\n        vst1q_f32(&B[i], float_vec);\n    }\n    for (; i < size; ++i) {\n        B[i] = reinterpret_cast<const float&>(A[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_57_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    for (; i <= size - 4; i += 4) {\n        uint32x4_t int_vec = vld1q_u32(A + i);\n        float32x4_t float_vec = vreinterpretq_f32_u32(int_vec);\n        vst1q_f32(B + i, float_vec);\n    }\n    for (; i < size; ++i) {\n        B[i] = reinterpret_cast<const float&>(A[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_57_Neon", "completion": "```c\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    for (; i <= size - 4; i += 4) {\n        uint32x4_t int_vec = vld1q_u32(&A[i]);\n        float32x4_t float_vec = vreinterpretq_f32_u32(int_vec);\n        vst1q_f32(&B[i], float_vec);\n    }\n    for (; i < size; ++i) {\n        B[i] = reinterpret_cast<const float&>(A[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_57_Neon", "completion": "```cpp\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    for (; i <= size - 4; i += 4) {\n        uint32x4_t int_vec = vld1q_u32(&A[i]);\n        float32x4_t float_vec = vreinterpretq_f32_u32(int_vec);\n        vst1q_f32(&B[i], float_vec);\n    }\n    for (; i < size; ++i) {\n        B[i] = reinterpret_cast<const float&>(A[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_58_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    size_t i = 0;\n    if (size > 0) {\n        diff[0] = 0.0f;\n    }\n\n    uint8x16_t true_mask = vmovq_n_u8(0xFF);\n    uint8x16_t false_mask = vmovq_n_u8(0x00);\n\n    for (; i <= size - 16; i += 16) {\n        int32x4_t a0 = vld1q_s32(&A[i]);\n        int32x4_t a1 = vld1q_s32(&A[i + 1]);\n        int32x4_t a2 = vld1q_s32(&A[i + 2]);\n        int32x4_t a3 = vld1q_s32(&A[i + 3]);\n\n        int32x4_t diff0 = vsubq_s32(a1, a0);\n        int32x4_t diff1 = vsubq_s32(a2, a1);\n        int32x4_t diff2 = vsubq_s32(a3, a2);\n\n        uint8x16_t c0 = vld1q_u8((const uint8_t*)&cond[i]);\n        uint8x16_t c1 = vld1q_u8((const uint8_t*)&cond[i + 4]);\n        uint8x16_t c2 = vld1q_u8((const uint8_t*)&cond[i + 8]);\n        uint8x16_t c3 = vld1q_u8((const uint8_t*)&cond[i + 12]);\n\n        uint8x16_t mask0 = vreinterpretq_u8_u32(vandq_u32(vreinterpretq_u32_u8(c0), true_mask));\n        uint8x16_t mask1 = vreinterpretq_u8_u32(vandq_u32(vreinterpretq_u32_u8(c1), true_mask));\n        uint8x16_t mask2 = vreinterpretq_u8_u32(vandq_u32(vreinterpretq_u32_u8(c2), true_mask));\n        uint8x16_t mask3 = vreinterpretq_u8_u32(vandq_u32(vreinterpretq_u32_u8(c3), true_mask));\n\n        float32x4_t f_diff0 = vcvtq_f32_s32(diff0);\n        float32x4_t f_diff1 = vcvtq_f32_s32(diff1);\n        float32x4_t f_diff2 = vcvtq_f32_s32(diff2);\n\n        float32x4_t zero = vmovq_n_f32(0.0f);\n\n        float32x4_t result0 = vbslq_f32(mask0, f_diff0, zero);\n        float32x4_t result1 = vbslq_f32(mask1, f_diff1, zero);\n        float32x4_t result2 = vbslq_f32(mask2, f_diff2, zero);\n        float32x4_t result3 = vbslq_f32(mask3, f_diff3, zero);\n\n        vst1q_f32(&diff[i + 1], result0);\n        vst1q_f32(&diff[i + 5], result1);\n        vst1q_f32(&diff[i + 9], result2);\n        vst1q_f32(&diff[i + 13], result3);\n    }\n\n    for (; i < size; ++i) {\n        diff[i] = cond[i] ? static_cast<float>(A[i] - A[i - 1]) : 0.0f;\n    }\n}\n```"}
{"task_id": "SimdBench_58_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    size_t i = 0;\n    diff[0] = 0.0f;\n\n    for (; i <= size - 4; i += 4) {\n        uint32x4_t cond_vec = vld1_u32((const uint32_t*)(cond + i));\n        int32x4_t a_vec = vld1q_s32(A + i);\n        int32x4_t prev_a_vec = vld1q_s32(A + i - 1);\n\n        int32x4_t diff_int_vec = vsubq_s32(a_vec, prev_a_vec);\n        float32x4_t diff_float_vec = vcvtq_f32_s32(diff_int_vec);\n\n        uint32x4_t mask = vceqq_u32(cond_vec, vdupq_n_u32(1));\n        float32x4_t zero_vec = vdupq_n_f32(0.0f);\n        float32x4_t result_vec = vbslq_f32(mask, diff_float_vec, zero_vec);\n\n        vst1q_f32(diff + i, result_vec);\n    }\n\n    for (; i < size; i++) {\n        diff[i] = cond[i] ? (float)(A[i] - A[i - 1]) : 0.0f;\n    }\n}\n```"}
{"task_id": "SimdBench_58_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    size_t i = 0;\n    float32x4_t zero = vdupq_n_f32(0.0f);\n\n    // Handle the first element separately\n    diff[0] = 0.0f;\n\n    // Process 4 elements at a time\n    for (; i <= size - 4; i += 4) {\n        uint32x4_t condition = vld1q_u32((const uint32_t*)&cond[i]);\n        int32x4_t current = vld1q_s32(&A[i]);\n        int32x4_t previous = vld1q_s32(&A[i - 1]);\n\n        int32x4_t differences = vsubq_s32(current, previous);\n        float32x4_t float_differences = vcvtq_f32_s32(differences);\n\n        uint32x4_t mask = vceqq_u32(condition, vdupq_n_u32(1));\n        float32x4_t result = vbslq_f32(mask, float_differences, zero);\n\n        vst1q_f32(&diff[i], result);\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        diff[i] = cond[i] ? (float)(A[i] - A[i - 1]) : 0.0f;\n    }\n}\n```"}
{"task_id": "SimdBench_58_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    size_t i = 0;\n    diff[0] = 0.0f;\n\n    for (; i <= size - 4; i += 4) {\n        uint32x4_t cond_vec = vld1_u32((const uint32_t*)&cond[i]);\n        int32x4_t a_vec = vld1q_s32(&A[i]);\n        int32x4_t prev_a_vec = vld1q_s32(&A[i - 1]);\n\n        int32x4_t diff_int_vec = vsubq_s32(a_vec, prev_a_vec);\n        float32x4_t diff_float_vec = vcvtq_f32_s32(diff_int_vec);\n\n        uint32x4_t mask_vec = vceqq_u32(cond_vec, vdupq_n_u32(1));\n        float32x4_t zero_vec = vdupq_n_f32(0.0f);\n\n        float32x4_t result_vec = vbslq_f32(mask_vec, diff_float_vec, zero_vec);\n\n        vst1q_f32(&diff[i], result_vec);\n    }\n\n    for (; i < size; ++i) {\n        diff[i] = cond[i] ? static_cast<float>(A[i] - A[i - 1]) : 0.0f;\n    }\n}\n```"}
{"task_id": "SimdBench_58_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    size_t i = 0;\n    diff[0] = 0.0f;\n\n    for (; i <= size - 4; i += 4) {\n        uint32x4_t cond_vec = vld1_u32((const uint32_t*)(cond + i));\n        int32x4_t a_vec = vld1q_s32(A + i);\n        int32x4_t prev_a_vec = vld1q_s32(A + i - 1);\n\n        int32x4_t diff_int_vec = vsubq_s32(a_vec, prev_a_vec);\n        float32x4_t diff_float_vec = vcvtq_f32_s32(diff_int_vec);\n\n        uint32x4_t zero_mask = vceqq_u32(cond_vec, vdupq_n_u32(0));\n        float32x4_t zero_vec = vdupq_n_f32(0.0f);\n        float32x4_t result_vec = vbslq_f32(zero_mask, zero_vec, diff_float_vec);\n\n        vst1q_f32(diff + i, result_vec);\n    }\n\n    for (; i < size; i++) {\n        diff[i] = cond[i] ? (float)(A[i] - A[i - 1]) : 0.0f;\n    }\n}\n```"}
{"task_id": "SimdBench_59_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    uint32x4_t ones = vdupq_n_u32(0xFFFFFFFF);\n    uint32x4_t high_ones = vshlq_n_u32(ones, 32);\n\n    for (; i <= length - 4; i += 4) {\n        uint32x4_t src_vec = vld1q_u32(&src[i]);\n        uint64x2_t low_part = vmovl_u32(src_vec);\n        uint64x2_t high_part = vreinterpretq_u64_u32(high_ones);\n        uint64x2_t result = vorrq_u64(low_part, high_part);\n        vst1q_u64(&dst[i], result);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = 0xFFFFFFFF00000000ULL | src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_59_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    uint32x4_t ones = vdupq_n_u32(0xFFFFFFFF);\n    uint32x4_t high_ones = vshlq_n_u32(ones, 32);\n\n    for (; i <= length - 4; i += 4) {\n        uint32x4_t src_vec = vld1q_u32(&src[i]);\n        uint64x2_t low = vmovl_u32(src_vec);\n        uint64x2_t high = vorrq_u64(low, high_ones);\n        vst1q_u64(&dst[i], high);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = ((uint64_t)0xFFFFFFFF << 32) | src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_59_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    uint32x4_t ones = vdupq_n_u32(0xFFFFFFFF);\n    uint32x4_t high_ones = vshlq_n_u32(ones, 32);\n\n    for (; i <= length - 4; i += 4) {\n        uint32x4_t src_vec = vld1q_u32(&src[i]);\n        uint64x2_t low_part = vmovl_u32(src_vec);\n        uint64x2_t high_part = vreinterpretq_u64_u32(high_ones);\n        uint64x2_t result = vorrq_u64(low_part, high_part);\n        vst1q_u64(&dst[i], result);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = 0xFFFFFFFF00000000ULL | src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_59_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    uint32x4_t ones = vdupq_n_u32(0xFFFFFFFF);\n    uint32x4_t high_ones = vshlq_n_u32(ones, 32);\n\n    for (; i <= length - 4; i += 4) {\n        uint32x4_t src_vec = vld1q_u32(&src[i]);\n        uint64x2_t low = vmovl_u32(src_vec);\n        uint64x2_t high = vorrq_u64(low, high_ones);\n        vst1q_u64(&dst[i], high);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = ((uint64_t)0xFFFFFFFF << 32) | src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_59_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    uint32x4_t ones = vdupq_n_u32(0xFFFFFFFF);\n    uint32x4_t high_bits = vshlq_n_u32(ones, 32);\n\n    for (; i <= length - 4; i += 4) {\n        uint32x4_t low_bits = vld1q_u32(&src[i]);\n        uint64x2_t result_low = vmovl_u32(vget_low_u32(low_bits));\n        uint64x2_t result_high = vmovl_u32(vget_high_u32(low_bits));\n        result_low = vorrq_u64(result_low, high_bits);\n        result_high = vorrq_u64(result_high, high_bits);\n        vst1q_u64(&dst[i], result_low);\n        vst1q_u64(&dst[i + 2], result_high);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = ((uint64_t)0xFFFFFFFF << 32) | src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_60_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double result = 0.0;\n    float64x2_t sum = vdupq_n_f64(0.0);\n\n    for (size_t i = 0; i <= length - 4; i += 4) {\n        int16x4_t idx = vld1_s16(index + i);\n        uint16x4_t uidx = vreinterpret_u16_s16(idx);\n        uint32x2_t idx_low = vget_low_u32(vmovl_u16(vget_low_u16(uidx)));\n        uint32x2_t idx_high = vget_high_u32(vmovl_u16(vget_high_u16(uidx)));\n\n        float64x2_t vec_low = vld1q_f64(vec + vgetq_lane_u32(idx_low, 0));\n        vec_low = vsetq_lane_f64(vec[vgetq_lane_u32(idx_low, 1)], vec_low, 1);\n\n        float64x2_t vec_high = vld1q_f64(vec + vgetq_lane_u32(idx_high, 0));\n        vec_high = vsetq_lane_f64(vec[vgetq_lane_u32(idx_high, 1)], vec_high, 1);\n\n        sum = vaddq_f64(sum, vec_low);\n        sum = vaddq_f64(sum, vec_high);\n    }\n\n    for (size_t i = (length / 4) * 4; i < length; ++i) {\n        result += vec[index[i]];\n    }\n\n    float64x1_t sum_low = vget_low_f64(sum);\n    float64x1_t sum_high = vget_high_f64(sum);\n    result += vget_lane_f64(sum_low, 0) + vget_lane_f64(sum_high, 0);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_60_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double sum[2] = {0.0, 0.0};\n    float64x2_t sum_vec = vdupq_n_f64(0.0);\n\n    for (size_t i = 0; i <= length - 4; i += 4) {\n        int16x4_t idx_vec = vld1_s16(index + i);\n        uint16x4_t idx_vec_u =vreinterpret_u16_s16(idx_vec);\n\n        uint32x2_t idx_low = vget_low_u32(vreinterpret_u32_u16(idx_vec_u));\n        uint32x2_t idx_high = vget_high_u32(vreinterpret_u32_u16(idx_vec_u));\n\n        float64x2_t vec_low = vld1q_f64(vec + vget_lane_u32(idx_low, 0));\n        vec_low = vsetq_lane_f64(vec[vget_lane_u32(idx_low, 1)], vec_low, 1);\n\n        float64x2_t vec_high = vld1q_f64(vec + vget_lane_u32(idx_high, 0));\n        vec_high = vsetq_lane_f64(vec[vget_lane_u32(idx_high, 1)], vec_high, 1);\n\n        sum_vec = vaddq_f64(sum_vec, vec_low);\n        sum_vec = vaddq_f64(sum_vec, vec_high);\n    }\n\n    vst1q_f64(sum, sum_vec);\n\n    for (size_t i = (length & ~3); i < length; ++i) {\n        sum[0] += vec[index[i]];\n    }\n\n    return sum[0] + sum[1];\n}\n```"}
{"task_id": "SimdBench_60_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double result = 0.0;\n    float64x2_t sum = vdupq_n_f64(0.0);\n\n    for (size_t i = 0; i <= length - 4; i += 4) {\n        int16x4_t idx = vld1_s16(index + i);\n        uint16x4_t uidx = vreinterpret_u16_s16(idx);\n        uint32x2_t idx_low = vget_low_u32(vmovl_u16(vget_low_u16(uidx)));\n        uint32x2_t idx_high = vget_high_u32(vmovl_u16(vget_high_u16(uidx)));\n\n        float64x2_t vec_low = vld1q_f64(vec + vgetq_lane_u32(idx_low, 0));\n        vec_low = vsetq_lane_f64(vec[vgetq_lane_u32(idx_low, 1)], vec_low, 1);\n\n        float64x2_t vec_high = vld1q_f64(vec + vgetq_lane_u32(idx_high, 0));\n        vec_high = vsetq_lane_f64(vec[vgetq_lane_u32(idx_high, 1)], vec_high, 1);\n\n        sum = vaddq_f64(sum, vec_low);\n        sum = vaddq_f64(sum, vec_high);\n    }\n\n    for (size_t i = (length / 4) * 4; i < length; ++i) {\n        result += vec[index[i]];\n    }\n\n    float64x1_t sum_low = vget_low_f64(sum);\n    float64x1_t sum_high = vget_high_f64(sum);\n    result += vget_lane_f64(sum_low, 0) + vget_lane_f64(sum_high, 0);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_60_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double result = 0.0;\n    float64x2_t sum = vdupq_n_f64(0.0);\n\n    for (size_t i = 0; i <= length - 4; i += 4) {\n        int16x4_t idx = vld1_s16(index + i);\n        uint16x4_t uidx = vreinterpret_u16_s16(idx);\n        uint32x2_t idx_low = vget_low_u32(vmovl_u16(vget_low_u16(uidx)));\n        uint32x2_t idx_high = vget_high_u32(vmovl_u16(vget_high_u16(uidx)));\n\n        float64x2_t vec_low = vld1q_f64(vec + vgetq_lane_u32(idx_low, 0));\n        vec_low = vsetq_lane_f64(vec[vgetq_lane_u32(idx_low, 1)], vec_low, 1);\n\n        float64x2_t vec_high = vld1q_f64(vec + vgetq_lane_u32(idx_high, 0));\n        vec_high = vsetq_lane_f64(vec[vgetq_lane_u32(idx_high, 1)], vec_high, 1);\n\n        sum = vaddq_f64(sum, vec_low);\n        sum = vaddq_f64(sum, vec_high);\n    }\n\n    result += vgetq_lane_f64(sum, 0) + vgetq_lane_f64(sum, 1);\n\n    for (size_t i = (length / 4) * 4; i < length; ++i) {\n        result += vec[index[i]];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_60_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double result = 0.0;\n    float64x2_t sum = vdupq_n_f64(0.0);\n\n    for (size_t i = 0; i <= length - 4; i += 4) {\n        int16x4_t idx = vld1_s16(index + i);\n        uint16x4_t uidx = vreinterpret_u16_s16(idx);\n        uint32x2_t idx_low = vget_low_u32(vmovl_u16(vget_low_u16(uidx)));\n        uint32x2_t idx_high = vget_high_u32(vmovl_u16(vget_high_u16(uidx)));\n\n        float64x2_t vec_low = vld1q_f64(vec + vgetq_lane_u32(idx_low, 0));\n        vec_low = vsetq_lane_f64(vec[vgetq_lane_u32(idx_low, 1)], vec_low, 1);\n\n        float64x2_t vec_high = vld1q_f64(vec + vgetq_lane_u32(idx_high, 0));\n        vec_high = vsetq_lane_f64(vec[vgetq_lane_u32(idx_high, 1)], vec_high, 1);\n\n        sum = vaddq_f64(sum, vec_low);\n        sum = vaddq_f64(sum, vec_high);\n    }\n\n    result += vgetq_lane_f64(sum, 0) + vgetq_lane_f64(sum, 1);\n\n    for (size_t i = (length & ~3); i < length; ++i) {\n        result += vec[index[i]];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_61_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    size_t kernel_area = kernel_size * kernel_size;\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t m = 0; m < kernel_size; ++m) {\n                for (size_t n = 0; n < kernel_size; n += 2) {\n                    uint64x2_t input_vec = vld1q_u64((const uint64_t*)&input[(i + m) * input_size + j + n]);\n                    uint64x2_t kernel_vec = vld1q_u64((const uint64_t*)&kernel[m * kernel_size + n]);\n                    float64x2_t input_fvec = vcvt_f64_u64(input_vec);\n                    float64x2_t kernel_fvec = vcvt_f64_u64(kernel_vec);\n                    float64x2_t prod = vmulq_f64(input_fvec, kernel_fvec);\n                    sum += vgetq_lane_f64(prod, 0) + vgetq_lane_f64(prod, 1);\n                }\n            }\n            output[i * output_size + j] = (sum > 0.0) ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t m = 0; m < kernel_size; ++m) {\n                for (size_t n = 0; n < kernel_size; n += 2) {\n                    uint64x2_t input_vec = vld1q_u64((const uint64_t*)&input[(i + m) * input_size + j + n]);\n                    uint64x2_t kernel_vec = vld1q_u64((const uint64_t*)&kernel[m * kernel_size + n]);\n                    float64x2_t input_fvec = vcvt_f64_u64(input_vec);\n                    float64x2_t kernel_fvec = vcvt_f64_u64(kernel_vec);\n                    float64x2_t prod = vmulq_f64(input_fvec, kernel_fvec);\n                    sum += vgetq_lane_f64(prod, 0) + vgetq_lane_f64(prod, 1);\n                }\n            }\n            output[i * output_size + j] = sum > 0.0 ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t m = 0; m < kernel_size; ++m) {\n                for (size_t n = 0; n < kernel_size; n += 2) {\n                    uint64x2_t input_vec = vld1q_u64((const uint64_t*)&input[(i + m) * input_size + j + n]);\n                    uint64x2_t kernel_vec = vld1q_u64((const uint64_t*)&kernel[m * kernel_size + n]);\n                    float64x2_t input_fvec = vcvt_f64_u64(input_vec);\n                    float64x2_t kernel_fvec = vcvt_f64_u64(kernel_vec);\n                    float64x2_t prod = vmulq_f64(input_fvec, kernel_fvec);\n                    sum += vgetq_lane_f64(prod, 0) + vgetq_lane_f64(prod, 1);\n                }\n            }\n            output[i * output_size + j] = sum > 0.0 ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t m = 0; m < kernel_size; ++m) {\n                for (size_t n = 0; n < kernel_size; n += 2) {\n                    uint64x2_t input_vec = vld1q_u64((const uint64_t*)&input[(i + m) * input_size + j + n]);\n                    uint64x2_t kernel_vec = vld1q_u64((const uint64_t*)&kernel[m * kernel_size + n]);\n                    float64x2_t input_fvec = vcvt_f64_u64(input_vec);\n                    float64x2_t kernel_fvec = vcvt_f64_u64(kernel_vec);\n                    float64x2_t prod = vmulq_f64(input_fvec, kernel_fvec);\n                    sum += vgetq_lane_f64(prod, 0) + vgetq_lane_f64(prod, 1);\n                }\n            }\n            output[i * output_size + j] = sum > 0.0 ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    size_t kernel_area = kernel_size * kernel_size;\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t m = 0; m < kernel_size; ++m) {\n                for (size_t n = 0; n < kernel_size; n += 2) {\n                    uint64x2_t input_vec = vld1q_u64((const uint64_t*)&input[(i + m) * input_size + j + n]);\n                    uint64x2_t kernel_vec = vld1q_u64((const uint64_t*)&kernel[m * kernel_size + n]);\n                    float64x2_t input_fvec = vcvt_f64_u64(input_vec);\n                    float64x2_t kernel_fvec = vcvt_f64_u64(kernel_vec);\n                    float64x2_t prod = vmulq_f64(input_fvec, kernel_fvec);\n                    sum += vaddvq_f64(prod);\n                }\n            }\n            output[i * output_size + j] = (sum > 0.0) ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_62_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    if (numbers.size() < 2) {\n        return false;\n    }\n\n    float64x2_t threshold_vec = vdupq_n_f64(threshold);\n\n    for (size_t i = 0; i < numbers.size(); i += 2) {\n        float64x2_t vec1 = vld1q_f64(&numbers[i]);\n\n        for (size_t j = i + 2; j < numbers.size(); j += 2) {\n            float64x2_t vec2 = vld1q_f64(&numbers[j]);\n\n            float64x2_t diff1 = vabsq_f64(vsubq_f64(vec1, vec2));\n            uint64x2_t mask1 = vcltq_f64(diff1, threshold_vec);\n\n            if (vmaxvq_u64(mask1)) {\n                return true;\n            }\n\n            if (j + 1 < numbers.size()) {\n                float64x2_t vec2_single = vsetq_lane_f64(numbers[j + 1], vec2, 1);\n                float64x2_t diff2 = vabsq_f64(vsubq_f64(vec1, vec2_single));\n                uint64x2_t mask2 = vcltq_f64(diff2, threshold_vec);\n\n                if (vmaxvq_u64(mask2)) {\n                    return true;\n                }\n            }\n        }\n\n        if (i + 1 < numbers.size()) {\n            float64x2_t vec1_single = vsetq_lane_f64(numbers[i + 1], vec1, 1);\n\n            for (size_t j = i + 2; j < numbers.size(); j += 2) {\n                float64x2_t vec2 = vld1q_f64(&numbers[j]);\n\n                float64x2_t diff1 = vabsq_f64(vsubq_f64(vec1_single, vec2));\n                uint64x2_t mask1 = vcltq_f64(diff1, threshold_vec);\n\n                if (vmaxvq_u64(mask1)) {\n                    return true;\n                }\n\n                if (j + 1 < numbers.size()) {\n                    float64x2_t vec2_single = vsetq_lane_f64(numbers[j + 1], vec2, 1);\n                    float64x2_t diff2 = vabsq_f64(vsubq_f64(vec1_single, vec2_single));\n                    uint64x2_t mask2 = vcltq_f64(diff2, threshold_vec);\n\n                    if (vmaxvq_u64(mask2)) {\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    if (numbers.size() < 2) return false;\n\n    float64x2_t threshold_vec = vdupq_n_f64(threshold);\n\n    for (size_t i = 0; i < numbers.size(); i += 2) {\n        float64x2_t vec1 = vld1q_f64(&numbers[i]);\n        for (size_t j = i + 2; j < numbers.size(); j += 2) {\n            float64x2_t vec2 = vld1q_f64(&numbers[j]);\n            float64x2_t diff1 = vabsq_f64(vsubq_f64(vec1, vec2));\n            uint64x2_t mask1 = vcltq_f64(diff1, threshold_vec);\n            if (vmaxvq_u64(mask1)) return true;\n\n            if (j + 1 < numbers.size()) {\n                float64x2_t vec3 = vsetq_lane_f64(numbers[j + 1], vec2, 1);\n                float64x2_t diff2 = vabsq_f64(vsubq_f64(vec1, vec3));\n                uint64x2_t mask2 = vcltq_f64(diff2, threshold_vec);\n                if (vmaxvq_u64(mask2)) return true;\n            }\n        }\n        if (i + 1 < numbers.size()) {\n            float64x2_t vec1_single = vsetq_lane_f64(numbers[i + 1], vec1, 1);\n            for (size_t j = i + 2; j < numbers.size(); j += 2) {\n                float64x2_t vec2 = vld1q_f64(&numbers[j]);\n                float64x2_t diff1 = vabsq_f64(vsubq_f64(vec1_single, vec2));\n                uint64x2_t mask1 = vcltq_f64(diff1, threshold_vec);\n                if (vmaxvq_u64(mask1)) return true;\n\n                if (j + 1 < numbers.size()) {\n                    float64x2_t vec3 = vsetq_lane_f64(numbers[j + 1], vec2, 1);\n                    float64x2_t diff2 = vabsq_f64(vsubq_f64(vec1_single, vec3));\n                    uint64x2_t mask2 = vcltq_f64(diff2, threshold_vec);\n                    if (vmaxvq_u64(mask2)) return true;\n                }\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    if (numbers.size() < 2) return false;\n\n    float64x2_t threshold_vec = vdupq_n_f64(threshold);\n\n    for (size_t i = 0; i < numbers.size(); i += 2) {\n        float64x2_t vec1 = vld1q_f64(&numbers[i]);\n        for (size_t j = i + 2; j < numbers.size(); j += 2) {\n            float64x2_t vec2 = vld1q_f64(&numbers[j]);\n            float64x2_t diff1 = vabsq_f64(vsubq_f64(vec1, vec2));\n            uint64x2_t mask1 = vcltq_f64(diff1, threshold_vec);\n            if (vmaxvq_u64(mask1)) return true;\n\n            if (j + 1 < numbers.size()) {\n                float64x2_t vec3 = vsetq_lane_f64(numbers[j + 1], vec2, 1);\n                float64x2_t diff2 = vabsq_f64(vsubq_f64(vec1, vec3));\n                uint64x2_t mask2 = vcltq_f64(diff2, threshold_vec);\n                if (vmaxvq_u64(mask2)) return true;\n            }\n        }\n        if (i + 1 < numbers.size()) {\n            float64x2_t vec4 = vsetq_lane_f64(numbers[i + 1], vec1, 1);\n            for (size_t j = i + 2; j < numbers.size(); j += 2) {\n                float64x2_t vec5 = vld1q_f64(&numbers[j]);\n                float64x2_t diff3 = vabsq_f64(vsubq_f64(vec4, vec5));\n                uint64x2_t mask3 = vcltq_f64(diff3, threshold_vec);\n                if (vmaxvq_u64(mask3)) return true;\n\n                if (j + 1 < numbers.size()) {\n                    float64x2_t vec6 = vsetq_lane_f64(numbers[j + 1], vec5, 1);\n                    float64x2_t diff4 = vabsq_f64(vsubq_f64(vec4, vec6));\n                    uint64x2_t mask4 = vcltq_f64(diff4, threshold_vec);\n                    if (vmaxvq_u64(mask4)) return true;\n                }\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    if (numbers.size() < 2) return false;\n\n    float64x2_t threshold_vec = vdupq_n_f64(threshold);\n\n    for (size_t i = 0; i < numbers.size(); i += 2) {\n        float64x2_t vec1 = vld1q_f64(&numbers[i]);\n        for (size_t j = i + 2; j < numbers.size(); j += 2) {\n            float64x2_t vec2 = vld1q_f64(&numbers[j]);\n            float64x2_t diff1 = vabsq_f64(vsubq_f64(vec1, vec2));\n            uint64x2_t mask1 = vcltq_f64(diff1, threshold_vec);\n            if (vmaxvq_u64(mask1)) return true;\n\n            if (j + 1 < numbers.size()) {\n                float64x2_t vec3 = vsetq_lane_f64(numbers[j + 1], vec2, 1);\n                float64x2_t diff2 = vabsq_f64(vsubq_f64(vec1, vec3));\n                uint64x2_t mask2 = vcltq_f64(diff2, threshold_vec);\n                if (vmaxvq_u64(mask2)) return true;\n            }\n        }\n        if (i + 1 < numbers.size()) {\n            float64x2_t vec4 = vsetq_lane_f64(numbers[i + 1], vec1, 1);\n            for (size_t j = i + 2; j < numbers.size(); j += 2) {\n                float64x2_t vec5 = vld1q_f64(&numbers[j]);\n                float64x2_t diff3 = vabsq_f64(vsubq_f64(vec4, vec5));\n                uint64x2_t mask3 = vcltq_f64(diff3, threshold_vec);\n                if (vmaxvq_u64(mask3)) return true;\n\n                if (j + 1 < numbers.size()) {\n                    float64x2_t vec6 = vsetq_lane_f64(numbers[j + 1], vec5, 1);\n                    float64x2_t diff4 = vabsq_f64(vsubq_f64(vec4, vec6));\n                    uint64x2_t mask4 = vcltq_f64(diff4, threshold_vec);\n                    if (vmaxvq_u64(mask4)) return true;\n                }\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    if (numbers.size() < 2) return false;\n\n    float64x2_t threshold_vec = vdupq_n_f64(threshold);\n\n    for (size_t i = 0; i < numbers.size(); i += 2) {\n        float64x2_t vec1 = vld1q_f64(&numbers[i]);\n        for (size_t j = i + 2; j < numbers.size(); j += 2) {\n            float64x2_t vec2 = vld1q_f64(&numbers[j]);\n            float64x2_t diff1 = vabsq_f64(vsubq_f64(vec1, vec2));\n            uint64x2_t mask1 = vcltq_f64(diff1, threshold_vec);\n            if (vmaxvq_u64(mask1)) return true;\n\n            if (j + 1 < numbers.size()) {\n                float64x2_t vec3 = vsetq_lane_f64(numbers[j + 1], vec2, 1);\n                float64x2_t diff2 = vabsq_f64(vsubq_f64(vec1, vec3));\n                uint64x2_t mask2 = vcltq_f64(diff2, threshold_vec);\n                if (vmaxvq_u64(mask2)) return true;\n            }\n        }\n        if (i + 1 < numbers.size()) {\n            float64x2_t vec4 = vsetq_lane_f64(numbers[i + 1], vec1, 1);\n            for (size_t j = i + 2; j < numbers.size(); j += 2) {\n                float64x2_t vec5 = vld1q_f64(&numbers[j]);\n                float64x2_t diff3 = vabsq_f64(vsubq_f64(vec4, vec5));\n                uint64x2_t mask3 = vcltq_f64(diff3, threshold_vec);\n                if (vmaxvq_u64(mask3)) return true;\n\n                if (j + 1 < numbers.size()) {\n                    float64x2_t vec6 = vsetq_lane_f64(numbers[j + 1], vec5, 1);\n                    float64x2_t diff4 = vabsq_f64(vsubq_f64(vec4, vec6));\n                    uint64x2_t mask4 = vcltq_f64(diff4, threshold_vec);\n                    if (vmaxvq_u64(mask4)) return true;\n                }\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int32x4_t balance = vdupq_n_s32(0);\n    int32x4_t zero = vdupq_n_s32(0);\n    int n = operations.size();\n    int i = 0;\n\n    for (; i <= n - 4; i += 4) {\n        int32x4_t ops = vld1q_s32(&operations[i]);\n        balance = vaddq_s32(balance, ops);\n        uint32x4_t mask = vcltq_s32(balance, zero);\n        if (vmaxvq_u32(mask)) {\n            return true;\n        }\n    }\n\n    for (; i < n; ++i) {\n        balance = vaddq_s32(balance, vdupq_n_s32(operations[i]));\n        int32x4_t lane = vget_low_s32(vuzpq_s32(vget_low_s32(balance), vget_high_s32(balance)).val[0]);\n        lane = vuzpq_s32(lane, lane).val[0];\n        lane = vuzpq_s32(lane, lane).val[0];\n        if (vget_lane_s32(lane, 0) < 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int32x4_t balance = vdupq_n_s32(0);\n    int32x4_t zero = vdupq_n_s32(0);\n    int n = operations.size();\n    int i = 0;\n\n    for (; i <= n - 4; i += 4) {\n        int32x4_t ops = vld1q_s32(&operations[i]);\n        balance = vaddq_s32(balance, ops);\n        uint32x4_t mask = vcltq_s32(balance, zero);\n        if (vmaxvq_u32(mask)) {\n            return true;\n        }\n    }\n\n    int32_t final_balance[4];\n    vst1q_s32(final_balance, balance);\n\n    for (; i < n; ++i) {\n        final_balance[i % 4] += operations[i];\n        if (final_balance[i % 4] < 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int32x4_t balance = vdupq_n_s32(0);\n    int32x4_t zero = vdupq_n_s32(0);\n    int i = 0;\n    int n = operations.size();\n\n    for (; i <= n - 4; i += 4) {\n        int32x4_t ops = vld1q_s32(&operations[i]);\n        balance = vaddq_s32(balance, ops);\n        uint32x4_t mask = vcltq_s32(balance, zero);\n        if (vmaxvq_u32(mask)) {\n            return true;\n        }\n    }\n\n    int32_t final_balance[4];\n    vst1q_s32(final_balance, balance);\n\n    for (; i < n; ++i) {\n        final_balance[i % 4] += operations[i];\n        if (final_balance[i % 4] < 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int32x4_t balance = vdupq_n_s32(0);\n    int32x4_t zero = vdupq_n_s32(0);\n    int n = operations.size();\n    int i = 0;\n\n    for (; i <= n - 4; i += 4) {\n        int32x4_t ops = vld1q_s32(&operations[i]);\n        balance = vaddq_s32(balance, ops);\n        uint32x4_t mask = vcltq_s32(balance, zero);\n        if (vmaxvq_u32(mask)) {\n            return true;\n        }\n    }\n\n    int32_t final_balance[4];\n    vst1q_s32(final_balance, balance);\n\n    for (; i < n; ++i) {\n        final_balance[i % 4] += operations[i];\n        if (final_balance[i % 4] < 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int32x4_t balance = vdupq_n_s32(0);\n    int32x4_t zero = vdupq_n_s32(0);\n    int i = 0;\n    int n = operations.size();\n\n    for (; i <= n - 4; i += 4) {\n        int32x4_t ops = vld1q_s32(&operations[i]);\n        balance = vaddq_s32(balance, ops);\n        uint32x4_t mask = vcltq_s32(balance, zero);\n        if (vmaxvq_u32(mask)) {\n            return true;\n        }\n    }\n\n    int32_t remaining_balance[4];\n    vst1q_s32(remaining_balance, balance);\n\n    for (; i < n; ++i) {\n        remaining_balance[i % 4] += operations[i];\n        if (remaining_balance[i % 4] < 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_64_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    if (numbers.size() == 0) return 0.0;\n\n    double sum = 0.0;\n    double mad_sum = 0.0;\n    size_t n = numbers.size();\n\n    // Calculate the sum of the numbers\n    float64x2_t sum_vec = vdupq_n_f64(0.0);\n    for (size_t i = 0; i <= n - 2; i += 2) {\n        float64x2_t num_vec = vld1q_f64(&numbers[i]);\n        sum_vec = vaddq_f64(sum_vec, num_vec);\n    }\n    double sum_array[2];\n    vst1q_f64(sum_array, sum_vec);\n    sum = sum_array[0] + sum_array[1];\n    for (size_t i = (n / 2) * 2; i < n; ++i) {\n        sum += numbers[i];\n    }\n\n    double mean = sum / n;\n\n    // Calculate the mean absolute deviation\n    float64x2_t mean_vec = vdupq_n_f64(mean);\n    float64x2_t mad_vec = vdupq_n_f64(0.0);\n    for (size_t i = 0; i <= n - 2; i += 2) {\n        float64x2_t num_vec = vld1q_f64(&numbers[i]);\n        float64x2_t diff_vec = vabsq_f64(vsubq_f64(num_vec, mean_vec));\n        mad_vec = vaddq_f64(mad_vec, diff_vec);\n    }\n    double mad_array[2];\n    vst1q_f64(mad_array, mad_vec);\n    mad_sum = mad_array[0] + mad_array[1];\n    for (size_t i = (n / 2) * 2; i < n; ++i) {\n        mad_sum += std::abs(numbers[i] - mean);\n    }\n\n    return mad_sum / n;\n}\n```"}
{"task_id": "SimdBench_64_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    if (numbers.size() == 0) return 0.0;\n\n    double sum = 0.0;\n    double mean = 0.0;\n    size_t n = numbers.size();\n\n    // Calculate mean\n    float64x2_t sum_vec = vdupq_n_f64(0.0);\n    for (size_t i = 0; i <= n - 2; i += 2) {\n        float64x2_t num_vec = vld1q_f64(&numbers[i]);\n        sum_vec = vaddq_f64(sum_vec, num_vec);\n    }\n    double sum_array[2];\n    vst1q_f64(sum_array, sum_vec);\n    sum = sum_array[0] + sum_array[1];\n    for (size_t i = (n / 2) * 2; i < n; ++i) {\n        sum += numbers[i];\n    }\n    mean = sum / n;\n\n    // Calculate mean absolute deviation\n    float64x2_t mean_vec = vdupq_n_f64(mean);\n    float64x2_t mad_vec = vdupq_n_f64(0.0);\n    for (size_t i = 0; i <= n - 2; i += 2) {\n        float64x2_t num_vec = vld1q_f64(&numbers[i]);\n        float64x2_t diff_vec = vabsq_f64(vsubq_f64(num_vec, mean_vec));\n        mad_vec = vaddq_f64(mad_vec, diff_vec);\n    }\n    double mad_array[2];\n    vst1q_f64(mad_array, mad_vec);\n    double mad_sum = mad_array[0] + mad_array[1];\n    for (size_t i = (n / 2) * 2; i < n; ++i) {\n        mad_sum += std::abs(numbers[i] - mean);\n    }\n\n    return mad_sum / n;\n}\n```"}
{"task_id": "SimdBench_64_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    if (numbers.size() == 0) return 0.0;\n\n    double sum = 0.0;\n    double mad_sum = 0.0;\n    size_t n = numbers.size();\n\n    // Calculate the mean\n    for (size_t i = 0; i < n; i++) {\n        sum += numbers[i];\n    }\n    double mean = sum / n;\n\n    // Convert mean to a SIMD register\n    float64x2_t vmean = vdupq_n_f64(mean);\n\n    // Process 2 elements at a time\n    for (size_t i = 0; i <= n - 2; i += 2) {\n        float64x2_t vnum = vld1q_f64(&numbers[i]);\n        float64x2_t vabs_diff = vabsq_f64(vsubq_f64(vnum, vmean));\n        mad_sum += vaddvq_f64(vabs_diff);\n    }\n\n    // Handle remaining element if any\n    if (n % 2 != 0) {\n        mad_sum += std::abs(numbers[n - 1] - mean);\n    }\n\n    return mad_sum / n;\n}\n```"}
{"task_id": "SimdBench_64_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    if (numbers.size() == 0) return 0.0;\n\n    double sum = 0.0;\n    double mean = 0.0;\n    size_t n = numbers.size();\n\n    // Calculate mean\n    float64x2_t sum_vec = vdupq_n_f64(0.0);\n    for (size_t i = 0; i <= n - 2; i += 2) {\n        float64x2_t num_vec = vld1q_f64(&numbers[i]);\n        sum_vec = vaddq_f64(sum_vec, num_vec);\n    }\n    double sum_array[2];\n    vst1q_f64(sum_array, sum_vec);\n    sum = sum_array[0] + sum_array[1];\n    for (size_t i = (n / 2) * 2; i < n; ++i) {\n        sum += numbers[i];\n    }\n    mean = sum / n;\n\n    // Calculate mean absolute deviation\n    float64x2_t mean_vec = vdupq_n_f64(mean);\n    float64x2_t mad_vec = vdupq_n_f64(0.0);\n    for (size_t i = 0; i <= n - 2; i += 2) {\n        float64x2_t num_vec = vld1q_f64(&numbers[i]);\n        float64x2_t diff_vec = vabsq_f64(vsubq_f64(num_vec, mean_vec));\n        mad_vec = vaddq_f64(mad_vec, diff_vec);\n    }\n    double mad_array[2];\n    vst1q_f64(mad_array, mad_vec);\n    double mad_sum = mad_array[0] + mad_array[1];\n    for (size_t i = (n / 2) * 2; i < n; ++i) {\n        mad_sum += std::abs(numbers[i] - mean);\n    }\n\n    return mad_sum / n;\n}\n```"}
{"task_id": "SimdBench_64_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    if (numbers.size() == 0) return 0.0;\n\n    double sum = 0.0;\n    double mad_sum = 0.0;\n    size_t n = numbers.size();\n    size_t i = 0;\n\n    // Calculate the sum of the numbers\n    float64x2_t sum_vec = vdupq_n_f64(0.0);\n    for (; i <= n - 4; i += 4) {\n        float64x2_t num_vec1 = vld1q_f64(&numbers[i]);\n        float64x2_t num_vec2 = vld1q_f64(&numbers[i + 2]);\n        sum_vec = vaddq_f64(sum_vec, vaddq_f64(num_vec1, num_vec2));\n    }\n    double sum_array[2];\n    vst1q_f64(sum_array, sum_vec);\n    sum = sum_array[0] + sum_array[1];\n\n    // Add remaining elements\n    for (; i < n; ++i) {\n        sum += numbers[i];\n    }\n\n    double mean = sum / n;\n\n    // Calculate the sum of absolute deviations\n    float64x2_t mean_vec = vdupq_n_f64(mean);\n    float64x2_t mad_sum_vec = vdupq_n_f64(0.0);\n    i = 0;\n    for (; i <= n - 4; i += 4) {\n        float64x2_t num_vec1 = vld1q_f64(&numbers[i]);\n        float64x2_t num_vec2 = vld1q_f64(&numbers[i + 2]);\n        float64x2_t abs_diff1 = vabsq_f64(vsubq_f64(num_vec1, mean_vec));\n        float64x2_t abs_diff2 = vabsq_f64(vsubq_f64(num_vec2, mean_vec));\n        mad_sum_vec = vaddq_f64(mad_sum_vec, vaddq_f64(abs_diff1, abs_diff2));\n    }\n    double mad_sum_array[2];\n    vst1q_f64(mad_sum_array, mad_sum_vec);\n    mad_sum = mad_sum_array[0] + mad_sum_array[1];\n\n    // Add remaining elements\n    for (; i < n; ++i) {\n        mad_sum += std::abs(numbers[i] - mean);\n    }\n\n    return mad_sum / n;\n}\n```"}
{"task_id": "SimdBench_65_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    std::vector<int> result;\n    if (numbers.empty()) return result;\n\n    int n = numbers.size();\n    int* input = numbers.data();\n    int* output = result.data();\n    result.resize(n + n - 1);\n\n    int i = 0;\n    for (; i <= n - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&input[i]);\n        int32x4_t delimeter_vec = vdupq_n_s32(delimeter);\n\n        int32x4_t shuffled1 = vzip1q_s32(vec, delimeter_vec);\n        int32x4_t shuffled2 = vzip2q_s32(vec, delimeter_vec);\n\n        vst1q_s32(&output[i * 2], shuffled1);\n        vst1q_s32(&output[i * 2 + 4], shuffled2);\n    }\n\n    for (; i < n; ++i) {\n        output[i * 2] = input[i];\n        if (i < n - 1) {\n            output[i * 2 + 1] = delimeter;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    std::vector<int> result;\n    if (numbers.empty()) return result;\n\n    int n = numbers.size();\n    int* input = numbers.data();\n    int* output = result.data();\n    result.resize(n * 2 - 1);\n\n    int i = 0;\n    for (; i <= n - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&input[i]);\n        int32x4_t delimeter_vec = vdupq_n_s32(delimeter);\n\n        int32x4_t shuffled1 = vzip1q_s32(vec, delimeter_vec);\n        int32x4_t shuffled2 = vzip2q_s32(vec, delimeter_vec);\n\n        vst1q_s32(&output[i * 2], shuffled1);\n        vst1q_s32(&output[i * 2 + 4], shuffled2);\n    }\n\n    for (; i < n; ++i) {\n        output[i * 2] = input[i];\n        if (i < n - 1) {\n            output[i * 2 + 1] = delimeter;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    std::vector<int> result;\n    if (numbers.empty()) return result;\n\n    int n = numbers.size();\n    int* input = numbers.data();\n    int* output = result.data();\n    result.resize(n * 2 - 1);\n\n    int i = 0;\n    for (; i <= n - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&input[i]);\n        int32x4_t delimeter_vec = vdupq_n_s32(delimeter);\n\n        int32x4_t shuffled1 = vzip1q_s32(vec, delimeter_vec);\n        int32x4_t shuffled2 = vzip2q_s32(vec, delimeter_vec);\n\n        vst1q_s32(&output[i * 2], shuffled1);\n        vst1q_s32(&output[i * 2 + 4], shuffled2);\n    }\n\n    for (; i < n; ++i) {\n        output[i * 2] = input[i];\n        if (i < n - 1) {\n            output[i * 2 + 1] = delimeter;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    std::vector<int> result;\n    if (numbers.empty()) return result;\n\n    int n = numbers.size();\n    int* input = numbers.data();\n    int* output = result.data();\n    result.resize(n * 2 - 1);\n\n    int i = 0;\n    for (; i <= n - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&input[i]);\n        int32x4_t delimeter_vec = vdupq_n_s32(delimeter);\n\n        int32x4_t shuffled1 = vzip1q_s32(vec, delimeter_vec);\n        int32x4_t shuffled2 = vzip2q_s32(vec, delimeter_vec);\n\n        vst1q_s32(&output[i * 2], shuffled1);\n        vst1q_s32(&output[i * 2 + 4], shuffled2);\n    }\n\n    for (; i < n; ++i) {\n        output[i * 2] = input[i];\n        if (i < n - 1) {\n            output[i * 2 + 1] = delimeter;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    std::vector<int> result;\n    if (numbers.empty()) return result;\n\n    int n = numbers.size();\n    int* input = numbers.data();\n    int* output = result.data();\n    result.resize(n * 2 - 1);\n\n    int i = 0;\n    for (; i <= n - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&input[i]);\n        int32x4_t delimeter_vec = vdupq_n_s32(delimeter);\n\n        int32x4_t shuffled1 = vzip1q_s32(vec, delimeter_vec);\n        int32x4_t shuffled2 = vzip2q_s32(vec, delimeter_vec);\n\n        vst1q_s32(&output[i * 2], shuffled1);\n        vst1q_s32(&output[i * 2 + 4], shuffled2);\n    }\n\n    for (; i < n; ++i) {\n        output[i * 2] = input[i];\n        if (i < n - 1) {\n            output[i * 2 + 1] = delimeter;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_66_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    if (numbers.empty()) {\n        return {sum, product};\n    }\n\n    int16x8_t vsum = vdupq_n_s16(0);\n    int16x8_t vprod = vdupq_n_s16(1);\n\n    size_t i = 0;\n    for (; i + 8 <= numbers.size(); i += 8) {\n        int16x8_t v = vld1q_s16(&numbers[i]);\n        vsum = vaddq_s16(vsum, v);\n        vprod = vmulq_s16(vprod, v);\n    }\n\n    int16_t sum_array[8];\n    int16_t prod_array[8];\n    vst1q_s16(sum_array, vsum);\n    vst1q_s16(prod_array, vprod);\n\n    for (size_t j = 0; j < 8; ++j) {\n        sum += sum_array[j];\n        product *= prod_array[j];\n    }\n\n    for (; i < numbers.size(); ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    if (numbers.empty()) {\n        return {sum, product};\n    }\n\n    int16x8_t sum_vec = vdupq_n_s16(0);\n    int16x8_t prod_vec = vdupq_n_s16(1);\n\n    size_t i = 0;\n    for (; i <= numbers.size() - 8; i += 8) {\n        int16x8_t num_vec = vld1q_s16(&numbers[i]);\n        sum_vec = vaddq_s16(sum_vec, num_vec);\n        prod_vec = vmulq_s16(prod_vec, num_vec);\n    }\n\n    int16_t sum_arr[8];\n    int16_t prod_arr[8];\n    vst1q_s16(sum_arr, sum_vec);\n    vst1q_s16(prod_arr, prod_vec);\n\n    for (size_t j = 0; j < 8; ++j) {\n        sum += sum_arr[j];\n        product *= prod_arr[j];\n    }\n\n    for (; i < numbers.size(); ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    if (numbers.empty()) {\n        return {sum, product};\n    }\n\n    int16x8_t vsum = vdupq_n_s16(0);\n    int16x8_t vprod = vdupq_n_s16(1);\n\n    size_t i = 0;\n    for (; i + 8 <= numbers.size(); i += 8) {\n        int16x8_t v = vld1q_s16(&numbers[i]);\n        vsum = vaddq_s16(vsum, v);\n        vprod = vmulq_s16(vprod, v);\n    }\n\n    int16_t sum_arr[8];\n    int16_t prod_arr[8];\n    vst1q_s16(sum_arr, vsum);\n    vst1q_s16(prod_arr, vprod);\n\n    for (size_t j = 0; j < 8; ++j) {\n        sum += sum_arr[j];\n        product *= prod_arr[j];\n    }\n\n    for (; i < numbers.size(); ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int32x4_t sum = vdupq_n_s32(0);\n    int32x4_t prod = vdupq_n_s32(1);\n\n    size_t i = 0;\n    for (; i + 8 <= numbers.size(); i += 8) {\n        int16x8_t num_vec = vld1q_s16(&numbers[i]);\n        int32x4_t num_low = vmovl_s16(vget_low_s16(num_vec));\n        int32x4_t num_high = vmovl_s16(vget_high_s16(num_vec));\n\n        sum = vaddq_s32(sum, num_low);\n        sum = vaddq_s32(sum, num_high);\n\n        prod = vmulq_s32(prod, num_low);\n        prod = vmulq_s32(prod, num_high);\n    }\n\n    int32_t sum_scalar[4];\n    int32_t prod_scalar[4];\n    vst1q_s32(sum_scalar, sum);\n    vst1q_s32(prod_scalar, prod);\n\n    int64_t total_sum = sum_scalar[0] + sum_scalar[1] + sum_scalar[2] + sum_scalar[3];\n    int64_t total_prod = prod_scalar[0] * prod_scalar[1] * prod_scalar[2] * prod_scalar[3];\n\n    for (; i < numbers.size(); ++i) {\n        total_sum += numbers[i];\n        total_prod *= numbers[i];\n    }\n\n    return {total_sum, total_prod};\n}\n```"}
{"task_id": "SimdBench_66_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    if (numbers.empty()) {\n        return {sum, product};\n    }\n\n    int16x8_t vsum = vdupq_n_s16(0);\n    int16x8_t vprod = vdupq_n_s16(1);\n\n    size_t i = 0;\n    for (; i + 8 <= numbers.size(); i += 8) {\n        int16x8_t v = vld1q_s16(&numbers[i]);\n        vsum = vaddq_s16(vsum, v);\n        vprod = vmulq_s16(vprod, v);\n    }\n\n    int16_t sum_arr[8];\n    int16_t prod_arr[8];\n    vst1q_s16(sum_arr, vsum);\n    vst1q_s16(prod_arr, vprod);\n\n    for (size_t j = 0; j < 8; ++j) {\n        sum += sum_arr[j];\n        product *= prod_arr[j];\n    }\n\n    for (; i < numbers.size(); ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_67_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    std::vector<int> result(numbers.size());\n    if (numbers.empty()) return result;\n\n    int32x4_t max_vec = vdupq_n_s32(numbers[0]);\n    int i = 0;\n\n    // Process 4 elements at a time\n    for (; i <= static_cast<int>(numbers.size()) - 4; i += 4) {\n        int32x4_t input_vec = vld1q_s32(&numbers[i]);\n        max_vec = vmaxq_s32(max_vec, input_vec);\n        vst1q_s32(&result[i], max_vec);\n    }\n\n    // Handle remaining elements\n    int32_t max_scalar = vgetq_lane_s32(max_vec, 3);\n    for (; i < numbers.size(); ++i) {\n        if (numbers[i] > max_scalar) {\n            max_scalar = numbers[i];\n        }\n        result[i] = max_scalar;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    std::vector<int> result(numbers.size());\n    if (numbers.empty()) return result;\n\n    int32x4_t max_vec = vdupq_n_s32(numbers[0]);\n    int i = 0;\n\n    // Process 4 elements at a time\n    for (; i <= static_cast<int>(numbers.size()) - 4; i += 4) {\n        int32x4_t input_vec = vld1q_s32(&numbers[i]);\n        max_vec = vmaxq_s32(max_vec, input_vec);\n        vst1q_s32(&result[i], max_vec);\n    }\n\n    // Handle remaining elements\n    int32_t max_scalar = vgetq_lane_s32(max_vec, 3);\n    for (; i < numbers.size(); ++i) {\n        if (numbers[i] > max_scalar) {\n            max_scalar = numbers[i];\n        }\n        result[i] = max_scalar;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    std::vector<int> result(numbers.size());\n    if (numbers.empty()) return result;\n\n    int32x4_t max_vec = vdupq_n_s32(numbers[0]);\n    int i = 0;\n\n    // Process 4 elements at a time\n    for (; i <= static_cast<int>(numbers.size()) - 4; i += 4) {\n        int32x4_t current_vec = vld1q_s32(&numbers[i]);\n        max_vec = vmaxq_s32(max_vec, current_vec);\n        vst1q_s32(&result[i], max_vec);\n    }\n\n    // Handle remaining elements\n    int32_t max_scalar = vgetq_lane_s32(max_vec, 3);\n    for (; i < numbers.size(); ++i) {\n        if (numbers[i] > max_scalar) {\n            max_scalar = numbers[i];\n        }\n        result[i] = max_scalar;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    std::vector<int> result(numbers.size());\n    if (numbers.empty()) return result;\n\n    int32x4_t max_vec = vdupq_n_s32(numbers[0]);\n    int i = 0;\n\n    // Process 4 elements at a time\n    for (; i <= static_cast<int>(numbers.size()) - 4; i += 4) {\n        int32x4_t current_vec = vld1q_s32(&numbers[i]);\n        max_vec = vmaxq_s32(max_vec, current_vec);\n        vst1q_s32(&result[i], max_vec);\n    }\n\n    // Handle remaining elements\n    int32_t max_scalar = vgetq_lane_s32(max_vec, 3);\n    for (; i < numbers.size(); ++i) {\n        if (numbers[i] > max_scalar) {\n            max_scalar = numbers[i];\n        }\n        result[i] = max_scalar;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    std::vector<int> result(numbers.size());\n    if (numbers.empty()) return result;\n\n    int32x4_t max_vec = vdupq_n_s32(numbers[0]);\n    int i = 0;\n\n    // Process 4 elements at a time\n    for (; i <= static_cast<int>(numbers.size()) - 4; i += 4) {\n        int32x4_t current_vec = vld1q_s32(&numbers[i]);\n        max_vec = vmaxq_s32(max_vec, current_vec);\n        vst1q_s32(&result[i], max_vec);\n    }\n\n    // Handle remaining elements\n    int32_t max_scalar = vgetq_lane_s32(max_vec, 3);\n    for (; i < numbers.size(); ++i) {\n        if (numbers[i] > max_scalar) {\n            max_scalar = numbers[i];\n        }\n        result[i] = max_scalar;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <cstring>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.length();\n    if (len != b.length()) {\n        return \"\";\n    }\n\n    std::string result(len, '0');\n    size_t i = 0;\n\n    // Process 16 characters at a time\n    for (; i <= len - 16; i += 16) {\n        uint8x16_t vec_a = vld1q_u8(reinterpret_cast<const uint8_t*>(a.c_str() + i));\n        uint8x16_t vec_b = vld1q_u8(reinterpret_cast<const uint8_t*>(b.c_str() + i));\n        uint8x16_t vec_result = veorq_u8(vec_a, vec_b);\n        vst1q_u8(reinterpret_cast<uint8_t*>(result.data() + i), vec_result);\n    }\n\n    // Process remaining characters\n    for (; i < len; ++i) {\n        result[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <cstring>\n\nstd::string string_xor_simd(std::string a, std::string b){\n    size_t len = a.length();\n    if (len != b.length()) {\n        return \"\";\n    }\n    std::string result(len, '0');\n    \n    const char* a_ptr = a.c_str();\n    const char* b_ptr = b.c_str();\n    char* result_ptr = &result[0];\n    \n    size_t i = 0;\n    for (; i <= len - 16; i += 16) {\n        uint8x16_t va = vld1q_u8(reinterpret_cast<const uint8_t*>(a_ptr + i));\n        uint8x16_t vb = vld1q_u8(reinterpret_cast<const uint8_t*>(b_ptr + i));\n        uint8x16_t vxor = veorq_u8(va, vb);\n        vst1q_u8(reinterpret_cast<uint8_t*>(result_ptr + i), vxor);\n    }\n    \n    for (; i < len; ++i) {\n        result[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_68_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <cstring>\n\nstd::string string_xor_simd(std::string a, std::string b){\n    size_t len = a.length();\n    if (len != b.length()) {\n        return \"\";\n    }\n    std::string result(len, '0');\n    \n    size_t i = 0;\n    for (; i <= len - 16; i += 16) {\n        uint8x16_t vec_a = vld1q_u8(reinterpret_cast<const uint8_t*>(a.c_str() + i));\n        uint8x16_t vec_b = vld1q_u8(reinterpret_cast<const uint8_t*>(b.c_str() + i));\n        uint8x16_t vec_result = veorq_u8(vec_a, vec_b);\n        vst1q_u8(reinterpret_cast<uint8_t*>(result.data() + i), vec_result);\n    }\n    \n    for (; i < len; ++i) {\n        result[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_68_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <cstring>\n\nstd::string string_xor_simd(std::string a, std::string b){\n    size_t len = a.length();\n    if (len != b.length()) {\n        return \"\";\n    }\n    std::string result(len, '0');\n    \n    const char* a_ptr = a.c_str();\n    const char* b_ptr = b.c_str();\n    char* result_ptr = &result[0];\n    \n    size_t i = 0;\n    for (; i <= len - 16; i += 16) {\n        uint8x16_t va = vld1q_u8(reinterpret_cast<const uint8_t*>(a_ptr + i));\n        uint8x16_t vb = vld1q_u8(reinterpret_cast<const uint8_t*>(b_ptr + i));\n        uint8x16_t vxor = veorq_u8(va, vb);\n        vst1q_u8(reinterpret_cast<uint8_t*>(result_ptr + i), vxor);\n    }\n    \n    for (; i < len; ++i) {\n        result[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_68_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <cstring>\n\nstd::string string_xor_simd(std::string a, std::string b){\n    size_t len = a.length();\n    if (len != b.length()) {\n        return \"\";\n    }\n    std::string result(len, '0');\n    \n    const char* a_ptr = a.c_str();\n    const char* b_ptr = b.c_str();\n    char* result_ptr = &result[0];\n    \n    size_t i = 0;\n    for (; i <= len - 16; i += 16) {\n        uint8x16_t va = vld1q_u8(reinterpret_cast<const uint8_t*>(a_ptr + i));\n        uint8x16_t vb = vld1q_u8(reinterpret_cast<const uint8_t*>(b_ptr + i));\n        uint8x16_t vxor = veorq_u8(va, vb);\n        vst1q_u8(reinterpret_cast<uint8_t*>(result_ptr + i), vxor);\n    }\n    \n    for (; i < len; ++i) {\n        result[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_69_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::string longest_simd(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    size_t max_length = 0;\n    const std::string* longest_string = nullptr;\n\n    size_t num_strings = strings.size();\n    size_t i = 0;\n\n    // Process 4 strings at a time\n    for (; i <= num_strings - 4; i += 4) {\n        uint8x16_t lengths = vdupq_n_u8(0);\n        const uint8_t* str_ptrs[4] = {\n            reinterpret_cast<const uint8_t*>(strings[i].data()),\n            reinterpret_cast<const uint8_t*>(strings[i+1].data()),\n            reinterpret_cast<const uint8_t*>(strings[i+2].data()),\n            reinterpret_cast<const uint8_t*>(strings[i+3].data())\n        };\n\n        for (size_t j = 0; ; ++j) {\n            uint8x16_t chars = vld1q_u8(&str_ptrs[0][j]);\n            chars = vsetq_lane_u8(str_ptrs[1][j], chars, 1);\n            chars = vsetq_lane_u8(str_ptrs[2][j], chars, 2);\n            chars = vsetq_lane_u8(str_ptrs[3][j], chars, 3);\n\n            uint8x16_t zeros = vceqq_u8(chars, vdupq_n_u8(0));\n            uint32x4_t zero_mask = vmovm_u8(zeros);\n\n            if (vmaskne_u32(vdupq_n_u32(0), zero_mask)) {\n                lengths = vaddq_u8(lengths, vdupq_n_u8(1));\n            } else {\n                break;\n            }\n        }\n\n        uint8x8_t lengths_low = vget_low_u8(lengths);\n        uint8x8_t lengths_high = vget_high_u8(lengths);\n\n        uint8x8_t max_lengths = vpmax_u8(lengths_low, lengths_high);\n        max_lengths = vpmax_u8(max_lengths, max_lengths);\n        max_lengths = vpmax_u8(max_lengths, max_lengths);\n\n        uint8_t max_length_local = vget_lane_u8(max_lengths, 0);\n\n        if (max_length_local > max_length) {\n            max_length = max_length_local;\n            longest_string = &strings[i + std::distance(std::begin(strings) + i, std::max_element(\n                std::begin(strings) + i, std::begin(strings) + i + 4,\n                [](const std::string& a, const std::string& b) {\n                    return a.size() < b.size();\n                }\n            ))];\n        }\n    }\n\n    // Process remaining strings\n    for (; i < num_strings; ++i) {\n        if (strings[i].size() > max_length) {\n            max_length = strings[i].size();\n            longest_string = &strings[i];\n        }\n    }\n\n    return *longest_string;\n}\n```"}
{"task_id": "SimdBench_69_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::string longest_simd(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    size_t max_length = 0;\n    size_t max_index = 0;\n\n    size_t num_strings = strings.size();\n    size_t i = 0;\n\n    // Process 4 strings at a time\n    for (; i <= num_strings - 4; i += 4) {\n        uint8x16_t lengths = vdupq_n_u8(0);\n        uint8x16_t indices = vdupq_n_u8(i);\n\n        for (size_t j = 0; j < 4; ++j) {\n            uint8x16_t len = vsetq_lane_u8(strings[i + j].length(), lengths, j);\n            lengths = vsetq_lane_u8(vgetq_lane_u8(len, j), lengths, j);\n        }\n\n        uint8x16_t max_len_vec = vpmax_u8(lengths, lengths);\n        max_len_vec = vpmax_u8(max_len_vec, max_len_vec);\n        uint8_t max_len = vgetq_lane_u8(max_len_vec, 0);\n\n        if (max_len > max_length) {\n            max_length = max_len;\n            max_index = i + std::distance(strings.begin() + i, std::max_element(strings.begin() + i, strings.begin() + i + 4, [](const std::string& a, const std::string& b) {\n                return a.length() < b.length();\n            }));\n        }\n    }\n\n    // Process remaining strings\n    for (; i < num_strings; ++i) {\n        if (strings[i].length() > max_length) {\n            max_length = strings[i].length();\n            max_index = i;\n        }\n    }\n\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_69_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::string longest_simd(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    size_t max_length = 0;\n    const std::string* longest_string = nullptr;\n\n    size_t num_strings = strings.size();\n    size_t i = 0;\n\n    // Process 4 strings at a time\n    for (; i <= num_strings - 4; i += 4) {\n        uint32x4_t lengths = vdupq_n_u32(0);\n        lengths = vsetq_lane_u32(strings[i].length(), lengths, 0);\n        lengths = vsetq_lane_u32(strings[i+1].length(), lengths, 1);\n        lengths = vsetq_lane_u32(strings[i+2].length(), lengths, 2);\n        lengths = vsetq_lane_u32(strings[i+3].length(), lengths, 3);\n\n        uint32x2_t max1 = vpmax_u32(vget_low_u32(lengths), vget_high_u32(lengths));\n        uint32x2_t max2 = vpmax_u32(max1, max1);\n        uint32_t max_len = vget_lane_u32(max2, 0);\n\n        if (max_len > max_length) {\n            max_length = max_len;\n            if (strings[i].length() == max_length) longest_string = &strings[i];\n            else if (strings[i+1].length() == max_length) longest_string = &strings[i+1];\n            else if (strings[i+2].length() == max_length) longest_string = &strings[i+2];\n            else if (strings[i+3].length() == max_length) longest_string = &strings[i+3];\n        }\n    }\n\n    // Process remaining strings\n    for (; i < num_strings; ++i) {\n        if (strings[i].length() > max_length) {\n            max_length = strings[i].length();\n            longest_string = &strings[i];\n        }\n    }\n\n    return *longest_string;\n}\n```"}
{"task_id": "SimdBench_69_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::string longest_simd(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    size_t max_length = 0;\n    const std::string* longest_string = nullptr;\n\n    size_t num_strings = strings.size();\n    size_t i = 0;\n\n    // Process 4 strings at a time\n    for (; i <= num_strings - 4; i += 4) {\n        uint8x16_t lengths = vdupq_n_u8(0);\n        const uint8_t* str_ptrs[4] = {\n            reinterpret_cast<const uint8_t*>(strings[i].data()),\n            reinterpret_cast<const uint8_t*>(strings[i+1].data()),\n            reinterpret_cast<const uint8_t*>(strings[i+2].data()),\n            reinterpret_cast<const uint8_t*>(strings[i+3].data())\n        };\n\n        for (size_t j = 0; ; ++j) {\n            uint8x16_t chars = vld1q_u8(&str_ptrs[0][j]);\n            chars = vorrq_u8(chars, vld1q_u8(&str_ptrs[1][j]));\n            chars = vorrq_u8(chars, vld1q_u8(&str_ptrs[2][j]));\n            chars = vorrq_u8(chars, vld1q_u8(&str_ptrs[3][j]));\n\n            uint8x16_t zeros = vceqq_u8(chars, vdupq_n_u8(0));\n            uint32x4_t mask = vmovmaskq_u8(zeros);\n\n            if (mask[0] || mask[1] || mask[2] || mask[3]) {\n                break;\n            }\n\n            lengths = vaddq_u8(lengths, vdupq_n_u8(1));\n        }\n\n        uint8_t len_arr[16];\n        vst1q_u8(len_arr, lengths);\n\n        for (size_t j = 0; j < 4; ++j) {\n            size_t len = len_arr[j * 4];\n            if (len > max_length) {\n                max_length = len;\n                longest_string = &strings[i + j];\n            }\n        }\n    }\n\n    // Process remaining strings\n    for (; i < num_strings; ++i) {\n        size_t len = strings[i].length();\n        if (len > max_length) {\n            max_length = len;\n            longest_string = &strings[i];\n        }\n    }\n\n    return *longest_string;\n}\n```"}
{"task_id": "SimdBench_69_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::string longest_simd(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    size_t max_length = 0;\n    const std::string* longest_string = nullptr;\n\n    size_t num_strings = strings.size();\n    size_t i = 0;\n\n    // Process 4 strings at a time\n    for (; i <= num_strings - 4; i += 4) {\n        uint8x16_t lengths = vdupq_n_u8(0);\n        const uint8_t* str_ptrs[4] = {\n            reinterpret_cast<const uint8_t*>(strings[i].data()),\n            reinterpret_cast<const uint8_t*>(strings[i+1].data()),\n            reinterpret_cast<const uint8_t*>(strings[i+2].data()),\n            reinterpret_cast<const uint8_t*>(strings[i+3].data())\n        };\n\n        while (true) {\n            uint8x16_t chars = vld1q_u8(str_ptrs);\n            uint8x16_t zeros = vceqq_u8(chars, vdupq_n_u8(0));\n            uint32x4_t zero_mask = vmovmskq_u8(zeros);\n\n            if (zero_mask[0] != 0) {\n                break;\n            }\n\n            str_ptrs[0]++;\n            str_ptrs[1]++;\n            str_ptrs[2]++;\n            str_ptrs[3]++;\n            lengths = vaddq_u8(lengths, vdupq_n_u8(1));\n        }\n\n        uint8x8_t lengths_low = vget_low_u8(lengths);\n        uint8x8_t lengths_high = vget_high_u8(lengths);\n\n        uint8x8_t max_lengths = vpmax_u8(lengths_low, lengths_high);\n        max_lengths = vpmax_u8(max_lengths, max_lengths);\n        max_lengths = vpmax_u8(max_lengths, max_lengths);\n\n        uint8_t max_length_local = vget_lane_u8(max_lengths, 0);\n\n        if (max_length_local > max_length) {\n            max_length = max_length_local;\n            longest_string = &strings[i + std::distance(std::begin(str_ptrs), std::max_element(std::begin(str_ptrs), std::end(str_ptrs), [](const uint8_t* a, const uint8_t* b) {\n                return strlen(reinterpret_cast<const char*>(a)) < strlen(reinterpret_cast<const char*>(b));\n            })) - reinterpret_cast<const uint8_t*>(strings[i].data())];\n        }\n    }\n\n    // Process remaining strings\n    for (; i < num_strings; ++i) {\n        if (strings[i].length() > max_length) {\n            max_length = strings[i].length();\n            longest_string = &strings[i];\n        }\n    }\n\n    return *longest_string;\n}\n```"}
{"task_id": "SimdBench_70_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    uint64x2_t va = vdupq_n_u64(a);\n    uint64x2_t vb = vdupq_n_u64(b);\n\n    while (true) {\n        uint64x2_t zero = vdupq_n_u64(0);\n        uint64x2_t mask = vceqq_u64(vb, zero);\n        if (vgetq_lane_u64(mask, 0) && vgetq_lane_u64(mask, 1)) {\n            break;\n        }\n\n        uint64x2_t temp = vb;\n        vb = vandq_u64(vsubq_u64(va, vb), vmvnq_u64(mask));\n        va = vandq_u64(temp, mask) | vandq_u64(va, vmvnq_u64(mask));\n    }\n\n    return vgetq_lane_u64(va, 0);\n}\n```"}
{"task_id": "SimdBench_70_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    uint64x2_t va = vdupq_n_u64(a);\n    uint64x2_t vb = vdupq_n_u64(b);\n\n    while (true) {\n        uint64x2_t zero = vdupq_n_u64(0);\n        uint64x2_t mask = vceqq_u64(vb, zero);\n        if (vgetq_lane_u64(mask, 0) && vgetq_lane_u64(mask, 1)) {\n            break;\n        }\n\n        uint64x2_t temp = vb;\n        vb = vandq_u64(vsubq_u64(va, vb), vmvnq_u64(mask));\n        va = vandq_u64(temp, mask) | vandq_u64(va, vmvnq_u64(mask));\n    }\n\n    return vgetq_lane_u64(va, 0);\n}\n```"}
{"task_id": "SimdBench_70_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    uint64x2_t va = vdupq_n_u64(a);\n    uint64x2_t vb = vdupq_n_u64(b);\n\n    while (true) {\n        uint64x2_t zero = vdupq_n_u64(0);\n        uint64x2_t mask = vceqq_u64(vb, zero);\n        if (vgetq_lane_u64(mask, 0) && vgetq_lane_u64(mask, 1)) {\n            break;\n        }\n\n        uint64x2_t temp = vb;\n        vb = vandq_u64(vsubq_u64(va, vb), vmvnq_u64(mask));\n        va = vandq_u64(temp, mask) | vandq_u64(va, vmvnq_u64(mask));\n    }\n\n    return vgetq_lane_u64(va, 0);\n}\n```"}
{"task_id": "SimdBench_70_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    uint64x2_t va = vdupq_n_u64(a);\n    uint64x2_t vb = vdupq_n_u64(b);\n\n    while (true) {\n        uint64x2_t zero = vdupq_n_u64(0);\n        uint64x2_t mask = vceqq_u64(vb, zero);\n        if (vgetq_lane_u64(mask, 0) && vgetq_lane_u64(mask, 1)) {\n            break;\n        }\n\n        uint64x2_t temp = vb;\n        vb = vandq_u64(vsubq_u64(va, vb), vmvnq_u64(mask));\n        va = vandq_u64(temp, mask) | vandq_u64(va, vmvnq_u64(mask));\n    }\n\n    return vgetq_lane_u64(va, 0);\n}\n```"}
{"task_id": "SimdBench_70_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    uint64x2_t va = vdupq_n_u64(a);\n    uint64x2_t vb = vdupq_n_u64(b);\n\n    while (true) {\n        uint64x2_t zero = vdupq_n_u64(0);\n        uint64x2_t mask = vceqq_u64(vb, zero);\n        if (vgetq_lane_u64(mask, 0) && vgetq_lane_u64(mask, 1)) {\n            break;\n        }\n\n        uint64x2_t temp = vb;\n        vb = vandq_u64(vsubq_u64(va, vb), vmvnq_u64(mask));\n        va = vandq_u64(temp, mask) | vandq_u64(va, vmvnq_u64(mask));\n    }\n\n    return vgetq_lane_u64(va, 0);\n}\n```"}
{"task_id": "SimdBench_71_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    float32x4_t min_diff = vdupq_n_f32(std::numeric_limits<float>::max());\n    float32x4_t closest_pair = vdupq_n_f32(0.0f);\n    float32x4_t num_vec1, num_vec2;\n    float32x2_t min_diff_low, min_diff_high;\n    float32x2_t closest_pair_low, closest_pair_high;\n    float min_diff_scalar = std::numeric_limits<float>::max();\n    float closest_pair_scalar[2];\n\n    for (size_t i = 0; i < numbers.size(); i += 4) {\n        num_vec1 = vld1q_f32(&numbers[i]);\n        for (size_t j = i + 4; j < numbers.size(); j += 4) {\n            num_vec2 = vld1q_f32(&numbers[j]);\n            float32x4_t diff = vabsq_f32(vsubq_f32(num_vec1, num_vec2));\n            uint32x4_t mask = vcltq_f32(diff, min_diff);\n            min_diff = vbslq_f32(mask, diff, min_diff);\n            closest_pair = vbslq_f32(mask, vzipq_f32(num_vec1, num_vec2).val[0], closest_pair);\n        }\n    }\n\n    min_diff_low = vget_low_f32(min_diff);\n    min_diff_high = vget_high_f32(min_diff);\n    closest_pair_low = vget_low_f32(closest_pair);\n    closest_pair_high = vget_high_f32(closest_pair);\n\n    float32x2_t min_diff_min = vpmin_f32(min_diff_low, min_diff_high);\n    float32x2_t closest_pair_min = vbsl_f32(vceq_f32(min_diff_low, min_diff_min), closest_pair_low, closest_pair_high);\n\n    min_diff_scalar = vget_lane_f32(vpmin_f32(min_diff_min, min_diff_min), 0);\n    closest_pair_scalar[0] = vget_lane_f32(closest_pair_min, 0);\n    closest_pair_scalar[1] = vget_lane_f32(closest_pair_min, 1);\n\n    if (closest_pair_scalar[0] > closest_pair_scalar[1]) {\n        std::swap(closest_pair_scalar[0], closest_pair_scalar[1]);\n    }\n\n    return {closest_pair_scalar[0], closest_pair_scalar[1]};\n}\n```"}
{"task_id": "SimdBench_71_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    float32x4_t min_diff = vdupq_n_f32(std::numeric_limits<float>::max());\n    float32x4_t closest_pair = vdupq_n_f32(0.0f);\n    float32x4_t num_vec1, num_vec2;\n    float32x2_t min_diff_low, min_diff_high;\n    float32x2_t closest_pair_low, closest_pair_high;\n    float min_diff_scalar = std::numeric_limits<float>::max();\n    float closest_pair_scalar[2];\n\n    for (size_t i = 0; i < numbers.size(); i += 4) {\n        num_vec1 = vld1q_f32(&numbers[i]);\n        for (size_t j = i + 4; j < numbers.size(); j += 4) {\n            num_vec2 = vld1q_f32(&numbers[j]);\n            float32x4_t diff = vabsq_f32(vsubq_f32(num_vec1, num_vec2));\n            uint32x4_t mask = vcltq_f32(diff, min_diff);\n            min_diff = vbslq_f32(mask, diff, min_diff);\n            closest_pair = vbslq_f32(mask, vzipq_f32(num_vec1, num_vec2).val[0], closest_pair);\n        }\n    }\n\n    min_diff_low = vget_low_f32(min_diff);\n    min_diff_high = vget_high_f32(min_diff);\n    closest_pair_low = vget_low_f32(closest_pair);\n    closest_pair_high = vget_high_f32(closest_pair);\n\n    float32x2_t min_diff_min = vpmin_f32(min_diff_low, min_diff_high);\n    float32x2_t closest_pair_min = vbsl_f32(vceq_f32(min_diff_low, min_diff_min), closest_pair_low, closest_pair_high);\n\n    min_diff_scalar = vget_lane_f32(vpmin_f32(min_diff_min, min_diff_min), 0);\n    closest_pair_scalar[0] = vget_lane_f32(closest_pair_min, 0);\n    closest_pair_scalar[1] = vget_lane_f32(closest_pair_min, 1);\n\n    if (closest_pair_scalar[0] > closest_pair_scalar[1]) {\n        std::swap(closest_pair_scalar[0], closest_pair_scalar[1]);\n    }\n\n    return {closest_pair_scalar[0], closest_pair_scalar[1]};\n}\n```"}
{"task_id": "SimdBench_71_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    float32x4_t min_diff = vdupq_n_f32(std::numeric_limits<float>::max());\n    float32x4_t closest_pair = vdupq_n_f32(0.0f);\n    float32x4_t num_vec1, num_vec2;\n    float32x4_t diff;\n    float32x2_t min_diff_low, min_diff_high;\n    float32x2_t closest_pair_low, closest_pair_high;\n    float min_scalar = std::numeric_limits<float>::max();\n    float closest_a = 0.0f, closest_b = 0.0f;\n\n    for (size_t i = 0; i < numbers.size() - 4; i += 4) {\n        num_vec1 = vld1q_f32(&numbers[i]);\n        num_vec2 = vld1q_f32(&numbers[i + 1]);\n\n        float32x4_t sorted1 = vcombine_f32(vmin_f32(vget_low_f32(num_vec1), vget_high_f32(num_vec1)),\n                                          vmax_f32(vget_low_f32(num_vec1), vget_high_f32(num_vec1)));\n        float32x4_t sorted2 = vcombine_f32(vmin_f32(vget_low_f32(num_vec2), vget_high_f32(num_vec2)),\n                                          vmax_f32(vget_low_f32(num_vec2), vget_high_f32(num_vec2)));\n\n        float32x4_t diff1 = vabsq_f32(vsubq_f32(sorted1, vextq_f32(sorted1, sorted1, 1)));\n        float32x4_t diff2 = vabsq_f32(vsubq_f32(sorted2, vextq_f32(sorted2, sorted2, 1)));\n\n        float32x4_t min_diffs = vminq_f32(diff1, diff2);\n        uint32x4_t mask = vcltq_f32(min_diffs, min_diff);\n\n        if (vmaxvq_u32(mask)) {\n            min_diff = vbslq_f32(mask, min_diffs, min_diff);\n            closest_pair = vbslq_f32(mask, vzipq_f32(sorted1, sorted2).val[0], closest_pair);\n        }\n    }\n\n    min_diff_low = vpmin_f32(vget_low_f32(min_diff), vget_high_f32(min_diff));\n    min_diff_high = vpmin_f32(vget_high_f32(min_diff), min_diff_low);\n    min_scalar = vget_lane_f32(min_diff_high, 0);\n\n    closest_pair_low = vpmin_f32(vget_low_f32(closest_pair), vget_high_f32(closest_pair));\n    closest_pair_high = vpmin_f32(vget_high_f32(closest_pair), closest_pair_low);\n    closest_a = vget_lane_f32(closest_pair_high, 0);\n    closest_b = vget_lane_f32(closest_pair_high, 1);\n\n    for (size_t i = numbers.size() - 4; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            float diff_scalar = std::fabs(numbers[i] - numbers[j]);\n            if (diff_scalar < min_scalar) {\n                min_scalar = diff_scalar;\n                closest_a = std::min(numbers[i], numbers[j]);\n                closest_b = std::max(numbers[i], numbers[j]);\n            }\n        }\n    }\n\n    return {closest_a, closest_b};\n}\n```"}
{"task_id": "SimdBench_71_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    float32x4_t min_diff = vdupq_n_f32(std::numeric_limits<float>::max());\n    float32x4_t closest_pair = vdupq_n_f32(0.0f);\n    float32x4_t num_vec1, num_vec2;\n    float32x2_t min_diff_low, min_diff_high;\n    float32x2_t closest_pair_low, closest_pair_high;\n    float min_diff_scalar = std::numeric_limits<float>::max();\n    float closest_pair_scalar[2];\n\n    for (size_t i = 0; i < numbers.size(); i += 4) {\n        num_vec1 = vld1q_f32(&numbers[i]);\n        for (size_t j = i + 4; j < numbers.size(); j += 4) {\n            num_vec2 = vld1q_f32(&numbers[j]);\n            float32x4_t diff = vabsq_f32(vsubq_f32(num_vec1, num_vec2));\n            uint32x4_t mask = vcltq_f32(diff, min_diff);\n            min_diff = vbslq_f32(mask, diff, min_diff);\n            closest_pair = vbslq_f32(mask, vzipq_f32(num_vec1, num_vec2).val[0], closest_pair);\n        }\n    }\n\n    min_diff_low = vget_low_f32(min_diff);\n    min_diff_high = vget_high_f32(min_diff);\n    closest_pair_low = vget_low_f32(closest_pair);\n    closest_pair_high = vget_high_f32(closest_pair);\n\n    float32x2_t min_diff_min = vpmin_f32(min_diff_low, min_diff_high);\n    float32x2_t closest_pair_min = vbsl_f32(vceq_f32(min_diff_low, min_diff_min), closest_pair_low, closest_pair_high);\n\n    min_diff_scalar = vget_lane_f32(vpmin_f32(min_diff_min, min_diff_min), 0);\n    closest_pair_scalar[0] = vget_lane_f32(closest_pair_min, 0);\n    closest_pair_scalar[1] = vget_lane_f32(closest_pair_min, 1);\n\n    if (closest_pair_scalar[0] > closest_pair_scalar[1]) {\n        std::swap(closest_pair_scalar[0], closest_pair_scalar[1]);\n    }\n\n    return {closest_pair_scalar[0], closest_pair_scalar[1]};\n}\n```"}
{"task_id": "SimdBench_71_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    float32x4_t min_diff = vdupq_n_f32(std::numeric_limits<float>::max());\n    float32x4_t closest_pair = vdupq_n_f32(0.0f);\n    float32x4_t num_vec1, num_vec2;\n    float32x4_t diff;\n    float32x2_t min_diff_low, min_diff_high;\n    float32x2_t closest_pair_low, closest_pair_high;\n    float min_scalar = std::numeric_limits<float>::max();\n    float closest_a = 0.0f, closest_b = 0.0f;\n\n    for (size_t i = 0; i < numbers.size(); i += 4) {\n        num_vec1 = vld1q_f32(&numbers[i]);\n        for (size_t j = i + 4; j < numbers.size(); j += 4) {\n            num_vec2 = vld1q_f32(&numbers[j]);\n            diff = vabsq_f32(vsubq_f32(num_vec1, num_vec2));\n            uint32x4_t mask = vcltq_f32(diff, min_diff);\n            min_diff = vbslq_f32(mask, diff, min_diff);\n            closest_pair = vbslq_f32(mask, vzipq_f32(num_vec1, num_vec2).val[0], closest_pair);\n        }\n    }\n\n    min_diff_low = vpmin_f32(vget_low_f32(min_diff), vget_high_f32(min_diff));\n    min_diff_high = vpmin_f32(vget_low_f32(min_diff), vget_high_f32(min_diff));\n    float32x2_t min_diff_min = vpmin_f32(min_diff_low, min_diff_high);\n\n    closest_pair_low = vpmin_f32(vget_low_f32(closest_pair), vget_high_f32(closest_pair));\n    closest_pair_high = vpmin_f32(vget_low_f32(closest_pair), vget_high_f32(closest_pair));\n    float32x2_t closest_pair_min = vpmin_f32(closest_pair_low, closest_pair_high);\n\n    vst1_f32(&min_scalar, min_diff_min);\n    vst1_f32(&closest_a, closest_pair_min);\n\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        if (std::fabs(numbers[i] - closest_a) == min_scalar) {\n            closest_b = numbers[i];\n            break;\n        }\n    }\n\n    if (closest_a > closest_b) std::swap(closest_a, closest_b);\n\n    return {closest_a, closest_b};\n}\n```"}
{"task_id": "SimdBench_72_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers){ \n    if (numbers.size() < 2) {\n        return numbers;\n    }\n\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n\n    float32x4_t v_min = vdupq_n_f32(min_val);\n    float32x4_t v_range = vdupq_n_f32(range);\n\n    size_t i = 0;\n    for (; i <= numbers.size() - 4; i += 4) {\n        float32x4_t v_numbers = vld1q_f32(&numbers[i]);\n        v_numbers = vsubq_f32(v_numbers, v_min);\n        v_numbers = vdivq_f32(v_numbers, v_range);\n        vst1q_f32(&numbers[i], v_numbers);\n    }\n\n    for (; i < numbers.size(); ++i) {\n        numbers[i] = (numbers[i] - min_val) / range;\n    }\n\n    return numbers;\n}\n```"}
{"task_id": "SimdBench_72_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    if (numbers.size() < 2) return numbers;\n\n    float* data = numbers.data();\n    size_t n = numbers.size();\n\n    // Find min and max using SIMD\n    float32x4_t v_min = vdupq_n_f32(data[0]);\n    float32x4_t v_max = vdupq_n_f32(data[0]);\n\n    for (size_t i = 0; i <= n - 4; i += 4) {\n        float32x4_t v = vld1q_f32(&data[i]);\n        v_min = vminq_f32(v_min, v);\n        v_max = vmaxq_f32(v_max, v);\n    }\n\n    float min_vals[4], max_vals[4];\n    vst1q_f32(min_vals, v_min);\n    vst1q_f32(max_vals, v_max);\n\n    float min_val = *std::min_element(min_vals, min_vals + 4);\n    float max_val = *std::max_element(max_vals, max_vals + 4);\n\n    // Handle remaining elements\n    for (size_t i = (n & ~3); i < n; ++i) {\n        min_val = std::min(min_val, data[i]);\n        max_val = std::max(max_val, data[i]);\n    }\n\n    float range = max_val - min_val;\n    if (range == 0.0f) return std::vector<float>(n, 0.0f);\n\n    float32x4_t v_range = vdupq_n_f32(range);\n    float32x4_t v_min_val = vdupq_n_f32(min_val);\n\n    for (size_t i = 0; i <= n - 4; i += 4) {\n        float32x4_t v = vld1q_f32(&data[i]);\n        v = vsubq_f32(v, v_min_val);\n        v = vdivq_f32(v, v_range);\n        vst1q_f32(&data[i], v);\n    }\n\n    // Handle remaining elements\n    for (size_t i = (n & ~3); i < n; ++i) {\n        data[i] = (data[i] - min_val) / range;\n    }\n\n    return numbers;\n}\n```"}
{"task_id": "SimdBench_72_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    if (numbers.size() < 2) return numbers;\n\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n\n    float32x4_t v_min = vdupq_n_f32(min_val);\n    float32x4_t v_range = vdupq_n_f32(range);\n\n    size_t i = 0;\n    for (; i <= numbers.size() - 4; i += 4) {\n        float32x4_t v_numbers = vld1q_f32(&numbers[i]);\n        v_numbers = vsubq_f32(v_numbers, v_min);\n        v_numbers = vdivq_f32(v_numbers, v_range);\n        vst1q_f32(&numbers[i], v_numbers);\n    }\n\n    for (; i < numbers.size(); ++i) {\n        numbers[i] = (numbers[i] - min_val) / range;\n    }\n\n    return numbers;\n}\n```"}
{"task_id": "SimdBench_72_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    if (numbers.size() < 2) return numbers;\n\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n\n    if (std::fabs(range) < 1e-6) {\n        std::vector<float> result(numbers.size(), 0.0f);\n        return result;\n    }\n\n    float32x4_t v_min = vdupq_n_f32(min_val);\n    float32x4_t v_range = vdupq_n_f32(range);\n\n    size_t i = 0;\n    for (; i <= numbers.size() - 4; i += 4) {\n        float32x4_t v_numbers = vld1q_f32(&numbers[i]);\n        float32x4_t v_rescaled = vsubq_f32(v_numbers, v_min);\n        v_rescaled = vdivq_f32(v_rescaled, v_range);\n        vst1q_f32(&numbers[i], v_rescaled);\n    }\n\n    for (; i < numbers.size(); ++i) {\n        numbers[i] = (numbers[i] - min_val) / range;\n    }\n\n    return numbers;\n}\n```"}
{"task_id": "SimdBench_72_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    if (numbers.size() < 2) return numbers;\n\n    float* data = numbers.data();\n    size_t n = numbers.size();\n\n    // Find min and max using SIMD\n    float32x4_t v_min = vdupq_n_f32(data[0]);\n    float32x4_t v_max = vdupq_n_f32(data[0]);\n\n    for (size_t i = 0; i <= n - 4; i += 4) {\n        float32x4_t v = vld1q_f32(&data[i]);\n        v_min = vminq_f32(v_min, v);\n        v_max = vmaxq_f32(v_max, v);\n    }\n\n    float min_vals[4], max_vals[4];\n    vst1q_f32(min_vals, v_min);\n    vst1q_f32(max_vals, v_max);\n\n    float min_val = *std::min_element(min_vals, min_vals + 4);\n    float max_val = *std::max_element(max_vals, max_vals + 4);\n\n    // Handle remaining elements\n    for (size_t i = (n & ~3); i < n; ++i) {\n        min_val = std::min(min_val, data[i]);\n        max_val = std::max(max_val, data[i]);\n    }\n\n    float range = max_val - min_val;\n    if (range == 0.0f) return std::vector<float>(n, 0.0f);\n\n    float32x4_t v_range = vdupq_n_f32(range);\n    float32x4_t v_min_val = vdupq_n_f32(min_val);\n\n    for (size_t i = 0; i <= n - 4; i += 4) {\n        float32x4_t v = vld1q_f32(&data[i]);\n        v = vsubq_f32(v, v_min_val);\n        v = vdivq_f32(v, v_range);\n        vst1q_f32(&data[i], v);\n    }\n\n    // Handle remaining elements\n    for (size_t i = (n & ~3); i < n; ++i) {\n        data[i] = (data[i] - min_val) / range;\n    }\n\n    return numbers;\n}\n```"}
{"task_id": "SimdBench_73_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    uint64x2_t n_vec = vdupq_n_u64(n);\n    uint64x2_t i_vec = vsubq_u64(n_vec, vcreate_u64(0x0000000000000002));\n    uint64x2_t zero_vec = vdupq_n_u64(0);\n    uint64x2_t one_vec = vdupq_n_u64(1);\n\n    while (true) {\n        uint64x2_t div_result = vdivq_u64(n_vec, i_vec);\n        uint64x2_t mul_result = vmulq_u64(div_result, i_vec);\n        uint64x2_t cmp_result = vceqq_u64(mul_result, n_vec);\n        uint64x2_t mask = vandq_u64(cmp_result, vreinterpretq_u64_u8(vmovmask_u64(i_vec)));\n\n        if (vgetq_lane_u64(mask, 0) != 0) {\n            return vgetq_lane_u64(i_vec, 0);\n        }\n        if (vgetq_lane_u64(mask, 1) != 0) {\n            return vgetq_lane_u64(i_vec, 1);\n        }\n\n        i_vec = vsubq_u64(i_vec, one_vec);\n        uint64x2_t cmp_zero = vceqq_u64(i_vec, zero_vec);\n        if (vgetq_lane_u64(cmp_zero, 0) || vgetq_lane_u64(cmp_zero, 1)) {\n            break;\n        }\n    }\n\n    return 1;\n}\n```"}
{"task_id": "SimdBench_73_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    uint64x2_t n_vec = vdupq_n_u64(n);\n    uint64x2_t one_vec = vdupq_n_u64(1);\n    uint64x2_t i_vec = vsubq_u64(n_vec, one_vec);\n    uint64x2_t zero_vec = vdupq_n_u64(0);\n\n    while (true) {\n        uint64x2_t mod_vec = vreinterpretq_u64_u8(vceqq_u64(vmulq_u64(i_vec, n_vec), n_vec));\n        uint64x2_t result_vec = vandq_u64(i_vec, mod_vec);\n        uint64_t result = vgetq_lane_u64(result_vec, 0);\n\n        if (result != 0) {\n            return result;\n        }\n\n        i_vec = vsubq_u64(i_vec, one_vec);\n        uint64x2_t mask_vec = vcltq_u64(i_vec, zero_vec);\n        if (vgetq_lane_u64(mask_vec, 0)) {\n            break;\n        }\n    }\n\n    return 1; // Fallback, should not reach here for n > 1\n}\n```"}
{"task_id": "SimdBench_73_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    uint64x2_t n_vec = vdupq_n_u64(n);\n    uint64x2_t i_vec = vsubq_u64(n_vec, vcreate_u64(0x0000000000000002));\n    uint64x2_t zero_vec = vdupq_n_u64(0);\n    uint64x2_t one_vec = vdupq_n_u64(1);\n\n    while (true) {\n        uint64x2_t div_result = vdivq_u64(n_vec, i_vec);\n        uint64x2_t mul_result = vmulq_u64(div_result, i_vec);\n        uint64x2_t cmp_result = vceqq_u64(mul_result, n_vec);\n        uint64x2_t mask = vandq_u64(cmp_result, vreinterpretq_u64_u8(vmovmask_u64(i_vec)));\n\n        if (vgetq_lane_u64(mask, 0) != 0) {\n            return vgetq_lane_u64(i_vec, 0);\n        }\n        if (vgetq_lane_u64(mask, 1) != 0) {\n            return vgetq_lane_u64(i_vec, 1);\n        }\n\n        i_vec = vsubq_u64(i_vec, one_vec);\n        uint64x2_t cmp_zero = vcgeq_u64(i_vec, zero_vec);\n        if (!vgetq_lane_u64(cmp_zero, 0) && !vgetq_lane_u64(cmp_zero, 1)) {\n            break;\n        }\n    }\n\n    return 1; // If no divisor is found, return 1 (though this should not happen for n > 1)\n}\n```"}
{"task_id": "SimdBench_73_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    uint64x2_t n_vec = vdupq_n_u64(n);\n    uint64x2_t i_vec = vsubq_u64(n_vec, vcreate_u64(0x0000000000000002));\n    uint64x2_t zero_vec = vdupq_n_u64(0);\n    uint64x2_t one_vec = vdupq_n_u64(1);\n\n    while (true) {\n        uint64x2_t div_result = vdivq_u64(n_vec, i_vec);\n        uint64x2_t mul_result = vmulq_u64(div_result, i_vec);\n        uint64x2_t cmp_result = vceqq_u64(mul_result, n_vec);\n        uint64x2_t mask = vandq_u64(cmp_result, vreinterpretq_u64_u8(vmovmask_u64(i_vec)));\n\n        if (vgetq_lane_u64(mask, 0) != 0) {\n            return vgetq_lane_u64(i_vec, 0);\n        }\n        if (vgetq_lane_u64(mask, 1) != 0) {\n            return vgetq_lane_u64(i_vec, 1);\n        }\n\n        i_vec = vsubq_u64(i_vec, one_vec);\n        uint64x2_t cmp_zero = vceqq_u64(i_vec, zero_vec);\n        if (vgetq_lane_u64(cmp_zero, 0) || vgetq_lane_u64(cmp_zero, 1)) {\n            break;\n        }\n    }\n\n    return 1;\n}\n```"}
{"task_id": "SimdBench_73_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    uint64x2_t n_vec = vdupq_n_u64(n);\n    uint64x2_t i_vec = vsubq_u64(n_vec, vcreate_u64(0x0000000000000002));\n    uint64x2_t zero_vec = vdupq_n_u64(0);\n    uint64x2_t one_vec = vdupq_n_u64(1);\n\n    while (true) {\n        uint64x2_t mod_vec = vreinterpretq_u64_u8(vceqq_u64(vmulq_u64(vdivq_u64(n_vec, i_vec), i_vec), n_vec));\n        uint64x2_t result_vec = vandq_u64(i_vec, mod_vec);\n        uint64x2_t max_result_vec = vpmaxq_u64(result_vec, result_vec);\n        uint64_t max_result = vgetq_lane_u64(max_result_vec, 0);\n\n        if (max_result != 0) {\n            return max_result;\n        }\n\n        i_vec = vsubq_u64(i_vec, one_vec);\n        uint64x2_t mask_vec = vcgeq_u64(i_vec, zero_vec);\n        if (vgetq_lane_u64(mask_vec, 0) == 0 && vgetq_lane_u64(mask_vec, 1) == 0) {\n            break;\n        }\n    }\n\n    return 1;\n}\n```"}
{"task_id": "SimdBench_74_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    int32x4_t twos = vdupq_n_s32(2);\n    int32x4_t fives = vdupq_n_s32(5);\n    int32x4_t sevens = vdupq_n_s32(7);\n\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    while (n % 5 == 0) {\n        factors.push_back(5);\n        n /= 5;\n    }\n\n    while (n % 7 == 0) {\n        factors.push_back(7);\n        n /= 7;\n    }\n\n    if (n > 1) {\n        // For simplicity, handling remaining prime factors without SIMD\n        for (int i = 11; i * i <= n; i += 6) {\n            while (n % i == 0) {\n                factors.push_back(i);\n                n /= i;\n            }\n            while (n % (i + 2) == 0) {\n                factors.push_back(i + 2);\n                n /= (i + 2);\n            }\n        }\n        if (n > 1) {\n            factors.push_back(n);\n        }\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    int32x4_t divisors = vdupq_n_s32(2);\n    int32x4_t zero = vdupq_n_s32(0);\n\n    while (n > 1) {\n        uint32x4_t quotients = vcvtnq_u32_f32(vreinterpretq_f32_s32(vdivq_s32(vdupq_n_s32(n), divisors)));\n        uint32x4_t remainders = vsubq_u32(vmulq_u32(divisors, vreinterpretq_s32_u32(quotients)), vdupq_n_u32(n));\n\n        for (int i = 0; i < 4; ++i) {\n            if (vgetq_lane_u32(remainders, i) == 0) {\n                factors.push_back(vgetq_lane_s32(divisors, i));\n                n /= vgetq_lane_s32(divisors, i);\n                break;\n            }\n        }\n\n        divisors = vaddq_s32(divisors, vdupq_n_s32(1));\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    int32x4_t twos = vdupq_n_s32(2);\n    int32x4_t fives = vdupq_n_s32(5);\n    int32x4_t sevens = vdupq_n_s32(7);\n\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    while (n % 5 == 0) {\n        factors.push_back(5);\n        n /= 5;\n    }\n\n    while (n % 7 == 0) {\n        factors.push_back(7);\n        n /= 7;\n    }\n\n    if (n > 1) {\n        // For simplicity, handling remaining prime factors without SIMD\n        for (int i = 11; i * i <= n; i += 2) {\n            while (n % i == 0) {\n                factors.push_back(i);\n                n /= i;\n            }\n        }\n        if (n > 1) {\n            factors.push_back(n);\n        }\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    int32x4_t twos = vdupq_n_s32(2);\n    int32x4_t divisors = twos;\n    int32x4_t zeros = vdupq_n_s32(0);\n\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    int divisor = 3;\n    while (divisor * divisor <= n) {\n        int32x4_t divisor_vec = vdupq_n_s32(divisor);\n        uint32x4_t mask = vceqq_s32(vmodq_s32(vdupq_n_s32(n), divisor_vec), zeros);\n        int count = vaddvq_u32(mask);\n\n        for (int i = 0; i < count; ++i) {\n            factors.push_back(divisor);\n            n /= divisor;\n        }\n\n        divisor += 2;\n    }\n\n    if (n > 2) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    int32x4_t divisors = vdupq_n_s32(2);\n    int32x4_t zero = vdupq_n_s32(0);\n\n    while (n > 1) {\n        uint32x4_t quotients = vcvtnq_u32_f32(vreinterpretq_f32_s32(vdivq_s32(vdupq_n_s32(n), divisors)));\n        uint32x4_t remainders = vsubq_u32(vmulq_u32(divisors, vreinterpretq_s32_u32(quotients)), vdupq_n_u32(n));\n\n        for (int i = 0; i < 4; ++i) {\n            if (vgetq_lane_u32(remainders, i) == 0) {\n                factors.push_back(vgetq_lane_s32(divisors, i));\n                n /= vgetq_lane_s32(divisors, i);\n                break;\n            }\n        }\n\n        divisors = vaddq_s32(divisors, vdupq_n_s32(1));\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_75_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    float32x4_t zero = vdupq_n_f32(0.0f);\n    size_t i = 0;\n    size_t n = l.size();\n\n    while (i <= n - 4) {\n        float32x4_t input = vld1q_f32(&l[i]);\n        uint32x4_t mask = vcgtq_f32(input, zero);\n        float32x4_t positive = vbslq_f32(mask, input, zero);\n\n        for (int j = 0; j < 4; ++j) {\n            if (vgetq_lane_f32(positive, j) != 0.0f) {\n                result.push_back(vgetq_lane_f32(positive, j));\n            }\n        }\n        i += 4;\n    }\n\n    while (i < n) {\n        if (l[i] > 0.0f) {\n            result.push_back(l[i]);\n        }\n        ++i;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    float32x4_t zero = vdupq_n_f32(0.0f);\n    size_t i = 0;\n    size_t n = l.size();\n\n    while (i <= n - 4) {\n        float32x4_t input = vld1q_f32(&l[i]);\n        uint32x4_t mask = vcgtq_f32(input, zero);\n        float32x4_t positive = vbslq_f32(mask, input, zero);\n\n        for (int j = 0; j < 4; ++j) {\n            if (vgetq_lane_f32(positive, j) != 0.0f) {\n                result.push_back(vgetq_lane_f32(positive, j));\n            }\n        }\n        i += 4;\n    }\n\n    while (i < n) {\n        if (l[i] > 0.0f) {\n            result.push_back(l[i]);\n        }\n        i++;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    float32x4_t zero = vdupq_n_f32(0.0f);\n    size_t i = 0;\n    size_t n = l.size();\n\n    while (i <= n - 4) {\n        float32x4_t input = vld1q_f32(&l[i]);\n        uint32x4_t mask = vcgtq_f32(input, zero);\n        float32x4_t positive = vbslq_f32(mask, input, zero);\n\n        for (int j = 0; j < 4; ++j) {\n            if (vgetq_lane_f32(positive, j) != 0.0f) {\n                result.push_back(vgetq_lane_f32(positive, j));\n            }\n        }\n        i += 4;\n    }\n\n    while (i < n) {\n        if (l[i] > 0.0f) {\n            result.push_back(l[i]);\n        }\n        i++;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    float32x4_t zero = vdupq_n_f32(0.0f);\n    size_t i = 0;\n    size_t n = l.size();\n\n    while (i <= n - 4) {\n        float32x4_t input = vld1q_f32(&l[i]);\n        uint32x4_t mask = vcgtq_f32(input, zero);\n        float32x4_t positive = vbslq_f32(mask, input, zero);\n\n        for (int j = 0; j < 4; ++j) {\n            if (vgetq_lane_f32(positive, j) != 0.0f) {\n                result.push_back(vgetq_lane_f32(positive, j));\n            }\n        }\n        i += 4;\n    }\n\n    while (i < n) {\n        if (l[i] > 0.0f) {\n            result.push_back(l[i]);\n        }\n        i++;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    float32x4_t zero = vdupq_n_f32(0.0f);\n    size_t i = 0;\n    size_t n = l.size();\n\n    while (i <= n - 4) {\n        float32x4_t input = vld1q_f32(&l[i]);\n        uint32x4_t mask = vcgtq_f32(input, zero);\n        float32x4_t positive = vbslq_f32(mask, input, zero);\n\n        for (int j = 0; j < 4; ++j) {\n            if (vgetq_lane_f32(positive, j) != 0.0f) {\n                result.push_back(vgetq_lane_f32(positive, j));\n            }\n        }\n        i += 4;\n    }\n\n    while (i < n) {\n        if (l[i] > 0.0f) {\n            result.push_back(l[i]);\n        }\n        i++;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_76_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t i = 5;\n    while (i * i <= n) {\n        int64x2_t factors = vdupq_n_s64(i);\n        int64x2_t increments = vcreate_s64(((uint64_t)6 << 32) | 2);\n        int64x2_t products = vmulq_s64(factors, factors);\n\n        while (vmaxvq_s64(products) <= n) {\n            uint32x2_t cmp1 = vcgtq_s64(vdupq_n_s64(n), products);\n            uint32x2_t cmp2 = vceqq_s64(vdupq_n_s64(0), vandq_s64(vmovq_n_u32(1), vshrq_n_u32((uint32x2_t)cmp1, 31)));\n            uint32_t result = vget_lane_u32(vreinterpret_u32_u64(vandq_u32(cmp2, cmp2)), 0) & 1;\n            if (result) return false;\n\n            factors = vaddq_s64(factors, increments);\n            products = vmulq_s64(factors, factors);\n        }\n\n        i += 6;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t i = 5;\n    while (i * i <= n) {\n        int64x2_t factors = vdupq_n_s64(i);\n        int64x2_t increments = vcreate_s64(((uint64_t)2 << 32) | 4);\n        int64x2_t products = vmulq_s64(factors, factors);\n\n        while (vmaxvq_s64(products) <= n) {\n            uint32x2_t cmp1 = vcgtq_s64(vdupq_n_s64(n), products);\n            uint32x2_t cmp2 = vceqq_s64(vdupq_n_s64(0), vandq_s64(vmovq_n_u32(1), vreinterpretq_u32_s64(vsubq_s64(vdupq_n_s64(n), products))));\n            uint32x2_t result = vandq_u32(cmp1, cmp2);\n\n            if (vget_lane_u32(result, 0) == 0 || vget_lane_u32(result, 1) == 0) {\n                return false;\n            }\n\n            factors = vaddq_s64(factors, increments);\n            products = vmulq_s64(factors, factors);\n        }\n\n        i += 6;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t i = 5;\n    while (i * i <= n) {\n        int64x2_t factors = vdupq_n_s64(i);\n        int64x2_t increments = vcreate_s64(((uint64_t)6 << 32) | 2);\n        int64x2_t products = vmulq_s64(factors, factors);\n\n        while (vmaxvq_s64(products) <= n) {\n            uint32x2_t cmp1 = vcgtq_s64(vdupq_n_s64(n), products);\n            uint32x2_t cmp2 = vceqq_s64(vdupq_n_s64(0), vandq_s64(vmovq_n_u32(1), vreinterpretq_u32_s64(vsubq_s64(vdupq_n_s64(n), products))));\n            uint32x2_t result = vandq_u32(cmp1, cmp2);\n\n            if (vgetq_lane_u32(result, 0) == 0 || vgetq_lane_u32(result, 1) == 0) {\n                return false;\n            }\n\n            factors = vaddq_s64(factors, increments);\n            products = vmulq_s64(factors, factors);\n        }\n\n        i += 6;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t i = 5;\n    while (i * i <= n) {\n        int64x2_t factors = vdupq_n_s64(i);\n        int64x2_t increments = vcreate_s64(((uint64_t)6 << 32) | 2);\n        int64x2_t products = vmulq_s64(factors, factors);\n\n        while (vmaxvq_s64(products) <= n) {\n            uint32x2_t cmp1 = vcgtq_s64(vdupq_n_s64(n), products);\n            uint32x2_t cmp2 = vandq_u32(cmp1, vceqq_s64(vmovq_n_s64(0), vandq_s64(products, vdupq_n_s64(n))));\n            if (vget_lane_u32(cmp2, 0) || vget_lane_u32(cmp2, 1)) {\n                return false;\n            }\n            factors = vaddq_s64(factors, increments);\n            products = vmulq_s64(factors, factors);\n        }\n\n        i += 6;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t i = 5;\n    while (i * i <= n) {\n        int64x2_t factors = vdupq_n_s64(i);\n        int64x2_t increments = vcreate_s64(((uint64_t)6 << 32) | 2);\n        int64x2_t products = vmulq_s64(factors, factors);\n\n        while (vmaxvq_s64(products) <= n) {\n            uint32x2_t cmp1 = vcgtq_s64(vdupq_n_s64(n), products);\n            uint32x2_t cmp2 = vceqq_s64(vandq_s64(cmp1, cmp1), vdupq_n_u32(0xFFFFFFFF));\n            uint32_t mask = vget_lane_u32(vreinterpret_u32_u64(vmovn_u64(cmp2)), 0);\n            if (mask & 1) return false;\n            if (mask & 2) return false;\n\n            factors = vaddq_s64(factors, increments);\n            products = vmulq_s64(factors, factors);\n        }\n\n        i += 6;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_77_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s) {\n    int n = s.size();\n    if (n == 0) return s;\n\n    std::string result(n, ' ');\n\n    // Check if there are any letters in the string\n    uint8x16_t has_letters = vdupq_u8(0);\n    for (int i = 0; i < n; i += 16) {\n        uint8x16_t chunk = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        uint8x16_t is_alpha = vandq_u8(vornq_u8(vcltq_u8(chunk, vdupq_u8('a')), vcgtq_u8(chunk, vdupq_u8('z'))),\n                                       vornq_u8(vcltq_u8(chunk, vdupq_u8('A')), vcgtq_u8(chunk, vdupq_u8('Z'))));\n        has_letters = vorrq_u8(has_letters, is_alpha);\n    }\n\n    // If there are no letters, reverse the string\n    if (vmaxvq_u8(has_letters) == 0) {\n        std::reverse_copy(s.begin(), s.end(), result.begin());\n        return result;\n    }\n\n    // Process the string to reverse the case of letters\n    for (int i = 0; i < n; i += 16) {\n        uint8x16_t chunk = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        uint8x16_t is_lower = vcltq_u8(chunk, vdupq_u8('a'));\n        uint8x16_t is_upper = vcgtq_u8(chunk, vdupq_u8('Z'));\n        uint8x16_t is_alpha = vandq_u8(vornq_u8(is_lower, vcgtq_u8(chunk, vdupq_u8('z'))),\n                                       vornq_u8(is_upper, vcltq_u8(chunk, vdupq_u8('A'))));\n\n        uint8x16_t to_upper = vsubq_u8(chunk, vdupq_u8('a' - 'A'));\n        uint8x16_t to_lower = vaddq_u8(chunk, vdupq_u8('a' - 'A'));\n\n        uint8x16_t result_chunk = vbslq_u8(is_lower, to_upper, chunk);\n        result_chunk = vbslq_u8(is_upper, to_lower, result_chunk);\n\n        vst1q_u8(reinterpret_cast<uint8_t*>(result.data() + i), result_chunk);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s) {\n    int n = s.size();\n    if (n == 0) return s;\n\n    std::string result(n, ' ');\n\n    // Check if there are any letters in the string\n    uint8x16_t has_letters = vdupq_n_u8(0);\n    for (int i = 0; i < n; i += 16) {\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        uint8x16_t is_alpha = vandq_u8(vornq_u8(vcltq_u8(chars, vdupq_n_u8('a')), vcgtq_u8(chars, vdupq_n_u8('z'))),\n                                       vornq_u8(vcltq_u8(chars, vdupq_n_u8('A')), vcgtq_u8(chars, vdupq_n_u8('Z'))));\n        has_letters = vorrq_u8(has_letters, is_alpha);\n    }\n\n    // If there are no letters, reverse the string\n    if (vmaxvq_u8(has_letters) == 0) {\n        std::reverse_copy(s.begin(), s.end(), result.begin());\n        return result;\n    }\n\n    // Process the string to reverse the case of letters\n    for (int i = 0; i < n; i += 16) {\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        uint8x16_t is_lower = vcltq_u8(chars, vdupq_n_u8('a'));\n        uint8x16_t is_upper = vcgtq_u8(chars, vdupq_n_u8('Z'));\n        uint8x16_t is_alpha = vandq_u8(vornq_u8(is_lower, vcgtq_u8(chars, vdupq_n_u8('z'))),\n                                       vornq_u8(is_upper, vcltq_u8(chars, vdupq_n_u8('A'))));\n        uint8x16_t toggle_case = veorq_u8(chars, vandq_u8(vdupq_n_u8(0x20), is_alpha));\n        vst1q_u8(reinterpret_cast<uint8_t*>(result.data() + i), toggle_case);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s) {\n    int n = s.size();\n    if (n == 0) return s;\n\n    std::string result(n, ' ');\n\n    // Check if there are any letters in the string\n    uint8x16_t has_letters = vdupq_n_u8(0);\n    for (int i = 0; i < n; i += 16) {\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        uint8x16_t is_alpha = vandq_u8(vornq_u8(vcltq_u8(chars, vdupq_n_u8('a')), vcgtq_u8(chars, vdupq_n_u8('z'))),\n                                      vornq_u8(vcltq_u8(chars, vdupq_n_u8('A')), vcgtq_u8(chars, vdupq_n_u8('Z'))));\n        has_letters = vorrq_u8(has_letters, is_alpha);\n    }\n\n    // If there are no letters, reverse the string\n    if (vmaxvq_u8(has_letters) == 0) {\n        std::reverse_copy(s.begin(), s.end(), result.begin());\n        return result;\n    }\n\n    // Process the string to reverse case\n    for (int i = 0; i < n; i += 16) {\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        uint8x16_t is_lower = vcltq_u8(chars, vdupq_n_u8('a'));\n        uint8x16_t is_upper = vcgtq_u8(chars, vdupq_n_u8('Z'));\n        uint8x16_t is_alpha = vandq_u8(vornq_u8(is_lower, vcgtq_u8(chars, vdupq_n_u8('z'))),\n                                      vornq_u8(is_upper, vcltq_u8(chars, vdupq_n_u8('A'))));\n\n        uint8x16_t lower_to_upper = vsubq_u8(chars, vdupq_n_u8('a' - 'A'));\n        uint8x16_t upper_to_lower = vaddq_u8(chars, vdupq_n_u8('a' - 'A'));\n\n        uint8x16_t result_chars = vbslq_u8(is_lower, lower_to_upper, chars);\n        result_chars = vbslq_u8(is_upper, upper_to_lower, result_chars);\n\n        vst1q_u8(reinterpret_cast<uint8_t*>(result.data() + i), result_chars);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s) {\n    int n = s.size();\n    if (n == 0) return s;\n\n    std::string result(n, ' ');\n\n    // Check if there are any letters in the string\n    uint8x16_t has_letters = vdupq_n_u8(0);\n    for (int i = 0; i < n; i += 16) {\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        uint8x16_t is_alpha = vandq_u8(vornq_u8(vcltq_u8(chars, vdupq_n_u8('a')), vcgtq_u8(chars, vdupq_n_u8('z'))),\n                                      vornq_u8(vcltq_u8(chars, vdupq_n_u8('A')), vcgtq_u8(chars, vdupq_n_u8('Z'))));\n        has_letters = vorrq_u8(has_letters, is_alpha);\n    }\n\n    // If there are no letters, reverse the string\n    if (vmaxvq_u8(has_letters) == 0) {\n        std::reverse_copy(s.begin(), s.end(), result.begin());\n        return result;\n    }\n\n    // Process the string to reverse case\n    for (int i = 0; i < n; i += 16) {\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        uint8x16_t is_lower = vcltq_u8(chars, vdupq_n_u8('a'));\n        uint8x16_t is_upper = vcgtq_u8(chars, vdupq_n_u8('Z'));\n        uint8x16_t is_alpha = vandq_u8(vornq_u8(is_lower, vcgtq_u8(chars, vdupq_n_u8('z'))),\n                                      vornq_u8(is_upper, vcltq_u8(chars, vdupq_n_u8('A'))));\n        uint8x16_t toggle_case = veorq_u8(chars, vandq_u8(vdupq_n_u8(0x20), is_alpha));\n        vst1q_u8(reinterpret_cast<uint8_t*>(result.data() + i), toggle_case);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s) {\n    int n = s.size();\n    if (n == 0) return s;\n\n    std::string result(n, ' ');\n\n    // Check if there are any letters in the string\n    uint8x16_t has_letters = vdupq_n_u8(0);\n    for (int i = 0; i < n; i += 16) {\n        uint8x16_t chunk = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        uint8x16_t is_alpha = vandq_u8(vornq_u8(vcltq_u8(chunk, vdupq_n_u8('a')), vcgtq_u8(chunk, vdupq_n_u8('z'))),\n                                       vornq_u8(vcltq_u8(chunk, vdupq_n_u8('A')), vcgtq_u8(chunk, vdupq_n_u8('Z'))));\n        has_letters = vorrq_u8(has_letters, is_alpha);\n    }\n\n    // If there are no letters, reverse the string\n    if (vmaxvq_u8(has_letters) == 0) {\n        std::reverse_copy(s.begin(), s.end(), result.begin());\n        return result;\n    }\n\n    // Process the string to reverse the case of letters\n    for (int i = 0; i < n; i += 16) {\n        uint8x16_t chunk = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        uint8x16_t is_lower = vcltq_u8(chunk, vdupq_n_u8('a'));\n        uint8x16_t is_upper = vcgtq_u8(chunk, vdupq_n_u8('Z'));\n        uint8x16_t is_alpha = vandq_u8(vornq_u8(is_lower, vcgtq_u8(chunk, vdupq_n_u8('z'))),\n                                       vornq_u8(is_upper, vcltq_u8(chunk, vdupq_n_u8('A'))));\n\n        uint8x16_t lower_to_upper = vsubq_u8(chunk, vdupq_n_u8('a' - 'A'));\n        uint8x16_t upper_to_lower = vaddq_u8(chunk, vdupq_n_u8('a' - 'A'));\n\n        uint8x16_t result_chunk = vbslq_u8(is_lower, lower_to_upper, chunk);\n        result_chunk = vbslq_u8(is_upper, upper_to_lower, result_chunk);\n\n        vst1q_u8(reinterpret_cast<uint8_t*>(result.data() + i), result_chunk);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    int n = l.size();\n    std::vector<int> sorted_thirds;\n    \n    // Collect elements at indices divisible by 3\n    for (int i = 0; i < n; i += 3) {\n        sorted_thirds.push_back(l[i]);\n    }\n    \n    // Sort the collected elements\n    std::sort(sorted_thirds.begin(), sorted_thirds.end());\n    \n    // Use NEON to replace elements at indices divisible by 3 with sorted elements\n    int32x4_t sorted_vec, original_vec, mask, result_vec;\n    int32_t sorted_array[4];\n    int32_t original_array[4];\n    int32_t result_array[4];\n    \n    for (int i = 0; i < n; i += 12) {\n        // Load 12 elements (4 sets of 3) into 4 vectors\n        for (int j = 0; j < 4; ++j) {\n            for (int k = 0; k < 3; ++k) {\n                original_array[j * 3 + k] = l[i + j * 3 + k];\n                if ((i + j * 3 + k) % 3 == 0) {\n                    sorted_array[j * 3 + k] = sorted_thirds[(i + j * 3 + k) / 3];\n                } else {\n                    sorted_array[j * 3 + k] = original_array[j * 3 + k];\n                }\n            }\n        }\n        \n        // Create vectors from arrays\n        original_vec = vld1q_s32(original_array);\n        sorted_vec = vld1q_s32(sorted_array);\n        \n        // Create a mask for elements at indices divisible by 3\n        mask = vdupq_n_s32(0xFFFFFFFF);\n        mask = vsetq_lane_s32(0, mask, 0);\n        mask = vsetq_lane_s32(0, mask, 3);\n        \n        // Blend sorted and original vectors based on the mask\n        result_vec = vbslq_s32(mask, sorted_vec, original_vec);\n        \n        // Store the result back to the array\n        vst1q_s32(result_array, result_vec);\n        \n        // Copy the result array back to the original vector\n        for (int j = 0; j < 4; ++j) {\n            for (int k = 0; k < 3; ++k) {\n                l[i + j * 3 + k] = result_array[j * 3 + k];\n            }\n        }\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_78_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    int n = l.size();\n    std::vector<int> result(n);\n    int32x4_t indices = vdupq_n_s32(0);\n    int32x4_t step = vdupq_n_s32(3);\n    int32x4_t ones = vdupq_n_s32(1);\n\n    for (int i = 0; i < n; i += 12) {\n        int32x4_t vec0 = vld1q_s32(&l[i]);\n        int32x4_t vec1 = vld1q_s32(&l[i + 4]);\n        int32x4_t vec2 = vld1q_s32(&l[i + 8]);\n\n        uint32x4_t mask0 = vceqq_s32(indices, vandq_s32(indices, step));\n        uint32x4_t mask1 = vceqq_s32(vaddq_s32(indices, ones), vandq_s32(vaddq_s32(indices, ones), step));\n        uint32x4_t mask2 = vceqq_s32(vaddq_s32(indices, vshlq_n_s32(ones, 1)), vandq_s32(vaddq_s32(indices, vshlq_n_s32(ones, 1)), step));\n\n        int32x4_t sorted0 = vec0;\n        int32x4_t sorted1 = vec1;\n        int32x4_t sorted2 = vec2;\n\n        if (vmaxvq_u32(mask0)) {\n            int temp[4];\n            vst1q_s32(temp, vec0);\n            std::sort(temp, temp + 4);\n            sorted0 = vld1q_s32(temp);\n        }\n\n        if (vmaxvq_u32(mask1)) {\n            int temp[4];\n            vst1q_s32(temp, vec1);\n            std::sort(temp, temp + 4);\n            sorted1 = vld1q_s32(temp);\n        }\n\n        if (vmaxvq_u32(mask2)) {\n            int temp[4];\n            vst1q_s32(temp, vec2);\n            std::sort(temp, temp + 4);\n            sorted2 = vld1q_s32(temp);\n        }\n\n        int32x4_t result0 = vbslq_s32(mask0, sorted0, vec0);\n        int32x4_t result1 = vbslq_s32(mask1, sorted1, vec1);\n        int32x4_t result2 = vbslq_s32(mask2, sorted2, vec2);\n\n        vst1q_s32(&result[i], result0);\n        vst1q_s32(&result[i + 4], result1);\n        vst1q_s32(&result[i + 8], result2);\n\n        indices = vaddq_s32(indices, vshlq_n_s32(ones, 2));\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    int n = l.size();\n    std::vector<int> result(n);\n    int32x4_t indices = vdupq_n_s32(0);\n    int32x4_t step = vdupq_n_s32(3);\n    int32x4_t ones = vdupq_n_s32(1);\n\n    for (int i = 0; i < n; i += 12) {\n        int32x4_t vec0 = vld1q_s32(&l[i]);\n        int32x4_t vec1 = vld1q_s32(&l[i + 4]);\n        int32x4_t vec2 = vld1q_s32(&l[i + 8]);\n\n        uint32x4_t mask0 = vceqq_s32(indices, vdupq_n_s32(0));\n        uint32x4_t mask1 = vceqq_s32(indices, vdupq_n_s32(3));\n        uint32x4_t mask2 = vceqq_s32(indices, vdupq_n_s32(6));\n        uint32x4_t mask3 = vceqq_s32(indices, vdupq_n_s32(9));\n\n        int32x4_t sorted0 = vec0;\n        int32x4_t sorted1 = vec1;\n        int32x4_t sorted2 = vec2;\n\n        if (i + 3 < n) {\n            int32x4_t temp = vcombine_s32(vget_low_s32(sorted0), vget_low_s32(sorted1));\n            temp = vcombine_s32(temp, vget_low_s32(sorted2));\n            int32x4x2_t zipped = vzipq_s32(vget_low_s32(temp), vget_high_s32(temp));\n            int32x4_t combined = vcombine_s32(zipped.val[0], zipped.val[1]);\n            int32x4_t sorted = vcombine_s32(vget_low_s32(combined), vget_high_s32(combined));\n            vst1q_s32(&result[i], vbslq_s32(mask0, vget_low_s32(sorted), vget_low_s32(vec0)));\n            vst1q_s32(&result[i + 4], vbslq_s32(mask1, vget_high_s32(sorted), vget_low_s32(vec1)));\n            vst1q_s32(&result[i + 8], vbslq_s32(mask2, vget_low_s32(sorted), vget_low_s32(vec2)));\n        }\n\n        indices = vaddq_s32(indices, step);\n    }\n\n    for (int i = 0; i < n; i += 3) {\n        if (i + 3 <= n) {\n            std::sort(&result[i], &result[i + 3]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    int n = l.size();\n    std::vector<int> result(n);\n    int32x4_t indices = vdupq_n_s32(0);\n    int32x4_t step = vdupq_n_s32(3);\n    int32x4_t ones = vdupq_n_s32(1);\n\n    for (int i = 0; i < n; i += 12) {\n        int32x4_t vec0 = vld1q_s32(&l[i]);\n        int32x4_t vec1 = vld1q_s32(&l[i + 4]);\n        int32x4_t vec2 = vld1q_s32(&l[i + 8]);\n\n        uint32x4_t mask0 = vceqq_s32(indices, vdupq_n_s32(0));\n        uint32x4_t mask1 = vceqq_s32(indices, vdupq_n_s32(3));\n        uint32x4_t mask2 = vceqq_s32(indices, vdupq_n_s32(6));\n        uint32x4_t mask3 = vceqq_s32(indices, vdupq_n_s32(9));\n\n        int32x4_t sorted0 = vec0;\n        int32x4_t sorted1 = vec1;\n        int32x4_t sorted2 = vec2;\n\n        if (i + 3 < n) {\n            int32x4_t temp = vcombine_s32(vget_low_s32(sorted0), vget_low_s32(sorted1));\n            temp = vcombine_s32(temp, vget_low_s32(sorted2));\n            int32x4x2_t zipped = vzipq_s32(temp, vcombine_s32(vget_high_s32(sorted0), vget_high_s32(sorted1)));\n            zipped.val[0] = vcombine_s32(zipped.val[0], vget_low_s32(sorted2));\n            zipped.val[1] = vcombine_s32(zipped.val[1], vget_high_s32(sorted2));\n\n            int32x4_t sorted = vcombine_s32(vcombine_s32(vget_low_s32(zipped.val[0]), vget_low_s32(zipped.val[1])),\n                                            vcombine_s32(vget_high_s32(zipped.val[0]), vget_high_s32(zipped.val[1])));\n            std::array<int, 12> arr;\n            vst1q_s32(reinterpret_cast<int32_t*>(arr.data()), sorted);\n\n            std::sort(arr.begin(), arr.begin() + std::min(12, n - i));\n\n            sorted0 = vld1q_s32(arr.data());\n            sorted1 = vld1q_s32(arr.data() + 4);\n            sorted2 = vld1q_s32(arr.data() + 8);\n        }\n\n        int32x4_t result0 = vbslq_s32(mask0, sorted0, vec0);\n        int32x4_t result1 = vbslq_s32(mask1, sorted0, vec1);\n        int32x4_t result2 = vbslq_s32(mask2, sorted0, vec2);\n        int32x4_t result3 = vbslq_s32(mask3, sorted0, vec2);\n\n        vst1q_s32(&result[i], result0);\n        vst1q_s32(&result[i + 4], result1);\n        vst1q_s32(&result[i + 8], result2);\n\n        indices = vaddq_s32(indices, ones);\n        indices = vaddq_s32(indices, ones);\n        indices = vaddq_s32(indices, ones);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    int n = l.size();\n    std::vector<int> result(n);\n    int32x4_t indices = vdupq_n_s32(0);\n    int32x4_t step = vdupq_n_s32(3);\n    int32x4_t ones = vdupq_n_s32(1);\n\n    for (int i = 0; i < n; i += 12) {\n        int32x4_t vec0 = vld1q_s32(&l[i]);\n        int32x4_t vec1 = vld1q_s32(&l[i + 4]);\n        int32x4_t vec2 = vld1q_s32(&l[i + 8]);\n\n        uint32x4_t mask0 = vceqq_s32(indices, vdupq_n_s32(0));\n        uint32x4_t mask1 = vceqq_s32(indices, vdupq_n_s32(3));\n        uint32x4_t mask2 = vceqq_s32(indices, vdupq_n_s32(6));\n        uint32x4_t mask3 = vceqq_s32(indices, vdupq_n_s32(9));\n\n        int32x4_t sorted0 = vec0;\n        int32x4_t sorted1 = vec1;\n        int32x4_t sorted2 = vec2;\n\n        if (i + 0 < n && (i + 0) % 3 == 0) sorted0 = vsetq_lane_s32(l[i + 0], sorted0, 0);\n        if (i + 1 < n && (i + 1) % 3 == 0) sorted0 = vsetq_lane_s32(l[i + 1], sorted0, 1);\n        if (i + 2 < n && (i + 2) % 3 == 0) sorted0 = vsetq_lane_s32(l[i + 2], sorted0, 2);\n        if (i + 3 < n && (i + 3) % 3 == 0) sorted0 = vsetq_lane_s32(l[i + 3], sorted0, 3);\n\n        if (i + 4 < n && (i + 4) % 3 == 0) sorted1 = vsetq_lane_s32(l[i + 4], sorted1, 0);\n        if (i + 5 < n && (i + 5) % 3 == 0) sorted1 = vsetq_lane_s32(l[i + 5], sorted1, 1);\n        if (i + 6 < n && (i + 6) % 3 == 0) sorted1 = vsetq_lane_s32(l[i + 6], sorted1, 2);\n        if (i + 7 < n && (i + 7) % 3 == 0) sorted1 = vsetq_lane_s32(l[i + 7], sorted1, 3);\n\n        if (i + 8 < n && (i + 8) % 3 == 0) sorted2 = vsetq_lane_s32(l[i + 8], sorted2, 0);\n        if (i + 9 < n && (i + 9) % 3 == 0) sorted2 = vsetq_lane_s32(l[i + 9], sorted2, 1);\n        if (i + 10 < n && (i + 10) % 3 == 0) sorted2 = vsetq_lane_s32(l[i + 10], sorted2, 2);\n        if (i + 11 < n && (i + 11) % 3 == 0) sorted2 = vsetq_lane_s32(l[i + 11], sorted2, 3);\n\n        int32_t temp[4];\n        vst1q_s32(temp, sorted0);\n        std::sort(temp, temp + 4);\n        sorted0 = vld1q_s32(temp);\n\n        vst1q_s32(temp, sorted1);\n        std::sort(temp, temp + 4);\n        sorted1 = vld1q_s32(temp);\n\n        vst1q_s32(temp, sorted2);\n        std::sort(temp, temp + 4);\n        sorted2 = vld1q_s32(temp);\n\n        vec0 = vbslq_s32(mask0, sorted0, vec0);\n        vec1 = vbslq_s32(mask1, sorted1, vec1);\n        vec2 = vbslq_s32(mask2, sorted2, vec2);\n\n        vst1q_s32(&result[i], vec0);\n        vst1q_s32(&result[i + 4], vec1);\n        vst1q_s32(&result[i + 8], vec2);\n\n        indices = vaddq_s32(indices, step);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_79_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nfloat max_element_simd(const std::vector<float>& l) {\n    float32x4_t max_vec = vdupq_n_f32(l[0]);\n    size_t i = 0;\n    size_t n = l.size();\n\n    for (; i <= n - 4; i += 4) {\n        float32x4_t vec = vld1q_f32(&l[i]);\n        max_vec = vmaxq_f32(max_vec, vec);\n    }\n\n    float32x2_t max_pair1 = vpmax_f32(vget_low_f32(max_vec), vget_high_f32(max_vec));\n    float32x2_t max_pair2 = vpmax_f32(max_pair1, max_pair1);\n    float max_val = vget_lane_f32(max_pair2, 0);\n\n    for (; i < n; ++i) {\n        max_val = std::max(max_val, l[i]);\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nfloat max_element_simd(const std::vector<float>& l) {\n    float32x4_t max_vec = vdupq_n_f32(l[0]);\n    size_t i = 0;\n    size_t length = l.size();\n\n    for (; i <= length - 4; i += 4) {\n        float32x4_t vec = vld1q_f32(&l[i]);\n        max_vec = vmaxq_f32(max_vec, vec);\n    }\n\n    float max_values[4];\n    vst1q_f32(max_values, max_vec);\n\n    float max_value = *std::max_element(max_values, max_values + 4);\n\n    for (; i < length; ++i) {\n        max_value = std::max(max_value, l[i]);\n    }\n\n    return max_value;\n}\n```"}
{"task_id": "SimdBench_79_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nfloat max_element_simd(const std::vector<float>& l) {\n    float32x4_t max_val = vdupq_n_f32(l[0]);\n    size_t i = 0;\n    size_t length = l.size();\n\n    for (; i <= length - 4; i += 4) {\n        float32x4_t vec = vld1q_f32(&l[i]);\n        max_val = vmaxq_f32(max_val, vec);\n    }\n\n    float32x2_t max_pair1 = vpmax_f32(vget_low_f32(max_val), vget_high_f32(max_val));\n    float32x2_t max_pair2 = vpmax_f32(max_pair1, max_pair1);\n    float max_scalar = vget_lane_f32(max_pair2, 0);\n\n    for (; i < length; ++i) {\n        max_scalar = std::max(max_scalar, l[i]);\n    }\n\n    return max_scalar;\n}\n```"}
{"task_id": "SimdBench_79_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nfloat max_element_simd(std::vector<float> l) {\n    float32x4_t max_vec = vdupq_n_f32(l[0]);\n    size_t i = 0;\n    size_t length = l.size();\n\n    for (; i <= length - 4; i += 4) {\n        float32x4_t vec = vld1q_f32(&l[i]);\n        max_vec = vmaxq_f32(max_vec, vec);\n    }\n\n    float32x2_t max_pair1 = vpmax_f32(vget_low_f32(max_vec), vget_high_f32(max_vec));\n    float32x2_t max_pair2 = vpmax_f32(max_pair1, max_pair1);\n    float max_val = vget_lane_f32(max_pair2, 0);\n\n    for (; i < length; ++i) {\n        max_val = std::max(max_val, l[i]);\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nfloat max_element_simd(std::vector<float> l) {\n    float32x4_t max_val = vdupq_n_f32(l[0]);\n    size_t i = 0;\n    size_t length = l.size();\n\n    for (; i <= length - 4; i += 4) {\n        float32x4_t vec = vld1q_f32(&l[i]);\n        max_val = vmaxq_f32(max_val, vec);\n    }\n\n    float32x2_t max_pair1 = vpmax_f32(vget_low_f32(max_val), vget_high_f32(max_val));\n    float32x2_t max_pair2 = vpmax_f32(max_pair1, max_pair1);\n    float max_result;\n    vst1_f32(&max_result, max_pair2);\n\n    for (; i < length; ++i) {\n        max_result = std::max(max_result, l[i]);\n    }\n\n    return max_result;\n}\n```"}
{"task_id": "SimdBench_80_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    int i = 0;\n    uint8x16_t seven = vdupq_n_u8('7');\n    uint8x16_t zero = vdupq_n_u8(0);\n\n    for (; i <= n - 16; i += 16) {\n        uint32x4_t indices = vld1q_u32((uint32_t*)&i);\n        uint32x4_t inc = vdupq_n_u32(1);\n        uint32x4_t nums1 = vaddq_u32(indices, inc);\n        uint32x4_t nums2 = vaddq_u32(nums1, inc);\n        uint32x4_t nums3 = vaddq_u32(nums2, inc);\n        uint32x4_t nums4 = vaddq_u32(nums3, inc);\n\n        uint32x4_t mask1 = vorrq_u32(vceqq_u32(vmodq_u32(nums1, vdupq_n_u32(11)), vdupq_n_u32(0)),\n                                    vceqq_u32(vmodq_u32(nums1, vdupq_n_u32(13)), vdupq_n_u32(0)));\n        uint32x4_t mask2 = vorrq_u32(vceqq_u32(vmodq_u32(nums2, vdupq_n_u32(11)), vdupq_n_u32(0)),\n                                    vceqq_u32(vmodq_u32(nums2, vdupq_n_u32(13)), vdupq_n_u32(0)));\n        uint32x4_t mask3 = vorrq_u32(vceqq_u32(vmodq_u32(nums3, vdupq_n_u32(11)), vdupq_n_u32(0)),\n                                    vceqq_u32(vmodq_u32(nums3, vdupq_n_u32(13)), vdupq_n_u32(0)));\n        uint32x4_t mask4 = vorrq_u32(vceqq_u32(vmodq_u32(nums4, vdupq_n_u32(11)), vdupq_n_u32(0)),\n                                    vceqq_u32(vmodq_u32(nums4, vdupq_n_u32(13)), vdupq_n_u32(0)));\n\n        uint8x16_t str1 = vcvtq_u8_u32(nums1);\n        uint8x16_t str2 = vcvtq_u8_u32(nums2);\n        uint8x16_t str3 = vcvtq_u8_u32(nums3);\n        uint8x16_t str4 = vcvtq_u8_u32(nums4);\n\n        uint8x16_t cmp1 = vandq_u8(mask1, veorq_u8(vceqq_u8(str1, seven), zero));\n        uint8x16_t cmp2 = vandq_u8(mask2, veorq_u8(vceqq_u8(str2, seven), zero));\n        uint8x16_t cmp3 = vandq_u8(mask3, veorq_u8(vceqq_u8(str3, seven), zero));\n        uint8x16_t cmp4 = vandq_u8(mask4, veorq_u8(vceqq_u8(str4, seven), zero));\n\n        count += vaddvq_u8(cmp1);\n        count += vaddvq_u8(cmp2);\n        count += vaddvq_u8(cmp3);\n        count += vaddvq_u8(cmp4);\n    }\n\n    for (; i < n; i++) {\n        if ((i % 11 == 0 || i % 13 == 0) && (i == 7 || (i >= 10 && (i / 10 == 7 || i % 10 == 7)))) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    int i = 0;\n    uint8x16_t seven = vdupq_n_u8('7');\n    uint8x16_t zero = vdupq_n_u8(0);\n\n    for (; i <= n - 16; i += 16) {\n        uint32x4_t indices = vld1q_u32((uint32_t*)&i);\n        uint32x4_t inc = vdupq_n_u32(1);\n        uint32x4_t nums1 = vaddq_u32(indices, inc);\n        uint32x4_t nums2 = vaddq_u32(nums1, inc);\n        uint32x4_t nums3 = vaddq_u32(nums2, inc);\n        uint32x4_t nums4 = vaddq_u32(nums3, inc);\n\n        uint32x4_t mask1 = vorrq_u32(vceqq_u32(vmodq_u32(nums1, vdupq_n_u32(11)), vdupq_n_u32(0)),\n                                    vceqq_u32(vmodq_u32(nums1, vdupq_n_u32(13)), vdupq_n_u32(0)));\n        uint32x4_t mask2 = vorrq_u32(vceqq_u32(vmodq_u32(nums2, vdupq_n_u32(11)), vdupq_n_u32(0)),\n                                    vceqq_u32(vmodq_u32(nums2, vdupq_n_u32(13)), vdupq_n_u32(0)));\n        uint32x4_t mask3 = vorrq_u32(vceqq_u32(vmodq_u32(nums3, vdupq_n_u32(11)), vdupq_n_u32(0)),\n                                    vceqq_u32(vmodq_u32(nums3, vdupq_n_u32(13)), vdupq_n_u32(0)));\n        uint32x4_t mask4 = vorrq_u32(vceqq_u32(vmodq_u32(nums4, vdupq_n_u32(11)), vdupq_n_u32(0)),\n                                    vceqq_u32(vmodq_u32(nums4, vdupq_n_u32(13)), vdupq_n_u32(0)));\n\n        uint8x16_t str1 = vcvtq_u8_u32(nums1);\n        uint8x16_t str2 = vcvtq_u8_u32(nums2);\n        uint8x16_t str3 = vcvtq_u8_u32(nums3);\n        uint8x16_t str4 = vcvtq_u8_u32(nums4);\n\n        uint8x16_t cmp1 = vandq_u8(mask1, veorq_u8(vceqq_u8(str1, seven), zero));\n        uint8x16_t cmp2 = vandq_u8(mask2, veorq_u8(vceqq_u8(str2, seven), zero));\n        uint8x16_t cmp3 = vandq_u8(mask3, veorq_u8(vceqq_u8(str3, seven), zero));\n        uint8x16_t cmp4 = vandq_u8(mask4, veorq_u8(vceqq_u8(str4, seven), zero));\n\n        count += vaddvq_u8(cmp1);\n        count += vaddvq_u8(cmp2);\n        count += vaddvq_u8(cmp3);\n        count += vaddvq_u8(cmp4);\n    }\n\n    for (; i < n; i++) {\n        if ((i % 11 == 0 || i % 13 == 0) && (i == 7 || (i >= 10 && (i / 10 == 7 || i % 10 == 7)))) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    int i = 0;\n    uint8x16_t seven = vdupq_n_u8('7');\n    uint8x16_t zero = vdupq_n_u8(0);\n\n    for (; i <= n - 16; i += 16) {\n        uint32x4_t indices = vld1q_u32((uint32_t*)&i);\n        uint32x4_t inc = vdupq_n_u32(1);\n        uint32x4_t nums1 = vaddq_u32(indices, inc);\n        uint32x4_t nums2 = vaddq_u32(nums1, inc);\n        uint32x4_t nums3 = vaddq_u32(nums2, inc);\n        uint32x4_t nums4 = vaddq_u32(nums3, inc);\n\n        uint32x4_t mask1 = vorrq_u32(vceqq_u32(vmodq_u32(nums1, vdupq_n_u32(11)), vdupq_n_u32(0)),\n                                    vceqq_u32(vmodq_u32(nums1, vdupq_n_u32(13)), vdupq_n_u32(0)));\n        uint32x4_t mask2 = vorrq_u32(vceqq_u32(vmodq_u32(nums2, vdupq_n_u32(11)), vdupq_n_u32(0)),\n                                    vceqq_u32(vmodq_u32(nums2, vdupq_n_u32(13)), vdupq_n_u32(0)));\n        uint32x4_t mask3 = vorrq_u32(vceqq_u32(vmodq_u32(nums3, vdupq_n_u32(11)), vdupq_n_u32(0)),\n                                    vceqq_u32(vmodq_u32(nums3, vdupq_n_u32(13)), vdupq_n_u32(0)));\n        uint32x4_t mask4 = vorrq_u32(vceqq_u32(vmodq_u32(nums4, vdupq_n_u32(11)), vdupq_n_u32(0)),\n                                    vceqq_u32(vmodq_u32(nums4, vdupq_n_u32(13)), vdupq_n_u32(0)));\n\n        uint8x16_t str1 = vcvtq_u8_u32(nums1);\n        uint8x16_t str2 = vcvtq_u8_u32(nums2);\n        uint8x16_t str3 = vcvtq_u8_u32(nums3);\n        uint8x16_t str4 = vcvtq_u8_u32(nums4);\n\n        uint8x16_t cmp1 = vandq_u8(mask1, veorq_u8(vceqq_u8(str1, seven), zero));\n        uint8x16_t cmp2 = vandq_u8(mask2, veorq_u8(vceqq_u8(str2, seven), zero));\n        uint8x16_t cmp3 = vandq_u8(mask3, veorq_u8(vceqq_u8(str3, seven), zero));\n        uint8x16_t cmp4 = vandq_u8(mask4, veorq_u8(vceqq_u8(str4, seven), zero));\n\n        count += vaddvq_u8(cmp1) + vaddvq_u8(cmp2) + vaddvq_u8(cmp3) + vaddvq_u8(cmp4);\n    }\n\n    for (; i < n; i++) {\n        if ((i % 11 == 0 || i % 13 == 0) && (i == 7 || (i >= 10 && (i / 10 == 7 || i % 10 == 7)))) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    int i = 0;\n    uint8x16_t seven = vdupq_n_u8('7');\n    uint8x16_t zero = vdupq_n_u8(0);\n\n    for (; i <= n - 16; i += 16) {\n        uint32x4_t indices = vld1q_u32((uint32_t*)&i);\n        uint32x4_t inc = vdupq_n_u32(1);\n        uint32x4_t nums1 = vaddq_u32(indices, inc);\n        uint32x4_t nums2 = vaddq_u32(nums1, inc);\n        uint32x4_t nums3 = vaddq_u32(nums2, inc);\n        uint32x4_t nums4 = vaddq_u32(nums3, inc);\n\n        uint32x4_t mask1 = vorrq_u32(vceqq_u32(vmodq_u32(nums1, vdupq_n_u32(11)), vdupq_n_u32(0)),\n                                    vceqq_u32(vmodq_u32(nums1, vdupq_n_u32(13)), vdupq_n_u32(0)));\n        uint32x4_t mask2 = vorrq_u32(vceqq_u32(vmodq_u32(nums2, vdupq_n_u32(11)), vdupq_n_u32(0)),\n                                    vceqq_u32(vmodq_u32(nums2, vdupq_n_u32(13)), vdupq_n_u32(0)));\n        uint32x4_t mask3 = vorrq_u32(vceqq_u32(vmodq_u32(nums3, vdupq_n_u32(11)), vdupq_n_u32(0)),\n                                    vceqq_u32(vmodq_u32(nums3, vdupq_n_u32(13)), vdupq_n_u32(0)));\n        uint32x4_t mask4 = vorrq_u32(vceqq_u32(vmodq_u32(nums4, vdupq_n_u32(11)), vdupq_n_u32(0)),\n                                    vceqq_u32(vmodq_u32(nums4, vdupq_n_u32(13)), vdupq_n_u32(0)));\n\n        uint8x16_t str1 = vcvtq_u8_u32(nums1);\n        uint8x16_t str2 = vcvtq_u8_u32(nums2);\n        uint8x16_t str3 = vcvtq_u8_u32(nums3);\n        uint8x16_t str4 = vcvtq_u8_u32(nums4);\n\n        uint8x16_t cmp1 = vandq_u8(mask1, veorq_u8(vceqq_u8(str1, seven), zero));\n        uint8x16_t cmp2 = vandq_u8(mask2, veorq_u8(vceqq_u8(str2, seven), zero));\n        uint8x16_t cmp3 = vandq_u8(mask3, veorq_u8(vceqq_u8(str3, seven), zero));\n        uint8x16_t cmp4 = vandq_u8(mask4, veorq_u8(vceqq_u8(str4, seven), zero));\n\n        count += vaddvq_u8(cmp1);\n        count += vaddvq_u8(cmp2);\n        count += vaddvq_u8(cmp3);\n        count += vaddvq_u8(cmp4);\n    }\n\n    for (; i < n; i++) {\n        if ((i % 11 == 0 || i % 13 == 0) && (i == 7 || (i >= 10 && (i / 10 == 7 || i % 10 == 7)))) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    int i = 0;\n    uint8x16_t seven = vdupq_n_u8('7');\n    uint8x16_t zero = vdupq_n_u8(0);\n\n    for (; i <= n - 16; i += 16) {\n        uint32x4_t indices = vld1q_u32((uint32_t*)&i);\n        uint32x4_t inc = vdupq_n_u32(1);\n        uint32x4_t nums1 = vaddq_u32(indices, inc);\n        uint32x4_t nums2 = vaddq_u32(nums1, inc);\n        uint32x4_t nums3 = vaddq_u32(nums2, inc);\n        uint32x4_t nums4 = vaddq_u32(nums3, inc);\n\n        uint32x4_t mask1 = vorrq_u32(vceqq_u32(vmodq_u32(nums1, vdupq_n_u32(11)), vdupq_n_u32(0)),\n                                    vceqq_u32(vmodq_u32(nums1, vdupq_n_u32(13)), vdupq_n_u32(0)));\n        uint32x4_t mask2 = vorrq_u32(vceqq_u32(vmodq_u32(nums2, vdupq_n_u32(11)), vdupq_n_u32(0)),\n                                    vceqq_u32(vmodq_u32(nums2, vdupq_n_u32(13)), vdupq_n_u32(0)));\n        uint32x4_t mask3 = vorrq_u32(vceqq_u32(vmodq_u32(nums3, vdupq_n_u32(11)), vdupq_n_u32(0)),\n                                    vceqq_u32(vmodq_u32(nums3, vdupq_n_u32(13)), vdupq_n_u32(0)));\n        uint32x4_t mask4 = vorrq_u32(vceqq_u32(vmodq_u32(nums4, vdupq_n_u32(11)), vdupq_n_u32(0)),\n                                    vceqq_u32(vmodq_u32(nums4, vdupq_n_u32(13)), vdupq_n_u32(0)));\n\n        uint8x16_t str1 = vcvtq_u8_u32(nums1);\n        uint8x16_t str2 = vcvtq_u8_u32(nums2);\n        uint8x16_t str3 = vcvtq_u8_u32(nums3);\n        uint8x16_t str4 = vcvtq_u8_u32(nums4);\n\n        uint8x16_t cmp1 = vandq_u8(mask1, veorq_u8(vceqq_u8(str1, seven), zero));\n        uint8x16_t cmp2 = vandq_u8(mask2, veorq_u8(vceqq_u8(str2, seven), zero));\n        uint8x16_t cmp3 = vandq_u8(mask3, veorq_u8(vceqq_u8(str3, seven), zero));\n        uint8x16_t cmp4 = vandq_u8(mask4, veorq_u8(vceqq_u8(str4, seven), zero));\n\n        count += vaddvq_u8(cmp1);\n        count += vaddvq_u8(cmp2);\n        count += vaddvq_u8(cmp3);\n        count += vaddvq_u8(cmp4);\n    }\n\n    for (; i < n; i++) {\n        if ((i % 11 == 0 || i % 13 == 0) && (i == 7 || (i >= 10 && (i / 10 == 7 || i % 10 == 7)))) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_81_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    int n = l.size();\n    if (n < 2) return l;\n\n    std::vector<float> even_elements;\n    for (int i = 0; i < n; i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    std::sort(even_elements.begin(), even_elements.end());\n\n    float32x4_t even_vec, result_vec;\n    int even_index = 0;\n\n    for (int i = 0; i < n; i += 4) {\n        float32x4_t input_vec = vld1q_f32(&l[i]);\n\n        if (i + 2 < n) {\n            even_vec = vsetq_lane_f32(even_elements[even_index], even_vec, 0);\n            even_vec = vsetq_lane_f32(even_elements[even_index + 1], even_vec, 2);\n            even_index += 2;\n        } else if (i < n) {\n            even_vec = vsetq_lane_f32(even_elements[even_index], even_vec, 0);\n            even_index += 1;\n        }\n\n        uint32x4_t mask = vmovq_n_u32(0x55555555); // 01010101 in binary\n        result_vec = vbslq_f32(mask, even_vec, input_vec);\n\n        vst1q_f32(&l[i], result_vec);\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_81_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    int n = l.size();\n    if (n < 2) return l;\n\n    std::vector<float> even_elements;\n    for (int i = 0; i < n; i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    std::sort(even_elements.begin(), even_elements.end());\n\n    float32x4_t even_vec, result_vec;\n    int even_index = 0;\n\n    for (int i = 0; i < n; i += 4) {\n        float32x4_t input_vec = vld1q_f32(&l[i]);\n\n        if (i + 2 < n) {\n            even_vec = vsetq_lane_f32(even_elements[even_index++], even_vec, 0);\n            even_vec = vsetq_lane_f32(even_elements[even_index++], even_vec, 2);\n        } else if (i < n) {\n            even_vec = vsetq_lane_f32(even_elements[even_index++], even_vec, 0);\n        }\n\n        result_vec = vbslq_f32(vcreate_u32(0xAAAAAAAAAAAAAAAA), input_vec, even_vec);\n\n        vst1q_f32(&l[i], result_vec);\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_81_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    int n = l.size();\n    if (n < 2) return l;\n\n    std::vector<float> even_elements;\n    for (int i = 0; i < n; i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    std::sort(even_elements.begin(), even_elements.end());\n\n    float32x4_t even_vec, result_vec;\n    int even_index = 0;\n\n    for (int i = 0; i < n; i += 4) {\n        float32x4_t input_vec = vld1q_f32(&l[i]);\n\n        if (i + 2 < n) {\n            even_vec = vsetq_lane_f32(even_elements[even_index], even_vec, 0);\n            even_vec = vsetq_lane_f32(even_elements[even_index + 1], even_vec, 2);\n            even_index += 2;\n        } else if (i < n) {\n            even_vec = vsetq_lane_f32(even_elements[even_index], even_vec, 0);\n            even_index += 1;\n        }\n\n        uint32x4_t mask = vmovq_n_u32(0x55555555); // 01010101 in binary\n        result_vec = vbslq_f32(mask, even_vec, input_vec);\n\n        vst1q_f32(&l[i], result_vec);\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_81_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    int n = l.size();\n    if (n < 2) return l;\n\n    std::vector<float> even_elements;\n    for (int i = 0; i < n; i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    std::sort(even_elements.begin(), even_elements.end());\n\n    float32x4_t even_vec, result_vec;\n    int even_index = 0;\n\n    for (int i = 0; i < n; i += 4) {\n        float32x4_t input_vec = vld1q_f32(&l[i]);\n\n        if (i + 2 < n) {\n            even_vec = vsetq_lane_f32(even_elements[even_index], even_vec, 0);\n            even_vec = vsetq_lane_f32(even_elements[even_index + 1], even_vec, 2);\n            even_index += 2;\n        } else if (i < n) {\n            even_vec = vsetq_lane_f32(even_elements[even_index], even_vec, 0);\n            even_index += 1;\n        }\n\n        uint32x4_t mask = vmovq_n_u32(0x55555555); // 01010101 in binary\n        result_vec = vbslq_f32(mask, even_vec, input_vec);\n\n        vst1q_f32(&l[i], result_vec);\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_81_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    int n = l.size();\n    if (n < 2) return l;\n\n    std::vector<float> even_elements;\n    for (int i = 0; i < n; i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    std::sort(even_elements.begin(), even_elements.end());\n\n    float32x4_t even_vec, l_vec;\n    int even_index = 0;\n\n    for (int i = 0; i < n; i += 4) {\n        l_vec = vld1q_f32(&l[i]);\n\n        if (i + 2 < n) {\n            even_vec = vsetq_lane_f32(even_elements[even_index++], even_vec, 0);\n            even_vec = vsetq_lane_f32(even_elements[even_index++], even_vec, 2);\n            l_vec = vsetq_lane_f32(vgetq_lane_f32(even_vec, 0), l_vec, 0);\n            l_vec = vsetq_lane_f32(vgetq_lane_f32(even_vec, 2), l_vec, 2);\n        } else if (i < n) {\n            even_vec = vsetq_lane_f32(even_elements[even_index++], even_vec, 0);\n            l_vec = vsetq_lane_f32(vgetq_lane_f32(even_vec, 0), l_vec, 0);\n        }\n\n        vst1q_f32(&l[i], l_vec);\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_82_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    for (int i = 0; i < n - 2; ++i) {\n        int32x4_t vi = vdupq_n_s32(l[i]);\n        for (int j = i + 1; j < n - 1; j += 4) {\n            int32x4_t vj = vld1q_s32(&l[j]);\n            int32x4_t vk = vld1q_s32(&l[j + 1]);\n\n            int32x4_t sum1 = vaddq_s32(vi, vj);\n            int32x4_t sum2 = vaddq_s32(vi, vk);\n\n            uint32x4_t cmp1 = vceqq_s32(sum1, vnegq_s32(vk));\n            uint32x4_t cmp2 = vceqq_s32(sum2, vnegq_s32(vj));\n\n            if (vmaxvq_u32(cmp1) || vmaxvq_u32(cmp2)) {\n                return true;\n            }\n\n            if (j + 3 < n) {\n                vk = vld1q_s32(&l[j + 2]);\n                sum2 = vaddq_s32(vi, vk);\n                cmp2 = vceqq_s32(sum2, vnegq_s32(vj));\n                if (vmaxvq_u32(cmp2)) {\n                    return true;\n                }\n            }\n\n            if (j + 4 < n) {\n                vk = vld1q_s32(&l[j + 3]);\n                sum2 = vaddq_s32(vi, vk);\n                cmp2 = vceqq_s32(sum2, vnegq_s32(vj));\n                if (vmaxvq_u32(cmp2)) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    for (int i = 0; i < n - 2; ++i) {\n        int32x4_t vi = vdupq_n_s32(l[i]);\n        for (int j = i + 1; j < n - 1; j += 4) {\n            int32x4_t vj = vld1q_s32(&l[j]);\n            int32x4_t vk = vld1q_s32(&l[j + 1]);\n\n            int32x4_t sum1 = vaddq_s32(vi, vj);\n            int32x4_t sum2 = vaddq_s32(vi, vk);\n\n            uint32x4_t cmp1 = vceqq_s32(sum1, vnegq_s32(vk));\n            uint32x4_t cmp2 = vceqq_s32(sum2, vnegq_s32(vj));\n\n            if (vmaxvq_u32(cmp1) || vmaxvq_u32(cmp2)) {\n                return true;\n            }\n\n            if (j + 3 < n) {\n                vk = vld1q_s32(&l[j + 2]);\n                sum1 = vaddq_s32(vi, vj);\n                sum2 = vaddq_s32(vi, vk);\n\n                cmp1 = vceqq_s32(sum1, vnegq_s32(vk));\n                cmp2 = vceqq_s32(sum2, vnegq_s32(vj));\n\n                if (vmaxvq_u32(cmp1) || vmaxvq_u32(cmp2)) {\n                    return true;\n                }\n            }\n\n            if (j + 4 < n) {\n                vk = vld1q_s32(&l[j + 3]);\n                sum1 = vaddq_s32(vi, vj);\n                sum2 = vaddq_s32(vi, vk);\n\n                cmp1 = vceqq_s32(sum1, vnegq_s32(vk));\n                cmp2 = vceqq_s32(sum2, vnegq_s32(vj));\n\n                if (vmaxvq_u32(cmp1) || vmaxvq_u32(cmp2)) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    for (int i = 0; i < n - 2; ++i) {\n        int32x4_t vi = vdupq_n_s32(l[i]);\n        for (int j = i + 1; j < n - 1; j += 4) {\n            int32x4_t vj = vld1q_s32(&l[j]);\n            int32x4_t vk = vld1q_s32(&l[j + 1]);\n            int32x4_t vsum1 = vaddq_s32(vi, vj);\n            int32x4_t vsum2 = vaddq_s32(vi, vk);\n\n            uint32x4_t vmask1 = vceqq_s32(vsum1, vnegq_s32(vk));\n            uint32x4_t vmask2 = vceqq_s32(vsum2, vnegq_s32(vj));\n\n            if (vmaxvq_u32(vmask1) || vmaxvq_u32(vmask2)) {\n                return true;\n            }\n\n            if (j + 3 < n) {\n                vk = vld1q_s32(&l[j + 2]);\n                vsum1 = vaddq_s32(vi, vj);\n                vsum2 = vaddq_s32(vi, vk);\n\n                vmask1 = vceqq_s32(vsum1, vnegq_s32(vk));\n                vmask2 = vceqq_s32(vsum2, vnegq_s32(vj));\n\n                if (vmaxvq_u32(vmask1) || vmaxvq_u32(vmask2)) {\n                    return true;\n                }\n            }\n\n            if (j + 4 < n) {\n                vk = vld1q_s32(&l[j + 3]);\n                vsum1 = vaddq_s32(vi, vj);\n                vsum2 = vaddq_s32(vi, vk);\n\n                vmask1 = vceqq_s32(vsum1, vnegq_s32(vk));\n                vmask2 = vceqq_s32(vsum2, vnegq_s32(vj));\n\n                if (vmaxvq_u32(vmask1) || vmaxvq_u32(vmask2)) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    for (int i = 0; i < n - 2; ++i) {\n        int32x4_t vi = vdupq_n_s32(l[i]);\n        for (int j = i + 1; j < n - 1; j += 4) {\n            int32x4_t vj = vld1q_s32(&l[j]);\n            int32x4_t vk = vld1q_s32(&l[j + 1]);\n            int32x4_t vsum1 = vaddq_s32(vi, vj);\n            int32x4_t vsum2 = vaddq_s32(vi, vk);\n\n            uint32x4_t vmask1 = vceqq_s32(vsum1, vnegq_s32(vk));\n            uint32x4_t vmask2 = vceqq_s32(vsum2, vnegq_s32(vj));\n\n            if (vmaxvq_u32(vmask1) || vmaxvq_u32(vmask2)) {\n                return true;\n            }\n\n            if (j + 3 < n - 1) {\n                vk = vld1q_s32(&l[j + 2]);\n                vsum1 = vaddq_s32(vi, vj);\n                vsum2 = vaddq_s32(vi, vk);\n\n                vmask1 = vceqq_s32(vsum1, vnegq_s32(vk));\n                vmask2 = vceqq_s32(vsum2, vnegq_s32(vj));\n\n                if (vmaxvq_u32(vmask1) || vmaxvq_u32(vmask2)) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    for (int i = 0; i < n - 2; ++i) {\n        int32x4_t vi = vdupq_n_s32(l[i]);\n        for (int j = i + 1; j < n - 1; j += 4) {\n            int32x4_t vj = vld1q_s32(&l[j]);\n            int32x4_t vk = vld1q_s32(&l[j + 1]);\n            int32x4_t vsum1 = vaddq_s32(vi, vj);\n            int32x4_t vsum2 = vaddq_s32(vi, vk);\n\n            uint32x4_t vmask1 = vceqq_s32(vsum1, vnegq_s32(vk));\n            uint32x4_t vmask2 = vceqq_s32(vsum2, vnegq_s32(vj));\n\n            if (vmaxvq_u32(vmask1) || vmaxvq_u32(vmask2)) {\n                return true;\n            }\n        }\n        for (int j = i + 1; j < n - 1; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                if (l[i] + l[j] + l[k] == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_83_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    int n = l.size();\n    std::vector<int> result(n);\n\n    int i = 0;\n    for (; i <= n - 8; i += 8) {\n        int32x4_t vec1 = vld1q_s32(&l[i]);\n        int32x4_t vec2 = vld1q_s32(&l[i + 4]);\n        int32x4_t inc_vec = vdupq_n_s32(1);\n        vec1 = vaddq_s32(vec1, inc_vec);\n        vec2 = vaddq_s32(vec2, inc_vec);\n        vst1q_s32(&result[i], vec1);\n        vst1q_s32(&result[i + 4], vec2);\n    }\n\n    for (; i < n; ++i) {\n        result[i] = l[i] + 1;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    int n = l.size();\n    int* data = l.data();\n    int i = 0;\n\n    // Process 4 integers at a time\n    for (; i <= n - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&data[i]);\n        vec = vaddq_s32(vec, vdupq_n_s32(1));\n        vst1q_s32(&data[i], vec);\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        data[i] += 1;\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_83_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    int n = l.size();\n    std::vector<int> result(n);\n\n    int i = 0;\n    for (; i <= n - 8; i += 8) {\n        int32x4_t vec1 = vld1q_s32(&l[i]);\n        int32x4_t vec2 = vld1q_s32(&l[i + 4]);\n        int32x4_t inc_vec = vdupq_n_s32(1);\n        vec1 = vaddq_s32(vec1, inc_vec);\n        vec2 = vaddq_s32(vec2, inc_vec);\n        vst1q_s32(&result[i], vec1);\n        vst1q_s32(&result[i + 4], vec2);\n    }\n\n    for (; i < n; ++i) {\n        result[i] = l[i] + 1;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    int n = l.size();\n    std::vector<int> result(n);\n\n    int i = 0;\n    for (; i <= n - 8; i += 8) {\n        int32x4_t vec1 = vld1q_s32(&l[i]);\n        int32x4_t vec2 = vld1q_s32(&l[i + 4]);\n        int32x4_t inc_vec = vdupq_n_s32(1);\n        vec1 = vaddq_s32(vec1, inc_vec);\n        vec2 = vaddq_s32(vec2, inc_vec);\n        vst1q_s32(&result[i], vec1);\n        vst1q_s32(&result[i + 4], vec2);\n    }\n\n    for (; i < n; ++i) {\n        result[i] = l[i] + 1;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    int n = l.size();\n    std::vector<int> result(n);\n\n    int i = 0;\n    for (; i <= n - 8; i += 8) {\n        int32x4_t vec1 = vld1q_s32(&l[i]);\n        int32x4_t vec2 = vld1q_s32(&l[i + 4]);\n        int32x4_t inc_vec = vdupq_n_s32(1);\n        vec1 = vaddq_s32(vec1, inc_vec);\n        vec2 = vaddq_s32(vec2, inc_vec);\n        vst1q_s32(&result[i], vec1);\n        vst1q_s32(&result[i + 4], vec2);\n    }\n\n    for (; i < n; ++i) {\n        result[i] = l[i] + 1;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_84_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(const std::vector<int>& l) {\n    int n = l.size();\n    if (n < 2) return false;\n\n    int32x4_t vec1, vec2, neg_vec1;\n    int32x4_t zero = vdupq_n_s32(0);\n    uint32x4_t mask;\n\n    for (int i = 0; i < n; i += 4) {\n        vec1 = vld1q_s32(&l[i]);\n        neg_vec1 = vnegq_s32(vec1);\n\n        for (int j = i + 4; j < n; j += 4) {\n            vec2 = vld1q_s32(&l[j]);\n            mask = vceqq_s32(neg_vec1, vec2);\n            if (vmaxvq_u32(mask)) return true;\n        }\n\n        // Check for pairs within the same loaded vector\n        mask = vceqq_s32(vec1, vextq_s32(vec1, vec1, 1));\n        if (vmaxvq_u32(mask)) return true;\n        mask = vceqq_s32(vec1, vextq_s32(vec1, vec1, 2));\n        if (vmaxvq_u32(mask)) return true;\n        mask = vceqq_s32(vec1, vextq_s32(vec1, vec1, 3));\n        if (vmaxvq_u32(mask)) return true;\n    }\n\n    // Check remaining elements\n    for (int i = (n / 4) * 4; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (l[i] + l[j] == 0) return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 2) return false;\n\n    int32x4_t vec1, vec2, neg_vec1, zero_vec = vdupq_n_s32(0);\n    uint32x4_t cmp_result;\n\n    for (int i = 0; i < n; i += 4) {\n        vec1 = vld1q_s32(&l[i]);\n        neg_vec1 = vnegq_s32(vec1);\n\n        for (int j = i + 4; j < n; j += 4) {\n            vec2 = vld1q_s32(&l[j]);\n            cmp_result = vceqq_s32(vdupq_laneq_s32(neg_vec1, 0), vec2);\n            if (vmaxvq_u32(cmp_result)) return true;\n            cmp_result = vceqq_s32(vdupq_laneq_s32(neg_vec1, 1), vec2);\n            if (vmaxvq_u32(cmp_result)) return true;\n            cmp_result = vceqq_s32(vdupq_laneq_s32(neg_vec1, 2), vec2);\n            if (vmaxvq_u32(cmp_result)) return true;\n            cmp_result = vceqq_s32(vdupq_laneq_s32(neg_vec1, 3), vec2);\n            if (vmaxvq_u32(cmp_result)) return true;\n        }\n\n        // Handle remaining elements in the second vector\n        for (int j = (n / 4) * 4; j < n; ++j) {\n            if (l[i] == -l[j] || l[i + 1] == -l[j] || l[i + 2] == -l[j] || l[i + 3] == -l[j]) {\n                return true;\n            }\n        }\n    }\n\n    // Handle remaining elements in the first vector\n    for (int i = (n / 4) * 4; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (l[i] == -l[j]) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 2) return false;\n\n    int32x4_t vec1, vec2, neg_vec1;\n    int32x4_t zero = vdupq_n_s32(0);\n    uint32x4_t mask;\n\n    for (int i = 0; i < n; i += 4) {\n        vec1 = vld1q_s32(&l[i]);\n        neg_vec1 = vnegq_s32(vec1);\n\n        for (int j = i + 4; j < n; j += 4) {\n            vec2 = vld1q_s32(&l[j]);\n            mask = vceqq_s32(vneg_vec1, vec2);\n            if (vmaxvq_u32(mask)) return true;\n        }\n\n        // Check for pairs within the same loaded vector\n        mask = vceqq_s32(vec1, vextq_s32(neg_vec1, neg_vec1, 1));\n        if (vmaxvq_u32(mask)) return true;\n        mask = vceqq_s32(vec1, vextq_s32(neg_vec1, neg_vec1, 2));\n        if (vmaxvq_u32(mask)) return true;\n        mask = vceqq_s32(vec1, vextq_s32(neg_vec1, neg_vec1, 3));\n        if (vmaxvq_u32(mask)) return true;\n    }\n\n    // Check remaining elements\n    for (int i = (n / 4) * 4; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (l[i] + l[j] == 0) return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(const std::vector<int>& l) {\n    int n = l.size();\n    if (n < 2) return false;\n\n    int32x4_t vec1, vec2, neg_vec1, zero_vec = vdupq_n_s32(0);\n    int32x4_t cmp_result;\n    uint32x4_t mask;\n\n    for (int i = 0; i < n; i += 4) {\n        vec1 = vld1q_s32(&l[i]);\n        neg_vec1 = vnegq_s32(vec1);\n\n        for (int j = i + 4; j < n; j += 4) {\n            vec2 = vld1q_s32(&l[j]);\n            cmp_result = vceqq_s32(vec2, neg_vec1);\n            mask = vandq_u32(vmovq_n_u32(0xFFFFFFFF), vreinterpretq_u32_s32(cmp_result));\n\n            if (vmaxvq_u32(mask) != 0) {\n                return true;\n            }\n        }\n\n        // Check for zero in the current chunk\n        cmp_result = vceqq_s32(vec1, zero_vec);\n        mask = vandq_u32(vmovq_n_u32(0xFFFFFFFF), vreinterpretq_u32_s32(cmp_result));\n        if (vmaxvq_u32(mask) > 1) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 2) return false;\n\n    int32x4_t vec1, vec2, neg_vec1, zero_vec = vdupq_n_s32(0);\n    uint32x4_t cmp_result;\n\n    for (int i = 0; i < n; i += 4) {\n        vec1 = vld1q_s32(&l[i]);\n        neg_vec1 = vnegq_s32(vec1);\n\n        for (int j = i + 4; j < n; j += 4) {\n            vec2 = vld1q_s32(&l[j]);\n            cmp_result = vceqq_s32(neg_vec1, vec2);\n\n            if (vmaxvq_u32(cmp_result)) {\n                return true;\n            }\n        }\n\n        // Check for pairs within the same loaded vector\n        cmp_result = vceqq_s32(vec1, vextq_s32(vec1, vec1, 1));\n        if (vmaxvq_u32(cmp_result) && vgetq_lane_s32(vec1, 0) != 0) return true;\n\n        cmp_result = vceqq_s32(vec1, vextq_s32(vec1, vec1, 2));\n        if (vmaxvq_u32(cmp_result) && vgetq_lane_s32(vec1, 0) != 0) return true;\n\n        cmp_result = vceqq_s32(vec1, vextq_s32(vec1, vec1, 3));\n        if (vmaxvq_u32(cmp_result) && vgetq_lane_s32(vec1, 0) != 0) return true;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_85_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <algorithm>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (base < 2 || base > 9) return \"\";\n\n    char buffer[65];\n    int index = 64;\n    buffer[index] = '\\0';\n\n    while (x != 0) {\n        uint8x8_t value = vdup_n_u8(x % base);\n        uint8x8_t ascii_offset = vdup_n_u8('0');\n        uint8x8_t ascii_value = vadd_u8(value, ascii_offset);\n\n        // Store the last character\n        buffer[--index] = vget_lane_u8(ascii_value, 0);\n\n        x /= base;\n    }\n\n    return std::string(buffer + index);\n}\n```"}
{"task_id": "SimdBench_85_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <algorithm>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (base < 2 || base > 9) return \"\";\n\n    char buffer[65];\n    int index = 64;\n    buffer[index] = '\\0';\n\n    while (x != 0) {\n        uint8x8_t value = vdup_n_u8(x % base);\n        uint8x8_t ascii_offset = vdup_n_u8('0');\n        uint8x8_t result = vadd_u8(value, ascii_offset);\n\n        vst1_lane_u8(&buffer[--index], result, 0);\n\n        x /= base;\n    }\n\n    return std::string(buffer + index);\n}\n```"}
{"task_id": "SimdBench_85_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <algorithm>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (base < 2 || base > 9) return \"\";\n\n    char buffer[65];\n    int index = 64;\n    buffer[index] = '\\0';\n\n    while (x != 0) {\n        uint8x8_t value = vdup_n_u8(x % base);\n        uint8x8_t ascii_offset = vdup_n_u8('0');\n        uint8x8_t result = vadd_u8(value, ascii_offset);\n\n        vst1_lane_u8(&buffer[--index], result, 0);\n\n        x /= base;\n    }\n\n    return std::string(buffer + index);\n}\n```"}
{"task_id": "SimdBench_85_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <algorithm>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (base < 2 || base > 9) return \"\";\n\n    char buffer[65];\n    int index = 64;\n    buffer[index] = '\\0';\n\n    while (x != 0) {\n        uint8x8_t value = vdup_n_u8(x % base);\n        uint8x8_t ascii_offset = vdup_n_u8('0');\n        uint8x8_t ascii_value = vadd_u8(value, ascii_offset);\n\n        // Store the last character\n        buffer[--index] = vget_lane_u8(ascii_value, 0);\n\n        x /= base;\n    }\n\n    return std::string(buffer + index);\n}\n```"}
{"task_id": "SimdBench_85_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <algorithm>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (base < 2 || base > 9) return \"\";\n\n    char buffer[65];\n    int index = 64;\n    buffer[index] = '\\0';\n\n    while (x != 0) {\n        uint8x8_t value = vdup_n_u8(x % base);\n        uint8x8_t ascii_offset = vdup_n_u8('0');\n        uint8x8_t result = vadd_u8(value, ascii_offset);\n\n        vst1_lane_u8(&buffer[--index], result, 0);\n\n        x /= base;\n    }\n\n    return std::string(buffer + index);\n}\n```"}
{"task_id": "SimdBench_86_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    int n = text.size();\n    if (n <= 1) return true;\n\n    const char* str = text.c_str();\n    int i = 0, j = n - 1;\n\n    while (i < j) {\n        uint8x16_t vec1 = vld1q_u8(reinterpret_cast<const uint8_t*>(str + i));\n        uint8x16_t vec2 = vld1q_u8(reinterpret_cast<const uint8_t*>(str + j - 15));\n\n        vec2 = vrev16q_u8(vec2);\n\n        uint16x8_t cmp1 = vceqq_u8(vget_low_u8(vec1), vget_high_u8(vec2));\n        uint16x8_t cmp2 = vceqq_u8(vget_high_u8(vec1), vget_low_u8(vec2));\n\n        uint32x4_t res1 = vandq_u32(vreinterpretq_u32_u16(cmp1), vreinterpretq_u32_u16(cmp2));\n        uint32x2_t res2 = vpmin_u32(vget_low_u32(res1), vget_high_u32(res1));\n        uint32_t res = vget_lane_u32(vpmin_u32(res2, res2), 0);\n\n        if (res != 0xFFFFFFFF) {\n            return false;\n        }\n\n        i += 16;\n        j -= 16;\n    }\n\n    while (i < j) {\n        if (str[i] != str[j]) {\n            return false;\n        }\n        i++;\n        j--;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    int n = text.size();\n    if (n <= 1) return true;\n\n    const char* str = text.c_str();\n    int i = 0, j = n - 1;\n\n    while (i < j) {\n        uint8x16_t vec1 = vld1q_u8(reinterpret_cast<const uint8_t*>(str + i));\n        uint8x16_t vec2 = vld1q_u8(reinterpret_cast<const uint8_t*>(str + j - 15));\n\n        vec2 = vrev64q_u8(vcombine_u8(vget_high_u8(vec2), vget_low_u8(vec2)));\n        vec2 = vextq_u8(vec2, vec2, 15);\n\n        uint16x8_t cmp = vceqq_u8(vec1, vec2);\n        uint64_t res = vmovmskq_u8(cmp);\n\n        if (res != 0xFFFFFFFFFFFFFFFF) {\n            int shift = __builtin_ctzl(~res);\n            return str[i + shift] == str[j - shift];\n        }\n\n        i += 16;\n        j -= 16;\n    }\n\n    while (i < j) {\n        if (str[i] != str[j]) return false;\n        i++;\n        j--;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    int n = text.size();\n    if (n <= 1) return true;\n\n    const char* str = text.c_str();\n    int i = 0, j = n - 1;\n\n    while (i < j) {\n        uint8x16_t vec1 = vld1q_u8(reinterpret_cast<const uint8_t*>(str + i));\n        uint8x16_t vec2 = vld1q_u8(reinterpret_cast<const uint8_t*>(str + j - 15));\n\n        vec2 = vrev64q_u8(vcombine_u8(vget_high_u8(vec2), vget_low_u8(vec2)));\n        vec2 = vextq_u8(vec2, vec2, 15);\n\n        uint16x8_t cmp = vceqq_u8(vec1, vec2);\n        uint64_t res = vmovmskq_u8(cmp);\n\n        if (res != 0xFFFFFFFFFFFFFFFF) {\n            int shift = __builtin_ctzl(~res);\n            return str[i + shift] == str[j - shift];\n        }\n\n        i += 16;\n        j -= 16;\n    }\n\n    while (i < j) {\n        if (str[i] != str[j]) return false;\n        i++;\n        j--;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    int n = text.size();\n    if (n <= 1) return true;\n\n    const char* str = text.c_str();\n    int i = 0, j = n - 1;\n\n    while (i < j) {\n        uint8x16_t vec1 = vld1q_u8(reinterpret_cast<const uint8_t*>(str + i));\n        uint8x16_t vec2 = vld1q_u8(reinterpret_cast<const uint8_t*>(str + j - 15));\n\n        vec2 = vrev64q_u8(vec2);\n        vec2 = vcombine_u8(vget_high_u8(vec2), vget_low_u8(vec2));\n\n        uint16x8_t cmp = vceqq_u8(vreinterpretq_u8_u16(vmovl_u8(vget_low_u8(vec1))),\n                                  vreinterpretq_u8_u16(vmovl_u8(vget_low_u8(vec2))));\n        uint16x8_t cmp_high = vceqq_u8(vreinterpretq_u8_u16(vmovl_u8(vget_high_u8(vec1))),\n                                       vreinterpretq_u8_u16(vmovl_u8(vget_high_u8(vec2))));\n\n        uint8x8_t res = vmovn_u16(cmp);\n        uint8x8_t res_high = vmovn_u16(cmp_high);\n\n        if (vminv_u8(res) == 0 || vminv_u8(res_high) == 0) {\n            return false;\n        }\n\n        i += 16;\n        j -= 16;\n    }\n\n    while (i < j) {\n        if (str[i] != str[j]) {\n            return false;\n        }\n        i++;\n        j--;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    int n = text.size();\n    if (n <= 1) return true;\n\n    const char* str = text.c_str();\n    int i = 0, j = n - 1;\n\n    while (i < j) {\n        uint8x16_t vec1 = vld1q_u8(reinterpret_cast<const uint8_t*>(str + i));\n        uint8x16_t vec2 = vld1q_u8(reinterpret_cast<const uint8_t*>(str + j - 15));\n\n        vec2 = vrev16q_u8(vec2);\n\n        uint16x8_t cmp1 = vceqq_u8(vget_low_u8(vec1), vget_high_u8(vec2));\n        uint16x8_t cmp2 = vceqq_u8(vget_high_u8(vec1), vget_low_u8(vec2));\n\n        uint32x4_t res1 = vmovn_u16(cmp1);\n        uint32x4_t res2 = vmovn_u16(cmp2);\n\n        uint64x2_t final_res = vcombine_u64(vmovn_u32(res1), vmovn_u32(res2));\n\n        if (vgetq_lane_u64(final_res, 0) != 0xFFFFFFFFFFFFFFFF || vgetq_lane_u64(final_res, 1) != 0xFFFFFFFFFFFFFFFF) {\n            return false;\n        }\n\n        i += 16;\n        j -= 16;\n    }\n\n    while (i < j) {\n        if (str[i] != str[j]) {\n            return false;\n        }\n        i++;\n        j--;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_87_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), ' ');\n    const int8_t shift = -5;\n    const int8_t base = 'a';\n    const int8_t wrap = 26;\n\n    size_t i = 0;\n    size_t length = s.length();\n\n    // Process 16 characters at a time\n    for (; i <= length - 16; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        int8x16_t shifted = vsubq_s8(vreinterpretq_s8_u8(input), vdupq_n_s8(base));\n        int8x16_t wrapped = vaddq_s8(shifted, vdupq_n_s8(wrap));\n        int8x16_t masked = vandq_s8(wrapped, vdupq_n_s8(0x1F)); // Mask to keep within 0-31\n        int8x16_t result = vaddq_s8(masked, vdupq_n_s8(base));\n        vst1q_u8(reinterpret_cast<uint8_t*>(out.data() + i), vreinterpretq_u8_s8(result));\n    }\n\n    // Handle remaining characters\n    for (; i < length; ++i) {\n        int w = ((int)s[i] + shift - base) % wrap;\n        if (w < 0) w += wrap;\n        out[i] = (char)(w + base);\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), ' ');\n    const int8_t shift = -5;\n    const int8_t base = 'a';\n    const int8_t wrap = 26;\n\n    size_t i = 0;\n    size_t length = s.length();\n\n    // Process 16 characters at a time\n    for (; i <= length - 16; i += 16) {\n        int8x16_t input = vld1q_s8(reinterpret_cast<const int8_t*>(s.data() + i));\n        int8x16_t shifted = vaddq_s8(input, vdupq_n_s8(shift));\n        int8x16_t wrapped = vsubq_s8(vaddq_s8(vmaxq_s8(shifted, vdupq_n_s8(base - wrap)), vdupq_n_s8(wrap)), vdupq_n_s8(base));\n        int8x16_t result = vaddq_s8(wrapped, vdupq_n_s8(base));\n        vst1q_s8(reinterpret_cast<int8_t*>(out.data() + i), result);\n    }\n\n    // Handle remaining characters\n    for (; i < length; ++i) {\n        int w = ((int)s[i] + shift - base + wrap) % wrap + base;\n        out[i] = (char)w;\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), ' ');\n    const int8_t shift = -5;\n    const int8_t base = 'a';\n    const int8_t wrap = 26;\n\n    size_t i = 0;\n    size_t length = s.length();\n\n    // Process 16 characters at a time\n    for (; i <= length - 16; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        int8x16_t shifted = vsubq_s8(vreinterpretq_s8_u8(input), vdupq_n_s8(base));\n        int8x16_t wrapped = vaddq_s8(shifted, vdupq_n_s8(wrap));\n        int8x16_t masked = vandq_s8(wrapped, vdupq_n_s8(0x1F)); // Mask to keep only lower 5 bits\n        int8x16_t result = vaddq_s8(masked, vdupq_n_s8(base));\n        vst1q_u8(reinterpret_cast<uint8_t*>(out.data() + i), vreinterpretq_u8_s8(result));\n    }\n\n    // Handle remaining characters\n    for (; i < length; ++i) {\n        int w = ((int)s[i] + shift - base) % wrap;\n        if (w < 0) w += wrap;\n        out[i] = (char)(w + base);\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.size(), ' ');\n    const int8_t shift = -5;\n    const int8_t base = 'a';\n    const int8_t wrap = 26;\n\n    size_t i = 0;\n    for (; i <= s.size() - 16; i += 16) {\n        int8x16_t vec = vld1q_s8(reinterpret_cast<const int8_t*>(s.data() + i));\n        int8x16_t base_vec = vdupq_n_s8(base);\n        int8x16_t wrap_vec = vdupq_n_s8(wrap);\n        int8x16_t shift_vec = vdupq_n_s8(shift);\n\n        int8x16_t sub_base = vsubq_s8(vec, base_vec);\n        int8x16_t shifted = vaddq_s8(sub_base, shift_vec);\n        int8x16_t wrapped = vaddq_s8(vmaxq_s8(shifted, vdupq_n_s8(0)), wrap_vec);\n        int8x16_t result = vaddq_s8(vminq_s8(shifted, vdupq_n_s8(wrap - 1)), base_vec);\n        int8x16_t final_result = vbslq_s8(vcltq_s8(shifted, vdupq_n_s8(0)), wrapped, result);\n\n        vst1q_s8(reinterpret_cast<int8_t*>(out.data() + i), final_result);\n    }\n\n    for (; i < s.size(); ++i) {\n        int w = ((int)s[i] + shift - base + wrap) % wrap + base;\n        out[i] = static_cast<char>(w);\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.size(), ' ');\n    const int8_t shift = -5;\n    const int8_t base = 'a';\n    const int8_t wrap = 26;\n\n    size_t i = 0;\n    for (; i <= s.size() - 16; i += 16) {\n        int8x16_t vec = vld1q_s8(reinterpret_cast<const int8_t*>(s.data() + i));\n        int8x16_t base_vec = vdupq_n_s8(base);\n        int8x16_t wrap_vec = vdupq_n_s8(wrap);\n        int8x16_t shift_vec = vdupq_n_s8(shift);\n\n        int8x16_t sub_base = vsubq_s8(vec, base_vec);\n        int8x16_t shifted = vaddq_s8(sub_base, shift_vec);\n        int8x16_t wrapped = vaddq_s8(vmaxq_s8(shifted, vdupq_n_s8(0)), wrap_vec);\n        int8x16_t result = vaddq_s8(vminq_s8(shifted, vdupq_n_s8(wrap - 1)), base_vec);\n        int8x16_t final_result = vbslq_s8(vcltq_s8(shifted, vdupq_n_s8(0)), wrapped, result);\n\n        vst1q_s8(reinterpret_cast<int8_t*>(out.data() + i), final_result);\n    }\n\n    for (; i < s.size(); ++i) {\n        int w = ((int)s[i] + shift - base + wrap) % wrap + base;\n        out[i] = static_cast<char>(w);\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_88_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    int n = l.size();\n    int32_t* data = l.data();\n    int32x4_t threshold = vdupq_n_s32(t);\n    uint32x4_t result = vdupq_n_u32(0xFFFFFFFF);\n\n    for (int i = 0; i <= n - 4; i += 4) {\n        int32x4_t values = vld1q_s32(&data[i]);\n        uint32x4_t cmp_result = vcgtq_s32(values, threshold);\n        result = vandq_u32(result, cmp_result);\n    }\n\n    // Check remaining elements\n    for (int i = (n & ~3); i < n; ++i) {\n        if (data[i] >= t) {\n            return false;\n        }\n    }\n\n    return vgetq_lane_u32(result, 0) == 0 && vgetq_lane_u32(result, 1) == 0 &&\n           vgetq_lane_u32(result, 2) == 0 && vgetq_lane_u32(result, 3) == 0;\n}\n```"}
{"task_id": "SimdBench_88_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    int n = l.size();\n    int32_t* data = l.data();\n    int32x4_t threshold = vdupq_n_s32(t);\n\n    for (int i = 0; i <= n - 4; i += 4) {\n        int32x4_t values = vld1q_s32(&data[i]);\n        uint32x4_t comparison = vcgtq_s32(values, threshold);\n        if (vmaxvq_u32(comparison) != 0) {\n            return false;\n        }\n    }\n\n    for (int i = (n & ~3); i < n; ++i) {\n        if (data[i] >= t) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_88_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    int n = l.size();\n    int32_t* data = l.data();\n    int32x4_t threshold = vdupq_n_s32(t);\n    uint32x4_t result = vdupq_n_u32(0xFFFFFFFF);\n\n    for (int i = 0; i <= n - 4; i += 4) {\n        int32x4_t values = vld1q_s32(&data[i]);\n        uint32x4_t comparison = vcgtq_s32(values, threshold);\n        result = vandq_u32(result, comparison);\n    }\n\n    // Check remaining elements\n    for (int i = (n & ~3); i < n; ++i) {\n        if (data[i] >= t) {\n            return false;\n        }\n    }\n\n    return vgetq_lane_u32(result, 0) == 0 && vgetq_lane_u32(result, 1) == 0 &&\n           vgetq_lane_u32(result, 2) == 0 && vgetq_lane_u32(result, 3) == 0;\n}\n```"}
{"task_id": "SimdBench_88_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    int n = l.size();\n    int32_t* data = l.data();\n    int32x4_t threshold = vdupq_n_s32(t);\n    uint32x4_t result = vdupq_n_u32(0xFFFFFFFF);\n\n    for (int i = 0; i <= n - 4; i += 4) {\n        int32x4_t values = vld1q_s32(&data[i]);\n        uint32x4_t cmp_result = vcgtq_s32(values, threshold);\n        result = vandq_u32(result, cmp_result);\n    }\n\n    // Check remaining elements\n    for (int i = (n & ~3); i < n; ++i) {\n        if (data[i] >= t) {\n            return false;\n        }\n    }\n\n    return vgetq_lane_u32(result, 0) == 0 &&\n           vgetq_lane_u32(result, 1) == 0 &&\n           vgetq_lane_u32(result, 2) == 0 &&\n           vgetq_lane_u32(result, 3) == 0;\n}\n```"}
{"task_id": "SimdBench_88_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    int n = l.size();\n    int32_t* data = l.data();\n    int32x4_t threshold = vdupq_n_s32(t);\n\n    for (int i = 0; i <= n - 4; i += 4) {\n        int32x4_t values = vld1q_s32(&data[i]);\n        uint32x4_t comparison = vcgtq_s32(values, threshold);\n        if (vmaxvq_u32(comparison)) {\n            return false;\n        }\n    }\n\n    for (int i = (n & ~3); i < n; ++i) {\n        if (data[i] >= t) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_89_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int32_t balance = 0;\n    size_t len = brackets.size();\n    const char* str = brackets.c_str();\n\n    uint8x16_t open_bracket = vdupq_n_u8('<');\n    uint8x16_t close_bracket = vdupq_n_u8('>');\n    int32x4_t balance_vec = vdupq_n_s32(0);\n\n    for (size_t i = 0; i <= len - 16; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(str + i));\n        uint8x16_t open_mask = vceqq_u8(input, open_bracket);\n        uint8x16_t close_mask = vceqq_u8(input, close_bracket);\n\n        int32x4_t open_count = vcntq_u8(open_mask);\n        int32x4_t close_count = vcntq_u8(close_mask);\n\n        balance_vec = vsubq_s32(vaddq_s32(balance_vec, open_count), close_count);\n    }\n\n    int32_t balance_array[4];\n    vst1q_s32(balance_array, balance_vec);\n    balance = balance_array[0] + balance_array[1] + balance_array[2] + balance_array[3];\n\n    for (size_t i = (len & ~15); i < len; ++i) {\n        if (str[i] == '<') {\n            balance++;\n        } else if (str[i] == '>') {\n            balance--;\n        }\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int32_t balance = 0;\n    size_t len = brackets.size();\n    const char* str = brackets.c_str();\n\n    uint8x16_t open_bracket = vdupq_n_u8('<');\n    uint8x16_t close_bracket = vdupq_n_u8('>');\n    int32x4_t balance_vec = vdupq_n_s32(0);\n\n    for (size_t i = 0; i <= len - 16; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(str + i));\n        uint8x16_t is_open = vceqq_u8(input, open_bracket);\n        uint8x16_t is_close = vceqq_u8(input, close_bracket);\n\n        int32x4_t open_count = vcntq_u8(is_open);\n        int32x4_t close_count = vcntq_u8(is_close);\n\n        balance_vec = vaddq_s32(balance_vec, vsubq_s32(open_count, close_count));\n    }\n\n    int32_t balance_array[4];\n    vst1q_s32(balance_array, balance_vec);\n    balance = balance_array[0] + balance_array[1] + balance_array[2] + balance_array[3];\n\n    for (size_t i = (len & ~15); i < len; ++i) {\n        if (str[i] == '<') {\n            balance++;\n        } else if (str[i] == '>') {\n            balance--;\n        }\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int32_t balance = 0;\n    size_t len = brackets.size();\n    const char* str = brackets.c_str();\n\n    uint8x16_t open_bracket = vdupq_n_u8('<');\n    uint8x16_t close_bracket = vdupq_n_u8('>');\n\n    for (size_t i = 0; i <= len - 16; i += 16) {\n        uint8x16_t chunk = vld1q_u8(reinterpret_cast<const uint8_t*>(str + i));\n        uint8x16_t open_mask = vceqq_u8(chunk, open_bracket);\n        uint8x16_t close_mask = vceqq_u8(chunk, close_bracket);\n\n        int32x4_t open_count = vcntq_u8(open_mask);\n        int32x4_t close_count = vcntq_u8(close_mask);\n\n        int32x2_t open_sum = vadd_s32(vget_low_s32(open_count), vget_high_s32(open_count));\n        int32x2_t close_sum = vadd_s32(vget_low_s32(close_count), vget_high_s32(close_count));\n\n        int32_t open_total = vget_lane_s32(vpadd_s32(open_sum, open_sum), 0);\n        int32_t close_total = vget_lane_s32(vpadd_s32(close_sum, close_sum), 0);\n\n        balance += open_total - close_total;\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    for (size_t i = (len & ~15); i < len; ++i) {\n        if (str[i] == '<') {\n            balance++;\n        } else if (str[i] == '>') {\n            balance--;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int32_t balance = 0;\n    size_t len = brackets.size();\n    const char* str = brackets.c_str();\n\n    uint8x16_t open_bracket = vdupq_n_u8('<');\n    uint8x16_t close_bracket = vdupq_n_u8('>');\n    int32x4_t balance_vec = vdupq_n_s32(0);\n\n    for (size_t i = 0; i <= len - 16; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(str + i));\n        uint8x16_t is_open = vceqq_u8(input, open_bracket);\n        uint8x16_t is_close = vceqq_u8(input, close_bracket);\n\n        int32x4_t open_count = vcntq_u8(is_open);\n        int32x4_t close_count = vcntq_u8(is_close);\n\n        balance_vec = vsubq_s32(vaddq_s32(balance_vec, open_count), close_count);\n    }\n\n    int32_t balance_array[4];\n    vst1q_s32(balance_array, balance_vec);\n    balance += balance_array[0] + balance_array[1] + balance_array[2] + balance_array[3];\n\n    for (size_t i = (len & ~15); i < len; ++i) {\n        if (str[i] == '<') {\n            balance++;\n        } else if (str[i] == '>') {\n            balance--;\n        }\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int32_t balance = 0;\n    size_t len = brackets.size();\n    const char* str = brackets.c_str();\n\n    uint8x16_t open_bracket = vdupq_n_u8('<');\n    uint8x16_t close_bracket = vdupq_n_u8('>');\n\n    for (size_t i = 0; i <= len - 16; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(str + i));\n        uint8x16_t open_mask = vceqq_u8(input, open_bracket);\n        uint8x16_t close_mask = vceqq_u8(input, close_bracket);\n\n        int32x4_t open_count = vcntq_s8(vreinterpretq_s8_u8(open_mask));\n        int32x4_t close_count = vcntq_s8(vreinterpretq_s8_u8(close_mask));\n\n        int32x2_t open_sum = vadd_s32(vget_low_s32(open_count), vget_high_s32(open_count));\n        int32x2_t close_sum = vadd_s32(vget_low_s32(close_count), vget_high_s32(close_count));\n\n        balance += vget_lane_s32(open_sum, 0) + vget_lane_s32(open_sum, 1);\n        balance -= vget_lane_s32(close_sum, 0) + vget_lane_s32(close_sum, 1);\n\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    for (size_t i = (len & ~15); i < len; ++i) {\n        if (str[i] == '<') {\n            balance++;\n        } else if (str[i] == '>') {\n            balance--;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int32_t balance = 0;\n    size_t len = brackets.size();\n    const char* str = brackets.c_str();\n\n    uint8x16_t open_bracket = vdupq_n_u8('(');\n    uint8x16_t close_bracket = vdupq_n_u8(')');\n    int32x4_t balance_vec = vdupq_n_s32(0);\n\n    for (size_t i = 0; i <= len - 16; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(str + i));\n        uint8x16_t open_mask = vceqq_u8(input, open_bracket);\n        uint8x16_t close_mask = vceqq_u8(input, close_bracket);\n\n        int32x4_t open_count = vcntq_u8(open_mask);\n        int32x4_t close_count = vcntq_u8(close_mask);\n\n        balance_vec = vaddq_s32(balance_vec, vsubq_s32(open_count, close_count));\n    }\n\n    int32_t balance_array[4];\n    vst1q_s32(balance_array, balance_vec);\n    balance = balance_array[0] + balance_array[1] + balance_array[2] + balance_array[3];\n\n    for (size_t i = (len & ~15); i < len; ++i) {\n        if (str[i] == '(') {\n            balance++;\n        } else if (str[i] == ')') {\n            balance--;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int32_t balance = 0;\n    size_t len = brackets.size();\n    const char* str = brackets.c_str();\n\n    uint8x16_t open_bracket = vdupq_n_u8('(');\n    uint8x16_t close_bracket = vdupq_n_u8(')');\n    int32x4_t balance_vec = vdupq_n_s32(0);\n\n    for (size_t i = 0; i <= len - 16; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(str + i));\n        uint8x16_t open_mask = vceqq_u8(input, open_bracket);\n        uint8x16_t close_mask = vceqq_u8(input, close_bracket);\n\n        int32x4_t open_count = vcntq_u8(open_mask);\n        int32x4_t close_count = vcntq_u8(close_mask);\n\n        balance_vec = vaddq_s32(balance_vec, vsubq_s32(open_count, close_count));\n    }\n\n    int32_t balance_array[4];\n    vst1q_s32(balance_array, balance_vec);\n    balance = balance_array[0] + balance_array[1] + balance_array[2] + balance_array[3];\n\n    for (size_t i = (len & ~15); i < len; ++i) {\n        if (str[i] == '(') {\n            balance++;\n        } else if (str[i] == ')') {\n            balance--;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int32_t balance = 0;\n    size_t len = brackets.size();\n    const char* str = brackets.c_str();\n\n    uint8x16_t open_bracket = vdupq_n_u8('(');\n    uint8x16_t close_bracket = vdupq_n_u8(')');\n    int32x4_t balance_vec = vdupq_n_s32(0);\n\n    for (size_t i = 0; i <= len - 16; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(str + i));\n        uint8x16_t open_mask = vceqq_u8(input, open_bracket);\n        uint8x16_t close_mask = vceqq_u8(input, close_bracket);\n\n        int32x4_t open_count = vcntq_u8(open_mask);\n        int32x4_t close_count = vcntq_u8(close_mask);\n\n        balance_vec = vaddq_s32(balance_vec, vsubq_s32(open_count, close_count));\n    }\n\n    int32_t balance_array[4];\n    vst1q_s32(balance_array, balance_vec);\n    balance = balance_array[0] + balance_array[1] + balance_array[2] + balance_array[3];\n\n    for (size_t i = (len & ~15); i < len; ++i) {\n        if (str[i] == '(') {\n            balance++;\n        } else if (str[i] == ')') {\n            balance--;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int32_t balance = 0;\n    size_t len = brackets.size();\n    const char* str = brackets.c_str();\n\n    uint8x16_t open_bracket = vdupq_n_u8('(');\n    uint8x16_t close_bracket = vdupq_n_u8(')');\n    int32x4_t balance_vec = vdupq_n_s32(0);\n\n    for (size_t i = 0; i <= len - 16; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(str + i));\n        uint8x16_t open_mask = vceqq_u8(input, open_bracket);\n        uint8x16_t close_mask = vceqq_u8(input, close_bracket);\n\n        int32x4_t open_count = vcntq_u8(open_mask);\n        int32x4_t close_count = vcntq_u8(close_mask);\n\n        balance_vec = vaddq_s32(balance_vec, vsubq_s32(open_count, close_count));\n    }\n\n    int32_t balance_array[4];\n    vst1q_s32(balance_array, balance_vec);\n    balance = balance_array[0] + balance_array[1] + balance_array[2] + balance_array[3];\n\n    for (size_t i = (len & ~15); i < len; ++i) {\n        if (str[i] == '(') {\n            balance++;\n        } else if (str[i] == ')') {\n            balance--;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int32_t balance = 0;\n    size_t len = brackets.size();\n    const char* str = brackets.c_str();\n\n    uint8x16_t open_bracket = vdupq_n_u8('(');\n    uint8x16_t close_bracket = vdupq_n_u8(')');\n    int32x4_t balance_vec = vdupq_n_s32(0);\n\n    for (size_t i = 0; i <= len - 16; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(str + i));\n        uint8x16_t open_mask = vceqq_u8(input, open_bracket);\n        uint8x16_t close_mask = vceqq_u8(input, close_bracket);\n\n        int32x4_t open_count = vcntq_u8(open_mask);\n        int32x4_t close_count = vcntq_u8(close_mask);\n\n        balance_vec = vsubq_s32(vaddq_s32(balance_vec, open_count), close_count);\n    }\n\n    int32_t balance_array[4];\n    vst1q_s32(balance_array, balance_vec);\n    balance = balance_array[0] + balance_array[1] + balance_array[2] + balance_array[3];\n\n    for (size_t i = (len & ~15); i < len; ++i) {\n        if (str[i] == '(') {\n            balance++;\n        } else if (str[i] == ')') {\n            balance--;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_91_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs){\n    std::vector<float> result;\n    int n = xs.size();\n    if (n <= 1) return result;\n\n    int i = 1;\n    float32x4_t coeff_vec, index_vec, result_vec;\n    float index[4] = {1.0f, 2.0f, 3.0f, 4.0f};\n\n    // Process 4 coefficients at a time\n    for (; i <= n - 4; i += 4) {\n        coeff_vec = vld1q_f32(&xs[i]);\n        index_vec = vld1q_f32(index);\n        result_vec = vmulq_f32(coeff_vec, index_vec);\n        vst1q_f32(&result[i-1], result_vec);\n\n        // Update index vector for next iteration\n        index[0] += 4.0f;\n        index[1] += 4.0f;\n        index[2] += 4.0f;\n        index[3] += 4.0f;\n    }\n\n    // Handle remaining coefficients\n    for (; i < n; ++i) {\n        result.push_back(xs[i] * i);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs){\n    std::vector<float> result;\n    if (xs.size() <= 1) return result;\n\n    int n = xs.size();\n    result.resize(n - 1);\n\n    float32x4_t coeff_vec, index_vec, result_vec;\n    float32x4_t zero_vec = vdupq_n_f32(0.0f);\n    float32x4_t one_vec = vdupq_n_f32(1.0f);\n\n    for (int i = 0; i < n - 4; i += 4) {\n        coeff_vec = vld1q_f32(&xs[i + 1]);\n        index_vec = vaddq_f32(vsetq_lane_f32(i + 1, one_vec, 0),\n                              vsetq_lane_f32(i + 2, one_vec, 1),\n                              vsetq_lane_f32(i + 3, one_vec, 2),\n                              vsetq_lane_f32(i + 4, one_vec, 3));\n        result_vec = vmulq_f32(coeff_vec, index_vec);\n        vst1q_f32(&result[i], result_vec);\n    }\n\n    for (int i = (n - 1) & ~3; i < n - 1; ++i) {\n        result[i] = xs[i + 1] * (i + 1);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs){\n    std::vector<float> result;\n    if (xs.size() <= 1) return result;\n\n    int n = xs.size();\n    result.resize(n - 1);\n\n    float32x4_t coeff_vec, index_vec, result_vec;\n    float32x4_t indices = vsetq_lane_f32(1.0f, vdupq_n_f32(0.0f), 0);\n    indices = vsetq_lane_f32(2.0f, indices, 1);\n    indices = vsetq_lane_f32(3.0f, indices, 2);\n    indices = vsetq_lane_f32(4.0f, indices, 3);\n\n    for (int i = 0; i <= n - 5; i += 4) {\n        coeff_vec = vld1q_f32(&xs[i + 1]);\n        index_vec = indices;\n        result_vec = vmulq_f32(coeff_vec, index_vec);\n        vst1q_f32(&result[i], result_vec);\n        indices = vaddq_f32(indices, vdupq_n_f32(4.0f));\n    }\n\n    for (int i = (n - 1) / 4 * 4 + 1; i < n; ++i) {\n        result[i - 1] = xs[i] * i;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs){\n    std::vector<float> result;\n    int n = xs.size();\n    if (n <= 1) return result;\n\n    int i = 1;\n    float32x4_t coeff_vec, index_vec, result_vec;\n    float32x4_t indices = vsetq_lane_f32(1.0f, vsetq_lane_f32(2.0f, vsetq_lane_f32(3.0f, vsetq_lane_f32(4.0f, vdupq_n_f32(0.0f), 0), 1), 2), 3);\n\n    for (; i <= n - 4; i += 4) {\n        coeff_vec = vld1q_f32(&xs[i]);\n        index_vec = vaddq_f32(vdupq_n_f32(static_cast<float>(i)), indices);\n        result_vec = vmulq_f32(coeff_vec, index_vec);\n        vst1q_f32(&result[i-1], result_vec);\n    }\n\n    for (; i < n; ++i) {\n        result.push_back(xs[i] * static_cast<float>(i));\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs){\n    std::vector<float> result;\n    int n = xs.size();\n    if (n <= 1) return result;\n\n    int i = 1;\n    float32x4_t coeff_vec, index_vec, result_vec;\n    float index[4] = {1.0f, 2.0f, 3.0f, 4.0f};\n\n    // Process 4 coefficients at a time\n    for (; i <= n - 4; i += 4) {\n        coeff_vec = vld1q_f32(&xs[i]);\n        index_vec = vld1q_f32(index);\n        result_vec = vmulq_f32(coeff_vec, index_vec);\n        vst1q_f32(&result[i-1], result_vec);\n\n        // Update index vector for next iteration\n        index[0] += 4.0f;\n        index[1] += 4.0f;\n        index[2] += 4.0f;\n        index[3] += 4.0f;\n    }\n\n    // Handle remaining coefficients\n    for (; i < n; ++i) {\n        result.push_back(xs[i] * i);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_92_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint vowels_count_simd(const std::string& s) {\n    int count = 0;\n    const char* str = s.c_str();\n    int len = s.length();\n\n    uint8x16_t vowels = vdupq_n_u8(0);\n    vowels = vorrq_u8(vowels, vsetq_lane_u8('a', vowels, 0));\n    vowels = vorrq_u8(vowels, vsetq_lane_u8('e', vowels, 1));\n    vowels = vorrq_u8(vowels, vsetq_lane_u8('i', vowels, 2));\n    vowels = vorrq_u8(vowels, vsetq_lane_u8('o', vowels, 3));\n    vowels = vorrq_u8(vowels, vsetq_lane_u8('u', vowels, 4));\n    vowels = vorrq_u8(vowels, vsetq_lane_u8('A', vowels, 5));\n    vowels = vorrq_u8(vowels, vsetq_lane_u8('E', vowels, 6));\n    vowels = vorrq_u8(vowels, vsetq_lane_u8('I', vowels, 7));\n    vowels = vorrq_u8(vowels, vsetq_lane_u8('O', vowels, 8));\n    vowels = vorrq_u8(vowels, vsetq_lane_u8('U', vowels, 9));\n\n    int i = 0;\n    for (; i <= len - 16; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(str + i));\n        uint8x16_t matches = vceqq_u8(input, vowels);\n        uint32x4_t counts = vcntq_u8(matches);\n        count += vaddvq_u32(counts);\n    }\n\n    for (; i < len; ++i) {\n        char c = str[i];\n        if ((c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n             c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') ||\n            (c == 'y' || c == 'Y') && i == len - 1) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint vowels_count_simd(const std::string& s) {\n    int count = 0;\n    const char* str = s.c_str();\n    int len = s.length();\n    int i = 0;\n\n    uint8x16_t vowels = vdupq_n_u8('a');\n    vowels = vsetq_lane_u8('e', vowels, 1);\n    vowels = vsetq_lane_u8('i', vowels, 2);\n    vowels = vsetq_lane_u8('o', vowels, 3);\n    vowels = vsetq_lane_u8('u', vowels, 4);\n    vowels = vsetq_lane_u8('A', vowels, 5);\n    vowels = vsetq_lane_u8('E', vowels, 6);\n    vowels = vsetq_lane_u8('I', vowels, 7);\n    vowels = vsetq_lane_u8('O', vowels, 8);\n    vowels = vsetq_lane_u8('U', vowels, 9);\n\n    while (len - i >= 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(str + i));\n        uint8x16_t cmp_a = vceqq_u8(input, vdupq_n_u8('a'));\n        uint8x16_t cmp_e = vceqq_u8(input, vdupq_n_u8('e'));\n        uint8x16_t cmp_i = vceqq_u8(input, vdupq_n_u8('i'));\n        uint8x16_t cmp_o = vceqq_u8(input, vdupq_n_u8('o'));\n        uint8x16_t cmp_u = vceqq_u8(input, vdupq_n_u8('u'));\n        uint8x16_t cmp_A = vceqq_u8(input, vdupq_n_u8('A'));\n        uint8x16_t cmp_E = vceqq_u8(input, vdupq_n_u8('E'));\n        uint8x16_t cmp_I = vceqq_u8(input, vdupq_n_u8('I'));\n        uint8x16_t cmp_O = vceqq_u8(input, vdupq_n_u8('O'));\n        uint8x16_t cmp_U = vceqq_u8(input, vdupq_n_u8('U'));\n\n        uint8x16_t result = vorrq_u8(vorrq_u8(vorrq_u8(vorrq_u8(vorrq_u8(vorrq_u8(vorrq_u8(vorrq_u8(cmp_a, cmp_e), cmp_i), cmp_o), cmp_u), cmp_A), cmp_E), cmp_I), cmp_O);\n        result = vorrq_u8(result, cmp_U);\n\n        uint32x4_t sum = vcntq_u8(result);\n        count += vaddvq_u32(sum);\n\n        i += 16;\n    }\n\n    for (; i < len; ++i) {\n        char c = str[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n            c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n\n    if (len > 0 && (str[len - 1] == 'y' || str[len - 1] == 'Y')) {\n        count++;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint vowels_count_simd(const std::string& s) {\n    int count = 0;\n    const char* str = s.c_str();\n    int len = s.length();\n    int i = 0;\n\n    uint8x16_t vowels = vdupq_n_u8(0);\n    vowels = vsetq_lane_u8('a', vowels, 0);\n    vowels = vsetq_lane_u8('e', vowels, 1);\n    vowels = vsetq_lane_u8('i', vowels, 2);\n    vowels = vsetq_lane_u8('o', vowels, 3);\n    vowels = vsetq_lane_u8('u', vowels, 4);\n    vowels = vsetq_lane_u8('A', vowels, 5);\n    vowels = vsetq_lane_u8('E', vowels, 6);\n    vowels = vsetq_lane_u8('I', vowels, 7);\n    vowels = vsetq_lane_u8('O', vowels, 8);\n    vowels = vsetq_lane_u8('U', vowels, 9);\n\n    while (i <= len - 16) {\n        uint8x16_t chunk = vld1q_u8(reinterpret_cast<const uint8_t*>(str + i));\n        uint8x16_t cmp_a = vceqq_u8(chunk, vdupq_n_u8('a'));\n        uint8x16_t cmp_e = vceqq_u8(chunk, vdupq_n_u8('e'));\n        uint8x16_t cmp_i = vceqq_u8(chunk, vdupq_n_u8('i'));\n        uint8x16_t cmp_o = vceqq_u8(chunk, vdupq_n_u8('o'));\n        uint8x16_t cmp_u = vceqq_u8(chunk, vdupq_n_u8('u'));\n        uint8x16_t cmp_A = vceqq_u8(chunk, vdupq_n_u8('A'));\n        uint8x16_t cmp_E = vceqq_u8(chunk, vdupq_n_u8('E'));\n        uint8x16_t cmp_I = vceqq_u8(chunk, vdupq_n_u8('I'));\n        uint8x16_t cmp_O = vceqq_u8(chunk, vdupq_n_u8('O'));\n        uint8x16_t cmp_U = vceqq_u8(chunk, vdupq_n_u8('U'));\n\n        uint8x16_t result = vorrq_u8(vorrq_u8(vorrq_u8(vorrq_u8(vorrq_u8(vorrq_u8(vorrq_u8(vorrq_u8(cmp_a, cmp_e), cmp_i), cmp_o), cmp_u), cmp_A), cmp_E), cmp_I), cmp_O), cmp_U);\n\n        uint32x4_t sum = vcntq_u8(result);\n        count += vaddvq_u32(sum);\n\n        i += 16;\n    }\n\n    for (; i < len; ++i) {\n        char c = str[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n            c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n\n    if (len > 0 && (str[len - 1] == 'y' || str[len - 1] == 'Y')) {\n        count++;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint vowels_count_simd(const std::string& s) {\n    int count = 0;\n    int len = s.length();\n    const char* str = s.c_str();\n\n    uint8x16_t vowels = vdupq_n_u8(0);\n    vowels = vorrq_u8(vowels, vceqq_u8(vdupq_n_u8('a'), vld1q_u8(reinterpret_cast<const uint8_t*>(str))));\n    vowels = vorrq_u8(vowels, vceqq_u8(vdupq_n_u8('e'), vld1q_u8(reinterpret_cast<const uint8_t*>(str))));\n    vowels = vorrq_u8(vowels, vceqq_u8(vdupq_n_u8('i'), vld1q_u8(reinterpret_cast<const uint8_t*>(str))));\n    vowels = vorrq_u8(vowels, vceqq_u8(vdupq_n_u8('o'), vld1q_u8(reinterpret_cast<const uint8_t*>(str))));\n    vowels = vorrq_u8(vowels, vceqq_u8(vdupq_n_u8('u'), vld1q_u8(reinterpret_cast<const uint8_t*>(str))));\n    vowels = vorrq_u8(vowels, vceqq_u8(vdupq_n_u8('A'), vld1q_u8(reinterpret_cast<const uint8_t*>(str))));\n    vowels = vorrq_u8(vowels, vceqq_u8(vdupq_n_u8('E'), vld1q_u8(reinterpret_cast<const uint8_t*>(str))));\n    vowels = vorrq_u8(vowels, vceqq_u8(vdupq_n_u8('I'), vld1q_u8(reinterpret_cast<const uint8_t*>(str))));\n    vowels = vorrq_u8(vowels, vceqq_u8(vdupq_n_u8('O'), vld1q_u8(reinterpret_cast<const uint8_t*>(str))));\n    vowels = vorrq_u8(vowels, vceqq_u8(vdupq_n_u8('U'), vld1q_u8(reinterpret_cast<const uint8_t*>(str))));\n\n    for (int i = 0; i < len; i += 16) {\n        uint8x16_t chunk = vld1q_u8(reinterpret_cast<const uint8_t*>(str + i));\n        uint8x16_t matches = vorrq_u8(\n            vorrq_u8(vceqq_u8(chunk, vdupq_n_u8('a')), vceqq_u8(chunk, vdupq_n_u8('A'))),\n            vorrq_u8(vorrq_u8(vceqq_u8(chunk, vdupq_n_u8('e')), vceqq_u8(chunk, vdupq_n_u8('E'))),\n                     vorrq_u8(vorrq_u8(vceqq_u8(chunk, vdupq_n_u8('i')), vceqq_u8(chunk, vdupq_n_u8('I'))),\n                              vorrq_u8(vorrq_u8(vceqq_u8(chunk, vdupq_n_u8('o')), vceqq_u8(chunk, vdupq_n_u8('O'))),\n                                       vorrq_u8(vceqq_u8(chunk, vdupq_n_u8('u')), vceqq_u8(chunk, vdupq_n_u8('U'))))))\n        );\n        if (i + 15 >= len && str[i + len - 1] == 'y') {\n            matches = vsetq_lane_u8(1, matches, len - 1 - i);\n        } else if (i + 15 >= len && str[i + len - 1] == 'Y') {\n            matches = vsetq_lane_u8(1, matches, len - 1 - i);\n        }\n        uint32x4_t vm = vpaddlq_u16(vpaddlq_u8(matches));\n        count += vgetq_lane_u32(vm, 0) + vgetq_lane_u32(vm, 1);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint vowels_count_simd(const std::string& s) {\n    int count = 0;\n    int len = s.length();\n    const char* str = s.c_str();\n\n    uint8x16_t vowels = vdupq_n_u8(0);\n    vowels = vorrq_u8(vowels, vceqq_u8(vdupq_n_u8('a'), vld1q_u8(reinterpret_cast<const uint8_t*>(str))));\n    vowels = vorrq_u8(vowels, vceqq_u8(vdupq_n_u8('e'), vld1q_u8(reinterpret_cast<const uint8_t*>(str))));\n    vowels = vorrq_u8(vowels, vceqq_u8(vdupq_n_u8('i'), vld1q_u8(reinterpret_cast<const uint8_t*>(str))));\n    vowels = vorrq_u8(vowels, vceqq_u8(vdupq_n_u8('o'), vld1q_u8(reinterpret_cast<const uint8_t*>(str))));\n    vowels = vorrq_u8(vowels, vceqq_u8(vdupq_n_u8('u'), vld1q_u8(reinterpret_cast<const uint8_t*>(str))));\n    vowels = vorrq_u8(vowels, vceqq_u8(vdupq_n_u8('A'), vld1q_u8(reinterpret_cast<const uint8_t*>(str))));\n    vowels = vorrq_u8(vowels, vceqq_u8(vdupq_n_u8('E'), vld1q_u8(reinterpret_cast<const uint8_t*>(str))));\n    vowels = vorrq_u8(vowels, vceqq_u8(vdupq_n_u8('I'), vld1q_u8(reinterpret_cast<const uint8_t*>(str))));\n    vowels = vorrq_u8(vowels, vceqq_u8(vdupq_n_u8('O'), vld1q_u8(reinterpret_cast<const uint8_t*>(str))));\n    vowels = vorrq_u8(vowels, vceqq_u8(vdupq_n_u8('U'), vld1q_u8(reinterpret_cast<const uint8_t*>(str))));\n\n    for (int i = 0; i < len; i += 16) {\n        uint8x16_t chunk = vld1q_u8(reinterpret_cast<const uint8_t*>(str + i));\n        uint8x16_t is_vowel = vorrq_u8(\n            vorrq_u8(vceqq_u8(chunk, vdupq_n_u8('a')), vceqq_u8(chunk, vdupq_n_u8('e'))),\n            vorrq_u8(vorrq_u8(vceqq_u8(chunk, vdupq_n_u8('i')), vceqq_u8(chunk, vdupq_n_u8('o'))),\n                     vorrq_u8(vceqq_u8(chunk, vdupq_n_u8('u')), vceqq_u8(chunk, vdupq_n_u8('A')))),\n            vorrq_u8(vorrq_u8(vceqq_u8(chunk, vdupq_n_u8('E')), vceqq_u8(chunk, vdupq_n_u8('I'))),\n                     vorrq_u8(vceqq_u8(chunk, vdupq_n_u8('O')), vceqq_u8(chunk, vdupq_n_u8('U'))))\n        );\n\n        if (i + 15 >= len - 1 && str[len - 1] == 'y') {\n            is_vowel = vorrq_u8(is_vowel, veorq_u8(vdupq_n_u8(0xFF), vshlq_n_u8(vdupq_n_u8(0x80), 15 - (len - i - 1))));\n        } else if (i + 15 >= len - 1 && str[len - 1] == 'Y') {\n            is_vowel = vorrq_u8(is_vowel, veorq_u8(vdupq_n_u8(0xFF), vshlq_n_u8(vdupq_n_u8(0x80), 15 - (len - i - 1))));\n        }\n\n        uint32x4_t sum = vpaddlq_u16(vpaddlq_u8(is_vowel));\n        count += vgetq_lane_u32(sum, 0) + vgetq_lane_u32(sum, 1);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_93_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    size_t len = s.length();\n    const char* str = s.c_str();\n\n    // Process 16 characters at a time\n    for (size_t i = 0; i <= len - 16; i += 16) {\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(str + i));\n        uint8x16_t upper_mask = vcgeq_u8(chars, vdupq_n_u8('A'));\n        uint8x16_t lower_mask = vcleq_u8(chars, vdupq_n_u8('Z'));\n        uint8x16_t upper_chars = vandq_u8(upper_mask, lower_mask);\n        uint16x8_t pairwise_sum1 = vpaddlq_u8(upper_chars);\n        uint32x4_t pairwise_sum2 = vpaddlq_u16(pairwise_sum1);\n        uint64x2_t pairwise_sum3 = vpaddlq_u32(pairwise_sum2);\n        sum += vgetq_lane_u64(pairwise_sum3, 0) + vgetq_lane_u64(pairwise_sum3, 1);\n    }\n\n    // Process remaining characters\n    for (size_t i = (len / 16) * 16; i < len; ++i) {\n        if (str[i] >= 'A' && str[i] <= 'Z') {\n            sum += static_cast<int>(str[i]);\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    size_t len = s.length();\n    const char* str = s.c_str();\n\n    // Process 16 characters at a time\n    for (size_t i = 0; i <= len - 16; i += 16) {\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(str + i));\n        uint8x16_t upper_mask = vcgeq_u8(chars, vdupq_n_u8('A'));\n        uint8x16_t lower_mask = vcleq_u8(chars, vdupq_n_u8('Z'));\n        uint8x16_t upper_chars = vandq_u8(upper_mask, lower_mask);\n        uint8x16_t zero = vdupq_n_u8(0);\n        uint8x16_t filtered_chars = vbslq_u8(upper_chars, chars, zero);\n        uint16x8_t pairwise_sum1 = vpaddlq_u8(filtered_chars);\n        uint32x4_t pairwise_sum2 = vpaddlq_u16(pairwise_sum1);\n        uint64x2_t pairwise_sum3 = vpaddlq_u32(pairwise_sum2);\n        sum += vgetq_lane_u64(pairwise_sum3, 0) + vgetq_lane_u64(pairwise_sum3, 1);\n    }\n\n    // Process remaining characters\n    for (size_t i = (len / 16) * 16; i < len; ++i) {\n        if (str[i] >= 'A' && str[i] <= 'Z') {\n            sum += static_cast<int>(str[i]);\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    size_t len = s.length();\n    const char* str = s.c_str();\n\n    // Process 16 characters at a time\n    for (size_t i = 0; i <= len - 16; i += 16) {\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(str + i));\n        uint8x16_t upper_mask = vcgeq_u8(chars, vdupq_n_u8('A'));\n        uint8x16_t lower_mask = vcleq_u8(chars, vdupq_n_u8('Z'));\n        uint8x16_t upper_chars = vandq_u8(upper_mask, lower_mask);\n        uint8x16_t zero = vdupq_n_u8(0);\n        uint8x16_t filtered_chars = vbslq_u8(upper_chars, chars, zero);\n        uint16x8_t pairwise_sum1 = vpaddlq_u8(filtered_chars);\n        uint32x4_t pairwise_sum2 = vpaddlq_u16(pairwise_sum1);\n        uint64x2_t pairwise_sum3 = vpaddlq_u32(pairwise_sum2);\n        sum += vgetq_lane_u64(pairwise_sum3, 0) + vgetq_lane_u64(pairwise_sum3, 1);\n    }\n\n    // Process remaining characters\n    for (size_t i = (len / 16) * 16; i < len; ++i) {\n        if (str[i] >= 'A' && str[i] <= 'Z') {\n            sum += static_cast<int>(str[i]);\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    size_t len = s.length();\n    const char* str = s.c_str();\n\n    // Process 16 characters at a time\n    for (size_t i = 0; i <= len - 16; i += 16) {\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(str + i));\n        uint8x16_t upper_mask = vandq_u8(chars, vdupq_n_u8(0x20));\n        uint8x16_t upper_chars = vsubq_u8(chars, upper_mask);\n        uint8x16_t is_upper = vceqq_u8(upper_chars, chars);\n        uint8x16_t zero = vdupq_n_u8(0);\n        uint8x16_t upper_only = vbslq_u8(is_upper, chars, zero);\n\n        uint16x8_t pairwise_sum1 = vpaddlq_u8(upper_only);\n        uint32x4_t pairwise_sum2 = vpaddlq_u16(pairwise_sum1);\n        uint64x2_t pairwise_sum3 = vpaddlq_u32(pairwise_sum2);\n\n        sum += vgetq_lane_u64(pairwise_sum3, 0) + vgetq_lane_u64(pairwise_sum3, 1);\n    }\n\n    // Process remaining characters\n    for (size_t i = (len / 16) * 16; i < len; ++i) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            sum += static_cast<int>(s[i]);\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    size_t len = s.length();\n    const char* str = s.c_str();\n\n    size_t i = 0;\n    uint8x16_t sum_vec = vdupq_n_u8(0);\n\n    for (; i <= len - 16; i += 16) {\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(str + i));\n        uint8x16_t is_upper = vcgeq_u8(chars, vdupq_n_u8('A'));\n        is_upper = vcleq_u8(is_upper, vdupq_n_u8('Z'));\n        uint8x16_t upper_chars = vandq_u8(chars, is_upper);\n        sum_vec = vaddq_u8(sum_vec, upper_chars);\n    }\n\n    uint8x8_t sum_low = vpaddl_u8(vget_low_u8(sum_vec));\n    uint8x8_t sum_high = vpaddl_u8(vget_high_u8(sum_vec));\n    uint16x4_t sum_pair = vpaddl_u16(sum_low);\n    sum_pair = vpaddl_u16(sum_pair);\n    sum += vget_lane_u32(reinterpret_cast<uint32x2_t>(sum_pair), 0);\n\n    for (; i < len; ++i) {\n        if (str[i] >= 'A' && str[i] <= 'Z') {\n            sum += static_cast<int>(str[i]);\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_94_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int min_even = std::numeric_limits<int>::max();\n    int min_index = -1;\n    int n = arr.size();\n\n    int i = 0;\n    for (; i <= n - 8; i += 8) {\n        int32x4_t v1 = vld1q_s32(&arr[i]);\n        int32x4_t v2 = vld1q_s32(&arr[i + 4]);\n\n        uint32x4_t mask1 = vceqq_s32(vandq_s32(v1, vdupq_n_s32(1)), vdupq_n_s32(0));\n        uint32x4_t mask2 = vceqq_s32(vandq_s32(v2, vdupq_n_s32(1)), vdupq_n_s32(0));\n\n        int32x4_t even1 = vbslq_s32(mask1, v1, vdupq_n_s32(std::numeric_limits<int>::max()));\n        int32x4_t even2 = vbslq_s32(mask2, v2, vdupq_n_s32(std::numeric_limits<int>::max()));\n\n        int32x4_t min1 = vpminq_s32(even1, even2);\n        int32x2_t min2 = vpmin_s32(vget_low_s32(min1), vget_high_s32(min1));\n        int32x2_t min3 = vpmin_s32(min2, min2);\n\n        int min_val = vget_lane_s32(min3, 0);\n        if (min_val < min_even) {\n            min_even = min_val;\n            int idx1 = vminvq_s32(vbslq_s32(vceqq_s32(even1, vdupq_n_s32(min_val)), vdupq_n_s32(i), vdupq_n_s32(-1)));\n            int idx2 = vminvq_s32(vbslq_s32(vceqq_s32(even2, vdupq_n_s32(min_val)), vdupq_n_s32(i + 4), vdupq_n_s32(-1)));\n            min_index = (idx1 != -1) ? idx1 : idx2;\n        }\n    }\n\n    for (; i < n; ++i) {\n        if (arr[i] % 2 == 0 && arr[i] < min_even) {\n            min_even = arr[i];\n            min_index = i;\n        }\n    }\n\n    if (min_index == -1) {\n        return {};\n    }\n\n    return {min_even, min_index};\n}\n```"}
{"task_id": "SimdBench_94_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int min_even = std::numeric_limits<int>::max();\n    int min_index = -1;\n    int n = arr.size();\n    int i = 0;\n\n    // Process 4 elements at a time\n    for (; i <= n - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&arr[i]);\n        uint32x4_t even_mask = vceqq_s32(vandq_s32(vec, vdupq_n_s32(1)), vdupq_n_s32(0));\n        int32x4_t even_values = vbslq_s32(even_mask, vec, vdupq_n_s32(std::numeric_limits<int>::max()));\n        \n        int32x2_t min_pair1 = vpmin_s32(vget_low_s32(even_values), vget_high_s32(even_values));\n        int32x2_t min_pair2 = vpmin_s32(min_pair1, min_pair1);\n        int min_val = vget_lane_s32(min_pair2, 0);\n\n        if (min_val < min_even) {\n            min_even = min_val;\n            // Find the index of the minimum even value\n            for (int j = 0; j < 4; ++j) {\n                if (arr[i + j] == min_even) {\n                    min_index = i + j;\n                    break;\n                }\n            }\n        }\n    }\n\n    // Process remaining elements\n    for (; i < n; ++i) {\n        if (arr[i] % 2 == 0 && arr[i] < min_even) {\n            min_even = arr[i];\n            min_index = i;\n        }\n    }\n\n    if (min_index == -1) {\n        return {};\n    } else {\n        return {min_even, min_index};\n    }\n}\n```"}
{"task_id": "SimdBench_94_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int min_even = std::numeric_limits<int>::max();\n    int min_index = -1;\n    int n = arr.size();\n\n    int i = 0;\n    for (; i <= n - 8; i += 8) {\n        int32x4_t v1 = vld1q_s32(&arr[i]);\n        int32x4_t v2 = vld1q_s32(&arr[i + 4]);\n\n        uint32x4_t mask1 = vceqq_s32(vandq_s32(v1, vdupq_n_s32(1)), vdupq_n_s32(0));\n        uint32x4_t mask2 = vceqq_s32(vandq_s32(v2, vdupq_n_s32(1)), vdupq_n_s32(0));\n\n        int32x4_t even1 = vbslq_s32(mask1, v1, vdupq_n_s32(std::numeric_limits<int>::max()));\n        int32x4_t even2 = vbslq_s32(mask2, v2, vdupq_n_s32(std::numeric_limits<int>::max()));\n\n        int32x2_t min1 = vpmin_s32(vget_low_s32(even1), vget_high_s32(even1));\n        int32x2_t min2 = vpmin_s32(vget_low_s32(even2), vget_high_s32(even2));\n        int32x2_t min3 = vpmin_s32(min1, min2);\n\n        int min_val = vminv_s32(min3);\n        if (min_val < min_even) {\n            min_even = min_val;\n            for (int j = 0; j < 8; ++j) {\n                if (arr[i + j] == min_even && (min_index == -1 || i + j < min_index)) {\n                    min_index = i + j;\n                }\n            }\n        }\n    }\n\n    for (; i < n; ++i) {\n        if (arr[i] % 2 == 0 && arr[i] < min_even) {\n            min_even = arr[i];\n            min_index = i;\n        }\n    }\n\n    if (min_index == -1) {\n        return {};\n    } else {\n        return {min_even, min_index};\n    }\n}\n```"}
{"task_id": "SimdBench_94_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int min_even = std::numeric_limits<int>::max();\n    int min_index = -1;\n    int n = arr.size();\n\n    int i = 0;\n    for (; i <= n - 8; i += 8) {\n        int32x4_t v1 = vld1q_s32(&arr[i]);\n        int32x4_t v2 = vld1q_s32(&arr[i + 4]);\n\n        uint32x4_t mask1 = vceqq_s32(vandq_s32(v1, vdupq_n_s32(1)), vdupq_n_s32(0));\n        uint32x4_t mask2 = vceqq_s32(vandq_s32(v2, vdupq_n_s32(1)), vdupq_n_s32(0));\n\n        int32x4_t even1 = vbslq_s32(mask1, v1, vdupq_n_s32(std::numeric_limits<int>::max()));\n        int32x4_t even2 = vbslq_s32(mask2, v2, vdupq_n_s32(std::numeric_limits<int>::max()));\n\n        int32x4_t min1 = vpminq_s32(even1, even2);\n        int32x2_t min2 = vpmin_s32(vget_low_s32(min1), vget_high_s32(min1));\n        int32x2_t min3 = vpmin_s32(min2, min2);\n\n        int min_val = vget_lane_s32(min3, 0);\n        if (min_val < min_even) {\n            min_even = min_val;\n            int idx1 = vget_lane_s32(vminvq_s32(vbslq_s32(vceqq_s32(even1, vdupq_n_s32(min_val)), vreinterpretq_s32_u32(vmovl_u16(vcreate_u16(i))), vdupq_n_s32(n))), 0);\n            int idx2 = vget_lane_s32(vminvq_s32(vbslq_s32(vceqq_s32(even2, vdupq_n_s32(min_val)), vreinterpretq_s32_u32(vmovl_u16(vcreate_u16(i + 4))), vdupq_n_s32(n))), 0);\n            min_index = (idx1 < n) ? idx1 : idx2;\n        }\n    }\n\n    for (; i < n; ++i) {\n        if (arr[i] % 2 == 0 && arr[i] < min_even) {\n            min_even = arr[i];\n            min_index = i;\n        }\n    }\n\n    if (min_index == -1) {\n        return {};\n    }\n\n    return {min_even, min_index};\n}\n```"}
{"task_id": "SimdBench_94_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int min_even = std::numeric_limits<int>::max();\n    int min_index = -1;\n    int n = arr.size();\n\n    int i = 0;\n    for (; i <= n - 8; i += 8) {\n        int32x4_t v1 = vld1q_s32(&arr[i]);\n        int32x4_t v2 = vld1q_s32(&arr[i + 4]);\n\n        uint32x4_t mask1 = vceqq_s32(vandq_s32(v1, vdupq_n_s32(1)), vdupq_n_s32(0));\n        uint32x4_t mask2 = vceqq_s32(vandq_s32(v2, vdupq_n_s32(1)), vdupq_n_s32(0));\n\n        int32x4_t even1 = vbslq_s32(mask1, v1, vdupq_n_s32(std::numeric_limits<int>::max()));\n        int32x4_t even2 = vbslq_s32(mask2, v2, vdupq_n_s32(std::numeric_limits<int>::max()));\n\n        int32x2_t min1 = vpmin_s32(vget_low_s32(even1), vget_high_s32(even1));\n        int32x2_t min2 = vpmin_s32(vget_low_s32(even2), vget_high_s32(even2));\n        int32x2_t min3 = vpmin_s32(min1, min2);\n\n        int min_val = vminv_s32(min3);\n        if (min_val < min_even) {\n            min_even = min_val;\n            for (int j = 0; j < 8; ++j) {\n                if (arr[i + j] == min_even && (min_index == -1 || i + j < min_index)) {\n                    min_index = i + j;\n                }\n            }\n        }\n    }\n\n    for (; i < n; ++i) {\n        if (arr[i] % 2 == 0 && arr[i] < min_even) {\n            min_even = arr[i];\n            min_index = i;\n        }\n    }\n\n    if (min_index == -1) {\n        return {};\n    } else {\n        return {min_even, min_index};\n    }\n}\n```"}
{"task_id": "SimdBench_95_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n#include <unordered_map>\n\nint search_simd(std::vector<int> lst) {\n    std::unordered_map<int, int> frequencyMap;\n    for (int num : lst) {\n        frequencyMap[num]++;\n    }\n\n    int result = -1;\n    for (const auto& entry : frequencyMap) {\n        int num = entry.first;\n        int freq = entry.second;\n        if (freq >= num && num > result) {\n            result = num;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_95_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    if (lst.empty()) return -1;\n\n    int max_val = *std::max_element(lst.begin(), lst.end());\n    std::vector<int> freq(max_val + 1, 0);\n\n    // Count frequencies using SIMD\n    for (size_t i = 0; i < lst.size(); i += 8) {\n        uint32x4_t v1 = vld1q_u32(reinterpret_cast<const uint32_t*>(&lst[i]));\n        uint32x4_t v2 = vld1q_u32(reinterpret_cast<const uint32_t*>(&lst[i + 4]));\n\n        for (int j = 0; j < 4; ++j) {\n            freq[vgetq_lane_u32(v1, j)]++;\n            freq[vgetq_lane_u32(v2, j)]++;\n        }\n    }\n\n    // Check for the condition\n    for (int i = max_val; i > 0; --i) {\n        if (freq[i] >= i) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n```"}
{"task_id": "SimdBench_95_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n#include <unordered_map>\n\nint search_simd(std::vector<int> lst) {\n    std::unordered_map<int, int> frequencyMap;\n    for (int num : lst) {\n        frequencyMap[num]++;\n    }\n\n    int result = -1;\n    for (const auto& entry : frequencyMap) {\n        int num = entry.first;\n        int freq = entry.second;\n        if (freq >= num && num > result) {\n            result = num;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_95_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n#include <unordered_map>\n\nint search_simd(std::vector<int> lst) {\n    std::unordered_map<int, int> frequencyMap;\n    for (int num : lst) {\n        frequencyMap[num]++;\n    }\n\n    int result = -1;\n    for (const auto& entry : frequencyMap) {\n        int num = entry.first;\n        int freq = entry.second;\n        if (freq >= num && num > result) {\n            result = num;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_95_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n#include <unordered_map>\n\nint search_simd(std::vector<int> lst) {\n    std::unordered_map<int, int> frequencyMap;\n    for (int num : lst) {\n        frequencyMap[num]++;\n    }\n\n    int result = -1;\n    for (const auto& entry : frequencyMap) {\n        int num = entry.first;\n        int freq = entry.second;\n        if (freq >= num && num > result) {\n            result = num;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_96_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    if (n == 0) return false;\n\n    // Check if the vector is a palindrome\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - i - 1]) {\n            return false;\n        }\n    }\n\n    // Calculate the sum using NEON intrinsics\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    int i;\n    for (i = 0; i <= n - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&q[i]);\n        sum_vec = vaddq_s32(sum_vec, vec);\n    }\n\n    int32_t sum[4];\n    vst1q_s32(sum, sum_vec);\n\n    int total_sum = sum[0] + sum[1] + sum[2] + sum[3];\n\n    // Add remaining elements\n    for (; i < n; ++i) {\n        total_sum += q[i];\n    }\n\n    return total_sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    if (n == 0) return false;\n\n    // Check if the vector is a palindrome\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - i - 1]) {\n            return false;\n        }\n    }\n\n    // Calculate the sum using NEON intrinsics\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    int i;\n    for (i = 0; i <= n - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&q[i]);\n        sum_vec = vaddq_s32(sum_vec, vec);\n    }\n\n    int32_t sum[4];\n    vst1q_s32(sum, sum_vec);\n\n    int total_sum = sum[0] + sum[1] + sum[2] + sum[3];\n\n    // Add remaining elements\n    for (; i < n; ++i) {\n        total_sum += q[i];\n    }\n\n    return total_sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    if (n == 0) return false;\n\n    // Check if the vector is a palindrome\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - i - 1]) {\n            return false;\n        }\n    }\n\n    // Calculate the sum using NEON intrinsics\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    int i;\n    for (i = 0; i <= n - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&q[i]);\n        sum_vec = vaddq_s32(sum_vec, vec);\n    }\n\n    int32_t sum[4];\n    vst1q_s32(sum, sum_vec);\n    int total_sum = sum[0] + sum[1] + sum[2] + sum[3];\n\n    // Add remaining elements\n    for (; i < n; ++i) {\n        total_sum += q[i];\n    }\n\n    return total_sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    if (n == 0) return false;\n\n    // Check if the vector is a palindrome\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - i - 1]) {\n            return false;\n        }\n    }\n\n    // Calculate the sum using NEON intrinsics\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    int i;\n    for (i = 0; i <= n - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&q[i]);\n        sum_vec = vaddq_s32(sum_vec, vec);\n    }\n\n    int32_t sum[4];\n    vst1q_s32(sum, sum_vec);\n\n    int total_sum = sum[0] + sum[1] + sum[2] + sum[3];\n\n    // Add remaining elements\n    for (; i < n; ++i) {\n        total_sum += q[i];\n    }\n\n    return total_sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    if (n == 0) return false;\n\n    // Check if the vector is a palindrome\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - i - 1]) {\n            return false;\n        }\n    }\n\n    // Calculate the sum using NEON intrinsics\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    int i;\n    for (i = 0; i <= n - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&q[i]);\n        sum_vec = vaddq_s32(sum_vec, vec);\n    }\n\n    int32_t sum[4];\n    vst1q_s32(sum, sum_vec);\n    int total_sum = sum[0] + sum[1] + sum[2] + sum[3];\n\n    // Add remaining elements\n    for (; i < n; ++i) {\n        total_sum += q[i];\n    }\n\n    return total_sum <= w;\n}\n```"}
{"task_id": "SimdBench_97_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    int* data = arr.data();\n\n    for (int i = 0; i <= n / 8; i += 2) {\n        int32x4_t vec1 = vld1q_s32(data + 4 * i);\n        int32x4_t vec2 = vld1q_s32(data + n - 4 * i - 4);\n\n        uint32x4_t cmp1 = vceqq_s32(vec1, vrev64q_s32(vec2));\n        uint32x4_t cmp2 = vceqq_s32(vextq_s32(vec1, vec1, 2), vextq_s32(vrev64q_s32(vec2), vrev64q_s32(vec2), 2));\n\n        uint32x4_t not_cmp1 = vmvnq_u32(cmp1);\n        uint32x4_t not_cmp2 = vmvnq_u32(cmp2);\n\n        uint32x4_t sum1 = vpaddlq_u16(vpaddlq_u8(vmovn_u16(vmovn_u32(not_cmp1))));\n        uint32x4_t sum2 = vpaddlq_u16(vpaddlq_u8(vmovn_u16(vmovn_u32(not_cmp2))));\n\n        changes += vgetq_lane_u32(sum1, 0) + vgetq_lane_u32(sum1, 1) +\n                   vgetq_lane_u32(sum2, 0) + vgetq_lane_u32(sum2, 1);\n    }\n\n    return changes / 2;\n}\n```"}
{"task_id": "SimdBench_97_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    int* data = arr.data();\n\n    for (int i = 0; i <= n / 8; i += 2) {\n        int32x4_t a = vld1q_s32(data + 4 * i);\n        int32x4_t b = vld1q_s32(data + n - 4 * i - 4);\n\n        uint32x4_t cmp1 = vceqq_s32(a, b);\n        uint32x4_t cmp2 = vceqq_s32(vld1q_s32(data + 4 * i + 4), vld1q_s32(data + n - 4 * i - 8));\n\n        uint32x4_t not_cmp1 = vmvnq_u32(cmp1);\n        uint32x4_t not_cmp2 = vmvnq_u32(cmp2);\n\n        uint32x4_t sum1 = vcntq_u32(not_cmp1);\n        uint32x4_t sum2 = vcntq_u32(not_cmp2);\n\n        uint32_t total_changes1 = vaddvq_u32(sum1);\n        uint32_t total_changes2 = vaddvq_u32(sum2);\n\n        changes += total_changes1 + total_changes2;\n    }\n\n    return changes / 2;\n}\n```"}
{"task_id": "SimdBench_97_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    int* data = arr.data();\n\n    for (int i = 0; i <= n / 8; i += 2) {\n        int32x4_t a = vld1q_s32(data + 4 * i);\n        int32x4_t b = vld1q_s32(data + n - 4 * i - 4);\n\n        uint32x4_t cmp1 = vceqq_s32(a, b);\n        uint32x4_t cmp2 = vceqq_s32(vld1q_s32(data + 4 * i + 4), vld1q_s32(data + n - 4 * i - 8));\n\n        uint32x4_t not_cmp1 = vmvnq_u32(cmp1);\n        uint32x4_t not_cmp2 = vmvnq_u32(cmp2);\n\n        uint32x4_t sum1 = vpaddlq_u16(vpaddlq_u8(vmovn_u16(vmovn_u32(not_cmp1))));\n        uint32x4_t sum2 = vpaddlq_u16(vpaddlq_u8(vmovn_u16(vmovn_u32(not_cmp2))));\n\n        changes += vgetq_lane_u32(sum1, 0) + vgetq_lane_u32(sum1, 1) +\n                   vgetq_lane_u32(sum2, 0) + vgetq_lane_u32(sum2, 1);\n    }\n\n    return changes / 2;\n}\n```"}
{"task_id": "SimdBench_97_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    int* data = arr.data();\n\n    for (int i = 0; i <= n / 8; i += 2) {\n        int32x4_t a = vld1q_s32(data + 4 * i);\n        int32x4_t b = vld1q_s32(data + n - 4 * i - 4);\n\n        uint32x4_t cmp1 = vceqq_s32(a, b);\n        uint32x4_t cmp2 = vceqq_s32(vld1q_s32(data + 4 * i + 4), vld1q_s32(data + n - 4 * i - 8));\n\n        uint32x4_t not_cmp1 = vmvnq_u32(cmp1);\n        uint32x4_t not_cmp2 = vmvnq_u32(cmp2);\n\n        uint32x4_t sum1 = vpaddlq_u16(vpaddlq_u8(vmovn_u16(vmovn_u32(not_cmp1))));\n        uint32x4_t sum2 = vpaddlq_u16(vpaddlq_u8(vmovn_u16(vmovn_u32(not_cmp2))));\n\n        changes += vgetq_lane_u32(sum1, 0) + vgetq_lane_u32(sum1, 1) +\n                   vgetq_lane_u32(sum2, 0) + vgetq_lane_u32(sum2, 1);\n    }\n\n    return changes / 2;\n}\n```"}
{"task_id": "SimdBench_97_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    int* data = arr.data();\n\n    for (int i = 0; i <= n / 8; i += 2) {\n        int32x4_t a = vld1q_s32(data + 4 * i);\n        int32x4_t b = vld1q_s32(data + n - 4 * i - 4);\n\n        uint32x4_t cmp1 = vceqq_s32(a, b);\n        uint32x4_t cmp2 = vceqq_s32(vld1q_s32(data + 4 * i + 4), vld1q_s32(data + n - 4 * i - 8));\n\n        uint32x4_t not_cmp1 = vmvnq_u32(cmp1);\n        uint32x4_t not_cmp2 = vmvnq_u32(cmp2);\n\n        uint32x4_t sum1 = vpaddlq_u16(vpaddlq_u8(vmovn_u16(vmovn_u32(not_cmp1))));\n        uint32x4_t sum2 = vpaddlq_u16(vpaddlq_u8(vmovn_u16(vmovn_u32(not_cmp2))));\n\n        changes += vgetq_lane_u32(sum1, 0) + vgetq_lane_u32(sum1, 1) +\n                   vgetq_lane_u32(sum2, 0) + vgetq_lane_u32(sum2, 1);\n    }\n\n    return changes / 2;\n}\n```"}
{"task_id": "SimdBench_98_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    int32x4_t sum1 = vdupq_n_s32(0);\n    int32x4_t sum2 = vdupq_n_s32(0);\n\n    size_t i;\n    for (i = 0; i + 4 <= lst1.size(); i += 4) {\n        int32x4_t len1 = vld1q_s32(reinterpret_cast<const int32_t*>(lst1[i].data()));\n        int32x4_t len2 = vld1q_s32(reinterpret_cast<const int32_t*>(lst2[i].data()));\n\n        sum1 = vaddq_s32(sum1, len1);\n        sum2 = vaddq_s32(sum2, len2);\n    }\n\n    int total1 = vaddvq_s32(sum1);\n    int total2 = vaddvq_s32(sum2);\n\n    for (; i < lst1.size(); ++i) {\n        total1 += lst1[i].size();\n    }\n\n    for (; i < lst2.size(); ++i) {\n        total2 += lst2[i].size();\n    }\n\n    return total1 < total2 ? lst1 : lst2;\n}\n```\n\nNote: The above code contains incorrect assumptions about loading string lengths directly into SIMD registers. This is not possible as `vld1q_s32` expects a pointer to an array of integers, not string lengths. A correct implementation would require summing string lengths in a scalar fashion and then using SIMD for larger chunks of data if applicable. Here's a corrected version:\n\n```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    int32x4_t sum1 = vdupq_n_s32(0);\n    int32x4_t sum2 = vdupq_n_s32(0);\n\n    size_t i;\n    for (i = 0; i + 4 <= lst1.size(); i += 4) {\n        int32_t lens1[4] = {static_cast<int32_t>(lst1[i].size()), static_cast<int32_t>(lst1[i+1].size()),\n                           static_cast<int32_t>(lst1[i+2].size()), static_cast<int32_t>(lst1[i+3].size())};\n        int32_t lens2[4] = {static_cast<int32_t>(lst2[i].size()), static_cast<int32_t>(lst2[i+1].size()),\n                           static_cast<int32_t>(lst2[i+2].size()), static_cast<int32_t>(lst2[i+3].size())};\n\n        int32x4_t len1 = vld1q_s32(lens1);\n        int32x4_t len2 = vld1q_s32(lens2);\n\n        sum1 = vaddq_s32(sum1, len1);\n        sum2 = vaddq_s32(sum2, len2);\n    }\n\n    int total1 = vaddvq_s32(sum1);\n    int total2 = vaddvq_s32(sum2);\n\n    for (; i < lst1.size(); ++i) {\n        total1 += lst1[i].size();\n    }\n\n    for (i = std::max(i - 4, 0); i < lst2.size(); ++i) {\n        total2 += lst2[i].size();\n    }\n\n    return total1 <= total2 ? lst1 : lst2;\n}\n```"}
{"task_id": "SimdBench_98_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    int32x4_t sum1 = vdupq_n_s32(0);\n    int32x4_t sum2 = vdupq_n_s32(0);\n\n    size_t i = 0;\n    for (; i + 4 <= lst1.size(); i += 4) {\n        int32x4_t len1 = vld1q_s32(reinterpret_cast<const int32_t*>(lst1[i].data()));\n        int32x4_t len2 = vld1q_s32(reinterpret_cast<const int32_t*>(lst2[i].data()));\n\n        sum1 = vaddq_s32(sum1, len1);\n        sum2 = vaddq_s32(sum2, len2);\n    }\n\n    int total1 = vgetq_lane_s32(sum1, 0) + vgetq_lane_s32(sum1, 1) + vgetq_lane_s32(sum1, 2) + vgetq_lane_s32(sum1, 3);\n    int total2 = vgetq_lane_s32(sum2, 0) + vgetq_lane_s32(sum2, 1) + vgetq_lane_s32(sum2, 2) + vgetq_lane_s32(sum2, 3);\n\n    for (; i < lst1.size(); ++i) {\n        total1 += lst1[i].size();\n        total2 += lst2[i].size();\n    }\n\n    for (; i < lst2.size(); ++i) {\n        total2 += lst2[i].size();\n    }\n\n    return total1 < total2 ? lst1 : lst2;\n}\n```"}
{"task_id": "SimdBench_98_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    int32x4_t sum1 = vdupq_n_s32(0);\n    int32x4_t sum2 = vdupq_n_s32(0);\n\n    size_t i = 0;\n    for (; i + 4 <= lst1.size(); i += 4) {\n        int32x4_t len1 = vld1q_s32(reinterpret_cast<const int32_t*>(lst1[i].data()));\n        int32x4_t len2 = vld1q_s32(reinterpret_cast<const int32_t*>(lst2[i].data()));\n\n        len1 = vsetq_lane_s32(lst1[i].size(), len1, 0);\n        len1 = vsetq_lane_s32(lst1[i+1].size(), len1, 1);\n        len1 = vsetq_lane_s32(lst1[i+2].size(), len1, 2);\n        len1 = vsetq_lane_s32(lst1[i+3].size(), len1, 3);\n\n        len2 = vsetq_lane_s32(lst2[i].size(), len2, 0);\n        len2 = vsetq_lane_s32(lst2[i+1].size(), len2, 1);\n        len2 = vsetq_lane_s32(lst2[i+2].size(), len2, 2);\n        len2 = vsetq_lane_s32(lst2[i+3].size(), len2, 3);\n\n        sum1 = vaddq_s32(sum1, len1);\n        sum2 = vaddq_s32(sum2, len2);\n    }\n\n    int total1 = 0, total2 = 0;\n    for (int j = 0; j < 4; ++j) {\n        total1 += vgetq_lane_s32(sum1, j);\n        total2 += vgetq_lane_s32(sum2, j);\n    }\n\n    for (; i < lst1.size(); ++i) {\n        total1 += lst1[i].size();\n        total2 += lst2[i].size();\n    }\n\n    for (; i < lst2.size(); ++i) {\n        total2 += lst2[i].size();\n    }\n\n    return total1 < total2 ? lst1 : lst2;\n}\n```"}
{"task_id": "SimdBench_98_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    int32x4_t sum1 = vdupq_n_s32(0);\n    int32x4_t sum2 = vdupq_n_s32(0);\n\n    size_t i;\n    for (i = 0; i + 4 <= lst1.size(); i += 4) {\n        int32x4_t len1 = vld1q_s32(reinterpret_cast<const int32_t*>(lst1[i].data()));\n        int32x4_t len2 = vld1q_s32(reinterpret_cast<const int32_t*>(lst2[i].data()));\n        sum1 = vaddq_s32(sum1, len1);\n        sum2 = vaddq_s32(sum2, len2);\n    }\n\n    int total1 = vgetq_lane_s32(sum1, 0) + vgetq_lane_s32(sum1, 1) + vgetq_lane_s32(sum1, 2) + vgetq_lane_s32(sum1, 3);\n    int total2 = vgetq_lane_s32(sum2, 0) + vgetq_lane_s32(sum2, 1) + vgetq_lane_s32(sum2, 2) + vgetq_lane_s32(sum2, 3);\n\n    for (; i < lst1.size(); ++i) {\n        total1 += lst1[i].size();\n        total2 += lst2[i].size();\n    }\n\n    for (; i < lst2.size(); ++i) {\n        total2 += lst2[i].size();\n    }\n\n    return total1 < total2 ? lst1 : lst2;\n}\n```"}
{"task_id": "SimdBench_98_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    int32x4_t sum1 = vdupq_n_s32(0);\n    int32x4_t sum2 = vdupq_n_s32(0);\n\n    size_t i;\n    for (i = 0; i + 4 <= lst1.size(); i += 4) {\n        int32x4_t len1 = vld1q_s32(reinterpret_cast<const int32_t*>(lst1[i].data()));\n        int32x4_t len2 = vld1q_s32(reinterpret_cast<const int32_t*>(lst2[i].data()));\n        sum1 = vaddq_s32(sum1, len1);\n        sum2 = vaddq_s32(sum2, len2);\n    }\n\n    int total1 = vaddvq_s32(sum1);\n    int total2 = vaddvq_s32(sum2);\n\n    for (; i < lst1.size(); ++i) {\n        total1 += lst1[i].size();\n    }\n\n    for (; i < lst2.size(); ++i) {\n        total2 += lst2[i].size();\n    }\n\n    return total1 < total2 ? lst1 : lst2;\n}\n```"}
{"task_id": "SimdBench_99_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n == 1) {\n        return x == 1;\n    }\n    uint64x2_t x_vec = vdupq_n_u64(x);\n    uint64x2_t n_vec = vdupq_n_u64(n);\n    uint64x2_t one_vec = vdupq_n_u64(1);\n    uint64x2_t result_vec = vdupq_n_u64(1);\n\n    while (true) {\n        uint64x2_t cmp_vec = vceqq_u64(result_vec, x_vec);\n        if (vgetq_lane_u64(cmp_vec, 0) || vgetq_lane_u64(cmp_vec, 1)) {\n            return true;\n        }\n        cmp_vec = vcgtq_u64(result_vec, x_vec);\n        if (vgetq_lane_u64(cmp_vec, 0) || vgetq_lane_u64(cmp_vec, 1)) {\n            return false;\n        }\n        result_vec = vmulq_u64(result_vec, n_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_99_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n == 1) {\n        return x == 1;\n    }\n    uint64x2_t x_vec = vdupq_n_u64(x);\n    uint64x2_t n_vec = vdupq_n_u64(n);\n    uint64x2_t one_vec = vdupq_n_u64(1);\n    uint64x2_t result_vec = vdupq_n_u64(1);\n\n    while (true) {\n        uint64x2_t cmp_vec = vceqq_u64(result_vec, x_vec);\n        if (vgetq_lane_u64(cmp_vec, 0) || vgetq_lane_u64(cmp_vec, 1)) {\n            return true;\n        }\n        cmp_vec = vcgtq_u64(result_vec, x_vec);\n        if (vgetq_lane_u64(cmp_vec, 0) || vgetq_lane_u64(cmp_vec, 1)) {\n            return false;\n        }\n        result_vec = vmulq_u64(result_vec, n_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_99_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n == 1) {\n        return x == 1;\n    }\n    uint64x2_t x_vec = vdupq_n_u64(x);\n    uint64x2_t n_vec = vdupq_n_u64(n);\n    uint64x2_t one_vec = vdupq_n_u64(1);\n    uint64x2_t result_vec = vdupq_n_u64(1);\n\n    while (true) {\n        uint64x2_t cmp_vec = vceqq_u64(result_vec, x_vec);\n        if (vgetq_lane_u64(cmp_vec, 0) || vgetq_lane_u64(cmp_vec, 1)) {\n            return true;\n        }\n        cmp_vec = vcgtq_u64(result_vec, x_vec);\n        if (vgetq_lane_u64(cmp_vec, 0) || vgetq_lane_u64(cmp_vec, 1)) {\n            return false;\n        }\n        result_vec = vmulq_u64(result_vec, n_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_99_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n == 1) {\n        return x == 1;\n    }\n    uint64_t current = 1;\n    uint64x2_t current_vec = vdupq_n_u64(1);\n    uint64x2_t n_vec = vdupq_n_u64(n);\n    uint64x2_t x_vec = vdupq_n_u64(x);\n\n    while (current <= x) {\n        uint64x2_t result = vmulq_u64(current_vec, n_vec);\n        uint64x2_t cmp = vceqq_u64(result, x_vec);\n        uint32x2_t cmp_res = vreinterpretq_u32_u64(cmp);\n        if (vgetq_lane_u32(cmp_res, 0) || vgetq_lane_u32(cmp_res, 1)) {\n            return true;\n        }\n        current_vec = result;\n        current = vgetq_lane_u64(current_vec, 0);\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n == 1) {\n        return x == 1;\n    }\n    uint64_t current = 1;\n    uint64x2_t current_vec = vdupq_n_u64(1);\n    uint64x2_t n_vec = vdupq_n_u64(n);\n    uint64x2_t x_vec = vdupq_n_u64(x);\n\n    while (current <= x) {\n        uint64x2_t result = vmulq_u64(current_vec, n_vec);\n        uint64x2_t cmp = vceqq_u64(result, x_vec);\n        uint32x2_t cmp_res = vreinterpretq_u32_u64(cmp);\n        if (vgetq_lane_u32(cmp_res, 0) || vgetq_lane_u32(cmp_res, 1)) {\n            return true;\n        }\n        current_vec = result;\n        current = vgetq_lane_u64(current_vec, 0);\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_100_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    int count = 0;\n    const uint8_t prime_hex_digits[16] = {0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0};\n    uint8x16_t prime_mask = vld1q_u8(prime_hex_digits);\n\n    size_t i = 0;\n    for (; i <= num.size() - 16; i += 16) {\n        uint8x16_t input = vdupq_n_u8(0);\n        for (size_t j = 0; j < 16; ++j) {\n            uint8_t digit = num[i + j];\n            if (digit >= '0' && digit <= '9') {\n                digit -= '0';\n            } else if (digit >= 'A' && digit <= 'F') {\n                digit = digit - 'A' + 10;\n            }\n            input = vsetq_lane_u8(digit, input, j);\n        }\n        uint8x16_t result = vqtbl1q_u8(prime_mask, input);\n        uint8x16_t ones = vcntq_u8(result);\n        count += vaddvq_u8(ones);\n    }\n\n    for (; i < num.size(); ++i) {\n        uint8_t digit = num[i];\n        if (digit >= '0' && digit <= '9') {\n            digit -= '0';\n        } else if (digit >= 'A' && digit <= 'F') {\n            digit = digit - 'A' + 10;\n        }\n        count += prime_hex_digits[digit];\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    int count = 0;\n    const uint8_t prime_hex_digits[16] = {0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0};\n    uint8x16_t prime_mask = vld1q_u8(prime_hex_digits);\n\n    size_t i = 0;\n    for (; i <= num.size() - 16; i += 16) {\n        uint8x16_t input = vdupq_n_u8(0);\n        for (size_t j = 0; j < 16; ++j) {\n            uint8_t digit = num[i + j];\n            if (digit >= '0' && digit <= '9') {\n                digit -= '0';\n            } else if (digit >= 'A' && digit <= 'F') {\n                digit = digit - 'A' + 10;\n            }\n            input = vsetq_lane_u8(digit, input, j);\n        }\n        uint8x16_t result = vandq_u8(vceqq_u8(input, prime_mask), prime_mask);\n        uint32x4_t sum = vpaddlq_u8(result);\n        sum = vpaddlq_u16(sum);\n        count += vgetq_lane_u32(sum, 0);\n    }\n\n    for (; i < num.size(); ++i) {\n        uint8_t digit = num[i];\n        if (digit >= '0' && digit <= '9') {\n            digit -= '0';\n        } else if (digit >= 'A' && digit <= 'F') {\n            digit = digit - 'A' + 10;\n        }\n        count += prime_hex_digits[digit];\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    int count = 0;\n    const uint8_t prime_hex_digits[16] = {0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0};\n    uint8x16_t prime_mask = vld1q_u8(prime_hex_digits);\n\n    size_t i = 0;\n    for (; i <= num.size() - 16; i += 16) {\n        uint8x16_t input = vdupq_n_u8(0);\n        for (size_t j = 0; j < 16; ++j) {\n            uint8_t digit = num[i + j];\n            if (digit >= '0' && digit <= '9') {\n                digit -= '0';\n            } else if (digit >= 'A' && digit <= 'F') {\n                digit -= 'A' - 10;\n            }\n            input = vsetq_lane_u8(digit, input, j);\n        }\n        uint8x16_t match = vceqq_u8(vqtbl1q_u8(prime_mask, input), vdupq_n_u8(1));\n        count += vaddvq_u8(match);\n    }\n\n    for (; i < num.size(); ++i) {\n        uint8_t digit = num[i];\n        if (digit >= '0' && digit <= '9') {\n            digit -= '0';\n        } else if (digit >= 'A' && digit <= 'F') {\n            digit -= 'A' - 10;\n        }\n        count += prime_hex_digits[digit];\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    int count = 0;\n    const uint8_t prime_hex_digits[16] = {0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0};\n    uint8x16_t prime_mask = vld1q_u8(prime_hex_digits);\n\n    size_t i = 0;\n    for (; i <= num.size() - 16; i += 16) {\n        uint8x16_t input = vdupq_n_u8(0);\n        for (size_t j = 0; j < 16; ++j) {\n            uint8_t digit = num[i + j];\n            if (digit >= '0' && digit <= '9') {\n                digit -= '0';\n            } else if (digit >= 'A' && digit <= 'F') {\n                digit -= 'A' - 10;\n            }\n            input = vsetq_lane_u8(digit, input, j);\n        }\n        uint8x16_t match = vceqq_u8(vqtbl1q_u8(prime_mask, input), vdupq_n_u8(1));\n        count += vaddvq_u8(match);\n    }\n\n    for (; i < num.size(); ++i) {\n        uint8_t digit = num[i];\n        if (digit >= '0' && digit <= '9') {\n            digit -= '0';\n        } else if (digit >= 'A' && digit <= 'F') {\n            digit -= 'A' - 10;\n        }\n        count += prime_hex_digits[digit];\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    int count = 0;\n    const uint8_t primes[] = {2, 3, 5, 7, 11, 13};\n    uint8x16_t prime_vec = vld1q_u8(primes);\n    size_t len = num.length();\n\n    for (size_t i = 0; i <= len - 16; i += 16) {\n        uint8x16_t hex_vec;\n        for (size_t j = 0; j < 16; ++j) {\n            char c = num[i + j];\n            if (c >= '0' && c <= '9') {\n                hex_vec[j] = c - '0';\n            } else {\n                hex_vec[j] = c - 'A' + 10;\n            }\n        }\n\n        uint8x16_t cmp1 = vceqq_u8(hex_vec, vdupq_n_u8(2));\n        uint8x16_t cmp2 = vceqq_u8(hex_vec, vdupq_n_u8(3));\n        uint8x16_t cmp3 = vceqq_u8(hex_vec, vdupq_n_u8(5));\n        uint8x16_t cmp4 = vceqq_u8(hex_vec, vdupq_n_u8(7));\n        uint8x16_t cmp5 = vceqq_u8(hex_vec, vdupq_n_u8(11));\n        uint8x16_t cmp6 = vceqq_u8(hex_vec, vdupq_n_u8(13));\n\n        uint8x16_t result = vorrq_u8(vorrq_u8(vorrq_u8(vorrq_u8(vorrq_u8(cmp1, cmp2), cmp3), cmp4), cmp5), cmp6);\n\n        uint32x4_t sum = vpaddlq_u16(vpaddlq_u8(vreinterpretq_u16_u8(result)));\n        count += vgetq_lane_u32(sum, 0) + vgetq_lane_u32(sum, 1);\n    }\n\n    for (size_t i = (len / 16) * 16; i < len; ++i) {\n        char c = num[i];\n        int digit = (c >= '0' && c <= '9') ? c - '0' : c - 'A' + 10;\n        if (digit == 2 || digit == 3 || digit == 5 || digit == 7 || digit == 11 || digit == 13) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_101_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s) {\n    if (s.length() < 3) {\n        return false;\n    }\n\n    const char* str = s.c_str();\n    size_t len = s.length();\n    size_t i = 0;\n\n    // Process 16 characters at a time\n    for (; i <= len - 16; i += 15) {\n        uint8x16_t vec1 = vld1q_u8(reinterpret_cast<const uint8_t*>(str + i));\n        uint8x16_t vec2 = vld1q_u8(reinterpret_cast<const uint8_t*>(str + i + 1));\n        uint8x16_t vec3 = vld1q_u8(reinterpret_cast<const uint8_t*>(str + i + 2));\n\n        uint8x16_t cmp1 = vceqq_u8(vec1, vec2);\n        uint8x16_t cmp2 = vceqq_u8(vec2, vec3);\n        uint8x16_t cmp3 = vceqq_u8(vec1, vec3);\n\n        uint8x16_t result = vorrq_u8(vorrq_u8(cmp1, cmp2), cmp3);\n\n        if (vmaxvq_u8(result) != 0) {\n            return false;\n        }\n    }\n\n    // Check remaining characters\n    for (; i <= len - 3; ++i) {\n        if (str[i] == str[i + 1] || str[i] == str[i + 2] || str[i + 1] == str[i + 2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s) {\n    size_t len = s.length();\n    if (len < 3) return false;\n\n    const char* str = s.c_str();\n    uint8x16_t zero = vdupq_n_u8(0);\n\n    for (size_t i = 0; i <= len - 16; i += 15) {\n        uint8x16_t vec1 = vld1q_u8(reinterpret_cast<const uint8_t*>(str + i));\n        uint8x16_t vec2 = vld1q_u8(reinterpret_cast<const uint8_t*>(str + i + 1));\n        uint8x16_t vec3 = vld1q_u8(reinterpret_cast<const uint8_t*>(str + i + 2));\n\n        uint8x16_t cmp1 = vceqq_u8(vec1, vec2);\n        uint8x16_t cmp2 = vceqq_u8(vec2, vec3);\n        uint8x16_t cmp3 = vceqq_u8(vec1, vec3);\n\n        uint8x16_t or1 = vorrq_u8(cmp1, cmp2);\n        uint8x16_t or2 = vorrq_u8(or1, cmp3);\n\n        uint8x16_t result = vandq_u8(or2, or2);\n\n        if (!vmaxvq_u8(result) == 0) {\n            return false;\n        }\n    }\n\n    for (size_t i = len - (len % 15); i <= len - 3; ++i) {\n        if (str[i] == str[i + 1] || str[i] == str[i + 2] || str[i + 1] == str[i + 2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s) {\n    size_t len = s.length();\n    if (len < 3) return false;\n\n    const char* str = s.c_str();\n    uint8x16_t vec1, vec2, vec3;\n    uint8x16_t cmp1, cmp2, result;\n    uint32_t mask;\n\n    for (size_t i = 0; i <= len - 16; i += 15) {\n        vec1 = vld1q_u8(reinterpret_cast<const uint8_t*>(str + i));\n        vec2 = vld1q_u8(reinterpret_cast<const uint8_t*>(str + i + 1));\n        vec3 = vld1q_u8(reinterpret_cast<const uint8_t*>(str + i + 2));\n\n        cmp1 = vceqq_u8(vec1, vec2);\n        cmp2 = vceqq_u8(vec1, vec3);\n        result = vorrq_u8(cmp1, cmp2);\n\n        mask = vreinterpretq_u32_u8(result);\n        if (mask != 0) return false;\n    }\n\n    for (size_t i = len - (len % 15); i <= len - 3; ++i) {\n        if (str[i] == str[i + 1] || str[i] == str[i + 2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s) {\n    size_t len = s.length();\n    if (len < 3) return false;\n\n    const char* str = s.c_str();\n    uint8x16_t zero = vdupq_n_u8(0);\n\n    for (size_t i = 0; i <= len - 16; i += 15) {\n        uint8x16_t vec1 = vld1q_u8(reinterpret_cast<const uint8_t*>(str + i));\n        uint8x16_t vec2 = vld1q_u8(reinterpret_cast<const uint8_t*>(str + i + 1));\n        uint8x16_t vec3 = vld1q_u8(reinterpret_cast<const uint8_t*>(str + i + 2));\n\n        uint8x16_t cmp1 = vceqq_u8(vec1, vec2);\n        uint8x16_t cmp2 = vceqq_u8(vec2, vec3);\n        uint8x16_t cmp3 = vceqq_u8(vec1, vec3);\n\n        uint8x16_t or1 = vorrq_u8(cmp1, cmp2);\n        uint8x16_t or2 = vorrq_u8(or1, cmp3);\n\n        uint8x16_t result = vandq_u8(or2, or2);\n\n        if (!vptestq_u8(result, zero)) {\n            return false;\n        }\n    }\n\n    for (size_t i = len - (len % 15); i <= len - 3; ++i) {\n        if (str[i] == str[i + 1] || str[i] == str[i + 2] || str[i + 1] == str[i + 2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s) {\n    if (s.length() < 3) {\n        return false;\n    }\n\n    const char* str = s.c_str();\n    int n = s.length();\n\n    for (int i = 0; i <= n - 16; i += 16) {\n        uint8x16_t vec1 = vld1q_u8(reinterpret_cast<const uint8_t*>(str + i));\n        uint8x16_t vec2 = vld1q_u8(reinterpret_cast<const uint8_t*>(str + i + 1));\n        uint8x16_t vec3 = vld1q_u8(reinterpret_cast<const uint8_t*>(str + i + 2));\n\n        uint8x16_t cmp1 = vceqq_u8(vec1, vec2);\n        uint8x16_t cmp2 = vceqq_u8(vec2, vec3);\n        uint8x16_t cmp3 = vceqq_u8(vec1, vec3);\n\n        uint8x16_t result = vorrq_u8(vorrq_u8(cmp1, cmp2), cmp3);\n\n        if (vmaxvq_u8(result) != 0) {\n            return false;\n        }\n    }\n\n    for (int i = n - (n % 16); i <= n - 3; ++i) {\n        if (str[i] == str[i + 1] || str[i] == str[i + 2] || str[i + 1] == str[i + 2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n#include <string>\n\nbool prime_length_simd(const std::string & str) {\n    int length = str.length();\n    if (length < 2) return false;\n\n    uint8x16_t sieve = vdupq_n_u8(1);\n    sieve = vsetq_lane_u8(0, sieve, 0); // 0 is not prime\n    sieve = vsetq_lane_u8(0, sieve, 1); // 1 is not prime\n\n    for (int i = 2; i <= std::sqrt(length); ++i) {\n        if (vgetq_lane_u8(sieve, i) == 1) {\n            for (int j = i * i; j < 16 && j <= length; j += i) {\n                sieve = vsetq_lane_u8(0, sieve, j);\n            }\n        }\n    }\n\n    if (length < 16) {\n        return vgetq_lane_u8(sieve, length) == 1;\n    } else {\n        // For lengths >= 16, we need to extend the sieve logic\n        // This is a simplified version and does not fully utilize SIMD for large numbers\n        for (int i = 16; i <= std::sqrt(length); ++i) {\n            if (length % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```"}
{"task_id": "SimdBench_102_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <cmath>\n\nbool prime_length_simd(const std::string & str) {\n    int length = str.length();\n    if (length < 2) return false;\n\n    uint8x16_t sieve = vdupq_n_u8(1);\n    sieve = vsetq_lane_u8(0, sieve, 0); // 0 is not prime\n    sieve = vsetq_lane_u8(0, sieve, 1); // 1 is not prime\n\n    for (int i = 2; i <= std::sqrt(length); ++i) {\n        if (vgetq_lane_u8(sieve, i) == 1) {\n            for (int j = i * i; j < 16 && j <= length; j += i) {\n                sieve = vsetq_lane_u8(0, sieve, j);\n            }\n        }\n    }\n\n    if (length < 16) {\n        return vgetq_lane_u8(sieve, length) == 1;\n    } else {\n        // For lengths >= 16, we need to extend the sieve logic\n        // This is a simplified version and does not fully utilize SIMD for large numbers\n        for (int i = 16; i <= std::sqrt(length); ++i) {\n            if (length % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```"}
{"task_id": "SimdBench_102_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <cmath>\n\nbool prime_length_simd(const std::string & str) {\n    int length = str.length();\n    if (length < 2) return false;\n\n    uint8x16_t sieve = vdupq_u8(1);\n    sieve = vsetq_lane_u8(0, sieve, 0); // 0 is not prime\n    sieve = vsetq_lane_u8(0, sieve, 1); // 1 is not prime\n\n    for (int i = 2; i <= std::sqrt(length); ++i) {\n        if (vgetq_lane_u8(sieve, i)) {\n            for (int j = i * i; j < 16 && j <= length; j += i) {\n                sieve = vsetq_lane_u8(0, sieve, j);\n            }\n        }\n    }\n\n    if (length < 16) {\n        return vgetq_lane_u8(sieve, length);\n    }\n\n    for (int i = 16; i <= length; ++i) {\n        bool is_prime = true;\n        for (int j = 2; j <= std::sqrt(i); ++j) {\n            if (i % j == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if (is_prime && i == length) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_102_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n#include <string>\n\nbool prime_length_simd(const std::string & str) {\n    int length = str.length();\n    if (length < 2) return false;\n\n    uint8x16_t sieve = vdupq_n_u8(1);\n    sieve = vsetq_lane_u8(0, sieve, 0); // 0 is not prime\n    sieve = vsetq_lane_u8(0, sieve, 1); // 1 is not prime\n\n    for (int i = 2; i <= std::sqrt(length); ++i) {\n        if (vgetq_lane_u8(sieve, i) == 1) {\n            for (int j = i * i; j < 16 && j <= length; j += i) {\n                sieve = vsetq_lane_u8(0, sieve, j);\n            }\n        }\n    }\n\n    if (length < 16) {\n        return vgetq_lane_u8(sieve, length) == 1;\n    } else {\n        // For lengths >= 16, we need to extend the sieve logic\n        // This is a simplified version and does not fully utilize SIMD for large numbers\n        for (int i = 16; i <= std::sqrt(length); ++i) {\n            if (length % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```"}
{"task_id": "SimdBench_102_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <cmath>\n\nbool prime_length_simd(const std::string & str) {\n    int length = str.length();\n    if (length < 2) return false;\n\n    uint8x16_t sieve = vdupq_u8(1);\n    sieve = vsetq_lane_u8(0, sieve, 0); // 0 is not prime\n    sieve = vsetq_lane_u8(0, sieve, 1); // 1 is not prime\n\n    for (int i = 2; i <= std::sqrt(length); ++i) {\n        if (vgetq_lane_u8(sieve, i) == 1) {\n            for (int j = i * i; j < 16 && j <= length; j += i) {\n                sieve = vsetq_lane_u8(0, sieve, j);\n            }\n        }\n    }\n\n    if (length < 16) {\n        return vgetq_lane_u8(sieve, length) == 1;\n    } else {\n        // For lengths >= 16, we need to extend the sieve logic\n        // This is a simplified version and may not fully utilize SIMD for large numbers\n        for (int i = 16; i <= std::sqrt(length); ++i) {\n            if (length % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```"}
{"task_id": "SimdBench_103_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string solve_simd(uint64_t N) {\n    uint8x16_t ones = vdupq_n_u8(1);\n    uint8x16_t sum = vdupq_n_u8(0);\n    uint8x16_t bits;\n\n    for (int i = 0; i < 8; ++i) {\n        bits = vdupq_n_u8((N >> (i * 16)) & 0xFFFF);\n        sum = vaddq_u8(sum, vandq_u8(bits, ones));\n        bits = vshrq_n_u8(bits, 1);\n        sum = vaddq_u8(sum, vandq_u8(bits, ones));\n        bits = vshrq_n_u8(bits, 1);\n        sum = vaddq_u8(sum, vandq_u8(bits, ones));\n        bits = vshrq_n_u8(bits, 1);\n        sum = vaddq_u8(sum, vandq_u8(bits, ones));\n        bits = vshrq_n_u8(bits, 1);\n        sum = vaddq_u8(sum, vandq_u8(bits, ones));\n        bits = vshrq_n_u8(bits, 1);\n        sum = vaddq_u8(sum, vandq_u8(bits, ones));\n        bits = vshrq_n_u8(bits, 1);\n        sum = vaddq_u8(sum, vandq_u8(bits, ones));\n        bits = vshrq_n_u8(bits, 1);\n        sum = vaddq_u8(sum, vandq_u8(bits, ones));\n    }\n\n    uint32_t total_sum = vaddvq_u8(sum);\n\n    std::string binary;\n    if (total_sum == 0) return \"0\";\n    while (total_sum > 0) {\n        binary = (total_sum % 2 == 0 ? \"0\" : \"1\") + binary;\n        total_sum /= 2;\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string solve_simd(uint64_t N) {\n    uint8x16_t ones = vdupq_n_u8(1);\n    uint8x16_t sum = vdupq_n_u8(0);\n    uint8x16_t bits;\n\n    for (int i = 0; i < 8; ++i) {\n        bits = vdupq_n_u8((N >> (i * 16)) & 0xFFFF);\n        sum = vaddq_u8(sum, vandq_u8(bits, ones));\n        bits = vshrq_n_u8(bits, 1);\n        sum = vaddq_u8(sum, vandq_u8(bits, ones));\n        bits = vshrq_n_u8(bits, 1);\n        sum = vaddq_u8(sum, vandq_u8(bits, ones));\n        bits = vshrq_n_u8(bits, 1);\n        sum = vaddq_u8(sum, vandq_u8(bits, ones));\n        bits = vshrq_n_u8(bits, 1);\n        sum = vaddq_u8(sum, vandq_u8(bits, ones));\n        bits = vshrq_n_u8(bits, 1);\n        sum = vaddq_u8(sum, vandq_u8(bits, ones));\n        bits = vshrq_n_u8(bits, 1);\n        sum = vaddq_u8(sum, vandq_u8(bits, ones));\n        bits = vshrq_n_u8(bits, 1);\n        sum = vaddq_u8(sum, vandq_u8(bits, ones));\n    }\n\n    uint32_t total_sum = vaddvq_u8(sum);\n\n    std::string binary;\n    if (total_sum == 0) return \"0\";\n    while (total_sum > 0) {\n        binary = (total_sum % 2 == 0 ? \"0\" : \"1\") + binary;\n        total_sum /= 2;\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string solve_simd(uint64_t N) {\n    uint8x16_t ones = vdupq_n_u8(1);\n    uint8x16_t sum = vdupq_n_u8(0);\n    uint8x16_t bits;\n\n    for (int i = 0; i < 8; ++i) {\n        bits = vdupq_n_u8((N >> (i * 16)) & 0xFFFF);\n        sum = vaddq_u8(sum, vandq_u8(bits, ones));\n        bits = vshrq_n_u8(bits, 1);\n        sum = vaddq_u8(sum, vandq_u8(bits, ones));\n        bits = vshrq_n_u8(bits, 1);\n        sum = vaddq_u8(sum, vandq_u8(bits, ones));\n        bits = vshrq_n_u8(bits, 1);\n        sum = vaddq_u8(sum, vandq_u8(bits, ones));\n        bits = vshrq_n_u8(bits, 1);\n        sum = vaddq_u8(sum, vandq_u8(bits, ones));\n        bits = vshrq_n_u8(bits, 1);\n        sum = vaddq_u8(sum, vandq_u8(bits, ones));\n        bits = vshrq_n_u8(bits, 1);\n        sum = vaddq_u8(sum, vandq_u8(bits, ones));\n        bits = vshrq_n_u8(bits, 1);\n        sum = vaddq_u8(sum, vandq_u8(bits, ones));\n    }\n\n    uint32_t total_sum = vaddvq_u8(sum);\n\n    std::string binary;\n    if (total_sum == 0) return \"0\";\n    while (total_sum > 0) {\n        binary = (total_sum % 2 == 0 ? \"0\" : \"1\") + binary;\n        total_sum /= 2;\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string solve_simd(uint64_t N) {\n    uint8x16_t ones = vdupq_n_u8(1);\n    uint8x16_t sum = vdupq_n_u8(0);\n    uint8x16_t bits;\n\n    for (int i = 0; i < 8; ++i) {\n        bits = vdupq_n_u8((N >> (i * 16)) & 0xFFFF);\n        sum = vaddq_u8(sum, vandq_u8(bits, ones));\n        bits = vshrq_n_u8(bits, 1);\n        sum = vaddq_u8(sum, vandq_u8(bits, ones));\n        bits = vshrq_n_u8(bits, 1);\n        sum = vaddq_u8(sum, vandq_u8(bits, ones));\n        bits = vshrq_n_u8(bits, 1);\n        sum = vaddq_u8(sum, vandq_u8(bits, ones));\n        bits = vshrq_n_u8(bits, 1);\n        sum = vaddq_u8(sum, vandq_u8(bits, ones));\n        bits = vshrq_n_u8(bits, 1);\n        sum = vaddq_u8(sum, vandq_u8(bits, ones));\n        bits = vshrq_n_u8(bits, 1);\n        sum = vaddq_u8(sum, vandq_u8(bits, ones));\n        bits = vshrq_n_u8(bits, 1);\n        sum = vaddq_u8(sum, vandq_u8(bits, ones));\n    }\n\n    uint32_t total_sum = vaddvq_u8(sum);\n\n    std::string binary;\n    if (total_sum == 0) return \"0\";\n    while (total_sum > 0) {\n        binary = (total_sum % 2 == 0 ? \"0\" : \"1\") + binary;\n        total_sum /= 2;\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string solve_simd(uint64_t N) {\n    uint8x16_t ones = vdupq_n_u8(1);\n    uint8x16_t sum = vdupq_n_u8(0);\n    uint8x16_t bits;\n\n    for (int i = 0; i < 8; ++i) {\n        bits = vdupq_n_u8((N >> (i * 16)) & 0xFFFF);\n        sum = vaddq_u8(sum, vandq_u8(bits, ones));\n        bits = vshrq_n_u8(bits, 1);\n        sum = vaddq_u8(sum, vandq_u8(bits, ones));\n        bits = vshrq_n_u8(bits, 1);\n        sum = vaddq_u8(sum, vandq_u8(bits, ones));\n        bits = vshrq_n_u8(bits, 1);\n        sum = vaddq_u8(sum, vandq_u8(bits, ones));\n        bits = vshrq_n_u8(bits, 1);\n        sum = vaddq_u8(sum, vandq_u8(bits, ones));\n        bits = vshrq_n_u8(bits, 1);\n        sum = vaddq_u8(sum, vandq_u8(bits, ones));\n        bits = vshrq_n_u8(bits, 1);\n        sum = vaddq_u8(sum, vandq_u8(bits, ones));\n        bits = vshrq_n_u8(bits, 1);\n        sum = vaddq_u8(sum, vandq_u8(bits, ones));\n    }\n\n    uint32_t total_sum = vaddvq_u8(sum);\n\n    std::string binary;\n    if (total_sum == 0) return \"0\";\n    while (total_sum > 0) {\n        binary = (total_sum % 2 == 0 ? \"0\" : \"1\") + binary;\n        total_sum /= 2;\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_104_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst){\n    int sum = 0;\n    int n = lst.size();\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    \n    for(int i = 1; i < n; i += 8){\n        int32x4_t vec1 = vld1q_s32(&lst[i]);\n        int32x4_t vec2 = vld1q_s32(&lst[i+4]);\n        \n        uint32x4_t mask1 = vceqq_s32(vandq_s32(vec1, vdupq_n_s32(1)), vdupq_n_s32(0));\n        uint32x4_t mask2 = vceqq_s32(vandq_s32(vec2, vdupq_n_s32(1)), vdupq_n_s32(0));\n        \n        vec1 = vandq_s32(vec1, mask1);\n        vec2 = vandq_s32(vec2, mask2);\n        \n        sum_vec = vaddq_s32(sum_vec, vec1);\n        sum_vec = vaddq_s32(sum_vec, vec2);\n    }\n    \n    int32x2_t sum_pair = vadd_s32(vget_low_s32(sum_vec), vget_high_s32(sum_vec));\n    sum = vget_lane_s32(vpadd_s32(sum_pair, sum_pair), 0);\n    \n    for(int i = (n/8)*8 + 1; i < n; i += 2){\n        if(lst[i] % 2 == 0){\n            sum += lst[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst){\n    int sum = 0;\n    int n = lst.size();\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    \n    for(int i = 1; i < n; i += 8){\n        int32x4_t vec1 = vld1q_s32(&lst[i]);\n        int32x4_t vec2 = vld1q_s32(&lst[i+4]);\n        \n        uint32x4_t mask1 = vceqq_s32(vandq_s32(vec1, vdupq_n_s32(1)), vdupq_n_s32(0));\n        uint32x4_t mask2 = vceqq_s32(vandq_s32(vec2, vdupq_n_s32(1)), vdupq_n_s32(0));\n        \n        int32x4_t even_vec1 = vandq_s32(vec1,vreinterpretq_s32_u32(mask1));\n        int32x4_t even_vec2 = vandq_s32(vec2,vreinterpretq_s32_u32(mask2));\n        \n        sum_vec = vaddq_s32(sum_vec, even_vec1);\n        sum_vec = vaddq_s32(sum_vec, even_vec2);\n    }\n    \n    int32x2_t sum_pair = vadd_s32(vget_low_s32(sum_vec), vget_high_s32(sum_vec));\n    sum = vget_lane_s32(vpadd_s32(sum_pair, sum_pair), 0);\n    \n    for(int i = (n/8)*8 + 1; i < n; i += 2){\n        if(lst[i] % 2 == 0){\n            sum += lst[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int sum = 0;\n    int n = lst.size();\n    int* data = lst.data();\n\n    // Process 8 elements at a time\n    for (int i = 1; i + 7 < n; i += 8) {\n        int32x4_t vec1 = vld1q_s32(data + i);\n        int32x4_t vec2 = vld1q_s32(data + i + 4);\n\n        // Create a mask for even numbers\n        uint32x4_t mask1 = vceqq_s32(vandq_s32(vec1, vdupq_n_s32(1)), vdupq_n_s32(0));\n        uint32x4_t mask2 = vceqq_s32(vandq_s32(vec2, vdupq_n_s32(1)), vdupq_n_s32(0));\n\n        // Zero out odd numbers\n        vec1 = vbslq_s32(mask1, vec1, vdupq_n_s32(0));\n        vec2 = vbslq_s32(mask2, vec2, vdupq_n_s32(0));\n\n        // Sum the vectors\n        int32x4_t sum_vec = vaddq_s32(vec1, vec2);\n\n        // Reduce to scalar\n        sum += vgetq_lane_s32(sum_vec, 0) + vgetq_lane_s32(sum_vec, 1) +\n               vgetq_lane_s32(sum_vec, 2) + vgetq_lane_s32(sum_vec, 3);\n    }\n\n    // Handle remaining elements\n    for (int i = (n / 8) * 8; i < n; i += 2) {\n        if (i % 2 != 0 && data[i] % 2 == 0) {\n            sum += data[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int sum = 0;\n    int n = lst.size();\n    int* data = lst.data();\n\n    // Process 8 elements at a time\n    for (int i = 1; i + 7 < n; i += 8) {\n        int32x4_t vec1 = vld1q_s32(data + i);\n        int32x4_t vec2 = vld1q_s32(data + i + 4);\n\n        // Create a mask for even numbers\n        uint32x4_t mask1 = vceqq_s32(vandq_s32(vec1, vdupq_n_s32(1)), vdupq_n_s32(0));\n        uint32x4_t mask2 = vceqq_s32(vandq_s32(vec2, vdupq_n_s32(1)), vdupq_n_s32(0));\n\n        // Zero out odd numbers\n        vec1 = vandq_s32(vec1, mask1);\n        vec2 = vandq_s32(vec2, mask2);\n\n        // Sum the vectors\n        int32x4_t sum_vec = vaddq_s32(vec1, vec2);\n\n        // Horizontal add\n        int32x2_t sum_pair = vpadd_s32(vget_low_s32(sum_vec), vget_high_s32(sum_vec));\n        sum += vget_lane_s32(vpaddl_s32(sum_pair), 0);\n    }\n\n    // Handle remaining elements\n    for (int i = 1; i < n; i += 2) {\n        if ((data[i] & 1) == 0) {\n            sum += data[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int sum = 0;\n    int n = lst.size();\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    int i;\n\n    for (i = 1; i < n - 3; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        uint32x4_t mask = vandq_u32(vceqq_s32(vandq_s32(vreinterpretq_u32_s32(vec), vdupq_n_u32(1)), vdupq_n_u32(0)), veorq_u32(vdupq_n_u32(0xFFFFFFFF), vcgeq_s32(vreinterpretq_s32_u32(vec), vdupq_n_s32(0))));\n        int32x4_t even_elements = vandq_s32(vec,vreinterpretq_s32_u32(mask));\n        sum_vec = vaddq_s32(sum_vec, even_elements);\n    }\n\n    int32x2_t sum_pair = vadd_s32(vget_low_s32(sum_vec), vget_high_s32(sum_vec));\n    sum = vget_lane_s32(vpadd_s32(sum_pair, sum_pair), 0);\n\n    for (; i < n; i += 2) {\n        if (i % 2 != 0 && lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_105_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    std::string result(s.size(), ' ');\n    const int8_t shift = 4; // 2 * 2 = 4\n    const uint8x16_t shift_vec = vdupq_n_u8(shift);\n    const uint8x16_t a_vec = vdupq_n_u8('a');\n    const uint8x16_t z_vec = vdupq_n_u8('z');\n\n    size_t i = 0;\n    for (; i <= s.size() - 16; i += 16) {\n        uint8x16_t input_vec = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        uint8x16_t shifted_vec = vaddq_u8(input_vec, shift_vec);\n        uint8x16_t wrapped_vec = vsubq_u8(vaddq_u8(shifted_vec, vandq_u8(vcgtq_u8(shifted_vec, z_vec), vsubq_u8(a_vec, vdupq_n_u8(1)))), a_vec);\n        vst1q_u8(reinterpret_cast<uint8_t*>(result.data() + i), wrapped_vec);\n    }\n\n    for (; i < s.size(); ++i) {\n        char c = s[i];\n        c = (c - 'a' + shift) % 26 + 'a';\n        result[i] = c;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    std::string result(s.size(), ' ');\n    const int8_t shift = 4; // 2 * 2 = 4\n    uint8x16_t shift_vec = vdupq_n_u8(shift);\n    uint8x16_t wrap_vec = vdupq_n_u8('z' - 'a' + 1);\n\n    for (size_t i = 0; i < s.size(); i += 16) {\n        size_t len = std::min<size_t>(16, s.size() - i);\n        uint8x16_t input_vec = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        uint8x16_t lower_a = vdupq_n_u8('a');\n        uint8x16_t lower_z = vdupq_n_u8('z');\n\n        // Check if characters are lowercase letters\n        uint8x16_t mask = vandq_u8(vcleq_u8(input_vec, lower_z), vcgeq_u8(input_vec, lower_a));\n\n        // Shift characters\n        uint8x16_t shifted_vec = vaddq_u8(input_vec, shift_vec);\n\n        // Wrap around if necessary\n        uint8x16_t wrapped_vec = vsubq_u8(shifted_vec, wrap_vec);\n        uint8x16_t final_vec = vbslq_u8(mask, vbslq_u8(vcltq_u8(shifted_vec, lower_a), wrapped_vec, shifted_vec), input_vec);\n\n        vst1q_u8(reinterpret_cast<uint8_t*>(result.data() + i), final_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    std::string result(s.size(), ' ');\n    const int8_t shift = 4; // Shift each letter by 4 positions\n\n    size_t i = 0;\n    for (; i <= s.size() - 16; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        uint8x16_t shifted = vaddq_u8(input, vdupq_n_u8(shift));\n        \n        // Handle wrap-around for lowercase letters\n        uint8x16_t wrap_mask = vcgtq_u8(shifted, vdupq_n_u8('z'));\n        uint8x16_t wrapped = vsubq_u8(shifted, vdupq_n_u8(26));\n        uint8x16_t output = vbslq_u8(wrap_mask, wrapped, shifted);\n\n        vst1q_u8(reinterpret_cast<uint8_t*>(result.data() + i), output);\n    }\n\n    // Handle remaining characters\n    for (; i < s.size(); ++i) {\n        char c = s[i];\n        c += shift;\n        if (c > 'z') {\n            c -= 26;\n        }\n        result[i] = c;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s){\n    std::string result(s.size(), ' ');\n    int n = s.size();\n    int i = 0;\n\n    // Process 16 characters at a time\n    for (; i <= n - 16; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        uint8x16_t shift = vdupq_n_u8(4); // Shift by 4 positions\n        uint8x16_t a = vdupq_n_u8('a');\n        uint8x16_t z = vdupq_n_u8('z');\n\n        // Subtract 'a' to get 0-based index\n        uint8x16_t indexed = vsubq_u8(input, a);\n\n        // Add shift and modulo 26\n        uint8x16_t shifted = vaddq_u8(indexed, shift);\n        uint8x16_t wrapped = vsubq_u8(vmodq_u8(shifted, vdupq_n_u8(26)), vdupq_n_u8(-'a'));\n\n        // Handle wrap-around for lowercase letters\n        uint8x16_t wrapped_around = vaddq_u8(wrapped, a);\n        uint8x16_t masked = vbslq_u8(vcgeq_u8(input, a), wrapped_around, input);\n\n        vst1q_u8(reinterpret_cast<uint8_t*>(result.data() + i), masked);\n    }\n\n    // Process remaining characters\n    for (; i < n; ++i) {\n        char c = s[i];\n        if (c >= 'a' && c <= 'z') {\n            c = ((c - 'a' + 4) % 26) + 'a';\n        }\n        result[i] = c;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    std::string result(s.size(), ' ');\n    const int8_t shift = 4; // 2 * 2 = 4\n    uint8x16_t shift_vec = vdupq_n_u8(shift);\n    uint8x16_t wrap_vec = vdupq_n_u8('z' - 'a' + 1);\n\n    for (size_t i = 0; i < s.size(); i += 16) {\n        uint8x16_t input_vec = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        uint8x16_t shifted_vec = vaddq_u8(input_vec, shift_vec);\n        uint8x16_t wrapped_vec = vsubq_u8(shifted_vec, wrap_vec);\n        uint8x16_t masked_vec = vbslq_u8(vcgtq_u8(shifted_vec, vdupq_n_u8('z')), wrapped_vec, shifted_vec);\n        vst1q_u8(reinterpret_cast<uint8_t*>(result.data() + i), masked_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message) {\n    const int len = message.size();\n    std::string result(len, ' ');\n\n    for (int i = 0; i <= len - 16; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(message.data() + i));\n\n        // Swap case\n        uint8x16_t case_swapped = veorq_u8(input, vdupq_n_u8(0x20));\n\n        // Define vowels and their replacements\n        uint8x16_t vowels_lower = vmovq_n_u8('a');\n        uint8x16_t vowels_upper = vmovq_n_u8('A');\n        uint8x16_t replacements_lower = vmovq_n_u8('c');\n        uint8x16_t replacements_upper = vmovq_n_u8('C');\n\n        for (int j = 1; j < 5; ++j) {\n            vowels_lower = vsetq_lane_u8(vowels_lower[j] + 2, vowels_lower, j);\n            vowels_upper = vsetq_lane_u8(vowels_upper[j] + 2, vowels_upper, j);\n            replacements_lower = vsetq_lane_u8(replacements_lower[j] + 2, replacements_lower, j);\n            replacements_upper = vsetq_lane_u8(replacements_upper[j] + 2, replacements_upper, j);\n        }\n\n        // Check for lowercase vowels and replace\n        uint8x16_t mask_lower = vceqq_u8(case_swapped, vowels_lower);\n        case_swapped = vbslq_u8(mask_lower, replacements_lower, case_swapped);\n\n        // Check for uppercase vowels and replace\n        uint8x16_t mask_upper = vceqq_u8(case_swapped, vowels_upper);\n        case_swapped = vbslq_u8(mask_upper, replacements_upper, case_swapped);\n\n        vst1q_u8(reinterpret_cast<uint8_t*>(result.data() + i), case_swapped);\n    }\n\n    // Handle remaining characters\n    for (int i = (len / 16) * 16; i < len; ++i) {\n        char c = message[i];\n        if (c >= 'a' && c <= 'z') {\n            c = c - 'a' + 'A';\n        } else if (c >= 'A' && c <= 'Z') {\n            c = c - 'A' + 'a';\n        }\n        switch (c) {\n            case 'a': c = 'C'; break;\n            case 'e': c = 'G'; break;\n            case 'i': c = 'K'; break;\n            case 'o': c = 'Q'; break;\n            case 'u': c = 'W'; break;\n            case 'A': c = 'C'; break;\n            case 'E': c = 'G'; break;\n            case 'I': c = 'K'; break;\n            case 'O': c = 'Q'; break;\n            case 'U': c = 'W'; break;\n        }\n        result[i] = c;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message) {\n    const int len = message.size();\n    std::string result(len, ' ');\n\n    for (int i = 0; i <= len - 16; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(message.data() + i));\n\n        // Swap case\n        uint8x16_t case_swapped = veorq_u8(input, vdupq_n_u8(0x20));\n\n        // Define vowels and their replacements\n        uint8x16_t vowels_lower = vmovq_n_u8('a');\n        uint8x16_t vowels_upper = vmovq_n_u8('A');\n        uint8x16_t replacements_lower = vmovq_n_u8('c');\n        uint8x16_t replacements_upper = vmovq_n_u8('C');\n\n        // Check for lowercase vowels\n        uint8x16_t is_vowel_lower = vceqq_u8(case_swapped, vowels_lower);\n        uint8x16_t is_vowel_lower_e = vceqq_u8(case_swapped, vmovq_n_u8('e'));\n        uint8x16_t is_vowel_lower_i = vceqq_u8(case_swapped, vmovq_n_u8('i'));\n        uint8x16_t is_vowel_lower_o = vceqq_u8(case_swapped, vmovq_n_u8('o'));\n        uint8x16_t is_vowel_lower_u = vceqq_u8(case_swapped, vmovq_n_u8('u'));\n\n        // Check for uppercase vowels\n        uint8x16_t is_vowel_upper = vceqq_u8(case_swapped, vowels_upper);\n        uint8x16_t is_vowel_upper_e = vceqq_u8(case_swapped, vmovq_n_u8('E'));\n        uint8x16_t is_vowel_upper_i = vceqq_u8(case_swapped, vmovq_n_u8('I'));\n        uint8x16_t is_vowel_upper_o = vceqq_u8(case_swapped, vmovq_n_u8('O'));\n        uint8x16_t is_vowel_upper_u = vceqq_u8(case_swapped, vmovq_n_u8('U'));\n\n        // Combine vowel checks\n        uint8x16_t is_vowel_lower_any = vorrq_u8(is_vowel_lower, vorrq_u8(is_vowel_lower_e, vorrq_u8(is_vowel_lower_i, vorrq_u8(is_vowel_lower_o, is_vowel_lower_u))));\n        uint8x16_t is_vowel_upper_any = vorrq_u8(is_vowel_upper, vorrq_u8(is_vowel_upper_e, vorrq_u8(is_vowel_upper_i, vorrq_u8(is_vowel_upper_o, is_vowel_upper_u))));\n\n        // Replace vowels\n        uint8x16_t replaced_lower = vbslq_u8(is_vowel_lower_any, replacements_lower, case_swapped);\n        uint8x16_t replaced_upper = vbslq_u8(is_vowel_upper_any, replacements_upper, replaced_lower);\n\n        // Store result\n        vst1q_u8(reinterpret_cast<uint8_t*>(result.data() + i), replaced_upper);\n    }\n\n    // Handle remaining characters\n    for (int i = (len / 16) * 16; i < len; ++i) {\n        char c = message[i];\n        if (c >= 'a' && c <= 'z') {\n            c = c - 'a' + 'A';\n        } else if (c >= 'A' && c <= 'Z') {\n            c = c - 'A' + 'a';\n        }\n        switch (c) {\n            case 'a': c = 'C'; break;\n            case 'e': c = 'G'; break;\n            case 'i': c = 'K'; break;\n            case 'o': c = 'Q'; break;\n            case 'u': c = 'W'; break;\n            case 'A': c = 'c'; break;\n            case 'E': c = 'g'; break;\n            case 'I': c = 'k'; break;\n            case 'O': c = 'q'; break;\n            case 'U': c = 'w'; break;\n        }\n        result[i] = c;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message) {\n    const int len = message.size();\n    std::string result(len, ' ');\n\n    uint8_t *input = reinterpret_cast<uint8_t*>(const_cast<char*>(message.c_str()));\n    uint8_t *output = reinterpret_cast<uint8_t*>(&result[0]);\n\n    for (int i = 0; i <= len - 16; i += 16) {\n        uint8x16_t vec = vld1q_u8(input + i);\n\n        // Swap case\n        uint8x16_t lower_mask = vcgeq_u8(vec, vdupq_n_u8('a'));\n        uint8x16_t upper_mask = vcltq_u8(vec, vdupq_n_u8('a'));\n        uint8x16_t swapped_case = veorq_u8(vec, vandq_u8(vdupq_n_u8(0x20), vorrq_u8(lower_mask, upper_mask)));\n\n        // Replace vowels\n        uint8x16_t is_a = vceqq_u8(swapped_case, vdupq_n_u8('a'));\n        uint8x16_t is_e = vceqq_u8(swapped_case, vdupq_n_u8('e'));\n        uint8x16_t is_i = vceqq_u8(swapped_case, vdupq_n_u8('i'));\n        uint8x16_t is_o = vceqq_u8(swapped_case, vdupq_n_u8('o'));\n        uint8x16_t is_u = vceqq_u8(swapped_case, vdupq_n_u8('u'));\n        uint8x16_t is_A = vceqq_u8(swapped_case, vdupq_n_u8('A'));\n        uint8x16_t is_E = vceqq_u8(swapped_case, vdupq_n_u8('E'));\n        uint8x16_t is_I = vceqq_u8(swapped_case, vdupq_n_u8('I'));\n        uint8x16_t is_O = vceqq_u8(swapped_case, vdupq_n_u8('O'));\n        uint8x16_t is_U = vceqq_u8(swapped_case, vdupq_n_u8('U'));\n\n        uint8x16_t replace_mask = vorrq_u8(vorrq_u8(vorrq_u8(vorrq_u8(is_a, is_e), vorrq_u8(is_i, is_o)), is_u),\n                                           vorrq_u8(vorrq_u8(vorrq_u8(vorrq_u8(is_A, is_E), vorrq_u8(is_I, is_O)), is_U));\n\n        uint8x16_t replaced_vowels = vbslq_u8(replace_mask, vaddq_u8(swapped_case, vdupq_n_u8(2)), swapped_case);\n\n        vst1q_u8(output + i, replaced_vowels);\n    }\n\n    // Handle remaining characters\n    for (int i = (len / 16) * 16; i < len; ++i) {\n        char c = message[i];\n        if (c >= 'a' && c <= 'z') {\n            c -= 32;\n        } else if (c >= 'A' && c <= 'Z') {\n            c += 32;\n        }\n        switch (c) {\n            case 'a': c = 'c'; break;\n            case 'e': c = 'g'; break;\n            case 'i': c = 'k'; break;\n            case 'o': c = 'q'; break;\n            case 'u': c = 'w'; break;\n            case 'A': c = 'C'; break;\n            case 'E': c = 'G'; break;\n            case 'I': c = 'K'; break;\n            case 'O': c = 'Q'; break;\n            case 'U': c = 'W'; break;\n        }\n        result[i] = c;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message){\n    const int len = message.size();\n    std::string result(len, ' ');\n\n    for (int i = 0; i <= len - 16; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(message.c_str() + i));\n        uint8x16_t lower_case = vandq_u8(input, vdupq_n_u8(~0x20));\n        uint8x16_t vowels = vornq_u8(vceqq_u8(lower_case, vdupq_n_u8('a')),\n                                     vornq_u8(vceqq_u8(lower_case, vdupq_n_u8('e')),\n                                              vornq_u8(vceqq_u8(lower_case, vdupq_n_u8('i')),\n                                                       vornq_u8(vceqq_u8(lower_case, vdupq_n_u8('o')),\n                                                                vceqq_u8(lower_case, vdupq_n_u8('u'))))));\n\n        uint8x16_t shifted_vowels = vaddq_u8(vandq_u8(vowels, lower_case), vdupq_n_u8(2));\n        uint8x16_t unchanged = vandq_u8(vmvnq_u8(vowels), input);\n        uint8x16_t encoded = vorrq_u8(shifted_vowels, unchanged);\n\n        uint8x16_t swapped_case = veorq_u8(encoded, vdupq_n_u8(0x20));\n        vst1q_u8(reinterpret_cast<uint8_t*>(result.data() + i), swapped_case);\n    }\n\n    // Handle remaining characters\n    for (int i = (len / 16) * 16; i < len; ++i) {\n        char c = message[i];\n        if (c >= 'a' && c <= 'z') {\n            c -= 32;\n            if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n                c += 2;\n            }\n        } else if (c >= 'A' && c <= 'Z') {\n            c += 32;\n            if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n                c += 2;\n            }\n        }\n        result[i] = c;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message){\n    const int len = message.size();\n    std::string result(len, ' ');\n\n    for (int i = 0; i <= len - 16; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(message.data() + i));\n        uint8x16_t lower_case = vandq_u8(input, vdupq_n_u8(~0x20));\n        uint8x16_t vowels = vornq_u8(vceqq_u8(lower_case, vdupq_n_u8('a')),\n                                     vornq_u8(vceqq_u8(lower_case, vdupq_n_u8('e')),\n                                              vornq_u8(vceqq_u8(lower_case, vdupq_n_u8('i')),\n                                                       vornq_u8(vceqq_u8(lower_case, vdupq_n_u8('o')),\n                                                                vceqq_u8(lower_case, vdupq_n_u8('u'))))));\n\n        uint8x16_t shifted_vowels = vaddq_u8(lower_case, vdupq_n_u8(2));\n        uint8x16_t replaced_vowels = vbslq_u8(vowels, shifted_vowels, lower_case);\n\n        uint8x16_t swapped_case = veorq_u8(replaced_vowels, vdupq_n_u8(0x20));\n        vst1q_u8(reinterpret_cast<uint8_t*>(result.data() + i), swapped_case);\n    }\n\n    // Handle remaining characters\n    for (int i = (len / 16) * 16; i < len; ++i) {\n        char c = message[i];\n        if (c >= 'a' && c <= 'z') {\n            c -= 32;\n            if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n                c += 2;\n            }\n        } else if (c >= 'A' && c <= 'Z') {\n            c += 32;\n            if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n                c += 2;\n            }\n        }\n        result[i] = c;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_107_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <map>\n#include <string>\n#include <cstring>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        size_t len = key.length();\n\n        if (len == 0) {\n            continue;\n        }\n\n        size_t i = 0;\n        uint8x16_t vec_all_lower = vdupq_u8(0xff);\n        uint8x16_t vec_all_upper = vdupq_u8(0xff);\n\n        for (; i <= len - 16; i += 16) {\n            uint8x16_t vec = vld1q_u8(reinterpret_cast<const uint8_t*>(key.c_str() + i));\n            uint8x16_t vec_lower = vandq_u8(vec, vdupq_u8(0xdf));\n            uint8x16_t vec_upper = vandq_u8(vec, vdupq_u8(0xdf));\n\n            vec_all_lower = vandq_u8(vec_all_lower, vceqq_u8(vec, vec_lower));\n            vec_all_upper = vandq_u8(vec_all_upper, vceqq_u8(vec, vec_upper));\n        }\n\n        all_lower &= vget_lane_u32(vreinterpretq_u32_u8(vec_all_lower), 0) == 0xffffffff;\n        all_upper &= vget_lane_u32(vreinterpretq_u32_u8(vec_all_upper), 0) == 0xffffffff;\n\n        for (; i < len; ++i) {\n            char c = key[i];\n            if (c >= 'a' && c <= 'z') {\n                all_upper = false;\n            } else if (c >= 'A' && c <= 'Z') {\n                all_lower = false;\n            } else {\n                all_lower = false;\n                all_upper = false;\n            }\n        }\n\n        if (!all_lower && !all_upper) {\n            return false;\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <map>\n#include <string>\n#include <cstring>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        size_t len = key.length();\n\n        if (len == 0) {\n            continue;\n        }\n\n        size_t i = 0;\n        for (; i <= len - 16; i += 16) {\n            uint8x16_t str_vec = vld1q_u8(reinterpret_cast<const uint8_t*>(key.c_str() + i));\n            uint8x16_t lower_mask = vcgeq_u8(str_vec, vdupq_n_u8('a'));\n            uint8x16_t upper_mask = vcleq_u8(str_vec, vdupq_n_u8('z'));\n            uint8x16_t upper_check = vcgeq_u8(str_vec, vdupq_n_u8('A'));\n            uint8x16_t lower_check = vcleq_u8(str_vec, vdupq_n_u8('Z'));\n\n            uint8x16_t lower_result = vandq_u8(lower_mask, upper_mask);\n            uint8x16_t upper_result = vandq_u8(upper_check, lower_check);\n\n            if (!vgetq_lane_u32(vceqq_u8(lower_result, vdupq_n_u8(0)), 0)) {\n                all_upper = false;\n            }\n            if (!vgetq_lane_u32(vceqq_u8(upper_result, vdupq_n_u8(0)), 0)) {\n                all_lower = false;\n            }\n        }\n\n        for (; i < len; ++i) {\n            char c = key[i];\n            if (c >= 'a' && c <= 'z') {\n                all_upper = false;\n            } else if (c >= 'A' && c <= 'Z') {\n                all_lower = false;\n            } else {\n                all_lower = false;\n                all_upper = false;\n            }\n        }\n\n        if (!all_lower && !all_upper) {\n            return false;\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <map>\n#include <string>\n#include <cstring>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        size_t len = key.length();\n\n        if (len == 0) {\n            continue;\n        }\n\n        size_t i = 0;\n        uint8x16_t vec_all_lower = vdupq_u8(0xff);\n        uint8x16_t vec_all_upper = vdupq_u8(0xff);\n\n        for (; i <= len - 16; i += 16) {\n            uint8x16_t vec = vld1q_u8(reinterpret_cast<const uint8_t*>(key.c_str() + i));\n            uint8x16_t vec_lower = vcltq_u8(vec, vdupq_u8('a')) | vcgeq_u8(vec, vdupq_u8('z'));\n            uint8x16_t vec_upper = vcltq_u8(vec, vdupq_u8('A')) | vcgeq_u8(vec, vdupq_u8('Z'));\n\n            vec_all_lower = vandq_u8(vec_all_lower, vec_lower);\n            vec_all_upper = vandq_u8(vec_all_upper, vec_upper);\n        }\n\n        if (vmaxvq_u8(vec_all_lower) != 0xff) {\n            all_lower = false;\n        }\n        if (vmaxvq_u8(vec_all_upper) != 0xff) {\n            all_upper = false;\n        }\n\n        for (; i < len; ++i) {\n            char c = key[i];\n            if (c < 'a' || c > 'z') {\n                all_lower = false;\n            }\n            if (c < 'A' || c > 'Z') {\n                all_upper = false;\n            }\n        }\n\n        if (!all_lower && !all_upper) {\n            return false;\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <map>\n#include <string>\n#include <cstring>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        size_t len = key.size();\n\n        if (len == 0) {\n            continue;\n        }\n\n        size_t i = 0;\n        uint8x16_t vec_all_lower = vdupq_u8(0xff);\n        uint8x16_t vec_all_upper = vdupq_u8(0xff);\n\n        for (; i <= len - 16; i += 16) {\n            uint8x16_t vec = vld1q_u8(reinterpret_cast<const uint8_t*>(key.c_str() + i));\n            uint8x16_t vec_lower = vandq_u8(vec, vdupq_u8(0xdf));\n            uint8x16_t vec_upper = vandq_u8(vec, vdupq_u8(0xdf));\n\n            vec_all_lower = vandq_u8(vec_all_lower, veorq_u8(vec_lower, vdupq_u8('a')));\n            vec_all_upper = vandq_u8(vec_all_upper, veorq_u8(vec_upper, vdupq_u8('A')));\n\n            if (vmovemaskq_u8(vec_all_lower) != 0xffff) {\n                all_lower = false;\n            }\n            if (vmovemaskq_u8(vec_all_upper) != 0xffff) {\n                all_upper = false;\n            }\n        }\n\n        for (; i < len; ++i) {\n            char c = key[i];\n            if (c >= 'a' && c <= 'z') {\n                all_upper = false;\n            } else if (c >= 'A' && c <= 'Z') {\n                all_lower = false;\n            } else {\n                all_lower = false;\n                all_upper = false;\n            }\n        }\n\n        if (!all_lower && !all_upper) {\n            return false;\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <map>\n#include <string>\n#include <cstring>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        size_t len = key.length();\n\n        if (len == 0) {\n            continue;\n        }\n\n        size_t i = 0;\n        for (; i <= len - 16; i += 16) {\n            uint8x16_t str_vec = vld1q_u8(reinterpret_cast<const uint8_t*>(key.c_str() + i));\n            uint8x16_t lower_mask = vcgeq_u8(str_vec, vdupq_n_u8('a'));\n            uint8x16_t upper_mask = vcleq_u8(str_vec, vdupq_n_u8('z'));\n            uint8x16_t upper_check = vcgeq_u8(str_vec, vdupq_n_u8('A'));\n            uint8x16_t lower_check = vcleq_u8(str_vec, vdupq_n_u8('Z'));\n\n            uint8x16_t lower_result = vandq_u8(lower_mask, upper_mask);\n            uint8x16_t upper_result = vandq_u8(upper_check, lower_check);\n\n            if (!vgetq_lane_u32(vceqq_u8(lower_result, vdupq_n_u8(0)), 0)) {\n                all_upper = false;\n            }\n            if (!vgetq_lane_u32(vceqq_u8(upper_result, vdupq_n_u8(0)), 0)) {\n                all_lower = false;\n            }\n        }\n\n        for (; i < len; ++i) {\n            char c = key[i];\n            if (c >= 'a' && c <= 'z') {\n                all_upper = false;\n            } else if (c >= 'A' && c <= 'Z') {\n                all_lower = false;\n            } else {\n                all_lower = false;\n                all_upper = false;\n            }\n        }\n\n        if (!all_lower && !all_upper) {\n            return false;\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_108_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n\n    std::vector<uint8_t> is_prime(n, 1);\n    is_prime[0] = is_prime[1] = 0;\n\n    for (int i = 2; i <= std::sqrt(n); ++i) {\n        if (is_prime[i]) {\n            int j = i * i;\n            while (j < n) {\n                int k = j;\n                uint8x16_t vzero = vdupq_n_u8(0);\n                for (; k <= n - 16; k += 16) {\n                    vst1q_u8(&is_prime[k], vzero);\n                }\n                for (; k < n; ++k) {\n                    is_prime[k] = 0;\n                }\n                j += i;\n            }\n        }\n    }\n\n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n\n    std::vector<uint8_t> is_prime(n, 1);\n    is_prime[0] = is_prime[1] = 0;\n\n    for (int i = 2; i <= std::sqrt(n); ++i) {\n        if (is_prime[i]) {\n            for (int j = i * i; j < n; j += i) {\n                is_prime[j] = 0;\n            }\n        }\n    }\n\n    for (int i = 2; i < n; ) {\n        uint8x16_t prime_chunk = vld1q_u8(&is_prime[i]);\n        uint32x4_t indices = vcreate_u32(((uint64_t)(i + 15) << 32) | ((uint64_t)(i + 11) << 24) |\n                                         ((uint64_t)(i + 7) << 16) | ((uint64_t)(i + 3) << 8) |\n                                         ((uint64_t)(i + 14) << 56) | ((uint64_t)(i + 10) << 48) |\n                                         ((uint64_t)(i + 6) << 40) | ((uint64_t)(i + 2) << 32) |\n                                         ((uint64_t)(i + 13) << 24) | ((uint64_t)(i + 9) << 16) |\n                                         ((uint64_t)(i + 5) << 8) | ((uint64_t)(i + 1) << 0) |\n                                         ((uint64_t)(i + 12) << 48) | ((uint64_t)(i + 8) << 40) |\n                                         ((uint64_t)(i + 4) << 32) | ((uint64_t)(i + 0) << 24));\n\n        uint32x4_t true_indices = vandq_u32(vmovq_n_u32(-1), vreinterpretq_u32_u8(prime_chunk));\n        uint32x4_t false_indices = veorq_u32(indices, true_indices);\n\n        uint32x4_t result = vbslq_u32(vceqq_u32(true_indices, vmovq_n_u32(0)), false_indices, indices);\n\n        for (int j = 0; j < 16; ++j) {\n            if (result[j] != 0 && result[j] < n) {\n                primes.push_back(result[j]);\n            }\n        }\n        i += 16;\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n\n    // Create a boolean array \"is_prime[0..n-1]\" and initialize all entries as true.\n    // A value in is_prime[i] will finally be false if i is Not a prime, else true.\n    std::vector<uint8_t> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false; // 0 and 1 are not prime numbers\n\n    int limit = static_cast<int>(std::sqrt(n)) + 1;\n\n    for (int p = 2; p < limit; ++p) {\n        if (is_prime[p]) {\n            // Marking multiples of p as false starting from p*p\n            int start = p * p;\n            if (start < 2) start = 2;\n\n            // Use NEON to mark multiples of p\n            uint8x16_t vfalse = vdupq_n_u8(0);\n            int i = start;\n            for (; i <= n - 16; i += 16) {\n                vst1q_u8(&is_prime[i], vfalse);\n            }\n\n            // Handle remaining elements\n            for (; i < n; ++i) {\n                is_prime[i] = false;\n            }\n        }\n    }\n\n    // Collecting all prime numbers\n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n\n    std::vector<uint8_t> is_prime(n, 1);\n    is_prime[0] = is_prime[1] = 0;\n\n    for (int i = 2; i <= std::sqrt(n); ++i) {\n        if (is_prime[i]) {\n            int j = i * i;\n            while (j < n) {\n                int k = j;\n                uint8x16_t vzero = vdupq_n_u8(0);\n                uint8x16_t vmask;\n                for (; k <= n - 16; k += 16) {\n                    vmask = vld1q_u8(&is_prime[k]);\n                    vmask = vbicq_u8(vmask, vzero);\n                    vst1q_u8(&is_prime[k], vmask);\n                }\n                for (; k < n; ++k) {\n                    is_prime[k] = 0;\n                }\n                j += i;\n            }\n        }\n    }\n\n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n\n    std::vector<uint8_t> is_prime(n, 1);\n    is_prime[0] = is_prime[1] = 0;\n\n    for (int i = 2; i <= std::sqrt(n); ++i) {\n        if (is_prime[i]) {\n            for (int j = i * i; j < n; j += i) {\n                is_prime[j] = 0;\n            }\n        }\n    }\n\n    for (int i = 2; i < n; ) {\n        uint8x16_t prime_chunk = vld1q_u8(&is_prime[i]);\n        uint32x4_t indices = vcreate_u32(((uint64_t)(i + 15) << 32) | ((uint64_t)(i + 11) << 24) |\n                                         ((uint64_t)(i + 7) << 16) | ((uint64_t)(i + 3) << 8) |\n                                         ((uint64_t)(i + 14) << 56) | ((uint64_t)(i + 10) << 48) |\n                                         ((uint64_t)(i + 6) << 40) | ((uint64_t)(i + 2) << 32) |\n                                         ((uint64_t)(i + 13) << 24) | ((uint64_t)(i + 9) << 16) |\n                                         ((uint64_t)(i + 5) << 8) | ((uint64_t)(i + 1) << 0) |\n                                         ((uint64_t)(i + 12) << 48) | ((uint64_t)(i + 8) << 40) |\n                                         ((uint64_t)(i + 4) << 32) | ((uint64_t)(i + 0) << 24));\n        uint32x4_t mask = vceqq_u32(vandq_u32(prime_chunk, vdupq_n_u32(0xFF)), vdupq_n_u32(0xFF));\n        uint32x4_t true_indices = vbslq_u32(mask, indices, vdupq_n_u32(0));\n\n        for (int j = 0; j < 16; ++j) {\n            int idx = vgetq_lane_u32(true_indices, j);\n            if (idx && idx < n) {\n                primes.push_back(idx);\n            }\n        }\n        i += 16;\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_109_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint count_upper_simd(const std::string & s){\n    int count = 0;\n    const char* str = s.c_str();\n    int len = s.length();\n    uint8x16_t vowels = vmovq_n_u8(0);\n    vowels = vsetq_lane_u8('A', vowels, 0);\n    vowels = vsetq_lane_u8('E', vowels, 1);\n    vowels = vsetq_lane_u8('I', vowels, 2);\n    vowels = vsetq_lane_u8('O', vowels, 3);\n    vowels = vsetq_lane_u8('U', vowels, 4);\n\n    for (int i = 0; i <= len - 16; i += 16, str += 16) {\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(str));\n        uint8x16_t mask_even = vmovq_n_u8(0);\n        mask_even = vsetq_lane_u8(1, mask_even, 0);\n        mask_even = vsetq_lane_u8(0, mask_even, 1);\n        mask_even = vsetq_lane_u8(1, mask_even, 2);\n        mask_even = vsetq_lane_u8(0, mask_even, 3);\n        mask_even = vsetq_lane_u8(1, mask_even, 4);\n        mask_even = vsetq_lane_u8(0, mask_even, 5);\n        mask_even = vsetq_lane_u8(1, mask_even, 6);\n        mask_even = vsetq_lane_u8(0, mask_even, 7);\n        mask_even = vsetq_lane_u8(1, mask_even, 8);\n        mask_even = vsetq_lane_u8(0, mask_even, 9);\n        mask_even = vsetq_lane_u8(1, mask_even, 10);\n        mask_even = vsetq_lane_u8(0, mask_even, 11);\n        mask_even = vsetq_lane_u8(1, mask_even, 12);\n        mask_even = vsetq_lane_u8(0, mask_even, 13);\n        mask_even = vsetq_lane_u8(1, mask_even, 14);\n        mask_even = vsetq_lane_u8(0, mask_even, 15);\n\n        uint8x16_t even_chars = vandq_u8(chars, mask_even);\n        uint8x16_t cmp1 = vceqq_u8(even_chars, vdupq_n_u8('A'));\n        uint8x16_t cmp2 = vceqq_u8(even_chars, vdupq_n_u8('E'));\n        uint8x16_t cmp3 = vceqq_u8(even_chars, vdupq_n_u8('I'));\n        uint8x16_t cmp4 = vceqq_u8(even_chars, vdupq_n_u8('O'));\n        uint8x16_t cmp5 = vceqq_u8(even_chars, vdupq_n_u8('U'));\n\n        uint8x16_t result = vorrq_u8(vorrq_u8(vorrq_u8(vorrq_u8(cmp1, cmp2), cmp3), cmp4), cmp5);\n        uint32x4_t sum = vpaddlq_u16(vpaddlq_u8(vreinterpretq_u16_u8(result)));\n        count += vgetq_lane_u32(sum, 0) + vgetq_lane_u32(sum, 1);\n    }\n\n    for (int i = len & ~15; i < len; ++i) {\n        if (i % 2 == 0 && (str[i] == 'A' || str[i] == 'E' || str[i] == 'I' || str[i] == 'O' || str[i] == 'U')) {\n            ++count;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint count_upper_simd(const std::string & s){\n    int count = 0;\n    int len = s.length();\n    const char* str = s.c_str();\n\n    uint8x16_t vowels = vdupq_n_u8(0);\n    vowels = vsetq_lane_u8('A', vowels, 0);\n    vowels = vsetq_lane_u8('E', vowels, 1);\n    vowels = vsetq_lane_u8('I', vowels, 2);\n    vowels = vsetq_lane_u8('O', vowels, 3);\n    vowels = vsetq_lane_u8('U', vowels, 4);\n\n    for (int i = 0; i <= len - 16; i += 16) {\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(str + i));\n        uint8x16_t mask_even = vmovq_n_u8(0x0F);\n        uint8x16_t even_chars = vandq_u8(chars, mask_even);\n\n        uint8x16_t cmp1 = vceqq_u8(even_chars, vdupq_n_u8('A'));\n        uint8x16_t cmp2 = vceqq_u8(even_chars, vdupq_n_u8('E'));\n        uint8x16_t cmp3 = vceqq_u8(even_chars, vdupq_n_u8('I'));\n        uint8x16_t cmp4 = vceqq_u8(even_chars, vdupq_n_u8('O'));\n        uint8x16_t cmp5 = vceqq_u8(even_chars, vdupq_n_u8('U'));\n\n        uint8x16_t result = vorrq_u8(vorrq_u8(vorrq_u8(vorrq_u8(cmp1, cmp2), cmp3), cmp4), cmp5);\n\n        uint32x4_t sum = vcntq_u8(result);\n        count += vaddvq_u32(sum) / 8;\n    }\n\n    for (int i = (len & ~15); i < len; i += 2) {\n        if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint count_upper_simd(const std::string & s){\n    int count = 0;\n    const char* str = s.c_str();\n    int len = s.length();\n    uint8x16_t vowels = vdupq_n_u8(0);\n    vowels = vsetq_lane_u8('A', vowels, 0);\n    vowels = vsetq_lane_u8('E', vowels, 1);\n    vowels = vsetq_lane_u8('I', vowels, 2);\n    vowels = vsetq_lane_u8('O', vowels, 3);\n    vowels = vsetq_lane_u8('U', vowels, 4);\n\n    for (int i = 0; i <= len - 16; i += 16) {\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(str + i));\n        uint8x16_t mask_even_indices = vmovq_n_u8(0);\n        mask_even_indices = vsetq_lane_u8(0xFF, mask_even_indices, 0);\n        mask_even_indices = vsetq_lane_u8(0, mask_even_indices, 1);\n        mask_even_indices = vsetq_lane_u8(0xFF, mask_even_indices, 2);\n        mask_even_indices = vsetq_lane_u8(0, mask_even_indices, 3);\n        mask_even_indices = vsetq_lane_u8(0xFF, mask_even_indices, 4);\n        mask_even_indices = vsetq_lane_u8(0, mask_even_indices, 5);\n        mask_even_indices = vsetq_lane_u8(0xFF, mask_even_indices, 6);\n        mask_even_indices = vsetq_lane_u8(0, mask_even_indices, 7);\n        mask_even_indices = vsetq_lane_u8(0xFF, mask_even_indices, 8);\n        mask_even_indices = vsetq_lane_u8(0, mask_even_indices, 9);\n        mask_even_indices = vsetq_lane_u8(0xFF, mask_even_indices, 10);\n        mask_even_indices = vsetq_lane_u8(0, mask_even_indices, 11);\n        mask_even_indices = vsetq_lane_u8(0xFF, mask_even_indices, 12);\n        mask_even_indices = vsetq_lane_u8(0, mask_even_indices, 13);\n        mask_even_indices = vsetq_lane_u8(0xFF, mask_even_indices, 14);\n        mask_even_indices = vsetq_lane_u8(0, mask_even_indices, 15);\n\n        uint8x16_t chars_even_indices = vandq_u8(chars, mask_even_indices);\n        uint8x16_t cmp_result = vceqq_u8(chars_even_indices, vowels);\n        uint8x16_t cmp_result_shifted = vshrq_n_u8(cmp_result, 7);\n        uint8x16_t ones = vdupq_n_u8(1);\n        uint8x16_t matches = vandq_u8(cmp_result_shifted, ones);\n        uint32x4_t sum = vpaddlq_u8(matches);\n        uint32x2_t sum2 = vpadd_u32(sum);\n        uint32_t final_sum = vget_lane_u32(vpaddl_u32(sum2), 0);\n        count += final_sum;\n    }\n\n    for (int i = (len & ~15); i < len; ++i) {\n        if (i % 2 == 0 && (str[i] == 'A' || str[i] == 'E' || str[i] == 'I' || str[i] == 'O' || str[i] == 'U')) {\n            ++count;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint count_upper_simd(const std::string & s){\n    int count = 0;\n    const char* str = s.c_str();\n    int len = s.length();\n    uint8x16_t vowels = vmovq_n_u8(0);\n    vowels = vsetq_lane_u8('A', vowels, 0);\n    vowels = vsetq_lane_u8('E', vowels, 1);\n    vowels = vsetq_lane_u8('I', vowels, 2);\n    vowels = vsetq_lane_u8('O', vowels, 3);\n    vowels = vsetq_lane_u8('U', vowels, 4);\n\n    for (int i = 0; i <= len - 16; i += 16) {\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(str + i));\n        uint8x16_t mask_even = vmovq_n_u8(0);\n        mask_even = vsetq_lane_u8(1, mask_even, 0);\n        mask_even = vsetq_lane_u8(0, mask_even, 1);\n        mask_even = vsetq_lane_u8(1, mask_even, 2);\n        mask_even = vsetq_lane_u8(0, mask_even, 3);\n        mask_even = vsetq_lane_u8(1, mask_even, 4);\n        mask_even = vsetq_lane_u8(0, mask_even, 5);\n        mask_even = vsetq_lane_u8(1, mask_even, 6);\n        mask_even = vsetq_lane_u8(0, mask_even, 7);\n        mask_even = vsetq_lane_u8(1, mask_even, 8);\n        mask_even = vsetq_lane_u8(0, mask_even, 9);\n        mask_even = vsetq_lane_u8(1, mask_even, 10);\n        mask_even = vsetq_lane_u8(0, mask_even, 11);\n        mask_even = vsetq_lane_u8(1, mask_even, 12);\n        mask_even = vsetq_lane_u8(0, mask_even, 13);\n        mask_even = vsetq_lane_u8(1, mask_even, 14);\n        mask_even = vsetq_lane_u8(0, mask_even, 15);\n\n        uint8x16_t even_chars = vandq_u8(chars, mask_even);\n        uint8x16_t cmp1 = vceqq_u8(even_chars, vdupq_n_u8('A'));\n        uint8x16_t cmp2 = vceqq_u8(even_chars, vdupq_n_u8('E'));\n        uint8x16_t cmp3 = vceqq_u8(even_chars, vdupq_n_u8('I'));\n        uint8x16_t cmp4 = vceqq_u8(even_chars, vdupq_n_u8('O'));\n        uint8x16_t cmp5 = vceqq_u8(even_chars, vdupq_n_u8('U'));\n\n        uint8x16_t result = vorrq_u8(vorrq_u8(vorrq_u8(vorrq_u8(cmp1, cmp2), cmp3), cmp4), cmp5);\n        uint32x4_t sum = vpaddlq_u16(vpaddlq_u8(vreinterpretq_u16_u8(result)));\n        count += vgetq_lane_u32(sum, 0) + vgetq_lane_u32(sum, 1);\n    }\n\n    for (int i = (len & ~15); i < len; i += 2) {\n        if (str[i] == 'A' || str[i] == 'E' || str[i] == 'I' || str[i] == 'O' || str[i] == 'U') {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint count_upper_simd(const std::string & s){\n    int count = 0;\n    const char* str = s.c_str();\n    int len = s.length();\n    uint8x16_t vowels = vdupq_n_u8(0);\n    vowels = vsetq_lane_u8('A', vowels, 0);\n    vowels = vsetq_lane_u8('E', vowels, 1);\n    vowels = vsetq_lane_u8('I', vowels, 2);\n    vowels = vsetq_lane_u8('O', vowels, 3);\n    vowels = vsetq_lane_u8('U', vowels, 4);\n\n    for (int i = 0; i <= len - 16; i += 16, str += 16) {\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(str));\n        uint8x16_t mask_even = vmovq_n_u8(0x55); // 0101010101010101 in binary\n        uint8x16_t even_chars = vandq_u8(chars, mask_even);\n        uint8x16_t cmp1 = vceqq_u8(even_chars, vdupq_n_u8('A'));\n        uint8x16_t cmp2 = vceqq_u8(even_chars, vdupq_n_u8('E'));\n        uint8x16_t cmp3 = vceqq_u8(even_chars, vdupq_n_u8('I'));\n        uint8x16_t cmp4 = vceqq_u8(even_chars, vdupq_n_u8('O'));\n        uint8x16_t cmp5 = vceqq_u8(even_chars, vdupq_n_u8('U'));\n        uint8x16_t result = vorrq_u8(vorrq_u8(vorrq_u8(vorrq_u8(cmp1, cmp2), cmp3), cmp4), cmp5);\n        uint32x4_t sum = vcgtq_u8(result, vdupq_n_u8(0));\n        count += vaddvq_u32(sum);\n    }\n\n    for (int i = len & ~15; i < len; i++) {\n        if (i % 2 == 0 && (str[i] == 'A' || str[i] == 'E' || str[i] == 'I' || str[i] == 'O' || str[i] == 'U')) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_110_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    int32x4_t increment = vdupq_n_s32(8);\n    int32x4_t current;\n\n    if (n % 2 == 0) {\n        current = vsetq_lane_s32(n, vsetq_lane_s32(n + 2, vsetq_lane_s32(n + 4, vsetq_lane_s32(n + 6, vdupq_n_s32(0)), 0), 1), 2);\n    } else {\n        current = vsetq_lane_s32(n, vsetq_lane_s32(n + 2, vsetq_lane_s32(n + 4, vsetq_lane_s32(n + 6, vdupq_n_s32(0)), 0), 1), 2);\n    }\n\n    for (int i = 0; i < n; i += 4) {\n        int32x4_t temp = current;\n        if (i + 3 < n) {\n            vst1q_s32(&result[i], temp);\n        } else {\n            for (int j = 0; j < n - i; ++j) {\n                result[i + j] = vgetq_lane_s32(temp, j);\n            }\n        }\n        current = vaddq_s32(current, increment);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    int32x4_t increment = vdupq_n_s32(8);\n    int32x4_t current;\n    \n    if (n % 2 == 0) {\n        current = vsetq_lane_s32(n, vdupq_n_s32(n + 2), 0);\n    } else {\n        current = vsetq_lane_s32(n, vdupq_n_s32(n + 1), 0);\n    }\n    \n    int i = 0;\n    for (; i <= n - 4; i += 4) {\n        vst1q_s32(&result[i], current);\n        current = vaddq_s32(current, increment);\n    }\n    \n    for (; i < n; ++i) {\n        result[i] = vgetq_lane_s32(current, i % 4);\n        if ((i + 1) % 4 == 0) {\n            current = vaddq_s32(current, increment);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_110_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    int32x4_t increment = vdupq_n_s32(8);\n    int32x4_t base;\n    int32x4_t current;\n\n    if (n % 2 == 0) {\n        base = vsetq_lane_s32(n, vsetq_lane_s32(n + 2, vsetq_lane_s32(n + 4, vdupq_n_s32(n + 6), 0), 1), 2);\n    } else {\n        base = vsetq_lane_s32(n, vsetq_lane_s32(n + 2, vsetq_lane_s32(n + 4, vdupq_n_s32(n + 6), 0), 1), 2);\n    }\n\n    for (int i = 0; i < n; i += 4) {\n        if (i == 0) {\n            current = base;\n        } else {\n            current = vaddq_s32(current, increment);\n        }\n        int32x2_t lo = vget_low_s32(current);\n        int32x2_t hi = vget_high_s32(current);\n        if (i < n) result[i] = vget_lane_s32(lo, 0);\n        if (i + 1 < n) result[i + 1] = vget_lane_s32(lo, 1);\n        if (i + 2 < n) result[i + 2] = vget_lane_s32(hi, 0);\n        if (i + 3 < n) result[i + 3] = vget_lane_s32(hi, 1);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    int32x4_t increment = vdupq_n_s32(8);\n    int32x4_t current;\n    \n    if (n % 2 == 0) {\n        current = vsetq_lane_s32(n, vsetq_lane_s32(n + 2, vsetq_lane_s32(n + 4, vsetq_lane_s32(n + 6, vdupq_n_s32(0)), 0), 1), 2);\n    } else {\n        current = vsetq_lane_s32(n, vsetq_lane_s32(n + 2, vsetq_lane_s32(n + 4, vsetq_lane_s32(n + 6, vdupq_n_s32(0)), 0), 1), 2);\n    }\n\n    for (int i = 0; i < n; i += 4) {\n        int32x4_t temp = current;\n        if (i + 3 < n) {\n            vst1q_s32(&result[i], temp);\n        } else {\n            for (int j = 0; j < n - i; ++j) {\n                result[i + j] = vgetq_lane_s32(temp, j);\n            }\n        }\n        current = vaddq_s32(current, increment);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    int32x4_t increment = vdupq_n_s32(8);\n    int32x4_t current;\n    \n    if (n % 2 == 0) {\n        current = vsetq_lane_s32(n, vsetq_lane_s32(n + 2, vsetq_lane_s32(n + 4, vsetq_lane_s32(n + 6, vdupq_n_s32(0)), 0), 1), 2);\n    } else {\n        current = vsetq_lane_s32(n, vsetq_lane_s32(n + 2, vsetq_lane_s32(n + 4, vsetq_lane_s32(n + 6, vdupq_n_s32(0)), 0), 1), 2);\n    }\n\n    for (int i = 0; i < n; i += 4) {\n        int32x4_t temp = current;\n        if (i + 0 < n) result[i + 0] = vgetq_lane_s32(temp, 0);\n        if (i + 1 < n) result[i + 1] = vgetq_lane_s32(temp, 1);\n        if (i + 2 < n) result[i + 2] = vgetq_lane_s32(temp, 2);\n        if (i + 3 < n) result[i + 3] = vgetq_lane_s32(temp, 3);\n        current = vaddq_s32(current, increment);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_111_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <bitset>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m){\n    if (n > m) {\n        return \"-1\";\n    }\n\n    int64_t sum = 0;\n    int64_t count = m - n + 1;\n\n    int64x2_t sum_vec = vdupq_n_s64(0);\n    int64x2_t n_vec = vdupq_n_s64(n);\n    int64x2_t one_vec = vdupq_n_s64(1);\n\n    for (int64_t i = 0; i < count; i += 2) {\n        int64x2_t current_vec = vaddq_s64(n_vec, vdupq_n_s64(i));\n        sum_vec = vaddq_s64(sum_vec, current_vec);\n        if (i + 1 < count) {\n            current_vec = vaddq_s64(n_vec, vdupq_n_s64(i + 1));\n            sum_vec = vaddq_s64(sum_vec, current_vec);\n        }\n    }\n\n    int64_t sum_array[2];\n    vst1q_s64(sum_array, sum_vec);\n    sum = sum_array[0] + sum_array[1];\n\n    int64_t avg = sum / count;\n\n    return std::bitset<64>(avg).to_string().substr(64 - std::bitset<64>(avg).count());\n}\n```"}
{"task_id": "SimdBench_111_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <bitset>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n\n    int64x2_t range = vdupq_n_s64(n);\n    int64x2_t end = vdupq_n_s64(m);\n    int64x2_t one = vdupq_n_s64(1);\n\n    // Create a vector with n and m+1\n    int64x2_t nm = vsetq_lane_s64(m + 1, range, 1);\n\n    // Calculate the sum of the range using the formula: sum = (m * (m + 1) / 2) - ((n - 1) * n / 2)\n    int64x2_t n_minus_one = vsubq_s64(range, one);\n    int64x2_t m_times_m_plus_one = vmulq_s64(end, nm);\n    int64x2_t n_minus_one_times_n = vmulq_s64(n_minus_one, range);\n\n    // Use polynomial multiplication to avoid overflow\n    int64x2_t sum1 = vshrq_n_s64(m_times_m_plus_one, 1);\n    int64x2_t sum2 = vshrq_n_s64(n_minus_one_times_n, 1);\n    int64x2_t sum = vsubq_s64(sum1, sum2);\n\n    // Calculate the average\n    int64x2_t count = vsubq_s64(nm, range);\n    int64x2_t avg = vrshrq_n_s64(sum, 0); // Right shift with rounding\n\n    // Extract the average value\n    int64_t result = vgetq_lane_s64(avg, 0);\n\n    // Convert to binary string\n    return std::bitset<64>(result).to_string().substr(64 - std::bitset<64>(result).count());\n}\n```"}
{"task_id": "SimdBench_111_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <bitset>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m){\n    if (n > m) {\n        return \"-1\";\n    }\n\n    int64_t sum = 0;\n    int64_t count = m - n + 1;\n\n    int64x2_t n_vec = vdupq_n_s64(n);\n    int64x2_t m_vec = vdupq_n_s64(m);\n    int64x2_t one_vec = vdupq_n_s64(1);\n    int64x2_t sum_vec = vdupq_n_s64(0);\n\n    int64x2_t i_vec = n_vec;\n    while (vmaxvq_s64(i_vec) <= m) {\n        sum_vec = vaddq_s64(sum_vec, i_vec);\n        i_vec = vaddq_s64(i_vec, one_vec);\n    }\n\n    int64_t sum_array[2];\n    vst1q_s64(sum_array, sum_vec);\n    sum = sum_array[0] + sum_array[1];\n\n    int64_t avg = sum / count;\n\n    return std::bitset<64>(avg).to_string().substr(64 - std::bitset<64>(avg).count());\n}\n```"}
{"task_id": "SimdBench_111_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <bitset>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m){\n    if (n > m) {\n        return \"-1\";\n    }\n\n    int64_t sum = 0;\n    int64_t count = m - n + 1;\n\n    int64x2_t n_vec = vdupq_n_s64(n);\n    int64x2_t m_vec = vdupq_n_s64(m);\n    int64x2_t one_vec = vdupq_n_s64(1);\n    int64x2_t sum_vec = vdupq_n_s64(0);\n\n    int64x2_t i_vec = n_vec;\n    while (vmaxvq_s64(i_vec) <= m) {\n        sum_vec = vaddq_s64(sum_vec, i_vec);\n        i_vec = vaddq_s64(i_vec, one_vec);\n    }\n\n    int64_t sum_array[2];\n    vst1q_s64(sum_array, sum_vec);\n    sum = sum_array[0] + sum_array[1];\n\n    int64_t avg = sum / count;\n\n    return std::bitset<64>(avg).to_string().substr(64 - std::ceil(std::log2(avg + 1)));\n}\n```"}
{"task_id": "SimdBench_111_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <bitset>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m){\n    if (n > m) {\n        return \"-1\";\n    }\n\n    int64_t sum = 0;\n    int64_t count = m - n + 1;\n\n    int64x2_t n_vec = vdupq_n_s64(n);\n    int64x2_t m_vec = vdupq_n_s64(m);\n    int64x2_t one_vec = vdupq_n_s64(1);\n    int64x2_t sum_vec = vdupq_n_s64(0);\n\n    int64x2_t i_vec = n_vec;\n    while (vmaxvq_s64(i_vec) <= m) {\n        sum_vec = vaddq_s64(sum_vec, i_vec);\n        i_vec = vaddq_s64(i_vec, one_vec);\n    }\n\n    int64_t sum_array[2];\n    vst1q_s64(sum_array, sum_vec);\n    sum = sum_array[0] + sum_array[1];\n\n    int64_t avg = sum / count;\n\n    return std::bitset<64>(avg).to_string().substr(64 - std::ceil(std::log2(avg + 1)));\n}\n```"}
{"task_id": "SimdBench_112_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    int32x4_t mod = vdupq_n_s32(10000);\n\n    for (int i = 0; i < n; i += 4) {\n        int32x4_t indices = vaddq_s32(vdupq_n_s32(i + 1), vld1q_s32((const int32_t[]){0, 1, 2, 3}));\n        uint32x4_t is_even = vceqq_s32(vandq_s32(indices, vdupq_n_s32(1)), vdupq_n_s32(0));\n        int32x4_t factorials = vdupq_n_s32(1);\n        int32x4_t sums = vdupq_n_s32(0);\n\n        for (int j = 1; j <= i + 4 && j <= n; ++j) {\n            int32x4_t j_vec = vdupq_n_s32(j);\n            factorials = vmulq_s32(factorials, j_vec);\n            factorials = vmodq_s32(factorials, mod);\n            sums = vaddq_s32(sums, j_vec);\n        }\n\n        int32x4_t results = vbslq_s32(is_even, factorials, sums);\n        vst1q_s32(&result[i], results);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    int32x4_t mod = vdupq_n_s32(10000);\n\n    for (int i = 0; i < n; i += 4) {\n        int32x4_t indices = vaddq_s32(vdupq_n_s32(i + 1), vld1q_s32((const int32_t[]){0, 1, 2, 3}));\n        uint32x4_t is_even = vceqq_u32(vandq_u32(vreinterpretq_u32_s32(indices), vdupq_n_u32(1)), vdupq_n_u32(0));\n        int32x4_t factorials = vdupq_n_s32(1);\n        int32x4_t sums = vdupq_n_s32(0);\n\n        for (int j = 0; j < 4 && i + j < n; ++j) {\n            int idx = i + j + 1;\n            if (idx % 2 == 0) {\n                int fact = 1;\n                for (int k = 1; k <= idx; ++k) {\n                    fact = (fact * k) % 10000;\n                }\n                factorials = vsetq_lane_s32(fact, factorials, j);\n            } else {\n                int sum = (idx * (idx + 1)) / 2;\n                sums = vsetq_lane_s32(sum, sums, j);\n            }\n        }\n\n        int32x4_t results = vbslq_s32(is_even, factorials, sums);\n        vst1q_s32(&result[i], results);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    int32x4_t mod_val = vdupq_n_s32(10000);\n\n    for (int i = 0; i < n; i += 4) {\n        int32x4_t indices = vaddq_s32(vdupq_n_s32(i + 1), vld1q_s32((const int32_t[]){0, 1, 2, 3}));\n        uint32x4_t is_even = vceqq_s32(vandq_s32(indices, vdupq_n_s32(1)), vdupq_n_s32(0));\n        int32x4_t factorials = vdupq_n_s32(1);\n        int32x4_t sums = vdupq_n_s32(0);\n\n        for (int j = 1; j <= i + 4 && j <= n; ++j) {\n            int32x4_t j_vec = vdupq_n_s32(j);\n            factorials = vmulq_s32(factorials, j_vec);\n            factorials = vmodq_s32(factorials, mod_val);\n            sums = vaddq_s32(sums, j_vec);\n        }\n\n        int32x4_t results = vbslq_s32(is_even, factorials, sums);\n        vst1q_s32(&result[i], results);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    int32x4_t mod_val = vdupq_n_s32(10000);\n\n    for (int i = 0; i < n; i += 4) {\n        int32x4_t indices = vaddq_s32(vdupq_n_s32(i + 1), vld1q_s32((const int32_t[]){0, 1, 2, 3}));\n        uint32x4_t is_even = vceqq_u32(vandq_u32(vreinterpretq_u32_s32(indices), vdupq_n_u32(1)), vdupq_n_u32(0));\n        int32x4_t factorials = vdupq_n_s32(1);\n        int32x4_t sums = vdupq_n_s32(0);\n\n        for (int j = 0; j < 4 && i + j < n; ++j) {\n            int idx = i + j + 1;\n            if (idx % 2 == 0) {\n                int fact = 1;\n                for (int k = 1; k <= idx; ++k) {\n                    fact = (fact * k) % 10000;\n                }\n                factorials = vsetq_lane_s32(fact, factorials, j);\n            } else {\n                int sum = (idx * (idx + 1)) / 2;\n                sums = vsetq_lane_s32(sum, sums, j);\n            }\n        }\n\n        int32x4_t results = vbslq_s32(is_even, factorials, sums);\n        vst1q_s32(&result[i], results);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    int32x4_t mod_val = vdupq_n_s32(10000);\n\n    for (int i = 0; i < n; i += 4) {\n        int32x4_t indices = vaddq_s32(vdupq_n_s32(i + 1), vld1q_s32((const int32_t[]){0, 1, 2, 3}));\n        uint32x4_t is_even = vceqq_s32(vandq_s32(indices, vdupq_n_s32(1)), vdupq_n_s32(0));\n        int32x4_t factorials = vdupq_n_s32(1);\n        int32x4_t sums = vdupq_n_s32(0);\n\n        for (int j = 1; j <= i + 4 && j <= n; ++j) {\n            int32x4_t j_vec = vdupq_n_s32(j);\n            factorials = vmulq_s32(factorials, j_vec);\n            factorials = vmodq_s32(factorials, mod_val);\n            sums = vaddq_s32(sums, j_vec);\n        }\n\n        int32x4_t results = vbslq_s32(is_even, factorials, sums);\n        vst1q_s32(&result[i], results);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_113_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    for (int i = 1; i <= n; i += 8) {\n        uint8x8_t nums = vdup_n_u8(0);\n        uint8x8_t evens = vdup_n_u8(0);\n        uint8x8_t odds = vdup_n_u8(0);\n\n        for (int j = 0; j < 8 && i + j <= n; ++j) {\n            int num = i + j;\n            int temp = num;\n            int reversed = 0;\n\n            while (temp > 0) {\n                int digit = temp % 10;\n                reversed = reversed * 10 + digit;\n                temp /= 10;\n            }\n\n            if (num == reversed) {\n                nums = vset_lane_u8(1, nums, j);\n                if (num % 2 == 0) {\n                    evens = vset_lane_u8(1, evens, j);\n                } else {\n                    odds = vset_lane_u8(1, odds, j);\n                }\n            }\n        }\n\n        uint32x2_t sum_evens = vpaddl_u16(vpaddl_u8(evens));\n        uint32x2_t sum_odds = vpaddl_u16(vpaddl_u8(odds));\n\n        even_count += vget_lane_u32(sum_evens, 0) + vget_lane_u32(sum_evens, 1);\n        odd_count += vget_lane_u32(sum_odds, 0) + vget_lane_u32(sum_odds, 1);\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    for (int i = 1; i <= n; i += 8) {\n        uint8x8_t nums = vdup_n_u8(0);\n        uint8x8_t evens = vdup_n_u8(0);\n        uint8x8_t odds = vdup_n_u8(0);\n\n        for (int j = 0; j < 8 && i + j <= n; ++j) {\n            int num = i + j;\n            int temp = num;\n            int reversed = 0;\n\n            while (temp > 0) {\n                int digit = temp % 10;\n                reversed = reversed * 10 + digit;\n                temp /= 10;\n            }\n\n            if (num == reversed) {\n                nums = vset_lane_u8(1, nums, j);\n                if (num % 2 == 0) {\n                    evens = vset_lane_u8(1, evens, j);\n                } else {\n                    odds = vset_lane_u8(1, odds, j);\n                }\n            }\n        }\n\n        uint32x2_t even_sum = vpaddl_u16(vpaddl_u8(vmovl_u8(evens)));\n        uint32x2_t odd_sum = vpaddl_u16(vpaddl_u8(vmovl_u8(odds)));\n\n        even_count += vget_lane_u32(even_sum, 0) + vget_lane_u32(even_sum, 1);\n        odd_count += vget_lane_u32(odd_sum, 0) + vget_lane_u32(odd_sum, 1);\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    for (int i = 1; i <= n; i += 8) {\n        uint8x8_t nums = vdup_n_u8(0);\n        uint8x8_t evens = vdup_n_u8(0);\n        uint8x8_t odds = vdup_n_u8(0);\n\n        for (int j = 0; j < 8 && (i + j) <= n; ++j) {\n            int num = i + j;\n            int temp = num;\n            int reversed = 0;\n\n            while (temp > 0) {\n                int digit = temp % 10;\n                reversed = reversed * 10 + digit;\n                temp /= 10;\n            }\n\n            if (num == reversed) {\n                nums = vset_lane_u8(1, nums, j);\n                if (num % 2 == 0) {\n                    evens = vset_lane_u8(1, evens, j);\n                } else {\n                    odds = vset_lane_u8(1, odds, j);\n                }\n            }\n        }\n\n        uint32x2_t sum_evens = vpaddl_u16(vpaddl_u8(evens));\n        uint32x2_t sum_odds = vpaddl_u16(vpaddl_u8(odds));\n\n        even_count += vget_lane_u32(sum_evens, 0) + vget_lane_u32(sum_evens, 1);\n        odd_count += vget_lane_u32(sum_odds, 0) + vget_lane_u32(sum_odds, 1);\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    for (int i = 1; i <= n; i += 8) {\n        uint8x8_t nums = vdup_n_u8(0);\n        uint8x8_t evens = vdup_n_u8(0);\n        uint8x8_t odds = vdup_n_u8(0);\n\n        for (int j = 0; j < 8 && i + j <= n; ++j) {\n            int num = i + j;\n            int temp = num;\n            int reversed = 0;\n\n            while (temp > 0) {\n                int digit = temp % 10;\n                reversed = reversed * 10 + digit;\n                temp /= 10;\n            }\n\n            if (num == reversed) {\n                nums = vset_lane_u8(1, nums, j);\n                if (num % 2 == 0) {\n                    evens = vset_lane_u8(1, evens, j);\n                } else {\n                    odds = vset_lane_u8(1, odds, j);\n                }\n            }\n        }\n\n        uint32x2_t sum_evens = vpaddl_u16(vpaddl_u8(evens));\n        uint32x2_t sum_odds = vpaddl_u16(vpaddl_u8(odds));\n\n        even_count += vget_lane_u32(sum_evens, 0) + vget_lane_u32(sum_evens, 1);\n        odd_count += vget_lane_u32(sum_odds, 0) + vget_lane_u32(sum_odds, 1);\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    for (int i = 1; i <= n; i += 8) {\n        uint8x8_t nums = vdup_n_u8(0);\n        uint8x8_t evens = vdup_n_u8(0);\n        uint8x8_t odds = vdup_n_u8(0);\n\n        for (int j = 0; j < 8 && i + j <= n; ++j) {\n            int num = i + j;\n            int temp = num;\n            int reversed = 0;\n\n            while (temp > 0) {\n                int digit = temp % 10;\n                reversed = reversed * 10 + digit;\n                temp /= 10;\n            }\n\n            if (num == reversed) {\n                nums = vset_lane_u8(1, nums, j);\n                if (num % 2 == 0) {\n                    evens = vset_lane_u8(1, evens, j);\n                } else {\n                    odds = vset_lane_u8(1, odds, j);\n                }\n            }\n        }\n\n        uint32x2_t sum_evens = vpaddl_u16(vpaddl_u8(evens));\n        uint32x2_t sum_odds = vpaddl_u16(vpaddl_u8(odds));\n\n        even_count += vget_lane_u32(sum_evens, 0) + vget_lane_u32(sum_evens, 1);\n        odd_count += vget_lane_u32(sum_odds, 0) + vget_lane_u32(sum_odds, 1);\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_114_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint count_nums_simd(const std::vector<int>& n) {\n    int count = 0;\n    size_t size = n.size();\n    size_t i = 0;\n\n    // Process 4 integers at a time\n    for (; i <= size - 4; i += 4) {\n        int32x4_t nums = vld1q_s32(&n[i]);\n        int32x4_t zeros = vdupq_n_s32(0);\n        uint32x4_t signs = vcltq_s32(nums, zeros); // Check if numbers are negative\n        int32x4_t abs_nums = vabsq_s32(nums); // Get absolute values\n\n        // Sum digits of each number\n        int16x8_t digits = vreinterpretq_s16_s32(vshrq_n_s32(abs_nums, 16)); // Shift right by 16 to get higher 16 bits\n        digits = vaddq_s16(digits, vreinterpretq_s16_s32(abs_nums)); // Add lower 16 bits\n        digits = vaddq_s16(digits, vshrq_n_s16(digits, 8)); // Shift right by 8 to get higher 8 bits\n        digits = vaddq_s16(digits, vshrq_n_s16(digits, 4)); // Shift right by 4 to get higher 4 bits\n        digits = vaddq_s16(digits, vshrq_n_s16(digits, 2)); // Shift right by 2 to get higher 2 bits\n        digits = vaddq_s16(digits, vshrq_n_s16(digits, 1)); // Shift right by 1 to get higher 1 bit\n\n        int16x4_t digit_sums = vpadd_s16(vget_low_s16(digits), vget_high_s16(digits)); // Pairwise add to get sums\n\n        // Adjust sums for negative numbers\n        int16x4_t adjusted_sums = vsubq_s16(digit_sums, vreinterpret_s16_s32(signs));\n\n        // Count numbers with digit sum > 0\n        uint16x4_t gt_zeros = vcgtq_s16(adjusted_sums, vdup_n_s16(0));\n        count += vaddv_u16(gt_zeros);\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        int num = n[i];\n        int sum = 0;\n        bool is_negative = num < 0;\n        num = std::abs(num);\n\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n\n        if (is_negative) {\n            sum = sum - 2 * (n[i] % 10); // Adjust for the negative sign\n        }\n\n        if (sum > 0) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint count_nums_simd(const std::vector<int>& n) {\n    int count = 0;\n    size_t size = n.size();\n    const int* data = n.data();\n\n    for (size_t i = 0; i <= size - 4; i += 4) {\n        int32x4_t nums = vld1q_s32(&data[i]);\n        int32x4_t zeros = vdupq_n_s32(0);\n        uint32x4_t signs = vcltq_s32(nums, zeros);\n        int32x4_t abs_nums = vabsq_s32(nums);\n\n        int16x8_t digits = vreinterpretq_s16_s32(vshrq_n_s32(abs_nums, 16));\n        digits = vaddq_s16(digits, vreinterpretq_s16_s32(abs_nums));\n\n        int8x16_t byte_digits = vreinterpretq_s8_s16(vshrq_n_s16(digits, 8));\n        byte_digits = vaddq_s8(byte_digits, vreinterpretq_s8_s16(digits));\n\n        int8x16_t ones = vdupq_n_s8(1);\n        int8x16_t digit_sums = vcntq_s8(byte_digits);\n\n        int8x16_t non_zero_digit_sums = vcgtq_s8(digit_sums, vdupq_n_s8(0));\n        int8x16_t adjusted_sums = vsubq_s8(non_zero_digit_sums, vreinterpretq_s8_u16(signs));\n\n        uint32x4_t positive_sums = vcgtq_s8(adjusted_sums, vdupq_n_s8(0));\n        count += vaddvq_u32(positive_sums);\n    }\n\n    for (size_t i = (size / 4) * 4; i < size; ++i) {\n        int num = data[i];\n        int sum = 0;\n        bool is_negative = num < 0;\n        num = std::abs(num);\n\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n\n        if ((is_negative && sum > 1) || (!is_negative && sum > 0)) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint count_nums_simd(const std::vector<int>& n) {\n    int count = 0;\n    size_t size = n.size();\n    size_t i = 0;\n\n    // Process 4 integers at a time\n    for (; i <= size - 4; i += 4) {\n        int32x4_t nums = vld1q_s32(&n[i]);\n        int32x4_t zeros = vdupq_n_s32(0);\n        uint32x4_t signs = vcltq_s32(nums, zeros); // Check if numbers are negative\n        int32x4_t abs_nums = vabsq_s32(nums); // Get absolute values\n\n        // Sum digits of each number\n        int16x8_t digits = vreinterpretq_s16_s32(vshrq_n_s32(abs_nums, 16)); // Shift right by 16 to get high 16 bits\n        digits = vaddq_s16(digits, vreinterpretq_s16_s32(abs_nums)); // Add low 16 bits\n        digits = vaddq_s16(digits, vshrq_n_s16(digits, 8)); // Shift right by 8 to get high 8 bits\n        digits = vaddq_s16(digits, vshrq_n_s16(digits, 4)); // Shift right by 4 to get high 4 bits\n        digits = vaddq_s16(digits, vshrq_n_s16(digits, 2)); // Shift right by 2 to get high 2 bits\n        digits = vaddq_s16(digits, vshrq_n_s16(digits, 1)); // Shift right by 1 to get high 1 bit\n\n        int16x4_t digit_sums = vpadd_s16(vget_low_s16(digits), vget_high_s16(digits)); // Pairwise add to get sums\n\n        // Adjust sums for negative numbers\n        int16x4_t adjusted_sums = vsubq_s16(digit_sums, vreinterpret_s16_s32(signs));\n\n        // Count numbers with digit sum > 0\n        uint16x4_t gt_zeros = vcgtq_s16(adjusted_sums, vdup_n_s16(0));\n        count += vaddv_u16(gt_zeros);\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        int num = n[i];\n        int sum = 0;\n        bool is_negative = num < 0;\n        num = std::abs(num);\n\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n\n        if (is_negative) {\n            sum = sum - 2 * (n[i] % 10); // Adjust for the negative sign\n        }\n\n        if (sum > 0) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint count_nums_simd(const std::vector<int>& n) {\n    int count = 0;\n    size_t size = n.size();\n    size_t i = 0;\n\n    // Process 4 integers at a time\n    for (; i <= size - 4; i += 4) {\n        int32x4_t nums = vld1q_s32(&n[i]);\n        int32x4_t zeros = vdupq_n_s32(0);\n        uint32x4_t signs = vcgtq_s32(nums, zeros); // 0xFFFFFFFF if positive, 0 otherwise\n\n        // Calculate absolute values\n        int32x4_t abs_nums = vabsq_s32(nums);\n\n        // Sum digits of each number\n        uint8x16_t digits = vreinterpretq_u8_s32(abs_nums);\n        uint8x16_t digit_sums = vdupq_n_u8(0);\n\n        for (int j = 0; j < 4; ++j) {\n            uint8x16_t shifted_digits = vshrq_n_u8(digits, j * 8);\n            digit_sums = vaddq_u8(digit_sums, vandq_u8(shifted_digits, vdupq_n_u8(0xFF)));\n        }\n\n        // Convert digit sums to 32-bit integers\n        uint32x4_t digit_sum_ints = vpaddlq_u16(vpaddlq_u8(digit_sums));\n\n        // Adjust for negative numbers\n        int32x4_t adjusted_sums = vsubq_s32(vreinterpretq_s32_u32(digit_sum_ints), vreinterpretq_s32_u32(signs));\n\n        // Count numbers with digit sum > 0\n        uint32x4_t gt_zero = vcgtq_s32(adjusted_sums, zeros);\n        uint32x2_t gt_zero_64 = vaddv_u32(gt_zero);\n        count += vaddv_u32(vreinterpret_u32_u64(gt_zero_64));\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        int num = n[i];\n        int sum_of_digits = 0;\n        bool is_negative = num < 0;\n        num = std::abs(num);\n\n        while (num > 0) {\n            sum_of_digits += num % 10;\n            num /= 10;\n        }\n\n        if (is_negative) {\n            sum_of_digits = -sum_of_digits + 2 * (sum_of_digits % 10);\n        }\n\n        if (sum_of_digits > 0) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint count_nums_simd(const std::vector<int>& n) {\n    int count = 0;\n    size_t size = n.size();\n    size_t i = 0;\n\n    // Process 4 integers at a time\n    for (; i <= size - 4; i += 4) {\n        int32x4_t nums = vld1q_s32(&n[i]);\n        int32x4_t zeros = vdupq_n_s32(0);\n        uint32x4_t signs = vcgtq_s32(nums, zeros); // 0xFFFFFFFF if positive, 0 otherwise\n\n        // Calculate absolute values\n        int32x4_t abs_nums = vabsq_s32(nums);\n\n        // Sum digits of each number\n        uint8x16_t digits = vreinterpretq_u8_s32(abs_nums);\n        uint8x16_t digit_sums = vdupq_n_u8(0);\n\n        for (int j = 0; j < 4; ++j) {\n            uint8x16_t shifted_digits = vshrq_n_u8(digits, j * 8);\n            digit_sums = vaddq_u8(digit_sums, vandq_u8(shifted_digits, vdupq_n_u8(0xFF)));\n        }\n\n        // Convert digit sums to 32-bit integers\n        uint32x4_t digit_sums_32 = vpaddlq_u16(vpaddlq_u8(vmovl_u8(digit_sums)));\n\n        // Adjust sums for negative numbers\n        int32x4_t adjusted_sums = vsubq_s32(vreinterpretq_s32_u32(digit_sums_32), vreinterpretq_s32_u32(signs));\n\n        // Count numbers with digit sum > 0\n        uint32x4_t gt_zero = vcgtq_s32(adjusted_sums, zeros);\n        uint32x2_t gt_zero_64 = vaddvq_u32(gt_zero);\n        count += vaddv_u32(gt_zero_64);\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        int num = n[i];\n        int sum = 0;\n        bool is_negative = num < 0;\n        num = std::abs(num);\n\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n\n        if (is_negative) {\n            sum = -sum + 2 * (sum % 10); // Adjust for negative sign\n        }\n\n        if (sum > 0) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_115_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n\n    int32_t* data = arr.data();\n    int32x4_t vec1, vec2, vec3;\n    int32x4_t min_vec = vdupq_n_s32(INT32_MAX);\n    int32x4_t max_vec = vdupq_n_s32(INT32_MIN);\n\n    for (int i = 0; i < n; i += 4) {\n        int len = std::min(4, n - i);\n        if (len == 4) {\n            vec1 = vld1q_s32(data + i);\n            vec2 = vld1q_s32(data + (i + 1) % n);\n            vec3 = vld1q_s32(data + (i + 2) % n);\n            vec1 = vsetq_lane_s32(data[(i + 3) % n], vec1, 3);\n\n            min_vec = vminq_s32(min_vec, vec1);\n            min_vec = vminq_s32(min_vec, vec2);\n            min_vec = vminq_s32(min_vec, vec3);\n\n            max_vec = vmaxq_s32(max_vec, vec1);\n            max_vec = vmaxq_s32(max_vec, vec2);\n            max_vec = vmaxq_s32(max_vec, vec3);\n        } else {\n            for (int j = 0; j < len; ++j) {\n                int32_t val = data[(i + j) % n];\n                min_vec = vminq_s32(min_vec, vdupq_n_s32(val));\n                max_vec = vmaxq_s32(max_vec, vdupq_n_s32(val));\n            }\n        }\n    }\n\n    int32_t min_val = vminvq_s32(min_vec);\n    int32_t max_val = vmaxvq_s32(max_vec);\n\n    for (int i = 0; i < n; ++i) {\n        if (data[i] == min_val) {\n            bool is_sorted = true;\n            for (int j = 0; j < n - 1; ++j) {\n                if (data[(i + j) % n] > data[(i + j + 1) % n]) {\n                    is_sorted = false;\n                    break;\n                }\n            }\n            if (is_sorted) return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_115_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n\n    int32x4_t vec1, vec2, vec3, vec4;\n    int32x4_t min_vec = vdupq_n_s32(INT_MAX);\n    int32x4_t max_vec = vdupq_n_s32(INT_MIN);\n\n    for (int i = 0; i < n; i += 4) {\n        int len = std::min(4, n - i);\n        int32_t temp[4] = {INT_MAX, INT_MAX, INT_MAX, INT_MAX};\n        for (int j = 0; j < len; ++j) {\n            temp[j] = arr[(i + j) % n];\n        }\n        vec1 = vld1q_s32(temp);\n\n        min_vec = vminq_s32(min_vec, vec1);\n        max_vec = vmaxq_s32(max_vec, vec1);\n    }\n\n    int32_t min_val[4], max_val[4];\n    vst1q_s32(min_val, min_vec);\n    vst1q_s32(max_val, max_vec);\n\n    int global_min = INT_MAX, global_max = INT_MIN;\n    for (int i = 0; i < 4; ++i) {\n        global_min = std::min(global_min, min_val[i]);\n        global_max = std::max(global_max, max_val[i]);\n    }\n\n    for (int shift = 0; shift < n; ++shift) {\n        bool is_sorted = true;\n        for (int i = 0; i < n; i += 4) {\n            int len = std::min(4, n - i);\n            int32_t temp[4] = {INT_MAX, INT_MAX, INT_MAX, INT_MAX};\n            for (int j = 0; j < len; ++j) {\n                temp[j] = arr[(i + j + shift) % n];\n            }\n            vec1 = vld1q_s32(temp);\n\n            if (i > 0) {\n                vec2 = vextq_s32(vec3, vec1, 3);\n                uint32x4_t mask = vcgtq_s32(vec2, vec1);\n                if (vmaxvq_u32(mask) != 0) {\n                    is_sorted = false;\n                    break;\n                }\n            }\n            vec3 = vec1;\n        }\n        if (is_sorted) return true;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_115_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n\n    int32_t* data = arr.data();\n    int32x4_t vec1, vec2, vec3, vec4;\n    int32x4_t min_vec = vdupq_n_s32(INT32_MAX);\n    int32x4_t max_vec = vdupq_n_s32(INT32_MIN);\n\n    for (int i = 0; i < n; i += 4) {\n        int len = std::min(4, n - i);\n        if (len == 4) {\n            vec1 = vld1q_s32(data + i);\n            vec2 = vld1q_s32(data + (i + 1) % n);\n            vec3 = vld1q_s32(data + (i + 2) % n);\n            vec4 = vld1q_s32(data + (i + 3) % n);\n\n            min_vec = vminq_s32(min_vec, vec1);\n            min_vec = vminq_s32(min_vec, vec2);\n            min_vec = vminq_s32(min_vec, vec3);\n            min_vec = vminq_s32(min_vec, vec4);\n\n            max_vec = vmaxq_s32(max_vec, vec1);\n            max_vec = vmaxq_s32(max_vec, vec2);\n            max_vec = vmaxq_s32(max_vec, vec3);\n            max_vec = vmaxq_s32(max_vec, vec4);\n        } else {\n            int32_t temp[4] = {INT32_MAX, INT32_MAX, INT32_MAX, INT32_MAX};\n            for (int j = 0; j < len; ++j) {\n                temp[j] = data[(i + j) % n];\n            }\n            vec1 = vld1q_s32(temp);\n\n            min_vec = vminq_s32(min_vec, vec1);\n            max_vec = vmaxq_s32(max_vec, vec1);\n        }\n    }\n\n    int32_t min_val[4], max_val[4];\n    vst1q_s32(min_val, min_vec);\n    vst1q_s32(max_val, max_vec);\n\n    int global_min = INT32_MAX, global_max = INT32_MIN;\n    for (int i = 0; i < 4; ++i) {\n        global_min = std::min(global_min, min_val[i]);\n        global_max = std::max(global_max, max_val[i]);\n    }\n\n    for (int i = 0; i < n; ++i) {\n        bool is_sorted = true;\n        for (int j = 0; j < n - 1; ++j) {\n            if (data[(i + j) % n] > data[(i + j + 1) % n]) {\n                is_sorted = false;\n                break;\n            }\n        }\n        if (is_sorted) return true;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_115_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n\n    int32_t* data = arr.data();\n    int32x4_t vec1, vec2, vec3, vec4;\n    int32x4_t min_vec = vdupq_n_s32(INT32_MAX);\n    int32x4_t max_vec = vdupq_n_s32(INT32_MIN);\n\n    for (int i = 0; i < n; i += 4) {\n        int len = std::min(4, n - i);\n        if (len == 4) {\n            vec1 = vld1q_s32(data + i);\n            vec2 = vld1q_s32(data + (i + 1) % n);\n            vec3 = vld1q_s32(data + (i + 2) % n);\n            vec4 = vld1q_s32(data + (i + 3) % n);\n\n            min_vec = vminq_s32(min_vec, vec1);\n            min_vec = vminq_s32(min_vec, vec2);\n            min_vec = vminq_s32(min_vec, vec3);\n            min_vec = vminq_s32(min_vec, vec4);\n\n            max_vec = vmaxq_s32(max_vec, vec1);\n            max_vec = vmaxq_s32(max_vec, vec2);\n            max_vec = vmaxq_s32(max_vec, vec3);\n            max_vec = vmaxq_s32(max_vec, vec4);\n        } else {\n            int32_t temp[4] = {INT32_MAX, INT32_MAX, INT32_MAX, INT32_MAX};\n            for (int j = 0; j < len; ++j) {\n                temp[j] = data[(i + j) % n];\n            }\n            vec1 = vld1q_s32(temp);\n\n            min_vec = vminq_s32(min_vec, vec1);\n            max_vec = vmaxq_s32(max_vec, vec1);\n        }\n    }\n\n    int32_t min_val[4], max_val[4];\n    vst1q_s32(min_val, min_vec);\n    vst1q_s32(max_val, max_vec);\n\n    int global_min = INT32_MAX, global_max = INT32_MIN;\n    for (int i = 0; i < 4; ++i) {\n        global_min = std::min(global_min, min_val[i]);\n        global_max = std::max(global_max, max_val[i]);\n    }\n\n    for (int i = 0; i < n; ++i) {\n        bool is_sorted = true;\n        for (int j = 0; j < n - 1; ++j) {\n            if (data[(i + j) % n] > data[(i + j + 1) % n]) {\n                is_sorted = false;\n                break;\n            }\n        }\n        if (is_sorted) return true;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_115_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n\n    int32_t* data = arr.data();\n    int32x4_t vec1, vec2, vec3;\n    int32x4_t min_vec = vdupq_n_s32(INT32_MAX);\n    int32x4_t max_vec = vdupq_n_s32(INT32_MIN);\n\n    for (int i = 0; i < n; i += 4) {\n        int len = std::min(n - i, 4);\n        if (len < 4) {\n            int32_t temp[4] = {INT32_MAX, INT32_MAX, INT32_MAX, INT32_MAX};\n            std::copy(data + i, data + i + len, temp);\n            vec1 = vld1q_s32(temp);\n        } else {\n            vec1 = vld1q_s32(data + i);\n        }\n\n        min_vec = vminq_s32(min_vec, vec1);\n        max_vec = vmaxq_s32(max_vec, vec1);\n    }\n\n    int32_t min_val[4], max_val[4];\n    vst1q_s32(min_val, min_vec);\n    vst1q_s32(max_val, max_vec);\n\n    int global_min = *std::min_element(min_val, min_val + 4);\n    int global_max = *std::max_element(max_val, max_val + 4);\n\n    for (int shift = 0; shift < n; ++shift) {\n        bool is_sorted = true;\n        for (int i = 0; i < n; i += 4) {\n            int len = std::min(n - i, 4);\n            if (len < 4) {\n                int32_t temp[4] = {INT32_MAX, INT32_MAX, INT32_MAX, INT32_MAX};\n                std::copy(data + (i + shift) % n, data + (i + shift + len) % n, temp);\n                vec1 = vld1q_s32(temp);\n            } else {\n                vec1 = vld1q_s32(data + (i + shift) % n);\n            }\n\n            if (i > 0) {\n                vec2 = vextq_s32(vec3, vec1, 3);\n                uint32x4_t mask = vcgtq_s32(vec2, vec1);\n                if (vmaxvq_u32(mask)) {\n                    is_sorted = false;\n                    break;\n                }\n            }\n            vec3 = vec1;\n        }\n        if (is_sorted) return true;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_116_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int32x4_t even_mask = vdupq_n_s32(0);\n    int32x4_t ones = vdupq_n_s32(1);\n\n    size_t i = 0;\n    for (; i + 4 <= lst1.size(); i += 4) {\n        int32x4_t vec1 = vld1q_s32(&lst1[i]);\n        even_mask = vorrq_s32(even_mask, vceqq_s32(vandq_s32(vec1, ones), vdupq_n_s32(0)));\n    }\n\n    for (size_t j = 0; j + 4 <= lst2.size(); j += 4) {\n        int32x4_t vec2 = vld1q_s32(&lst2[j]);\n        uint32x4_t odd_elements = vceqq_s32(vandq_s32(vec2, ones), vdupq_n_s32(1));\n        if (vmaxvq_u32(odd_elements) == 0) continue;\n\n        even_mask = vorrq_s32(even_mask, odd_elements);\n        if (vmaxvq_u32(vceqq_s32(even_mask, vdupq_n_s32(1))) == 1) return \"YES\";\n    }\n\n    for (; i < lst1.size(); ++i) {\n        if (lst1[i] % 2 != 0) {\n            bool has_odd_in_lst2 = false;\n            for (size_t j = 0; j < lst2.size(); ++j) {\n                if (lst2[j] % 2 != 0) {\n                    has_odd_in_lst2 = true;\n                    break;\n                }\n            }\n            if (!has_odd_in_lst2) return \"NO\";\n        }\n    }\n\n    return vmaxvq_u32(vceqq_s32(even_mask, vdupq_n_s32(1))) == 1 ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int32x4_t even_mask = vdupq_n_s32(0x7FFFFFFE); // Mask to check if a number is even\n\n    size_t n1 = lst1.size();\n    size_t n2 = lst2.size();\n\n    // Check lst1 for odd numbers\n    for (size_t i = 0; i <= n1 - 4; i += 4) {\n        int32x4_t vec1 = vld1q_s32(&lst1[i]);\n        uint32x4_t odd_check = vceqq_s32(vandq_s32(vec1, even_mask), vec1);\n        if (!vminvq_u32(odd_check)) { // If there's at least one odd number\n            // Check lst2 for even numbers\n            bool has_even_in_lst2 = false;\n            for (size_t j = 0; j <= n2 - 4; j += 4) {\n                int32x4_t vec2 = vld1q_s32(&lst2[j]);\n                uint32x4_t even_check = vceqq_s32(vandq_s32(vec2, even_mask), vec2);\n                if (vmaxvq_u32(even_check)) { // If there's at least one even number\n                    has_even_in_lst2 = true;\n                    break;\n                }\n            }\n            // Check remaining elements in lst2 if not already found\n            if (!has_even_in_lst2) {\n                for (size_t j = (n2 / 4) * 4; j < n2; ++j) {\n                    if ((lst2[j] & 1) == 0) {\n                        has_even_in_lst2 = true;\n                        break;\n                    }\n                }\n            }\n            if (!has_even_in_lst2) {\n                return \"NO\";\n            }\n        }\n    }\n\n    // Check remaining elements in lst1 if not already all even\n    for (size_t i = (n1 / 4) * 4; i < n1; ++i) {\n        if ((lst1[i] & 1) != 0) { // If the number is odd\n            // Check lst2 for even numbers\n            bool has_even_in_lst2 = false;\n            for (size_t j = 0; j <= n2 - 4; j += 4) {\n                int32x4_t vec2 = vld1q_s32(&lst2[j]);\n                uint32x4_t even_check = vceqq_s32(vandq_s32(vec2, even_mask), vec2);\n                if (vmaxvq_u32(even_check)) { // If there's at least one even number\n                    has_even_in_lst2 = true;\n                    break;\n                }\n            }\n            // Check remaining elements in lst2 if not already found\n            if (!has_even_in_lst2) {\n                for (size_t j = (n2 / 4) * 4; j < n2; ++j) {\n                    if ((lst2[j] & 1) == 0) {\n                        has_even_in_lst2 = true;\n                        break;\n                    }\n                }\n            }\n            if (!has_even_in_lst2) {\n                return \"NO\";\n            }\n        }\n    }\n\n    return \"YES\";\n}\n```"}
{"task_id": "SimdBench_116_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int32x4_t even_mask = vdupq_n_s32(0);\n    int32x4_t ones = vdupq_n_s32(1);\n\n    size_t i = 0;\n    for (; i + 4 <= lst1.size(); i += 4) {\n        int32x4_t vec1 = vld1q_s32(&lst1[i]);\n        even_mask = vorrq_s32(even_mask, vceqq_s32(vandq_s32(vec1, ones), vdupq_n_s32(0)));\n    }\n\n    for (i = 0; i + 4 <= lst2.size(); i += 4) {\n        int32x4_t vec2 = vld1q_s32(&lst2[i]);\n        even_mask = vorrq_s32(even_mask, vceqq_s32(vandq_s32(vec2, ones), vdupq_n_s32(0)));\n    }\n\n    if (i < lst1.size()) {\n        int32x4_t vec1 = vdupq_n_s32(0);\n        vst1q_s32((int32_t*)&vec1, &lst1[i]);\n        even_mask = vorrq_s32(even_mask, vceqq_s32(vandq_s32(vec1, ones), vdupq_n_s32(0)));\n    }\n\n    if (i < lst2.size()) {\n        int32x4_t vec2 = vdupq_n_s32(0);\n        vst1q_s32((int32_t*)&vec2, &lst2[i]);\n        even_mask = vorrq_s32(even_mask, vceqq_s32(vandq_s32(vec2, ones), vdupq_n_s32(0)));\n    }\n\n    uint32x4_t result = vceqq_s32(even_mask, vdupq_n_s32(0));\n    uint32_t final_result = vaddvq_u32(result);\n\n    return final_result == 0 ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int32x4_t even_mask = vdupq_n_s32(0);\n    int32x4_t ones = vdupq_n_s32(1);\n\n    size_t i = 0;\n    for (; i + 4 <= lst1.size(); i += 4) {\n        int32x4_t vec1 = vld1q_s32(&lst1[i]);\n        even_mask = vorrq_s32(even_mask, vceqq_s32(vandq_s32(vec1, ones), vdupq_n_s32(0)));\n    }\n\n    for (i = 0; i + 4 <= lst2.size(); i += 4) {\n        int32x4_t vec2 = vld1q_s32(&lst2[i]);\n        even_mask = vorrq_s32(even_mask, vceqq_s32(vandq_s32(vec2, ones), vdupq_n_s32(0)));\n    }\n\n    if (i < lst1.size()) {\n        int32x4_t vec1 = vdupq_n_s32(0);\n        vst1q_s32((int32_t*)&vec1, &lst1[i]);\n        even_mask = vorrq_s32(even_mask, vceqq_s32(vandq_s32(vec1, ones), vdupq_n_s32(0)));\n    }\n\n    if (i < lst2.size()) {\n        int32x4_t vec2 = vdupq_n_s32(0);\n        vst1q_s32((int32_t*)&vec2, &lst2[i]);\n        even_mask = vorrq_s32(even_mask, vceqq_s32(vandq_s32(vec2, ones), vdupq_n_s32(0)));\n    }\n\n    uint32x4_t result = vceqq_s32(even_mask, vdupq_n_s32(0));\n    uint32_t final_result = vaddvq_u32(result);\n\n    return final_result == 0 ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int32x4_t even_mask = vdupq_n_s32(0x7FFFFFFE); // Mask to check if a number is even\n\n    size_t n1 = lst1.size();\n    size_t n2 = lst2.size();\n\n    // Check lst1 for odd numbers\n    for (size_t i = 0; i <= n1 - 4; i += 4) {\n        int32x4_t vec1 = vld1q_s32(&lst1[i]);\n        uint32x4_t odd_check = vceqq_s32(vandq_s32(vec1, even_mask), vec1);\n        if (!vminvq_u32(odd_check)) { // If there's at least one odd number\n            // Check lst2 for even numbers\n            bool has_even_in_lst2 = false;\n            for (size_t j = 0; j <= n2 - 4; j += 4) {\n                int32x4_t vec2 = vld1q_s32(&lst2[j]);\n                uint32x4_t even_check = vceqq_s32(vandq_s32(vec2, even_mask), vec2);\n                if (vmaxvq_u32(even_check)) { // If there's at least one even number\n                    has_even_in_lst2 = true;\n                    break;\n                }\n            }\n            // Check remaining elements in lst2 if not already found an even number\n            for (size_t j = (n2 / 4) * 4; j < n2; ++j) {\n                if ((lst2[j] & 1) == 0) {\n                    has_even_in_lst2 = true;\n                    break;\n                }\n            }\n            if (!has_even_in_lst2) {\n                return \"NO\";\n            }\n        }\n    }\n\n    // Check remaining elements in lst1 if not already all even\n    for (size_t i = (n1 / 4) * 4; i < n1; ++i) {\n        if (lst1[i] & 1) { // If the number is odd\n            // Check lst2 for even numbers\n            bool has_even_in_lst2 = false;\n            for (size_t j = 0; j < n2; ++j) {\n                if ((lst2[j] & 1) == 0) {\n                    has_even_in_lst2 = true;\n                    break;\n                }\n            }\n            if (!has_even_in_lst2) {\n                return \"NO\";\n            }\n        }\n    }\n\n    return \"YES\";\n}\n```"}
{"task_id": "SimdBench_117_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        uint8x16_t odd_count = vdupq_n_u8(0);\n        size_t len = str.size();\n        size_t i = 0;\n        for (; i <= len - 16; i += 16) {\n            uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(str.c_str() + i));\n            uint8x16_t odds = vandq_u8(chars, vdupq_n_u8(1));\n            odd_count = vaddq_u8(odd_count, odds);\n        }\n        uint8_t odd_sum[16];\n        vst1q_u8(odd_sum, odd_count);\n        uint8_t total_odds = 0;\n        for (size_t j = 0; j < 16; ++j) {\n            total_odds += odd_sum[j];\n        }\n        for (; i < len; ++i) {\n            total_odds += (str[i] - '0') % 2;\n        }\n        std::string res = \"the number of odd elements \";\n        res += static_cast<char>('0' + total_odds);\n        res += \"n the str\";\n        res += static_cast<char>('0' + total_odds);\n        res += \"ng \";\n        res += static_cast<char>('0' + total_odds);\n        res += \" of the \";\n        res += static_cast<char>('0' + total_odds);\n        res += \"nput.\";\n        result.push_back(res);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        uint8x16_t odd_count = vdupq_n_u8(0);\n        size_t len = str.size();\n        size_t i = 0;\n        for (; i <= len - 16; i += 16) {\n            uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(str.c_str() + i));\n            uint8x16_t odds = vandq_u8(chars, vdupq_n_u8(1));\n            odd_count = vaddq_u8(odd_count, odds);\n        }\n        uint8_t odd_sum[16];\n        vst1q_u8(odd_sum, odd_count);\n        uint8_t total_odds = 0;\n        for (size_t j = 0; j < 16; ++j) {\n            total_odds += odd_sum[j];\n        }\n        for (; i < len; ++i) {\n            total_odds += (str[i] - '0') % 2;\n        }\n        std::string res = \"the number of odd elements \";\n        res += std::to_string(total_odds);\n        res += \"n the str\";\n        res += std::to_string(total_odds);\n        res += \"ng \";\n        res += std::to_string(total_odds);\n        res += \" of the \";\n        res += std::to_string(total_odds);\n        res += \"nput.\";\n        result.push_back(res);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        uint8x16_t odd_count = vdupq_n_u8(0);\n        size_t len = str.size();\n        size_t i = 0;\n\n        for (; i <= len - 16; i += 16) {\n            uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(str.c_str() + i));\n            uint8x16_t odds = vandq_u8(chars, vdupq_n_u8(1));\n            odd_count = vaddq_u8(odd_count, odds);\n        }\n\n        uint8_t odd_sum[16];\n        vst1q_u8(odd_sum, odd_count);\n\n        int total_odds = 0;\n        for (int j = 0; j < 16; ++j) {\n            total_odds += odd_sum[j];\n        }\n\n        for (; i < len; ++i) {\n            total_odds += (str[i] - '0') % 2;\n        }\n\n        std::string res = \"the number of odd elements \";\n        res += std::to_string(total_odds);\n        res += \"n the str\";\n        res += std::to_string(total_odds);\n        res += \"ng \";\n        res += std::to_string(total_odds);\n        res += \" of the \";\n        res += std::to_string(total_odds);\n        res += \"nput.\";\n        result.push_back(res);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        uint8x16_t odd_count = vdupq_n_u8(0);\n        size_t len = str.size();\n        size_t i = 0;\n\n        for (; i <= len - 16; i += 16) {\n            uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(str.c_str() + i));\n            uint8x16_t odds = vandq_u8(chars, vdupq_n_u8(1));\n            odd_count = vaddq_u8(odd_count, odds);\n        }\n\n        uint8_t odd_sum[16];\n        vst1q_u8(odd_sum, odd_count);\n\n        uint8_t total_odds = 0;\n        for (size_t j = 0; j < 16; ++j) {\n            total_odds += odd_sum[j];\n        }\n\n        for (; i < len; ++i) {\n            total_odds += (str[i] - '0') % 2;\n        }\n\n        std::string res = \"the number of odd elements \";\n        res += std::to_string(total_odds);\n        res += \"n the str\";\n        res += std::to_string(total_odds);\n        res += \"ng \";\n        res += std::to_string(total_odds);\n        res += \" of the \";\n        res += std::to_string(total_odds);\n        res += \"nput.\";\n        result.push_back(res);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        uint8x16_t odd_count = vdupq_n_u8(0);\n        size_t len = str.size();\n        size_t i = 0;\n        for (; i <= len - 16; i += 16) {\n            uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(str.c_str() + i));\n            uint8x16_t odds = vandq_u8(chars, vdupq_n_u8(1));\n            odd_count = vaddq_u8(odd_count, odds);\n        }\n        uint8_t odd_sum[16];\n        vst1q_u8(odd_sum, odd_count);\n        uint8_t total_odds = 0;\n        for (size_t j = 0; j < 16; ++j) {\n            total_odds += odd_sum[j];\n        }\n        for (; i < len; ++i) {\n            total_odds += (str[i] - '0') % 2;\n        }\n        std::string res = \"the number of odd elements \";\n        res += static_cast<char>('0' + total_odds);\n        res += \"n the str\";\n        res += static_cast<char>('0' + total_odds);\n        res += \"ng \";\n        res += static_cast<char>('0' + total_odds);\n        res += \" of the \";\n        res += static_cast<char>('0' + total_odds);\n        res += \"nput.\";\n        result.push_back(res);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_118_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    if (nums.empty()) return 0;\n\n    int64_t min_sum = std::numeric_limits<int64_t>::max();\n    int64_t current_min = 0;\n    size_t n = nums.size();\n\n    // Process 2 elements at a time\n    size_t i = 0;\n    for (; i <= n - 2; i += 2) {\n        int64x2_t num_vec = vld1q_s64(&nums[i]);\n        int64x2_t current_min_vec = vdupq_n_s64(current_min);\n        int64x2_t new_min_vec = vminq_s64(vaddq_s64(num_vec, current_min_vec), num_vec);\n        current_min = std::min(vgetq_lane_s64(new_min_vec, 0), vgetq_lane_s64(new_min_vec, 1));\n        min_sum = std::min(min_sum, current_min);\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        current_min = std::min(nums[i], current_min + nums[i]);\n        min_sum = std::min(min_sum, current_min);\n    }\n\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    if (nums.empty()) return 0;\n\n    int64_t min_sum = std::numeric_limits<int64_t>::max();\n    int64_t current_min = 0;\n    size_t n = nums.size();\n\n    // Process 2 elements at a time\n    size_t i = 0;\n    for (; i <= n - 2; i += 2) {\n        int64x2_t num_vec = vld1q_s64(&nums[i]);\n        int64x2_t current_min_vec = vdupq_n_s64(current_min);\n        int64x2_t new_min_vec = vminq_s64(vaddq_s64(num_vec, current_min_vec), num_vec);\n        current_min = std::min(vgetq_lane_s64(new_min_vec, 0), vgetq_lane_s64(new_min_vec, 1));\n        min_sum = std::min(min_sum, current_min);\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        current_min = std::min(nums[i], current_min + nums[i]);\n        min_sum = std::min(min_sum, current_min);\n    }\n\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    if (nums.empty()) return 0;\n\n    int64_t min_sum = std::numeric_limits<int64_t>::max();\n    int64_t current_min = 0;\n    size_t n = nums.size();\n\n    // Process 2 elements at a time\n    size_t i = 0;\n    for (; i <= n - 2; i += 2) {\n        int64x2_t num_vec = vld1q_s64(&nums[i]);\n        int64x2_t current_min_vec = vdupq_n_s64(current_min);\n        int64x2_t new_min_vec = vminq_s64(vaddq_s64(num_vec, current_min_vec), num_vec);\n        current_min = std::min(vgetq_lane_s64(new_min_vec, 0), vgetq_lane_s64(new_min_vec, 1));\n        min_sum = std::min(min_sum, current_min);\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        current_min = std::min(nums[i], current_min + nums[i]);\n        min_sum = std::min(min_sum, current_min);\n    }\n\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    if (nums.empty()) return 0;\n\n    int64_t min_sum = std::numeric_limits<int64_t>::max();\n    int64_t current_min = 0;\n    size_t n = nums.size();\n    size_t i = 0;\n\n    // Process 2 elements at a time using int64x2_t\n    for (; i <= n - 2; i += 2) {\n        int64x2_t num_vec = vld1q_s64(&nums[i]);\n        int64x2_t current_min_vec = vdupq_n_s64(current_min);\n        int64x2_t new_min_vec = vminq_s64(vaddq_s64(num_vec, current_min_vec), num_vec);\n        int64_t new_mins[2];\n        vst1q_s64(new_mins, new_min_vec);\n\n        current_min = std::min(new_mins[0], new_mins[1]);\n        min_sum = std::min(min_sum, current_min);\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        current_min = std::min(nums[i], current_min + nums[i]);\n        min_sum = std::min(min_sum, current_min);\n    }\n\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    if (nums.empty()) return 0;\n\n    int64_t min_sum = std::numeric_limits<int64_t>::max();\n    int64_t current_min = 0;\n    size_t n = nums.size();\n\n    // Process 2 elements at a time\n    size_t i = 0;\n    for (; i <= n - 2; i += 2) {\n        int64x2_t num_vec = vld1q_s64(&nums[i]);\n        int64x2_t current_min_vec = vdupq_n_s64(current_min);\n        int64x2_t new_min_vec = vminq_s64(vaddq_s64(num_vec, current_min_vec), num_vec);\n        int64_t new_mins[2];\n        vst1q_s64(new_mins, new_min_vec);\n\n        current_min = std::min(new_mins[0], new_mins[1]);\n        min_sum = std::min(min_sum, current_min);\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        current_min = std::min(nums[i], current_min + nums[i]);\n        min_sum = std::min(min_sum, current_min);\n    }\n\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_119_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    int total_drops = 0;\n    int num_rows = grid.size();\n    if (num_rows == 0) return 0;\n    int num_cols = grid[0].size();\n    \n    for (int i = 0; i < num_rows; ++i) {\n        const int* row = grid[i].data();\n        int drops_in_row = 0;\n        \n        // Process 16 elements at a time\n        for (int j = 0; j <= num_cols - 16; j += 16) {\n            uint8x16_t row_vec = vld1q_u8(reinterpret_cast<const uint8_t*>(row + j));\n            uint8x16_t ones = vcntq_u8(row_vec);\n            uint32x4_t sum1 = vpaddlq_u8(ones);\n            uint32x2_t sum2 = vpadd_u32(vget_low_u32(sum1), vget_high_u32(sum1));\n            uint32_t sum3 = vget_lane_u32(vpaddl_u32(sum2), 0);\n            drops_in_row += sum3;\n        }\n        \n        // Handle remaining elements\n        for (int j = (num_cols / 16) * 16; j < num_cols; ++j) {\n            drops_in_row += row[j];\n        }\n        \n        total_drops += (drops_in_row + capacity - 1) / capacity;\n    }\n    \n    return total_drops;\n}\n```"}
{"task_id": "SimdBench_119_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    int total_drops = 0;\n    int num_rows = grid.size();\n    if (num_rows == 0) return 0;\n    int num_cols = grid[0].size();\n    int num_simd_elements = 16 / sizeof(int); // NEON works with 128-bit registers, which can hold 4 integers\n\n    for (int i = 0; i < num_rows; ++i) {\n        const int* row = grid[i].data();\n        int drops_in_row = 0;\n\n        for (int j = 0; j <= num_cols - num_simd_elements; j += num_simd_elements) {\n            int32x4_t v = vld1q_s32(&row[j]);\n            uint32x4_t ones = vcgtq_s32(v, vdupq_n_s32(0));\n            uint32x2_t sum1 = vpadd_u32(vget_low_u32(ones), vget_high_u32(ones));\n            uint32x2_t sum2 = vpadd_u32(sum1, sum1);\n            drops_in_row += vget_lane_u32(sum2, 0);\n        }\n\n        // Handle remaining elements\n        for (int j = (num_cols / num_simd_elements) * num_simd_elements; j < num_cols; ++j) {\n            drops_in_row += row[j];\n        }\n\n        total_drops += (drops_in_row + capacity - 1) / capacity; // Ceiling division\n    }\n\n    return total_drops;\n}\n```"}
{"task_id": "SimdBench_119_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    int total_dips = 0;\n    int num_rows = grid.size();\n    if (num_rows == 0) return 0;\n    int num_cols = grid[0].size();\n    int num_simd_elements = 16 / sizeof(int); // NEON works with 128-bit registers, which can hold 4 integers\n\n    for (int i = 0; i < num_rows; ++i) {\n        const int* row = grid[i].data();\n        int row_sum = 0;\n        int j = 0;\n\n        // Process elements in chunks of 4 using NEON\n        for (; j <= num_cols - num_simd_elements; j += num_simd_elements) {\n            int32x4_t v = vld1q_s32(&row[j]);\n            int32x4_t ones = vcntq_u8(vreinterpretq_u8_s32(v));\n            int32x2_t ones_lo = vpaddl_s16(vreinterpretq_s16_u8(vget_low_u8(ones)));\n            int32x2_t ones_hi = vpaddl_s16(vreinterpretq_s16_u8(vget_high_u8(ones)));\n            int32x2_t ones_total = vadd_s32(ones_lo, ones_hi);\n            row_sum += vget_lane_s32(ones_total, 0) + vget_lane_s32(ones_total, 1);\n        }\n\n        // Process remaining elements\n        for (; j < num_cols; ++j) {\n            row_sum += row[j];\n        }\n\n        // Calculate the number of dips for this row\n        total_dips += (row_sum + capacity - 1) / capacity;\n    }\n\n    return total_dips;\n}\n```"}
{"task_id": "SimdBench_119_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    int total_dips = 0;\n    int num_rows = grid.size();\n    if (num_rows == 0) return 0;\n    int num_cols = grid[0].size();\n    int num_simd_elements = 16 / sizeof(int); // NEON works with 128-bit registers, which can hold 4 integers\n\n    for (int i = 0; i < num_rows; ++i) {\n        int row_sum = 0;\n        int j = 0;\n        for (; j <= num_cols - num_simd_elements; j += num_simd_elements) {\n            int32x4_t row_vec = vld1q_s32(&grid[i][j]);\n            int32x4_t ones_count = vcntq_u8(vreinterpretq_u8_s32(row_vec));\n            int ones_sum = vaddvq_u32(vpaddlq_u16(vpaddlq_u8(ones_count)));\n            row_sum += ones_sum;\n        }\n        for (; j < num_cols; ++j) {\n            row_sum += grid[i][j];\n        }\n        total_dips += (row_sum + capacity - 1) / capacity; // Ceiling division\n    }\n    return total_dips;\n}\n```"}
{"task_id": "SimdBench_119_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    int total_dips = 0;\n    int num_rows = grid.size();\n    if (num_rows == 0) return 0;\n    int num_cols = grid[0].size();\n    int num_simd_elements = 16 / sizeof(int); // NEON works with 128-bit registers, which can hold 4 integers\n\n    for (int i = 0; i < num_rows; ++i) {\n        const int* row = grid[i].data();\n        int row_sum = 0;\n        int j = 0;\n\n        // Process elements in chunks of 4 using NEON\n        for (; j <= num_cols - num_simd_elements; j += num_simd_elements) {\n            int32x4_t v = vld1q_s32(&row[j]);\n            int32x4_t ones = vcntq_u8(vreinterpretq_u8_s32(v));\n            int32x2_t ones_lo = vpadd_s32(vget_low_s32(ones), vget_high_s32(ones));\n            int sum = vget_lane_s32(vpaddl_s32(ones_lo), 0);\n            row_sum += sum;\n        }\n\n        // Process remaining elements\n        for (; j < num_cols; ++j) {\n            row_sum += row[j];\n        }\n\n        // Calculate the number of dips for this row\n        total_dips += (row_sum + capacity - 1) / capacity;\n    }\n\n    return total_dips;\n}\n```"}
{"task_id": "SimdBench_120_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    size_t n = lst.size();\n    const int16_t* ptr = lst.data();\n\n    // Process 8 elements at a time\n    for (size_t i = 0; i <= n - 8; i += 8, ptr += 8) {\n        int16x8_t vec = vld1q_s16(ptr);\n        int16x8_t even_indices = vdupq_n_s16(0);\n        int16x8_t mask = veorq_s16(even_indices, vreinterpretq_s16_u16(vshrq_n_u16(vreinterpretq_u16_s16(vec), 15)));\n        int16x8_t odd_elements = vandq_s16(vec, mask);\n        int16x8_t even_positions = vandq_s16(odd_elements, vcreate_s16((uint64_t)0xAAAAAAAAAAAAAAAA));\n        int32x4_t sum1 = vpaddlq_s16(even_positions);\n        int32x2_t sum2 = vpadd_s32(sum1);\n        int32x2_t sum3 = vpadd_s32(vcombine_s32(sum2, vdup_n_s32(0)));\n        sum += vget_lane_s32(sum3, 0);\n    }\n\n    // Handle remaining elements\n    for (size_t i = (n / 8) * 8; i < n; ++i) {\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    size_t n = lst.size();\n    const int16_t* ptr = lst.data();\n\n    // Process 8 elements at a time\n    for (size_t i = 0; i <= n - 8; i += 8, ptr += 8) {\n        int16x8_t vec = vld1q_s16(ptr);\n        int16x8_t even_positions = vsetq_lane_s16(vgetq_lane_s16(vec, 0), vsetq_lane_s16(vgetq_lane_s16(vec, 2), vsetq_lane_s16(vgetq_lane_s16(vec, 4), vsetq_lane_s16(vgetq_lane_s16(vec, 6), vdupq_n_s16(0)))), 0);\n        int16x8_t odd_mask = vandq_s16(even_positions, vdupq_n_s16(1));\n        int16x8_t odd_elements = vandq_s16(even_positions, odd_mask);\n        int32x4_t sum_pairs = vpaddlq_s16(odd_elements);\n        int32x2_t sum_quads = vpadd_s32(sum_pairs);\n        int32_t sum_octa = vget_lane_s32(vpaddl_s32(sum_quads), 0);\n        sum += sum_octa;\n    }\n\n    // Handle remaining elements\n    for (size_t i = (n / 8) * 8; i < n; i += 2) {\n        if (i + 1 < n && (lst[i] & 1)) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    size_t n = lst.size();\n    const int16_t* ptr = lst.data();\n\n    // Process 8 elements at a time\n    for (size_t i = 0; i <= n - 8; i += 8, ptr += 8) {\n        int16x8_t vec = vld1q_s16(ptr);\n        int16x8_t even_indices = vdupq_n_s16(0); // 0, 1, 2, 3, 4, 5, 6, 7\n        int16x8_t mask = vceqq_s16(even_indices, veorq_s16(even_indices, vdupq_n_s16(1))); // 1, 0, 1, 0, 1, 0, 1, 0\n        int16x8_t even_positions = vandq_s16(vec, mask);\n\n        int16x8_t odd_mask = vandq_s16(even_positions, vdupq_n_s16(1)); // Check if the number is odd\n        int16x8_t odd_numbers = vandq_s16(even_positions, odd_mask);\n\n        int32x4_t sum_low = vpaddlq_s16(vget_low_s16(odd_numbers));\n        int32x4_t sum_high = vpaddlq_s16(vget_high_s16(odd_numbers));\n        int32x2_t sum_pair = vadd_s32(vget_low_s32(sum_low), vget_high_s32(sum_low));\n        sum_pair = vadd_s32(sum_pair, vadd_s32(vget_low_s32(sum_high), vget_high_s32(sum_high)));\n\n        sum += vget_lane_s32(sum_pair, 0) + vget_lane_s32(sum_pair, 1);\n    }\n\n    // Handle remaining elements\n    for (size_t i = (n / 8) * 8; i < n; ++i) {\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    size_t n = lst.size();\n    const int16_t* ptr = lst.data();\n\n    // Process 8 elements at a time\n    for (size_t i = 0; i <= n - 8; i += 8, ptr += 8) {\n        int16x8_t vec = vld1q_s16(ptr);\n        int16x8_t even_indices = vdupq_n_s16(0);\n        int16x8_t mask = veorq_s16(even_indices, vreinterpretq_s16_u16(vshrq_n_u16(vreinterpretq_u16_s16(vec), 15)));\n        int16x8_t odd_elements = vandq_s16(vec, mask);\n        int16x8_t even_positions = vandq_s16(odd_elements, vcreate_s16((uint64_t)0xAAAAAAAAAAAAAAAA));\n        int32x4_t sum1 = vpaddlq_s16(even_positions);\n        int32x2_t sum2 = vpadd_s32(sum1);\n        int32x2_t sum3 = vpadd_s32(vcombine_s32(sum2, vdup_n_s32(0)));\n        sum += vget_lane_s32(sum3, 0);\n    }\n\n    // Handle remaining elements\n    for (size_t i = (n / 8) * 8; i < n; ++i) {\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    size_t n = lst.size();\n    const int16_t* ptr = lst.data();\n\n    // Process 8 elements at a time\n    for (size_t i = 0; i <= n - 8; i += 8, ptr += 8) {\n        int16x8_t vec = vld1q_s16(ptr);\n        int16x8_t even_indices = vdupq_n_s16(0); // 0, 1, 2, 3, 4, 5, 6, 7\n        int16x8_t mask = vceqq_s16(even_indices, veorq_s16(vshrq_n_s16(even_indices, 1), vshrq_n_s16(even_indices, 0)));\n        int16x8_t filtered = vandq_s16(vec, mask);\n        int16x8_t odd_elements = vandq_s16(filtered, vdupq_n_s16(1));\n        int32x4_t sum_pairs = vpaddlq_s16(odd_elements);\n        int32x2_t sum_quads = vpadd_s32(sum_pairs);\n        int32_t sum_eights = vaddv_s32(sum_quads);\n        sum += sum_eights;\n    }\n\n    // Handle remaining elements\n    for (size_t i = (n / 8) * 8; i < n; ++i) {\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int* ptr = arr.data();\n    int n = (k + 3) & ~3; // Round up to the nearest multiple of 4\n\n    for (int i = 0; i < n; i += 4) {\n        int32x4_t vec = vld1q_s32(ptr + i);\n        uint32x4_t mask = vcltq_s32(vec, vdupq_n_s32(100));\n        int32x4_t filtered = vandq_s32(vec,vreinterpretq_s32_u32(mask));\n        int32x2_t sum_pair = vpadd_s32(vget_low_s32(filtered), vget_high_s32(filtered));\n        sum += vget_lane_s32(vpaddl_s32(sum_pair), 0);\n    }\n\n    // Subtract the excess elements if k is not a multiple of 4\n    for (int i = k; i < n; ++i) {\n        if (arr[i] < 100) {\n            sum -= arr[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int* ptr = arr.data();\n    int n = (k + 3) & ~3; // Round up to the nearest multiple of 4\n\n    for (int i = 0; i < n; i += 4) {\n        int32x4_t vec = vld1q_s32(ptr + i);\n        uint32x4_t mask = vcgtq_s32(vec, vdupq_n_s32(99));\n        int32x4_t filtered = vbslq_s32(mask, vdupq_n_s32(0), vec);\n        sum += vaddvq_s32(filtered);\n    }\n\n    // Subtract the excess elements if k is not a multiple of 4\n    for (int i = k; i < n; ++i) {\n        sum -= arr[i];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int* ptr = arr.data();\n    int n = (k + 3) & ~3; // Round up to the nearest multiple of 4\n\n    for (int i = 0; i < n; i += 4) {\n        int32x4_t vec = vld1q_s32(ptr + i);\n        uint32x4_t mask = vcltq_s32(vec, vdupq_n_s32(100));\n        int32x4_t filtered = vandq_s32(vec,vreinterpretq_s32_u32(mask));\n        int32x2_t sum_pair = vpadd_s32(vget_low_s32(filtered), vget_high_s32(filtered));\n        sum += vget_lane_s32(vpaddl_s32(sum_pair), 0);\n    }\n\n    // Subtract the elements that were added but should not have been\n    for (int i = k; i < n; ++i) {\n        if (arr[i] >= 100) {\n            sum -= arr[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int* ptr = arr.data();\n    int n = (k + 3) & ~3; // Round up to the nearest multiple of 4\n\n    for (int i = 0; i < n; i += 4) {\n        int32x4_t vec = vld1q_s32(ptr + i);\n        uint32x4_t mask = vcltq_s32(vec, vdupq_n_s32(100));\n        int32x4_t filtered = vandq_s32(vec,vreinterpretq_s32_u32(mask));\n        int32x2_t sum_pair = vpadd_s32(vget_low_s32(filtered), vget_high_s32(filtered));\n        sum += vget_lane_s32(vpaddl_s32(sum_pair), 0);\n    }\n\n    // Subtract the excess elements if k is not a multiple of 4\n    for (int i = k; i < n; ++i) {\n        if (arr[i] < 100) {\n            sum -= arr[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int* ptr = arr.data();\n    int n = (k + 3) & ~3; // Round up to the nearest multiple of 4\n\n    for (int i = 0; i < n; i += 4) {\n        int32x4_t vec = vld1q_s32(ptr + i);\n        uint32x4_t mask = vcltq_s32(vec, vdupq_n_s32(100));\n        int32x4_t filtered = vandq_s32(vec,vreinterpretq_s32_u32(mask));\n        int32x2_t sum_pair = vpadd_s32(vget_low_s32(filtered), vget_high_s32(filtered));\n        sum += vget_lane_s32(vpadd_s32(sum_pair, sum_pair), 0);\n    }\n\n    // Subtract the excess elements if k is not a multiple of 4\n    for (int i = k; i < n; ++i) {\n        if (arr[i] < 100) {\n            sum -= arr[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_122_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    int n = lst.size();\n    if (n <= 1) return true;\n\n    uint32x4_t prev = vld1q_u32(reinterpret_cast<const uint32_t*>(&lst[0]));\n    uint32x4_t ones = vdupq_n_u32(1);\n    uint32x4_t mask = vdupq_n_u32(0xFFFFFFFF);\n\n    for (int i = 4; i < n; i += 4) {\n        uint32x4_t curr = vld1q_u32(reinterpret_cast<const uint32_t*>(&lst[i]));\n        uint32x4_t diff = vsubq_u32(curr, prev);\n        uint32x4_t cmp1 = vcltq_u32(prev, curr);\n        uint32x4_t cmp2 = vceqq_u32(diff, ones);\n        uint32x4_t result = vandq_u32(cmp1, cmp2);\n        uint32x4_t not_result = vmvnq_u32(result);\n        if (vgetq_lane_u32(not_result, 0) || vgetq_lane_u32(not_result, 1) ||\n            vgetq_lane_u32(not_result, 2) || vgetq_lane_u32(not_result, 3)) {\n            return false;\n        }\n        prev = curr;\n    }\n\n    for (int i = (n / 4) * 4; i < n - 1; ++i) {\n        if (lst[i] >= lst[i + 1]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    int n = lst.size();\n    if (n <= 1) return true;\n\n    uint32x4_t prev = vld1q_u32(reinterpret_cast<const uint32_t*>(&lst[0]));\n    uint32x4_t ones = vdupq_n_u32(1);\n    uint32x4_t mask = vdupq_n_u32(0xFFFFFFFF);\n\n    for (int i = 4; i < n; i += 4) {\n        uint32x4_t curr = vld1q_u32(reinterpret_cast<const uint32_t*>(&lst[i]));\n        uint32x4_t diff = vsubq_u32(curr, prev);\n        uint32x4_t cmp1 = vcltq_u32(prev, curr);\n        uint32x4_t cmp2 = vceqq_u32(diff, ones);\n        uint32x4_t result = vandq_u32(cmp1, cmp2);\n        if (vmovemaskq_u32(vceqq_u32(result, mask)) != 0xF) {\n            return false;\n        }\n        prev = curr;\n    }\n\n    for (int i = (n / 4) * 4; i < n - 1; ++i) {\n        if (lst[i] >= lst[i + 1]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    if (lst.size() <= 1) return true;\n\n    uint32x4_t prev = vld1q_u32(reinterpret_cast<const uint32_t*>(&lst[0]));\n    uint32x4_t ones = vdupq_n_u32(1);\n    uint32x4_t mask = vdupq_n_u32(0xFFFFFFFF);\n\n    for (size_t i = 4; i < lst.size(); i += 4) {\n        uint32x4_t curr = vld1q_u32(reinterpret_cast<const uint32_t*>(&lst[i]));\n\n        uint32x4_t ge = vcgeq_u32(curr, prev);\n        uint32x4_t eq = vceqq_u32(curr, prev);\n\n        uint32x4_t ge_shifted = vextq_u32(prev, curr, 3);\n        uint32x4_t ge_check = vcgeq_u32(curr, ge_shifted);\n\n        uint32x4_t eq_shifted = vextq_u32(prev, curr, 3);\n        uint32x4_t eq_check = vceqq_u32(curr, eq_shifted);\n\n        uint32x4_t result_ge = vandq_u32(ge, ge_check);\n        uint32x4_t result_eq = vandq_u32(eq, veorq_u32(eq_check, ones));\n\n        uint32x4_t final_result = vandq_u32(result_ge, result_eq);\n\n        if (vmovemaskq_u32(vceqq_u32(final_result, mask)) != 0xF) {\n            return false;\n        }\n\n        prev = curr;\n    }\n\n    // Handle remaining elements\n    for (size_t i = (lst.size() / 4) * 4; i < lst.size() - 1; ++i) {\n        if (lst[i] > lst[i + 1] || (i > 0 && lst[i] == lst[i - 1] && lst[i] == lst[i + 1])) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    if (lst.size() <= 1) return true;\n\n    uint32x4_t prev = vld1q_u32(reinterpret_cast<const uint32_t*>(&lst[0]));\n    uint32x4_t ones = vdupq_n_u32(1);\n    uint32x4_t mask = vdupq_n_u32(0xFFFFFFFF);\n\n    for (size_t i = 4; i < lst.size(); i += 4) {\n        uint32x4_t curr = vld1q_u32(reinterpret_cast<const uint32_t*>(&lst[i]));\n\n        uint32x4_t ge = vcgeq_u32(curr, prev);\n        uint32x4_t eq = vceqq_u32(curr, prev);\n\n        uint32x4_t ge_shifted = vextq_u32(ge, ge, 1);\n        uint32x4_t eq_shifted = vextq_u32(eq, eq, 1);\n\n        uint32x4_t not_sorted = vmvnq_u32(vandq_u32(ge, ge_shifted));\n        uint32x4_t duplicates = vandq_u32(eq, eq_shifted);\n\n        if (vmaxvq_u32(not_sorted) != 0 || vmaxvq_u32(duplicates) != 0) {\n            return false;\n        }\n\n        prev = curr;\n    }\n\n    // Handle remaining elements\n    for (size_t i = (lst.size() / 4) * 4; i < lst.size() - 1; ++i) {\n        if (lst[i] > lst[i + 1] || (i > 0 && lst[i] == lst[i - 1] && lst[i] == lst[i + 1])) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    if (lst.size() <= 1) return true;\n\n    uint32x4_t prev = vld1q_u32(reinterpret_cast<const uint32_t*>(&lst[0]));\n    uint32x4_t ones = vdupq_n_u32(1);\n    uint32x4_t mask = vdupq_n_u32(0xFFFFFFFF);\n\n    for (size_t i = 4; i < lst.size(); i += 4) {\n        uint32x4_t curr = vld1q_u32(reinterpret_cast<const uint32_t*>(&lst[i]));\n\n        uint32x4_t ge = vcgeq_u32(curr, prev);\n        uint32x4_t eq = vceqq_u32(curr, prev);\n\n        uint32x4_t shifted_eq = vextq_u32(eq, eq, 1);\n        uint32x4_t any_eq = vandq_u32(eq, shifted_eq);\n        uint32x4_t any_ge = vmvnq_u32(ge);\n\n        if (vmaxvq_u32(any_eq) || vmaxvq_u32(any_ge)) {\n            return false;\n        }\n\n        prev = curr;\n    }\n\n    // Handle remaining elements\n    for (size_t i = (lst.size() / 4) * 4; i < lst.size() - 1; ++i) {\n        if (lst[i] >= lst[i + 1] || (i > 0 && lst[i] == lst[i - 1])) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_123_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr){\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int32x4_t sum_magnitudes = vdupq_n_s32(0);\n    int32x4_t prod_signs = vdupq_n_s32(1);\n\n    size_t i = 0;\n    for (; i + 4 <= arr.size(); i += 4) {\n        int32x4_t vec = vld1q_s32(&arr[i]);\n        int32x4_t abs_vec = vabsq_s32(vec);\n        sum_magnitudes = vaddq_s32(sum_magnitudes, abs_vec);\n\n        int32x4_t sign_vec = vcombine_s32(\n            vneg_s32(vclt_s32(vget_low_s32(vec), vdup_n_s32(0))),\n            vneg_s32(vclt_s32(vget_high_s32(vec), vdup_n_s32(0)))\n        );\n        sign_vec = vorrq_s32(sign_vec, veorq_s32(vceqq_s32(vec, vdupq_n_s32(0)), vdupq_n_s32(-1)));\n        prod_signs = vmulq_s32(prod_signs, sign_vec);\n    }\n\n    int32_t sum_magnitudes_scalar = vaddvq_s32(sum_magnitudes);\n    int32_t prod_signs_scalar = vaddvq_s32(prod_signs);\n\n    for (; i < arr.size(); ++i) {\n        sum_magnitudes_scalar += std::abs(arr[i]);\n        prod_signs_scalar *= (arr[i] > 0) - (arr[i] < 0);\n    }\n\n    return sum_magnitudes_scalar * prod_signs_scalar;\n}\n```"}
{"task_id": "SimdBench_123_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr){\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int32x4_t sum_magnitudes = vdupq_n_s32(0);\n    int32x4_t prod_signs = vdupq_n_s32(1);\n\n    size_t i = 0;\n    for (; i + 4 <= arr.size(); i += 4) {\n        int32x4_t values = vld1q_s32(&arr[i]);\n        int32x4_t magnitudes = vabsq_s32(values);\n        sum_magnitudes = vaddq_s32(sum_magnitudes, magnitudes);\n\n        int32x4_t signs = vshrq_n_s31(vsubq_s32(values, vdupq_n_s32(0)));\n        signs = vaddq_s32(signs, vdupq_n_s32(1));\n        prod_signs = vmulq_s32(prod_signs, signs);\n    }\n\n    int32_t sum_magnitudes_scalar = vaddvq_s32(sum_magnitudes);\n    int32_t prod_signs_scalar = vaddvq_s32(prod_signs);\n\n    for (; i < arr.size(); ++i) {\n        int value = arr[i];\n        sum_magnitudes_scalar += std::abs(value);\n        prod_signs_scalar *= (value > 0) - (value < 0);\n    }\n\n    return sum_magnitudes_scalar * prod_signs_scalar;\n}\n```"}
{"task_id": "SimdBench_123_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr){\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int32x4_t sum_magnitudes = vdupq_n_s32(0);\n    int32x4_t prod_signs = vdupq_n_s32(1);\n\n    size_t i = 0;\n    for (; i + 4 <= arr.size(); i += 4) {\n        int32x4_t vec = vld1q_s32(&arr[i]);\n        int32x4_t abs_vec = vabsq_s32(vec);\n        sum_magnitudes = vaddq_s32(sum_magnitudes, abs_vec);\n\n        int32x4_t sign_vec = vcombine_s32(\n            vneg_s32(vclt_s32(vget_low_s32(vec), vdup_n_s32(0))),\n            vneg_s32(vclt_s32(vget_high_s32(vec), vdup_n_s32(0)))\n        );\n        sign_vec = vorrq_s32(sign_vec, veorq_s32(vceqq_s32(vec, vdupq_n_s32(0)), vdupq_n_s32(-1)));\n        prod_signs = vmulq_s32(prod_signs, sign_vec);\n    }\n\n    int32_t sum_magnitudes_scalar = vaddvq_s32(sum_magnitudes);\n    int32_t prod_signs_scalar = vaddvq_s32(prod_signs);\n\n    for (; i < arr.size(); ++i) {\n        sum_magnitudes_scalar += std::abs(arr[i]);\n        prod_signs_scalar *= (arr[i] > 0) - (arr[i] < 0);\n    }\n\n    return sum_magnitudes_scalar * prod_signs_scalar;\n}\n```"}
{"task_id": "SimdBench_123_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr){\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int32x4_t sum_magnitudes = vdupq_n_s32(0);\n    int32x4_t prod_signs = vdupq_n_s32(1);\n\n    size_t i = 0;\n    for (; i + 4 <= arr.size(); i += 4) {\n        int32x4_t values = vld1q_s32(&arr[i]);\n        int32x4_t abs_values = vabsq_s32(values);\n        sum_magnitudes = vaddq_s32(sum_magnitudes, abs_values);\n\n        int32x4_t signs = vshrq_n_s31(vsubq_s32(values, vdupq_n_s32(0)));\n        signs = vaddq_s32(signs, vdupq_n_s32(1));\n        prod_signs = vmulq_s32(prod_signs, signs);\n    }\n\n    int32_t sum_magnitudes_scalar = vaddvq_s32(sum_magnitudes);\n    int32_t prod_signs_scalar = vaddvq_s32(prod_signs);\n\n    for (; i < arr.size(); ++i) {\n        int value = arr[i];\n        sum_magnitudes_scalar += std::abs(value);\n        prod_signs_scalar *= (value > 0) - (value < 0);\n    }\n\n    return sum_magnitudes_scalar * prod_signs_scalar;\n}\n```"}
{"task_id": "SimdBench_123_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr){\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int32x4_t sum_magnitudes = vdupq_n_s32(0);\n    int32x4_t prod_signs = vdupq_n_s32(1);\n\n    size_t i = 0;\n    for (; i + 4 <= arr.size(); i += 4) {\n        int32x4_t values = vld1q_s32(&arr[i]);\n        int32x4_t abs_values = vabsq_s32(values);\n        sum_magnitudes = vaddq_s32(sum_magnitudes, abs_values);\n\n        int32x4_t signs = vcombine_s32(\n            vshrq_n_s31(vsubq_s32(values, vdupq_n_s32(0))),\n            vshrq_n_s31(vsubq_s32(values, vdupq_n_s32(0)))\n        );\n        signs = vorrq_s32(signs, vceqq_s32(values, vdupq_n_s32(0)));\n        signs = vsubq_s32(vdupq_n_s32(0), signs);\n        prod_signs = vmulq_s32(prod_signs, signs);\n    }\n\n    int32_t sum_magnitudes_scalar = vaddvq_s32(sum_magnitudes);\n    int32_t prod_signs_scalar = vaddvq_s32(prod_signs);\n\n    for (; i < arr.size(); ++i) {\n        int value = arr[i];\n        sum_magnitudes_scalar += std::abs(value);\n        prod_signs_scalar *= (value > 0) - (value < 0);\n    }\n\n    return sum_magnitudes_scalar * prod_signs_scalar;\n}\n```"}
{"task_id": "SimdBench_124_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k, INT_MAX);\n    int path[k];\n    \n    auto comparePaths = [&](const int* path1, const int* path2) {\n        int32x4_t v1 = vld1q_s32(path1);\n        int32x4_t v2 = vld1q_s32(path2);\n        uint32x4_t cmp = vcltq_s32(v1, v2);\n        uint32_t mask = vmovmskq_u32(cmp);\n        if (mask == 0xF) return true;\n        if (mask == 0x0) {\n            v1 = vld1q_s32(path1 + 4);\n            v2 = vld1q_s32(path2 + 4);\n            cmp = vcltq_s32(v1, v2);\n            mask = vmovmskq_u32(cmp);\n            if (mask == 0xF) return true;\n            if (mask == 0x0 && k > 8) {\n                if (path1[8] < path2[8]) return true;\n            }\n        }\n        return false;\n    };\n\n    auto dfs = [&](auto&& dfs, int x, int y, int depth) -> void {\n        if (depth == k) {\n            if (comparePaths(path, result.data())) {\n                std::copy(path, path + k, result.begin());\n            }\n            return;\n        }\n        static const int dx[] = {0, 0, 1, -1};\n        static const int dy[] = {1, -1, 0, 0};\n        path[depth] = grid[x][y];\n        for (int dir = 0; dir < 4; ++dir) {\n            int nx = x + dx[dir];\n            int ny = y + dy[dir];\n            if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n                dfs(dfs, nx, ny, depth + 1);\n            }\n        }\n    };\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            dfs(dfs, i, j, 0);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_124_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k, INT_MAX);\n    int min_start = *std::min_element(grid[0].begin(), grid[0].end());\n\n    for (int start_row = 0; start_row < N; ++start_row) {\n        for (int start_col = 0; start_col < N; ++start_col) {\n            if (grid[start_row][start_col] > min_start) continue;\n\n            std::vector<int> path;\n            path.push_back(grid[start_row][start_col]);\n\n            std::vector<std::pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n            std::vector<std::vector<bool>> visited(N, std::vector<bool>(N, false));\n            visited[start_row][start_col] = true;\n\n            while (path.size() < k) {\n                int current_row = path.size() > 0 ? start_row : -1;\n                int current_col = path.size() > 0 ? start_col : -1;\n                int min_next = INT_MAX;\n                int next_row = -1, next_col = -1;\n\n                for (const auto& dir : directions) {\n                    int new_row = current_row + dir.first;\n                    int new_col = current_col + dir.second;\n\n                    if (new_row >= 0 && new_row < N && new_col >= 0 && new_col < N && !visited[new_row][new_col]) {\n                        if (grid[new_row][new_col] < min_next) {\n                            min_next = grid[new_row][new_col];\n                            next_row = new_row;\n                            next_col = new_col;\n                        }\n                    }\n                }\n\n                if (next_row != -1 && next_col != -1) {\n                    path.push_back(grid[next_row][next_col]);\n                    visited[next_row][next_col] = true;\n                } else {\n                    break;\n                }\n            }\n\n            if (path.size() == k && path < result) {\n                result = path;\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_124_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k, INT_MAX);\n    int min_path[k];\n    \n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            int path[k];\n            path[0] = grid[i][j];\n            \n            for (int l = 1; l < k; ++l) {\n                int min_val = INT_MAX;\n                int min_x = 0, min_y = 0;\n                \n                // Check all 4 possible directions\n                static const int dx[] = {-1, 1, 0, 0};\n                static const int dy[] = {0, 0, -1, 1};\n                \n                for (int dir = 0; dir < 4; ++dir) {\n                    int ni = i + dx[dir];\n                    int nj = j + dy[dir];\n                    \n                    if (ni >= 0 && ni < N && nj >= 0 && nj < N) {\n                        if (grid[ni][nj] < min_val) {\n                            min_val = grid[ni][nj];\n                            min_x = ni;\n                            min_y = nj;\n                        }\n                    }\n                }\n                \n                path[l] = min_val;\n                i = min_x;\n                j = min_y;\n            }\n            \n            // Compare paths using NEON intrinsics\n            int32x4_t path_vec1 = vld1q_s32(path);\n            int32x4_t path_vec2 = vld1q_s32(result.data());\n            uint32x4_t cmp = vcltq_s32(path_vec1, path_vec2);\n            \n            if (vmaxvq_u32(cmp) != 0) {\n                std::copy(path, path + k, result.begin());\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_124_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k, INT_MAX);\n    int min_start = *std::min_element(grid[0].begin(), grid[0].end());\n\n    for (int start_row = 0; start_row < N; ++start_row) {\n        for (int start_col = 0; start_col < N; ++start_col) {\n            if (grid[start_row][start_col] > min_start) continue;\n\n            std::vector<int> path;\n            path.push_back(grid[start_row][start_col]);\n\n            std::vector<std::pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n            std::vector<std::vector<bool>> visited(N, std::vector<bool>(N, false));\n            visited[start_row][start_col] = true;\n\n            std::function<void(int, int, int)> dfs = [&](int row, int col, int depth) {\n                if (depth == k) {\n                    if (std::lexicographical_compare(path.begin(), path.end(), result.begin(), result.end())) {\n                        result = path;\n                    }\n                    return;\n                }\n\n                int16x8_t current_path = vdupq_n_s16(path.back());\n                for (const auto& dir : directions) {\n                    int new_row = row + dir.first;\n                    int new_col = col + dir.second;\n                    if (new_row >= 0 && new_row < N && new_col >= 0 && new_col < N && !visited[new_row][new_col]) {\n                        visited[new_row][new_col] = true;\n                        path.push_back(grid[new_row][new_col]);\n                        int16x8_t next_value = vdupq_n_s16(grid[new_row][new_col]);\n                        int16x8_t combined = vcombine_s16(vget_low_s16(current_path), vget_low_s16(next_value));\n                        if (vmaxvq_s16(combined) < vmaxvq_s16(vreinterpretq_s16_u16(vmovl_u8(vcreate_u8(__builtin_bswap32(*reinterpret_cast<uint32_t*>(&result[depth]))))))) {\n                            dfs(new_row, new_col, depth + 1);\n                        }\n                        path.pop_back();\n                        visited[new_row][new_col] = false;\n                    }\n                }\n            };\n\n            dfs(start_row, start_col, 1);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_124_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k, INT_MAX);\n    int min_start = *std::min_element(grid[0].begin(), grid[0].end());\n\n    for (int start_row = 0; start_row < N; ++start_row) {\n        for (int start_col = 0; start_col < N; ++start_col) {\n            if (grid[start_row][start_col] > min_start) continue;\n\n            std::vector<int> path;\n            path.push_back(grid[start_row][start_col]);\n\n            std::vector<std::pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n            std::vector<std::vector<bool>> visited(N, std::vector<bool>(N, false));\n            visited[start_row][start_col] = true;\n\n            std::function<void(int, int, int)> dfs = [&](int row, int col, int depth) {\n                if (depth == k) {\n                    if (std::lexicographical_compare(path.begin(), path.end(), result.begin(), result.end())) {\n                        result = path;\n                    }\n                    return;\n                }\n\n                int16x8_t current_path = vdupq_n_s16(path.back());\n                for (const auto& dir : directions) {\n                    int new_row = row + dir.first;\n                    int new_col = col + dir.second;\n                    if (new_row >= 0 && new_row < N && new_col >= 0 && new_col < N && !visited[new_row][new_col]) {\n                        visited[new_row][new_col] = true;\n                        path.push_back(grid[new_row][new_col]);\n                        int16x8_t next_value = vdupq_n_s16(grid[new_row][new_col]);\n                        uint16x8_t cmp = vcltq_u16(vreinterpretq_u16_s16(next_value), vreinterpretq_u16_s16(current_path));\n                        if (vmaxvq_u16(cmp)) {\n                            dfs(new_row, new_col, depth + 1);\n                        }\n                        path.pop_back();\n                        visited[new_row][new_col] = false;\n                    }\n                }\n            };\n\n            dfs(start_row, start_col, 1);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_125_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t digits_simd(uint64_t n) {\n    uint8x16_t ones = vdupq_n_u8(1);\n    uint8x16_t evens = vdupq_n_u8(0);\n    uint8x16_t product = vdupq_n_u8(1);\n    uint8x16_t has_odd = vdupq_n_u8(0);\n\n    while (n > 0) {\n        uint8x16_t digits = vdupq_n_u8(0);\n        for (int i = 0; i < 16 && n > 0; ++i) {\n            digits[i] = n % 10;\n            n /= 10;\n        }\n\n        uint8x16_t is_odd = vandq_u8(vceqq_u8(vandq_u8(digits, ones), ones), veorq_u8(digits, evens));\n        uint8x16_t odd_digits = vbslq_u8(is_odd, digits, ones);\n        product = vmulq_u8(product, odd_digits);\n        has_odd = vorrq_u8(has_odd, is_odd);\n    }\n\n    uint8_t result[16];\n    vst1q_u8(result, product);\n    uint8_t has_odd_result[16];\n    vst1q_u8(has_odd_result, has_odd);\n\n    uint64_t final_product = 1;\n    for (int i = 0; i < 16; ++i) {\n        final_product *= result[i];\n    }\n\n    uint64_t any_odd = 0;\n    for (int i = 0; i < 16; ++i) {\n        any_odd |= has_odd_result[i];\n    }\n\n    return any_odd ? final_product : 0;\n}\n```"}
{"task_id": "SimdBench_125_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t digits_simd(uint64_t n) {\n    uint8x16_t ones = vdupq_n_u8(1);\n    uint8x16_t evens = vdupq_n_u8(0);\n    uint8x16_t product = vdupq_n_u8(1);\n    uint8x16_t has_odd = vdupq_n_u8(0);\n\n    while (n > 0) {\n        uint8x16_t digits = vdupq_n_u8(0);\n        for (int i = 0; i < 16 && n > 0; ++i) {\n            digits[i] = n % 10;\n            n /= 10;\n        }\n\n        uint8x16_t is_odd = vandq_u8(vceqq_u8(vandq_u8(digits, ones), ones), vceqq_u8(digits, veorq_u8(digits, evens)));\n        uint8x16_t odd_digits = vbslq_u8(is_odd, digits, ones);\n        product = vmulq_u8(product, odd_digits);\n        has_odd = vorrq_u8(has_odd, is_odd);\n    }\n\n    uint8_t result[16];\n    vst1q_u8(result, product);\n    uint8_t has_odd_result[16];\n    vst1q_u8(has_odd_result, has_odd);\n\n    uint64_t final_product = 1;\n    for (int i = 0; i < 16; ++i) {\n        final_product *= result[i];\n    }\n\n    uint64_t any_odd = 0;\n    for (int i = 0; i < 16; ++i) {\n        any_odd |= has_odd_result[i];\n    }\n\n    return any_odd ? final_product : 0;\n}\n```"}
{"task_id": "SimdBench_125_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t digits_simd(uint64_t n) {\n    uint8x16_t ones = vdupq_n_u8(1);\n    uint8x16_t evens = vdupq_n_u8(0);\n    uint8x16_t product = vdupq_n_u8(1);\n    uint8x16_t has_odd = vdupq_n_u8(0);\n\n    while (n > 0) {\n        uint8x16_t digits = vdupq_n_u8(0);\n        for (int i = 0; i < 16 && n > 0; ++i) {\n            digits[i] = n % 10;\n            n /= 10;\n        }\n\n        uint8x16_t is_odd = vandq_u8(vceqq_u8(vandq_u8(digits, ones), ones), vceqq_u8(digits, veorq_u8(digits, evens)));\n        uint8x16_t odd_digits = vbslq_u8(is_odd, digits, ones);\n        product = vmulq_u8(product, odd_digits);\n        has_odd = vorrq_u8(has_odd, is_odd);\n    }\n\n    uint8_t result[16];\n    vst1q_u8(result, product);\n    uint8_t has_odd_result[16];\n    vst1q_u8(has_odd_result, has_odd);\n\n    uint64_t final_product = 1;\n    for (int i = 0; i < 16; ++i) {\n        final_product *= result[i];\n    }\n\n    uint64_t any_odd = 0;\n    for (int i = 0; i < 16; ++i) {\n        any_odd |= has_odd_result[i];\n    }\n\n    return any_odd ? final_product : 0;\n}\n```"}
{"task_id": "SimdBench_125_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t digits_simd(uint64_t n) {\n    uint8x16_t ones = vdupq_n_u8(1);\n    uint8x16_t evens = vdupq_n_u8(0);\n    uint8x16_t product = vdupq_n_u8(1);\n    uint8x16_t has_odd = vdupq_n_u8(0);\n\n    while (n > 0) {\n        uint8x16_t digits = vdupq_n_u8(0);\n        for (int i = 0; i < 16 && n > 0; ++i) {\n            digits[i] = n % 10;\n            n /= 10;\n        }\n\n        uint8x16_t is_odd = vandq_u8(vceqq_u8(vandq_u8(digits, ones), ones), vcmpneq_u8(digits, evens));\n        uint8x16_t odd_digits = vbslq_u8(is_odd, digits, ones);\n        product = vmulq_u8(product, odd_digits);\n        has_odd = vorrq_u8(has_odd, is_odd);\n    }\n\n    uint8_t result[16];\n    vst1q_u8(result, product);\n    uint8_t has_odd_result[16];\n    vst1q_u8(has_odd_result, has_odd);\n\n    uint64_t final_product = 1;\n    for (int i = 0; i < 16; ++i) {\n        final_product *= result[i];\n    }\n\n    return vgetq_lane_u8(has_odd, 0) ? final_product : 0;\n}\n```"}
{"task_id": "SimdBench_125_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t digits_simd(uint64_t n) {\n    uint8x16_t ones = vdupq_n_u8(1);\n    uint8x16_t evens = vdupq_n_u8(0);\n    uint8x16_t product = vdupq_n_u8(1);\n    uint8x16_t has_odd = vdupq_n_u8(0);\n\n    while (n > 0) {\n        uint8x16_t digits = vdupq_n_u8(0);\n        for (int i = 0; i < 16 && n > 0; ++i) {\n            digits[i] = n % 10;\n            n /= 10;\n        }\n\n        uint8x16_t is_odd = vandq_u8(vceqq_u8(vandq_u8(digits, ones), ones), vcmpneq_u8(digits, evens));\n        uint8x16_t odd_digits = vbslq_u8(is_odd, digits, ones);\n        product = vmulq_u8(product, odd_digits);\n        has_odd = vorrq_u8(has_odd, is_odd);\n    }\n\n    uint8_t result[16];\n    vst1q_u8(result, product);\n    uint8_t has_odd_result[16];\n    vst1q_u8(has_odd_result, has_odd);\n\n    uint64_t final_product = 1;\n    for (int i = 0; i < 16; ++i) {\n        final_product *= result[i];\n    }\n\n    uint64_t any_odd = 0;\n    for (int i = 0; i < 16; ++i) {\n        any_odd |= has_odd_result[i];\n    }\n\n    return any_odd ? final_product : 0;\n}\n```"}
{"task_id": "SimdBench_126_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    size_t i = 0;\n    size_t n = lst.size();\n\n    // Process 4 elements at a time\n    for (; i <= n - 4; i += 4) {\n        float32x4_t vec = vld1q_f32(&lst[i]);\n        float32x4_t ceil_vec = vceilq_f32(vec);\n        int32x4_t int_vec = vcvtq_s32_f32(ceil_vec);\n        int32x4_t square_vec = vmulq_s32(int_vec, int_vec);\n        int64x2_t long_square_vec = vpaddlq_s32(square_vec);\n        int64_t temp_sum = vpadalq_s32(&sum, long_square_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        int32_t val = static_cast<int32_t>(std::ceil(lst[i]));\n        sum += val * val;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    size_t i = 0;\n    size_t n = lst.size();\n    \n    // Process 4 elements at a time\n    for (; i <= n - 4; i += 4) {\n        float32x4_t vec = vld1q_f32(&lst[i]);\n        float32x4_t ceil_vec = vceilq_f32(vec);\n        int32x4_t int_vec = vcvtq_s32_f32(ceil_vec);\n        int32x4_t square_vec = vmulq_s32(int_vec, int_vec);\n        int64x2_t long_square_vec = vpaddlq_s32(square_vec);\n        int64_t temp_sum = vpadalq_s32(&sum, long_square_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < n; ++i) {\n        int val = static_cast<int>(std::ceil(lst[i]));\n        sum += val * val;\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    size_t i = 0;\n    size_t n = lst.size();\n\n    // Process 4 elements at a time\n    for (; i <= n - 4; i += 4) {\n        float32x4_t vec = vld1q_f32(&lst[i]);\n        float32x4_t ceil_vec = vceilq_f32(vec);\n        int32x4_t int_vec = vcvtq_s32_f32(ceil_vec);\n        int32x4_t square_vec = vmulq_s32(int_vec, int_vec);\n        uint64x2_t uint_square_vec = vmovl_u32(vget_low_u32(vreinterpretq_u32_s32(square_vec)));\n        uint64x2_t uint_square_vec_high = vmovl_u32(vget_high_u32(vreinterpretq_u32_s32(square_vec)));\n        sum += vgetq_lane_u64(uint_square_vec, 0) + vgetq_lane_u64(uint_square_vec, 1);\n        sum += vgetq_lane_u64(uint_square_vec_high, 0) + vgetq_lane_u64(uint_square_vec_high, 1);\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        int32_t val = static_cast<int32_t>(std::ceil(lst[i]));\n        sum += val * val;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    size_t i = 0;\n    size_t n = lst.size();\n    \n    // Process 4 elements at a time\n    for (; i <= n - 4; i += 4) {\n        float32x4_t vec = vld1q_f32(&lst[i]);\n        float32x4_t ceil_vec = vceilq_f32(vec);\n        int32x4_t int_vec = vcvtq_s32_f32(ceil_vec);\n        int32x4_t square_vec = vmulq_s32(int_vec, int_vec);\n        int64x2_t long_square_vec = vpaddlq_s32(square_vec);\n        int64_t temp_sum = vpadalq_s32(&sum, long_square_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < n; ++i) {\n        int32_t val = static_cast<int32_t>(std::ceil(lst[i]));\n        sum += val * val;\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    size_t i = 0;\n    size_t n = lst.size();\n    \n    // Process 4 elements at a time\n    for (; i <= n - 4; i += 4) {\n        float32x4_t vec = vld1q_f32(&lst[i]);\n        float32x4_t ceil_vec = vceilq_f32(vec);\n        int32x4_t int_vec = vcvtq_s32_f32(ceil_vec);\n        int32x4_t square_vec = vmulq_s32(int_vec, int_vec);\n        int64x2_t long_square_vec = vpaddlq_s32(square_vec);\n        int64_t temp_sum = vpadalq_s32(&sum, long_square_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < n; ++i) {\n        int32_t val = static_cast<int32_t>(std::ceil(lst[i]));\n        sum += val * val;\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_127_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n < 2) return -1;\n\n    int32x4_t prev_vec = vdupq_n_s32(arr[0]);\n    int32x4_t curr_vec;\n    int32x4_t cmp_vec;\n    uint32x4_t mask_vec;\n    uint32_t mask;\n\n    int result = -1;\n    for (int i = 1; i < n; i += 4) {\n        int load_count = std::min(4, n - i);\n        if (load_count == 4) {\n            curr_vec = vld1q_s32(&arr[i]);\n        } else {\n            int32_t temp[4] = {arr[i], arr[i+1], arr[i+2], arr[i+3]};\n            curr_vec = vld1q_s32(temp);\n        }\n\n        cmp_vec = vcgeq_s32(curr_vec, prev_vec);\n        mask_vec = vmvnq_u32(vreinterpretq_u32_s32(cmp_vec));\n        mask = vgetq_lane_u32(mask_vec, 0) | (vgetq_lane_u32(mask_vec, 1) << 1) |\n               (vgetq_lane_u32(mask_vec, 2) << 2) | (vgetq_lane_u32(mask_vec, 3) << 3);\n\n        if (mask != 0) {\n            for (int j = 0; j < load_count; ++j) {\n                if ((mask >> j) & 1) {\n                    result = i + j;\n                }\n            }\n        }\n\n        prev_vec = curr_vec;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n < 2) return -1;\n\n    int32x4_t vec_prev, vec_curr;\n    int32x4_t cmp_result;\n    uint32x4_t mask;\n    uint32_t mask_val;\n    int result = -1;\n\n    for (int i = 0; i <= n - 4; i += 4) {\n        vec_prev = vld1q_s32(&arr[i]);\n        vec_curr = vld1q_s32(&arr[i + 1]);\n\n        cmp_result = vcltq_s32(vec_curr, vec_prev);\n        mask = vreinterpretq_u32_s32(cmp_result);\n        mask_val = vgetq_lane_u32(mask, 0) | vgetq_lane_u32(mask, 1) | vgetq_lane_u32(mask, 2) | vgetq_lane_u32(mask, 3);\n\n        if (mask_val) {\n            for (int j = 0; j < 4; ++j) {\n                if (vgetq_lane_u32(mask, j)) {\n                    result = i + j + 1;\n                }\n            }\n        }\n    }\n\n    for (int i = (n / 4) * 4; i < n - 1; ++i) {\n        if (arr[i + 1] < arr[i]) {\n            result = i + 1;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n < 2) return -1;\n\n    int32x4_t prev_vec = vdupq_n_s32(arr[0]);\n    int32x4_t curr_vec;\n    int32x4_t cmp_vec;\n    uint32x4_t mask_vec;\n    uint32_t mask;\n    int result = -1;\n\n    for (int i = 1; i < n; i += 4) {\n        int load_size = std::min(4, n - i);\n        int32_t temp[4] = {0};\n        for (int j = 0; j < load_size; ++j) {\n            temp[j] = arr[i + j];\n        }\n        curr_vec = vld1q_s32(temp);\n\n        cmp_vec = vcltq_s32(curr_vec, prev_vec);\n        mask_vec = vreinterpretq_u32_s32(cmp_vec);\n        mask = vgetq_lane_u32(mask_vec, 0) | (vgetq_lane_u32(mask_vec, 1) << 1) |\n               (vgetq_lane_u32(mask_vec, 2) << 2) | (vgetq_lane_u32(mask_vec, 3) << 3);\n\n        if (mask != 0) {\n            for (int j = 0; j < load_size; ++j) {\n                if ((mask >> j) & 1) {\n                    result = i + j;\n                }\n            }\n        }\n\n        prev_vec = curr_vec;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n < 2) return -1;\n\n    int32x4_t prev_vec = vdupq_n_s32(arr[0]);\n    int32x4_t curr_vec;\n    int32x4_t cmp_vec;\n    uint32x4_t mask_vec;\n    uint32_t mask;\n    int result = -1;\n\n    for (int i = 1; i < n; i += 4) {\n        int load_count = std::min(4, n - i);\n        if (load_count < 4) {\n            int32_t temp[4] = {arr[i], arr[i+1], arr[i+2], arr[i+3]};\n            curr_vec = vld1q_s32(temp);\n        } else {\n            curr_vec = vld1q_s32(&arr[i]);\n        }\n\n        cmp_vec = vcgeq_s32(curr_vec, prev_vec);\n        mask_vec = vmvnq_u32(vreinterpretq_u32_s32(cmp_vec));\n        mask = vgetq_lane_u32(mask_vec, 0) | (vgetq_lane_u32(mask_vec, 1) << 1) |\n               (vgetq_lane_u32(mask_vec, 2) << 2) | (vgetq_lane_u32(mask_vec, 3) << 3);\n\n        if (mask != 0) {\n            for (int j = 0; j < load_count; ++j) {\n                if ((mask >> j) & 1) {\n                    result = i + j;\n                }\n            }\n        }\n\n        prev_vec = curr_vec;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n < 2) return -1;\n\n    int32x4_t prev_vec = vdupq_n_s32(arr[0]);\n    int32x4_t curr_vec;\n    int32x4_t cmp_vec;\n    uint32x4_t mask_vec;\n    uint32_t mask;\n\n    int result = -1;\n    for (int i = 1; i < n; i += 4) {\n        int load_count = std::min(4, n - i);\n        int32_t temp[4] = {0};\n        for (int j = 0; j < load_count; ++j) {\n            temp[j] = arr[i + j];\n        }\n        curr_vec = vld1q_s32(temp);\n\n        cmp_vec = vcltq_s32(curr_vec, prev_vec);\n        mask_vec = vandq_u32(vreinterpretq_u32_s32(cmp_vec), vreinterpretq_u32_s32(vceqq_s32(curr_vec, curr_vec)));\n        mask = vgetq_lane_u32(mask_vec, 0) | (vgetq_lane_u32(mask_vec, 1) << 1) | (vgetq_lane_u32(mask_vec, 2) << 2) | (vgetq_lane_u32(mask_vec, 3) << 3);\n\n        for (int j = 0; j < load_count; ++j) {\n            if (mask & (1 << j)) {\n                result = i + j;\n            }\n        }\n\n        prev_vec = curr_vec;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_128_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    int32x4_t max_neg = vdupq_n_s32(0);\n    int32x4_t min_pos = vdupq_n_s32(0);\n    bool found_neg = false;\n    bool found_pos = false;\n\n    size_t i = 0;\n    for (; i + 4 <= lst.size(); i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n\n        uint32x4_t neg_mask = vcltq_s32(vec, vdupq_n_s32(0));\n        uint32x4_t pos_mask = vcgtq_s32(vec, vdupq_n_s32(0));\n\n        if (!found_neg && vmaxvq_u32(neg_mask)) {\n            max_neg = vmaxq_s32(max_neg, vec);\n            found_neg = true;\n        } else if (found_neg && vmaxvq_u32(neg_mask)) {\n            max_neg = vmaxq_s32(max_neg, vec);\n        }\n\n        if (!found_pos && vmaxvq_u32(pos_mask)) {\n            min_pos = vminq_s32(min_pos, vec);\n            found_pos = true;\n        } else if (found_pos && vmaxvq_u32(pos_mask)) {\n            min_pos = vminq_s32(min_pos, vec);\n        }\n    }\n\n    int max_neg_scalar = found_neg ? vmaxvq_s32(max_neg) : 0;\n    int min_pos_scalar = found_pos ? vminvq_s32(min_pos) : 0;\n\n    for (; i < lst.size(); ++i) {\n        if (lst[i] < 0) {\n            max_neg_scalar = std::max(max_neg_scalar, lst[i]);\n        } else if (lst[i] > 0) {\n            min_pos_scalar = std::min(min_pos_scalar, lst[i]);\n        }\n    }\n\n    return {max_neg_scalar, min_pos_scalar};\n}\n```"}
{"task_id": "SimdBench_128_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    int32x4_t max_neg = vdupq_n_s32(0);\n    int32x4_t min_pos = vdupq_n_s32(0);\n    bool found_neg = false;\n    bool found_pos = false;\n\n    size_t i = 0;\n    for (; i + 4 <= lst.size(); i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n\n        uint32x4_t neg_mask = vcltq_s32(vec, vdupq_n_s32(0));\n        uint32x4_t pos_mask = vcgtq_s32(vec, vdupq_n_s32(0));\n\n        if (!found_neg && vmaxvq_u32(neg_mask)) {\n            max_neg = vmaxq_s32(max_neg, vec);\n            found_neg = true;\n        } else if (found_neg && vmaxvq_u32(neg_mask)) {\n            max_neg = vmaxq_s32(max_neg, vec);\n        }\n\n        if (!found_pos && vmaxvq_u32(pos_mask)) {\n            min_pos = vminq_s32(min_pos, vec);\n            found_pos = true;\n        } else if (found_pos && vmaxvq_u32(pos_mask)) {\n            min_pos = vminq_s32(min_pos, vec);\n        }\n    }\n\n    int max_neg_scalar = found_neg ? vmaxvq_s32(max_neg) : 0;\n    int min_pos_scalar = found_pos ? vminvq_s32(min_pos) : 0;\n\n    for (; i < lst.size(); ++i) {\n        if (lst[i] < 0) {\n            max_neg_scalar = std::max(max_neg_scalar, lst[i]);\n            found_neg = true;\n        } else if (lst[i] > 0) {\n            min_pos_scalar = std::min(min_pos_scalar, lst[i]);\n            found_pos = true;\n        }\n    }\n\n    return {max_neg_scalar, min_pos_scalar};\n}\n```"}
{"task_id": "SimdBench_128_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    int32x4_t max_neg = vdupq_n_s32(0);\n    int32x4_t min_pos = vdupq_n_s32(0);\n    bool found_neg = false;\n    bool found_pos = false;\n\n    size_t i = 0;\n    for (; i + 4 <= lst.size(); i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n\n        uint32x4_t neg_mask = vcltq_s32(vec, vdupq_n_s32(0));\n        uint32x4_t pos_mask = vcgtq_s32(vec, vdupq_n_s32(0));\n\n        if (!found_neg && vmaxvq_u32(neg_mask)) {\n            max_neg = vmaxq_s32(max_neg, vec);\n            found_neg = true;\n        } else if (found_neg && vmaxvq_u32(neg_mask)) {\n            max_neg = vmaxq_s32(max_neg, vec);\n        }\n\n        if (!found_pos && vmaxvq_u32(pos_mask)) {\n            min_pos = vminq_s32(min_pos, vec);\n            found_pos = true;\n        } else if (found_pos && vmaxvq_u32(pos_mask)) {\n            min_pos = vminq_s32(min_pos, vec);\n        }\n    }\n\n    int max_neg_scalar = found_neg ? vmaxvq_s32(max_neg) : 0;\n    int min_pos_scalar = found_pos ? vminvq_s32(min_pos) : 0;\n\n    for (; i < lst.size(); ++i) {\n        if (lst[i] < 0) {\n            max_neg_scalar = found_neg ? std::max(max_neg_scalar, lst[i]) : lst[i];\n            found_neg = true;\n        } else if (lst[i] > 0) {\n            min_pos_scalar = found_pos ? std::min(min_pos_scalar, lst[i]) : lst[i];\n            found_pos = true;\n        }\n    }\n\n    return {max_neg_scalar, min_pos_scalar};\n}\n```"}
{"task_id": "SimdBench_128_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    int32x4_t max_neg = vdupq_n_s32(0);\n    int32x4_t min_pos = vdupq_n_s32(0);\n    bool found_neg = false;\n    bool found_pos = false;\n\n    size_t i = 0;\n    for (; i + 4 <= lst.size(); i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n\n        uint32x4_t neg_mask = vcltq_s32(vec, vdupq_n_s32(0));\n        uint32x4_t pos_mask = vcgtq_s32(vec, vdupq_n_s32(0));\n\n        if (!found_neg && vmaxvq_u32(neg_mask)) {\n            max_neg = vmaxq_s32(max_neg, vec);\n            found_neg = true;\n        } else if (found_neg && vmaxvq_u32(neg_mask)) {\n            max_neg = vmaxq_s32(max_neg, vec);\n        }\n\n        if (!found_pos && vmaxvq_u32(pos_mask)) {\n            min_pos = vminq_s32(min_pos, vec);\n            found_pos = true;\n        } else if (found_pos && vmaxvq_u32(pos_mask)) {\n            min_pos = vminq_s32(min_pos, vec);\n        }\n    }\n\n    int max_neg_scalar = found_neg ? vmaxvq_s32(max_neg) : 0;\n    int min_pos_scalar = found_pos ? vminvq_s32(min_pos) : 0;\n\n    for (; i < lst.size(); ++i) {\n        if (lst[i] < 0) {\n            max_neg_scalar = std::max(max_neg_scalar, lst[i]);\n        } else if (lst[i] > 0) {\n            min_pos_scalar = std::min(min_pos_scalar, lst[i]);\n        }\n    }\n\n    return {max_neg_scalar, min_pos_scalar};\n}\n```"}
{"task_id": "SimdBench_128_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    int32x4_t max_neg = vdupq_n_s32(0);\n    int32x4_t min_pos = vdupq_n_s32(0);\n    bool found_neg = false;\n    bool found_pos = false;\n\n    size_t i = 0;\n    for (; i + 4 <= lst.size(); i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n\n        uint32x4_t neg_mask = vcltq_s32(vec, vdupq_n_s32(0));\n        uint32x4_t pos_mask = vcgtq_s32(vec, vdupq_n_s32(0));\n\n        if (!found_neg && vmaxvq_u32(neg_mask)) {\n            max_neg = vmaxq_s32(max_neg, vec);\n            found_neg = true;\n        } else if (found_neg && vmaxvq_u32(neg_mask)) {\n            max_neg = vmaxq_s32(max_neg, vec);\n        }\n\n        if (!found_pos && vmaxvq_u32(pos_mask)) {\n            min_pos = vminq_s32(min_pos, vec);\n            found_pos = true;\n        } else if (found_pos && vmaxvq_u32(pos_mask)) {\n            min_pos = vminq_s32(min_pos, vec);\n        }\n    }\n\n    int max_neg_scalar = found_neg ? vmaxvq_s32(max_neg) : 0;\n    int min_pos_scalar = found_pos ? vminvq_s32(min_pos) : 0;\n\n    for (; i < lst.size(); ++i) {\n        if (lst[i] < 0) {\n            max_neg_scalar = found_neg ? std::max(max_neg_scalar, lst[i]) : lst[i];\n            found_neg = true;\n        } else if (lst[i] > 0) {\n            min_pos_scalar = found_pos ? std::min(min_pos_scalar, lst[i]) : lst[i];\n            found_pos = true;\n        }\n    }\n\n    return {max_neg_scalar, min_pos_scalar};\n}\n```"}
{"task_id": "SimdBench_129_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    uint64_t result = 1;\n    uint64x2_t factorial = vdupq_n_u64(1);\n    uint64x2_t i_vec = vdupq_n_u64(1);\n    uint64x2_t two = vdupq_n_u64(2);\n\n    while (vgetq_lane_u64(i_vec, 0) <= n || vgetq_lane_u64(i_vec, 1) <= n) {\n        factorial = vmulq_u64(factorial, i_vec);\n        i_vec = vaddq_u64(i_vec, two);\n    }\n\n    result *= vgetq_lane_u64(factorial, 0);\n    if (vgetq_lane_u64(i_vec, 1) <= n) {\n        result *= vgetq_lane_u64(factorial, 1);\n    }\n\n    for (uint64_t i = vgetq_lane_u64(i_vec, 0); i <= n; ++i) {\n        result *= i;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    uint64_t result = 1;\n    uint64x2_t factorial = vdupq_n_u64(1);\n    uint64x2_t i_vec = vdupq_n_u64(1);\n    uint64x2_t two = vdupq_n_u64(2);\n\n    while (vgetq_lane_u64(i_vec, 0) <= n || vgetq_lane_u64(i_vec, 1) <= n) {\n        factorial = vmulq_u64(factorial, i_vec);\n        i_vec = vaddq_u64(i_vec, two);\n    }\n\n    result *= vgetq_lane_u64(factorial, 0);\n    if (vgetq_lane_u64(i_vec, 1) <= n) {\n        result *= vgetq_lane_u64(factorial, 1);\n    }\n\n    for (uint64_t i = vgetq_lane_u64(i_vec, 0); i <= n; ++i) {\n        result *= i;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    uint64_t result = 1;\n    uint64x2_t factorial = vmovq_n_u64(1);\n    uint64x2_t i_vec = vmovq_n_u64(1);\n    uint64x2_t two = vmovq_n_u64(2);\n\n    while (i_vec[0] <= n || i_vec[1] <= n) {\n        factorial = vmulq_u64(factorial, i_vec);\n        i_vec = vaddq_u64(i_vec, two);\n    }\n\n    result = factorial[0] * factorial[1];\n    if (i_vec[0] > n) {\n        result /= i_vec[0] - 1;\n    }\n    if (i_vec[1] > n) {\n        result /= i_vec[1] - 1;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    uint64_t result = 1;\n    uint64x2_t factorial = vdupq_n_u64(1);\n    uint64x2_t i_vec = vdupq_n_u64(1);\n    uint64x2_t two = vdupq_n_u64(2);\n\n    while (vgetq_lane_u64(i_vec, 0) <= n || vgetq_lane_u64(i_vec, 1) <= n) {\n        factorial = vmulq_u64(factorial, i_vec);\n        i_vec = vaddq_u64(i_vec, two);\n    }\n\n    result *= vgetq_lane_u64(factorial, 0);\n    if (vgetq_lane_u64(i_vec, 1) <= n) {\n        result *= vgetq_lane_u64(factorial, 1);\n    }\n\n    for (uint64_t i = vgetq_lane_u64(i_vec, 0); i <= n; ++i) {\n        result *= i;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    uint64_t result = 1;\n    uint64x2_t factorial = vdupq_n_u64(1);\n    uint64x2_t i_vec = vdupq_n_u64(1);\n    uint64x2_t two = vdupq_n_u64(2);\n\n    while (vgetq_lane_u64(i_vec, 0) <= n || vgetq_lane_u64(i_vec, 1) <= n) {\n        factorial = vmulq_u64(factorial, i_vec);\n        i_vec = vaddq_u64(i_vec, two);\n    }\n\n    result *= vgetq_lane_u64(factorial, 0);\n    if (vgetq_lane_u64(i_vec, 1) <= n) {\n        result *= vgetq_lane_u64(factorial, 1);\n    }\n\n    for (uint64_t i = vgetq_lane_u64(i_vec, 0); i <= n; ++i) {\n        result *= i;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_130_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    int sum = 0;\n    int n = lst.size();\n    int i = 0;\n\n    // Process 8 elements at a time\n    for (; i <= n - 8; i += 8) {\n        int32x4_t v1 = vld1q_s32(&lst[i]);\n        int32x4_t v2 = vld1q_s32(&lst[i + 4]);\n\n        // Create masks for indices that are multiples of 3 or 4\n        uint32x4_t mask3_1 = vcgeq_s32(vdupq_n_s32(i), vdupq_n_s32(3));\n        uint32x4_t mask3_2 = vcgeq_s32(vdupq_n_s32(i + 4), vdupq_n_s32(3));\n        uint32x4_t mask4_1 = veorq_u32(vcgeq_s32(vdupq_n_s32(i), vdupq_n_s32(4)), mask3_1);\n        uint32x4_t mask4_2 = veorq_u32(vcgeq_s32(vdupq_n_s32(i + 4), vdupq_n_s32(4)), mask3_2);\n\n        // Square elements at indices that are multiples of 3\n        int32x4_t squared1 = vmulq_s32(v1, v1);\n        int32x4_t squared2 = vmulq_s32(v2, v2);\n        v1 = vbslq_s32(mask3_1, squared1, v1);\n        v2 = vbslq_s32(mask3_2, squared2, v2);\n\n        // Cube elements at indices that are multiples of 4 and not multiples of 3\n        int32x4_t cubed1 = vmulq_s32(squared1, v1);\n        int32x4_t cubed2 = vmulq_s32(squared2, v2);\n        v1 = vbslq_s32(mask4_1, cubed1, v1);\n        v2 = vbslq_s32(mask4_2, cubed2, v2);\n\n        // Sum the results\n        int32x4_t sum128 = vaddq_s32(v1, v2);\n        int32x2_t sum64 = vpadd_s32(vget_low_s32(sum128), vget_high_s32(sum128));\n        int32x2_t sum32 = vpadd_s32(sum64, sum64);\n        sum += vget_lane_s32(sum32, 0);\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        int val = lst[i];\n        if (i % 3 == 0) {\n            val *= val;\n        } else if (i % 4 == 0) {\n            val *= val * val;\n        }\n        sum += val;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    int sum = 0;\n    int n = lst.size();\n    int i = 0;\n\n    // Process 4 elements at a time\n    for (; i <= n - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        int32x4_t indices = vdupq_n_s32(i);\n        int32x4_t multiples_of_3 = vandq_s32(vceqq_s32(vmodq_s32(indices, vdupq_n_s32(3)), vdupq_n_s32(0)), vdupq_n_s32(1));\n        int32x4_t multiples_of_4_not_3 = vandq_s32(vceqq_s32(vmodq_s32(indices, vdupq_n_s32(4)), vdupq_n_s32(0)), vmvnq_s32(multiples_of_3));\n\n        int32x4_t squares = vmulq_s32(vec, vec);\n        int32x4_t cubes = vmulq_s32(squares, vec);\n\n        int32x4_t result = vbslq_s32(multiples_of_3, squares, vec);\n        result = vbslq_s32(multiples_of_4_not_3, cubes, result);\n\n        sum += vaddvq_s32(result);\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    int sum = 0;\n    int n = lst.size();\n    int i = 0;\n\n    // Process 4 elements at a time\n    for (; i <= n - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        int32x4_t indices = vdupq_n_s32(i);\n        int32x4_t multiples_of_3 = vandq_s32(vceqq_s32(vmodq_s32(indices, vdupq_n_s32(3)), vdupq_n_s32(0)), vdupq_n_s32(1));\n        int32x4_t multiples_of_4_not_3 = vandq_s32(vceqq_s32(vmodq_s32(indices, vdupq_n_s32(4)), vdupq_n_s32(0)), vmvnq_s32(multiples_of_3));\n\n        int32x4_t squares = vmulq_s32(vec, vec);\n        int32x4_t cubes = vmulq_s32(squares, vec);\n\n        int32x4_t result = vbslq_s32(multiples_of_3, squares, vec);\n        result = vbslq_s32(multiples_of_4_not_3, cubes, result);\n\n        sum += vaddvq_s32(result);\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    int sum = 0;\n    int n = lst.size();\n    int i = 0;\n\n    // Process 8 elements at a time\n    for (; i <= n - 8; i += 8) {\n        int32x4_t v1 = vld1q_s32(&lst[i]);\n        int32x4_t v2 = vld1q_s32(&lst[i + 4]);\n\n        // Create masks for indices that are multiples of 3 or 4\n        uint32x4_t mask3_1 = vceqq_s32(vandq_s32(vmovq_n_s32(i), vmovq_n_s32(3)), vmovq_n_s32(0));\n        uint32x4_t mask4_1 = vandq_u32(vceqq_s32(vandq_s32(vmovq_n_s32(i), vmovq_n_s32(4)), vmovq_n_s32(0)),\n                                        vmvnq_u32(mask3_1));\n\n        uint32x4_t mask3_2 = vceqq_s32(vandq_s32(vmovq_n_s32(i + 4), vmovq_n_s32(3)), vmovq_n_s32(0));\n        uint32x4_t mask4_2 = vandq_u32(vceqq_s32(vandq_s32(vmovq_n_s32(i + 4), vmovq_n_s32(4)), vmovq_n_s32(0)),\n                                        vmvnq_u32(mask3_2));\n\n        // Square elements at indices that are multiples of 3\n        int32x4_t squared1 = vmulq_s32(v1, v1);\n        int32x4_t squared2 = vmulq_s32(v2, v2);\n\n        // Cube elements at indices that are multiples of 4 and not multiples of 3\n        int32x4_t cubed1 = vmulq_s32(vmulq_s32(v1, v1), v1);\n        int32x4_t cubed2 = vmulq_s32(vmulq_s32(v2, v2), v2);\n\n        // Select squared or cubed values based on the masks\n        int32x4_t result1 = vbslq_s32(mask3_1, squared1, v1);\n        int32x4_t result2 = vbslq_s32(mask3_2, squared2, v2);\n\n        result1 = vbslq_s32(mask4_1, cubed1, result1);\n        result2 = vbslq_s32(mask4_2, cubed2, result2);\n\n        // Sum the results\n        sum += vaddvq_s32(result1);\n        sum += vaddvq_s32(result2);\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    int sum = 0;\n    int n = lst.size();\n    int i = 0;\n\n    // Process 8 elements at a time\n    for (; i <= n - 8; i += 8) {\n        int32x4_t v1 = vld1q_s32(&lst[i]);\n        int32x4_t v2 = vld1q_s32(&lst[i + 4]);\n\n        // Create masks for indices that are multiples of 3 or 4\n        uint32x4_t mask3_1 = vceqq_s32(vandq_s32(vmovq_n_s32(i), vmovq_n_s32(3)), vmovq_n_s32(0));\n        uint32x4_t mask4_1 = vandq_u32(vceqq_s32(vandq_s32(vmovq_n_s32(i), vmovq_n_s32(4)), vmovq_n_s32(0)),\n                                        vmvnq_u32(mask3_1));\n\n        uint32x4_t mask3_2 = vceqq_s32(vandq_s32(vmovq_n_s32(i + 4), vmovq_n_s32(3)), vmovq_n_s32(0));\n        uint32x4_t mask4_2 = vandq_u32(vceqq_s32(vandq_s32(vmovq_n_s32(i + 4), vmovq_n_s32(4)), vmovq_n_s32(0)),\n                                        vmvnq_u32(mask3_2));\n\n        // Square elements at indices that are multiples of 3\n        int32x4_t squared1 = vmulq_s32(v1, v1);\n        int32x4_t squared2 = vmulq_s32(v2, v2);\n\n        // Cube elements at indices that are multiples of 4 and not multiples of 3\n        int32x4_t cubed1 = vmulq_s32(vmulq_s32(v1, v1), v1);\n        int32x4_t cubed2 = vmulq_s32(vmulq_s32(v2, v2), v2);\n\n        // Select squared or cubed values based on the masks\n        int32x4_t result1 = vbslq_s32(mask3_1, squared1, v1);\n        int32x4_t result2 = vbslq_s32(mask3_2, squared2, v2);\n\n        result1 = vbslq_s32(mask4_1, cubed1, result1);\n        result2 = vbslq_s32(mask4_2, cubed2, result2);\n\n        // Sum the results\n        int32x2_t sum1 = vadd_s32(vget_low_s32(result1), vget_high_s32(result1));\n        int32x2_t sum2 = vadd_s32(vget_low_s32(result2), vget_high_s32(result2));\n        int32x2_t total_sum = vadd_s32(sum1, sum2);\n\n        sum += vget_lane_s32(total_sum, 0) + vget_lane_s32(total_sum, 1);\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_131_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums){\n    int count = 0;\n    int n = nums.size();\n    const int* data = nums.data();\n\n    int i = 0;\n    for (; i <= n - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&data[i]);\n        int32x4_t ten = vdupq_n_s32(10);\n        uint32x4_t gt_ten = vcgtq_s32(vec, ten);\n\n        int32x4_t abs_vec = vabsq_s32(vec);\n        uint8x16_t bytes = vreinterpretq_u8_s32(abs_vec);\n        uint8x16_t first_last_digits = vtbl1q_u8(bytes, vdupq_n_u8(0));\n\n        uint8x16_t odd_mask = vdupq_n_u8(0x11); // 0001 0001 in each byte\n        uint8x16_t odd_digits = vandq_u8(first_last_digits, odd_mask);\n        uint8x16_t both_odd = vceqq_u8(odd_digits, odd_mask);\n\n        uint32x4_t valid = vandq_u32(gt_ten, vreinterpretq_u32_u8(both_odd));\n        count += vaddvq_u32(valid);\n    }\n\n    for (; i < n; ++i) {\n        int num = data[i];\n        if (num > 10) {\n            int abs_num = std::abs(num);\n            int first_digit = abs_num;\n            while (first_digit >= 10) first_digit /= 10;\n            int last_digit = abs_num % 10;\n            if ((first_digit % 2 != 0) && (last_digit % 2 != 0)) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums){\n    int count = 0;\n    int n = nums.size();\n    const int* data = nums.data();\n\n    // Process 4 integers at a time\n    for (int i = 0; i <= n - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&data[i]);\n        int32x4_t ten = vdupq_n_s32(10);\n        uint32x4_t gt_ten = vcgtq_s32(vec, ten);\n\n        // Extract first and last digits\n        int32x4_t abs_vec = vabsq_s32(vec);\n        int32x4_t last_digit = vandq_s32(abs_vec, vdupq_n_s32(9));\n        int32x4_t first_digit = abs_vec;\n        uint32x4_t mask = vdupq_n_u32(0xFFFFFFFF);\n        for (int j = 0; j < 3; ++j) {\n            first_digit = vshrq_n_u32(first_digit, 4);\n            mask = vshrq_n_u32(mask, 4);\n            first_digit = vandq_u32(first_digit, mask);\n        }\n        first_digit = vandq_s32(first_digit, vdupq_n_s32(9));\n\n        // Check if both first and last digits are odd\n        uint32x4_t odd_first = vandq_u32(vceqq_s32(vandq_s32(first_digit, vdupq_n_s32(1)), vdupq_n_s32(1)), gt_ten);\n        uint32x4_t odd_last = vandq_u32(vceqq_s32(vandq_s32(last_digit, vdupq_n_s32(1)), vdupq_n_s32(1)), gt_ten);\n        uint32x4_t result = vandq_u32(odd_first, odd_last);\n\n        // Count true values\n        uint32x2_t cnt1 = vcnt_u32(vget_low_u32(result));\n        uint32x2_t cnt2 = vcnt_u32(vget_high_u32(result));\n        uint32x2_t cnt = vadd_u32(cnt1, cnt2);\n        count += vget_lane_u32(cnt, 0) + vget_lane_u32(cnt, 1);\n    }\n\n    // Process remaining elements\n    for (int i = (n / 4) * 4; i < n; ++i) {\n        int num = data[i];\n        if (num > 10) {\n            int last_digit = abs(num) % 10;\n            int first_digit = abs(num);\n            while (first_digit >= 10) {\n                first_digit /= 10;\n            }\n            if ((first_digit % 2 != 0) && (last_digit % 2 != 0)) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums){\n    int count = 0;\n    int n = nums.size();\n    const int* data = nums.data();\n\n    // Process 4 integers at a time\n    for (int i = 0; i <= n - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&data[i]);\n        int32x4_t ten = vdupq_n_s32(10);\n        uint32x4_t gt_ten = vcgtq_s32(vec, ten);\n\n        // Extract first and last digits\n        int32x4_t abs_vec = vabsq_s32(vec);\n        int32x4_t last_digit = vandq_s32(abs_vec, vdupq_n_s32(9));\n        int32x4_t first_digit = abs_vec;\n        for (int j = 0; j < 9; ++j) {\n            first_digit = vshrq_n_s32(first_digit, 1);\n            first_digit = vandq_s32(first_digit, vdupq_n_s32(9));\n        }\n\n        // Check if both first and last digits are odd\n        uint32x4_t odd_first_last = vandq_u32(vtstq_u32(first_digit, vdupq_n_u32(1)), vtstq_u32(last_digit, vdupq_n_u32(1)));\n\n        // Combine conditions\n        uint32x4_t result = vandq_u32(gt_ten, odd_first_last);\n\n        // Count true values\n        uint32x2_t sum1 = vpadd_u32(vget_low_u32(result), vget_high_u32(result));\n        uint32x2_t sum2 = vpadd_u32(sum1, sum1);\n        count += vget_lane_u32(sum2, 0);\n    }\n\n    // Handle remaining elements\n    for (int i = (n / 4) * 4; i < n; ++i) {\n        int num = nums[i];\n        if (num > 10) {\n            int last_digit = abs(num) % 10;\n            int first_digit = abs(num);\n            while (first_digit >= 10) {\n                first_digit /= 10;\n            }\n            if ((first_digit % 2 != 0) && (last_digit % 2 != 0)) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums){\n    int count = 0;\n    int n = nums.size();\n    const int* data = nums.data();\n\n    int i = 0;\n    for (; i <= n - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&data[i]);\n        int32x4_t ten = vdupq_n_s32(10);\n        uint32x4_t gt_ten = vcgtq_s32(vec, ten);\n\n        int32x4_t abs_vec = vabsq_s32(vec);\n        int32x4_t first_digit_mask = vdupq_n_s32(0x8000000F);\n        int32x4_t first_digit = vandq_s32(abs_vec, first_digit_mask);\n\n        int32x4_t last_digit = vandq_s32(abs_vec, vdupq_n_s32(0xF));\n\n        uint32x4_t odd_first_digit = vandq_u32(vtstq_u32(first_digit, vdupq_n_u32(1)), vdupq_n_u32(0xFFFFFFFF));\n        uint32x4_t odd_last_digit = vandq_u32(vtstq_u32(last_digit, vdupq_n_u32(1)), vdupq_n_u32(0xFFFFFFFF));\n\n        uint32x4_t odd_both_digits = vandq_u32(odd_first_digit, odd_last_digit);\n        uint32x4_t result = vandq_u32(gt_ten, odd_both_digits);\n\n        uint32x2_t sum1 = vpadd_u32(vget_low_u32(result), vget_high_u32(result));\n        uint32x2_t sum2 = vpadd_u32(sum1, sum1);\n        count += vget_lane_u32(sum2, 0);\n    }\n\n    for (; i < n; ++i) {\n        int num = data[i];\n        if (num > 10) {\n            int abs_num = std::abs(num);\n            int first_digit = abs_num % 10;\n            while (abs_num >= 10) {\n                abs_num /= 10;\n            }\n            int last_digit = abs_num;\n            if ((first_digit % 2 != 0) && (last_digit % 2 != 0)) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums){\n    int count = 0;\n    int n = nums.size();\n    const int* data = nums.data();\n\n    // Process 4 integers at a time\n    for (int i = 0; i <= n - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&data[i]);\n        int32x4_t ten = vdupq_n_s32(10);\n        uint32x4_t gt_ten = vcgtq_s32(vec, ten);\n\n        // Extract first and last digits\n        int32x4_t abs_vec = vabsq_s32(vec);\n        int32x4_t last_digit = vandq_s32(abs_vec, vdupq_n_s32(9));\n        int32x4_t first_digit = abs_vec;\n        uint32x4_t mask = vdupq_n_u32(0xFFFFFFFF);\n        for (int j = 0; j < 3; ++j) {\n            first_digit = vshrq_n_u32(first_digit, 4);\n            mask = vshrq_n_u32(mask, 4);\n            first_digit = vandq_u32(first_digit, mask);\n        }\n        first_digit = vandq_s32(first_digit, vdupq_n_s32(9));\n\n        // Check if both first and last digits are odd\n        uint32x4_t odd_first = vandq_u32(vceqq_s32(vandq_s32(first_digit, vdupq_n_s32(1)), vdupq_n_s32(1)), gt_ten);\n        uint32x4_t odd_last = vandq_u32(vceqq_s32(vandq_s32(last_digit, vdupq_n_s32(1)), vdupq_n_s32(1)), gt_ten);\n        uint32x4_t result = vandq_u32(odd_first, odd_last);\n\n        // Count true values\n        uint32x2_t cnt1 = vcnt_u32(vget_low_u32(result));\n        uint32x2_t cnt2 = vcnt_u32(vget_high_u32(result));\n        uint32x2_t cnt = vadd_u32(cnt1, cnt2);\n        count += vget_lane_u32(cnt, 0) + vget_lane_u32(cnt, 1);\n    }\n\n    // Process remaining elements\n    for (int i = (n / 4) * 4; i < n; ++i) {\n        int num = data[i];\n        if (num > 10) {\n            int last_digit = abs(num) % 10;\n            int first_digit = abs(num);\n            while (first_digit >= 10) {\n                first_digit /= 10;\n            }\n            if ((first_digit % 2 != 0) && (last_digit % 2 != 0)) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    uint64_t count = 0;\n    if (n < 3) return 0;\n\n    uint32_t* a = new uint32_t[n];\n    for (uint64_t i = 0; i < n; ++i) {\n        a[i] = i * i - i + 1;\n    }\n\n    uint32x4_t mod3_counts = vdupq_n_u32(0);\n    for (uint64_t i = 0; i < n; i += 4) {\n        uint32x4_t vec = vld1q_u32(&a[i]);\n        uint32x4_t mod3 = vmodq_u32(vec, vdupq_n_u32(3));\n        uint32x4_t counts = vcntq_u32(vceqq_u32(mod3, vdupq_n_u32(0)));\n        mod3_counts = vaddq_u32(mod3_counts, counts);\n    }\n\n    uint32_t counts[4];\n    vst1q_u32(counts, mod3_counts);\n    uint32_t mod0_count = counts[0] + counts[1] + counts[2] + counts[3];\n\n    for (uint64_t i = 0; i < n - 2; ++i) {\n        for (uint64_t j = i + 1; j < n - 1; ++j) {\n            uint32_t sum_ij_mod3 = (a[i] + a[j]) % 3;\n            uint32_t target_mod3 = (3 - sum_ij_mod3) % 3;\n            for (uint64_t k = j + 1; k < n; ++k) {\n                if (a[k] % 3 == target_mod3) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    delete[] a;\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    uint64_t count = 0;\n    if (n < 3) return 0;\n\n    uint32_t* a = new uint32_t[n];\n    for (uint64_t i = 0; i < n; ++i) {\n        a[i] = i * i - i + 1;\n    }\n\n    uint64_t i = 0;\n    for (; i <= n - 3; i += 4) {\n        uint32x4_t vec_i = vld1q_u32(&a[i]);\n        uint32x4_t vec_j = vld1q_u32(&a[i + 1]);\n        uint32x4_t vec_k = vld1q_u32(&a[i + 2]);\n\n        for (uint64_t j = i + 1; j <= n - 2; ++j) {\n            uint32x4_t vec_j_val = vdupq_n_u32(a[j]);\n            uint32x4_t vec_sum_ij = vaddq_u32(vec_i, vec_j_val);\n\n            for (uint64_t k = j + 1; k <= n - 1; ++k) {\n                uint32x4_t vec_k_val = vdupq_n_u32(a[k]);\n                uint32x4_t vec_sum_ijk = vaddq_u32(vec_sum_ij, vec_k_val);\n                uint32x4_t vec_mod_3 = vandq_u32(vec_sum_ijk, vdupq_n_u32(2));\n\n                uint32x4_t vec_zero = vceqq_u32(vec_mod_3, vdupq_n_u32(0));\n                uint64x2_t vec_cnt = vcntq_u8(vreinterpretq_u8_u32(vec_zero));\n                count += vgetq_lane_u64(vec_cnt, 0) + vgetq_lane_u64(vec_cnt, 1);\n            }\n        }\n    }\n\n    for (; i <= n - 3; ++i) {\n        for (uint64_t j = i + 1; j <= n - 2; ++j) {\n            for (uint64_t k = j + 1; k <= n - 1; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    delete[] a;\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    uint64_t count = 0;\n    if (n < 3) return 0;\n\n    uint32_t* a = new uint32_t[n];\n    for (uint64_t i = 0; i < n; ++i) {\n        a[i] = i * i - i + 1;\n    }\n\n    uint32x4_t mod3_counts = vdupq_n_u32(0);\n    for (uint64_t i = 0; i < n; i += 4) {\n        uint32x4_t vec = vld1q_u32(&a[i]);\n        uint32x4_t mod3 = vmodq_u32(vec, vdupq_n_u32(3));\n        uint32x4_t counts = vcntq_u32(vceqq_u32(mod3, vdupq_n_u32(0)));\n        mod3_counts = vaddq_u32(mod3_counts, counts);\n    }\n\n    uint32_t counts[4];\n    vst1q_u32(counts, mod3_counts);\n    uint32_t count_mod0 = counts[0] + counts[1] + counts[2] + counts[3];\n\n    uint32_t count_mod1 = 0, count_mod2 = 0;\n    for (uint64_t i = 0; i < n; ++i) {\n        if (a[i] % 3 == 1) count_mod1++;\n        else if (a[i] % 3 == 2) count_mod2++;\n    }\n\n    count = (static_cast<uint64_t>(count_mod0) * (count_mod0 - 1) * (count_mod0 - 2) / 6) +\n            (static_cast<uint64_t>(count_mod1) * count_mod1 * (count_mod1 - 1) / 2) * count_mod0 +\n            (static_cast<uint64_t>(count_mod2) * count_mod2 * (count_mod2 - 1) / 2) * count_mod0 +\n            (static_cast<uint64_t>(count_mod1) * count_mod2 * (count_mod1 - 1)) +\n            (static_cast<uint64_t>(count_mod1) * count_mod2 * (count_mod2 - 1));\n\n    delete[] a;\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    uint64_t count = 0;\n    if (n < 3) return 0;\n\n    uint32_t* a = new uint32_t[n];\n    for (uint64_t i = 0; i < n; ++i) {\n        a[i] = i * i - i + 1;\n    }\n\n    uint64_t i = 0;\n    for (; i <= n - 3; i += 4) {\n        uint32x4_t vec_i = vld1q_u32(a + i);\n        uint32x4_t vec_j = vld1q_u32(a + i + 1);\n        uint32x4_t vec_k = vld1q_u32(a + i + 2);\n\n        for (uint64_t j = i + 1; j <= n - 2; ++j) {\n            uint32x4_t vec_j_base = vdupq_n_u32(a[j]);\n            uint32x4_t vec_k_base = vdupq_n_u32(a[j + 1]);\n\n            uint32x4_t sum1 = vaddq_u32(vec_i, vec_j_base);\n            uint32x4_t sum2 = vaddq_u32(sum1, vec_k_base);\n\n            uint32x4_t mod3 = vandq_u32(sum2, vdupq_n_u32(2));\n\n            uint32x4_t zero = vdupq_n_u32(0);\n            uint32x4_t mask = vceqq_u32(mod3, zero);\n\n            uint32x2_t lo = vget_low_u32(mask);\n            uint32x2_t hi = vget_high_u32(mask);\n\n            count += vget_lane_u32(lo, 0) ? 1 : 0;\n            count += vget_lane_u32(lo, 1) ? 1 : 0;\n            count += vget_lane_u32(hi, 0) ? 1 : 0;\n            count += vget_lane_u32(hi, 1) ? 1 : 0;\n\n            for (uint64_t k = j + 2; k < n; ++k) {\n                uint32x4_t vec_k_single = vdupq_n_u32(a[k]);\n                uint32x4_t sum = vaddq_u32(vaddq_u32(vec_i, vec_j_base), vec_k_single);\n                uint32x4_t mod3_single = vandq_u32(sum, vdupq_n_u32(2));\n                count += vgetq_lane_u32(vceqq_u32(mod3_single, vdupq_n_u32(0)), 0) ? 1 : 0;\n            }\n        }\n    }\n\n    for (; i < n - 2; ++i) {\n        for (uint64_t j = i + 1; j < n - 1; ++j) {\n            for (uint64_t k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    delete[] a;\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    uint64_t count = 0;\n    if (n < 3) return 0;\n\n    uint32_t* a = new uint32_t[n];\n    for (uint64_t i = 0; i < n; ++i) {\n        a[i] = i * i - i + 1;\n    }\n\n    uint64_t i = 0;\n    for (; i <= n - 3; i += 4) {\n        uint32x4_t ai = vld1q_u32(&a[i]);\n        uint32x4_t aj = vld1q_u32(&a[i + 1]);\n        uint32x4_t ak = vld1q_u32(&a[i + 2]);\n\n        for (uint64_t j = i + 1; j <= n - 2; ++j) {\n            uint32x4_t bj = vdupq_n_u32(a[j]);\n            uint32x4_t bk = vld1q_u32(&a[j + 1]);\n\n            for (uint64_t k = j + 1; k <= n - 1; ++k) {\n                uint32x4_t ck = vdupq_n_u32(a[k]);\n\n                uint32x4_t sum1 = vaddq_u32(ai, bj);\n                uint32x4_t sum2 = vaddq_u32(sum1, ck);\n\n                uint32x4_t mod3 = vandq_u32(sum2, vdupq_n_u32(2));\n\n                uint32x4_t zero = vceqq_u32(mod3, vdupq_n_u32(0));\n                uint32x2_t zero_low = vget_low_u32(zero);\n                uint32x2_t zero_high = vget_high_u32(zero);\n\n                count += vget_lane_u32(vcnt_u8(vreinterpret_u8_u32(zero_low)), 0) / 8;\n                count += vget_lane_u32(vcnt_u8(vreinterpret_u8_u32(zero_high)), 0) / 8;\n            }\n        }\n    }\n\n    for (; i <= n - 3; ++i) {\n        for (uint64_t j = i + 1; j <= n - 2; ++j) {\n            for (uint64_t k = j + 1; k <= n - 1; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    delete[] a;\n    return count;\n}\n```"}
{"task_id": "SimdBench_133_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    int32x4_t n_vec = vdupq_n_s32(n);\n    int32x4_t x_vec = vdupq_n_s32(x);\n    int32x4_t y_vec = vdupq_n_s32(y);\n    int32x4_t result;\n\n    // Check divisibility by 2 to 10 for simplicity\n    int32x4_t divisors = vld1q_s32((const int32_t[]){2, 3, 4, 5});\n    int32x4_t zero = vdupq_n_s32(0);\n\n    uint32x4_t is_divisible = vceqq_s32(vmodq_s32(n_vec, divisors), zero);\n    uint32x4_t is_not_prime = vorrq_u32(is_divisible, vshlq_n_u32(is_divisible, 1));\n\n    for (int i = 6; i <= 10; i++) {\n        divisors = vsetq_lane_s32(i, divisors, 0);\n        divisors = vsetq_lane_s32(i + 1, divisors, 1);\n        divisors = vsetq_lane_s32(i + 2, divisors, 2);\n        divisors = vsetq_lane_s32(i + 3, divisors, 3);\n\n        is_divisible = vceqq_s32(vmodq_s32(n_vec, divisors), zero);\n        is_not_prime = vorrq_u32(is_not_prime, is_divisible);\n    }\n\n    // Special case for 2 and 3\n    uint32x4_t is_small_prime = vceqq_s32(n_vec, vdupq_n_s32(2));\n    is_small_prime = vorrq_u32(is_small_prime, vceqq_s32(n_vec, vdupq_n_s32(3)));\n\n    // Combine results\n    uint32x4_t is_prime = vmvnq_u32(is_not_prime);\n    is_prime = vorrq_u32(is_prime, is_small_prime);\n\n    // Select x or y based on is_prime\n    result = vbslq_s32(is_prime, x_vec, y_vec);\n\n    // Return the first element of the result vector\n    return vgetq_lane_s32(result, 0);\n}\n```"}
{"task_id": "SimdBench_133_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    int32x4_t n_vec = vdupq_n_s32(n);\n    int32x4_t x_vec = vdupq_n_s32(x);\n    int32x4_t y_vec = vdupq_n_s32(y);\n    int32x4_t result_vec;\n\n    // Check for divisibility by 2 to 10 as a simple heuristic\n    int32x4_t divisors = vld1q_s32((const int32_t[]){2, 3, 4, 5});\n    int32x4_t zero = vdupq_n_s32(0);\n    uint32x4_t mask = vceqq_s32(vandq_s32(n_vec, divisors), zero);\n\n    for (int i = 6; i <= 10; i++) {\n        int32x4_t divisor = vdupq_n_s32(i);\n        mask = vandq_u32(mask, vceqq_s32(vandq_s32(n_vec, divisor), zero));\n    }\n\n    // Check if n is less than 2\n    mask = vandq_u32(mask, vcgtq_s32(n_vec, vdupq_n_s32(1)));\n\n    // Select x or y based on the mask\n    result_vec = vbslq_s32(mask, x_vec, y_vec);\n\n    // Return the first element of the result vector\n    return vgetq_lane_s32(result_vec, 0);\n}\n```"}
{"task_id": "SimdBench_133_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    int32_t is_prime = 1;\n    if (n <= 1) is_prime = 0;\n\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) {\n            is_prime = 0;\n            break;\n        }\n    }\n\n    int32x4_t n_vec = vdupq_n_s32(n);\n    int32x4_t x_vec = vdupq_n_s32(x);\n    int32x4_t y_vec = vdupq_n_s32(y);\n    int32x4_t is_prime_vec = vdupq_n_s32(is_prime);\n\n    int32x4_t result_vec = vbslq_s32((uint32x4_t)is_prime_vec, x_vec, y_vec);\n\n    return vgetq_lane_s32(result_vec, 0);\n}\n```"}
{"task_id": "SimdBench_133_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    int32x4_t n_vec = vdupq_n_s32(n);\n    int32x4_t x_vec = vdupq_n_s32(x);\n    int32x4_t y_vec = vdupq_n_s32(y);\n    int32x4_t result;\n\n    // Create a vector of numbers from 2 to 5\n    int32x4_t divisors = vsetq_lane_s32(2, vsetq_lane_s32(3, vsetq_lane_s32(4, vdupq_n_s32(5), 0), 1), 2);\n\n    // Check divisibility\n    uint32x4_t is_divisible = vceqq_s32(vandq_s32(n_vec, vsubq_s32(n_vec, divisors)), vdupq_n_s32(0));\n\n    // Check if n is less than 2\n    uint32x4_t is_less_than_2 = vcltq_s32(n_vec, vdupq_n_s32(2));\n\n    // Combine conditions for non-prime\n    uint32x4_t is_not_prime = vorrq_u32(is_divisible, is_less_than_2);\n\n    // Select x or y based on prime check\n    result = vbslq_s32(is_not_prime, y_vec, x_vec);\n\n    // Return the first element of the result vector\n    return vgetq_lane_s32(result, 0);\n}\n```"}
{"task_id": "SimdBench_133_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    int32x4_t n_vec = vdupq_n_s32(n);\n    int32x4_t x_vec = vdupq_n_s32(x);\n    int32x4_t y_vec = vdupq_n_s32(y);\n    int32x4_t result;\n\n    // Check divisibility by 2 to 10 for simplicity\n    int32x4_t divisors = vld1q_s32((const int32_t[]){2, 3, 4, 5});\n    int32x4_t zero = vdupq_n_s32(0);\n\n    uint32x4_t is_divisible = vceqq_s32(vmulq_s32(vdivq_s32(n_vec, divisors), divisors), n_vec);\n    uint32x4_t is_not_prime = vorrq_u32(is_divisible, vceqq_s32(divisors, n_vec));\n\n    // Shift divisors to check next set of numbers\n    divisors = vld1q_s32((const int32_t[]){6, 7, 8, 9});\n    is_divisible = vceqq_s32(vmulq_s32(vdivq_s32(n_vec, divisors), divisors), n_vec);\n    is_not_prime = vorrq_u32(is_not_prime, is_divisible);\n\n    // Check if n is 1 or less\n    is_not_prime = vorrq_u32(is_not_prime, vcleq_s32(n_vec, vdupq_n_s32(1)));\n\n    // Select x or y based on is_not_prime\n    result = vbslq_s32(is_not_prime, y_vec, x_vec);\n\n    // Return the first element of the result vector\n    return vgetq_lane_s32(result, 0);\n}\n```"}
{"task_id": "SimdBench_134_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    size_t n = lst.size();\n    size_t i = 0;\n\n    float32x4_t zero = vdupq_n_f32(0.0f);\n    int32x4_t one = vdupq_n_s32(1);\n\n    for (; i <= n - 4; i += 4) {\n        float32x4_t vec = vld1q_f32(&lst[i]);\n        uint32x4_t mask_non_negative = vcgtq_f32(vec, zero);\n        int32x4_t vec_int = vcvtq_s32_f32(vec);\n        float32x4_t vec_float_converted = vcvtq_f32_s32(vec_int);\n        uint32x4_t mask_integer = vceqq_f32(vec, vec_float_converted);\n        int32x4_t vec_odd = vandq_s32(vec_int, one);\n        uint32x4_t mask_odd = vceqq_s32(vec_odd, one);\n        uint32x4_t mask = vandq_u32(mask_non_negative, vandq_u32(mask_integer, mask_odd));\n        float32x4_t vec_squared = vmulq_f32(vec, vec);\n        float32x4_t vec_masked = vbslq_f32(mask, vec_squared, zero);\n        uint32x2_t sum_low = vpadd_u32(vreinterpretq_u32_f32(vec_masked), vreinterpretq_u32_f32(vec_masked));\n        uint32x2_t sum_high = vpadd_u32(sum_low, sum_low);\n        sum += vget_lane_u32(sum_high, 0);\n    }\n\n    for (; i < n; ++i) {\n        float num = lst[i];\n        if (num >= 0 && num == static_cast<int>(num) && static_cast<int>(num) % 2 != 0) {\n            sum += static_cast<uint64_t>(num * num);\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    size_t n = lst.size();\n    size_t i = 0;\n\n    float32x4_t zero = vdupq_n_f32(0.0f);\n    float32x4_t one = vdupq_n_f32(1.0f);\n    int32x4_t odd_mask = vdupq_n_s32(1);\n\n    for (; i <= n - 4; i += 4) {\n        float32x4_t vec = vld1q_f32(&lst[i]);\n        uint32x4_t positive_mask = vcgtq_f32(vec, zero);\n        int32x4_t int_vec = vcvtq_s32_f32(vec);\n        int32x4_t is_integer_mask = vceqq_f32(vcvtq_f32_s32(int_vec), vec);\n        int32x4_t combined_mask = vandq_u32(positive_mask, is_integer_mask);\n        int32x4_t odd_check = vandq_s32(int_vec, odd_mask);\n        int32x4_t is_odd_mask = vceqq_s32(odd_check, odd_mask);\n        int32x4_t final_mask = vandq_u32(combined_mask, vreinterpretq_u32_s32(is_odd_mask));\n\n        float32x4_t squared = vmulq_f32(vec, vec);\n        float32x4_t masked_squared = vbslq_f32(final_mask, squared, zero);\n\n        uint64x2_t sum64 = vpaddlq_u32(vpaddlq_u16(vpaddlq_u8(vreinterpretq_u8_f32(masked_squared))));\n        sum += vgetq_lane_u64(sum64, 0) + vgetq_lane_u64(sum64, 1);\n    }\n\n    for (; i < n; ++i) {\n        float num = lst[i];\n        if (num > 0 && num == static_cast<int>(num) && static_cast<int>(num) % 2 != 0) {\n            sum += static_cast<uint64_t>(num * num);\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    size_t n = lst.size();\n    size_t i = 0;\n\n    float32x4_t zero = vdupq_n_f32(0.0f);\n    float32x4_t one = vdupq_n_f32(1.0f);\n    int32x4_t odd_mask = vmovq_n_s32(1);\n\n    for (; i <= n - 4; i += 4) {\n        float32x4_t vec = vld1q_f32(&lst[i]);\n        uint32x4_t is_positive = vcgtq_f32(vec, zero);\n        int32x4_t int_vec = vcvtq_s32_f32(vec);\n        int32x4_t is_integer = vceqq_f32(vcvtq_f32_s32(int_vec), vec);\n        int32x4_t is_odd = vandq_s32(vandq_s32(is_positive, is_integer), veorq_s32(vandq_s32(int_vec, odd_mask), odd_mask));\n        int32x4_t odd_squares = vmulq_s32(is_odd, int_vec);\n        odd_squares = vmulq_s32(odd_squares, int_vec);\n        sum += vaddvq_u32(vreinterpretq_u32_s32(odd_squares));\n    }\n\n    for (; i < n; ++i) {\n        float num = lst[i];\n        if (num > 0 && num == static_cast<int>(num) && static_cast<int>(num) % 2 != 0) {\n            sum += static_cast<uint64_t>(num) * static_cast<uint64_t>(num);\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    size_t n = lst.size();\n    size_t i = 0;\n\n    float32x4_t zero = vdupq_n_f32(0.0f);\n    int32x4_t one = vdupq_n_s32(1);\n\n    for (; i <= n - 4; i += 4) {\n        float32x4_t vec = vld1q_f32(&lst[i]);\n        uint32x4_t is_positive = vcgtq_f32(vec, zero);\n        int32x4_t int_vec = vcvtq_s32_f32(vec);\n        float32x4_t float_int_vec = vcvtq_f32_s32(int_vec);\n        uint32x4_t is_integer = vceqq_f32(vec, float_int_vec);\n        int32x4_t odd_mask = vandq_s32(vreinterpretq_s32_u32(is_positive), vreinterpretq_s32_u32(is_integer));\n        int32x4_t odd_int_vec = vandq_s32(int_vec, odd_mask);\n        int32x4_t odd_square = vmulq_s32(odd_int_vec, odd_int_vec);\n        uint32x4_t odd_square_u =vreinterpretq_u32_s32(odd_square);\n        uint32x2_t odd_square_low = vadd_u32(vget_low_u32(odd_square_u), vget_high_u32(odd_square_u));\n        uint32_t odd_square_sum = vget_lane_u32(vpaddl_u32(odd_square_low), 0);\n        sum += odd_square_sum;\n    }\n\n    for (; i < n; ++i) {\n        float num = lst[i];\n        if (num > 0 && num == static_cast<int>(num)) {\n            int int_num = static_cast<int>(num);\n            if (int_num % 2 != 0) {\n                sum += int_num * int_num;\n            }\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    size_t n = lst.size();\n    size_t i = 0;\n\n    float32x4_t zero = vdupq_n_f32(0.0f);\n    int32x4_t one = vdupq_n_s32(1);\n\n    for (; i <= n - 4; i += 4) {\n        float32x4_t vec = vld1q_f32(&lst[i]);\n        uint32x4_t is_positive = vcgtq_f32(vec, zero);\n        int32x4_t int_vec = vcvtq_s32_f32(vec);\n        float32x4_t float_int_vec = vcvtq_f32_s32(int_vec);\n        uint32x4_t is_integer = vceqq_f32(vec, float_int_vec);\n        int32x4_t odd_mask = vandq_s32(vreinterpretq_s32_u32(is_positive), vreinterpretq_s32_u32(is_integer));\n        int32x4_t odd_int_vec = vandq_s32(int_vec, odd_mask);\n        int32x4_t odd_squared = vmulq_s32(odd_int_vec, odd_int_vec);\n        int32x4_t odd_squared_filtered = vandq_s32(odd_squared, odd_mask);\n        int32x2_t odd_squared_low = vadd_s32(vget_low_s32(odd_squared_filtered), vget_high_s32(odd_squared_filtered));\n        int32x2_t odd_squared_sum = vpadd_s32(odd_squared_low, odd_squared_low);\n        sum += vget_lane_s32(odd_squared_sum, 0);\n    }\n\n    for (; i < n; ++i) {\n        float num = lst[i];\n        if (num > 0 && num == static_cast<int>(num)) {\n            int int_num = static_cast<int>(num);\n            if (int_num % 2 != 0) {\n                sum += int_num * int_num;\n            }\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_135_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result(game.size());\n    size_t i = 0;\n    size_t n = game.size();\n\n    for (; i <= n - 4; i += 4) {\n        int32x4_t game_vec = vld1q_s32(&game[i]);\n        int32x4_t guess_vec = vld1q_s32(&guess[i]);\n        int32x4_t diff_vec = vabdq_s32(game_vec, guess_vec);\n        vst1q_s32(&result[i], diff_vec);\n    }\n\n    for (; i < n; ++i) {\n        result[i] = abs(game[i] - guess[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result(game.size());\n    size_t i = 0;\n    for (; i <= game.size() - 4; i += 4) {\n        int32x4_t game_vec = vld1q_s32(&game[i]);\n        int32x4_t guess_vec = vld1q_s32(&guess[i]);\n        int32x4_t diff_vec = vabdq_s32(game_vec, guess_vec);\n        vst1q_s32(&result[i], diff_vec);\n    }\n    for (; i < game.size(); ++i) {\n        result[i] = abs(game[i] - guess[i]);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result(game.size());\n    size_t i = 0;\n    for (; i <= game.size() - 4; i += 4) {\n        int32x4_t game_vec = vld1q_s32(&game[i]);\n        int32x4_t guess_vec = vld1q_s32(&guess[i]);\n        int32x4_t diff_vec = vabdq_s32(game_vec, guess_vec);\n        vst1q_s32(&result[i], diff_vec);\n    }\n    for (; i < game.size(); ++i) {\n        result[i] = abs(game[i] - guess[i]);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result(game.size());\n    size_t i = 0;\n    for (; i <= game.size() - 4; i += 4) {\n        int32x4_t game_vec = vld1q_s32(&game[i]);\n        int32x4_t guess_vec = vld1q_s32(&guess[i]);\n        int32x4_t diff_vec = vabdq_s32(game_vec, guess_vec);\n        vst1q_s32(&result[i], diff_vec);\n    }\n    for (; i < game.size(); ++i) {\n        result[i] = std::abs(game[i] - guess[i]);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result(game.size());\n    size_t i = 0;\n    size_t n = game.size();\n\n    for (; i <= n - 4; i += 4) {\n        int32x4_t game_vec = vld1q_s32(&game[i]);\n        int32x4_t guess_vec = vld1q_s32(&guess[i]);\n        int32x4_t diff_vec = vabdq_s32(game_vec, guess_vec);\n        vst1q_s32(&result[i], diff_vec);\n    }\n\n    for (; i < n; ++i) {\n        result[i] = abs(game[i] - guess[i]);\n    }\n\n    return result;\n}\n```"}

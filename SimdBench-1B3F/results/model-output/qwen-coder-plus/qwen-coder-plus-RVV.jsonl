{"task_id": "SimdBench_0_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m8(length - i);\n        vint64m8_t src_vec = vle64_v_i64m8(&src[i], vl);\n        vbool8_t mask_vec = vmseq_vx_u8m8(vle8_v_u8m8((const uint8_t *)&mask[i], vl), 1, vl);\n        vse64_v_i64m8_m(dst + i, mask_vec, src_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_0_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m8(length - i);\n        vint64m8_t src_vec = vle64_v_i64m8(&src[i], vl);\n        vbool8_t mask_vec = vmseq_vx_u8m8(vle8_v_u8m8((const uint8_t *)&mask[i], vl), 1, vl);\n        vse64_v_i64m8_m(&dst[i], mask_vec, src_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_0_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m8(length - i);\n        vint64m8_t src_vec = vle64_v_i64m8(&src[i], vl);\n        vbool8_t mask_vec = vmseq_vx_u8m8(vle8_v_u8m8((const uint8_t *)&mask[i], vl), 1, vl);\n        vse64_v_i64m8_m(&dst[i], mask_vec, src_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_0_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m1(length - i);\n        vint64m1_t src_vec = vle64_v_i64m1(&src[i], vl);\n        vbool8_t mask_vec = vmseq_vx_u8m1(vle8_v_u8m1((const uint8_t *)&mask[i], vl), 1, vl);\n        vse64_v_i64m1_m(mask_vec, &dst[i], src_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_0_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m8(length - i);\n        vint64m8_t src_vec = vle64_v_i64m8(&src[i], vl);\n        vbool8_t mask_vec = vmseq_vx_u8m8(vle8_v_u8m8((const uint8_t *)&mask[i], vl), 1, vl);\n        vse64_v_i64m8_m(&dst[i], mask_vec, src_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_1_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t vl = vsetvl_e32m8(length);\n    vint32m8_t v_src, v_tmp1, v_tmp2, v_result;\n    vint32m8_t v_scale = vmv_v_x_i32m8(scale, vl);\n\n    do {\n        v_src = vle32_v_i32m8(src, vl);\n        v_tmp1 = vsra_vx_i32m8(vsmul_vv_i32m8(v_src, v_scale, vl), 3, vl);\n        v_tmp2 = vsll_vx_i32m8(vsmul_vv_i32m8(v_src, v_scale, vl), 3, vl);\n        v_result = vdiv_vv_i32m8(vadd_vv_i32m8(vsmul_vv_i32m8(v_src, v_scale, vl), vsmul_vv_i32m8(v_tmp1, v_tmp2, vl), vl), vmv_v_x_i32m8(7, vl), vl);\n        vse32_v_i32m8(dst, v_result, vl);\n        src += vl;\n        dst += vl;\n        length -= vl;\n        vl = vsetvl_e32m8(length);\n    } while (length > 0);\n}\n```"}
{"task_id": "SimdBench_1_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t vl = vsetvl_e32m8(length);\n    vint32m8_t v_src, v_tmp1, v_tmp2, v_result;\n\n    do {\n        v_src = vle32_v_i32m8(src, vl);\n        v_tmp1 = vsra_vx_i32m8(vsmul_vx_i32m8(v_src, scale, vl), 3, vl);\n        v_tmp2 = vsll_vx_i32m8(vsmul_vx_i32m8(v_src, scale, vl), 3, vl);\n        v_result = vdiv_vv_i32m8(vadd_vv_i32m8(vsmul_vx_i32m8(v_src, scale, vl), vmul_vv_i32m8(v_tmp1, v_tmp2, vl), vl), 7, vl);\n        vse32_v_i32m8(dst, v_result, vl);\n\n        src += vl;\n        dst += vl;\n        length -= vl;\n        vl = vsetvl_e32m8(length);\n    } while (length > 0);\n}\n```"}
{"task_id": "SimdBench_1_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t vl = vsetvl_e32m8(length);\n    vint32m8_t v_src, v_tmp1, v_tmp2, v_result;\n\n    do {\n        v_src = vle32_v_i32m8(src, vl);\n        v_tmp1 = vsrl_vx_i32m8(vsmul_vx_i32m8(v_src, scale, vl), 3, vl);\n        v_tmp2 = vsll_vx_i32m8(vsmul_vx_i32m8(v_src, scale, vl), 3, vl);\n        v_result = vdiv_vv_i32m8(vadd_vv_i32m8(vsmul_vx_i32m8(v_src, scale, vl), vmul_vv_i32m8(v_tmp1, v_tmp2, vl), vl), 7, vl);\n        vse32_v_i32m8(dst, v_result, vl);\n\n        src += vl;\n        dst += vl;\n        length -= vl;\n        vl = vsetvl_e32m8(length);\n    } while (length > 0);\n}\n```"}
{"task_id": "SimdBench_1_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t vl = vsetvl_e32m8(length);\n    vint32m8_t v_src, v_tmp1, v_tmp2, v_result;\n    vint32m8_t v_scale = vmv_v_x_i32m8(scale, vl);\n\n    do {\n        v_src = vle32_v_i32m8(src, vl);\n        v_tmp1 = vsrl_vx_i32m8(vsmul_vv_i32m8(v_src, v_scale, vl), 3, vl);\n        v_tmp2 = vsll_vx_i32m8(vsmul_vv_i32m8(v_src, v_scale, vl), 3, vl);\n        v_result = vdiv_vv_i32m8(vadd_vv_i32m8(vsmul_vv_i32m8(v_src, v_scale, vl), vsmul_vv_i32m8(v_tmp1, v_tmp2, vl), vl), vmv_v_x_i32m8(7, vl), vl);\n        vse32_v_i32m8(dst, v_result, vl);\n\n        src += vl;\n        dst += vl;\n        length -= vl;\n        vl = vsetvl_e32m8(length);\n    } while (length > 0);\n}\n```"}
{"task_id": "SimdBench_1_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t vl = vsetvl_e32m8(length);\n    vint32m8_t v_src, v_tmp1, v_tmp2, v_result;\n\n    do {\n        v_src = vle32_v_i32m8(src, vl);\n        v_tmp1 = vsra_vx_i32m8(vsmul_vx_i32m8(v_src, scale, vl), 3, vl);\n        v_tmp2 = vsll_vx_i32m8(vsmul_vx_i32m8(v_src, scale, vl), 3, vl);\n        v_result = vdiv_vv_i32m8(vadd_vv_i32m8(vsmul_vx_i32m8(v_src, scale, vl), vmul_vv_i32m8(v_tmp1, v_tmp2, vl), vl), 7, vl);\n        vse32_v_i32m8(dst, v_result, vl);\n\n        src += vl;\n        dst += vl;\n        length -= vl;\n        vl = vsetvl_e32m8(length);\n    } while (length > 0);\n}\n```"}
{"task_id": "SimdBench_2_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t vl = vsetvl_e64m1(1);\n    vfloat64m1_t v_src;\n    for (size_t r = 0; r < rows; r++) {\n        v_src = vle64_v_f64m1(&src[r * cols + stride], vl);\n        vse64_v_f64m1(&dst[r], v_src, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_2_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t vl = vsetvl_e64m1(rows);\n    vfloat64m1_t v_src;\n    for (size_t r = 0; r < rows; r += vl) {\n        vl = vsetvl_e64m1(rows - r);\n        v_src = vle64_v_f64m1(&src[r * cols + stride], vl);\n        vse64_v_f64m1(&dst[r], v_src, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_2_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t vl = vsetvl_e64m1(1);\n    vfloat64m1_t v_src;\n    for (size_t r = 0; r < rows; r++) {\n        v_src = vle64_v_f64m1(&src[r * cols + stride], vl);\n        vse64_v_f64m1(&dst[r], v_src, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_2_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t vl = vsetvl_e64m1(1);\n    vfloat64m1_t v_src;\n    for (size_t r = 0; r < rows; r++) {\n        v_src = vle64_v_f64m1(&src[r * cols + stride], vl);\n        vse64_v_f64m1(&dst[r], v_src, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_2_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t vl = vsetvl_e64m1(rows);\n    vfloat64m1_t v_src;\n    for (size_t r = 0; r < rows; r += vl) {\n        vl = vsetvl_e64m1(rows - r);\n        v_src = vle64_v_f64m1(&src[r * cols + stride], vl);\n        vse64_v_f64m1(&dst[r], v_src, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_3_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t vl = vsetvl_e32m1(length);\n    vfloat32m1_t v_src, v_dst;\n    vint32m1_t v_indices;\n\n    // Gather operation\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n        v_indices = vle32_v_i32m1(&indices[i], vl);\n        v_src = vlsseg1e32_v_f32m1(src, v_indices, vl);\n        vse32_v_f32m1(&dst[i], v_src, vl);\n    }\n\n    // Scatter operation\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n        v_indices = vle32_v_i32m1(&indices[i], vl);\n        v_src = vle32_v_f32m1(&src[i], vl);\n        vsseg1e32_v_f32m1(dst, v_indices, v_src, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_3_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t vl = vsetvl_e32m1(length);\n    vfloat32m1_t v_src, v_dst;\n    vint32m1_t v_indices;\n\n    // Gather operation\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n        v_indices = vle32_v_i32m1(&indices[i], vl);\n        v_src = vlsseg1e32_v_f32m1(src, v_indices, vl);\n        vse32_v_f32m1(&dst[i], v_src, vl);\n    }\n\n    // Scatter operation\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n        v_indices = vle32_v_i32m1(&indices[i], vl);\n        v_src = vle32_v_f32m1(&src[i], vl);\n        vsseg1e32_v_f32m1(dst, v_indices, v_src, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_3_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t vl = vsetvl_e32m8(length);\n    vfloat32m8_t v_src, v_dst;\n    vint32m8_t v_indices;\n\n    do {\n        v_src = vle32_v_f32m8(src, vl);\n        v_indices = vle32_v_i32m8(indices, vl);\n\n        // Gather operation\n        v_dst = vlsseg32_v_f32m8(src, v_indices, vl);\n        vse32_v_f32m8(dst, v_dst, vl);\n\n        // Scatter operation\n        vsseg32_v_f32m8(dst, v_indices, v_src, vl);\n\n        src += vl;\n        indices += vl;\n        dst += vl;\n        length -= vl;\n        vl = vsetvl_e32m8(length);\n    } while (length > 0);\n}\n```"}
{"task_id": "SimdBench_3_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t vl = vsetvl_e32m8(length);\n    vfloat32m8_t v_src, v_dst;\n    vint32m8_t v_indices;\n\n    do {\n        v_src = vle32_v_f32m8(src, vl);\n        v_indices = vle32_v_i32m8(indices, vl);\n\n        // Gather operation\n        v_dst = vlsseg3e32_v_f32m8(src, v_indices, vl);\n        vse32_v_f32m8(dst, v_dst, vl);\n\n        // Scatter operation\n        vsseg3e32_v_f32m8(dst, v_indices, v_src, vl);\n\n        src += vl;\n        indices += vl;\n        dst += vl;\n        length -= vl;\n        vl = vsetvl_e32m8(length);\n    } while (length > 0);\n}\n```"}
{"task_id": "SimdBench_3_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t vl = vsetvl_e32m8(length);\n    vfloat32m8_t v_src, v_dst;\n    vint32m8_t v_indices;\n\n    do {\n        v_src = vle32_v_f32m8(src, vl);\n        v_indices = vle32_v_i32m8(indices, vl);\n\n        // Gather operation\n        v_dst = vlsseg32_v_f32m8(src, v_indices, vl);\n        vse32_v_f32m8(dst, v_dst, vl);\n\n        // Scatter operation\n        vsseg32_v_f32m8(dst, v_indices, v_src, vl);\n\n        src += vl;\n        indices += vl;\n        dst += vl;\n        length -= vl;\n        vl = vsetvl_e32m8(length);\n    } while (length > 0);\n}\n```"}
{"task_id": "SimdBench_4_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    size_t vl = vsetvl_e16m8(end - start + 1);\n    vint16m8_t vec1 = vle16_v_i16m8(&arr[start], vl);\n    vint16m8_t vec2 = vrev8_v_i16m8(vec1, vl);\n    vse16_v_i16m8(&arr[end - vl + 1], vec2, vl);\n\n    // Handle the middle part if the length is not a multiple of 8\n    size_t remaining = (end - start + 1) % 8;\n    if (remaining > 0) {\n        for (size_t i = 0; i < remaining / 2; i++) {\n            int16_t temp = arr[start + i];\n            arr[start + i] = arr[end - i];\n            arr[end - i] = temp;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_4_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    size_t vl = vsetvl_e16m8(end - start + 1);\n    vint16m8_t vec1 = vle16_v_i16m8(&arr[start], vl);\n    vint16m8_t vec2 = vrev8_v_i16m8(vec1, vl);\n    vse16_v_i16m8(&arr[end - vl + 1], vec2, vl);\n\n    // Handle the middle part if the length is not a multiple of the vector length\n    while (start < end) {\n        int16_t temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n```"}
{"task_id": "SimdBench_4_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    size_t n = end - start + 1;\n    size_t vl = vsetvl_e16m8(n);\n\n    vint16m8_t vec1 = vle16_v_i16m8(&arr[start], vl);\n    vint16m8_t vec2 = vrev8_v_i16m8(vec1, vl);\n\n    vse16_v_i16m8(&arr[end - vl + 1], vec2, vl);\n\n    for (size_t i = 1; i < n / vl; i++) {\n        vec1 = vle16_v_i16m8(&arr[start + i * vl], vl);\n        vec2 = vrev8_v_i16m8(vec1, vl);\n        vse16_v_i16m8(&arr[end - (i + 1) * vl + 1], vec2, vl);\n    }\n\n    if (n % vl) {\n        size_t remaining = n % vl;\n        vl = vsetvl_e16m8(remaining);\n        vec1 = vle16_v_i16m8(&arr[start + n - remaining], vl);\n        vec2 = vrev8_v_i16m8(vec1, vl);\n        vse16_v_i16m8(&arr[end - remaining + 1], vec2, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_4_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    size_t vl = vsetvl_e16m1(end - start + 1);\n    vint16m1_t vec1 = vle16_v_i16m1(&arr[start], vl);\n    vint16m1_t vec2 = vrev8_v_i16m1(vec1, vl);\n    vse16_v_i16m1(&arr[end - vl + 1], vec2, vl);\n\n    // Handle the middle part if the length is not a multiple of the vector length\n    while (start < end) {\n        int16_t temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n```"}
{"task_id": "SimdBench_4_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    size_t n = end - start + 1;\n    size_t vl = vsetvl_e16m8(n);\n\n    vint16m8_t vec1 = vle16_v_i16m8(&arr[start], vl);\n    vint16m8_t vec2 = vrev8_v_i16m8(vec1, vl);\n\n    vse16_v_i16m8(&arr[end - vl + 1], vec2, vl);\n\n    if (n > vl) {\n        size_t mid = n / 2;\n        size_t i = 0;\n        for (; i < mid - vl; i += vl) {\n            vec1 = vle16_v_i16m8(&arr[start + i], vl);\n            vec2 = vle16_v_i16m8(&arr[end - i - vl], vl);\n            vse16_v_i16m8(&arr[end - i - vl], vec1, vl);\n            vse16_v_i16m8(&arr[start + i], vec2, vl);\n        }\n\n        size_t remaining = mid - i;\n        if (remaining > 0) {\n            vl = vsetvl_e16m8(remaining);\n            vec1 = vle16_v_i16m8(&arr[start + i], vl);\n            vec2 = vle16_v_i16m8(&arr[end - i - vl], vl);\n            vse16_v_i16m8(&arr[end - i - vl], vec1, vl);\n            vse16_v_i16m8(&arr[start + i], vec2, vl);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t total_elements = dim1 * dim2;\n    size_t stride = dim1 * dim2 * dim3;\n    const uint8_t *start_ptr = tensor + slice_idx * total_elements;\n\n    size_t vl = vsetvl_e8m8(total_elements);\n    vuint8m8_t v_slice = vle8_v_u8m8(start_ptr, vl);\n    vse8_v_u8m8(slice, v_slice, vl);\n}\n```"}
{"task_id": "SimdBench_5_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t total_elements = dim1 * dim2;\n    size_t stride = dim1 * dim2 * dim3;\n    const uint8_t *start_ptr = tensor + slice_idx * total_elements;\n\n    size_t vl = vsetvl_e8m8(total_elements);\n    vuint8m8_t v_slice;\n\n    do {\n        v_slice = vle8_v_u8m8(start_ptr, vl);\n        vse8_v_u8m8(slice, v_slice, vl);\n\n        start_ptr += vl;\n        slice += vl;\n        total_elements -= vl;\n        vl = vsetvl_e8m8(total_elements);\n    } while (total_elements > 0);\n}\n```"}
{"task_id": "SimdBench_5_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t total_elements = dim1 * dim2;\n    size_t stride = dim1 * dim2 * dim3;\n    const uint8_t *start_ptr = tensor + slice_idx * total_elements;\n\n    size_t vl = vsetvl_e8m8(total_elements);\n    vuint8m8_t v_slice;\n\n    do {\n        v_slice = vle8_v_u8m8(start_ptr, vl);\n        vse8_v_u8m8(slice, v_slice, vl);\n\n        start_ptr += vl;\n        slice += vl;\n    } while ((vl = vsetvl_e8m8(total_elements - (slice - slice))) > 0);\n}\n```"}
{"task_id": "SimdBench_5_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t total_elements = dim1 * dim2;\n    size_t stride = dim1 * dim2 * dim3;\n    const uint8_t *start_ptr = tensor + slice_idx * total_elements;\n\n    size_t vlmax = vsetvl_e8m1(total_elements);\n    vuint8m1_t v_slice;\n\n    for (size_t i = 0; i < total_elements; i += vlmax) {\n        vlmax = vsetvl_e8m1(total_elements - i);\n        v_slice = vle8_v_u8m1(start_ptr + i, vlmax);\n        vse8_v_u8m1(slice + i, v_slice, vlmax);\n    }\n}\n```"}
{"task_id": "SimdBench_5_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t total_elements = dim1 * dim2;\n    size_t stride = dim1 * dim2 * dim3;\n    const uint8_t *start_ptr = tensor + slice_idx * total_elements;\n\n    size_t vlmax = vsetvl_e8m1(total_elements);\n    vuint8m1_t v_slice;\n    for (size_t i = 0; i < total_elements; i += vlmax) {\n        vlmax = vsetvl_e8m1(total_elements - i);\n        v_slice = vle8_v_u8m1(start_ptr + i, vlmax);\n        vse8_v_u8m1(slice + i, v_slice, vlmax);\n    }\n}\n```"}
{"task_id": "SimdBench_6_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t bi = 0; bi < block_size && i + bi < rows; ++bi) {\n                for (size_t bj = 0; bj < block_size && j + bj < cols; ++bj) {\n                    size_t src_idx = (i + bi) * cols + (j + bj);\n                    size_t dst_idx = (j + bj) * rows + (i + bi);\n                    size_t k = 0;\n                    size_t vlen = vsetvl_e16m8(block_size - k);\n                    vint16m8_t src_vec = vle16_v_i16m8(&src[src_idx + k * cols], vlen);\n                    vse16_v_i16m8(&dst[dst_idx + k * rows], src_vec, vlen);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t bi = 0; bi < block_size && i + bi < rows; ++bi) {\n                for (size_t bj = 0; bj < block_size && j + bj < cols; ++bj) {\n                    size_t src_index = (i + bi) * cols + (j + bj);\n                    size_t dst_index = (j + bj) * rows + (i + bi);\n                    size_t num_elements = 1;\n                    vint16m1_t src_vec = vle16_v_i16m1(&src[src_index], vl1e16m1(num_elements));\n                    vse16_v_i16m1(&dst[dst_index], src_vec, vl1e16m1(num_elements));\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t bi = 0; bi < block_size && i + bi < rows; ++bi) {\n                for (size_t bj = 0; bj < block_size && j + bj < cols; ++bj) {\n                    size_t src_idx = (i + bi) * cols + (j + bj);\n                    size_t dst_idx = (j + bj) * rows + (i + bi);\n                    size_t num_elements = 1;\n                    vint16m1_t src_vec = vle16_v_i16m1(&src[src_idx], vl1re16_v_i16m1(num_elements));\n                    vse16_v_i16m1(&dst[dst_idx], src_vec, vl1re16_v_i16m1(num_elements));\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t bi = 0; bi < block_size && i + bi < rows; ++bi) {\n                for (size_t bj = 0; bj < block_size && j + bj < cols; ++bj) {\n                    size_t src_index = (i + bi) * cols + (j + bj);\n                    size_t dst_index = (j + bj) * rows + (i + bi);\n                    size_t num_elements = 1;\n                    vint16m1_t src_vec = vle16_v_i16m1(&src[src_index], vl1re16_v_i16m1(num_elements));\n                    vse16_v_i16m1(&dst[dst_index], src_vec, vl1re16_v_i16m1(num_elements));\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t bi = 0; bi < block_size && i + bi < rows; ++bi) {\n                for (size_t bj = 0; bj < block_size && j + bj < cols; ++bj) {\n                    size_t src_idx = (i + bi) * cols + (j + bj);\n                    size_t dst_idx = (j + bj) * rows + (i + bi);\n                    size_t num_elements = 1;\n                    vint16m1_t src_vec = vle16_v_i16m1(&src[src_idx], vl1re16_v_i16m1(num_elements));\n                    vse16_v_i16m1(&dst[dst_idx], src_vec, vl1re16_v_i16m1(num_elements));\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_7_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t stride = dim * dim + dim + 1;\n    size_t total_elements = dim;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n        vfloat32m8_t v_values = vle32_v_f32m8(array + i * stride, vl);\n        vfloat32m8_t v_zeros = vfmv_v_f_f32(0.0f, vl);\n        vfloat32m8_t v_sum = vfadd_vv_f32m8(v_zeros, v_values, vl);\n        sum += vfredsum_vs_f32m8_f32(v_sum, 0.0f, vl);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t stride = dim * dim + dim + 1;\n    size_t total_elements = dim;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n        vfloat32m8_t v_values = vle32_v_f32m8(array + i * stride, vl);\n        vfloat32m8_t v_zeros = vfmv_v_f_f32(0.0f, vl);\n        vfloat32m8_t v_sum = vfadd_vv_f32m8(v_zeros, v_values, vl);\n        sum += vfredsum_vs_f32m8_f32(v_sum, 0.0f, vl);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t stride = dim * dim + dim + 1;\n    size_t vl = vsetvl_e32m8(dim);\n    vfloat32m8_t vsum = vfmv_v_f_f32m8(0.0f, vl);\n\n    for (size_t i = 0; i < dim; i += vl) {\n        vfloat32m8_t vdata = vle32_v_f32m8(array + i * stride, vl);\n        vsum = vfadd_vv_f32m8(vsum, vdata, vl);\n    }\n\n    sum = vfredusum_vs_f32m8_f32(vsum, 0.0f, vundefined_f32m1(), vl);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t stride = dim * dim + dim + 1;\n    size_t total_elements = dim;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n        vfloat32m8_t v_values = vle32_v_f32m8(array + i * stride, vl);\n        vfloat32m8_t v_zeros = vfmv_v_f_f32(0.0f, vl);\n        vfloat32m8_t v_sum = vfadd_vv_f32m8(v_zeros, v_values, vl);\n        sum += vfredsum_vs_f32m8_f32(v_sum, 0.0f, vl);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    size_t stride = dim * dim + dim + 1;\n    size_t total_elements = dim;\n    size_t vl = vsetvl_e32m8(total_elements);\n    vfloat32m8_t vsum = vfmv_v_f_f32m8(0.0f, vl);\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vfloat32m8_t vdata = vle32_v_f32m8(array + i * stride, vl);\n        vsum = vfadd_vv_f32m8(vsum, vdata, vl);\n    }\n\n    float result = vfmv_f_s_f32m8_f32(vsum);\n    return result;\n}\n```"}
{"task_id": "SimdBench_8_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t n = rows * cols;\n    size_t vl;\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e64m8(n - i);\n        vfloat64m8_t src_vec = vle64_v_f64m8(&src[i], vl);\n        vbool8_t mask = vfgt_vf_f64m8_b8(src_vec, threshold, vl);\n        vfloat64m8_t scaled_vec = vfmul_vf_f64m8_m(mask, src_vec, scale, src_vec, vl);\n        vse64_v_f64m8(&dst[i], scaled_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_8_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t n = rows * cols;\n    size_t vl;\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e64m8(n - i);\n        vfloat64m8_t src_vec = vle64_v_f64m8(&src[i], vl);\n        vbool8_t mask = vfgt_vf_f64m8_b8(src_vec, threshold, vl);\n        vfloat64m8_t scaled_vec = vfmul_vf_f64m8_m(mask, src_vec, scale, src_vec, vl);\n        vse64_v_f64m8(&dst[i], scaled_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_8_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e64m8(total_elements - i);\n\n        vfloat64m8_t src_vec = vle64_v_f64m8(&src[i], vl);\n        vbool8_t mask = vfgt_vf_f64m8_b8(src_vec, threshold, vl);\n        vfloat64m8_t scaled_vec = vfmul_vf_f64m8_m(mask, src_vec, scale, src_vec, vl);\n\n        vse64_v_f64m8(&dst[i], scaled_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_8_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e64m8(total_elements - i);\n\n        vfloat64m8_t src_vec = vle64_v_f64m8(&src[i], vl);\n        vbool8_t mask = vfgt_vf_f64m8_b8(src_vec, threshold, vl);\n        vfloat64m8_t scaled_vec = vfmul_vf_f64m8_m(mask, src_vec, scale, src_vec, vl);\n\n        vse64_v_f64m8(&dst[i], scaled_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_8_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t n = rows * cols;\n    size_t vl;\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e64m8(n - i);\n        vfloat64m8_t src_vec = vle64_v_f64m8(&src[i], vl);\n        vbool8_t mask = vfgt_vf_f64m8_b8(src_vec, threshold, vl);\n        vfloat64m8_t scaled_vec = vfmul_vf_f64m8_m(mask, src_vec, scale, src_vec, vl);\n        vse64_v_f64m8(&dst[i], scaled_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_9_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t i;\n    for (i = 0; i < rows; i++) {\n        size_t index = indices[i];\n        size_t col;\n        for (col = 0; col < cols; col += vsetvl_e64m8(cols - col)) {\n            vfloat64m8_t v_src = vle64_v_f64m8(&src[index * cols + col], vundefined());\n            vse64_v_f64m8(&dst[i * cols + col], v_src, vundefined());\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t i;\n    for (i = 0; i < rows; i++) {\n        size_t index = indices[i];\n        size_t j;\n        for (j = 0; j < cols; j += 2) {\n            vfloat64m2_t v_src = vle64_v_f64m2(&src[index * cols + j], VLMAX_e64m2);\n            vse64_v_f64m2(&dst[i * cols + j], v_src, VLMAX_e64m2);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t i;\n    for (i = 0; i < rows; i++) {\n        size_t index = indices[i];\n        size_t col;\n        for (col = 0; col < cols; col += vsetvl_e64m8(cols - col)) {\n            vfloat64m8_t v_src = vle64_v_f64m8(&src[index * cols + col], vundefined());\n            vse64_v_f64m8(&dst[i * cols + col], v_src, vundefined());\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t i;\n    for (i = 0; i < rows; i++) {\n        size_t index = indices[i];\n        size_t j;\n        for (j = 0; j < cols; j += 2) {\n            vfloat64m2_t v_src = vle64_v_f64m2(&src[index * cols + j], VLMAX_e64m2);\n            vse64_v_f64m2(&dst[i * cols + j], v_src, VLMAX_e64m2);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t i;\n    for (i = 0; i < rows; i++) {\n        size_t index = indices[i];\n        size_t j;\n        for (j = 0; j < cols; j += 2) {\n            vfloat64m2_t v_src = vle64_v_f64m2(&src[index * cols + j], VLMAX_e64m2);\n            vse64_v_f64m2(&dst[i * cols + j], v_src, VLMAX_e64m2);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_10_RVV", "completion": "```c\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t vl;\n    vint64m1_t vec_src1, vec_src2, vec_result, vec_scalar;\n\n    vec_scalar = vmv_v_x_i64m1(scalar, 1);\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m1(length - i);\n        vec_src1 = vle64_v_i64m1(&src1[i], vl);\n        vec_src2 = vle64_v_i64m1(&src2[i], vl);\n        vec_result = vadd_vv_i64m1(vec_src1, vec_src2, vl);\n        vec_result = vadd_vv_i64m1(vec_result, vec_scalar, vl);\n        vec_result = vsra_vx_i64m1(vec_result, 1, vl);\n        vse64_v_i64m1(&dst[i], vec_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_10_RVV", "completion": "```c\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t vl;\n    vint64m1_t vec_src1, vec_src2, vec_result, vec_scalar;\n\n    vec_scalar = vmv_v_x_i64m1(scalar, 1);\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m1(length - i);\n        vec_src1 = vle64_v_i64m1(&src1[i], vl);\n        vec_src2 = vle64_v_i64m1(&src2[i], vl);\n        vec_result = vadd_vv_i64m1(vec_src1, vec_src2, vl);\n        vec_result = vadd_vv_i64m1(vec_result, vec_scalar, vl);\n        vec_result = vsra_vx_i64m1(vec_result, 1, vl);\n        vse64_v_i64m1(&dst[i], vec_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_10_RVV", "completion": "```c\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t vl;\n    vint64m1_t vec_src1, vec_src2, vec_result, vec_scalar;\n\n    vec_scalar = vmv_v_x_i64m1(scalar, 1);\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m1(length - i);\n        vec_src1 = vle64_v_i64m1(&src1[i], vl);\n        vec_src2 = vle64_v_i64m1(&src2[i], vl);\n        vec_result = vadd_vv_i64m1(vec_src1, vec_src2, vl);\n        vec_result = vadd_vv_i64m1(vec_result, vec_scalar, vl);\n        vec_result = vsra_vx_i64m1(vec_result, 1, vl);\n        vse64_v_i64m1(&dst[i], vec_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_10_RVV", "completion": "```c\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t vl;\n    vint64m1_t vec_src1, vec_src2, vec_result, vec_scalar;\n\n    vec_scalar = vmv_v_x_i64m1(scalar, 1);\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m1(length - i);\n        vec_src1 = vle64_v_i64m1(&src1[i], vl);\n        vec_src2 = vle64_v_i64m1(&src2[i], vl);\n        vec_result = vadd_vv_i64m1(vec_src1, vec_src2, vl);\n        vec_result = vadd_vv_i64m1(vec_result, vec_scalar, vl);\n        vec_result = vsra_vx_i64m1(vec_result, 1, vl);\n        vse64_v_i64m1(&dst[i], vec_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_10_RVV", "completion": "```c\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t vl;\n    vint64m1_t vec_src1, vec_src2, vec_result, vec_scalar;\n\n    vec_scalar = vmv_v_x_i64m1(scalar, 1);\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m1(length - i);\n        vec_src1 = vle64_v_i64m1(&src1[i], vl);\n        vec_src2 = vle64_v_i64m1(&src2[i], vl);\n        vec_result = vadd_vv_i64m1(vec_src1, vec_src2, vl);\n        vec_result = vadd_vv_i64m1(vec_result, vec_scalar, vl);\n        vec_result = vsra_vx_i64m1(vec_result, 1, vl);\n        vse64_v_i64m1(&dst[i], vec_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_11_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    size_t vl = vsetvl_e32m1(length / 2);\n    vint32m1_t min_vec = vundefined_v_i32m1();\n    min_vec = vle32_v_i32m1(src, vl);\n\n    for (size_t i = vl; i < length / 2; i += vl) {\n        vint32m1_t vec = vle32_v_i32m1(&src[i * 2], vl);\n        min_vec = vmin_vv_i32m1(min_vec, vec, vl);\n    }\n\n    int result = __INT32_MAX__;\n    for (size_t i = 0; i < vl; ++i) {\n        int val = vget_v_i32m1_i32(min_vec, i);\n        if (val < result) {\n            result = val;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_11_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    size_t vl = vsetvl_e32m1(length / 2);\n    vint32m1_t min_vec = vundefined_v_i32m1();\n    bool first_iter = true;\n\n    for (size_t i = 0; i < length; i += vl * 2) {\n        vl = vsetvl_e32m1((length - i) / 2);\n        vint32m1_t even_elements = vle32_v_i32m1(&src[i], vl);\n        if (first_iter) {\n            min_vec = even_elements;\n            first_iter = false;\n        } else {\n            min_vec = vmin_vv_i32m1(min_vec, even_elements, vl);\n        }\n    }\n\n    int result = __INT32_MAX__;\n    for (size_t i = 0; i < vl; ++i) {\n        int temp;\n        vse32_v_i32m1(&temp, min_vec, 1);\n        if (temp < result) {\n            result = temp;\n        }\n        min_vec = vslide1down_vx_i32m1(min_vec, 0, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_11_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    size_t vl = vsetvl_e32m1(length / 2);\n    vint32m1_t min_vec = vundefined_v_i32m1();\n    min_vec = vle32_v_i32m1(src, vl);\n\n    for (size_t i = vl; i < length / 2; i += vl) {\n        vl = vsetvl_e32m1(length / 2 - i);\n        vint32m1_t vec = vle32_v_i32m1(&src[i * 2], vl);\n        min_vec = vmin_vv_i32m1(min_vec, vec, vl);\n    }\n\n    int min_val = vredmin_vs_i32m1_i32(min_vec, INT32_MAX, vl);\n\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    size_t vl = vsetvl_e32m1(length / 2);\n    vint32m1_t min_vec = vundefined_v_i32m1();\n    min_vec = vle32_v_i32m1(src, vl);\n\n    for (size_t i = vl; i < length / 2; i += vl) {\n        vint32m1_t vec = vle32_v_i32m1(&src[i * 2], vl);\n        min_vec = vmin_vv_i32m1(min_vec, vec, vl);\n    }\n\n    int min_val = vredmin_vs_i32m1_i32(min_vec, INT32_MAX, vl);\n\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    size_t vl = vsetvl_e32m1(length / 2);\n    vint32m1_t min_vec = vle32_v_i32m1(src, vl);\n    src += 2 * vl;\n\n    while (vl > 0) {\n        size_t new_vl = vsetvl_e32m1(length / 2 - (src - src) / 2);\n        vint32m1_t vec = vle32_v_i32m1(src, new_vl);\n        min_vec = vmin_vv_i32m1(min_vec, vec, new_vl);\n        src += 2 * new_vl;\n        vl = new_vl;\n    }\n\n    int result = __INT32_MAX__;\n    for (size_t i = 0; i < vgetvl_e32m1(min_vec); ++i) {\n        int val;\n        vse32_v_i32m1(&val, min_vec, 1);\n        result = val < result ? val : result;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_12_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t vl = vsetvl_e32m8(length);\n    vint32m8_t src_v = vle32_v_i32m8(src, vl);\n    vint32m8_t arith_shift_v = vsra_vx_i32m8(src_v, shift, vl);\n    vuint32m8_t logic_shift_v = vsrl_vx_u32m8(vreinterpret_v_u32m8_i32m8(src_v), shift, vl);\n    vint32m8_t result_v = vadd_vv_i32m8(arith_shift_v, vreinterpret_v_i32m8_u32m8(logic_shift_v), vl);\n    vse32_v_i32m8(dst, result_v, vl);\n\n    for (size_t i = vl; i < length; ++i) {\n        int arith_shift = src[i] >> shift;\n        int logic_shift = (unsigned int)src[i] >> shift;\n        dst[i] = arith_shift + logic_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t vl = vsetvl_e32m8(length);\n    vint32m8_t src_v = vle32_v_i32m8(src, vl);\n    vint32m8_t arith_shift_v = vsra_vx_i32m8(src_v, shift, vl);\n    vuint32m8_t logic_shift_v = vsrl_vx_u32m8(vreinterpret_v_u32m8_i32m8(src_v), shift, vl);\n    vint32m8_t result_v = vadd_vv_i32m8(arith_shift_v, vreinterpret_v_i32m8_u32m8(logic_shift_v), vl);\n    vse32_v_i32m8(dst, result_v, vl);\n\n    for (size_t i = vl; i < length; i++) {\n        int arith_shift = src[i] >> shift;\n        int logic_shift = (unsigned int)src[i] >> shift;\n        dst[i] = arith_shift + logic_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t vl = vsetvl_e32m8(length);\n    vint32m8_t src_v = vle32_v_i32m8(src, vl);\n    vint32m8_t arith_shift_v = vsra_vx_i32m8(src_v, shift, vl);\n    vuint32m8_t logic_shift_v = vsrl_vx_u32m8(vreinterpret_v_u32m8_i32m8(src_v), shift, vl);\n    vint32m8_t result_v = vadd_vv_i32m8(arith_shift_v, vreinterpret_v_i32m8_u32m8(logic_shift_v), vl);\n    vse32_v_i32m8(dst, result_v, vl);\n\n    for (size_t i = vl; i < length; ++i) {\n        int arith_shift = src[i] >> shift;\n        int logic_shift = (unsigned int)src[i] >> shift;\n        dst[i] = arith_shift + logic_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12_RVV", "completion": "```c\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t vl = vsetvl_e32m8(length);\n    vint32m8_t src_v = vle32_v_i32m8(src, vl);\n    vint32m8_t arith_shift_v = vsra_vx_i32m8(src_v, shift, vl);\n    vuint32m8_t logic_shift_v = vsrl_vx_u32m8(vreinterpret_v_u32m8_i32m8(src_v), shift, vl);\n    vint32m8_t result_v = vadd_vv_i32m8(arith_shift_v, vreinterpret_v_i32m8_u32m8(logic_shift_v), vl);\n    vse32_v_i32m8(dst, result_v, vl);\n\n    for (size_t i = vl; i < length; ++i) {\n        int arith_shift = src[i] >> shift;\n        int logic_shift = (unsigned int)src[i] >> shift;\n        dst[i] = arith_shift + logic_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t vl = vsetvl_e32m8(length);\n    vint32m8_t v_src = vle32_v_i32m8(src, vl);\n    vint32m8_t v_arith_shift = vsra_vx_i32m8(v_src, shift, vl);\n    vuint32m8_t v_uint_src = vreinterpret_v_i32m8_u32m8(v_src);\n    vuint32m8_t v_logic_shift = vsrl_vx_u32m8(v_uint_src, shift, vl);\n    vint32m8_t v_result = vadd_vv_i32m8(v_arith_shift, vreinterpret_v_u32m8_i32m8(v_logic_shift), vl);\n    vse32_v_i32m8(dst, v_result, vl);\n\n    for (size_t i = vl; i < length; i++) {\n        int arith_shift = src[i] >> shift;\n        unsigned int logic_shift = (unsigned int)src[i] >> shift;\n        dst[i] = arith_shift + (int)logic_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_13_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    int64_t sum = 0;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n        vint32m8_t vec = vle32_v_i32m8(&matrix[i], vl);\n        vint64m4_t acc = vmv_v_x_i64m4(0, vl);\n        acc = vwredsum_vs_i32m8_i64m4(acc, vec, acc, vl);\n        sum += vfirst_m_i64m4(acc, vl);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    int64_t sum = 0;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n        vint32m8_t vec = vle32_v_i32m8(&matrix[i], vl);\n        vint64m4_t acc = vmv_v_x_i64m4(0, vl);\n        acc = vredsum_vs_i32m8_i64m4(acc, vec, acc, vl);\n        sum += vfirst_m_i64m4(acc, vl);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    int64_t sum = 0;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n        vint32m8_t vec = vle32_v_i32m8(matrix + i, vl);\n        vint64m4_t acc = vmv_v_x_i64m4(0, vl);\n        acc = vredsum_vs_i32m8_i64m4(acc, vec, acc, vl);\n        sum += vmv_x_s_i64m4_i64(acc);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    int64_t sum = 0;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n        vint32m8_t vec = vle32_v_i32m8(&matrix[i], vl);\n        vint64m4_t acc = vmv_v_x_i64m4(0, vl);\n        acc = vredsum_vs_i32m8_i64m4(acc, vec, acc, vl);\n        sum += vfirst_m_i64m4(acc, vl);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    int64_t sum = 0;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n        vint32m8_t vec = vle32_v_i32m8(&matrix[i], vl);\n        vint64m4_t acc = vmv_v_x_i64m4(0, vl);\n        acc = vredsum_vs_i32m8_i64m4(acc, vec, acc, vl);\n        sum += vfirst_m_i64m4(acc, vl);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_14_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n\n    size_t vl;\n    vint8m1_t v_src;\n    vbool8_t v_mask;\n    size_t index;\n\n    for (index = 0; index < length; index += vl) {\n        vl = vsetvl_e8m1(length - index);\n        v_src = vle8_v_i8m1(&src[index], vl);\n        v_mask = vmgt_vx_i8m1_b8(v_src, max_value, vl);\n\n        if (vfirst_m_b8(v_mask, vl) != UINT64_MAX) {\n            size_t local_index = vfirst_m_b8(v_mask, vl);\n            max_value = src[index + local_index];\n            max_index = index + local_index;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n\n    size_t vl;\n    vint8m1_t v_src;\n    vbool8_t v_mask;\n    size_t index;\n\n    for (index = 0; index < length; index += vl) {\n        vl = vsetvl_e8m1(length - index);\n        v_src = vle8_v_i8m1(&src[index], vl);\n        v_mask = vmgt_vx_i8m1_b8(v_src, max_value, vl);\n\n        if (vfirst_m_b8(v_mask, vl) != UINT8_MAX) {\n            size_t local_index = vfirst_m_b8(v_mask, vl);\n            max_value = src[index + local_index];\n            max_index = index + local_index;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n\n    size_t vl;\n    vint8m1_t v_src;\n    vbool8_t v_mask;\n    size_t index;\n\n    for (index = 0; index < length; index += vl) {\n        vl = vsetvl_e8m1(length - index);\n        v_src = vle8_v_i8m1(&src[index], vl);\n        v_mask = vmgt_vx_i8m1_b8(v_src, max_value, vl);\n\n        if (vfirst_m_b8(v_mask, vl) != UINT8_MAX) {\n            size_t local_index = vfirst_m_b8(v_mask, vl);\n            max_value = src[index + local_index];\n            max_index = index + local_index;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n\n    size_t vl;\n    vint8m1_t v_src;\n    vbool8_t v_mask;\n    size_t v_index;\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e8m1(length - i);\n        v_src = vle8_v_i8m1(&src[i], vl);\n        v_mask = vmgt_vx_i8m1_b8(v_src, max_value, vl);\n\n        if (vfirst_m_b8(v_mask, vl) != UINT64_MAX) {\n            v_index = vfirst_m_b8(v_mask, vl) + i;\n            max_value = src[v_index];\n            max_index = v_index;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n\n    size_t vl;\n    vint8m1_t v_src;\n    vbool8_t v_mask;\n    size_t index;\n\n    for (index = 0; index < length; index += vl) {\n        vl = vsetvl_e8m1(length - index);\n        v_src = vle8_v_i8m1(&src[index], vl);\n        v_mask = vmgt_vx_i8m1_b8(v_src, max_value, vl);\n\n        if (vfirst_m_b8(v_mask, vl) != UINT64_MAX) {\n            size_t local_index = vfirst_m_b8(v_mask, vl);\n            max_value = src[index + local_index];\n            max_index = index + local_index;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_15_RVV", "completion": "```c\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16m8(length - i);\n        vuint16m8_t v_src1 = vle16_v_u16m8(src1 + i, vl);\n        vuint16m8_t v_src2 = vle16_v_u16m8(src2 + i, vl);\n        vbool8_t v_mask = vmseq_m_b8(vl, vand_vx_u16m8(vle16_v_u16m8((uint16_t*)&i, vl), mask, vl), 0, vl);\n        vse16_v_u16m8(dst + i, vmerge_vvm_u16m8(v_mask, v_src2, v_src1, vl));\n    }\n}\n```"}
{"task_id": "SimdBench_15_RVV", "completion": "```c\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16m8(length - i);\n        vuint16m8_t v_src1 = vle16_v_u16m8(&src1[i], vl);\n        vuint16m8_t v_src2 = vle16_v_u16m8(&src2[i], vl);\n        vbool8_t v_mask = vmseq_vx_u16m8_b8(vand_vx_u16m8(vcreate_u16m8(i), mask, vl), 0, vl);\n        vse16_v_u16m8(&dst[i], vmerge_vvm_u16m8(v_mask, v_src2, v_src1, vl));\n    }\n}\n```"}
{"task_id": "SimdBench_15_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16m8(length - i);\n        vuint16m8_t v_src1 = vle16_v_u16m8(src1 + i, vl);\n        vuint16m8_t v_src2 = vle16_v_u16m8(src2 + i, vl);\n        vbool4m8_t v_mask = vmseq_m_b4m8_b4m8(vmsne_vx_u32m8_b4m8(mask & i, 0, vl), 1, vl);\n        vuint16m8_t v_result = vmerge_vvm_u16m8(v_mask, v_src1, v_src2, vl);\n        vse16_v_u16m8(dst + i, v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_15_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16m8(length - i);\n        vuint16m8_t v_src1 = vle16_v_u16m8(src1 + i, vl);\n        vuint16m8_t v_src2 = vle16_v_u16m8(src2 + i, vl);\n        vbool4m8_t v_mask = vmseq_m_b4m8_b4m8(vreinterpret_v_u16m8_u32m8(vmv_v_x_u32m8(mask, vl)), vzero_v_u32m8(vl), vl);\n        v_mask = vmnez_vx_b4m8(v_mask, 0, vl);\n        vuint16m8_t v_dst = vmerge_vvm_u16m8(v_mask, v_src1, v_src2, vl);\n        vse16_v_u16m8(dst + i, v_dst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_15_RVV", "completion": "```c\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16m8(length - i);\n        vuint16m8_t v_src1 = vle16_v_u16m8(&src1[i], vl);\n        vuint16m8_t v_src2 = vle16_v_u16m8(&src2[i], vl);\n        vbool8_t v_mask = vmseq_m_b8(vl, vand_vx_u16m8(vle16_v_u16m8((const uint16_t*)&i, vl), mask, vl), 0, vl);\n        vse16_v_u16m8(&dst[i], vmerge_vvm_u16m8(v_mask, v_src2, v_src1, vl));\n    }\n}\n```"}
{"task_id": "SimdBench_16_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        vuint32m8_t src_v = vle32_v_u32m8(&src[i], vl);\n        vuint32m8_t popcount_v = vpopcnt_v_u32m8(src_v, vl);\n        vse32_v_u32m8(&dst[i], popcount_v, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_16_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        vuint32m8_t src_v = vle32_v_u32m8(&src[i], vl);\n        vuint32m8_t popcount_v = vpopcnt_v_u32m8(src_v, vl);\n        vse32_v_u32m8(&dst[i], popcount_v, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_16_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        vuint32m8_t src_v = vle32_v_u32m8(&src[i], vl);\n        vuint32m8_t popcount_v = vcpop_m_b8(vundefined_u8m1(), src_v, vl);\n        vse32_v_u32m8(&dst[i], popcount_v, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_16_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        vuint32m8_t src_v = vle32_v_u32m8(&src[i], vl);\n        vuint32m8_t popcount_v = vcpop_m_b8(src_v, vl);\n        vse32_v_u32m8(&dst[i], popcount_v, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_16_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        vuint32m8_t src_v = vle32_v_u32m8(&src[i], vl);\n        vuint32m8_t popcount_v = vpopcnt_v_u32m8(src_v, vl);\n        vse32_v_u32m8(&dst[i], popcount_v, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_17_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16m8(length - i);\n        vuint16m8_t vec1 = vle16_v_u16m8(&src1[i], vl);\n        vuint16m8_t vec2 = vle16_v_u16m8(&src2[i], vl);\n        vuint16m8_t result = vsaddu_vv_u16m8(vec1, vec2, vl);\n        vse16_v_u16m8(&dst[i], result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_17_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n#include <limits.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16m8(length - i);\n        vuint16m8_t vec1 = vle16_v_u16m8(&src1[i], vl);\n        vuint16m8_t vec2 = vle16_v_u16m8(&src2[i], vl);\n        vuint16m8_t result = vsaddu_vv_u16m8(vec1, vec2, vl);\n        vse16_v_u16m8(&dst[i], result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_17_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n#include <limits.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16m8(length - i);\n        vuint16m8_t vec1 = vle16_v_u16m8(&src1[i], vl);\n        vuint16m8_t vec2 = vle16_v_u16m8(&src2[i], vl);\n        vuint16m8_t result = vsaddu_vv_u16m8(vec1, vec2, vl);\n        vse16_v_u16m8(&dst[i], result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_17_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16m8(length - i);\n        vuint16m8_t vec1 = vle16_v_u16m8(&src1[i], vl);\n        vuint16m8_t vec2 = vle16_v_u16m8(&src2[i], vl);\n        vuint16m8_t result = vsaddu_vv_u16m8(vec1, vec2, vl);\n        vse16_v_u16m8(&dst[i], result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_17_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16m8(length - i);\n        vuint16m8_t vec1 = vle16_v_u16m8(&src1[i], vl);\n        vuint16m8_t vec2 = vle16_v_u16m8(&src2[i], vl);\n        vuint16m8_t result = vsaddu_vv_u16m8(vec1, vec2, vl);\n        vse16_v_u16m8(&dst[i], result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_18_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double c = 0.0;\n            size_t k = 0;\n            while (k < n) {\n                size_t vl = vsetvl_e64m8(n - k);\n                vfloat64m8_t va = vle64_v_f64m8(&A[i * n + k], vl);\n                vfloat64m8_t vb = vle64_v_f64m8(&B[j + k * p], vl);\n                vbool64_t mask_a = vmflt_vf_f64m8_b64(va, 100.0, vl);\n                vbool64_t mask_b = vmflt_vf_f64m8_b64(vb, 100.0, vl);\n                vbool64_t mask_a_neg = vmfge_vf_f64m8_b64(va, -100.0, vl);\n                vbool64_t mask_b_neg = vmfge_vf_f64m8_b64(vb, -100.0, vl);\n                vbool64_t mask = vand_vv_b64(mask_a, mask_b, vl);\n                mask = vand_vv_b64(mask, mask_a_neg, vl);\n                mask = vand_vv_b64(mask, mask_b_neg, vl);\n                vfloat64m8_t va_filtered = vcompress_vm_f64m8(va, mask, vl);\n                vfloat64m8_t vb_filtered = vcompress_vm_f64m8(vb, mask, vl);\n                size_t filtered_vl = vpopc_m_b64(mask, vl);\n                vfloat64m8_t vmul = vfmul_vv_f64m8(va_filtered, vb_filtered, filtered_vl);\n                double sum = vfredusum_vs_f64m8_f64(vmul, 0.0, filtered_vl);\n                c += sum;\n                k += vl;\n            }\n            C[i * p + j] = c;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double c = 0.0;\n            size_t k = 0;\n            for (; k <= n - VL_MAX_D; k += VL_MAX_D) {\n                vbool8_t mask_a = vmfgt_vf_d_b(vle64_v_f64m8(&A[i * n + k], VL_MAX_D), -100.0, VL_MAX_D);\n                vbool8_t mask_b = vmfgt_vf_d_b(vle64_v_f64m8(&B[j + k * p], VL_MAX_D), -100.0, VL_MAX_D);\n                vbool8_t mask_a_pos = vfmle_vf_d_b(vle64_v_f64m8(&A[i * n + k], VL_MAX_D), 100.0, VL_MAX_D);\n                vbool8_t mask_b_pos = vfmle_vf_d_b(vle64_v_f64m8(&B[j + k * p], VL_MAX_D), 100.0, VL_MAX_D);\n                vbool8_t mask = vmand_mm_b(mask_a, mask_b, VL_MAX_D);\n                mask = vmand_mm_b(mask, mask_a_pos, VL_MAX_D);\n                mask = vmand_mm_b(mask, mask_b_pos, VL_MAX_D);\n                vfloat64m8_t va = vle64_v_f64m8(&A[i * n + k], VL_MAX_D);\n                vfloat64m8_t vb = vle64_v_f64m8(&B[j + k * p], VL_MAX_D);\n                vfloat64m8_t vmul = vfmul_vv_f64m8_m(mask, va, vb, vundefined_f64m8(), VL_MAX_D);\n                c += vfredusum_vs_f64m8_f64(vmul, 0.0, vundefined_f64m1(), VL_MAX_D);\n            }\n            for (; k < n; ++k) {\n                if (A[i * n + k] >= -100.0 && A[i * n + k] <= 100.0 && B[j + k * p] >= -100.0 && B[j + k * p] <= 100.0) {\n                    c += A[i * n + k] * B[j + k * p];\n                }\n            }\n            C[i * p + j] = c;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double c = 0.0;\n            size_t k = 0;\n            while (k < n) {\n                size_t vl = vsetvl_e64m8(n - k);\n                vfloat64m8_t va = vle64_v_f64m8(&A[i * n + k], vl);\n                vfloat64m8_t vb = vle64_v_f64m8(&B[j + k * p], vl);\n                vbool8_t mask_a = vmflt_vf_f64m8_b8(va, 100.0, vl);\n                vbool8_t mask_b = vmflt_vf_f64m8_b8(vb, 100.0, vl);\n                vbool8_t mask_a_neg = vmfge_vf_f64m8_b8(va, -100.0, vl);\n                vbool8_t mask_b_neg = vmfge_vf_f64m8_b8(vb, -100.0, vl);\n                vbool8_t mask = vmand_vv_b8(mask_a, mask_b, vl);\n                mask = vmand_vv_b8(mask, mask_a_neg, vl);\n                mask = vmand_vv_b8(mask, mask_b_neg, vl);\n                vfloat64m8_t va_filtered = vcompress_vm_f64m8(va, mask, vl);\n                vfloat64m8_t vb_filtered = vcompress_vm_f64m8(vb, mask, vl);\n                size_t filtered_vl = vpopc_m_b8(mask, vl);\n                vfloat64m8_t vmul = vfmul_vv_f64m8(va_filtered, vb_filtered, filtered_vl);\n                double sum = vfredsum_vs_f64m8_f64(vmul, 0.0, filtered_vl);\n                c += sum;\n                k += vl;\n            }\n            C[i * p + j] = c;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    size_t i, j, k;\n    double min_val = -100.0;\n    double max_val = 100.0;\n\n    for (i = 0; i < m; ++i) {\n        for (j = 0; j < p; ++j) {\n            double sum = 0.0;\n            size_t l = 0;\n            for (; l <= n - VL_MAX_D; l += VL_MAX_D) {\n                vfloat64m1_t va = vle64_v_f64m1(&A[i * n + l], VL_MAX_D);\n                vfloat64m1_t vb = vle64_v_f64m1(&B[j + l * p], VL_MAX_D);\n                vbool64_t mask_a = vmflt_vf_f64m1_b64(va, max_val, VL_MAX_D);\n                vbool64_t mask_b = vmfgt_vf_f64m1_b64(vb, min_val, VL_MAX_D);\n                vbool64_t mask = vmand_vv_b64(mask_a, mask_b, VL_MAX_D);\n                va = vfmul_vv_f64m1_m(mask, va, vb, va, VL_MAX_D);\n                sum += vfredsum_vs_f64m1_f64(va, vfmv_f_s_f64m1(0.0, VL_MAX_D), VL_MAX_D);\n            }\n            for (; l < n; ++l) {\n                double a = A[i * n + l];\n                double b = B[j + l * p];\n                if (a >= min_val && a <= max_val && b >= min_val && b <= max_val) {\n                    sum += a * b;\n                }\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double c = 0.0;\n            size_t k = 0;\n            while (k < n) {\n                size_t vl = vsetvl_e64m8(n - k);\n                vfloat64m8_t va = vle64_v_f64m8(&A[i * n + k], vl);\n                vfloat64m8_t vb = vle64_v_f64m8(&B[j + k * p], vl);\n                vbool64_t mask_a = vmflt_vf_i64m8_b64(va, 100.0, vl);\n                vbool64_t mask_b = vmflt_vf_i64m8_b64(vb, 100.0, vl);\n                vbool64_t mask_a_neg = vmfgt_vf_i64m8_b64(va, -100.0, vl);\n                vbool64_t mask_b_neg = vmfgt_vf_i64m8_b64(vb, -100.0, vl);\n                vbool64_t mask = vmand_vv_i64m8_b64(mask_a, mask_b, vl);\n                mask = vmand_vv_i64m8_b64(mask, mask_a_neg, vl);\n                mask = vmand_vv_i64m8_b64(mask, mask_b_neg, vl);\n                vfloat64m8_t va_filtered = vcompress_vm_f64m8(va, mask, vl);\n                vfloat64m8_t vb_filtered = vcompress_vm_f64m8(vb, mask, vl);\n                size_t filtered_vl = vpopc_m_b64(mask, vl);\n                vfloat64m8_t vmul = vfmul_vv_f64m8(va_filtered, vb_filtered, filtered_vl);\n                double sum = vfredusum_vs_f64m8_f64(vmul, 0.0, filtered_vl);\n                c += sum;\n                k += vl;\n            }\n            C[i * p + j] = c;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e64m8(total_elements - i);\n        vint64m8_t va = vle64_v_i64m8(&A[i], vl);\n        vint64m8_t vb = vle64_v_i64m8(&B[i], vl);\n        vint64m8_t vc = vadd_vv_i64m8(va, vb, vl);\n        vse64_v_i64m8(&C[i], vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_19_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e64m8(total_elements - i);\n        vint64m8_t va = vle64_v_i64m8(&A[i], vl);\n        vint64m8_t vb = vle64_v_i64m8(&B[i], vl);\n        vint64m8_t vc = vadd_vv_i64m8(va, vb, vl);\n        vse64_v_i64m8(&C[i], vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_19_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e64m8(total_elements - i);\n        vint64m8_t va = vle64_v_i64m8(&A[i], vl);\n        vint64m8_t vb = vle64_v_i64m8(&B[i], vl);\n        vint64m8_t vc = vadd_vv_i64m8(va, vb, vl);\n        vse64_v_i64m8(&C[i], vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_19_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e64m8(total_elements - i);\n        vint64m8_t va = vle64_v_i64m8(&A[i], vl);\n        vint64m8_t vb = vle64_v_i64m8(&B[i], vl);\n        vint64m8_t vc = vadd_vv_i64m8(va, vb, vl);\n        vse64_v_i64m8(&C[i], vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_19_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e64m8(total_elements - i);\n        vint64m8_t va = vle64_v_i64m8(&A[i], vl);\n        vint64m8_t vb = vle64_v_i64m8(&B[i], vl);\n        vint64m8_t vc = vadd_vv_i64m8(va, vb, vl);\n        vse64_v_i64m8(&C[i], vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_20_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        vfloat32m8_t vec1 = vle32_v_f32m8(&src1[i], vl);\n        vfloat32m8_t vec2 = vle32_v_f32m8(&src2[i], vl);\n        vfloat32m8_t sum = vfadd_vv_f32m8(vec1, vec2, vl);\n        vint32m8_t rounded_sum = vfcvt_rtz_x_f_v_i32m8(sum, vl);\n        vse32_v_i32m8(&dst[i], rounded_sum, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_20_RVV", "completion": "```c\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        vfloat32m8_t vec1 = vle32_v_f32m8(&src1[i], vl);\n        vfloat32m8_t vec2 = vle32_v_f32m8(&src2[i], vl);\n        vfloat32m8_t sum = vfadd_vv_f32m8(vec1, vec2, vl);\n        vint32m8_t rounded_sum = vfcvt_rtz_x_f_v_i32m8(sum, vl);\n        vse32_v_i32m8(&dst[i], rounded_sum, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_20_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        vfloat32m8_t vec1 = vle32_v_f32m8(&src1[i], vl);\n        vfloat32m8_t vec2 = vle32_v_f32m8(&src2[i], vl);\n        vfloat32m8_t sum = vfadd_vv_f32m8(vec1, vec2, vl);\n        vint32m8_t rounded_sum = vfcvt_rtz_x_f_v_i32m8(sum, vl);\n        vse32_v_i32m8(&dst[i], rounded_sum, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_20_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        vfloat32m8_t vec1 = vle32_v_f32m8(&src1[i], vl);\n        vfloat32m8_t vec2 = vle32_v_f32m8(&src2[i], vl);\n        vfloat32m8_t sum = vfadd_vv_f32m8(vec1, vec2, vl);\n        vint32m8_t rounded_sum = vfcvt_rtz_x_f_v_i32m8(sum, vl);\n        vse32_v_i32m8(&dst[i], rounded_sum, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_20_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        vfloat32m8_t vec1 = vle32_v_f32m8(&src1[i], vl);\n        vfloat32m8_t vec2 = vle32_v_f32m8(&src2[i], vl);\n        vfloat32m8_t vec_sum = vfadd_vv_f32m8(vec1, vec2, vl);\n        vint32m8_t vec_rounded = vfcvt_rtz_x_f_v_i32m8(vec_sum, vl);\n        vse32_v_i32m8(&dst[i], vec_rounded, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_21_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length){\n    size_t i = 0;\n    vfloat32m8_t v_src1, v_src2, v_result, v_abs_diff, v_threshold, v_neg_one;\n    vbool4_t v_mask;\n    float threshold = 50.0f;\n    float neg_one = -1.0f;\n\n    v_threshold = vfmv_v_f_f32m8(threshold, 8);\n    v_neg_one = vfmv_v_f_f32m8(neg_one, 8);\n\n    for (; i <= length - 8; i += 8) {\n        v_src1 = vle32_v_f32m8(src1 + i, 8);\n        v_src2 = vle32_v_f32m8(src2 + i, 8);\n\n        v_abs_diff = vfabs_vv_f32m8(vfsub_vv_f32m8(v_src1, v_src2, 8), 8);\n        v_mask = vmflt_vv_b4_f32m8(v_abs_diff, v_threshold, 8);\n\n        v_result = vfmul_vv_f32m8_m(v_mask, v_src1, v_src2, 8);\n        v_result = vfredusum_vs_f32m8_f32mf2(v_result, vfmv_s_f_f32mf2(0.0f, 2), 8);\n        v_result = vfcvt_xu_f_v_i32m8(vfrdiv_vf_f32m8(v_result, 1.0f, 8), 8);\n        v_result = vfcvt_f_xu_v_f32m8(v_result, 8);\n        v_result = vfmax_vv_f32m8(v_result, v_neg_one, 8);\n\n        vse32_v_f32m8(dst + i, v_result, 8);\n    }\n\n    for (; i < length; i++) {\n        if (i % 2 == 0 && fabsf(src1[i] - src2[i]) <= 50.0f) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length){\n    size_t i = 0;\n    vfloat32m8_t v_src1, v_src2, v_result, v_abs_diff, v_threshold, v_neg_one;\n    vbool4_t v_mask;\n    float32_t threshold = 50.0f;\n    float32_t neg_one = -1.0f;\n\n    v_threshold = vfmv_v_f_f32m8(threshold, 8);\n    v_neg_one = vfmv_v_f_f32m8(neg_one, 8);\n\n    for (; i <= length - 8; i += 8) {\n        v_src1 = vle32_v_f32m8(&src1[i], 8);\n        v_src2 = vle32_v_f32m8(&src2[i], 8);\n\n        v_abs_diff = vfabs_vv_f32m8(vfsub_vv_f32m8(v_src1, v_src2, 8), 8);\n        v_mask = vmflt_vv_b4_f32m8(v_abs_diff, v_threshold, 8);\n\n        v_result = vfmul_vv_f32m8_m(v_mask, v_src1, v_src2, 8);\n        v_result = vfredusum_vs_f32m8_f32mf2(v_result, vfmv_s_f_f32mf2(0.0f, 2), 8);\n        v_result = vfcvt_xu_f_v_u32m8(vfrsqrt7_v_f32m8(vresult, 8), 8);\n        v_result = vfcvt_f_xu_v_f32m8(vresult, 8);\n\n        for (size_t j = 0; j < 8; j++) {\n            if ((i + j) % 2 != 0 || !v_mask[j]) {\n                dst[i + j] = neg_one;\n            } else {\n                dst[i + j] = ceilf(v_result[j]);\n            }\n        }\n    }\n\n    for (; i < length; i++) {\n        float diff = fabsf(src1[i] - src2[i]);\n        if (diff <= threshold && i % 2 == 0) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = neg_one;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length){\n    size_t i = 0;\n    vfloat32m8_t v_src1, v_src2, v_result, v_abs_diff, v_threshold, v_neg_one;\n    vbool4_t v_mask;\n    float threshold = 50.0f;\n    float neg_one = -1.0f;\n\n    v_threshold = vfmv_v_f_f32m8(threshold, 8);\n    v_neg_one = vfmv_v_f_f32m8(neg_one, 8);\n\n    for (; i <= length - 8; i += 8) {\n        v_src1 = vle32_v_f32m8(&src1[i], 8);\n        v_src2 = vle32_v_f32m8(&src2[i], 8);\n\n        v_abs_diff = vfabs_v_f32m8(vfsub_vv_f32m8(v_src1, v_src2, 8), 8);\n        v_mask = vmflt_vv_b4_f32m8(v_abs_diff, v_threshold, 8);\n\n        v_result = vfmul_vv_f32m8_m(v_mask, v_src1, v_src2, 8);\n        v_result = vfredusum_vs_f32m8_f32m1(v_result, v_result, 8);\n\n        v_result = vfmv_v_f_f32m8(ceilf(vfmv_f_s_f32m1_f32(v_result, 0)), 8);\n        v_result = vmerge_vvm_f32m8(v_mask, v_result, v_neg_one, 8);\n\n        vse32_v_f32m8(&dst[i], v_result, 8);\n    }\n\n    for (; i < length; i++) {\n        if (i % 2 == 0 && fabsf(src1[i] - src2[i]) <= 50.0f) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length){\n    size_t i = 0;\n    vfloat32m8_t v_src1, v_src2, v_result, v_abs_diff, v_threshold, v_neg_one;\n    vbool4_t v_mask;\n    float32_t threshold = 50.0f;\n    float32_t neg_one = -1.0f;\n\n    v_threshold = vfmv_v_f_f32m8(threshold, 8);\n    v_neg_one = vfmv_v_f_f32m8(neg_one, 8);\n\n    for (; i <= length - 8; i += 8) {\n        v_src1 = vle32_v_f32m8(&src1[i], 8);\n        v_src2 = vle32_v_f32m8(&src2[i], 8);\n\n        v_abs_diff = vfabs_v_f32m8(vfsub_vv_f32m8(v_src1, v_src2, 8), 8);\n        v_mask = vmflt_vv_b4_f32m8(v_abs_diff, v_threshold, 8);\n\n        v_result = vfmul_vv_f32m8_m(v_mask, v_src1, v_src2, 8);\n        v_result = vfredusum_vs_f32m8_f32mf2(v_result, vfmv_s_f_f32mf2(0.0f, 2), 8);\n        v_result = vfcvt_xu_f_v_i32m8(vfrsqrt7_v_f32m8(vresult, 8), 8);\n        v_result = vfcvt_f_xu_v_f32m8(vresult, 8);\n\n        vbool4_t v_index_mask = vmseq_vx_b4_u32m8(vcreate_u32m8(i, i+1, i+2, i+3, i+4, i+5, i+6, i+7), 0, 8);\n        v_mask = vm_and_vv_b4(v_mask, v_index_mask, 8);\n\n        v_result = vmerge_vvm_f32m8(v_neg_one, v_result, v_mask, 8);\n        vse32_v_f32m8(&dst[i], v_result, 8);\n    }\n\n    for (; i < length; i++) {\n        if (i % 2 == 0 && fabsf(src1[i] - src2[i]) <= 50.0f) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length){\n    size_t i = 0;\n    vfloat32m8_t v_src1, v_src2, v_result, v_abs_diff, v_threshold, v_neg_one;\n    vbool4_t v_mask;\n    float threshold = 50.0f;\n    float neg_one = -1.0f;\n\n    v_threshold = vfmv_v_f_f32m8(threshold, 8);\n    v_neg_one = vfmv_v_f_f32m8(neg_one, 8);\n\n    for (; i <= length - 8; i += 8) {\n        v_src1 = vle32_v_f32m8(&src1[i], 8);\n        v_src2 = vle32_v_f32m8(&src2[i], 8);\n\n        v_abs_diff = vfabs_v_f32m8(vfsub_vv_f32m8(v_src1, v_src2, 8), 8);\n        v_mask = vmflt_vv_b4(v_abs_diff, v_threshold, 8);\n\n        v_result = vfmul_vv_f32m8_m(v_mask, v_src1, v_src2, 8);\n        v_result = vfredusum_vs_f32m8_f32m1(v_result, v_result, 8);\n\n        for (size_t j = 0; j < 8; j++) {\n            if ((i + j) % 2 == 0 && v_mask[j]) {\n                dst[i + j] = ceilf(v_result[j]);\n            } else {\n                dst[i + j] = neg_one;\n            }\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        if (fabsf(src1[i] - src2[i]) <= threshold && i % 2 == 0) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = neg_one;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_22_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t num_elements = m * n;\n    size_t vl;\n\n    for (size_t i = 0; i < num_elements; i += vl) {\n        vl = vsetvl_e64m8(num_elements - i);\n        vfloat64m8_t mat_v = vle64_v_f64m8(&mat[i], vl);\n        vfloat64m8_t scalar_v = vfmv_v_f_f64m8(scalar, vl);\n        vfloat64m8_t result_v = vfmul_vv_f64m8(mat_v, scalar_v, vl);\n        vse64_v_f64m8(&dst[i], result_v, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_22_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t num_elements = m * n;\n    size_t vl;\n\n    for (size_t i = 0; i < num_elements; i += vl) {\n        vl = vsetvl_e64m8(num_elements - i);\n        vfloat64m8_t mat_v = vle64_v_f64m8(&mat[i], vl);\n        vfloat64m8_t scalar_v = vfmv_v_f_f64m8(scalar, vl);\n        vfloat64m8_t result_v = vfmul_vv_f64m8(mat_v, scalar_v, vl);\n        vse64_v_f64m8(&dst[i], result_v, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_22_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t num_elements = m * n;\n    size_t vl;\n\n    for (size_t i = 0; i < num_elements; i += vl) {\n        vl = vsetvl_e64m8(num_elements - i);\n        vfloat64m8_t vec_mat = vle64_v_f64m8(&mat[i], vl);\n        vfloat64m8_t vec_scalar = vfmv_v_f_f64m8(scalar, vl);\n        vfloat64m8_t vec_result = vfmul_vv_f64m8(vec_mat, vec_scalar, vl);\n        vse64_v_f64m8(&dst[i], vec_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_22_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t num_elements = m * n;\n    size_t vl;\n\n    for (size_t i = 0; i < num_elements; i += vl) {\n        vl = vsetvl_e64m8(num_elements - i);\n        vfloat64m8_t mat_v = vle64_v_f64m8(&mat[i], vl);\n        vfloat64m8_t scalar_v = vfmv_v_f_f64m8(scalar, vl);\n        vfloat64m8_t result_v = vfmul_vv_f64m8(mat_v, scalar_v, vl);\n        vse64_v_f64m8(&dst[i], result_v, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_22_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t num_elements = m * n;\n    size_t vl;\n\n    for (size_t i = 0; i < num_elements; i += vl) {\n        vl = vsetvl_e64m8(num_elements - i);\n        vfloat64m8_t vec_mat = vle64_v_f64m8(&mat[i], vl);\n        vfloat64m8_t vec_scalar = vfmul_vf_f64m8(vec_mat, scalar, vl);\n        vse64_v_f64m8(&dst[i], vec_scalar, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_23_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float* row = mat + i * n;\n        vfloat32m8_t v_sum = vfmv_v_f_f32m8(0.0f, 8);\n        size_t vl = n;\n\n        do {\n            vfloat32m8_t v_row = vle32_v_f32m8(row, vl);\n            vfloat32m8_t v_square = vfmul_vv_f32m8(v_row, v_row, vl);\n            v_sum = vfadd_vv_f32m8(v_sum, v_square, vl);\n            row += vl;\n            vl = vsetvl_e32m8(n - (row - mat - i * n));\n        } while (vl > 0);\n\n        float sum = vfmv_f_s_f32m8_f32(vfredsum_vs_f32m8_f32(v_sum, 0.0f, 8));\n        float norm = sqrtf(sum);\n\n        if (norm != 0.0f) {\n            row = mat + i * n;\n            vl = n;\n\n            do {\n                vfloat32m8_t v_row = vle32_v_f32m8(row, vl);\n                vfloat32m8_t v_normalized = vfdiv_vf_f32m8(v_row, norm, vl);\n                vse32_v_f32m8(row, v_normalized, vl);\n                row += vl;\n                vl = vsetvl_e32m8(n - (row - mat - i * n));\n            } while (vl > 0);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float* row = mat + i * n;\n        size_t vl = vsetvl_e32m8(n);\n        vfloat32m8_t v_sum = vfmv_v_f_f32m8(0.0f, vl);\n        size_t offset = 0;\n\n        do {\n            vfloat32m8_t v_row = vle32_v_f32m8(row + offset, vl);\n            vfloat32m8_t v_square = vfmul_vv_f32m8(v_row, v_row, vl);\n            v_sum = vfadd_vv_f32m8(v_sum, v_square, vl);\n            offset += vl;\n            vl = vsetvl_e32m8(n - offset);\n        } while (offset < n);\n\n        float sum = vfmv_f_s_f32m1_f32(vfredsum_vs_f32m8_f32mf2(v_sum, vfmv_f_s_f32mf2_f32(0.0f), vl));\n        float norm = sqrtf(sum);\n\n        if (norm != 0.0f) {\n            vl = vsetvl_e32m8(n);\n            offset = 0;\n\n            do {\n                vfloat32m8_t v_row = vle32_v_f32m8(row + offset, vl);\n                vfloat32m8_t v_normalized = vfdiv_vf_f32m8(v_row, norm, vl);\n                vse32_v_f32m8(row + offset, v_normalized, vl);\n                offset += vl;\n                vl = vsetvl_e32m8(n - offset);\n            } while (offset < n);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float* row = mat + i * n;\n        size_t vl = __riscv_vsetvl_e32m8(n);\n        vfloat32m8_t v_sum = __riscv_vfmv_v_f_f32m8(0.0f, vl);\n        vfloat32m8_t v_zero = __riscv_vfmv_v_f_f32m8(0.0f, vl);\n\n        for (size_t j = 0; j < n; j += vl) {\n            vl = __riscv_vsetvl_e32m8(n - j);\n            vfloat32m8_t v_row = __riscv_vle32_v_f32m8(row + j, vl);\n            vfloat32m8_t v_square = __riscv_vfmul_vv_f32m8(v_row, v_row, vl);\n            v_sum = __riscv_vfredusum_vs_f32m8_f32mf2(v_square, v_sum, v_zero, vl);\n        }\n\n        float sum = __riscv_vfmv_f_s_f32m1(__riscv_vfadd_vv_f32m1(v_sum, v_sum, 1), 0);\n        float norm = sqrtf(sum);\n\n        if (norm != 0.0f) {\n            vfloat32m8_t v_norm = __riscv_vfmv_v_f_f32m8(1.0f / norm, vl);\n\n            for (size_t j = 0; j < n; j += vl) {\n                vl = __riscv_vsetvl_e32m8(n - j);\n                vfloat32m8_t v_row = __riscv_vle32_v_f32m8(row + j, vl);\n                vfloat32m8_t v_normalized = __riscv_vfmul_vv_f32m8(v_row, v_norm, vl);\n                __riscv_vse32_v_f32m8(row + j, v_normalized, vl);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float* row = mat + i * n;\n        size_t vl = vsetvl_e32m8(n);\n\n        vfloat32m8_t v_sum = vfmv_v_f_f32m8(0.0f, vl);\n        size_t offset = 0;\n\n        do {\n            vfloat32m8_t v_row = vle32_v_f32m8(row + offset, vl);\n            vfloat32m8_t v_squares = vfmul_vv_f32m8(v_row, v_row, vl);\n            v_sum = vfadd_vv_f32m8(v_sum, v_squares, vl);\n            offset += vl;\n            vl = vsetvl_e32m8(n - offset);\n        } while (offset < n);\n\n        float sum = vfmv_f_s_f32m8(vfredsum_vs_f32m8_f32(v_sum, 0.0f, vl));\n        float norm = sqrtf(sum);\n\n        if (norm != 0.0f) {\n            vl = vsetvl_e32m8(n);\n            offset = 0;\n\n            do {\n                vfloat32m8_t v_row = vle32_v_f32m8(row + offset, vl);\n                vfloat32m8_t v_normalized = vfdiv_vf_f32m8(v_row, norm, vl);\n                vse32_v_f32m8(row + offset, v_normalized, vl);\n                offset += vl;\n                vl = vsetvl_e32m8(n - offset);\n            } while (offset < n);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float* row = mat + i * n;\n        size_t vl = __riscv_vsetvl_e32m8(n);\n        vfloat32m8_t v_sum = __riscv_vfmv_v_f_f32m8(0.0f, vl);\n        vfloat32m8_t v_row;\n\n        do {\n            v_row = __riscv_vle32_v_f32m8(row, vl);\n            vfloat32m8_t v_square = __riscv_vfmul_vv_f32m8(v_row, v_row, vl);\n            v_sum = __riscv_vfredusum_vs_f32m8_f32mf2(v_square, v_sum, vl);\n            row += vl;\n            vl = __riscv_vsetvl_e32m8(n - (row - mat - i * n));\n        } while (vl > 0);\n\n        float sum = __riscv_vfmv_f_s_f32mf2_f32(v_sum);\n        float norm = sqrtf(sum);\n\n        if (norm != 0.0f) {\n            row = mat + i * n;\n            vl = __riscv_vsetvl_e32m8(n);\n\n            do {\n                v_row = __riscv_vle32_v_f32m8(row, vl);\n                vfloat32m8_t v_normalized = __riscv_vfdiv_vf_f32m8(v_row, norm, vl);\n                __riscv_vse32_v_f32m8(row, v_normalized, vl);\n                row += vl;\n                vl = __riscv_vsetvl_e32m8(n - (row - mat - i * n));\n            } while (vl > 0);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            size_t k = 0;\n            for (; k <= n - VL_MAX_D; k += VL_MAX_D) {\n                vfloat64m1_t vec1 = vle64_v_f64m1(&mat1[i * n + k], VL_MAX_D);\n                vfloat64m1_t vec2 = vle64_v_f64m1(&mat2[j + k * p], p, VL_MAX_D);\n                vfloat64m1_t vec_mul = vfmul_vv_f64m1(vec1, vec2, VL_MAX_D);\n                sum += vfredsum_vs_f64m1_f64m1(vfmv_s_f_f64m1(0.0, VL_MAX_D), vec_mul, VL_MAX_D).v[0];\n            }\n            for (; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[j + k * p];\n            }\n            dst[i * p + j] = rint(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ) {\n                size_t vl = vsetvl_e64m8(n - k);\n                vfloat64m8_t vec1 = vle64_v_f64m8(&mat1[i * n + k], vl);\n                vfloat64m8_t vec2 = vle64_v_f64m8(&mat2[j + k * p], vl);\n                vfloat64m8_t vec_mul = vfmul_vv_f64m8(vec1, vec2, vl);\n                sum += vfredsum_vs_f64m8_f64(vfadd_vv_f64m8(vec_mul, vec_mul, vl), 0.0, vl);\n                k += vl;\n            }\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            size_t k = 0;\n            for (; k <= n - VL_MAX_D; k += VL_MAX_D) {\n                vfloat64m1_t vec1 = vle64_v_f64m1(&mat1[i * n + k], VL_MAX_D);\n                vfloat64m1_t vec2 = vle64_v_f64m1(&mat2[j + k * p], p, VL_MAX_D);\n                vfloat64m1_t vec_mul = vfmul_vv_f64m1(vec1, vec2, VL_MAX_D);\n                sum += vfredusum_vs_f64m1_f64m1(vec_mul, vfmul_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfmul_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfmul_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vfsub_vv_f64m1(vfadd_vv_f64m1(vf"}
{"task_id": "SimdBench_24_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            size_t k = 0;\n            for (; k <= n - VL_MAX_D; k += VL_MAX_D) {\n                vfloat64m1_t vec1 = vle64_v_f64m1(&mat1[i * n + k], VL_MAX_D);\n                vfloat64m1_t vec2 = vle64_v_f64m1(&mat2[j + k * p], p, VL_MAX_D);\n                vfloat64m1_t vec_mul = vfmul_vv_f64m1(vec1, vec2, VL_MAX_D);\n                sum += vfredusum_vs_f64m1_f64m1(vfadd_vv_f64m1(vec_mul, vec_mul, VL_MAX_D), 0.0, NULL, VL_MAX_D);\n            }\n            for (; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[j + k * p];\n            }\n            dst[i * p + j] = rint(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            size_t k = 0;\n            for (; k <= n - VL_MAX_D; k += VL_MAX_D) {\n                vfloat64m1_t vec1 = vle64_v_f64m1(&mat1[i * n + k], VL_MAX_D);\n                vfloat64m1_t vec2 = vle64_v_f64m1(&mat2[j + k * p], p, VL_MAX_D);\n                vfloat64m1_t vec_mul = vfmul_vv_f64m1(vec1, vec2, VL_MAX_D);\n                sum += vfredusum_vs_f64m1_f64m1(vfadd_vv_f64m1(vec_mul, vec_mul, VL_MAX_D), 0.0, vfredusum_vs_f64m1_f64m1_op, VL_MAX_D).s0;\n            }\n            for (; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = rint(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t n = rows * cols;\n    size_t vlmax = vsetvl_e32m8(n);\n\n    for (size_t i = 0; i < cols; ++i) {\n        for (size_t j = 0; j < rows; j += vlmax) {\n            size_t vl = vsetvl_e32m8(rows - j);\n            vfloat32m8_t vsrc = vle32_v_f32m8(&src[i * rows + j], vl);\n            vfloat32m8_t vrounded = vrndne_vf_f32m8(vsrc, 0.25f, vl);\n            vse32_v_f32m8(&dst[j * cols + i], vrounded, vl);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t n = rows * cols;\n    size_t vl;\n\n    for (size_t i = 0; i < cols; ++i) {\n        for (size_t j = 0; j < rows; j += vl) {\n            vl = vsetvl_e32m8(rows - j);\n            vfloat32m8_t vec = vle32_v_f32m8(&src[i * rows + j], vl);\n            vfloat32m8_t rounded_vec = vfcvt_rtz_x_f_v_f32m8(vfadd_vf_f32m8(vec, 0.125f, vl), vl);\n            vse32_v_f32m8(&dst[j * cols + i], rounded_vec, vl);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t n = rows * cols;\n    size_t vlmax = vsetvl_e32m8(n);\n\n    for (size_t i = 0; i < cols; ++i) {\n        for (size_t j = 0; j < rows; j += vlmax) {\n            size_t vl = vsetvl_e32m8(rows - j);\n            vfloat32m8_t vsrc = vle32_v_f32m8(&src[i * rows + j], vl);\n            vfloat32m8_t vrounded = vrndne_vf_f32m8(vsrc, 0.25f, vl);\n            vse32_v_f32m8(&dst[j * cols + i], vrounded, vl);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t n = rows * cols;\n    size_t vl;\n\n    for (size_t i = 0; i < cols; ++i) {\n        for (size_t j = 0; j < rows; j += vl) {\n            vl = vsetvl_e32m8(rows - j);\n            vfloat32m8_t vec = vle32_v_f32m8(&src[i * rows + j], vl);\n            vfloat32m8_t rounded_vec = vfcvt_rtz_x_f_v_f32m8(vfmul_vf_f32m8(vec, 4.0f, vl), vl);\n            rounded_vec = vfdiv_vf_f32m8(rounded_vec, 4.0f, vl);\n            vse32_v_f32m8(&dst[j * cols + i], rounded_vec, vl);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t n = rows * cols;\n    size_t vl = vsetvl_e32m8(n);\n\n    vfloat32m8_t v_zero_point_two_five = vfmul_vf_f32m8(vfadd_vf_f32m8(vfsub_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(vfcvt_f_x_v_f32m8(vfmul_vf_f32m8(vfcvt_f_x_v_f32m8(vfadd_vf_f32m8(v"}
{"task_id": "SimdBench_26_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n        vfloat32m8_t v_tensor1 = vle32_v_f32m8(&tensor1[i], vl);\n        vfloat32m8_t v_tensor2 = vle32_v_f32m8(&tensor2[i], vl);\n        vfloat32m8_t v_result = vfsub_vv_f32m8(v_tensor1, v_tensor2, vl);\n        vint32m8_t v_rounded = vfcvt_rtz_x_f_v_i32m8(v_result, vl);\n        vse32_v_i32m8(&dst[i], v_rounded, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_26_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n        vfloat32m8_t v_tensor1 = vle32_v_f32m8(&tensor1[i], vl);\n        vfloat32m8_t v_tensor2 = vle32_v_f32m8(&tensor2[i], vl);\n        vfloat32m8_t v_result = vfsub_vv_f32m8(v_tensor1, v_tensor2, vl);\n        vint32m8_t v_rounded = vfcvt_rtz_x_f_v_i32m8(v_result, vl);\n        vse32_v_i32m8(&dst[i], v_rounded, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_26_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n        vfloat32m8_t v_tensor1 = vle32_v_f32m8(&tensor1[i], vl);\n        vfloat32m8_t v_tensor2 = vle32_v_f32m8(&tensor2[i], vl);\n        vfloat32m8_t v_result = vfsub_vv_f32m8(v_tensor1, v_tensor2, vl);\n        vint32m8_t v_rounded_result = vfcvt_rtz_x_f_v_i32m8(v_result, vl);\n        vse32_v_i32m8(&dst[i], v_rounded_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_26_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n        vfloat32m8_t v_tensor1 = vle32_v_f32m8(&tensor1[i], vl);\n        vfloat32m8_t v_tensor2 = vle32_v_f32m8(&tensor2[i], vl);\n        vfloat32m8_t v_result = vfsub_vv_f32m8(v_tensor1, v_tensor2, vl);\n        vint32m8_t v_rounded = vfcvt_rtz_x_f_v_i32m8(v_result, vl);\n        vse32_v_i32m8(&dst[i], v_rounded, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_26_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n        vfloat32m8_t v_tensor1 = vle32_v_f32m8(&tensor1[i], vl);\n        vfloat32m8_t v_tensor2 = vle32_v_f32m8(&tensor2[i], vl);\n        vfloat32m8_t v_result = vfsub_vv_f32m8(v_tensor1, v_tensor2, vl);\n        vint32m8_t v_rounded = vfcvt_rtz_x_f_v_i32m8(v_result, vl);\n        vse32_v_i32m8(&dst[i], v_rounded, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_27_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t num_elements = m * n;\n    size_t vl;\n\n    for (size_t i = 0; i < num_elements; i += vl) {\n        vl = vsetvl_e64m8(num_elements - i);\n        vfloat64m8_t vec1 = vle64_v_f64m8(&mat1[i], vl);\n        vfloat64m8_t vec2 = vle64_v_f64m8(&mat2[i], vl);\n        vfloat64m8_t result = vfmul_vv_f64m8(vec1, vec2, vl);\n        vse64_v_f64m8(&dst[i], result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_27_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t num_elements = m * n;\n    size_t vl;\n\n    for (size_t i = 0; i < num_elements; i += vl) {\n        vl = vsetvl_e64m8(num_elements - i);\n        vfloat64m8_t vec1 = vle64_v_f64m8(&mat1[i], vl);\n        vfloat64m8_t vec2 = vle64_v_f64m8(&mat2[i], vl);\n        vfloat64m8_t result = vfmul_vv_f64m8(vec1, vec2, vl);\n        vse64_v_f64m8(&dst[i], result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_27_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t num_elements = m * n;\n    size_t vl;\n\n    for (size_t i = 0; i < num_elements; i += vl) {\n        vl = vsetvl_e64m8(num_elements - i);\n        vfloat64m8_t vec1 = vle64_v_f64m8(&mat1[i], vl);\n        vfloat64m8_t vec2 = vle64_v_f64m8(&mat2[i], vl);\n        vfloat64m8_t result = vfmul_vv_f64m8(vec1, vec2, vl);\n        vse64_v_f64m8(&dst[i], result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_27_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t num_elements = m * n;\n    size_t vl;\n\n    for (size_t i = 0; i < num_elements; i += vl) {\n        vl = vsetvl_e64m8(num_elements - i);\n        vfloat64m8_t vec1 = vle64_v_f64m8(&mat1[i], vl);\n        vfloat64m8_t vec2 = vle64_v_f64m8(&mat2[i], vl);\n        vfloat64m8_t result = vfmul_vv_f64m8(vec1, vec2, vl);\n        vse64_v_f64m8(&dst[i], result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_27_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t num_elements = m * n;\n    size_t vl;\n\n    for (size_t i = 0; i < num_elements; i += vl) {\n        vl = vsetvl_e64m8(num_elements - i);\n        vfloat64m8_t vec1 = vle64_v_f64m8(&mat1[i], vl);\n        vfloat64m8_t vec2 = vle64_v_f64m8(&mat2[i], vl);\n        vfloat64m8_t result = vfmul_vv_f64m8(vec1, vec2, vl);\n        vse64_v_f64m8(&dst[i], result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_28_RVV", "completion": "```c\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    size_t i;\n    vfloat32m8_t v_vec, v_mat, v_dst;\n    vfloat32m8_t v_sum = vmf32_v_f_f32m8(0.0f, 8);\n\n    for (i = 0; i < m; ++i) {\n        size_t j;\n        for (j = 0; j < n; j += 8) {\n            v_vec = vle32_v_f32m8(&vec[j], 8);\n            v_mat = vle32_v_f32m8(&mat[i * n + j], 8);\n            v_dst = vfmul_vv_f32m8(v_mat, v_vec, 8);\n            v_sum = vfadd_vv_f32m8(v_sum, v_dst, 8);\n        }\n        // Handle remaining elements if n is not a multiple of 8\n        for (; j < n; ++j) {\n            v_sum[0] += mat[i * n + j] * vec[j];\n        }\n        dst[i] = v_sum[0];\n        v_sum = vmf32_v_f_f32m8(0.0f, 8); // Reset sum for next row\n    }\n}\n```"}
{"task_id": "SimdBench_28_RVV", "completion": "```c\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    size_t i;\n    vfloat32m8_t v_vec, v_mat, v_dst;\n    vfloat32m8_t v_sum = vmf32_v_f32m8(0.0f, 8);\n\n    for (i = 0; i < m; i++) {\n        size_t j;\n        for (j = 0; j < n; j += 8) {\n            v_vec = vle32_v_f32m8(&vec[j], 8);\n            v_mat = vle32_v_f32m8(&mat[i * n + j], 8);\n            v_dst = vfmul_vv_f32m8(v_mat, v_vec, 8);\n            v_sum = vfadd_vv_f32m8(v_sum, v_dst, 8);\n        }\n        // Handle remaining elements if n is not a multiple of 8\n        for (; j < n; j++) {\n            v_sum[0] += mat[i * n + j] * vec[j];\n        }\n        dst[i] = v_sum[0];\n        v_sum = vmf32_v_f32m8(0.0f, 8); // Reset sum for next row\n    }\n}\n```"}
{"task_id": "SimdBench_28_RVV", "completion": "```c\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    size_t i;\n    vfloat32m8_t v_vec, v_mat, v_dst;\n    vfloat32m8_t v_sum = vfmv_v_f_f32m8(0.0f, 8);\n\n    for (i = 0; i < m; ++i) {\n        size_t j;\n        for (j = 0; j < n; j += 8) {\n            v_vec = vle32_v_f32m8(&vec[j], 8);\n            v_mat = vle32_v_f32m8(&mat[i * n + j], 8);\n            v_dst = vfmul_vv_f32m8(v_mat, v_vec, 8);\n            v_sum = vfadd_vv_f32m8(v_sum, v_dst, 8);\n        }\n        // Handle remaining elements if n is not a multiple of 8\n        for (; j < n; ++j) {\n            v_sum[0] += mat[i * n + j] * vec[j];\n        }\n        dst[i] = v_sum[0];\n        v_sum = vfmv_v_f_f32m8(0.0f, 8); // Reset sum for next row\n    }\n}\n```"}
{"task_id": "SimdBench_28_RVV", "completion": "```c\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    size_t vl = vsetvl_e32m8(n);\n    vfloat32m8_t v_vec = vle32_v_f32m8(vec, vl);\n\n    for (size_t i = 0; i < m; ++i) {\n        const float* mat_row = &mat[i * n];\n        vfloat32m8_t v_mat_row = vle32_v_f32m8(mat_row, vl);\n        vfloat32m8_t v_result = vfmul_vv_f32m8(v_mat_row, v_vec, vl);\n        float sum = vfredsum_vs_f32m8_f32m1(v_result, vfmul_vf_f32m8(v_result, 0.0f, vl), vl);\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28_RVV", "completion": "```c\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    size_t i;\n    vfloat32m8_t v_vec, v_mat, v_dst;\n    vfloat32m8_t v_sum = vmf32_v_f_f32m8(0.0f, 8);\n\n    for (i = 0; i < m; i++) {\n        size_t j;\n        for (j = 0; j < n; j += 8) {\n            v_vec = vle32_v_f32m8(&vec[j], 8);\n            v_mat = vle32_v_f32m8(&mat[i * n + j], 8);\n            v_dst = vfmul_vv_f32m8(v_mat, v_vec, 8);\n            v_sum = vfadd_vv_f32m8(v_sum, v_dst, 8);\n        }\n        // Handle remaining elements if n is not a multiple of 8\n        for (; j < n; j++) {\n            v_sum[0] += mat[i * n + j] * vec[j];\n        }\n        dst[i] = v_sum[0];\n        v_sum = vmf32_v_f_f32m8(0.0f, 8); // Reset sum for next row\n    }\n}\n```"}
{"task_id": "SimdBench_29_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    double sum = 0.0;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e64m8(total_elements - i);\n        vfloat64m8_t v_mat = vle64_v_f64m8(&mat[i], vl);\n        vfloat64m8_t v_sum = vfredusum_vs_f64m8_f64(v_mat, 0.0, vl);\n        sum += vfmv_f_s_f64m1_f64(v_sum);\n    }\n\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    double sum = 0.0;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e64m8(total_elements - i);\n        vfloat64m8_t v_mat = vle64_v_f64m8(&mat[i], vl);\n        vfloat64m8_t v_sum = vfredusum_vs_f64m8_f64(v_mat, 0.0, vl);\n        sum += vfmv_f_s_f64m1_f64(v_sum);\n    }\n\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    double sum = 0.0;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e64m8(total_elements - i);\n        vfloat64m8_t v_mat = vle64_v_f64m8(&mat[i], vl);\n        vfloat64m8_t v_sum = vfredusum_vs_f64m8_f64(v_mat, 0.0, vl);\n        sum += vfmv_f_s_f64m1_f64(v_sum);\n    }\n\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    double sum = 0.0;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e64m8(total_elements - i);\n        vfloat64m8_t v_mat = vle64_v_f64m8(&mat[i], vl);\n        vfloat64m8_t v_sum = vfredusum_vs_f64m8_f64(v_mat, 0.0, vl);\n        sum += vfmv_f_s_f64m1_f64(v_sum);\n    }\n\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    double sum = 0.0;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e64m8(total_elements - i);\n        vfloat64m8_t v_mat = vle64_v_f64m8(&mat[i], vl);\n        vfloat64m8_t v_sum = vfredusum_vs_f64m8_f64(v_mat, 0.0, vl);\n        sum += vfmv_f_s_f64m1_f64(v_sum);\n    }\n\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_30_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        bool ascending = directions[i];\n        size_t j = 0;\n        while (j < cols) {\n            size_t vl = __riscv_vsetvl_e32m8(cols - j);\n            vint32m8_t vec = __riscv_vle32_v_i32m8(row + j, vl);\n            vint32m8_t vec_shifted = __riscv_vsrl_vx_i32m8(vec, 1, vl);\n            vbool4_t mask_asc = __riscv_vle32_v_b4(__riscv_vle32_v_u32m8((const uint32_t*)vec, vl) <= __riscv_vle32_v_u32m8((const uint32_t*)vec_shifted, vl), vl);\n            vbool4_t mask_desc = __riscv_vle32_v_b4(__riscv_vle32_v_u32m8((const uint32_t*)vec, vl) >= __riscv_vle32_v_u32m8((const uint32_t*)vec_shifted, vl), vl);\n            vbool4_t mask = ascending ? mask_asc : mask_desc;\n            if (!__riscv_vfirst_m_b4(mask, vl)) {\n                return false;\n            }\n            j += vl - 1;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        bool ascending = directions[i];\n        size_t j = 0;\n\n        while (j < cols) {\n            size_t vl = __riscv_vsetvl_e32m8(cols - j);\n            vint32m8_t vec = __riscv_vle32_v_i32m8(row + j, vl);\n            vint32m8_t vec_shifted = __riscv_vsrl_vx_i32m8(vec, 1, vl);\n            vbool4_t mask_asc = __riscv_vle32_v_b4(__riscv_vle32_v_u32m8((const uint32_t*)vec, vl), vl);\n            vbool4_t mask_desc = __riscv_vle32_v_b4(__riscv_vle32_v_u32m8((const uint32_t*)vec_shifted, vl), vl);\n\n            if (ascending) {\n                mask_asc = __riscv_vmsle_vv_b4(vec, vec_shifted, vl);\n                if (!__riscv_vfirst_m_b4(mask_asc, vl)) {\n                    return false;\n                }\n            } else {\n                mask_desc = __riscv_vmsgt_vv_b4(vec, vec_shifted, vl);\n                if (!__riscv_vfirst_m_b4(mask_desc, vl)) {\n                    return false;\n                }\n            }\n\n            j += vl;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        bool ascending = directions[i];\n        size_t j = 0;\n\n        while (j < cols) {\n            size_t vl = __riscv_vsetvl_e32m8(cols - j);\n            vint32m8_t vec = __riscv_vle32_v_i32m8(row + j, vl);\n            vint32m8_t vec_shifted = __riscv_vsrl_vx_i32m8(vec, 1, vl);\n            vbool4_t mask_asc = __riscv_vle32_v_b4(__riscv_vle32_v_u32m8((const uint32_t*)vec, vl) <= __riscv_vle32_v_u32m8((const uint32_t*)vec_shifted, vl), vl);\n            vbool4_t mask_desc = __riscv_vle32_v_b4(__riscv_vle32_v_u32m8((const uint32_t*)vec, vl) >= __riscv_vle32_v_u32m8((const uint32_t*)vec_shifted, vl), vl);\n\n            if (ascending) {\n                if (!__riscv_vfirst_m_b4(mask_asc, vl)) {\n                    return false;\n                }\n            } else {\n                if (!__riscv_vfirst_m_b4(mask_desc, vl)) {\n                    return false;\n                }\n            }\n\n            j += vl;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        bool ascending = directions[i];\n        size_t j = 0;\n        while (j < cols) {\n            size_t vl = __riscv_vsetvl_e32m8(cols - j);\n            vint32m8_t vec = __riscv_vle32_v_i32m8(row + j, vl);\n            vint32m8_t vec_shifted = __riscv_vsrl_vx_i32m8(vec, 1, vl);\n            vbool4_t mask_asc = __riscv_vle32_v_b4(__riscv_vle32_v_u32m8((const uint32_t*)vec, vl), vl);\n            vbool4_t mask_desc = __riscv_vle32_v_b4(__riscv_vle32_v_u32m8((const uint32_t*)vec_shifted, vl), vl);\n            vbool4_t mask = ascending ? mask_asc : mask_desc;\n            if (!__riscv_vfirst_m_b4(mask, vl)) {\n                return false;\n            }\n            j += vl;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        bool ascending = directions[i];\n        size_t j = 0;\n\n        while (j < cols) {\n            size_t vl = __riscv_vsetvl_e32m8(cols - j);\n            vint32m8_t vec = __riscv_vle32_v_i32m8(row + j, vl);\n            vint32m8_t vec_shifted = __riscv_vsrl_vx_i32m8(vec, 1, vl);\n            vbool4_t mask_asc = __riscv_vle32_v_b4(__riscv_vle32_v_i32m8(row + j + 1, vl), vl);\n            vbool4_t mask_desc = __riscv_vle32_v_b4(__riscv_vle32_v_i32m8(row + j + 1, vl), vl);\n\n            if (ascending) {\n                mask_asc = __riscv_vmsle_vv_b4(vec, vec_shifted, vl);\n                if (!__riscv_vfirst_m_b4(mask_asc, vl)) {\n                    return false;\n                }\n            } else {\n                mask_desc = __riscv_vmsgt_vv_b4(vec, vec_shifted, vl);\n                if (!__riscv_vfirst_m_b4(mask_desc, vl)) {\n                    return false;\n                }\n            }\n\n            j += vl;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_31_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t vl = vsetvl_e16m1(length);\n    vint16m1_t src_v = vle16_v_i16m1(src, vl);\n    vint16m1_t base_v = vmv_v_x_i16m1((int16_t)base, vl);\n    vint16m1_t div_v = vdiv_vv_i16m1(src_v, base_v, vl);\n    vint16m1_t result_v = vmul_vv_i16m1(div_v, base_v, vl);\n    vse16_v_i16m1(dst, result_v, vl);\n}\n```"}
{"task_id": "SimdBench_31_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t vl = vsetvl_e16m1(length);\n    vint16m1_t src_v = vle16_v_i16m1(src, vl);\n    vint16m1_t base_v = vmv_v_x_i16m1((int16_t)base, vl);\n    vint16m1_t div_v = vdiv_vv_i16m1(src_v, base_v, vl);\n    vint16m1_t result_v = vmul_vv_i16m1(div_v, base_v, vl);\n    vse16_v_i16m1(dst, result_v, vl);\n}\n```"}
{"task_id": "SimdBench_31_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t vl = vsetvl_e16m1(length);\n    vint16m1_t src_v = vle16_v_i16m1(src, vl);\n    vint16m1_t base_v = vmv_v_x_i16m1((int16_t)base, vl);\n    vint16m1_t div_v = vdiv_vv_i16m1(src_v, base_v, vl);\n    vint16m1_t result_v = vmul_vv_i16m1(div_v, base_v, vl);\n    vse16_v_i16m1(dst, result_v, vl);\n}\n```"}
{"task_id": "SimdBench_31_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t vl = vsetvl_e16m1(length);\n    vint16m1_t src_v = vle16_v_i16m1(src, vl);\n    vint16m1_t base_v = vmv_v_x_i16m1((int16_t)base, vl);\n    vint16m1_t div_v = vdiv_vv_i16m1(src_v, base_v, vl);\n    vint16m1_t result_v = vmul_vv_i16m1(div_v, base_v, vl);\n    vse16_v_i16m1(dst, result_v, vl);\n}\n```"}
{"task_id": "SimdBench_31_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t vl = vsetvl_e16m1(length);\n    vint16m1_t src_v = vle16_v_i16m1(src, vl);\n    vint16m1_t base_v = vmv_v_x_i16m1((int16_t)base, vl);\n    vint16m1_t div_v = vdiv_vv_i16m1(src_v, base_v, vl);\n    vint16m1_t result_v = vmul_vv_i16m1(div_v, base_v, vl);\n    vse16_v_i16m1(dst, result_v, vl);\n}\n```"}
{"task_id": "SimdBench_32_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    size_t i;\n    vbool64_t mask;\n    vfloat64m1_t vec_v, vec_m;\n\n    for (i = 0; i < rows; ++i) {\n        vec_v = vle64_v_f64m1(vector, cols);\n        vec_m = vle64_v_f64m1(matrix + i * cols, cols);\n        mask = vmfeq_vv_b64(vec_v, vec_m, cols);\n        if (vmfirst_m_b64(mask)) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    size_t i;\n    vbool64_t mask;\n    vfloat64m1_t vec, row_vec;\n\n    for (i = 0; i < rows; ++i) {\n        vec = vle64_v_f64m1(vector, cols);\n        row_vec = vle64_v_f64m1(matrix + i * cols, cols);\n        mask = vmfeq_vv_b64(vec, row_vec, cols);\n        if (vmfirst_m_b64(mask)) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    size_t i;\n    vbool64_t mask;\n    vfloat64m1_t vec_v, vec_m;\n\n    for (i = 0; i < rows; ++i) {\n        vec_v = vle64_v_f64m1(vector, cols);\n        vec_m = vle64_v_f64m1(matrix + i * cols, cols);\n        mask = vmfeq_vv_b64(vec_v, vec_m, cols);\n        if (vmfirst_m_b64(mask)) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    size_t i;\n    vbool64_t mask;\n    vfloat64m1_t vec_v, vec_m;\n\n    for (i = 0; i < rows; ++i) {\n        vec_v = vle64_v_f64m1(vector, cols);\n        vec_m = vle64_v_f64m1(matrix + i * cols, cols);\n        mask = vmfeq_vv_b64(vec_v, vec_m, cols);\n        if (vmfirst_m_b64(mask)) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    size_t i;\n    vbool64_t mask;\n    vfloat64m1_t vec_v, vec_m;\n\n    for (i = 0; i < rows; ++i) {\n        vec_v = vle64_v_f64m1(vector, cols);\n        vec_m = vle64_v_f64m1(matrix + i * cols, cols);\n        mask = vmfeq_vv_b64(vec_v, vec_m, cols);\n        if (vmfirst_m_b64(mask)) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_33_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    size_t i = 0;\n\n    while (i <= total_elements - VLMAX_U8) {\n        size_t vl = vsetvl_e8m1(total_elements - i);\n        vuint8m1_t va = vle8_v_u8m1(A + i, vl);\n        vuint8m1_t vb = vle8_v_u8m1(B + i, vl);\n        vbool1_t vm = vmseq_vv_u8m1_b1(va, vb, vl);\n        count += vcpop_m_b1(vm, vl);\n        i += vl;\n    }\n\n    // Handle remaining elements\n    for (; i < total_elements; ++i) {\n        count += (A[i] == B[i]);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    size_t i = 0;\n\n    vuint8m1_t vec_a, vec_b;\n    vbool1_t mask;\n    size_t vl;\n\n    while (i < total_elements) {\n        vl = vsetvl_e8m1(total_elements - i);\n        vec_a = vle8_v_u8m1(A + i, vl);\n        vec_b = vle8_v_u8m1(B + i, vl);\n        mask = vmseq_vv_u8m1_b1(vec_a, vec_b, vl);\n        count += vmcntm_b1_m(vl, mask);\n        i += vl;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    size_t i = 0;\n\n    while (i <= total_elements - VLMAX_U8) {\n        size_t vl = vsetvl_e8m1(total_elements - i);\n        vuint8m1_t va = vle8_v_u8m1(A + i, vl);\n        vuint8m1_t vb = vle8_v_u8m1(B + i, vl);\n        vbool1_t mask = vmseq_vv_u8m1_b1(va, vb, vl);\n        count += vcpop_m_b1(mask, vl);\n        i += vl;\n    }\n\n    // Handle remaining elements\n    for (; i < total_elements; ++i) {\n        count += (A[i] == B[i]);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    size_t i = 0;\n\n    while (i <= total_elements - VLMAX_U8) {\n        size_t vl = vsetvl_e8m1(total_elements - i);\n        vuint8m1_t va = vle8_v_u8m1(A + i, vl);\n        vuint8m1_t vb = vle8_v_u8m1(B + i, vl);\n        vbool1_t mask = vmseq_vv_u8m1_b1(va, vb, vl);\n        count += vcpop_m_b1(mask, vl);\n        i += vl;\n    }\n\n    // Handle remaining elements\n    for (; i < total_elements; ++i) {\n        if (A[i] == B[i]) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    size_t i = 0;\n\n    while (i <= total_elements - VLMAX_U8) {\n        size_t vl = vsetvl_e8m1(total_elements - i);\n        vuint8m1_t va = vle8_v_u8m1(A + i, vl);\n        vuint8m1_t vb = vle8_v_u8m1(B + i, vl);\n        vbool1_t mask = vmseq_vv_u8m1_b1(va, vb, vl);\n        count += vcpop_m_b1(mask, vl);\n        i += vl;\n    }\n\n    // Handle remaining elements\n    for (; i < total_elements; ++i) {\n        if (A[i] == B[i]) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_34_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t vl = vsetvl_e64m1(length);\n    vint64m1_t vx = vle64_v_i64m1(x, vl);\n    vint64m1_t va = vmv_v_x_i64m1(a, vl);\n    vint64m1_t vax = vsmul_vv_i64m1(va, vx, vl);\n    vint64m1_t vy = vle64_v_i64m1(y, vl);\n    vint64m1_t vabs_y = vabs_v_i64m1(vy, vl);\n    vint64m1_t vresult = vsub_vv_i64m1(vax, vabs_y, vl);\n    vse64_v_i64m1(y, vresult, vl);\n}\n```"}
{"task_id": "SimdBench_34_RVV", "completion": "```c\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t vl = vsetvl_e64m1(length);\n    vint64m1_t vx = vle64_v_i64m1(x, vl);\n    vint64m1_t va = vmv_v_x_i64m1(a, vl);\n    vint64m1_t vax = vsmul_vv_i64m1(va, vx, vl);\n    vint64m1_t vy = vle64_v_i64m1(y, vl);\n    vint64m1_t vabs_y = vabs_v_i64m1(vy, vl);\n    vint64m1_t vresult = vsub_vv_i64m1(vax, vabs_y, vl);\n    vse64_v_i64m1(y, vresult, vl);\n}\n```"}
{"task_id": "SimdBench_34_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t vl = vsetvl_e64m1(length);\n    vint64m1_t vx = vle64_v_i64m1(x, vl);\n    vint64m1_t va = vmv_v_x_i64m1(a, vl);\n    vint64m1_t vax = vsmul_vv_i64m1(va, vx, vl);\n    vint64m1_t vy = vle64_v_i64m1(y, vl);\n    vint64m1_t vabs_y = vabs_v_i64m1(vy, vl);\n    vint64m1_t vresult = vsub_vv_i64m1(vax, vabs_y, vl);\n    vse64_v_i64m1(y, vresult, vl);\n}\n```"}
{"task_id": "SimdBench_34_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t vl = length;\n    vint64m1_t vx, vy, vax;\n\n    do {\n        vl = vsetvl_e64m1(vl);\n        vx = vle64_v_i64m1(x, vl);\n        vax = vmul_vx_i64m1(vx, a, vl);\n        vy = vle64_v_i64m1(y, vl);\n        vy = vsub_vv_i64m1(vax, vy, vl);\n        vy = vabs_v_i64m1(vy, vl);\n        vse64_v_i64m1(y, vy, vl);\n\n        x += vl;\n        y += vl;\n    } while (vl != 0);\n}\n```"}
{"task_id": "SimdBench_34_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t vl = vsetvl_e64m1(length);\n    vint64m1_t vx = vle64_v_i64m1(x, vl);\n    vint64m1_t va = vmv_v_x_i64m1(a, vl);\n    vint64m1_t vax = vsmul_vv_i64m1(va, vx, vl);\n    vint64m1_t vy = vle64_v_i64m1(y, vl);\n    vint64m1_t vabs_y = vabs_v_i64m1(vy, vl);\n    vint64m1_t vresult = vsub_vv_i64m1(vax, vabs_y, vl);\n    vse64_v_i64m1(y, vresult, vl);\n}\n```"}
{"task_id": "SimdBench_35_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    size_t vl = vsetvl_e16m1(length);\n    vint16m1_t v_vec = vle16_v_i16m1(vec, vl);\n    vint16m1_t v_min = vmv_v_x_i16m1(INT16_MAX, vl);\n    vint16m1_t v_max = vmv_v_x_i16m1(INT16_MIN, vl);\n\n    do {\n        v_min = vmin_vv_i16m1(v_min, v_vec, vl);\n        v_max = vmax_vv_i16m1(v_max, v_vec, vl);\n        vec += vl;\n        length -= vl;\n        vl = vsetvl_e16m1(length);\n        if (vl > 0) {\n            v_vec = vle16_v_i16m1(vec, vl);\n        }\n    } while (vl > 0);\n\n    int16_t min_num = vmin_vs_i16m1_i16(v_min, INT16_MAX, vl);\n    int16_t max_num = vmax_vs_i16m1_i16(v_max, INT16_MIN, vl);\n\n    return (MinMaxPair){min_num, max_num};\n}\n```"}
{"task_id": "SimdBench_35_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    size_t vl = vsetvl_e16m1(length);\n    vint16m1_t v_vec = vle16_v_i16m1(vec, vl);\n    vint16m1_t v_min = vmv_v_x_i16m1(INT16_MAX, vl);\n    vint16m1_t v_max = vmv_v_x_i16m1(INT16_MIN, vl);\n\n    do {\n        v_min = vmin_vv_i16m1(v_min, v_vec, vl);\n        v_max = vmax_vv_i16m1(v_max, v_vec, vl);\n        vec += vl;\n        length -= vl;\n        vl = vsetvl_e16m1(length);\n        if (vl > 0) {\n            v_vec = vle16_v_i16m1(vec, vl);\n        }\n    } while (vl > 0);\n\n    int16_t min_num = vmin_vs_i16m1_i16(v_min, INT16_MAX, vl);\n    int16_t max_num = vmax_vs_i16m1_i16(v_max, INT16_MIN, vl);\n\n    return (MinMaxPair){min_num, max_num};\n}\n```"}
{"task_id": "SimdBench_35_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    size_t vl = vsetvl_e16m1(length);\n    vint16m1_t v_vec = vle16_v_i16m1(vec, vl);\n    vint16m1_t v_min = vmv_v_x_i16m1(INT16_MAX, vl);\n    vint16m1_t v_max = vmv_v_x_i16m1(INT16_MIN, vl);\n\n    do {\n        v_min = vmin_vv_i16m1(v_min, v_vec, vl);\n        v_max = vmax_vv_i16m1(v_max, v_vec, vl);\n        vec += vl;\n        length -= vl;\n        vl = vsetvl_e16m1(length);\n        if (vl > 0) {\n            v_vec = vle16_v_i16m1(vec, vl);\n        }\n    } while (vl > 0);\n\n    int16_t min_num = vmin_vs_i16m1_i16(v_min, INT16_MAX, vl);\n    int16_t max_num = vmax_vs_i16m1_i16(v_max, INT16_MIN, vl);\n\n    return (MinMaxPair){min_num, max_num};\n}\n```"}
{"task_id": "SimdBench_35_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    size_t vl = vsetvl_e16m1(length);\n    vint16m1_t v_vec = vle16_v_i16m1(vec, vl);\n    vint16m1_t v_min = vmv_v_x_i16m1(INT16_MAX, vl);\n    vint16m1_t v_max = vmv_v_x_i16m1(INT16_MIN, vl);\n\n    do {\n        v_min = vmin_vv_i16m1(v_min, v_vec, vl);\n        v_max = vmax_vv_i16m1(v_max, v_vec, vl);\n        vec += vl;\n        length -= vl;\n        vl = vsetvl_e16m1(length);\n        if (vl > 0) {\n            v_vec = vle16_v_i16m1(vec, vl);\n        }\n    } while (vl > 0);\n\n    int16_t min_num = vmin_vs_i16m1_i16(v_min, INT16_MAX, vl);\n    int16_t max_num = vmax_vs_i16m1_i16(v_max, INT16_MIN, vl);\n\n    return (MinMaxPair){min_num, max_num};\n}\n```"}
{"task_id": "SimdBench_35_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    size_t vl = vsetvl_e16m1(length);\n    vint16m1_t v_vec = vle16_v_i16m1(vec, vl);\n    vint16m1_t v_min = vmv_v_x_i16m1(INT16_MAX, vl);\n    vint16m1_t v_max = vmv_v_x_i16m1(INT16_MIN, vl);\n\n    do {\n        v_min = vmin_vv_i16m1(v_min, v_vec, vl);\n        v_max = vmax_vv_i16m1(v_max, v_vec, vl);\n        vec += vl;\n        length -= vl;\n        vl = vsetvl_e16m1(length);\n        if (vl > 0) {\n            v_vec = vle16_v_i16m1(vec, vl);\n        }\n    } while (vl > 0);\n\n    int16_t min_num = vmin_vs_i16m1_i16(v_min, INT16_MAX, vl);\n    int16_t max_num = vmax_vs_i16m1_i16(v_max, INT16_MIN, vl);\n\n    return (MinMaxPair){min_num, max_num};\n}\n```"}
{"task_id": "SimdBench_36_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        size_t j = 0;\n        while (j < cols) {\n            size_t vl = __riscv_vsetvl_e32m8(cols - j);\n            vint32m8_t current = __riscv_vle32_v_i32m8(row + j, vl);\n            vint32m8_t next = __riscv_vle32_v_i32m8(row + j + 1, vl);\n            vbool4_t mask = __riscv_vmslt_vv_i32m8_b4(current, next, vl);\n            if (!__riscv_vmv_x_s_b4_m(mask, vl)) {\n                return false;\n            }\n            j += vl - 1;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        size_t j = 0;\n        while (j < cols) {\n            size_t vl = vsetvl_e32m8(cols - j);\n            vint32m8_t current = vle32_v_i32m8(row + j, vl);\n            vint32m8_t next = vle32_v_i32m8(row + j + 1, vl);\n            vbool4_t mask = vmgt_vv_i32m8_b4(current, next, vl);\n            if (!vmfirst_m_b4(mask, vl)) {\n                return false;\n            }\n            j += vl;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        size_t j = 0;\n        while (j < cols) {\n            size_t vl = vsetvl_e32m8(cols - j);\n            vint32m8_t current = vle32_v_i32m8(row + j, vl);\n            vint32m8_t next = vle32_v_i32m8(row + j + 1, vl);\n            vbool4_t mask = vmgt_vv_i32m8_b4(current, next, vl);\n            if (!vmfirst_m_b4(mask, vl)) {\n                return false;\n            }\n            j += vl;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        size_t j = 0;\n        while (j < cols) {\n            size_t vl = vsetvl_e32m8(cols - j);\n            vint32m8_t current = vle32_v_i32m8(row + j, vl);\n            vint32m8_t next = vle32_v_i32m8(row + j + 1, vl);\n            vbool4_t mask = vmgt_vv_i32m8_b4(current, next, vl);\n            if (!vmfirst_m_b4(mask, vl)) {\n                return false;\n            }\n            j += vl;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        size_t j = 0;\n        while (j < cols) {\n            size_t vl = vsetvl_e32m8(cols - j);\n            vint32m8_t current = vle32_v_i32m8(row + j, vl);\n            vint32m8_t next = vle32_v_i32m8(row + j + 1, vl);\n            vbool4_t mask = vmgt_vv_i32m8_b4(current, next, vl);\n            if (!vmfirst_m_b4(mask, vl)) {\n                return false;\n            }\n            j += vl;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdbool.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n\n    for (size_t i = 0; i < num_blocks_row; ++i) {\n        for (size_t j = 0; j < num_blocks_col; ++j) {\n            size_t block_start = i * block_size * cols + j * block_size;\n            vint32m1_t first_block = vle32_v_i32m1(matrix + block_start, block_size * block_size);\n            for (size_t bi = 0; bi < block_size; ++bi) {\n                for (size_t bj = 0; bj < block_size; ++bj) {\n                    size_t current_block_start = (i * block_size + bi) * cols + j * block_size + bj;\n                    vint32m1_t current_block = vle32_v_i32m1(matrix + current_block_start, 1);\n                    vbool4_t mask = vmseq_vv_i32m1_b4(first_block, current_block, block_size * block_size);\n                    if (!vmfirst_m_b4(mask)) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdbool.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n\n    for (size_t i = 0; i < num_blocks_row; ++i) {\n        for (size_t j = 0; j < num_blocks_col; ++j) {\n            size_t block_start = i * block_size * cols + j * block_size;\n            vint32m1_t first_block = vle32_v_i32m1(matrix + block_start, block_size * block_size);\n            for (size_t bi = 0; bi < block_size; ++bi) {\n                for (size_t bj = 0; bj < block_size; ++bj) {\n                    size_t current_block_start = (i * block_size + bi) * cols + j * block_size + bj;\n                    vint32m1_t current_block = vle32_v_i32m1(matrix + current_block_start, 1);\n                    vbool4_t mask = vmseq_vv_i32m1_b4(first_block, current_block, block_size * block_size);\n                    if (!vmfirst_m_b4(mask)) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdbool.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n\n    vint32m1_t first_block_v = vle32_v_i32m1(matrix, block_size * block_size);\n\n    for (size_t i = 0; i < num_blocks_row; ++i) {\n        for (size_t j = 0; j < num_blocks_col; ++j) {\n            size_t block_start = (i * cols + j * block_size) * block_size;\n            vint32m1_t current_block_v = vle32_v_i32m1(&matrix[block_start], block_size * block_size);\n            vbool4_t mask = vmseq_vv_i32m1_b4(first_block_v, current_block_v, block_size * block_size);\n            if (!vmfirst_m_b4(mask)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdbool.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n\n    for (size_t i = 0; i < num_blocks_row; ++i) {\n        for (size_t j = 0; j < num_blocks_col; ++j) {\n            size_t block_start = i * block_size * cols + j * block_size;\n            vint32m1_t first_block = vle32_v_i32m1(matrix + block_start, block_size * block_size);\n            for (size_t bi = 0; bi < block_size; ++bi) {\n                for (size_t bj = 0; bj < block_size; ++bj) {\n                    size_t current_block_start = (i * block_size + bi) * cols + j * block_size + bj;\n                    vint32m1_t current_block = vle32_v_i32m1(matrix + current_block_start, 1);\n                    vbool4_t mask = vmseq_vv_i32m1_b4(first_block, current_block, block_size * block_size);\n                    if (!vmfirst_m_b4(mask)) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdbool.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n\n    vint32m1_t first_block_v = vle32_v_i32m1(matrix, block_size * block_size);\n\n    for (size_t i = 0; i < num_blocks_row; ++i) {\n        for (size_t j = 0; j < num_blocks_col; ++j) {\n            size_t block_start = (i * cols + j * block_size) * block_size;\n            vint32m1_t current_block_v = vle32_v_i32m1(&matrix[block_start], block_size * block_size);\n            vbool4_t mask = vmseq_vv_i32m1_b4(first_block_v, current_block_v, block_size * block_size);\n            if (!vmfirst_m_b4(mask)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    vfloat64m1_t first_block = vle64_v_f64m1(vec, block_size);\n    vfloat64m1_t tol_vec = vfmul_vf_f64m1(vfsub_vv_f64m1(first_block, first_block, block_size), tolerance, block_size);\n\n    for (size_t i = 1; i < num_blocks; ++i) {\n        vfloat64m1_t current_block = vle64_v_f64m1(vec + i * block_size, block_size);\n        vbool64_t mask = vmflt_vv_b64(vfabs_vv_f64m1(vfsub_vv_f64m1(current_block, first_block, block_size), block_size), tol_vec, block_size);\n        if (!vmfirst_m_b64(mask)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (length < block_size || block_size == 0) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    vfloat64m1_t first_block = vle64_v_f64m1(vec, block_size);\n    vfloat64m1_t tol_vec = vfmul_vf_f64m1(vfsub_vv_f64m1(first_block, first_block, block_size), tolerance, block_size);\n\n    for (size_t i = 1; i < num_blocks; ++i) {\n        vfloat64m1_t current_block = vle64_v_f64m1(vec + i * block_size, block_size);\n        vbool64_t mask = vmflt_vv_b64(vfabs_vv_f64m1(vfsub_vv_f64m1(current_block, first_block, block_size), block_size), tol_vec, block_size);\n        if (!vmfirst_m_b64(mask)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (length < block_size || block_size == 0) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    vfloat64m1_t v_tolerance = vfmv_f_s_f64m1(tolerance, 1);\n    vfloat64m1_t v_first_block = vle64_v_f64m1(vec, block_size);\n\n    for (size_t i = 1; i < num_blocks; ++i) {\n        vfloat64m1_t v_current_block = vle64_v_f64m1(vec + i * block_size, block_size);\n        vbool64_t v_mask = vfeq_vv_f64m1_b64(v_first_block, v_current_block, block_size);\n        vfloat64m1_t v_diff = vfsub_vv_f64m1(v_first_block, v_current_block, block_size);\n        vfloat64m1_t v_abs_diff = vfabs_v_f64m1(v_diff, block_size);\n        vbool64_t v_within_tolerance = vflt_vv_f64m1_b64(v_abs_diff, v_tolerance, block_size);\n        vbool64_t v_result = vand_vv_b64(v_mask, v_within_tolerance, block_size);\n\n        if (!vmfirst_m_b64(v_result, block_size)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (length < block_size || block_size == 0) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    vfloat64m1_t first_block = vle64_v_f64m1(vec, block_size);\n    vfloat64m1_t tol_vec = vfmul_vf_f64m1(vfsub_vv_f64m1(first_block, first_block, block_size), tolerance, block_size);\n\n    for (size_t i = 1; i < num_blocks; ++i) {\n        vfloat64m1_t current_block = vle64_v_f64m1(vec + i * block_size, block_size);\n        vbool64_t mask = vmflt_vv_b64(vfabs_vv_f64m1(vfsub_vv_f64m1(current_block, first_block, block_size), block_size), tol_vec, block_size);\n        if (!vmfirst_m_b64(mask)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    vfloat64m1_t first_block = vle64_v_f64m1(vec, block_size);\n    vfloat64m1_t tol_vec = vfmul_vf_f64m1(vbroadcast_v_f64m1_f64(tolerance, block_size), 2.0, block_size);\n\n    for (size_t i = 1; i < num_blocks; ++i) {\n        vfloat64m1_t current_block = vle64_v_f64m1(vec + i * block_size, block_size);\n        vfloat64m1_t diff = vfsub_vv_f64m1(first_block, current_block, block_size);\n        vfloat64m1_t abs_diff = vfabs_v_f64m1(diff, block_size);\n        vbool64_t mask = vmflt_vv_b64(abs_diff, tol_vec, block_size);\n        if (!vmfirst_m_b64(mask)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_39_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    size_t i;\n    for (i = 0; i < rows; ++i) {\n        double sum = 0.0;\n        size_t j;\n        for (j = 0; j < cols; j += vsetvl_e64m8(cols - j)) {\n            vfloat64m8_t v_matrix = vle64_v_f64m8(&matrix[i * cols + j], vundefined());\n            vfloat64m8_t v_squared = vmul_vv_f64m8(v_matrix, v_matrix, vundefined());\n            vfloat64m1_t v_sum = vredsum_vs_f64m8_f64m1(v_squared, vfmv_s_f_f64m1(0.0, vundefined()), vundefined());\n            sum += vfmv_f_s_f64m1_f64(v_sum);\n        }\n        double norm = sqrt(sum);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    size_t i;\n    for (i = 0; i < rows; ++i) {\n        double sum = 0.0;\n        size_t j;\n        for (j = 0; j < cols; j += vsetvl_e64m8(cols - j)) {\n            vfloat64m8_t v_matrix = vle64_v_f64m8(&matrix[i * cols + j], vsetvl_e64m8(cols - j));\n            v_matrix = vfmul_vv_f64m8(v_matrix, v_matrix, vsetvl_e64m8(cols - j));\n            vfloat64m8_t v_sum = vfredusum_vs_f64m8_f64m1(v_matrix, 0.0, vundefined_f64m1(), vsetvl_e64m8(cols - j));\n            sum += vfmv_f_s_f64m1_f64(v_sum);\n        }\n        double norm = sqrt(sum);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    size_t i;\n    for (i = 0; i < rows; ++i) {\n        double sum = 0.0;\n        size_t j;\n        for (j = 0; j < cols; j += vsetvl_e64m8(cols - j)) {\n            vfloat64m8_t v_matrix = vle64_v_f64m8(&matrix[i * cols + j], vsetvl_e64m8(cols - j));\n            vfloat64m8_t v_squared = vfmul_vv_f64m8(v_matrix, v_matrix, vsetvl_e64m8(cols - j));\n            vfloat64m1_t v_sum = vfredusum_vs_f64m8_f64m1(v_squared, 0.0, vundefined_f64m1(), vsetvl_e64m8(cols - j));\n            sum += vfmv_f_s_f64m1_f64(v_sum);\n        }\n        double norm = sqrt(sum);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    size_t i;\n    for (i = 0; i < rows; ++i) {\n        double sum = 0.0;\n        size_t j;\n        for (j = 0; j < cols; j += vsetvl_e64m8(cols - j)) {\n            vfloat64m8_t v_matrix = vle64_v_f64m8(&matrix[i * cols + j], vundefined());\n            vfloat64m8_t v_squared = vfmul_vv_f64m8(v_matrix, v_matrix, vundefined());\n            vfloat64m1_t v_sum = vfredusum_vs_f64m8_f64m1(v_squared, 0.0, vundefined());\n            sum += vfmv_f_s_f64m1_f64(v_sum);\n        }\n        double norm = sqrt(sum);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    size_t i;\n    for (i = 0; i < rows; ++i) {\n        double sum = 0.0;\n        size_t j;\n        for (j = 0; j < cols; j += vsetvl_e64m8(cols - j)) {\n            vfloat64m8_t v_matrix = vle64_v_f64m8(&matrix[i * cols + j], vsetvl_e64m8(cols - j));\n            vfloat64m8_t v_squared = vfmul_vv_f64m8(v_matrix, v_matrix, vsetvl_e64m8(cols - j));\n            vfloat64m1_t v_sum = vfredusum_vs_f64m8_f64m1(v_squared, 0.0, vundefined_f64m1(), vsetvl_e64m8(cols - j));\n            sum += vfmv_f_s_f64m1_f64(v_sum);\n        }\n        double norm = sqrt(sum);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_40_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        vuint32m8_t va = vle32_v_u32m8(&A[i], vl);\n        vuint32m8_t vb = vle32_v_u32m8(&B[i], vl);\n        vuint32m8_t vc = vor_vv_u32m8(va, vb, vl);\n        vse32_v_u32m8(&C[i], vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_40_RVV", "completion": "```c\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        vuint32m8_t va = vle32_v_u32m8(&A[i], vl);\n        vuint32m8_t vb = vle32_v_u32m8(&B[i], vl);\n        vuint32m8_t vc = vor_vv_u32m8(va, vb, vl);\n        vse32_v_u32m8(&C[i], vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_40_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        vuint32m8_t va = vle32_v_u32m8(&A[i], vl);\n        vuint32m8_t vb = vle32_v_u32m8(&B[i], vl);\n        vuint32m8_t vc = vor_vv_u32m8(va, vb, vl);\n        vse32_v_u32m8(&C[i], vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_40_RVV", "completion": "```c\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        vuint32m8_t va = vle32_v_u32m8(&A[i], vl);\n        vuint32m8_t vb = vle32_v_u32m8(&B[i], vl);\n        vuint32m8_t vc = vor_vv_u32m8(va, vb, vl);\n        vse32_v_u32m8(&C[i], vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_40_RVV", "completion": "```c\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        vuint32m8_t va = vle32_v_u32m8(&A[i], vl);\n        vuint32m8_t vb = vle32_v_u32m8(&B[i], vl);\n        vuint32m8_t vc = vor_vv_u32m8(va, vb, vl);\n        vse32_v_u32m8(&C[i], vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_41_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    size_t vl = __riscv_vsetvl_e8m1(length);\n    vint8m1_t va, vb;\n    vint16m2_t vprod, vsumsq_a, vsumsq_b;\n    vint32m4_t vsum_prod, vsum_sumsq_a, vsum_sumsq_b;\n    int32_t sum_prod = 0, sum_sumsq_a = 0, sum_sumsq_b = 0;\n\n    va = __riscv_vle8_v_i8m1(A, vl);\n    vb = __riscv_vle8_v_i8m1(B, vl);\n\n    vprod = __riscv_vwmul_vv_i16m2(va, vb, vl);\n    vsumsq_a = __riscv_vwmul_vv_i16m2(va, va, vl);\n    vsumsq_b = __riscv_vwmul_vv_i16m2(vb, vb, vl);\n\n    vsum_prod = __riscv_vwredsum_vs_i16m2_i32m4(vprod, vsum_prod, vl);\n    vsum_sumsq_a = __riscv_vwredsum_vs_i16m2_i32m4(vsumsq_a, vsum_sumsq_a, vl);\n    vsum_sumsq_b = __riscv_vwredsum_vs_i16m2_i32m4(vsumsq_b, vsum_sumsq_b, vl);\n\n    sum_prod = __riscv_vmv_x_s_i32m4_i32(vsum_prod);\n    sum_sumsq_a = __riscv_vmv_x_s_i32m4_i32(vsum_sumsq_a);\n    sum_sumsq_b = __riscv_vmv_x_s_i32m4_i32(vsum_sumsq_b);\n\n    return (int64_t)(sum_sumsq_a + sum_sumsq_b - 2 * sum_prod);\n}\n```"}
{"task_id": "SimdBench_41_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    size_t vl = __riscv_vsetvl_e8m1(length);\n    vint8m1_t va, vb;\n    vint16m2_t vprod, vsumsq_a, vsumsq_b;\n    vint32m4_t vsum_prod, vsum_sumsq_a, vsum_sumsq_b;\n    int32_t sum_prod = 0, sum_sumsq_a = 0, sum_sumsq_b = 0;\n\n    do {\n        va = __riscv_vle8_v_i8m1(A, vl);\n        vb = __riscv_vle8_v_i8m1(B, vl);\n\n        vprod = __riscv_vwmul_vv_i16m2(va, vb, vl);\n        vsumsq_a = __riscv_vwmul_vv_i16m2(va, va, vl);\n        vsumsq_b = __riscv_vwmul_vv_i16m2(vb, vb, vl);\n\n        vsum_prod = __riscv_vwredsum_vs_i16m2_i32m4(vprod, vsum_prod, vl);\n        vsum_sumsq_a = __riscv_vwredsum_vs_i16m2_i32m4(vsumsq_a, vsum_sumsq_a, vl);\n        vsum_sumsq_b = __riscv_vwredsum_vs_i16m2_i32m4(vsumsq_b, vsum_sumsq_b, vl);\n\n        A += vl;\n        B += vl;\n        length -= vl;\n        vl = __riscv_vsetvl_e8m1(length);\n    } while (length > 0);\n\n    sum_prod = __riscv_vmv_x_s_i32m4_i32(vsum_prod);\n    sum_sumsq_a = __riscv_vmv_x_s_i32m4_i32(vsum_sumsq_a);\n    sum_sumsq_b = __riscv_vmv_x_s_i32m4_i32(vsum_sumsq_b);\n\n    return (int64_t)(sum_sumsq_a + sum_sumsq_b - 2 * sum_prod);\n}\n```"}
{"task_id": "SimdBench_41_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    size_t vl = __riscv_vsetvl_e8m1(length);\n    vint8m1_t va, vb;\n    vint16m2_t vsqsum, vprodsum;\n    vint32m4_t vacc_sqsum = __riscv_vmv_v_x_i32m4(0, vl);\n    vint32m4_t vacc_prodsum = __riscv_vmv_v_x_i32m4(0, vl);\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e8m1(length - i);\n        va = __riscv_vle8_v_i8m1(A + i, vl);\n        vb = __riscv_vle8_v_i8m1(B + i, vl);\n\n        vsqsum = __riscv_vwmul_vv_i16m2(va, va, vl);\n        vprodsum = __riscv_vwmul_vv_i16m2(va, vb, vl);\n\n        vacc_sqsum = __riscv_vwredsum_vs_i16m2_i32m4(vsqsum, vacc_sqsum, vl);\n        vacc_prodsum = __riscv_vwredsum_vs_i16m2_i32m4(vprodsum, vacc_prodsum, vl);\n    }\n\n    int32_t sqsum = __riscv_vmv_x_s_i32m4_i32(vacc_sqsum);\n    int32_t prodsum = __riscv_vmv_x_s_i32m4_i32(vacc_prodsum);\n\n    return (int64_t)sqsum - (int64_t)prodsum;\n}\n```"}
{"task_id": "SimdBench_41_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    size_t vl = length;\n    vint8m1_t va, vb;\n    vint16m2_t vprod, vsumsq_a, vsumsq_b;\n    vint32m4_t vsum_prod, vsum_sumsq_a, vsum_sumsq_b;\n    int32_t sum_prod = 0, sum_sumsq_a = 0, sum_sumsq_b = 0;\n\n    do {\n        vl = vsetvl_e8m1(vl);\n        va = vle8_v_i8m1(A, vl);\n        vb = vle8_v_i8m1(B, vl);\n\n        vprod = vwmul_vv_i16m2(va, vb, vl);\n        vsumsq_a = vwmul_vv_i16m2(va, va, vl);\n        vsumsq_b = vwmul_vv_i16m2(vb, vb, vl);\n\n        vsum_prod = vwredsum_vs_i16m2_i32m4(vsum_prod, vprod, vsum_prod, vl);\n        vsum_sumsq_a = vwredsum_vs_i16m2_i32m4(vsum_sumsq_a, vsumsq_a, vsum_sumsq_a, vl);\n        vsum_sumsq_b = vwredsum_vs_i16m2_i32m4(vsum_sumsq_b, vsumsq_b, vsum_sumsq_b, vl);\n\n        sum_prod += vmv_x_s_i32m4_i32(vsum_prod);\n        sum_sumsq_a += vmv_x_s_i32m4_i32(vsum_sumsq_a);\n        sum_sumsq_b += vmv_x_s_i32m4_i32(vsum_sumsq_b);\n\n        A += vl;\n        B += vl;\n    } while (vl == length);\n\n    return (sum_sumsq_a + sum_sumsq_b) - 2 * sum_prod;\n}\n```"}
{"task_id": "SimdBench_41_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    size_t vl = __riscv_vsetvl_e8m1(length);\n    vint8m1_t va, vb;\n    vint16m2_t vsquares, vproducts;\n    vint32m4_t vsumsquares, vsumproducts;\n    int32_t sum_squares = 0, sum_products = 0;\n\n    do {\n        va = __riscv_vle8_v_i8m1(A, vl);\n        vb = __riscv_vle8_v_i8m1(B, vl);\n\n        vsquares = __riscv_vwmul_vv_i16m2(va, va, vl);\n        vproducts = __riscv_vwmul_vv_i16m2(va, vb, vl);\n\n        vsumsquares = __riscv_vwredsum_vs_i16m2_i32m4(vsquares, vsumsquares, vl);\n        vsumproducts = __riscv_vwredsum_vs_i16m2_i32m4(vproducts, vsumproducts, vl);\n\n        A += vl;\n        B += vl;\n        length -= vl;\n        vl = __riscv_vsetvl_e8m1(length);\n    } while (length > 0);\n\n    sum_squares = __riscv_vmv_x_s_i32m4_i32(vsumsquares);\n    sum_products = __riscv_vmv_x_s_i32m4_i32(vsumproducts);\n\n    return sum_squares - sum_products;\n}\n```"}
{"task_id": "SimdBench_42_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m1(length - i);\n        vuint64m1_t vecA = vle64_v_u64m1(&A[i], vl);\n        vuint64m1_t vecB = vle64_v_u64m1(&B[i], vl);\n        vuint64m1_t vecNotB = vmvn_v_u64m1(vecB, vl);\n        vuint64m1_t vecResult = vand_vv_u64m1(vecA, vecNotB, vl);\n        vse64_v_u64m1(&C[i], vecResult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_42_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m1(length - i);\n        vuint64m1_t va = vle64_v_u64m1(&A[i], vl);\n        vuint64m1_t vb = vle64_v_u64m1(&B[i], vl);\n        vuint64m1_t vnegb = vmvn_v_u64m1(vb, vl);\n        vuint64m1_t vresult = vand_vv_u64m1(va, vnegb, vl);\n        vse64_v_u64m1(&C[i], vresult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_42_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m1(length - i);\n        vuint64m1_t vecA = vle64_v_u64m1(&A[i], vl);\n        vuint64m1_t vecB = vle64_v_u64m1(&B[i], vl);\n        vuint64m1_t vecNotB = vmvn_v_u64m1(vecB, vl);\n        vuint64m1_t vecResult = vand_vv_u64m1(vecA, vecNotB, vl);\n        vse64_v_u64m1(&C[i], vecResult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_42_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m1(length - i);\n        vuint64m1_t vecA = vle64_v_u64m1(&A[i], vl);\n        vuint64m1_t vecB = vle64_v_u64m1(&B[i], vl);\n        vuint64m1_t vecNotB = vmvn_v_u64m1(vecB, vl);\n        vuint64m1_t vecResult = vand_vv_u64m1(vecA, vecNotB, vl);\n        vse64_v_u64m1(&C[i], vecResult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_42_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m1(length - i);\n        vuint64m1_t vecA = vle64_v_u64m1(&A[i], vl);\n        vuint64m1_t vecB = vle64_v_u64m1(&B[i], vl);\n        vuint64m1_t vecNotB = vmvn_v_u64m1(vecB, vl);\n        vuint64m1_t vecResult = vand_vv_u64m1(vecA, vecNotB, vl);\n        vse64_v_u64m1(&C[i], vecResult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_43_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t vl = vsetvl_e8m1(length);\n    vint8m1_t va, vb, vresult;\n    vbool8m1_t mask_pos, mask_neg;\n\n    do {\n        va = vle8_v_i8m1(A, vl);\n        vb = vle8_v_i8m1(B, vl);\n\n        mask_pos = vm_and_vv_b8m1(vmsltz_vx_i8m1_b8m1(va, 0, vl), vmsltz_vx_i8m1_b8m1(vb, 0, vl), vl);\n        mask_neg = vm_and_vv_b8m1(vmsgtz_vx_i8m1_b8m1(va, 0, vl), vmsgtz_vx_i8m1_b8m1(vb, 0, vl), vl);\n\n        vresult = vmerge_vvm_i8m1(vmerge_vvm_i8m1(vzext_xf_i8m1(-1, vl), mask_neg, vl), vzext_xf_i8m1(1, vl), mask_pos, vl);\n\n        vse8_v_i8m1(C, vresult, vl);\n\n        A += vl;\n        B += vl;\n        C += vl;\n        length -= vl;\n        vl = vsetvl_e8m1(length);\n    } while (length > 0);\n}\n```"}
{"task_id": "SimdBench_43_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t vl = vsetvl_e8m1(length);\n    vint8m1_t va, vb, vpos, vneg, vzero, vresult;\n\n    do {\n        va = vle8_v_i8m1(A, vl);\n        vb = vle8_v_i8m1(B, vl);\n\n        vpos = vand_vv_i8m1(vmsltz_v_i8m1_b8(va, vl), vmsltz_v_i8m1_b8(vb, vl), vl);\n        vneg = vand_vv_i8m1(vmgez_v_i8m1_b8(va, vl), vmgez_v_i8m1_b8(vb, vl), vl);\n        vzero = vmseq_vx_i8m1_b8(vpos, 0, vl);\n        vzero = vor_vv_i8m1(vzero, vmseq_vx_i8m1_b8(vneg, 0, vl), vl);\n\n        vresult = vadd_vx_i8m1(vneg, -1, vl);\n        vresult = vmerge_vvm_i8m1(vpos, vresult, vzero, vl);\n\n        vse8_v_i8m1(C, vresult, vl);\n\n        A += vl;\n        B += vl;\n        C += vl;\n        length -= vl;\n        vl = vsetvl_e8m1(length);\n    } while (length > 0);\n}\n```"}
{"task_id": "SimdBench_43_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t vl = vsetvl_e8m1(length);\n    vint8m1_t va, vb, vresult;\n    vbool8m1_t mask1, mask2;\n\n    do {\n        va = vle8_v_i8m1(A, vl);\n        vb = vle8_v_i8m1(B, vl);\n\n        mask1 = vmul_vv_b8m1(va, vb, vl);\n        mask2 = vmslt_vv_b8m1(va, vzero_v_i8m1(vl), vl);\n\n        vresult = vcompress_vm_i8m1(vresult, mask1, vmslt_vv_b8m1(va, vzero_v_i8m1(vl), vl), vl);\n        vresult = vcompress_vm_i8m1(vresult, mask1, vmnot_m_b8m1(mask2, vl), vl);\n        vresult = vcompress_vm_i8m1(vresult, vmnot_m_b8m1(mask1, vl), vzero_v_i8m1(vl), vl);\n\n        vse8_v_i8m1(C, vresult, vl);\n\n        A += vl;\n        B += vl;\n        C += vl;\n        length -= vl;\n        vl = vsetvl_e8m1(length);\n    } while (length > 0);\n}\n```"}
{"task_id": "SimdBench_43_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t vl = vsetvl_e8m1(length);\n    vint8m1_t va, vb, vresult;\n    vbool8m1_t mask_pos, mask_neg;\n\n    do {\n        va = vle8_v_i8m1(A, vl);\n        vb = vle8_v_i8m1(B, vl);\n\n        mask_pos = vm_and_vv_b8m1(vmsltz_vx_i8m1_b8m1(va, 0, vl), vmsltz_vx_i8m1_b8m1(vb, 0, vl), vl);\n        mask_neg = vm_and_vv_b8m1(vmsgtz_vx_i8m1_b8m1(va, 0, vl), vmsgtz_vx_i8m1_b8m1(vb, 0, vl), vl);\n\n        vresult = vmerge_vvm_i8m1(vmerge_vvm_i8m1(vzext_vf2_i8m1(mask_pos, vl), vsext_vf2_i8m1(mask_neg, vl), vl), 0, vl);\n\n        vse8_v_i8m1(C, vresult, vl);\n\n        A += vl;\n        B += vl;\n        C += vl;\n        length -= vl;\n        vl = vsetvl_e8m1(length);\n    } while (length > 0);\n}\n```"}
{"task_id": "SimdBench_43_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t vl = vsetvl_e8m1(length);\n    vint8m1_t va, vb, vpos, vneg, vzero, vresult;\n\n    do {\n        va = vle8_v_i8m1(A, vl);\n        vb = vle8_v_i8m1(B, vl);\n\n        vpos = vand_vv_i8m1(vmsltz_v_i8m1_b8(va, vl), vmsltz_v_i8m1_b8(vb, vl), vl);\n        vneg = vand_vv_i8m1(vmgez_v_i8m1_b8(va, vl), vmgez_v_i8m1_b8(vb, vl), vl);\n        vzero = vmseq_vx_i8m1_b8(vpos, 0, vl);\n        vzero = vor_vv_i8m1(vzero, vmseq_vx_i8m1_b8(vneg, 0, vl), vl);\n\n        vresult = vadd_vx_i8m1(vneg, -1, vl);\n        vresult = vmerge_vvm_i8m1(vresult, vpos, vl);\n        vresult = vmerge_vvm_i8m1(vresult, vzero, vl);\n\n        vse8_v_i8m1(C, vresult, vl);\n\n        A += vl;\n        B += vl;\n        C += vl;\n        length -= vl;\n        vl = vsetvl_e8m1(length);\n    } while (length > 0);\n}\n```"}
{"task_id": "SimdBench_44_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t vl;\n\n    // Process elements before the midpoint with XOR\n    for (size_t i = 0; i < midpoint; i += vl) {\n        vl = vsetvl_e16m8(midpoint - i);\n        vuint16m8_t va = vle16_v_u16m8(&A[i], vl);\n        vuint16m8_t vb = vle16_v_u16m8(&B[i], vl);\n        vuint16m8_t vxor = vbxor_vv_u16m8(va, vb, vl);\n        vse16_v_u16m8(&C[i], vxor, vl);\n    }\n\n    // Process the element at the midpoint (if length is odd)\n    if (length % 2 != 0) {\n        C[midpoint] = A[midpoint];\n    }\n\n    // Process elements after the midpoint with AND\n    for (size_t i = midpoint + (length % 2); i < length; i += vl) {\n        vl = vsetvl_e16m8(length - i);\n        vuint16m8_t va = vle16_v_u16m8(&A[i], vl);\n        vuint16m8_t vb = vle16_v_u16m8(&B[i], vl);\n        vuint16m8_t vand = vband_vv_u16m8(va, vb, vl);\n        vse16_v_u16m8(&C[i], vand, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_44_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t vl = vsetvl_e16m8(length);\n\n    vuint16m8_t va = vle16_v_u16m8(A, vl);\n    vuint16m8_t vb = vle16_v_u16m8(B, vl);\n\n    vbool16_t mask = vmseq_m_b16(vl, vw_v_x_uint16m1(midpoint, vl), vl);\n\n    vuint16m8_t vxor = vbxor_vv_u16m8(va, vb, vl);\n    vuint16m8_t vand = vband_vv_u16m8(va, vb, vl);\n\n    vuint16m8_t result = vmerge_vvm_u16m8(vxor, vand, mask, vl);\n\n    if (length % 2 != 0) {\n        C[midpoint] = A[midpoint];\n    }\n\n    vse16_v_u16m8(C, result, vl);\n}\n```"}
{"task_id": "SimdBench_44_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t vl;\n\n    // Process elements before the midpoint with XOR\n    for (size_t i = 0; i < midpoint; i += vl) {\n        vl = vsetvl_e16m8(midpoint - i);\n        vuint16m8_t va = vle16_v_u16m8(&A[i], vl);\n        vuint16m8_t vb = vle16_v_u16m8(&B[i], vl);\n        vuint16m8_t vxor = vlxor_vv_u16m8(va, vb, vl);\n        vse16_v_u16m8(&C[i], vxor, vl);\n    }\n\n    // Process the element at the midpoint (if length is odd)\n    if (length % 2 != 0) {\n        C[midpoint] = A[midpoint];\n    }\n\n    // Process elements after the midpoint with AND\n    for (size_t i = midpoint + (length % 2); i < length; i += vl) {\n        vl = vsetvl_e16m8(length - i);\n        vuint16m8_t va = vle16_v_u16m8(&A[i], vl);\n        vuint16m8_t vb = vle16_v_u16m8(&B[i], vl);\n        vuint16m8_t vand = vland_vv_u16m8(va, vb, vl);\n        vse16_v_u16m8(&C[i], vand, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_44_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t vl = vsetvl_e16m8(length);\n\n    vuint16m8_t va = vle16_v_u16m8(A, vl);\n    vuint16m8_t vb = vle16_v_u16m8(B, vl);\n\n    vbool16_t mask = vmseq_m_b16(vl, vw_v_x_uint16m1(midpoint, vl), vl);\n    vuint16m8_t vxor = vbxor_vv_u16m8(va, vb, vl);\n    vuint16m8_t vand = vband_vv_u16m8(va, vb, vl);\n\n    vuint16m8_t result = vmerge_vvm_u16m8(vxor, vand, mask, vl);\n\n    if (length % 2 != 0) {\n        C[midpoint] = A[midpoint];\n    }\n\n    vse16_v_u16m8(C, result, vl);\n}\n```"}
{"task_id": "SimdBench_44_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t vl = vsetvl_e16m8(length);\n\n    vuint16m8_t va = vle16_v_u16m8(A, vl);\n    vuint16m8_t vb = vle16_v_u16m8(B, vl);\n\n    vbool16_t mask = vmseq_m_b16(vl, vwadd_vx_u16m8(vcreate_u16m8(midpoint), 0, vl), 0);\n\n    vuint16m8_t vxor = vbxor_vv_u16m8(va, vb, vl);\n    vuint16m8_t vand = vmand_vv_u16m8(va, vb, vl);\n\n    vuint16m8_t result = vmerge_vvm_u16m8(vxor, vand, mask, vl);\n\n    if (length % 2 != 0) {\n        vse16_v_u16m8(C, result, vl);\n        C[midpoint] = A[midpoint];\n    } else {\n        vse16_v_u16m8(C, result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_45_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n\n        vfloat32m8_t va = vle32_v_f32m8(&A[i], vl);\n        vfloat32m8_t vb = vle32_v_f32m8(&B[i], vl);\n        vfloat32m8_t vc = vle32_v_f32m8(&C[i], vl);\n        vfloat32m8_t vd = vle32_v_f32m8(&D[i], vl);\n\n        vbool8_t vcond1 = vmseq_vx_u8m8(vle8_v_u8m8((const uint8_t*)&cond1[i], vl), 1, vl);\n        vbool8_t vcond2 = vmseq_vx_u8m8(vle8_v_u8m8((const uint8_t*)&cond2[i], vl), 1, vl);\n\n        vbool8_t vcond1_and_cond2 = vand_vv_b8(vcond1, vcond2, vl);\n        vbool8_t vcond1_and_not_cond2 = vand_vv_b8(vcond1, vnot_v_b8(vcond2, vl), vl);\n        vbool8_t vnot_cond1_and_cond2 = vand_vv_b8(vnot_v_b8(vcond1, vl), vcond2, vl);\n\n        vfloat32m8_t vout = vfmerge_vvm_f32m8(vfmerge_vvm_f32m8(vd, vc, vnot_cond1_and_cond2, vl), vb, vcond1_and_not_cond2, vl);\n        vout = vfmerge_vvm_f32m8(vout, va, vcond1_and_cond2, vl);\n\n        vse32_v_f32m8(&out[i], vout, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_45_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n\n        vfloat32m8_t va = vle32_v_f32m8(&A[i], vl);\n        vfloat32m8_t vb = vle32_v_f32m8(&B[i], vl);\n        vfloat32m8_t vc = vle32_v_f32m8(&C[i], vl);\n        vfloat32m8_t vd = vle32_v_f32m8(&D[i], vl);\n\n        vbool4m8_t vcond1 = vmseq_vx_u8m8(vle8_v_u8m8((const uint8_t*)&cond1[i], vl), 1, vl);\n        vbool4m8_t vcond2 = vmseq_vx_u8m8(vle8_v_u8m8((const uint8_t*)&cond2[i], vl), 1, vl);\n\n        vbool4m8_t vcond1_and_cond2 = vand_vv_b4m8(vcond1, vcond2, vl);\n        vbool4m8_t vcond1_and_not_cond2 = vand_vv_b4m8(vcond1, vmnot_m_b4m8(vcond2, vl), vl);\n        vbool4m8_t vnot_cond1_and_cond2 = vand_vv_b4m8(vmnot_m_b4m8(vcond1, vl), vcond2, vl);\n\n        vfloat32m8_t vout = vfmerge_vvm_f32m8(vfmerge_vvm_f32m8(vd, vc, vnot_cond1_and_cond2, vl), vb, vcond1_and_not_cond2, vl);\n        vout = vfmerge_vvm_f32m8(vout, va, vcond1_and_cond2, vl);\n\n        vse32_v_f32m8(&out[i], vout, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_45_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n\n        vfloat32m8_t va = vle32_v_f32m8(&A[i], vl);\n        vfloat32m8_t vb = vle32_v_f32m8(&B[i], vl);\n        vfloat32m8_t vc = vle32_v_f32m8(&C[i], vl);\n        vfloat32m8_t vd = vle32_v_f32m8(&D[i], vl);\n\n        vbool4_t vcond1 = vmseq_vx_u8m4(vle8_v_u8m4((const uint8_t*)&cond1[i], vl), 1, vl);\n        vbool4_t vcond2 = vmseq_vx_u8m4(vle8_v_u8m4((const uint8_t*)&cond2[i], vl), 1, vl);\n\n        vbool4_t vcond1_and_cond2 = vand_vv_u8m4(vcond1, vcond2, vl);\n        vbool4_t vcond1_and_not_cond2 = vand_vv_u8m4(vcond1, vnot_m_b4(vcond2, vl), vl);\n        vbool4_t vnot_cond1_and_cond2 = vand_vv_u8m4(vnot_m_b4(vcond1, vl), vcond2, vl);\n\n        vfloat32m8_t vout = vfmerge_vvm_f32m8(vfmerge_vvm_f32m8(vd, vc, vnot_cond1_and_cond2, vl), vb, vcond1_and_not_cond2, vl);\n        vout = vfmerge_vvm_f32m8(vout, va, vcond1_and_cond2, vl);\n\n        vse32_v_f32m8(&out[i], vout, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_45_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n\n        vfloat32m8_t va = vle32_v_f32m8(&A[i], vl);\n        vfloat32m8_t vb = vle32_v_f32m8(&B[i], vl);\n        vfloat32m8_t vc = vle32_v_f32m8(&C[i], vl);\n        vfloat32m8_t vd = vle32_v_f32m8(&D[i], vl);\n\n        vbool8_t vcond1 = vmseq_vx_u8m8(vle8_v_u8m8((const uint8_t*)&cond1[i], vl), 1, vl);\n        vbool8_t vcond2 = vmseq_vx_u8m8(vle8_v_u8m8((const uint8_t*)&cond2[i], vl), 1, vl);\n\n        vbool8_t vcond1_and_cond2 = vand_vv_b8(vcond1, vcond2, vl);\n        vbool8_t vcond1_and_not_cond2 = vand_vv_b8(vcond1, vnot_v_b8(vcond2, vl), vl);\n        vbool8_t vnot_cond1_and_cond2 = vand_vv_b8(vnot_v_b8(vcond1, vl), vcond2, vl);\n\n        vfloat32m8_t vout = vfmerge_vvm_f32m8(vfmerge_vvm_f32m8(vd, vc, vnot_cond1_and_cond2, vl), vb, vcond1_and_not_cond2, vl);\n        vout = vfmerge_vvm_f32m8(vout, va, vcond1_and_cond2, vl);\n\n        vse32_v_f32m8(&out[i], vout, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_45_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n\n        vfloat32m8_t va = vle32_v_f32m8(&A[i], vl);\n        vfloat32m8_t vb = vle32_v_f32m8(&B[i], vl);\n        vfloat32m8_t vc = vle32_v_f32m8(&C[i], vl);\n        vfloat32m8_t vd = vle32_v_f32m8(&D[i], vl);\n\n        vbool4_t vcond1 = vmseq_vx_u8m4(vle8_v_u8m4((const uint8_t*)&cond1[i], vl), 1, vl);\n        vbool4_t vcond2 = vmseq_vx_u8m4(vle8_v_u8m4((const uint8_t*)&cond2[i], vl), 1, vl);\n\n        vbool4_t vcond1_and_cond2 = vand_vv_u8m4(vcond1, vcond2, vl);\n        vbool4_t vcond1_and_not_cond2 = vand_vv_u8m4(vcond1, vnot_m_b4(vcond2, vl), vl);\n        vbool4_t vnot_cond1_and_cond2 = vand_vv_u8m4(vnot_m_b4(vcond1, vl), vcond2, vl);\n\n        vfloat32m8_t vout = vfmerge_vvm_f32m8(vfmerge_vvm_f32m8(vd, vc, vnot_cond1_and_cond2, vl), vb, vcond1_and_not_cond2, vl);\n        vout = vfmerge_vvm_f32m8(vout, va, vcond1_and_cond2, vl);\n\n        vse32_v_f32m8(&out[i], vout, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_46_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n        vuint32m8_t vec_A = vle32_v_u32m8(&A[i], vl);\n        vuint8mf8_t vec_out = vpopcnt_v_u32mf8(vec_A, vl);\n        vse8_v_u8mf8(&out[i], vec_out, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_46_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n        vuint32m8_t vec_A = vle32_v_u32m8(&A[i], vl);\n        vuint8m8_t vec_out = vpopcnt_v_u32m8_u8m8(vec_A, vl);\n        vse8_v_u8m8(&out[i], vec_out, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_46_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n        vuint32m8_t vec_A = vle32_v_u32m8(&A[i], vl);\n        vuint8m8_t vec_out = vpopcnt_v_u32m8_u8m8(vec_A, vl);\n        vse8_v_u8m8(&out[i], vec_out, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_46_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n        vuint32m8_t vec_A = vle32_v_u32m8(&A[i], vl);\n        vuint8mf8_t vec_out = vpopcnt_v_u32mf8(vec_A, vl);\n        vse8_v_u8mf8(&out[i], vec_out, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_46_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n        vuint32m8_t vec_A = vle32_v_u32m8(&A[i], vl);\n        vuint8m8_t vec_out = vpopcnt_v_u32m8_u8m8(vec_A, vl);\n        vse8_v_u8m8(&out[i], vec_out, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_47_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t n = rows * cols;\n    size_t vl;\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m8(n - i);\n\n        vint32m8_t va = vle32_v_i32m8(&A[i], vl);\n        vbool8_t mask = vmseq_vx_i32m8_b8(va, 0, vl);\n        mask = vmaskn_m_b8(mask, vmsnez_vx_i32m8_b8(va, 3, vl), vl);\n\n        vint32m8_t vabs = vabs_v_i32m8(va, vl);\n        va = vmerge_vvm_i32m8(mask, vabs, va, vl);\n\n        vse32_v_i32m8(&B[i], va, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_47_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t n = rows * cols;\n    size_t vl;\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m8(n - i);\n\n        vint32m8_t va = vle32_v_i32m8(&A[i], vl);\n        vbool4_t mask = vmseq_vx_i32m8_b4(va, 3, vl);\n        vint32m8_t abs_va = vabs_v_i32m8(va, vl);\n        vint32m8_t result = vmerge_vvm_i32m8(abs_va, va, mask, vl);\n\n        vse32_v_i32m8(&B[i], result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_47_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t n = rows * cols;\n    size_t vl;\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m8(n - i);\n\n        vint32m8_t va = vle32_v_i32m8(&A[i], vl);\n        vbool4_t mask = vmseq_vx_i32m8_b4(va, 3, vl);\n        vint32m8_t abs_va = vabs_v_i32m8(va, vl);\n        vint32m8_t result = vmerge_vvm_i32m8(mask, abs_va, va, vl);\n\n        vse32_v_i32m8(&B[i], result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_47_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t n = rows * cols;\n    size_t vl;\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m8(n - i);\n\n        vint32m8_t va = vle32_v_i32m8(&A[i], vl);\n        vbool8_t mask = vmsne_vx_i32m8_b8(va, 0, vl);\n        mask = vmseq_vx_i32m8_b8(va, 0, vl);\n        mask = vmseq_vx_i32m8_b8(va, 3, vl);\n        mask = vmsnez_vx_i32m8_b8(va, 3, vl);\n\n        vint32m8_t abs_va = vabs_v_i32m8(va, vl);\n        vse32_v_i32m8(&B[i], vmv_v_v_i32m8_m(mask, va, abs_va, vl), vl);\n    }\n}\n```"}
{"task_id": "SimdBench_47_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t n = rows * cols;\n    size_t vl;\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m8(n - i);\n\n        vint32m8_t va = vle32_v_i32m8(&A[i], vl);\n        vbool8_t mask = vmseq_vx_i32m8_b8(va, 0, vl);\n        mask = vmaskn_m_b8(mask, vmsne_vx_i32m8_b8(va, 3, vl), vl);\n\n        vint32m8_t vabs = vabs_v_i32m8(va, vl);\n        vse32_v_i32m8(&B[i], vmerge_vvm_i32m8(va, vabs, mask, vl));\n    }\n}\n```"}
{"task_id": "SimdBench_48_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    size_t vl = vsetvl_e32m8(length);\n    vuint32m8_t src_v = vle32_v_u32m8(src, vl);\n    vuint32m8_t mask_v = vmseq_vx_u32m8(vand_vx_u32m8(src_v, 0xF, vl), 0xF, vl);\n    vuint32m8_t rotated_v = vrol_vx_u32m8(src_v, rotate_bits, vl);\n    vuint32m8_t negated_v = vneg_v_u32m8(src_v, vl);\n    vuint32m8_t result_v = vmerge_vvm_u32m8(mask_v, rotated_v, negated_v, vl);\n    vse32_v_u32m8(dst, result_v, vl);\n}\n```"}
{"task_id": "SimdBench_48_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    size_t vl = vsetvl_e32m8(length);\n    vuint32m8_t src_v = vle32_v_u32m8(src, vl);\n    vuint32m8_t mask_v = vmseq_vx_u32m8(vand_vx_u32m8(src_v, 0xF, vl), 0xF, vl);\n    vuint32m8_t rotated_v = vror_vx_u32m8(src_v, rotate_bits, vl);\n    vuint32m8_t negated_v = vnot_v_u32m8(src_v, vl);\n    vuint32m8_t result_v = vmerge_vvm_u32m8(mask_v, rotated_v, negated_v, vl);\n    vse32_v_u32m8(dst, result_v, vl);\n}\n```"}
{"task_id": "SimdBench_48_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    size_t vl = vsetvl_e32m8(length);\n    vuint32m8_t src_v = vle32_v_u32m8(src, vl);\n    vuint32m8_t mask_v = vmseq_vx_i32m8(vand_vx_i32m8(src_v, 0xF, vl), 0xF, vl);\n    vuint32m8_t rotated_v = vrol_vx_u32m8(src_v, rotate_bits, vl);\n    vuint32m8_t negated_v = vneg_v_u32m8(src_v, vl);\n    vuint32m8_t result_v = vmerge_vvm_u32m8(mask_v, rotated_v, negated_v, vl);\n    vse32_v_u32m8(dst, result_v, vl);\n}\n```"}
{"task_id": "SimdBench_48_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    size_t vl = vsetvl_e32m8(length);\n    vuint32m8_t src_v = vle32_v_u32m8(src, vl);\n    vuint32m8_t mask_v = vmseq_vx_u32m8(vand_vx_u32m8(src_v, 0xF, vl), 0xF, vl);\n    vuint32m8_t rotated_v = vrol_vx_u32m8(src_v, rotate_bits, vl);\n    vuint32m8_t negated_v = vnot_v_u32m8(src_v, vl);\n    vuint32m8_t result_v = vmerge_vvm_u32m8(mask_v, rotated_v, negated_v, vl);\n    vse32_v_u32m8(dst, result_v, vl);\n}\n```"}
{"task_id": "SimdBench_48_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    size_t vl = vsetvl_e32m8(length);\n    vuint32m8_t src_v = vle32_v_u32m8(src, vl);\n    vuint32m8_t mask_v = vmseq_vx_u32m8(vand_vx_u32m8(src_v, 0xF, vl), 0xF, vl);\n    vuint32m8_t rotated_v = vrol_vx_u32m8(src_v, rotate_bits, vl);\n    vuint32m8_t negated_v = vnot_v_u32m8(src_v, vl);\n    vuint32m8_t result_v = vmerge_vvm_u32m8(mask_v, rotated_v, negated_v, vl);\n    vse32_v_u32m8(dst, result_v, vl);\n}\n```"}
{"task_id": "SimdBench_49_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t vl = vsetvl_e32m8(length);\n    vfloat32m8_t vec_A, vec_B, vec_epsilon;\n    vint8m8_t vec_out;\n    vbool4_t mask_gt, mask_lt;\n\n    vec_epsilon = vfmv_v_f_f32m8(fabsf(epsilon), vl);\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        vec_A = vle32_v_f32m8(&A[i], vl);\n        vec_B = vle32_v_f32m8(&B[i], vl);\n\n        vfloat32m8_t diff = vfsub_vv_f32m8(vec_A, vec_B, vl);\n        vfloat32m8_t abs_diff = vfabs_v_f32m8(diff, vl);\n\n        mask_gt = vmfgt_vv_b4_f32m8(abs_diff, vec_epsilon, vl);\n        mask_lt = vflt_vv_b4_f32m8(diff, vfneg_v_f32m8(vec_epsilon, vl), vl);\n\n        vec_out = vmerge_vvm_i8m8(vreinterpret_v_i8m8_i32m8(vmv_v_x_i32m8(1, vl)), vreinterpret_v_i8m8_i32m8(vmv_v_x_i32m8(-1, vl)), mask_lt, vl);\n        vec_out = vmerge_vvm_i8m8(vec_out, vreinterpret_v_i8m8_i32m8(vmv_v_x_i32m8(0, vl)), mask_gt, vl);\n\n        vse8_v_i8m8(&out[i], vec_out, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_49_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t vl = vsetvl_e32m8(length);\n    vfloat32m8_t vec_A, vec_B, vec_epsilon;\n    vint8m8_t vec_out;\n    vbool4_t mask;\n\n    vec_epsilon = vfmv_v_f_f32m8(fabsf(epsilon), vl);\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        vec_A = vle32_v_f32m8(&A[i], vl);\n        vec_B = vle32_v_f32m8(&B[i], vl);\n\n        vfloat32m8_t diff = vfsub_vv_f32m8(vec_A, vec_B, vl);\n        vfloat32m8_t abs_diff = vfabs_v_f32m8(diff, vl);\n\n        mask = vmflt_vv_b4(abs_diff, vec_epsilon, vl);\n        vec_out = vmv_v_x_i8m8(0, vl);\n        vec_out = vcompress_vm_i8m8(vec_out, mask, vec_out, vl);\n\n        mask = vmfgt_vv_b4(diff, vec_epsilon, vl);\n        vec_out = vmerge_vvm_i8m8(vmv_v_x_i8m8(1, vl), vec_out, mask, vl);\n\n        mask = vmfle_vv_b4(diff, vfneg_v_f32m8(vec_epsilon, vl), vl);\n        vec_out = vmerge_vvm_i8m8(vmv_v_x_i8m8(-1, vl), vec_out, mask, vl);\n\n        vse8_v_i8m8(&out[i], vec_out, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_49_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t vl = vsetvl_e32m8(length);\n    vfloat32m8_t vec_A, vec_B, vec_epsilon;\n    vint8m8_t vec_out;\n    vbool4_t mask;\n\n    vec_epsilon = vfmv_v_f_f32m8(fabsf(epsilon), vl);\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        vec_A = vle32_v_f32m8(&A[i], vl);\n        vec_B = vle32_v_f32m8(&B[i], vl);\n\n        vfloat32m8_t diff = vfsub_vv_f32m8(vec_A, vec_B, vl);\n        vfloat32m8_t abs_diff = vfabs_v_f32m8(diff, vl);\n\n        mask = vmflt_vv_b4(abs_diff, vec_epsilon, vl);\n        vec_out = vmv_v_x_i8m8(-1, vl);\n        vec_out = vcompress_vm_i8m8(vec_out, mask, vec_out, vl);\n\n        mask = vmfgt_vv_b4(diff, vec_epsilon, vl);\n        vec_out = vcompress_vm_i8m8(vec_out, mask, vmv_v_x_i8m8(1, vl), vl);\n\n        vse8_v_i8m8(&out[i], vec_out, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_49_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t vl = vsetvl_e32m8(length);\n    vfloat32m8_t vA, vB, vEpsilon, vDiff, vAbsDiff, vAbsEpsilon;\n    vint8m8_t vResult;\n    vbool8_t vMask1, vMask2;\n\n    vEpsilon = vfmv_v_f_f32m8(epsilon, vl);\n    vAbsEpsilon = vfabs_v_f32m8(vEpsilon, vl);\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        vA = vle32_v_f32m8(&A[i], vl);\n        vB = vle32_v_f32m8(&B[i], vl);\n        vDiff = vfsub_vv_f32m8(vA, vB, vl);\n        vAbsDiff = vfabs_v_f32m8(vDiff, vl);\n\n        vMask1 = vfgt_vf_f32m8_b8(vDiff, vAbsEpsilon, vl);\n        vMask2 = vflt_vf_f32m8_b8(vDiff, vfneg_v_f32m8(vAbsEpsilon, vl), vl);\n\n        vResult = vmv_v_x_i8m8(0, vl);\n        vResult = vcompress_vm_i8m8(vResult, vfmv_v_f_i8m8(1, vl), vMask1, vl);\n        vResult = vcompress_vm_i8m8(vResult, vfmv_v_f_i8m8(-1, vl), vMask2, vl);\n\n        vse8_v_i8m8(&out[i], vResult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_49_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t vl = vsetvl_e32m8(length);\n    vfloat32m8_t vA, vB, vEpsilon, vDiff, vAbsDiff, vAbsEpsilon;\n    vint8m8_t vResult;\n    float abs_epsilon = fabsf(epsilon);\n\n    do {\n        vA = vle32_v_f32m8(A, vl);\n        vB = vle32_v_f32m8(B, vl);\n        vEpsilon = vfmv_v_f_f32m8(abs_epsilon, vl);\n        vDiff = vfsub_vv_f32m8(vA, vB, vl);\n        vAbsDiff = vfabs_v_f32m8(vDiff, vl);\n        vAbsEpsilon = vfmv_v_f_f32m8(abs_epsilon, vl);\n\n        vbool4_t mask_gt = vmfgt_vv_b4_f32m8(vDiff, vAbsEpsilon, vl);\n        vbool4_t mask_lt = vmlt_vv_b4_f32m8(vDiff, vfneg_v_f32m8(vAbsEpsilon, vl), vl);\n\n        vResult = vmerge_vvm_i8m8(vmerge_vvm_i8m8(vzext_vf_i8m8(mask_gt, vl), -1, mask_lt, vl), 0, vl);\n        vse8_v_i8m8(out, vResult, vl);\n\n        A += vl;\n        B += vl;\n        out += vl;\n    } while ((length -= vl) > 0);\n}\n```"}
{"task_id": "SimdBench_50_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <limits.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t vl;\n    vfloat32m8_t va;\n    vint32m8_t vb;\n    vint32m8_t vmax = vmv_v_x_i32m8(INT32_MAX, 8);\n    vint32m8_t vmin = vmv_v_x_i32m8(INT32_MIN, 8);\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n        va = vle32_v_f32m8(&A[i], vl);\n        vb = vfcvt_rtz_x_f_v_i32m8(va, vl);\n        vb = vmax_vv_i32m8(vb, vmin, vl);\n        vb = vmin_vv_i32m8(vb, vmax, vl);\n        vse32_v_i32m8(&B[i], vb, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_50_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <limits.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t vl;\n    const float32_t *a = A;\n    int32_t *b = B;\n\n    while (size > 0) {\n        vl = vsetvl_e32m8(size);\n        vfloat32m8_t va = vle32_v_f32m8(a, vl);\n        vint32m8_t vmin = vmv_v_x_i32m8(INT32_MIN, vl);\n        vint32m8_t vmax = vmv_v_x_i32m8(INT32_MAX, vl);\n        vint32m8_t vi = vfcvt_rtz_x_f_v_i32m8(va, vl);\n        vi = vmax_vv_i32m8(vmin, vi, vl);\n        vi = vmin_vv_i32m8(vi, vmax, vl);\n        vse32_v_i32m8(b, vi, vl);\n\n        a += vl;\n        b += vl;\n        size -= vl;\n    }\n}\n```"}
{"task_id": "SimdBench_50_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <limits.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t vl;\n    const float32_t *a = A;\n    int32_t *b = B;\n\n    do {\n        vl = vsetvl_e32m8(size);\n        vfloat32m8_t va = vle32_v_f32m8(a, vl);\n        vint32m8_t vmin = vmv_v_x_i32m8(INT32_MIN, vl);\n        vint32m8_t vmax = vmv_v_x_i32m8(INT32_MAX, vl);\n        vint32m8_t vi = vfcvt_rtz_x_f_v_i32m8(va, vl);\n        vi = vmax_vv_i32m8(vmin, vi, vl);\n        vi = vmin_vv_i32m8(vi, vmax, vl);\n        vse32_v_i32m8(b, vi, vl);\n        a += vl;\n        b += vl;\n        size -= vl;\n    } while (size > 0);\n}\n```"}
{"task_id": "SimdBench_50_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <limits.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t vl;\n    const float32_t *a = A;\n    int32_t *b = B;\n\n    do {\n        vl = vsetvl_e32m8(size);\n        vfloat32m8_t va = vle32_v_f32m8(a, vl);\n        vint32m8_t vi = vfncvt_x_f_w_i32m8(va, vl);\n        vbool32_t mask_max = vfmgt_vf_f32m8_b32(va, INT32_MAX, vl);\n        vbool32_t mask_min = vfmtle_vf_f32m8_b32(va, INT32_MIN, vl);\n        vi = vmerge_vvm_i32m8(vi, vmv_v_x_i32m8(INT32_MAX, vl), mask_max, vl);\n        vi = vmerge_vvm_i32m8(vi, vmv_v_x_i32m8(INT32_MIN, vl), mask_min, vl);\n        vse32_v_i32m8(b, vi, vl);\n        a += vl;\n        b += vl;\n        size -= vl;\n    } while (size > 0);\n}\n```"}
{"task_id": "SimdBench_50_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <limits.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t vl;\n    vfloat32m8_t va;\n    vint32m8_t vb;\n    vint32m8_t vmax = vmv_v_x_i32m8(INT32_MAX, 8);\n    vint32m8_t vmin = vmv_v_x_i32m8(INT32_MIN, 8);\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n        va = vle32_v_f32m8(&A[i], vl);\n        vb = vfcvt_rtz_x_f_v_i32m8(va, vl);\n        vb = vmax_vv_i32m8(vb, vmin, vl);\n        vb = vmin_vv_i32m8(vb, vmax, vl);\n        vse32_v_i32m8(&B[i], vb, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_51_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t vl;\n    vint32m4_t int_vec;\n    vfloat32m4_t float_vec;\n    float scale_factor = (float)scale;\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m4(size - i);\n        int_vec = vle32_v_i32m4(&A[i], vl);\n        float_vec = vfcvt_f_x_v_f32m4(int_vec, vl);\n        float_vec = vfmul_vf_f32m4(float_vec, scale_factor, vl);\n        vse32_v_f32m4(&B[i], float_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_51_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n        vint32m8_t va = vle32_v_i32m8(&A[i], vl);\n        vfloat32m8_t vf = vfcvt_f_x_v_f32m8(va, vl);\n        vfloat32m8_t vscaled = vfmul_vf_f32m8(vf, (float)scale, vl);\n        vse32_v_f32m8(&B[i], vscaled, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_51_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n        vint32m8_t va = vle32_v_i32m8(&A[i], vl);\n        vfloat32m8_t vf = vfcvt_f_x_v_f32m8(va, vl);\n        vfloat32m8_t vscaled = vfmul_vf_f32m8(vf, (float)scale, vl);\n        vse32_v_f32m8(&B[i], vscaled, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_51_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n        vint32m8_t va = vle32_v_i32m8(&A[i], vl);\n        vfloat32m8_t vf = vfcvt_f_x_v_f32m8(va, vl);\n        vfloat32m8_t vscaled = vfmul_vf_f32m8(vf, (float)scale, vl);\n        vse32_v_f32m8(&B[i], vscaled, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_51_RVV", "completion": "```c\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t vl = __riscv_vsetvl_e32m1(size);\n    vint32m1_t va = __riscv_vle32_v_i32m1(A, vl);\n    vfloat32m1_t vscaled = __riscv_vfmul_vf_f32m1(__riscv_vfcvt_f_x_v_f32m1(va, vl), (float)scale, vl);\n    __riscv_vse32_v_f32m1(B, vscaled, vl);\n}\n```"}
{"task_id": "SimdBench_52_RVV", "completion": "```c\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n        vfloat32m8_t va = vle32_v_f32m8(&A[i], vl);\n        vfloat32m8_t vb = vle32_v_f32m8(&B[i], vl);\n        vfloat32m8_t vresult = vfdiv_vv_f32m8(va, vb, vl);\n        vint32m8_t vrnd_result = vfcvt_rtz_x_f_v_i32m8(vresult, vl);\n        vse32_v_i32m8(&C[i], vrnd_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_52_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t vl = __riscv_vsetvl_e32m8(size);\n    vfloat32m8_t va, vb, vresult;\n    vint32m8_t vrresult;\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = __riscv_vsetvl_e32m8(size - i);\n        va = __riscv_vle32_v_f32m8(&A[i], vl);\n        vb = __riscv_vle32_v_f32m8(&B[i], vl);\n        vresult = __riscv_vfdiv_vv_f32m8(va, vb, vl);\n        vrresult = __riscv_vfcvt_rtz_x_f_v_i32m8(vresult, vl);\n        __riscv_vse32_v_i32m8(&C[i], vrresult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_52_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t vl = __riscv_vsetvl_e32m8(size);\n    vfloat32m8_t va, vb, vresult;\n    vint32m8_t vrresult;\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = __riscv_vsetvl_e32m8(size - i);\n        va = __riscv_vle32_v_f32m8(&A[i], vl);\n        vb = __riscv_vle32_v_f32m8(&B[i], vl);\n        vresult = __riscv_vfdiv_vv_f32m8(va, vb, vl);\n        vrresult = __riscv_vfcvt_rtz_x_f_v_i32m8(vresult, vl);\n        __riscv_vse32_v_i32m8(&C[i], vrresult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_52_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t vl = __riscv_vsetvl_e32m8(size);\n    vfloat32m8_t va, vb, vresult;\n    vint32m8_t vrresult;\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = __riscv_vsetvl_e32m8(size - i);\n        va = __riscv_vle32_v_f32m8(&A[i], vl);\n        vb = __riscv_vle32_v_f32m8(&B[i], vl);\n        vresult = __riscv_vfdiv_vv_f32m8(va, vb, vl);\n        vrresult = __riscv_vfcvt_rtz_x_f_v_i32m8(vresult, vl);\n        __riscv_vse32_v_i32m8(&C[i], vrresult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_52_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t vl = __riscv_vsetvl_e32m8(size);\n    vfloat32m8_t va, vb, vresult;\n    vint32m8_t vrresult;\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = __riscv_vsetvl_e32m8(size - i);\n        va = __riscv_vle32_v_f32m8(&A[i], vl);\n        vb = __riscv_vle32_v_f32m8(&B[i], vl);\n        vresult = __riscv_vfdiv_vv_f32m8(va, vb, vl);\n        vrresult = __riscv_vfcvt_rtz_x_f_v_i32m8(vresult, vl);\n        __riscv_vse32_v_i32m8(&C[i], vrresult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_53_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e64m8(size - i);\n        vfloat64m8_t va = vle64_v_f64m8(&A[i], vl);\n        vfloat32m4_t vmax = vfmv_v_f_f32m4(FLT_MAX, vl);\n        vfloat32m4_t vmin = vfmv_v_f_f32m4(-FLT_MAX, vl);\n        vfloat32m4_t vf = vfncvt_f_f_w_f32m4_f64m8(va, vl);\n        vbool4_t mask_max = vfgt_vf_f32m4_b4(vf, FLT_MAX, vl);\n        vbool4_t mask_min = vflt_vf_f32m4_b4(vf, -FLT_MAX, vl);\n        vf = vmerge_vvm_f32m4(vmax, vf, mask_max, vl);\n        vf = vmerge_vvm_f32m4(vmin, vf, mask_min, vl);\n        vse32_v_f32m4(&B[i], vf, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_53_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e64m8(size - i);\n        vfloat64m8_t va = vle64_v_f64m8(&A[i], vl);\n        vfloat32m4_t vmax = vfmv_v_f_f32m4(FLT_MAX, vl);\n        vfloat32m4_t vmin = vfmv_v_f_f32m4(-FLT_MAX, vl);\n        vfloat32m4_t vf = vfncvt_f_f_w_f32m4_f64m8(va, vl);\n        vbool4_t mask_max = vfgt_vf_f32m4_b4(vf, FLT_MAX, vl);\n        vbool4_t mask_min = vflt_vf_f32m4_b4(vf, -FLT_MAX, vl);\n        vf = vmerge_vvm_f32m4(vmax, vf, mask_max, vl);\n        vf = vmerge_vvm_f32m4(vmin, vf, mask_min, vl);\n        vse32_v_f32m4(&B[i], vf, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_53_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e64m8(size - i);\n        vfloat64m8_t va = vle64_v_f64m8(&A[i], vl);\n        vfloat32m4_t vmax = vfmv_v_f_f32m4(FLT_MAX, vl);\n        vfloat32m4_t vmin = vfmv_v_f_f32m4(-FLT_MAX, vl);\n        vfloat32m4_t vf = vfncvt_f_f_w_f32m4_f64m8(va, vl);\n        vbool4_t mask_max = vfgt_vf_f32m4_b4(vf, FLT_MAX, vl);\n        vbool4_t mask_min = vflt_vf_f32m4_b4(vf, -FLT_MAX, vl);\n        vf = vmerge_vvm_f32m4(vmax, vf, mask_max, vl);\n        vf = vmerge_vvm_f32m4(vmin, vf, mask_min, vl);\n        vse32_v_f32m4(&B[i], vf, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_53_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e64m8(size - i);\n        vfloat64m8_t va = vle64_v_f64m8(&A[i], vl);\n        vfloat32m4_t vmax = vfmv_v_f_f32m4(FLT_MAX, vl);\n        vfloat32m4_t vmin = vfmv_v_f_f32m4(-FLT_MAX, vl);\n        vfloat32m4_t vf = vfncvt_f_f_w_f32m4_f64m8(va, vl);\n        vbool4_t mask_max = vfgt_vf_f32m4_b4(vf, FLT_MAX, vl);\n        vbool4_t mask_min = vflt_vf_f32m4_b4(vf, -FLT_MAX, vl);\n        vf = vmerge_vvm_f32m4(vmax, vf, mask_max, vl);\n        vf = vmerge_vvm_f32m4(vmin, vf, mask_min, vl);\n        vse32_v_f32m4(&B[i], vf, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_53_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e64m8(size - i);\n        vfloat64m8_t va = vle64_v_f64m8(&A[i], vl);\n        vfloat32m4_t vmax = vfmv_v_f_f32m4(FLT_MAX, vl);\n        vfloat32m4_t vmin = vfmv_v_f_f32m4(-FLT_MAX, vl);\n        vfloat32m4_t vf = vfncvt_f_f_w_f32m4_f64m8(va, vl);\n        vbool4_t mask_max = vfgt_vf_f32m4_b4(vf, FLT_MAX, vl);\n        vbool4_t mask_min = vflt_vf_f32m4_b4(vf, -FLT_MAX, vl);\n        vf = vmerge_vvm_f32m4(vmax, vf, mask_max, vl);\n        vf = vmerge_vvm_f32m4(vmin, vf, mask_min, vl);\n        vse32_v_f32m4(&B[i], vf, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_54_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e16m8(size - i);\n        vint16m8_t va = vle16_v_i16m8(&A[i], vl);\n        vse32_v_i32m8(&B[i], vwcvt_x_x_s_e32m8_i16m8(va, vl), vl);\n    }\n}\n```"}
{"task_id": "SimdBench_54_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e16m8(size - i);\n        vint16m8_t va = vle16_v_i16m8(&A[i], vl);\n        vse32_v_i32m8(&B[i], vwcvt_x_x_s_e32m8_i16m8(va, vl), vl);\n    }\n}\n```"}
{"task_id": "SimdBench_54_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e16m8(size - i);\n        vint16m8_t va = vle16_v_i16m8(&A[i], vl);\n        vse32_v_i32m8(&B[i], vwcvt_x_x_s_e32m8_i16m8(va, vl), vl);\n    }\n}\n```"}
{"task_id": "SimdBench_54_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e16m8(size - i);\n        vint16m8_t va = vle16_v_i16m8(&A[i], vl);\n        vse32_v_i32m8(&B[i], vwcvt_x_x_s_e32m8_i16m8(va, vl), vl);\n    }\n}\n```"}
{"task_id": "SimdBench_54_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e16m8(size - i);\n        vint16m8_t va = vle16_v_i16m8(&A[i], vl);\n        vse32_v_i32m8(&B[i], vwcvt_x_x_s_e32m8_i16m8(va, vl), vl);\n    }\n}\n```"}
{"task_id": "SimdBench_55_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    size_t i = 0;\n    float scale = 1.0f / (max_val - min_val);\n\n    for (; i <= size - VLMAX_F32; i += VLMAX_F32) {\n        vfloat32m1_t va = vle32_v_f32m1(&A[i], VLMAX_F32);\n        vint32m1_t vcontrol = vle32_v_i32m1(&control[i], VLMAX_F32);\n\n        vbool4_t mask = vmgt_vx_i32m1_b4(vcontrol, 0, VLMAX_F32);\n\n        vfloat32m1_t vnormalized = vfsub_vf_f32m1(va, min_val, VLMAX_F32);\n        vnormalized = vfmul_vf_f32m1(vnormalized, scale, VLMAX_F32);\n        vnormalized = vmax_vf_f32m1(vnormalized, 0.0f, VLMAX_F32);\n        vnormalized = vmin_vf_f32m1(vnormalized, 1.0f, VLMAX_F32);\n\n        vfloat32m1_t vresult = vmerge_vvm_f32m1(va, vnormalized, mask, VLMAX_F32);\n\n        vse32_v_f32m1(&B[i], vresult, VLMAX_F32);\n    }\n\n    for (; i < size; i++) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) * scale;\n            B[i] = val < 0.0f ? 0.0f : (val > 1.0f ? 1.0f : val);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    size_t vl = __riscv_vsetvl_e32m8(size);\n    vfloat32m8_t v_min = __riscv_vfmv_v_f_f32m8(min_val, vl);\n    vfloat32m8_t v_max = __riscv_vfmv_v_f_f32m8(max_val, vl);\n    vfloat32m8_t v_one = __riscv_vfmv_v_f_f32m8(1.0f, vl);\n    vfloat32m8_t v_zero = __riscv_vfmv_v_f_f32m8(0.0f, vl);\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = __riscv_vsetvl_e32m8(size - i);\n        vfloat32m8_t v_a = __riscv_vle32_v_f32m8(A + i, vl);\n        vint32m8_t v_control = __riscv_vle32_v_i32m8(control + i, vl);\n\n        vbool8_t mask = __riscv_vmslt_vx_i32m8_b8(v_control, 1, vl);\n        vfloat32m8_t v_normalized = __riscv_vfsub_vv_f32m8(v_a, v_min, vl);\n        v_normalized = __riscv_vfdiv_vv_f32m8(v_normalized, __riscv_vfsub_vv_f32m8(v_max, v_min, vl), vl);\n        v_normalized = __riscv_vfmax_vv_f32m8(v_normalized, v_zero, vl);\n        v_normalized = __riscv_vfmin_vv_f32m8(v_normalized, v_one, vl);\n\n        vfloat32m8_t v_result = __riscv_vmerge_vvm_f32m8(v_a, v_normalized, mask, vl);\n        __riscv_vse32_v_f32m8(B + i, v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_55_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    size_t vl = __riscv_vsetvl_e32m8(size);\n    vfloat32m8_t v_min = __riscv_vfmv_v_f_f32m8(min_val, vl);\n    vfloat32m8_t v_max = __riscv_vfmv_v_f_f32m8(max_val, vl);\n    vfloat32m8_t v_one = __riscv_vfmv_v_f_f32m8(1.0f, vl);\n    vfloat32m8_t v_zero = __riscv_vfmv_v_f_f32m8(0.0f, vl);\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = __riscv_vsetvl_e32m8(size - i);\n        vfloat32m8_t va = __riscv_vle32_v_f32m8(&A[i], vl);\n        vint32m8_t vcontrol = __riscv_vle32_v_i32m8(&control[i], vl);\n\n        vbool4_t mask = __riscv_vmslt_vx_i32m8_b4(vcontrol, 1, vl);\n        vfloat32m8_t vnormalized = __riscv_vfsub_vv_f32m8(va, v_min, vl);\n        vfloat32m8_t vrange = __riscv_vfsub_vv_f32m8(v_max, v_min, vl);\n        vfloat32m8_t vresult = __riscv_vfdiv_vv_f32m8(vnormalized, vrange, vl);\n        vresult = __riscv_vfmax_vv_f32m8(vresult, vzero, vl);\n        vresult = __riscv_vfmin_vv_f32m8(vresult, vone, vl);\n\n        vfloat32m8_t voutput = __riscv_vmerge_vvm_f32m8(vresult, va, mask, vl);\n        __riscv_vse32_v_f32m8(&B[i], voutput, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_55_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    size_t vl;\n    float32_t min_vec = vfmv_f_s_f32m1(min_val, 8);\n    float32_t max_vec = vfmv_f_s_f32m1(max_val, 8);\n    float32_t zero_vec = vfmv_f_s_f32m1(0.0f, 8);\n    float32_t one_vec = vfmv_f_s_f32m1(1.0f, 8);\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n\n        vfloat32m1_t a_vec = vle32_v_f32m1(&A[i], vl);\n        vint32m1_t control_vec = vle32_v_i32m1(&control[i], vl);\n\n        vbool4_t mask = vmgt_vx_i32m1_b4(control_vec, 0, vl);\n\n        vfloat32m1_t norm_vec = vfsub_vv_f32m1(a_vec, min_vec, vl);\n        norm_vec = vfdiv_vv_f32m1(norm_vec, vfsub_vv_f32m1(max_vec, min_vec, vl), vl);\n        norm_vec = vmax_vv_f32m1(norm_vec, zero_vec, vl);\n        norm_vec = vmin_vv_f32m1(norm_vec, one_vec, vl);\n\n        vfloat32m1_t result_vec = vmerge_vvm_f32m1(vfsgather_vv_f32m1(a_vec, mask, vl), norm_vec, mask, vl);\n\n        vse32_v_f32m1(&B[i], result_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_55_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    size_t i = 0;\n    float scale = 1.0f / (max_val - min_val);\n\n    for (; i <= size - VLMAX_F32; i += VLMAX_F32) {\n        vfloat32m8_t va = vle32_v_f32m8(&A[i], size - i);\n        vint32m8_t vcontrol = vle32_v_i32m8(&control[i], size - i);\n        vbool8_t mask = vmgt_vx_i32m8_b8(vcontrol, 0, size - i);\n\n        vfloat32m8_t vnormalized = vfsub_vf_f32m8(va, min_val, size - i);\n        vnormalized = vfmul_vf_f32m8(vnormalized, scale, size - i);\n        vnormalized = vmax_vf_f32m8(vnormalized, 0.0f, size - i);\n        vnormalized = vmin_vf_f32m8(vnormalized, 1.0f, size - i);\n\n        vfloat32m8_t vresult = vmerge_vvm_f32m8(va, vnormalized, mask, size - i);\n        vse32_v_f32m8(&B[i], vresult, size - i);\n    }\n\n    for (; i < size; i++) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) * scale;\n            B[i] = val < 0.0f ? 0.0f : (val > 1.0f ? 1.0f : val);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_56_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl = __riscv_vsetvl_e32m8(size);\n    vuint32m8_t vec_A = __riscv_vle32_v_u32m8(A, vl);\n    vuint16mf4_t high_16_bits = __riscv_vsrl_vx_u16mf4(__riscv_vreinterpret_v_u16mf4_u32m8(vec_A), 16, vl);\n    vfloat32mf2_t vec_B = __riscv_vfcvt_f_x_v_f32mf2(high_16_bits, vl);\n    vec_B = __riscv_vfsqrt_v_f32mf2(vec_B, vl);\n    __riscv_vse32_v_f32mf2(B, vec_B, vl);\n}\n```"}
{"task_id": "SimdBench_56_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl = __riscv_vsetvl_e32m8(size);\n    vuint32m8_t vec_A = __riscv_vle32_v_u32m8(A, vl);\n    vuint16mf4_t high_16_bits = __riscv_vsrl_vx_u16mf4(__riscv_vreinterpret_v_u16mf4_u32m8(vec_A), 16, vl);\n    vfloat32mf2_t vec_B = __riscv_vfcvt_f_x_v_f32mf2(high_16_bits, vl);\n    vec_B = __riscv_vfsqrt_v_f32mf2(vec_B, vl);\n    __riscv_vse32_v_f32mf2(B, vec_B, vl);\n}\n```"}
{"task_id": "SimdBench_56_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl = __riscv_vsetvl_e32m8(size);\n    vuint32m8_t vec_A = __riscv_vle32_v_u32m8(A, vl);\n    vuint16mf4_t high_16_bits = __riscv_vsrl_vx_u16mf4(__riscv_vreinterpret_v_u16mf4_u32m8(vec_A), 16, vl);\n    vfloat32mf2_t vec_B = __riscv_vfcvt_f_x_v_f32mf2(high_16_bits, vl);\n    vec_B = __riscv_vfsqrt_v_f32mf2(vec_B, vl);\n    __riscv_vse32_v_f32mf2(B, vec_B, vl);\n}\n```"}
{"task_id": "SimdBench_56_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl = __riscv_vsetvl_e32m8(size);\n    vuint32m8_t vec_A = __riscv_vle32_v_u32m8(A, vl);\n    vuint16mf4_t high_16_bits = __riscv_vsrl_vx_u16mf4(__riscv_vreinterpret_v_u16mf4_u32m8(vec_A), 16, vl);\n    vfloat32mf2_t vec_B = __riscv_vfcvt_f_x_v_f32mf2(high_16_bits, vl);\n    vec_B = __riscv_vfsqrt_v_f32mf2(vec_B, vl);\n    __riscv_vse32_v_f32mf2(B, vec_B, vl);\n}\n```"}
{"task_id": "SimdBench_56_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl = __riscv_vsetvl_e32m8(size);\n    vuint32m8_t vec_A = __riscv_vle32_v_u32m8(A, vl);\n    vuint16mf4_t high_16_bits = __riscv_vsrl_vx_u16mf4(__riscv_vreinterpret_v_u16mf4_u32m8(vec_A), 16, vl);\n    vfloat32mf2_t vec_B = __riscv_vfcvt_f_x_v_f32mf2(high_16_bits, vl);\n    vec_B = __riscv_vfsqrt_v_f32mf2(vec_B, vl);\n    __riscv_vse32_v_f32mf2(B, vec_B, vl);\n}\n```"}
{"task_id": "SimdBench_57_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n        vuint32m8_t int_vec = vle32_v_u32m8(&A[i], vl);\n        vfloat32m8_t float_vec = vreinterpret_v_u32m8_f32m8(int_vec);\n        vse32_v_f32m8(&B[i], float_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_57_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n        vuint32m8_t int_vec = vle32_v_u32m8(&A[i], vl);\n        vfloat32m8_t float_vec = vreinterpret_v_u32m8_f32m8(int_vec);\n        vse32_v_f32m8(&B[i], float_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_57_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n        vuint32m8_t int_vec = vle32_v_u32m8(&A[i], vl);\n        vfloat32m8_t float_vec = vreinterpret_v_u32m8_f32m8(int_vec);\n        vse32_v_f32m8(&B[i], float_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_57_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n        vuint32m8_t int_vec = vle32_v_u32m8(&A[i], vl);\n        vfloat32m8_t float_vec = vreinterpret_v_u32m8_f32m8(int_vec);\n        vse32_v_f32m8(&B[i], float_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_57_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n        vuint32m8_t int_vec = vle32_v_u32m8(&A[i], vl);\n        vfloat32m8_t float_vec = vreinterpret_v_u32m8_f32m8(int_vec);\n        vse32_v_f32m8(&B[i], float_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_58_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    size_t vl = vsetvl_e32m8(size);\n    vbool8_t mask = vmf_m_b8(vl);\n    vint32m8_t va = vle32_v_i32m8(A, vl);\n    vfloat32m8_t vzero = vfmv_v_f_f32m8(0.0f, vl);\n\n    diff[0] = 0.0f;\n\n    for (size_t i = 1; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n        vint32m8_t va_prev = va;\n        va = vle32_v_i32m8(&A[i], vl);\n        vint32m8_t vdiff = vsub_vv_i32m8(va, va_prev, vl);\n        vfloat32m8_t vdiff_f = vfcvt_f_x_v_f32m8_i32m8(vdiff, vl);\n        mask = vmseq_m_b8(vmule_vx_u8m1(&cond[i], 1, vl), 1, vl);\n        vse32_v_mask_i32m8((int32_t*)&diff[i], vmerge_vvm_f32m8(vzero, vdiff_f, mask, vl), mask, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_58_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    size_t i = 0;\n    size_t vl = vsetvl_e32m8(size);\n\n    // Initialize diff[0] to 0.0f\n    diff[0] = 0.0f;\n\n    for (; i + vl <= size; i += vl) {\n        vint32m8_t va = vle32_v_i32m8(&A[i], vl);\n        vint32m8_t vprev_a = vslideup_vx_i32m8(va, A[i - 1], vl);\n        vint32m8_t vdiff = vsub_vv_i32m8(va, vprev_a, vl);\n        vbool8_t vcond = vmseq_vx_u8m8(vreinterpret_v_u8m8_b8mf8(vle8_v_b8mf8(&cond[i], vl)), 1, vl);\n        vfloat32m8_t vfdiff = vfcvt_f_x_v_f32m8(vdiff, vl);\n        vfloat32m8_t vresult = vmerge_vvm_f32m8(vfmul_vf_f32m8(vfdiff, 0.0f, vl), vfdiff, vcond, vl);\n        vse32_v_f32m8(&diff[i], vresult, vl);\n    }\n\n    // Handle the remaining elements\n    if (i < size) {\n        vl = vsetvl_e32m8(size - i);\n        vint32m8_t va = vle32_v_i32m8(&A[i], vl);\n        vint32m8_t vprev_a = vslideup_vx_i32m8(va, A[i - 1], vl);\n        vint32m8_t vdiff = vsub_vv_i32m8(va, vprev_a, vl);\n        vbool8_t vcond = vmseq_vx_u8m8(vreinterpret_v_u8m8_b8mf8(vle8_v_b8mf8(&cond[i], vl)), 1, vl);\n        vfloat32m8_t vfdiff = vfcvt_f_x_v_f32m8(vdiff, vl);\n        vfloat32m8_t vresult = vmerge_vvm_f32m8(vfmul_vf_f32m8(vfdiff, 0.0f, vl), vfdiff, vcond, vl);\n        vse32_v_f32m8(&diff[i], vresult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_58_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    size_t vl = vsetvl_e32m8(size);\n    vint32m8_t va = vle32_v_i32m8(A, vl);\n    vbool8_t vcond = vmseq_vx_u8m8(vreinterpret_v_u32m8_i32m8(va), 0, vl);\n    vfloat32m8_t vzero = vfmv_v_f_f32m8(0.0f, vl);\n\n    for (size_t i = 1; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n        vint32m8_t va_curr = vle32_v_i32m8(&A[i], vl);\n        vint32m8_t va_prev = vle32_v_i32m8(&A[i - 1], vl);\n        vint32m8_t vdiff = vsub_vv_i32m8(va_curr, va_prev, vl);\n        vfloat32m8_t vdiff_float = vfcvt_f_x_v_f32m8(vdiff, vl);\n        vbool8_t vcond_curr = vle8_v_b8m8(&cond[i], vl);\n        vfloat32m8_t vresult = vmerge_vvm_f32m8(vdiff_float, vzero, vcond_curr, vl);\n        vse32_v_f32m8(&diff[i], vresult, vl);\n    }\n\n    diff[0] = 0.0f;\n}\n```"}
{"task_id": "SimdBench_58_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    size_t vl = vsetvl_e32m8(size);\n    vbool8_t mask = vmf_m_b8(vl);\n    vint32m8_t va = vle32_v_i32m8(A, vl);\n    vfloat32m8_t vzero = vfmv_v_f_f32m8(0.0f, vl);\n\n    diff[0] = 0.0f;\n\n    for (size_t i = 1; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n        vint32m8_t va_prev = va;\n        va = vle32_v_i32m8(&A[i], vl);\n        vint32m8_t vdiff = vsub_vv_i32m8(va, va_prev, vl);\n        vfloat32m8_t vdiff_f = vfcvt_f_x_v_f32m8_i32m8(vdiff, vl);\n        mask = vmseq_m_b8_b8(vmule_vx_u8m1(vle8_v_u8mf8((const uint8_t*)&cond[i], vl), 1, vl), 1, vl);\n        vse32_v_i32m8((int32_t*)&diff[i], vfmerge_vfm_f32m8(vdiff_f, vzero, mask, vl), vl);\n    }\n}\n```"}
{"task_id": "SimdBench_58_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    size_t vl = vsetvl_e32m8(size);\n    vbool8_t mask = vmf_m_b8(vl);\n    vint32m8_t va = vle32_v_i32m8(A, vl);\n    vfloat32m8_t vzero = vfmv_v_f_f32m8(0.0f, vl);\n\n    diff[0] = 0.0f;\n\n    for (size_t i = 1; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n        vint32m8_t va_prev = va;\n        va = vle32_v_i32m8(&A[i], vl);\n        vint32m8_t vdiff = vsub_vv_i32m8(va, va_prev, vl);\n        vfloat32m8_t vdiff_float = vfcvt_f_x_v_f32m8_i32m8(vdiff, vl);\n        mask = vmseq_m_b8(vmule_vx_u8m1(cond + i, 1, vl), 1, vl);\n        vse32_v_mask_i32m8((int32_t*)&diff[i], vmerge_vvm_f32m8(vdiff_float, vzero, mask, vl), mask, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_59_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        vuint32m8_t src_vec = vle32_v_u32m8(&src[i], vl);\n        vuint64m4_t dst_vec = vsext_vf2_u64m4(src_vec, vl);\n        dst_vec = vor_vx_u64m4(dst_vec, 0xFFFFFFFF00000000ULL, vl);\n        vse64_v_u64m4(&dst[i], dst_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_59_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        vuint32m8_t src_vec = vle32_v_u32m8(&src[i], vl);\n        vuint64m4_t dst_vec = vsext_vf2_u64m4(src_vec, vl);\n        dst_vec = vor_vx_u64m4(dst_vec, 0xFFFFFFFF00000000ULL, vl);\n        vse64_v_u64m4(&dst[i], dst_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_59_RVV", "completion": "```c\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        vuint32m8_t src_vec = vle32_v_u32m8(&src[i], vl);\n        vuint64m4_t dst_vec = vsext_vf2_u64m4(src_vec, vl);\n        vuint64m4_t ones = vmv_v_x_u64m4(UINT64_C(0xFFFFFFFF00000000), vl);\n        dst_vec = vor_vv_u64m4(dst_vec, ones, vl);\n        vse64_v_u64m4(&dst[i], dst_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_59_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        vuint32m8_t src_vec = vle32_v_u32m8(&src[i], vl);\n        vuint64m4_t dst_vec = vsext_vf2_u64m4(src_vec, vl);\n        vuint64m4_t ones = vmv_v_x_u64m4(UINT64_C(0xFFFFFFFF00000000), vl);\n        dst_vec = vor_vv_u64m4(dst_vec, ones, vl);\n        vse64_v_u64m4(&dst[i], dst_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_59_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        vuint32m8_t src_v = vle32_v_u32m8(&src[i], vl);\n        vuint64m4_t dst_v = vsext_vf2_u64m4(src_v, vl);\n        vuint64m4_t ones = vmv_v_x_u64m4(UINT64_C(0xFFFFFFFF00000000), vl);\n        dst_v = vor_vv_u64m4(dst_v, ones, vl);\n        vse64_v_u64m4(&dst[i], dst_v, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_60_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double result = 0.0;\n    size_t vlmax = vsetvl_e64m1(length);\n    vfloat64m1_t sum = vfmv_v_f_f64m1(0.0, vlmax);\n\n    for (size_t i = 0; i < length; i += vlmax) {\n        size_t vl = vsetvl_e16m1(vlmax);\n        vint16m1_t idx_vec = vle16_v_i16m1(&index[i], vl);\n        vfloat64m1_t selected_vec = vrgather_vv_f64m1(vec, idx_vec, vl);\n        sum = vfadd_vv_f64m1(sum, selected_vec, vl);\n    }\n\n    result = vfredsum_vs_f64m1_f64m1(sum, vfmv_s_f_f64m1(0.0, vlmax), vlmax);\n    return result;\n}\n```"}
{"task_id": "SimdBench_60_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double result = 0.0;\n    size_t vl;\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m8(length - i);\n        vfloat64m8_t vsum = vfmv_v_f_f64m8(0.0, vl);\n        vint16m8_t vindex = vle16_v_i16m8(&index[i], vl);\n\n        for (size_t j = 0; j < vl; ++j) {\n            size_t idx = vindex[j];\n            if (idx >= 0 && idx < length) {\n                vfloat64m8_t vtemp = vle64_v_f64m8(&vec[idx], 1);\n                vsum = vfadd_vv_f64m8(vsum, vtemp, vl);\n            }\n        }\n\n        double temp_result[8];\n        vse64_v_f64m8(temp_result, vsum, vl);\n        for (size_t j = 0; j < vl; ++j) {\n            result += temp_result[j];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_60_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double result = 0.0;\n    size_t vl;\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m8(length - i);\n        vfloat64m8_t vsum = vfmv_v_f_f64m8(0.0, vl);\n        vint16m8_t vindex = vle16_v_i16m8(&index[i], vl);\n\n        for (size_t j = 0; j < vl; ++j) {\n            size_t idx = vindex[j];\n            if (idx >= 0 && idx < length) {\n                vfloat64m8_t vtemp = vle64_v_f64m8(&vec[idx], 1);\n                vsum = vfadd_vv_f64m8(vsum, vtemp, vl);\n            }\n        }\n\n        double temp_result[8];\n        vse64_v_f64m8(temp_result, vsum, vl);\n        for (size_t j = 0; j < vl; ++j) {\n            result += temp_result[j];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_60_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double result = 0.0;\n    size_t vlmax = vsetvl_e64m1(length);\n    vfloat64m1_t sum = vfmv_v_f_f64m1(0.0, vlmax);\n\n    for (size_t i = 0; i < length; i += vlmax) {\n        size_t vl = vsetvl_e16m1(vlmax);\n        vint16m1_t idx_vec = vle16_v_i16m1(&index[i], vl);\n        vfloat64m1_t vec_vec = vlgather_vv_f64m1(vec, idx_vec, vl);\n        sum = vfadd_vv_f64m1(sum, vec_vec, vl);\n    }\n\n    result = vfredsum_vs_f64m1_f64m1(sum, vfmv_s_f_f64m1(0.0, vlmax), vlmax);\n    return result;\n}\n```"}
{"task_id": "SimdBench_60_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double result = 0.0;\n    size_t vlmax = vsetvl_e64m1(length);\n    vfloat64m1_t sum = vfmv_v_f_f64m1(0.0, vlmax);\n\n    for (size_t i = 0; i < length; i += vlmax) {\n        size_t vl = vsetvl_e16m1(vlmax);\n        vint16m1_t idx = vle16_v_i16m1(&index[i], vl);\n        vfloat64m1_t selected = vrgather_vv_f64m1(vec, idx, vl);\n        sum = vfadd_vv_f64m1(sum, selected, vl);\n    }\n\n    for (size_t i = 0; i < vlmax; ++i) {\n        result += vget_f64m1_i64mf2(sum, i);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_61_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    size_t ksq = kernel_size * kernel_size;\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    size_t in_idx = (i + ki) * input_size + (j + kj);\n                    size_t ker_idx = ki * kernel_size + kj;\n                    sum += input[in_idx] * kernel[ker_idx];\n                }\n            }\n            output[i * output_size + j] = fmax(0.0, sum);\n        }\n    }\n\n    // RVV SIMD implementation\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            size_t l = 0;\n            for (; l <= ksq - VL_MAX_D; l += VL_MAX_D) {\n                vfloat64m1_t vin = vle64_v_f64m1(&input[(i * input_size + j) * ksq + l], VL_MAX_D);\n                vfloat64m1_t vker = vle64_v_f64m1(&kernel[l], VL_MAX_D);\n                vfloat64m1_t vmul = vfmul_vv_f64m1(vin, vker, VL_MAX_D);\n                sum += vredsum_vs_f64m1_f64(vmul, 0.0, VL_MAX_D);\n            }\n            for (; l < ksq; ++l) {\n                sum += input[(i * input_size + j) * ksq + l] * kernel[l];\n            }\n            output[i * output_size + j] = fmax(0.0, sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    size_t ksq = kernel_size * kernel_size;\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    size_t in_idx = (i + ki) * input_size + (j + kj);\n                    size_t ker_idx = ki * kernel_size + kj;\n                    sum += input[in_idx] * kernel[ker_idx];\n                }\n            }\n            vfloat64m1_t v_sum = vfmv_s_f_f64m1(sum, 1);\n            vfloat64m1_t v_relu = vfmax_vf_f64m1(v_sum, 0.0, 1);\n            output[i * output_size + j] = vfmv_f_s_f64m1_f64(v_relu);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    size_t kernel_area = kernel_size * kernel_size;\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t m = 0; m < kernel_size; ++m) {\n                for (size_t n = 0; n < kernel_size; ++n) {\n                    size_t input_idx = (i + m) * input_size + (j + n);\n                    size_t kernel_idx = m * kernel_size + n;\n\n                    vfloat64m8_t v_input = vle64_v_f64m8(&input[input_idx], VLMAX_e64m8);\n                    vfloat64m8_t v_kernel = vle64_v_f64m8(&kernel[kernel_idx], VLMAX_e64m8);\n                    vfloat64m8_t v_prod = vfmul_vv_f64m8(v_input, v_kernel, VLMAX_e64m8);\n                    sum += vredsum_vs_f64m8_f64(v_prod, 0.0, VLMAX_e64m8);\n                }\n            }\n            output[i * output_size + j] = sum > 0.0 ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    size_t ksq = kernel_size * kernel_size;\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    size_t input_idx = (i + ki) * input_size + (j + kj);\n                    size_t kernel_idx = ki * kernel_size + kj;\n                    sum += input[input_idx] * kernel[kernel_idx];\n                }\n            }\n            // Use RVV to apply ReLU activation\n            vfloat64m1_t v_sum = vle64_v_f64m1(&sum, 1);\n            vfloat64m1_t v_zero = vfmv_v_f_f64m1(0.0, 1);\n            vbool8_t vmask = vfmgt_vf_f64m1_b8(v_sum, 0.0, 1);\n            v_sum = vmerge_vvm_f64m1(v_zero, v_sum, vmask, 1);\n            vse64_v_f64m1(&output[i * output_size + j], v_sum, 1);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    size_t ksq = kernel_size * kernel_size;\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    size_t in_idx = (i + ki) * input_size + (j + kj);\n                    size_t ker_idx = ki * kernel_size + kj;\n                    sum += input[in_idx] * kernel[ker_idx];\n                }\n            }\n            output[i * output_size + j] = fmax(0.0, sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_62_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n < 2) return false;\n\n    vfloat64m1_t v_threshold = vfmv_v_f_f64m1(threshold, 1);\n    for (size_t i = 0; i < n; ++i) {\n        vfloat64m1_t v_num_i = vfmv_v_f_f64m1(numbers[i], 1);\n        for (size_t j = i + 1; j < n; j += vsetvl_e64m1(n - j)) {\n            size_t vl = vsetvl_e64m1(n - j);\n            vfloat64m1_t v_num_j = vle64_v_f64m1(&numbers[j], vl);\n            vfloat64m1_t v_diff = vfsub_vv_f64m1(v_num_i, v_num_j, vl);\n            vfloat64m1_t v_abs_diff = vfabs_v_f64m1(v_diff, vl);\n            vbool64_t v_mask = vmflt_vv_b64(v_abs_diff, v_threshold, vl);\n            if (vmfirst_m_b64(v_mask, vl)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n < 2) return false;\n\n    vfloat64m1_t v_threshold = vfmv_v_f_f64m1(threshold, 1);\n    for (size_t i = 0; i < n; ++i) {\n        vfloat64m1_t v_num_i = vfmv_v_f_f64m1(numbers[i], 1);\n        for (size_t j = i + 1; j < n; j += vsetvl_e64m1(n - j)) {\n            size_t vl = vsetvl_e64m1(n - j);\n            vfloat64m1_t v_num_j = vle64_v_f64m1(&numbers[j], vl);\n            vfloat64m1_t v_diff = vfsub_vv_f64m1(v_num_i, v_num_j, vl);\n            vfloat64m1_t v_abs_diff = vfabs_v_f64m1(v_diff, vl);\n            vbool64_t vm = vmflt_vv_b64(v_abs_diff, v_threshold, vl);\n            if (vmfirst_m_b64(vm)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n < 2) return false;\n\n    vfloat64m1_t v_threshold = vfmv_v_f_f64m1(threshold, 1);\n    for (size_t i = 0; i < n; ++i) {\n        vfloat64m1_t v_num_i = vfmv_v_f_f64m1(numbers[i], 1);\n        for (size_t j = i + 1; j < n; j += vsetvl_e64m1(n - j)) {\n            size_t vl = vsetvl_e64m1(n - j);\n            vfloat64m1_t v_num_j = vle64_v_f64m1(&numbers[j], vl);\n            vfloat64m1_t v_diff = vfsub_vv_f64m1(v_num_i, v_num_j, vl);\n            vfloat64m1_t v_abs_diff = vfabs_v_f64m1(v_diff, vl);\n            vbool64_t vm = vmflt_vv_b64(v_abs_diff, v_threshold, vl);\n            if (vmfirst_m_b64(vm)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n < 2) return false;\n\n    vfloat64m1_t v_threshold = vfmv_v_f_f64m1(threshold, 1);\n    for (size_t i = 0; i < n; ++i) {\n        vfloat64m1_t v_num_i = vfmv_v_f_f64m1(numbers[i], 1);\n        for (size_t j = i + 1; j < n; j += vsetvl_e64m1(n - j)) {\n            size_t vl = vsetvl_e64m1(n - j);\n            vfloat64m1_t v_num_j = vle64_v_f64m1(&numbers[j], vl);\n            vfloat64m1_t v_diff = vfsub_vv_f64m1(v_num_i, v_num_j, vl);\n            vfloat64m1_t v_abs_diff = vfabs_v_f64m1(v_diff, vl);\n            vbool64_t vm = vmflt_vv_b64(v_abs_diff, v_threshold, vl);\n            if (vmfirst_m_b64(vm)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n < 2) return false;\n\n    vfloat64m1_t v_threshold = vfmv_v_f_f64m1(threshold, 1);\n    for (size_t i = 0; i < n; ++i) {\n        vfloat64m1_t v_num_i = vfmv_v_f_f64m1(numbers[i], 1);\n        for (size_t j = i + 1; j < n; j += vsetvl_e64m1(n - j)) {\n            size_t vl = vsetvl_e64m1(n - j);\n            vfloat64m1_t v_num_j = vle64_v_f64m1(&numbers[j], vl);\n            vfloat64m1_t v_diff = vfsub_vv_f64m1(v_num_i, v_num_j, vl);\n            vfloat64m1_t v_abs_diff = vfabs_v_f64m1(v_diff, vl);\n            vbool64_t v_mask = vmflt_vv_b64(v_abs_diff, v_threshold, vl);\n            if (vmfirst_m_b64(v_mask, vl)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    size_t n = operations.size();\n    int balance = 0;\n    size_t vl;\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m8(n - i);\n        vint32m8_t op_v = vle32_v_i32m8(&operations[i], vl);\n        vint32m8_t balance_v = vmv_v_x_i32m8(balance, vl);\n        vint32m8_t new_balance_v = vadd_vv_i32m8(op_v, balance_v, vl);\n        vbool4_t mask = vmslt_vx_i32m8_b4(new_balance_v, 0, vl);\n\n        if (vm_first_m_b4(mask, vl)) {\n            return true;\n        }\n\n        balance = vmv_x_s_i32m8_i32(new_balance_v, vl);\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    size_t n = operations.size();\n    int balance = 0;\n    size_t vl;\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m8(n - i);\n        vint32m8_t op_v = vle32_v_i32m8(&operations[i], vl);\n        vint32m8_t balance_v = vmv_v_x_i32m8(balance, vl);\n        vint32m8_t new_balance_v = vadd_vv_i32m8(op_v, balance_v, vl);\n        vbool4_t mask = vmslt_vx_i32m8_b4(new_balance_v, 0, vl);\n\n        if (vm_first_m_b4(mask, vl)) {\n            return true;\n        }\n\n        balance = vmv_x_s_i32m8_i32(new_balance_v, vl);\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    size_t n = operations.size();\n    int balance = 0;\n    size_t vl;\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m8(n - i);\n        vint32m8_t op_v = vle32_v_i32m8(&operations[i], vl);\n        vint32m8_t balance_v = vmv_v_x_i32m8(balance, vl);\n        vint32m8_t new_balance_v = vadd_vv_i32m8(balance_v, op_v, vl);\n        vbool4_t mask = vmslt_vx_i32m8_b4(new_balance_v, 0, vl);\n\n        if (vm_first_m_b4(mask, vl)) {\n            return true;\n        }\n\n        balance = vmv_x_s_i32m8_i32(new_balance_v, vl);\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    size_t n = operations.size();\n    int balance = 0;\n    size_t vl;\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m8(n - i);\n        vint32m8_t op_v = vle32_v_i32m8(&operations[i], vl);\n        vint32m8_t balance_v = vmv_v_x_i32m8(balance, vl);\n        vint32m8_t new_balance_v = vadd_vv_i32m8(op_v, balance_v, vl);\n        vbool4_t mask = vmslt_vx_i32m8_b4(new_balance_v, 0, vl);\n\n        if (vm_first_m_b4(mask, vl)) {\n            return true;\n        }\n\n        balance = vmv_x_s_i32m8_i32(new_balance_v, vl);\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    size_t n = operations.size();\n    int balance = 0;\n    size_t vl;\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m8(n - i);\n        vint32m8_t op_v = vle32_v_i32m8(&operations[i], vl);\n        vint32m8_t balance_v = vmv_v_x_i32m8(balance, vl);\n        vint32m8_t new_balance_v = vadd_vv_i32m8(op_v, balance_v, vl);\n        vbool4_t mask = vmslt_vx_i32m8_b4(new_balance_v, 0, vl);\n\n        if (vm_first_m_b4(mask, vl)) {\n            return true;\n        }\n\n        balance = vmv_x_s_i32m8_i32(new_balance_v, vl);\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_64_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t n = numbers.size();\n    double sum = 0.0;\n    double mad_sum = 0.0;\n\n    // Calculate the mean\n    for (size_t i = 0; i < n; ++i) {\n        sum += numbers[i];\n    }\n    double mean = sum / n;\n\n    // Calculate the mean absolute deviation using RVV\n    size_t vlmax = __riscv_vsetvl_e64m1(n);\n    vfloat64m1_t v_mean = __riscv_vmv_v_f_f64m1(mean, vlmax);\n    vfloat64m1_t v_mad_sum = __riscv_vfmv_v_f_f64m1(0.0, vlmax);\n\n    for (size_t i = 0; i < n; i += vlmax) {\n        size_t vl = __riscv_vsetvl_e64m1(n - i);\n        vfloat64m1_t v_numbers = __riscv_vle64_v_f64m1(&numbers[i], vl);\n        vfloat64m1_t v_diff = __riscv_vfsub_vv_f64m1(v_numbers, v_mean, vl);\n        vfloat64m1_t v_abs_diff = __riscv_vfabs_v_f64m1(v_diff, vl);\n        v_mad_sum = __riscv_vfredusum_vs_f64m1_f64m1(v_mad_sum, v_abs_diff, v_mad_sum, vl);\n    }\n\n    mad_sum = __riscv_vfmv_f_s_f64m1_f64(v_mad_sum);\n    return mad_sum / n;\n}\n```"}
{"task_id": "SimdBench_64_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(const std::vector<double>& numbers) {\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    double sum = 0.0;\n    size_t vl = __riscv_vsetvl_e64m1(n);\n    vfloat64m1_t v_sum = __riscv_vfmv_v_f_f64m1(0.0, vl);\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e64m1(n - i);\n        vfloat64m1_t v_numbers = __riscv_vle64_v_f64m1(&numbers[i], vl);\n        v_sum = __riscv_vfadd_vv_f64m1(v_sum, v_numbers, vl);\n    }\n\n    sum = __riscv_vfredusum_vs_f64m1_f64m1(v_sum, 0.0, vl);\n\n    double mean = sum / n;\n\n    double mad_sum = 0.0;\n    vfloat64m1_t v_mad_sum = __riscv_vfmv_v_f_f64m1(0.0, vl);\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e64m1(n - i);\n        vfloat64m1_t v_numbers = __riscv_vle64_v_f64m1(&numbers[i], vl);\n        vfloat64m1_t v_diff = __riscv_vfsub_vf_f64m1(v_numbers, mean, vl);\n        vfloat64m1_t v_abs_diff = __riscv_vfabs_v_f64m1(v_diff, vl);\n        v_mad_sum = __riscv_vfadd_vv_f64m1(v_mad_sum, v_abs_diff, vl);\n    }\n\n    mad_sum = __riscv_vfredusum_vs_f64m1_f64m1(v_mad_sum, 0.0, vl);\n\n    return mad_sum / n;\n}\n```"}
{"task_id": "SimdBench_64_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(const std::vector<double>& numbers) {\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    double sum = 0.0;\n    size_t vl = __riscv_vsetvl_e64m1(n);\n    vfloat64m1_t v_sum = __riscv_vfmv_v_f_f64m1(0.0, vl);\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e64m1(n - i);\n        vfloat64m1_t v_numbers = __riscv_vle64_v_f64m1(&numbers[i], vl);\n        v_sum = __riscv_vfadd_vv_f64m1(v_sum, v_numbers, vl);\n    }\n\n    sum = __riscv_vfredusum_vs_f64m1_f64m1(v_sum, 0.0, vl);\n\n    double mean = sum / n;\n\n    double mad_sum = 0.0;\n    vfloat64m1_t v_mad_sum = __riscv_vfmv_v_f_f64m1(0.0, vl);\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e64m1(n - i);\n        vfloat64m1_t v_numbers = __riscv_vle64_v_f64m1(&numbers[i], vl);\n        vfloat64m1_t v_diff = __riscv_vfsub_vf_f64m1(v_numbers, mean, vl);\n        vfloat64m1_t v_abs_diff = __riscv_vfabs_v_f64m1(v_diff, vl);\n        v_mad_sum = __riscv_vfadd_vv_f64m1(v_mad_sum, v_abs_diff, vl);\n    }\n\n    mad_sum = __riscv_vfredusum_vs_f64m1_f64m1(v_mad_sum, 0.0, vl);\n\n    return mad_sum / n;\n}\n```"}
{"task_id": "SimdBench_64_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(const std::vector<double>& numbers) {\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    double sum = 0.0;\n    size_t vl = __riscv_vsetvl_e64m1(n);\n    vfloat64m1_t v_sum = __riscv_vfmv_v_f_f64m1(0.0, vl);\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e64m1(n - i);\n        vfloat64m1_t v_nums = __riscv_vle64_v_f64m1(&numbers[i], vl);\n        v_sum = __riscv_vfadd_vv_f64m1(v_sum, v_nums, vl);\n    }\n\n    sum = __riscv_vfredusum_vs_f64m1_f64m1(v_sum, 0.0, vl);\n\n    double mean = sum / n;\n\n    double mad_sum = 0.0;\n    vfloat64m1_t v_mad_sum = __riscv_vfmv_v_f_f64m1(0.0, vl);\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e64m1(n - i);\n        vfloat64m1_t v_nums = __riscv_vle64_v_f64m1(&numbers[i], vl);\n        vfloat64m1_t v_diff = __riscv_vfsub_vf_f64m1(v_nums, mean, vl);\n        vfloat64m1_t v_abs_diff = __riscv_vfabs_v_f64m1(v_diff, vl);\n        v_mad_sum = __riscv_vfadd_vv_f64m1(v_mad_sum, v_abs_diff, vl);\n    }\n\n    mad_sum = __riscv_vfredusum_vs_f64m1_f64m1(v_mad_sum, 0.0, vl);\n\n    return mad_sum / n;\n}\n```"}
{"task_id": "SimdBench_64_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t n = numbers.size();\n    double sum = 0.0;\n    double mad = 0.0;\n\n    // Calculate the mean\n    for (size_t i = 0; i < n; ++i) {\n        sum += numbers[i];\n    }\n    double mean = sum / n;\n\n    // Calculate the mean absolute deviation using RVV\n    size_t vl = __riscv_vsetvl_e64m1(n);\n    vfloat64m1_t v_mean = __riscv_vfmv_v_f_f64m1(mean, vl);\n    vfloat64m1_t v_mad = __riscv_vfadd_vv_f64m1(__riscv_vfsub_vv_f64m1(__riscv_vle64_v_f64m1(numbers.data(), vl), v_mean, vl), v_mad, vl);\n\n    for (size_t i = vl; i < n; ++i) {\n        mad += std::abs(numbers[i] - mean);\n    }\n\n    mad = __riscv_vfredusum_vs_f64m1_f64(v_mad, 0.0, vl) + mad;\n    return mad / n;\n}\n```"}
{"task_id": "SimdBench_65_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    size_t n = numbers.size();\n    if (n == 0) return {};\n\n    size_t result_size = 2 * n - 1;\n    std::vector<int> result(result_size);\n\n    size_t i = 0;\n    while (i < n) {\n        size_t vl = __riscv_vsetvl_e32m1(n - i);\n        vint32m1_t vec = __riscv_vle32_v_i32m1(&numbers[i], vl);\n        __riscv_vse32_v_i32m1(&result[2 * i], vec, vl);\n        vint32m1_t delim_vec = __riscv_vmv_v_x_i32m1(delimeter, vl);\n        __riscv_vse32_v_i32m1(&result[2 * i + 1], delim_vec, vl - 1);\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    size_t n = numbers.size();\n    if (n == 0) return {};\n\n    size_t result_size = 2 * n - 1;\n    std::vector<int> result(result_size);\n\n    size_t i = 0;\n    while (i < n) {\n        size_t vl = __riscv_vsetvl_e32m1(n - i);\n        vint32m1_t vec = __riscv_vle32_v_i32m1(&numbers[i], vl);\n        __riscv_vse32_v_i32m1(&result[2 * i], vec, vl);\n        vint32m1_t delim_vec = __riscv_vmv_v_x_i32m1(delimeter, vl);\n        __riscv_vse32_v_i32m1(&result[2 * i + 1], delim_vec, vl - 1);\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    size_t n = numbers.size();\n    if (n == 0) return {};\n\n    size_t result_size = 2 * n - 1;\n    std::vector<int> result(result_size);\n\n    size_t i = 0;\n    while (i < n) {\n        size_t vl = __riscv_vsetvl_e32m1(n - i);\n        vint32m1_t vec = __riscv_vle32_v_i32m1(&numbers[i], vl);\n        __riscv_vse32_v_i32m1(&result[2 * i], vec, vl);\n        vint32m1_t delim_vec = __riscv_vmv_v_x_i32m1(delimeter, vl);\n        __riscv_vse32_v_i32m1(&result[2 * i + 1], delim_vec, vl - 1);\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    size_t n = numbers.size();\n    if (n == 0) return {};\n\n    size_t result_size = 2 * n - 1;\n    std::vector<int> result(result_size);\n\n    size_t i = 0;\n    while (i < n) {\n        size_t vl = __riscv_vsetvl_e32m1(n - i);\n        vint32m1_t vec = __riscv_vle32_v_i32m1(&numbers[i], vl);\n        __riscv_vse32_v_i32m1(&result[2 * i], vec, vl);\n        vint32m1_t delim_vec = __riscv_vmv_v_x_i32m1(delimeter, vl);\n        __riscv_vse32_v_i32m1(&result[2 * i + 1], delim_vec, vl - 1);\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    size_t n = numbers.size();\n    if (n == 0) return {};\n\n    size_t result_size = 2 * n - 1;\n    std::vector<int> result(result_size);\n\n    size_t i = 0;\n    while (i < n) {\n        size_t vl = __riscv_vsetvl_e32m1(n - i);\n        vint32m1_t vec = __riscv_vle32_v_i32m1(&numbers[i], vl);\n        __riscv_vse32_v_i32m1(&result[2 * i], vec, vl);\n        vint32m1_t delim_vec = __riscv_vmv_v_x_i32m1(delimeter, vl);\n        __riscv_vse32_v_i32m1(&result[2 * i + 1], delim_vec, vl - 1);\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_66_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    size_t n = numbers.size();\n    if (n == 0) {\n        return {0, 1};\n    }\n\n    size_t vlmax = __riscv_vsetvl_e16m1(n);\n    vint16m1_t vec = __riscv_vle16_v_i16m1(numbers.data(), vlmax);\n\n    vint32m1_t vsum = __riscv_vmv_v_x_i32m1(0, vlmax);\n    vint32m1_t vprod = __riscv_vmv_v_x_i32m1(1, vlmax);\n\n    for (size_t i = 0; i < n; i += vlmax) {\n        size_t vl = __riscv_vsetvl_e16m1(n - i);\n        vec = __riscv_vle16_v_i16m1(numbers.data() + i, vl);\n\n        vsum = __riscv_vwredsum_vs_i16m1_i32m1(vsum, vec, vsum, vl);\n        vprod = __riscv_vwmul_vv_i32m1(vprod, vec, vprod, vl);\n    }\n\n    sum = __riscv_vmv_x_s_i32m1_i32(vsum);\n    product = __riscv_vmv_x_s_i32m1_i32(vprod);\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    size_t n = numbers.size();\n    if (n == 0) {\n        return {0, 1};\n    }\n\n    size_t vl = __riscv_vsetvl_e16m1(n);\n    vint16m1_t vec = __riscv_vle16_v_i16m1(numbers.data(), vl);\n\n    vint32m1_t sum_vec = __riscv_vmv_v_x_i32m1(0, vl);\n    vint32m1_t prod_vec = __riscv_vmv_v_x_i32m1(1, vl);\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e16m1(n - i);\n        vec = __riscv_vle16_v_i16m1(numbers.data() + i, vl);\n\n        sum_vec = __riscv_vwredsum_vs_i16m1_i32m1(sum_vec, vec, sum_vec, vl);\n        prod_vec = __riscv_vwmul_vv_i32m1(prod_vec, prod_vec, vec, vl);\n    }\n\n    sum = __riscv_vmv_x_s_i32m1_i32(sum_vec);\n    product = __riscv_vmv_x_s_i32m1_i32(prod_vec);\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) {\n        return {0, 1};\n    }\n\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    size_t vlmax = __riscv_vsetvl_e16m1(n);\n    vint16m1_t vec = __riscv_vle16_v_i16m1(numbers.data(), vlmax);\n\n    for (size_t vl = vlmax; vl > 0;) {\n        vint32m1_t sum_vec = __riscv_vwredsum_vs_i16m1_i32m1(vec, 0, vl);\n        sum += __riscv_vmv_x_s_i32m1_i32(sum_vec);\n\n        vint16m1_t prod_vec = __riscv_vwmul_vv_i16m1(vec, vec, vl);\n        product *= __riscv_vmv_x_s_i16m1_i16(__riscv_vredprod_vs_i16m1_i16m1(prod_vec, 1, vl));\n\n        numbers.data() += vl;\n        vl = __riscv_vsetvl_e16m1(n - (numbers.data() - numbers.data()));\n        vec = __riscv_vle16_v_i16m1(numbers.data(), vl);\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    size_t n = numbers.size();\n    if (n == 0) {\n        return {0, 1};\n    }\n\n    size_t vl = __riscv_vsetvl_e16m1(n);\n    vint16m1_t vec = __riscv_vle16_v_i16m1(numbers.data(), vl);\n\n    vint32m1_t sum_vec = __riscv_vmv_v_x_i32m1(0, vl);\n    vint32m1_t prod_vec = __riscv_vmv_v_x_i32m1(1, vl);\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e16m1(n - i);\n        vec = __riscv_vle16_v_i16m1(numbers.data() + i, vl);\n\n        sum_vec = __riscv_vwredsum_vs_i16m1_i32m1(sum_vec, vec, sum_vec, vl);\n        prod_vec = __riscv_vwmul_vv_i32m1(prod_vec, prod_vec, vec, vl);\n    }\n\n    sum = __riscv_vmv_x_s_i32m1_i32(sum_vec);\n    product = __riscv_vmv_x_s_i32m1_i32(prod_vec);\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    size_t n = numbers.size();\n    if (n == 0) {\n        return {0, 1};\n    }\n\n    size_t vl = __riscv_vsetvl_e16m1(n);\n    vint16m1_t vec = __riscv_vle16_v_i16m1(numbers.data(), vl);\n\n    vint32m1_t sum_vec = __riscv_vmv_v_x_i32m1(0, vl);\n    vint32m1_t prod_vec = __riscv_vmv_v_x_i32m1(1, vl);\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e16m1(n - i);\n        vec = __riscv_vle16_v_i16m1(numbers.data() + i, vl);\n\n        sum_vec = __riscv_vwredsum_vs_i16m1_i32m1(sum_vec, vec, sum_vec, vl);\n        prod_vec = __riscv_vwmul_vv_i32m1(prod_vec, prod_vec, vec, vl);\n    }\n\n    sum = __riscv_vmv_x_s_i32m1_i32(sum_vec);\n    product = __riscv_vmv_x_s_i32m1_i32(prod_vec);\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_67_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) return {};\n\n    std::vector<int> result(n);\n    int max_val = numbers[0];\n    result[0] = max_val;\n\n    size_t vlmax = __riscv_vsetvl_e32m1(n - 1);\n    vint32m1_t max_vec = __riscv_vmv_v_x_i32m1(max_val, vlmax);\n\n    for (size_t i = 1; i < n; ++i) {\n        vint32m1_t vec = __riscv_vle32_v_i32m1(&numbers[i], vlmax);\n        max_vec = __riscv_vmax_vv_i32m1(max_vec, vec, vlmax);\n        max_val = __riscv_vmv_x_s_i32m1_i32(max_vec);\n        result[i] = max_val;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) return {};\n\n    std::vector<int> result(n);\n    int max_val = numbers[0];\n    result[0] = max_val;\n\n    size_t vl;\n    for (size_t i = 1; i < n; ) {\n        vl = vsetvl_e32m8(n - i);\n        vint32m8_t vec = vle32_v_i32m8(&numbers[i], vl);\n        vint32m8_t max_vec = vmv_v_x_i32m8(max_val, vl);\n        vbool4_t mask = vmslt_vv_i32m8_b4(vec, max_vec, vl);\n        vec = vmerge_vvm_i32m8(mask, max_vec, vec, vl);\n        vse32_v_i32m8(&result[i], vec, vl);\n\n        // Find the new max value in the current segment\n        for (size_t j = 0; j < vl; ++j) {\n            max_val = std::max(max_val, numbers[i + j]);\n        }\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) return {};\n\n    std::vector<int> result(n);\n    int max_val = numbers[0];\n    result[0] = max_val;\n\n    size_t vlmax = __riscv_vsetvl_e32m1(n - 1);\n    vint32m1_t max_vec = __riscv_vmv_v_x_i32m1(max_val, vlmax);\n\n    for (size_t i = 1; i < n; ++i) {\n        size_t vl = __riscv_vsetvl_e32m1(n - i);\n        vint32m1_t vec = __riscv_vle32_v_i32m1(&numbers[i], vl);\n        vint32m1_t max_cmp = __riscv_vmax_vv_i32m1(vec, max_vec, vl);\n        max_val = __riscv_vredmax_vs_i32m1_i32(max_cmp, max_val, __riscv_vundefined_i32m1(), vl);\n        result[i] = max_val;\n        max_vec = __riscv_vmv_v_x_i32m1(max_val, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) return {};\n\n    std::vector<int> result(n);\n    int max_val = numbers[0];\n    result[0] = max_val;\n\n    size_t vlmax = __riscv_vsetvl_e32m1(n - 1);\n    vint32m1_t max_vec = __riscv_vmv_v_x_i32m1(max_val, vlmax);\n\n    for (size_t i = 1; i < n; ++i) {\n        size_t vl = __riscv_vsetvl_e32m1(n - i);\n        vint32m1_t vec = __riscv_vle32_v_i32m1(&numbers[i], vl);\n        vint32m1_t max_cmp = __riscv_vmax_vv_i32m1(vec, max_vec, vl);\n        max_val = __riscv_vredmax_vs_i32m1_i32(max_cmp, max_val, __riscv_vundefined_i32m1(), vl);\n        result[i] = max_val;\n        max_vec = __riscv_vmv_v_x_i32m1(max_val, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) return {};\n\n    std::vector<int> result(n);\n    int max_val = numbers[0];\n    result[0] = max_val;\n\n    size_t vl;\n    for (size_t i = 1; i < n; ) {\n        vl = vsetvl_e32m8(n - i);\n        vint32m8_t vec = vle32_v_i32m8(&numbers[i], vl);\n        vint32m8_t max_vec = vmv_v_x_i32m8(max_val, vl);\n        vbool4_t mask = vmslt_vv_i32m8_b4(vec, max_vec, vl);\n        vec = vmerge_vvm_i32m8(mask, max_vec, vec, vl);\n        vse32_v_i32m8(&result[i], vec, vl);\n\n        // Find the new max_val in the current segment\n        for (size_t j = 0; j < vl; ++j) {\n            max_val = std::max(max_val, numbers[i + j]);\n        }\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b){\n    size_t len = a.size();\n    std::string result(len, '0');\n\n    size_t vl = __riscv_vsetvl_e8m1(len);\n    vuint8m1_t va = __riscv_vle8_v_u8m1((const uint8_t*)a.c_str(), vl);\n    vuint8m1_t vb = __riscv_vle8_v_u8m1((const uint8_t*)b.c_str(), vl);\n    vuint8m1_t vxor = __riscv_vxor_vv_u8m1(va, vb, vl);\n\n    __riscv_vse8_v_u8m1((uint8_t*)result.data(), vxor, vl);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.size();\n    if (len != b.size()) {\n        throw std::invalid_argument(\"Strings must be of the same length\");\n    }\n\n    std::string result(len, '0');\n    size_t vl = __riscv_vsetvl_e8m1(len);\n\n    vbool8_t mask = __riscv_vmseq_vv_u8m1(__riscv_vle8_v_u8m1(reinterpret_cast<const uint8_t*>(a.c_str()), vl),\n                                         __riscv_vle8_v_u8m1(reinterpret_cast<const uint8_t*>(b.c_str()), vl), vl);\n    vuint8m1_t xor_result = __riscv_vmv_v_x_u8m1(0x30, vl); // ASCII '0'\n    xor_result = __riscv_vmsbc_vvm_u8m1(xor_result, mask, xor_result, vl); // Set to '1' where mask is true\n\n    __riscv_vse8_v_u8m1(reinterpret_cast<uint8_t*>(result.data()), xor_result, vl);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <cstring>\n\nstd::string string_xor_simd(std::string a, std::string b){\n    size_t len = a.length();\n    if (len != b.length()) {\n        throw std::invalid_argument(\"Strings must be of the same length\");\n    }\n\n    std::string result(len, '0');\n    size_t vlmax = __riscv_vsetvl_e8m1(len);\n\n    for (size_t i = 0; i < len; i += vlmax) {\n        size_t vl = __riscv_vsetvl_e8m1(len - i);\n        vuint8m1_t va = __riscv_vle8_v_u8m1(reinterpret_cast<const uint8_t*>(a.c_str() + i), vl);\n        vuint8m1_t vb = __riscv_vle8_v_u8m1(reinterpret_cast<const uint8_t*>(b.c_str() + i), vl);\n        vuint8m1_t vxor = __riscv_vxor_vv_u8m1(va, vb, vl);\n        __riscv_vse8_v_u8m1(reinterpret_cast<uint8_t*>(result.data() + i), vxor, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <cstring>\n\nstd::string string_xor_simd(std::string a, std::string b){\n    size_t len = a.length();\n    if (len != b.length()) {\n        return \"\";\n    }\n\n    std::string result(len, '0');\n    size_t vl = __riscv_vsetvl_e8m1(len);\n\n    const char *pa = a.c_str();\n    const char *pb = b.c_str();\n    char *pr = result.data();\n\n    vbool8_t mask;\n    vuint8m1_t va, vb, vxor;\n\n    do {\n        va = __riscv_vle8_v_u8m1(pa, vl);\n        vb = __riscv_vle8_v_u8m1(pb, vl);\n        vxor = __riscv_vxor_vv_u8m1(va, vb, vl);\n        __riscv_vse8_v_u8m1(pr, vxor, vl);\n\n        pa += vl;\n        pb += vl;\n        pr += vl;\n    } while ((vl = __riscv_vsetvl_e8m1(len - (pa - a.c_str()))) > 0);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <cstring>\n\nstd::string string_xor_simd(std::string a, std::string b){\n    size_t len = a.length();\n    if (len != b.length()) {\n        throw std::invalid_argument(\"Strings must be of the same length\");\n    }\n\n    std::string result(len, '0');\n    size_t vl = __riscv_vsetvl_e8m1(len);\n\n    const char* a_ptr = a.c_str();\n    const char* b_ptr = b.c_str();\n    char* result_ptr = &result[0];\n\n    vbool8_t mask = __riscv_vmseq_vv_i8m1(__riscv_vle8_v_i8m1(a_ptr, vl), __riscv_vle8_v_i8m1(b_ptr, vl), vl);\n    vint8m1_t xor_result = __riscv_vnmsb_vvm_i8m1(mask, __riscv_vle8_v_i8m1(a_ptr, vl), __riscv_vle8_v_i8m1(b_ptr, vl), vl);\n\n    __riscv_vse8_v_i8m1(result_ptr, xor_result, vl);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_69_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::string longest_simd(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return {};\n    }\n\n    size_t max_length = 0;\n    size_t max_index = 0;\n\n    size_t num_strings = strings.size();\n    size_t vl = __riscv_vsetvl_e32m1(num_strings);\n\n    vuint32m1_t lengths = __riscv_vle32_v_u32m1(reinterpret_cast<const uint32_t*>(strings.data()), vl);\n    vbool1_t mask = __riscv_vmsne_vx_u32m1_b1(lengths, 0, vl);\n\n    while (vl > 0) {\n        for (size_t i = 0; i < vl; ++i) {\n            if (__riscv_vmv_x_s_b1(mask, i)) {\n                if (strings[i].length() > max_length) {\n                    max_length = strings[i].length();\n                    max_index = i;\n                }\n            }\n        }\n        num_strings -= vl;\n        if (num_strings == 0) break;\n        vl = __riscv_vsetvl_e32m1(num_strings);\n        lengths = __riscv_vle32_v_u32m1(reinterpret_cast<const uint32_t*>(strings.data() + (strings.size() - num_strings)), vl);\n        mask = __riscv_vmsne_vx_u32m1_b1(lengths, 0, vl);\n    }\n\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_69_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::string longest_simd(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    size_t max_length = 0;\n    size_t max_index = 0;\n\n    size_t num_strings = strings.size();\n    size_t vl = __riscv_vsetvl_e32m1(num_strings);\n\n    vuint32m1_t lengths = __riscv_vle32_v_u32m1(reinterpret_cast<const uint32_t*>(strings.data()), vl);\n    vbool1_t mask = __riscv_vmseq_vx_u32m1_b1(lengths, 0, vl);\n\n    for (size_t i = 0; i < num_strings; i += vl) {\n        vl = __riscv_vsetvl_e32m1(num_strings - i);\n        lengths = __riscv_vle32_v_u32m1(reinterpret_cast<const uint32_t*>(strings.data() + i), vl);\n\n        for (size_t j = 0; j < vl; ++j) {\n            if (strings[i + j].length() > max_length) {\n                max_length = strings[i + j].length();\n                max_index = i + j;\n            }\n        }\n    }\n\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_69_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::string longest_simd(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    size_t max_len = 0;\n    size_t max_index = 0;\n\n    size_t num_strings = strings.size();\n    size_t vl = __riscv_vsetvl_e32m1(num_strings);\n\n    vuint32m1_t len_vec = __riscv_vle32_v_u32m1(reinterpret_cast<const uint32_t*>(strings.data()), vl);\n    vbool1_t mask = __riscv_vmsne_vx_u32m1_b1(len_vec, 0, vl);\n\n    while (vl > 0) {\n        for (size_t i = 0; i < vl; ++i) {\n            if (__riscv_vmv_x_s_b1(mask, i)) {\n                size_t current_len = strings[i].length();\n                if (current_len > max_len) {\n                    max_len = current_len;\n                    max_index = i;\n                }\n            }\n        }\n        num_strings -= vl;\n        if (num_strings == 0) break;\n        vl = __riscv_vsetvl_e32m1(num_strings);\n        len_vec = __riscv_vle32_v_u32m1(reinterpret_cast<const uint32_t*>(strings.data() + (strings.size() - num_strings)), vl);\n        mask = __riscv_vmsne_vx_u32m1_b1(len_vec, 0, vl);\n    }\n\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_69_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::string longest_simd(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    size_t max_length = 0;\n    size_t max_index = 0;\n\n    size_t num_strings = strings.size();\n    size_t vl = __riscv_vsetvl_e32m1(num_strings);\n\n    vuint32m1_t lengths = __riscv_vle32_v_u32m1(reinterpret_cast<const uint32_t*>(strings.data()), vl);\n    vbool1_t mask = __riscv_vmseq_vx_u32m1_b1(lengths, 0, vl);\n\n    for (size_t i = 0; i < num_strings; i += vl) {\n        vl = __riscv_vsetvl_e32m1(num_strings - i);\n        lengths = __riscv_vle32_v_u32m1(reinterpret_cast<const uint32_t*>(strings.data() + i), vl);\n\n        for (size_t j = 0; j < vl; ++j) {\n            if (strings[i + j].length() > max_length) {\n                max_length = strings[i + j].length();\n                max_index = i + j;\n            }\n        }\n    }\n\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_69_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::string longest_simd(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    size_t max_length = 0;\n    size_t max_index = 0;\n\n    size_t num_strings = strings.size();\n    size_t vl = __riscv_vsetvl_e32m1(num_strings);\n\n    vuint32m1_t lengths = __riscv_vle32_v_u32m1(reinterpret_cast<const uint32_t*>(strings.data()), vl);\n    vbool1_t mask = __riscv_vmseq_vx_u32m1_b1(lengths, 0, vl);\n\n    for (size_t i = 0; i < num_strings; i += vl) {\n        vl = __riscv_vsetvl_e32m1(num_strings - i);\n        lengths = __riscv_vle32_v_u32m1(reinterpret_cast<const uint32_t*>(strings.data() + i), vl);\n\n        for (size_t j = 0; j < vl; ++j) {\n            if (strings[i + j].length() > max_length) {\n                max_length = strings[i + j].length();\n                max_index = i + j;\n            }\n        }\n    }\n\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_70_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    vuint64m1_t va, vb, vtemp;\n    size_t vl = 1;\n\n    va = vle64_v_u64m1(&a, vl);\n    vb = vle64_v_u64m1(&b, vl);\n\n    while (vfirst_m_b1(vmsne_vi_u64m1(vb, 0, vl), vl)) {\n        vtemp = vb;\n        vb = vrem_vv_u64m1(va, vb, vl);\n        va = vtemp;\n    }\n\n    return va[0];\n}\n```"}
{"task_id": "SimdBench_70_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    vuint64m1_t va, vb, vtemp;\n    size_t vl = 1;\n\n    va = vle64_v_u64m1(&a, vl);\n    vb = vle64_v_u64m1(&b, vl);\n\n    while (!vmv_x_s_u64m1_b0(vmsne_vv_u64m1_b1(va, vb, vl), vl)) {\n        vtemp = vsub_vv_u64m1(va, vb, vl);\n        va = vmin_vv_u64m1(va, vb, vl);\n        vb = vtemp;\n    }\n\n    return vmv_x_s_u64m1_i64(va, vl);\n}\n```"}
{"task_id": "SimdBench_70_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    vuint64m1_t va, vb, vtemp;\n    size_t vl = 1;\n\n    va = vle64_v_u64m1(&a, vl);\n    vb = vle64_v_u64m1(&b, vl);\n\n    while (vfirst_m_b1(vmsne_vi_u64m1(vb, 0, vl), vl)) {\n        vtemp = vb;\n        vb = vrem_vv_u64m1(va, vb, vl);\n        va = vtemp;\n    }\n\n    return va[0];\n}\n```"}
{"task_id": "SimdBench_70_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    vuint64m1_t va, vb, vtemp;\n    vbool1_t vm;\n    size_t vl = 1;\n\n    va = vle64_v_u64m1(&a, vl);\n    vb = vle64_v_u64m1(&b, vl);\n\n    do {\n        vtemp = va;\n        va = vb;\n        vb = vrem_vv_u64m1(vtemp, vb, vl);\n        vm = vmsne_vv_u64m1_b1(vb, vtemp, vl);\n    } while (!vm_first_m_b1(vm, vl));\n\n    return vb[0];\n}\n```"}
{"task_id": "SimdBench_70_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    vuint64m1_t va, vb, vtemp;\n    size_t vl = 1;\n\n    va = vle64_v_u64m1(&a, vl);\n    vb = vle64_v_u64m1(&b, vl);\n\n    while (!vmv_x_s_u64m1_b1(vmsne_vv_u64m1_b1(va, vb, vl), vl)) {\n        vtemp = vsub_vv_u64m1(va, vb, vl);\n        va = vmin_vv_u64m1(va, vb, vl);\n        vb = vtemp;\n    }\n\n    return vmv_x_s_u64m1_i64(va, vl);\n}\n```"}
{"task_id": "SimdBench_71_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    float result[2] = {0.0f, 0.0f};\n\n    for (size_t i = 0; i < n; ++i) {\n        vfloat32m8_t vec1 = vle32_v_f32m8(&numbers[i], n - i);\n        vfloat32m8_t vec2 = vslide1up_vf32m8(vec1, numbers[i], n - i);\n        vfloat32m8_t diff = vfsub_vv_f32m8(vec2, vec1, n - i);\n        vbool4_t mask = vmflt_vf_f32m8_b4(diff, min_diff, n - i);\n\n        if (vmfirst_m_b4(mask)) {\n            size_t idx = vfirst_m_b4(mask);\n            float a = numbers[i + idx];\n            float b = numbers[i + idx + 1];\n            if (a > b) std::swap(a, b);\n            min_diff = std::abs(b - a);\n            result[0] = a;\n            result[1] = b;\n        }\n    }\n\n    return std::vector<float>{result[0], result[1]};\n}\n```"}
{"task_id": "SimdBench_71_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    float result[2] = {0.0f, 0.0f};\n\n    for (size_t i = 0; i < n; ++i) {\n        vfloat32m8_t vec1 = vle32_v_f32m8(&numbers[i], n - i);\n        vfloat32m8_t vec2 = vslide1up_vx_f32m8(vec1, numbers[i], n - i);\n\n        vfloat32m8_t diff = vfsub_vv_f32m8(vec2, vec1, n - i);\n        vfloat32m8_t abs_diff = vfabs_v_f32m8(diff, n - i);\n\n        vbool4_t mask = vmflt_vf_f32m8_b4(abs_diff, min_diff, n - i);\n        if (vmfirst_m_b4(mask)) {\n            size_t idx = vfirst_m_b4(mask);\n            min_diff = vfmv_f_s_f32m8_f32(abs_diff, idx);\n            result[0] = vfmv_f_s_f32m8_f32(vec1, idx);\n            result[1] = vfmv_f_s_f32m8_f32(vec2, idx);\n        }\n    }\n\n    if (result[0] > result[1]) {\n        std::swap(result[0], result[1]);\n    }\n\n    return {result[0], result[1]};\n}\n```"}
{"task_id": "SimdBench_71_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    float result[2] = {0.0f, 0.0f};\n\n    for (size_t i = 0; i < n; ++i) {\n        vfloat32m8_t vec1 = vle32_v_f32m8(&numbers[i], n - i);\n        vfloat32m8_t vec2 = vslideup_vx_f32m8(vec1, numbers[i], n - i);\n\n        vfloat32m8_t diff = vfsub_vv_f32m8(vec1, vec2, n - i);\n        vfloat32m8_t abs_diff = vfabs_v_f32m8(diff, n - i);\n\n        vbool4_t mask = vmflt_vf_f32m8_b4(abs_diff, min_diff, n - i);\n        if (vmfirst_m_b4(mask)) {\n            size_t idx = vfirst_m_b4(mask);\n            min_diff = vfmv_f_s_f32m8_f32(abs_diff, idx);\n            result[0] = numbers[i + idx];\n            result[1] = numbers[i];\n            if (result[0] > result[1]) std::swap(result[0], result[1]);\n        }\n    }\n\n    return std::vector<float>{result[0], result[1]};\n}\n```"}
{"task_id": "SimdBench_71_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    float result[2] = {0.0f, 0.0f};\n\n    for (size_t i = 0; i < n; ++i) {\n        vfloat32m8_t vec1 = vle32_v_f32m8(&numbers[i], n - i);\n        vfloat32m8_t vec2 = vslide1up_vx_f32m8(vec1, numbers[i], n - i);\n\n        vfloat32m8_t diff = vfsub_vv_f32m8(vec1, vec2, n - i);\n        vfloat32m8_t abs_diff = vfabs_v_f32m8(diff, n - i);\n\n        vbool4_t mask = vmflt_vf_f32m8_b4(abs_diff, min_diff, n - i);\n        if (vmfirst_m_b4(mask)) {\n            size_t idx = vfirst_m_b4(mask);\n            min_diff = vfmv_f_s_f32m8_f32(abs_diff, idx);\n            result[0] = numbers[i + idx];\n            result[1] = numbers[i + idx + 1];\n            if (result[0] > result[1]) {\n                std::swap(result[0], result[1]);\n            }\n        }\n    }\n\n    return std::vector<float>{result[0], result[1]};\n}\n```"}
{"task_id": "SimdBench_71_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    float result[2] = {0.0f, 0.0f};\n\n    for (size_t i = 0; i < n; ++i) {\n        vfloat32m8_t vec1 = vle32_v_f32m8(&numbers[i], n - i);\n        vfloat32m8_t vec2 = vle32_v_f32m8(&numbers[i + 1], n - i - 1);\n\n        vfloat32m8_t diff = vfsub_vv_f32m8(vec1, vec2, __RISCV_VLMAX);\n        vfloat32m8_t abs_diff = vfabs_v_f32m8(diff, __RISCV_VLMAX);\n\n        float temp_min_diff = vmin_vf_f32m8_f32(abs_diff, std::numeric_limits<float>::max(), __RISCV_VLMAX);\n\n        if (temp_min_diff < min_diff) {\n            min_diff = temp_min_diff;\n            size_t index = 0;\n            vbool4_t mask = vmfeq_vf_f32m8_b4(abs_diff, temp_min_diff, __RISCV_VLMAX);\n            vmfirst_m_b4_i32(&index, mask, __RISCV_VLMAX);\n            result[0] = numbers[i + index];\n            result[1] = numbers[i + index + 1];\n            if (result[0] > result[1]) std::swap(result[0], result[1]);\n        }\n    }\n\n    return std::vector<float>{result[0], result[1]};\n}\n```"}
{"task_id": "SimdBench_72_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n < 2) return numbers;\n\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n\n    std::vector<float> result(n);\n    size_t vl = __riscv_vsetvl_e32m8(n);\n\n    vfloat32m8_t v_min = __riscv_vfmv_v_f_f32m8(min_val, vl);\n    vfloat32m8_t v_range = __riscv_vfmv_v_f_f32m8(range, vl);\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m8(n - i);\n        vfloat32m8_t v_in = __riscv_vle32_v_f32m8(&numbers[i], vl);\n        vfloat32m8_t v_out = __riscv_vfsub_vv_f32m8(v_in, v_min, vl);\n        v_out = __riscv_vfdiv_vv_f32m8(v_out, v_range, vl);\n        __riscv_vse32_v_f32m8(&result[i], v_out, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n < 2) return numbers;\n\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n\n    std::vector<float> result(n);\n    size_t vl = __riscv_vsetvl_e32m8(n);\n\n    vfloat32m8_t v_min = __riscv_vfmv_v_f_f32m8(min_val, vl);\n    vfloat32m8_t v_range = __riscv_vfmv_v_f_f32m8(range, vl);\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m8(n - i);\n        vfloat32m8_t v_in = __riscv_vle32_v_f32m8(&numbers[i], vl);\n        vfloat32m8_t v_out = __riscv_vfsub_vv_f32m8(v_in, v_min, vl);\n        v_out = __riscv_vfdiv_vv_f32m8(v_out, v_range, vl);\n        __riscv_vse32_v_f32m8(&result[i], v_out, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n < 2) return numbers;\n\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n\n    std::vector<float> result(n);\n    size_t vl = __riscv_vsetvl_e32m8(n);\n\n    vfloat32m8_t v_min = __riscv_vfmv_v_f_f32m8(min_val, vl);\n    vfloat32m8_t v_range = __riscv_vfmv_v_f_f32m8(range, vl);\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m8(n - i);\n        vfloat32m8_t v_in = __riscv_vle32_v_f32m8(&numbers[i], vl);\n        vfloat32m8_t v_out = __riscv_vfsub_vv_f32m8(v_in, v_min, vl);\n        v_out = __riscv_vfdiv_vv_f32m8(v_out, v_range, vl);\n        __riscv_vse32_v_f32m8(&result[i], v_out, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n < 2) return numbers;\n\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n\n    std::vector<float> result(n);\n    size_t vl = __riscv_vsetvl_e32m8(n);\n\n    vfloat32m8_t v_min = __riscv_vfmv_v_f_f32m8(min_val, vl);\n    vfloat32m8_t v_range = __riscv_vfmv_v_f_f32m8(range, vl);\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m8(n - i);\n        vfloat32m8_t v_in = __riscv_vle32_v_f32m8(&numbers[i], vl);\n        vfloat32m8_t v_out = __riscv_vfsub_vv_f32m8(v_in, v_min, vl);\n        v_out = __riscv_vfdiv_vv_f32m8(v_out, v_range, vl);\n        __riscv_vse32_v_f32m8(&result[i], v_out, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n < 2) return numbers;\n\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n\n    std::vector<float> result(n);\n    size_t vl = __riscv_vsetvl_e32m8(n);\n\n    vfloat32m8_t v_min = __riscv_vfmv_v_f_f32m8(min_val, vl);\n    vfloat32m8_t v_range = __riscv_vfmv_v_f_f32m8(range, vl);\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m8(n - i);\n        vfloat32m8_t v_in = __riscv_vle32_v_f32m8(&numbers[i], vl);\n        vfloat32m8_t v_out = __riscv_vfsub_vv_f32m8(v_in, v_min, vl);\n        v_out = __riscv_vfdiv_vv_f32m8(v_out, v_range, vl);\n        __riscv_vse32_v_f32m8(&result[i], v_out, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_73_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    uint64_t result = 1;\n    size_t vl = vsetvl_e64m1(1);\n    vuint64m1_t vn = vmv_v_x_u64m1(n, vl);\n    vuint64m1_t vone = vmv_v_x_u64m1(1, vl);\n    vuint64m1_t vresult = vmv_v_x_u64m1(1, vl);\n\n    for (uint64_t i = 2; i < n; i++) {\n        vuint64m1_t vi = vmv_v_x_u64m1(i, vl);\n        vbool1_t mask = vmseq_vx_u64m1_b1(vn, i, vl);\n        vresult = vmerge_vvm_u64m1(mask, vi, vresult, vl);\n    }\n\n    return vresult[0];\n}\n```"}
{"task_id": "SimdBench_73_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    uint64_t result = 1;\n    size_t vlmax = vsetvl_e64m1(n - 1);\n    vuint64m1_t divisors = vseq_v_u64m1(2, 1, vlmax);\n    vuint64m1_t remainders = vrem_vv_u64m1(divisors, vdup_v_u64m1(n, vlmax), vlmax);\n    vbool64_t mask = vmseq_vx_u64m1_b64(remainders, 0, vlmax);\n    vuint64m1_t valid_divisors = vcompress_vm_u64m1(mask, divisors, vlmax);\n    size_t valid_count = vpopcount_m_b64(mask, vlmax);\n    if (valid_count > 0) {\n        result = vfirst_m_b64(mask, vlmax) ? valid_divisors[valid_count - 1] : 1;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_73_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    uint64_t result = 1;\n    size_t vlmax = vsetvl_e64m1(n - 1);\n    vuint64m1_t divisors = vseq_v_u64m1(2, 1, vlmax);\n    vuint64m1_t remainders = vrem_vv_u64m1(divisors, vdup_v_u64m1(n, vlmax), vlmax);\n    vbool64_t mask = vmseq_vx_u64m1_b64(remainders, 0, vlmax);\n    vuint64m1_t valid_divisors = vcompress_vm_u64m1(mask, divisors, vlmax);\n    size_t valid_count = vpopcnt_m_b64(mask, vlmax);\n    if (valid_count > 0) {\n        result = vfirst_m_b64(mask, vlmax) ? valid_divisors[0] : result;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_73_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    uint64_t result = 1;\n    size_t vl = vsetvl_e64m1(n - 1);\n    vuint64m1_t divisors = vseq_vl_e64m1(2, 1, vl);\n    vuint64m1_t remainders = vrem_vv_u64m1(divisors, vdup_v_u64m1(n, vl), vl);\n    vbool64_t mask = vmseq_vx_u64m1_b64(remainders, 0, vl);\n    vuint64m1_t valid_divisors = vcompress_vm_u64m1(mask, divisors, vl);\n    size_t max_index = 0;\n    vuint64m1_t max_divisor = vfirst_m_v_u64m1(&max_index, mask, vl);\n    if (max_index != 0) {\n        result = vget_i64m1_i64(max_divisor, max_index - 1);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_73_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    uint64_t result = 1;\n    size_t vlmax = vsetvl_e64m1(n - 1);\n    vuint64m1_t divisors = vseq_v_u64m1(2, 1, vlmax);\n    vuint64m1_t remainders = vrem_vv_u64m1(divisors, vdup_v_u64m1(n, vlmax), vlmax);\n    vbool64_t mask = vmseq_vx_u64m1_b64(remainders, 0, vlmax);\n    vuint64m1_t valid_divisors = vcompress_vm_u64m1(mask, divisors, vlmax);\n    size_t valid_count = vpopcount_m_b64(mask, vlmax);\n    if (valid_count > 0) {\n        result = vfirst_m_v_u64m1(valid_divisors, mask, vlmax);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_74_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    int original_n = n;\n\n    // Check for number of 2s that divide n\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    // n must be odd at this point, so a skip of 2 (i.e., i = i + 2) can be used\n    for (int i = 3; i <= std::sqrt(n); i += 2) {\n        // While i divides n, add i and divide n\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n\n    // This condition is to check if n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    int original_n = n;\n\n    // Check for number of 2s that divide n\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    // n must be odd at this point, so a skip of 2 (i.e., i = i + 2) can be used\n    for (int i = 3; i <= std::sqrt(n); i += 2) {\n        // While i divides n, add i and divide n\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n\n    // This condition is to check if n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    int original_n = n;\n\n    // Check for number of 2s that divide n\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    // n must be odd at this point, so a skip of 2 (i.e., i += 2) can be used\n    for (int i = 3; i <= std::sqrt(n); i += 2) {\n        // While i divides n, add i and divide n\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n\n    // This condition is to check if n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    int original_n = n;\n\n    // Check for number of 2s that divide n\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    // n must be odd at this point, so a skip of 2 (i.e., i = i + 2) can be used\n    for (int i = 3; i <= std::sqrt(n); i += 2) {\n        // While i divides n, add i and divide n\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n\n    // This condition is to check if n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    int original_n = n;\n\n    // Check for number of 2s that divide n\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    // n must be odd at this point, so a skip of 2 (i.e., i += 2) can be used\n    for (int i = 3; i <= std::sqrt(n); i += 2) {\n        // While i divides n, add i and divide n\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n\n    // This condition is to check if n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_75_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    size_t n = l.size();\n    std::vector<float> result(n);\n    size_t i = 0;\n\n    while (i < n) {\n        size_t vl = __riscv_vsetvl_e32m8(n - i);\n        vfloat32m8_t vec = __riscv_vle32_v_f32m8(&l[i], vl);\n        vbool8_t mask = __riscv_vfsgt_vf_f32m8_b8(vec, 0.0f, vl);\n        size_t cnt = __riscv_vpopc_b8_m(mask, vl);\n\n        __riscv_vse32_v_f32m8_m(&result[i], vec, mask, vl);\n\n        i += vl;\n    }\n\n    // Resize result to remove trailing zeros\n    size_t result_size = 0;\n    for (size_t j = 0; j < n; ++j) {\n        if (result[j] > 0) {\n            ++result_size;\n        }\n    }\n    result.resize(result_size);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    size_t n = l.size();\n    std::vector<float> result(n);\n    size_t i = 0;\n\n    while (i < n) {\n        size_t vl = __riscv_vsetvl_e32m8(n - i);\n        vfloat32m8_t vec = __riscv_vle32_v_f32m8(&l[i], vl);\n        vbool8_t mask = __riscv_vfsgt_vf_f32m8_b8(vec, 0.0f, vl);\n        size_t true_count = __riscv_vpopc_m_b8(mask, vl);\n\n        __riscv_vse32_v_f32m8_mask(&result[i], vec, mask, vl);\n\n        i += vl;\n    }\n\n    // Resize result to remove trailing zeros\n    size_t result_size = 0;\n    for (size_t j = 0; j < n; ++j) {\n        if (result[j] > 0) {\n            ++result_size;\n        }\n    }\n    result.resize(result_size);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    size_t n = l.size();\n    std::vector<float> result(n);\n    size_t i = 0;\n\n    while (i < n) {\n        size_t vl = __riscv_vsetvl_e32m8(n - i);\n        vfloat32m8_t vec = __riscv_vle32_v_f32m8(&l[i], vl);\n        vbool8_t mask = __riscv_vfsgt_vf_f32m8_b8(vec, 0.0f, vl);\n        size_t true_count = __riscv_vpopc_b8_m(mask, vl);\n\n        __riscv_vse32_v_f32m8_mask(&result[i], vec, mask, vl);\n\n        i += vl;\n    }\n\n    // Resize result to remove trailing zeros\n    size_t result_size = 0;\n    for (size_t j = 0; j < n; ++j) {\n        if (result[j] > 0) {\n            ++result_size;\n        }\n    }\n    result.resize(result_size);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    size_t n = l.size();\n    std::vector<float> result(n);\n    size_t i = 0;\n\n    while (i < n) {\n        size_t vl = __riscv_vsetvl_e32m8(n - i);\n        vfloat32m8_t vec = __riscv_vle32_v_f32m8(&l[i], vl);\n        vbool8_t mask = __riscv_vfmgt_vf_f32m8_b8(vec, 0.0f, vl);\n        size_t true_count = __riscv_vpopc_b8_m(mask, vl);\n\n        __riscv_vse32_v_f32m8_mask(&result[i], vec, mask, vl);\n\n        i += vl;\n    }\n\n    // Resize result to remove trailing zeros\n    size_t result_size = 0;\n    for (size_t j = 0; j < n; ++j) {\n        if (result[j] > 0) {\n            ++result_size;\n        }\n    }\n    result.resize(result_size);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    size_t n = l.size();\n    std::vector<float> result(n);\n    size_t i = 0;\n\n    while (i < n) {\n        size_t vl = __riscv_vsetvl_e32m8(n - i);\n        vfloat32m8_t vec = __riscv_vle32_v_f32m8(&l[i], vl);\n        vbool8_t mask = __riscv_vfsgt_vf_f32m8_b8(vec, 0.0f, vl);\n        size_t cnt = __riscv_vpopc_b8_m(mask, vl);\n\n        __riscv_vmcompress_v_f32m8(&result[i], vec, mask, vl);\n\n        i += vl;\n    }\n\n    result.resize(std::count_if(result.begin(), result.end(), [](float x) { return x > 0; }));\n    return result;\n}\n```"}
{"task_id": "SimdBench_76_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdbool.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t i = 5;\n    while (i * i <= n) {\n        size_t vl = vsetvl_e64m8(n - i + 1);\n        vint64m8_t vi = vid_v_i64m8(vl);\n        vi = vadd_vx_i64m8(vi, i, vl);\n        vint64m8_t vstep = vle64_v_i64m8(&i, vl);\n        vstep = vadd_vi_i64m8(vstep, 6, vl);\n        vint64m8_t vdiv1 = vdiv_vv_i64m8(vi, vstep, vl);\n        vint64m8_t vdiv2 = vdiv_vv_i64m8(vi, vadd_vi_i64m8(vstep, 2, vl), vl);\n        vbool8_t vmask1 = vmsne_vv_i64m8_b8(vmul_vv_i64m8(vdiv1, vstep, vl), vi, vl);\n        vbool8_t vmask2 = vmsne_vv_i64m8_b8(vmul_vv_i64m8(vdiv2, vadd_vi_i64m8(vstep, 2, vl), vl), vi, vl);\n        vbool8_t vmask = vand_vv_b8(vmask1, vmask2, vl);\n        if (!vfirst_m_b8(vmask, vl)) {\n            return false;\n        }\n        i += 6;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdbool.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t i = 5;\n    while (i * i <= n) {\n        size_t vl = vsetvl_e64m8(n - i + 1);\n        vint64m8_t vi = vid_v_i64m8(vl);\n        vi = vadd_vx_i64m8(vi, i, vl);\n        vint64m8_t vstep = vmul_vx_i64m8(vi, 6, vl);\n        vint64m8_t vtest1 = vsub_vx_i64m8(vstep, 1, vl);\n        vint64m8_t vtest2 = vadd_vx_i64m8(vstep, 1, vl);\n\n        vbool8_t mask1 = vmseq_vx_i64m8_b8(vtest1, n, vl);\n        vbool8_t mask2 = vmseq_vx_i64m8_b8(vtest2, n, vl);\n\n        if (vmfirst_m_b8(mask1, vl) || vmfirst_m_b8(mask2, vl)) {\n            return false;\n        }\n\n        i += 6;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdbool.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t i = 5;\n    while (i * i <= n) {\n        size_t vl = vsetvl_e64m8(n - i + 1);\n        vint64m8_t vi = vid_v_i64m8(vl);\n        vi = vadd_vx_i64m8(vi, i, vl);\n        vint64m8_t vj = vadd_vx_i64m8(vi, 2, vl);\n        vbool8_t mask1 = vmnez_vv_i64m8_b8(vrem_vv_i64m8(vi, vi, vl), vi, vl);\n        vbool8_t mask2 = vmnez_vv_i64m8_b8(vrem_vv_i64m8(vj, vj, vl), vj, vl);\n        vbool8_t mask = vmor_vv_b8(mask1, mask2, vl);\n        if (!vmfirst_m_b8(mask)) return false;\n        i += 6;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdbool.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t i = 5;\n    while (i * i <= n) {\n        size_t vl = vsetvl_e64m8(n - i + 1);\n        vint64m8_t vi = vid_v_i64m8(i, 1, vl);\n        vint64m8_t vi_plus_2 = vadd_vx_i64m8(vi, 2, vl);\n        vint64m8_t vi_times_vi = vmul_vv_i64m8(vi, vi, vl);\n        vint64m8_t vi_plus_2_times_vi_plus_2 = vmul_vv_i64m8(vi_plus_2, vi_plus_2, vl);\n\n        vbool8_t mask1 = vmle_vx_u64m8_b8(vi_times_vi, n, vl);\n        vbool8_t mask2 = vmle_vx_u64m8_b8(vi_plus_2_times_vi_plus_2, n, vl);\n\n        vbool8_t divisible_by_i = vmseq_vx_u64m8_b8(vrem_vx_u64m8((vuint64m8_t)n, vi, vl), 0, vl);\n        vbool8_t divisible_by_i_plus_2 = vmseq_vx_u64m8_b8(vrem_vx_u64m8((vuint64m8_t)n, vi_plus_2, vl), 0, vl);\n\n        if (vany_true_b8(mask1 & divisible_by_i) || vany_true_b8(mask2 & divisible_by_i_plus_2)) {\n            return false;\n        }\n\n        i += 6;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdbool.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t i = 5;\n    while (i * i <= n) {\n        size_t vl = vsetvl_e64m1(n - i + 1);\n        vint64m1_t vi = vid_v_i64m1(vl);\n        vi = vadd_vx_i64m1(vi, i, vl);\n        vint64m1_t vstep = vmul_vx_i64m1(vi, 6, vl);\n        vint64m1_t vtest1 = vsub_vx_i64m1(vstep, 1, vl);\n        vint64m1_t vtest2 = vadd_vx_i64m1(vstep, 1, vl);\n\n        vbool64_t mask1 = vrem_vx_u64m1_b64(vtest1, n, vl);\n        vbool64_t mask2 = vrem_vx_u64m1_b64(vtest2, n, vl);\n        vbool64_t mask = vmvnb_m_b64(mask1, mask2, vl);\n\n        if (!vmfirst_m_b64(mask, vl)) {\n            return false;\n        }\n\n        i += 6;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_77_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s) {\n    size_t n = s.size();\n    if (n == 0) return s;\n\n    // Check if there are any letters in the string\n    bool has_letters = false;\n    for (char c : s) {\n        if (isalpha(c)) {\n            has_letters = true;\n            break;\n        }\n    }\n\n    if (!has_letters) {\n        // Reverse the string if there are no letters\n        std::string result = s;\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n\n    // Allocate space for the result\n    std::string result(n, ' ');\n\n    // Process the string in chunks using RVV\n    size_t i = 0;\n    while (i < n) {\n        size_t vl = __riscv_vsetvl_e8m1(n - i);\n        vuint8m1_t input = __riscv_vle8_v_u8m1((const uint8_t*)&s[i], vl);\n        vuint8m1_t output;\n\n        // Check if each character is a letter and reverse its case\n        vbool8_t is_lower = __riscv_vmflt_vx_u8m1_b8(input, 'a', vl) & __riscv_vmsle_vx_u8m1_b8(input, 'z', vl);\n        vbool8_t is_upper = __riscv_vmflt_vx_u8m1_b8(input, 'A', vl) & __riscv_vmsle_vx_u8m1_b8(input, 'Z', vl);\n        vbool8_t is_letter = __riscv_vorr_vv_b8(is_lower, is_upper, vl);\n\n        vuint8m1_t lower_to_upper = __riscv_vsub_vx_u8m1_m(is_lower, input, 'a' - 'A', vl);\n        vuint8m1_t upper_to_lower = __riscv_vadd_vx_u8m1_m(is_upper, input, 'a' - 'A', vl);\n        output = __riscv_vmerge_vvm_u8m1(lower_to_upper, upper_to_lower, is_letter, vl);\n\n        // Keep non-letter characters unchanged\n        output = __riscv_vmerge_vvm_u8m1(output, input, __riscv_vnot_v_b8(is_letter, vl), vl);\n\n        // Store the result\n        __riscv_vse8_v_u8m1((uint8_t*)&result[i], output, vl);\n\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s) {\n    size_t n = s.size();\n    if (n == 0) return s;\n\n    // Check if there are any letters in the string\n    bool has_letters = false;\n    for (char c : s) {\n        if (isalpha(c)) {\n            has_letters = true;\n            break;\n        }\n    }\n\n    if (!has_letters) {\n        // Reverse the string if there are no letters\n        std::string result = s;\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n\n    // Allocate space for the result\n    std::string result(n, ' ');\n\n    // Process the string in chunks using RVV\n    size_t i = 0;\n    while (i < n) {\n        size_t vl = __riscv_vsetvl_e8m1(n - i);\n        vuint8m1_t input = __riscv_vle8_v_u8m1((const uint8_t*)&s[i], vl);\n        vuint8m1_t output;\n\n        // Check if each character is a letter and reverse its case\n        vbool8_t is_lower = __riscv_vmflt_vx_u8m1_b8(input, 'a', vl);\n        vbool8_t is_upper = __riscv_vmflt_vx_u8m1_b8(__riscv_vmv_v_x_u8m1('Z', vl), input, vl);\n        vbool8_t is_letter = __riscv_vor_vv_b8(is_lower, is_upper, vl);\n\n        vuint8m1_t lower_to_upper = __riscv_vsub_vx_u8m1(input, 'a' - 'A', vl);\n        vuint8m1_t upper_to_lower = __riscv_vadd_vx_u8m1(input, 'a' - 'A', vl);\n\n        output = __riscv_vmerge_vvm_u8m1(lower_to_upper, upper_to_lower, is_lower, vl);\n        output = __riscv_vmerge_vvm_u8m1(output, input, is_letter, vl);\n\n        __riscv_vse8_v_u8m1((uint8_t*)&result[i], output, vl);\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s) {\n    size_t n = s.size();\n    if (n == 0) return s;\n\n    // Check if there are any letters in the string\n    bool has_letters = false;\n    for (char c : s) {\n        if (isalpha(c)) {\n            has_letters = true;\n            break;\n        }\n    }\n\n    if (!has_letters) {\n        // Reverse the string if there are no letters\n        std::string result = s;\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n\n    // Allocate space for the result\n    std::string result(n, ' ');\n\n    // Process the string in chunks using RVV\n    size_t i = 0;\n    while (i < n) {\n        size_t vl = __riscv_vsetvl_e8m1(n - i);\n        vuint8m1_t input = __riscv_vle8_v_u8m1((const uint8_t*)&s[i], vl);\n        vuint8m1_t output;\n\n        // Check if each character is a letter and reverse its case\n        vbool8_t is_lower = __riscv_vmflt_vx_u8m1_b8(input, 'a', vl);\n        vbool8_t is_upper = __riscv_vmflt_vx_u8m1_b8(__riscv_vmv_v_x_u8m1('Z', vl), input, vl);\n        vbool8_t is_letter = __riscv_vor_vv_b8(is_lower, is_upper, vl);\n\n        vuint8m1_t lower_to_upper = __riscv_vsub_vx_u8m1(input, 'a' - 'A', vl);\n        vuint8m1_t upper_to_lower = __riscv_vadd_vx_u8m1(input, 'a' - 'A', vl);\n\n        output = __riscv_vmerge_vvm_u8m1(lower_to_upper, upper_to_lower, is_lower, vl);\n        output = __riscv_vmerge_vvm_u8m1(output, input, is_letter, vl);\n\n        __riscv_vse8_v_u8m1((uint8_t*)&result[i], output, vl);\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s) {\n    size_t n = s.size();\n    if (n == 0) return s;\n\n    // Check if there are any letters in the string\n    bool has_letters = false;\n    for (char c : s) {\n        if (isalpha(c)) {\n            has_letters = true;\n            break;\n        }\n    }\n\n    if (!has_letters) {\n        // Reverse the string if there are no letters\n        std::string reversed_s = s;\n        std::reverse(reversed_s.begin(), reversed_s.end());\n        return reversed_s;\n    }\n\n    // Allocate space for the result\n    std::string result(n, ' ');\n\n    // Process the string with RVV intrinsics\n    size_t i = 0;\n    while (i < n) {\n        size_t vl = __riscv_vsetvl_e8m1(n - i);\n        vuint8m1_t input = __riscv_vle8_v_u8m1((const uint8_t*)&s[i], vl);\n        vuint8m1_t output;\n\n        // Check if each character is a letter and reverse its case\n        vbool8_t is_lower = __riscv_vmflt_vx_u8m1_b8(input, 'a', vl);\n        vbool8_t is_upper = __riscv_vmflt_vx_u8m1_b8(__riscv_vmv_v_x_u8m1('Z', vl), input, vl);\n        vbool8_t is_letter = __riscv_vand_vv_b8(is_lower, is_upper, vl);\n\n        vuint8m1_t lower_to_upper = __riscv_vsub_vx_u8m1(input, 'a' - 'A', vl);\n        vuint8m1_t upper_to_lower = __riscv_vadd_vx_u8m1(input, 'a' - 'A', vl);\n\n        output = __riscv_vmerge_vvm_u8m1(lower_to_upper, upper_to_lower, is_lower, vl);\n        output = __riscv_vmerge_vvm_u8m1(output, input, __riscv_vnot_v_b8(is_letter, vl), vl);\n\n        __riscv_vse8_v_u8m1((uint8_t*)&result[i], output, vl);\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s) {\n    size_t n = s.size();\n    if (n == 0) return s;\n\n    // Check if there are any letters in the string\n    bool has_letters = false;\n    for (char c : s) {\n        if (isalpha(c)) {\n            has_letters = true;\n            break;\n        }\n    }\n\n    if (!has_letters) {\n        // Reverse the string if there are no letters\n        std::string result = s;\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n\n    // Allocate space for the result\n    std::string result(n, ' ');\n\n    // Process the string in chunks using RVV\n    size_t i = 0;\n    while (i < n) {\n        size_t vl = __riscv_vsetvl_e8m1(n - i);\n        vuint8m1_t input = __riscv_vle8_v_u8m1((const uint8_t*)&s[i], vl);\n        vuint8m1_t output;\n\n        // Check if each character is a letter and reverse its case\n        vbool8_t is_lower = __riscv_vmflt_vx_u8m1_b8(input, 'a', vl) & __riscv_vmsle_vx_u8m1_b8(input, 'z', vl);\n        vbool8_t is_upper = __riscv_vmflt_vx_u8m1_b8(input, 'A', vl) & __riscv_vmsle_vx_u8m1_b8(input, 'Z', vl);\n        vbool8_t is_letter = __riscv_vorr_vv_b8(is_lower, is_upper, vl);\n\n        vuint8m1_t lower_to_upper = __riscv_vsub_vx_u8m1(input, 'a' - 'A', vl);\n        vuint8m1_t upper_to_lower = __riscv_vadd_vx_u8m1(input, 'a' - 'A', vl);\n\n        output = __riscv_vmerge_vvm_u8m1(__riscv_vmerge_vvm_u8m1(input, upper_to_lower, is_lower, vl), lower_to_upper, is_upper, vl);\n\n        // Store the result\n        __riscv_vse8_v_u8m1((uint8_t*)&result[i], output, vl);\n\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> sorted_thirds;\n    \n    // Collect elements at indices divisible by 3\n    for (size_t i = 0; i < n; i += 3) {\n        sorted_thirds.push_back(l[i]);\n    }\n    \n    // Sort the collected elements\n    std::sort(sorted_thirds.begin(), sorted_thirds.end());\n    \n    // Create a mask for indices divisible by 3\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vbool32_t mask = __riscv_vmseq_vx_i32m1(__riscv_vle32_v_i32m1(l.data(), vl), 0, vl);\n    \n    // Replace elements at indices divisible by 3 with sorted elements\n    vint32m1_t sorted_vec = __riscv_vle32_v_i32m1(sorted_thirds.data(), vl);\n    vint32m1_t result_vec = __riscv_vmerge_vvm_i32m1(mask, sorted_vec, __riscv_vle32_v_i32m1(l.data(), vl), vl);\n    \n    // Store the result back to the vector\n    __riscv_vse32_v_i32m1(l.data(), result_vec, vl);\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_78_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> sorted_thirds;\n    \n    // Collect elements at indices divisible by 3\n    for (size_t i = 0; i < n; i += 3) {\n        sorted_thirds.push_back(l[i]);\n    }\n    \n    // Sort the collected elements\n    std::sort(sorted_thirds.begin(), sorted_thirds.end());\n    \n    // Create a mask for indices divisible by 3\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vbool32_t mask = __riscv_vmseq_vx_i32m1(__riscv_vle32_v_i32m1(l.data(), vl), 0, vl);\n    \n    // Replace elements at indices divisible by 3 with sorted elements\n    vint32m1_t sorted_vec = __riscv_vle32_v_i32m1(sorted_thirds.data(), vl);\n    vint32m1_t result_vec = __riscv_vmerge_vvm_i32m1(mask, sorted_vec, __riscv_vle32_v_i32m1(l.data(), vl), vl);\n    \n    // Store the result back to the vector\n    __riscv_vse32_v_i32m1(l.data(), result_vec, vl);\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_78_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> sorted_thirds;\n    \n    // Collect elements at indices divisible by 3\n    for (size_t i = 0; i < n; i += 3) {\n        sorted_thirds.push_back(l[i]);\n    }\n    \n    // Sort the collected elements\n    std::sort(sorted_thirds.begin(), sorted_thirds.end());\n    \n    // Use RVV to update the original vector with sorted elements at indices divisible by 3\n    vint32m1_t v_sorted = vle32_v_i32m1(sorted_thirds.data(), sorted_thirds.size());\n    for (size_t i = 0; i < n; i += 3) {\n        vse32_v_i32m1(&l[i], v_sorted, 1);\n        v_sorted = vslide1up_vx_i32m1(v_sorted, 0, 1);\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_78_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> sorted_thirds;\n    \n    // Collect elements at indices divisible by 3\n    for (size_t i = 0; i < n; i += 3) {\n        sorted_thirds.push_back(l[i]);\n    }\n    \n    // Sort the collected elements\n    std::sort(sorted_thirds.begin(), sorted_thirds.end());\n    \n    // Use RVV to update the original vector with sorted elements at indices divisible by 3\n    vint32m1_t v_sorted = vle32_v_i32m1(sorted_thirds.data(), sorted_thirds.size());\n    for (size_t i = 0; i < n; i += 3) {\n        vse32_v_i32m1(&l[i], v_sorted, 1);\n        v_sorted = vslide1up_vx_i32m1(v_sorted, 0, 1);\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_78_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result(n);\n    size_t vl;\n\n    // Process elements not divisible by 3 directly\n    for (size_t i = 0; i < n; ++i) {\n        if (i % 3 != 0) {\n            result[i] = l[i];\n        }\n    }\n\n    // Collect elements at indices divisible by 3\n    std::vector<int> divisible_by_three;\n    for (size_t i = 0; i < n; i += 3) {\n        divisible_by_three.push_back(l[i]);\n    }\n\n    // Sort the collected elements\n    std::sort(divisible_by_three.begin(), divisible_by_three.end());\n\n    // Place sorted elements back into their original positions\n    size_t index = 0;\n    for (size_t i = 0; i < n; i += 3) {\n        result[i] = divisible_by_three[index++];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_79_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nfloat max_element_simd(const std::vector<float>& l) {\n    size_t n = l.size();\n    float result = std::numeric_limits<float>::lowest();\n    size_t vlmax = __riscv_vsetvl_e32m8(n);\n\n    vfloat32m8_t v_result = __riscv_vfmv_v_f_f32m8(result, vlmax);\n    const float* ptr = l.data();\n\n    for (size_t i = 0; i < n; i += vlmax) {\n        size_t vl = __riscv_vsetvl_e32m8(n - i);\n        vfloat32m8_t v_data = __riscv_vle32_v_f32m8(ptr + i, vl);\n        v_result = __riscv_vfredmax_vs_f32m8_f32m1(v_data, v_result, vl);\n    }\n\n    return __riscv_vfmv_f_s_f32m1_f32(v_result);\n}\n```"}
{"task_id": "SimdBench_79_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nfloat max_element_simd(std::vector<float> l) {\n    size_t n = l.size();\n    float result = std::numeric_limits<float>::lowest();\n    size_t vlmax = vsetvl_e32m1(n);\n\n    vfloat32m1_t v_max = vle32_v_f32m1(&l[0], vlmax);\n    for (size_t i = vlmax; i < n; i += vlmax) {\n        size_t vl = vsetvl_e32m1(n - i);\n        vfloat32m1_t v_temp = vle32_v_f32m1(&l[i], vl);\n        v_max = vfmax_vv_f32m1(v_max, v_temp, vl);\n    }\n\n    vse32_v_f32m1(&result, vfredmax_vs_f32m1_f32(v_max, result, vlmax), 1);\n    return result;\n}\n```"}
{"task_id": "SimdBench_79_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nfloat max_element_simd(std::vector<float> l) {\n    size_t n = l.size();\n    float result = std::numeric_limits<float>::lowest();\n    size_t vlmax = __riscv_vsetvl_e32m8(n);\n\n    vfloat32m8_t v_max = __riscv_vle32_v_f32m8(&l[0], vlmax);\n    for (size_t i = vlmax; i < n; i += vlmax) {\n        size_t vl = __riscv_vsetvl_e32m8(n - i);\n        vfloat32m8_t v_temp = __riscv_vle32_v_f32m8(&l[i], vl);\n        v_max = __riscv_vfmax_vv_f32m8(v_max, v_temp, vl);\n    }\n\n    __riscv_vse32_v_f32m8(&result, v_max, 1);\n    return result;\n}\n```"}
{"task_id": "SimdBench_79_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nfloat max_element_simd(const std::vector<float>& l) {\n    size_t n = l.size();\n    float result = std::numeric_limits<float>::lowest();\n    size_t vlmax = __riscv_vsetvl_e32m8(n);\n\n    vfloat32m8_t v_result = __riscv_vfmv_v_f_f32m8(result, vlmax);\n    const float* ptr = l.data();\n\n    for (size_t i = 0; i < n; i += vlmax) {\n        size_t vl = __riscv_vsetvl_e32m8(n - i);\n        vfloat32m8_t v_data = __riscv_vle32_v_f32m8(ptr + i, vl);\n        v_result = __riscv_vfredmax_vs_f32m8_f32m1(v_data, v_result, vl);\n    }\n\n    return __riscv_vfmv_f_s_f32m1_f32(v_result);\n}\n```"}
{"task_id": "SimdBench_79_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nfloat max_element_simd(std::vector<float> l) {\n    size_t n = l.size();\n    float result = std::numeric_limits<float>::lowest();\n    size_t vlmax = vsetvl_e32m1(n);\n\n    for (size_t i = 0; i < n; i += vlmax) {\n        size_t vl = vsetvl_e32m1(n - i);\n        vfloat32m1_t vec = vle32_v_f32m1(&l[i], vl);\n        vfloat32m1_t max_vec = vfredmax_vs_f32m1_f32m1(vec, vfmv_s_f_f32m1(result, vl), vl);\n        result = vfmv_f_s_f32m1_f32(max_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_80_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    size_t vlmax = vsetvl_e32m1(n);\n    vbool32_t mask;\n    vint32m1_t vn, v_eleven, v_thirteen, v_seventy, v_zero, v_ones;\n    int i;\n\n    for (i = 0; i < n; i += vlmax) {\n        size_t vl = vsetvl_e32m1(n - i);\n        vn = vid_v_i32m1(vl) + i;\n        v_eleven = vmul_vx_i32m1(vn, 11, vl);\n        v_thirteen = vmul_vx_i32m1(vn, 13, vl);\n        v_seventy = vmul_vx_i32m1(vn, 7, vl);\n        v_zero = vsub_vv_i32m1(vn, vn, vl);\n\n        mask = vmseq_vx_i32m1_b32(v_eleven, 0, vl) & (vmseq_vx_i32m1_b32(vn, v_eleven, vl) | vmseq_vx_i32m1_b32(vn, v_thirteen, vl));\n        v_ones = vmv_v_x_i32m1(1, vl);\n        v_ones = vcompress_vm_i32m1(v_ones, mask, vl);\n        count += vredsum_vs_i32m1_i32(v_ones, 0, vl);\n\n        mask = vmseq_vx_i32m1_b32(v_seventy, 7, vl) & (vmseq_vx_i32m1_b32(vn, v_eleven, vl) | vmseq_vx_i32m1_b32(vn, v_thirteen, vl));\n        v_ones = vmv_v_x_i32m1(1, vl);\n        v_ones = vcompress_vm_i32m1(v_ones, mask, vl);\n        count += vredsum_vs_i32m1_i32(v_ones, 0, vl);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    size_t vlmax = vsetvl_e32m1(n);\n    vbool32_t mask;\n    vint32m1_t vec, div11, div13, sevens;\n    int i;\n\n    for (i = 0; i < n; i += vlmax) {\n        vlmax = vsetvl_e32m1(n - i);\n        vec = vid_v_i32m1(i, 1, vlmax);\n        div11 = vmseq_vx_i32m1_b32(vec, 11, vlmax);\n        div13 = vmseq_vx_i32m1_b32(vec, 13, vlmax);\n        mask = vmvnb_m_b32m1(div11, div13, vlmax);\n        vec = vcompress_vm_i32m1(vec, mask, vlmax);\n\n        size_t valid_elements = vpopc_m_b32_m(vlmax, mask, vlmax);\n        for (size_t j = 0; j < valid_elements; ++j) {\n            int num = vec[j];\n            while (num > 0) {\n                if (num % 10 == 7) {\n                    count++;\n                }\n                num /= 10;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    size_t vlmax = vsetvl_e32m1(n);\n    vint32m1_t vn = vseqiv_e32m1(vlmax);\n    vbool32_t mask_div_11_or_13 = vmorn_m_b32(vmsnez_vx_i32m1_b32(vn, 11, vlmax), vmsnez_vx_i32m1_b32(vn, 13, vlmax), vlmax);\n    vint32m1_t vfiltered = vcompress_vm_e32m1(vn, mask_div_11_or_13, vlmax);\n\n    size_t filtered_vl = vgetvl_e32m1(vfiltered);\n    for (size_t i = 0; i < filtered_vl; ++i) {\n        int num = vfiltered[i];\n        while (num > 0) {\n            if (num % 10 == 7) {\n                count++;\n            }\n            num /= 10;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    size_t vlmax = vsetvl_e32m1(n);\n    vint32m1_t v_seven = vrepl_v_i32m1(7, vlmax);\n    vint32m1_t v_eleven = vrepl_v_i32m1(11, vlmax);\n    vint32m1_t v_thirteen = vrepl_v_i32m1(13, vlmax);\n\n    for (size_t i = 0; i < n; i += vlmax) {\n        size_t vl = vsetvl_e32m1(n - i);\n        vint32m1_t v_index = vid_v_i32m1(vl);\n        vint32m1_t v_offset = vadd_vx_i32m1(v_index, i, vl);\n        vbool4_t v_mask_divisible = vor_vv_b4(vrem_vv_i32m1(v_offset, v_eleven, vl) == vmzero_v_i32m1(vl),\n                                             vrem_vv_i32m1(v_offset, v_thirteen, vl) == vmzero_v_i32m1(vl), vl);\n        vint32m1_t v_filtered = vcompress_vm_i32m1(v_mask_divisible, v_offset, vl);\n        size_t filtered_vl = vpopcnt_m_b4(v_mask_divisible, vl);\n\n        for (size_t j = 0; j < filtered_vl; ++j) {\n            int num = v_filtered[j];\n            while (num > 0) {\n                if (num % 10 == 7) {\n                    count++;\n                }\n                num /= 10;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    int i = 0;\n    size_t vl;\n\n    while (i < n) {\n        vl = vsetvl_e32m8(n - i);\n        vint32m8_t vec = vid_v_i32m8(i, 1, vl);\n        vbool8_t mask1 = vmseq_vx_i32m8_b8(vec, 0, vl);\n        vbool8_t mask2 = vmsle_vx_i32m8_b8(vec, n - 1, vl);\n        vbool8_t mask3 = vmsnez_vx_i32m8_b8(vrem_vx_i32m8(vec, 11, vl), 0, vl);\n        vbool8_t mask4 = vmsnez_vx_i32m8_b8(vrem_vx_i32m8(vec, 13, vl), 0, vl);\n        vbool8_t mask5 = vmseq_vx_i32m8_b8(vpopcnt_v_i8m1(vrgather_vv_i8m1(vreinterpret_v_u8m1_i32m8(vec), vl), vl), 7, vl);\n        vbool8_t mask = vand_vv_b8(mask1, mask2, vl);\n        mask = vand_vv_b8(mask, vorn_vv_b8(mask3, mask4, vl), vl);\n        mask = vand_vv_b8(mask, mask5, vl);\n        count += vcpop_m_b8(mask, vl);\n        i += vl;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_81_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    if (n <= 1) return l;\n\n    // Create a mask for even indices\n    vbool8_t mask = vmseq_vx_i32m1_b8(vseq_i32m1(0, 1, n), 0, n);\n\n    // Gather even-indexed elements\n    std::vector<float> even_elements;\n    for (size_t i = 0; i < n; i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    // Sort the even-indexed elements\n    std::sort(even_elements.begin(), even_elements.end());\n\n    // Scatter the sorted even-indexed elements back into the original vector\n    size_t even_index = 0;\n    for (size_t i = 0; i < n; i++) {\n        if (i % 2 == 0) {\n            l[i] = even_elements[even_index++];\n        }\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_81_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    size_t veclen = __riscv_vsetvl_e32m1(n / 2);\n\n    vfloat32m1_t even_vec = __riscv_vle32_v_f32m1(&l[0], veclen);\n    std::vector<float> even_elements(n / 2);\n    __riscv_vse32_v_f32m1(even_elements.data(), even_vec, veclen);\n\n    std::sort(even_elements.begin(), even_elements.end());\n\n    for (size_t i = 0; i < n / 2; ++i) {\n        l[i * 2] = even_elements[i];\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_81_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    if (n <= 1) return l;\n\n    // Create a mask for even indices\n    vbool8_t mask = vmseq_vx_i32m1_b8(vseq_i32m1(0, 1, n), 0, n);\n\n    // Gather even-indexed elements\n    std::vector<float> even_elements;\n    for (size_t i = 0; i < n; i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    // Sort the even-indexed elements\n    std::sort(even_elements.begin(), even_elements.end());\n\n    // Scatter the sorted even-indexed elements back into the original vector\n    size_t even_index = 0;\n    for (size_t i = 0; i < n; i++) {\n        if (i % 2 == 0) {\n            l[i] = even_elements[even_index++];\n        }\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_81_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    size_t veclen = __riscv_vsetvl_e32m1(n / 2);\n\n    // Create a vector to hold even-indexed elements\n    float even_elements[n / 2];\n    for (size_t i = 0; i < n / 2; ++i) {\n        even_elements[i] = l[i * 2];\n    }\n\n    // Sort the even-indexed elements\n    std::sort(even_elements, even_elements + n / 2);\n\n    // Create a mask for even indices\n    vbool32_t mask = __riscv_vmseq_vx_i32m1(__riscv_vle32_v_i32m1(l.data(), veclen), 0, veclen);\n\n    // Scatter the sorted even elements back into the original vector\n    __riscv_vse32_v_i32m1(__riscv_vcompress_vm_i32m1(__riscv_vle32_v_i32m1(even_elements, veclen), mask, veclen), l.data(), veclen);\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_81_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    if (n <= 1) return l;\n\n    // Create a mask for even indices\n    vbool8_t mask = vmseq_vx_i32m1_b8(vseq_i32m1(0, 1, n), 0, n);\n\n    // Gather even-indexed elements\n    std::vector<float> even_elements;\n    for (size_t i = 0; i < n; i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    // Sort the even-indexed elements\n    std::sort(even_elements.begin(), even_elements.end());\n\n    // Scatter the sorted even-indexed elements back into the original vector\n    size_t even_index = 0;\n    for (size_t i = 0; i < n; i++) {\n        if (i % 2 == 0) {\n            l[i] = even_elements[even_index++];\n        }\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_82_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 3) return false;\n\n    for (size_t i = 0; i < n - 2; ++i) {\n        for (size_t j = i + 1; j < n - 1; ++j) {\n            int vi = l[i];\n            int vj = l[j];\n            int target = -(vi + vj);\n\n            size_t k = j + 1;\n            while (k < n) {\n                size_t vl = __riscv_vsetvl_e32m8(n - k);\n                vint32m8_t vk_vec = __riscv_vle32_v_i32m8(&l[k], vl);\n                vbool8_t mask = __riscv_vmseq_vx_i32m8_b8(vk_vec, target, vl);\n                if (__riscv_vfirst_m_b8(mask, vl) != UINT64_MAX) {\n                    return true;\n                }\n                k += vl;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 3) return false;\n\n    for (size_t i = 0; i < n - 2; ++i) {\n        for (size_t j = i + 1; j < n - 1; ++j) {\n            int target = -(l[i] + l[j]);\n            size_t k = j + 1;\n            size_t vl = __riscv_vsetvl_e32m1(n - k);\n            vint32m1_t vec = __riscv_vle32_v_i32m1(&l[k], vl);\n            vbool4_t mask = __riscv_vmseq_vx_i32m1_b4(vec, target, vl);\n            if (__riscv_vfirst_m_b4(mask, vl) != UINT32_MAX) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 3) return false;\n\n    for (size_t i = 0; i < n - 2; ++i) {\n        for (size_t j = i + 1; j < n - 1; ++j) {\n            int vi = l[i];\n            int vj = l[j];\n            int target = -(vi + vj);\n\n            size_t k = j + 1;\n            while (k < n) {\n                size_t vl = __riscv_vsetvl_e32m8(n - k);\n                vint32m8_t vk_vec = __riscv_vle32_v_i32m8(&l[k], vl);\n                vbool8_t mask = __riscv_vmseq_vx_i32m8_b8(vk_vec, target, vl);\n                if (__riscv_vfirst_m_b8(mask, vl) != UINT64_MAX) {\n                    return true;\n                }\n                k += vl;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 3) return false;\n\n    for (size_t i = 0; i < n - 2; ++i) {\n        for (size_t j = i + 1; j < n - 1; ++j) {\n            int vi = l[i];\n            int vj = l[j];\n            int target = -(vi + vj);\n\n            size_t k = j + 1;\n            while (k < n) {\n                size_t vl = __riscv_vsetvl_e32m8(n - k);\n                vint32m8_t vk_vec = __riscv_vle32_v_i32m8(&l[k], vl);\n                vbool8_t mask = __riscv_vmseq_vx_i32m8_b8(vk_vec, target, vl);\n                if (__riscv_vfirst_m_b8(mask, vl) != UINT64_MAX) {\n                    return true;\n                }\n                k += vl;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 3) return false;\n\n    for (size_t i = 0; i < n - 2; ++i) {\n        for (size_t j = i + 1; j < n - 1; ++j) {\n            int target = -(l[i] + l[j]);\n            size_t k = j + 1;\n            size_t vl = __riscv_vsetvl_e32m1(n - k);\n            vint32m1_t vec = __riscv_vle32_v_i32m1(&l[k], vl);\n            vbool4_t mask = __riscv_vmseq_vx_i32m1_b4(vec, target, vl);\n            if (__riscv_vfirst_m_b4(mask, vl) != UINT32_MAX) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_83_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result(n);\n    size_t vl;\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m8(n - i);\n        vint32m8_t vec = vle32_v_i32m8(&l[i], vl);\n        vint32m8_t inc_vec = vadd_vx_i32m8(vec, 1, vl);\n        vse32_v_i32m8(&result[i], inc_vec, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result(n);\n    size_t vl = __riscv_vsetvl_e32m8(n);\n\n    vint32m8_t vec_in = __riscv_vle32_v_i32m8(l.data(), vl);\n    vint32m8_t vec_inc = __riscv_vadd_vx_i32m8(vec_in, 1, vl);\n    __riscv_vse32_v_i32m8(result.data(), vec_inc, vl);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result(n);\n\n    // Determine the number of elements per segment\n    size_t vl = __riscv_vsetvl_e32m8(n);\n\n    // Create a vector from the input array\n    vint32m8_t in_vec = __riscv_vle32_v_i32m8(l.data(), vl);\n\n    // Increment each element by 1\n    vint32m8_t incr_vec = __riscv_vadd_vx_i32m8(in_vec, 1, vl);\n\n    // Store the result back to the output array\n    __riscv_vse32_v_i32m8(result.data(), incr_vec, vl);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result(n);\n    size_t vl = __riscv_vsetvl_e32m8(n);\n\n    vint32m8_t vec_in = __riscv_vle32_v_i32m8(l.data(), vl);\n    vint32m8_t vec_inc = __riscv_vadd_vx_i32m8(vec_in, 1, vl);\n    __riscv_vse32_v_i32m8(result.data(), vec_inc, vl);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result(n);\n\n    // Determine the number of elements per segment\n    size_t vl = __riscv_vsetvl_e32m8(n);\n\n    // Create a vector from the input list\n    vint32m8_t in_vec = __riscv_vle32_v_i32m8(l.data(), vl);\n\n    // Increment each element by 1\n    vint32m8_t incr_vec = __riscv_vadd_vx_i32m8(in_vec, 1, vl);\n\n    // Store the result back to the output list\n    __riscv_vse32_v_i32m8(result.data(), incr_vec, vl);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_84_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 2) return false;\n\n    for (size_t i = 0; i < n; ++i) {\n        int target = -l[i];\n        size_t vl = __riscv_vsetvl_e32m1(n - i - 1);\n        vint32m1_t vec = __riscv_vle32_v_i32m1(&l[i + 1], vl);\n        vbool1_t mask = __riscv_vmseq_vx_i32m1_b1(vec, target, vl);\n        if (__riscv_vfirst_m_b1(mask, vl) != UINT64_MAX) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 2) return false;\n\n    for (size_t i = 0; i < n; ++i) {\n        int val = l[i];\n        size_t vl = __riscv_vsetvl_e32m1(n - i - 1);\n        vint32m1_t vec = __riscv_vle32_v_i32m1(&l[i + 1], vl);\n        vint32m1_t neg_vec = __riscv_vneg_v_i32m1(vec, vl);\n        vbool1_t mask = __riscv_vmseq_vx_i32m1_b1(neg_vec, val, vl);\n        if (__riscv_vfirst_m_b1(mask, vl) != UINT64_MAX) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 2) return false;\n\n    for (size_t i = 0; i < n; ++i) {\n        int target = -l[i];\n        size_t vl = __riscv_vsetvl_e32m1(n - i - 1);\n        vint32m1_t vec = __riscv_vle32_v_i32m1(&l[i + 1], vl);\n        vbool1_t mask = __riscv_vmseq_vx_i32m1_b1(vec, target, vl);\n        if (__riscv_vfirst_m_b1(mask, vl) != UINT64_MAX) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 2) return false;\n\n    for (size_t i = 0; i < n; ++i) {\n        int val = l[i];\n        size_t vl = __riscv_vsetvl_e32m1(n - i - 1);\n        vint32m1_t vec = __riscv_vle32_v_i32m1(&l[i + 1], vl);\n        vint32m1_t neg_vec = __riscv_vneg_v_i32m1(vec, vl);\n        vbool1_t mask = __riscv_vmseq_vx_i32m1_b1(neg_vec, val, vl);\n        if (__riscv_vfirst_m_b1(mask, vl) != UINT64_MAX) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 2) return false;\n\n    for (size_t i = 0; i < n; ++i) {\n        int target = -l[i];\n        size_t vl = __riscv_vsetvl_e32m1(n - i - 1);\n        vint32m1_t vec = __riscv_vle32_v_i32m1(&l[i + 1], vl);\n        vbool1_t mask = __riscv_vmseq_vx_i32m1_b1(vec, target, vl);\n        if (__riscv_vfirst_m_b1(mask, vl) != UINT64_MAX) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_85_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <cstring>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    char result[65]; // Assuming max 64 bits for int64_t in binary\n    int pos = 64;\n    result[pos] = '\\0';\n\n    vint8m1_t v_base = vmv_v_x_i8m1(base, 1);\n    vint8m1_t v_zero = vmv_v_x_i8m1(0, 1);\n    vint8m1_t v_one = vmv_v_x_i8m1(1, 1);\n\n    while (x > 0) {\n        pos--;\n        vint8m1_t v_x = vmv_v_x_i8m1(x % base, 1);\n        result[pos] = v_x[0] + '0';\n        x /= base;\n    }\n\n    return std::string(result + pos);\n}\n```"}
{"task_id": "SimdBench_85_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <cstring>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    char result[65]; // Assuming max 64 bits for int64_t in binary\n    int pos = 64;\n    result[pos] = '\\0';\n\n    vint8m1_t v_base = vmv_v_x_i8m1(base, 1);\n    vint8m1_t v_zero = vmv_v_x_i8m1(0, 1);\n    vint8m1_t v_one = vmv_v_x_i8m1(1, 1);\n\n    while (x > 0) {\n        pos--;\n        vint8m1_t v_x = vmv_v_x_i8m1(x % base, 1);\n        result[pos] = v_x[0] + '0';\n        x /= base;\n    }\n\n    return std::string(result + pos);\n}\n```"}
{"task_id": "SimdBench_85_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <cstring>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    char result[65]; // Assuming max 64 bits for int64_t in binary\n    int pos = 64;\n    result[pos] = '\\0';\n\n    vint8m1_t v_base = vmv_v_x_i8m1(base, 1);\n    vint8m1_t v_zero = vmv_v_x_i8m1(0, 1);\n    vint8m1_t v_one = vmv_v_x_i8m1(1, 1);\n\n    while (x > 0) {\n        pos--;\n        int remainder = x % base;\n        result[pos] = '0' + remainder;\n        x /= base;\n    }\n\n    return std::string(result + pos);\n}\n```"}
{"task_id": "SimdBench_85_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <cstring>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    char result[65]; // Assuming max 64 bits for int64_t in binary\n    int pos = 64;\n    result[pos] = '\\0';\n\n    vint8m1_t v_base = vmv_v_x_i8m1(base, 1);\n    vint8m1_t v_zero = vmv_v_x_i8m1(0, 1);\n    vint8m1_t v_one = vmv_v_x_i8m1(1, 1);\n\n    while (x > 0) {\n        pos--;\n        vint8m1_t v_x = vmv_v_x_i8m1(x % base, 1);\n        result[pos] = v_x[0] + '0';\n        x /= base;\n    }\n\n    return std::string(result + pos);\n}\n```"}
{"task_id": "SimdBench_85_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <cstring>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    const int max_digits = 64; // Maximum digits for base 2 representation of int64_t\n    char result[max_digits];\n    int pos = max_digits - 1;\n    result[pos] = '\\0';\n\n    vint8m1_t v_base = vmv_v_x_i8m1(base, 1);\n    vint8m1_t v_zero = vmv_v_x_i8m1(0, 1);\n    vint8m1_t v_one = vmv_v_x_i8m1(1, 1);\n\n    while (x > 0) {\n        int8_t remainder = x % base;\n        result[--pos] = remainder + '0';\n        x /= base;\n    }\n\n    return std::string(&result[pos]);\n}\n```"}
{"task_id": "SimdBench_86_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    size_t n = text.size();\n    if (n <= 1) return true;\n\n    size_t i = 0;\n    size_t j = n - 1;\n\n    while (i < j) {\n        size_t vl = __riscv_vsetvl_e8m1(j - i + 1);\n        vuint8m1_t vec1 = __riscv_vle8_v_u8m1(&text[i], vl);\n        vuint8m1_t vec2 = __riscv_vle8_v_u8m1(&text[j - vl + 1], vl);\n        vbool1_t mask = __riscv_vmsne_vv_u8m1_b1(vec1, vec2, vl);\n\n        if (__riscv_vfirst_m_b1(mask, vl) != -1) {\n            return false;\n        }\n\n        i += vl;\n        j -= vl;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    size_t n = text.size();\n    if (n <= 1) return true;\n\n    size_t i = 0;\n    size_t j = n - 1;\n\n    while (i < j) {\n        size_t vl = __riscv_vsetvl_e8m1(j - i + 1);\n        vuint8m1_t vec1 = __riscv_vle8_v_u8m1(&text[i], vl);\n        vuint8m1_t vec2 = __riscv_vle8_v_u8m1(&text[j - vl + 1], vl);\n        vbool1_t mask = __riscv_vmsne_vv_u8m1_b1(vec1, vec2, vl);\n\n        if (__riscv_vfirst_m_b1(mask, vl) != UINT64_MAX) {\n            return false;\n        }\n\n        i += vl;\n        j -= vl;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    size_t n = text.size();\n    if (n <= 1) return true;\n\n    size_t i = 0;\n    size_t j = n - 1;\n\n    while (i < j) {\n        size_t vl = __riscv_vsetvl_e8m1(j - i + 1);\n        vuint8m1_t vec1 = __riscv_vle8_v_u8m1(&text[i], vl);\n        vuint8m1_t vec2 = __riscv_vle8_v_u8m1(&text[j - vl + 1], vl);\n        vbool1_t mask = __riscv_vmsne_vv_u8m1_b1(vec1, vec2, vl);\n\n        if (__riscv_vfirst_m_b1(mask, vl) != UINT64_MAX) {\n            return false;\n        }\n\n        i += vl;\n        j -= vl;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    size_t n = text.size();\n    if (n <= 1) return true;\n\n    size_t i = 0;\n    size_t j = n - 1;\n\n    while (i < j) {\n        size_t vl = __riscv_vsetvl_e8m1(j - i + 1);\n        vuint8m1_t vec1 = __riscv_vle8_v_u8m1(&text[i], vl);\n        vuint8m1_t vec2 = __riscv_vle8_v_u8m1(&text[j - vl + 1], vl);\n        vbool1_t mask = __riscv_vmsne_vv_u8m1_b1(vec1, vec2, vl);\n\n        if (__riscv_vfirst_m_b1(mask, vl) < vl) {\n            return false;\n        }\n\n        i += vl;\n        j -= vl;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    size_t n = text.size();\n    if (n <= 1) return true;\n\n    size_t i = 0;\n    size_t j = n - 1;\n\n    while (i < j) {\n        size_t vl = __riscv_vsetvl_e8m1(j - i + 1);\n        vuint8m1_t vec1 = __riscv_vle8_v_u8m1(&text[i], vl);\n        vuint8m1_t vec2 = __riscv_vle8_v_u8m1(&text[j - vl + 1], vl);\n        vbool1_t mask = __riscv_vmsne_vv_u8m1_b1(vec1, vec2, vl);\n\n        if (__riscv_vfirst_m_b1(mask, vl) != UINT64_MAX) {\n            return false;\n        }\n\n        i += vl;\n        j -= vl;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_87_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    size_t len = s.length();\n    std::string out(len, ' ');\n\n    size_t vlmax = __riscv_vsetvl_e8m1(len);\n    vuint8m1_t vec_in, vec_out;\n    vint8m1_t vec_shifted;\n\n    for (size_t i = 0; i < len; i += vlmax) {\n        vlmax = __riscv_vsetvl_e8m1(len - i);\n        vec_in = __riscv_vle8_v_u8m1((const uint8_t*)&s[i], vlmax);\n        vec_shifted = __riscv_vsub_vx_i8m1(vec_in, 5, vlmax);\n        vec_shifted = __riscv_vadd_vx_i8m1(__riscv_vmerge_vvm_i8m1(__riscv_vgt_vx_i8m1(vec_shifted, -(int)'a', vlmax), __riscv_vadd_vi8m1(vec_shifted, 26, vlmax), vec_shifted, vlmax), (int)'a', vlmax);\n        __riscv_vse8_v_u8m1((uint8_t*)&out[i], vec_out, vlmax);\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    size_t len = s.length();\n    std::string out(len, ' ');\n\n    size_t vlmax = __riscv_vsetvl_e8m1(len);\n    vuint8m1_t vec_in, vec_out;\n    vint8m1_t vec_shifted;\n\n    for (size_t i = 0; i < len; i += vlmax) {\n        vlmax = __riscv_vsetvl_e8m1(len - i);\n        vec_in = __riscv_vle8_v_u8m1((const uint8_t*)&s[i], vlmax);\n        vec_shifted = __riscv_vsub_vx_i8m1(vec_in, 5, vlmax);\n        vec_shifted = __riscv_vadd_vx_i8m1(__riscv_vmerge_vvm_i8m1(__riscv_vgt_vx_i8m1(vec_shifted, -(int)'a', vlmax), vec_shifted, __riscv_vadd_vi8m1(__riscv_vmv_v_x_i8m1(-(int)'a', vlmax), 26, vlmax), vlmax), (int)'a', vlmax);\n        __riscv_vse8_v_u8m1((uint8_t*)&out[i], vec_out, vlmax);\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    size_t len = s.length();\n    std::string out(len, ' ');\n\n    size_t vlmax = __riscv_vsetvl_e8m1(len);\n    vuint8m1_t vec_in, vec_out;\n    vint8m1_t vec_shifted;\n\n    for (size_t i = 0; i < len; i += vlmax) {\n        vlmax = __riscv_vsetvl_e8m1(len - i);\n        vec_in = __riscv_vle8_v_u8m1((const uint8_t*)&s[i], vlmax);\n        vec_shifted = __riscv_vsub_vx_i8m1(vec_in, 5, vlmax);\n        vec_shifted = __riscv_vadd_vx_i8m1(__riscv_vmerge_vvm_i8m1(__riscv_vgt_vx_i8m1(vec_shifted, 'a' - 1, vlmax), vec_shifted, __riscv_vadd_vi8m1(__riscv_vmv_v_x_i8m1('z', vlmax), 1 - ('a' - 1), vlmax), vlmax), 'a' - 1, vlmax);\n        vec_out = __riscv_vreinterpret_v_u8m1_i8m1(vec_shifted);\n        __riscv_vse8_v_u8m1((uint8_t*)&out[i], vec_out, vlmax);\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    size_t len = s.length();\n    std::string out(len, ' ');\n\n    size_t vlmax = __riscv_vsetvl_e8m1(len);\n    vuint8m1_t vec_in, vec_out;\n    vint8m1_t vec_shifted;\n\n    for (size_t i = 0; i < len; i += vlmax) {\n        vlmax = __riscv_vsetvl_e8m1(len - i);\n        vec_in = __riscv_vle8_v_u8m1((const uint8_t*)&s[i], vlmax);\n        vec_shifted = __riscv_vsub_vx_i8m1(vec_in, 5, vlmax);\n        vec_shifted = __riscv_vadd_vx_i8m1(__riscv_vmerge_vvm_i8m1(__riscv_vgt_vx_i8m1(vec_shifted, -(int)'a', vlmax), vec_shifted, __riscv_vadd_vi_i8m1(__riscv_vmv_v_x_i8m1(-(int)'a', vlmax), 26, vlmax), vlmax), (int)'a', vlmax);\n        __riscv_vse8_v_u8m1((uint8_t*)&out[i], vec_out, vlmax);\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    size_t len = s.length();\n    std::string out(len, ' ');\n\n    size_t vlmax = __riscv_vsetvl_e8m1(len);\n    vuint8m1_t vec_in, vec_out;\n    vint8m1_t vec_shifted;\n\n    for (size_t i = 0; i < len; i += vlmax) {\n        vlmax = __riscv_vsetvl_e8m1(len - i);\n        vec_in = __riscv_vle8_v_u8m1((const uint8_t*)&s[i], vlmax);\n        vec_shifted = __riscv_vsub_vx_i8m1(vec_in, 5, vlmax);\n        vec_shifted = __riscv_vadd_vx_i8m1(__riscv_vmerge_vvm_i8m1(__riscv_vgt_vx_i8m1(vec_shifted, 'a' - 1, vlmax), vec_shifted, __riscv_vadd_vi8m1(__riscv_vmv_v_x_i8m1('z', vlmax), 1 - ('a' - 1), vlmax), vlmax), 'a' - 1, vlmax);\n        vec_out = __riscv_vreinterpret_v_u8m1_i8m1(vec_shifted);\n        __riscv_vse8_v_u8m1((uint8_t*)&out[i], vec_out, vlmax);\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_88_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    size_t n = l.size();\n    bool result = true;\n\n    // Determine the number of elements per segment\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    // Create a mask for comparison\n    vbool32_t mask = __riscv_vmseq_vx_i32m1(__riscv_vle32_v_i32m1(l.data(), vl), t, vl);\n\n    // Check if all elements are below the threshold\n    if (__riscv_vfirst_m_b32(mask, vl) == -1) {\n        result = false;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_88_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    size_t n = l.size();\n    bool result = true;\n\n    // Determine the number of elements per segment\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    // Create a mask for comparison\n    vbool32_t mask = __riscv_vmseq_vx_i32m1(__riscv_vle32_v_i32m1(l.data(), vl), t, vl);\n\n    // Check if all elements are below the threshold\n    result = __riscv_vmsof_m_b32(mask, vl);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_88_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    size_t n = l.size();\n    bool result = true;\n\n    // Determine the number of elements per segment\n    size_t vl = __riscv_vsetvl_e32m8(n);\n\n    // Create a mask for comparison\n    vbool8_t mask = __riscv_vmseq_vx_i32m8_b8(__riscv_vle32_v_i32m8(l.data(), vl), t, vl);\n\n    // Check if all elements are below the threshold\n    if (__riscv_vfirst_m_b8(mask, vl) == -1) {\n        result = false;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_88_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    size_t n = l.size();\n    bool result = true;\n\n    // Determine the number of elements per segment\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    // Create a mask for comparison\n    vbool32_t mask = __riscv_vmseq_vx_i32m1(__riscv_vle32_v_i32m1(l.data(), vl), t, vl);\n\n    // Check if all elements are below the threshold\n    result = __riscv_vmsof_m_b32(mask, vl);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_88_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    size_t n = l.size();\n    bool result = true;\n\n    // Determine the number of elements per segment\n    size_t vl = __riscv_vsetvl_e32m8(n);\n\n    // Create a mask for comparison\n    vbool8_t mask = __riscv_vmseq_vx_i32m8_b8(__riscv_vle32_v_i32m8(l.data(), vl), t, vl);\n\n    // Check if all elements are below the threshold\n    if (__riscv_vfirst_m_b8(mask, vl) == -1) {\n        result = false;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_89_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t n = brackets.size();\n    if (n == 0) return true;\n\n    int balance = 0;\n    size_t vl = __riscv_vsetvl_e8m1(n);\n\n    vint8m1_t v_balance = __riscv_vmv_v_x_i8m1(0, vl);\n    vbool1_t vmask;\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e8m1(n - i);\n        vint8m1_t v_brackets = __riscv_vle8_v_i8m1(reinterpret_cast<const uint8_t*>(brackets.data() + i), vl);\n        vint8m1_t v_open = __riscv_vmseq_vx_i8m1_b1(v_brackets, '<', vl);\n        vint8m1_t v_close = __riscv_vmseq_vx_i8m1_b1(v_brackets, '>', vl);\n\n        vint8m1_t v_diff = __riscv_vsub_vv_i8m1(v_open, v_close, vl);\n        v_balance = __riscv_vwredsum_vs_i8m1_i16m1(v_diff, v_balance, vl);\n\n        balance = __riscv_vmv_x_s_i16m1_i16(v_balance);\n        if (balance < 0) return false;\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t n = brackets.size();\n    if (n == 0) return true;\n\n    int balance = 0;\n    size_t vl = __riscv_vsetvl_e8m1(n);\n\n    vint8m1_t v_balance = __riscv_vmv_v_x_i8m1(0, vl);\n    vbool1_t vmask;\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e8m1(n - i);\n        vint8m1_t v_brackets = __riscv_vle8_v_i8m1(reinterpret_cast<const uint8_t*>(brackets.data() + i), vl);\n        vint8m1_t v_open = __riscv_vmseq_vx_i8m1_b1(v_brackets, '<', vl);\n        vint8m1_t v_close = __riscv_vmseq_vx_i8m1_b1(v_brackets, '>', vl);\n\n        vint8m1_t v_diff = __riscv_vsub_vv_i8m1(v_open, v_close, vl);\n        v_balance = __riscv_vwredsum_vs_i8m1_i16m1(v_diff, v_balance, vl);\n\n        balance = __riscv_vmv_x_s_i16m1_i16(v_balance);\n        if (balance < 0) return false;\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t n = brackets.size();\n    if (n == 0) return true;\n\n    int balance = 0;\n    size_t vl = __riscv_vsetvl_e8m1(n);\n\n    vint8m1_t v_balance = __riscv_vmv_v_x_i8m1(0, vl);\n    vbool1_t vmask;\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e8m1(n - i);\n        vint8m1_t v_brackets = __riscv_vle8_v_i8m1(reinterpret_cast<const uint8_t*>(brackets.data() + i), vl);\n        vint8m1_t v_open = __riscv_vmseq_vx_i8m1_b1(v_brackets, '<', vl);\n        vint8m1_t v_close = __riscv_vmseq_vx_i8m1_b1(v_brackets, '>', vl);\n\n        v_balance = __riscv_vadd_vv_i8m1(v_balance, __riscv_vsub_vv_i8m1(v_open, v_close, vl), vl);\n\n        vmask = __riscv_vmslt_vx_i8m1_b1(v_balance, 0, vl);\n        if (__riscv_vfirst_m_b1(vmask, vl) < vl) {\n            return false;\n        }\n    }\n\n    return __riscv_vmv_x_s_i8m1_i8(__riscv_vredsum_vs_i8m1_i16m1(v_balance, 0, vl)) == 0;\n}\n```"}
{"task_id": "SimdBench_89_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t n = brackets.size();\n    if (n == 0) return true;\n\n    int balance = 0;\n    size_t vl = __riscv_vsetvl_e8m1(n);\n\n    vint8m1_t v_balance = __riscv_vmv_v_x_i8m1(0, vl);\n    vbool1_t vmask;\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e8m1(n - i);\n        vint8m1_t v_brackets = __riscv_vle8_v_i8m1(reinterpret_cast<const uint8_t*>(brackets.data() + i), vl);\n        vint8m1_t v_open = __riscv_vmseq_vx_i8m1_b1(v_brackets, '<', vl);\n        vint8m1_t v_close = __riscv_vmseq_vx_i8m1_b1(v_brackets, '>', vl);\n\n        vint8m1_t v_diff = __riscv_vsub_vv_i8m1(v_open, v_close, vl);\n        v_balance = __riscv_vwredsum_vs_i8m1_i16m1(v_diff, v_balance, vl);\n\n        balance = __riscv_vmv_x_s_i16m1_i16(v_balance);\n        if (balance < 0) return false;\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t n = brackets.size();\n    if (n == 0) return true;\n\n    int balance = 0;\n    size_t vl = __riscv_vsetvl_e8m1(n);\n\n    vint8m1_t v_balance = __riscv_vmv_v_x_i8m1(0, vl);\n    vbool1_t vmask;\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e8m1(n - i);\n        vint8m1_t v_brackets = __riscv_vle8_v_i8m1(reinterpret_cast<const uint8_t*>(brackets.data() + i), vl);\n        vint8m1_t v_open = __riscv_vmseq_vx_i8m1_b1(v_brackets, '<', vl);\n        vint8m1_t v_close = __riscv_vmseq_vx_i8m1_b1(v_brackets, '>', vl);\n\n        vint8m1_t v_diff = __riscv_vsub_vv_i8m1(v_open, v_close, vl);\n        v_balance = __riscv_vwredsum_vs_i8m1_i16m1(v_diff, v_balance, vl);\n\n        balance = __riscv_vmv_x_s_i16m1_i16(v_balance);\n        if (balance < 0) return false;\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t n = brackets.size();\n    int balance = 0;\n    size_t vl;\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e8m1(n - i);\n        vint8m1_t vec = __riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(brackets.data() + i), vl);\n        vint8m1_t ones = __riscv_vmv_v_x_i8m1(1, vl);\n        vint8m1_t neg_ones = __riscv_vmv_v_x_i8m1(-1, vl);\n        vbool1_t mask_open = __riscv_vmseq_vx_i8m1_b1(vec, '(', vl);\n        vbool1_t mask_close = __riscv_vmseq_vx_i8m1_b1(vec, ')', vl);\n        vint8m1_t inc = __riscv_vmerge_vvm_i8m1(ones, neg_ones, mask_open, mask_close, vl);\n        balance += __riscv_vredsum_vs_i8m1_i32m1(inc, 0, vl);\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t n = brackets.size();\n    int balance = 0;\n    size_t vl;\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e8m1(n - i);\n        vint8m1_t vec = __riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(brackets.data() + i), vl);\n        vint8m1_t ones = __riscv_vmv_v_x_i8m1(1, vl);\n        vint8m1_t neg_ones = __riscv_vmv_v_x_i8m1(-1, vl);\n        vbool1_t mask_open = __riscv_vmseq_vx_i8m1_b1(vec, '(', vl);\n        vbool1_t mask_close = __riscv_vmseq_vx_i8m1_b1(vec, ')', vl);\n        vint8m1_t inc = __riscv_vmerge_vvm_i8m1(ones, neg_ones, mask_open, mask_close, vl);\n        int sum = __riscv_vredsum_vs_i8m1_i32m1(inc, 0, vl);\n        balance += sum;\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t n = brackets.size();\n    int balance = 0;\n    size_t vl;\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e8m1(n - i);\n        vint8m1_t vec = vle8_v_i8m1(reinterpret_cast<const int8_t*>(brackets.data() + i), vl);\n        vint8m1_t ones = vmseq_vx_i8m1_b8(vec, '(', vl);\n        vint8m1_t neg_ones = vmseq_vx_i8m1_b8(vec, ')', vl);\n        vint8m1_t diff = vsub_vv_i8m1(ones, neg_ones, vl);\n        vint32m1_t sum = vredsum_vs_i8m1_i32m1(diff, 0, vl);\n\n        balance += vfirst_m_i32m1(sum, vl);\n\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t n = brackets.size();\n    int balance = 0;\n    size_t vl;\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e8m1(n - i);\n        vint8m1_t vec = vle8_v_i8m1(&brackets[i], vl);\n        vint8m1_t ones = vmseq_vx_i8m1_b8(vec, '(', vl);\n        vint8m1_t neg_ones = vmseq_vx_i8m1_b8(vec, ')', vl);\n        vint8m1_t diff = vsub_vv_i8m1(ones, neg_ones, vl);\n        vint32m1_t sum = vredsum_vs_i8m1_i32m1(diff, 0, vl);\n\n        balance += vfirst_m_i32m1(sum, vl);\n\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t n = brackets.size();\n    int balance = 0;\n    size_t vl;\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e8m1(n - i);\n        vint8m1_t vec = __riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(brackets.data() + i), vl);\n        vint8m1_t ones = __riscv_vmv_v_x_i8m1(1, vl);\n        vint8m1_t neg_ones = __riscv_vmv_v_x_i8m1(-1, vl);\n        vbool1_t mask_open = __riscv_vmseq_vx_i8m1_b1(vec, '(', vl);\n        vbool1_t mask_close = __riscv_vmseq_vx_i8m1_b1(vec, ')', vl);\n        vint8m1_t inc = __riscv_vmerge_vvm_i8m1(ones, neg_ones, mask_open, mask_close, vl);\n        balance += __riscv_vredsum_vs_i8m1_i32m1(inc, 0, vl);\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_91_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs){\n    size_t n = xs.size();\n    if (n <= 1) return {};\n\n    std::vector<float> result(n - 1);\n    size_t i = 0;\n    size_t vl = __riscv_vsetvl_e32m8(n - 1);\n\n    vfloat32m8_t v_xs = __riscv_vle32_v_f32m8(&xs[1], vl);\n    vint32m8_t v_indices = __riscv_vseqi_v_i32m8(1, vl);\n    vfloat32m8_t v_result = __riscv_vfmul_vv_f32m8(v_xs, v_indices, vl);\n\n    __riscv_vse32_v_f32m8(&result[0], v_result, vl);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs){\n    size_t n = xs.size();\n    if (n <= 1) return {};\n\n    std::vector<float> result(n - 1);\n    size_t i = 0;\n    size_t vl = __riscv_vsetvl_e32m8(n - 1);\n\n    vfloat32m8_t v_xs = __riscv_vle32_v_f32m8(&xs[1], vl);\n    vfloat32m8_t v_indices = __riscv_vseq_vf_i32m8_f32m8(1, vl);\n    vfloat32m8_t v_result = __riscv_vfmul_vv_f32m8(v_xs, v_indices, vl);\n\n    __riscv_vse32_v_f32m8(&result[0], v_result, vl);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs){\n    size_t n = xs.size();\n    if (n <= 1) return {};\n\n    std::vector<float> result(n - 1);\n    size_t i = 0;\n    size_t vl = __riscv_vsetvl_e32m8(n - 1);\n\n    vfloat32m8_t v_xs = __riscv_vle32_v_f32m8(&xs[1], vl);\n    vfloat32m8_t v_indices = __riscv_vseq_vf_i32m8_f32m8(1, vl);\n    vfloat32m8_t v_result = __riscv_vfmul_vv_f32m8(v_xs, v_indices, vl);\n\n    __riscv_vse32_v_f32m8(&result[0], v_result, vl);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs){\n    size_t n = xs.size();\n    if (n <= 1) return {};\n\n    std::vector<float> result(n - 1);\n    size_t i = 0;\n    size_t vl = __riscv_vsetvl_e32m8(n - 1);\n\n    vfloat32m8_t v_xs = __riscv_vle32_v_f32m8(&xs[1], vl);\n    vint32m8_t v_indices = __riscv_vseqi_v_i32m8(1, vl);\n    vfloat32m8_t v_result = __riscv_vfmul_vv_f32m8(v_xs, v_indices, vl);\n\n    __riscv_vse32_v_f32m8(&result[0], v_result, vl);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    size_t n = xs.size();\n    if (n <= 1) return {};\n\n    std::vector<float> result(n - 1);\n    size_t i = 0;\n\n    // Determine the maximum vector length supported\n    size_t vl = __riscv_vsetvl_e32m8(n - 1);\n\n    // Load coefficients starting from the second one\n    vfloat32m8_t v_xs = __riscv_vle32_v_f32m8(&xs[1], vl);\n    // Create a vector with multipliers 1, 2, 3, ...\n    vfloat32m8_t v_multipliers = __riscv_vseq_v_f32m8(vl, 1);\n\n    // Multiply coefficients by their respective powers\n    vfloat32m8_t v_result = __riscv_vfmul_vv_f32m8(v_xs, v_multipliers, vl);\n\n    // Store the result\n    __riscv_vse32_v_f32m8(&result[0], v_result, vl);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_92_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <cstring>\n\nint vowels_count_simd(const std::string s) {\n    int count = 0;\n    size_t len = s.length();\n    const char* str = s.c_str();\n\n    // Define a vector of characters to compare against vowels\n    vuint8m1_t vowels = vmv_v_x_u8m1('a', 8);\n    vowels = vslide1up_vx_u8m1(vowels, 'e', 8);\n    vowels = vslide1up_vx_u8m1(vowels, 'i', 8);\n    vowels = vslide1up_vx_u8m1(vowels, 'o', 8);\n    vowels = vslide1up_vx_u8m1(vowels, 'u', 8);\n\n    size_t i = 0;\n    for (; i <= len - 8; i += 8) {\n        vuint8m1_t vec = vle8_v_u8m1((const uint8_t*)&str[i], 8);\n        vbool4_t mask_a = vmseq_vx_u8m1_b4(vec, 'a', 8);\n        vbool4_t mask_e = vmseq_vx_u8m1_b4(vec, 'e', 8);\n        vbool4_t mask_i = vmseq_vx_u8m1_b4(vec, 'i', 8);\n        vbool4_t mask_o = vmseq_vx_u8m1_b4(vec, 'o', 8);\n        vbool4_t mask_u = vmseq_vx_u8m1_b4(vec, 'u', 8);\n\n        vbool4_t mask = vor_vv_b4(mask_a, mask_e, 8);\n        mask = vor_vv_b4(mask, mask_i, 8);\n        mask = vor_vv_b4(mask, mask_o, 8);\n        mask = vor_vv_b4(mask, mask_u, 8);\n\n        count += vcpop_m_b4(mask, 8);\n    }\n\n    // Check remaining characters\n    for (; i < len; ++i) {\n        char c = str[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n    }\n\n    // Check if 'y' is at the end\n    if (len > 0 && (str[len - 1] == 'y' || str[len - 1] == 'Y')) {\n        count++;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <algorithm>\n\nint vowels_count_simd(const std::string s) {\n    int count = 0;\n    size_t len = s.length();\n    const char* str = s.c_str();\n\n    // Convert string to lowercase for uniformity\n    std::string lower_s = s;\n    std::transform(lower_s.begin(), lower_s.end(), lower_s.begin(), ::tolower);\n    str = lower_s.c_str();\n\n    size_t i = 0;\n    size_t vl;\n\n    while (i < len) {\n        vl = __riscv_vsetvl_e8m1(len - i);\n        vbool8_t mask_a = __riscv_vmseq_vx_i8m1(__riscv_vle8_v_i8m1((const int8_t*)(str + i), vl), 'a', vl);\n        vbool8_t mask_e = __riscv_vmseq_vx_i8m1(__riscv_vle8_v_i8m1((const int8_t*)(str + i), vl), 'e', vl);\n        vbool8_t mask_i = __riscv_vmseq_vx_i8m1(__riscv_vle8_v_i8m1((const int8_t*)(str + i), vl), 'i', vl);\n        vbool8_t mask_o = __riscv_vmseq_vx_i8m1(__riscv_vle8_v_i8m1((const int8_t*)(str + i), vl), 'o', vl);\n        vbool8_t mask_u = __riscv_vmseq_vx_i8m1(__riscv_vle8_v_i8m1((const int8_t*)(str + i), vl), 'u', vl);\n\n        count += __riscv_vpopc_b8_m(mask_a, vl);\n        count += __riscv_vpopc_b8_m(mask_e, vl);\n        count += __riscv_vpopc_b8_m(mask_i, vl);\n        count += __riscv_vpopc_b8_m(mask_o, vl);\n        count += __riscv_vpopc_b8_m(mask_u, vl);\n\n        if (i + vl == len - 1 && str[i + vl - 1] == 'y') {\n            count++;\n        }\n\n        i += vl;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <algorithm>\n#include <cctype>\n\nint vowels_count_simd(const std::string s) {\n    int count = 0;\n    size_t n = s.size();\n    const char* str = s.c_str();\n\n    // Convert string to lowercase for uniformity\n    std::string lower_s = s;\n    std::transform(lower_s.begin(), lower_s.end(), lower_s.begin(), ::tolower);\n    str = lower_s.c_str();\n\n    size_t i = 0;\n    while (i < n) {\n        size_t vl = __riscv_vsetvl_e8m1(n - i);\n        vuint8m1_t vec = __riscv_vle8_v_u8m1((const uint8_t*)(str + i), vl);\n\n        vbool1_t mask_a = __riscv_vmseq_vx_i8m1_b1(vec, 'a', vl);\n        vbool1_t mask_e = __riscv_vmseq_vx_i8m1_b1(vec, 'e', vl);\n        vbool1_t mask_i = __riscv_vmseq_vx_i8m1_b1(vec, 'i', vl);\n        vbool1_t mask_o = __riscv_vmseq_vx_i8m1_b1(vec, 'o', vl);\n        vbool1_t mask_u = __riscv_vmseq_vx_i8m1_b1(vec, 'u', vl);\n\n        vbool1_t mask_vowels = __riscv_vor_vv_b1(mask_a, mask_e, vl);\n        mask_vowels = __riscv_vor_vv_b1(mask_vowels, mask_i, vl);\n        mask_vowels = __riscv_vor_vv_b1(mask_vowels, mask_o, vl);\n        mask_vowels = __riscv_vor_vv_b1(mask_vowels, mask_u, vl);\n\n        if (i + vl == n) { // Check last character for 'y'\n            vbool1_t mask_y = __riscv_vmseq_vx_i8m1_b1(vec, 'y', vl);\n            mask_vowels = __riscv_vor_vv_b1(mask_vowels, mask_y, vl);\n        }\n\n        count += __riscv_vpopc_b1(mask_vowels, vl);\n        i += vl;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <cstring>\n\nint vowels_count_simd(const std::string s) {\n    int count = 0;\n    size_t len = s.length();\n    const char* str = s.c_str();\n\n    // Define a mask for vowels\n    vbool8_t vowel_mask;\n    vuint8m1_t vowels = vmv_v_x_u8m1('a', 1);\n    vowels = vslide1up_vx_u8m1(vowels, 'e', 1);\n    vowels = vslide1up_vx_u8m1(vowels, 'i', 1);\n    vowels = vslide1up_vx_u8m1(vowels, 'o', 1);\n    vowels = vslide1up_vx_u8m1(vowels, 'u', 1);\n\n    size_t i = 0;\n    for (; i <= len - 8; i += 8) {\n        vuint8m1_t chars = vle8_v_u8m1((const uint8_t*)&str[i], 1);\n        vbool8_t match = vmseq_vv_u8m1_b8(chars, vowels, 1);\n        count += vm_popcnt_m_b8(match, 1);\n    }\n\n    // Check remaining characters\n    for (; i < len; ++i) {\n        char c = str[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n    }\n\n    // Check if 'y' is at the end\n    if (len > 0 && (str[len - 1] == 'y' || str[len - 1] == 'Y')) {\n        count++;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <cstring>\n\nint vowels_count_simd(std::string s) {\n    int count = 0;\n    const char* str = s.c_str();\n    size_t len = s.length();\n    const char vowels[] = \"aeiouAEIOU\";\n    size_t vl;\n\n    while (len > 0) {\n        vl = __riscv_vsetvl_e8m1(len);\n        vbool8_t mask_a = __riscv_vmseq_vx_i8mf8(__riscv_vle8_v_i8mf8(str, vl), 'a', vl);\n        vbool8_t mask_e = __riscv_vmseq_vx_i8mf8(__riscv_vle8_v_i8mf8(str, vl), 'e', vl);\n        vbool8_t mask_i = __riscv_vmseq_vx_i8mf8(__riscv_vle8_v_i8mf8(str, vl), 'i', vl);\n        vbool8_t mask_o = __riscv_vmseq_vx_i8mf8(__riscv_vle8_v_i8mf8(str, vl), 'o', vl);\n        vbool8_t mask_u = __riscv_vmseq_vx_i8mf8(__riscv_vle8_v_i8mf8(str, vl), 'u', vl);\n        vbool8_t mask_A = __riscv_vmseq_vx_i8mf8(__riscv_vle8_v_i8mf8(str, vl), 'A', vl);\n        vbool8_t mask_E = __riscv_vmseq_vx_i8mf8(__riscv_vle8_v_i8mf8(str, vl), 'E', vl);\n        vbool8_t mask_I = __riscv_vmseq_vx_i8mf8(__riscv_vle8_v_i8mf8(str, vl), 'I', vl);\n        vbool8_t mask_O = __riscv_vmseq_vx_i8mf8(__riscv_vle8_v_i8mf8(str, vl), 'O', vl);\n        vbool8_t mask_U = __riscv_vmseq_vx_i8mf8(__riscv_vle8_v_i8mf8(str, vl), 'U', vl);\n\n        vbool8_t mask_vowels = __riscv_vorr_vv_b8(mask_a, mask_e, vl);\n        mask_vowels = __riscv_vorr_vv_b8(mask_vowels, mask_i, vl);\n        mask_vowels = __riscv_vorr_vv_b8(mask_vowels, mask_o, vl);\n        mask_vowels = __riscv_vorr_vv_b8(mask_vowels, mask_u, vl);\n        mask_vowels = __riscv_vorr_vv_b8(mask_vowels, mask_A, vl);\n        mask_vowels = __riscv_vorr_vv_b8(mask_vowels, mask_E, vl);\n        mask_vowels = __riscv_vorr_vv_b8(mask_vowels, mask_I, vl);\n        mask_vowels = __riscv_vorr_vv_b8(mask_vowels, mask_O, vl);\n        mask_vowels = __riscv_vorr_vv_b8(mask_vowels, mask_U, vl);\n\n        if (len == vl && str[vl - 1] == 'y') {\n            mask_vowels = __riscv_vset_vl_b8(mask_vowels, true, vl - 1, vl);\n        }\n        if (len == vl && str[vl - 1] == 'Y') {\n            mask_vowels = __riscv_vset_vl_b8(mask_vowels, true, vl - 1, vl);\n        }\n\n        count += __riscv_vpopc_b8(mask_vowels, vl);\n        str += vl;\n        len -= vl;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_93_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    size_t n = s.size();\n    size_t vl;\n\n    // Process the string in chunks of vector length\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e8m1(n - i);\n        vuint8m1_t str_vec = __riscv_vle8_v_u8m1((const uint8_t*)&s[i], vl);\n        vbool8_t upper_mask = __riscv_vmsltu_vx_u8m1_b8(str_vec, 'a', vl);\n        vuint8m1_t upper_chars = __riscv_vcompress_vm_u8m1(str_vec, upper_mask, vl);\n        size_t upper_count = __riscv_vpopc_m_b8(upper_mask, vl);\n\n        for (size_t j = 0; j < upper_count; ++j) {\n            sum += upper_chars[j];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    size_t n = s.size();\n    size_t vl;\n\n    // Process the string in chunks of vector length\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e8m1(n - i);\n        vuint8m1_t str_vec = __riscv_vle8_v_u8m1((const uint8_t*)&s[i], vl);\n        vbool8_t upper_mask = __riscv_vmsltu_vx_u8m1_b8(str_vec, 'a', vl);\n        vuint8m1_t upper_chars = __riscv_vcompress_vm_u8m1(str_vec, upper_mask, vl);\n        size_t upper_count = __riscv_vpopc_m_b8(upper_mask, vl);\n\n        for (size_t j = 0; j < upper_count; ++j) {\n            sum += upper_chars[j];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    size_t n = s.size();\n    size_t vl;\n\n    // Process the string in chunks of vector length\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e8m1(n - i);\n        vuint8m1_t str_vec = __riscv_vle8_v_u8m1((const uint8_t*)&s[i], vl);\n        vbool8_t upper_mask = __riscv_vmsltu_vx_u8m1_b8(str_vec, 'a', vl);\n        vuint8m1_t upper_chars = __riscv_vcompress_vm_u8m1(str_vec, upper_mask, vl);\n        size_t upper_count = __riscv_vpopc_m_b8(upper_mask, vl);\n\n        for (size_t j = 0; j < upper_count; ++j) {\n            sum += upper_chars[j];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    size_t n = s.size();\n    size_t vl;\n\n    // Process the string in chunks of vector length\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e8m1(n - i);\n        vuint8m1_t str_vec = __riscv_vle8_v_u8m1((const uint8_t*)&s[i], vl);\n        vbool8_t upper_mask = __riscv_vmsltu_vx_u8m1_b8(str_vec, 'a', vl);\n        vuint8m1_t upper_chars = __riscv_vcompress_vm_u8m1(str_vec, upper_mask, vl);\n        size_t upper_count = __riscv_vpopc_m_b8(upper_mask, vl);\n\n        for (size_t j = 0; j < upper_count; ++j) {\n            sum += upper_chars[j];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    size_t n = s.size();\n    size_t vl;\n\n    // Process the string in chunks of vector length\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e8m1(n - i);\n        vuint8m1_t str_vec = __riscv_vle8_v_u8m1((const uint8_t*)&s[i], vl);\n        vbool8_t upper_mask = __riscv_vmseq_vx_i8m1_b8(str_vec, 'A', vl);\n        upper_mask = __riscv_vmand_vv_b8(upper_mask, __riscv_vmsle_vx_i8m1_b8(str_vec, 'Z', vl), vl);\n        vuint8m1_t upper_chars = __riscv_vcompress_vm_u8m1(str_vec, upper_mask, vl);\n        size_t upper_count = __riscv_vpopc_m_b8(upper_mask, vl);\n        vuint16m2_t sum_vec = __riscv_vwredsum_vs_u8m1_u16m2(upper_chars, 0, upper_count);\n        sum += __riscv_vmv_x_s_u16m2_i16(sum_vec);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_94_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    size_t n = arr.size();\n    int min_even = std::numeric_limits<int>::max();\n    size_t min_index = n;\n\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t v_min_even = __riscv_vmv_v_x_i32m1(min_even, vl);\n    vuint32m1_t v_min_index = __riscv_vmv_v_x_u32m1(min_index, vl);\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m1(n - i);\n        vint32m1_t v_arr = __riscv_vle32_v_i32m1(arr.data() + i, vl);\n        vbool4_t mask_even = __riscv_vmseq_vx_i32m1_b4(v_arr, 0, vl);\n        vint32m1_t v_even = __riscv_vmerge_vvm_i32m1(v_arr, v_min_even, mask_even, vl);\n        vuint32m1_t v_index = __riscv_vadd_vx_u32m1(__riscv_vmv_v_x_u32m1(i, vl), __riscv_vseq_vx_i32m1_b4(v_arr, 0, vl), vl);\n        vuint32m1_t v_min_index_temp = __riscv_vmerge_vvm_u32m1(v_index, v_min_index, mask_even, vl);\n\n        vbool4_t mask_min = __riscv_vmsle_vv_i32m1_b4(v_even, v_min_even, vl);\n        v_min_even = __riscv_vmerge_vvm_i32m1(v_even, v_min_even, mask_min, vl);\n        v_min_index = __riscv_vmerge_vvm_u32m1(v_min_index_temp, v_min_index, mask_min, vl);\n    }\n\n    int result_min_even = __riscv_vmv_x_s_i32m1_i32(v_min_even);\n    size_t result_min_index = __riscv_vmv_x_s_u32m1_u32(v_min_index);\n\n    if (result_min_even == std::numeric_limits<int>::max()) {\n        return {};\n    }\n\n    return {result_min_even, static_cast<int>(result_min_index)};\n}\n```"}
{"task_id": "SimdBench_94_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int min_even = std::numeric_limits<int>::max();\n    int min_index = -1;\n    size_t n = arr.size();\n\n    for (size_t i = 0; i < n;) {\n        size_t vl = __riscv_vsetvl_e32m8(n - i);\n        vint32m8_t vec = __riscv_vle32_v_i32m8(arr.data() + i, vl);\n        vbool8_t mask = __riscv_vmseq_vx_i32m8_b8(vec, 0, vl);\n        vint32m8_t even_vec = __riscv_vcompress_vm_i32m8(vec, mask, vl);\n\n        size_t even_count = __riscv_vpopc_m_b8(mask, vl);\n        if (even_count > 0) {\n            vint32m8_t min_even_vec = __riscv_vredmin_vs_i32m8_i32(even_vec, min_even, mask, vl);\n            min_even = __riscv_vmv_x_s_i32m8_i32(min_even_vec);\n\n            for (size_t j = 0; j < vl; ++j) {\n                if (mask[j] && arr[i + j] == min_even && (min_index == -1 || i + j < min_index)) {\n                    min_index = i + j;\n                }\n            }\n        }\n        i += vl;\n    }\n\n    if (min_index == -1) {\n        return {};\n    } else {\n        return {min_even, min_index};\n    }\n}\n```"}
{"task_id": "SimdBench_94_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    size_t n = arr.size();\n    int min_even = std::numeric_limits<int>::max();\n    int min_index = -1;\n\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t v_arr = __riscv_vle32_v_i32m1(arr.data(), vl);\n    vbool1_t mask = __riscv_vmsnevi_v_i32m1_b1(v_arr, 0, vl);\n    vint32m1_t v_even = __riscv_vand_vv_i32m1(v_arr, mask, vl);\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m1(n - i);\n        v_arr = __riscv_vle32_v_i32m1(arr.data() + i, vl);\n        mask = __riscv_vmseq_vx_i32m1_b1(__riscv_vand_vx_i32m1(v_arr, 1, vl), 0, vl);\n        v_even = __riscv_vcompress_vm_i32m1(v_arr, mask, vl);\n\n        size_t num_even = __riscv_vpopc_m_b1(mask, vl);\n        for (size_t j = 0; j < num_even; ++j) {\n            int even_value = __riscv_vmv_x_s_i32m1_i32(v_even, j);\n            if (even_value < min_even) {\n                min_even = even_value;\n                min_index = i + j;\n            }\n        }\n    }\n\n    if (min_index == -1) {\n        return {};\n    } else {\n        return {min_even, min_index};\n    }\n}\n```"}
{"task_id": "SimdBench_94_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    size_t n = arr.size();\n    int min_even = std::numeric_limits<int>::max();\n    int min_index = -1;\n\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t v_arr = __riscv_vle32_v_i32m1(arr.data(), vl);\n    vbool1_t mask = __riscv_vmsnevi_v_i32m1_b1(v_arr, 0, vl);\n    vint32m1_t v_even = __riscv_vand_vv_i32m1(v_arr, mask, vl);\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m1(n - i);\n        v_arr = __riscv_vle32_v_i32m1(arr.data() + i, vl);\n        mask = __riscv_vmseq_vx_i32m1_b1(__riscv_vand_vx_i32m1(v_arr, 1, vl), 0, vl);\n        v_even = __riscv_vcompress_vm_i32m1(v_arr, mask, vl);\n\n        size_t num_even = __riscv_vpopc_m_b1(mask, vl);\n        for (size_t j = 0; j < num_even; ++j) {\n            int even_value = __riscv_vmv_x_s_i32m1_i32(v_even, j);\n            if (even_value < min_even) {\n                min_even = even_value;\n                min_index = i + j;\n            }\n        }\n    }\n\n    if (min_index == -1) {\n        return {};\n    } else {\n        return {min_even, min_index};\n    }\n}\n```"}
{"task_id": "SimdBench_94_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    size_t n = arr.size();\n    int min_even = std::numeric_limits<int>::max();\n    size_t min_index = n;\n\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t v_arr = __riscv_vle32_v_i32m1(arr.data(), vl);\n    vint32m1_t v_min_even = __riscv_vmv_v_x_i32m1(min_even, vl);\n    vbool32_t mask = __riscv_vmseq_vx_i32m1_b32(v_arr, min_even, vl);\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m1(n - i);\n        v_arr = __riscv_vle32_v_i32m1(arr.data() + i, vl);\n        vbool32_t even_mask = __riscv_vmand_vx_b32(__riscv_vmerge_vvm_b32(mask, __riscv_vmseq_vx_i32m1_b32(v_arr, 0, vl), vl), vl);\n        vint32m1_t even_values = __riscv_vcompress_vm_i32m1(v_arr, even_mask, vl);\n        size_t even_count = __riscv_vpopc_m_b32(even_mask, vl);\n\n        if (even_count > 0) {\n            vint32m1_t min_even_vec = __riscv_vredmin_vs_i32m1_i32(even_values, min_even, even_mask, vl);\n            min_even = __riscv_vmv_x_s_i32m1_i32(min_even_vec);\n            for (size_t j = 0; j < even_count; ++j) {\n                if (arr[i + j] == min_even && min_index == n) {\n                    min_index = i + j;\n                }\n            }\n        }\n    }\n\n    if (min_index == n) {\n        return {};\n    } else {\n        return {min_even, static_cast<int>(min_index)};\n    }\n}\n```"}
{"task_id": "SimdBench_95_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    int n = lst.size();\n    if (n == 0) return -1;\n\n    // Find the maximum element to determine the size of the frequency array\n    int max_elem = *std::max_element(lst.begin(), lst.end());\n\n    // Initialize frequency array\n    std::vector<int> freq(max_elem + 1, 0);\n\n    // Calculate frequencies using RVV\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t vec;\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m1(n - i);\n        vec = __riscv_vle32_v_i32m1(&lst[i], vl);\n        for (size_t j = 0; j < vl; ++j) {\n            int val = __riscv_vmv_x_s_i32m1_i32(vec, j);\n            freq[val]++;\n        }\n    }\n\n    // Find the greatest integer with frequency >= its value\n    for (int i = max_elem; i > 0; --i) {\n        if (freq[i] >= i) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n```"}
{"task_id": "SimdBench_95_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    int n = lst.size();\n    if (n == 0) return -1;\n\n    // Find the maximum element to determine the size of the frequency array\n    int max_elem = *std::max_element(lst.begin(), lst.end());\n\n    // Initialize frequency array\n    std::vector<int> freq(max_elem + 1, 0);\n\n    // Calculate frequencies using RVV\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t vec;\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m1(n - i);\n        vec = __riscv_vle32_v_i32m1(lst.data() + i, vl);\n        for (size_t j = 0; j < vl; ++j) {\n            int val = __riscv_vmv_x_s_i32m1_i32(vec, j);\n            freq[val]++;\n        }\n    }\n\n    // Find the greatest integer with frequency >= its value\n    for (int i = max_elem; i > 0; --i) {\n        if (freq[i] >= i) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n```"}
{"task_id": "SimdBench_95_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    int max_val = *std::max_element(lst.begin(), lst.end());\n    std::vector<int> freq(max_val + 1, 0);\n\n    size_t n = lst.size();\n    size_t vl;\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m8(n - i);\n        vint32m8_t vec = vle32_v_i32m8(&lst[i], vl);\n        for (size_t j = 0; j < vl; ++j) {\n            int val = vget_v_i32m8_i32(vec, j);\n            freq[val]++;\n        }\n    }\n\n    for (int i = max_val; i > 0; --i) {\n        if (freq[i] >= i) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n```"}
{"task_id": "SimdBench_95_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    int n = lst.size();\n    if (n == 0) return -1;\n\n    // Find the maximum element in the list to determine the size of the frequency array\n    int max_elem = *std::max_element(lst.begin(), lst.end());\n\n    // Create a frequency array to count occurrences of each element\n    std::vector<int> freq(max_elem + 1, 0);\n\n    // Use RVV to count frequencies\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t vec;\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m1(n - i);\n        vec = __riscv_vle32_v_i32m1(lst.data() + i, vl);\n        for (size_t j = 0; j < vl; ++j) {\n            int elem = __riscv_vmv_x_s_i32m1_i32(vec, j);\n            freq[elem]++;\n        }\n    }\n\n    // Find the greatest integer that meets the condition\n    for (int i = max_elem; i > 0; --i) {\n        if (freq[i] >= i) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n```"}
{"task_id": "SimdBench_95_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    int n = lst.size();\n    if (n == 0) return -1;\n\n    // Find the maximum element to determine the size of the frequency array\n    int max_elem = *std::max_element(lst.begin(), lst.end());\n\n    // Initialize frequency array\n    std::vector<int> freq(max_elem + 1, 0);\n\n    // Calculate frequencies using RVV\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t vec;\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m1(n - i);\n        vec = __riscv_vle32_v_i32m1(lst.data() + i, vl);\n        for (size_t j = 0; j < vl; ++j) {\n            int elem = __riscv_vmv_x_s_i32m1_i32(vec, j);\n            freq[elem]++;\n        }\n    }\n\n    // Find the greatest integer with frequency >= its value\n    for (int i = max_elem; i > 0; --i) {\n        if (freq[i] >= i) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n```"}
{"task_id": "SimdBench_96_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    size_t n = q.size();\n    if (n == 0) return false;\n\n    // Check if the vector is a palindrome\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t vec = __riscv_vle32_v_i32m1(q.data(), vl);\n    vint32m1_t rev_vec = __riscv_vloxei32_v_i32m1(q.data() + n - 1, __riscv_vmseq_vx_i32m1(__riscv_vsub_vx_i32m1(__riscv_vmv_v_x_i32m1(n - 1, vl), __riscv_vseq0_v_i32m1(vl), vl), 1, vl), vl);\n    vbool4_t mask = __riscv_vmsne_vv_i32m1_b4(vec, rev_vec, vl);\n    bool is_palindrome = !__riscv_vfirst_m_b4(mask, vl);\n\n    // Calculate the sum of the vector elements\n    vint32m1_t sum_vec = __riscv_vredsum_vs_i32m1_i32m1(vec, 0, vl);\n    int sum = __riscv_vmv_x_s_i32m1_i32(sum_vec);\n\n    return is_palindrome && (sum <= w);\n}\n```"}
{"task_id": "SimdBench_96_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    size_t n = q.size();\n    if (n == 0) return false;\n\n    // Check if the vector is palindromic\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t vec = __riscv_vle32_v_i32m1(q.data(), vl);\n    vint32m1_t rev_vec = __riscv_vloxei32_v_i32m1(q.data() + n - 1, __riscv_vmseq_vx_i32m1(vl - 1, -1, vl), vl);\n    vbool4_t mask = __riscv_vmsne_vv_i32m1_b4(vec, rev_vec, vl);\n    bool is_palindrome = !__riscv_vfirst_m_b4(mask, vl);\n\n    // Calculate the sum of the vector elements\n    vint32m1_t zero = __riscv_vmv_v_x_i32m1(0, vl);\n    vint32m1_t sum_vec = __riscv_vredsum_vs_i32m1_i32m1(vec, zero, vl);\n    int sum = __riscv_vmv_x_s_i32m1_i32(sum_vec);\n\n    return is_palindrome && sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    size_t n = q.size();\n    if (n == 0) return false;\n\n    // Check if the vector is a palindrome\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t vec = __riscv_vle32_v_i32m1(q.data(), vl);\n    vint32m1_t rev_vec = __riscv_vloxei32_v_i32m1(q.data() + n - 1, __riscv_vmseq_vx_i32m1(__riscv_vsub_vx_i32m1(__riscv_vmv_v_x_i32m1(n - 1, vl), __riscv_vseq0_v_i32m1(vl), vl), 1, vl), vl);\n    vbool4_t mask = __riscv_vmsne_vv_i32m1_b4(vec, rev_vec, vl);\n    bool is_palindrome = !__riscv_vfirst_m_b4(mask, vl);\n\n    // Calculate the sum of the vector elements\n    vint32m1_t sum_vec = __riscv_vredsum_vs_i32m1_i32m1(vec, 0, vl);\n    int sum = __riscv_vmv_x_s_i32m1_i32(sum_vec);\n\n    return is_palindrome && sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    size_t n = q.size();\n    if (n == 0) return false;\n\n    // Check if the vector is palindromic\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t vec = __riscv_vle32_v_i32m1(q.data(), vl);\n    vint32m1_t rev_vec = __riscv_vloxei32_v_i32m1(q.data() + n - 1, __riscv_vmseq_vx_i32m1(vl - 1, -1, vl), vl);\n    vbool4_t mask = __riscv_vmsne_vv_i32m1_b4(vec, rev_vec, vl);\n    bool is_palindrome = !__riscv_vfirst_m_b4(mask, vl);\n\n    // Calculate the sum of the vector elements\n    vint32m1_t zero = __riscv_vmv_v_x_i32m1(0, vl);\n    vint32m1_t sum_vec = __riscv_vredsum_vs_i32m1_i32m1(vec, zero, vl);\n    int sum = __riscv_vmv_x_s_i32m1_i32(sum_vec);\n\n    return is_palindrome && sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    size_t n = q.size();\n    if (n == 0) return false;\n\n    // Check if the vector is palindromic\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t vec = __riscv_vle32_v_i32m1(q.data(), vl);\n    vint32m1_t rev_vec = __riscv_vloxei32_v_i32m1(q.data() + n - 1, __riscv_vseqi32_v_i32m1(n - 1, -1, vl), vl);\n    vbool4_t mask = __riscv_vmsne_vv_i32m1_b4(vec, rev_vec, vl);\n    bool is_palindrome = !__riscv_vfirst_m_b4(mask, vl);\n\n    // Calculate the sum of the vector elements\n    vint32m1_t zero = __riscv_vmv_v_x_i32m1(0, vl);\n    vint32m1_t sum_vec = __riscv_vredsum_vs_i32m1_i32m1(vec, zero, vl);\n    int sum = __riscv_vmv_x_s_i32m1_i32(sum_vec);\n\n    return is_palindrome && sum <= w;\n}\n```"}
{"task_id": "SimdBench_97_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n\nint smallest_change_simd(std::vector<int> arr) {\n    size_t n = arr.size();\n    size_t half_n = n / 2;\n    int changes = 0;\n\n    // Determine the maximum vector length supported\n    size_t vl = __riscv_vsetvl_e32m1(half_n);\n\n    // Create vectors for the first and reversed second halves of the array\n    vint32m1_t v_first = __riscv_vle32_v_i32m1(arr.data(), vl);\n    vint32m1_t v_second = __riscv_vle32_v_i32m1(arr.data() + n - vl, vl);\n\n    // Reverse the second half vector\n    vint32m1_t v_second_reversed = __riscv_vrev8_v_i32m1(v_second, vl);\n\n    // Compare the two vectors and count the number of differences\n    vbool4m1_t mask = __riscv_vmsne_vv_i32m1_b4m1(v_first, v_second_reversed, vl);\n    size_t diff_count = __riscv_vpopc_m_b4m1(mask, vl);\n\n    // Add the difference count to the total changes\n    changes += diff_count;\n\n    // Handle the case where n is odd, we need to check the middle element separately\n    if (n % 2 != 0) {\n        if (arr[half_n] != arr[n - half_n - 1]) {\n            changes++;\n        }\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n\nint smallest_change_simd(std::vector<int> arr) {\n    size_t n = arr.size();\n    size_t half_n = n / 2;\n    int changes = 0;\n\n    // Determine the maximum vector length supported\n    size_t vl = __riscv_vsetvl_e32m1(half_n);\n\n    // Create vectors for the first and reversed second halves of the array\n    vint32m1_t v_first_half = __riscv_vle32_v_i32m1(arr.data(), vl);\n    vint32m1_t v_second_half = __riscv_vle32_v_i32m1(arr.data() + n - vl, vl);\n\n    // Reverse the second half vector\n    vint32m1_t v_reversed_second_half = __riscv_vrev8_v_i32m1(v_second_half, vl);\n\n    // Compare the first half and the reversed second half\n    vbool4_t vmask = __riscv_vmsne_vv_i32m1_b4(v_first_half, v_reversed_second_half, vl);\n\n    // Count the number of differences\n    size_t diff_count = __riscv_vpopc_m_b4(vmask, vl);\n\n    // Add the difference count to the total changes\n    changes += diff_count;\n\n    // Handle the case where n is odd, we need to check the middle element separately\n    if (n % 2 != 0) {\n        if (arr[half_n] != arr[n - half_n - 1]) {\n            changes++;\n        }\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    size_t vl;\n\n    for (size_t i = 0; i < n / 2; i += vl) {\n        vl = vsetvl_e32m8(n / 2 - i);\n        vint32m8_t left = vle32_v_i32m8(&arr[i], vl);\n        vint32m8_t right = vle32_v_i32m8(&arr[n - i - vl], vl);\n        vbool8_t mask = vmne_vv_i32m8_b8(left, right, vl);\n        changes += vcpop_m_b8(mask, vl);\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n\nint smallest_change_simd(std::vector<int> arr) {\n    size_t n = arr.size();\n    size_t half_n = n / 2;\n    int changes = 0;\n\n    // Determine the maximum vector length supported\n    size_t vl = __riscv_vsetvl_e32m1(half_n);\n\n    // Create vectors for the first and reversed second halves of the array\n    vint32m1_t v_first = __riscv_vle32_v_i32m1(arr.data(), vl);\n    vint32m1_t v_second = __riscv_vle32_v_i32m1(arr.data() + n - vl, vl);\n\n    // Reverse the second half vector\n    vint32m1_t v_second_reversed = __riscv_vrev8_v_i32m1(v_second, vl);\n\n    // Compare the two vectors and count the number of differences\n    vbool4m1_t mask = __riscv_vmne_vv_i32m1_b4m1(v_first, v_second_reversed, vl);\n    size_t diff_count = __riscv_vpopc_m_b4m1(mask, vl);\n\n    // Add the difference count to the total changes\n    changes += diff_count;\n\n    // Handle the case where n is odd, we need to check the middle element separately\n    if (n % 2 != 0) {\n        if (arr[half_n] != arr[n - half_n - 1]) {\n            changes++;\n        }\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n\nint smallest_change_simd(std::vector<int> arr) {\n    size_t n = arr.size();\n    size_t half_n = n / 2;\n    int changes = 0;\n\n    // Determine the maximum vector length supported\n    size_t vl = __riscv_vsetvl_e32m1(half_n);\n\n    // Create vectors for the first and reversed second halves of the array\n    vint32m1_t v_first = __riscv_vle32_v_i32m1(arr.data(), vl);\n    vint32m1_t v_second = __riscv_vle32_v_i32m1(arr.data() + n - vl, vl);\n\n    // Reverse the second half vector\n    vint32m1_t v_second_reversed = __riscv_vrev8_v_i32m1(v_second, vl);\n\n    // Compare the two vectors and count the number of differences\n    vbool4m1_t v_mask = __riscv_vmsne_vv_i32m1_b4m1(v_first, v_second_reversed, vl);\n    size_t diff_count = __riscv_vpopc_m_b4m1(v_mask, vl);\n\n    // Add the difference count to the total changes\n    changes += diff_count;\n\n    // Handle the case where n is odd, we need to check the middle element separately\n    if (n % 2 != 0) {\n        if (arr[half_n] != arr[n - half_n - 1]) {\n            changes++;\n        }\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_98_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    size_t total_chars_lst1 = 0;\n    size_t total_chars_lst2 = 0;\n\n    for (const auto& str : lst1) {\n        total_chars_lst1 += str.size();\n    }\n\n    for (const auto& str : lst2) {\n        total_chars_lst2 += str.size();\n    }\n\n    return total_chars_lst1 < total_chars_lst2 ? lst1 : lst2;\n}\n```"}
{"task_id": "SimdBench_98_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    size_t total_chars_lst1 = 0;\n    size_t total_chars_lst2 = 0;\n\n    for (const auto& str : lst1) {\n        total_chars_lst1 += str.size();\n    }\n\n    for (const auto& str : lst2) {\n        total_chars_lst2 += str.size();\n    }\n\n    return total_chars_lst1 < total_chars_lst2 ? lst1 : lst2;\n}\n```"}
{"task_id": "SimdBench_98_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    size_t total_chars_lst1 = 0;\n    size_t total_chars_lst2 = 0;\n\n    for (const auto& str : lst1) {\n        total_chars_lst1 += str.size();\n    }\n\n    for (const auto& str : lst2) {\n        total_chars_lst2 += str.size();\n    }\n\n    return total_chars_lst1 < total_chars_lst2 ? lst1 : lst2;\n}\n```"}
{"task_id": "SimdBench_98_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    size_t total_chars_lst1 = 0;\n    size_t total_chars_lst2 = 0;\n\n    for (const auto& str : lst1) {\n        total_chars_lst1 += str.size();\n    }\n\n    for (const auto& str : lst2) {\n        total_chars_lst2 += str.size();\n    }\n\n    return total_chars_lst1 < total_chars_lst2 ? lst1 : lst2;\n}\n```"}
{"task_id": "SimdBench_98_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    size_t total_chars_lst1 = 0;\n    size_t total_chars_lst2 = 0;\n\n    for (const auto& str : lst1) {\n        total_chars_lst1 += str.size();\n    }\n\n    for (const auto& str : lst2) {\n        total_chars_lst2 += str.size();\n    }\n\n    return total_chars_lst1 < total_chars_lst2 ? lst1 : lst2;\n}\n```"}
{"task_id": "SimdBench_99_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdbool.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n == 1) {\n        return x == 1;\n    }\n    size_t vl = 1;\n    vuint64m1_t vn = vmv_v_x_u64m1(n, vl);\n    vuint64m1_t vx = vmv_v_x_u64m1(x, vl);\n    vuint64m1_t vresult = vmseq_vv_u64m1_b1(vx, vn, vl);\n    bool result = vmfirst_m_b1(vresult, vl);\n    uint64_t power = n;\n    while (power < x) {\n        power *= n;\n        vn = vmv_v_x_u64m1(power, vl);\n        vresult = vmseq_vv_u64m1_b1(vx, vn, vl);\n        result |= vmfirst_m_b1(vresult, vl);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_99_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdbool.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n == 1) {\n        return x == 1;\n    }\n    size_t vl = 1;\n    vuint64m1_t vn = vle64_v_u64m1(&n, vl);\n    vuint64m1_t vx = vle64_v_u64m1(&x, vl);\n    vuint64m1_t vone = vmv_v_x_u64m1(1, vl);\n    vuint64m1_t vpwr = vone;\n\n    while (true) {\n        vbool1_t mask = vmseq_vv_u64m1_b1(vpwr, vx, vl);\n        if (vmfirst_m_b1(mask, vl)) {\n            return true;\n        }\n        mask = vmge_vv_u64m1_b1(vpwr, vx, vl);\n        if (vmfirst_m_b1(mask, vl)) {\n            return false;\n        }\n        vpwr = vwmul_vv_u64m1(vpwr, vn, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_99_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdbool.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n == 1) {\n        return x == 1;\n    }\n    size_t vl = 1;\n    vuint64m1_t vec_n = vmv_v_x_u64m1(n, vl);\n    vuint64m1_t vec_pow = vmv_v_x_u64m1(1, vl);\n    vuint64m1_t vec_one = vmv_v_x_u64m1(1, vl);\n    vbool1_t mask;\n\n    do {\n        vec_pow = vmul_vv_u64m1(vec_pow, vec_n, vl);\n        mask = vmseq_vx_u64m1_b1(vec_pow, x, vl);\n        if (vm_first_m_b1(mask, vl)) {\n            return true;\n        }\n        mask = vmseq_vx_u64m1_b1(vec_pow, vec_one, vl);\n    } while (!vm_first_m_b1(mask, vl));\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdbool.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n == 1) {\n        return x == 1;\n    }\n    size_t vl = 1;\n    vuint64m1_t vn = vle64_v_u64m1(&n, vl);\n    vuint64m1_t vx = vle64_v_u64m1(&x, vl);\n    vuint64m1_t vone = vmv_v_x_u64m1(1, vl);\n    vuint64m1_t vpwr = vone;\n\n    while (true) {\n        vbool1_t mask = vmseq_vv_u64m1_b1(vpwr, vx, vl);\n        if (vmfirst_m_b1(mask, vl)) {\n            return true;\n        }\n        mask = vmge_vv_u64m1_b1(vpwr, vx, vl);\n        if (vmfirst_m_b1(mask, vl)) {\n            return false;\n        }\n        vpwr = vwmul_vv_u64m1(vpwr, vn, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_99_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdbool.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n == 1) {\n        return x == 1;\n    }\n    size_t vl = 1;\n    vuint64m1_t vn = vle64_v_u64m1(&n, vl);\n    vuint64m1_t vx = vle64_v_u64m1(&x, vl);\n    vuint64m1_t vone = vmv_v_x_u64m1(1, vl);\n    vuint64m1_t vpwr = vone;\n\n    while (true) {\n        vbool1_t mask = vmseq_vv_u64m1_b1(vpwr, vx, vl);\n        if (vmfirst_m_b1(mask, vl)) {\n            return true;\n        }\n        mask = vmge_vv_u64m1_b1(vpwr, vx, vl);\n        if (vmfirst_m_b1(mask, vl)) {\n            return false;\n        }\n        vpwr = vwmul_vv_u64m1(vpwr, vn, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_100_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    int count = 0;\n    size_t n = num.size();\n    const char prime_hex_digits[] = {'2', '3', '5', '7', 'B', 'D'};\n    size_t prime_hex_len = sizeof(prime_hex_digits);\n\n    for (size_t i = 0; i < n; i += 8) {\n        size_t vl = __riscv_vsetvl_e8m1(n - i);\n        vuint8m1_t input = __riscv_vle8_v_u8m1((const uint8_t*)&num[i], vl);\n        vbool1_t mask = __riscv_vfalse_v_b1(vl);\n\n        for (size_t j = 0; j < prime_hex_len; ++j) {\n            vuint8m1_t prime_digit = __riscv_vmv_v_x_u8m1(prime_hex_digits[j], vl);\n            mask = __riscv_vor_vv_b1(mask, __riscv_veq_vv_u8m1_b1(input, prime_digit, vl), vl);\n        }\n\n        count += __riscv_vpopc_b1(mask, vl);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    int count = 0;\n    size_t n = num.size();\n    const char primes[] = {'2', '3', '5', '7', 'B', 'D'};\n    vbool8_t mask;\n    vuint8m1_t vec_num, vec_prime;\n\n    for (size_t i = 0; i < n; i += 8) {\n        size_t vl = __riscv_vsetvl_e8m1(n - i);\n        vec_num = __riscv_vle8_v_u8m1(&num[i], vl);\n\n        for (const auto &prime : primes) {\n            vec_prime = __riscv_vmv_v_x_u8m1(prime, vl);\n            mask = __riscv_vmsne_vx_u8m1_b8(vec_num, prime, vl);\n            count += __riscv_vpopc_m_b8(mask, vl);\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    int count = 0;\n    size_t n = num.size();\n    const char prime_hex_digits[] = {'2', '3', '5', '7', 'B', 'D'};\n    size_t vl;\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e8m1(n - i);\n        vuint8m1_t input = vle8_v_u8m1(&num[i], vl);\n        vbool1_t mask2 = vmseq_vx_u8m1_b1(input, '2', vl);\n        vbool1_t mask3 = vmseq_vx_u8m1_b1(input, '3', vl);\n        vbool1_t mask5 = vmseq_vx_u8m1_b1(input, '5', vl);\n        vbool1_t mask7 = vmseq_vx_u8m1_b1(input, '7', vl);\n        vbool1_t maskB = vmseq_vx_u8m1_b1(input, 'B', vl);\n        vbool1_t maskD = vmseq_vx_u8m1_b1(input, 'D', vl);\n\n        vbool1_t mask = vor_vv_b1(mask2, mask3, vl);\n        mask = vor_vv_b1(mask, mask5, vl);\n        mask = vor_vv_b1(mask, mask7, vl);\n        mask = vor_vv_b1(mask, maskB, vl);\n        mask = vor_vv_b1(mask, maskD, vl);\n\n        count += vpopc_m_b1(mask, vl);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    int count = 0;\n    size_t n = num.size();\n    const char prime_hex_digits[] = {'2', '3', '5', '7', 'B', 'D'};\n\n    for (size_t i = 0; i < n; ) {\n        size_t vl = __riscv_vsetvl_e8m1(n - i);\n        vuint8m1_t input = __riscv_vle8_v_u8m1((const uint8_t*)&num[i], vl);\n        vbool1_t mask2 = __riscv_vmseq_vx_u8m1_b1(input, '2', vl);\n        vbool1_t mask3 = __riscv_vmseq_vx_u8m1_b1(input, '3', vl);\n        vbool1_t mask5 = __riscv_vmseq_vx_u8m1_b1(input, '5', vl);\n        vbool1_t mask7 = __riscv_vmseq_vx_u8m1_b1(input, '7', vl);\n        vbool1_t maskB = __riscv_vmseq_vx_u8m1_b1(input, 'B', vl);\n        vbool1_t maskD = __riscv_vmseq_vx_u8m1_b1(input, 'D', vl);\n\n        vbool1_t mask = __riscv_vorr_vv_b1(mask2, mask3, vl);\n        mask = __riscv_vorr_vv_b1(mask, mask5, vl);\n        mask = __riscv_vorr_vv_b1(mask, mask7, vl);\n        mask = __riscv_vorr_vv_b1(mask, maskB, vl);\n        mask = __riscv_vorr_vv_b1(mask, maskD, vl);\n\n        count += __riscv_vpopc_b1(mask, vl);\n        i += vl;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    int count = 0;\n    size_t n = num.size();\n    const char prime_hex_digits[] = {'2', '3', '5', '7', 'B', 'D'};\n    size_t prime_hex_size = sizeof(prime_hex_digits);\n\n    for (size_t i = 0; i < n; i += 8) {\n        size_t vl = __riscv_vsetvl_e8m1(n - i);\n        vuint8m1_t input = __riscv_vle8_v_u8m1((const uint8_t*)&num[i], vl);\n        vbool1_t mask = __riscv_vfalse_v_b1(vl);\n\n        for (size_t j = 0; j < prime_hex_size; ++j) {\n            vuint8m1_t prime_digit = __riscv_vmv_v_x_u8m1(prime_hex_digits[j], vl);\n            mask = __riscv_vor_vv_b1(mask, __riscv_veq_vv_u8m1_b1(input, prime_digit, vl), vl);\n        }\n\n        count += __riscv_vpopc_b1(mask, vl);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_101_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s) {\n    size_t n = s.size();\n    if (n < 3) return false;\n\n    size_t i = 0;\n    while (i <= n - 3) {\n        size_t vl = __riscv_vsetvl_e8m1(n - i);\n        vuint8m1_t vec1 = __riscv_vle8_v_u8m1((const uint8_t*)&s[i], vl);\n        vuint8m1_t vec2 = __riscv_vle8_v_u8m1((const uint8_t*)&s[i + 1], vl);\n        vuint8m1_t vec3 = __riscv_vle8_v_u8m1((const uint8_t*)&s[i + 2], vl);\n\n        vbool1_t mask1 = __riscv_vmsne_vv_u8m1_b1(vec1, vec2, vl);\n        vbool1_t mask2 = __riscv_vmsne_vv_u8m1_b1(vec2, vec3, vl);\n        vbool1_t mask3 = __riscv_vmsne_vv_u8m1_b1(vec1, vec3, vl);\n\n        vbool1_t result_mask = __riscv_vand_vv_b1(mask1, mask2, vl);\n        result_mask = __riscv_vand_vv_b1(result_mask, mask3, vl);\n\n        if (!__riscv_vfirst_m_b1(result_mask, vl)) {\n            return false;\n        }\n\n        i += vl - 2; // Move the index forward by vl - 2 to ensure overlap\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s) {\n    size_t n = s.size();\n    if (n < 3) return false;\n\n    size_t i = 0;\n    while (i <= n - 3) {\n        size_t vl = __riscv_vsetvl_e8m1(n - i);\n        vuint8m1_t vec1 = __riscv_vle8_v_u8m1((const uint8_t*)&s[i], vl);\n        vuint8m1_t vec2 = __riscv_vle8_v_u8m1((const uint8_t*)&s[i + 1], vl);\n        vuint8m1_t vec3 = __riscv_vle8_v_u8m1((const uint8_t*)&s[i + 2], vl);\n\n        vbool1_t mask1 = __riscv_vmsne_vv_u8m1_b1(vec1, vec2, vl);\n        vbool1_t mask2 = __riscv_vmsne_vv_u8m1_b1(vec2, vec3, vl);\n        vbool1_t mask3 = __riscv_vmsne_vv_u8m1_b1(vec1, vec3, vl);\n\n        vbool1_t result_mask = __riscv_vand_vv_b1(mask1, mask2, vl);\n        result_mask = __riscv_vand_vv_b1(result_mask, mask3, vl);\n\n        if (!__riscv_vfirst_m_b1(result_mask, vl)) {\n            return false;\n        }\n\n        i += vl - 2; // Move the index forward by vl - 2 to ensure overlap\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s) {\n    size_t n = s.size();\n    if (n < 3) return false;\n\n    size_t i = 0;\n    while (i <= n - 3) {\n        size_t vl = __riscv_vsetvl_e8m1(n - i);\n        vuint8m1_t vec1 = __riscv_vle8_v_u8m1((const uint8_t*)&s[i], vl);\n        vuint8m1_t vec2 = __riscv_vle8_v_u8m1((const uint8_t*)&s[i + 1], vl);\n        vuint8m1_t vec3 = __riscv_vle8_v_u8m1((const uint8_t*)&s[i + 2], vl);\n\n        vbool1_t mask1 = __riscv_vmsne_vv_u8m1_b1(vec1, vec2, vl);\n        vbool1_t mask2 = __riscv_vmsne_vv_u8m1_b1(vec2, vec3, vl);\n        vbool1_t mask3 = __riscv_vmsne_vv_u8m1_b1(vec1, vec3, vl);\n\n        vbool1_t result_mask = __riscv_vand_vv_b1(mask1, mask2, vl);\n        result_mask = __riscv_vand_vv_b1(result_mask, mask3, vl);\n\n        if (!__riscv_vfirst_m_b1(result_mask, vl)) {\n            return false;\n        }\n\n        i += vl - 2;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s) {\n    size_t n = s.size();\n    if (n < 3) return false;\n\n    size_t i = 0;\n    while (i <= n - 3) {\n        size_t vl = __riscv_vsetvl_e8m1(n - i);\n        vuint8m1_t vec1 = __riscv_vle8_v_u8m1((const uint8_t*)&s[i], vl);\n        vuint8m1_t vec2 = __riscv_vle8_v_u8m1((const uint8_t*)&s[i + 1], vl);\n        vuint8m1_t vec3 = __riscv_vle8_v_u8m1((const uint8_t*)&s[i + 2], vl);\n\n        vbool1_t mask1 = __riscv_vmsne_vv_u8m1_b1(vec1, vec2, vl);\n        vbool1_t mask2 = __riscv_vmsne_vv_u8m1_b1(vec2, vec3, vl);\n        vbool1_t mask3 = __riscv_vmsne_vv_u8m1_b1(vec1, vec3, vl);\n\n        vbool1_t result_mask = __riscv_vand_vv_b1(mask1, mask2, vl);\n        result_mask = __riscv_vand_vv_b1(result_mask, mask3, vl);\n\n        if (!__riscv_vfirst_m_b1(result_mask, vl)) {\n            return false;\n        }\n\n        i += vl - 2; // Move the index forward by vl - 2 to ensure overlap\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s) {\n    size_t n = s.size();\n    if (n < 3) return false;\n\n    size_t i = 0;\n    while (i <= n - 3) {\n        size_t vl = __riscv_vsetvl_e8m1(n - i);\n        vuint8m1_t vec1 = __riscv_vle8_v_u8m1((const uint8_t*)&s[i], vl);\n        vuint8m1_t vec2 = __riscv_vle8_v_u8m1((const uint8_t*)&s[i + 1], vl);\n        vuint8m1_t vec3 = __riscv_vle8_v_u8m1((const uint8_t*)&s[i + 2], vl);\n\n        vbool1_t mask1 = __riscv_vmsne_vv_u8m1_b1(vec1, vec2, vl);\n        vbool1_t mask2 = __riscv_vmsne_vv_u8m1_b1(vec2, vec3, vl);\n        vbool1_t mask3 = __riscv_vmsne_vv_u8m1_b1(vec1, vec3, vl);\n\n        vbool1_t result_mask = __riscv_vand_vv_b1(mask1, mask2, vl);\n        result_mask = __riscv_vand_vv_b1(result_mask, mask3, vl);\n\n        if (!__riscv_vfirst_m_b1(result_mask, vl)) {\n            return false;\n        }\n\n        i += vl - 2; // Move the index forward by vl - 2 to ensure overlap\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n#include <string>\n\nbool prime_length_simd(const std::string & str) {\n    size_t length = str.length();\n    if (length < 2) return false;\n\n    size_t sqrt_len = static_cast<size_t>(std::sqrt(length)) + 1;\n    vuint32m1_t vec = vseq_v_u32m1(2, 1, sqrt_len - 2);\n    vbool4_t mask = vmseq_vx_u32m1_b4(vec, length, sqrt_len - 2);\n\n    for (size_t i = 2; i < sqrt_len; ++i) {\n        if (length % i == 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n#include <string>\n\nbool prime_length_simd(const std::string & str) {\n    size_t length = str.length();\n    if (length < 2) return false;\n\n    size_t sqrt_length = static_cast<size_t>(std::sqrt(length)) + 1;\n    size_t vl = vsetvl_e32m1(sqrt_length);\n\n    vbool32_t mask = vmseq_vx_i32m1(vle32_v_i32m1(nullptr, vl), 0, vl);\n    for (size_t i = 2; i < sqrt_length; ++i) {\n        vint32m1_t vec = vle32_v_i32m1(reinterpret_cast<const int32_t*>(&i), vl);\n        vint32m1_t divs = vdiv_vv_i32m1(vec, vec, vl);\n        vbool32_t is_divisible = vmsne_vv_i32m1(divs, vle32_v_i32m1(reinterpret_cast<const int32_t*>(&length), vl), vl);\n        mask = vmor_vv_b32(mask, is_divisible, vl);\n    }\n\n    return !vmfirst_m_b32(mask, vl);\n}\n```"}
{"task_id": "SimdBench_102_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n#include <string>\n\nbool prime_length_simd(const std::string & str) {\n    size_t length = str.length();\n    if (length < 2) return false;\n\n    size_t sqrt_length = static_cast<size_t>(std::sqrt(length)) + 1;\n    vuint32m1_t vec = vseq_v_u32m1(2, 1, sqrt_length - 2);\n    vbool4_t mask = vmseq_vx_u32m1_b4(vec, length, sqrt_length - 2);\n\n    for (size_t i = 2; i < sqrt_length; ++i) {\n        if (length % i == 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n#include <string>\n\nbool prime_length_simd(const std::string & str) {\n    size_t length = str.length();\n    if (length < 2) return false;\n\n    size_t sqrt_len = static_cast<size_t>(std::sqrt(length)) + 1;\n    vuint32m1_t vec = vseq_v_u32m1(2, 1, sqrt_len - 2);\n    vbool4_t mask = vmseq_vx_u32m1_b4(vec, length % vget_v_u32m1(vec), sqrt_len - 2);\n\n    bool is_prime = true;\n    for (size_t i = 0; i < sqrt_len - 2; i++) {\n        if (vmfirst_m_b4(mask)) {\n            is_prime = false;\n            break;\n        }\n        vec = vadd_vx_u32m1(vec, 1, sqrt_len - 2);\n        mask = vmseq_vx_u32m1_b4(vec, length % vget_v_u32m1(vec), sqrt_len - 2);\n    }\n\n    return is_prime;\n}\n```"}
{"task_id": "SimdBench_102_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n#include <string>\n\nbool prime_length_simd(const std::string & str) {\n    size_t length = str.length();\n    if (length < 2) return false;\n\n    size_t sqrt_len = static_cast<size_t>(std::sqrt(length)) + 1;\n    size_t vl = vsetvl_e32m1(sqrt_len);\n\n    vbool32_t mask = vmseq_vx_i32m1(vle32_v_i32m1(nullptr, vl), 0, vl);\n    for (size_t i = 2; i < sqrt_len; ++i) {\n        vint32m1_t vec = vle32_v_i32m1(reinterpret_cast<const int32_t*>(&i), vl);\n        vint32m1_t divs = vdiv_vv_i32m1(vec, vec, vl);\n        vbool32_t is_divisible = vmseq_vv_i32m1(divs, vle32_v_i32m1(reinterpret_cast<const int32_t*>(&length), vl), vl);\n        mask = vmor_vv_b32(mask, is_divisible, vl);\n    }\n\n    return !vmfirst_m_b32(mask, vl);\n}\n```"}
{"task_id": "SimdBench_103_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <bitset>\n\nstd::string solve_simd(uint64_t N) {\n    size_t vl = vsetvl_e8m1(1);\n    vuint8m1_t vec = vle8_v_u8m1(reinterpret_cast<uint8_t*>(&N), vl);\n    vuint8m1_t ones = vmv_v_x_u8m1(1, vl);\n    vbool1_t mask = vmsne_vx_u8m1_b1(vec, 0, vl);\n    vuint8m1_t sum_vec = vcpop_m_b1_u8m1(mask, ones, vl);\n    uint64_t sum = vredsum_vs_u8m1_u64m1(sum_vec, 0, vl);\n    return std::bitset<64>(sum).to_string().substr(64 - std::bitset<64>(sum).count());\n}\n```"}
{"task_id": "SimdBench_103_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string solve_simd(uint64_t N) {\n    size_t vl = vsetvl_e8m1(8);\n    vuint8m1_t vec;\n    uint8_t result[8] = {0};\n    uint32_t sum = 0;\n\n    // Convert N to binary and store each bit in a vector\n    for (int i = 0; i < 64; i += vl) {\n        vec = vmv_v_x_u8m1((uint8_t)((N >> i) & 0xFF), vl);\n        vse8_v_u8m1(result, vec, vl);\n        for (int j = 0; j < vl; ++j) {\n            sum += __builtin_popcount(result[j]);\n        }\n    }\n\n    // Convert sum to binary string\n    std::string binary = \"\";\n    if (sum == 0) return \"0\";\n    while (sum > 0) {\n        binary = (sum % 2 == 0 ? \"0\" : \"1\") + binary;\n        sum /= 2;\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <bitset>\n\nstd::string solve_simd(uint64_t N) {\n    size_t vl = vsetvl_e8m1(1);\n    vuint8m1_t sum = vmv_v_x_u8m1(0, vl);\n    vuint8m1_t one = vmv_v_x_u8m1(1, vl);\n\n    while (N > 0) {\n        uint8_t digit = N % 2;\n        sum = vadd_vx_u8m1(sum, digit, vl);\n        N /= 2;\n    }\n\n    uint8_t result = vredsum_vs_u8m1_u8m1(sum, sum, vl);\n    return std::bitset<8>(result).to_string().substr(8 - vl);\n}\n```"}
{"task_id": "SimdBench_103_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <bitset>\n\nstd::string solve_simd(uint64_t N) {\n    size_t vl = vsetvl_e8m1(1);\n    vuint8m1_t vec = vle8_v_u8m1(reinterpret_cast<const uint8_t*>(&N), vl);\n    vuint8m1_t ones = vpopc_v_u8m1(vec, vl);\n    size_t sum = vredsum_vs_u8m1_u32m1(ones, 0, vl);\n    return std::bitset<64>(sum).to_string().substr(64 - std::bitset<64>(sum).count());\n}\n```"}
{"task_id": "SimdBench_103_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <bitset>\n\nstd::string solve_simd(uint64_t N) {\n    size_t vl = vsetvl_e8m1(1);\n    vuint8m1_t vec = vle8_v_u8m1(reinterpret_cast<const uint8_t*>(&N), vl);\n    vuint8m1_t ones = vmv_v_x_u8m1(1, vl);\n    vbool1_t mask = vmsne_vx_u8m1_b1(vec, 0, vl);\n    vuint8m1_t sum_vec = vcpop_m_b1_u8m1(mask, ones, vl);\n    uint64_t sum = vredsum_vs_u8m1_u64m1(sum_vec, 0, vl);\n    return std::bitset<64>(sum).to_string().substr(64 - std::bitset<64>(sum).count());\n}\n```"}
{"task_id": "SimdBench_104_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    size_t n = lst.size();\n    int sum = 0;\n\n    // Define the vector length\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    // Create a vector to store the result of the mask\n    vbool32_t mask = __riscv_vmseq_vx_i32m1(__riscv_vle32_v_i32m1(lst.data(), vl), 0, vl);\n\n    // Iterate over the vector with a step of 2 starting from index 1\n    for (size_t i = 1; i < n; i += 2) {\n        vl = __riscv_vsetvl_e32m1(n - i);\n        vint32m1_t vec = __riscv_vle32_v_i32m1(&lst[i], vl);\n        vbool32_t odd_index_mask = __riscv_vmseq_vx_i32m1(__riscv_vle32_v_i32m1(&lst[i], vl), 0, vl);\n        vbool32_t even_and_odd_index_mask = __riscv_vand_vv_b32m1(mask, odd_index_mask, vl);\n        vint32m1_t filtered_vec = __riscv_vcompress_vm_i32m1(vec, even_and_odd_index_mask, vl);\n        size_t filtered_vl = __riscv_vpopc_m_b32m1(even_and_odd_index_mask, vl);\n        sum += __riscv_vredsum_vs_i32m1_i32(filtered_vec, 0, filtered_vl);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    size_t n = lst.size();\n    int sum = 0;\n\n    // Create a mask for odd indices\n    vbool16_t mask = vmseq_vx_i16(vmnot_vi16_m(vcreate_i16(0), 1), 1, n);\n\n    // Iterate over the vector in chunks\n    for (size_t i = 1; i < n; i += __riscv_vsetvl_e32m1(n - i)) {\n        vint32m1_t vec = vle32_v_i32m1(lst.data() + i, __riscv_vsetvl_e32m1(n - i));\n        vint32m1_t even_vec = vcompress_vm_i32m1(mask, vec, __riscv_vsetvl_e32m1(n - i));\n        sum += vredsum_vs_i32m1_i32(even_vec, 0, __riscv_vsetvl_e32m1(n - i));\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst){\n    size_t n = lst.size();\n    int sum = 0;\n    size_t vl;\n\n    // Create a mask for odd indices\n    vbool32_t mask = vmseq_vx_i32m1_b32(vseq_vl_e32m1(n, __RISCV_VLMAX), 1, n);\n\n    // Iterate over the vector in chunks\n    for (size_t i = 1; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        vint32m1_t vec = vle32_v_i32m1(lst.data() + i, vl);\n        vint32m1_t even_vec = vand_vx_i32m1(vec, 2, vl); // Keep only even numbers\n        vint32m1_t masked_even_vec = vcompress_vm_i32m1(even_vec, mask, vl);\n        sum += vredsum_vs_i32m1_i32(masked_even_vec, 0, vl);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    size_t n = lst.size();\n    int sum = 0;\n\n    // Define the vector length\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    // Create a vector to store the result\n    vint32m1_t v_sum = __riscv_vmv_v_x_i32m1(0, vl);\n\n    // Iterate over the list with a step of 2 starting from index 1\n    for (size_t i = 1; i < n; i += 2) {\n        // Load the elements at odd indices\n        vint32m1_t v_elements = __riscv_vle32_v_i32m1(&lst[i], vl);\n\n        // Create a mask for even elements\n        vbool4_t v_mask = __riscv_vmseq_vx_i32m1_b4(v_elements, 0, vl);\n\n        // Filter even elements and add them to the sum\n        v_sum = __riscv_vredsum_vs_i32m1_i32m1(v_elements, v_sum, v_mask, vl);\n    }\n\n    // Sum up the results in the vector\n    sum = __riscv_vmv_x_s_i32m1_i32(v_sum);\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    size_t n = lst.size();\n    int sum = 0;\n\n    // Create a mask for odd indices\n    vbool16_t mask = vmseq_vx_i16(vmnot_vi16_m(vcreate_i16(0), 1), 1, n);\n\n    // Iterate over the vector in chunks\n    for (size_t i = 1; i < n; i += 8) {\n        vint16m1_t vec = vle16_v_i16m1(&lst[i], n - i);\n        vint16m1_t even_vec = vand_vx_i16m1(vec, 2, n - i);\n        vint16m1_t masked_even_vec = vcompress_vm_i16m1(mask, even_vec, n - i);\n        sum += vredsum_vs_i16m1_i32m1(masked_even_vec, 0, vundefined_i32m1());\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_105_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    size_t len = s.length();\n    std::string result(len, ' ');\n\n    // Define the shift amount\n    int8_t shift = 4; // 2 * 2\n\n    // Create a vector group\n    size_t vl = __riscv_vsetvl_e8m1(len);\n\n    // Load the input string into a vector\n    vint8m1_t input_vec = __riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(s.c_str()), vl);\n\n    // Create a vector of shift amounts\n    vint8m1_t shift_vec = __riscv_vmv_v_x_i8m1(shift, vl);\n\n    // Perform the shift operation\n    vint8m1_t shifted_vec = __riscv_vadd_vv_i8m1(input_vec, shift_vec, vl);\n\n    // Handle wrap-around for lowercase letters\n    vbool8m1_t mask = __riscv_vmsltu_vx_i8m1_b8m1(shifted_vec, 'a', vl);\n    shifted_vec = __riscv_vmerge_vvm_i8m1(__riscv_vsub_vx_i8m1(shifted_vec, 26, vl), shifted_vec, mask, vl);\n\n    mask = __riscv_vmsgeu_vx_i8m1_b8m1(shifted_vec, 'z' + 1, vl);\n    shifted_vec = __riscv_vmerge_vvm_i8m1(__riscv_vadd_vx_i8m1(shifted_vec, -26, vl), shifted_vec, mask, vl);\n\n    // Store the result back to the output string\n    __riscv_vse8_v_i8m1(reinterpret_cast<int8_t*>(result.data()), shifted_vec, vl);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    size_t len = s.length();\n    std::string result(len, ' ');\n\n    // Define the shift amount\n    const int shift = 2 * 2;\n\n    // Process the string in chunks of vector length\n    size_t i = 0;\n    for (; i <= len - 8; i += 8) {\n        // Load 8 characters into a vector\n        vuint8m1_t input = vle8_v_u8m1(reinterpret_cast<const uint8_t*>(s.data() + i), __riscv_vl(8, __RISCV_VLMAX));\n\n        // Shift each character by the defined amount, wrapping around the alphabet\n        vuint8m1_t shifted = vadd_vx_u8m1(input, shift, __riscv_vl(8, __RISCV_VLMAX));\n        vbool8_t mask = vmsltu_vx_u8m1_b8(shifted, 'a', __riscv_vl(8, __RISCV_VLMAX));\n        shifted = vadd_vx_u8m1_m(mask, shifted, 26, shifted, __riscv_vl(8, __RISCV_VLMAX));\n\n        // Store the result back to the output string\n        vse8_v_u8m1(reinterpret_cast<uint8_t*>(result.data() + i), shifted, __riscv_vl(8, __RISCV_VLMAX));\n    }\n\n    // Handle the remaining characters\n    for (; i < len; ++i) {\n        char c = s[i];\n        c += shift;\n        if (c > 'z') {\n            c -= 26;\n        }\n        result[i] = c;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    size_t len = s.length();\n    std::string result(len, ' ');\n\n    // Define the shift amount\n    int shift = 2 * 2;\n\n    // Process the string in chunks of vector length\n    size_t i = 0;\n    for (; i <= len - 8; i += 8) {\n        // Load 8 characters into a vector\n        vuint8m1_t input_vec = vle8_v_u8m1(reinterpret_cast<const uint8_t*>(s.data() + i), __riscv_vl(8, __RISCV_VLMAX));\n\n        // Shift each character by the specified amount, wrapping around the alphabet\n        vuint8m1_t shifted_vec = vadd_vx_u8m1(input_vec, shift, __riscv_vl(8, __RISCV_VLMAX));\n        vbool8_t mask = vmsltu_vx_u8m1_b8(shifted_vec, 'a', __riscv_vl(8, __RISCV_VLMAX));\n        shifted_vec = vadd_vx_u8m1_m(mask, shifted_vec, 26, shifted_vec, __riscv_vl(8, __RISCV_VLMAX));\n\n        // Store the result back to the output string\n        vse8_v_u8m1(reinterpret_cast<uint8_t*>(result.data() + i), shifted_vec, __riscv_vl(8, __RISCV_VLMAX));\n    }\n\n    // Handle any remaining characters\n    for (; i < len; ++i) {\n        char c = s[i];\n        c += shift;\n        if (c > 'z') {\n            c -= 26;\n        }\n        result[i] = c;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    size_t len = s.length();\n    std::string result(len, ' ');\n\n    // Define the shift amount\n    int shift = 2 * 2;\n\n    // Process the string in chunks of vector length\n    size_t i = 0;\n    for (; i <= len - 8; i += 8) {\n        vuint8m1_t input = vle8_v_u8m1(reinterpret_cast<const uint8_t*>(s.data() + i), __riscv_vl(8, __RISCV_VLMAX));\n        vuint8m1_t shifted = vadd_vx_u8m1(input, shift, __riscv_vl(8, __RISCV_VLMAX));\n        \n        // Wrap around the shift for lowercase letters\n        vbool8_t mask = vmsltu_vx_u8m1_b8(shifted, 'a', __riscv_vl(8, __RISCV_VLMAX));\n        shifted = vadd_vx_u8m1_m(mask, shifted, 'z' - 'a' + 1, shifted, __riscv_vl(8, __RISCV_VLMAX));\n\n        vse8_v_u8m1(reinterpret_cast<uint8_t*>(result.data() + i), shifted, __riscv_vl(8, __RISCV_VLMAX));\n    }\n\n    // Handle remaining characters\n    for (; i < len; ++i) {\n        char c = s[i];\n        c += shift;\n        if (c > 'z') {\n            c -= ('z' - 'a' + 1);\n        }\n        result[i] = c;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    size_t len = s.length();\n    std::string result(len, ' ');\n\n    // Define the shift amount\n    int shift = 2 * 2;\n\n    // Process the string in chunks of vector length\n    size_t i = 0;\n    for (; i <= len - 8; i += 8) {\n        // Load 8 characters into a vector\n        vuint8m1_t input = vle8_v_u8m1(reinterpret_cast<const uint8_t*>(s.data() + i), __riscv_vl(8, __RISCV_VLMAX));\n\n        // Shift each character by the specified amount\n        vuint8m1_t shifted = vadd_vx_u8m1(input, shift, __riscv_vl(8, __RISCV_VLMAX));\n\n        // Wrap around the shift if it goes past 'z'\n        vbool8_t mask = vmsltu_vx_u8m1_b8(shifted, 'a', __riscv_vl(8, __RISCV_VLMAX));\n        shifted = vmerge_vvm_u8m1(vadd_vx_u8m1(shifted, 'a' - 'z' - 1, __riscv_vl(8, __RISCV_VLMAX)), shifted, mask, __riscv_vl(8, __RISCV_VLMAX));\n\n        // Store the result back to the output string\n        vse8_v_u8m1(reinterpret_cast<uint8_t*>(result.data() + i), shifted, __riscv_vl(8, __RISCV_VLMAX));\n    }\n\n    // Handle the remaining characters\n    for (; i < len; ++i) {\n        char c = s[i];\n        c += shift;\n        if (c > 'z') {\n            c += 'a' - 'z' - 1;\n        }\n        result[i] = c;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message){\n    size_t len = message.length();\n    std::string result(len, ' ');\n\n    // Define vectors for vowels and their replacements\n    const char vowels[] = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n    const char replacements[] = {'c', 'g', 'k', 'q', 'w', 'C', 'G', 'K', 'Q', 'W'};\n\n    // Load the message into a vector\n    vuint8m1_t msg_vec = vle8_v_u8m1((const uint8_t*)message.data(), len);\n\n    // Process each character\n    for (size_t i = 0; i < len; i += 1) {\n        uint8_t ch = vget_v_u8m1_i8(msg_vec, i);\n\n        // Swap case\n        if ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z')) {\n            ch = (ch >= 'a' && ch <= 'z') ? ch - ('a' - 'A') : ch + ('a' - 'A');\n        }\n\n        // Check if the character is a vowel and replace it\n        for (int j = 0; j < 10; ++j) {\n            if (ch == vowels[j]) {\n                ch = replacements[j];\n                break;\n            }\n        }\n\n        // Store the result\n        result[i] = ch;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message){\n    size_t len = message.length();\n    std::string result(len, ' ');\n\n    // Define the vector length\n    size_t vl = __riscv_vsetvl_e8m1(len);\n\n    // Load the message into a vector\n    vuint8m1_t msg_vec = __riscv_vle8_v_u8m1((const uint8_t*)message.data(), vl);\n\n    // Create vectors for vowels and their replacements\n    vuint8m1_t vowels_lower = __riscv_vmv_v_x_u8m1('a', vl);\n    vuint8m1_t vowels_upper = __riscv_vmv_v_x_u8m1('A', vl);\n    vuint8m1_t replacements_lower = __riscv_vmv_v_x_u8m1('c', vl);\n    vuint8m1_t replacements_upper = __riscv_vmv_v_x_u8m1('C', vl);\n\n    // Iterate over each vowel and its replacement\n    for (int i = 0; i < 5; ++i) {\n        // Check for lowercase vowels\n        vbool1_t mask_lower = __riscv_vmseq_vx_u8m1_b1(msg_vec, vowels_lower[i], vl);\n        msg_vec = __riscv_vmerge_vvm_u8m1(msg_vec, replacements_lower[i], mask_lower, vl);\n\n        // Check for uppercase vowels\n        vbool1_t mask_upper = __riscv_vmseq_vx_u8m1_b1(msg_vec, vowels_upper[i], vl);\n        msg_vec = __riscv_vmerge_vvm_u8m1(msg_vec, replacements_upper[i], mask_upper, vl);\n    }\n\n    // Swap case\n    vuint8m1_t case_swapped = __riscv_vxor_vx_u8m1(msg_vec, 0x20, vl);\n\n    // Store the result back to the string\n    __riscv_vse8_v_u8m1((uint8_t*)result.data(), case_swapped, vl);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message){\n    size_t len = message.length();\n    std::string result(len, ' ');\n\n    // Define the vector length\n    size_t vl = __riscv_vsetvl_e8m1(len);\n\n    // Load the message into a vector\n    vuint8m1_t msg_vec = __riscv_vle8_v_u8m1((const uint8_t*)message.data(), vl);\n\n    // Create vectors for vowels and their replacements\n    vuint8m1_t vowels_lower = __riscv_vmv_v_x_u8m1('a', vl);\n    vuint8m1_t vowels_upper = __riscv_vmv_v_x_u8m1('A', vl);\n    vuint8m1_t replacements_lower = __riscv_vmv_v_x_u8m1('c', vl);\n    vuint8m1_t replacements_upper = __riscv_vmv_v_x_u8m1('C', vl);\n\n    // Iterate over each vowel and its replacement\n    for (int i = 0; i < 5; ++i) {\n        // Check for lowercase vowels\n        vbool1_t mask_lower = __riscv_vmseq_vx_u8m1_b1(msg_vec, vowels_lower[i], vl);\n        msg_vec = __riscv_vmerge_vvm_u8m1(msg_vec, replacements_lower[i], mask_lower, vl);\n\n        // Check for uppercase vowels\n        vbool1_t mask_upper = __riscv_vmseq_vx_u8m1_b1(msg_vec, vowels_upper[i], vl);\n        msg_vec = __riscv_vmerge_vvm_u8m1(msg_vec, replacements_upper[i], mask_upper, vl);\n    }\n\n    // Swap case\n    vuint8m1_t case_swapped = __riscv_vxor_vx_u8m1(msg_vec, 0x20, vl);\n\n    // Store the result back to the string\n    __riscv_vse8_v_u8m1((uint8_t*)result.data(), case_swapped, vl);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message){\n    size_t len = message.length();\n    std::string result(len, ' ');\n\n    // Define vectors for vowels and their replacements\n    const char vowels[] = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n    const char replacements[] = {'c', 'g', 'k', 'q', 'w', 'C', 'G', 'K', 'Q', 'W'};\n\n    // Load the message into a vector\n    vuint8m1_t msg_vec = vle8_v_u8m1((const uint8_t*)message.data(), len);\n\n    // Process each character\n    for (size_t i = 0; i < len; i += vsetvl_e8m1(len - i)) {\n        vuint8m1_t current_vec = vle8_v_u8m1((const uint8_t*)(message.data() + i), len - i);\n\n        // Swap case\n        vuint8m1_t swapped_case = vxor_vx_u8m1(current_vec, 0x20, vsetvl_e8m1(len - i));\n\n        // Check for vowels and replace\n        for (int j = 0; j < 10; ++j) {\n            vbool8_t mask = vmseq_vx_u8m1_b8(swapped_case, vowels[j], vsetvl_e8m1(len - i));\n            swapped_case = vmerge_vvm_u8m1(swapped_case, vdup_v_x_u8m1(replacements[j], vsetvl_e8m1(len - i)), mask, vsetvl_e8m1(len - i));\n        }\n\n        // Store the result\n        vse8_v_u8m1((uint8_t*)(result.data() + i), swapped_case, vsetvl_e8m1(len - i));\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message){\n    size_t len = message.length();\n    std::string result(len, ' ');\n\n    // Define vectors for vowels and their replacements\n    const char vowels[] = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n    const char replacements[] = {'c', 'g', 'k', 'q', 'w', 'C', 'G', 'K', 'Q', 'W'};\n\n    // Load the message into a vector\n    vuint8m1_t msg_vec = vle8_v_u8m1((const uint8_t*)message.data(), len);\n\n    // Process each character\n    for (size_t i = 0; i < len; i += 1) {\n        uint8_t ch = vget_v_u8m1_i8(msg_vec, i);\n\n        // Swap case\n        if ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z')) {\n            ch = (ch >= 'a' && ch <= 'z') ? ch - ('a' - 'A') : ch + ('a' - 'A');\n        }\n\n        // Check if the character is a vowel and replace it\n        for (int j = 0; j < 10; ++j) {\n            if (ch == vowels[j]) {\n                ch = replacements[j];\n                break;\n            }\n        }\n\n        // Store the result\n        result[i] = ch;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_107_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        size_t len = key.length();\n\n        if (len == 0) {\n            continue;\n        }\n\n        size_t vl = __riscv_vsetvl_e8m1(len);\n        vbool8_t is_lower = __riscv_vmseq_vx_i8m1(__riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(key.c_str()), vl), 'a' - 'A', vl);\n        vbool8_t is_upper = __riscv_vmseq_vx_i8m1(__riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(key.c_str()), vl), 'A' - 'a', vl);\n\n        for (size_t i = 0; i < len; ++i) {\n            char c = key[i];\n            if (!std::islower(c)) {\n                all_lower = false;\n            }\n            if (!std::isupper(c)) {\n                all_upper = false;\n            }\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        size_t len = key.length();\n\n        if (len == 0) {\n            continue;\n        }\n\n        size_t vl = __riscv_vsetvl_e8m1(len);\n        vbool8_t is_lower = __riscv_vmseq_vx_i8m1(__riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(key.c_str()), vl), 'a' - 'A', vl);\n        vbool8_t is_upper = __riscv_vmseq_vx_i8m1(__riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(key.c_str()), vl), 'A' - 'a', vl);\n\n        for (size_t i = 0; i < len; ++i) {\n            char c = key[i];\n            if (!std::islower(c)) {\n                all_lower = false;\n            }\n            if (!std::isupper(c)) {\n                all_upper = false;\n            }\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        size_t len = key.length();\n\n        if (len == 0) {\n            continue;\n        }\n\n        size_t vl = __riscv_vsetvl_e8m1(len);\n        vuint8m1_t v_key = __riscv_vle8_v_u8m1((const uint8_t*)key.c_str(), vl);\n\n        vbool1_t v_is_lower = __riscv_vmseq_vx_i8m1_b1(v_key, __riscv_vmax_vx_i8m1(__riscv_vmin_vx_i8m1(v_key, 'z', vl), 'a', vl), vl);\n        vbool1_t v_is_upper = __riscv_vmseq_vx_i8m1_b1(v_key, __riscv_vmax_vx_i8m1(__riscv_vmin_vx_i8m1(v_key, 'Z', vl), 'A', vl), vl);\n\n        all_lower &= __riscv_vfirst_m_b1(v_is_lower, vl) == -1;\n        all_upper &= __riscv_vfirst_m_b1(v_is_upper, vl) == -1;\n\n        if (!all_lower && !all_upper) {\n            return false;\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        size_t len = key.length();\n\n        if (len == 0) {\n            continue;\n        }\n\n        size_t vl = __riscv_vsetvl_e8m1(len);\n        vbool8_t mask_lower = __riscv_vmseq_vx_i8m1(__riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(key.c_str()), vl), 'a' - 'A', vl);\n        vbool8_t mask_upper = __riscv_vmseq_vx_i8m1(__riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(key.c_str()), vl), 'A' - 'a', vl);\n\n        for (size_t i = 0; i < len; ++i) {\n            if (!std::islower(key[i])) {\n                all_lower = false;\n            }\n            if (!std::isupper(key[i])) {\n                all_upper = false;\n            }\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        size_t len = key.length();\n\n        if (len == 0) {\n            continue;\n        }\n\n        size_t vl = __riscv_vsetvl_e8m1(len);\n        vbool8_t mask_lower = __riscv_vmseq_vv_i8m1(__riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(key.c_str()), vl),\n                                                   __riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(key.c_str()), vl), vl);\n        vbool8_t mask_upper = __riscv_vmseq_vv_i8m1(__riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(key.c_str()), vl),\n                                                   __riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(key.c_str()), vl), vl);\n\n        for (size_t i = 0; i < len; ++i) {\n            if (!std::islower(key[i])) {\n                all_lower = false;\n            }\n            if (!std::isupper(key[i])) {\n                all_upper = false;\n            }\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_108_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n\n    int *is_prime = new int[n];\n    for (int i = 0; i < n; ++i) is_prime[i] = 1;\n    is_prime[0] = is_prime[1] = 0;\n\n    for (int i = 2; i <= std::sqrt(n); ++i) {\n        if (is_prime[i]) {\n            size_t vl = __riscv_vsetvl_e32m1(n - i * i);\n            vint32m1_t mask = __riscv_vmseq_vx_i32m1(__riscv_vle32_v_i32m1(is_prime + i * i, vl), 1, vl);\n            __riscv_vse32_v_i32m1(is_prime + i * i, __riscv_vand_vx_i32m1(mask, 0, vl), vl);\n            for (int j = i * i + vl; j < n; j += i) {\n                is_prime[j] = 0;\n            }\n        }\n    }\n\n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    delete[] is_prime;\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n\n    int sqrt_n = static_cast<int>(std::sqrt(n));\n    for (int i = 2; i <= sqrt_n; ++i) {\n        if (is_prime[i]) {\n            size_t vl = __riscv_vsetvl_e32m1(n - i * i);\n            vbool32_t mask = __riscv_vmseq_vx_i32m1(__riscv_vle32_v_u32m1(&is_prime[i * i], vl), 1, vl);\n            for (size_t j = 0; j < vl; j += 1) {\n                if (__riscv_vget_mask(mask, j)) {\n                    is_prime[i * i + j * i] = false;\n                }\n            }\n        }\n    }\n\n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n\n    int sqrt_n = static_cast<int>(std::sqrt(n));\n    for (int i = 2; i <= sqrt_n; ++i) {\n        if (is_prime[i]) {\n            size_t vl = __riscv_vsetvl_e32m1(n - i * i);\n            vbool32_t mask = __riscv_vmseq_vx_i32m1(__riscv_vle32_v_u32m1(is_prime.data() + i * i, vl), 1, vl);\n            __riscv_vsse32_v_b32(is_prime.data() + i * i, 1, __riscv_vand_vx_b32m1(mask, 0, vl), vl);\n            for (size_t j = i * i + vl; j < n; j += vl) {\n                vl = __riscv_vsetvl_e32m1(n - j);\n                mask = __riscv_vmseq_vx_i32m1(__riscv_vle32_v_u32m1(is_prime.data() + j, vl), 1, vl);\n                __riscv_vsse32_v_b32(is_prime.data() + j, 1, __riscv_vand_vx_b32m1(mask, 0, vl), vl);\n            }\n        }\n    }\n\n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n\n    int *is_prime = new int[n];\n    for (int i = 0; i < n; ++i) is_prime[i] = 1;\n    is_prime[0] = is_prime[1] = 0;\n\n    for (int i = 2; i <= std::sqrt(n); ++i) {\n        if (is_prime[i]) {\n            size_t vl = __riscv_vsetvl_e32m1(n - i * i);\n            vbool32_t mask = __riscv_vmseq_vx_i32m1(__riscv_vle32_v_i32m1(is_prime + i * i, vl), 1, vl);\n            for (size_t j = 0; j < vl; ++j) {\n                if (__riscv_vget_mask(mask, j)) {\n                    is_prime[i * i + j * i] = 0;\n                }\n            }\n        }\n    }\n\n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) primes.push_back(i);\n    }\n\n    delete[] is_prime;\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n\n    size_t len = n - 2; // Exclude 0 and 1\n    uint8_t* is_prime = new uint8_t[n];\n    std::fill(is_prime, is_prime + n, 1);\n    is_prime[0] = is_prime[1] = 0;\n\n    for (int i = 2; i <= std::sqrt(n); ++i) {\n        if (is_prime[i]) {\n            size_t start = i * i;\n            size_t end = n;\n            size_t offset = start - 2; // Adjust for the excluded 0 and 1\n\n            size_t vl = __riscv_vsetvl_e8m1(len - offset);\n            vbool8_t mask = __riscv_vmseq_vx_u8_m(vl, __riscv_vle8_v_u8_m(vl, is_prime + offset), 1);\n            vuint8_t zero_vec = __riscv_vmv_v_x_u8_m(vl, 0);\n            __riscv_vse8_v_u8_m(vl, is_prime + offset, __riscv_vmerge_vvm_u8_m(mask, zero_vec, __riscv_vle8_v_u8_m(vl, is_prime + offset)));\n\n            for (size_t j = start + i; j < end; j += i) {\n                is_prime[j] = 0;\n            }\n        }\n    }\n\n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    delete[] is_prime;\n    return primes;\n}\n```"}
{"task_id": "SimdBench_109_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint count_upper_simd(const std::string & s){\n    int count = 0;\n    size_t n = s.size();\n    size_t i = 0;\n\n    // Define the vector length\n    size_t vl = __riscv_vsetvl_e8m1(n);\n\n    // Create a vector mask for even indices\n    vbool8_t even_mask = __riscv_vmseq_vx_u8_m(vbool8_t(), __riscv_vle8_v_u8(s.data(), vl), 0, vl);\n    for (size_t j = 1; j < vl; j += 2) {\n        even_mask = __riscv_vmand_vv_b8(even_mask, __riscv_vmseq_vx_u8_m(vbool8_t(), __riscv_vle8_v_u8(s.data() + j, vl - j), j, vl - j), vl - j);\n    }\n\n    while (i < n) {\n        // Load the characters into a vector\n        vuint8m1_t chars = __riscv_vle8_v_u8((const uint8_t*)(s.data() + i), vl);\n\n        // Create a mask for uppercase vowels\n        vbool8_t vowel_mask = __riscv_vmand_vv_b8(__riscv_vmand_vv_b8(__riscv_vmge_vx_u8_m(vbool8_t(), chars, 'A', vl), __riscv_vle_vx_u8_m(vbool8_t(), chars, 'Z', vl), vl), even_mask, vl);\n\n        // Count the number of true values in the mask\n        count += __riscv_vpopc_b8_m(vowel_mask, vl);\n\n        // Move to the next vector length\n        i += vl;\n        vl = __riscv_vsetvl_e8m1(n - i);\n        even_mask = __riscv_vmseq_vx_u8_m(vbool8_t(), __riscv_vle8_v_u8(s.data() + i, vl), 0, vl);\n        for (size_t j = 1; j < vl; j += 2) {\n            even_mask = __riscv_vmand_vv_b8(even_mask, __riscv_vmseq_vx_u8_m(vbool8_t(), __riscv_vle8_v_u8(s.data() + i + j, vl - j), j, vl - j), vl - j);\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint count_upper_simd(const std::string & s){\n    int count = 0;\n    size_t n = s.size();\n    size_t i = 0;\n\n    // Define the vector length\n    size_t vl = __riscv_vsetvl_e8m1(n);\n\n    // Create a vector mask for even indices\n    vbool8_t even_mask = __riscv_vmseq_vx_u8_m(vbool8_t(), __riscv_vle8_v_u8(s.data(), vl), 0, vl);\n    for (size_t j = 1; j < n; j += 2) {\n        even_mask = __riscv_vmand_vx_b8_m(even_mask, even_mask, 0, vl);\n    }\n\n    // Define the vector for uppercase vowels\n    vuint8m1_t vowels = __riscv_vmv_v_x_u8('A', vl);\n    vowels = __riscv_vslideup_vx_u8_m(vowels, vowels, 'E', vl);\n    vowels = __riscv_vslideup_vx_u8_m(vowels, vowels, 'I', vl);\n    vowels = __riscv_vslideup_vx_u8_m(vowels, vowels, 'O', vl);\n    vowels = __riscv_vslideup_vx_u8_m(vowels, vowels, 'U', vl);\n\n    while (i < n) {\n        vl = __riscv_vsetvl_e8m1(n - i);\n        vuint8m1_t chars = __riscv_vle8_v_u8(s.data() + i, vl);\n        vbool8_t vowel_mask = __riscv_vmsne_vv_u8_m(vbool8_t(), chars, vowels, vl);\n        vbool8_t result_mask = __riscv_vmand_mm_b8(even_mask, vowel_mask, vl);\n        count += __riscv_vpopc_m_b8(result_mask, vl);\n        i += vl;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint count_upper_simd(const std::string & s){\n    int count = 0;\n    size_t n = s.size();\n    size_t i = 0;\n\n    // Define the vector length\n    size_t vl = __riscv_vsetvl_e8m1(n);\n\n    // Create a vector mask for even indices\n    vbool8_t even_mask = __riscv_vmseq_vx_u8_m(vbool8_t(), __riscv_vle8_v_u8(s.data(), vl), 0, vl);\n    for (size_t j = 1; j < n; j += 2) {\n        even_mask = __riscv_vmand_vvm_b8(even_mask, __riscv_vmseq_vx_u8_m(vbool8_t(), __riscv_vle8_v_u8(s.data() + j, vl), 0, vl), vl);\n    }\n\n    // Define the vector for uppercase vowels\n    vuint8m1_t vowels = __riscv_vle8_v_u8(reinterpret_cast<const uint8_t*>(\"AEIOU\"), 5);\n\n    while (i < n) {\n        vl = __riscv_vsetvl_e8m1(n - i);\n        vuint8m1_t chars = __riscv_vle8_v_u8(reinterpret_cast<const uint8_t*>(s.data() + i), vl);\n        vbool8_t vowel_mask = __riscv_vmsne_vv_u8_m(vbool8_t(), chars, vowels, 5);\n        vbool8_t result_mask = __riscv_vmand_vvm_b8(even_mask, vowel_mask, vl);\n        count += __riscv_vpopc_m_b8(result_mask, vl);\n        i += vl;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint count_upper_simd(const std::string & s){\n    int count = 0;\n    size_t n = s.size();\n    size_t i = 0;\n\n    // Define the vector length\n    size_t vl = __riscv_vsetvl_e8m1(n);\n\n    // Create a vector mask for even indices\n    vbool8_t even_mask = __riscv_vmseq_vx_u8_m(vbool8_t(), __riscv_vle8_v_u8(s.data(), vl), 0, vl);\n    for (size_t j = 1; j < n; j += 2) {\n        even_mask = __riscv_vmand_vx_b8_m(even_mask, even_mask, 0, vl);\n        even_mask = __riscv_vsse8_v_u8_m(s.data() + j, 2, even_mask, 0, vl);\n    }\n\n    // Load the string into a vector\n    vuint8m1_t str_vec = __riscv_vle8_v_u8(s.data(), vl);\n\n    // Create a vector of uppercase vowels\n    vuint8m1_t vowels = __riscv_vmv_v_x_u8('A', vl);\n    vowels = __riscv_vslide1up_vx_u8_m(vowels, vowels, 'E', vl);\n    vowels = __riscv_vslide1up_vx_u8_m(vowels, vowels, 'I', vl);\n    vowels = __riscv_vslide1up_vx_u8_m(vowels, vowels, 'O', vl);\n    vowels = __riscv_vslide1up_vx_u8_m(vowels, vowels, 'U', vl);\n\n    // Check for uppercase vowels at even indices\n    vbool8_t vowel_mask = __riscv_vmsne_vv_u8_m(vbool8_t(), str_vec, vowels, vl);\n    vowel_mask = __riscv_vmand_mm_b8(even_mask, vowel_mask, vl);\n\n    // Count the number of true values in the mask\n    count = __riscv_vpopc_m_b8(vowel_mask, vl);\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint count_upper_simd(const std::string & s){\n    int count = 0;\n    size_t n = s.size();\n    size_t i = 0;\n\n    // Define the vector length\n    size_t vl = __riscv_vsetvl_e8m1(n);\n\n    // Create a vector to store the characters at even indices\n    vuint8m1_t even_chars = __riscv_vle8_v_u8m1(s.data(), vl);\n\n    // Create a vector mask for uppercase vowels\n    vbool1_t vowel_mask = __riscv_vmseq_vx_i8m1_b1(even_chars, 'A', vl);\n    vowel_mask = __riscv_vorr_vv_b1(vowel_mask, __riscv_vmseq_vx_i8m1_b1(even_chars, 'E', vl), vl);\n    vowel_mask = __riscv_vorr_vv_b1(vowel_mask, __riscv_vmseq_vx_i8m1_b1(even_chars, 'I', vl), vl);\n    vowel_mask = __riscv_vorr_vv_b1(vowel_mask, __riscv_vmseq_vx_i8m1_b1(even_chars, 'O', vl), vl);\n    vowel_mask = __riscv_vorr_vv_b1(vowel_mask, __riscv_vmseq_vx_i8m1_b1(even_chars, 'U', vl), vl);\n\n    // Count the number of true values in the mask\n    count += __riscv_vpopc_b1(vowel_mask, vl);\n\n    // Process remaining characters if n is odd\n    if (n % 2 != 0) {\n        for (; i < n; i += 2) {\n            char c = s[i];\n            if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_110_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    vint32m1_t v_stones = __riscv_vseqiv_e32m1(0, 1, vl);\n    v_stones = __riscv_vadd_vx_i32m1(v_stones, n, vl);\n\n    int start = n % 2 == 0 ? 2 : 1;\n    vint32m1_t v_increment = __riscv_vmv_v_x_i32m1(start, vl);\n    vint32m1_t v_ones = __riscv_vmv_v_x_i32m1(2, vl);\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m1(n - i);\n        v_stones = __riscv_vadd_vv_i32m1(v_stones, v_increment, vl);\n        v_increment = __riscv_vadd_vv_i32m1(v_increment, v_ones, vl);\n        __riscv_vse32_v_i32m1(&result[i], v_stones, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t v_result = __riscv_vmv_v_x_i32m1(n, vl);\n    vint32m1_t v_increment = __riscv_vadd_vx_i32m1(__riscv_vmseq_vx_i32m1(v_result, n, vl), 1, vl);\n    v_result = __riscv_vadd_vv_i32m1(v_result, v_increment, vl);\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m1(n - i);\n        v_result = __riscv_vadd_vx_i32m1(v_result, 2, vl);\n        __riscv_vse32_v_i32m1(&result[i], v_result, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    vint32m1_t v_stones = __riscv_vseq_iv_i32m1(n, 1, vl);\n    vint32m1_t v_increment = __riscv_vmseq_vx_i32m1_b32(__riscv_vrem_vx_i32m1(v_stones, 2, vl), 0, vl);\n    v_increment = __riscv_vadd_vx_i32m1(v_increment, 1, vl);\n    v_increment = __riscv_vadd_vx_i32m1(v_increment, n % 2, vl);\n\n    v_stones = __riscv_vmul_vx_i32m1(v_stones, 2, vl);\n    v_stones = __riscv_vsub_vx_i32m1(v_stones, 1, vl);\n    v_stones = __riscv_vadd_vv_i32m1(v_stones, v_increment, vl);\n\n    __riscv_vse32_v_i32m1(result.data(), v_stones, vl);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    vint32m1_t v_stones = __riscv_vseqiv_e32m1(0, 1, vl);\n    v_stones = __riscv_vadd_vx_i32m1(v_stones, n, vl);\n\n    int start = (n % 2 == 0) ? 2 : 1;\n    vint32m1_t v_increment = __riscv_vmseq_vx_i32m1(v_stones, 1, vl);\n    v_increment = __riscv_vadd_vx_i32m1(v_increment, start, vl);\n    v_increment = __riscv_vmul_vx_i32m1(v_increment, 2, vl);\n\n    v_stones = __riscv_vadd_vv_i32m1(v_stones, v_increment, vl);\n\n    __riscv_vse32_v_i32m1(result.data(), v_stones, vl);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    vint32m1_t v_stones = __riscv_vseqiv_e32m1(0, 1, vl);\n    v_stones = __riscv_vadd_vx_i32m1(v_stones, n, vl);\n\n    int start = (n % 2 == 0) ? 2 : 1;\n    vint32m1_t v_increment = __riscv_vmv_v_x_i32m1(start, vl);\n    vint32m1_t v_step = __riscv_vmv_v_x_i32m1(2, vl);\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m1(n - i);\n        v_stones = __riscv_vadd_vv_i32m1(v_stones, v_increment, vl);\n        __riscv_vse32_v_i32m1(&result[i], v_stones, vl);\n        v_increment = __riscv_vadd_vv_i32m1(v_increment, v_step, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_111_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <bitset>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n\n    size_t vl = m - n + 1;\n    vint64m1_t vec_n = vmv_v_x_i64m1(n, vl);\n    vint64m1_t vec_m = vmv_v_x_i64m1(m, vl);\n    vint64m1_t vec_range = vseq_vv_i64m1(vec_n, vec_m, vl);\n\n    vint64m1_t vec_sum = vredsum_vs_i64m1_i64m1(vec_range, 0, vl);\n    int64_t sum = vec_sum[0];\n\n    int64_t avg = sum / vl;\n    std::string binary = std::bitset<64>(avg).to_string();\n\n    // Remove leading zeros\n    binary = binary.substr(binary.find('1'));\n\n    return binary;\n}\n```"}
{"task_id": "SimdBench_111_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <bitset>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n\n    size_t vl = m - n + 1;\n    vint64m1_t vec_n = vmv_v_x_i64m1(n, vl);\n    vint64m1_t vec_m = vmv_v_x_i64m1(m, vl);\n    vint64m1_t vec_range = vseq_vv_i64m1(vec_n, vec_m, vl);\n\n    vint64m1_t vec_sum = vredsum_vs_i64m1_i64m1(vec_range, 0, vl);\n    int64_t sum = vec_sum[0];\n\n    int64_t avg = sum / vl;\n    std::string binary = std::bitset<64>(avg).to_string();\n\n    // Remove leading zeros\n    binary = binary.substr(binary.find('1'));\n\n    return binary;\n}\n```"}
{"task_id": "SimdBench_111_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <bitset>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n\n    size_t vl = m - n + 1;\n    vint64m1_t vec = vseq_i64m1(n, 1, vl);\n    vint64m1_t sum_vec = vredsum_vs_i64m1_i64m1(vec, 0, vl);\n    int64_t sum = vfirstm1_i64m1(sum_vec, vl);\n\n    int64_t avg = sum / vl;\n    std::string binary = std::bitset<64>(avg).to_string();\n    auto pos = binary.find('1');\n    if (pos != std::string::npos) {\n        return binary.substr(pos);\n    }\n    return \"0\";\n}\n```"}
{"task_id": "SimdBench_111_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <bitset>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n\n    size_t vl = m - n + 1;\n    vint64m1_t vec_n = vmv_v_x_i64m1(n, vl);\n    vint64m1_t vec_m = vmv_v_x_i64m1(m, vl);\n    vint64m1_t vec_range = vseq_vv_i64m1(vec_n, vec_m, vl);\n\n    vint64m1_t vec_sum = vredsum_vs_i64m1_i64m1(vec_range, 0, vl);\n    int64_t sum = vec_sum[0];\n\n    int64_t avg = sum / vl;\n    std::string binary = std::bitset<64>(avg).to_string();\n\n    // Remove leading zeros\n    binary = binary.substr(binary.find('1'));\n\n    return binary;\n}\n```"}
{"task_id": "SimdBench_111_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <bitset>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n\n    size_t vl = m - n + 1;\n    vint64m1_t vec_n = vmv_v_x_i64m1(n, vl);\n    vint64m1_t vec_m = vmv_v_x_i64m1(m, vl);\n    vint64m1_t vec_range = vseq_vv_i64m1(vec_n, vec_m, vl);\n\n    vint64m1_t vec_sum = vredsum_vs_i64m1_i64m1(vec_range, 0, vl);\n    int64_t sum = vec_sum[0];\n\n    int64_t avg = sum / vl;\n    std::string binary = std::bitset<64>(avg).to_string();\n\n    // Remove leading zeros\n    binary = binary.substr(binary.find('1'));\n\n    return binary;\n}\n```"}
{"task_id": "SimdBench_112_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    int *result_ptr = result.data();\n\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    vint32m1_t v_index = __riscv_vseqiv_e32m1(vl);\n    vint32m1_t v_one = __riscv_vmv_v_x_i32m1(1, vl);\n    vint32m1_t v_ten_thousand = __riscv_vmv_v_x_i32m1(10000, vl);\n    vbool32_t v_mask_even = __riscv_vmseq_vx_i32m1_b32(v_index, 0, vl);\n\n    vint32m1_t v_factorial = v_one;\n    vint32m1_t v_sum = v_one;\n\n    for (int i = 1; i <= n; ++i) {\n        vint32m1_t v_current_index = __riscv_vadd_vx_i32m1(v_index, i - 1, vl);\n        vbool32_t v_mask_current_even = __riscv_vmseq_vx_i32m1_b32(v_current_index, 0, vl);\n\n        v_factorial = __riscv_vnmsub_vv_i32m1(v_factorial, v_current_index, v_factorial, vl);\n        v_factorial = __riscv_vrem_vv_i32m1(v_factorial, v_ten_thousand, vl);\n\n        v_sum = __riscv_vadd_vv_i32m1(v_sum, v_current_index, vl);\n\n        vint32m1_t v_result = __riscv_vmerge_vvm_i32m1(v_factorial, v_sum, v_mask_current_even, vl);\n        __riscv_vse32_v_i32m1(result_ptr + i - 1, v_result, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    int *result_ptr = result.data();\n\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    vint32m1_t idx_vec = __riscv_vseqiv_e32m1(vl);\n    vint32m1_t one_vec = __riscv_vmv_v_x_i32m1(1, vl);\n    vint32m1_t ten_thousand_vec = __riscv_vmv_v_x_i32m1(10000, vl);\n    vbool32_t mask_even = __riscv_vmseq_vx_i32m1_b32(idx_vec, 0, vl);\n\n    vint32m1_t fact_vec = one_vec;\n    vint32m1_t sum_vec = one_vec;\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m1(n - i);\n\n        idx_vec = __riscv_vadd_vx_i32m1(idx_vec, 1, vl);\n        mask_even = __riscv_vmseq_vx_i32m1_b32(idx_vec, 0, vl);\n\n        vint32m1_t new_fact_vec = __riscv_vmul_vv_i32m1(fact_vec, idx_vec, vl);\n        fact_vec = __riscv_vrem_vv_i32m1(new_fact_vec, ten_thousand_vec, vl);\n\n        vint32m1_t new_sum_vec = __riscv_vadd_vv_i32m1(sum_vec, idx_vec, vl);\n        sum_vec = new_sum_vec;\n\n        vint32m1_t result_vec = __riscv_vmerge_vvm_i32m1(fact_vec, sum_vec, mask_even, vl);\n        __riscv_vse32_v_i32m1(result_ptr + i, result_vec, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    int *result_ptr = result.data();\n\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    vint32m1_t v_index = __riscv_vseqiv_e32m1(vl);\n    vint32m1_t v_ones = __riscv_vmv_v_x_i32m1(1, vl);\n    vint32m1_t v_twos = __riscv_vmv_v_x_i32m1(2, vl);\n    vint32m1_t v_ten_thousand = __riscv_vmv_v_x_i32m1(10000, vl);\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m1(n - i);\n\n        vint32m1_t v_i = __riscv_vadd_vx_i32m1(v_index, i, vl);\n        vbool32_t v_even_mask = __riscv_vmseq_vx_i32m1_b32(v_i, 0, vl);\n\n        vint32m1_t v_factorial = v_ones;\n        vint32m1_t v_sum = v_ones;\n\n        for (int j = 2; j <= n; ++j) {\n            vint32m1_t v_j = __riscv_vmv_v_x_i32m1(j, vl);\n            v_factorial = __riscv_vmul_vv_i32m1(v_factorial, v_j, vl);\n            v_factorial = __riscv_vrem_vv_i32m1(v_factorial, v_ten_thousand, vl);\n            v_sum = __riscv_vadd_vv_i32m1(v_sum, v_j, vl);\n        }\n\n        vint32m1_t v_result = __riscv_vmerge_vvm_i32m1(v_factorial, v_sum, v_even_mask, vl);\n        __riscv_vse32_v_i32m1(result_ptr + i, v_result, vl);\n\n        v_index = __riscv_vadd_vx_i32m1(v_index, vl, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    int *result_ptr = result.data();\n\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    vint32m1_t v_index = __riscv_vseqiv_e32m1(vl);\n    vint32m1_t v_ones = __riscv_vmv_v_x_i32m1(1, vl);\n    vint32m1_t v_twos = __riscv_vmv_v_x_i32m1(2, vl);\n    vint32m1_t v_ten_thousand = __riscv_vmv_v_x_i32m1(10000, vl);\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m1(n - i);\n\n        vint32m1_t v_i = __riscv_vadd_vx_i32m1(v_index, i, vl);\n        vbool32_t v_even_mask = __riscv_vmseq_vx_i32m1_b32(v_i, 0, vl);\n\n        vint32m1_t v_factorial = v_ones;\n        vint32m1_t v_sum = v_ones;\n\n        for (int j = 2; j <= n; ++j) {\n            vint32m1_t v_j = __riscv_vmv_v_x_i32m1(j, vl);\n            v_factorial = __riscv_vnmsub_wv_wv_i32m1(v_factorial, v_j, v_factorial, vl);\n            v_factorial = __riscv_vrem_vv_i32m1(v_factorial, v_ten_thousand, vl);\n            v_sum = __riscv_vadd_vv_i32m1(v_sum, v_j, vl);\n        }\n\n        vint32m1_t v_result = __riscv_vmerge_vvm_i32m1(v_factorial, v_sum, v_even_mask, vl);\n        __riscv_vse32_v_i32m1(result_ptr + i, v_result, vl);\n\n        v_index = __riscv_vadd_vx_i32m1(v_index, vl, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    int *result_ptr = result.data();\n\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    vint32m1_t idx_vec = __riscv_vseqiv_e32m1(vl);\n    vint32m1_t one_vec = __riscv_vmv_v_x_i32m1(1, vl);\n    vint32m1_t ten_thousand_vec = __riscv_vmv_v_x_i32m1(10000, vl);\n    vbool32_t even_mask = __riscv_vmseq_vx_i32m1_b32(idx_vec, 0, vl);\n\n    vint32m1_t fact_vec = one_vec;\n    vint32m1_t sum_vec = one_vec;\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m1(n - i);\n\n        idx_vec = __riscv_vadd_vx_i32m1(idx_vec, 1, vl);\n        even_mask = __riscv_vmseq_vx_i32m1_b32(idx_vec, 0, vl);\n\n        vint32m1_t new_fact_vec = __riscv_vmul_vv_i32m1(fact_vec, idx_vec, vl);\n        fact_vec = __riscv_vrem_vv_i32m1(new_fact_vec, ten_thousand_vec, vl);\n\n        vint32m1_t new_sum_vec = __riscv_vadd_vv_i32m1(sum_vec, idx_vec, vl);\n        sum_vec = new_sum_vec;\n\n        vint32m1_t result_vec = __riscv_vmerge_vvm_i32m1(fact_vec, sum_vec, even_mask, vl);\n        __riscv_vse32_v_i32m1(result_ptr + i, result_vec, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_113_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t vn = __riscv_vseqiv_e32m1(vl);\n    vbool32_t mask = __riscv_vmslt_vx_i32m1_b32(vn, n + 1, vl);\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m1(n - i);\n        vn = __riscv_vadd_vx_i32m1(__riscv_vseqiv_e32m1(vl), i, vl);\n        mask = __riscv_vmslt_vx_i32m1_b32(vn, n + 1, vl);\n\n        vint32m1_t reversed = vn;\n        vint32m1_t temp = vn;\n        vint32m1_t zero = __riscv_vmv_v_x_i32m1(0, vl);\n        vint32m1_t ten = __riscv_vmv_v_x_i32m1(10, vl);\n\n        for (int j = 0; j < 10; ++j) {\n            vint32m1_t digit = __riscv_vrem_vv_i32m1(temp, ten, vl);\n            reversed = __riscv_vmacc_vv_i32m1(reversed, digit, __riscv_vsll_vx_i32m1(reversed, 3, vl), vl);\n            temp = __riscv_vdiv_vv_i32m1(temp, ten, vl);\n        }\n\n        vbool32_t is_palindrome = __riscv_vmsne_vv_i32m1_b32(vn, reversed, vl);\n        vbool32_t is_even = __riscv_vmand_vv_b32(__riscv_vmsne_vx_i32m1_b32(vn, zero, vl), __riscv_vmsne_vx_i32m1_b32(__riscv_vand_vx_i32m1(vn, 1, vl), zero, vl), vl);\n        vbool32_t is_odd = __riscv_vmand_vv_b32(is_palindrome, __riscv_vmsne_vx_i32m1_b32(__riscv_vand_vx_i32m1(vn, 1, vl), zero, vl), vl);\n\n        even_count += __riscv_vpopc_b32_m(is_even, mask);\n        odd_count += __riscv_vpopc_b32_m(is_odd, mask);\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t indices = __riscv_vseqiv_e32m1(vl);\n    vint32m1_t ones = __riscv_vmv_v_x_i32m1(1, vl);\n    vbool32_t mask;\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m1(n - i);\n        indices = __riscv_vadd_vx_i32m1(indices, 1, vl);\n\n        vint32m1_t reversed = indices;\n        vint32m1_t temp = indices;\n        vint32m1_t zero = __riscv_vmvdv_v_i32m1(0, vl);\n        vint32m1_t ten = __riscv_vmv_v_x_i32m1(10, vl);\n\n        // Reverse the number\n        for (int j = 0; j < 5; ++j) { // Maximum digits in 2^10 is 4, so 5 iterations are safe\n            vint32m1_t digit = __riscv_vrem_vv_i32m1(temp, ten, vl);\n            reversed = __riscv_vfmacc_vv_i32m1(reversed, ten, digit, vl);\n            temp = __riscv_vdiv_vv_i32m1(temp, ten, vl);\n        }\n\n        mask = __riscv_vmsne_vv_i32m1_b32(indices, reversed, vl);\n        vint32m1_t palindromes = __riscv_vcompress_vm_i32m1(indices, mask, vl);\n\n        vl = __riscv_vget_vl_e32m1(palindromes);\n        vbool32_t even_mask = __riscv_vmand_vx_i32m1_b32(__riscv_vmerge_vvm_i32m1(zero, palindromes, ones, vl), 1, vl);\n        vbool32_t odd_mask = __riscv_vmnand_vx_i32m1_b32(__riscv_vmerge_vvm_i32m1(zero, palindromes, ones, vl), 1, vl);\n\n        even_count += __riscv_vpopc_b32_m(even_mask, vl);\n        odd_count += __riscv_vpopc_b32_m(odd_mask, vl);\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t vn = __riscv_vseqiv_e32m1(vl);\n    vbool32_t mask = __riscv_vmseq_vx_i32m1_b32(vn, 0, vl);\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m1(n - i);\n        vn = __riscv_vadd_vx_i32m1(__riscv_vseqiv_e32m1(vl), 1, vl);\n        mask = __riscv_vmsle_vx_i32m1_b32(vn, n, vl);\n\n        vint32m1_t reversed = vn;\n        vint32m1_t temp = vn;\n        vint32m1_t zero = __riscv_vmv_v_x_i32m1(0, vl);\n        vint32m1_t ten = __riscv_vmv_v_x_i32m1(10, vl);\n\n        for (int j = 0; j < 10; ++j) {\n            vint32m1_t digit = __riscv_vrem_vv_i32m1(temp, ten, vl);\n            reversed = __riscv_vfmacc_vv_i32m1(reversed, ten, digit, vl);\n            temp = __riscv_vdiv_vv_i32m1(temp, ten, vl);\n        }\n\n        vbool32_t is_palindrome = __riscv_vmsne_vv_i32m1_b32(vn, reversed, vl);\n        is_palindrome = __riscv_vmand_vv_b32(is_palindrome, mask, vl);\n\n        vbool32_t is_even = __riscv_vmand_vx_b32(__riscv_vmsne_vx_i32m1_b32(vn, 0, vl), is_palindrome, vl);\n        vbool32_t is_odd = __riscv_vmand_vx_b32(__riscv_vmsne_vx_i32m1_b32(vn, 1, vl), is_palindrome, vl);\n\n        even_count += __riscv_vpopc_b32(is_even);\n        odd_count += __riscv_vpopc_b32(is_odd);\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t vn = __riscv_vseqi_v_i32m1(1, vl);\n    vint32m1_t vone = __riscv_vmv_v_x_i32m1(1, vl);\n    vint32m1_t vtwo = __riscv_vmv_v_x_i32m1(2, vl);\n    vbool32_t vmask;\n\n    for (int i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m1(n - i);\n        vint32m1_t vrange = __riscv_vadd_vv_i32m1(vn, __riscv_vmseq_vx_i32m1(i, vl), vl);\n\n        // Check if numbers are palindromes\n        vbool32_t vis_palindrome = __riscv_vmseq_vv_i32m1(vrange, __riscv_vrev8_v_i32m1(vrange, vl), vl);\n\n        // Count even palindromes\n        vbool32_t vis_even = __riscv_vmand_vv_b32(__riscv_vmseq_vv_i32m1(__riscv_vand_vx_i32m1(vrange, 1, vl), vzero_i32m1(), vl), vis_palindrome, vl);\n        even_count += __riscv_vpopc_b32_m(vis_even, vl);\n\n        // Count odd palindromes\n        vbool32_t vis_odd = __riscv_vmand_vv_b32(__riscv_vmnand_vv_b32(__riscv_vmseq_vv_i32m1(__riscv_vand_vx_i32m1(vrange, 1, vl), vzero_i32m1(), vl), vis_palindrome, vl), vis_palindrome, vl);\n        odd_count += __riscv_vpopc_b32_m(vis_odd, vl);\n\n        vn = __riscv_vadd_vv_i32m1(vn, vone, vl);\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t indices = __riscv_vseqiv_e32m1(vl);\n    vint32m1_t ones = __riscv_vmv_v_x_i32m1(1, vl);\n    vbool32_t mask;\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m1(n - i);\n        indices = __riscv_vadd_vx_i32m1(indices, 1, vl);\n\n        // Check if the number is a palindrome\n        vint32m1_t reversed = indices;\n        vint32m1_t temp = indices;\n        vint32m1_t zero = __riscv_vmv_v_x_i32m1(0, vl);\n        vint32m1_t ten = __riscv_vmv_v_x_i32m1(10, vl);\n\n        for (int j = 0; j < 10; ++j) { // Assuming max 10 digits for numbers up to 2^10\n            vint32m1_t digit = __riscv_vrem_vv_i32m1(temp, ten, vl);\n            reversed = __riscv_vmacc_vv_i32m1(reversed, digit, ten, vl);\n            temp = __riscv_vdiv_vv_i32m1(temp, ten, vl);\n        }\n\n        mask = __riscv_vmsne_vv_i32m1_b32(indices, reversed, vl);\n        vint32m1_t palindromes = __riscv_vcompress_vm_i32m1(mask, ones, vl);\n\n        // Count even and odd palindromes\n        mask = __riscv_vmand_vx_i32m1_b32(__riscv_vmand_vx_i32m1_b32(mask, palindromes, 1, vl), 0, vl);\n        even_count += __riscv_vpopc_m_b32(mask, vl);\n\n        mask = __riscv_vmand_vx_i32m1_b32(__riscv_vmand_vx_i32m1_b32(mask, palindromes, 1, vl), 1, vl);\n        odd_count += __riscv_vpopc_m_b32(mask, vl);\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_114_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n\nint count_nums_simd(const std::vector<int>& n) {\n    size_t size = n.size();\n    int count = 0;\n\n    // Define the vector length\n    size_t vl = __riscv_vsetvl_e32m1(size);\n\n    // Load the input vector\n    vint32m1_t vec = __riscv_vle32_v_i32m1(n.data(), vl);\n\n    // Create a mask for counting elements with sum of digits > 0\n    vbool1_t mask = __riscv_vmv_v_x_b1(false, vl);\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = __riscv_vsetvl_e32m1(size - i);\n\n        // Load the next segment of the vector\n        vec = __riscv_vle32_v_i32m1(n.data() + i, vl);\n\n        // Process each element in the vector\n        for (size_t j = 0; j < vl; ++j) {\n            int num = n[i + j];\n            int sum = 0;\n            int abs_num = std::abs(num);\n            while (abs_num > 0) {\n                sum += abs_num % 10;\n                abs_num /= 10;\n            }\n            if (num < 0) {\n                sum = sum - 2 * (std::abs(num) % 10);\n            }\n            if (sum > 0) {\n                mask = __riscv_vmset_m_b1(mask, j, true);\n            }\n        }\n\n        // Count the number of true elements in the mask\n        count += __riscv_vpopc_m_b1(mask, vl);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n\nint count_nums_simd(const std::vector<int>& n) {\n    size_t size = n.size();\n    int count = 0;\n\n    // Determine the maximum vector length supported\n    size_t vl = __riscv_vsetvl_e32m1(size);\n\n    // Create a vector register to store the results\n    vbool32_t result_mask = __riscv_vfalse();\n\n    // Process the vector in chunks of 'vl'\n    for (size_t i = 0; i < size; i += vl) {\n        // Load a segment of the input vector into a vector register\n        vint32m1_t vec = __riscv_vle32_v_i32m1(&n[i], vl);\n\n        // Initialize a vector register to store the sum of digits\n        vint32m1_t sum_digits = __riscv_vmv_v_x_i32m1(0, vl);\n\n        // Calculate the sum of digits for each element in the vector\n        for (size_t j = 0; j < vl; ++j) {\n            int num = n[i + j];\n            int sum = 0;\n            int abs_num = std::abs(num);\n            while (abs_num > 0) {\n                sum += abs_num % 10;\n                abs_num /= 10;\n            }\n            if (num < 0) {\n                sum = sum - 2 * (num % 10); // Adjust for the negative sign\n            }\n            sum_digits = __riscv_vfslide1up_vx_i32m1(sum_digits, sum, vl);\n        }\n\n        // Compare the sum of digits with 0 and update the result mask\n        result_mask = __riscv_vor_vv_b32(result_mask, __riscv_vmslt_vx_i32m1_b32(sum_digits, 0, vl), vl);\n    }\n\n    // Count the number of true elements in the result mask\n    for (size_t i = 0; i < size; ++i) {\n        if (__riscv_vget_i_b32(result_mask, i)) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n\nint count_nums_simd(const std::vector<int>& n) {\n    size_t size = n.size();\n    int count = 0;\n    size_t vl;\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n        vint32m8_t vec = vle32_v_i32m8(&n[i], vl);\n        vbool8_t mask = vmseq_vx_i32m8_b8(vec, 0, vl);\n        vec = vneg_v_i32m8_m(mask, vec, vec, vl);\n\n        vint32m8_t sum_digits = vdup_v_i32m8(0, vl);\n        vint32m8_t ones = vdup_v_i32m8(1, vl);\n\n        for (size_t j = 0; j < 32; ++j) {\n            vint32m8_t abs_vec = vabs_v_i32m8(vec, vl);\n            vint32m8_t digits = vrem_vv_i32m8(abs_vec, ones, vl);\n            sum_digits = vadd_vv_i32m8(sum_digits, digits, vl);\n            vec = vsra_vx_i32m8(vec, 1, vl);\n        }\n\n        mask = vmsgt_vx_i32m8_b8(sum_digits, 0, vl);\n        count += vmcntm_b8_m(mask, mask, vl);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n\nint count_nums_simd(const std::vector<int>& n) {\n    size_t size = n.size();\n    int count = 0;\n    size_t vl;\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n        vint32m8_t vec = vle32_v_i32m8(&n[i], vl);\n        vbool8_t mask = vmseq_vx_i32m8_b8(vec, 0, vl);\n        vec = vneg_v_i32m8_m(mask, vec, vec, vl);\n\n        vint32m8_t sum_digits = vdup_v_i32m8(0, vl);\n        vint32m8_t ones = vdup_v_i32m8(1, vl);\n\n        for (size_t j = 0; j < 32; ++j) {\n            vint32m8_t abs_vec = vabs_v_i32m8(vec, vl);\n            vint32m8_t digits = vrem_vv_i32m8(abs_vec, ones, vl);\n            sum_digits = vadd_vv_i32m8(sum_digits, digits, vl);\n            vec = vsra_vx_i32m8(vec, 1, vl);\n        }\n\n        mask = vmsgt_vx_i32m8_b8(sum_digits, 0, vl);\n        count += vmcntm_b8_m(mask, mask, vl);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n\nint count_nums_simd(const std::vector<int>& n) {\n    size_t size = n.size();\n    int count = 0;\n    size_t vl;\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n        vint32m8_t vec = vle32_v_i32m8(&n[i], vl);\n        vbool8_t mask = vmseq_vx_i32m8_b8(vec, 0, vl);\n        vec = vneg_v_i32m8_m(mask, vec, vec, vl);\n\n        vint32m8_t sum_digits = vdup_v_i32m8(0, vl);\n        vint32m8_t ones = vdup_v_i32m8(1, vl);\n\n        for (size_t j = 0; j < 32; ++j) {\n            vint32m8_t abs_vec = vabs_v_i32m8(vec, vl);\n            vint32m8_t digits = vrem_vv_i32m8(abs_vec, ones, vl);\n            sum_digits = vadd_vv_i32m8(sum_digits, digits, vl);\n            vec = vsra_vx_i32m8(vec, 1, vl);\n        }\n\n        mask = vmsgt_vx_i32m8_b8(sum_digits, 0, vl);\n        count += vmcntm_b8_m(mask, mask, vl);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_115_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    size_t N = arr.size();\n    if (N == 0) return true;\n\n    int *data = arr.data();\n    vint32m1_t vec1, vec2;\n    vbool4_t mask;\n    size_t vl = vsetvl_e32m1(N);\n\n    for (size_t i = 0; i < N; ++i) {\n        vec1 = vle32_v_i32m1(&data[i], vl);\n        vec2 = vle32_v_i32m1(&data[(i + 1) % N], vl);\n        mask = vmle_vv_i32m1_b4(vec1, vec2, vl);\n        if (!vmfirst_m_b4(mask, vl)) break;\n        if (i == N - 1) return true;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_115_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    size_t N = arr.size();\n    if (N == 0) return true;\n\n    // Create a vector to store the sorted version of arr\n    std::vector<int> sorted_arr(arr);\n    std::sort(sorted_arr.begin(), sorted_arr.end());\n\n    // Check all possible rotations\n    for (size_t shift = 0; shift < N; ++shift) {\n        // Load the original array into a vector register\n        vint32m1_t vec_arr = vle32_v_i32m1(arr.data() + shift, N - shift);\n        vint32m1_t vec_arr_shifted = vle32_v_i32m1(arr.data(), shift);\n\n        // Create a mask to blend the two parts\n        vbool32_t mask = vmseq_m_b32(viota_m1_i32m1(0, 1), vsetvl_e32m1(N));\n        mask = vslideup_vx_b32(mask, mask, N - shift);\n\n        // Blend the two parts to form the rotated array\n        vint32m1_t vec_rotated = vmerge_vvm_i32m1(vec_arr_shifted, vec_arr, mask);\n\n        // Load the sorted array into a vector register\n        vint32m1_t vec_sorted = vle32_v_i32m1(sorted_arr.data(), N);\n\n        // Compare the rotated array with the sorted array\n        vbool32_t cmp_mask = vmseq_vv_i32m1_b32(vec_rotated, vec_sorted, N);\n\n        // Check if all elements are equal\n        if (vmfirst_m_b32(cmp_mask, N) && vmpopc_m_b32(cmp_mask, N) == N) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_115_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    size_t N = arr.size();\n    if (N == 0) return true;\n\n    // Create a vector to store the sorted version of arr\n    std::vector<int> sorted_arr(arr);\n    std::sort(sorted_arr.begin(), sorted_arr.end());\n\n    // Check if the array is already sorted\n    bool is_sorted = true;\n    for (size_t i = 0; i < N; ++i) {\n        if (arr[i] != sorted_arr[i]) {\n            is_sorted = false;\n            break;\n        }\n    }\n    if (is_sorted) return true;\n\n    // Use RVV to check all possible rotations\n    for (size_t shift = 1; shift < N; ++shift) {\n        // Load the original array into a vector register\n        vint32m1_t vec_arr = vle32_v_i32m1(arr.data(), N);\n\n        // Perform the right shift operation\n        vint32m1_t vec_shifted = vslide1down_vx_i32m1(vec_arr, arr[N - shift], N);\n\n        // Load the sorted array into a vector register\n        vint32m1_t vec_sorted = vle32_v_i32m1(sorted_arr.data(), N);\n\n        // Compare the shifted array with the sorted array\n        vbool4_t mask = vmseq_vv_i32m1_b4(vec_shifted, vec_sorted, N);\n\n        // Check if all elements match\n        if (vmfirst_m_b4(mask, N)) {\n            bool all_match = true;\n            for (size_t i = 0; i < N; ++i) {\n                if (!vmask_m_b4(mask, i)) {\n                    all_match = false;\n                    break;\n                }\n            }\n            if (all_match) return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_115_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    size_t N = arr.size();\n    if (N == 0) return true;\n\n    int *data = arr.data();\n    vint32m1_t vec1, vec2;\n    vbool32_t mask;\n    size_t vl = vsetvl_e32m1(N);\n\n    for (size_t i = 0; i < N; ++i) {\n        vec1 = vle32_v_i32m1(&data[i], vl);\n        vec2 = vle32_v_i32m1(&data[(i + 1) % N], vl);\n        mask = vmle_vv_i32m1_b32(vec1, vec2, vl);\n        if (!vmfirst_m_b32(mask, vl)) break;\n        if (i == N - 1) return true;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_115_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    size_t N = arr.size();\n    if (N == 0) return true;\n\n    // Create a vector to store the sorted version of arr\n    std::vector<int> sorted_arr(arr);\n    std::sort(sorted_arr.begin(), sorted_arr.end());\n\n    // Check if the array is already sorted\n    bool is_sorted = true;\n    for (size_t i = 0; i < N; ++i) {\n        if (arr[i] != sorted_arr[i]) {\n            is_sorted = false;\n            break;\n        }\n    }\n    if (is_sorted) return true;\n\n    // Use RVV to check for possible sorted rotations\n    for (size_t shift = 1; shift < N; ++shift) {\n        // Load vectors\n        vint32m1_t vec1 = vle32_v_i32m1(&arr[0], vlmax_e32m1());\n        vint32m1_t vec2 = vle32_v_i32m1(&sorted_arr[0], vlmax_e32m1());\n\n        // Perform right shift on vec1\n        vint32m1_t shifted_vec1 = vslide1down_vx_i32m1(vec1, arr[N - shift], vlmax_e32m1());\n\n        // Compare vectors\n        vbool4_t mask = vmseq_vv_i32m1_b4(shifted_vec1, vec2, vlmax_e32m1());\n        bool all_equal = vmfirst_m_b4(mask, vlmax_e32m1());\n\n        if (all_equal) return true;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_116_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t n1 = lst1.size();\n    size_t n2 = lst2.size();\n    size_t vl;\n\n    // Check if there is at least one even number in lst2\n    int any_even_in_lst2 = 0;\n    for (size_t i = 0; i < n2; i += vl) {\n        vl = vsetvl_e32m8(n2 - i);\n        vbool8_t mask = vmseq_vx_i32m8(vle32_v_i32m8(lst2.data() + i, vl), 0, vl);\n        any_even_in_lst2 |= vmfirst_m_b8(mask, vl);\n    }\n\n    if (!any_even_in_lst2) {\n        return \"NO\";\n    }\n\n    // Check if all odd numbers in lst1 can be replaced by even numbers from lst2\n    for (size_t i = 0; i < n1; i += vl) {\n        vl = vsetvl_e32m8(n1 - i);\n        vint32m8_t vec1 = vle32_v_i32m8(lst1.data() + i, vl);\n        vbool8_t mask_odd = vmsne_vx_i32m8(vec1, 0, vl); // Check for odd numbers\n        size_t odd_count = vcpop_m_b8(mask_odd, vl);\n\n        if (odd_count == 0) {\n            continue;\n        }\n\n        // Check if there are enough even numbers in lst2 to replace odd numbers in lst1\n        int even_count_in_lst2 = 0;\n        for (size_t j = 0; j < n2; j += vl) {\n            vl = vsetvl_e32m8(n2 - j);\n            vint32m8_t vec2 = vle32_v_i32m8(lst2.data() + j, vl);\n            vbool8_t mask_even = vmseq_vx_i32m8(vec2, 0, vl);\n            even_count_in_lst2 += vcpop_m_b8(mask_even, vl);\n        }\n\n        if (even_count_in_lst2 < odd_count) {\n            return \"NO\";\n        }\n    }\n\n    return \"YES\";\n}\n```"}
{"task_id": "SimdBench_116_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t n1 = lst1.size();\n    size_t n2 = lst2.size();\n    size_t vl;\n\n    // Check if there is at least one even number in lst2\n    int *lst2_data = const_cast<int*>(lst2.data());\n    vl = __riscv_vsetvl_e32m1(n2);\n    vbool32_t mask = __riscv_vmsne_vx_i32m1(__riscv_vle32_v_i32m1(lst2_data, vl), 0, vl);\n    vbool32_t even_mask = __riscv_vmand_vv_b32(__riscv_vmerge_vvm_b32(__riscv_vmnot_b32(mask, vl), mask, vl), __riscv_vmsne_vx_i32m1(__riscv_vle32_v_i32m1(lst2_data, vl), 1, vl), vl);\n    bool has_even_in_lst2 = __riscv_vfirst_m_b32(even_mask, vl) != UINT32_MAX;\n\n    if (!has_even_in_lst2) {\n        return \"NO\";\n    }\n\n    // Check if all numbers in lst1 are even or if there is at least one odd number in lst1\n    int *lst1_data = const_cast<int*>(lst1.data());\n    vl = __riscv_vsetvl_e32m1(n1);\n    mask = __riscv_vmsne_vx_i32m1(__riscv_vle32_v_i32m1(lst1_data, vl), 0, vl);\n    even_mask = __riscv_vmand_vv_b32(__riscv_vmerge_vvm_b32(__riscv_vmnot_b32(mask, vl), mask, vl), __riscv_vmsne_vx_i32m1(__riscv_vle32_v_i32m1(lst1_data, vl), 1, vl), vl);\n    bool all_even_in_lst1 = __riscv_vfirst_m_b32(__riscv_vmnot_b32(even_mask, vl), vl) == UINT32_MAX;\n\n    if (all_even_in_lst1) {\n        return \"YES\";\n    }\n\n    return \"YES\";\n}\n```"}
{"task_id": "SimdBench_116_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t n1 = lst1.size();\n    size_t n2 = lst2.size();\n    size_t vl;\n\n    // Check if there is at least one even number in lst2\n    int any_even_in_lst2 = 0;\n    for (size_t i = 0; i < n2; i += vl) {\n        vl = vsetvl_e32m8(n2 - i);\n        vbool8_t mask = vmseq_vx_i32m8(vle32_v_i32m8(lst2.data() + i, vl), 0, vl);\n        any_even_in_lst2 |= vmfirst_m_b8(mask, vl);\n    }\n\n    if (!any_even_in_lst2) {\n        return \"NO\";\n    }\n\n    // Check if all odd numbers in lst1 can be replaced by even numbers from lst2\n    for (size_t i = 0; i < n1; i += vl) {\n        vl = vsetvl_e32m8(n1 - i);\n        vint32m8_t vec1 = vle32_v_i32m8(lst1.data() + i, vl);\n        vbool8_t mask_odd = vmsne_vx_i32m8(vec1, 0, vl); // Create mask for odd numbers\n\n        // Count odd numbers in current segment\n        size_t odd_count = vcpop_m_b8(mask_odd, vl);\n\n        // If there are odd numbers, check if we have enough even numbers in lst2\n        if (odd_count > 0) {\n            if (!any_even_in_lst2) {\n                return \"NO\";\n            }\n        }\n    }\n\n    return \"YES\";\n}\n```"}
{"task_id": "SimdBench_116_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t n1 = lst1.size();\n    size_t n2 = lst2.size();\n    size_t vl;\n\n    // Check if there is at least one even number in lst2\n    int *lst2_data = const_cast<int*>(lst2.data());\n    vl = __riscv_vsetvl_e32m1(n2);\n    vbool32_t mask = __riscv_vmseq_vx_i32m1(__riscv_vle32_v_i32m1(lst2_data, vl), 0, vl);\n    for (size_t i = vl; i < n2; i += vl) {\n        vl = __riscv_vsetvl_e32m1(n2 - i);\n        mask = __riscv_vor_vv_b32(__riscv_vmseq_vx_i32m1(__riscv_vle32_v_i32m1(lst2_data + i, vl), 0, vl), mask, vl);\n    }\n    if (__riscv_vfirst_m_b32(mask, vl) != UINT32_MAX) {\n        return \"YES\";\n    }\n\n    // Check if all numbers in lst1 are already even\n    int *lst1_data = const_cast<int*>(lst1.data());\n    vl = __riscv_vsetvl_e32m1(n1);\n    mask = __riscv_vmseq_vx_i32m1(__riscv_vle32_v_i32m1(lst1_data, vl), 0, vl);\n    for (size_t i = vl; i < n1; i += vl) {\n        vl = __riscv_vsetvl_e32m1(n1 - i);\n        mask = __riscv_vor_vv_b32(__riscv_vmseq_vx_i32m1(__riscv_vle32_v_i32m1(lst1_data + i, vl), 0, vl), mask, vl);\n    }\n    if (__riscv_vfirst_m_b32(mask, vl) == UINT32_MAX) {\n        return \"YES\";\n    }\n\n    return \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t n1 = lst1.size();\n    size_t n2 = lst2.size();\n    size_t vl = __riscv_vsetvl_e32m1(n1);\n\n    vbool32_t mask = __riscv_vmseq_vx_i32m1(__riscv_vle32_v_i32m1(lst1.data(), vl), 0, vl);\n    bool has_odd_in_lst1 = __riscv_vms_any_true_b32_m(mask, vl);\n\n    if (!has_odd_in_lst1) {\n        return \"YES\";\n    }\n\n    vl = __riscv_vsetvl_e32m1(n2);\n    mask = __riscv_vmand_vv_b32_m(__riscv_vmand_vv_b32_m(__riscv_vmseq_vx_i32m1(__riscv_vle32_v_i32m1(lst2.data(), vl), 0, vl), __riscv_vmseq_vx_i32m1(__riscv_vle32_v_i32m1(lst2.data(), vl), 2, vl), vl), __riscv_vmseq_vx_i32m1(__riscv_vle32_v_i32m1(lst2.data(), vl), 4, vl), vl);\n    bool has_even_in_lst2 = __riscv_vms_any_true_b32_m(mask, vl);\n\n    return has_even_in_lst2 ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_117_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for (const auto &str : lst) {\n        size_t len = str.size();\n        size_t cnt = 0;\n        for (size_t i = 0; i < len; ) {\n            size_t vl = __riscv_vsetvl_e8m1(len - i);\n            vuint8m1_t vec = __riscv_vle8_v_u8m1((const uint8_t*)(str.c_str() + i), vl);\n            vbool1_t mask = __riscv_vmseq_vx_i8m1_b1(vec, '1', vl) |\n                           __riscv_vmseq_vx_i8m1_b1(vec, '3', vl) |\n                           __riscv_vmseq_vx_i8m1_b1(vec, '5', vl) |\n                           __riscv_vmseq_vx_i8m1_b1(vec, '7', vl) |\n                           __riscv_vmseq_vx_i8m1_b1(vec, '9', vl);\n            cnt += __riscv_vpopc_b1(mask, vl);\n            i += vl;\n        }\n        std::string res = \"the number of odd elements \";\n        res += std::to_string(cnt);\n        res += \"n the str\";\n        res += std::to_string(cnt);\n        res += \"ng \";\n        res += std::to_string(cnt);\n        res += \" of the \";\n        res += std::to_string(cnt);\n        res += \"nput.\";\n        result.push_back(res);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for (const auto &str : lst) {\n        size_t len = str.size();\n        size_t cnt = 0;\n        for (size_t i = 0; i < len; ) {\n            size_t vl = vsetvl_e8m1(len - i);\n            vuint8m1_t vec = vle8_v_u8m1((const uint8_t*)(str.data() + i), vl);\n            vbool1_t mask = vmseq_vx_i8m1_b1(vec, '1', vl) |\n                           vmseq_vx_i8m1_b1(vec, '3', vl) |\n                           vmseq_vx_i8m1_b1(vec, '5', vl) |\n                           vmseq_vx_i8m1_b1(vec, '7', vl) |\n                           vmseq_vx_i8m1_b1(vec, '9', vl);\n            cnt += vmcntm_b1_m_b1(mask, vl);\n            i += vl;\n        }\n        std::string res = \"the number of odd elements \";\n        res += std::to_string(cnt);\n        res += \"n the str\";\n        res += std::to_string(cnt);\n        res += \"ng \";\n        res += std::to_string(cnt);\n        res += \" of the \";\n        res += std::to_string(cnt);\n        res += \"nput.\";\n        result.push_back(res);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for (const auto &str : lst) {\n        size_t len = str.size();\n        size_t cnt = 0;\n        for (size_t i = 0; i < len; ) {\n            size_t vl = vsetvl_e8m1(len - i);\n            vuint8m1_t vec = vle8_v_u8m1((const uint8_t*)(str.c_str() + i), vl);\n            vbool1_t mask = vmseq_vx_u8m1_b1(vec, '1', vl) |\n                           vmseq_vx_u8m1_b1(vec, '3', vl) |\n                           vmseq_vx_u8m1_b1(vec, '5', vl) |\n                           vmseq_vx_u8m1_b1(vec, '7', vl) |\n                           vmseq_vx_u8m1_b1(vec, '9', vl);\n            cnt += vpopc_m_b1(mask, vl);\n            i += vl;\n        }\n        std::string res = \"the number of odd elements \";\n        res += std::to_string(cnt);\n        res += \"n the str\";\n        res += std::to_string(cnt);\n        res += \"ng \";\n        res += std::to_string(cnt);\n        res += \" of the \";\n        res += std::to_string(cnt);\n        res += \"nput.\";\n        result.push_back(res);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for (const auto &str : lst) {\n        size_t len = str.size();\n        size_t cnt = 0;\n        for (size_t i = 0; i < len; ) {\n            size_t vl = vsetvl_e8m1(len - i);\n            vuint8m1_t vec = vle8_v_u8m1((const uint8_t*)(str.c_str() + i), vl);\n            vbool1_t mask = vmseq_vx_u8m1_b1(vec, '1', vl) |\n                           vmseq_vx_u8m1_b1(vec, '3', vl) |\n                           vmseq_vx_u8m1_b1(vec, '5', vl) |\n                           vmseq_vx_u8m1_b1(vec, '7', vl) |\n                           vmseq_vx_u8m1_b1(vec, '9', vl);\n            cnt += vpopc_m_b1(mask, vl);\n            i += vl;\n        }\n        std::string res = \"the number of odd elements \";\n        res += std::to_string(cnt);\n        res += \"n the str\";\n        res += std::to_string(cnt);\n        res += \"ng \";\n        res += std::to_string(cnt);\n        res += \" of the \";\n        res += std::to_string(cnt);\n        res += \"nput.\";\n        result.push_back(res);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for (const auto &str : lst) {\n        size_t len = str.size();\n        size_t cnt = 0;\n        for (size_t i = 0; i < len; ) {\n            size_t vl = vsetvl_e8m1(len - i);\n            vuint8m1_t vec = vle8_v_u8m1((const uint8_t*)(str.c_str() + i), vl);\n            vbool1_t mask = vmseq_vx_u8m1_b1(vec, '1', vl) |\n                           vmseq_vx_u8m1_b1(vec, '3', vl) |\n                           vmseq_vx_u8m1_b1(vec, '5', vl) |\n                           vmseq_vx_u8m1_b1(vec, '7', vl) |\n                           vmseq_vx_u8m1_b1(vec, '9', vl);\n            cnt += vpopc_m_b1(mask, vl);\n            i += vl;\n        }\n        std::string res = \"the number of odd elements \";\n        res += std::to_string(cnt);\n        res += \"n the str\";\n        res += std::to_string(cnt);\n        res += \"ng \";\n        res += std::to_string(cnt);\n        res += \" of the \";\n        res += std::to_string(cnt);\n        res += \"nput.\";\n        result.push_back(res);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_118_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <limits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    size_t n = nums.size();\n    if (n == 0) return 0;\n\n    int64_t min_sum = std::numeric_limits<int64_t>::max();\n    int64_t current_min = 0;\n\n    size_t vl = __riscv_vsetvl_e64m1(n);\n    vint64m1_t v_min = __riscv_vmv_v_x_i64m1(min_sum, vl);\n    vint64m1_t v_current_min = __riscv_vmv_v_x_i64m1(0, vl);\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e64m1(n - i);\n        vint64m1_t v_nums = __riscv_vle64_v_i64m1(&nums[i], vl);\n        v_current_min = __riscv_vfadd_vv_i64m1(v_current_min, v_nums, vl);\n        v_current_min = __riscv_vfmin_vv_i64m1(v_current_min, v_nums, vl);\n        v_min = __riscv_vfmin_vv_i64m1(v_min, v_current_min, vl);\n    }\n\n    __riscv_vredmin_vs_i64m1_i64(&min_sum, v_min, vl);\n\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <limits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    size_t n = nums.size();\n    if (n == 0) return 0;\n\n    int64_t min_sum = std::numeric_limits<int64_t>::max();\n    int64_t current_min = 0;\n\n    size_t vl = __riscv_vsetvl_e64m1(n);\n    vint64m1_t v_min = __riscv_vmv_v_x_i64m1(min_sum, vl);\n    vint64m1_t v_current_min = __riscv_vmv_v_x_i64m1(current_min, vl);\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e64m1(n - i);\n        vint64m1_t v_nums = __riscv_vle64_v_i64m1(&nums[i], vl);\n        v_current_min = __riscv_vfadd_vv_i64m1(v_current_min, v_nums, vl);\n        v_current_min = __riscv_vmin_vx_i64m1(v_current_min, 0, vl);\n        v_min = __riscv_vmin_vv_i64m1(v_min, v_current_min, vl);\n    }\n\n    int64_t result;\n    __riscv_vredmin_vs_i64m1_i64(&result, v_min, __riscv_vmv_v_x_i64m1(min_sum, vl), vl);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_118_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <limits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    size_t n = nums.size();\n    if (n == 0) return 0;\n\n    int64_t min_sum = std::numeric_limits<int64_t>::max();\n    int64_t current_min = 0;\n\n    size_t vl = __riscv_vsetvl_e64m1(n);\n    vint64m1_t v_min = __riscv_vmv_v_x_i64m1(min_sum, vl);\n    vint64m1_t v_current_min = __riscv_vmv_v_x_i64m1(current_min, vl);\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e64m1(n - i);\n        vint64m1_t v_nums = __riscv_vle64_v_i64m1(&nums[i], vl);\n        v_current_min = __riscv_vfadd_vv_i64m1(v_current_min, v_nums, vl);\n        v_current_min = __riscv_vmin_vv_i64m1(v_current_min, v_nums, vl);\n        v_min = __riscv_vmin_vv_i64m1(v_min, v_current_min, vl);\n    }\n\n    __riscv_vredmin_vs_i64m1_i64(&min_sum, v_min, vl);\n\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <limits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    size_t n = nums.size();\n    if (n == 0) return 0;\n\n    int64_t min_sum = std::numeric_limits<int64_t>::max();\n    int64_t current_min = 0;\n\n    size_t vl = __riscv_vsetvl_e64m1(n);\n    vint64m1_t v_min_sum = __riscv_vmv_v_x_i64m1(min_sum, vl);\n    vint64m1_t v_current_min = __riscv_vmv_v_x_i64m1(current_min, vl);\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e64m1(n - i);\n        vint64m1_t v_nums = __riscv_vle64_v_i64m1(&nums[i], vl);\n        v_current_min = __riscv_vfadd_vv_i64m1(v_current_min, v_nums, vl);\n        v_current_min = __riscv_vmin_vx_i64m1(v_current_min, 0, vl);\n        v_min_sum = __riscv_vmin_vv_i64m1(v_min_sum, v_current_min, vl);\n    }\n\n    __riscv_vredmin_vs_i64m1_i64(&min_sum, v_min_sum, vl);\n\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <limits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    size_t n = nums.size();\n    if (n == 0) return 0;\n\n    int64_t min_sum = std::numeric_limits<int64_t>::max();\n    int64_t current_min = 0;\n\n    size_t vl = __riscv_vsetvl_e64m1(n);\n    vint64m1_t v_min = __riscv_vmv_v_x_i64m1(min_sum, vl);\n    vint64m1_t v_current_min = __riscv_vmv_v_x_i64m1(current_min, vl);\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e64m1(n - i);\n        vint64m1_t v_nums = __riscv_vle64_v_i64m1(&nums[i], vl);\n        v_current_min = __riscv_vfadd_vv_i64m1(v_nums, v_current_min, vl);\n        v_current_min = __riscv_vmin_vv_i64m1(v_current_min, v_nums, vl);\n        v_min = __riscv_vmin_vv_i64m1(v_min, v_current_min, vl);\n    }\n\n    __riscv_vredmin_vs_i64m1_i64(&min_sum, v_min, vl);\n\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_119_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    int total_dips = 0;\n    size_t row_length = grid[0].size();\n    size_t num_rows = grid.size();\n\n    for (const auto& row : grid) {\n        size_t i = 0;\n        int row_sum = 0;\n        while (i < row_length) {\n            size_t vl = vsetvl_e32m8(row_length - i);\n            vint32m8_t vec = vle32_v_i32m8(&row[i], vl);\n            vbool4_t mask = vmseq_vx_i32m8_b4(vec, 1, vl);\n            int ones_count = vcpop_m_b4(mask, vl);\n            row_sum += ones_count;\n            i += vl;\n        }\n        total_dips += std::ceil(static_cast<double>(row_sum) / capacity);\n    }\n\n    return total_dips;\n}\n```"}
{"task_id": "SimdBench_119_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    int total_dips = 0;\n    size_t num_rows = grid.size();\n    size_t num_cols = grid[0].size();\n\n    for (size_t i = 0; i < num_rows; ++i) {\n        size_t col = 0;\n        int row_sum = 0;\n\n        while (col < num_cols) {\n            size_t vl = vsetvl_e32m8(num_cols - col);\n            vint32m8_t vec = vle32_v_i32m8(&grid[i][col], vl);\n            vbool4_t mask = vmseq_vx_i32m8_b4(vec, 1, vl);\n            int ones_in_vec = vcpop_m_b4(mask, vl);\n            row_sum += ones_in_vec;\n            col += vl;\n        }\n\n        total_dips += std::ceil(static_cast<double>(row_sum) / capacity);\n    }\n\n    return total_dips;\n}\n```"}
{"task_id": "SimdBench_119_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    int total_dips = 0;\n    size_t row_length = grid[0].size();\n    size_t num_rows = grid.size();\n\n    for (const auto& row : grid) {\n        size_t i = 0;\n        int row_sum = 0;\n        while (i < row_length) {\n            size_t vl = vsetvl_e32m8(row_length - i);\n            vint32m8_t vec = vle32_v_i32m8(&row[i], vl);\n            vbool4_t mask = vmseq_vx_i32m8_b4(vec, 1, vl);\n            int ones_in_vec = vcpop_m_b4(mask, vl);\n            row_sum += ones_in_vec;\n            i += vl;\n        }\n        total_dips += std::ceil(static_cast<double>(row_sum) / capacity);\n    }\n\n    return total_dips;\n}\n```"}
{"task_id": "SimdBench_119_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    int total_dips = 0;\n    size_t num_rows = grid.size();\n    size_t num_cols = grid[0].size();\n\n    for (size_t i = 0; i < num_rows; ++i) {\n        size_t col = 0;\n        int row_sum = 0;\n\n        while (col < num_cols) {\n            size_t vl = vsetvl_e32m8(num_cols - col);\n            vint32m8_t vec = vle32_v_i32m8(&grid[i][col], vl);\n            vbool4_t mask = vmseq_vx_i32m8_b4(vec, 1, vl);\n            int ones_in_vec = vcpop_m_b4(mask, vl);\n            row_sum += ones_in_vec;\n            col += vl;\n        }\n\n        total_dips += std::ceil(static_cast<double>(row_sum) / capacity);\n    }\n\n    return total_dips;\n}\n```"}
{"task_id": "SimdBench_119_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    int total_dips = 0;\n    size_t num_rows = grid.size();\n    size_t num_cols = grid[0].size();\n\n    for (size_t i = 0; i < num_rows; ++i) {\n        size_t col = 0;\n        int row_sum = 0;\n\n        while (col < num_cols) {\n            size_t vl = vsetvl_e32m8(num_cols - col);\n            vint32m8_t vec = vle32_v_i32m8(&grid[i][col], vl);\n            vbool4_t mask = vmseq_vx_i32m8_b4(vec, 1, vl);\n            int ones_count = vcpop_m_b4(mask, vl);\n            row_sum += ones_count;\n            col += vl;\n        }\n\n        total_dips += std::ceil(static_cast<double>(row_sum) / capacity);\n    }\n\n    return total_dips;\n}\n```"}
{"task_id": "SimdBench_120_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    size_t n = lst.size();\n    int64_t sum = 0;\n    size_t vl;\n\n    // Create a mask for even indices\n    vbool16_t mask = vmseq_vx_u16_b16(vle16_v_u16(n / 2, reinterpret_cast<const uint16_t*>(lst.data()), vl = n / 2), 0, vl);\n\n    // Process the vector in chunks\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e16m1(n - i);\n        vint16m1_t vec = vle16_v_i16m1(lst.data() + i, vl);\n        vint16m1_t even_indexed = vcompress_vm_i16m1(vec, mask, vl);\n        vbool16_t odd_mask = vmsne_vx_i16_b16(even_indexed, 0, vl) & vmod_vx_i16_b16(even_indexed, 2, vl);\n        vint16m1_t odd_elements = vcompress_vm_i16m1(even_indexed, odd_mask, vl);\n        sum += vwredsum_vs_i32m1_i64m1(vwadd_vv_i32m1(odd_elements, odd_elements, vl), sum, vl);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    size_t n = lst.size();\n    int64_t sum = 0;\n    size_t vl;\n\n    // Create a mask for even indices\n    vbool16_t mask = vmseq_vx_u16_b16(vle16_v_u16(n / 2, reinterpret_cast<const uint16_t*>(lst.data()), vl = vsetvl_e16m1(n / 2)), 0, vl);\n\n    // Iterate over the vector in chunks\n    for (size_t i = 0; i < n; i += vl * 2) {\n        vl = vsetvl_e16m1(n - i);\n        vint16m1_t vec = vle16_v_i16(vl, reinterpret_cast<const int16_t*>(lst.data() + i), vl);\n        vint16m1_t even_pos_vec = vcompress_vm_i16m1(vec, mask, vl);\n        vbool16_t odd_mask = vmsne_vx_i16_b16(even_pos_vec, 0, vl) & vmod_vx_i16_b16(even_pos_vec, 2, vl);\n        vint16m1_t odd_vec = vcompress_vm_i16m1(even_pos_vec, odd_mask, vl);\n        sum += vredsum_vs_i16m1_i64m1(odd_vec, 0, vl);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    size_t n = lst.size();\n    int64_t sum = 0;\n    size_t vl;\n\n    // Create a mask for even indices\n    vbool16_t mask = vmseq_vx_u16_b16(vmnot_vi_u16_m_b16(vundefined_b16(), 0, n), 0, n);\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e16m1(n - i);\n        vint16m1_t vec = vle16_v_i16m1(lst.data() + i, vl);\n        vint16m1_t filtered_vec = vcompress_vm_i16m1(mask, vec, vl);\n        vint32m1_t odd_check = vmod_vx_i32m1(vreinterpret_v_i32m1_i16m1(filtered_vec), 2, vl);\n        vbool16_t odd_mask = vmseq_vx_i16_b16(vreinterpret_v_i16m1_i32m1(odd_check), 1, vl);\n        vint16m1_t odd_filtered_vec = vcompress_vm_i16m1(odd_mask, filtered_vec, vl);\n        vint32m1_t sum_vec = vredsum_vs_i16m1_i32m1(vundefined_i32m1(), odd_filtered_vec, vundefined_i32m1(), vl);\n        sum += vfirst_m_i32m1_i32(sum_vec, vcreate_i32m1(0));\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    size_t n = lst.size();\n    int64_t sum = 0;\n    size_t vl;\n\n    // Create a mask for even indices\n    vbool16_t mask = vmseq_vx_u16_b16(vle16_v_u16(n / 2, reinterpret_cast<const uint16_t*>(lst.data()), vl = n / 2), 0, vl);\n\n    // Process the vector in chunks\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e16m1(n - i);\n        vint16m1_t vec = vle16_v_i16m1(lst.data() + i, vl);\n        vint16m1_t even_indexed = vcompress_vm_i16m1(vec, mask, vl);\n        vbool16_t odd_mask = vmsne_vx_i16_b16(even_indexed, 0, vl) & vmod_vx_i16_b16(even_indexed, 2, vl);\n        vint16m1_t odd_elements = vcompress_vm_i16m1(even_indexed, odd_mask, vl);\n        sum += vredsum_vs_i16m1_i64m1(odd_elements, 0, vl);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    size_t n = lst.size();\n    int64_t sum = 0;\n    size_t vl;\n\n    // Create a mask for even indices\n    vbool16_t mask = vmseq_vx_u16_b16(vle16_v_u16(n / 2, (uint16_t*)nullptr, 2), 0, n / 2);\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e16m1(n - i);\n        vint16m1_t vec = vle16_v_i16m1(&lst[i], vl);\n        vint16m1_t filtered_vec = vcompress_vm_i16m1(mask, vec, vl);\n        vint32m1_t odd_check = vmod_vx_i32m1(vreinterpret_v_i32m1_i16m1(filtered_vec), 2, vl);\n        vbool16_t odd_mask = vmseq_vx_i32m1_b16(odd_check, 1, vl);\n        vint16m1_t odd_filtered_vec = vcompress_vm_i16m1(odd_mask, filtered_vec, vl);\n        vint32m1_t sum_vec = vwmul_vx_i32m1(odd_filtered_vec, 1, vl);\n        sum += vwredsum_vs_i32m1_i64m1(sum_vec, 0, vl);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    size_t vl = __riscv_vsetvl_e32m1(k);\n    vint32m1_t vec = __riscv_vle32_v_i32m1(arr.data(), vl);\n    vbool4_t mask = __riscv_vle32_v_b4(__riscv_vmslt_vx_i32m1(vec, 100, vl), vl);\n    vint32m1_t filtered = __riscv_vcompress_vm_i32m1(mask, vec, vl);\n    size_t filtered_vl = __riscv_vpopc_m_b4(mask, vl);\n    sum = __riscv_vredsum_vs_i32m1_i32(filtered, 0, filtered_vl);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    size_t vl = __riscv_vsetvl_e32m1(k);\n    vint32m1_t vec = __riscv_vle32_v_i32m1(arr.data(), vl);\n    vbool4_t mask = __riscv_vle32_v_b4(__riscv_vmslt_vx_i32m1_b4(vec, 100, vl), vl);\n    vint32m1_t filtered_vec = __riscv_vcompress_vm_i32m1(vec, mask, vl);\n    size_t filtered_vl = __riscv_vpopc_m_b4(mask, vl);\n    sum = __riscv_vredsum_vs_i32m1_i32(filtered_vec, 0, filtered_vl);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    size_t vl = __riscv_vsetvl_e32m1(k);\n    vint32m1_t vec = __riscv_vle32_v_i32m1(arr.data(), vl);\n    vbool4_t mask = __riscv_vle32_v_b4(__riscv_vmslt_vx_i32m1(vec, 100, vl), vl);\n    vint32m1_t filtered_vec = __riscv_vcompress_vm_i32m1(mask, vec, vl);\n    size_t filtered_vl = __riscv_vpopc_m_b4(mask, vl);\n    sum = __riscv_vredsum_vs_i32m1_i32(filtered_vec, 0, filtered_vl);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    size_t vl = __riscv_vsetvl_e32m1(k);\n    vint32m1_t vec = __riscv_vle32_v_i32m1(arr.data(), vl);\n    vbool4_t mask = __riscv_vle32_v_b4(__riscv_vmslt_vx_i32m1(vec, 100, vl), vl);\n    vint32m1_t filtered_vec = __riscv_vcompress_vm_i32m1(mask, vec, vl);\n    size_t filtered_vl = __riscv_vpopc_m_b4(mask, vl);\n    sum = __riscv_vredsum_vs_i32m1_i32(filtered_vec, 0, filtered_vl);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    size_t vl = __riscv_vsetvl_e32m1(k);\n    vint32m1_t vec = __riscv_vle32_v_i32m1(arr.data(), vl);\n    vbool4_t mask = __riscv_vle32_v_b4(__riscv_vmslt_vx_i32m1_b4(vec, 100, vl), vl);\n    vint32m1_t filtered_vec = __riscv_vcompress_vm_i32m1(vec, mask, vl);\n    size_t filtered_vl = __riscv_vpopc_m_b4(mask, vl);\n    sum = __riscv_vredsum_vs_i32m1_i32(filtered_vec, 0, filtered_vl);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_122_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    size_t n = lst.size();\n    if (n <= 1) return true;\n\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t vec = __riscv_vle32_v_i32m1(lst.data(), vl);\n    vint32m1_t shifted_vec = __riscv_vsrl_vx_i32m1(vec, 1, vl);\n    vbool32_t less_than_mask = __riscv_vmslt_vv_i32m1_b32(vec, shifted_vec, vl);\n    vbool32_t equal_mask = __riscv_vmsne_vv_i32m1_b32(vec, shifted_vec, vl);\n\n    bool any_less_than = __riscv_vany_true_b32(less_than_mask, vl);\n    bool all_equal = __riscv_vall_true_b32(equal_mask, vl);\n\n    return !any_less_than && !all_equal;\n}\n```"}
{"task_id": "SimdBench_122_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    size_t n = lst.size();\n    if (n <= 1) return true;\n\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t vec = __riscv_vle32_v_i32m1(lst.data(), vl);\n    vint32m1_t shifted_vec = __riscv_vsrl_vx_i32m1(vec, 1, vl);\n    vbool32_t less_than_mask = __riscv_vmslt_vv_i32m1_b32(vec, shifted_vec, vl);\n    vbool32_t equal_mask = __riscv_vmsne_vv_i32m1_b32(vec, shifted_vec, vl);\n\n    bool any_less_than = __riscv_vany_true_b32(less_than_mask, vl);\n    bool all_equal = __riscv_vall_true_b32(equal_mask, vl);\n\n    return !any_less_than && !all_equal;\n}\n```"}
{"task_id": "SimdBench_122_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    size_t n = lst.size();\n    if (n <= 1) return true;\n\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t vec = __riscv_vle32_v_i32m1(lst.data(), vl);\n    vint32m1_t shifted_vec = __riscv_vsrl_vx_i32m1(vec, 1, vl);\n    vbool32_t less_than_mask = __riscv_vmslt_vv_i32m1_b32(vec, shifted_vec, vl);\n    vbool32_t equal_mask = __riscv_vmsne_vv_i32m1_b32(vec, shifted_vec, vl);\n\n    bool any_less_than = __riscv_vany_true_b32(less_than_mask, vl);\n    bool all_equal = __riscv_vall_true_b32(equal_mask, vl);\n\n    return !any_less_than && !all_equal;\n}\n```"}
{"task_id": "SimdBench_122_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    size_t n = lst.size();\n    if (n <= 1) return true;\n\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t vec = __riscv_vle32_v_i32m1(lst.data(), vl);\n    vint32m1_t shifted_vec = __riscv_vsrl_vx_i32m1(vec, 1, vl);\n    vbool32_t less_than_mask = __riscv_vmslt_vv_i32m1_b32(vec, shifted_vec, vl);\n    vbool32_t equal_mask = __riscv_vmsne_vv_i32m1_b32(vec, shifted_vec, vl);\n\n    bool any_less_than = __riscv_vany_true_b32(less_than_mask, vl);\n    bool all_equal = __riscv_vall_true_b32(equal_mask, vl);\n\n    return !any_less_than && !all_equal;\n}\n```"}
{"task_id": "SimdBench_122_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    size_t n = lst.size();\n    if (n <= 1) return true;\n\n    size_t vl = __riscv_vsetvl_e32m1(n - 1);\n    vint32m1_t vec1 = __riscv_vle32_v_i32m1(lst.data(), vl);\n    vint32m1_t vec2 = __riscv_vle32_v_i32m1(lst.data() + 1, vl);\n\n    vbool1_t mask_le = __riscv_vle32_v_i32m1(lst.data(), vl) <= __riscv_vle32_v_i32m1(lst.data() + 1, vl);\n    vbool1_t mask_eq = __riscv_vle32_v_i32m1(lst.data(), vl) == __riscv_vle32_v_i32m1(lst.data() + 1, vl);\n\n    bool all_le = __riscv_vmv_x_s_b1(mask_le);\n    bool any_eq = !__riscv_vmv_x_s_b1(__riscv_vmnot_m_b1(mask_eq, vl));\n\n    return all_le && !any_eq;\n}\n```"}
{"task_id": "SimdBench_123_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr){\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    size_t n = arr.size();\n    vint32m1_t v_arr;\n    vint32m1_t v_signs;\n    vint32m1_t v_magnitudes;\n    vint32m1_t v_ones = vmv_v_x_i32m1(1, 1);\n    vint32m1_t v_zeros = vmv_v_x_i32m1(0, 1);\n    vint32m1_t v_neg_ones = vmv_v_x_i32m1(-1, 1);\n\n    int sum_of_magnitudes = 0;\n    int product_of_signs = 1;\n\n    for (size_t i = 0; i < n; i += vsetvl_e32m1(n - i)) {\n        size_t vl = vsetvl_e32m1(n - i);\n        v_arr = vle32_v_i32m1(&arr[i], vl);\n\n        v_signs = vmslt_vx_i32m1_b32m1(v_arr, 0, vl);\n        v_signs = vsub_vv_i32m1(v_zeros, v_signs, vl);\n        v_signs = vadd_vv_i32m1(v_signs, v_ones, vl);\n        v_signs = vmerge_vvm_i32m1(v_neg_ones, v_signs, vmsne_vx_i32m1_b32m1(v_arr, 0, vl), vl);\n\n        v_magnitudes = vabs_v_i32m1(v_arr, vl);\n\n        sum_of_magnitudes += vredsum_vs_i32m1_i32(v_magnitudes, 0, vl);\n        product_of_signs *= vredprod_vs_i32m1_i32(v_signs, 1, vl);\n    }\n\n    return sum_of_magnitudes * product_of_signs;\n}\n```"}
{"task_id": "SimdBench_123_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr){\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    size_t n = arr.size();\n    int sum_of_magnitudes = 0;\n    int product_of_signs = 1;\n\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t vec = __riscv_vle32_v_i32m1(arr.data(), vl);\n\n    vint32m1_t abs_vec = __riscv_vabs_v_i32m1(vec, vl);\n    sum_of_magnitudes = __riscv_vredsum_vs_i32m1_i32(abs_vec, 0, vl);\n\n    vint32m1_t sign_vec = __riscv_vsgn_j_v_i32m1(vec, vl);\n    vbool4_t mask = __riscv_vmseq_vx_i32m1_b4(sign_vec, 0, vl);\n    if (__riscv_vfirst_m_b4(mask, vl) < vl) {\n        product_of_signs = 0;\n    } else {\n        vint32m1_t sign_no_zero = __riscv_vmerge_vvm_i32m1(sign_vec, sign_vec, mask, vl);\n        product_of_signs = __riscv_vredprod_vs_i32m1_i32(sign_no_zero, 1, vl);\n    }\n\n    return sum_of_magnitudes * product_of_signs;\n}\n```"}
{"task_id": "SimdBench_123_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr){\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    size_t n = arr.size();\n    vint32m1_t v_arr = vle32_v_i32m1(arr.data(), n);\n    vint32m1_t v_signs = vsgn_v_i32m1(v_arr, n);\n    vint32m1_t v_magnitudes = vabs_v_i32m1(v_arr, n);\n\n    int sum_of_magnitudes = vredsum_vs_i32m1_i32(v_magnitudes, 0, n);\n    int product_of_signs = vredprod_vs_i32m1_i32(v_signs, 1, n);\n\n    return sum_of_magnitudes * product_of_signs;\n}\n```"}
{"task_id": "SimdBench_123_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr){\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    size_t n = arr.size();\n    vint32m1_t vec;\n    vint32m1_t sign_vec;\n    vint32m1_t mag_vec;\n    vint32m1_t sum_mag_vec;\n    vint32m1_t prod_sign_vec;\n    int sum_mag = 0;\n    int prod_sign = 1;\n\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m1(n - i);\n        vec = __riscv_vle32_v_i32m1(arr.data() + i, vl);\n\n        // Calculate sign\n        sign_vec = __riscv_vssra_vx_i32m1(vec, 31, vl);\n        sign_vec = __riscv_vadd_vx_i32m1(sign_vec, 1, vl);\n        sign_vec = __riscv_vsub_vx_i32m1(sign_vec, (vec == 0), vl);\n\n        // Calculate magnitude\n        mag_vec = __riscv_vabs_v_i32m1(vec, vl);\n\n        // Sum of magnitudes\n        sum_mag_vec = __riscv_vredsum_vs_i32m1_i32(mag_vec, 0, vl);\n        sum_mag += __riscv_vmv_x_s_i32m1_i32(sum_mag_vec);\n\n        // Product of signs\n        prod_sign_vec = __riscv_vredprod_vs_i32m1_i32(sign_vec, 1, vl);\n        prod_sign *= __riscv_vmv_x_s_i32m1_i32(prod_sign_vec);\n    }\n\n    return sum_mag * prod_sign;\n}\n```"}
{"task_id": "SimdBench_123_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr){\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    size_t n = arr.size();\n    int sum_magnitude = 0;\n    int prod_sign = 1;\n\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t vec = __riscv_vle32_v_i32m1(arr.data(), vl);\n\n    vint32m1_t abs_vec = __riscv_vabs_v_i32m1(vec, vl);\n    sum_magnitude += __riscv_vredsum_vs_i32m1_i32(abs_vec, 0, vl);\n\n    vint32m1_t sign_vec = __riscv_vsgn_j_v_i32m1(vec, vl);\n    prod_sign *= __riscv_vredprod_vs_i32m1_i32(sign_vec, 1, vl);\n\n    return sum_magnitude * prod_sign;\n}\n```"}
{"task_id": "SimdBench_124_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k, INT_MAX);\n    size_t vl = __riscv_vsetvl_e32m1(k);\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            std::vector<int> path;\n            path.push_back(grid[i][j]);\n\n            std::function<void(int, int, int)> dfs = [&](int x, int y, int depth) {\n                if (depth == k) {\n                    vint32m1_t v_path = __riscv_vle32_v_i32m1(path.data(), vl);\n                    vint32m1_t v_result = __riscv_vle32_v_i32m1(result.data(), vl);\n                    vbool4_t vm = __riscv_vmslt_vv_i32m1_b4(v_path, v_result, vl);\n                    if (__riscv_vfirst_m_b4(vm, vl) != UINTVLMAX) {\n                        result = path;\n                    }\n                    return;\n                }\n\n                static const int dx[] = {-1, 1, 0, 0};\n                static const int dy[] = {0, 0, -1, 1};\n\n                for (int dir = 0; dir < 4; ++dir) {\n                    int nx = x + dx[dir];\n                    int ny = y + dy[dir];\n                    if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n                        path.push_back(grid[nx][ny]);\n                        dfs(nx, ny, depth + 1);\n                        path.pop_back();\n                    }\n                }\n            };\n\n            dfs(i, j, 1);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_124_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k) {\n    int N = grid.size();\n    std::vector<int> min_path(k, INT_MAX);\n    size_t vl;\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            std::vector<int> path;\n            path.push_back(grid[i][j]);\n\n            std::vector<std::pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n            std::vector<std::vector<int>> paths = {path};\n\n            for (int step = 1; step < k; ++step) {\n                std::vector<std::vector<int>> new_paths;\n                for (const auto& p : paths) {\n                    int x = p.back() / N;\n                    int y = p.back() % N;\n                    for (const auto& dir : directions) {\n                        int nx = x + dir.first;\n                        int ny = y + dir.second;\n                        if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n                            std::vector<int> new_path = p;\n                            new_path.push_back(grid[nx][ny]);\n                            new_paths.push_back(new_path);\n                        }\n                    }\n                }\n                paths = new_paths;\n            }\n\n            for (const auto& p : paths) {\n                vl = p.size();\n                vint32m1_t v_min_path = vle32_v_i32m1(min_path.data(), vl);\n                vint32m1_t v_path = vle32_v_i32m1(p.data(), vl);\n                vbool4_t mask = vmflt_vv_i32m1_b4(v_path, v_min_path, vl);\n                if (vmfirst_m_b4(mask, vl)) {\n                    min_path = p;\n                }\n            }\n        }\n    }\n\n    return min_path;\n}\n```"}
{"task_id": "SimdBench_124_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k) {\n    int N = grid.size();\n    std::vector<int> min_path(k, INT_MAX);\n    vint32m1_t v_min_path = vle32_v_i32m1(min_path.data(), k);\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            std::vector<int> path;\n            path.push_back(grid[i][j]);\n\n            std::function<void(int, int, int)> dfs = [&](int x, int y, int depth) {\n                if (depth == k) {\n                    vint32m1_t v_path = vle32_v_i32m1(path.data(), k);\n                    vbool4_t mask = vmflt_vv_i32m1_b4(v_path, v_min_path, k);\n                    if (vmfirst_m_b4(mask)) {\n                        vse32_v_i32m1(min_path.data(), v_path, k);\n                    }\n                    return;\n                }\n\n                static const int dx[] = {-1, 1, 0, 0};\n                static const int dy[] = {0, 0, -1, 1};\n\n                for (int dir = 0; dir < 4; ++dir) {\n                    int nx = x + dx[dir];\n                    int ny = y + dy[dir];\n                    if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n                        path.push_back(grid[nx][ny]);\n                        dfs(nx, ny, depth + 1);\n                        path.pop_back();\n                    }\n                }\n            };\n\n            dfs(i, j, 1);\n        }\n    }\n\n    return min_path;\n}\n```"}
{"task_id": "SimdBench_124_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k, INT_MAX);\n    size_t vl = __riscv_vsetvl_e32m1(k);\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            std::vector<int> path;\n            path.push_back(grid[i][j]);\n\n            std::vector<std::pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n            std::vector<std::vector<int>> paths = {path};\n\n            for (int step = 1; step < k; ++step) {\n                std::vector<std::vector<int>> new_paths;\n                for (const auto& p : paths) {\n                    int x = p.back() / N;\n                    int y = p.back() % N;\n                    for (const auto& dir : directions) {\n                        int nx = x + dir.first;\n                        int ny = y + dir.second;\n                        if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n                            std::vector<int> new_path = p;\n                            new_path.push_back(grid[nx][ny]);\n                            new_paths.push_back(new_path);\n                        }\n                    }\n                }\n                paths = new_paths;\n            }\n\n            for (const auto& p : paths) {\n                vint32m1_t v_result = __riscv_vle32_v_i32m1(result.data(), vl);\n                vint32m1_t v_path = __riscv_vle32_v_i32m1(p.data(), vl);\n                vbool4_t mask = __riscv_vmslt_vv_i32m1_b4(v_path, v_result, vl);\n                if (__riscv_vfirst_m_b4(mask, vl) < vl) {\n                    result = p;\n                }\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_124_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k) {\n    int N = grid.size();\n    std::vector<int> min_path(k, INT_MAX);\n    size_t vl;\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            std::vector<int> path;\n            path.push_back(grid[i][j]);\n\n            std::vector<std::pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n            std::vector<std::vector<int>> paths = {path};\n\n            for (int step = 1; step < k; ++step) {\n                std::vector<std::vector<int>> new_paths;\n                for (const auto& p : paths) {\n                    int x = p.back() / N;\n                    int y = p.back() % N;\n                    for (const auto& dir : directions) {\n                        int nx = x + dir.first;\n                        int ny = y + dir.second;\n                        if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n                            std::vector<int> new_path = p;\n                            new_path.push_back(grid[nx][ny]);\n                            new_paths.push_back(new_path);\n                        }\n                    }\n                }\n                paths = new_paths;\n            }\n\n            for (const auto& p : paths) {\n                bool is_min = true;\n                for (int l = 0; l < k; ++l) {\n                    vl = vsetvl_e32m1(k);\n                    vint32m1_t vp = vle32_v_i32m1(p.data() + l, vl);\n                    vint32m1_t vm = vle32_v_i32m1(min_path.data() + l, vl);\n                    vbool4_t mask = vmv_x_s_b4(true);\n                    mask = vmaskn_m_b4(mask, vmv_x_s_b4(false), vl);\n                    mask = vmslt_vv_b4(mask, vp, vm, vl);\n                    if (!vmfirst_m_b4(mask, vl)) {\n                        is_min = false;\n                        break;\n                    }\n                }\n                if (is_min) {\n                    min_path = p;\n                }\n            }\n        }\n    }\n\n    return min_path;\n}\n```"}
{"task_id": "SimdBench_125_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t digits_simd(uint64_t n) {\n    uint64_t result = 1;\n    uint8_t has_odd = 0;\n\n    // Convert the number to a string of digits\n    char digits[20]; // Enough to hold the digits of a uint64_t\n    int len = 0;\n    while (n > 0) {\n        digits[len++] = n % 10;\n        n /= 10;\n    }\n\n    // Create a vector from the digits\n    size_t vl = vsetvl_e8m1(len);\n    vuint8m1_t digit_vec = vle8_v_u8m1(digits, vl);\n\n    // Create a mask for odd digits\n    vbool1_t odd_mask = vmseq_vx_u8m1_b1(digit_vec, 1, vl);\n    for (int i = 3; i <= 9; i += 2) {\n        odd_mask = vmsor_vv_b1(odd_mask, vmseq_vx_u8m1_b1(digit_vec, i, vl), vl);\n    }\n\n    // Multiply the odd digits\n    vuint8m1_t odd_digits = vcompress_vm_u8m1(digit_vec, odd_mask, vl);\n    size_t odd_count = vpopc_m_b1(odd_mask, vl);\n\n    if (odd_count == 0) {\n        return 0;\n    }\n\n    for (size_t i = 0; i < odd_count; i++) {\n        result *= odd_digits[i];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_125_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t digits_simd(uint64_t n) {\n    uint64_t result = 1;\n    uint8_t has_odd = 0;\n\n    // Convert the number to a string of digits\n    char digits[21]; // Maximum digits for uint64_t is 20 + 1 for null terminator\n    int len = snprintf(digits, sizeof(digits), \"%lu\", n);\n\n    // Create a vector to hold the digits\n    size_t vl = vsetvl_e8m1(len);\n    vuint8m1_t digit_vec = vle8_v_u8m1((uint8_t *)digits, vl);\n\n    // Create a mask for odd digits\n    vbool1_t odd_mask = vmseq_vx_u8m1_b1(digit_vec, '1', vl) |\n                        vmseq_vx_u8m1_b1(digit_vec, '3', vl) |\n                        vmseq_vx_u8m1_b1(digit_vec, '5', vl) |\n                        vmseq_vx_u8m1_b1(digit_vec, '7', vl) |\n                        vmseq_vx_u8m1_b1(digit_vec, '9', vl);\n\n    // Check if there are any odd digits\n    has_odd = vmfirst_m_b1(odd_mask, vl);\n\n    if (!has_odd) {\n        return 0;\n    }\n\n    // Convert ASCII to integer and multiply odd digits\n    vuint8m1_t odd_digit_vec = vcompress_vm_u8m1(digit_vec, odd_mask, vl);\n    vl = vgetvl_e8m1(vl);\n    for (size_t i = 0; i < vl; i++) {\n        uint8_t digit = odd_digit_vec[i] - '0';\n        result *= digit;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_125_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t digits_simd(uint64_t n) {\n    uint64_t result = 1;\n    uint8_t has_odd = 0;\n\n    // Convert the number to a string of digits\n    char digits[21]; // Maximum digits for uint64_t + null terminator\n    int len = snprintf(digits, sizeof(digits), \"%lu\", n);\n\n    // Create a vector mask for odd digits\n    vbool8_t mask;\n    vuint8m1_t digit_vec;\n    size_t vl = len;\n\n    do {\n        digit_vec = vle8_v_u8m1((uint8_t*)digits, vl);\n        mask = vmseq_vx_u8m1_b8(digit_vec, '0', vl);\n        digit_vec = vsub_vx_u8m1(digit_vec, '0', vl);\n        mask = vmseq_vx_u8m1_b8(digit_vec, 0, vl);\n        mask = vmn_vx_b8(mask, 1, vl);\n        digit_vec = vand_vx_u8m1(digit_vec, 1, vl);\n        mask = vmseq_vx_u8m1_b8(digit_vec, 1, vl);\n        has_odd |= vmfirst_m_b8(mask, vl);\n\n        // Multiply odd digits\n        vuint64m1_t odd_digits = vcompress_vm_u8m1(digit_vec, mask, vl);\n        size_t odd_count = vpopc_m_b8(mask, vl);\n        for (size_t i = 0; i < odd_count; i++) {\n            result *= odd_digits[i];\n        }\n\n        digits += vl;\n        vl = vsetvl_e8m1(len - (digits - (char*)digits));\n    } while (vl > 0);\n\n    return has_odd ? result : 0;\n}\n```"}
{"task_id": "SimdBench_125_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t digits_simd(uint64_t n) {\n    uint64_t result = 1;\n    uint8_t has_odd = 0;\n\n    // Convert the number to a string of digits\n    char digits[21]; // Maximum digits for uint64_t is 20 + 1 for null terminator\n    int len = snprintf(digits, sizeof(digits), \"%lu\", n);\n\n    // Create a vector mask for odd digits\n    vbool8_t mask;\n    vuint8m1_t digit_vec;\n    size_t vl = len;\n\n    do {\n        digit_vec = vle8_v_u8m1((const uint8_t *)digits, vl);\n        mask = vmseq_vx_u8m1_b8(digit_vec, '0', vl);\n        digit_vec = vsub_vx_u8m1(digit_vec, '0', mask, vl); // Convert ASCII to integer\n        mask = vmod_vx_u8m1_b8(digit_vec, 2, vl); // Check if digit is odd\n        vse8_v_u8m1_m((uint8_t *)&has_odd, mask, vadd_vx_u8m1(vle8_v_u8m1((const uint8_t *)&has_odd, 1), 1, 1), 1); // Set has_odd if any digit is odd\n        vse8_v_u8m1_m((uint8_t *)&result, mask, vmul_vv_u8m1(vle8_v_u8m1((const uint8_t *)&result, 1), digit_vec, 1), 1); // Multiply odd digits\n        vl -= 1;\n        digits += 1;\n    } while (vl > 0);\n\n    return has_odd ? result : 0;\n}\n```"}
{"task_id": "SimdBench_125_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t digits_simd(uint64_t n) {\n    uint64_t result = 1;\n    uint8_t has_odd = 0;\n\n    // Convert the number to a string of digits\n    char digits[20];\n    int len = 0;\n    while (n > 0) {\n        digits[len++] = n % 10;\n        n /= 10;\n    }\n\n    // Create a vector from the digits\n    size_t vl = vsetvl_e8m1(len);\n    vuint8m1_t v_digits = vle8_v_u8m1(digits, vl);\n\n    // Create a mask for odd digits\n    vbool1_t mask = vmseq_vx_u8m1_b1(v_digits, 1, vl);\n    for (int i = 3; i < 10; i += 2) {\n        mask = vmor_vv_b1(mask, vmseq_vx_u8m1_b1(v_digits, i, vl), vl);\n    }\n\n    // Multiply the odd digits\n    vuint8m1_t v_ones = vmv_v_x_u8m1(1, vl);\n    vuint8m1_t v_result = vredprod_vs_u8m1_u8m1(v_ones, v_digits, mask, vl);\n\n    // Check if there are any odd digits\n    vbool1_t any_odd_mask = vmfirst_m_b1(mask, vl);\n    if (vmv_x_s_b1(any_odd_mask)) {\n        result = vfmv_f_s_u8m1_i8(v_result);\n    } else {\n        result = 0;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_126_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n#include <vector>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    size_t n = lst.size();\n    uint64_t sum = 0;\n    size_t vl;\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m8(n - i);\n        vfloat32m8_t vec = vle32_v_f32m8(lst.data() + i, vl);\n        vint32m8_t ceil_vec = vfcvt_xu_f_v_i32m8(vec, vl);\n        vint32m8_t square_vec = vmul_vv_i32m8(ceil_vec, ceil_vec, vl);\n        vint64m4_t square_long_vec = vwcvt_x_x_v_i64m4_i32m8(square_vec, vl);\n        sum += vredsum_vs_i64m4_i64(square_long_vec, 0, vl);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n#include <vector>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    size_t n = lst.size();\n    uint64_t sum = 0;\n    size_t vl;\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m8(n - i);\n        vfloat32m8_t vec = vle32_v_f32m8(lst.data() + i, vl);\n        vint32m8_t ceil_vec = vfcvt_xu_f_v_i32m8(vec, vl);\n        vint32m8_t square_vec = vmul_vv_i32m8(ceil_vec, ceil_vec, vl);\n        vuint64m1_t sum_vec = vredsum_vs_u64m1_i32m8(vundefined_u64m1(), square_vec, vcreate_u64m1(0), vl);\n        sum += vfirst_m1_u64m1(sum_vec, vl);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n#include <vector>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    size_t n = lst.size();\n    uint64_t sum = 0;\n    size_t vl;\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m8(n - i);\n        vfloat32m8_t vec = vle32_v_f32m8(lst.data() + i, vl);\n        vint32m8_t ceil_vec = vfcvt_xu_f_v_i32m8(vec, vl);\n        vint32m8_t square_vec = vmul_vv_i32m8(ceil_vec, ceil_vec, vl);\n        vuint64m1_t sum_vec = vredsum_vs_u64m1_i32m8(vundefined_u64m1(), square_vec, vcreate_u64m1(0), vl);\n        sum += vextract_lane_u64m1_i64(sum_vec, 0);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n#include <vector>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    size_t n = lst.size();\n    uint64_t sum = 0;\n    size_t vl;\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m8(n - i);\n        vfloat32m8_t vec = vle32_v_f32m8(lst.data() + i, vl);\n        vint32m8_t ceil_vec = vfcvt_xu_f_v_i32m8(vec, vl);\n        vint32m8_t square_vec = vmul_vv_i32m8(ceil_vec, ceil_vec, vl);\n        vuint64m1_t sum_vec = vwredsum_vs_u64m1_i32m8(vundefined_u64m1(), square_vec, vcreate_u64m1(0), vl);\n        sum += vread_u64m1_i64(sum_vec);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n#include <vector>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    size_t n = lst.size();\n    uint64_t sum = 0;\n    size_t vl;\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m8(n - i);\n        vfloat32m8_t vec = vle32_v_f32m8(lst.data() + i, vl);\n        vint32m8_t ceil_vec = vfcvt_rtz_x_f_v_i32m8(ceilf_v_f32m8(vec, vl), vl);\n        vint32m8_t square_vec = vmul_vv_i32m8(ceil_vec, ceil_vec, vl);\n        vuint64m1_t sum_vec = vwredsum_vs_u64m1_i32m8(vundefined_u64m1(), square_vec, vcreate_u64m1(0), vl);\n        sum += vread_u64m1_i64(sum_vec);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_127_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr){\n    int n = arr.size();\n    if (n < 2) return -1;\n\n    int result = -1;\n    size_t vlmax = __riscv_vsetvl_e32m1(n);\n    vint32m1_t vec = __riscv_vle32_v_i32m1(arr.data(), vlmax);\n    vint32m1_t shifted_vec = __riscv_vsrl_vx_i32m1(vec, 1, vlmax);\n    vbool32_t mask = __riscv_vmslt_vv_b32m1(vec, shifted_vec, vlmax);\n\n    for (size_t i = 0; i < n; ++i) {\n        if (__riscv_vmv_x_s_b32m1(mask, i)) {\n            result = i;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr){\n    int n = arr.size();\n    if (n < 2) return -1;\n\n    int result = -1;\n    size_t vl = __riscv_vsetvl_e32m1(n - 1);\n    vint32m1_t vec1 = __riscv_vle32_v_i32m1(arr.data(), vl);\n    vint32m1_t vec2 = __riscv_vle32_v_i32m1(arr.data() + 1, vl);\n    vbool1_t mask = __riscv_vmslt_vv_i32m1_b1(vec2, vec1, vl);\n\n    for (size_t i = 0; i < vl; ++i) {\n        if (__riscv_vmv_x_s_b1(mask, i)) {\n            result = i;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n < 2) return -1;\n\n    int result = -1;\n    size_t vlmax = __riscv_vsetvl_e32m1(n);\n    vint32m1_t vec = __riscv_vle32_v_i32m1(arr.data(), vlmax);\n    vint32m1_t shifted_vec = __riscv_vsrl_vx_i32m1(vec, 1, vlmax);\n\n    for (size_t i = 0; i < n; i += vlmax) {\n        size_t vl = __riscv_vsetvl_e32m1(n - i);\n        vbool4_t mask = __riscv_vmslt_vv_b4(vec, shifted_vec, vl);\n        size_t index = __riscv_vfirst_m_b4(mask, vl);\n        if (index < vl) {\n            result = i + index;\n        }\n        vec = __riscv_vslideup_vx_i32m1(vec, arr[i + vl], vl);\n        shifted_vec = __riscv_vslideup_vx_i32m1(shifted_vec, arr[i + vl - 1], vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n < 2) return -1;\n\n    int result = -1;\n    size_t vlmax = __riscv_vsetvl_e32m1(n);\n    vint32m1_t vec = __riscv_vle32_v_i32m1(arr.data(), vlmax);\n\n    for (size_t i = 1; i < n; i += vlmax) {\n        size_t vl = __riscv_vsetvl_e32m1(n - i);\n        vint32m1_t current = __riscv_vle32_v_i32m1(arr.data() + i, vl);\n        vint32m1_t prev = __riscv_vsrl_vx_i32m1(current, 1, vl);\n        vbool32_t mask = __riscv_vmslt_vv_i32m1_b32(prev, current, vl);\n\n        for (size_t j = 0; j < vl; ++j) {\n            if (__riscv_vmv_x_s_b32_m(mask, j)) {\n                result = i + j;\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n < 2) return -1;\n\n    int result = -1;\n    size_t vlmax = __riscv_vsetvl_e32m1(n);\n    vint32m1_t vec = __riscv_vle32_v_i32m1(arr.data(), vlmax);\n    vint32m1_t shifted_vec = __riscv_vsrl_vx_i32m1(vec, 1, vlmax);\n\n    for (size_t i = 0; i < n; i += vlmax) {\n        size_t vl = __riscv_vsetvl_e32m1(n - i);\n        vbool4_t mask = __riscv_vmslt_vv_b4(vec, shifted_vec, vl);\n        size_t index = __riscv_vfirst_m_b4(mask, vl);\n        if (index < vl) {\n            result = i + index;\n        }\n        vec = __riscv_vslideup_vx_i32m1(vec, arr[i + vl], vl);\n        shifted_vec = __riscv_vslideup_vx_i32m1(shifted_vec, arr[i + vl - 1], vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_128_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    size_t n = lst.size();\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    vint32m1_t v_neg = __riscv_vle32_v_i32m1(lst.data(), vl);\n    vint32m1_t v_pos = __riscv_vle32_v_i32m1(lst.data(), vl);\n\n    vbool32_t mask_neg = __riscv_vmslt_vx_i32m1_b32(v_neg, 0, vl);\n    vbool32_t mask_pos = __riscv_vmsgt_vx_i32m1_b32(v_pos, 0, vl);\n\n    vint32m1_t v_neg_filtered = __riscv_vcompress_vm_i32m1(v_neg, mask_neg, vl);\n    vint32m1_t v_pos_filtered = __riscv_vcompress_vm_i32m1(v_pos, mask_pos, vl);\n\n    size_t neg_count = __riscv_vpopc_m_b32(mask_neg, vl);\n    size_t pos_count = __riscv_vpopc_m_b32(mask_pos, vl);\n\n    if (neg_count > 0) {\n        largest_negative = __riscv_vmax_vs_i32m1_i32(v_neg_filtered, std::numeric_limits<int>::min(), neg_count);\n    }\n\n    if (pos_count > 0) {\n        smallest_positive = __riscv_vmin_vs_i32m1_i32(v_pos_filtered, std::numeric_limits<int>::max(), pos_count);\n    }\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_128_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    size_t n = lst.size();\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    vint32m1_t v_neg = __riscv_vle32_v_i32m1(lst.data(), vl);\n    vint32m1_t v_pos = __riscv_vle32_v_i32m1(lst.data(), vl);\n\n    vbool32_t mask_neg = __riscv_vmslt_vx_i32m1_b32(v_neg, 0, vl);\n    vbool32_t mask_pos = __riscv_vmsgt_vx_i32m1_b32(v_pos, 0, vl);\n\n    vint32m1_t v_neg_filtered = __riscv_vcompress_vm_i32m1(v_neg, mask_neg, vl);\n    vint32m1_t v_pos_filtered = __riscv_vcompress_vm_i32m1(v_pos, mask_pos, vl);\n\n    size_t neg_cnt = __riscv_vpopc_m_b32(mask_neg, vl);\n    size_t pos_cnt = __riscv_vpopc_m_b32(mask_pos, vl);\n\n    if (neg_cnt > 0) {\n        largest_negative = __riscv_vredmax_vs_i32m1_i32(v_neg_filtered, std::numeric_limits<int>::min(), __riscv_vundefined_i32m1(), neg_cnt);\n    }\n\n    if (pos_cnt > 0) {\n        smallest_positive = __riscv_vredmin_vs_i32m1_i32(v_pos_filtered, std::numeric_limits<int>::max(), __riscv_vundefined_i32m1(), pos_cnt);\n    }\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_128_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    size_t n = lst.size();\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    vint32m1_t v_neg = __riscv_vle32_v_i32m1(lst.data(), vl);\n    vint32m1_t v_pos = __riscv_vle32_v_i32m1(lst.data(), vl);\n\n    vbool32_t mask_neg = __riscv_vmslt_vx_i32m1_b32(v_neg, 0, vl);\n    vbool32_t mask_pos = __riscv_vmsgt_vx_i32m1_b32(v_pos, 0, vl);\n\n    vint32m1_t v_neg_filtered = __riscv_vcompress_vm_i32m1(v_neg, mask_neg, vl);\n    vint32m1_t v_pos_filtered = __riscv_vcompress_vm_i32m1(v_pos, mask_pos, vl);\n\n    size_t neg_count = __riscv_vpopc_m_b32(mask_neg, vl);\n    size_t pos_count = __riscv_vpopc_m_b32(mask_pos, vl);\n\n    if (neg_count > 0) {\n        largest_negative = __riscv_vredmax_vs_i32m1_i32(v_neg_filtered, std::numeric_limits<int>::min(), __riscv_vundefined_i32m1(), neg_count);\n    }\n\n    if (pos_count > 0) {\n        smallest_positive = __riscv_vredmin_vs_i32m1_i32(v_pos_filtered, std::numeric_limits<int>::max(), __riscv_vundefined_i32m1(), pos_count);\n    }\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_128_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    size_t n = lst.size();\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    vint32m1_t v_neg = __riscv_vle32_v_i32m1(lst.data(), vl);\n    vint32m1_t v_pos = __riscv_vle32_v_i32m1(lst.data(), vl);\n\n    vbool32_t mask_neg = __riscv_vmslt_vx_i32m1_b32(v_neg, 0, vl);\n    vbool32_t mask_pos = __riscv_vmsgt_vx_i32m1_b32(v_pos, 0, vl);\n\n    vint32m1_t v_neg_filtered = __riscv_vcompress_vm_i32m1(v_neg, mask_neg, vl);\n    vint32m1_t v_pos_filtered = __riscv_vcompress_vm_i32m1(v_pos, mask_pos, vl);\n\n    size_t neg_count = __riscv_vpopc_m_b32(mask_neg, vl);\n    size_t pos_count = __riscv_vpopc_m_b32(mask_pos, vl);\n\n    if (neg_count > 0) {\n        largest_negative = __riscv_vmax_vs_i32m1_i32(v_neg_filtered, std::numeric_limits<int>::min(), neg_count);\n    }\n\n    if (pos_count > 0) {\n        smallest_positive = __riscv_vmin_vs_i32m1_i32(v_pos_filtered, std::numeric_limits<int>::max(), pos_count);\n    }\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_128_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    size_t n = lst.size();\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    vint32m1_t v_neg = __riscv_vle32_v_i32m1(lst.data(), vl);\n    vint32m1_t v_pos = __riscv_vle32_v_i32m1(lst.data(), vl);\n\n    vbool32_t mask_neg = __riscv_vmslt_vx_i32m1_b32(v_neg, 0, vl);\n    vbool32_t mask_pos = __riscv_vmsgt_vx_i32m1_b32(v_pos, 0, vl);\n\n    vint32m1_t v_neg_filtered = __riscv_vcompress_vm_i32m1(v_neg, mask_neg, vl);\n    vint32m1_t v_pos_filtered = __riscv_vcompress_vm_i32m1(v_pos, mask_pos, vl);\n\n    size_t neg_cnt = __riscv_vpopc_m_b32(mask_neg, vl);\n    size_t pos_cnt = __riscv_vpopc_m_b32(mask_pos, vl);\n\n    if (neg_cnt > 0) {\n        largest_negative = __riscv_vmax_vs_i32m1_i32(v_neg_filtered, std::numeric_limits<int>::min(), neg_cnt);\n    }\n\n    if (pos_cnt > 0) {\n        smallest_positive = __riscv_vmin_vs_i32m1_i32(v_pos_filtered, std::numeric_limits<int>::max(), pos_cnt);\n    }\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_129_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; i++) {\n        uint64_t factorial = 1;\n        size_t vl = vsetvl_e64m1(i);\n        vuint64m1_t v_i = vid_v_u64m1(vl);\n        vuint64m1_t v_ones = vmv_v_x_u64m1(1, vl);\n        vuint64m1_t v_factorial = vmul_vv_u64m1(v_i, v_ones, vl);\n\n        for (size_t j = 2; j <= i; j++) {\n            vl = vsetvl_e64m1(j);\n            vuint64m1_t v_j = vmv_v_x_u64m1(j, vl);\n            v_factorial = vmul_vv_u64m1(v_factorial, v_j, vl);\n        }\n\n        uint64_t temp_result[1];\n        vse64_v_u64m1(temp_result, v_factorial, vl);\n        factorial = temp_result[0];\n\n        result *= factorial;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; i++) {\n        uint64_t factorial = 1;\n        size_t vl = vsetvl_e64m1(i);\n        vuint64m1_t v_i = vid_v_u64m1(vl);\n        vuint64m1_t v_ones = vmv_v_x_u64m1(1, vl);\n        vuint64m1_t v_factorial = vmul_vv_u64m1(v_i, v_ones, vl);\n\n        for (size_t j = 2; j <= i; j++) {\n            vl = vsetvl_e64m1(j);\n            v_i = vid_v_u64m1(vl);\n            v_factorial = vmul_vv_u64m1(v_factorial, v_i, vl);\n        }\n\n        uint64_t temp_result[1];\n        vse64_v_u64m1(temp_result, v_factorial, vl);\n        factorial = temp_result[0];\n\n        result *= factorial;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    uint64_t result = 1;\n    uint64_t i;\n\n    for (i = 1; i <= n; i++) {\n        uint64_t factorial = 1;\n        uint64_t j;\n\n        size_t vl = vsetvl_e64m1(i);\n        vuint64m1_t v_j = vid_v_u64m1(vl);\n        vuint64m1_t v_ones = vmv_v_x_u64m1(1, vl);\n        vuint64m1_t v_factorial = vmv_v_x_u64m1(1, vl);\n\n        for (j = 1; j <= i; j += vl) {\n            vl = vsetvl_e64m1(i - j + 1);\n            v_j = vadd_vx_u64m1(v_j, j - 1, vl);\n            v_factorial = vmul_vv_u64m1(v_factorial, v_j, vl);\n        }\n\n        vuint64m1_t v_sum = vredsum_vs_u64m1_u64m1(v_factorial, v_ones, vl);\n        factorial *= v_sum[0];\n\n        result *= factorial;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    uint64_t result = 1;\n    uint64_t i;\n\n    for (i = 1; i <= n; i++) {\n        uint64_t factorial = 1;\n        uint64_t j;\n\n        size_t vl = vsetvl_e64m1(i);\n        vuint64m1_t v_j = vid_v_u64m1(vl);\n        vuint64m1_t v_ones = vmv_v_x_u64m1(1, vl);\n        vuint64m1_t v_factorial = vmul_vv_u64m1(v_j, v_ones, vl);\n\n        for (j = 2; j <= i; j++) {\n            vl = vsetvl_e64m1(j);\n            v_j = vid_v_u64m1(vl);\n            v_factorial = vmul_vv_u64m1(v_factorial, v_j, vl);\n        }\n\n        size_t k;\n        for (k = 0; k < vl; k++) {\n            factorial *= v_factorial[k];\n        }\n\n        result *= factorial;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; i++) {\n        uint64_t factorial = 1;\n        size_t vl = vsetvl_e64m1(i);\n        vuint64m1_t v_i = vid_v_u64m1(vl);\n        vuint64m1_t v_ones = vmv_v_x_u64m1(1, vl);\n        vuint64m1_t v_factorial = vmul_vv_u64m1(v_i, v_ones, vl);\n\n        for (size_t j = 2; j <= i; j++) {\n            vl = vsetvl_e64m1(j);\n            v_i = vid_v_u64m1(vl);\n            v_factorial = vmul_vv_u64m1(v_factorial, v_i, vl);\n        }\n\n        uint64_t temp_result[1];\n        vse64_v_u64m1(temp_result, v_factorial, vl);\n        factorial = temp_result[0];\n\n        result *= factorial;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_130_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    size_t n = lst.size();\n    int sum = 0;\n\n    // Define the stride for multiples of 3 and 4\n    size_t stride_3 = 3;\n    size_t stride_4 = 4;\n\n    // Create masks for indices that are multiples of 3 and 4\n    vbool32_t mask_3, mask_4;\n    vint32m1_t vec, vec_squared, vec_cubed;\n    size_t vl;\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n\n        // Load vector from memory\n        vec = vle32_v_i32m1(lst.data() + i, vl);\n\n        // Create masks for multiples of 3 and 4\n        mask_3 = vmseq_vx_i32m1_b32(vec, i % stride_3 == 0 ? 0 : stride_3, vl);\n        mask_4 = vmseq_vx_i32m1_b32(vec, i % stride_4 == 0 ? 0 : stride_4, vl) & vmn_vx_i32m1_b32(mask_3, 1, vl);\n\n        // Square elements at multiples of 3\n        vec_squared = vfmul_vv_i32m1(vec, vec, vl);\n        vec = vmerge_vvm_i32m1(vec_squared, vec, mask_3, vl);\n\n        // Cube elements at multiples of 4 and not multiples of 3\n        vec_cubed = vfmul_vv_i32m1(vec, vec_squared, vl);\n        vec = vmerge_vvm_i32m1(vec_cubed, vec, mask_4, vl);\n\n        // Sum the vector elements\n        sum += vredsum_vs_i32m1_i32(vec, 0, vl);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    size_t n = lst.size();\n    int sum = 0;\n\n    // Define the stride for multiples of 3 and 4\n    size_t stride_3 = 3;\n    size_t stride_4 = 4;\n\n    // Create masks for multiples of 3 and 4\n    vbool32_t mask_3, mask_4;\n    vint32m1_t vec, vec_squared, vec_cubed;\n    size_t vl;\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n\n        // Load vector from memory\n        vec = vle32_v_i32m1(lst.data() + i, vl);\n\n        // Create masks for multiples of 3 and 4\n        mask_3 = vmseq_vx_i32m1_b32(vec, i / stride_3 * stride_3, vl);\n        mask_4 = vmseq_vx_i32m1_b32(vec, i / stride_4 * stride_4, vl);\n\n        // Square the elements at multiples of 3\n        vec_squared = vsmul_vv_i32m1(vec, vec, vl);\n        vec = vmerge_vvm_i32m1(vec_squared, vec, mask_3, vl);\n\n        // Cube the elements at multiples of 4 and not multiples of 3\n        vec_cubed = vsmul_vv_i32m1(vec, vec_squared, vl);\n        mask_4 = vmnand_mm_b32(mask_3, mask_4, vl);\n        vec = vmerge_vvm_i32m1(vec_cubed, vec, mask_4, vl);\n\n        // Sum the vector elements\n        sum += vredsum_vs_i32m1_i32(vec, 0, vl);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    size_t n = lst.size();\n    int sum = 0;\n\n    // Define the stride for multiples of 3 and 4\n    size_t stride_3 = 3;\n    size_t stride_4 = 4;\n\n    // Create masks for multiples of 3 and 4\n    vbool32_t mask_3, mask_4;\n    vint32m1_t vec, vec_squared, vec_cubed;\n    size_t vl;\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n\n        // Load vector from memory\n        vec = vle32_v_i32m1(lst.data() + i, vl);\n\n        // Create masks for multiples of 3 and 4\n        mask_3 = vmseq_vx_i32m1_b32(vec, i / stride_3 * stride_3, vl);\n        mask_4 = vmseq_vx_i32m1_b32(vec, i / stride_4 * stride_4, vl) & vmnseq_vx_i32m1_b32(vec, i / stride_3 * stride_3, vl);\n\n        // Square elements at multiples of 3\n        vec_squared = vfmul_vv_i32m1(vec, vec, vl);\n        vec = vmerge_vvm_i32m1(vec_squared, vec, mask_3, vl);\n\n        // Cube elements at multiples of 4 and not multiples of 3\n        vec_cubed = vfmul_vv_i32m1(vec, vec_squared, vl);\n        vec = vmerge_vvm_i32m1(vec_cubed, vec, mask_4, vl);\n\n        // Sum the vector elements\n        sum += vredsum_vs_i32m1_i32(vec, 0, vl);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    size_t n = lst.size();\n    int sum = 0;\n\n    // Define the stride for multiples of 3 and 4\n    size_t stride_3 = 3;\n    size_t stride_4 = 4;\n\n    // Create masks for indices that are multiples of 3 and 4\n    vbool32_t mask_3, mask_4;\n    vint32m1_t vec, squared, cubed;\n    size_t vl;\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n\n        // Load vector from memory\n        vec = vle32_v_i32m1(lst.data() + i, vl);\n\n        // Create masks for multiples of 3 and 4\n        mask_3 = vmseq_vx_i32m1_b32(vec, i % stride_3 == 0 ? 0 : stride_3, vl);\n        mask_4 = vmseq_vx_i32m1_b32(vec, i % stride_4 == 0 ? 0 : stride_4, vl) & vmn_vx_i32m1_b32(mask_3, 1, vl);\n\n        // Square elements at indices that are multiples of 3\n        squared = vsll_vx_i32m1(vec, 1, vl);\n        squared = vsmul_vv_i32m1(squared, vec, vl);\n\n        // Cube elements at indices that are multiples of 4 and not multiples of 3\n        cubed = vmul_vv_i32m1(vec, vec, vl);\n        cubed = vmul_vv_i32m1(cubed, vec, vl);\n\n        // Blend squared and cubed values into the original vector\n        vec = vmerge_vvm_i32m1(squared, cubed, mask_3, vl);\n        vec = vmerge_vvm_i32m1(vec, cubed, mask_4, vl);\n\n        // Sum the vector elements\n        sum += vredsum_vs_i32m1_i32(vec, 0, vl);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    size_t n = lst.size();\n    int sum = 0;\n\n    // Define the stride for multiples of 3 and 4\n    size_t stride_3 = 3;\n    size_t stride_4 = 4;\n\n    // Create masks for multiples of 3 and 4\n    vbool32_t mask_3, mask_4;\n    vint32m1_t vec, vec_squared, vec_cubed;\n    size_t vl;\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n\n        // Load vector from memory\n        vec = vle32_v_i32m1(lst.data() + i, vl);\n\n        // Create masks for indices that are multiples of 3 and 4\n        mask_3 = vmseq_vx_i32m1_b32(vec, i / stride_3 * stride_3, vl);\n        mask_4 = vmseq_vx_i32m1_b32(vec, i / stride_4 * stride_4, vl);\n\n        // Square elements at indices that are multiples of 3\n        vec_squared = vsmul_vv_i32m1(vec, vec, vl);\n        vec = vmerge_vvm_i32m1(vec_squared, vec, mask_3, vl);\n\n        // Cube elements at indices that are multiples of 4 and not multiples of 3\n        vec_cubed = vsmul_vv_i32m1(vec, vec_squared, vl);\n        mask_4 = vmnand_mm_b32(mask_4, mask_3, vl);\n        vec = vmerge_vvm_i32m1(vec_cubed, vec, mask_4, vl);\n\n        // Sum the vector elements\n        sum += vredsum_vs_i32m1_i32(vec, 0, vl);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_131_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums){\n    int count = 0;\n    size_t n = nums.size();\n    const int *ptr = nums.data();\n\n    vbool32_t mask;\n    vint32m1_t vec, first_digit_vec, last_digit_vec, ten_vec;\n    size_t vl;\n\n    ten_vec = vmv_v_x_i32m1(10, 1);\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        vec = vle32_v_i32m1(ptr + i, vl);\n\n        // Check if elements are greater than 10\n        mask = vmgt_vv_b32m1(vec, ten_vec, vl);\n\n        // Extract last digit\n        last_digit_vec = vand_vx_i32m1(vec, 0xF, vl);\n\n        // Extract first digit\n        vint32m1_t abs_vec = vabs_v_i32m1(vec, vl);\n        first_digit_vec = abs_vec;\n        for (int shift = 4; shift < 32; shift *= 2) {\n            vint32m1_t shifted = vsrl_vx_i32m1(abs_vec, shift, vl);\n            first_digit_vec = vor_vv_i32m1(first_digit_vec, shifted, vl);\n        }\n        first_digit_vec = vand_vx_i32m1(first_digit_vec, 0xF, vl);\n\n        // Check if both first and last digits are odd\n        vbool32_t odd_last_digit_mask = vmandn_vx_b32m1(mask, vmerge_vvm_i32m1(vmsne_vx_b32m1(last_digit_vec, 0, vl), vmsne_vx_b32m1(last_digit_vec, 2, vl), vmsne_vx_b32m1(last_digit_vec, 4, vl), vmsne_vx_b32m1(last_digit_vec, 6, vl), vmsne_vx_b32m1(last_digit_vec, 8, vl), vl), vl);\n        vbool32_t odd_first_digit_mask = vmandn_vx_b32m1(mask, vmerge_vvm_i32m1(vmsne_vx_b32m1(first_digit_vec, 0, vl), vmsne_vx_b32m1(first_digit_vec, 2, vl), vmsne_vx_b32m1(first_digit_vec, 4, vl), vmsne_vx_b32m1(first_digit_vec, 6, vl), vmsne_vx_b32m1(first_digit_vec, 8, vl), vl), vl);\n        mask = vand_vv_b32m1(odd_last_digit_mask, odd_first_digit_mask, vl);\n\n        // Count true values in mask\n        count += vmcntm_b32_m_b1(mask, vl);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums){\n    int count = 0;\n    size_t n = nums.size();\n    const int *ptr = nums.data();\n\n    vbool32_t mask;\n    vint32m1_t vec, first_digit_vec, last_digit_vec, ten_vec;\n    size_t vl;\n\n    ten_vec = vmv_v_x_i32m1(10, 1);\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        vec = vle32_v_i32m1(ptr + i, vl);\n\n        // Check if elements are greater than 10\n        mask = vmgt_vv_b32m1(vec, ten_vec, vl);\n\n        // Extract last digit\n        last_digit_vec = vand_vx_i32m1(vec, 0xF, vl);\n\n        // Extract first digit\n        vint32m1_t abs_vec = vabs_v_i32m1(vec, vl);\n        first_digit_vec = abs_vec;\n        for (int shift = 4; shift < 32; shift *= 2) {\n            vint32m1_t shifted = vsrl_vx_i32m1(abs_vec, shift, vl);\n            first_digit_vec = vor_vv_i32m1(first_digit_vec, shifted, vl);\n        }\n        first_digit_vec = vand_vx_i32m1(first_digit_vec, 0xF, vl);\n\n        // Check if both first and last digits are odd\n        vbool32_t odd_first_digit_mask = vmsne_vx_b32m1(first_digit_vec, 0, vl);\n        vbool32_t odd_last_digit_mask = vmsne_vx_b32m1(last_digit_vec, 0, vl);\n        for (int digit : {1, 3, 5, 7, 9}) {\n            odd_first_digit_mask = vmandn_vx_b32m1(odd_first_digit_mask, vmsne_vx_b32m1(first_digit_vec, digit, vl), vl);\n            odd_last_digit_mask = vmandn_vx_b32m1(odd_last_digit_mask, vmsne_vx_b32m1(last_digit_vec, digit, vl), vl);\n        }\n\n        // Combine masks\n        mask = vmand_vv_b32m1(mask, odd_first_digit_mask, vl);\n        mask = vmand_vv_b32m1(mask, odd_last_digit_mask, vl);\n\n        // Count true elements in mask\n        count += vmcntm_b32_m_b1(mask, vl);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums){\n    int count = 0;\n    size_t n = nums.size();\n    const int *data = nums.data();\n\n    vbool32_t mask;\n    vint32m1_t vec, first_digit_vec, last_digit_vec, ten_vec;\n    size_t vl;\n\n    ten_vec = vmv_v_x_i32m1(10, 1);\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        vec = vle32_v_i32m1(&data[i], vl);\n\n        // Check if elements are greater than 10\n        mask = vmgt_vv_b32m1(vec, ten_vec, vl);\n\n        // Extract last digit\n        last_digit_vec = vand_vx_i32m1(vec, 0xF, vl);\n\n        // Extract first digit\n        vint32m1_t abs_vec = vabs_v_i32m1(vec, vl);\n        first_digit_vec = abs_vec;\n        for (int shift = 4; shift < 32; shift *= 2) {\n            first_digit_vec = vor_vv_i32m1(first_digit_vec, vsrl_vx_i32m1(first_digit_vec, shift, vl), vl);\n        }\n        first_digit_vec = vand_vx_i32m1(first_digit_vec, 0xF, vl);\n\n        // Check if both first and last digits are odd\n        vbool32_t odd_last_digit_mask = vmandn_vx_b32m1(mask, vmerge_vvm_i32m1(vmsne_vx_b32m1(last_digit_vec, 0, vl), vmsne_vx_b32m1(last_digit_vec, 2, vl), vmsne_vx_b32m1(last_digit_vec, 4, vl), vmsne_vx_b32m1(last_digit_vec, 6, vl), vmsne_vx_b32m1(last_digit_vec, 8, vl), vl), vl);\n        vbool32_t odd_first_digit_mask = vmandn_vx_b32m1(odd_last_digit_mask, vmerge_vvm_i32m1(vmsne_vx_b32m1(first_digit_vec, 0, vl), vmsne_vx_b32m1(first_digit_vec, 2, vl), vmsne_vx_b32m1(first_digit_vec, 4, vl), vmsne_vx_b32m1(first_digit_vec, 6, vl), vmsne_vx_b32m1(first_digit_vec, 8, vl), vl), vl);\n\n        // Count true values in mask\n        count += vmcntm_b32m1_b32(odd_first_digit_mask, vl);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums){\n    int count = 0;\n    size_t n = nums.size();\n    const int *ptr = nums.data();\n\n    vbool32_t mask;\n    vint32m1_t vec, first_digit_vec, last_digit_vec, ten_vec;\n    size_t vl;\n\n    ten_vec = vmv_v_x_i32m1(10, 1);\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        vec = vle32_v_i32m1(ptr + i, vl);\n\n        // Check if elements are greater than 10\n        mask = vmgt_vv_b32m1(vec, ten_vec, vl);\n\n        // Extract last digit\n        last_digit_vec = vand_vx_i32m1(vec, 0xF, vl);\n\n        // Extract first digit\n        vint32m1_t abs_vec = vabs_v_i32m1(vec, vl);\n        first_digit_vec = abs_vec;\n        for (int shift = 4; shift < 32; shift *= 2) {\n            vint32m1_t shifted = vsrl_vx_i32m1(abs_vec, shift, vl);\n            first_digit_vec = vor_vv_i32m1(first_digit_vec, shifted, vl);\n        }\n        first_digit_vec = vand_vx_i32m1(first_digit_vec, 0xF, vl);\n\n        // Check if both first and last digits are odd\n        vbool32_t odd_last_digit_mask = vmandn_vx_b32m1(mask, vmerge_vvm_i32m1(vmsne_vx_b32m1(last_digit_vec, 0, vl), vmsne_vx_b32m1(last_digit_vec, 2, vl), vmsne_vx_b32m1(last_digit_vec, 4, vl), vmsne_vx_b32m1(last_digit_vec, 6, vl), vmsne_vx_b32m1(last_digit_vec, 8, vl), vl), vl);\n        vbool32_t odd_first_digit_mask = vmandn_vx_b32m1(odd_last_digit_mask, vmerge_vvm_i32m1(vmsne_vx_b32m1(first_digit_vec, 0, vl), vmsne_vx_b32m1(first_digit_vec, 2, vl), vmsne_vx_b32m1(first_digit_vec, 4, vl), vmsne_vx_b32m1(first_digit_vec, 6, vl), vmsne_vx_b32m1(first_digit_vec, 8, vl), vl), vl);\n\n        // Count true values in mask\n        count += vmcntm_b32_m_b1(odd_first_digit_mask, vl);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums){\n    int count = 0;\n    size_t n = nums.size();\n    const int *data = nums.data();\n\n    vbool32_t mask;\n    vint32m1_t vec, first_digit_vec, last_digit_vec, ten_vec;\n    size_t vl;\n\n    ten_vec = vmv_v_x_i32m1(10, 1);\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        vec = vle32_v_i32m1(&data[i], vl);\n\n        // Check if elements are greater than 10\n        mask = vmgt_vv_b32m1(vec, ten_vec, vl);\n\n        // Extract last digit\n        last_digit_vec = vand_vx_i32m1(vec, 0xF, vl);\n\n        // Extract first digit\n        vint32m1_t abs_vec = vabs_v_i32m1(vec, vl);\n        first_digit_vec = abs_vec;\n        for (int shift = 4; shift < 32; shift *= 2) {\n            first_digit_vec = vor_vv_i32m1(first_digit_vec, vsrl_vx_i32m1(first_digit_vec, shift, vl), vl);\n        }\n        first_digit_vec = vand_vx_i32m1(first_digit_vec, 0xF, vl);\n\n        // Check if both first and last digits are odd\n        vbool32_t odd_last_digit_mask = vmandn_vx_b32m1(mask, vmerge_vvm_i32m1(vmsne_vx_i32m1(last_digit_vec, 0, vl), vmsne_vx_i32m1(last_digit_vec, 2, vl), vl), vl);\n        odd_last_digit_mask = vmandn_vx_b32m1(odd_last_digit_mask, vmerge_vvm_i32m1(vmsne_vx_i32m1(last_digit_vec, 4, vl), vmsne_vx_i32m1(last_digit_vec, 6, vl), vl), vl);\n        odd_last_digit_mask = vmandn_vx_b32m1(odd_last_digit_mask, vmerge_vvm_i32m1(vmsne_vx_i32m1(last_digit_vec, 8, vl), vmsne_vx_i32m1(last_digit_vec, 10, vl), vl), vl);\n\n        vbool32_t odd_first_digit_mask = vmandn_vx_b32m1(mask, vmerge_vvm_i32m1(vmsne_vx_i32m1(first_digit_vec, 0, vl), vmsne_vx_i32m1(first_digit_vec, 2, vl), vl), vl);\n        odd_first_digit_mask = vmandn_vx_b32m1(odd_first_digit_mask, vmerge_vvm_i32m1(vmsne_vx_i32m1(first_digit_vec, 4, vl), vmsne_vx_i32m1(first_digit_vec, 6, vl), vl), vl);\n        odd_first_digit_mask = vmandn_vx_b32m1(odd_first_digit_mask, vmerge_vvm_i32m1(vmsne_vx_i32m1(first_digit_vec, 8, vl), vmsne_vx_i32m1(first_digit_vec, 10, vl), vl), vl);\n\n        mask = vand_vv_b32m1(odd_last_digit_mask, odd_first_digit_mask, vl);\n\n        count += vmcntm_b32_m_b1(mask, vl);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t get_max_triples_simd(uint64_t n){\n    uint64_t count = 0;\n    size_t vl = vsetvl_e64m1(n);\n    vint64m1_t idx_vec = vid_v_i64m1(vl);\n    vint64m1_t a_vec = vmul_vv_i64m1(idx_vec, idx_vec, vl);\n    a_vec = vsub_vv_i64m1(a_vec, idx_vec, vl);\n    a_vec = vadd_vi_i64m1(a_vec, 1, vl);\n\n    for (size_t i = 0; i < n; ++i) {\n        for (size_t j = i + 1; j < n; ++j) {\n            for (size_t k = j + 1; k < n; ++k) {\n                int64_t ai = vget_i64m1_i64(a_vec, i);\n                int64_t aj = vget_i64m1_i64(a_vec, j);\n                int64_t ak = vget_i64m1_i64(a_vec, k);\n                if ((ai + aj + ak) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    uint64_t count = 0;\n    size_t vlmax = vsetvl_e64m1(n);\n    vint64m1_t idx_vec = vid_v_i64m1(vlmax);\n    vint64m1_t a_vec = vmul_vv_i64m1(idx_vec, idx_vec, vlmax);\n    a_vec = vsub_vv_i64m1(a_vec, idx_vec, vlmax);\n    a_vec = vadd_vi_i64m1(a_vec, 1, vlmax);\n\n    for (size_t i = 0; i < n; ++i) {\n        for (size_t j = i + 1; j < n; ++j) {\n            for (size_t k = j + 1; k < n; ++k) {\n                int64_t ai = vget_i64m1_i64(a_vec, i);\n                int64_t aj = vget_i64m1_i64(a_vec, j);\n                int64_t ak = vget_i64m1_i64(a_vec, k);\n                if ((ai + aj + ak) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t get_max_triples_simd(uint64_t n){\n    uint64_t count = 0;\n    size_t vl = vsetvl_e64m1(n);\n    vint64m1_t idx_vec = vid_v_i64m1(vl);\n    vint64m1_t a_vec = vmul_vv_i64m1(idx_vec, idx_vec, vl);\n    a_vec = vsub_vv_i64m1(a_vec, idx_vec, vl);\n    a_vec = vadd_vi_i64m1(a_vec, 1, vl);\n\n    for (size_t i = 0; i < n; ++i) {\n        for (size_t j = i + 1; j < n; ++j) {\n            for (size_t k = j + 1; k < n; ++k) {\n                int64_t ai = vget_i64m1_i64(a_vec, i);\n                int64_t aj = vget_i64m1_i64(a_vec, j);\n                int64_t ak = vget_i64m1_i64(a_vec, k);\n                if ((ai + aj + ak) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t get_max_triples_simd(uint64_t n){\n    uint64_t count = 0;\n    size_t vl = vsetvl_e64m1(n);\n    vint64m1_t idx_vec = vid_v_i64m1(vl);\n    vint64m1_t a_vec = vmul_vv_i64m1(idx_vec, idx_vec, vl);\n    a_vec = vsub_vv_i64m1(a_vec, idx_vec, vl);\n    a_vec = vadd_vi_i64m1(a_vec, 1, vl);\n\n    for (size_t i = 0; i < n; ++i) {\n        for (size_t j = i + 1; j < n; ++j) {\n            for (size_t k = j + 1; k < n; ++k) {\n                int64_t ai = vget_i64m1_i64(a_vec, i);\n                int64_t aj = vget_i64m1_i64(a_vec, j);\n                int64_t ak = vget_i64m1_i64(a_vec, k);\n                if ((ai + aj + ak) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t get_max_triples_simd(uint64_t n){\n    uint64_t count = 0;\n    size_t vl = __riscv_vsetvl_e64m1(n);\n    vint64m1_t idx_vec = __riscv_vseqiv_e64m1(vl);\n    vint64m1_t a_vec = __riscv_vfmul_vv_i64m1(idx_vec, idx_vec, vl);\n    a_vec = __riscv_vfsub_vv_i64m1(a_vec, idx_vec, vl);\n    a_vec = __riscv_vfadd_vx_i64m1(a_vec, 1, vl);\n\n    for (size_t i = 0; i < n; ++i) {\n        for (size_t j = i + 1; j < n; ++j) {\n            for (size_t k = j + 1; k < n; ++k) {\n                int64_t ai = __riscv_vmv_x_s_i64m1_i64(__riscv_vsll_vx_i64m1(a_vec, 0, i, vl));\n                int64_t aj = __riscv_vmv_x_s_i64m1_i64(__riscv_vsll_vx_i64m1(a_vec, 0, j, vl));\n                int64_t ak = __riscv_vmv_x_s_i64m1_i64(__riscv_vsll_vx_i64m1(a_vec, 0, k, vl));\n                if ((ai + aj + ak) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_133_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    vbool1_t mask;\n    vint32m1_t vn, vx, vy, result;\n    size_t vl = 1;\n\n    vn = vle32_v_i32m1(&n, vl);\n    vx = vle32_v_i32m1(&x, vl);\n    vy = vle32_v_i32m1(&y, vl);\n\n    // Check if n is less than 2 (not prime)\n    mask = vmblt_vx_i32m1_b1(vn, 2, vl);\n    result = vmv_v_v_i32m1(vy, vl);\n    result = vmerge_vvm_i32m1(result, vx, mask, vl);\n\n    // Check divisibility from 2 to sqrt(n)\n    for (int i = 2; i * i <= n; i++) {\n        vint32m1_t vi = vle32_v_i32m1(&i, vl);\n        vint32m1_t vmod = vrem_vv_i32m1(vn, vi, vl);\n        mask = vmseq_vx_i32m1_b1(vmod, 0, vl);\n        result = vmerge_vvm_i32m1(result, vy, mask, vl);\n    }\n\n    int output;\n    vse32_v_i32m1(&output, result, vl);\n    return output;\n}\n```"}
{"task_id": "SimdBench_133_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    vbool1_t mask;\n    vint32m1_t vn, vx, vy, result;\n    size_t vl = 1;\n\n    vn = vle32_v_i32m1(&n, vl);\n    vx = vle32_v_i32m1(&x, vl);\n    vy = vle32_v_i32m1(&y, vl);\n\n    // Check if n is less than 2 (not prime)\n    mask = vmblt_vx_i32m1_b1(vn, 2, vl);\n    result = vmv_v_v_i32m1(vy, vl);\n    result = vmerge_vvm_i32m1(result, vx, mask, vl);\n\n    // Check divisibility from 2 to sqrt(n)\n    for (int i = 2; i * i <= n; i++) {\n        vint32m1_t vi = vle32_v_i32m1(&i, vl);\n        vint32m1_t vmod = vrem_vv_i32m1(vn, vi, vl);\n        mask = vmseq_vx_i32m1_b1(vmod, 0, vl);\n        result = vmerge_vvm_i32m1(result, vy, mask, vl);\n    }\n\n    int output;\n    vse32_v_i32m1(&output, result, vl);\n    return output;\n}\n```"}
{"task_id": "SimdBench_133_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    vbool1_t mask;\n    vint32m1_t vn, vx, vy, result;\n    size_t vl = 1;\n\n    vn = vle32_v_i32m1(&n, vl);\n    vx = vle32_v_i32m1(&x, vl);\n    vy = vle32_v_i32m1(&y, vl);\n\n    // Check if n is less than 2 (not prime)\n    mask = vmblt_vx_i32m1_b1(vn, 2, vl);\n    result = vmv_v_v_i32m1(vy, vl);\n    result = vmerge_vvm_i32m1(result, vx, mask, vl);\n\n    // Check divisibility from 2 to sqrt(n)\n    for (int i = 2; i * i <= n; i++) {\n        vint32m1_t vi = vle32_v_i32m1(&i, vl);\n        vint32m1_t vmod = vrem_vv_i32m1(vn, vi, vl);\n        mask = vmseq_vx_i32m1_b1(vmod, 0, vl);\n        result = vmerge_vvm_i32m1(result, vy, mask, vl);\n    }\n\n    int output;\n    vse32_v_i32m1(&output, result, vl);\n    return output;\n}\n```"}
{"task_id": "SimdBench_133_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    vbool1_t mask;\n    vint32m1_t vn, vx, vy, result;\n    size_t vl = 1;\n\n    vn = vle32_v_i32m1(&n, vl);\n    vx = vle32_v_i32m1(&x, vl);\n    vy = vle32_v_i32m1(&y, vl);\n\n    // Check if n is a prime number\n    // This is a simplified check and may not be efficient for large numbers\n    vint32m1_t vone = vmv_v_x_i32m1(1, vl);\n    vint32m1_t vtwo = vmv_v_x_i32m1(2, vl);\n    vint32m1_t vthree = vmv_v_x_i32m1(3, vl);\n    vint32m1_t vsix = vmv_v_x_i32m1(6, vl);\n\n    mask = vmseq_vx_i32m1_b1(vn, 2, vl); // n == 2\n    vint32m1_t is_prime = vmseq_vx_i32m1_b1(vn, 2, vl); // Assume true initially\n\n    mask = vmorn_vv_b1(mask, vmseq_vx_i32m1_b1(vn, 3, vl), vl); // n == 3\n    is_prime = vmorn_vv_b1(is_prime, vmseq_vx_i32m1_b1(vn, 3, vl), vl);\n\n    vint32m1_t vmod2 = vrem_vv_i32m1(vn, vtwo, vl);\n    mask = vmorn_vv_b1(mask, vmsne_vx_i32m1_b1(vmod2, 0, vl), vl); // n % 2 != 0\n    is_prime = vmorn_vv_b1(is_prime, vmsne_vx_i32m1_b1(vmod2, 0, vl), vl);\n\n    vint32m1_t vmod3 = vrem_vv_i32m1(vn, vthree, vl);\n    mask = vmorn_vv_b1(mask, vmsne_vx_i32m1_b1(vmod3, 0, vl), vl); // n % 3 != 0\n    is_prime = vmorn_vv_b1(is_prime, vmsne_vx_i32m1_b1(vmod3, 0, vl), vl);\n\n    vint32m1_t i = vmv_v_x_i32m1(5, vl);\n    while (1) {\n        vint32m1_t vi_squared = vmul_vv_i32m1(i, i, vl);\n        mask = vmorn_vv_b1(mask, vmsge_vx_i32m1_b1(vi_squared, vn, vl), vl); // i * i >= n\n        if (vmfirst_m_b1(mask)) break;\n\n        vint32m1_t vmodi = vrem_vv_i32m1(vn, i, vl);\n        mask = vmorn_vv_b1(mask, vmsne_vx_i32m1_b1(vmodi, 0, vl), vl); // n % i != 0\n        is_prime = vmorn_vv_b1(is_prime, vmsne_vx_i32m1_b1(vmodi, 0, vl), vl);\n\n        vint32m1_t vmodi_plus_2 = vrem_vv_i32m1(vn, vadd_vv_i32m1(i, vtwo, vl), vl);\n        mask = vmorn_vv_b1(mask, vmsne_vx_i32m1_b1(vmodi_plus_2, 0, vl), vl); // n % (i + 2) != 0\n        is_prime = vmorn_vv_b1(is_prime, vmsne_vx_i32m1_b1(vmodi_plus_2, 0, vl), vl);\n\n        i = vadd_vv_i32m1(i, vsix, vl);\n    }\n\n    result = vmerge_vvm_i32m1(vx, vy, is_prime, vl);\n    int result_scalar;\n    vse32_v_i32m1(&result_scalar, result, vl);\n\n    return result_scalar;\n}\n```"}
{"task_id": "SimdBench_133_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    vbool1_t mask;\n    vint32m1_t vn, vx, vy, result;\n    size_t vl = 1;\n\n    vn = vle32_v_i32m1(&n, vl);\n    vx = vle32_v_i32m1(&x, vl);\n    vy = vle32_v_i32m1(&y, vl);\n\n    // Check if n is a prime number\n    // This is a simplified check and may not be efficient for large numbers\n    vint32m1_t vone = vmv_v_x_i32m1(1, vl);\n    vint32m1_t vtwo = vmv_v_x_i32m1(2, vl);\n    vint32m1_t vsqrt_n = viota_m_v_i32m1(vmsne_vv_i32m1_b1(vn, vone, vl), vtwo, vl);\n    vint32m1_t vsqrt_n_squared = vmul_vv_i32m1(vsqrt_n, vsqrt_n, vl);\n    mask = vmsle_vv_i32m1_b1(vn, vsqrt_n_squared, vl);\n\n    vint32m1_t vzero = vmv_v_x_i32m1(0, vl);\n    vint32m1_t vthree = vmv_v_x_i32m1(3, vl);\n    vint32m1_t vtwo_times_i = vmul_vx_i32m1(vthree, 2, vl);\n    vint32m1_t vi = vle32_v_i32m1(&vthree, vl);\n\n    while (vm_first_m_b1(mask)) {\n        vint32m1_t vremainder = vrem_vv_i32m1(vn, vi, vl);\n        mask = vmaskn_m_b1(mask, vmsne_vv_i32m1_b1(vremainder, vzero, vl), vl);\n        vi = vadd_vv_i32m1(vi, vtwo_times_i, vl);\n    }\n\n    mask = vmsne_vv_i32m1_b1(vn, vone, vl);\n    result = vmerge_vvm_i32m1(vx, vy, mask, vl);\n\n    return vfmv_f_s_i32m1_i32(result, vl);\n}\n```"}
{"task_id": "SimdBench_134_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    size_t n = lst.size();\n    if (n == 0) return 0;\n\n    uint64_t sum_of_squares = 0;\n    size_t vlmax = vsetvl_e32m1(n);\n\n    for (size_t i = 0; i < n; i += vlmax) {\n        size_t vl = vsetvl_e32m1(n - i);\n        vfloat32m1_t vec = vle32_v_f32m1(lst.data() + i, vl);\n        vbool4_t mask_odd = vmfne_vf_f32m1_b4(vec, 0.0f, vl);\n        vint32m1_t vec_int = vfcvt_x_f_v_i32m1(vec, vl);\n        vbool4_t mask_positive = vmfge_vf_f32m1_b4(vec, 0.0f, vl);\n        vbool4_t mask_integer = vmseq_vv_i32m1_b4(vec_int, vfcvt_f_x_v_f32m1(vec, vl), vl);\n        vbool4_t mask = vmand_mm_b4(mask_odd, vmand_mm_b4(mask_positive, mask_integer, vl), vl);\n\n        vint32m1_t vec_odd_int = vcompress_vm_i32m1(vec_int, mask, vl);\n        vint32m1_t vec_odd_squared = vsmul_vv_i32m1(vec_odd_int, vec_odd_int, vl);\n        vint64m1_t vec_odd_squared_64 = vwcvt_x_x_v_i64m1_i32m1(vec_odd_squared, vl);\n\n        sum_of_squares += vredsum_vs_i64m1_i64(vec_odd_squared_64, 0, vl);\n    }\n\n    return sum_of_squares;\n}\n```"}
{"task_id": "SimdBench_134_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    size_t n = lst.size();\n    if (n == 0) return 0;\n\n    uint64_t sum_of_squares = 0;\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    vfloat32m1_t vec = __riscv_vle32_v_f32m1(lst.data(), vl);\n    vbool32_t mask_odd = __riscv_vmsne_vx_i32m1_b32(__riscv_vfcvt_x_f_v_i32m1(vec, vl), 0, vl);\n    vbool32_t mask_positive = __riscv_vfsgt_vf_f32m1_b32(vec, 0.0f, vl);\n    vbool32_t mask_int = __riscv_vmsne_vx_i32m1_b32(__riscv_vfcvt_x_f_v_i32m1(vec, vl), __riscv_vfcvt_x_f_v_i32m1(__riscv_vfcvt_f_x_v_f32m1(vec, vl), vl), vl);\n    vbool32_t mask = __riscv_vand_vv_b32(mask_odd, mask_positive, vl);\n    mask = __riscv_vand_vv_b32(mask, mask_int, vl);\n\n    vint32m1_t int_vec = __riscv_vfcvt_x_f_v_i32m1(vec, vl);\n    vint32m1_t odd_int_vec = __riscv_vcompress_vm_i32m1(int_vec, mask, vl);\n    size_t odd_count = __riscv_vpopc_m_b32(mask, vl);\n\n    for (size_t i = 0; i < odd_count; ++i) {\n        int val = __riscv_vmv_x_s_i32m1_i32(odd_int_vec, i);\n        if (val % 2 != 0) {\n            sum_of_squares += val * val;\n        }\n    }\n\n    return sum_of_squares;\n}\n```"}
{"task_id": "SimdBench_134_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    size_t n = lst.size();\n    if (n == 0) return 0;\n\n    uint64_t sum_of_squares = 0;\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    vfloat32m1_t vec = __riscv_vle32_v_f32m1(lst.data(), vl);\n    vbool32_t mask_odd = __riscv_vmsne_vf_i32m1_b32(vec, 0.0f, vl);\n    vbool32_t mask_positive = __riscv_vfmge_vf_f32m1_b32(vec, 0.0f, vl);\n    vbool32_t mask_integer = __riscv_vfredusum_vs_f32m1_f32mf2(__riscv_vfcvt_rtz_x_f_v_i32m1_f32m1(vec, vl), 0.0f, __riscv_vfmul_vv_f32m1(vec, vec, vl), vl);\n\n    vbool32_t mask = __riscv_vand_vv_b32(mask_odd, mask_positive, vl);\n    mask = __riscv_vand_vv_b32(mask, mask_integer, vl);\n\n    vfloat32m1_t vec_squared = __riscv_vfmul_vv_f32m1(vec, vec, vl);\n    vfloat32m1_t vec_filtered = __riscv_vcompress_vm_f32m1(vec_squared, mask, vl);\n\n    size_t filtered_vl = __riscv_vpopc_m_b32(mask, vl);\n    for (size_t i = 0; i < filtered_vl; ++i) {\n        sum_of_squares += static_cast<uint64_t>(__riscv_vget_f32m1_i32mf2(vec_filtered, i));\n    }\n\n    return sum_of_squares;\n}\n```"}
{"task_id": "SimdBench_134_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    size_t n = lst.size();\n    if (n == 0) return 0;\n\n    uint64_t sum = 0;\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    vfloat32m1_t vec = __riscv_vle32_v_f32m1(lst.data(), vl);\n    vbool32_t mask_odd = __riscv_vmsne_vx_i32m1_b32(vec, 0, vl);\n    mask_odd = __riscv_vmand_vv_b32(mask_odd, __riscv_vmerge_vvm_b32(__riscv_vmslt_vx_i32m1_b32(vec, 0, vl), __riscv_vmseq_vx_i32m1_b32(__riscv_vfcvt_rtz_x_f_v_i32m1(vec, vl), vec, vl), vl), vl);\n\n    vint32m1_t vec_int = __riscv_vfcvt_rtz_x_f_v_i32m1(vec, vl);\n    vint32m1_t vec_odd = __riscv_vcompress_vm_i32m1(vec_int, mask_odd, vl);\n\n    size_t m = __riscv_vpopc_m_b32(mask_odd, vl);\n    for (size_t i = 0; i < m; ++i) {\n        int32_t val = __riscv_vmv_x_s_i32m1_i32(vec_odd, i);\n        if (val % 2 != 0) {\n            sum += val * val;\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    size_t n = lst.size();\n    if (n == 0) return 0;\n\n    uint64_t sum_of_squares = 0;\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    vfloat32m1_t vec = __riscv_vle32_v_f32m1(lst.data(), vl);\n    vbool32_t mask_odd = __riscv_vmsne_vx_i32m1_b32(__riscv_vfcvt_x_f_v_i32m1(vec, vl), 0, vl);\n    vbool32_t mask_positive = __riscv_vfsgt_vf_f32m1_b32(vec, 0.0f, vl);\n    vbool32_t mask_int = __riscv_vmsne_vx_i32m1_b32(__riscv_vfcvt_x_f_v_i32m1(vec, vl), __riscv_vfcvt_x_f_v_i32m1(__riscv_vfcvt_f_x_v_f32m1(vec, vl), vl), vl);\n    vbool32_t mask = __riscv_vand_vv_b32(mask_odd, mask_positive, vl);\n    mask = __riscv_vand_vv_b32(mask, mask_int, vl);\n\n    vint32m1_t int_vec = __riscv_vfcvt_x_f_v_i32m1(vec, vl);\n    vint32m1_t odd_int_vec = __riscv_vcompress_vm_i32m1(int_vec, mask, vl);\n    size_t odd_count = __riscv_vpopc_m_b32(mask, vl);\n\n    for (size_t i = 0; i < odd_count; ++i) {\n        int val = __riscv_vmv_x_s_i32m1_i32(odd_int_vec, i);\n        if (val % 2 != 0) {\n            sum_of_squares += val * val;\n        }\n    }\n\n    return sum_of_squares;\n}\n```"}
{"task_id": "SimdBench_135_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t n = game.size();\n    std::vector<int> result(n);\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    vint32m1_t game_v = __riscv_vle32_v_i32m1(game.data(), vl);\n    vint32m1_t guess_v = __riscv_vle32_v_i32m1(guess.data(), vl);\n    vint32m1_t diff_v = __riscv_vsub_vv_i32m1(game_v, guess_v, vl);\n    vint32m1_t abs_diff_v = __riscv_vabs_v_i32m1(diff_v, vl);\n\n    __riscv_vse32_v_i32m1(result.data(), abs_diff_v, vl);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t n = game.size();\n    std::vector<int> result(n);\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    vint32m1_t game_v = __riscv_vle32_v_i32m1(game.data(), vl);\n    vint32m1_t guess_v = __riscv_vle32_v_i32m1(guess.data(), vl);\n    vint32m1_t diff_v = __riscv_vsub_vv_i32m1(game_v, guess_v, vl);\n    vint32m1_t abs_diff_v = __riscv_vabs_v_i32m1(diff_v, vl);\n\n    __riscv_vse32_v_i32m1(result.data(), abs_diff_v, vl);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t n = game.size();\n    std::vector<int> result(n);\n    size_t vl;\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m8(n - i);\n        vint32m8_t game_v = vle32_v_i32m8(&game[i], vl);\n        vint32m8_t guess_v = vle32_v_i32m8(&guess[i], vl);\n        vint32m8_t diff_v = vsub_vv_i32m8(game_v, guess_v, vl);\n        vint32m8_t abs_diff_v = vabs_v_i32m8(diff_v, vl);\n        vse32_v_i32m8(&result[i], abs_diff_v, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t n = game.size();\n    std::vector<int> result(n);\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    vint32m1_t game_v = __riscv_vle32_v_i32m1(game.data(), vl);\n    vint32m1_t guess_v = __riscv_vle32_v_i32m1(guess.data(), vl);\n    vint32m1_t diff_v = __riscv_vsub_vv_i32m1(game_v, guess_v, vl);\n    vint32m1_t abs_diff_v = __riscv_vabs_v_i32m1(diff_v, vl);\n\n    __riscv_vse32_v_i32m1(result.data(), abs_diff_v, vl);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t n = game.size();\n    std::vector<int> result(n);\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    vint32m1_t game_v = __riscv_vle32_v_i32m1(game.data(), vl);\n    vint32m1_t guess_v = __riscv_vle32_v_i32m1(guess.data(), vl);\n    vint32m1_t diff_v = __riscv_vsub_vv_i32m1(game_v, guess_v, vl);\n    vint32m1_t abs_diff_v = __riscv_vabs_v_i32m1(diff_v, vl);\n\n    __riscv_vse32_v_i32m1(result.data(), abs_diff_v, vl);\n\n    return result;\n}\n```"}

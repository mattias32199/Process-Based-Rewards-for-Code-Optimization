{"task_id": "SimdBench_0_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    do {\n        size_t vl = svcntd();\n        if (i + vl > length) {\n            vl = length - i;\n            pg = svwhilelt_b64(i, length);\n        } else {\n            pg = svptrue_b64();\n        }\n        svint64_t src_vec = svld1(pg, &src[i]);\n        svint64_t dst_vec = svld1(pg, &dst[i]);\n        svbool_t mask_vec = svld1_b64(pg, (const uint8_t*)&mask[i]);\n        svint64_t result_vec = svsel_b_z(pg, mask_vec, src_vec, dst_vec);\n        svst1(pg, &dst[i], result_vec);\n        i += vl;\n    } while (i < length);\n}\n```"}
{"task_id": "SimdBench_0_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    do {\n        size_t vl = svcntd();\n        if (i + vl > length) {\n            vl = length - i;\n            pg = svwhilelt_b64(i, length);\n        } else {\n            pg = svptrue_b64();\n        }\n        svint64_t src_vec = svld1(pg, &src[i]);\n        svint64_t dst_vec = svld1(pg, &dst[i]);\n        svbool_t mask_vec = svld1_b64(pg, (const uint8_t*)&mask[i]);\n        svint64_t result_vec = svsel_b_z(pg, mask_vec, src_vec, dst_vec);\n        svst1(pg, &dst[i], result_vec);\n        i += vl;\n    } while (i < length);\n}\n```"}
{"task_id": "SimdBench_0_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    do {\n        size_t vl = svcntw();\n        if (i + vl > length) {\n            vl = length - i;\n            pg = svwhilelt_b64(i, length);\n        } else {\n            pg = svptrue_b64();\n        }\n        svint64_t src_vec = svld1_s64(pg, &src[i]);\n        svint64_t dst_vec = svld1_s64(pg, &dst[i]);\n        svbool_t mask_vec = svld1_b64(pg, (const uint64_t *)&mask[i]);\n        svint64_t result_vec = svsel_s64(mask_vec, src_vec, dst_vec);\n        svst1_s64(pg, &dst[i], result_vec);\n        i += vl;\n    } while (i < length);\n}\n```"}
{"task_id": "SimdBench_0_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    do {\n        size_t vl = svcntw();\n        if (i + vl > length) {\n            vl = length - i;\n            pg = svwhilelt_b64(i, length);\n        } else {\n            pg = svptrue_b64();\n        }\n        svint64_t src_vec = svld1_s64(pg, &src[i]);\n        svint64_t dst_vec = svld1_s64(pg, &dst[i]);\n        svbool_t mask_vec = svld1_b64(pg, (const uint64_t*)&mask[i]);\n        svint64_t result_vec = svsel_s64(mask_vec, src_vec, dst_vec);\n        svst1_s64(pg, &dst[i], result_vec);\n        i += vl;\n    } while (i < length);\n}\n```"}
{"task_id": "SimdBench_0_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    do {\n        size_t vl = svcntb() / sizeof(int64_t);\n        if (i + vl > length) {\n            vl = length - i;\n            pg = svwhilelt_b64(i, length);\n        } else {\n            pg = svptrue_b64();\n        }\n        svint64_t src_vec = svld1_s64(pg, &src[i]);\n        svint64_t dst_vec = svld1_s64(pg, &dst[i]);\n        svbool_t mask_vec = svld1_b64(pg, (const uint64_t *)&mask[i]);\n        svint64_t result_vec = svsel_s64(mask_vec, src_vec, dst_vec);\n        svst1_s64(pg, &dst[i], result_vec);\n        i += vl;\n    } while (i < length);\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t vl = svcntw();\n    svint32_t sv_scale = svdup_s32(scale);\n\n    for (size_t i = 0; i < length; i += vl) {\n        svint32_t sv_src = svld1_s32(svslidedown_n_u32(svundef_s32(), src, i));\n        svint32_t sv_tmp1 = svshr_n_s32(svmul_s32(sv_src, sv_scale), 3);\n        svint32_t sv_tmp2 = svshl_n_s32(svmul_s32(sv_src, sv_scale), 3);\n        svint32_t sv_result = svdiv_n_s32(svadd_s32(svmul_s32(sv_src, sv_scale), svmul_s32(sv_tmp1, sv_tmp2)), 7);\n        svst1_s32(svslidedown_n_u32(svundef_s32(), dst, i), sv_result);\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t vl = svcntw();\n    svint32_t sv_scale = svdup_s32(scale);\n\n    for (size_t i = 0; i < length; i += vl) {\n        svint32_t sv_src = svld1_s32(svslidedown_z(svptrue_b32(), svundef_s32(), sv_src, length - i));\n        svint32_t sv_tmp1 = svlsr_n_s32_z(svptrue_b32(), svmul_s32_z(svptrue_b32(), sv_src, sv_scale), 3);\n        svint32_t sv_tmp2 = svlsl_n_s32_z(svptrue_b32(), svmul_s32_z(svptrue_b32(), sv_src, sv_scale), 3);\n        svint32_t sv_result = svdiv_n_s32_z(svptrue_b32(), svmadd_s32_z(svptrue_b32(), svmul_s32_z(svptrue_b32(), sv_src, sv_scale), svmul_s32_z(svptrue_b32(), sv_tmp1, sv_tmp2)), 7);\n        svst1_s32(svslidedown_z(svptrue_b32(), svundef_s32(), sv_result, length - i), dst + i);\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t vl = svcntw();\n    svint32_t sv_scale = svdup_s32(scale);\n\n    for (size_t i = 0; i < length; i += vl) {\n        svint32_t sv_src = svld1_s32(svslidedown_z(svptrue_b32(), svundef_s32(), svld1_s32(svptrue_b32(), &src[i]), length - i));\n        svint32_t sv_tmp1 = svshr_n_s32(svmul_s32(sv_src, sv_scale), 3);\n        svint32_t sv_tmp2 = svshl_n_s32(svmul_s32(sv_src, sv_scale), 3);\n        svint32_t sv_result = svdiv_n_s32(svadd_s32(svmul_s32(sv_src, sv_scale), svmul_s32(sv_tmp1, sv_tmp2)), 7);\n        svst1_s32(svslidedown_z(svptrue_b32(), svundef_s32(), sv_result, length - i), &dst[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t vl = svcntw();\n    svint32_t sv_scale = svdup_s32(scale);\n\n    for (size_t i = 0; i < length; i += vl) {\n        svint32_t sv_src = svld1_s32(svslidedown_n_u32(svundef_s32(), src, i));\n        svint32_t sv_tmp1 = svlsr_n_s32(svmul_s32(sv_src, sv_scale), 3);\n        svint32_t sv_tmp2 = svlsl_n_s32(svmul_s32(sv_src, sv_scale), 3);\n        svint32_t sv_result = svdiv_s32(svadd_s32(svmul_s32(sv_src, sv_scale), svmul_s32(sv_tmp1, sv_tmp2)), 7);\n        svst1_s32(svslidedown_n_u32(svundef_s32(), dst, i), sv_result);\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < length; i += vl) {\n        svint32_t vec_src = svld1_s32(svundef_s32(), &src[i], svwhilelt_b32(svptrue_b32(), i, length));\n        svint32_t vec_scale = svdup_s32(scale);\n\n        svint32_t vec_tmp1 = svshr_n_s32(svmul_s32(vec_src, vec_scale), 3);\n        svint32_t vec_tmp2 = svshl_n_s32(svmul_s32(vec_src, vec_scale), 3);\n\n        svint32_t vec_result = svdiv_n_s32(svadd_s32(svmul_s32(vec_src, vec_scale), svmul_s32(vec_tmp1, vec_tmp2)), 7);\n\n        svst1_s32(&dst[i], vec_result, svwhilelt_b32(svptrue_b32(), i, length));\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t i = 0;\n    svbool_t pg;\n    svfloat64_t vec;\n\n    for (; i <= rows - svcntd(); i += svcntd()) {\n        pg = svptrue_b64();\n        vec = svld1(pg, &src[i * cols + stride]);\n        svst1(pg, &dst[i], vec);\n    }\n\n    for (; i < rows; ++i) {\n        dst[i] = src[i * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t i = 0;\n    svbool_t pg;\n    svdouble_t vec_src;\n\n    for (; i <= rows - svcntd(); i += svcntd()) {\n        pg = svptrue_b64();\n        vec_src = svld1(pg, &src[i * cols + stride]);\n        svst1(pg, &dst[i], vec_src);\n    }\n\n    for (; i < rows; i++) {\n        dst[i] = src[i * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t i = 0;\n    svbool_t pg;\n    svfloat64_t vec;\n\n    for (; i <= rows - svcntd(); i += svcntd()) {\n        pg = svptrue_b64();\n        vec = svld1(pg, &src[i * cols + stride]);\n        svst1(pg, &dst[i], vec);\n    }\n\n    for (; i < rows; i++) {\n        dst[i] = src[i * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t i = 0;\n    svbool_t pg;\n    svdouble_t vec_src;\n\n    for (; i <= rows - svcntd(); i += svcntd()) {\n        pg = svptrue_b64();\n        vec_src = svld1(pg, &src[i * cols + stride]);\n        svst1(pg, &dst[i], vec_src);\n    }\n\n    for (; i < rows; ++i) {\n        dst[i] = src[i * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t i = 0;\n    svbool_t pg;\n    svdouble_t vec_src;\n\n    // Process elements in vector length chunks\n    for (; i <= rows - svcntd(); i += svcntd()) {\n        pg = svptrue_b64();\n        vec_src = svld1(pg, &src[i * cols + stride]);\n        svst1(pg, &dst[i], vec_src);\n    }\n\n    // Handle remaining elements\n    if (i < rows) {\n        pg = svwhilelt_b64(i, rows);\n        vec_src = svld1(pg, &src[i * cols + stride]);\n        svst1(pg, &dst[i], vec_src);\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n\n    // Gather operation\n    while (i < length) {\n        svuint32_t idx_vec = svld1_u32(svwhilelt_b32(i, length), &indices[i]);\n        svfloat32_t val_vec = sv_gather_indexed_f32(svundef_f32(), src, idx_vec);\n        svst1_f32(svwhilelt_b32(i, length), &dst[i], val_vec);\n        i += svcntw();\n    }\n\n    // Scatter operation\n    i = 0;\n    while (i < length) {\n        svuint32_t idx_vec = svld1_u32(svwhilelt_b32(i, length), &indices[i]);\n        svfloat32_t val_vec = svld1_f32(svwhilelt_b32(i, length), &src[i]);\n        svst1_scatter_indexed_f32(dst, idx_vec, val_vec);\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n\n    // Gather operation\n    while (i < length) {\n        svuint32_t idx_vec = svld1_u32(svwhilelt_b32(i, length), &indices[i]);\n        svfloat32_t val_vec = sv_gather_indexed_f32(svundef_f32(), src, idx_vec);\n        svst1_f32(svwhilelt_b32(i, length), &dst[i], val_vec);\n        i += svcntw();\n    }\n\n    // Scatter operation\n    i = 0;\n    while (i < length) {\n        svuint32_t idx_vec = svld1_u32(svwhilelt_b32(i, length), &indices[i]);\n        svfloat32_t val_vec = svld1_f32(svwhilelt_b32(i, length), &src[i]);\n        svst1_scatter_indexed_f32(dst, idx_vec, val_vec);\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n\n    // Gather operation\n    while (i < length) {\n        svuint32_t idx_vec = svld1_u32(svwhilelt_b32(i, length), &indices[i]);\n        svfloat32_t val_vec = sv_gather_indexed_f32(svundef_f32(), src, idx_vec);\n        svst1_f32(svwhilelt_b32(i, length), &dst[i], val_vec);\n        i += svcntw();\n    }\n\n    // Scatter operation\n    i = 0;\n    while (i < length) {\n        svuint32_t idx_vec = svld1_u32(svwhilelt_b32(i, length), &indices[i]);\n        svfloat32_t val_vec = svld1_f32(svwhilelt_b32(i, length), &src[i]);\n        svst1_scatter_indexed_f32(dst, idx_vec, val_vec);\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n\n    // Gather operation\n    while (i < length) {\n        svuint32_t idx_vec = svld1_u32(svwhilelt_b32(i, length), &indices[i]);\n        svfloat32_t val_vec = sv_gather_float32idx(svundef_f32(), src, idx_vec);\n        svst1_f32(svwhilelt_b32(i, length), &dst[i], val_vec);\n        i += svcntw();\n    }\n\n    // Scatter operation\n    i = 0;\n    while (i < length) {\n        svuint32_t idx_vec = svld1_u32(svwhilelt_b32(i, length), &indices[i]);\n        svfloat32_t val_vec = svld1_f32(svwhilelt_b32(i, length), &src[i]);\n        svst1_scatter_float32idx(svwhilelt_b32(i, length), dst, idx_vec, val_vec);\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n\n    // Gather operation\n    while (i < length) {\n        svuint32_t idx_vec = svld1_u32(svwhilelt_b32(i, length), &indices[i]);\n        svfloat32_t val_vec = sv_gather_indexed_f32(svundef_f32(), src, idx_vec);\n        svst1_f32(svwhilelt_b32(i, length), &dst[i], val_vec);\n        i += svcntw();\n    }\n\n    // Scatter operation\n    i = 0;\n    while (i < length) {\n        svuint32_t idx_vec = svld1_u32(svwhilelt_b32(i, length), &indices[i]);\n        svfloat32_t val_vec = svld1_f32(svwhilelt_b32(i, length), &src[i]);\n        svst1_scatter_indexed_f32(dst, idx_vec, val_vec);\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t length = end - start + 1;\n    uint64_t i = start;\n    uint64_t j = end;\n\n    while (i < j) {\n        svbool_t pg = svwhilelt_b16(i, j);\n        svint16_t vec_i = svld1_gather_index_hu(pg, arr, svindex_u16(svzerob(), 1, i));\n        svint16_t vec_j = svld1_gather_index_hu(pg, arr, svindex_u16(svzerob(), 1, j));\n\n        svst1_scatter_index_hu(pg, arr, svindex_u16(svzerob(), 1, i), vec_j);\n        svst1_scatter_index_hu(pg, arr, svindex_u16(svzerob(), 1, j), vec_i);\n\n        i += svcntw();\n        j -= svcntw();\n    }\n\n    // Handle any remaining elements that were not processed in the loop\n    while (i < j) {\n        int16_t temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n        i++;\n        j--;\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t len = end - start + 1;\n    uint64_t i = start;\n    uint64_t j = end;\n\n    while (i < j) {\n        svbool_t pg = svwhilelt_b16(i, j);\n        svint16_t vec_i = svld1_gather_index_hu(pg, arr, svindex_u16(svzerob_u16(), 1, i));\n        svint16_t vec_j = svld1_gather_index_hu(pg, arr, svindex_u16(svzerob_u16(), 1, j));\n\n        svst1_scatter_index_hu(pg, arr, svindex_u16(svzerob_u16(), 1, i), vec_j);\n        svst1_scatter_index_hu(pg, arr, svindex_u16(svzerob_u16(), 1, j), vec_i);\n\n        i += svcntw();\n        j -= svcntw();\n    }\n\n    // Handle any remaining elements that were not processed in the loop\n    while (i < j) {\n        int16_t temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n        i++;\n        j--;\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t len = end - start + 1;\n    uint64_t i = start;\n    uint64_t j = end;\n\n    while (i < j) {\n        svbool_t pg = svwhilelt_b16(i, j);\n        svint16_t vec_i = svld1_gather_index_hu(pg, arr, svindex_u16(svzerob(), 1, i));\n        svint16_t vec_j = svld1_gather_index_hu(pg, arr, svindex_u16(svzerob(), 1, j));\n\n        svst1_scatter_index_hu(pg, arr, svindex_u16(svzerob(), 1, i), vec_j);\n        svst1_scatter_index_hu(pg, arr, svindex_u16(svzerob(), 1, j), vec_i);\n\n        i += svcntw();\n        j -= svcntw();\n    }\n\n    // Handle any remaining elements that were not processed in the loop\n    while (i <= j) {\n        int16_t temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n        i++;\n        j--;\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t len = end - start + 1;\n    uint64_t i = 0;\n    svbool_t pg;\n\n    while (i < len) {\n        uint64_t vl = svmin(len - i, svcntw());\n        pg = svwhilelt_b16(i, vl);\n\n        svint16_t vec1 = svld1(pg, &arr[start + i]);\n        svint16_t vec2 = svld1(pg, &arr[end - i]);\n\n        svst1(pg, &arr[start + i], vec2);\n        svst1(pg, &arr[end - i], vec1);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t length = end - start + 1;\n    uint64_t i = start;\n    uint64_t j = end;\n\n    while (i < j) {\n        svbool_t pg = svwhilelt_b16(i, j);\n        svint16_t vec_i = svld1_gather_index_hu(pg, arr, svindex_u16(svzerob_u16(), 1, i));\n        svint16_t vec_j = svld1_gather_index_hu(pg, arr, svindex_u16(svzerob_u16(), 1, j));\n\n        svst1_scatter_index_hu(pg, arr, svindex_u16(svzerob_u16(), 1, i), vec_j);\n        svst1_scatter_index_hu(pg, arr, svindex_u16(svzerob_u16(), 1, j), vec_i);\n\n        i += svcntw();\n        j -= svcntw();\n    }\n\n    // Handle any remaining elements that were not processed in the loop\n    while (i <= j) {\n        int16_t temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n        i++;\n        j--;\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t total_elements = dim1 * dim2;\n    size_t start_idx = slice_idx * total_elements;\n    svuint8_t pg;\n\n    for (size_t i = 0; i < total_elements; i += svcntb()) {\n        pg = svwhilelt_b8(i, total_elements);\n        svuint8_t vec = svld1(pg, &tensor[start_idx + i]);\n        svst1(pg, &slice[i], vec);\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t total_elements = dim1 * dim2;\n    size_t offset = slice_idx * dim1 * dim2;\n    svuint8_t pg;\n\n    for (size_t i = 0; i < total_elements; i += svcntb()) {\n        pg = svwhilelt_b8(i, total_elements);\n        svuint8_t vec = svld1(pg, &tensor[offset + i]);\n        svst1(pg, &slice[i], vec);\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t total_elements = dim1 * dim2;\n    size_t start_offset = slice_idx * dim1 * dim2;\n\n    for (size_t i = 0; i < total_elements; ) {\n        svuint8_t vec;\n        size_t vl = svcntb();\n\n        if (i + vl > total_elements) {\n            vl = total_elements - i;\n        }\n\n        vec = svld1_b(svuload_pat(svptrue_b8(), &tensor[start_offset + i], svptrue_b8()));\n        svst1_b(slice + i, vec);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t total_elements = dim1 * dim2;\n    const uint8_t *start_ptr = tensor + slice_idx * total_elements;\n    size_t i = 0;\n\n    svbool_t pg;\n    svuint8_t vec;\n\n    do {\n        pg = svwhilelt_b8(i, total_elements);\n        vec = svld1_u8(pg, start_ptr + i);\n        svst1_u8(pg, slice + i, vec);\n        i += svcntb();\n    } while (svptest_any(svptrue_b8(), pg));\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t total_elements = dim1 * dim2;\n    const uint8_t *start_ptr = tensor + slice_idx * total_elements;\n\n    for (size_t i = 0; i < total_elements; ) {\n        svuint8_t vec = svld1_u8(svuloadl(svptrue_b8(), &start_ptr[i]));\n        svst1_u8(slice + i, vec);\n        i += svcntb();\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t bi = 0; bi < block_size && i + bi < rows; ++bi) {\n                for (size_t bj = 0; bj < block_size && j + bj < cols; ++bj) {\n                    size_t src_index = (i + bi) * cols + (j + bj);\n                    size_t dst_index = (j + bj) * rows + (i + bi);\n\n                    svint16_t vec = svld1_s16(src + src_index);\n                    svst1_s16(dst + dst_index, vec);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t bi = 0; bi < block_size && i + bi < rows; ++bi) {\n                for (size_t bj = 0; bj < block_size && j + bj < cols; ++bj) {\n                    size_t src_idx = (i + bi) * cols + (j + bj);\n                    size_t dst_idx = (j + bj) * rows + (i + bi);\n\n                    svint16_t vec = svld1_s16(src + src_idx);\n                    svst1_s16(dst + dst_idx, vec);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t bi = 0; bi < block_size && i + bi < rows; ++bi) {\n                for (size_t bj = 0; bj < block_size && j + bj < cols; ++bj) {\n                    size_t src_idx = (i + bi) * cols + (j + bj);\n                    size_t dst_idx = (j + bj) * rows + (i + bi);\n\n                    svint16_t vec = svld1_s16(src + src_idx);\n                    svst1_s16(dst + dst_idx, vec);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t bi = 0; bi < block_size && i + bi < rows; ++bi) {\n                for (size_t bj = 0; bj < block_size && j + bj < cols; ++bj) {\n                    size_t src_idx = (i + bi) * cols + (j + bj);\n                    size_t dst_idx = (j + bj) * rows + (i + bi);\n\n                    svint16_t vec = svld1_s16(src + src_idx);\n                    svst1_s16(dst + dst_idx, vec);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t bi = 0; bi < block_size && i + bi < rows; ++bi) {\n                for (size_t bj = 0; bj < block_size && j + bj < cols; ++bj) {\n                    size_t src_index = (i + bi) * cols + (j + bj);\n                    size_t dst_index = (j + bj) * rows + (i + bi);\n\n                    svint16_t vec = svld1_s16(src + src_index);\n                    svst1_s16(dst + dst_index, vec);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\n#include <arm_sve.h> \n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t i = 0;\n    svfloat32_t acc = svdup_f32(0.0f);\n\n    for (; i <= dim - svcntw(); i += svcntw()) {\n        svint32_t index = svindex_s32(i, dim * dim + dim + 1);\n        svfloat32_t values = svld1_gather_index_f32(array, index);\n        acc = svadd_f32_m(svundef_b(), acc, values, svptrue_b());\n    }\n\n    for (; i < dim; ++i) {\n        sum += array[i * (dim * dim + dim + 1)];\n    }\n\n    sum += svcvtd_lane_f32_f64(svptrue_b(), svaddv_f32(acc));\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\n#include <arm_sve.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t i = 0;\n    svfloat32_t acc = svdup_f32(0.0f);\n\n    for (; i <= dim - svcntw(); i += svcntw()) {\n        svint32_t idx = svindex_s32(i, dim * dim + dim + 1);\n        svfloat32_t vec = svld1_gather_index_f32(array, idx);\n        acc = svadd_f32_m(svundef_b(), acc, vec, svptrue_b());\n    }\n\n    for (; i < dim; ++i) {\n        sum += array[i * (dim * dim + dim + 1)];\n    }\n\n    sum += svaddv_f32(acc);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\n#include <arm_sve.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t i = 0;\n    svfloat32_t acc = svdup_f32(0.0f);\n\n    for (; i <= dim - svcntw(); i += svcntw()) {\n        svint32_t idx = svindex_s32(i, dim * dim + dim + 1);\n        svfloat32_t vec = svld1_gather_index_f32(array, idx);\n        acc = svadd_f32(acc, vec);\n    }\n\n    sum = svaddv_f32(acc);\n\n    for (; i < dim; ++i) {\n        sum += array[i * (dim * dim + dim + 1)];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\n#include <arm_sve.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t i = 0;\n    svfloat32_t acc = svdup_f32(0.0f);\n\n    for (; i <= dim - svcntw(); i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, dim);\n        svint32_t idx = svindex_s32(i, 1);\n        svint32_t diag_idx = svmul_s32(idx, svdup_s32(dim * dim + dim + 1));\n        svfloat32_t values = svld1_gather_index_f32(pg, array, diag_idx);\n        acc = svadd_m_f32(acc, pg, acc, values);\n    }\n\n    for (; i < dim; ++i) {\n        sum += array[i * dim * dim + i * dim + i];\n    }\n\n    sum += svaddv_f32(acc);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\n#include <arm_sve.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t i = 0;\n    svfloat32_t acc = svdup_f32(0.0f);\n\n    for (; i <= dim - svcntw(); i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, dim);\n        svint32_t idx = svindex_s32(i, 1);\n        svint32_t diag_idx = svmul_s32_x(pg, idx, svadd_s32_x(pg, idx, svadd_s32_x(pg, idx, idx)));\n        svfloat32_t values = svld1_gather_offset_f32(array, diag_idx);\n        acc = svadd_m_f32(acc, pg, acc, values);\n    }\n\n    sum = svaddv_f32(acc);\n\n    for (; i < dim; ++i) {\n        sum += array[i + i * dim + i * dim * dim];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t num_elements = rows * cols;\n    svbool_t pg;\n    svfloat64_t v_threshold = svdup_f64(threshold);\n    svfloat64_t v_scale = svdup_f64(scale);\n\n    for (size_t i = 0; i < num_elements; i += svcntd()) {\n        pg = svwhilelt_b64(i, num_elements);\n        svfloat64_t v_src = svld1(pg, &src[i]);\n        svfloat64_t v_scaled = svmul_f64_z(pg, v_src, v_scale);\n        svfloat64_t v_result = svsel_f64(pg, svcmpgt_f64(pg, v_src, v_threshold), v_scaled, v_src);\n        svst1(pg, &dst[i], v_result);\n    }\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t num_elements = rows * cols;\n    svbool_t pg;\n    svfloat64_t v_threshold = svdup_f64(threshold);\n    svfloat64_t v_scale = svdup_f64(scale);\n\n    for (size_t i = 0; i < num_elements; i += svcntd()) {\n        pg = svwhilelt_b64(i, num_elements);\n        svfloat64_t v_src = svld1(pg, &src[i]);\n        svfloat64_t v_scaled = svmul_f64_z(pg, v_src, v_scale);\n        svfloat64_t v_result = svsel_f64(pg, svcmpgt_f64(pg, v_src, v_threshold), v_scaled, v_src);\n        svst1(pg, &dst[i], v_result);\n    }\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t num_elements = rows * cols;\n    svbool_t pg;\n    svfloat64_t v_threshold = svdup_f64(threshold);\n    svfloat64_t v_scale = svdup_f64(scale);\n\n    for (size_t i = 0; i < num_elements; i += svcntd()) {\n        pg = svwhilelt_b64(i, num_elements);\n        svfloat64_t v_src = svld1(pg, &src[i]);\n        svfloat64_t v_scaled = svmul_f64_z(pg, v_src, v_scale);\n        svfloat64_t v_result = svsel_f64(pg, svcmpgt_f64(pg, v_src, v_threshold), v_scaled, v_src);\n        svst1(pg, &dst[i], v_result);\n    }\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t num_elements = rows * cols;\n    svbool_t pg;\n    svfloat64_t v_threshold = svdup_f64(threshold);\n    svfloat64_t v_scale = svdup_f64(scale);\n\n    for (size_t i = 0; i < num_elements; i += svcntd()) {\n        pg = svwhilelt_b64(i, num_elements);\n        svfloat64_t v_src = svld1(pg, &src[i]);\n        svfloat64_t v_gt = svcmpgt_f64(pg, v_src, v_threshold);\n        svfloat64_t v_scaled = svmul_f64_z(pg, v_gt, v_src, v_scale);\n        svfloat64_t v_result = svsel_f64(pg, v_scaled, v_src);\n        svst1(pg, &dst[i], v_result);\n    }\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t num_elements = rows * cols;\n    svbool_t pg;\n    svfloat64_t sv_threshold = svdup_f64(threshold);\n    svfloat64_t sv_scale = svdup_f64(scale);\n\n    for (size_t i = 0; i < num_elements; i += svcntd()) {\n        pg = svwhilelt_b64(i, num_elements);\n        svfloat64_t sv_src = svld1(pg, &src[i]);\n        svfloat64_t sv_gt = svcmpgt(sv_src, sv_threshold);\n        svfloat64_t sv_scaled = svmul_m(sv_gt, sv_src, sv_scale, sv_src);\n        svst1(pg, &dst[i], sv_scaled);\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t col = 0;\n    svbool_t pg = svptrue_b64();\n    svfloat64_t vec;\n\n    for (col = 0; col < cols; col++) {\n        for (size_t row = 0; row < rows; row += svcntd()) {\n            size_t idx = indices[row];\n            vec = svld1(pg, &src[idx * cols + col]);\n            svst1(pg, &dst[row * cols + col], vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t i;\n    svbool_t pg;\n    svfloat64_t vec;\n\n    for (i = 0; i < rows; ++i) {\n        size_t index = indices[i];\n        const double *row_src = &src[index * cols];\n        double *row_dst = &dst[i * cols];\n\n        for (size_t j = 0; j < cols; j += svcntd()) {\n            pg = svwhilelt_b64(j, cols);\n            vec = svld1(pg, &row_src[j]);\n            svst1(pg, &row_dst[j], vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t i;\n    svbool_t pg;\n    svfloat64_t vec;\n\n    for (i = 0; i < rows; ++i) {\n        size_t idx = indices[i];\n        size_t col = 0;\n        while (col < cols) {\n            size_t vl = svcntd();\n            if (col + vl > cols) {\n                vl = cols - col;\n            }\n            pg = svwhilelt_b64(col, cols);\n            vec = svld1(pg, &src[idx * cols + col]);\n            svst1(pg, &dst[i * cols + col], vec);\n            col += vl;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t col = 0;\n    svbool_t pg = svptrue_b64();\n    svfloat64_t vec;\n\n    for (col = 0; col < cols; col++) {\n        for (size_t row = 0; row < rows; row += svcntd()) {\n            size_t idx = indices[row];\n            vec = svld1(pg, &src[idx * cols + col]);\n            svst1(pg, &dst[row * cols + col], vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t col = 0;\n    svbool_t pg = svptrue_b64();\n    svfloat64_t vec;\n\n    for (col = 0; col < cols; col++) {\n        for (size_t row = 0; row < rows; row++) {\n            size_t idx = indices[row];\n            double *src_row = (double *)src + idx * cols;\n            vec = svld1(pg, &src_row[col]);\n            svst1(pg, &dst[row * cols + col], vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t vl = svcntd();\n    svint64_t sv_scalar = svdup_s64(scalar);\n\n    for (size_t i = 0; i < length; i += vl) {\n        svint64_t sv_src1 = svld1_s64(svundef_s64(), &src1[i], svptrue_b64());\n        svint64_t sv_src2 = svld1_s64(svundef_s64(), &src2[i], svptrue_b64());\n\n        svint64_t sv_sum = svadd_s64_z(svptrue_b64(), sv_src1, sv_src2);\n        svint64_t sv_result = svadd_s64_z(svptrue_b64(), sv_sum, sv_scalar);\n        svint64_t sv_final = svshr_n_s64_z(svptrue_b64(), sv_result, 1);\n\n        svst1_s64(svundef_s64(), &dst[i], sv_final, svptrue_b64());\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    svbool_t pg;\n    svint64_t vec_scalar = svdup_s64(scalar);\n    size_t vl;\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = svcntd();\n        if (i + vl > length) {\n            vl = length - i;\n        }\n        pg = svwhilelt_b64(i, length);\n\n        svint64_t vec1 = svld1(pg, &src1[i]);\n        svint64_t vec2 = svld1(pg, &src2[i]);\n\n        svint64_t sum = svadd_z(pg, vec1, vec2);\n        svint64_t result = svadd_z(pg, sum, vec_scalar);\n        svint64_t final_result = svlsr_z(pg, result, 1);\n\n        svst1(pg, &dst[i], final_result);\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    svbool_t pg;\n    svint64_t vec_scalar = svdup_s64(scalar);\n    size_t index = 0;\n\n    do {\n        size_t vl = svcntd();\n        if (index + vl > length) {\n            vl = length - index;\n        }\n        pg = svwhilelt_b64(index, length);\n\n        svint64_t vec1 = svld1(pg, &src1[index]);\n        svint64_t vec2 = svld1(pg, &src2[index]);\n\n        svint64_t sum = svadd_z(pg, vec1, vec2);\n        svint64_t result = svadd_z(pg, sum, vec_scalar);\n        svint64_t final_result = svlsr_z(pg, result, 1);\n\n        svst1(pg, &dst[index], final_result);\n\n        index += vl;\n    } while (index < length);\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t vl = svcntd();\n    svint64_t sv_scalar = svdup_s64(scalar);\n\n    for (size_t i = 0; i < length; i += vl) {\n        svint64_t sv_src1 = svld1_s64(svundef_s64(), &src1[i], svll1());\n        svint64_t sv_src2 = svld1_s64(svundef_s64(), &src2[i], svll1());\n\n        svint64_t sv_sum = svadd_s64_z(sv_ptrue_b64(), sv_src1, sv_src2);\n        svint64_t sv_result = svadd_s64_z(sv_ptrue_b64(), sv_sum, sv_scalar);\n        svint64_t sv_final = svshr_n_s64_z(sv_ptrue_b64(), sv_result, 1);\n\n        svst1_s64(&dst[i], sv_final, svll1());\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t vl = svcntd();\n    svint64_t sv_scalar = svdup_s64(scalar);\n\n    for (size_t i = 0; i < length; i += vl) {\n        svint64_t sv_src1 = svld1_s64(svslided_up_z(svptrue_b64(), svundef_s64(), src1 + i, length - i));\n        svint64_t sv_src2 = svld1_s64(svslided_up_z(svptrue_b64(), svundef_s64(), src2 + i, length - i));\n\n        svint64_t sv_sum = svadd_s64_z(svptrue_b64(), sv_src1, sv_src2);\n        svint64_t sv_result = svadd_s64_z(svptrue_b64(), sv_sum, sv_scalar);\n        svint64_t sv_final = svshr_n_s64_z(svptrue_b64(), sv_result, 1);\n\n        svst1_s64(svslided_up_z(svptrue_b64(), svundef_s64(), dst + i, length - i), sv_final);\n    }\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint vector_even_min_simd(const int *src, size_t length){\n    if (length == 0) {\n        return -1;\n    }\n\n    svbool_t pg = svptrue_b32();\n    svint32_t min_val = svdup_s32(INT_MAX);\n\n    for (size_t i = 0; i < length; i += svcntw()) {\n        size_t count = length - i > svcntw() ? svcntw() : length - i;\n        svbool_t idx_pg = svwhilelt_b32(0, count);\n        svint32_t vec = svld1_s32(svindex_s32(i, 1), src);\n        svint32_t even_vec = svsel_s32_z(svcmpeq_n_s32(idx_pg, svindex_s32(0, 1), 0), vec, svdup_s32(INT_MAX));\n        min_val = svmin_s32_m(idx_pg, min_val, even_vec);\n    }\n\n    int result = svminv_s32(pg, min_val);\n    return result == INT_MAX ? -1 : result;\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint vector_even_min_simd(const int *src, size_t length){\n    if (length == 0) {\n        return -1;\n    }\n\n    svbool_t pg = svptrue_b32();\n    svint32_t min_val = svdup_s32(INT_MAX);\n\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svint32_t vec = svld1_s32(pg, &src[i]);\n        svbool_t even_idx = svcmpeq_n_u32(pg, svindex_s32(svzeropg(), 0, 1), 0);\n        svint32_t even_vec = svsel_s32(even_idx, vec, svdup_s32(INT_MAX));\n        min_val = svmin_s32_m(pg, min_val, even_vec);\n    }\n\n    int result = svminv_s32_m(svptrue_b32(), min_val);\n    return result == INT_MAX ? -1 : result;\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint vector_even_min_simd(const int *src, size_t length){\n    if (length == 0) {\n        return -1;\n    }\n\n    svbool_t pg = svptrue_b32();\n    svint32_t min_val = svdup_s32(INT_MAX);\n\n    for (size_t i = 0; i < length; i += svcntw()) {\n        size_t count = length - i > svcntw() ? svcntw() : length - i;\n        svbool_t idx_pg = svwhilelt_b32(0, count);\n        svint32_t vec = svld1_s32(idx_pg, &src[i]);\n        svint32_t even_vec = svcompress_s32(svand_b32(idx_pg, sveven_b32(svindex_s32(0, 1))), vec);\n        min_val = svmin_s32_m(svand_b32(idx_pg, sveven_b32(svindex_s32(0, 1))), min_val, even_vec);\n    }\n\n    int result = INT_MAX;\n    svst1_s32(pg, &result, min_val);\n    return result == INT_MAX ? -1 : result;\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint vector_even_min_simd(const int *src, size_t length){\n    if (length == 0) {\n        return -1;\n    }\n\n    svbool_t pg = svptrue_b32();\n    svint32_t min_val = svdup_s32(INT_MAX);\n\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svint32_t vec = svld1_s32(pg, &src[i]);\n        svbool_t even_idx = svindex_s32(pg, 0, 1) % 2 == 0;\n        svint32_t even_vec = svsel_s32(even_idx, vec, svdup_s32(INT_MAX));\n        min_val = svmin_s32_m(pg, min_val, even_vec);\n    }\n\n    int result = svminv_s32_m(svptrue_b32(), min_val);\n    return result == INT_MAX ? -1 : result;\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint vector_even_min_simd(const int *src, size_t length){\n    if (length == 0) {\n        return -1;\n    }\n\n    svbool_t pg = svptrue_b32();\n    svint32_t min_val = svdup_s32(INT_MAX);\n\n    for (size_t i = 0; i < length; i += svcntw()) {\n        size_t cnt = length - i > svcntw() ? svcntw() : length - i;\n        svbool_t idx_pg = svwhilelt_b32(0, cnt);\n        svint32_t vec = svld1_s32(idx_pg, &src[i]);\n        svint32_t even_vec = svand_s32_z(pg, vec, svdup_s32(1));\n        svbool_t even_mask = sveor_b32_z(pg, idx_pg, svcmpeq_n_s32(pg, even_vec, 0));\n        min_val = svmin_s32_m(even_mask, min_val, vec);\n    }\n\n    int result = svminv_s32(min_val);\n    return result == INT_MAX ? -1 : result;\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    svint32_t vec_src, vec_arith_shift, vec_logic_shift;\n\n    do {\n        pg = svwhilelt_b32(i, length);\n        vec_src = svld1_s32(pg, &src[i]);\n\n        vec_arith_shift = svasr_n_s32(vec_src, shift);\n        vec_logic_shift = svreinterpret_s32_u32(svlshr_n_u32(svreinterpret_u32_s32(vec_src), shift));\n\n        svst1_s32(pg, &dst[i], svadd_s32_z(pg, vec_arith_shift, vec_logic_shift));\n\n        i += svcntw();\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n\n    while (svcntw() > 0 && i < length) {\n        size_t vl = svcntw();\n        if (i + vl > length) {\n            vl = length - i;\n            pg = svwhilelt_b32(0, vl);\n        } else {\n            pg = svptrue_b32();\n        }\n\n        svint32_t src_vec = svld1(pg, &src[i]);\n        svint32_t arith_shifted = svasr_n_s32_z(pg, src_vec, shift);\n        svuint32_t logic_shifted = svlsr_n_u32_z(pg, svreinterpret_u32_s32(src_vec), shift);\n        svint32_t result = svadd_z(pg, arith_shifted, svreinterpret_s32_u32(logic_shifted));\n\n        svst1(pg, &dst[i], result);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    svint32_t vec_src, vec_arith_shift, vec_logic_shift;\n\n    do {\n        pg = svwhilelt_b32(i, length);\n        vec_src = svld1_s32(pg, &src[i]);\n\n        vec_arith_shift = svasr_n_s32(vec_src, shift);\n        vec_logic_shift = svreinterpret_s32_u32(svlshr_n_u32(svreinterpret_u32_s32(vec_src), shift));\n\n        svst1_s32(pg, &dst[i], svadd_s32_z(pg, vec_arith_shift, vec_logic_shift));\n\n        i += svcntw();\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t vl = svcntw();\n    svint32_t sv_src, sv_arith_shift, sv_logic_shift, sv_result;\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = svmin(vl, length - i);\n        sv_src = svld1_s32(svundef_s32(), &src[i]);\n\n        sv_arith_shift = svshr_n_s32(sv_src, shift);\n        sv_logic_shift = svreinterpret_s32_u32(svlsr_n_u32(svreinterpret_u32_s32(sv_src), shift));\n\n        sv_result = svadd_s32(sv_arith_shift, sv_logic_shift);\n        svst1_s32(&dst[i], sv_result);\n    }\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    svint32_t vec_src, vec_arith_shift, vec_logic_shift;\n\n    do {\n        pg = svwhilelt_b32(i, length);\n        vec_src = svld1_s32(pg, &src[i]);\n\n        vec_arith_shift = svasr_n_s32(vec_src, shift);\n        vec_logic_shift = svreinterpret_s32_u32(svlsr_n_u32(svreinterpret_u32_s32(vec_src), shift));\n\n        svst1_s32(pg, &dst[i], svadd_s32_m(pg, vec_arith_shift, vec_logic_shift));\n\n        i += svcntw();\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    int64_t sum = 0;\n\n    svbool_t pg;\n    svint32_t vec;\n    svint64_t acc = svdup_s64(0);\n\n    for (size_t i = 0; i < total_elements; i += svcntw()) {\n        pg = svwhilelt_b32(i, total_elements);\n        vec = svld1_s32(pg, &matrix[i]);\n        acc = svaddl_s32(acc, vec);\n    }\n\n    sum = svaddv_s64(acc);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    int64_t sum = 0;\n\n    svbool_t pg;\n    svint32_t vec;\n    svint64_t acc = svdup_s64(0);\n\n    for (size_t i = 0; i < total_elements; i += svcntw()) {\n        pg = svwhilelt_b32(i, total_elements);\n        vec = svld1_s32(pg, &matrix[i]);\n        acc = svaddl_s32(acc, vec);\n    }\n\n    sum = svaddv_s64(acc);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    int64_t sum = 0;\n\n    svbool_t pg;\n    svint32_t vec;\n    svint64_t acc = svdup_s64(0);\n\n    for (size_t i = 0; i < total_elements; i += svcntw()) {\n        pg = svwhilelt_b32(i, total_elements);\n        vec = svld1_s32(pg, &matrix[i]);\n        acc = svaddl_s32(acc, vec);\n    }\n\n    sum = svaddv_s64(acc);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    int64_t sum = 0;\n\n    svbool_t pg;\n    svint32_t vec;\n    svint64_t acc = svdup_s64(0);\n\n    for (size_t i = 0; i < total_elements; i += svcntw()) {\n        pg = svwhilelt_b32(i, total_elements);\n        vec = svld1_s32(pg, &matrix[i]);\n        acc = svaddl_s32(acc, vec);\n    }\n\n    sum = svaddv_s64(acc);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    int64_t sum = 0;\n\n    svbool_t pg = svptrue_b32();\n    svint32_t sum_vec = svdup_s32(0);\n\n    for (size_t i = 0; i < total_elements; i += svcntw()) {\n        svint32_t vec = svld1_s32(pg, &matrix[i]);\n        sum_vec = svadd_s32_m(pg, sum_vec, vec);\n    }\n\n    sum = svaddv_s32(sum_vec);\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\n#include <arm_sve.h> \n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n\n    svbool_t pg = svptrue_b8();\n    svint8_t max_vec = svdup_s8(max_value);\n    svuint64_t index_vec = svindex_u64(0, 1);\n\n    for (size_t i = 0; i < length; i += svcntb()) {\n        size_t vl = svmin_zu(svptrue_b8(), svcntb(), length - i);\n        svint8_t vec = svld1_s8(pg, &src[i]);\n        svbool_t cmp = svcmpgt_s8(pg, vec, max_vec);\n\n        if (svptest_any(svptrue_b8(), cmp)) {\n            svint8_t new_max = svsel_s8(cmp, vec, max_vec);\n            svuint64_t new_indices = svsel_u64(cmp, index_vec, svdup_u64(max_index));\n            max_vec = new_max;\n            max_index = svlastb_u64(new_indices);\n        }\n        index_vec = svadd_u64_x(svptrue_b8(), index_vec, svdup_u64(vl));\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\n#include <arm_sve.h> \n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n\n    svbool_t pg = svptrue_b8();\n    svint8_t max_vec = svdup_s8(max_value);\n    svuint64_t index_vec = svindex_u64(0, 1);\n\n    for (size_t i = 0; i < length; i += svcntb()) {\n        size_t vl = svmin_z(pg, length - i);\n        svint8_t vec = svld1_s8(svwhilelt_b8(i + vl, length), &src[i]);\n        svbool_t cmp = svcmpgt_s8(pg, vec, max_vec);\n\n        if (svptest_any(cmp)) {\n            svuint64_t new_indices = svadd_u64_z(pg, index_vec, svdup_u64(i));\n            svuint64_t max_indices = svsel_u64(cmp, new_indices, svdup_u64(max_index));\n            svint8_t new_maxes = svsel_s8(cmp, vec, max_vec);\n\n            max_index = svlastb(max_indices);\n            max_value = svlastb(new_maxes);\n            max_vec = svdup_s8(max_value);\n        }\n\n        index_vec = svadd_u64_z(pg, index_vec, svdup_u64(svcntb()));\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\n#include <arm_sve.h> \n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    svbool_t pg = svptrue_b8();\n    svint8_t max_val = svld1_s8(pg, src);\n    svuint64_t max_idx = svindex_u64(0, 1);\n\n    size_t i = 0;\n    for (; i <= length - svcntb(); i += svcntb()) {\n        pg = svptrue_b8();\n        svint8_t vec = svld1_s8(pg, &src[i]);\n        svbool_t cmp = svcmpgt_s8(pg, vec, max_val);\n        max_val = svsel_s8(cmp, vec, max_val);\n        svuint64_t idx = svadd_u64_z(pg, svindex_u64(i, 1), svdup_u64(0));\n        max_idx = svsel_u64(cmp, idx, max_idx);\n    }\n\n    int8_t max_scalar = svmaxv_s8(max_val);\n    size_t result = svmaxv_u64(max_idx);\n\n    for (; i < length; ++i) {\n        if (src[i] > max_scalar) {\n            max_scalar = src[i];\n            result = i;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\n#include <arm_sve.h> \n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n\n    svbool_t pg = svptrue_b8();\n    svint8_t max_vec = svdup_s8(max_value);\n    svuint64_t index_vec = svindex_u64(0, 1);\n\n    for (size_t i = 0; i < length; i += svcntb()) {\n        size_t vl = svmin_z(pg, svcntb(), length - i);\n        svint8_t vec = svld1_s8(svwhilelt_b8(i + vl, length), &src[i]);\n        svbool_t cmp = svcmpgt_s8(pg, vec, max_vec);\n\n        if (svptest_any(cmp)) {\n            svint8_t new_max = svsel_s8(cmp, vec, max_vec);\n            svuint64_t new_indices = svsel_u64(cmp, index_vec, svdup_u64(max_index));\n            max_vec = new_max;\n            max_index = svlastb_u64(new_indices);\n            max_value = svlastb_s8(new_max);\n        }\n        index_vec = svadd_u64_x(svptrue_b64(), index_vec, svdup_u64(vl));\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\n#include <arm_sve.h> \n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n\n    svbool_t pg = svptrue_b8();\n    svint8_t max_vec = svdup_s8(max_value);\n    svuint64_t index_vec = svindex_u64(0, 1);\n\n    for (size_t i = 0; i < length; i += svcntb()) {\n        size_t vl = svmin_zu(svptrue_b8(), svcntb(), length - i);\n        svint8_t vec = svld1_s8(pg, &src[i]);\n        svbool_t cmp = svcmpgt_s8(pg, vec, max_vec);\n\n        if (svptest_any(svptrue_b8(), cmp)) {\n            max_vec = svsel_s8(cmp, vec, max_vec);\n            svuint64_t new_indices = svadd_u64_z(sveldup_u64(svptrue_b8(), i), index_vec);\n            svuint64_t selected_indices = svsel_u64(cmp, new_indices, index_vec);\n            max_index = svlastb_u64(selected_indices);\n        }\n\n        index_vec = svadd_u64_z(index_vec, svdup_u64(vl));\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    do {\n        pg = svwhilelt_b16(i, length);\n        svuint16_t indices = svindex_u16(i, 1);\n        svuint16_t mask_vec = svdup_u16(mask);\n        svuint16_t and_result = svand_u16_z(pg, indices, mask_vec);\n        svbool_t sel = svcmpne_n_u16(pg, and_result, 0);\n        svuint16_t src1_vec = svld1_u16(pg, &src1[i]);\n        svuint16_t src2_vec = svld1_u16(pg, &src2[i]);\n        svuint16_t result = svsel_u16(pg, sel, src1_vec, src2_vec);\n        svst1_u16(pg, &dst[i], result);\n        i += svcntw();\n    } while (svptest_any(svptrue_b16(), pg));\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    do {\n        pg = svwhilelt_b16(i, length);\n        svuint16_t indices = svindex_u16(svzeroneg16(), 1);\n        svuint16_t masked_indices = svand_u16_z(pg, indices, svdup_u16(mask));\n        svbool_t cond = svcmpne_n_u16(pg, masked_indices, 0);\n        svuint16_t values_src1 = svld1_u16(pg, &src1[i]);\n        svuint16_t values_src2 = svld1_u16(pg, &src2[i]);\n        svuint16_t blended_values = svsel_u16(cond, values_src1, values_src2);\n        svst1_u16(pg, &dst[i], blended_values);\n        i += svcntw();\n    } while (svptest_any(svptrue_b16(), pg));\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    do {\n        pg = svwhilelt_b16(i, length);\n        svuint16_t indices = svindex_u16(svzerob_u16(), 1);\n        svuint16_t masked_indices = svand_u16_z(pg, indices, svdup_u16(mask));\n        svbool_t cond = svcmpne_n_u16(pg, masked_indices, 0);\n        svuint16_t values_src1 = svld1_u16(pg, &src1[i]);\n        svuint16_t values_src2 = svld1_u16(pg, &src2[i]);\n        svuint16_t blended_values = svsel_u16(pg, cond, values_src1, values_src2);\n        svst1_u16(pg, &dst[i], blended_values);\n        i += svcntw();\n    } while (svptest_any(svptrue_b16(), pg));\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    do {\n        pg = svwhilelt_b16(i, length);\n        svuint16_t indices = svindex_u16(svzeroneg16(), 1);\n        svuint16_t masked_indices = svand_u16_z(pg, indices, svdup_u16(mask));\n        svbool_t cond = svcmpne_n_u16(pg, masked_indices, 0);\n        svuint16_t values_src1 = svld1_u16(pg, &src1[i]);\n        svuint16_t values_src2 = svld1_u16(pg, &src2[i]);\n        svuint16_t blended_values = svsel_u16(pg, cond, values_src1, values_src2);\n        svst1_u16(pg, &dst[i], blended_values);\n        i += svcntw();\n    } while (svptest_any(svptrue_b16(), pg));\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    do {\n        pg = svwhilelt_b16(i, length);\n        svuint16_t indices = svindex_u16(svzerob_u16(), 1);\n        svuint16_t masked_indices = svand_u16_z(pg, indices, svdup_u16(mask));\n        svbool_t cond = svcmpne_n_u16(pg, masked_indices, 0);\n        svuint16_t values_src1 = svld1_u16(pg, &src1[i]);\n        svuint16_t values_src2 = svld1_u16(pg, &src2[i]);\n        svuint16_t blended_values = svsel_u16(pg, cond, values_src1, values_src2);\n        svst1_u16(pg, &dst[i], blended_values);\n        i += svcntw();\n    } while (svptest_any(svptrue_b16(), pg));\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    svuint32_t vec_src, vec_dst;\n\n    do {\n        pg = svwhilelt_b32(i, length);\n        vec_src = svld1_u32(pg, &src[i]);\n        vec_dst = svcntb_u32_z(pg, vec_src);\n        svst1_u32(pg, &dst[i], vec_dst);\n        i += svcntb();\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    svuint32_t vec_src, vec_dst;\n\n    do {\n        pg = svwhilelt_b32(i, length);\n        vec_src = svld1_u32(pg, &src[i]);\n        vec_dst = svcnt_i32_z(pg, vec_src);\n        svst1_u32(pg, &dst[i], vec_dst);\n        i += svcntb();\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    svuint32_t vec_src, vec_dst;\n\n    do {\n        pg = svwhilelt_b32(i, length);\n        vec_src = svld1_u32(pg, &src[i]);\n        vec_dst = svcntb_u32_z(pg, vec_src);\n        svst1_u32(pg, &dst[i], vec_dst);\n        i += svcntb();\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    svuint32_t vec_src, vec_dst;\n\n    do {\n        size_t vl = svcntw();\n        if (i + vl > length) {\n            vl = length - i;\n        }\n        pg = svwhilelt_b32(i, length);\n        vec_src = svld1(pg, &src[i]);\n        vec_dst = svcntp_b_z(pg, svptrue_b32(), vec_src);\n        svst1(pg, &dst[i], vec_dst);\n        i += vl;\n    } while (i < length);\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    svuint32_t vec_src, vec_dst;\n\n    do {\n        pg = svwhilelt_b32(i, length);\n        vec_src = svld1_u32(pg, &src[i]);\n        vec_dst = svcnt_i32_z(pg, vec_src);\n        svst1_u32(pg, &dst[i], vec_dst);\n        i += svcntb();\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    svuint16_t vec1, vec2, result;\n\n    do {\n        pg = svwhilelt_b16(i, length);\n        vec1 = svld1_u16(pg, &src1[i]);\n        vec2 = svld1_u16(pg, &src2[i]);\n        result = svqadd_u16_m(pg, vec1, vec2, svdup_u16(0));\n        svst1_u16(pg, &dst[i], result);\n        i += svcntw();\n    } while (svptest_any(svptrue_b16(), pg));\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    svuint16_t vec1, vec2, result;\n\n    do {\n        pg = svwhilelt_b16(i, length);\n        vec1 = svld1_u16(pg, &src1[i]);\n        vec2 = svld1_u16(pg, &src2[i]);\n        result = svqadd_u16_z(pg, vec1, vec2);\n        svst1_u16(pg, &dst[i], result);\n        i += svcntw();\n    } while (svptest_any(svptrue_b16(), pg));\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    svuint16_t vec1, vec2, result;\n\n    do {\n        pg = svwhilelt_b16(i, length);\n        vec1 = svld1_u16(pg, &src1[i]);\n        vec2 = svld1_u16(pg, &src2[i]);\n        result = svqadd_u16_m(pg, vec1, vec2, svdup_u16(0));\n        svst1_u16(pg, &dst[i], result);\n        i += svcntw();\n    } while (svptest_any(svptrue_b16(), pg));\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    svuint16_t vec1, vec2, result;\n\n    do {\n        pg = svwhilelt_b16(i, length);\n        vec1 = svld1_u16(pg, &src1[i]);\n        vec2 = svld1_u16(pg, &src2[i]);\n        result = svqadd_u16_m(pg, vec1, vec2, svdup_u16(0));\n        svst1_u16(pg, &dst[i], result);\n        i += svcntw();\n    } while (svptest_any(svptrue_b16(), pg));\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    svuint16_t vec1, vec2, result;\n\n    do {\n        pg = svwhilelt_b16(i, length);\n        vec1 = svld1_u16(pg, &src1[i]);\n        vec2 = svld1_u16(pg, &src2[i]);\n        result = svqadd_u16_z(pg, vec1, vec2);\n        svst1_u16(pg, &dst[i], result);\n        i += svcntw();\n    } while (svptest_any(svptrue_b16(), pg));\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    svbool_t pg;\n    svfloat64_t va, vb, vc, vzero = svdup_f64(0.0);\n    svfloat64_t vlower = svdup_f64(-100.0);\n    svfloat64_t vupper = svdup_f64(100.0);\n\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            vc = vzero;\n            for (size_t k = 0; k < n; k += svcntd()) {\n                pg =svptrue_b64();\n                va = svld1(pg, &A[i * n + k]);\n                vb = svld1(pg, &B[j + k * p]);\n\n                svbool_t pa = svcmplt(pg, va, vupper) & svcmlt(pg, va, vlower);\n                svbool_t pb = svcmplt(pg, vb, vupper) & svcmlt(pg, vb, vlower);\n\n                svbool_t pangb = svand_b64(pa, pb);\n                va = svsel_f64(pangb, va, vzero);\n                vb = svsel_f64(pangb, vb, vzero);\n\n                vc = svmla_m(pg, vc, va, vb);\n            }\n            C[i * p + j] = svaddv_f64(vc);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    svbool_t pg;\n    svfloat64_t va, vb, vc, vzero = svdup_f64(0.0);\n    svfloat64_t vlower_bound = svdup_f64(-100.0);\n    svfloat64_t vupper_bound = svdup_f64(100.0);\n\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            vc = vzero;\n            for (size_t k = 0; k < n; k += svcntd()) {\n                pg = svwhilelt_b64(k, n);\n                va = svld1(pg, &A[i * n + k]);\n                vb = svld1(pg, &B[j + k * p]);\n\n                svbool_t in_range_a = svand_b64(svcmplt_f64(pg, va, vupper_bound), svcmpgt_f64(pg, va, vlower_bound));\n                svbool_t in_range_b = svand_b64(svcmplt_f64(pg, vb, vupper_bound), svcmpgt_f64(pg, vb, vlower_bound));\n                svbool_t in_range = svand_b64(in_range_a, in_range_b);\n\n                va = svsel_f64(in_range, va, vzero);\n                vb = svsel_f64(in_range, vb, vzero);\n\n                vc = svmla_m(pg, vc, va, vb);\n            }\n            C[i * p + j] = svaddv_f64(vc);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    svbool_t pg;\n    svfloat64_t va, vb, vc, vzero = svdup_f64(0.0);\n    svfloat64_t vlower = svdup_f64(-100.0);\n    svfloat64_t vupper = svdup_f64(100.0);\n\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            vc = vzero;\n            for (size_t k = 0; k < n; k += svcntd()) {\n                pg = svwhilelt_b64(k, n);\n                va = svld1(pg, &A[i * n + k]);\n                vb = svld1(pg, &B[j + k * p]);\n\n                svbool_t in_range_a = svand_b64(svcle_f64(pg, va, vupper), svcge_f64(pg, va, vlower));\n                svbool_t in_range_b = svand_b64(svcle_f64(pg, vb, vupper), svcge_f64(pg, vb, vlower));\n                svbool_t in_range = svand_b64(in_range_a, in_range_b);\n\n                va = svsel_f64(in_range, va, vzero);\n                vb = svsel_f64(in_range, vb, vzero);\n\n                vc = svmla_m(pg, vc, va, vb);\n            }\n            C[i * p + j] = svaddv_f64(vc);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    svbool_t pg;\n    svfloat64_t va, vb, vc, vzero = svdup_f64(0.0);\n    svfloat64_t vlower_bound = svdup_f64(-100.0);\n    svfloat64_t vupper_bound = svdup_f64(100.0);\n\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            vc = vzero;\n            for (size_t k = 0; k < n; k += svcntd()) {\n                pg =svptrue_b64();\n                va = svld1(pg, &A[i * n + k]);\n                vb = svld1(pg, &B[j + k * p]);\n\n                svbool_t pa = svcmplt(pg, va, vupper_bound);\n                svbool_t pb = svcmplt(pg, vb, vupper_bound);\n                svbool_t na = svcmpgt(pg, va, vlower_bound);\n                svbool_t nb = svcmpgt(pg, vb, vlower_bound);\n\n                svbool_t pab = svand_z(pg, pa, pb);\n                svbool_t nab = svand_z(pg, na, nb);\n                svbool_t cond = svand_z(pg, pab, nab);\n\n                va = svsel(cond, va, vzero);\n                vb = svsel(cond, vb, vzero);\n\n                vc = svmla_m(pg, vc, va, vb);\n            }\n            C[i * p + j] = svaddv_f64(vc);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    svbool_t pg;\n    svfloat64_t va, vb, vc, vzero = svdup_f64(0.0);\n    svfloat64_t vlower = svdup_f64(-100.0);\n    svfloat64_t vupper = svdup_f64(100.0);\n\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            vc = vzero;\n            for (size_t k = 0; k < n; k += svcntd()) {\n                pg = svwhilelt_b64(k, n);\n                va = svld1(pg, &A[i * n + k]);\n                vb = svld1(pg, &B[j + k * p]);\n\n                svbool_t in_range_a = svand_b64(svcmplt_f64(pg, va, vupper), svcmpgt_f64(pg, va, vlower));\n                svbool_t in_range_b = svand_b64(svcmplt_f64(pg, vb, vupper), svcmpgt_f64(pg, vb, vlower));\n                svbool_t in_range = svand_b64(in_range_a, in_range_b);\n\n                va = svsel_f64(in_range, va, vzero);\n                vb = svsel_f64(in_range, vb, vzero);\n\n                vc = svmla_m(pg, vc, va, vb);\n            }\n            C[i * p + j] = svaddv_f64(vc);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    svbool_t pg;\n    svint64_t vec_a, vec_b, vec_c;\n\n    for (; i <= total_elements - svcntd(); i += svcntd()) {\n        pg = svptrue_b64();\n        vec_a = svld1(pg, &A[i]);\n        vec_b = svld1(pg, &B[i]);\n        vec_c = svadd_z(pg, vec_a, vec_b);\n        svst1(pg, &C[i], vec_c);\n    }\n\n    for (; i < total_elements; i++) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    svbool_t pg;\n    svint64_t vec_a, vec_b, vec_c;\n\n    for (; i <= total_elements - svcntd(); i += svcntd()) {\n        pg = svptrue_b64();\n        vec_a = svld1(pg, &A[i]);\n        vec_b = svld1(pg, &B[i]);\n        vec_c = svadd_z(pg, vec_a, vec_b);\n        svst1(pg, &C[i], vec_c);\n    }\n\n    for (; i < total_elements; i++) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    svbool_t pg;\n    svint64_t vec_a, vec_b, vec_c;\n\n    while (svcntd(svptrue_b64()) + i <= total_elements) {\n        pg = svptrue_b64();\n        vec_a = svld1(pg, &A[i]);\n        vec_b = svld1(pg, &B[i]);\n        vec_c = svadd_z(pg, vec_a, vec_b);\n        svst1(pg, &C[i], vec_c);\n        i += svcntd(pg);\n    }\n\n    // Handle any remaining elements\n    if (i < total_elements) {\n        pg = svwhilelt_b64(i, total_elements);\n        vec_a = svld1(pg, &A[i]);\n        vec_b = svld1(pg, &B[i]);\n        vec_c = svadd_z(pg, vec_a, vec_b);\n        svst1(pg, &C[i], vec_c);\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    svbool_t pg;\n    svint64_t vec_a, vec_b, vec_c;\n\n    while (svcntd(svptrue_b64()) + i <= total_elements) {\n        pg = svptrue_b64();\n        vec_a = svld1(pg, &A[i]);\n        vec_b = svld1(pg, &B[i]);\n        vec_c = svadd_z(pg, vec_a, vec_b);\n        svst1(pg, &C[i], vec_c);\n        i += svcntd(pg);\n    }\n\n    // Handle any remaining elements\n    if (i < total_elements) {\n        pg = svwhilelt_b64(i, total_elements);\n        vec_a = svld1(pg, &A[i]);\n        vec_b = svld1(pg, &B[i]);\n        vec_c = svadd_z(pg, vec_a, vec_b);\n        svst1(pg, &C[i], vec_c);\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    svbool_t pg;\n    svint64_t vec_a, vec_b, vec_c;\n\n    for (; i <= total_elements - svcntd(); i += svcntd()) {\n        pg = svptrue_b64();\n        vec_a = svld1(pg, &A[i]);\n        vec_b = svld1(pg, &B[i]);\n        vec_c = svadd_z(pg, vec_a, vec_b);\n        svst1(pg, &C[i], vec_c);\n    }\n\n    for (; i < total_elements; i++) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n\n    do {\n        // Determine the number of elements to process in this iteration\n        size_t vl = svcntw();\n        if (i + vl > length) {\n            vl = length - i;\n        }\n\n        // Create a predicate for the current vector length\n        pg = svwhilelt_b32(i, length);\n\n        // Load vectors from src1 and src2\n        svfloat32_t vec1 = svld1(pg, &src1[i]);\n        svfloat32_t vec2 = svld1(pg, &src2[i]);\n\n        // Add the vectors\n        svfloat32_t sum = svadd_f32_m(pg, vec1, vec2);\n\n        // Round the sum to the nearest integer\n        svfloat32_t rounded_sum = svrintn_f32_m(pg, sum);\n\n        // Store the result in the destination array\n        svst1(pg, &dst[i], rounded_sum);\n\n        // Move to the next vector length\n        i += vl;\n    } while (i < length);\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    do {\n        pg = svwhilelt_bf32(i, length);\n        svfloat32_t vec1 = svld1(pg, &src1[i]);\n        svfloat32_t vec2 = svld1(pg, &src2[i]);\n        svfloat32_t sum = svadd_f32_m(pg, vec1, vec2);\n        svfloat32_t rounded_sum = svrintn_f32_m(pg, sum);\n        svst1(pg, &dst[i], rounded_sum);\n        i += svcntb() / sizeof(float);\n    } while (svptest_any(svptrue_b(), pg));\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    do {\n        pg = svwhilelt_bf32(i, length);\n        svfloat32_t vec1 = svld1(pg, &src1[i]);\n        svfloat32_t vec2 = svld1(pg, &src2[i]);\n        svfloat32_t sum = svadd_f32_m(pg, vec1, vec2);\n        svfloat32_t rounded_sum = svrintn_f32_m(pg, sum);\n        svst1(pg, &dst[i], rounded_sum);\n        i += svcntb() / sizeof(float);\n    } while (svptest_any(svptrue_b(), pg));\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n\n    do {\n        // Determine the number of elements to process in this iteration\n        size_t vl = svcntw();\n        if (i + vl > length) {\n            vl = length - i;\n        }\n\n        // Create a predicate for the current vector length\n        pg = svwhilelt_b32(i, length);\n\n        // Load vectors from src1 and src2\n        svfloat32_t vec1 = svld1(pg, &src1[i]);\n        svfloat32_t vec2 = svld1(pg, &src2[i]);\n\n        // Add the vectors\n        svfloat32_t sum = svadd_f32_m(pg, vec1, vec2);\n\n        // Round to the nearest integer\n        svfloat32_t rounded = svrintn_f32_m(pg, sum);\n\n        // Store the result in dst\n        svst1(pg, &dst[i], rounded);\n\n        // Move to the next vector length\n        i += vl;\n    } while (i < length);\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n\n    do {\n        // Determine the number of elements to process in this iteration\n        size_t vl = svcntw();\n        if (i + vl > length) {\n            vl = length - i;\n        }\n\n        // Create a predicate for the current vector length\n        pg = svwhilelt_b32(i, length);\n\n        // Load vectors from src1 and src2\n        svfloat32_t vec1 = svld1(pg, &src1[i]);\n        svfloat32_t vec2 = svld1(pg, &src2[i]);\n\n        // Add the vectors\n        svfloat32_t sum = svadd_f32_m(pg, vec1, vec2);\n\n        // Round to the nearest integer\n        svfloat32_t rounded_sum = svrintn_f32_m(pg, sum);\n\n        // Store the result in dst\n        svst1(pg, &dst[i], rounded_sum);\n\n        // Move to the next vector length\n        i += vl;\n    } while (i < length);\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length){\n    size_t i = 0;\n    svbool_t pg;\n    svfloat32_t v_src1, v_src2, v_diff, v_abs_diff, v_result, v_neg_one;\n    svfloat32_t v_zero = svdup_f32(0.0f);\n    svfloat32_t v_fifty = svdup_f32(50.0f);\n    svint32_t v_index, v_even_indices;\n\n    while (i < length) {\n        pg = svwhilelt_b32(i, length);\n        v_index = svindex_s32(0, 1);\n        v_even_indices = sveor_z(svptrue_b32(), svcmpeq_n_s32(pg, svand_s32_z(pg, v_index, svdup_s32(1)), 0));\n        v_src1 = svld1_f32(pg, &src1[i]);\n        v_src2 = svld1_f32(pg, &src2[i]);\n        v_diff = svsub_f32_z(pg, v_src1, v_src2);\n        v_abs_diff = svabs_f32_z(pg, v_diff);\n        v_result = svmul_f32_z(pg, v_src1, v_src2);\n        v_result = svwhere_f32(pg, svand_z(pg, svcmpge_f32(pg, v_abs_diff, v_zero), svcmple_f32(pg, v_abs_diff, v_fifty)), v_result, v_zero);\n        v_result = svwhere_f32(pg, v_even_indices, v_result, v_zero);\n        v_neg_one = svdup_f32(-1.0f);\n        v_result = svwhere_f32(pg, v_result, v_result, v_neg_one);\n        v_result = svmla_f32_z(pg, v_zero, v_result, svdup_f32(1.0f)); // Round up towards positive infinity\n        svst1_f32(pg, &dst[i], v_result);\n        i += svcntb() / sizeof(float);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length){\n    size_t i = 0;\n    svbool_t pg;\n    svfloat32_t v_src1, v_src2, v_diff, v_abs_diff, v_result, v_neg_one;\n    svfloat32_t v_zero = svdup_f32(0.0f);\n    svfloat32_t v_fifty = svdup_f32(50.0f);\n    svint32_t v_index, v_mod_index;\n\n    while (i < length) {\n        pg = svwhilelt_b32(i, length);\n        v_src1 = svld1(pg, &src1[i]);\n        v_src2 = svld1(pg, &src2[i]);\n        v_diff = svsub_f32_z(pg, v_src1, v_src2);\n        v_abs_diff = svabs_f32_z(pg, v_diff);\n        v_index = svindex_s32_z(svundef_s32(), i, 1);\n        v_mod_index = svand_s32_z(pg, v_index, svdup_s32(1));\n        v_neg_one = svdup_f32(-1.0f);\n\n        svbool_t cond1 = svcmplt_f32(pg, v_abs_diff, v_fifty);\n        svbool_t cond2 = svcmpeq_s32(pg, v_mod_index, svdup_s32(0));\n        svbool_t final_cond = svand_b_z(pg, cond1, cond2);\n\n        v_result = svmul_f32_z(final_cond, v_src1, v_src2);\n        v_result = svmla_f32_z(final_cond, v_result, v_zero, v_zero); // Round up towards positive infinity\n        v_result = svsel_f32(pg, v_result, v_neg_one);\n\n        svst1(pg, &dst[i], v_result);\n        i += svcntb() / sizeof(float);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    svfloat32_t v_src1, v_src2, v_diff, v_abs_diff, v_result, v_neg_one;\n    svfloat32_t v_zero = svdup_f32(0.0f);\n    svfloat32_t v_fifty = svdup_f32(50.0f);\n\n    while (i < length) {\n        pg = svwhilelt_b32(i, length);\n        v_src1 = svld1(pg, &src1[i]);\n        v_src2 = svld1(pg, &src2[i]);\n\n        v_diff = svsub_f32_m(pg, v_src1, v_src2);\n        v_abs_diff = svabs_f32_m(pg, v_diff);\n\n        svbool_t cond1 = svcmplt_f32(pg, v_abs_diff, v_fifty);\n        svbool_t cond2 = svcmpeq_n_u32(pg, svindex_u32(svzeropg(), 0, 1), i % 2 == 0 ? 0 : 1);\n        svbool_t combined_cond = svand_b_z(pg, cond1, cond2);\n\n        v_result = svmul_f32_m(combined_cond, v_src1, v_src2);\n        v_result = svmla_f32_m(combined_cond, v_result, v_zero, v_zero); // Round up towards positive infinity\n        v_neg_one = svdup_f32(-1.0f);\n        v_result = svsel_f32(combined_cond, v_result, v_neg_one);\n\n        svst1(pg, &dst[i], v_result);\n\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length){\n    size_t i = 0;\n    svbool_t pg;\n    svfloat32_t v_src1, v_src2, v_diff, v_abs_diff, v_result, v_neg_one;\n    svfloat32_t v_zero = svdup_f32(0.0f);\n    svfloat32_t v_fifty = svdup_f32(50.0f);\n    svint32_t v_index, v_zero_int = svdup_s32(0);\n    svint32_t v_two = svdup_s32(2);\n\n    while (i < length) {\n        pg = svwhilelt_b32(i, length);\n        v_src1 = svld1(pg, &src1[i]);\n        v_src2 = svld1(pg, &src2[i]);\n        v_diff = svsub_f32_z(pg, v_src1, v_src2);\n        v_abs_diff = svabs_f32_z(pg, v_diff);\n        v_result = svmul_f32_z(pg, v_src1, v_src2);\n        v_result = svmla_f32_z(pg, v_result, v_zero, v_zero); // Ensure correct rounding\n        v_result = svadd_f32_z(pg, v_result, v_zero); // Use add to trigger rounding\n        v_neg_one = svdup_f32(-1.0f);\n        v_index = svindex_s32(v_zero_int, 1);\n        v_index = svadd_s32_z(pg, v_index, svdup_s32(i));\n        svbool_t cond1 = svcmplt_f32(pg, v_abs_diff, v_fifty);\n        svbool_t cond2 = sveor_b_z(pg, svcmpeq_s32(pg, svand_s32_z(pg, v_index, v_two), v_zero_int), svpfalse_b());\n        svbool_t final_cond = svand_b_z(pg, cond1, cond2);\n        v_result = svsel_f32(final_cond, v_result, v_neg_one);\n        svst1(pg, &dst[i], v_result);\n        i += svcntb() / sizeof(float);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length){\n    size_t i = 0;\n    svbool_t pg;\n    svfloat32_t v_src1, v_src2, v_diff, v_abs_diff, v_result, v_neg_one, v_fifty, v_zero, v_index, v_mod_two;\n\n    v_neg_one = svdup_f32(-1.0f);\n    v_fifty = svdup_f32(50.0f);\n    v_zero = svdup_f32(0.0f);\n\n    do {\n        pg = svwhilelt_b32(i, length);\n        v_index = svindex_f32(v_zero, 1.0f);\n        v_mod_two = svcmpeq_f32(pg, svand_f32_z(pg, v_index, svdup_f32(1.0f)), v_zero);\n        v_src1 = svld1_f32(pg, &src1[i]);\n        v_src2 = svld1_f32(pg, &src2[i]);\n        v_diff = svsub_f32_z(pg, v_src1, v_src2);\n        v_abs_diff = svabs_f32_z(pg, v_diff);\n        pg = svand_b_z(pg, pg, svcmple_f32(pg, v_abs_diff, v_fifty));\n        pg = svand_b_z(pg, pg, v_mod_two);\n        v_result = svmul_f32_z(pg, v_src1, v_src2);\n        v_result = svmla_f32_z(pg, svsub_f32_z(pg, v_result, v_zero), svadd_f32_z(pg, v_result, v_zero), svdup_f32(1.0f));\n        v_result = svsel_f32(pg, v_result, v_neg_one);\n        svst1_f32(pg, &dst[i], v_result);\n        i += svcntw();\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t num_elements = m * n;\n    svbool_t pg;\n    svfloat64_t vec_scalar = svdup_f64(scalar);\n\n    for (size_t i = 0; i < num_elements; i += svcntd()) {\n        pg = svwhilelt_b64(i, num_elements);\n        svfloat64_t vec_mat = svld1_f64(pg, &mat[i]);\n        svfloat64_t vec_result = svmul_f64_z(pg, vec_mat, vec_scalar);\n        svst1_f64(pg, &dst[i], vec_result);\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t num_elements = m * n;\n    svbool_t pg;\n    svfloat64_t vec_scalar = svdup_f64(scalar);\n\n    for (size_t i = 0; i < num_elements; i += svcntd()) {\n        pg = svwhilelt_b64(i, num_elements);\n        svfloat64_t vec_mat = svld1_f64(pg, &mat[i]);\n        svfloat64_t vec_result = svmul_f64_z(pg, vec_mat, vec_scalar);\n        svst1_f64(pg, &dst[i], vec_result);\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t num_elements = m * n;\n    svbool_t pg;\n    svfloat64_t vec_scalar = svdup_f64(scalar);\n\n    for (size_t i = 0; i < num_elements; i += svcntd()) {\n        pg = svwhilelt_b64(i, num_elements);\n        svfloat64_t vec_mat = svld1_f64(pg, &mat[i]);\n        svfloat64_t vec_result = svmul_f64_z(pg, vec_mat, vec_scalar);\n        svst1_f64(pg, &dst[i], vec_result);\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t num_elements = m * n;\n    svbool_t pg;\n    svfloat64_t vec_scalar = svdup_f64(scalar);\n\n    for (size_t i = 0; i < num_elements; i += svcntd()) {\n        pg = svwhilelt_b64(i, num_elements);\n        svfloat64_t vec_mat = svld1_f64(pg, &mat[i]);\n        svfloat64_t vec_result = svmul_f64_z(pg, vec_mat, vec_scalar);\n        svst1_f64(pg, &dst[i], vec_result);\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t num_elements = m * n;\n    svbool_t pg;\n    svfloat64_t vec_scalar = svdup_f64(scalar);\n\n    for (size_t i = 0; i < num_elements; i += svcntd()) {\n        pg = svwhilelt_b64(i, num_elements);\n        svfloat64_t vec_mat = svld1_f64(pg, &mat[i]);\n        svfloat64_t vec_result = svmul_f64_z(pg, vec_mat, vec_scalar);\n        svst1_f64(pg, &dst[i], vec_result);\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float* row = mat + i * n;\n        svfloat32_t sum_of_squares = svdup_f32(0.0f);\n        size_t j = 0;\n\n        // Calculate the sum of squares for the row\n        for (; j <= n - svcntw(); j += svcntw()) {\n            svfloat32_t vec = svld1_f32(row + j);\n            sum_of_squares = svadd_f32_m(sum_of_squares, svtrue_b32(), svmul_f32(vec, vec));\n        }\n\n        // Handle any remaining elements\n        if (j < n) {\n            svbool_t pg = svwhilelt_b32(j, n);\n            svfloat32_t vec = svld1_f32(row + j);\n            sum_of_squares = svadd_f32_m(sum_of_squares, pg, svmul_f32(vec, vec));\n        }\n\n        // Calculate the L^2 norm (square root of sum of squares)\n        float l2_norm = sqrt(svaddv_f32(sum_of_squares));\n\n        // Normalize the row\n        j = 0;\n        for (; j <= n - svcntw(); j += svcntw()) {\n            svfloat32_t vec = svld1_f32(row + j);\n            svfloat32_t normalized_vec = svdiv_f32_z(svtrue_b32(), vec, svdup_f32(l2_norm));\n            svst1_f32(row + j, normalized_vec);\n        }\n\n        // Handle any remaining elements\n        if (j < n) {\n            svbool_t pg = svwhilelt_b32(j, n);\n            svfloat32_t vec = svld1_f32(row + j);\n            svfloat32_t normalized_vec = svdiv_f32_z(pg, vec, svdup_f32(l2_norm));\n            svst1_f32(row + j, normalized_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float* row = mat + i * n;\n        svfloat32_t sum_of_squares = svdup_f32(0.0f);\n        size_t j = 0;\n\n        // Calculate the sum of squares for the row\n        for (; j <= n - svcntw(); j += svcntw()) {\n            svfloat32_t vec = svld1_f32(row + j);\n            sum_of_squares = svadd_f32_m(sum_of_squares, svtrue_b32(), svmul_f32(vec, vec));\n        }\n\n        // Handle any remaining elements\n        if (j < n) {\n            svbool_t pg = svwhilelt_b32(j, n);\n            svfloat32_t vec = svld1_f32(row + j);\n            sum_of_squares = svadd_f32_m(sum_of_squares, pg, svmul_f32_z(pg, vec, vec));\n        }\n\n        // Calculate the L^2 norm (square root of sum of squares)\n        float l2_norm = sqrt(svaddv_f32(sum_of_squares));\n\n        // Normalize the row\n        j = 0;\n        for (; j <= n - svcntw(); j += svcntw()) {\n            svfloat32_t vec = svld1_f32(row + j);\n            svfloat32_t normalized_vec = svdiv_f32_x(svdup_f32(l2_norm), vec);\n            svst1_f32(row + j, normalized_vec);\n        }\n\n        // Handle any remaining elements\n        if (j < n) {\n            svbool_t pg = svwhilelt_b32(j, n);\n            svfloat32_t vec = svld1_f32(row + j);\n            svfloat32_t normalized_vec = svdiv_f32_x(svdup_f32(l2_norm), vec);\n            svst1_f32(row + j, svsel_f32(pg, normalized_vec, vec));\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float* row = mat + i * n;\n        svfloat32_t sum_of_squares = svdup_f32(0.0f);\n        size_t j = 0;\n\n        // Calculate the sum of squares for the row\n        for (; j <= n - svcntw(); j += svcntw()) {\n            svfloat32_t vec = svld1_f32(row + j);\n            sum_of_squares = svadd_f32_m(sum_of_squares, svtrue_b32(), svmul_f32(vec, vec));\n        }\n\n        // Handle any remaining elements\n        if (j < n) {\n            svbool_t pg = svwhilelt_b32(j, n);\n            svfloat32_t vec = svld1_f32(row + j);\n            sum_of_squares = svadd_f32_m(sum_of_squares, pg, svmul_f32(vec, vec));\n        }\n\n        // Calculate the L^2 norm (square root of sum of squares)\n        float l2_norm = sqrt(svaddv_f32(sum_of_squares));\n\n        // Normalize the row\n        j = 0;\n        for (; j <= n - svcntw(); j += svcntw()) {\n            svfloat32_t vec = svld1_f32(row + j);\n            svfloat32_t normalized_vec = svdiv_f32_z(svtrue_b32(), vec, svdup_f32(l2_norm));\n            svst1_f32(row + j, normalized_vec);\n        }\n\n        // Handle any remaining elements\n        if (j < n) {\n            svbool_t pg = svwhilelt_b32(j, n);\n            svfloat32_t vec = svld1_f32(row + j);\n            svfloat32_t normalized_vec = svdiv_f32_z(pg, vec, svdup_f32(l2_norm));\n            svst1_f32(row + j, normalized_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float* row = mat + i * n;\n        svfloat32_t sum_of_squares = svdup_f32(0.0f);\n        size_t j = 0;\n\n        // Calculate the sum of squares for the row\n        for (; j <= n - svcntw(); j += svcntw()) {\n            svfloat32_t vec = svld1_f32(row + j);\n            sum_of_squares = svadd_f32_m(sum_of_squares, svtrue_b32(), svmul_f32(vec, vec));\n        }\n\n        // Handle remaining elements\n        if (j < n) {\n            svbool_t pg = svwhilelt_b32(j, n);\n            svfloat32_t vec = svld1_f32(row + j);\n            sum_of_squares = svadd_f32_m(sum_of_squares, pg, svmul_f32(vec, vec));\n        }\n\n        // Sum up the partial sums from the vector\n        float sum_of_squares_scalar = svaddv_f32(sum_of_squares);\n        float norm = 1.0f / sqrtf(sum_of_squares_scalar);\n\n        // Normalize the row\n        j = 0;\n        for (; j <= n - svcntw(); j += svcntw()) {\n            svfloat32_t vec = svld1_f32(row + j);\n            svfloat32_t normalized_vec = svmul_f32_z(svtrue_b32(), vec, svdup_f32(norm));\n            svst1_f32(row + j, normalized_vec);\n        }\n\n        // Handle remaining elements\n        if (j < n) {\n            svbool_t pg = svwhilelt_b32(j, n);\n            svfloat32_t vec = svld1_f32(row + j);\n            svfloat32_t normalized_vec = svmul_f32_z(pg, vec, svdup_f32(norm));\n            svst1_f32(row + j, normalized_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float* row = mat + i * n;\n        svfloat32_t sum_of_squares = svdup_f32(0.0f);\n        size_t j = 0;\n\n        // Calculate the sum of squares for the row\n        for (; j <= n - svcntw(); j += svcntw()) {\n            svfloat32_t vec = svld1_f32(row + j);\n            sum_of_squares = svadd_f32_m(sum_of_squares, svtrue_b32(), svmul_f32(vec, vec));\n        }\n\n        // Handle remaining elements\n        if (j < n) {\n            svbool_t pg = svwhilelt_b32(j, n);\n            svfloat32_t vec = svld1_f32(row + j);\n            sum_of_squares = svadd_f32_m(sum_of_squares, pg, svmul_f32(vec, vec));\n        }\n\n        // Sum up the partial sums from the vector\n        float sum_of_squares_scalar = 0.0f;\n        for (size_t k = 0; k < svcntw(); ++k) {\n            sum_of_squares_scalar += svget2_f32(sum_of_squares, k);\n        }\n\n        float norm = 1.0f / sqrtf(sum_of_squares_scalar);\n\n        // Normalize the row\n        j = 0;\n        for (; j <= n - svcntw(); j += svcntw()) {\n            svfloat32_t vec = svld1_f32(row + j);\n            svfloat32_t normalized_vec = svmul_f32_z(svundef_f32(), svtrue_b32(), vec, svdup_f32(norm));\n            svst1_f32(row + j, normalized_vec);\n        }\n\n        // Handle remaining elements\n        if (j < n) {\n            svbool_t pg = svwhilelt_b32(j, n);\n            svfloat32_t vec = svld1_f32(row + j);\n            svfloat32_t normalized_vec = svmul_f32_z(svundef_f32(), pg, vec, svdup_f32(norm));\n            svst1_f32(row + j, normalized_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            size_t k = 0;\n            svbool_t pg = svptrue_b64();\n            svfloat64_t sum_vec = svdup_f64(0.0);\n\n            for (; k <= n - svcntb() * 8; k += svcntb() * 8) {\n                svfloat64_t vec1 = svld1_f64(pg, &mat1[i * n + k]);\n                svfloat64_t vec2 = svld1_f64(pg, &mat2[j + k * p]);\n                sum_vec = svmla_f64_m(pg, sum_vec, vec1, vec2);\n            }\n\n            sum = svaddv_f64(pg, sum_vec);\n\n            for (; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[j + k * p];\n            }\n\n            dst[i * p + j] = rint(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```c\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            size_t k = 0;\n            svbool_t pg = svptrue_b64();\n            svfloat64_t vec_sum = svdup_f64(0.0);\n\n            for (; k <= n - svcntb() * 8; k += svcntb() * 8) {\n                svfloat64_t vec_mat1 = svld1_f64(pg, &mat1[i * n + k]);\n                svfloat64_t vec_mat2 = svld1_f64(pg, &mat2[j + k * p]);\n                vec_sum = svmla_f64_z(pg, vec_sum, vec_mat1, vec_mat2);\n            }\n\n            sum = svaddv_f64(vec_sum);\n\n            for (; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[j + k * p];\n            }\n\n            dst[i * p + j] = rint(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            size_t k = 0;\n            svbool_t pg = svptrue_b64();\n            svfloat64_t vec_sum = svdup_f64(0.0);\n\n            for (; k <= n - svcntd(); k += svcntd()) {\n                svfloat64_t vec_mat1 = svld1(pg, &mat1[i * n + k]);\n                svfloat64_t vec_mat2 = svld1(pg, &mat2[j + k * p]);\n                vec_sum = svmla_f64_z(pg, vec_sum, vec_mat1, vec_mat2);\n            }\n\n            sum = svaddv_f64(vec_sum);\n\n            for (; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[j + k * p];\n            }\n\n            dst[i * p + j] = rint(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            size_t k = 0;\n            svbool_t pg = svptrue_b64();\n            svfloat64_t vec_sum = svdup_f64(0.0);\n\n            for (; k <= n - svcntb() * 8; k += svcntb() * 8) {\n                svfloat64_t vec_mat1 = svld1_f64(pg, &mat1[i * n + k]);\n                svfloat64_t vec_mat2 = svld1_f64(pg, &mat2[j + k * p]);\n                vec_sum = svmla_f64_z(pg, vec_sum, vec_mat1, vec_mat2);\n            }\n\n            sum = svaddv_f64(vec_sum);\n\n            for (; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[j + k * p];\n            }\n\n            dst[i * p + j] = rint(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```c\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            size_t k = 0;\n            svbool_t pg = svptrue_b64();\n            svfloat64_t vec_sum = svdup_f64(0.0);\n\n            for (; k <= n - svcntd(); k += svcntd()) {\n                svfloat64_t vec_mat1 = svld1(pg, &mat1[i * n + k]);\n                svfloat64_t vec_mat2 = svld1(pg, &mat2[j + k * p]);\n                vec_sum = svmla_m(pg, vec_sum, vec_mat1, vec_mat2);\n            }\n\n            sum = svaddv_f64(vec_sum);\n\n            for (; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[j + k * p];\n            }\n\n            dst[i * p + j] = rint(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t i, j;\n    svfloat32_t quarter = svdup_f32(0.25f);\n    svfloat32_t half = svdup_f32(0.5f);\n\n    for (j = 0; j < cols; j++) {\n        for (i = 0; i < rows; i += svcntw()) {\n            svfloat32_t vec = svld1_f32(src + i * cols + j);\n            svfloat32_t rounded_vec = svround_f32_x(vec);\n            svfloat32_t remainder = svsub_f32_x(vec, rounded_vec);\n            svbool_t cond = svabs_f32_ge(remainder, half);\n            rounded_vec = svadd_f32_m(cond, rounded_vec, svcmpgt_f32(remainder, svdup_f32(0.0f)) ? quarter : svmul_f32(quarter, svdup_f32(-1.0f)));\n            svst1_f32(dst + j * rows + i, rounded_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t i, j;\n    svfloat32_t quarter = svdup_f32(0.25f);\n\n    for (j = 0; j < cols; j++) {\n        for (i = 0; i < rows; i += svcntw()) {\n            svfloat32_t vec = svld1_f32(src + i * cols + j);\n            svfloat32_t rounded_vec = svround_f32_x(vec);\n            svfloat32_t quarter_rounded_vec = svmul_f32_z(svptrue_b32(), rounded_vec, quarter);\n            svfloat32_t final_vec = svmul_f32_z(svptrue_b32(), quarter_rounded_vec, svdup_f32(4.0f));\n            svst1_f32(dst + j * rows + i, final_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t col = 0;\n    svbool_t pg;\n\n    while (col < cols) {\n        size_t row = 0;\n        float* dst_ptr = dst + col * rows;\n\n        while (row < rows) {\n            pg = svwhilelt_bf32(row, rows);\n            svfloat32_t vec = svld1(pg, src + row * cols + col);\n            svfloat32_t rounded_vec = svround_n_f32_z(pg, vec, -2); // Round to nearest quarter\n            svst1(pg, dst_ptr, rounded_vec);\n            dst_ptr += svcntb() / sizeof(float);\n            row += svcntb() / sizeof(float);\n        }\n        col++;\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t i, j;\n    svfloat32_t quarter = svdup_f32(0.25f);\n\n    for (j = 0; j < cols; j++) {\n        for (i = 0; i < rows; i += svcntw()) {\n            svfloat32_t vec = svld1_f32(src + i * cols + j);\n            svfloat32_t rounded_vec = svround_f32_x(vec);\n            svfloat32_t quarter_rounded_vec = svadd_f32_x(svsub_f32_x(rounded_vec, svmul_f32_x(rounded_vec, quarter)), svmul_f32_x(svrint_f32_x(svmul_f32_x(rounded_vec, quarter)), quarter));\n            svst1_f32(dst + j * rows + i, quarter_rounded_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t i, j;\n    svfloat32_t quarter = svdup_f32(0.25f);\n\n    for (j = 0; j < cols; j++) {\n        for (i = 0; i < rows; i += svcntw()) {\n            svfloat32_t vec = svld1_f32(src + i * cols + j);\n            svfloat32_t rounded_vec = svround_f32_x(vec);\n            svfloat32_t quarter_rounded_vec = svmul_f32_z(svptrue_b32(), rounded_vec, quarter);\n            svfloat32_t final_vec = svmul_f32_z(svptrue_b32(), quarter_rounded_vec, svdup_f32(4.0f));\n            svst1_f32(dst + j * rows + i, final_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    svbool_t pg;\n    svfloat32_t vec1, vec2, result;\n\n    for (; i <= total_elements - svcntw(); i += svcntw()) {\n        pg = svptrue_b32();\n        vec1 = svld1(pg, &tensor1[i]);\n        vec2 = svld1(pg, &tensor2[i]);\n        result = svsub_z(pg, vec1, vec2);\n        result = svrintz_x(pg, result);\n        svst1(pg, &dst[i], result);\n    }\n\n    // Handle any remaining elements\n    if (i < total_elements) {\n        pg = svwhilelt_b32(i, total_elements);\n        vec1 = svld1(pg, &tensor1[i]);\n        vec2 = svld1(pg, &tensor2[i]);\n        result = svsub_z(pg, vec1, vec2);\n        result = svrintz_x(pg, result);\n        svst1(pg, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    svbool_t pg;\n    svfloat32_t vec1, vec2, vec_result;\n\n    while (svcntb(pg = svwhilelt_b32(i, total_elements)) > 0) {\n        vec1 = svld1/pg_f32(pg, &tensor1[i]);\n        vec2 = svld1/pg_f32(pg, &tensor2[i]);\n        vec_result = svsub_z_f32(pg, vec1, vec2);\n        vec_result = svrintz_x_f32_z(pg, vec_result);\n        svst1/pg_f32(pg, &dst[i], vec_result);\n        i += svcntb(pg);\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    svbool_t pg;\n    svfloat32_t vec1, vec2, result;\n\n    for (; i <= total_elements - svcntw(); i += svcntw()) {\n        pg = svptrue_b32();\n        vec1 = svld1(pg, &tensor1[i]);\n        vec2 = svld1(pg, &tensor2[i]);\n        result = svsub_z(pg, vec1, vec2);\n        result = svrintz_x(pg, result);\n        svst1(pg, &dst[i], result);\n    }\n\n    // Handle any remaining elements\n    if (i < total_elements) {\n        pg = svwhilelt_b32(i, total_elements);\n        vec1 = svld1(pg, &tensor1[i]);\n        vec2 = svld1(pg, &tensor2[i]);\n        result = svsub_z(pg, vec1, vec2);\n        result = svrintz_x(pg, result);\n        svst1(pg, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```c\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    svbool_t pg;\n    svfloat32_t vec1, vec2, vec_result;\n\n    for (; i <= total_elements - svcntw(); i += svcntw()) {\n        pg = svptrue_b32();\n        vec1 = svld1(pg, &tensor1[i]);\n        vec2 = svld1(pg, &tensor2[i]);\n        vec_result = svsub_z(pg, vec1, vec2);\n        vec_result = svrintz_x(pg, vec_result);\n        svst1(pg, &dst[i], vec_result);\n    }\n\n    // Handle any remaining elements\n    if (i < total_elements) {\n        pg = svwhilelt_b32(i, total_elements);\n        vec1 = svld1(pg, &tensor1[i]);\n        vec2 = svld1(pg, &tensor2[i]);\n        vec_result = svsub_z(pg, vec1, vec2);\n        vec_result = svrintz_x(pg, vec_result);\n        svst1(pg, &dst[i], vec_result);\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    svbool_t pg;\n    svfloat32_t vec1, vec2, vec_result;\n\n    for (; i <= total_elements - svcntw(); i += svcntw()) {\n        pg = svptrue_b32();\n        vec1 = svld1(pg, &tensor1[i]);\n        vec2 = svld1(pg, &tensor2[i]);\n        vec_result = svsub_z(pg, vec1, vec2);\n        vec_result = svrintz_x(pg, vec_result);\n        svst1(pg, &dst[i], vec_result);\n    }\n\n    // Handle any remaining elements\n    if (i < total_elements) {\n        pg = svwhilelt_b32(i, total_elements);\n        vec1 = svld1(pg, &tensor1[i]);\n        vec2 = svld1(pg, &tensor2[i]);\n        vec_result = svsub_z(pg, vec1, vec2);\n        vec_result = svrintz_x(pg, vec_result);\n        svst1(pg, &dst[i], vec_result);\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t num_elements = m * n;\n    size_t i = 0;\n\n    svbool_t pg;\n    svfloat64_t vec1, vec2, result;\n\n    for (; i <= num_elements - svcntd(); i += svcntd()) {\n        pg = svptrue_b64();\n        vec1 = svld1(pg, &mat1[i]);\n        vec2 = svld1(pg, &mat2[i]);\n        result = svmul(pg, vec1, vec2);\n        svst1(pg, &dst[i], result);\n    }\n\n    // Handle any remaining elements\n    if (i < num_elements) {\n        pg = svwhilelt_b64(i, num_elements);\n        vec1 = svld1(pg, &mat1[i]);\n        vec2 = svld1(pg, &mat2[i]);\n        result = svmul(pg, vec1, vec2);\n        svst1(pg, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t num_elements = m * n;\n    size_t i = 0;\n\n    svbool_t pg;\n    svfloat64_t vec1, vec2, vec_result;\n\n    for (; i <= num_elements - svcntd(); i += svcntd()) {\n        pg = svptrue_b64();\n        vec1 = svld1(pg, &mat1[i]);\n        vec2 = svld1(pg, &mat2[i]);\n        vec_result = svmul_x(pg, vec1, vec2);\n        svst1(pg, &dst[i], vec_result);\n    }\n\n    // Handle any remaining elements\n    if (i < num_elements) {\n        pg = svwhilelt_b64(i, num_elements);\n        vec1 = svld1(pg, &mat1[i]);\n        vec2 = svld1(pg, &mat2[i]);\n        vec_result = svmul_x(pg, vec1, vec2);\n        svst1(pg, &dst[i], vec_result);\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t num_elements = m * n;\n    size_t i = 0;\n\n    svbool_t pg;\n    svfloat64_t vec1, vec2, vec_result;\n\n    for (; i <= num_elements - svcntd(); i += svcntd()) {\n        pg = svptrue_b64();\n        vec1 = svld1(pg, &mat1[i]);\n        vec2 = svld1(pg, &mat2[i]);\n        vec_result = svmul_f64_z(pg, vec1, vec2);\n        svst1(pg, &dst[i], vec_result);\n    }\n\n    // Handle any remaining elements\n    if (i < num_elements) {\n        pg = svwhilelt_b64(i, num_elements);\n        vec1 = svld1(pg, &mat1[i]);\n        vec2 = svld1(pg, &mat2[i]);\n        vec_result = svmul_f64_z(pg, vec1, vec2);\n        svst1(pg, &dst[i], vec_result);\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t num_elements = m * n;\n    size_t i = 0;\n\n    svbool_t pg;\n    svfloat64_t vec1, vec2, result;\n\n    for (; i <= num_elements - svcntd(); i += svcntd()) {\n        pg = svptrue_b64();\n        vec1 = svld1(pg, &mat1[i]);\n        vec2 = svld1(pg, &mat2[i]);\n        result = svmul_m(pg, vec1, vec2);\n        svst1(pg, &dst[i], result);\n    }\n\n    // Handle any remaining elements\n    if (i < num_elements) {\n        pg = svwhilelt_b64(i, num_elements);\n        vec1 = svld1(pg, &mat1[i]);\n        vec2 = svld1(pg, &mat2[i]);\n        result = svmul_m(pg, vec1, vec2);\n        svst1(pg, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t num_elements = m * n;\n    size_t i = 0;\n\n    svbool_t pg;\n    svfloat64_t vec1, vec2, result;\n\n    for (; i <= num_elements - svcntd(); i += svcntd()) {\n        pg = svptrue_b64();\n        vec1 = svld1(pg, &mat1[i]);\n        vec2 = svld1(pg, &mat2[i]);\n        result = svmul_x(pg, vec1, vec2);\n        svst1(pg, &dst[i], result);\n    }\n\n    // Handle any remaining elements\n    if (i < num_elements) {\n        pg = svwhilelt_b64(i, num_elements);\n        vec1 = svld1(pg, &mat1[i]);\n        vec2 = svld1(pg, &mat2[i]);\n        result = svmul_x(pg, vec1, vec2);\n        svst1(pg, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    size_t i, j;\n    svfloat32_t sum_vec = svdup_f32(0.0f);\n    svbool_t pg = svptrue_b32();\n\n    for (i = 0; i < m; ++i) {\n        sum_vec = svdup_f32(0.0f);\n        for (j = 0; j < n; j += svcntw()) {\n            svfloat32_t mat_vec = svld1_f32(pg, &mat[i * n + j]);\n            svfloat32_t vec_vec = svld1_f32(pg, &vec[j]);\n            svfloat32_t prod_vec = svmul_f32_z(pg, mat_vec, vec_vec);\n            sum_vec = svadd_f32_m(pg, sum_vec, prod_vec);\n        }\n        // Horizontal sum reduction\n        float sum = 0.0f;\n        svfloat32_t acc = svdup_f32(0.0f);\n        for (svbool_t pg_reduce = svptrue_b32(); !svallfalse_b32(pg_reduce); ) {\n            svfloat32_t tmp = svadd_f32_x(pg_reduce, acc, sum_vec);\n            svbool_t pg_hsum = svhalve_b32(pg_reduce);\n            acc = svadd_f32_x(pg_hsum, tmp, svreinterpret_f32(svrevhalve_u32_z(pg_hsum, svreinterpret_u32(tmp))));\n            pg_reduce = pg_hsum;\n        }\n        sum = svgetlane_f32(acc, 0);\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    size_t i, j;\n    svfloat32_t sum_vec = svdup_f32(0.0f);\n    svbool_t pg = svptrue_b32();\n\n    for (i = 0; i < m; ++i) {\n        sum_vec = svdup_f32(0.0f);\n        for (j = 0; j < n; j += svcntw()) {\n            svfloat32_t mat_vec = svld1_f32(pg, &mat[i * n + j]);\n            svfloat32_t vec_vec = svld1_f32(pg, &vec[j]);\n            svfloat32_t prod_vec = svmul_f32_z(pg, mat_vec, vec_vec);\n            sum_vec = svadd_f32_m(pg, sum_vec, prod_vec);\n        }\n        float sum[svleng(svpgather_b32(svtrue_b32()))];\n        svst1_f32(pg, sum, sum_vec);\n        dst[i] = 0.0f;\n        for (size_t k = 0; k < svleng(svpgather_b32(svtrue_b32())); ++k) {\n            dst[i] += sum[k];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    size_t i, j;\n    svfloat32_t sum_vec = svdup_f32(0.0f);\n    svbool_t pg = svptrue_b32();\n\n    for (i = 0; i < m; ++i) {\n        sum_vec = svdup_f32(0.0f);\n        for (j = 0; j < n; j += svcntw()) {\n            svfloat32_t mat_vec = svld1_f32(pg, &mat[i * n + j]);\n            svfloat32_t vec_vec = svld1_f32(pg, &vec[j]);\n            svfloat32_t prod_vec = svmul_f32_z(pg, mat_vec, vec_vec);\n            sum_vec = svadd_f32_m(pg, sum_vec, prod_vec);\n        }\n        // Horizontal sum reduction\n        float sum = 0.0f;\n        svfloat32_t acc = svdup_f32(0.0f);\n        for (svbool_t pg_reduce = svptrue_b32(); !svallfalse_b32(pg_reduce); ) {\n            svfloat32_t tmp = svadd_f32_x(pg_reduce, acc, sum_vec);\n            svbool_t pg_hsum = svhadd_pat_b();\n            acc = svhadd_f32_m(pg_hsum, tmp, tmp);\n            pg_reduce = svhalve_b32(pg_reduce);\n        }\n        sum = svgetlane_f32(acc, 0);\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    size_t i, j;\n    svfloat32_t sum_vec = svdup_f32(0.0f);\n    svbool_t pg = svptrue_b32();\n\n    for (i = 0; i < m; ++i) {\n        sum_vec = svdup_f32(0.0f);\n        for (j = 0; j < n; j += svcntw()) {\n            svfloat32_t mat_vec = svld1_f32(pg, &mat[i * n + j]);\n            svfloat32_t vec_vec = svld1_f32(pg, &vec[j]);\n            svfloat32_t prod_vec = svmul_f32_z(pg, mat_vec, vec_vec);\n            sum_vec = svadd_f32_m(pg, sum_vec, prod_vec);\n        }\n        // Horizontal sum reduction\n        float sum = 0.0f;\n        svfloat32_t acc = svdup_f32(0.0f);\n        for (svbool_t pg_reduce = svptrue_b32(); !svallfalse_b32(pg_reduce); ) {\n            svfloat32_t tmp = svaddv_f32_m(svptrue_b32(), acc, sum_vec, pg_reduce);\n            pg_reduce = svpfalse_b32();\n            acc = tmp;\n        }\n        sum = svaddv_f32(svptrue_b32(), acc);\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    size_t i, j;\n    svfloat32_t sum_vec = svdup_f32(0.0f);\n    svbool_t pg = svptrue_b32();\n\n    for (i = 0; i < m; ++i) {\n        sum_vec = svdup_f32(0.0f);\n        for (j = 0; j < n; j += svcntw()) {\n            svfloat32_t mat_vec = svld1_f32(pg, &mat[i * n + j]);\n            svfloat32_t vec_vec = svld1_f32(pg, &vec[j]);\n            svfloat32_t prod_vec = svmul_f32_z(pg, mat_vec, vec_vec);\n            sum_vec = svadd_f32_m(pg, sum_vec, prod_vec);\n        }\n        float sum[svleng(svpgather_b32(svtrue_b32()))];\n        svst1_f32(pg, sum, sum_vec);\n        dst[i] = sum[0];\n        for (size_t k = 1; k < svleng(svpgather_b32(svtrue_b32())); ++k) {\n            dst[i] += sum[k];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```c\n#include <arm_sve.h> \n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    svbool_t pg;\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    double sum = 0.0;\n    size_t i = 0;\n\n    do {\n        pg = svwhilelt_b64(i, total_elements);\n        svfloat64_t vec = svld1(pg, &mat[i]);\n        sum_vec = svadd_m(sum_vec, pg, sum_vec, vec);\n        i += svcntb() / sizeof(double);\n    } while (svptest_any(svptrue_b64(), pg));\n\n    sum = svaddv_f64(svptrue_b64(), sum_vec);\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```c\n#include <arm_sve.h> \n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    svbool_t pg;\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    double sum = 0.0;\n    size_t i = 0;\n\n    do {\n        pg = svwhilelt_b64(i, total_elements);\n        svfloat64_t vec = svld1(pg, &mat[i]);\n        sum_vec = svadd_m(sum_vec, pg, sum_vec, vec);\n        i += svcntb() / sizeof(double);\n    } while (svptest_any(svptrue_b64(), pg));\n\n    sum = svaddv_f64(svptrue_b64(), sum_vec);\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```c\n#include <arm_sve.h> \n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    svbool_t pg;\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    double sum = 0.0;\n    size_t i = 0;\n\n    do {\n        pg = svwhilelt_b64(i, total_elements);\n        svfloat64_t vec = svld1(pg, &mat[i]);\n        sum_vec = svadd_m(sum_vec, pg, sum_vec, vec);\n        i += svcntb() / sizeof(double);\n    } while (svptest_any(svptrue_b64(), pg));\n\n    sum = svaddv_f64(svptrue_b64(), sum_vec);\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```c\n#include <arm_sve.h> \n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    svbool_t pg;\n    svfloat64_t sum = svdup_f64(0.0);\n    size_t total_elements = m * n;\n    size_t i = 0;\n\n    do {\n        size_t count = svcntd();\n        if (i + count > total_elements) {\n            count = total_elements - i;\n        }\n        pg = svwhilelt_b64(i, total_elements);\n        svfloat64_t vec = svld1(pg, &mat[i]);\n        sum = svadd_m(sum, pg, sum, vec);\n        i += count;\n    } while (i < total_elements);\n\n    double result[2];\n    svst1_f64(pg, result, sum);\n    return (result[0] + result[1]) / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```c\n#include <arm_sve.h> \n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    svbool_t pg;\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    double sum = 0.0;\n    size_t i = 0;\n\n    do {\n        pg = svwhilelt_b64(i, total_elements);\n        svfloat64_t vec = svld1(pg, &mat[i]);\n        sum_vec = svadd_m(sum_vec, pg, sum_vec, vec);\n        i += svcntb() / sizeof(double);\n    } while (svptest_any(svptrue_b64(), pg));\n\n    sum = svaddv_f64(svptrue_b64(), sum_vec);\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```c\n#include <arm_sve.h> \n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        svbool_t pg = svptrue_b32();\n        svint32_t prev = svld1_s32(pg, row);\n        bool ascending = directions[i];\n\n        for (size_t j = 1; j < cols; ++j) {\n            svint32_t curr = svld1_s32(pg, row + j);\n            svbool_t cmp;\n            if (ascending) {\n                cmp = svcmplt_s32(pg, prev, curr);\n            } else {\n                cmp = svcmpgt_s32(pg, prev, curr);\n            }\n            if (!svptest_any(svptrue_b32(), cmp)) {\n                return false;\n            }\n            prev = curr;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```c\n#include <arm_sve.h> \n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        svbool_t pg = svptrue_b32();\n        svint32_t prev = svld1_s32(pg, row);\n        bool ascending = directions[i];\n\n        for (size_t j = 1; j < cols; ++j) {\n            svint32_t curr = svld1_s32(pg, row + j);\n            svbool_t cmp;\n            if (ascending) {\n                cmp = svcmplt_s32(pg, prev, curr);\n            } else {\n                cmp = svcmpgt_s32(pg, prev, curr);\n            }\n            if (!svptest_any(svptrue_b32(), cmp)) {\n                return false;\n            }\n            prev = curr;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```c\n#include <arm_sve.h> \n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t r = 0; r < rows; ++r) {\n        const int* row = matrix + r * cols;\n        svbool_t pg = svptrue_b32();\n        svint32_t prev = svld1_s32(pg, row);\n        bool ascending = directions[r];\n\n        for (size_t c = 1; c < cols; ++c) {\n            svint32_t curr = svld1_s32(pg, row + c);\n            svbool_t cmp;\n            if (ascending) {\n                cmp = svcmplt_s32(pg, prev, curr);\n            } else {\n                cmp = svcmpgt_s32(pg, prev, curr);\n            }\n            if (!svptest_any(svptrue_b32(), cmp)) {\n                return false;\n            }\n            prev = curr;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```c\n#include <arm_sve.h> \n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t r = 0; r < rows; ++r) {\n        const int* row = matrix + r * cols;\n        svbool_t pg = svptrue_b32();\n        svint32_t prev = svld1_s32(pg, row);\n        bool ascending = directions[r];\n\n        for (size_t c = 1; c < cols; ++c) {\n            svint32_t curr = svld1_s32(pg, row + c);\n            svbool_t cmp;\n            if (ascending) {\n                cmp = svcmplt_s32(pg, prev, curr);\n            } else {\n                cmp = svcmpgt_s32(pg, prev, curr);\n            }\n            if (!svptest_any(svptrue_b32(), cmp)) {\n                return false;\n            }\n            prev = curr;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```c\n#include <arm_sve.h> \n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t r = 0; r < rows; ++r) {\n        const int* row = matrix + r * cols;\n        svbool_t pg = svptrue_b32();\n        svint32_t prev = svld1_s32(pg, row);\n        bool ascending = directions[r];\n\n        for (size_t c = 1; c < cols; ++c) {\n            svint32_t curr = svld1_s32(pg, row + c);\n            svbool_t cmp;\n            if (ascending) {\n                cmp = svcmplt_s32(pg, prev, curr);\n            } else {\n                cmp = svcmpgt_s32(pg, prev, curr);\n            }\n            if (!svptest_any(svptrue_b32(), cmp)) {\n                return false;\n            }\n            prev = curr;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    svbool_t pg;\n    svint16_t vbase = svdup_s16(base);\n    size_t vl;\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = svcntw();\n        if (i + vl > length) {\n            vl = length - i;\n        }\n        pg = svwhilelt_b16(i, length);\n        svint16_t vsrc = svld1_s16(pg, &src[i]);\n        svint16_t vdiv = svdiv_s16_z(pg, vsrc, vbase);\n        svint16_t vmul = svmul_s16_z(pg, vdiv, vbase);\n        svst1_s16(pg, &dst[i], vmul);\n    }\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    svint16_t vbase = svdup_s16(base);\n    size_t vl;\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = svcntw();\n        svint16_t vsrc = svld1_s16(svundef_s16(), &src[i], svwup_b8(vl));\n        svint16_t vdiv = svdiv_s16_z(svptrue_b16(), vsrc, vbase);\n        svint16_t vmul = svmul_s16_z(svptrue_b16(), vdiv, vbase);\n        svst1_s16(&dst[i], svwup_b8(vl), vmul);\n    }\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    svbool_t pg;\n    svint16_t vbase = svdup_s16(base);\n    size_t vl;\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = svcntw();\n        if (i + vl > length) {\n            vl = length - i;\n        }\n        pg = svwhilelt_b16(i, length);\n        svint16_t vsrc = svld1_s16(pg, &src[i]);\n        svint16_t vdiv = svdiv_s16_z(pg, vsrc, vbase);\n        svint16_t vmul = svmul_s16_z(pg, vdiv, vbase);\n        svst1_s16(pg, &dst[i], vmul);\n    }\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    svbool_t pg;\n    svint16_t vbase = svdup_s16(base);\n    size_t vl;\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = svcntw();\n        if (i + vl > length) {\n            vl = length - i;\n        }\n        pg = svwhilelt_b16(i, length);\n        svint16_t vsrc = svld1_s16(pg, &src[i]);\n        svint16_t vdiv = svdiv_s16_z(pg, vsrc, vbase);\n        svint16_t vmul = svmul_s16_z(pg, vdiv, vbase);\n        svst1_s16(pg, &dst[i], vmul);\n    }\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    svbool_t pg;\n    svint16_t vbase = svdup_s16(base);\n    size_t vl;\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = svcntw();\n        if (i + vl > length) {\n            vl = length - i;\n        }\n        pg = svwhilelt_b16(i, length);\n        svint16_t vsrc = svld1_s16(pg, &src[i]);\n        svint16_t vdiv = svdiv_s16_z(pg, vsrc, vbase);\n        svint16_t vmul = svmul_s16_z(pg, vdiv, vbase);\n        svst1_s16(pg, &dst[i], vmul);\n    }\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    svbool_t pg = svptrue_b64();\n    size_t col_offset = 0;\n\n    while (col_offset < cols) {\n        svfloat64_t vec = svld1(pg, &vector[col_offset]);\n        for (size_t i = 0; i < rows; ++i) {\n            svfloat64_t mat_row = svld1(pg, &matrix[i * cols + col_offset]);\n            svbool_t cmp = svcmpeq(pg, mat_row, vec);\n            if (svptest_any(svptrue_b64(), cmp)) {\n                return true;\n            }\n        }\n        col_offset += svcntd();\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    svbool_t pg = svptrue_b64();\n    size_t col_offset = 0;\n\n    while (col_offset < cols) {\n        svfloat64_t vec = svld1(pg, &vector[col_offset]);\n        for (size_t i = 0; i < rows; ++i) {\n            svfloat64_t mat_row = svld1(pg, &matrix[i * cols + col_offset]);\n            svbool_t match = svcmpeq(pg, mat_row, vec);\n            if (svptest_any(svptrue_b64(), match)) {\n                return true;\n            }\n        }\n        col_offset += svcntd();\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    svbool_t pg = svptrue_b64();\n    size_t col_offset = 0;\n\n    while (col_offset < cols) {\n        svfloat64_t vec = svld1(pg, &vector[col_offset]);\n        for (size_t i = 0; i < rows; ++i) {\n            svfloat64_t mat_row = svld1(pg, &matrix[i * cols + col_offset]);\n            svbool_t match = svmcmpeq(pg, mat_row, vec);\n            if (svptest_any(svptrue_b64(), match)) {\n                return true;\n            }\n        }\n        col_offset += svcntd();\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    svbool_t pg = svptrue_b64();\n    size_t col_offset = 0;\n\n    while (col_offset < cols) {\n        svfloat64_t vec = svld1(pg, &vector[col_offset]);\n        size_t row = 0;\n        while (row < rows) {\n            svfloat64_t mat = svld1(pg, &matrix[row * cols + col_offset]);\n            svbool_t cmp = svcmpeq(pg, mat, vec);\n            if (svptest_any(cmp)) {\n                return true;\n            }\n            row++;\n        }\n        col_offset += svcntb() / sizeof(double);\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    svbool_t pg = svptrue_b64();\n    size_t col_offset = 0;\n\n    while (col_offset < cols) {\n        svfloat64_t vec = svld1(pg, &vector[col_offset]);\n        for (size_t i = 0; i < rows; ++i) {\n            svfloat64_t mat_row = svld1(pg, &matrix[i * cols + col_offset]);\n            svbool_t match = svmulm_b64(pg, mat_row, vec);\n            if (svptest_any(svptrue_b64(), match)) {\n                return true;\n            }\n        }\n        col_offset += svcntd();\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```c\n#include <arm_sve.h> \n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    size_t i = 0;\n\n    svbool_t pg;\n    svuint8_t vecA, vecB;\n    svuint16_t vecEqCount;\n\n    while (svcntb(pg = svwhilelt_b8(i, total_elements)) > 0) {\n        vecA = svld1_u8(pg, &A[i]);\n        vecB = svld1_u8(pg, &B[i]);\n        vecEqCount = svcntb_m(svcmpeq_u8(pg, vecA, vecB), pg);\n        count += svaddv_u16(vecEqCount);\n        i += svcntb(pg);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```c\n#include <arm_sve.h> \n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    size_t i = 0;\n\n    svbool_t pg;\n    svuint8_t vecA, vecB;\n    svuint64_t vecCount = svdup_u64(0);\n\n    while (svcntb(pg = svwhilelt_b8(i, total_elements)) > 0) {\n        vecA = svld1_u8(pg, &A[i]);\n        vecB = svld1_u8(pg, &B[i]);\n        vecCount = svadd_u64_m(pg, vecCount, svcmpeq_u8(pg, vecA, vecB));\n        i += svcntb(pg);\n    }\n\n    count = svaddv_u64(vecCount);\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```c\n#include <arm_sve.h> \n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    size_t i = 0;\n\n    svbool_t pg;\n    svuint8_t vecA, vecB;\n    svuint64_t vecCount = svdup_u64(0);\n\n    while (svcntb(pg = svwhilelt_b8(i, total_elements)) > 0) {\n        vecA = svld1_u8(pg, &A[i]);\n        vecB = svld1_u8(pg, &B[i]);\n        vecCount = svadd_u64_m(pg, vecCount, svcmpeq_u8_z(pg, vecA, vecB));\n        i += svcntb(pg);\n    }\n\n    count = svaddv_u64(vecCount);\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```c\n#include <arm_sve.h> \n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    size_t i = 0;\n\n    svbool_t pg;\n    svuint8_t vecA, vecB;\n    svuint16_t vecEqCount;\n    uint16_t eqCount[2];\n\n    while (i < total_elements) {\n        pg = svwhilelt_b8(i, total_elements);\n        vecA = svld1_u8(pg, A + i);\n        vecB = svld1_u8(pg, B + i);\n\n        vecEqCount = svcntb_m_n_u16(pg, svecmpeq_u8_m(pg, vecA, vecB));\n        eqCount[0] = svcadd_u16_m(svptrue_b16(), vecEqCount, svdup_u16(0))[0];\n\n        count += eqCount[0];\n        i += svcntb();\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```c\n#include <arm_sve.h> \n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    size_t i = 0;\n\n    svbool_t pg;\n    svuint8_t vec_a, vec_b;\n    svuint16_t vec_eq;\n    svuint64_t vec_sum;\n    uint64_t sum;\n\n    while (i < total_elements) {\n        pg = svwhilelt_b8(i, total_elements);\n        vec_a = svld1_u8(pg, A + i);\n        vec_b = svld1_u8(pg, B + i);\n        vec_eq = sveq_u8_z(pg, vec_a, vec_b);\n        vec_sum = svcntb_m_n_u64_z(pg, vec_eq);\n        sum = svaddv_u64(vec_sum);\n        count += sum;\n        i += svcntb();\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t vl = svcntd();\n    svbool_t pg;\n\n    for (size_t i = 0; i < length; i += vl) {\n        pg = svwhilelt_b64(i, length);\n        svint64_t vec_x = svld1(pg, &x[i]);\n        svint64_t vec_a = svdup_n_s64(a);\n        svint64_t vec_y = svld1(pg, &y[i]);\n\n        svint64_t mul_result = svmul_s64_z(pg, vec_a, vec_x);\n        svint64_t abs_result = svabs_s64_z(pg, vec_y);\n\n        svint64_t sub_result = svsub_s64_z(pg, abs_result, mul_result);\n        svst1(pg, &y[i], sub_result);\n    }\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t vl;\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = svcntd();\n        vl = svmin_zd(svwhilelt_b64(i, length), vl);\n\n        svint64_t vec_x = svld1_s64(vl, &x[i]);\n        svint64_t vec_a = svdup_s64(a);\n        svint64_t vec_y = svld1_s64(vl, &y[i]);\n\n        svint64_t mul_result = svmul_s64_z(vl, vec_a, vec_x);\n        svint64_t abs_result = svabs_s64_z(vl, vec_y);\n\n        svint64_t sub_result = svsub_s64_z(vl, abs_result, mul_result);\n\n        svst1_s64(vl, &y[i], sub_result);\n    }\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t vl;\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = svcntd(); // Get the number of elements per vector\n\n        svint64_t vec_x = svld1_s64(svundef_u64(), &x[i], svwhilelt_b64(i + vl, length));\n        svint64_t vec_a = svdup_s64(a);\n        svint64_t vec_y = svld1_s64(svundef_u64(), &y[i], svwhilelt_b64(i + vl, length));\n\n        svint64_t mul_result = svmul_s64_z(svwhilelt_b64(i + vl, length), vec_a, vec_x);\n        svint64_t abs_result = svabs_s64_z(svwhilelt_b64(i + vl, length), vec_y);\n\n        svint64_t sub_result = svsub_s64_z(svwhilelt_b64(i + vl, length), abs_result, mul_result);\n\n        svst1_s64(&y[i], sub_result, svwhilelt_b64(i + vl, length));\n    }\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t vl;\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = svcntd();\n        vl = svmin_zd(vl, length - i);\n\n        svint64_t vec_x = svld1_s64(svundef_b64(), &x[i]);\n        svint64_t vec_a = svdup_s64(a);\n        svint64_t vec_y = svld1_s64(svundef_b64(), &y[i]);\n\n        svint64_t mul_result = svmul_s64_z(svptrue_b64(), vec_a, vec_x);\n        svint64_t abs_result = svabs_s64_z(svptrue_b64(), vec_y);\n        svint64_t sub_result = svsub_s64_z(svptrue_b64(), abs_result, mul_result);\n\n        svst1_s64(svundef_b64(), &y[i], sub_result);\n    }\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t vl = svcntd();\n    svbool_t pg;\n\n    for (size_t i = 0; i < length; i += vl) {\n        pg = svwhilelt_b64(i, length);\n        svint64_t vec_x = svld1(pg, &x[i]);\n        svint64_t vec_a = svdup_n_s64(a);\n        svint64_t vec_y = svld1(pg, &y[i]);\n\n        svint64_t mul_result = svmul_s64_z(pg, vec_a, vec_x);\n        svint64_t abs_result = svabs_s64_z(pg, vec_y);\n\n        svint64_t sub_result = svsub_s64_z(pg, abs_result, mul_result);\n        svst1(pg, &y[i], sub_result);\n    }\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\n#include <arm_sve.h> \n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    svint16_t min_vec = svdup_s16(INT16_MAX);\n    svint16_t max_vec = svdup_s16(INT16_MIN);\n    size_t vl;\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = svmin_zu(svptrue_b16(), length - i);\n        svint16_t vec_sve = svld1_s16(vl, &vec[i]);\n        min_vec = svmin_s16_z(svptrue_b16(), min_vec, vec_sve);\n        max_vec = svmax_s16_z(svptrue_b16(), max_vec, vec_sve);\n    }\n\n    int16_t min_result = svminv_s16(min_vec);\n    int16_t max_result = svmaxv_s16(max_vec);\n\n    return (MinMaxPair){min_result, max_result};\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\n#include <arm_sve.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    svbool_t pg = svwhilelt_b16(0, length);\n    svint16_t min_val = svdup_n_s16(INT16_MAX);\n    svint16_t max_val = svdup_n_s16(INT16_MIN);\n\n    const int16_t* end = vec + length;\n    while (svptest_any(svptrue_b16(), pg)) {\n        svint16_t vec_sve = svld1_s16(pg, vec);\n        min_val = svmin_s16_z(pg, min_val, vec_sve);\n        max_val = svmax_s16_z(pg, max_val, vec_sve);\n        vec += svcntw();\n        pg = svwhilelt_b16(vec - vec, length);\n    }\n\n    int16_t min_result = svminv_s16(min_val);\n    int16_t max_result = svmaxv_s16(max_val);\n\n    return (MinMaxPair){min_result, max_result};\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\n#include <arm_sve.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    svbool_t pg = svwhilelt_b16(0, length);\n    svint16_t min_val = svdup_n_s16(INT16_MAX);\n    svint16_t max_val = svdup_n_s16(INT16_MIN);\n\n    const int16_t* end = vec + length;\n    while (svptest_any(svptrue_b16(), pg)) {\n        svint16_t vec_s16 = svld1_s16(pg, vec);\n        min_val = svmin_s16_z(pg, min_val, vec_s16);\n        max_val = svmax_s16_z(pg, max_val, vec_s16);\n        vec += svcntw();\n        pg = svwhilelt_b16((vec - vec), length);\n    }\n\n    int16_t min_result = svminv_s16(min_val);\n    int16_t max_result = svmaxv_s16(max_val);\n\n    return (MinMaxPair){min_result, max_result};\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\n#include <arm_sve.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    svbool_t pg = svwhilelt_b16(0, length);\n    svint16_t min_val = svdup_n_s16(INT16_MAX);\n    svint16_t max_val = svdup_n_s16(INT16_MIN);\n\n    const int16_t* end = vec + length;\n    while (svptest_any(svptrue_b16(), pg)) {\n        svint16_t vec_sve = svld1_s16(pg, vec);\n        min_val = svmin_s16_z(pg, min_val, vec_sve);\n        max_val = svmax_s16_z(pg, max_val, vec_sve);\n        vec += svcntw();\n        pg = svwhilelt_b16(vec - vec, length);\n    }\n\n    int16_t min_result = svminv_s16(min_val);\n    int16_t max_result = svmaxv_s16(max_val);\n\n    return (MinMaxPair){min_result, max_result};\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\n#include <arm_sve.h> \n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    svint16_t min_vec = svdup_s16(INT16_MAX);\n    svint16_t max_vec = svdup_s16(INT16_MIN);\n    size_t vl;\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = svmin_zu(svptrue_b16(), length - i);\n        svint16_t vec_sve = svld1_s16(vl, &vec[i]);\n        min_vec = svmin_s16_m(svptrue_b16(), min_vec, vec_sve);\n        max_vec = svmax_s16_m(svptrue_b16(), max_vec, vec_sve);\n    }\n\n    int16_t min_result = svminv_s16(min_vec);\n    int16_t max_result = svmaxv_s16(max_vec);\n\n    return (MinMaxPair){min_result, max_result};\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    size_t col = 0;\n    svbool_t pg = svptrue_b32();\n    svint32_t prev = svld1_s32(pg, matrix);\n\n    for (size_t row = 0; row < rows; ++row) {\n        const int* row_start = matrix + row * cols;\n        prev = svld1_s32(pg, row_start);\n        for (col = 1; col < cols; col += svcntw()) {\n            svint32_t curr = svld1_s32(pg, row_start + col);\n            svbool_t cmp = svcmplt_s32(pg, prev, curr);\n            if (!svall_b32(cmp)) {\n                return false;\n            }\n            prev = curr;\n        }\n        // Handle remaining elements that do not fit into a full vector\n        for (; col < cols; ++col) {\n            if (row_start[col - 1] >= row_start[col]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    size_t col = 0;\n    svbool_t pg = svptrue_b32();\n    svint32_t prev = svld1_s32(pg, matrix);\n\n    for (size_t row = 0; row < rows; ++row) {\n        const int* row_start = matrix + row * cols;\n        prev = svld1_s32(pg, row_start);\n        for (col = 1; col < cols; col += svcntw()) {\n            svint32_t curr = svld1_s32(pg, row_start + col);\n            svbool_t cmp = svcmplt_s32(pg, prev, curr);\n            if (!svall_b32(pg, cmp)) {\n                return false;\n            }\n            prev = curr;\n        }\n        // Handle remaining elements that do not fit into a full vector\n        for (; col < cols; ++col) {\n            if (row_start[col - 1] >= row_start[col]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    size_t col = 0;\n    svbool_t pg = svptrue_b32();\n    for (size_t row = 0; row < rows; ++row) {\n        const int* row_start = matrix + row * cols;\n        col = 0;\n        while (col < cols - 1) {\n            size_t vl = svcntw() < cols - col ? svcntw() : cols - col - 1;\n            svint32_t vec1 = svld1(pg, row_start + col);\n            svint32_t vec2 = svld1(pg, row_start + col + 1);\n            svbool_t cmp = svcmplt_s32(pg, vec1, vec2);\n            if (!svall_b32(cmp)) {\n                return false;\n            }\n            col += vl;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        size_t j = 0;\n\n        svbool_t pg = svptrue_b32();\n        svint32_t prev = svld1_s32(pg, row);\n\n        for (j = 1; j <= cols - svcntw(); j += svcntw()) {\n            svint32_t curr = svld1_s32(pg, row + j);\n            svbool_t cmp = svcmplt_s32(pg, prev, curr);\n            if (!svall_b32(pg, cmp)) {\n                return false;\n            }\n            prev = curr;\n        }\n\n        for (; j < cols; ++j) {\n            if (row[j - 1] >= row[j]) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    size_t col = 0;\n    svbool_t pg = svptrue_b32();\n    for (size_t row = 0; row < rows; ++row) {\n        const int* row_start = matrix + row * cols;\n        col = 0;\n        while (col < cols - 1) {\n            size_t vl = svcntw() < cols - col ? svcntw() : cols - col - 1;\n            svint32_t vec1 = svld1(pg, row_start + col);\n            svint32_t vec2 = svld1(pg, row_start + col + 1);\n            svbool_t cmp = svcmplt_s32(pg, vec1, vec2);\n            if (!svall_b32(cmp)) {\n                return false;\n            }\n            col += vl;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n\n    svint32_t first_block[block_size];\n    for (size_t i = 0; i < block_size; ++i) {\n        first_block[i] = svld1_s32(matrix + i * cols);\n    }\n\n    for (size_t block_row = 0; block_row < num_blocks_row; ++block_row) {\n        for (size_t block_col = 0; block_col < num_blocks_col; ++block_col) {\n            if (block_row == 0 && block_col == 0) {\n                continue;\n            }\n\n            for (size_t i = 0; i < block_size; ++i) {\n                svint32_t current_block = svld1_s32(matrix + (block_row * block_size + i) * cols + block_col * block_size);\n                svbool_t eq = svecmpeq_s32(svptrue_b32(), current_block, first_block[i]);\n                if (!svptest_any(svptrue_b32(), eq)) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n\n    svint32_t first_block[block_size];\n    for (size_t i = 0; i < block_size; ++i) {\n        first_block[i] = svld1_s32(matrix + i * cols);\n    }\n\n    for (size_t block_row = 0; block_row < num_blocks_row; ++block_row) {\n        for (size_t block_col = 0; block_col < num_blocks_col; ++block_col) {\n            if (block_row == 0 && block_col == 0) {\n                continue;\n            }\n\n            for (size_t i = 0; i < block_size; ++i) {\n                svint32_t current_block = svld1_s32(matrix + (block_row * block_size + i) * cols + block_col * block_size);\n                svbool_t eq = svecmpeq_s32(svptrue_b32(), current_block, first_block[i]);\n                if (!svptest_any(svptrue_b32(), eq)) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n\n    svint32_t first_block[block_size];\n    for (size_t i = 0; i < block_size; ++i) {\n        first_block[i] = svld1_s32(matrix + i * cols);\n    }\n\n    for (size_t block_row = 0; block_row < num_blocks_row; ++block_row) {\n        for (size_t block_col = 0; block_col < num_blocks_col; ++block_col) {\n            if (block_row == 0 && block_col == 0) {\n                continue;\n            }\n\n            for (size_t i = 0; i < block_size; ++i) {\n                svint32_t current_block = svld1_s32(matrix + (block_row * block_size + i) * cols + block_col * block_size);\n                svbool_t eq = svecmpeq_s32(svptrue_b32(), current_block, first_block[i]);\n                if (!svptest_any(svptrue_b32(), eq)) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n\n    svint32_t first_block[block_size];\n    for (size_t i = 0; i < block_size; ++i) {\n        first_block[i] = svld1_s32(matrix + i * cols);\n    }\n\n    for (size_t block_row = 0; block_row < num_blocks_row; ++block_row) {\n        for (size_t block_col = 0; block_col < num_blocks_col; ++block_col) {\n            if (block_row == 0 && block_col == 0) {\n                continue;\n            }\n\n            for (size_t i = 0; i < block_size; ++i) {\n                svint32_t current_block = svld1_s32(matrix + (block_row * block_size + i) * cols + block_col * block_size);\n                svbool_t eq = svecmpeq_s32(svptrue_b32(), current_block, first_block[i]);\n                if (!svptest_any(svptrue_b32(), eq)) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```c\n#include <arm_sve.h> \n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n\n    svint32_t first_block[block_size];\n    for (size_t i = 0; i < block_size; ++i) {\n        first_block[i] = svld1_s32(matrix + i * cols);\n    }\n\n    for (size_t block_row = 0; block_row < num_blocks_row; ++block_row) {\n        for (size_t block_col = 0; block_col < num_blocks_col; ++block_col) {\n            if (block_row == 0 && block_col == 0) {\n                continue;\n            }\n\n            for (size_t i = 0; i < block_size; ++i) {\n                svint32_t current_block = svld1_s32(matrix + (block_row * block_size + i) * cols + block_col * block_size);\n                svbool_t eq = svecmpeq_s32(svptrue_b32(), current_block, first_block[i]);\n                if (!svptest_any(svptrue_b32(), eq)) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (!vec || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    svbool_t pg = svptrue_b64();\n    svfloat64_t tol = svdup_f64(tolerance);\n\n    // Load the first block\n    svfloat64_t first_block = svld1(pg, vec);\n\n    size_t num_blocks = length / block_size;\n\n    for (size_t i = 1; i < num_blocks; ++i) {\n        const double* current_block_ptr = vec + i * block_size;\n        svfloat64_t current_block = svld1(pg, current_block_ptr);\n\n        svfloat64_t diff = svabs_f64(svsub_f64(current_block, first_block));\n        svbool_t result = svcmplt_f64(pg, diff, tol);\n\n        if (!svptest_any(sv_ptrue_b64(), result)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (!vec || length < block_size || block_size == 0) {\n        return false;\n    }\n\n    svbool_t pg = svptrue_b64();\n    svfloat64_t tol = svdup_f64(tolerance);\n    svfloat64_t first_block = svld1(pg, vec);\n\n    for (size_t i = block_size; i <= length - block_size; i += block_size) {\n        svfloat64_t current_block = svld1(pg, &vec[i]);\n        svfloat64_t diff = svabs_f64_z(pg, svsub_f64_z(pg, current_block, first_block));\n        svbool_t result = svcmplt_f64(pg, diff, tol);\n        if (!svall_b(pg, result)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (!vec || length < block_size || block_size == 0) {\n        return false;\n    }\n\n    svbool_t pg = svptrue_b64();\n    svfloat64_t tol = svdup_f64(tolerance);\n    svfloat64_t first_block = svld1(pg, vec);\n\n    for (size_t i = block_size; i <= length - block_size; i += block_size) {\n        svfloat64_t current_block = svld1(pg, &vec[i]);\n        svfloat64_t diff = svabs_f64_z(pg, svsub_f64_z(pg, current_block, first_block));\n        svbool_t result = svcmplt_f64(pg, diff, tol);\n        if (!svptest_any(sv_ptrue_b64(), result)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (!vec || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    svbool_t pg = svptrue_b64();\n    svfloat64_t tol = svdup_f64(tolerance);\n    svfloat64_t first_block = svld1(pg, vec);\n\n    for (size_t i = block_size; i <= length - block_size; i += block_size) {\n        svfloat64_t current_block = svld1(pg, &vec[i]);\n        svfloat64_t diff = svabs_f64_z(pg, svsub_f64_z(pg, current_block, first_block));\n        svbool_t result = svcmplt_f64(pg, diff, tol);\n        if (!svptest_any(sv_ptrue_b64(), result)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (!vec || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    svbool_t pg = svptrue_b64();\n    svfloat64_t tol = svdup_f64(tolerance);\n    svfloat64_t first_block = svld1(pg, vec);\n\n    for (size_t i = block_size; i <= length - block_size; i += block_size) {\n        svfloat64_t current_block = svld1(pg, &vec[i]);\n        svfloat64_t diff = svabs_f64_z(pg, svsub_f64_z(pg, current_block, first_block));\n        svbool_t result = svcmplt_f64(pg, diff, tol);\n        if (!svall_b(pg, result)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    size_t i;\n    for (i = 0; i < rows; ++i) {\n        svbool_t pg = svptrue_b64();\n        svfloat64_t sum = svdup_f64(0.0);\n        size_t j;\n        for (j = 0; j < cols; j += svcntd()) {\n            svfloat64_t vec = svld1(pg, &matrix[i * cols + j]);\n            vec = svmul_f64_z(pg, vec, vec);\n            sum = svadd_f64_m(pg, sum, vec);\n        }\n        double norm = cmla_f64(svgetlane_f64(sum, 0), svgetlane_f64(sum, 1), svgetlane_f64(sum, 2), svgetlane_f64(sum, 3));\n        norm = sqrt(norm);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    size_t i;\n    for (i = 0; i < rows; ++i) {\n        svbool_t pg = svptrue_b64();\n        svfloat64_t sum = svdup_f64(0.0);\n        size_t j;\n        for (j = 0; j < cols; j += svcntd()) {\n            svfloat64_t vec = svld1(pg, &matrix[i * cols + j]);\n            vec = svmul_f64_z(pg, vec, vec);\n            sum = svadd_f64_m(pg, sum, vec);\n        }\n        double norm = cblas_dsqrt(svaddv_f64(pg, sum));\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    size_t i;\n    for (i = 0; i < rows; ++i) {\n        svbool_t pg = svptrue_b64();\n        svfloat64_t sum = svdup_f64(0.0);\n        size_t j;\n        for (j = 0; j < cols; j += svcntd()) {\n            svfloat64_t vec = svld1(pg, &matrix[i * cols + j]);\n            vec = svmul_f64_z(pg, vec, vec);\n            sum = svadd_f64_m(pg, sum, vec);\n        }\n        double norm = cblas_dsqrt(svaddv_f64(pg, sum));\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    size_t i;\n    for (i = 0; i < rows; ++i) {\n        svbool_t pg = svptrue_b64();\n        svfloat64_t sum = svdup_f64(0.0);\n        size_t j;\n        for (j = 0; j < cols; j += svcntd()) {\n            svfloat64_t vec = svld1(pg, &matrix[i * cols + j]);\n            vec = svmul_f64_z(pg, vec, vec);\n            sum = svadd_f64_m(pg, sum, vec);\n        }\n        double norm = cblas_dsqrt(svaddv_f64(pg, sum));\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    size_t i;\n    for (i = 0; i < rows; ++i) {\n        svbool_t pg = svptrue_b64();\n        svfloat64_t sum = svdup_f64(0.0);\n        size_t j;\n        for (j = 0; j < cols; j += svcntd()) {\n            svfloat64_t vec = svld1(pg, &matrix[i * cols + j]);\n            vec = svmul_f64_z(pg, vec, vec);\n            sum = svadd_f64_m(pg, sum, vec);\n        }\n        double norm = cmla_f64(sum);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    do {\n        pg = svwhilelt_b32(i, length);\n        svuint32_t vecA = svld1_u32(pg, &A[i]);\n        svuint32_t vecB = svld1_u32(pg, &B[i]);\n        svuint32_t vecResult = svorr_u32_z(pg, vecA, vecB);\n        svst1_u32(pg, &C[i], vecResult);\n        i += svcntw();\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    do {\n        pg = svwhilelt_b32(i, length);\n        svuint32_t vecA = svld1_u32(pg, &A[i]);\n        svuint32_t vecB = svld1_u32(pg, &B[i]);\n        svuint32_t vecResult = svorr_u32_z(pg, vecA, vecB);\n        svst1_u32(pg, &C[i], vecResult);\n        i += svcntw();\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    do {\n        pg = svwhilelt_b32(i, length);\n        svuint32_t vecA = svld1_u32(pg, &A[i]);\n        svuint32_t vecB = svld1_u32(pg, &B[i]);\n        svuint32_t vecResult = svorr_u32_z(pg, vecA, vecB);\n        svst1_u32(pg, &C[i], vecResult);\n        i += svcntw();\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    do {\n        pg = svwhilelt_b32(i, length);\n        svuint32_t vecA = svld1_u32(pg, &A[i]);\n        svuint32_t vecB = svld1_u32(pg, &B[i]);\n        svuint32_t vecResult = svorr_u32_z(pg, vecA, vecB);\n        svst1_u32(pg, &C[i], vecResult);\n        i += svcntw();\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    do {\n        pg = svwhilelt_b32(i, length);\n        svuint32_t vecA = svld1_u32(pg, &A[i]);\n        svuint32_t vecB = svld1_u32(pg, &B[i]);\n        svuint32_t vecResult = svorr_u32_z(pg, vecA, vecB);\n        svst1_u32(pg, &C[i], vecResult);\n        i += svcntw();\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_of_squares = 0;\n    int64_t sum_of_products = 0;\n\n    svbool_t pg = svptrue_b8();\n    svint8_t vec_a, vec_b;\n    svint16_t vec_a_squared, vec_b_squared, vec_products;\n    svint32_t vec_sum_squares = svdup_n_s32(0);\n    svint32_t vec_sum_products = svdup_n_s32(0);\n\n    for (size_t i = 0; i < length; i += svcntb()) {\n        size_t vl = svmin(svptrue_b8(), length - i);\n        pg = svwhilelt_b8(i, length);\n\n        vec_a = svld1_s8(pg, &A[i]);\n        vec_b = svld1_s8(pg, &B[i]);\n\n        vec_a_squared = svmul_s16(svextb_s16(vec_a), svextb_s16(vec_a));\n        vec_b_squared = svmul_s16(svextb_s16(vec_b), svextb_s16(vec_b));\n        vec_products = svmul_s16(svextb_s16(vec_a), svextb_s16(vec_b));\n\n        vec_sum_squares = svaddv_s32_z(pg, vec_sum_squares, svadd_s32_z(pg, vec_a_squared, vec_b_squared));\n        vec_sum_products = svaddv_s32_z(pg, vec_sum_products, vec_products);\n    }\n\n    sum_of_squares = svaddv_s64(svdup_n_s64(0), svaddl_s64_z(svptrue_b64(), vec_sum_squares, vec_sum_squares));\n    sum_of_products = svaddv_s64(svdup_n_s64(0), svaddl_s64_z(svptrue_b64(), vec_sum_products, vec_sum_products));\n\n    return sum_of_squares - sum_of_products;\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_of_squares = 0;\n    int64_t sum_of_products = 0;\n\n    svbool_t pg = svwhilelt_b8(0, length);\n    svint8_t vec_a = svld1_s8(pg, A);\n    svint8_t vec_b = svld1_s8(pg, B);\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svint16_t squares_a = svmul_s16(svreinterpret_s16_s8(vec_a), svreinterpret_s16_s8(vec_a));\n        svint16_t squares_b = svmul_s16(svreinterpret_s16_s8(vec_b), svreinterpret_s16_s8(vec_b));\n        svint16_t products = svmul_s16(svreinterpret_s16_s8(vec_a), svreinterpret_s16_s8(vec_b));\n\n        sum_of_squares += svaddv_s64(svptrue_b64(), svadd_s64_z(svptrue_b64(), svaddl_s64(svptrue_b64(), squares_a, squares_b), svdup_s64(0)));\n        sum_of_products += svaddv_s64(svptrue_b64(), svaddl_s64(svptrue_b64(), products, svdup_s64(0)));\n\n        size_t consumed = svcntb();\n        A += consumed;\n        B += consumed;\n        length -= consumed;\n        pg = svwhilelt_b8(0, length);\n        vec_a = svld1_s8(pg, A);\n        vec_b = svld1_s8(pg, B);\n    }\n\n    return sum_of_squares - sum_of_products;\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_of_squares = 0;\n    int64_t sum_of_products = 0;\n\n    svbool_t pg = svwhilelt_b8(0, length);\n    svint8_t vec_a = svld1_s8(pg, A);\n    svint8_t vec_b = svld1_s8(pg, B);\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svint16_t squares_a = svmul_s16(svreinterpret_s16_s8(vec_a), svreinterpret_s16_s8(vec_a));\n        svint16_t squares_b = svmul_s16(svreinterpret_s16_s8(vec_b), svreinterpret_s16_s8(vec_b));\n        svint16_t products = svmul_s16(svreinterpret_s16_s8(vec_a), svreinterpret_s16_s8(vec_b));\n\n        sum_of_squares += svaddl_s32(svptrue_b16(), squares_a, squares_b);\n        sum_of_products += svaddl_s32(svptrue_b16(), products);\n\n        size_t consumed = svcntb();\n        A += consumed;\n        B += consumed;\n        length -= consumed;\n        pg = svwhilelt_b8(0, length);\n        vec_a = svld1_s8(pg, A);\n        vec_b = svld1_s8(pg, B);\n    }\n\n    return sum_of_squares - sum_of_products;\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_of_squares = 0;\n    int64_t sum_of_products = 0;\n\n    svbool_t pg = svptrue_b8();\n    svint8_t va, vb;\n    svint16_t vsquares, vproducts;\n    svint32_t vacc_squares = svdup_s32(0);\n    svint32_t vacc_products = svdup_s32(0);\n\n    for (size_t i = 0; i < length; i += svcntb()) {\n        size_t vl = svmin(svptrue_b8(), length - i);\n        pg = svwhilelt_b8(i, length);\n\n        va = svld1_s8(pg, &A[i]);\n        vb = svld1_s8(pg, &B[i]);\n\n        vsquares = svmlal_s16(svmlal_s16(svdup_s16(0), va, va), vb, vb);\n        vproducts = svmad_s16_z(pg, svdup_s16(0), va, vb);\n\n        vacc_squares = svaddv_s32(vacc_squares, svaddv_s32_z(pg, svdup_s32(0), vsquares));\n        vacc_products = svaddv_s32(vacc_products, svaddv_s32_z(pg, svdup_s32(0), vproducts));\n    }\n\n    sum_of_squares = svaddv_s64(svdup_s64(0), svaddl_s32(svdup_s32(0), vacc_squares, vacc_squares));\n    sum_of_products = svaddv_s64(svdup_s64(0), svaddl_s32(svdup_s32(0), vacc_products, vacc_products));\n\n    return sum_of_squares - sum_of_products;\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_of_squares = 0;\n    int64_t sum_of_products = 0;\n\n    svbool_t pg = svwhilelt_b8(0, length);\n    svint8_t vec_a = svld1_s8(pg, A);\n    svint8_t vec_b = svld1_s8(pg, B);\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svint16_t squares_a = svmul_s16(svreinterpret_s16_s8(vec_a), svreinterpret_s16_s8(vec_a));\n        svint16_t squares_b = svmul_s16(svreinterpret_s16_s8(vec_b), svreinterpret_s16_s8(vec_b));\n        svint16_t products = svmul_s16(svreinterpret_s16_s8(vec_a), svreinterpret_s16_s8(vec_b));\n\n        sum_of_squares += svaddl_s32(svptrue_b16(), squares_a, squares_b);\n        sum_of_products += svaddl_s32(svptrue_b16(), products);\n\n        size_t consumed = svcntb() - svcntp_b8(svptrue_b8(), pg);\n        A += consumed;\n        B += consumed;\n        length -= consumed;\n        pg = svwhilelt_b8(0, length);\n        vec_a = svld1_s8(pg, A);\n        vec_b = svld1_s8(pg, B);\n    }\n\n    return sum_of_squares - sum_of_products;\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    do {\n        size_t vl = svcntd();\n        if (i + vl > length) {\n            vl = length - i;\n            pg = svwhilelt_b64(i, length);\n        } else {\n            pg = svptrue_b64();\n        }\n        svuint64_t vecA = svld1(pg, &A[i]);\n        svuint64_t vecB = svld1(pg, &B[i]);\n        svuint64_t vecNotB = svnot_b_z(pg, vecB);\n        svuint64_t result = svand_z(pg, vecA, vecNotB);\n        svst1(pg, &C[i], result);\n        i += vl;\n    } while (i < length);\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    do {\n        size_t vl = svcntd();\n        if (i + vl > length) {\n            vl = length - i;\n            pg = svwhilelt_b64(i, length);\n        } else {\n            pg = svptrue_b64();\n        }\n        svuint64_t vecA = svld1_u64(pg, &A[i]);\n        svuint64_t vecB = svld1_u64(pg, &B[i]);\n        svuint64_t vecNotB = svnot_u64_z(pg, vecB);\n        svuint64_t result = svand_u64_z(pg, vecA, vecNotB);\n        svst1_u64(pg, &C[i], result);\n        i += vl;\n    } while (i < length);\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    do {\n        size_t vl = svcntd();\n        if (i + vl > length) {\n            vl = length - i;\n            pg = svwhilelt_b64(i, length);\n        } else {\n            pg = svptrue_b64();\n        }\n        svuint64_t vecA = svld1(pg, &A[i]);\n        svuint64_t vecB = svld1(pg, &B[i]);\n        svuint64_t vecNotB = svnot_b_z(pg, vecB);\n        svuint64_t result = svand_z(pg, vecA, vecNotB);\n        svst1(pg, &C[i], result);\n        i += vl;\n    } while (i < length);\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    do {\n        size_t vl = svcntd();\n        if (i + vl > length) {\n            vl = length - i;\n            pg = svwhilelt_b64(i, length);\n        } else {\n            pg = svptrue_b64();\n        }\n        svuint64_t vecA = svld1_u64(pg, &A[i]);\n        svuint64_t vecB = svld1_u64(pg, &B[i]);\n        svuint64_t vecNotB = svnot_u64_z(pg, vecB);\n        svuint64_t result = svand_u64_z(pg, vecA, vecNotB);\n        svst1_u64(pg, &C[i], result);\n        i += vl;\n    } while (i < length);\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    do {\n        size_t vl = svcntd();\n        if (i + vl > length) {\n            vl = length - i;\n            pg = svwhilelt_b64(i, length);\n        } else {\n            pg = svptrue_b64();\n        }\n        svuint64_t vecA = svld1_u64(pg, &A[i]);\n        svuint64_t vecB = svld1_u64(pg, &B[i]);\n        svuint64_t vecNotB = svnot_u64_z(pg, vecB);\n        svuint64_t result = svand_u64_z(pg, vecA, vecNotB);\n        svst1_u64(pg, &C[i], result);\n        i += vl;\n    } while (i < length);\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n\n    while (svcntb() <= length - i) {\n        pg = svwhilelt_b8(i, length);\n\n        svint8_t vecA = svld1_s8(pg, &A[i]);\n        svint8_t vecB = svld1_s8(pg, &B[i]);\n\n        svint8_t posA = svcmpgt_s8(pg, vecA, svdup_n_s8(0));\n        svint8_t posB = svcmpgt_s8(pg, vecB, svdup_n_s8(0));\n        svint8_t negA = svmclt_s8(pg, vecA, svdup_n_s8(0));\n        svint8_t negB = svmclt_s8(pg, vecB, svdup_n_s8(0));\n\n        svint8_t result = svorr_s8_z(pg, svand_s8_z(pg, posA, posB), svand_s8_z(pg, negA, negB));\n        result = svsel_s8(pg, svsel_s8(pg, svdup_n_s8(1), svdup_n_s8(-1), svand_s8_z(pg, negA, negB)), svdup_n_s8(0), result);\n\n        svst1_s8(pg, &C[i], result);\n\n        i += svcntb();\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    svint8_t vec_a, vec_b, vec_c, zero, one, minus_one;\n\n    zero = svdup_s8(0);\n    one = svdup_s8(1);\n    minus_one = svdup_s8(-1);\n\n    for (; svlt_b64(i, length); i += svcntb()) {\n        pg = svwhilelt_b64(i, length);\n        vec_a = svld1_s8(pg, &A[i]);\n        vec_b = svld1_s8(pg, &B[i]);\n\n        svint8_t pos_a = svcmpgt_s8(pg, vec_a, zero);\n        svint8_t pos_b = svcmpgt_s8(pg, vec_b, zero);\n        svint8_t neg_a = svmvn_z(pg, svcmpge_s8(pg, vec_a, zero));\n        svint8_t neg_b = svmvn_z(pg, svcmpge_s8(pg, vec_b, zero));\n\n        svint8_t both_pos = svand_z(pg, pos_a, pos_b);\n        svint8_t both_neg = svand_z(pg, neg_a, neg_b);\n\n        vec_c = svbsl_z(pg, both_pos, one, zero);\n        vec_c = svsel_z(pg, both_neg, minus_one, vec_c);\n\n        svst1_s8(pg, &C[i], vec_c);\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    svint8_t vec_a, vec_b, vec_c, zero, one, minus_one;\n\n    zero = svdup_s8(0);\n    one = svdup_s8(1);\n    minus_one = svdup_s8(-1);\n\n    for (; svlt_b64(i, length); i += svcntb()) {\n        pg = svwhilelt_b64(i, length);\n        vec_a = svld1_s8(pg, &A[i]);\n        vec_b = svld1_s8(pg, &B[i]);\n\n        svint8_t pos_a = svcmpgt_s8(pg, vec_a, zero);\n        svint8_t pos_b = svcmpgt_s8(pg, vec_b, zero);\n        svint8_t neg_a = svmvn_z(pg, svcmpge_s8(pg, vec_a, zero));\n        svint8_t neg_b = svmvn_z(pg, svcmpge_s8(pg, vec_b, zero));\n\n        svint8_t both_pos = svand_z(pg, pos_a, pos_b);\n        svint8_t both_neg = svand_z(pg, neg_a, neg_b);\n\n        vec_c = svsel_z(pg, both_pos, one, zero);\n        vec_c = svsel_z(pg, both_neg, minus_one, vec_c);\n\n        svst1_s8(pg, &C[i], vec_c);\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    svint8_t vec_a, vec_b, vec_c, zero, one, minus_one;\n\n    zero = svdup_s8(0);\n    one = svdup_s8(1);\n    minus_one = svdup_s8(-1);\n\n    do {\n        size_t vl = svcntb();\n        if (i + vl > length) {\n            vl = length - i;\n        }\n        pg = svwhilelt_b8(i, length);\n\n        vec_a = svld1_s8(pg, &A[i]);\n        vec_b = svld1_s8(pg, &B[i]);\n\n        svbool_t both_positive = svand_b8(svptrue_b8(), svcmpgt_s8(pg, vec_a, zero), svcmpgt_s8(pg, vec_b, zero));\n        svbool_t both_negative = svand_b8(svptrue_b8(), svcmplt_s8(pg, vec_a, zero), svcmplt_s8(pg, vec_b, zero));\n\n        vec_c = svbsl_s8(svorr_b8(both_positive, both_negative), svbsl_s8(both_positive, one, minus_one), zero);\n\n        svst1_s8(pg, &C[i], vec_c);\n\n        i += vl;\n    } while (i < length);\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    svint8_t vec_a, vec_b, vec_c, zero, one, minus_one;\n\n    zero = svdup_s8(0);\n    one = svdup_s8(1);\n    minus_one = svdup_s8(-1);\n\n    for (; svlt_b64(i, length); i += svcntb()) {\n        pg = svwhilelt_b64(i, length);\n        vec_a = svld1_s8(pg, &A[i]);\n        vec_b = svld1_s8(pg, &B[i]);\n\n        svint8_t pos_a = svcmpgt_s8(pg, vec_a, zero);\n        svint8_t pos_b = svcmpgt_s8(pg, vec_b, zero);\n        svint8_t neg_a = svcmplt_s8(pg, vec_a, zero);\n        svint8_t neg_b = svcmplt_s8(pg, vec_b, zero);\n\n        svint8_t both_pos = svand_s8_z(pg, pos_a, pos_b);\n        svint8_t both_neg = svand_s8_z(pg, neg_a, neg_b);\n\n        vec_c = svsel_s8(svorr_s8_z(pg, both_pos, both_neg), svsel_s8_z(pg, both_pos, one, minus_one), zero);\n\n        svst1_s8(pg, &C[i], vec_c);\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    svbool_t pg = svptrue_b16();\n    size_t i = 0;\n\n    // Process elements before the midpoint\n    for (; i + svcntw() <= midpoint; i += svcntw()) {\n        svuint16_t vecA = svld1_u16(pg, &A[i]);\n        svuint16_t vecB = svld1_u16(pg, &B[i]);\n        svuint16_t vecXOR = sveor_u16_z(pg, vecA, vecB);\n        svst1_u16(pg, &C[i], vecXOR);\n    }\n\n    // Handle any remaining elements before the midpoint\n    if (i < midpoint) {\n        svbool_t pg_tail = svwhilelt_b16(i, midpoint);\n        svuint16_t vecA = svld1_u16(pg_tail, &A[i]);\n        svuint16_t vecB = svld1_u16(pg_tail, &B[i]);\n        svuint16_t vecXOR = sveor_u16_z(pg_tail, vecA, vecB);\n        svst1_u16(pg_tail, &C[i], vecXOR);\n        i = midpoint;\n    }\n\n    // Process the midpoint element\n    if (length % 2 != 0) {\n        C[midpoint] = A[midpoint];\n        i++;\n    }\n\n    // Process elements after the midpoint\n    for (; i + svcntw() <= length; i += svcntw()) {\n        svuint16_t vecA = svld1_u16(pg, &A[i]);\n        svuint16_t vecB = svld1_u16(pg, &B[i]);\n        svuint16_t vecAND = svand_u16_z(pg, vecA, vecB);\n        svst1_u16(pg, &C[i], vecAND);\n    }\n\n    // Handle any remaining elements after the midpoint\n    if (i < length) {\n        svbool_t pg_tail = svwhilelt_b16(i, length);\n        svuint16_t vecA = svld1_u16(pg_tail, &A[i]);\n        svuint16_t vecB = svld1_u16(pg_tail, &B[i]);\n        svuint16_t vecAND = svand_u16_z(pg_tail, vecA, vecB);\n        svst1_u16(pg_tail, &C[i], vecAND);\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    svbool_t pg = svptrue_b16();\n    size_t i = 0;\n\n    // Process elements before the midpoint\n    for (; i + svcntw() <= midpoint; i += svcntw()) {\n        svuint16_t vecA = svld1_u16(pg, &A[i]);\n        svuint16_t vecB = svld1_u16(pg, &B[i]);\n        svuint16_t vecXOR = sveor_u16_z(pg, vecA, vecB);\n        svst1_u16(pg, &C[i], vecXOR);\n    }\n\n    // Handle any remaining elements before the midpoint\n    if (i < midpoint) {\n        svbool_t pg_remaining = svwhilelt_b16(i, midpoint);\n        svuint16_t vecA = svld1_u16(pg_remaining, &A[i]);\n        svuint16_t vecB = svld1_u16(pg_remaining, &B[i]);\n        svuint16_t vecXOR = sveor_u16_z(pg_remaining, vecA, vecB);\n        svst1_u16(pg_remaining, &C[i], vecXOR);\n        i = midpoint;\n    }\n\n    // Process the midpoint element\n    if (length % 2 != 0) {\n        C[midpoint] = A[midpoint];\n        i++;\n    }\n\n    // Process elements after the midpoint\n    for (; i + svcntw() <= length; i += svcntw()) {\n        svuint16_t vecA = svld1_u16(pg, &A[i]);\n        svuint16_t vecB = svld1_u16(pg, &B[i]);\n        svuint16_t vecAND = svand_u16_z(pg, vecA, vecB);\n        svst1_u16(pg, &C[i], vecAND);\n    }\n\n    // Handle any remaining elements after the midpoint\n    if (i < length) {\n        svbool_t pg_remaining = svwhilelt_b16(i, length);\n        svuint16_t vecA = svld1_u16(pg_remaining, &A[i]);\n        svuint16_t vecB = svld1_u16(pg_remaining, &B[i]);\n        svuint16_t vecAND = svand_u16_z(pg_remaining, vecA, vecB);\n        svst1_u16(pg_remaining, &C[i], vecAND);\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    svbool_t pg = svptrue_b16();\n    size_t i = 0;\n\n    // Process elements before the midpoint\n    for (; i + svcntw() <= midpoint; i += svcntw()) {\n        svuint16_t vecA = svld1_u16(pg, &A[i]);\n        svuint16_t vecB = svld1_u16(pg, &B[i]);\n        svuint16_t vecXOR = sveor_u16_z(pg, vecA, vecB);\n        svst1_u16(pg, &C[i], vecXOR);\n    }\n\n    // Handle any remaining elements before the midpoint\n    if (i < midpoint) {\n        svbool_t pg_tail = svwhilelt_b16(i, midpoint);\n        svuint16_t vecA = svld1_u16(pg_tail, &A[i]);\n        svuint16_t vecB = svld1_u16(pg_tail, &B[i]);\n        svuint16_t vecXOR = sveor_u16_z(pg_tail, vecA, vecB);\n        svst1_u16(pg_tail, &C[i], vecXOR);\n        i = midpoint;\n    }\n\n    // Process the midpoint element\n    if (length % 2 != 0) {\n        C[midpoint] = A[midpoint];\n        i++;\n    }\n\n    // Process elements after the midpoint\n    for (; i + svcntw() <= length; i += svcntw()) {\n        svuint16_t vecA = svld1_u16(pg, &A[i]);\n        svuint16_t vecB = svld1_u16(pg, &B[i]);\n        svuint16_t vecAND = svand_u16_z(pg, vecA, vecB);\n        svst1_u16(pg, &C[i], vecAND);\n    }\n\n    // Handle any remaining elements after the midpoint\n    if (i < length) {\n        svbool_t pg_tail = svwhilelt_b16(i, length);\n        svuint16_t vecA = svld1_u16(pg_tail, &A[i]);\n        svuint16_t vecB = svld1_u16(pg_tail, &B[i]);\n        svuint16_t vecAND = svand_u16_z(pg_tail, vecA, vecB);\n        svst1_u16(pg_tail, &C[i], vecAND);\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    svbool_t pg = svptrue_b16();\n    size_t i = 0;\n\n    // Process elements before the midpoint\n    for (; i + svcntw() <= midpoint; i += svcntw()) {\n        svuint16_t vecA = svld1_u16(pg, &A[i]);\n        svuint16_t vecB = svld1_u16(pg, &B[i]);\n        svuint16_t vecXOR = sveor_u16_z(pg, vecA, vecB);\n        svst1_u16(pg, &C[i], vecXOR);\n    }\n\n    // Handle any remaining elements before the midpoint\n    if (i < midpoint) {\n        svbool_t pg_tail = svwhilelt_b16(i, midpoint);\n        svuint16_t vecA = svld1_u16(pg_tail, &A[i]);\n        svuint16_t vecB = svld1_u16(pg_tail, &B[i]);\n        svuint16_t vecXOR = sveor_u16_z(pg_tail, vecA, vecB);\n        svst1_u16(pg_tail, &C[i], vecXOR);\n        i = midpoint;\n    }\n\n    // Process the midpoint element\n    if (length % 2 != 0) {\n        C[midpoint] = A[midpoint];\n        i++;\n    }\n\n    // Process elements after the midpoint\n    for (; i + svcntw() <= length; i += svcntw()) {\n        svuint16_t vecA = svld1_u16(pg, &A[i]);\n        svuint16_t vecB = svld1_u16(pg, &B[i]);\n        svuint16_t vecAND = svand_u16_z(pg, vecA, vecB);\n        svst1_u16(pg, &C[i], vecAND);\n    }\n\n    // Handle any remaining elements after the midpoint\n    if (i < length) {\n        svbool_t pg_tail = svwhilelt_b16(i, length);\n        svuint16_t vecA = svld1_u16(pg_tail, &A[i]);\n        svuint16_t vecB = svld1_u16(pg_tail, &B[i]);\n        svuint16_t vecAND = svand_u16_z(pg_tail, vecA, vecB);\n        svst1_u16(pg_tail, &C[i], vecAND);\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    svbool_t pg = svptrue_b16();\n    size_t i = 0;\n\n    // Process elements before the midpoint\n    for (; i + svcntw() <= midpoint; i += svcntw()) {\n        svuint16_t vecA = svld1_u16(pg, &A[i]);\n        svuint16_t vecB = svld1_u16(pg, &B[i]);\n        svuint16_t vecXOR = sveor_u16_z(pg, vecA, vecB);\n        svst1_u16(pg, &C[i], vecXOR);\n    }\n\n    // Handle any remaining elements before the midpoint\n    if (i < midpoint) {\n        svbool_t pg_tail = svwhilelt_b16(i, midpoint);\n        svuint16_t vecA = svld1_u16(pg_tail, &A[i]);\n        svuint16_t vecB = svld1_u16(pg_tail, &B[i]);\n        svuint16_t vecXOR = sveor_u16_z(pg_tail, vecA, vecB);\n        svst1_u16(pg_tail, &C[i], vecXOR);\n        i = midpoint;\n    }\n\n    // Process the midpoint element\n    if (length % 2 != 0) {\n        C[midpoint] = A[midpoint];\n        i++;\n    }\n\n    // Process elements after the midpoint\n    for (; i + svcntw() <= length; i += svcntw()) {\n        svuint16_t vecA = svld1_u16(pg, &A[i]);\n        svuint16_t vecB = svld1_u16(pg, &B[i]);\n        svuint16_t vecAND = svand_u16_z(pg, vecA, vecB);\n        svst1_u16(pg, &C[i], vecAND);\n    }\n\n    // Handle any remaining elements after the midpoint\n    if (i < length) {\n        svbool_t pg_tail = svwhilelt_b16(i, length);\n        svuint16_t vecA = svld1_u16(pg_tail, &A[i]);\n        svuint16_t vecB = svld1_u16(pg_tail, &B[i]);\n        svuint16_t vecAND = svand_u16_z(pg_tail, vecA, vecB);\n        svst1_u16(pg_tail, &C[i], vecAND);\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    while (i < total_elements) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        svfloat32_t va = svld1_f32(pg, &A[i]);\n        svfloat32_t vb = svld1_f32(pg, &B[i]);\n        svfloat32_t vc = svld1_f32(pg, &C[i]);\n        svfloat32_t vd = svld1_f32(pg, &D[i]);\n\n        svuint8_t vcond1 = svld1_u8(pg, (const uint8_t*)&cond1[i]);\n        svuint8_t vcond2 = svld1_u8(pg, (const uint8_t*)&cond2[i]);\n\n        svbool_t pcond1 = svcmpeq_n_u8(pg, vcond1, 1);\n        svbool_t pcond2 = svcmpeq_n_u8(pg, vcond2, 1);\n\n        svbool_t pcond1_true_cond2_true = svand_b_z(pg, pcond1, pcond2);\n        svbool_t pcond1_true_cond2_false = svand_b_z(pg, pcond1, svnot_b_z(pg, pcond2));\n        svbool_t pcond1_false_cond2_true = svand_b_z(pg, svnot_b_z(pg, pcond1), pcond2);\n\n        svfloat32_t vout = svsel_f32(pcond1_true_cond2_true, va, vb);\n        vout = svsel_f32(pcond1_true_cond2_false, vout, vc);\n        vout = svsel_f32(pcond1_false_cond2_true, vout, vd);\n\n        svst1_f32(pg, &out[i], vout);\n\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    while (i < total_elements) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        svfloat32_t va = svld1(pg, &A[i]);\n        svfloat32_t vb = svld1(pg, &B[i]);\n        svfloat32_t vc = svld1(pg, &C[i]);\n        svfloat32_t vd = svld1(pg, &D[i]);\n\n        svuint8_t vcond1 = svld1_u8(pg, (const uint8_t*)&cond1[i]);\n        svuint8_t vcond2 = svld1_u8(pg, (const uint8_t*)&cond2[i]);\n\n        svbool_t pcond1 = svcmpeq_n_u8(pg, vcond1, 1);\n        svbool_t pcond2 = svcmpeq_n_u8(pg, vcond2, 1);\n\n        svbool_t pcond1_true_cond2_true = svand_b32(pcond1, pcond2);\n        svbool_t pcond1_true_cond2_false = svand_b32(pcond1, svnot_b32(pcond2));\n        svbool_t pcond1_false_cond2_true = svand_b32(svnot_b32(pcond1), pcond2);\n\n        svfloat32_t vout = svsel_f32(pcond1_true_cond2_true, va, vb);\n        vout = svsel_f32(pcond1_true_cond2_false, vout, vc);\n        vout = svsel_f32(pcond1_false_cond2_true, vout, vd);\n\n        svst1(pg, &out[i], vout);\n\n        i += svcntb();\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    while (i < total_elements) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        svfloat32_t va = svld1(pg, &A[i]);\n        svfloat32_t vb = svld1(pg, &B[i]);\n        svfloat32_t vc = svld1(pg, &C[i]);\n        svfloat32_t vd = svld1(pg, &D[i]);\n\n        svuint8_t vcond1 = svld1_u8(pg, (const uint8_t*)&cond1[i]);\n        svuint8_t vcond2 = svld1_u8(pg, (const uint8_t*)&cond2[i]);\n\n        svbool_t pcond1 = svcmpeq_n_u8(pg, vcond1, 1);\n        svbool_t pcond2 = svcmpeq_n_u8(pg, vcond2, 1);\n\n        svbool_t pcond1_true_cond2_true = svand_b32(pcond1, pcond2);\n        svbool_t pcond1_true_cond2_false = svand_b32(pcond1, svnot_b32(pcond2));\n        svbool_t pcond1_false_cond2_true = svand_b32(svnot_b32(pcond1), pcond2);\n\n        svfloat32_t vout = svsel(pg, pcond1_true_cond2_true, va, vb);\n        vout = svsel(pg, pcond1_true_cond2_false, vout, vc);\n        vout = svsel(pg, pcond1_false_cond2_true, vout, vd);\n\n        svst1(pg, &out[i], vout);\n\n        i += svcntb();\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    while (i < total_elements) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        svfloat32_t va = svld1_f32(pg, &A[i]);\n        svfloat32_t vb = svld1_f32(pg, &B[i]);\n        svfloat32_t vc = svld1_f32(pg, &C[i]);\n        svfloat32_t vd = svld1_f32(pg, &D[i]);\n\n        svbool_t pcond1 = svld1_b32(pg, (const uint32_t*)&cond1[i]);\n        svbool_t pcond2 = svld1_b32(pg, (const uint32_t*)&cond2[i]);\n\n        svbool_t pcond1_and_cond2 = svand_b_z(pg, pcond1, pcond2);\n        svbool_t pcond1_and_not_cond2 = svand_b_z(pg, pcond1, svnot_b_z(pg, pcond2));\n        svbool_t pnot_cond1_and_cond2 = svand_b_z(pg, svnot_b_z(pg, pcond1), pcond2);\n\n        svfloat32_t vout = svsel_f32(pcond1_and_cond2, va, vb);\n        vout = svsel_f32(pcond1_and_not_cond2, vout, vc);\n        vout = svsel_f32(pnot_cond1_and_cond2, vout, vd);\n\n        svst1_f32(pg, &out[i], vout);\n\n        i += svcntb() / sizeof(float);\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    while (i < total_elements) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        svfloat32_t vecA = svld1(pg, &A[i]);\n        svfloat32_t vecB = svld1(pg, &B[i]);\n        svfloat32_t vecC = svld1(pg, &C[i]);\n        svfloat32_t vecD = svld1(pg, &D[i]);\n\n        svuint8_t vecCond1 = svld1_u8(pg, (const uint8_t*)&cond1[i]);\n        svuint8_t vecCond2 = svld1_u8(pg, (const uint8_t*)&cond2[i]);\n\n        svbool_t cond1_true = svcmpne_n_u8(pg, vecCond1, 0);\n        svbool_t cond2_true = svcmpne_n_u8(pg, vecCond2, 0);\n\n        svbool_t both_true = svand_b_z(pg, cond1_true, cond2_true);\n        svbool_t cond1_true_cond2_false = svand_b_z(pg, cond1_true, svnot_b_z(pg, cond2_true));\n        svbool_t cond1_false_cond2_true = svand_b_z(pg, svnot_b_z(pg, cond1_true), cond2_true);\n\n        svfloat32_t result = svsel_f32(both_true, vecA, vecB);\n        result = svsel_f32(cond1_true_cond2_false, result, vecC);\n        result = svsel_f32(cond1_false_cond2_true, result, vecD);\n\n        svst1(pg, &out[i], result);\n\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    while (i < total_elements) {\n        svuint32_t vec_a = svld1_u32(svulbdl(svptrue_b32(), &A[i]));\n        svuint32_t vec_count = svcnt_i32(vec_a);\n\n        size_t vl = svcntw();\n        if (i + vl > total_elements) {\n            vl = total_elements - i;\n        }\n\n        svst1_u8(svbool_t pg = svptrue_b8(), &out[i], svxtn_u16(svadd_u8_x(svcvt_u8_u16(svunpklo_u8(svadd_u8_x(svcvt_u8_u16(svunpklo_u8(vec_count)), svcvt_u8_u16(svunpkhi_u8(vec_count))))), svcvt_u8_u16(svunpkhi_u8(svadd_u8_x(svcvt_u8_u16(svunpklo_u8(vec_count)), svcvt_u8_u16(svunpkhi_u8(vec_count)))))));\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    while (i < total_elements) {\n        svuint32_t vec_a = svld1_u32(svuloadl(svptrue_b32(), &A[i]));\n        svuint32_t vec_count = svcnt_i32(vec_a);\n\n        // Convert the count from uint32 to uint8\n        svuint8_t vec_count_u8 = svcvt_u8_u32_z(svptrue_b8(), vec_count);\n\n        // Store the result\n        svst1_u8(svuloadl(svptrue_b8()), &out[i], vec_count_u8);\n\n        i += svcntb();\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    while (i < total_elements) {\n        svuint32_t vec_a = svld1_u32(svuloadl(svptrue_b32(), &A[i]));\n        svuint32_t vec_count = svcnt_i32(vec_a);\n\n        // Convert the count from uint32 to uint8\n        svuint8_t vec_count_u8 = svcvt_u8_u32_z(svptrue_b8(), vec_count);\n\n        // Store the result\n        svst1_u8(svuloadl(svptrue_b8()), &out[i], vec_count_u8);\n\n        i += svcntb();\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    while (i < total_elements) {\n        svuint32_t vec_a = svld1_u32(svulbdl(svptrue_b32(), &A[i]));\n        svuint32_t vec_count = svcntb_u32(vec_a);\n\n        size_t vl = svcntw();\n        if (i + vl > total_elements) {\n            vl = total_elements - i;\n        }\n\n        svst1_u8(svulbdl(svptrue_b8(), &out[i]), svxtnb_u16(svaddv_u32_z(svptrue_b16(), svdup_n_u16(0), svreinterpret_u16_u32(vec_count))));\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    while (i < total_elements) {\n        svuint32_t vec_a = svld1_u32(svulbdl(svptrue_b32(), &A[i]));\n        svuint32_t vec_count = svcnt_i32(vec_a);\n\n        size_t vl = svcntw();\n        size_t j = 0;\n        while (j < vl && i + j < total_elements) {\n            out[i + j] = (uint8_t)svnth_u32(vec_count, j);\n            j++;\n        }\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    while (i < total_elements) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        svint32_t vec_a = svld1_s32(pg, &A[i]);\n        svint32_t zero = svdup_s32(0);\n        svint32_t three = svdup_s32(3);\n        svbool_t cond = svcmpeq_n_s32(svand_s32_z(pg, vec_a, three), zero);\n        svint32_t abs_vec_a = svabs_s32_z(pg, vec_a);\n        svint32_t result = svsel_s32(pg, cond, abs_vec_a, vec_a);\n        svst1_s32(pg, &B[i], result);\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    while (i < total_elements) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        svint32_t vec_a = svld1_s32(pg, &A[i]);\n        svint32_t vec_mod = svmod_s32_z(pg, vec_a, svdup_s32(3));\n        svbool_t cond = sveor_b_z(pg, svcmpeq_n_s32(pg, vec_mod, 0), svpfalse_b32());\n        svint32_t vec_abs = svabs_s32_z(pg, vec_a);\n        svint32_t result = svsel_s32(pg, cond, vec_a, vec_abs);\n        svst1_s32(pg, &B[i], result);\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    svbool_t pg;\n    svint32_t vec_a, vec_b, vec_three, vec_zero, vec_abs;\n\n    for (size_t i = 0; i < total_elements; i += svcntw()) {\n        pg = svwhilelt_b32(i, total_elements);\n        vec_a = svld1_s32(pg, &A[i]);\n        vec_three = svdup_s32(3);\n        vec_zero = svdup_s32(0);\n\n        // Check if elements are divisible by 3\n        svbool_t divisible_by_three = svcmpeq_s32(pg, svand_s32_z(pg, vec_a, vec_three), vec_zero);\n\n        // Calculate absolute values\n        vec_abs = svabs_s32_z(pg, vec_a);\n\n        // Select between original and absolute values based on condition\n        vec_b = svsel_s32(divisible_by_three, vec_abs, vec_a);\n\n        svst1_s32(pg, &B[i], vec_b);\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    svbool_t pg;\n    svint32_t vec_a, vec_b, vec_zero, vec_three;\n\n    for (size_t i = 0; i < total_elements; i += svcntw()) {\n        pg = svwhilelt_b32(i, total_elements);\n        vec_a = svld1_s32(pg, &A[i]);\n        vec_zero = svdup_s32(0);\n        vec_three = svdup_s32(3);\n\n        svbool_t cond = svcmpeq_n_s32(pg, svmod_s32_z(pg, vec_a, vec_three), 0);\n        vec_b = svsel_s32(pg, cond, svabs_s32_z(pg, vec_a), vec_a);\n\n        svst1_s32(pg, &B[i], vec_b);\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    while (i < total_elements) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        svint32_t vec_a = svld1_s32(pg, &A[i]);\n        svint32_t zero = svdup_s32(0);\n        svint32_t three = svdup_s32(3);\n        svbool_t cond = svcmpeq_n_s32(svand_s32_z(pg, vec_a, three), zero);\n        svint32_t abs_vec_a = svabs_s32_z(pg, vec_a);\n        svint32_t result = svsel_s32(pg, cond, abs_vec_a, vec_a);\n        svst1_s32(pg, &B[i], result);\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    svbool_t pg;\n    svuint32_t sv_src, sv_dst, sv_ones, sv_rotated, sv_negated;\n    uint32_t ones = 0xF; // Low 4 bits all 1\n\n    for (size_t i = 0; i < length; i += svcntw()) {\n        size_t vl = svmin(svcntw(), length - i);\n        pg = svwhilelt_b32(0, vl);\n\n        sv_src = svld1(pg, &src[i]);\n        sv_ones = svdup_n_u32(ones);\n\n        // Check if low 4 bits are all 1\n        svbool_t cond = svcmpeq_m(pg, svand_m(pg, sv_src, sv_ones), sv_ones);\n\n        // Rotate right by rotate_bits\n        sv_rotated = svrshl_m(pg, sv_src, svdup_n_u32(rotate_bits));\n\n        // Bitwise negation\n        sv_negated = sveor_m(pg, sv_src, svdup_n_u32(~0));\n\n        // Conditional select\n        sv_dst = svsel_m(pg, cond, sv_rotated, sv_negated);\n\n        svst1(pg, &dst[i], sv_dst);\n    }\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t vl = svcntw();\n    svbool_t pg = svwhilelt_b32(0, length);\n\n    do {\n        svuint32_t vec_src = svld1_u32(pg, src);\n        svuint32_t low_4_bits = svand_u32_z(pg, vec_src, svdup_u32(0xF));\n        svbool_t cond = sveq_u32(pg, low_4_bits, svdup_u32(0xF));\n\n        svuint32_t rotated = svlsl_n_u32_z(pg, vec_src, 32 - rotate_bits);\n        svuint32_t negated = svmvn_u32_z(pg, vec_src);\n\n        svuint32_t result = svsel_u32(pg, cond, rotated, negated);\n\n        svst1_u32(pg, dst, result);\n\n        src += vl;\n        dst += vl;\n        length -= vl;\n        pg = svwhilelt_b32(0, length);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t vl = svcntw();\n    svbool_t pg = svwhilelt_b32(0, length);\n\n    do {\n        svuint32_t vec_src = svld1_u32(pg, src);\n        svuint32_t low_4_bits = svand_u32_z(pg, vec_src, svdup_u32(0xF));\n        svbool_t cond = sveq_u32_z(pg, low_4_bits, svdup_u32(0xF));\n\n        svuint32_t rotated = svlsl_n_u32_z(cond, vec_src, 32 - rotate_bits);\n        svuint32_t negated = svmvn_u32_z(pg, vec_src);\n\n        svuint32_t result = svsel_u32(cond, rotated, negated);\n        svst1_u32(pg, dst, result);\n\n        src += vl;\n        dst += vl;\n        length -= vl;\n        pg = svwhilelt_b32(0, length);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    size_t vl = svcntw();\n    svbool_t pg = svwhilelt_b32(0, length);\n\n    do {\n        svuint32_t vec_src = svld1_u32(pg, src);\n        svuint32_t low_4_bits = svand_u32_z(pg, vec_src, svdup_u32(0xF));\n        svbool_t cond = sveq_u32(pg, low_4_bits, svdup_u32(0xF));\n\n        svuint32_t rotated = svlsl_n_u32_z(cond, vec_src, 32 - rotate_bits);\n        svuint32_t negated = svmvn_u32_z(svnot_b_z(pg, cond), vec_src);\n\n        svuint32_t result = svsel_u32(cond, rotated, negated);\n        svst1_u32(pg, dst, result);\n\n        src += vl;\n        dst += vl;\n        length -= vl;\n        pg = svwhilelt_b32(0, length);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    svbool_t pg;\n    svuint32_t sv_src, sv_dst, sv_ones, sv_rotated, sv_negated;\n    size_t vl;\n\n    do {\n        vl = svld1_bf16(pg, &length);\n        pg = svwhilelt_bf16(0, length, vl);\n\n        sv_src = svld1_u32(pg, src);\n        sv_ones = svdup_u32(0xF); // Low 4 bits set to 1\n\n        // Check if low 4 bits are all 1\n        svbool_t cond = svcmpeq_n_u32(pg, svand_u32_z(pg, sv_src, sv_ones), 0xF);\n\n        // Rotate right by rotate_bits\n        sv_rotated = svrshl_u32_z(pg, sv_src, svdup_n_s32(-rotate_bits));\n\n        // Bitwise negation\n        sv_negated = sveor_u32_z(pg, sv_src, svdup_u32(~0));\n\n        // Conditional select\n        sv_dst = svsel_u32(pg, cond, sv_rotated, sv_negated);\n\n        svst1_u32(pg, dst, sv_dst);\n\n        src += vl;\n        dst += vl;\n        length -= vl;\n    } while (svptest_any(svptrue_b(), pg));\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    svfloat32_t vecA, vecB, vecEpsilon, vecZero, vecOne, vecNegOne;\n    svint8_t vecOut;\n\n    vecEpsilon = svdup_f32(epsilon);\n    vecZero = svdup_f32(0.0f);\n    vecOne = svdup_s8(1);\n    vecNegOne = svdup_s8(-1);\n\n    do {\n        size_t vl = svcntw();\n        if (i + vl > length) {\n            vl = length - i;\n        }\n        pg = svwhilelt_b32(i, length);\n\n        vecA = svld1(pg, &A[i]);\n        vecB = svld1(pg, &B[i]);\n\n        svfloat32_t diff = svsub_f32_m(pg, vecA, vecB);\n        svfloat32_t absDiff = svabs_f32_m(pg, diff);\n        svfloat32_t absEpsilon = svabs_f32_m(pg, vecEpsilon);\n\n        svbool_t gtMask = svcmpgt_f32(pg, absDiff, absEpsilon);\n        svbool_t ltMask = svcmplt_f32(pg, absDiff, absEpsilon);\n\n        vecOut = svdup_s8_z(pg, 0);\n        vecOut = svsel_s8(gtMask, vecOne, vecOut);\n        vecOut = svsel_s8(svandnot_b_z(pg, ltMask, gtMask), vecNegOne, vecOut);\n\n        svst1(pg, &out[i], vecOut);\n\n        i += vl;\n    } while (i < length);\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    svfloat32_t vecA, vecB, vecEpsilon, vecZero, vecOne, vecNegOne;\n    svint8_t vecOut;\n\n    vecEpsilon = svdup_f32(epsilon);\n    vecZero = svdup_f32(0.0f);\n    vecOne = svdup_s8(1);\n    vecNegOne = svdup_s8(-1);\n\n    do {\n        size_t vl = svcntw();\n        if (i + vl > length) {\n            vl = length - i;\n        }\n        pg = svwhilelt_b32(i, length);\n\n        vecA = svld1/pg_f32(pg, &A[i]);\n        vecB = svld1/pg_f32(pg, &B[i]);\n\n        svfloat32_t diff = svsub_f32_z(pg, vecA, vecB);\n        svfloat32_t absDiff = svabs_f32_z(pg, diff);\n        svfloat32_t absEpsilon = svabs_f32_z(pg, vecEpsilon);\n\n        svbool_t gtMask = svcmpgt_f32(pg, absDiff, absEpsilon);\n        svbool_t ltMask = svcmplt_f32(pg, absDiff, absEpsilon);\n\n        vecOut = svdup_s8_z(pg, 0);\n        vecOut = svsel_s8(pg, gtMask, svsel_s8(pg, svcmplt_f32(pg, diff, vecZero), vecNegOne, vecOne), vecOut);\n\n        svst1/pg_s8(pg, &out[i], vecOut);\n\n        i += vl;\n    } while (i < length);\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    svfloat32_t vecA, vecB, vecEpsilon, vecZero, vecOne, vecNegOne;\n    svint8_t vecOut;\n\n    vecEpsilon = svdup_f32(epsilon);\n    vecZero = svdup_f32(0.0f);\n    vecOne = svdup_s8(1);\n    vecNegOne = svdup_s8(-1);\n\n    do {\n        size_t vl = svcntw();\n        if (i + vl > length) {\n            vl = length - i;\n        }\n        pg = svwhilelt_b32(i, length);\n\n        vecA = svld1(pg, &A[i]);\n        vecB = svld1(pg, &B[i]);\n\n        svfloat32_t diff = svsub_f32_z(pg, vecA, vecB);\n        svfloat32_t absDiff = svabs_f32_z(pg, diff);\n        svfloat32_t absEpsilon = svabs_f32_z(pg, vecEpsilon);\n\n        svbool_t gtMask = svcmpgt_f32(pg, absDiff, absEpsilon);\n        svbool_t ltMask = svcmplt_f32(pg, absDiff, absEpsilon);\n\n        svint8_t result = svdup_z(pg, (int8_t)0);\n        result = svsel_s8(gtMask, vecOne, result);\n        result = svsel_s8(svandnot_b_z(pg, ltMask, gtMask), vecNegOne, result);\n\n        svst1(pg, &out[i], result);\n\n        i += vl;\n    } while (i < length);\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    svfloat32_t vecA, vecB, vecEpsilon, vecZero, vecOne, vecNegOne;\n    svint8_t vecOut;\n\n    vecEpsilon = svdup_f32(epsilon);\n    vecZero = svdup_f32(0.0f);\n    vecOne = svdup_s8(1);\n    vecNegOne = svdup_s8(-1);\n\n    do {\n        size_t vl = svcntw();\n        if (i + vl > length) {\n            vl = length - i;\n        }\n        pg = svwhilelt_b32(i, length);\n\n        vecA = svld1/pg_f32(pg, &A[i]);\n        vecB = svld1/pg_f32(pg, &B[i]);\n\n        svfloat32_t diff = svsub_f32_z(pg, vecA, vecB);\n        svfloat32_t absDiff = svabs_f32_z(pg, diff);\n        svfloat32_t absEpsilon = svabs_f32_z(pg, vecEpsilon);\n\n        svbool_t gtMask = svcmpgt_f32(pg, absDiff, absEpsilon);\n        svbool_t ltMask = svcmplt_f32(pg, absDiff, absEpsilon);\n\n        vecOut = svdup_s8_z(pg, 0);\n        vecOut = svsel_s8(pg, gtMask, svsel_s8(pg, svcmplt_f32(pg, diff, vecZero), vecNegOne, vecOne), vecOut);\n\n        svst1/pg_s8(pg, &out[i], vecOut);\n\n        i += vl;\n    } while (i < length);\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    svfloat32_t vecA, vecB, vecEpsilon, vecZero, vecOne, vecNegOne;\n    svint8_t vecOut;\n\n    vecEpsilon = svdup_f32(epsilon);\n    vecZero = svdup_f32(0.0f);\n    vecOne = svdup_s8(1);\n    vecNegOne = svdup_s8(-1);\n\n    do {\n        size_t vl = svcntw();\n        if (i + vl > length) {\n            vl = length - i;\n        }\n        pg = svwhilelt_b32(i, length);\n\n        vecA = svld1(pg, &A[i]);\n        vecB = svld1(pg, &B[i]);\n\n        svfloat32_t diff = svsub_f32_z(pg, vecA, vecB);\n        svfloat32_t absDiff = svabs_f32_z(pg, diff);\n        svfloat32_t absEpsilon = svabs_f32_z(pg, vecEpsilon);\n\n        svbool_t gtMask = svcmpgt_f32(pg, diff, absEpsilon);\n        svbool_t ltMask = svcmplt_f32(pg, diff, svneg_f32_z(pg, absEpsilon));\n\n        vecOut = svdup_s8_z(pg, 0);\n        vecOut = svsel_s8(gtMask, vecOne, vecOut);\n        vecOut = svsel_s8(ltMask, vecNegOne, vecOut);\n\n        svst1_s8(pg, &out[i], vecOut);\n\n        i += vl;\n    } while (i < length);\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    svbool_t pg;\n    svfloat32_t va;\n    svint32_t vb;\n    const int32_t int32_max = INT32_MAX;\n    const int32_t int32_min = INT32_MIN;\n\n    for (size_t i = 0; i < size; i += svcntw()) {\n        pg = svwhilelt_b32(i, size);\n        va = svld1/pg_f32(pg, &A[i]);\n        va = svmax_f32_z(pg, va, svdup_n_f32(int32_min));\n        va = svmin_f32_z(pg, va, svdup_n_f32(int32_max));\n        vb = svcvt_s32_f32_z(pg, va);\n        svst1/pg_s32(pg, &B[i], vb);\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    svbool_t pg;\n    svfloat32_t vec_a;\n    svint32_t vec_b;\n    const int32_t int32_max = INT32_MAX;\n    const int32_t int32_min = INT32_MIN;\n\n    size_t i = 0;\n    while (svcntw(svptrue_b32()) <= (size - i)) {\n        pg = svwhilelt_b32(i, size);\n        vec_a = svld1(pg, &A[i]);\n        vec_b = svcvt_s32_f32_z(pg, vec_a);\n        vec_b = svmax_z(pg, vec_b, svdup_n_s32(int32_min));\n        vec_b = svmin_z(pg, vec_b, svdup_n_s32(int32_max));\n        svst1(pg, &B[i], vec_b);\n        i += svcntw(svptrue_b32());\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    svbool_t pg;\n    svfloat32_t vec_a;\n    svint32_t vec_b;\n    const int32_t int32_max = INT32_MAX;\n    const int32_t int32_min = INT32_MIN;\n    svint32_t max_val = svdup_s32(int32_max);\n    svint32_t min_val = svdup_s32(int32_min);\n\n    for (size_t i = 0; i < size; i += svcntw()) {\n        pg = svwhilelt_b32(i, size);\n        vec_a = svld1/pg_f32(pg, &A[i]);\n        vec_b = svcvt_s32_f32_z(pg, vec_a);\n        vec_b = svmax_z(pg, vec_b, min_val);\n        vec_b = svmin_z(pg, vec_b, max_val);\n        svst1/pg_s32(pg, &B[i], vec_b);\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    svbool_t pg;\n    svfloat32_t vec_a;\n    svint32_t vec_b;\n    const int32_t int32_max = INT32_MAX;\n    const int32_t int32_min = INT32_MIN;\n\n    size_t i = 0;\n    for (; i <= size - svcntw(); i += svcntw()) {\n        pg = svwhilelt_b32(i, size);\n        vec_a = svld1(pg, &A[i]);\n        vec_b = svcvt_s32_f32_z(pg, vec_a);\n        vec_b = svmax_z(pg, vec_b, svdup_s32(int32_min));\n        vec_b = svmin_z(pg, vec_b, svdup_s32(int32_max));\n        svst1(pg, &B[i], vec_b);\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        float val = A[i];\n        if (val > int32_max) {\n            B[i] = int32_max;\n        } else if (val < int32_min) {\n            B[i] = int32_min;\n        } else {\n            B[i] = (int32_t)val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    svbool_t pg;\n    svfloat32_t vec_a;\n    svint32_t vec_b;\n    const int32_t int32_max = INT32_MAX;\n    const int32_t int32_min = INT32_MIN;\n\n    size_t i = 0;\n    for (; i <= size - svcntw(); i += svcntw()) {\n        pg = svwhilelt_b32(i, size);\n        vec_a = svld1(pg, &A[i]);\n        vec_b = svcvt_s32_f32_z(pg, vec_a);\n        vec_b = svmax_z(pg, vec_b, svdup_s32(int32_min));\n        vec_b = svmin_z(pg, vec_b, svdup_s32(int32_max));\n        svst1(pg, &B[i], vec_b);\n    }\n\n    for (; i < size; ++i) {\n        float val = A[i];\n        if (val > int32_max) {\n            B[i] = int32_max;\n        } else if (val < int32_min) {\n            B[i] = int32_min;\n        } else {\n            B[i] = (int32_t)val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    svbool_t pg;\n    svint32_t vec_int32;\n    svfloat32_t vec_float32;\n    float scale_factor = static_cast<float>(scale);\n\n    for (size_t i = 0; i < size; i += svcntw()) {\n        pg = svwhilelt_b32(i, size);\n        vec_int32 = svld1_s32(pg, &A[i]);\n        vec_float32 = svcvt_f32_s32_z(pg, vec_int32);\n        vec_float32 = svmul_f32_z(pg, vec_float32, svdup_f32(scale_factor));\n        svst1_f32(pg, &B[i], vec_float32);\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    svbool_t pg;\n    svint32_t vec_int32;\n    svfloat32_t vec_float32;\n    float scale_factor = static_cast<float>(scale);\n\n    for (size_t i = 0; i < size; i += svcntw()) {\n        pg = svwhilelt_b32(i, size);\n        vec_int32 = svld1_s32(pg, &A[i]);\n        vec_float32 = svcvt_f32_s32_z(pg, vec_int32);\n        vec_float32 = svmul_f32_z(pg, vec_float32, svdup_n_f32(scale_factor));\n        svst1_f32(pg, &B[i], vec_float32);\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    svbool_t pg;\n    svint32_t vec_int32;\n    svfloat32_t vec_float32;\n    float scale_factor = static_cast<float>(scale);\n\n    for (size_t i = 0; i < size; i += svcntw()) {\n        pg = svwhilelt_b32(i, size);\n        vec_int32 = svld1_s32(pg, &A[i]);\n        vec_float32 = svcvt_f32_s32_z(pg, vec_int32);\n        vec_float32 = svmul_f32_z(pg, vec_float32, svdup_f32(scale_factor));\n        svst1_f32(pg, &B[i], vec_float32);\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    svbool_t pg;\n    svint32_t vec_int32;\n    svfloat32_t vec_float32;\n    float scale_factor = static_cast<float>(scale);\n\n    for (size_t i = 0; i < size; i += svcntw()) {\n        pg = svwhilelt_b32(i, size);\n        vec_int32 = svld1_s32(pg, &A[i]);\n        vec_float32 = svcvt_f32_s32_z(pg, vec_int32);\n        vec_float32 = svmul_f32_z(pg, vec_float32, svdup_f32(scale_factor));\n        svst1_f32(pg, &B[i], vec_float32);\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    svbool_t pg;\n    svint32_t va;\n    svfloat32_t vb;\n    float scale_factor = (float)scale;\n\n    for (size_t i = 0; i < size; i += svcntw()) {\n        pg = svwhilelt_b32(i, size);\n        va = svld1_s32(pg, &A[i]);\n        vb = svmul_f32_z(pg, svreinterpret_f32_s32(va), scale_factor);\n        svst1_f32(pg, &B[i], vb);\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    svbool_t pg;\n    svfloat32_t vecA, vecB, vecResult;\n\n    do {\n        pg = svwhilelt_b32(i, size);\n        vecA = svld1/pg_f32(pg, &A[i]);\n        vecB = svld1/pg_f32(pg, &B[i]);\n        vecResult = svdiv_x_f32_z(pg, vecA, vecB);\n        svst1/pg_s32(pg, &C[i], svcvt_s32_f32_z(pg, vecResult));\n        i += svcntb() / sizeof(float);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    svbool_t pg;\n    svfloat32_t vecA, vecB, vecResult;\n\n    do {\n        pg = svwhilelt_b32(i, size);\n        vecA = svld1/pg_f32(pg, &A[i]);\n        vecB = svld1/pg_f32(pg, &B[i]);\n        vecResult = svdiv_x_f32_z(pg, vecA, vecB);\n        svst1/pg_s32(pg, &C[i], svcvt_s32_f32_z(pg, vecResult));\n        i += svcntb() / sizeof(float);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    svbool_t pg;\n\n    do {\n        // Determine the number of elements to process in this iteration\n        size_t vl = svmin_z(svptrue_b32(), size - i);\n\n        // Load vectors from A and B\n        svfloat32_t vecA = svld1_f32(pg, &A[i]);\n        svfloat32_t vecB = svld1_f32(pg, &B[i]);\n\n        // Perform element-wise division\n        svfloat32_t vecResult = svdiv_f32_z(pg, vecA, vecB);\n\n        // Round to the nearest integer\n        svint32_t vecRounded = svcvt_s32_f32_z(pg, svrinta_f32_x(pg, vecResult));\n\n        // Store the result in C\n        svst1_s32(pg, &C[i], vecRounded);\n\n        // Move to the next chunk of data\n        i += vl;\n    } while (i < size);\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    svbool_t pg;\n    svfloat32_t vecA, vecB, vecResult;\n\n    do {\n        pg = svwhilelt_b32(i, size);\n        vecA = svld1/pg_f32(pg, &A[i]);\n        vecB = svld1/pg_f32(pg, &B[i]);\n        vecResult = svdiv_x_f32_z(pg, vecA, vecB);\n        svst1/pg_s32(pg, &C[i], svcvt_s32_f32_z(pg, vecResult));\n        i += svcntb() / sizeof(float);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    svbool_t pg;\n    svfloat32_t vecA, vecB, vecResult;\n\n    do {\n        pg = svwhilelt_b32(i, size);\n        vecA = svld1/pg_f32(pg, &A[i]);\n        vecB = svld1/pg_f32(pg, &B[i]);\n        vecResult = svcvtf_s32_f32_z(pg, svdiv_f32_z(pg, vecA, vecB));\n        svst1/pg_s32(pg, &C[i], vecResult);\n        i += svcntb() / sizeof(float);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    svbool_t pg;\n    svfloat32_t max_float = svdup_f32(FLT_MAX);\n    svfloat32_t min_float = svdup_f32(-FLT_MAX);\n\n    for (size_t i = 0; i < size; i += svcntd()) {\n        pg =svptrue_b32();\n        svfloat64_t va = svld1(pg, &A[i]);\n        svfloat32_t vb = svcvt_f32_f64_x(pg, va);\n\n        svbool_t gt_max = svcmpgt(pg, vb, max_float);\n        svbool_t lt_min = svcmplt(pg, vb, min_float);\n\n        vb = svsel_f32(gt_max, max_float, vb);\n        vb = svsel_f32(lt_min, min_float, vb);\n\n        svst1(pg, &B[i], vb);\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    svbool_t pg;\n    svfloat32_t max_float = svdup_f32(FLT_MAX);\n    svfloat32_t min_float = svdup_f32(-FLT_MAX);\n\n    for (size_t i = 0; i < size; i += svcntd()) {\n        pg =svptrue_b64();\n        svfloat64_t vec_double = svld1(pg, &A[i]);\n        svfloat32_t vec_float = svcvt_f32_f64_z(pg, vec_double);\n        vec_float = svmax_f32_z(pg, vec_float, min_float);\n        vec_float = svmin_f32_z(pg, vec_float, max_float);\n        svst1(pg, &B[i], vec_float);\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg;\n    svfloat32_t max_float = svdup_f32(FLT_MAX);\n    svfloat32_t min_float = svdup_f32(-FLT_MAX);\n\n    do {\n        size_t count = svcntd();\n        if (i + count > size) {\n            count = size - i;\n            pg = svwhilelt_b64(i, size);\n        } else {\n            pg = svptrue_b64();\n        }\n\n        svfloat64_t vec_double = svld1(pg, &A[i]);\n        svfloat32_t vec_float = svcvt_f32_f64_z(pg, vec_double);\n        vec_float = svmax_f32_z(pg, vec_float, min_float);\n        vec_float = svmin_f32_z(pg, vec_float, max_float);\n        svst1(pg, &B[i], vec_float);\n\n        i += count;\n    } while (i < size);\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg;\n    svfloat32_t max_float = svdup_f32(FLT_MAX);\n    svfloat32_t min_float = svdup_f32(-FLT_MAX);\n\n    do {\n        size_t count = svcntd();\n        if (i + count > size) {\n            count = size - i;\n            pg = svwhilelt_b64(i, size);\n        } else {\n            pg = svptrue_b64();\n        }\n\n        svfloat64_t vec_double = svld1(pg, &A[i]);\n        svfloat32_t vec_float = svcvt_f32_f64_z(pg, vec_double);\n        vec_float = svmax_f32_z(pg, vec_float, min_float);\n        vec_float = svmin_f32_z(pg, vec_float, max_float);\n        svst1(pg, &B[i], vec_float);\n\n        i += count;\n    } while (i < size);\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg;\n    svfloat32_t max_float = svdup_f32(FLT_MAX);\n    svfloat32_t min_float = svdup_f32(-FLT_MAX);\n\n    do {\n        pg = svwhilelt_b64(i, size);\n        svfloat64_t vec_double = svld1/pg_f64(pg, &A[i]);\n        svfloat32_t vec_float = svcvt_f32_f64_z(pg, vec_double);\n        svbool_t gt_max = svcmpgt_f32(pg, vec_float, max_float);\n        svbool_t lt_min = svcmplt_f32(pg, vec_float, min_float);\n        vec_float = svsel_f32(gt_max, max_float, vec_float);\n        vec_float = svsel_f32(lt_min, min_float, vec_float);\n        svst1/pg_f32(pg, &B[i], vec_float);\n        i += svcntb() / sizeof(float);\n    } while (svptest_any(svptrue_b64(), pg));\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg;\n    svint16_t vec16;\n    svint32_t vec32;\n\n    for (; i <= size - svcntw(); i += svcntw()) {\n        pg = svwhilelt_b32(i, size);\n        vec16 = svld1_s16(pg, &A[i]);\n        vec32 = svshl_z(pg, svdup_n_s32(0), svreinterpret_s32_s16(vec16));\n        svst1_s32(pg, &B[i], vec32);\n    }\n\n    for (; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg;\n    svint16_t vec16;\n    svint32_t vec32;\n\n    for (; i <= size - svcntw(); i += svcntw()) {\n        pg = svwhilelt_b32(i, size);\n        vec16 = svld1_s16(pg, &A[i]);\n        vec32 = svshl_z(pg, svdup_n_s32(0), svreinterpret_s32_s16(vec16));\n        svst1_s32(pg, &B[i], vec32);\n    }\n\n    for (; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg;\n    do {\n        pg = svwhilelt_b16(i, size);\n        svint16_t vec_a = svld1_s16(pg, &A[i]);\n        svint32_t vec_b = svcvt_s32_s16(vec_a);\n        svst1_s32(pg, &B[i], vec_b);\n        i += svcntw();\n    } while (svptest_any(svptrue_b16(), pg));\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg;\n    svint16_t vec16;\n    svint32_t vec32;\n\n    for (; i <= size - svcntw(); i += svcntw()) {\n        pg = svwhilelt_b32(i, size);\n        vec16 = svld1_s16(pg, &A[i]);\n        vec32 = svshl_z(pg, svdup_n_s32(0), svreinterpret_s32_s16(vec16));\n        svst1_s32(pg, &B[i], vec32);\n    }\n\n    for (; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg;\n    do {\n        pg = svwhilelt_b16(i, size);\n        svint16_t vec_a = svld1_s16(pg, &A[i]);\n        svint32_t vec_b = svcvt_s32_s16(vec_a);\n        svst1_s32(pg, &B[i], vec_b);\n        i += svcntw();\n    } while (svptest_any(svptrue_b16(), pg));\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    svbool_t pg;\n    svfloat32_t v_min = svdup_f32(min_val);\n    svfloat32_t v_max = svdup_f32(max_val);\n    svfloat32_t v_one = svdup_f32(1.0f);\n    svfloat32_t v_zero = svdup_f32(0.0f);\n\n    for (size_t i = 0; i < size; i += svcntw()) {\n        pg = svwhilelt_b32(i, size);\n\n        svfloat32_t va = svld1(pg, &A[i]);\n        svint32_t vcontrol = svld1_s32(pg, &control[i]);\n\n        svfloat32_t vrange = svsub_f32_z(pg, v_max, v_min);\n        svfloat32_t vnormalized = svdiv_f32_z(pg, svsub_f32_z(pg, va, v_min), vrange);\n        vnormalized = svmax_f32_z(pg, vnormalized, vzero);\n        vnormalized = svmin_f32_z(pg, vnormalized, vone);\n\n        svfloat32_t vresult = svsel_f32(pg, vnormalized, va, svcmplt_s32(pg, vcontrol, svdup_s32(0)));\n\n        svst1(pg, &B[i], vresult);\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    svbool_t pg;\n    svfloat32_t v_min = svdup_f32(min_val);\n    svfloat32_t v_max = svdup_f32(max_val);\n    svfloat32_t v_one = svdup_f32(1.0f);\n    svfloat32_t v_zero = svdup_f32(0.0f);\n\n    for (size_t i = 0; i < size; i += svcntw()) {\n        pg = svwhilelt_b32(i, size);\n        svfloat32_t v_a = svld1(pg, &A[i]);\n        svint32_t v_control = svld1_s32(pg, &control[i]);\n\n        svfloat32_t v_range = svsub_f32_z(pg, v_max, v_min);\n        svfloat32_t v_normalized = svdiv_f32_z(pg, svsub_f32_z(pg, v_a, v_min), v_range);\n        v_normalized = svmax_f32_z(pg, v_normalized, v_zero);\n        v_normalized = svmin_f32_z(pg, v_normalized, v_one);\n\n        svbool_t v_control_gt_zero = svgt_s32(pg, v_control, svdup_s32(0));\n        svfloat32_t v_result = svsel_f32(v_control_gt_zero, v_normalized, v_a);\n\n        svst1(pg, &B[i], v_result);\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    svbool_t pg;\n    svfloat32_t v_min = svdup_f32(min_val);\n    svfloat32_t v_max = svdup_f32(max_val);\n    svfloat32_t v_one = svdup_f32(1.0f);\n    svfloat32_t v_zero = svdup_f32(0.0f);\n\n    for (size_t i = 0; i < size; i += svcntw()) {\n        pg = svwhilelt_b32(i, size);\n        svfloat32_t v_a = svld1(pg, &A[i]);\n        svint32_t v_control = svld1_s32(pg, &control[i]);\n\n        svfloat32_t v_normalized = svsub_f32_z(pg, svdiv_f32_z(pg, svsub_f32_z(pg, v_a, v_min), svsub_f32_z(pg, v_max, v_min)), v_zero);\n        v_normalized = svmax_f32_z(pg, v_normalized, v_zero);\n        v_normalized = svmin_f32_z(pg, v_normalized, v_one);\n\n        svfloat32_t v_result = svsel_f32(pg, svsel_f32(pg, v_normalized, v_a, svcmplt_s32(pg, v_control, svdup_s32(0))), v_a);\n\n        svst1(pg, &B[i], v_result);\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    svbool_t pg;\n    svfloat32_t v_min_val = svdup_f32(min_val);\n    svfloat32_t v_max_val = svdup_f32(max_val);\n    svfloat32_t v_one = svdup_f32(1.0f);\n    svfloat32_t v_zero = svdup_f32(0.0f);\n\n    for (size_t i = 0; i < size; i += svcntw()) {\n        pg = svwhilelt_b32(i, size);\n        svfloat32_t v_a = svld1(pg, &A[i]);\n        svint32_t v_control = svld1_s32(pg, &control[i]);\n\n        svbool_t mask = svcmpgt_s32(pg, v_control, svdup_s32(0));\n        svfloat32_t v_normalized = svsub_f32_z(pg, mask, v_a, v_min_val);\n        v_normalized = svdiv_f32_z(pg, mask, v_normalized, svsub_f32_z(pg, mask, v_max_val, v_min_val));\n        v_normalized = svmax_f32_z(pg, mask, v_normalized, v_zero);\n        v_normalized = svmin_f32_z(pg, mask, v_normalized, v_one);\n\n        svfloat32_t v_result = svsel_f32(pg, mask, v_normalized, v_a);\n        svst1(pg, &B[i], v_result);\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    svbool_t pg;\n    svfloat32_t v_min = svdup_f32(min_val);\n    svfloat32_t v_max = svdup_f32(max_val);\n    svfloat32_t v_one = svdup_f32(1.0f);\n    svfloat32_t v_zero = svdup_f32(0.0f);\n\n    for (size_t i = 0; i < size; i += svcntw()) {\n        pg = svwhilelt_b32(i, size);\n        svfloat32_t va = svld1(pg, &A[i]);\n        svint32_t vcontrol = svld1_s32(pg, &control[i]);\n\n        svbool_t mask = svcmpgt_s32(pg, vcontrol, svdup_s32(0));\n        svfloat32_t vrange = svsub_f32_z(pg, v_max, v_min);\n        svfloat32_t vnormalized = svdiv_f32_z(pg, svsub_f32_z(pg, va, v_min), vrange);\n        vnormalized = svmax_f32_z(pg, vzero, vnormalized);\n        vnormalized = svmin_f32_z(pg, vone, vnormalized);\n\n        svfloat32_t vresult = svsel_f32(pg, mask, vnormalized, va);\n        svst1(pg, &B[i], vresult);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg;\n    svuint32_t vecA;\n    svfloat32_t vecB;\n\n    do {\n        pg = svwhilelt_b32(i, size);\n        vecA = svld1_u32(pg, &A[i]);\n        vecA = svlsr_n_u32_z(pg, vecA, 16);\n        vecB = svcvt_f32_u32_z(pg, vecA);\n        vecB = vsqrt_f32_z(pg, vecB);\n        svst1_f32(pg, &B[i], vecB);\n        i += svcntw();\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg;\n\n    do {\n        // Load 8 uint32_t elements from A\n        svuint32_t vecA = svld1_u32(svundef_u32(), &A[i]);\n\n        // Shift right by 16 bits to get the high 16 bits\n        svuint32_t high16 = svlsr_n_u32_z(svpglast_b32(svptrue_b32()), vecA, 16);\n\n        // Convert uint32_t to float\n        svfloat32_t vecF = svcvt_f32_u32_z(svpglast_b32(svptrue_b32()), high16);\n\n        // Compute the square root\n        svfloat32_t sqrtF = vsqrt_f32_z(svpglast_b32(svptrue_b32()), vecF);\n\n        // Store the result in B\n        svst1_f32(svpglast_b32(svptrue_b32()), &B[i], sqrtF);\n\n        // Move to the next 8 elements\n        i += svcntw();\n    } while (i < size);\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg;\n    svuint32_t vecA;\n    svfloat32_t vecB;\n\n    do {\n        pg = svwhilelt_b32(i, size);\n        vecA = svld1_u32(pg, &A[i]);\n        vecA = svlsr_n_u32_z(pg, vecA, 16);\n        vecB = svcvt_f32_u32_z(pg, vecA);\n        vecB = vsqrt_f32_z(pg, vecB);\n        svst1_f32(pg, &B[i], vecB);\n        i += svcntw();\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg;\n    svuint32_t vecA;\n    svfloat32_t vecB;\n\n    do {\n        pg = svwhilelt_b32(i, size);\n        vecA = svld1_u32(pg, &A[i]);\n        vecA = svlsr_n_u32_z(pg, vecA, 16);\n        vecB = svcvt_f32_u32_z(pg, vecA);\n        vecB = vsqrt_f32_z(pg, vecB);\n        svst1_f32(pg, &B[i], vecB);\n        i += svcntb();\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg;\n    svuint32_t vec_A;\n    svfloat32_t vec_B;\n\n    do {\n        pg = svwhilelt_b32(i, size);\n        vec_A = svld1_u32(pg, &A[i]);\n        vec_A = svlsr_n_u32_z(pg, vec_A, 16);\n        vec_B = svcvt_f32_u32_z(pg, vec_A);\n        vec_B = vsqrt_f32_z(pg, vec_B);\n        svst1_f32(pg, &B[i], vec_B);\n        i += svcntw();\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg;\n    do {\n        size_t vl = svcntw();\n        if (i + vl > size) {\n            vl = size - i;\n            pg = svwhilelt_b32(0, vl);\n        } else {\n            pg = svptrue_b32();\n        }\n        svuint32_t vec_a = svld1_u32(pg, &A[i]);\n        svfloat32_t vec_b = svreinterpret_f32_u32(vec_a);\n        svst1_f32(pg, &B[i], vec_b);\n        i += vl;\n    } while (i < size);\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg;\n    do {\n        size_t vl = svcntw();\n        if (i + vl > size) {\n            vl = size - i;\n            pg = svwhilelt_b32(0, vl);\n        } else {\n            pg = svptrue_b32();\n        }\n        svuint32_t vec_a = svld1_u32(pg, &A[i]);\n        svfloat32_t vec_b = svreinterpret_f32_u32(vec_a);\n        svst1_f32(pg, &B[i], vec_b);\n        i += vl;\n    } while (i < size);\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg;\n    do {\n        size_t vl = svcntw();\n        if (i + vl > size) {\n            vl = size - i;\n            pg = svwhilelt_b32(0, vl);\n        } else {\n            pg = svptrue_b32();\n        }\n        svuint32_t vec_a = svld1_u32(pg, &A[i]);\n        svfloat32_t vec_b = svreinterpret_f32_u32(vec_a);\n        svst1_f32(pg, &B[i], vec_b);\n        i += vl;\n    } while (i < size);\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg;\n    do {\n        size_t vl = svcntw();\n        if (i + vl > size) {\n            vl = size - i;\n            pg = svwhilelt_b32(0, vl);\n        } else {\n            pg = svptrue_b32();\n        }\n        svuint32_t vec_a = svld1_u32(pg, &A[i]);\n        svfloat32_t vec_b = svreinterpret_f32_u32(vec_a);\n        svst1_f32(pg, &B[i], vec_b);\n        i += vl;\n    } while (i < size);\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg;\n    do {\n        size_t vl = svmin(size - i, svcntw());\n        pg = svwhilelt_b32(i, size);\n        svuint32_t vec_uint = svld1(pg, &A[i]);\n        svfloat32_t vec_float = svreinterpret_f32_u32(vec_uint);\n        svst1(pg, &B[i], vec_float);\n        i += vl;\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    svfloat32_t zero = svdup_f32(0.0f);\n\n    // Set the first element of diff to 0.0f\n    diff[0] = 0.0f;\n\n    // Process the rest of the elements\n    for (; i <= size - svcntw(); i += svcntw()) {\n        svint32_t a = svld1_s32(pg, &A[i]);\n        svint32_t a_prev = svld1_s32(pg, &A[i - 1]);\n        svbool_t c = svld1_b8(pg, (const uint8_t*)&cond[i]);\n        svfloat32_t d = svsub_f32_z(pg, svdup_f32(0.0f), svcvt_f32_s32_z(pg, svsub_s32_z(pg, a, a_prev)));\n        d = svsel_f32(c, d, zero);\n        svst1_f32(pg, &diff[i], d);\n    }\n\n    // Handle any remaining elements\n    for (; i < size; ++i) {\n        diff[i] = cond[i] ? (float)(A[i] - A[i - 1]) : 0.0f;\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    svfloat32_t zero = svdup_f32(0.0f);\n\n    // Set the first element of diff to 0.0f\n    diff[0] = 0.0f;\n\n    // Process the rest of the elements\n    for (; i < size - 1; i += svcntw()) {\n        svint32_t a = svld1_s32(pg, &A[i]);\n        svint32_t a_prev = svld1_s32(pg, &A[i + 1]);\n        svbool_t c = svld1_b8(pg, (const uint8_t*)&cond[i + 1]);\n\n        svint32_t diff_int = svsub_s32_z(pg, c, a_prev, a);\n        svfloat32_t diff_float = svcvt_f32_s32_z(pg, c, diff_int);\n\n        diff_float = svsel_f32(svnot_b(c), zero, diff_float);\n        svst1_f32(pg, &diff[i + 1], diff_float);\n    }\n\n    // Handle any remaining elements\n    for (; i < size; ++i) {\n        diff[i] = cond[i] ? (float)(A[i] - A[i - 1]) : 0.0f;\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    svfloat32_t zero = svdup_f32(0.0f);\n\n    // Set the first element of diff to 0.0f\n    diff[0] = 0.0f;\n\n    // Process the rest of the elements\n    for (; i < size - 1; i += svcntw()) {\n        svint32_t va = svld1_s32(pg, &A[i]);\n        svint32_t vnexta = svld1_s32(pg, &A[i + 1]);\n        svbool_t vcond = svld1_b8(pg, (const uint8_t*)&cond[i + 1]);\n\n        svint32_t vdiff = svsub_z(pg, vzero_s32(), va, vnexta);\n        svfloat32_t vfdiff = svcvt_f32_s32_z(pg, zero, vdiff);\n\n        vfdiff = svsel_f32(vcond, vfdiff, zero);\n        svst1_f32(pg, &diff[i + 1], vfdiff);\n    }\n\n    // Handle any remaining elements\n    for (; i < size; ++i) {\n        diff[i] = cond[i] ? (float)(A[i] - A[i - 1]) : 0.0f;\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    svfloat32_t zero = svdup_f32(0.0f);\n\n    // Set the first element of diff to 0.0f\n    diff[0] = 0.0f;\n\n    // Process the rest of the elements\n    for (; i < size - 1; i += svcntw()) {\n        svint32_t a = svld1_s32(pg, &A[i]);\n        svint32_t a_prev = svld1_s32(pg, &A[i + 1]);\n        svbool_t c = svld1_b8(pg, (const uint8_t*)&cond[i + 1]);\n\n        svint32_t diff_int = svsub_s32_z(pg, c, a_prev, a);\n        svfloat32_t diff_float = svcvt_f32_s32_z(pg, c, diff_int);\n\n        diff_float = svsel_f32(pg, c, diff_float, zero);\n        svst1_f32(pg, &diff[i + 1], diff_float);\n    }\n\n    // Handle any remaining elements\n    for (; i < size; ++i) {\n        diff[i] = cond[i] ? (float)(A[i] - A[i - 1]) : 0.0f;\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    svfloat32_t zero = svdup_f32(0.0f);\n\n    // Set the first element of diff to 0.0f\n    diff[0] = 0.0f;\n\n    // Process the rest of the elements\n    for (; i < size - 1; i += svcntw()) {\n        svint32_t a = svld1_s32(pg, &A[i]);\n        svint32_t a_prev = svld1_s32(pg, &A[i + 1]);\n        svbool_t c = svld1_b8(pg, (const uint8_t*)&cond[i + 1]);\n\n        svint32_t diff_int = svsub_z(svptrue_b32(), a_prev, a);\n        svfloat32_t diff_float = svcvt_f32_s32(diff_int);\n\n        svfloat32_t result = svsel_f32(c, diff_float, zero);\n        svst1_f32(pg, &diff[i + 1], result);\n    }\n\n    // Handle any remaining elements\n    for (; i < size; ++i) {\n        diff[i] = cond[i] ? (float)(A[i] - A[i - 1]) : 0.0f;\n    }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    svuint32_t vec_src;\n    svuint64_t vec_dst;\n\n    do {\n        pg = svwhilelt_b32(i, length);\n        vec_src = svld1_u32(pg, &src[i]);\n        vec_dst = svusxt_u64_u32(vec_src);\n        vec_dst = sveor_u64_z(pg, vec_dst, svdup_u64(0xFFFFFFFF00000000ULL));\n        svst1_u64(pg, &dst[i], vec_dst);\n        i += svcntw();\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    svuint32_t vec_src;\n    svuint64_t vec_dst;\n\n    do {\n        pg = svwhilelt_b32(i, length);\n        vec_src = svld1_u32(pg, &src[i]);\n        vec_dst = svusxt_u64(vec_src);\n        vec_dst = sveor_u64_z(pg, vec_dst, svdup_u64(0xFFFFFFFF00000000ULL));\n        svst1_u64(pg, &dst[i], vec_dst);\n        i += svcntw();\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    svuint32_t vec_src;\n    svuint64_t vec_dst;\n\n    do {\n        pg = svwhilelt_b32(i, length);\n        vec_src = svld1_u32(pg, &src[i]);\n        vec_dst = svusxt_u64_u32(vec_src);\n        vec_dst = sveor_u64_z(pg, vec_dst, svdup_u64(0xFFFFFFFF00000000ULL));\n        svst1_u64(pg, &dst[i], vec_dst);\n        i += svcntw();\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    svuint32_t vec_src;\n    svuint64_t vec_dst;\n\n    do {\n        pg = svwhilelt_b32(i, length);\n        vec_src = svld1_u32(pg, &src[i]);\n        vec_dst = svusxt_u64(vec_src);\n        vec_dst = sveor_u64_z(pg, vec_dst, svdup_u64(0xFFFFFFFF00000000ULL));\n        svst1_u64(pg, &dst[i], vec_dst);\n        i += svcntw();\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    svuint32_t vec_src;\n    svuint64_t vec_dst;\n\n    do {\n        pg = svwhilelt_b32(i, length);\n        vec_src = svld1_u32(pg, &src[i]);\n        vec_dst = svusxt_u64(vec_src);\n        vec_dst = sveor_u64_z(pg, vec_dst, svdup_u64(0xFFFFFFFF00000000ULL));\n        svst1_u64(pg, &dst[i], vec_dst);\n        i += svcntw();\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c\n#include <arm_sve.h> \n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    svbool_t pg = svptrue_b64();\n    svfloat64_t sum = svdup_f64(0.0);\n\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svint16_t idx_vec = svld1_s16(pg, &index[i]);\n        svfloat64_t vec_vec = svld1_gather_index_f64(pg, vec, idx_vec);\n        sum = svadd_f64_m(pg, sum, vec_vec);\n    }\n\n    return svaddv_f64(pg, sum);\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c\n#include <arm_sve.h> \n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    svbool_t pg = svptrue_b64();\n    svfloat64_t sum = svdup_f64(0.0);\n\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svint16_t idx_vec = svld1_s16(pg, &index[i]);\n        svfloat64_t vec_vec = svld1_gather_index_f64(pg, vec, idx_vec);\n        sum = svadd_f64_m(pg, sum, vec_vec);\n    }\n\n    double result = 0.0;\n    svst1_f64(pg, &result, svaddv_f64_m(pg, sum));\n    return result;\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c\n#include <arm_sve.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    svbool_t pg = svptrue_b64();\n    svfloat64_t sum = svdup_f64(0.0);\n\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svint16_t idx_vec = svld1_s16(pg, &index[i]);\n        svfloat64_t vec_vec = svld1_gather_index_f64(pg, vec, idx_vec);\n        sum = svadd_f64_m(pg, sum, vec_vec);\n    }\n\n    double result = 0.0;\n    svst1_f64(pg, &result, svaddv_f64_m(pg, sum));\n    return result;\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c\n#include <arm_sve.h> \n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double result = 0.0;\n    svbool_t pg;\n    svfloat64_t sum = svdup_f64(0.0);\n\n    for (size_t i = 0; i < length; ) {\n        size_t vl = svcntw();\n        if (i + vl > length) {\n            vl = length - i;\n        }\n        pg = svwhilelt_b64(i, length);\n\n        svint16_t idx_vec = svld1_s16(pg, &index[i]);\n        svfloat64_t vec_vec = svld1_gather_index_f64(pg, vec, idx_vec);\n\n        sum = svadd_m(sum, pg, sum, vec_vec);\n\n        i += vl;\n    }\n\n    result = svaddv_f64(sum);\n    return result;\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c\n#include <arm_sve.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    svbool_t pg = svptrue_b64();\n    svfloat64_t sum = svdup_f64(0.0);\n\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svint16_t idx_vec = svld1_s16(pg, &index[i]);\n        svfloat64_t vec_vec = svld1_gather_index_f64(pg, vec, idx_vec);\n        sum = svadd_f64_m(pg, sum, vec_vec);\n    }\n\n    return svaddv_f64(pg, sum);\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    size_t kernel_area = kernel_size * kernel_size;\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            svfloat64_t acc = svdup_f64(0.0);\n\n            for (size_t m = 0; m < kernel_size; ++m) {\n                for (size_t n = 0; n < kernel_size; ++n) {\n                    size_t input_idx = (i + m) * input_size + (j + n);\n                    size_t kernel_idx = m * kernel_size + n;\n\n                    svfloat64_t input_vec = svld1_f64(svptrue_b64(), &input[input_idx]);\n                    svfloat64_t kernel_vec = svld1_f64(svptrue_b64(), &kernel[kernel_idx]);\n\n                    svfloat64_t prod = svmul_f64_z(svptrue_b64(), input_vec, kernel_vec);\n                    acc = svadd_f64_m(svptrue_b64(), acc, prod);\n                }\n            }\n\n            sum = svaddv_f64(svptrue_b64(), acc);\n            output[i * output_size + j] = (sum > 0.0) ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    size_t kernel_area = kernel_size * kernel_size;\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            svbool_t pg = svptrue_b64();\n            svfloat64_t acc = svdup_f64(0.0);\n\n            for (size_t m = 0; m < kernel_size; ++m) {\n                for (size_t n = 0; n < kernel_size; ++n) {\n                    size_t input_idx = (i + m) * input_size + (j + n);\n                    size_t kernel_idx = m * kernel_size + n;\n\n                    svfloat64_t vec_input = svld1_f64(pg, &input[input_idx]);\n                    svfloat64_t vec_kernel = svld1_f64(pg, &kernel[kernel_idx]);\n\n                    acc = svmla_f64_z(pg, acc, vec_input, vec_kernel);\n                }\n            }\n\n            sum = svaddv_f64(pg, acc);\n            output[i * output_size + j] = (sum > 0.0) ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    size_t kernel_area = kernel_size * kernel_size;\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            svfloat64_t acc = svdup_f64(0.0);\n\n            for (size_t m = 0; m < kernel_size; ++m) {\n                for (size_t n = 0; n < kernel_size; ++n) {\n                    size_t input_idx = (i + m) * input_size + (j + n);\n                    size_t kernel_idx = m * kernel_size + n;\n\n                    svfloat64_t input_vec = svld1_f64(svptrue_b64(), &input[input_idx]);\n                    svfloat64_t kernel_vec = svld1_f64(svptrue_b64(), &kernel[kernel_idx]);\n\n                    svfloat64_t prod = svmul_f64_z(svptrue_b64(), input_vec, kernel_vec);\n                    acc = svadd_f64_m(svptrue_b64(), acc, prod);\n                }\n            }\n\n            sum = svaddv_f64(svptrue_b64(), acc);\n            output[i * output_size + j] = (sum > 0.0) ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    size_t kernel_area = kernel_size * kernel_size;\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            svbool_t pg = svptrue_b64();\n            svfloat64_t acc = svdup_f64(0.0);\n\n            for (size_t m = 0; m < kernel_size; ++m) {\n                for (size_t n = 0; n < kernel_size; ++n) {\n                    size_t input_idx = (i + m) * input_size + (j + n);\n                    size_t kernel_idx = m * kernel_size + n;\n\n                    svfloat64_t vec_input = svld1_f64(pg, &input[input_idx]);\n                    svfloat64_t vec_kernel = svld1_f64(pg, &kernel[kernel_idx]);\n\n                    acc = svmla_f64_z(pg, acc, vec_input, vec_kernel);\n                }\n            }\n\n            sum = svaddv_f64(pg, acc);\n            output[i * output_size + j] = (sum > 0.0) ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    size_t kernel_area = kernel_size * kernel_size;\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            svbool_t pg = svptrue_b64();\n            svfloat64_t acc = svdup_f64(0.0);\n\n            for (size_t m = 0; m < kernel_size; ++m) {\n                for (size_t n = 0; n < kernel_size; ++n) {\n                    const double* input_ptr = &input[(i + m) * input_size + (j + n)];\n                    const double* kernel_ptr = &kernel[m * kernel_size + n];\n\n                    svfloat64_t vec_input = svld1_f64(pg, input_ptr);\n                    svfloat64_t vec_kernel = svld1_f64(pg, kernel_ptr);\n\n                    acc = svmla_f64_z(pg, acc, vec_input, vec_kernel);\n                }\n            }\n\n            sum = svaddv_f64(pg, acc);\n            output[i * output_size + j] = (sum > 0.0) ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    svbool_t pg = svptrue_b64();\n    size_t n = numbers.size();\n\n    for (size_t i = 0; i < n; ++i) {\n        double num_i = numbers[i];\n        svfloat64_t vec_num_i = svdup_f64(num_i);\n        svfloat64_t vec_threshold = svdup_f64(threshold);\n\n        for (size_t j = i + 1; j < n; j += svcntb() / sizeof(double)) {\n            size_t length = svcntb() / sizeof(double) < n - j ? svcntb() / sizeof(double) : n - j;\n            svbool_t pg_j = svwhilelt_b64(0, length);\n            svfloat64_t vec_j = svld1(pg_j, &numbers[j]);\n\n            svfloat64_t diff = svabs_f64(svsub_f64_z(pg_j, vec_j, vec_num_i));\n            svbool_t close_elements = svcmplt_f64(pg_j, diff, vec_threshold);\n\n            if (svptest_any(svptrue_b64(), close_elements)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    svbool_t pg = svptrue_b64();\n    size_t num_elements = numbers.size();\n\n    for (size_t i = 0; i < num_elements; ++i) {\n        double vi = numbers[i];\n        svfloat64_t vec_i = svdup_f64(vi);\n        for (size_t j = i + 1; j < num_elements; j += svcntb() / sizeof(double)) {\n            size_t length = svcntb() / sizeof(double) < num_elements - j ? svcntb() / sizeof(double) : num_elements - j;\n            pg = svwhilelt_b64(svptrue_b64(), j, num_elements);\n            svfloat64_t vec_j = svld1(pg, &numbers[j]);\n            svfloat64_t diff = svabs_f64(svsub_f64_z(pg, vec_i, vec_j));\n            svbool_t close_elements = svcmplt_f64(pg, diff, svdup_f64(threshold));\n            if (svptest_any(svptrue_b64(), close_elements)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    svbool_t pg = svptrue_b64();\n    size_t n = numbers.size();\n\n    for (size_t i = 0; i < n; ++i) {\n        double num_i = numbers[i];\n        svfloat64_t vec_num_i = svdup_f64(num_i);\n        svfloat64_t vec_threshold = svdup_f64(threshold);\n\n        for (size_t j = i + 1; j < n; j += svcntb() / sizeof(double)) {\n            size_t length = svcntb() / sizeof(double) < n - j ? svcntb() / sizeof(double) : n - j;\n            pg = svwhilelt_b64(svptrue_b64(), j, n);\n\n            svfloat64_t vec_j = svld1(pg, &numbers[j]);\n            svfloat64_t diff = svabs_f64(svsub_f64(vec_j, vec_num_i));\n            svbool_t close_elements = svcmplt_f64(pg, diff, vec_threshold);\n\n            if (svptest_any(svptrue_b64(), close_elements)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    svbool_t pg = svptrue_b64();\n    size_t n = numbers.size();\n\n    for (size_t i = 0; i < n; ++i) {\n        double num_i = numbers[i];\n        svfloat64_t vec_num_i = svdup_f64(num_i);\n        svfloat64_t vec_threshold = svdup_f64(threshold);\n\n        for (size_t j = i + 1; j < n; j += svcntb() / sizeof(double)) {\n            size_t length = svcntb() / sizeof(double) < n - j ? svcntb() / sizeof(double) : n - j;\n            pg = svwhilelt_b64(svptrue_b64(), j, n);\n\n            svfloat64_t vec_j = svld1(pg, &numbers[j]);\n            svfloat64_t diff = svabs_f64(svsub_f64(vec_j, vec_num_i));\n            svbool_t close_elements = svcmplt_f64(pg, diff, vec_threshold);\n\n            if (svptest_any(svptrue_b64(), close_elements)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    svbool_t pg = svptrue_b64();\n    size_t n = numbers.size();\n\n    for (size_t i = 0; i < n; ++i) {\n        double num_i = numbers[i];\n        svfloat64_t vec_num_i = svdup_f64(num_i);\n        svfloat64_t vec_threshold = svdup_f64(threshold);\n\n        for (size_t j = i + 1; j < n; j += svcntb() / sizeof(double)) {\n            size_t length = svcntb() / sizeof(double) < n - j ? svcntb() / sizeof(double) : n - j;\n            pg = svwhilelt_b64(svptrue_b64(), j, n);\n\n            svfloat64_t vec_j = svld1(pg, &numbers[j]);\n            svfloat64_t diff = svabs_f64(svsub_f64(vec_j, vec_num_i));\n            svbool_t close_elements = svcmplt_f64(pg, diff, vec_threshold);\n\n            if (svptest_any(svptrue_b64(), close_elements)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int64_t sum = 0;\n    svint32_t vec_sum = svdup_s32(0);\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < operations.size(); i += vl) {\n        svint32_t vec_ops = svld1_s32(svundef_s32(), &operations[i]);\n        vec_sum = svadd_s32_z(svpmull_s32(svcmplt_s32(vec_sum, svdup_s32(0)), svdup_s32(0), vec_sum), vec_ops);\n        sum += svaddv_s32(vec_sum);\n        if (sum < 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int64_t sum = 0;\n    svint32_t vec_sum = svdup_s32(0);\n    size_t vl;\n\n    for (size_t i = 0; i < operations.size(); i += vl) {\n        vl = svcntw();\n        svint32_t vec_ops = svld1_s32(svundef_u32(), &operations[i]);\n        vec_sum = svadd_s32_z(svwhilelt_b32(vl, operations.size() - i), vec_sum, vec_ops);\n\n        // Horizontal sum of the vector\n        int32_t partial_sum = svaddv_s32(vec_sum);\n        sum += partial_sum;\n\n        if (sum < 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int64_t sum = 0;\n    svint32_t vec_sum = svdup_s32(0);\n    size_t vl;\n\n    for (size_t i = 0; i < operations.size(); i += vl) {\n        vl = svcntw();\n        svint32_t vec_ops = svld1_s32(svundef_u32(), &operations[i]);\n        vec_sum = svadd_s32_z(svwhilelt_b32(vl, operations.size() - i), vec_sum, vec_ops);\n\n        // Convert vector sum to scalar and add to total sum\n        int32_t partial_sum = svaddv_s32(vec_sum);\n        sum += partial_sum;\n\n        if (sum < 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool below_zero_simd(const std::vector<int>& operations) {\n    int64_t sum = 0;\n    svint32_t acc = svdup_s32(0);\n    size_t i = 0;\n    size_t length = operations.size();\n\n    while (i < length) {\n        size_t vl = svcntw();\n        if (i + vl > length) {\n            vl = length - i;\n        }\n        svint32_t vec = svld1_s32(svundef_u32(), &operations[i]);\n        acc = svadd_s32_z(svwhilelt_b32(vl, 0), acc, vec);\n        svbool_t lt_zero = svcmplt_s32(acc, svdup_s32(0));\n        if (svptest_any(svptrue_b32(), lt_zero)) {\n            return true;\n        }\n        i += vl;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int64_t sum = 0;\n    svint32_t vec_sum = svdup_s32(0);\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < operations.size(); i += vl) {\n        svint32_t vec_ops = svld1_s32(svundef_s32(), &operations[i]);\n        vec_sum = svadd_s32_z(svpmull_s32(svcmplt_s32(vec_sum, svdup_s32(0)), svdup_s32(0), vec_sum), vec_ops);\n        sum += svaddv_s32(vec_sum);\n\n        if (sum < 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\ndouble mean_absolute_deviation_simd(const std::vector<double>& numbers) {\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    svbool_t pg;\n    svfloat64_t sum = svdup_f64(0.0);\n    svfloat64_t mean;\n    size_t i = 0;\n\n    // Calculate the sum of the array\n    for (; i + svcntd() <= n; i += svcntd()) {\n        pg = svptrue_b64();\n        svfloat64_t vec = svld1_f64(pg, &numbers[i]);\n        sum = svadd_f64_m(pg, sum, vec);\n    }\n\n    // Handle the remaining elements\n    if (i < n) {\n        pg = svwhilelt_b64(i, n);\n        svfloat64_t vec = svld1_f64(pg, &numbers[i]);\n        sum = svadd_f64_m(pg, sum, vec);\n    }\n\n    // Calculate the mean\n    double total_sum = svaddv_f64(svptrue_b64(), sum);\n    mean = svdup_f64(total_sum / n);\n\n    // Calculate the sum of absolute deviations\n    sum = svdup_f64(0.0);\n    i = 0;\n\n    for (; i + svcntd() <= n; i += svcntd()) {\n        pg = svptrue_b64();\n        svfloat64_t vec = svld1_f64(pg, &numbers[i]);\n        svfloat64_t abs_diff = svabs_f64_z(pg, svsub_f64_z(pg, vec, mean));\n        sum = svadd_f64_m(pg, sum, abs_diff);\n    }\n\n    // Handle the remaining elements\n    if (i < n) {\n        pg = svwhilelt_b64(i, n);\n        svfloat64_t vec = svld1_f64(pg, &numbers[i]);\n        svfloat64_t abs_diff = svabs_f64_z(pg, svsub_f64_z(pg, vec, mean));\n        sum = svadd_f64_m(pg, sum, abs_diff);\n    }\n\n    // Calculate the mean absolute deviation\n    double mad_sum = svaddv_f64(svptrue_b64(), sum);\n    return mad_sum / n;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\ndouble mean_absolute_deviation_simd(const std::vector<double>& numbers) {\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    svbool_t pg;\n    svfloat64_t sum = svdup_f64(0.0);\n    svfloat64_t mean_sum = svdup_f64(0.0);\n\n    // Calculate the sum of the array\n    for (size_t i = 0; i < n; i += svcntd()) {\n        pg = svwhilelt_b64(i, n);\n        svfloat64_t vec = svld1(pg, &numbers[i]);\n        mean_sum = svadd_m(mean_sum, pg, mean_sum, vec);\n    }\n\n    // Calculate the mean\n    double total_sum = svaddv_f64(svptrue_b64(), mean_sum);\n    double mean = total_sum / n;\n\n    // Calculate the sum of absolute deviations\n    for (size_t i = 0; i < n; i += svcntd()) {\n        pg = svwhilelt_b64(i, n);\n        svfloat64_t vec = svld1(pg, &numbers[i]);\n        svfloat64_t diff = svabs_f64_z(pg, svsub_f64_z(pg, vec, svdup_f64(mean)));\n        sum = svadd_m(sum, pg, sum, diff);\n    }\n\n    // Calculate the mean absolute deviation\n    double mad_sum = svaddv_f64(svptrue_b64(), sum);\n    return mad_sum / n;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(const std::vector<double>& numbers) {\n    if (numbers.empty()) return 0.0;\n\n    svbool_t pg;\n    svfloat64_t sum = svdup_f64(0.0);\n    size_t i = 0;\n    const size_t length = numbers.size();\n\n    // Calculate the mean\n    for (; i + svcntd() <= length; i += svcntd()) {\n        pg = svptrue_b64();\n        svfloat64_t vec = svld1(pg, &numbers[i]);\n        sum = svadd_f64_m(pg, sum, vec);\n    }\n    for (; i < length; ++i) {\n        sum = svadd_f64(sum, svdup_f64(numbers[i]));\n    }\n\n    double total_sum = 0.0;\n    i = 0;\n    for (; i + svcntd() <= length; i += svcntd()) {\n        pg = svptrue_b64();\n        svfloat64_t vec = svld1(pg, &numbers[i]);\n        total_sum += svaddv_f64(pg, vec);\n    }\n    for (; i < length; ++i) {\n        total_sum += numbers[i];\n    }\n\n    double mean = total_sum / length;\n\n    // Calculate the mean absolute deviation\n    sum = svdup_f64(0.0);\n    i = 0;\n    for (; i + svcntd() <= length; i += svcntd()) {\n        pg = svptrue_b64();\n        svfloat64_t vec = svld1(pg, &numbers[i]);\n        svfloat64_t diff = svabs_f64(svneg_f64_x(pg, svsub_f64_x(pg, vec, svdup_f64(mean))));\n        sum = svadd_f64_m(pg, sum, diff);\n    }\n    for (; i < length; ++i) {\n        sum = svadd_f64(sum, svdup_f64(std::abs(numbers[i] - mean)));\n    }\n\n    double mad_sum = 0.0;\n    i = 0;\n    for (; i + svcntd() <= length; i += svcntd()) {\n        pg = svptrue_b64();\n        svfloat64_t vec = svld1(pg, &numbers[i]);\n        mad_sum += svaddv_f64(pg, vec);\n    }\n    for (; i < length; ++i) {\n        mad_sum += numbers[i];\n    }\n\n    return mad_sum / length;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\ndouble mean_absolute_deviation_simd(const std::vector<double>& numbers) {\n    svbool_t pg;\n    svfloat64_t sum = svdup_f64(0.0);\n    svfloat64_t sum_abs_dev = svdup_f64(0.0);\n    size_t i = 0;\n    const size_t length = numbers.size();\n\n    // Calculate the sum of the elements\n    for (; i + svcntd() <= length; i += svcntd()) {\n        pg =svptrue_b64();\n        svfloat64_t vec = svld1_f64(pg, &numbers[i]);\n        sum = svadd_f64_m(pg, sum, vec);\n    }\n    // Handle the remaining elements\n    if (i < length) {\n        pg = svwhilelt_b64(i, length);\n        svfloat64_t vec = svld1_f64(pg, &numbers[i]);\n        sum = svadd_f64_m(pg, sum, vec);\n    }\n\n    // Calculate the mean\n    double total_sum = svaddv_f64(svptrue_b64(), sum);\n    double mean = total_sum / length;\n\n    // Calculate the sum of absolute deviations\n    i = 0;\n    for (; i + svcntd() <= length; i += svcntd()) {\n        pg = svptrue_b64();\n        svfloat64_t vec = svld1_f64(pg, &numbers[i]);\n        svfloat64_t abs_dev = svabs_f64_z(pg, svsub_f64_z(pg, vec, svdup_f64(mean)));\n        sum_abs_dev = svadd_f64_m(pg, sum_abs_dev, abs_dev);\n    }\n    // Handle the remaining elements\n    if (i < length) {\n        pg = svwhilelt_b64(i, length);\n        svfloat64_t vec = svld1_f64(pg, &numbers[i]);\n        svfloat64_t abs_dev = svabs_f64_z(pg, svsub_f64_z(pg, vec, svdup_f64(mean)));\n        sum_abs_dev = svadd_f64_m(pg, sum_abs_dev, abs_dev);\n    }\n\n    // Calculate the mean absolute deviation\n    double total_abs_dev = svaddv_f64(svptrue_b64(), sum_abs_dev);\n    return total_abs_dev / length;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(const std::vector<double>& numbers) {\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    // Calculate the mean\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    size_t i = 0;\n    for (; i + svcntd() <= n; i += svcntd()) {\n        svfloat64_t vec = svld1_f64(&numbers[i]);\n        sum_vec = svadd_f64_m(svpgather_bf64(svptrue_b64(), &numbers[i]), sum_vec, vec);\n    }\n    double sum = 0.0;\n    svst1_f64(&sum, svaddv_f64(sum_vec));\n\n    for (; i < n; ++i) {\n        sum += numbers[i];\n    }\n\n    double mean = sum / n;\n\n    // Calculate the mean absolute deviation\n    svfloat64_t mad_vec = svdup_f64(0.0);\n    i = 0;\n    for (; i + svcntd() <= n; i += svcntd()) {\n        svfloat64_t vec = svld1_f64(&numbers[i]);\n        svfloat64_t diff = svabs_f64_z(svptrue_b64(), svsub_f64_z(svptrue_b64(), vec, svdup_f64(mean)));\n        mad_vec = svadd_f64_m(svpgather_bf64(svptrue_b64(), &numbers[i]), mad_vec, diff);\n    }\n    double mad_sum = 0.0;\n    svst1_f64(&mad_sum, svaddv_f64(mad_vec));\n\n    for (; i < n; ++i) {\n        mad_sum += std::abs(numbers[i] - mean);\n    }\n\n    return mad_sum / n;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimiter) {\n    std::vector<int> result;\n    if (numbers.empty()) {\n        return result;\n    }\n\n    svint32_t sv_delimiter = svdup_s32(delimiter);\n    size_t num_elements = numbers.size();\n    size_t result_size = 2 * num_elements - 1;\n    result.resize(result_size);\n\n    const int *input_ptr = numbers.data();\n    int *output_ptr = result.data();\n\n    svbool_t pg;\n    do {\n        // Load up to VL-1 elements from the input\n        svint32_t sv_numbers = svld1_s32(svwhilelt_b32(svptrue_b32(), input_ptr, numbers.data() + num_elements));\n        size_t vl = svcntb(pg = svwhilelt_b32(svptrue_b32(), output_ptr, result.data() + result_size));\n\n        // Store the first element\n        svst1_s32(pg, output_ptr, sv_numbers);\n        output_ptr += svptest_any(svptrue_b32(), pg);\n\n        // Interleave delimiter and the rest of the elements\n        for (size_t i = 1; i < vl; ++i) {\n            svst1_s32(pg, output_ptr, sv_delimiter);\n            output_ptr += svptest_any(svptrue_b32(), pg);\n            svst1_s32(pg, output_ptr, svext(sv_numbers, sv_numbers, i));\n            output_ptr += svptest_any(svptrue_b32(), pg);\n        }\n\n        input_ptr += vl - 1;\n    } while (svptest_any(svptrue_b32(), pg));\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimiter) {\n    std::vector<int> result;\n    if (numbers.empty()) {\n        return result;\n    }\n\n    size_t n = numbers.size();\n    size_t result_size = 2 * n - 1;\n    result.resize(result_size);\n\n    svint32_t sv_delimiter = svdup_s32(delimiter);\n    size_t i = 0;\n\n    while (i < n) {\n        size_t vl = svcntw();\n        if (i + vl > n) {\n            vl = n - i;\n        }\n\n        svint32_t sv_numbers = svld1_s32(svundef_s32(), &numbers[i]);\n        svint32_t sv_result = svinterleave_s32(sv_numbers, sv_delimiter);\n\n        size_t store_vl = 2 * vl - 1;\n        if (i + vl == n) {\n            store_vl = 2 * vl - 1;\n        } else {\n            store_vl = 2 * vl;\n        }\n\n        svst1_s32(&result[2 * i], svext(sv_result, sv_result, store_vl / 2));\n\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimiter) {\n    std::vector<int> result;\n    if (numbers.empty()) {\n        return result;\n    }\n\n    size_t n = numbers.size();\n    size_t result_size = 2 * n - 1;\n    result.resize(result_size);\n\n    svint32_t sv_delimiter = svdup_s32(delimiter);\n    size_t i = 0;\n\n    while (i < n) {\n        size_t vl = svcntw();\n        if (i + vl > n) {\n            vl = n - i;\n        }\n\n        svint32_t sv_numbers = svld1_s32(svundef_s32(), &numbers[i]);\n        svint32_t sv_result = svinterleave_s32(sv_numbers, sv_delimiter);\n\n        size_t store_vl = 2 * vl - 1;\n        if (i + vl == n) {\n            store_vl = 2 * vl - 1;\n        } else {\n            store_vl = 2 * vl;\n        }\n\n        svst1_s32(&result[2 * i], svext(sv_result, sv_result, store_vl));\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimiter) {\n    std::vector<int> result;\n    if (numbers.empty()) {\n        return result;\n    }\n\n    svint32_t sv_delimiter = svdup_s32(delimiter);\n    size_t num_elements = numbers.size();\n    size_t result_size = 2 * num_elements - 1;\n    result.resize(result_size);\n\n    const int *input_ptr = numbers.data();\n    int *output_ptr = result.data();\n\n    svbool_t pg;\n    do {\n        // Load up to VL elements from the input array\n        svint32_t sv_numbers = svld1_s32(pg, input_ptr);\n\n        // Create a predicate for the positions where the delimiter should be inserted\n        svbool_t delimiter_pg = svnot_b_z(pg, svindex_s32(0, 1));\n        delimiter_pg = svand_b_z(pg, delimiter_pg, svwhilelt_b32(0, svcntb(pg) - 1));\n\n        // Scatter the numbers and delimiters to the output array\n        svst1_scatter_offset_s32(svindex_s32(0, 2), output_ptr, sv_numbers);\n        svst1_scatter_offset_s32(svindex_s32(1, 2), output_ptr, sv_delimiter, delimiter_pg);\n\n        // Move pointers and update the predicate\n        input_ptr += svcntw(pg);\n        output_ptr += 2 * svcntw(pg);\n        pg = svwhilelt_b32(input_ptr, numbers.data() + num_elements);\n    } while (svptest_any(svptrue_b32(), pg));\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimiter) {\n    std::vector<int> result;\n    if (numbers.empty()) {\n        return result;\n    }\n\n    size_t n = numbers.size();\n    size_t result_size = 2 * n - 1;\n    result.resize(result_size);\n\n    svint32_t sv_delimiter = svdup_s32(delimiter);\n    size_t i = 0;\n\n    while (i < n) {\n        size_t vl = svcntw();\n        if (i + vl > n) {\n            vl = n - i;\n        }\n\n        svint32_t sv_numbers = svld1_s32(svundef_s32(), &numbers[i]);\n        svint32_t sv_result = svinterleave_s32(sv_numbers, sv_delimiter);\n\n        size_t store_vl = 2 * vl - 1;\n        if (i + vl == n) {\n            store_vl = 2 * vl - 1;\n        } else {\n            store_vl = 2 * vl;\n        }\n\n        svst1_s32(&result[2 * i], svext(sv_result, sv_result, store_vl));\n\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    if (numbers.empty()) {\n        return {sum, product};\n    }\n\n    svbool_t pg = svptrue_b16();\n    svint16_t vsum = svdup_n_s16(0);\n    svint16_t vprod = svdup_n_s16(1);\n\n    size_t i = 0;\n    for (; i <= numbers.size() - svcntw(); i += svcntw()) {\n        svint16_t vec = svld1_s16(pg, &numbers[i]);\n        vsum = svadd_s16_m(pg, vsum, vec);\n        vprod = svmul_s16_m(pg, vprod, vec);\n    }\n\n    int16_t sum_array[svcntw()];\n    int16_t prod_array[svcntw()];\n    svst1_s16(pg, sum_array, vsum);\n    svst1_s16(pg, prod_array, vprod);\n\n    for (size_t j = 0; j < svcntw(); ++j) {\n        sum += sum_array[j];\n        product *= prod_array[j];\n    }\n\n    for (; i < numbers.size(); ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    if (numbers.empty()) {\n        return {sum, product};\n    }\n\n    svbool_t pg = svptrue_b16();\n    svint16_t vsum = svdup_n_s16(0);\n    svint16_t vprod = svdup_n_s16(1);\n\n    size_t i = 0;\n    for (; i <= numbers.size() - svcntw(); i += svcntw()) {\n        svint16_t vec = svld1_s16(pg, &numbers[i]);\n        vsum = svadd_s16_m(pg, vsum, vec);\n        vprod = svmul_s16_m(pg, vprod, vec);\n    }\n\n    int16_t sum_array[svcntw()];\n    int16_t prod_array[svcntw()];\n    svst1_s16(pg, sum_array, vsum);\n    svst1_s16(pg, prod_array, vprod);\n\n    for (size_t j = 0; j < svcntw(); ++j) {\n        sum += sum_array[j];\n        product *= prod_array[j];\n    }\n\n    for (; i < numbers.size(); ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    if (numbers.empty()) {\n        return {sum, product};\n    }\n\n    svbool_t pg = svptrue_b16();\n    svint16_t vsum = svdup_n_s16(0);\n    svint16_t vprod = svdup_n_s16(1);\n\n    size_t i = 0;\n    for (; i <= numbers.size() - svcntw(); i += svcntw()) {\n        svint16_t vec = svld1_s16(pg, &numbers[i]);\n        vsum = svadd_s16_m(pg, vsum, vec);\n        vprod = svmul_s16_m(pg, vprod, vec);\n    }\n\n    int16_t sum_arr[svcntw()];\n    int16_t prod_arr[svcntw()];\n    svst1_s16(pg, sum_arr, vsum);\n    svst1_s16(pg, prod_arr, vprod);\n\n    for (size_t j = 0; j < svcntw(); ++j) {\n        sum += sum_arr[j];\n        product *= prod_arr[j];\n    }\n\n    for (; i < numbers.size(); ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    if (numbers.empty()) {\n        return {sum, product};\n    }\n\n    svbool_t pg = svptrue_b16();\n    svint16_t vsum = svdup_n_s16(0);\n    svint16_t vprod = svdup_n_s16(1);\n\n    size_t i = 0;\n    for (; i <= numbers.size() - svcntw(); i += svcntw()) {\n        svint16_t vec = svld1_s16(pg, &numbers[i]);\n        vsum = svadd_s16_m(pg, vsum, vec);\n        vprod = svmul_s16_m(pg, vprod, vec);\n    }\n\n    int16_t sum_arr[svcntw()], prod_arr[svcntw()];\n    svst1_s16(pg, sum_arr, vsum);\n    svst1_s16(pg, prod_arr, vprod);\n\n    for (size_t j = 0; j < svcntw(); ++j) {\n        sum += sum_arr[j];\n        product *= prod_arr[j];\n    }\n\n    for (; i < numbers.size(); ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    if (numbers.empty()) {\n        return {sum, product};\n    }\n\n    svbool_t pg = svptrue_b16();\n    svint16_t vsum = svdup_n_s16(0);\n    svint16_t vprod = svdup_n_s16(1);\n\n    size_t i = 0;\n    for (; i <= numbers.size() - svcntw(); i += svcntw()) {\n        svint16_t vec = svld1_s16(pg, &numbers[i]);\n        vsum = svadd_s16_m(pg, vsum, vec);\n        vprod = svmul_s16_m(pg, vprod, vec);\n    }\n\n    int16_t sum_arr[svcntw()];\n    int16_t prod_arr[svcntw()];\n    svst1_s16(pg, sum_arr, vsum);\n    svst1_s16(pg, prod_arr, vprod);\n\n    for (size_t j = 0; j < svcntw(); ++j) {\n        sum += sum_arr[j];\n        product *= prod_arr[j];\n    }\n\n    for (; i < numbers.size(); ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    std::vector<int> result(numbers.size());\n    if (numbers.empty()) return result;\n\n    int *input = numbers.data();\n    int *output = result.data();\n    size_t n = numbers.size();\n\n    svint32_t max_vec = svdup_s32(input[0]);\n    output[0] = input[0];\n\n    for (size_t i = 1; i < n; ) {\n        size_t vl = svcntw();\n        svint32_t vec = svld1_s32(svundef_s32(), &input[i], svptrue_b32());\n        max_vec = svmax_s32_z(svptrue_b32(), max_vec, vec);\n        svst1_s32(svundef_s32(), &output[i], max_vec, svptrue_b32());\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    std::vector<int> result(numbers.size());\n    if (numbers.empty()) return result;\n\n    int *input = numbers.data();\n    int *output = result.data();\n    size_t n = numbers.size();\n\n    svint32_t max_vec = svdup_s32(input[0]);\n    output[0] = input[0];\n\n    for (size_t i = 1; i < n; ) {\n        size_t vl = svcntw();\n        if (i + vl > n) {\n            vl = n - i;\n        }\n\n        svint32_t vec = svld1_s32(svundef_s32(), &input[i], svptrue_b32());\n        max_vec = svmax_s32(max_vec, vec);\n        svst1_s32(svundef_s32(), &output[i], max_vec, svptrue_b32());\n\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    std::vector<int> result(numbers.size());\n    if (numbers.empty()) return result;\n\n    int *input = numbers.data();\n    int *output = result.data();\n    size_t n = numbers.size();\n\n    svint32_t max_vec = svdup_s32(input[0]);\n    output[0] = input[0];\n\n    for (size_t i = 1; i < n; ) {\n        size_t vl = svcntw();\n        svint32_t vec = svld1_s32(svundef_s32(), &input[i], svptrue_b32());\n        max_vec = svmax_s32_z(svptrue_b32(), max_vec, vec);\n        svst1_s32(svundef_s32(), &output[i], max_vec, svptrue_b32());\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    std::vector<int> result(numbers.size());\n    if (numbers.empty()) return result;\n\n    int *input = numbers.data();\n    int *output = result.data();\n    size_t n = numbers.size();\n\n    svint32_t max_vec = svdup_s32(input[0]);\n    output[0] = input[0];\n\n    for (size_t i = 1; i < n; ) {\n        size_t vl = svcntw();\n        svint32_t vec = svld1_s32(svundef_s32(), &input[i], svptrue_b32());\n        max_vec = svmax_s32_z(svptrue_b32(), max_vec, vec);\n        svst1_s32(svundef_s32(), &output[i], max_vec, svptrue_b32());\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    std::vector<int> result(numbers.size());\n    if (numbers.empty()) return result;\n\n    int *input = numbers.data();\n    int *output = result.data();\n    size_t n = numbers.size();\n\n    svint32_t max_vec = svdup_s32(input[0]);\n    output[0] = input[0];\n\n    for (size_t i = 1; i < n;) {\n        size_t vl = svcntw();\n        svint32_t vec = svld1_s32(svundef_s32(), &input[i], svptrue_b32());\n        max_vec = svmax_s32_z(svptrue_b32(), max_vec, vec);\n        svst1_s32(svundef_s32(), &output[i], max_vec, svptrue_b32());\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.length();\n    if (b.length() != len) {\n        throw std::invalid_argument(\"Strings must be of the same length\");\n    }\n\n    std::string result(len, '0');\n\n    const char *pa = a.c_str();\n    const char *pb = b.c_str();\n    char *pr = result.data();\n\n    svbool_t pg;\n    svuint8_t va, vb, vxor;\n\n    for (size_t i = 0; i < len; i += svcntb()) {\n        size_t vl = svmin(svcntb(), len - i);\n        pg = svwhilelt_b8(i, len);\n\n        va = svld1(pg, reinterpret_cast<const uint8_t*>(pa + i));\n        vb = svld1(pg, reinterpret_cast<const uint8_t*>(pb + i));\n\n        vxor = sveor_z(pg, va, vb);\n\n        svst1(pg, reinterpret_cast<uint8_t*>(pr + i), vxor);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.length();\n    if (len != b.length()) {\n        throw std::invalid_argument(\"Strings must be of the same length\");\n    }\n\n    std::string result(len, '0');\n    const char* a_ptr = a.c_str();\n    const char* b_ptr = b.c_str();\n    char* result_ptr = result.data();\n\n    svbool_t pg;\n    svuint8_t vec_a, vec_b, vec_result;\n\n    for (size_t i = 0; i < len; i += svcntb()) {\n        size_t vl = svmin(svcntb(), len - i);\n        pg = svwhilelt_b8(i, len);\n\n        vec_a = svld1(pg, reinterpret_cast<const uint8_t*>(a_ptr + i));\n        vec_b = svld1(pg, reinterpret_cast<const uint8_t*>(b_ptr + i));\n\n        vec_result = sveor_z(pg, vec_a, vec_b);\n\n        svst1(pg, reinterpret_cast<uint8_t*>(result_ptr + i), vec_result);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.length();\n    if (len != b.length()) {\n        return \"\";\n    }\n\n    std::string result(len, '0');\n    const char *a_ptr = a.c_str();\n    const char *b_ptr = b.c_str();\n    char *result_ptr = result.data();\n\n    svbool_t pg;\n    svuint8_t vec_a, vec_b, vec_result;\n\n    for (size_t i = 0; i < len; i += svcntb()) {\n        size_t vl = svmin(svcntb(), len - i);\n        pg = svwhilelt_b8(i, len);\n\n        vec_a = svld1(pg, reinterpret_cast<const uint8_t*>(a_ptr + i));\n        vec_b = svld1(pg, reinterpret_cast<const uint8_t*>(b_ptr + i));\n\n        vec_result = sveor_z(pg, vec_a, vec_b);\n\n        svst1(pg, reinterpret_cast<uint8_t*>(result_ptr + i), vec_result);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.length();\n    if (b.length() != len) {\n        return \"\";\n    }\n\n    std::string result(len, '0');\n    const char* a_ptr = a.c_str();\n    const char* b_ptr = b.c_str();\n    char* result_ptr = result.data();\n\n    svbool_t pg;\n    svuint8_t vec_a, vec_b, vec_result;\n\n    for (size_t i = 0; i < len; i += svcntb()) {\n        size_t vl = svmin(svcntb(), len - i);\n        pg = svwhilelt_b8(i, len);\n\n        vec_a = svld1(pg, reinterpret_cast<const uint8_t*>(a_ptr + i));\n        vec_b = svld1(pg, reinterpret_cast<const uint8_t*>(b_ptr + i));\n\n        vec_result = sveor_z(pg, vec_a, vec_b);\n\n        svst1(pg, reinterpret_cast<uint8_t*>(result_ptr + i), vec_result);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.length();\n    if (len != b.length()) {\n        throw std::invalid_argument(\"Strings must be of equal length\");\n    }\n\n    std::string result(len, '0');\n    const char* a_ptr = a.c_str();\n    const char* b_ptr = b.c_str();\n    char* result_ptr = result.data();\n\n    svbool_t pg;\n    svuint8_t vec_a, vec_b, vec_result;\n\n    for (size_t i = 0; i < len; i += svcntb()) {\n        size_t vl = svmin(svcntb(), len - i);\n        pg = svwhilelt_b8(i, len);\n\n        vec_a = svld1(pg, reinterpret_cast<const uint8_t*>(a_ptr + i));\n        vec_b = svld1(pg, reinterpret_cast<const uint8_t*>(b_ptr + i));\n\n        vec_result = sveor_z(pg, vec_a, vec_b);\n\n        svst1(pg, reinterpret_cast<uint8_t*>(result_ptr + i), vec_result);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::string longest_simd(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return {};\n    }\n\n    size_t max_length = 0;\n    size_t max_index = 0;\n\n    size_t num_strings = strings.size();\n    size_t i = 0;\n\n    while (i < num_strings) {\n        svbool_t pg = svwhilelt_b64(i, num_strings);\n        svuint64_t lengths = svdup_u64(0);\n\n        for (size_t j = 0; j < svcntb() && i + j < num_strings; ++j) {\n            lengths = svset1_u64(lengths, j, strings[i + j].length());\n        }\n\n        svuint64_t max_lengths = svmaxv_u64_m(pg, lengths, 0);\n        size_t local_max_length = max_lengths;\n\n        if (local_max_length > max_length) {\n            max_length = local_max_length;\n            max_index = i + svindex_u64(pg, 0)[svfirstb(svcmpeq_u64(pg, lengths, max_lengths))];\n        }\n\n        i += svcntb();\n    }\n\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::string longest_simd(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return {};\n    }\n\n    size_t max_length = 0;\n    size_t max_index = 0;\n\n    svbool_t pg = svptrue_b64();\n    size_t num_elements = strings.size();\n    size_t i = 0;\n\n    while (i < num_elements) {\n        size_t vl = svcntb(pg);\n        svuint64_t lengths = svdup_u64(0);\n\n        for (size_t j = 0; j < vl && i + j < num_elements; ++j) {\n            lengths = svset1_u64(lengths, j, strings[i + j].length());\n        }\n\n        svuint64_t max_lengths = svmaxv_u64_m(pg, lengths);\n        size_t local_max_index = svindexOf_u64_m(svcmpeq_u64(pg, lengths, max_lengths), lengths);\n\n        if (svptest_any(svptrue_b64(), svcmpeq_u64(pg, lengths, max_lengths))) {\n            if (strings[i + local_max_index].length() > max_length) {\n                max_length = strings[i + local_max_index].length();\n                max_index = i + local_max_index;\n            }\n        }\n\n        i += vl;\n    }\n\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::string longest_simd(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    size_t max_length = 0;\n    size_t max_index = 0;\n\n    svbool_t pg;\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < strings.size(); i += vl) {\n        svuint32_t lengths = svdup_u32(0);\n        pg = svwhilelt_b32(i, strings.size());\n\n        for (size_t j = 0; j < vl && i + j < strings.size(); ++j) {\n            lengths = svset1_u32(lengths, j, strings[i + j].length());\n        }\n\n        svuint32_t max_lengths = svmaxv_u32_m(pg, lengths, 0);\n        size_t local_max_index = svindex_u32(0, 1, vl);\n        local_max_index = svadd_u32_z(pg, local_max_index, svdup_u32(i));\n\n        svbool_t max_mask = sveq_u32(pg, lengths, svdup_u32(max_lengths));\n        size_t local_max_pos = svindex_u32(0, 1, vl);\n        local_max_pos = svsel_u32(max_mask, local_max_index, svdup_u32(0));\n\n        size_t local_max = svmaxv_u32_m(pg, local_max_pos, 0);\n\n        if (strings[local_max].length() > max_length) {\n            max_length = strings[local_max].length();\n            max_index = local_max;\n        }\n    }\n\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::string longest_simd(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    size_t max_length = 0;\n    size_t max_index = 0;\n\n    size_t num_strings = strings.size();\n    size_t i = 0;\n\n    while (i < num_strings) {\n        svbool_t pg = svwhilelt_b64(i, num_strings);\n        svuint64_t lengths = svdup_u64(0);\n\n        for (size_t j = 0; j < svcntb() && i + j < num_strings; ++j) {\n            lengths = svset1_u64(lengths, j, strings[i + j].length());\n        }\n\n        svuint64_t max_lengths = svmaxv_u64_m(pg, lengths);\n        size_t local_max_length = max_lengths;\n\n        if (local_max_length > max_length) {\n            max_length = local_max_length;\n            max_index = i + svindex_u64(svcmpeq_u64(pg, lengths, svdup_u64(local_max_length)), 0, 1)[0];\n        }\n\n        i += svcntb();\n    }\n\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::string longest_simd(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return {};\n    }\n\n    size_t max_length = 0;\n    size_t max_index = 0;\n\n    size_t num_strings = strings.size();\n    size_t i = 0;\n\n    while (i < num_strings) {\n        svbool_t pg = svwhilelt_b64(i, num_strings);\n        svuint64_t lengths = svdup_u64(0);\n\n        for (size_t j = 0; j < svcntb() && i + j < num_strings; ++j) {\n            lengths = svset1_u64(lengths, j, strings[i + j].length());\n        }\n\n        svuint64_t max_lengths = svmaxv_u64_m(pg, lengths, 0);\n        size_t local_max_length = max_lengths;\n\n        if (local_max_length > max_length) {\n            max_length = local_max_length;\n            max_index = i + svindex_u64(svcmpeq_u64(pg, lengths, svdup_u64(local_max_length)), 0, 1)[0];\n        }\n\n        i += svcntb();\n    }\n\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b){\n    svuint64_t vec_a = svdup_u64(a);\n    svuint64_t vec_b = svdup_u64(b);\n\n    while (svany(svne_u64(vec_a, vec_b))) {\n        svbool_t pg = svgt_u64(vec_a, vec_b);\n        vec_a = svsel_u64(pg, svsub_u64_m(pg, vec_a, vec_b), vec_a);\n        vec_b = svsel_u64(svnot_b_z(pg, pg), svsub_u64_m(svnot_b_z(pg, pg), vec_b, vec_a), vec_b);\n    }\n\n    return svlastb_u64(sve_true_b(), vec_a);\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b){\n    svuint64_t vec_a = svdup_u64(a);\n    svuint64_t vec_b = svdup_u64(b);\n\n    while (svany(svne_u64(vec_a, vec_b))) {\n        svbool_t pg = svgt_u64(vec_a, vec_b);\n        vec_a = svsel_u64(pg, svsub_u64_m(pg, vec_a, vec_b), vec_a);\n        vec_b = svsel_u64(svnot_b_z(pg, pg), svsub_u64_m(svnot_b_z(pg, pg), vec_b, vec_a), vec_b);\n    }\n\n    return svlastb_u64(sve_true_b(), vec_a);\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b){\n    svuint64_t vec_a = svdup_u64(a);\n    svuint64_t vec_b = svdup_u64(b);\n\n    while (svany(svne_u64(vec_a, vec_b))) {\n        svbool_t pg = svwhilelt_b64(0, 1);\n        svuint64_t temp = svsel_u64(svcmplt_u64(pg, vec_a, vec_b), vec_a, vec_b);\n        vec_b = svsel_u64(svcmplt_u64(pg, vec_a, vec_b), vec_b, svsub_u64_m(pg, vec_a, vec_b));\n        vec_a = temp;\n    }\n\n    return svlastb_u64(sve_true_b64(), vec_a);\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b){\n    svuint64_t vec_a = svdup_u64(a);\n    svuint64_t vec_b = svdup_u64(b);\n\n    while (svptest_any(svcmpne_u64(vec_a, vec_b))) {\n        svbool_t pg = svcmplt_u64(vec_a, vec_b);\n        vec_b = svsel_u64(pg, svsub_u64_z(pg, vec_b, vec_a), vec_b);\n        vec_a = svsel_u64(svnot_b(pg), svsub_u64_z(svnot_b(pg), vec_a, vec_b), vec_a);\n    }\n\n    return svlastb_u64(svptrue_b64(), vec_a);\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b){\n    svuint64_t vec_a = svdup_u64(a);\n    svuint64_t vec_b = svdup_u64(b);\n\n    while (svptest_any(svcmpne_u64(vec_a, vec_b))) {\n        svbool_t pg = svcmplt_u64(vec_a, vec_b);\n        vec_b = svsel_u64(pg, svsub_u64_z(pg, vec_b, vec_a), vec_b);\n        vec_a = svsel_u64(svnot_b(pg), svsub_u64_z(svnot_b(pg), vec_a, vec_b), vec_a);\n    }\n\n    return svlastb_u64(vec_a);\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_a = 0.0f;\n    float closest_b = 0.0f;\n\n    svbool_t pg = svptrue_b32();\n    svfloat32_t min_diff_vec = svdup_f32(min_diff);\n    svfloat32_t closest_a_vec = svdup_f32(closest_a);\n    svfloat32_t closest_b_vec = svdup_f32(closest_b);\n\n    size_t n = numbers.size();\n    for (size_t i = 0; i < n; ++i) {\n        svfloat32_t vec_i = svdup_f32(numbers[i]);\n        for (size_t j = i + 1; j < n; j += svcntw()) {\n            size_t length = svcntw() - (j + svcntw() > n ? j + svcntw() - n : 0);\n            svbool_t pg_j = svwhilelt_b32(0, length);\n            svfloat32_t vec_j = svld1(pg_j, &numbers[j]);\n\n            svfloat32_t diff = svabs_f32(svsub_f32(vec_i, vec_j));\n            svbool_t is_closer = svcmplt_f32(pg_j, diff, min_diff_vec);\n\n            min_diff_vec = svsel_f32(is_closer, diff, min_diff_vec);\n            closest_a_vec = svsel_f32(is_closer, vec_i, closest_a_vec);\n            closest_b_vec = svsel_f32(is_closer, vec_j, closest_b_vec);\n        }\n    }\n\n    min_diff = svgetlane_f32(svreinterpret_f32_u32(svminv_u32_z(pg, svreinterpret_u32_f32(min_diff_vec))), 0);\n    closest_a = svgetlane_f32(svmin_f32_z(pg, closest_a_vec, closest_b_vec), 0);\n    closest_b = svgetlane_f32(svmax_f32_z(pg, closest_a_vec, closest_b_vec), 0);\n\n    return {closest_a, closest_b};\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_a = 0.0f;\n    float closest_b = 0.0f;\n\n    svbool_t pg = svptrue_b32();\n    svfloat32_t min_diff_vec = svdup_f32(min_diff);\n    svfloat32_t closest_a_vec = svdup_f32(closest_a);\n    svfloat32_t closest_b_vec = svdup_f32(closest_b);\n\n    size_t n = numbers.size();\n    for (size_t i = 0; i < n; ++i) {\n        svfloat32_t vec_i = svdup_f32(numbers[i]);\n        for (size_t j = i + 1; j < n; j += svcntw()) {\n            size_t len = svcntw() - (j + svcntw() > n ? j + svcntw() - n : 0);\n            svbool_t pg_j = svwhilelt_b32(0, len);\n            svfloat32_t vec_j = svld1_f32(pg_j, &numbers[j]);\n\n            svfloat32_t diff = svabs_f32_z(pg_j, svsub_f32_z(pg_j, vec_i, vec_j));\n            svbool_t is_closer = svcmplt_f32(pg_j, diff, min_diff_vec);\n\n            min_diff_vec = svsel_f32(pg_j, svsel_f32(is_closer, diff, min_diff_vec), min_diff_vec);\n            closest_a_vec = svsel_f32(pg_j, svsel_f32(is_closer, vec_i, closest_a_vec), closest_a_vec);\n            closest_b_vec = svsel_f32(pg_j, svsel_f32(is_closer, vec_j, closest_b_vec), closest_b_vec);\n        }\n    }\n\n    min_diff = svgetlane_f32(svreinterpret_f32_u32(svminv_u32_z(pg, svreinterpret_u32_f32(min_diff_vec))), 0);\n    closest_a = svgetlane_f32(svreinterpret_f32_u32(svminv_u32_z(pg, svreinterpret_u32_f32(closest_a_vec))), 0);\n    closest_b = svgetlane_f32(svreinterpret_f32_u32(svminv_u32_z(pg, svreinterpret_u32_f32(closest_b_vec))), 0);\n\n    if (closest_a > closest_b) {\n        std::swap(closest_a, closest_b);\n    }\n\n    return {closest_a, closest_b};\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_a = 0.0f;\n    float closest_b = 0.0f;\n\n    svfloat32_t min_diff_vec = svdup_f32(min_diff);\n    svfloat32_t closest_a_vec = svdup_f32(closest_a);\n    svfloat32_t closest_b_vec = svdup_f32(closest_b);\n\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < numbers.size(); i += vl) {\n        svfloat32_t vec_i = svld1_f32(svptrue_b32(), &numbers[i]);\n\n        for (size_t j = i + 1; j < numbers.size(); j += vl) {\n            svfloat32_t vec_j = svld1_f32(svptrue_b32(), &numbers[j]);\n\n            svfloat32_t diff = svabs_f32(svsub_f32(vec_i, vec_j));\n            svbool_t is_closer = svcmplt_f32(diff, min_diff_vec);\n\n            min_diff_vec = svsel_f32(is_closer, diff, min_diff_vec);\n            closest_a_vec = svsel_f32(is_closer, svmin_f32(vec_i, vec_j), closest_a_vec);\n            closest_b_vec = svsel_f32(is_closer, svmax_f32(vec_i, vec_j), closest_b_vec);\n        }\n    }\n\n    min_diff = svminv_f32(svptrue_b32(), min_diff_vec);\n    closest_a = svminv_f32(svptrue_b32(), closest_a_vec);\n    closest_b = svminv_f32(svptrue_b32(), closest_b_vec);\n\n    return {closest_a, closest_b};\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_a = 0.0f;\n    float closest_b = 0.0f;\n\n    svfloat32_t min_diff_vec = svdup_f32(min_diff);\n    svfloat32_t closest_a_vec = svdup_f32(closest_a);\n    svfloat32_t closest_b_vec = svdup_f32(closest_b);\n\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < numbers.size(); i += vl) {\n        svfloat32_t vec_i = svld1_f32(svptrue_b32(), &numbers[i]);\n\n        for (size_t j = i + 1; j < numbers.size(); j += vl) {\n            svfloat32_t vec_j = svld1_f32(svptrue_b32(), &numbers[j]);\n\n            svfloat32_t diff = svabs_f32(svsub_f32(vec_i, vec_j));\n            svbool_t is_closer = svcmplt_f32(diff, min_diff_vec);\n\n            min_diff_vec = svsel_f32(is_closer, diff, min_diff_vec);\n            closest_a_vec = svsel_f32(is_closer, vec_i, closest_a_vec);\n            closest_b_vec = svsel_f32(is_closer, vec_j, closest_b_vec);\n        }\n    }\n\n    min_diff = svminv_f32(svptrue_b32(), min_diff_vec);\n    closest_a = svminv_f32(svptrue_b32(), closest_a_vec);\n    closest_b = svminv_f32(svptrue_b32(), closest_b_vec);\n\n    if (closest_a > closest_b) {\n        std::swap(closest_a, closest_b);\n    }\n\n    return {closest_a, closest_b};\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_a = 0.0f;\n    float closest_b = 0.0f;\n\n    svfloat32_t min_diff_vec = svdup_f32(min_diff);\n    svfloat32_t closest_a_vec = svdup_f32(closest_a);\n    svfloat32_t closest_b_vec = svdup_f32(closest_b);\n\n    size_t num_elements = numbers.size();\n    svbool_t pg = svptrue_b32();\n\n    for (size_t i = 0; i < num_elements; ++i) {\n        svfloat32_t vec_i = svld1(pg, &numbers[i]);\n        for (size_t j = i + 1; j < num_elements; ++j) {\n            svfloat32_t vec_j = svld1(pg, &numbers[j]);\n            svfloat32_t diff = svabs_f32(svsub_f32(vec_i, vec_j));\n            svbool_t is_closer = svcmplt_f32(pg, diff, min_diff_vec);\n\n            min_diff_vec = svsel_f32(is_closer, diff, min_diff_vec);\n            closest_a_vec = svsel_f32(is_closer, vec_i, closest_a_vec);\n            closest_b_vec = svsel_f32(is_closer, vec_j, closest_b_vec);\n        }\n    }\n\n    min_diff = svgetlane_f32(svptrue_b32(), min_diff_vec, 0);\n    closest_a = svgetlane_f32(svptrue_b32(), closest_a_vec, 0);\n    closest_b = svgetlane_f32(svptrue_b32(), closest_b_vec, 0);\n\n    if (closest_a > closest_b) {\n        std::swap(closest_a, closest_b);\n    }\n\n    return {closest_a, closest_b};\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    if (numbers.size() < 2) {\n        return numbers;\n    }\n\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n\n    svfloat32_t sv_min = svdup_f32(min_val);\n    svfloat32_t sv_range = svdup_f32(range);\n\n    size_t vl = svcntw();\n    size_t num_elements = numbers.size();\n    std::vector<float> result(num_elements);\n\n    for (size_t i = 0; i < num_elements; i += vl) {\n        svfloat32_t sv_numbers = svld1_f32(svptrue_b32(), &numbers[i]);\n        svfloat32_t sv_result = svsub_f32_z(svptrue_b32(), sv_numbers, sv_min);\n        sv_result = svdiv_f32_z(svptrue_b32(), sv_result, sv_range);\n        svst1_f32(svptrue_b32(), &result[i], sv_result);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    if (numbers.size() < 2) {\n        return numbers;\n    }\n\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n\n    svfloat32_t sv_min = svdup_f32(min_val);\n    svfloat32_t sv_range = svdup_f32(range);\n\n    size_t vl = svcntw();\n    size_t num_elements = numbers.size();\n    std::vector<float> result(num_elements);\n\n    for (size_t i = 0; i < num_elements; i += vl) {\n        svfloat32_t sv_numbers = svld1_f32(svundef_f32(), &numbers[i], svwhilelt_b32(svptrue_b32(), i, num_elements));\n        svfloat32_t sv_result = svdiv_f32_z(svptrue_b32(), svsub_f32_z(svptrue_b32(), sv_numbers, sv_min), sv_range);\n        svst1_f32(svwhilelt_b32(svptrue_b32(), i, num_elements), &result[i], sv_result);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    if (numbers.size() < 2) {\n        return numbers;\n    }\n\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n\n    svfloat32_t sv_min = svdup_f32(min_val);\n    svfloat32_t sv_range = svdup_f32(range);\n\n    size_t vl = svcntw();\n    size_t num_elements = numbers.size();\n\n    for (size_t i = 0; i < num_elements; i += vl) {\n        size_t length = svmin_z(svptrue_b32(), svindex_u32(0, 1), svdup_u32(num_elements - i));\n        svfloat32_t sv_numbers = svld1_f32(length, &numbers[i]);\n        svfloat32_t sv_rescaled = svdiv_f32_z(length, svsub_f32_z(length, sv_numbers, sv_min), sv_range);\n        svst1_f32(length, &numbers[i], sv_rescaled);\n    }\n\n    return numbers;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    if (numbers.size() < 2) {\n        return numbers;\n    }\n\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n\n    svfloat32_t sv_min = svdup_f32(min_val);\n    svfloat32_t sv_range = svdup_f32(range);\n\n    size_t vl = svcntw();\n    size_t num_elements = numbers.size();\n    std::vector<float> result(num_elements);\n\n    for (size_t i = 0; i < num_elements; i += vl) {\n        size_t length = svminnum_u32_z(svptrue_b32(), svlen_u32(vl), num_elements - i);\n        svbool_t pg = svwhilelt_b32(0, length);\n\n        svfloat32_t sv_numbers = svld1(pg, &numbers[i]);\n        svfloat32_t sv_result = svsub_f32_z(pg, sv_numbers, sv_min);\n        sv_result = svdiv_f32_z(pg, sv_result, sv_range);\n\n        svst1(pg, &result[i], sv_result);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    if (numbers.size() < 2) {\n        return numbers;\n    }\n\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n\n    svfloat32_t sv_min = svdup_f32(min_val);\n    svfloat32_t sv_range = svdup_f32(range);\n\n    size_t vl = svcntw();\n    size_t num_elements = numbers.size();\n\n    for (size_t i = 0; i < num_elements; i += vl) {\n        size_t length = svmin_z(svptrue_b32(), svindex_u32(0, 1), svdup_u32(num_elements - i));\n        svfloat32_t sv_numbers = svld1_f32(length, &numbers[i]);\n        svfloat32_t sv_rescaled = svdiv_f32_z(length, svsub_f32_z(length, sv_numbers, sv_min), sv_range);\n        svst1_f32(length, &numbers[i], sv_rescaled);\n    }\n\n    return numbers;\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t largest_divisor_simd(uint64_t n){\n    uint64_t result = 1;\n    svbool_t pg = svptrue_b64();\n    svuint64_t vn = svdup_u64(n);\n    svuint64_t vdivisor = svsub_u64_z(pg, vn, svindex_u64(2, 1));\n    \n    do {\n        svbool_t pred = sveor_b_z(pg, svcmpeq_u64(pg, svmul_u64_z(pg, vdivisor, svdiv_u64_z(pg, vn, vdivisor)), vn), svcmplt_u64(pg, vdivisor, vn));\n        if (svptest_any(svptrue_b64(), pred)) {\n            result = svlastb_u64(pred, vdivisor);\n        }\n        vdivisor = svsub_u64_z(pg, vdivisor, svdup_u64(1));\n    } while (svptest_any(svptrue_b64(), svcmpgt_u64(pg, vdivisor, svdup_u64(1))));\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t largest_divisor_simd(uint64_t n){\n    uint64_t result = 1;\n    svbool_t pg = svptrue_b64();\n    svuint64_t vn = svdup_u64(n);\n    svuint64_t vresult = svdup_u64(result);\n    svuint64_t vdivisor = svindex_u64(2, 1, pg);\n\n    do {\n        svbool_t pred = svcmplt(svptrue_b64(), vdivisor, vn);\n        svbool_t divisible = sveor_b_z(pg, pred, svcmpeq(svmul_m(pg, vn, svdiv_n_u64_z(pg, vn, vdivisor)), vn));\n        vresult = svsel_u64(divisible, vdivisor, vresult);\n        vdivisor = svadd_u64_m(pg, vdivisor, svdup_u64(1));\n    } while (svptest_any(svptrue_b64(), svcmplt(svptrue_b64(), vdivisor, vn)));\n\n    return svlastb_u64(vresult);\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t largest_divisor_simd(uint64_t n){\n    uint64_t result = 1;\n    svbool_t pg = svptrue_b64();\n    svuint64_t vn = svdup_u64(n);\n    svuint64_t vdivisor = svsub_u64_z(pg, vn, svindex_u64(2, 1));\n    \n    do {\n        svbool_t pred = sveor_b_z(pg, svcmpeq_u64(pg, svmul_u64_z(pg, vdivisor, svdiv_u64_z(pg, vn, vdivisor)), vn), svcmplt_u64(pg, vdivisor, vn));\n        if (svptest_any(svptrue_b64(), pred)) {\n            result = svlastb_u64(pred, vdivisor);\n        }\n        vdivisor = svsub_u64_z(pg, vdivisor, svdup_u64(1));\n    } while (svtest_any(svptrue_b64(), svcmpgt_u64(pg, vdivisor, svdup_u64(1))));\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t largest_divisor_simd(uint64_t n){\n    uint64_t result = 1;\n    svbool_t pg = svptrue_b64();\n    svuint64_t vn = svdup_u64(n);\n    svuint64_t vresult = svdup_u64(result);\n    svuint64_t vdivisor = svindex_u64(2, 1, pg);\n\n    do {\n        svbool_t pred = svcmplt(svptrue_b64(), vdivisor, vn);\n        svbool_t divisible = sveor_b_z(pg, pred, svcmpeq(svmul_u64_z(pred, vdivisor, svdiv_u64_z(pred, vn, vdivisor)), vn));\n        vresult = svsel_u64(divisible, vdivisor, vresult);\n        vdivisor = svadd_u64_z(pg, vdivisor, svdup_u64(1));\n    } while (svptest_any(svptrue_b64(), svcmplt(svptrue_b64(), vdivisor, vn)));\n\n    return svlastb_u64(vresult);\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t largest_divisor_simd(uint64_t n){\n    uint64_t result = 1;\n    svbool_t pg = svptrue_b64();\n    svuint64_t vn = svdup_u64(n);\n    svuint64_t vresult = svdup_u64(result);\n    svuint64_t vdivisor = svindex_u64(2, 1, pg);\n\n    do {\n        svbool_t pred = svcmplt(svptrue_b64(), vdivisor, vn);\n        svbool_t divisible = sveor_b_z(pg, pred, svcmpeq(svmul_m(pg, vn, svdiv_x(pg, vn, vdivisor)), vn));\n        vresult = svsel_u64(divisible, vdivisor, vresult);\n        vdivisor = svadd_x(pg, vdivisor, svdup_u64(1));\n    } while (svptest_any(svptrue_b64(), svcmplt(svptrue_b64(), vdivisor, vn)));\n\n    return svlastb_u64(vresult);\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    int divisor = 2;\n\n    while (n > 1) {\n        svint32_t v_divisor = svdup_s32(divisor);\n        svbool_t pg = svwhilelt_b32(0, divisor);\n        int count = 0;\n\n        while (svptest_any(svptrue_b32(), pg)) {\n            svint32_t v_n = svdup_s32(n);\n            svbool_t divisible = svcmpeq_s32(pg, svmod_s32_z(pg, v_n, v_divisor), svzero_s32());\n            count += svcntp_b32(svptrue_b32(), divisible);\n            v_n = svdiv_s32_z(pg, v_n, v_divisor);\n            n = svlastb(svptrue_b32(), v_n);\n            pg = svand_b_z(pg, pg, divisible);\n        }\n\n        for (int i = 0; i < count; ++i) {\n            factors.push_back(divisor);\n        }\n\n        divisor++;\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    int divisor = 2;\n\n    while (n > 1) {\n        svint32_t v_divisor = svdup_s32(divisor);\n        svbool_t pg = svwhilelt_b32(0, divisor);\n        int count = 0;\n\n        while (svptest_any(svptrue_b32(), pg)) {\n            svint32_t v_n = svdup_s32(n);\n            svbool_t divisible = svcmplt_s32(pg, svmod_s32_z(pg, v_n, v_divisor), svdup_s32(1));\n            if (svptest_any(svptrue_b32(), divisible)) {\n                n /= divisor;\n                count++;\n            } else {\n                break;\n            }\n        }\n\n        for (int i = 0; i < count; ++i) {\n            factors.push_back(divisor);\n        }\n\n        divisor++;\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    int divisor = 2;\n\n    while (n > 1) {\n        svint32_t v_n = svdup_s32(n);\n        svint32_t v_divisor = svdup_s32(divisor);\n        svbool_t pg = svwhilelt_b32(svptrue_b32(), 0, 1);\n\n        while (svptest_any(svptrue_b32(), svcmpeq_s32(pg, svmod_s32_z(pg, v_n, v_divisor), svdup_s32(0)))) {\n            n /= divisor;\n            factors.push_back(divisor);\n            v_n = svdup_s32(n);\n        }\n\n        divisor++;\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    int divisor = 2;\n\n    while (n > 1) {\n        svint32_t v_divisor = svdup_s32(divisor);\n        svbool_t pg = svwhilelt_b32(0, n);\n        svint32_t v_n = svdup_s32(n);\n\n        while (svptest_any(svptrue_b32(), svcmpeq_s32(pg, svmod_s32_z(pg, v_n, v_divisor), svdup_s32(0)))) {\n            n /= divisor;\n            factors.push_back(divisor);\n            v_n = svdup_s32(n);\n        }\n\n        divisor++;\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    int divisor = 2;\n\n    while (n > 1) {\n        svint32_t v_divisor = svdup_s32(divisor);\n        svbool_t pg = svwhilelt_b32(0, divisor);\n        int count = 0;\n\n        while (svptest_any(svptrue_b32(), pg)) {\n            svint32_t v_n = svdup_s32(n);\n            svbool_t divisible = svcmplt_s32(pg, svmod_s32_z(pg, v_n, v_divisor), svdup_s32(1));\n            if (svptest_any(svptrue_b32(), divisible)) {\n                n /= divisor;\n                count++;\n            } else {\n                break;\n            }\n        }\n\n        for (int i = 0; i < count; ++i) {\n            factors.push_back(divisor);\n        }\n\n        divisor++;\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    size_t num_elements = l.size();\n    const float *input_ptr = l.data();\n\n    svbool_t pg = svptrue_b32();\n    size_t i = 0;\n\n    while (i < num_elements) {\n        svfloat32_t vec = svld1_f32(pg, input_ptr + i);\n        svbool_t pos_mask = svcmpgt_f32(pg, vec, svdup_n_f32(0.0f));\n        size_t valid_elements = svcntp_b32(pos_mask);\n\n        if (valid_elements > 0) {\n            float temp[SVF32_MAX];\n            svst1_f32(svcompress_b32(pos_mask, pg), temp, vec);\n            result.insert(result.end(), temp, temp + valid_elements);\n        }\n\n        i += svcntb/pg;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    size_t num_elements = l.size();\n    const float *input_ptr = l.data();\n\n    // Process the input vector in chunks of svcntf_f32() elements\n    while (num_elements > 0) {\n        // Create an SVE vector from the input data\n        svbool_t pg = svwhilelt_b32(0, num_elements);\n        svfloat32_t vec = svld1(pg, input_ptr);\n\n        // Compare the vector with zero to get a predicate of positive numbers\n        svbool_t pos_mask = svcmpgt_f32(pg, vec, svdup_n_f32(0.0f));\n\n        // Count the number of positive elements in the current vector\n        size_t pos_count = svcntp_b32(pos_mask);\n\n        // Gather the positive elements into a new vector\n        svfloat32_t pos_vec = svsel_f32(pos_mask, vec, svdup_n_f32(0.0f));\n\n        // Store the positive elements into the result vector\n        for (size_t i = 0; i < pos_count; ++i) {\n            result.push_back(svget1_f32(pos_vec, i));\n        }\n\n        // Move to the next chunk of elements\n        input_ptr += svcntf_f32();\n        num_elements -= svcntf_f32();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    size_t num_elements = l.size();\n    const float *input_ptr = l.data();\n\n    while (num_elements > 0) {\n        svbool_t pg = svwhilelt_bf32(0, num_elements);\n        svfloat32_t vec = svld1(pg, input_ptr);\n        svbool_t pos_mask = svcmpgt(svunpklo_f32_z(pg, vec), svdup_n_f32(0.0f));\n        pos_mask = svorr_b_z(pg, pos_mask, svcmpgt(svunpkhi_f32_z(pg, vec), svdup_n_f32(0.0f)));\n\n        size_t active_elements = svcntp_b(pg, pos_mask);\n        result.resize(result.size() + active_elements);\n\n        svst1(pos_mask, &result[result.size() - active_elements], svunpklo_f32_z(pg, vec));\n        svst1(pos_mask, &result[result.size() - active_elements], svunpkhi_f32_z(pg, vec));\n\n        input_ptr += svcntb() / sizeof(float);\n        num_elements -= svcntb() / sizeof(float);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    size_t num_elements = l.size();\n    const float *input_ptr = l.data();\n\n    while (num_elements > 0) {\n        svbool_t pg = svwhilelt_bf32(0, num_elements);\n        svfloat32_t vec = svld1(pg, input_ptr);\n        svbool_t pos_mask = svcmpgt(svptrue_bf32(), vec, svdup_f32(0.0f));\n        size_t active_elements = svcntp_b32(pos_mask);\n\n        if (active_elements > 0) {\n            float temp_buffer[SVF32_MAX];\n            svst1(pos_mask, temp_buffer, vec);\n            result.insert(result.end(), temp_buffer, temp_buffer + active_elements);\n        }\n\n        input_ptr += num_elements;\n        num_elements -= svcntb();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    size_t num_elements = l.size();\n    const float *input_ptr = l.data();\n\n    svbool_t pg = svptrue_b32();\n    size_t i = 0;\n\n    while (i < num_elements) {\n        svfloat32_t vec = svld1_f32(pg, input_ptr + i);\n        svbool_t pos_mask = svcmpgt_f32(pg, vec, svdup_n_f32(0.0f));\n        size_t valid_elements = svcntp_b32(pos_mask);\n\n        if (valid_elements > 0) {\n            float temp[SVF32_MAX];\n            svst1_f32(svcompress_b32(pos_mask, pg), temp, vec);\n            result.insert(result.end(), temp, temp + valid_elements);\n        }\n\n        i += svcntb();\n        pg = svwhilelt_b32(i, num_elements);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <stdbool.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t i = 5;\n    while (i * i <= n) {\n        svint64_t v_i = svdup_s64(i);\n        svint64_t v_n = svdup_s64(n);\n        svint64_t v_i_plus_2 = svadd_s64_z(svptrue_b64(), v_i, svdup_s64(2));\n        svint64_t v_i_plus_4 = svadd_s64_z(svptrue_b64(), v_i, svdup_s64(4));\n\n        svbool_t pg = svwhilelt_b64(v_i, v_n);\n        svbool_t pg_plus_2 = svwhilelt_b64(v_i_plus_2, v_n);\n        svbool_t pg_plus_4 = svwhilelt_b64(v_i_plus_4, v_n);\n\n        if (!svptest_any(svptrue_b64(), svmul_s64_z(pg, v_n, v_i)) &&\n            !svptest_any(svptrue_b64(), svmul_s64_z(pg_plus_2, v_n, v_i_plus_2)) &&\n            !svptest_any(svptrue_b64(), svmul_s64_z(pg_plus_4, v_n, v_i_plus_4))) {\n            i += 6;\n        } else {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <stdbool.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t i = 5;\n    while (i * i <= n) {\n        svint64_t v_i = svdup_s64(i);\n        svint64_t v_n = svdup_s64(n);\n        svint64_t v_i_plus_2 = svadd_s64_z(svptrue_b64(), v_i, svdup_s64(2));\n        svint64_t v_i_plus_4 = svadd_s64_z(svptrue_b64(), v_i, svdup_s64(4));\n\n        svbool_t pg = svle_s64(svmla_s64_z(svptrue_b64(), v_i, v_i, v_i_plus_2), v_n);\n        if (svptest_any(svptrue_b64(), pg)) return false;\n\n        pg = svle_s64(svmla_s64_z(svptrue_b64(), v_i, v_i, v_i_plus_4), v_n);\n        if (svptest_any(svptrue_b64(), pg)) return false;\n\n        i += 6;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <stdbool.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t i = 5;\n    while (i * i <= n) {\n        svint64_t v_i = svdup_s64(i);\n        svint64_t v_n = svdup_s64(n);\n        svint64_t v_step = svdup_s64(6);\n\n        svbool_t pg = svwhilelt_b64(0, i);\n        do {\n            svint64_t v_div1 = svdiv_s64_z(pg, v_n, v_i);\n            svint64_t v_div2 = svdiv_s64_z(pg, v_n, svadd_s64_z(pg, v_i, svdup_s64(2)));\n            svbool_t v_eq1 = sveq_s64(pg, svmul_s64_z(pg, v_div1, v_i), v_n);\n            svbool_t v_eq2 = sveq_s64(pg, svmul_s64_z(pg, v_div2, svadd_s64_z(pg, v_i, svdup_s64(2))), v_n);\n            svbool_t v_any_eq = svany(vorr_b(pg, v_eq1, v_eq2));\n            if (svptest_any(svptrue_b64(), v_any_eq)) {\n                return false;\n            }\n            v_i = svadd_s64_z(pg, v_i, v_step);\n            pg = svwhilelt_b64(i, n);\n        } while (svptest_any(svptrue_b64(), pg));\n\n        i += 6;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <stdbool.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t i = 5;\n    while (i * i <= n) {\n        svint64_t v_i = svdup_s64(i);\n        svint64_t v_i_plus_2 = svadd_s64(v_i, svdup_s64(2));\n        svint64_t v_n = svdup_s64(n);\n\n        svbool_t pg = svwhilelt_b64(0, i);\n        svbool_t cond1 = svcmpeq_s64(pg, svmod_s64_z(pg, v_n, v_i), svdup_s64(0));\n        svbool_t cond2 = svcmpeq_s64(pg, svmod_s64_z(pg, v_n, v_i_plus_2), svdup_s64(0));\n\n        if (svptest_any(svptrue_b64(), cond1) || svptest_any(svptrue_b64(), cond2)) {\n            return false;\n        }\n\n        i += 6;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <stdbool.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t i = 5;\n    while (i * i <= n) {\n        svint64_t v_i = svdup_s64(i);\n        svint64_t v_step = svdup_s64(6);\n        svint64_t v_n = svdup_s64(n);\n\n        svbool_t pg = svwhilelt_b64(0, i);\n        do {\n            svint64_t v_div1 = svdiv_s64_z(pg, v_n, v_i);\n            svint64_t v_div2 = svdiv_s64_z(pg, v_n, svadd_s64_z(pg, v_i, svdup_s64(2)));\n            svbool_t v_not_prime1 = svcmpeq_s64(pg, svmul_s64_z(pg, v_div1, v_i), v_n);\n            svbool_t v_not_prime2 = svcmpeq_s64(pg, svmul_s64_z(pg, v_div2, svadd_s64_z(pg, v_i, svdup_s64(2))), v_n);\n            svbool_t v_not_prime = svorr_b_z(pg, v_not_prime1, v_not_prime2);\n\n            if (svptest_any(svptrue_b64(), v_not_prime)) {\n                return false;\n            }\n\n            v_i = svadd_s64_z(pg, v_i, v_step);\n            pg = svwhilelt_b64(i, n);\n        } while (svptest_any(svptrue_b64(), pg));\n\n        i += 6;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s) {\n    size_t len = s.length();\n    if (len == 0) return s;\n\n    // Check if there are any letters in the string\n    svbool_t pg = svptrue_b8();\n    svuint8_t str_vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.data()));\n    svbool_t has_letters = svany(svor_z(pg, svcle_b8_z(pg, str_vec, svdup_u8('z')), svcle_b8_z(pg, str_vec, svdup_u8('Z'))));\n\n    if (!svptest_any(svptrue_b8(), has_letters)) {\n        // No letters, reverse the string\n        std::string result = s;\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n\n    // Allocate space for the result\n    std::string result(len, ' ');\n\n    // Process the string to reverse the case of letters\n    size_t i = 0;\n    while (i < len) {\n        size_t vl = svcntb();\n        if (i + vl > len) vl = len - i;\n        pg = svwhilelt_b8(i, len);\n\n        str_vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.data() + i));\n        svbool_t is_lower = svand_z(pg, svcle_b8_z(pg, str_vec, svdup_u8('z')), svcle_b8_z(pg, svdup_u8('a'), str_vec));\n        svbool_t is_upper = svand_z(pg, svcle_b8_z(pg, str_vec, svdup_u8('Z')), svcle_b8_z(pg, svdup_u8('A'), str_vec));\n\n        svuint8_t lower_to_upper = svsub_z(pg, str_vec, svdup_u8('a' - 'A'));\n        svuint8_t upper_to_lower = svadd_z(pg, str_vec, svdup_u8('a' - 'A'));\n\n        svuint8_t result_vec = svsel_z(pg, is_lower, lower_to_upper, str_vec);\n        result_vec = svsel_z(pg, is_upper, upper_to_lower, result_vec);\n\n        svst1_u8(pg, reinterpret_cast<uint8_t*>(result.data() + i), result_vec);\n\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s) {\n    size_t len = s.length();\n    if (len == 0) return s;\n\n    // Check if there are any letters in the string\n    svbool_t pg = svptrue_b8();\n    svuint8_t str_vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.data()));\n    svbool_t has_letters = svany(svorr_z(pg, svcollt_z(pg, str_vec, svdup_u8('a')), svcollt_z(pg, str_vec, svdup_u8('A'))));\n\n    if (!has_letters) {\n        std::string reversed_s = s;\n        std::reverse(reversed_s.begin(), reversed_s.end());\n        return reversed_s;\n    }\n\n    // Allocate space for the result\n    std::string result(len, ' ');\n\n    do {\n        size_t vl = svcntb();\n        if (vl > len) vl = len;\n\n        pg = svwhilelt_b8(0, vl);\n        str_vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.data()));\n\n        // Check for lowercase letters\n        svbool_t is_lower = svcollt_z(pg, str_vec, svdup_u8('a'));\n        is_lower = svand_z(pg, is_lower, svcollt_z(pg, svsub_u8_z(pg, str_vec, svdup_u8('a')), svdup_u8(26)));\n\n        // Check for uppercase letters\n        svbool_t is_upper = svcollt_z(pg, str_vec, svdup_u8('A'));\n        is_upper = svand_z(pg, is_upper, svcollt_z(pg, svsub_u8_z(pg, str_vec, svdup_u8('A')), svdup_u8(26)));\n\n        // Reverse case\n        svuint8_t reversed_case = svsel_u8(is_lower, svadd_u8_z(pg, str_vec, svdup_u8('A' - 'a')), str_vec);\n        reversed_case = svsel_u8(is_upper, svsub_u8_z(pg, str_vec, svdup_u8('A' - 'a')), reversed_case);\n\n        // Store the result\n        svst1_u8(pg, reinterpret_cast<uint8_t*>(result.data()), reversed_case);\n\n        s = s.substr(vl);\n        result = result.substr(vl);\n        len -= vl;\n    } while (len > 0);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s) {\n    size_t len = s.length();\n    if (len == 0) return s;\n\n    // Check if there are any letters in the string\n    svbool_t pg = svptrue_b8();\n    svuint8_t str_vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.data()));\n    svbool_t has_letters = svany(svorr_z(pg, svcgt_z(pg, str_vec, svdup_u8('Z')), svand_z(pg, svcgt_z(pg, str_vec, svdup_u8('`')), svcmplt_z(pg, str_vec, svdup_u8('z')))));\n\n    if (!svptest_any(svptrue_b8(), has_letters)) {\n        // No letters, reverse the string\n        std::string reversed_s = s;\n        std::reverse(reversed_s.begin(), reversed_s.end());\n        return reversed_s;\n    }\n\n    // Allocate space for the result\n    std::string result(len, ' ');\n\n    // Process the string in chunks\n    size_t i = 0;\n    while (i < len) {\n        size_t vl = svcntb();\n        if (i + vl > len) vl = len - i;\n        pg = svwhilelt_b8(i, len);\n\n        str_vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.data() + i));\n\n        // Check which characters are lowercase letters\n        svbool_t is_lower = svand_z(pg, svcgt_z(pg, str_vec, svdup_u8('`')), svcmplt_z(pg, str_vec, svdup_u8('z')));\n        // Check which characters are uppercase letters\n        svbool_t is_upper = svcgt_z(pg, str_vec, svdup_u8('Z'));\n\n        // Convert lowercase to uppercase\n        svuint8_t upper_case = svsub_z(is_lower, str_vec, svdup_u8('a' - 'A'));\n        // Convert uppercase to lowercase\n        svuint8_t lower_case = svadd_z(is_upper, str_vec, svdup_u8('a' - 'A'));\n\n        // Combine results\n        svuint8_t result_vec = svsel_z(pg, is_lower, upper_case, str_vec);\n        result_vec = svsel_z(pg, is_upper, lower_case, result_vec);\n\n        // Store the result\n        svst1_u8(pg, reinterpret_cast<uint8_t*>(result.data() + i), result_vec);\n\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s) {\n    size_t len = s.length();\n    if (len == 0) return s;\n\n    // Check if there are any letters in the string\n    svbool_t pg = svptrue_b8();\n    svuint8_t str_vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.data()));\n    svbool_t has_letters = svany(svor_z(pg, svcvtb_u8_b8(svcmplt_z(pg, str_vec, svdup_u8('a'))), svcvtb_u8_b8(svcmpgt_z(pg, str_vec, svdup_u8('z')))), svcvtb_u8_b8(svcmplt_z(pg, str_vec, svdup_u8('A'))), svcvtb_u8_b8(svcmpgt_z(pg, str_vec, svdup_u8('Z'))));\n\n    if (!svptest_any(svptrue_b8(), has_letters)) {\n        // Reverse the string if there are no letters\n        std::string reversed_s = s;\n        std::reverse(reversed_s.begin(), reversed_s.end());\n        return reversed_s;\n    }\n\n    // Allocate space for the result\n    std::string result(len, ' ');\n\n    // Process the string to reverse the case of letters\n    size_t i = 0;\n    while (i < len) {\n        size_t vl = svcntb();\n        if (i + vl > len) vl = len - i;\n        pg = svwhilelt_b8(i, len);\n\n        str_vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.data() + i));\n\n        // Check for lowercase letters\n        svbool_t is_lower = svand_z(pg, svcvtb_u8_b8(svcmplt_z(pg, str_vec, svdup_u8('a'))), svcvtb_u8_b8(svcmpgt_z(pg, str_vec, svdup_u8('z'))));\n        // Check for uppercase letters\n        svbool_t is_upper = svand_z(pg, svcvtb_u8_b8(svcmplt_z(pg, str_vec, svdup_u8('A'))), svcvtb_u8_b8(svcmpgt_z(pg, str_vec, svdup_u8('Z'))));\n\n        // Convert lowercase to uppercase\n        svuint8_t upper_case = svsub_z(is_lower, str_vec, svdup_u8('a' - 'A'));\n        // Convert uppercase to lowercase\n        svuint8_t lower_case = svadd_z(is_upper, str_vec, svdup_u8('a' - 'A'));\n\n        // Combine results\n        svuint8_t result_vec = svsel_z(pg, svsel_z(pg, str_vec, upper_case, is_lower), lower_case, is_upper);\n\n        svst1_u8(pg, reinterpret_cast<uint8_t*>(result.data() + i), result_vec);\n\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s) {\n    size_t len = s.length();\n    if (len == 0) return s;\n\n    // Check if there are any letters in the string\n    svbool_t pg = svptrue_b8();\n    svuint8_t str_vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.data()));\n    svbool_t has_letters = svany(svcmpne_n_u8(pg, str_vec, '0') & svcmpne_n_u8(pg, str_vec, '9'));\n\n    if (!has_letters) {\n        std::string reversed_s = s;\n        std::reverse(reversed_s.begin(), reversed_s.end());\n        return reversed_s;\n    }\n\n    // Allocate space for the result\n    std::string result(len, ' ');\n\n    do {\n        size_t vl = svcntb();\n        if (vl > len) vl = len;\n\n        pg = svwhilelt_b8(0, vl);\n        str_vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.data()));\n\n        // Check for lowercase letters\n        svbool_t is_lower = svcmplt_n_u8(pg, str_vec, 'a') | svcmpgt_n_u8(pg, str_vec, 'z');\n        svuint8_t lower_to_upper = svsub_u8_m(pg, str_vec, 32, svnot_b8(is_lower));\n\n        // Check for uppercase letters\n        svbool_t is_upper = svcmplt_n_u8(pg, str_vec, 'A') | svcmpgt_n_u8(pg, str_vec, 'Z');\n        svuint8_t upper_to_lower = svadd_u8_m(pg, str_vec, 32, svnot_b8(is_upper));\n\n        // Combine results\n        svuint8_t result_vec = svsel_u8(pg, lower_to_upper, upper_to_lower);\n\n        // Store the result\n        svst1_u8(pg, reinterpret_cast<uint8_t*>(result.data()), result_vec);\n\n        s = s.substr(vl);\n        result = result.substr(vl);\n        len -= vl;\n    } while (len > 0);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> sorted_elements;\n\n    // Collect elements at indices divisible by 3\n    for (size_t i = 0; i < n; i += 3) {\n        sorted_elements.push_back(l[i]);\n    }\n\n    // Sort the collected elements\n    std::sort(sorted_elements.begin(), sorted_elements.end());\n\n    // Create an SVE vector for the input data\n    svint32_t *data = reinterpret_cast<svint32_t*>(l.data());\n    size_t stride = svcntw() * sizeof(int);\n\n    // Process the vector in chunks\n    for (size_t offset = 0; offset < n; offset += svcntw()) {\n        svbool_t pg = svwhilelt_b32(offset, n);\n        svint32_t vec = svld1(pg, &l[offset]);\n\n        // Replace elements at indices divisible by 3 with sorted elements\n        for (size_t i = 0; i < svcntw(); ++i) {\n            if ((offset + i) % 3 == 0 && (offset + i) < n) {\n                int sorted_index = (offset + i) / 3;\n                vec = svset1_i32_index(vec, pg, i, sorted_elements[sorted_index]);\n            }\n        }\n\n        // Store the result back to the vector\n        svst1(pg, &l[offset], vec);\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> sorted_thirds;\n    \n    // Collect elements at indices divisible by 3\n    for (size_t i = 0; i < n; i += 3) {\n        sorted_thirds.push_back(l[i]);\n    }\n    \n    // Sort the collected elements\n    std::sort(sorted_thirds.begin(), sorted_thirds.end());\n    \n    // Create an SVE vector for the input list\n    svint32_t *sv_l = reinterpret_cast<svint32_t*>(l.data());\n    size_t vl = svcntw();\n    \n    // Process the list in chunks of 'vl'\n    for (size_t i = 0; i < n; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t vec = svld1(pg, &l[i]);\n        \n        // Replace elements at indices divisible by 3 with sorted values\n        for (size_t j = 0; j < vl && i + j < n; ++j) {\n            if ((i + j) % 3 == 0) {\n                vec = svset1(pg, vec, sorted_thirds[(i + j) / 3], j);\n            }\n        }\n        \n        svst1(pg, &l[i], vec);\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> sorted_thirds;\n    \n    // Collect elements at indices divisible by 3\n    for (size_t i = 0; i < n; i += 3) {\n        sorted_thirds.push_back(l[i]);\n    }\n    \n    // Sort the collected elements\n    std::sort(sorted_thirds.begin(), sorted_thirds.end());\n    \n    // Create an SVE vector for the input\n    svint32_t vl = svld1_s32(svundef_s32(), l.data(), svlen_u32(n));\n    \n    // Create a mask for indices divisible by 3\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t index = svindex_s32_z(pg, 0, 1);\n    svbool_t mask = svcmpeq_n_s32_z(pg, svand_n_s32_z(pg, index, 3), 0);\n    \n    // Replace elements at indices divisible by 3 with sorted elements\n    size_t sorted_index = 0;\n    svint32_t sorted_vl = svld1_s32(svundef_s32(), sorted_thirds.data(), svlen_u32(sorted_thirds.size()));\n    svint32_t result = svsel_s32(mask, svnth_s32(sorted_vl, sorted_index++), vl);\n    \n    // Store the result back to the vector\n    svst1_s32(svundef_s32(), l.data(), result, svlen_u32(n));\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> sorted_elements;\n\n    // Collect elements at indices divisible by 3\n    for (size_t i = 0; i < n; i += 3) {\n        sorted_elements.push_back(l[i]);\n    }\n\n    // Sort the collected elements\n    std::sort(sorted_elements.begin(), sorted_elements.end());\n\n    // Create an SVE vector for the input data\n    svint32_t *data = reinterpret_cast<svint32_t*>(l.data());\n    size_t stride = svcntw() * sizeof(int);\n\n    // Process the vector in chunks\n    for (size_t offset = 0; offset < n; offset += svcntw()) {\n        svbool_t pg = svwhilelt_b32(offset, n);\n        svint32_t vec = svld1(pg, &l[offset]);\n\n        // Replace elements at indices divisible by 3 with sorted elements\n        for (size_t i = 0; i < svcntw() && (offset + i) < n; ++i) {\n            if ((offset + i) % 3 == 0) {\n                int sorted_value = sorted_elements[(offset + i) / 3];\n                vec = svset1_i32_index(vec, pg, i, sorted_value);\n            }\n        }\n\n        // Store the modified vector back to memory\n        svst1(pg, &l[offset], vec);\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> sorted_thirds;\n    \n    // Collect elements at indices divisible by 3\n    for (size_t i = 0; i < n; i += 3) {\n        sorted_thirds.push_back(l[i]);\n    }\n    \n    // Sort the collected elements\n    std::sort(sorted_thirds.begin(), sorted_thirds.end());\n    \n    // Create an SVE vector for the input\n    svint32_t vec_l = svld1_s32(svundef_s32(), l.data());\n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    // Create an SVE vector for the sorted thirds\n    svint32_t vec_sorted_thirds = svld1_s32(svundef_s32(), sorted_thirds.data());\n    \n    // Index to track position in sorted_thirds\n    size_t sorted_index = 0;\n    \n    // Process the vector in chunks\n    do {\n        // Create a predicate for indices divisible by 3\n        svbool_t div_by_three = svcmpeq_n_b32(pg, svindex_s32_z(pg, 0, 1), 0);\n        \n        // Replace elements at indices divisible by 3 with sorted elements\n        vec_l = svsel_b32(div_by_three, svld1_s32(svundef_s32(), &sorted_thirds[sorted_index]), vec_l);\n        \n        // Advance the index for sorted_thirds\n        sorted_index += svcntp_b32(div_by_three);\n        \n        // Move to the next chunk\n        pg = svptrue_b32() - pg;\n        vec_l = svld1_s32(pg, l.data() + n - svcntb_b32(pg));\n    } while (!svptest_any(sv_ptrue_b32(), pg));\n    \n    // Store the result back to the vector\n    svst1_s32(svundef_s32(), l.data(), vec_l);\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nfloat max_element_simd(const std::vector<float>& l) {\n    float result = std::numeric_limits<float>::lowest();\n    svbool_t pg;\n    svfloat32_t max_vec = svdup_f32(result);\n\n    for (size_t i = 0; i < l.size(); i += svcntw()) {\n        pg = svwhilelt_b32(i, l.size());\n        svfloat32_t vec = svld1(pg, &l[i]);\n        max_vec = svmax_m(pg, max_vec, vec);\n    }\n\n    float max_array[svcntw()];\n    svst1_f32(svpgt_b32(svptrue_b32(), 0), max_array, max_vec);\n\n    for (size_t i = 0; i < svcntw(); ++i) {\n        if (max_array[i] > result) {\n            result = max_array[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nfloat max_element_simd(std::vector<float> l) {\n    svfloat32_t max_vec = svdup_f32(l[0]);\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < l.size(); i += vl) {\n        svfloat32_t vec = svld1_f32(svptrue_b32(), &l[i]);\n        max_vec = svmax_f32_z(svptrue_b32(), max_vec, vec);\n    }\n\n    float max_val = l[0];\n    for (size_t i = 0; i < vl; ++i) {\n        float val = svget2_f32(max_vec, i);\n        if (val > max_val) {\n            max_val = val;\n        }\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nfloat max_element_simd(std::vector<float> l) {\n    svfloat32_t max_vec = svdup_f32(l[0]);\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < l.size(); i += vl) {\n        svfloat32_t vec = svld1_f32(svptrue_b32(), &l[i]);\n        max_vec = svmax_f32_z(svptrue_b32(), max_vec, vec);\n    }\n\n    float max_val = l[0];\n    for (size_t i = 0; i < vl; ++i) {\n        float val = svgetlane_f32(max_vec, i);\n        if (val > max_val) {\n            max_val = val;\n        }\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nfloat max_element_simd(std::vector<float> l) {\n    float result = std::numeric_limits<float>::lowest();\n    svbool_t pg;\n    svfloat32_t max_vec = svdup_f32(result);\n\n    for (size_t i = 0; i < l.size(); i += svcntw()) {\n        pg = svwhilelt_b32(i, l.size());\n        svfloat32_t vec = svld1(pg, &l[i]);\n        max_vec = svmax_m(pg, max_vec, vec);\n    }\n\n    float max_array[svcntw()];\n    svst1_f32(svpgt_b32(svptrue_b32(), 0), max_array, max_vec);\n\n    for (size_t i = 0; i < svcntw(); ++i) {\n        if (max_array[i] > result) {\n            result = max_array[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nfloat max_element_simd(std::vector<float> l) {\n    svfloat32_t max_vec = svdup_f32(l[0]);\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < l.size(); i += vl) {\n        svfloat32_t vec = svld1_f32(svptrue_b32(), &l[i]);\n        max_vec = svmax_f32_z(svptrue_b32(), max_vec, vec);\n    }\n\n    float max_val = l[0];\n    for (size_t i = 0; i < vl; ++i) {\n        float val = svget4_f32(max_vec, i);\n        if (val > max_val) {\n            max_val = val;\n        }\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint fizz_buzz_simd(int n){\n    int count = 0;\n    svbool_t pg;\n    svint32_t v_seven = svdup_s32(7);\n    svint32_t v_eleven = svdup_s32(11);\n    svint32_t v_thirteen = svdup_s32(13);\n\n    for (int i = 0; i < n; i += svcntw()) {\n        pg = svwhilelt_b32(svptrue_b32(), i, n);\n        svint32_t v_index = svindex_s32_z(pg, i, 1);\n        svbool_t divisible_by_11 = svcmpeq_s32_z(pg, svmod_s32_z(pg, v_index, v_eleven), svdup_s32(0));\n        svbool_t divisible_by_13 = svcmpeq_s32_z(pg, svmod_s32_z(pg, v_index, v_thirteen), svdup_s32(0));\n        svbool_t divisible_by_11_or_13 = svorr_b_z(pg, divisible_by_11, divisible_by_13);\n\n        for (int j = 0; j < svcntw(); ++j) {\n            if (svptest_any(svptrue_b32(), svand_b_z(pg, svptrue_b32(), divisible_by_11_or_13))) {\n                int num = svlastb_h(svreinterpret_u16_s32(svindex_s32_z(pg, i, 1)));\n                while (num > 0) {\n                    if (num % 10 == 7) {\n                        count++;\n                    }\n                    num /= 10;\n                }\n            }\n            pg = svpnext_b32(pg);\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    svbool_t pg;\n    svint32_t sv_nines, sv_sevens, sv_ones, sv_seventeens;\n    svint32_t sv_i, sv_eleven, sv_thirteen, sv_zero;\n    svint32_t sv_mask_eleven, sv_mask_thirteen, sv_mask_seven;\n\n    sv_zero = svdup_s32(0);\n    sv_seven = svdup_s32(7);\n    sv_nines = svdup_s32(9);\n    sv_ones = svdup_s32(1);\n    sv_seventeens = svdup_s32(17);\n    sv_eleven = svdup_s32(11);\n    sv_thirteen = svdup_s32(13);\n\n    for (int i = 0; i < n; i += svcntw()) {\n        pg = svwhilelt_b32(svdup_s32(i), svdup_s32(n));\n        sv_i = svindex_s32_z(pg, svdup_s32(i), 1);\n\n        sv_mask_eleven = svcmpeq_s32_z(pg, svand_s32_z(pg, sv_i, sv_eleven), sv_zero);\n        sv_mask_thirteen = svcmpeq_s32_z(pg, svand_s32_z(pg, sv_i, sv_thirteen), sv_zero);\n        sv_mask_seven = svcmpeq_s32_z(pg, svand_s32_z(pg, sv_i, sv_seven), sv_seven);\n\n        svint32_t sv_count_seven = svcntb_m(sv_zero, sv_mask_seven);\n        svint32_t sv_count_eleven = svcntb_m(sv_zero, sv_mask_eleven);\n        svint32_t sv_count_thirteen = svcntb_m(sv_zero, sv_mask_thirteen);\n\n        svint32_t sv_total_count = svadd_s32_z(pg, svadd_s32_z(pg, sv_count_seven, sv_count_eleven), sv_count_thirteen);\n\n        count += svaddv_s32(sv_total_count);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint fizz_buzz_simd(int n){\n    int count = 0;\n    svbool_t pg;\n    svint32_t v_seven = svdup_s32(7);\n    svint32_t v_eleven = svdup_s32(11);\n    svint32_t v_thirteen = svdup_s32(13);\n\n    for (int i = 0; i < n; i += svcntw()) {\n        pg = svwhilelt_b32(svptrue_b32(), i, n);\n        svint32_t v_index = svindex_s32_z(pg, i, 1);\n        svbool_t divisible_by_11 = svcmpeq_s32_z(pg, svmod_s32_z(pg, v_index, v_eleven), svdup_s32(0));\n        svbool_t divisible_by_13 = svcmpeq_s32_z(pg, svmod_s32_z(pg, v_index, v_thirteen), svdup_s32(0));\n        svbool_t divisible_by_11_or_13 = svorr_b_z(pg, divisible_by_11, divisible_by_13);\n\n        for (int j = 0; j < svcntw(); ++j) {\n            if (svptest_any(svptrue_b32(), svand_b_z(pg, pg, svindex_b32(j, 1))) && svptest_any(svptrue_b32(), svand_b_z(pg, divisible_by_11_or_13, svindex_b32(j, 1)))) {\n                int num = i + j;\n                while (num > 0) {\n                    if (num % 10 == 7) {\n                        count++;\n                    }\n                    num /= 10;\n                }\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint fizz_buzz_simd(int n){\n    int count = 0;\n    svbool_t pg;\n    svint32_t v_seven = svdup_s32(7);\n    svint32_t v_eleven = svdup_s32(11);\n    svint32_t v_thirteen = svdup_s32(13);\n\n    for (int i = 0; i < n; i += svcntw()) {\n        pg = svwhilelt_b32(svptrue_b32(), i, n);\n        svint32_t v_index = svindex_s32_z(pg, i, 1);\n        svbool_t divisible_by_11 = svcmpeq_s32_z(pg, svmod_s32_z(pg, v_index, v_eleven), svdup_s32(0));\n        svbool_t divisible_by_13 = svcmpeq_s32_z(pg, svmod_s32_z(pg, v_index, v_thirteen), svdup_s32(0));\n        svbool_t divisible_by_11_or_13 = svorr_b_z(pg, divisible_by_11, divisible_by_13);\n\n        for (int j = 0; j < svcntw(); ++j) {\n            if (svptest_any(svptrue_b32(), svand_b_z(pg, svptrue_b32(), divisible_by_11_or_13))) {\n                int num = svlastb_h(svreinterpret_u16_s32(svindex_s32_z(pg, i, 1)));\n                while (num > 0) {\n                    if (num % 10 == 7) {\n                        count++;\n                    }\n                    num /= 10;\n                }\n            }\n            pg = svpnext_b32(pg);\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    svbool_t pg;\n    svint32_t v_seven = svdup_s32(7);\n    svint32_t v_eleven = svdup_s32(11);\n    svint32_t v_thirteen = svdup_s32(13);\n\n    for (int i = 0; i < n; i += svcntw()) {\n        pg = svwhilelt_b32(svptrue_b32(), i, n);\n        svint32_t v_index = svindex_s32_z(pg, i, 1);\n        svbool_t divisible_by_11 = svcmpeq_s32_z(pg, svmod_s32_z(pg, v_index, v_eleven), svdup_s32(0));\n        svbool_t divisible_by_13 = svcmpeq_s32_z(pg, svmod_s32_z(pg, v_index, v_thirteen), svdup_s32(0));\n        svbool_t divisible_by_11_or_13 = svorr_b_z(pg, divisible_by_11, divisible_by_13);\n\n        svint32_t v_digits = v_index;\n        svint32_t v_zero = svdup_s32(0);\n        svint32_t v_ten = svdup_s32(10);\n\n        int num_elements = svcntw();\n        int temp_count = 0;\n\n        do {\n            svint32_t v_last_digit = svmod_s32_z(pg, v_digits, v_ten);\n            svbool_t is_seven = svcmpeq_s32_z(pg, v_last_digit, v_seven);\n            temp_count += svptest_any(sv_ptrue_b32(), svand_b_z(pg, is_seven, divisible_by_11_or_13));\n            v_digits = svdiv_s32_z(pg, v_digits, v_ten);\n        } while (svptest_any(sv_ptrue_b32(), svcmpne_s32_z(pg, v_digits, v_zero)));\n\n        count += temp_count;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    std::vector<float> even_elements;\n\n    // Collect even index elements\n    for (size_t i = 0; i < n; i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    // Sort the collected even index elements\n    std::sort(even_elements.begin(), even_elements.end());\n\n    // Create an SVE vector for even indices\n    svfloat32_t even_vec = svld1_f32(svptrue_b32(), even_elements.data());\n\n    // Create a mask for even indices\n    svbool_t pg = svptrue_b32();\n    svbool_t even_mask = svwhilelt_b32(0, n);\n    even_mask = svand_b32(even_mask, svcmpeq_n_b32(pg, svindex_s32_z(pg, 0, 1), 0));\n\n    // Scatter the sorted even elements back into the original vector\n    svst1_f32(svcompress_b32(even_mask, pg), &l[0], even_vec);\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    std::vector<float> even_elements;\n\n    // Collect even index elements\n    for (size_t i = 0; i < n; i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    // Sort even index elements\n    std::sort(even_elements.begin(), even_elements.end());\n\n    // Create an SVE vector for even elements\n    svfloat32_t sv_even = svld1_f32(svreinterpret_u32_f32(svindex_u32(0, 1)), even_elements.data());\n\n    // Create an SVE vector for the original list\n    svfloat32_t sv_l = svld1_f32(svreinterpret_u32_f32(svindex_u32(0, 1)), l.data());\n\n    // Create a predicate for even indices\n    svbool_t pg_even = svwhilelt_b32(0, n);\n    pg_even = svand_b32(pg_even, svcmpeq_n_b32(pg_even, svand_n_u32_z(pg_even, svindex_u32(0, 1), 1), 0));\n\n    // Scatter sorted even elements back into the original list\n    svst1_f32(svsel_b32(pg_even, sv_even, sv_l), l.data());\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    std::vector<float> even_elements;\n\n    // Collect even index elements\n    for (size_t i = 0; i < n; i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    // Sort the collected even index elements\n    std::sort(even_elements.begin(), even_elements.end());\n\n    // Create an SVE vector for even indices\n    svbool_t pg = svptrue_b32();\n    svfloat32_t even_vec = svld1_f32(pg, even_elements.data());\n\n    // Write sorted even elements back to the original vector\n    for (size_t i = 0; i < n; i += 2) {\n        l[i] = svget32(svindex_s32(0, 1), even_vec);\n        even_vec = svext_f32(even_vec, even_vec, 1);\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    std::vector<float> even_elements;\n\n    // Collect even index elements\n    for (size_t i = 0; i < n; i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    // Sort even index elements\n    std::sort(even_elements.begin(), even_elements.end());\n\n    // Create an SVE vector for even elements\n    svfloat32_t even_vec = svld1_f32(svptrue_b32(), even_elements.data());\n\n    // Create an SVE vector for the result\n    svfloat32_t result_vec = svld1_f32(svptrue_b32(), l.data());\n\n    // Update even indices in the result vector with sorted even elements\n    for (size_t i = 0; i < n; i += 2) {\n        svbool_t pg = svptrue_b32();\n        result_vec = svwupb(svwhilerw(pg, i / 2), result_vec, even_vec);\n    }\n\n    // Store the result back to the vector\n    svst1_f32(svptrue_b32(), l.data(), result_vec);\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    std::vector<float> even_elements;\n\n    // Collect even index elements\n    for (size_t i = 0; i < n; i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    // Sort the collected even index elements\n    std::sort(even_elements.begin(), even_elements.end());\n\n    // Create an SVE vector for even indices\n    svfloat32_t even_vec = svld1_f32(svptrue_b32(), even_elements.data());\n\n    // Create a mask for even indices\n    svbool_t pg = svptrue_b32();\n    svbool_t even_mask = svwhilelt_b32(0, n);\n    even_mask = svand_b32(even_mask, svcmpeq_n_b32(pg, svindex_s32(svzero_s32(), 0), 0));\n\n    // Scatter the sorted even elements back into the original vector\n    svst1_f32(svcompress_b32(even_mask, pg), &l[0], even_vec);\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 3) return false;\n\n    svint32_t *vec = reinterpret_cast<svint32_t*>(l.data());\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < n; ++i) {\n        for (size_t j = i + 1; j < n; ++j) {\n            int32_t neg_sum = -(l[i] + l[j]);\n            size_t k = j + 1;\n            while (k < n) {\n                size_t num_elements = n - k;\n                size_t elements_in_vec = (num_elements > vl) ? vl : num_elements;\n                svint32_t vec_k = svld1_s32(svptrue_b32(), &l[k]);\n                svbool_t pg = svcmpeq_s32(svptrue_b32(), vec_k, svdup_s32(neg_sum));\n                if (svptest_any(svptrue_b32(), pg)) {\n                    return true;\n                }\n                k += elements_in_vec;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 3) return false;\n\n    svint32_t *vec = reinterpret_cast<svint32_t*>(l.data());\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < n; ++i) {\n        for (size_t j = i + 1; j < n; ++j) {\n            int32_t neg_sum = -(l[i] + l[j]);\n            size_t k = j + 1;\n            while (k < n) {\n                size_t num_elements = n - k;\n                svbool_t pg = svwhilelt_b32(0, num_elements);\n                svint32_t v_neg_sum = svdup_s32(neg_sum);\n                svint32_t v = svld1_s32(pg, &l[k]);\n\n                svbool_t cmp = svecmpeq_b32(pg, v, v_neg_sum);\n                if (svptest_any(svptrue_b32(), cmp)) {\n                    return true;\n                }\n                k += vl;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 3) return false;\n\n    svint32_t *vec = reinterpret_cast<svint32_t*>(l.data());\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < n; ++i) {\n        for (size_t j = i + 1; j < n; ++j) {\n            int32_t neg_sum = -(l[i] + l[j]);\n            size_t k = j + 1;\n            while (k < n) {\n                size_t num_elements = n - k;\n                size_t elements_in_vec = (num_elements > vl) ? vl : num_elements;\n                svint32_t v_neg_sum = svdup_s32(neg_sum);\n                svint32_t v = svld1_s32(svptrue_b32(), &vec[k / vl][k % vl]);\n                svbool_t pg = svwhilelt_b32(0, elements_in_vec);\n                if (svany(svcmpeq(pg, v, v_neg_sum))) {\n                    return true;\n                }\n                k += elements_in_vec;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 3) return false;\n\n    svint32_t *vec = reinterpret_cast<svint32_t*>(l.data());\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < n; ++i) {\n        for (size_t j = i + 1; j < n; ++j) {\n            int32_t neg_sum = -(l[i] + l[j]);\n            size_t k = j + 1;\n            while (k < n) {\n                size_t num_elements = n - k;\n                svbool_t pg = svwhilelt_b32(0, num_elements);\n                svint32_t vec_k = svld1_s32(pg, &l[k]);\n                svbool_t cmp = sveq_s32(pg, vec_k, svdup_s32(neg_sum));\n                if (svptest_any(svptrue_b32(), cmp)) {\n                    return true;\n                }\n                k += vl;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 3) return false;\n\n    svint32_t *vec = reinterpret_cast<svint32_t*>(l.data());\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < n; ++i) {\n        for (size_t j = i + 1; j < n; ++j) {\n            int32_t neg_sum = -(l[i] + l[j]);\n            size_t k = j + 1;\n            while (k < n) {\n                size_t num_elements = n - k;\n                svbool_t pg = svwhilelt_b32(0, num_elements);\n                svint32_t vec_k = svld1_s32(pg, &l[k]);\n                svbool_t cmp = sveq_s32(pg, vec_k, svdup_s32(neg_sum));\n                if (svptest_any(svptrue_b32(), cmp)) {\n                    return true;\n                }\n                k += vl;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t size = l.size();\n    std::vector<int> result(size);\n\n    svint32_t *input_ptr = reinterpret_cast<svint32_t*>(l.data());\n    svint32_t *output_ptr = reinterpret_cast<svint32_t*>(result.data());\n\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    for (; i <= size - svcntw(); i += svcntw()) {\n        svint32_t vec = svld1(pg, &input_ptr[i]);\n        svint32_t incr_vec = svadd_z(pg, vec, svdup_n_s32(1));\n        svst1(pg, &output_ptr[i], incr_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        result[i] = l[i] + 1;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t num_elements = l.size();\n    std::vector<int> result(num_elements);\n\n    svint32_t *input_ptr = reinterpret_cast<svint32_t*>(l.data());\n    svint32_t *output_ptr = reinterpret_cast<svint32_t*>(result.data());\n\n    size_t i = 0;\n    svbool_t pg;\n    do {\n        pg = svwhilelt_b32(i, num_elements);\n        svint32_t vec = svld1(pg, &input_ptr[i]);\n        svint32_t incr_vec = svadd_z(pg, vec, svdup_n_s32(1));\n        svst1(pg, &output_ptr[i], incr_vec);\n        i += svcntw();\n    } while (svptest_any(svptrue_b32(), pg));\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t size = l.size();\n    std::vector<int> result(size);\n\n    // Calculate the number of elements that fit into one sve vector\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < size; i += vl) {\n        // Load elements into an sve vector\n        svint32_t vec = svld1(pg, &l[i]);\n\n        // Increment each element in the vector by 1\n        svint32_t inc_vec = svadd_z(pg, vec, svdup_n_s32(1));\n\n        // Store the result back into the output vector\n        svst1(pg, &result[i], inc_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t num_elements = l.size();\n    std::vector<int> result(num_elements);\n\n    svint32_t *input_ptr = reinterpret_cast<svint32_t*>(l.data());\n    svint32_t *output_ptr = reinterpret_cast<svint32_t*>(result.data());\n\n    size_t i = 0;\n    svbool_t pg;\n    do {\n        pg = svwhilelt_b32(i, num_elements);\n        svint32_t vec = svld1(pg, &input_ptr[i]);\n        svint32_t incr_vec = svadd_z(pg, vec, svdup_n_s32(1));\n        svst1(pg, &output_ptr[i], incr_vec);\n        i += svcntw();\n    } while (svptest_any(svptrue_b32(), pg));\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t num_elements = l.size();\n    std::vector<int> result(num_elements);\n\n    svint32_t *input_ptr = reinterpret_cast<svint32_t*>(l.data());\n    svint32_t *output_ptr = reinterpret_cast<svint32_t*>(result.data());\n\n    size_t i = 0;\n    svbool_t pg;\n    do {\n        pg = svwhilelt_b32(i, num_elements);\n        svint32_t vec = svld1(pg, &input_ptr[i]);\n        svint32_t incr_vec = svadd_z(pg, vec, svdup_n_s32(1));\n        svst1(pg, &output_ptr[i], incr_vec);\n        i += svcntw();\n    } while (svptest_any(svptrue_b32(), pg));\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    svint32_t vec;\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < l.size(); ++i) {\n        vec = svld1_s32(vl, &l[i]);\n        for (size_t j = i + 1; j < l.size(); j += vl) {\n            svint32_t vec2 = svld1_s32_z(svptrue_b32(), &l[j]);\n            svbool_t pg = svcmpeq_s32_z(svptrue_b32(), vec, svneg_s32_x(svptrue_b32(), vec2));\n            if (svptest_any(svptrue_b32(), pg)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(const std::vector<int>& l) {\n    size_t n = l.size();\n    if (n < 2) return false;\n\n    svint32_t vec;\n    svbool_t pg = svptrue_b32();\n\n    for (size_t i = 0; i < n; ++i) {\n        int target = -l[i];\n        vec = svld1(pg, &l[0]);\n\n        for (size_t j = 0; j < n; j += svcntw()) {\n            pg = svwhilelt_b32(svptrue_b32(), j, n);\n            svint32_t v = svld1(pg, &l[j]);\n            svbool_t cmp = svcmpeq_n_s32(pg, v, target);\n            if (svptest_any(svptrue_b32(), cmp) && (j + svfirstb(cmp) != i)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    svint32_t vec;\n    size_t vl = svcntw();\n    size_t n = l.size();\n\n    for (size_t i = 0; i < n; i += vl) {\n        vec = svld1_s32(svptrue_b32(), &l[i]);\n        for (size_t j = i + 1; j < n; j += vl) {\n            svint32_t vec2 = svld1_s32(svptrue_b32(), &l[j]);\n            svbool_t pg = svcmpeq_s32(svptrue_b32(), vec, svneg_s32_z(svptrue_b32(), vec2));\n            if (svptest_any(svptrue_b32(), pg)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(const std::vector<int>& l) {\n    svint32_t vec;\n    size_t vl = svcntw();\n    size_t n = l.size();\n\n    for (size_t i = 0; i < n; i += vl) {\n        vec = svld1_s32(svptrue_b32(), &l[i]);\n        for (size_t j = i + 1; j < n; j += vl) {\n            svint32_t vec2 = svld1_s32(svptrue_b32(), &l[j]);\n            svbool_t pg = svcmpeq_s32(svptrue_b32(), svadd_s32_z(svptrue_b32(), vec, vec2), svdup_s32(0));\n            if (svptest_any(svptrue_b32(), pg)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(const std::vector<int>& l) {\n    svint32_t vec;\n    size_t vl = svcntw();\n    size_t n = l.size();\n\n    for (size_t i = 0; i < n; i += vl) {\n        vec = svld1_s32(svptrue_b32(), &l[i]);\n        for (size_t j = i + 1; j < n; j += vl) {\n            svint32_t vec2 = svld1_s32(svptrue_b32(), &l[j]);\n            svbool_t pg = svcmpeq_s32(svptrue_b32(), svadd_s32_z(svptrue_b32(), vec, vec2), svdup_s32(0));\n            if (svptest_any(svptrue_b32(), pg)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (base < 2 || base > 9) return \"\";\n\n    std::string result;\n    int64_t max_digits = 64; // Maximum digits for int64_t in any base < 10\n    svint8_t base_vec = svdup_s8(base);\n    svint64_t x_vec = svdup_s64(x);\n    svint64_t zero_vec = svdup_s64(0);\n    svint64_t remainder_vec;\n    svbool_t pg = svptrue_b64();\n\n    char buffer[64];\n    int pos = 63;\n\n    while (svptest_any(svptrue_b64(), svcmpne_s64(pg, x_vec, zero_vec))) {\n        remainder_vec = svmod_s64_x(pg, x_vec, base_vec);\n        x_vec = svdiv_s64_x(pg, x_vec, base_vec);\n\n        svst1_b8(pg, &buffer[pos], svcvt_s8_s64_z(pg, remainder_vec));\n        pos--;\n    }\n\n    result.assign(buffer + pos + 1, buffer + 64);\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (base < 2 || base > 9) return \"\";\n\n    std::string result;\n    int64_t max_digits = 64; // Maximum digits for int64_t in base 2\n    svuint8_t digits = svdup_u8(0);\n    svuint8_t base_vec = svdup_u8(base);\n\n    for (int i = 0; i < max_digits; ++i) {\n        svuint8_t remainder = svmod_u8(svdup_u8(x % base), base_vec);\n        digits = svusdot_lane_u8(digits, remainder, svdup_u8('0'), 0);\n        x /= base;\n        if (x == 0) break;\n    }\n\n    uint8_t buffer[64];\n    svst1_u8(buffer, digits);\n\n    for (int i = 0; i < max_digits; ++i) {\n        if (buffer[i] == '0') continue;\n        result.push_back(buffer[i]);\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result.empty() ? \"0\" : result;\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (base < 2 || base > 9) return \"\";\n\n    std::string result;\n    int64_t max_digits = 64; // Maximum digits for int64_t in any base < 10\n    svint8_t sv_base = svdup_s8(base);\n    svint8_t sv_zero = svdup_s8(0);\n    svint8_t sv_nines = svdup_s8('9');\n    svint8_t sv_ascii_offset = svdup_s8('0');\n\n    uint8_t buffer[64];\n    svuint8_t sv_buffer = svld1_u8(buffer);\n\n    while (x > 0) {\n        svint8_t sv_x = svdup_s8(x % base);\n        sv_buffer = svadd_u8(sv_buffer, svadd_u8(sv_x, sv_ascii_offset));\n        x /= base;\n    }\n\n    // Reverse the buffer to get the correct order\n    std::reverse(buffer, buffer + max_digits);\n\n    // Find the first non-zero character\n    auto it = std::find_if(buffer, buffer + max_digits, [](uint8_t c) { return c != '0'; });\n    if (it == buffer + max_digits) return \"0\"; // If all zeros, return \"0\"\n\n    result.assign(it, buffer + max_digits);\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (base < 2 || base > 9) return \"\";\n\n    std::string result;\n    int64_t max_digits = 64; // Maximum digits for int64_t in base 2\n    svint8_t base_vec = svdup_s8(base);\n    svint64_t x_vec = svdup_s64(x);\n    svint64_t zero_vec = svdup_s64(0);\n    svint64_t remainder_vec;\n    svbool_t pg = svptrue_b64();\n\n    char buffer[64];\n    int pos = 63;\n\n    while (svptest_any(svptrue_b64(), svcmpne_s64(pg, x_vec, zero_vec))) {\n        remainder_vec = svmod_s64_x(pg, x_vec, base_vec);\n        x_vec = svdiv_s64_x(pg, x_vec, base_vec);\n        buffer[pos--] = '0' + svlastb_s8(svld1_s8(pg, reinterpret_cast<const int8_t*>(&remainder_vec)));\n    }\n\n    result.assign(buffer + pos + 1, buffer + 64);\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (base < 2 || base > 9) return \"\";\n\n    std::string result;\n    uint64_t value = static_cast<uint64_t>(x);\n\n    // Determine the maximum number of digits needed\n    uint64_t max_digits = 64; // For simplicity, assuming 64 bits\n\n    // Create an SVE vector to store remainders\n    svuint8_t remainders = svdup_u8(0);\n\n    // Process in chunks of vector length\n    for (uint64_t i = 0; i < max_digits; i += svcntb()) {\n        svuint64_t vec_value = svld1_u64(svptrue_b64(), &value);\n        svuint64_t vec_base = svdup_u64(base);\n\n        // Calculate remainders and new values\n        svuint64_t quotients = svdiv_n_u64(vec_value, base);\n        remainders = svadd_u8_z(svptrue_b8(), remainders, svreinterpret_u8_u64(svsub_u64_z(svptrue_b64(), vec_value, svmul_u64_z(svptrue_b64(), quotients, vec_base))));\n\n        // Store new values back to memory\n        svst1_u64(svptrue_b64(), &value, quotients);\n\n        // Break if value becomes zero\n        if (value == 0) break;\n    }\n\n    // Convert remainders to characters and build the result string\n    uint8_t buffer[svcntb()];\n    svst1_u8(svptrue_b8(), buffer, remainders);\n\n    for (size_t i = 0; i < svcntb(); ++i) {\n        if (buffer[i] == 0) break;\n        result.push_back('0' + buffer[i]);\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    size_t length = text.length();\n    if (length <= 1) return true;\n\n    const char* data = text.data();\n    size_t i = 0;\n    size_t j = length - 1;\n\n    while (i < j) {\n        svbool_t pg = svptrue_b8();\n        svuint8_t vec1 = svld1(pg, reinterpret_cast<const uint8_t*>(data + i));\n        svuint8_t vec2 = svld1(pg, reinterpret_cast<const uint8_t*>(data + j));\n\n        svbool_t cmp = svcmpeq(svuzp1_b8(vec1, vec2), svuzp2_b8(vec1, vec2));\n        if (!svptest_any(svptrue_b8(), cmp)) {\n            return false;\n        }\n\n        i += svcntb();\n        j -= svcntb();\n    }\n\n    // Check remaining characters if length is not a multiple of svcntb()\n    while (i < j) {\n        if (data[i] != data[j]) {\n            return false;\n        }\n        i++;\n        j--;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    size_t len = text.length();\n    if (len == 0) return true;\n\n    const char* str = text.c_str();\n    size_t i = 0, j = len - 1;\n\n    while (i < j) {\n        svbool_t pg = svptrue_b8();\n        svuint8_t vec1 = svld1(pg, reinterpret_cast<const uint8_t*>(str + i));\n        svuint8_t vec2 = svld1(pg, reinterpret_cast<const uint8_t*>(str + j));\n\n        svbool_t cmp = svcmpeq(svuzp1_b8(vec1, vec2), svuzp2_b8(vec1, vec2));\n        if (!svptest_any(svptrue_b8(), cmp)) {\n            return false;\n        }\n\n        i += svcntb();\n        j -= svcntb();\n    }\n\n    // Check remaining characters if length is not a multiple of vector length\n    while (i < j) {\n        if (str[i] != str[j]) {\n            return false;\n        }\n        i++;\n        j--;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    size_t len = text.length();\n    if (len <= 1) return true;\n\n    const char* str = text.c_str();\n    size_t i = 0;\n    size_t j = len - 1;\n\n    while (i < j) {\n        svbool_t pg = svptrue_b8();\n        svuint8_t vec1 = svld1(pg, reinterpret_cast<const uint8_t*>(str + i));\n        svuint8_t vec2 = svld1(pg, reinterpret_cast<const uint8_t*>(str + j));\n\n        svbool_t cmp = svcmpeq(svuzp1_b8(vec1, vec2), svuzp2_b8(vec1, vec2));\n        if (!svptest_any(cmp)) {\n            return false;\n        }\n\n        i += svcntb();\n        j -= svcntb();\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    size_t len = text.length();\n    if (len == 0) return true;\n\n    const char* str = text.c_str();\n    size_t i = 0, j = len - 1;\n\n    while (i < j) {\n        svbool_t pg = svptrue_b8();\n        svuint8_t vec1 = svld1(pg, reinterpret_cast<const uint8_t*>(str + i));\n        svuint8_t vec2 = svld1(pg, reinterpret_cast<const uint8_t*>(str + j));\n\n        svbool_t cmp = svcmpeq(svuzp1_b8(vec1, vec2), svuzp2_b8(vec1, vec2));\n        if (!svptest_any(svptrue_b8(), cmp)) {\n            return false;\n        }\n\n        i += svcntb();\n        j -= svcntb();\n    }\n\n    // Check remaining characters if length is not a multiple of vector length\n    while (i < j) {\n        if (str[i] != str[j]) {\n            return false;\n        }\n        i++;\n        j--;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_palindrome_simd(const std::string& text) {\n    size_t length = text.length();\n    if (length <= 1) return true;\n\n    const char* data = text.data();\n    size_t i = 0;\n    size_t j = length - 1;\n\n    while (i < j) {\n        svbool_t pg = svptrue_b8();\n        svuint8_t vec1 = svld1(pg, reinterpret_cast<const uint8_t*>(data + i));\n        svuint8_t vec2 = svld1(pg, reinterpret_cast<const uint8_t*>(data + j));\n\n        svbool_t cmp = svcmpeq(svuzp1_b8(vec1, vec2), svuzp2_b8(vec1, vec2));\n        if (!svptest_any(svptrue_b8(), cmp)) {\n            return false;\n        }\n\n        i += svcntb();\n        j -= svcntb();\n    }\n\n    // Check remaining characters if length is not a multiple of svcntb()\n    while (i < j) {\n        if (data[i] != data[j]) {\n            return false;\n        }\n        i++;\n        j--;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), ' ');\n    const char* in = s.c_str();\n    char* out_ptr = &out[0];\n    svbool_t pg;\n    svint8_t v_a = svdup_s8('a');\n    svint8_t v_26 = svdup_s8(26);\n    svint8_t v_5 = svdup_s8(5);\n\n    size_t i = 0;\n    for (; i <= s.length() - svcntb(); i += svcntb()) {\n        svint8_t v_in = svld1_s8(svundef_b8(), &in[i]);\n        svint8_t v_decoded = svsub_s8_z(pg, v_in, v_5);\n        v_decoded = svadd_s8_z(pg, v_decoded, v_26);\n        v_decoded = svsub_s8_m(svcmpeq_s8(pg, v_decoded, v_26), v_decoded, v_26);\n        v_decoded = svadd_s8_z(pg, v_decoded, v_a);\n        svst1_s8(svundef_b8(), &out_ptr[i], v_decoded);\n    }\n\n    // Handle remaining characters\n    for (; i < s.length(); ++i) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out_ptr[i] = (char)w;\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), ' ');\n    svbool_t pg;\n    svuint8_t vec_a = svdup_u8('a');\n    svuint8_t vec_5 = svdup_u8(5);\n    svuint8_t vec_26 = svdup_u8(26);\n\n    size_t i = 0;\n    for (; i <= s.length() - svcntb(); i += svcntb()) {\n        pg = svptrue_b8();\n        svuint8_t vec_s = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.data() + i));\n        svuint8_t vec_decoded = svsub_u8_z(pg, svadd_u8_z(pg, vec_s, vec_26), vec_5);\n        vec_decoded = svadd_u8_z(pg, vec_decoded, vec_a);\n        svst1_u8(pg, reinterpret_cast<uint8_t*>(out.data() + i), vec_decoded);\n    }\n\n    for (; i < s.length(); ++i) {\n        out[i] = ((s[i] - 'a' + 21) % 26) + 'a';\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), ' ');\n    svbool_t pg;\n    svuint8_t vec_a = svdup_u8('a');\n    svuint8_t vec_5 = svdup_u8(5);\n    svuint8_t vec_26 = svdup_u8(26);\n\n    size_t i = 0;\n    for (; i <= s.length() - svcntb(); i += svcntb()) {\n        pg = svptrue_b8();\n        svuint8_t vec_s = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.data() + i));\n        svuint8_t vec_decoded = svsub_u8_z(pg, svadd_u8_z(pg, vec_s, vec_5), vec_a);\n        vec_decoded = svmod_u8_z(pg, vec_decoded, vec_26);\n        vec_decoded = svadd_u8_z(pg, vec_decoded, vec_a);\n        svst1_u8(pg, reinterpret_cast<uint8_t*>(out.data() + i), vec_decoded);\n    }\n\n    // Handle remaining characters\n    for (; i < s.length(); ++i) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out[i] = (char)w;\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), ' ');\n    svbool_t pg;\n    svuint8_t vec_a = svdup_u8('a');\n    svuint8_t vec_5 = svdup_u8(5);\n    svuint8_t vec_26 = svdup_u8(26);\n\n    size_t i = 0;\n    for (; i <= s.length() - svcntb(); i += svcntb()) {\n        pg = svptrue_b8();\n        svuint8_t vec_s = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.data() + i));\n        svuint8_t vec_decoded = svsub_u8_z(pg, svadd_u8_z(pg, vec_s, vec_26), vec_5);\n        vec_decoded = svadd_u8_z(pg, svsub_u8_z(pg, vec_decoded, vec_a), vec_a);\n        svst1_u8(pg, reinterpret_cast<uint8_t*>(out.data() + i), vec_decoded);\n    }\n\n    for (; i < s.length(); ++i) {\n        out[i] = ((s[i] - 5 - 'a' + 26) % 26) + 'a';\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), ' ');\n    const char* in = s.c_str();\n    char* out_ptr = &out[0];\n    svbool_t pg;\n    svint8_t v_in, v_out, v_a, v_5, v_26;\n\n    v_a = svdup_s8('a');\n    v_5 = svdup_s8(5);\n    v_26 = svdup_s8(26);\n\n    size_t i = 0;\n    for (; i <= s.length() - svcntb(); i += svcntb()) {\n        pg = svptrue_b8();\n        v_in = svld1_s8(pg, &in[i]);\n        v_in = svsub_s8_m(pg, v_in, v_5);\n        v_in = svadd_s8_m(pg, v_in, v_26);\n        v_out = svmod_s8_m(pg, v_in, v_26);\n        v_out = svadd_s8_m(pg, v_out, v_a);\n        svst1_s8(pg, &out_ptr[i], v_out);\n    }\n\n    // Handle remaining characters\n    for (; i < s.length(); ++i) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out_ptr[i] = (char)w;\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    svbool_t pg = svptrue_b32();\n    svint32_t threshold = svdup_s32(t);\n    const int *ptr = l.data();\n    size_t count = l.size();\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec = svld1_s32(pg, ptr);\n        svbool_t cmp = svcmplt_s32(pg, vec, threshold);\n        if (!svptest_all(svptrue_b32(), cmp)) {\n            return false;\n        }\n        ptr += svcntw();\n        count -= svcntw();\n        pg = svwhilelt_b32(0, count);\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    svbool_t pg = svptrue_b32();\n    svint32_t threshold = svdup_s32(t);\n    const int *ptr = l.data();\n    size_t count = l.size();\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec = svld1_s32(pg, ptr);\n        pg = svcmplt_s32(pg, vec, threshold);\n        ptr += svcntw();\n        count -= svcntw();\n        if (count < svcntw()) {\n            pg = svptrue_b32();\n            pg = svwhilelt_b32(pg, 0, count);\n        }\n    }\n\n    return !svptest_any(svptrue_b32(), pg);\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    svbool_t pg = svptrue_b32();\n    svint32_t threshold = svdup_s32(t);\n    const int *ptr = l.data();\n    size_t count = l.size();\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec = svld1_s32(pg, ptr);\n        pg = svcmplt_s32(pg, vec, threshold);\n        ptr += svcntw();\n        count -= svcntw();\n        if (count < svcntw()) {\n            pg = svptrue_b32();\n            pg = svwhilelt_b32(pg, 0, count);\n        }\n    }\n\n    return !svptest_any(svptrue_b32(), pg);\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    svbool_t pg = svptrue_b32();\n    svint32_t threshold = svdup_n_s32(t);\n    const int *ptr = l.data();\n    size_t count = l.size();\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec = svld1_s32(pg, ptr);\n        pg = svcmplt_s32(pg, vec, threshold);\n        ptr += svcntw();\n        count -= svcntw();\n        if (count < svcntw()) {\n            pg = svptrue_b32();\n            pg = svwhilelt_b32(pg, 0, count);\n        }\n    }\n\n    return !svptest_any(svptrue_b32(), pg);\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    svbool_t pg = svptrue_b32();\n    svint32_t threshold = svdup_n_s32(t);\n    const int *ptr = l.data();\n    size_t count = l.size();\n\n    while (svcntb(pg) > 0 && count > 0) {\n        svint32_t vec = svld1_s32(pg, ptr);\n        pg = svcmplt_s32_z(pg, vec, threshold);\n        ptr += svcntw(pg);\n        count -= svcntw(pg);\n    }\n\n    return svptest_any(svptrue_b32(), pg);\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    const char* str = brackets.c_str();\n    size_t len = brackets.size();\n    int balance = 0;\n\n    svbool_t pg;\n    svint8_t v_open, v_close, v_balance;\n    svint16_t v_balance_wide;\n    svint16_t v_zero = svdup_n_s16(0);\n\n    do {\n        size_t vl = svcntb();\n        pg = svwhilelt_b8(0, len);\n        v_open = svld1/pg_s8(pg, (const int8_t*)str);\n        v_close = svld1/pg_s8(pg, (const int8_t*)(str + 1));\n\n        v_balance = svsub_z/pg_s8(pg, svadd_z/pg_s8(pg, svcmpeq_z/pg_s8(pg, v_open, svdup_n_s8('<')), svneg_z/pg_s8(pg, svcmpeq_z/pg_s8(pg, v_close, svdup_n_s8('>')))), svdup_n_s8(balance));\n        v_balance_wide = svaddw_n_s16(svzero_s16(), v_balance);\n\n        for (size_t i = 0; i < svcntw(); ++i) {\n            balance += svget2_s16(v_balance_wide, i);\n        }\n\n        str += vl;\n        len -= vl;\n    } while (svptest_any(svptrue_b8(), pg));\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    const char* str = brackets.c_str();\n    size_t len = brackets.size();\n    int balance = 0;\n\n    svbool_t pg;\n    svint8_t v_open, v_close, v_balance;\n    svint16_t v_balance_wide;\n    svint32_t v_balance_wider;\n\n    do {\n        pg = svwhilelt_b8(0, len);\n        v_open = svld1/pg_b8(pg, (const uint8_t*)(str));\n        v_close = svld1/pg_b8(pg, (const uint8_t*)(str));\n\n        v_open = svcmpeq_b8(pg, v_open, svdup_n_b8('<'));\n        v_close = svcmpeq_b8(pg, v_close, svdup_n_b8('>'));\n        v_balance = svsub_z(pg, svreinterpret_s8_b8(v_open), svreinterpret_s8_b8(v_close));\n\n        v_balance_wide = svaddw_n_s16(svzero_s16(), v_balance, balance);\n        v_balance_wider = svaddw_n_s32(svzero_s32(), v_balance_wide, 0);\n\n        balance = svlastb_h(svptrue_b32(), v_balance_wider);\n\n        str += svcntb();\n        len -= svcntb();\n    } while (svptest_any(svptrue_b8(), pg));\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    const char* str = brackets.c_str();\n    size_t len = brackets.size();\n    int balance = 0;\n\n    svbool_t pg;\n    svint8_t v_open, v_close, v_balance;\n    svint16_t v_balance_wide;\n\n    do {\n        pg = svwhilelt_b8(0, len);\n        v_open = svld1/pg_b8(pg, (const uint8_t*)(str));\n        v_close = svld1/pg_b8(pg, (const uint8_t*)(str));\n\n        v_open = svcmpeq_b8(pg, v_open, svdup_n_b8('<'));\n        v_close = svcmpeq_b8(pg, v_close, svdup_n_b8('>'));\n        v_balance = svsub_z(pg, svadd_z(pg, svreinterpret_s8_b8(v_open), svreinterpret_s8_b8(v_close)), svdup_n_s8(balance));\n\n        v_balance_wide = svaddw_n_s16(svzero_s16(), v_balance);\n        balance = svaddvsvl_s16(svptrue_b16(), v_balance_wide);\n\n        str += svcntb();\n        len -= svcntb();\n    } while (svptest_any(svptrue_b8(), pg));\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    const char* str = brackets.c_str();\n    size_t len = brackets.size();\n    int balance = 0;\n\n    svbool_t pg;\n    svint8_t v_open, v_close, v_balance;\n    svint16_t v_balance_wide;\n\n    do {\n        pg = svwhilelt_b8(0, len);\n        v_open = svld1_s8(pg, reinterpret_cast<const int8_t*>(str));\n        v_close = svld1_s8(pg, reinterpret_cast<const int8_t*>(str));\n\n        v_open = svcmpeq_s8(pg, v_open, svdup_s8('<'));\n        v_close = svcmpeq_s8(pg, v_close, svdup_s8('>'));\n        v_balance = svsub_s8_z(pg, svadd_s8_z(pg, svdup_s8(balance), svreinterpret_s8_s8(svadd_s8_m(svundef_s8(), pg, svreinterpret_s8_s8(v_open), svreinterpret_s8_s8(v_close)))), svreinterpret_s8_s8(v_close));\n\n        v_balance_wide = svaddw_s16_m(svdup_s16(0), pg, svreinterpret_s16_s8(svext_s8(svundef_s8(), v_balance)), svreinterpret_s16_s8(v_balance));\n        balance = svaddv_s16_m(0, pg, v_balance_wide);\n\n        str += svcntb();\n        len -= svcntb();\n    } while (svptest_any(svptrue_b8(), pg));\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    const char* str = brackets.c_str();\n    size_t len = brackets.size();\n    int balance = 0;\n\n    svbool_t pg;\n    svint8_t v_open, v_close, v_balance;\n    svint16_t v_sum;\n\n    do {\n        pg = svwhilelt_b8(0, len);\n        v_open = svld1_s8(pg, (const int8_t*)str);\n        v_close = svsub_z(pg, v_open, svdup_n_s8('<'));\n        v_close = sveor_z(pg, v_close, svdup_n_s8('>'));\n        v_balance = svsub_z(pg, svdup_n_s8(0), v_close);\n        v_sum = svaddw_s8(svdup_n_s16(balance), v_balance);\n\n        balance = svaddv_s16(v_sum);\n        str += svcntb();\n        len -= svcntb();\n    } while (svptest_any(svptrue_b8(), pg));\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int32_t balance = 0;\n    size_t len = brackets.size();\n    const char* str = brackets.c_str();\n\n    while (len > 0) {\n        svbool_t pg = svwhilelt_b32(0, len);\n        svint32_t vbalance = svdup_s32(balance);\n        svint8_t vstr = svld1_s8(pg, reinterpret_cast<const int8_t*>(str));\n\n        svint32_t vopen = svcntb_m_n(svptrue_b8(), svcmpeq_b8(pg, vstr, svdup_s8('(')));\n        svint32_t vclose = svcntb_m_n(svptrue_b8(), svcmpeq_b8(pg, vstr, svdup_s8(')')));\n        vbalance = svadd_s32_m(pg, vbalance, svsub_s32_z(pg, vopen, vclose));\n\n        balance = svlastb_h32(svptrue_b32(), vbalance);\n        if (balance < 0) {\n            return false;\n        }\n\n        str += svcntb_b8(svptrue_b8());\n        len -= svcntb_b8(svptrue_b8());\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int32_t balance = 0;\n    size_t len = brackets.size();\n    const char* str = brackets.c_str();\n\n    while (len > 0) {\n        svbool_t pg = svwhilelt_b32(0, len);\n        svint32_t vbalance = svdup_s32(balance);\n        svint8_t vstr = svld1_s8(pg, reinterpret_cast<const int8_t*>(str));\n\n        svint32_t vopen = svcntb_m_n(svptrue_b8(), svcmpeq_b8(pg, vstr, svdup_s8('(')));\n        svint32_t vclose = svcntb_m_n(svptrue_b8(), svcmpeq_b8(pg, vstr, svdup_s8(')')));\n\n        vbalance = svadd_s32_m(pg, vbalance, svsub_s32_z(pg, vopen, vclose));\n        balance = svlastb_h32(svptrue_b32(), vbalance);\n\n        if (balance < 0) {\n            return false;\n        }\n\n        str += svcntb(pg);\n        len -= svcntb(pg);\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int32_t balance = 0;\n    size_t len = brackets.size();\n    const char* str = brackets.c_str();\n\n    while (len > 0) {\n        svbool_t pg = svwhilelt_b32(0, len);\n        svint32_t vbalance = svdup_s32(balance);\n        svint8_t vstr = svld1_s8(pg, reinterpret_cast<const int8_t*>(str));\n\n        svint32_t vopen = svcntb_m_n(svptrue_b8(), svcmpeq_b8(pg, vstr, svdup_s8('(')));\n        svint32_t vclose = svcntb_m_n(svptrue_b8(), svcmpeq_b8(pg, vstr, svdup_s8(')')));\n\n        vbalance = svadd_s32_m(pg, vbalance, svsub_s32_z(pg, vopen, vclose));\n        balance = svlastb_h32(svptrue_b32(), vbalance);\n\n        if (balance < 0) {\n            return false;\n        }\n\n        str += svcntb_b8(svptrue_b8());\n        len -= svcntb_b8(svptrue_b8());\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int32_t balance = 0;\n    size_t len = brackets.size();\n    const char* str = brackets.c_str();\n\n    while (len > 0) {\n        svbool_t pg = svwhilelt_b32(0, len);\n        svint32_t vbalance = svdup_s32(balance);\n        svint8_t vstr = svld1_s8(pg, reinterpret_cast<const int8_t*>(str));\n\n        svint32_t vopen = svcntb_m_n(svptrue_b8(), svcmpeq_b8(pg, vstr, svdup_s8('(')));\n        svint32_t vclose = svcntb_m_n(svptrue_b8(), svcmpeq_b8(pg, vstr, svdup_s8(')')));\n        vbalance = svadd_s32_m(pg, vbalance, svsub_s32_z(pg, vopen, vclose));\n\n        balance = svlastb_h(svptrue_b32(), vbalance);\n\n        if (balance < 0) {\n            return false;\n        }\n\n        str += svcntb_b8(svptrue_b8());\n        len -= svcntb_b8(svptrue_b8());\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int32_t balance = 0;\n    size_t len = brackets.size();\n    const char* str = brackets.c_str();\n\n    while (len > 0) {\n        svbool_t pg = svwhilelt_b32(0, len);\n        svint32_t vbalance = svdup_s32(balance);\n        svint32_t vopen = svcntb_m_n(svptrue_b8(), pg, svcmpeq_b8(pg, svld1_b8(pg, (const uint8_t*)str), svdup_u8('(')));\n        svint32_t vclose = svcntb_m_n(svptrue_b8(), pg, svcmpeq_b8(pg, svld1_b8(pg, (const uint8_t*)str), svdup_u8(')')));\n        vbalance = svadd_s32_m(pg, vbalance, svsub_s32_z(pg, vopen, vclose));\n        balance = svlastb_h(svptrue_b32(), vbalance);\n        if (balance < 0) {\n            return false;\n        }\n        str += svcntb(pg);\n        len -= svcntb(pg);\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    std::vector<float> result;\n    if (xs.size() <= 1) {\n        return result;\n    }\n    result.resize(xs.size() - 1);\n\n    svfloat32_t vindex = svindex_f32(0.0f, 1.0f);\n    svfloat32_t vmul = svdup_f32(1.0f);\n    size_t i = 0;\n    for (; i <= xs.size() - 8; i += 8) {\n        svfloat32_t vx = svld1_f32(&xs[i + 1]);\n        svfloat32_t vresult = svmul_f32_z(svptrue_b32(), vx, svadd_f32_z(svptrue_b32(), vindex, vmul));\n        svst1_f32(&result[i], vresult);\n        vindex = svadd_f32_z(svptrue_b32(), vindex, svdup_f32(8.0f));\n    }\n\n    for (; i < xs.size() - 1; ++i) {\n        result[i] = xs[i + 1] * (i + 1);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    std::vector<float> result;\n    if (xs.size() <= 1) {\n        return result;\n    }\n    result.resize(xs.size() - 1);\n\n    svfloat32_t vindex = svindex_f32(1.0f, 1.0f);\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < result.size(); i += vl) {\n        svfloat32_t vcoeffs = svld1_f32(svundef_u32(), &xs[i + 1], vl);\n        svfloat32_t vderivative = svmul_f32_z(svptrue_b32(), vcoeffs, vindex);\n        svst1_f32(svundef_u32(), &result[i], vderivative);\n        vindex = svadd_f32_z(svptrue_b32(), vindex, svdup_n_f32(vl));\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    std::vector<float> result;\n    if (xs.size() <= 1) return result;\n\n    size_t n = xs.size() - 1;\n    result.resize(n);\n\n    svfloat32_t vindex = svindex_f32(1.0f, 1.0f);\n    svfloat32_t vzero = svdup_f32(0.0f);\n\n    float *input_ptr = xs.data() + 1;\n    float *output_ptr = result.data();\n\n    while (svcntb(svptrue_b32()) <= n) {\n        svbool_t pg = svwhilelt_b32(0, n);\n        svfloat32_t vcoeff = svld1(pg, input_ptr);\n        svfloat32_t vresult = svmul_f32_m(pg, vzero, vcoeff, vindex);\n        svst1(pg, output_ptr, vresult);\n        input_ptr += svcntb(svptrue_b32());\n        output_ptr += svcntb(svptrue_b32());\n        vindex = svadd_f32_z(pg, vindex, svdup_f32(svcntb(svptrue_b32())));\n        n -= svcntb(svptrue_b32());\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    std::vector<float> result;\n    if (xs.size() <= 1) return result;\n\n    size_t n = xs.size() - 1;\n    result.resize(n);\n\n    svfloat32_t vindex = svindex_f32(1.0f, 1.0f);\n    svfloat32_t vzero = svdup_f32(0.0f);\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        size_t vl = svcntw();\n        if (i + vl > n) {\n            vl = n - i;\n        }\n\n        svfloat32_t vcoeffs = svld1_f32(svundef_b(), &xs[i + 1]);\n        svfloat32_t vresult = svmul_f32_z(svptrue_b32(), vcoeffs, vindex);\n\n        svst1_f32(svundef_b(), &result[i], vresult);\n\n        vindex = svadd_f32_z(svptrue_b32(), vindex, svdup_f32(vl));\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    std::vector<float> result;\n    if (xs.size() <= 1) {\n        return result;\n    }\n    result.resize(xs.size() - 1);\n\n    svfloat32_t vindex = svindex_f32(1.0f, 1.0f);\n    size_t i = 0;\n    for (; i <= xs.size() - 1 - SVF32_MAX; i += SVF32_MAX) {\n        svfloat32_t vcoeffs = svld1_f32(&xs[i + 1]);\n        svfloat32_t vresult = svmul_f32_m(svtrue_f32(), vcoeffs, vindex);\n        svst1_f32(&result[i], vresult);\n        vindex = svadd_f32_x(vindex, svdup_f32(SVF32_MAX));\n    }\n\n    for (; i < xs.size() - 1; ++i) {\n        result[i] = xs[i + 1] * (i + 1);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <cctype>\n\nint vowels_count_simd(const std::string s) {\n    int count = 0;\n    size_t len = s.length();\n    const char* str = s.c_str();\n\n    svbool_t pg;\n    svint8_t vec, vowels1, vowels2, y_check;\n    svint8_t a = svdup_s8('a'), e = svdup_s8('e'), i = svdup_s8('i'), o = svdup_s8('o'), u = svdup_s8('u'), y = svdup_s8('y');\n\n    for (size_t i = 0; i < len; i += svcntb()) {\n        pg =svptrue_b8();\n        if (i + svcntb() > len) {\n            pg = svwhilelt_b8(i, len);\n        }\n        vec = svld1_s8(pg, reinterpret_cast<const int8_t*>(str + i));\n\n        vowels1 = svorr_s8_z(pg, svorr_s8_z(pg, svorr_s8_z(pg, svcmpeq_s8(pg, vec, a), svcmpeq_s8(pg, vec, e)), svcmpeq_s8(pg, vec, i)), svcmpeq_s8(pg, vec, o));\n        vowels2 = svorr_s8_z(pg, svcmpeq_s8(pg, vec, u), svand_s8_z(pg, svcmpeq_s8(pg, vec, y), svcmpeq_s8(pg, svld1_s8(svwhilelt_b8(i + svcntb() - 1, len), reinterpret_cast<const int8_t*>(str + i + svcntb() - 1)), y)));\n\n        count += svcntp_b8(svorr_s8_z(pg, vowels1, vowels2), pg);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <cctype>\n\nint vowels_count_simd(const std::string s) {\n    int count = 0;\n    const char* str = s.c_str();\n    svbool_t pg;\n    svint8_t vowels, ch, y_check;\n    svint8_t a = svdup_s8('a'), e = svdup_s8('e'), i = svdup_s8('i'), o = svdup_s8('o'), u = svdup_s8('u'), y = svdup_s8('y');\n    svint8_t A = svdup_s8('A'), E = svdup_s8('E'), I = svdup_s8('I'), O = svdup_s8('O'), U = svdup_s8('U'), Y = svdup_s8('Y');\n\n    size_t length = s.length();\n    size_t i = 0;\n\n    while (svptest_any(svptrue_b8(), pg = svwhilelt_b8(i, length))) {\n        ch = svld1_b8(pg, reinterpret_cast<const uint8_t*>(str + i));\n        vowels = svorr_b8(svorr_b8(svorr_b8(svorr_b8(svorr_b8(sveq_b8(ch, a), sveq_b8(ch, e)), sveq_b8(ch, i)), sveq_b8(ch, o)), sveq_b8(ch, u)),\n                         svorr_b8(svorr_b8(svorr_b8(svorr_b8(svorr_b8(sveq_b8(ch, A), sveq_b8(ch, E)), sveq_b8(ch, I)), sveq_b8(ch, O)), sveq_b8(ch, U)));\n        y_check = svand_b8(sveq_b8(ch, y), svcmpeq_n_b8(pg, svindex_s8(svptrue_b8(), 0, 1), length - 1));\n        y_check = svorr_b8(y_check, svand_b8(sveq_b8(ch, Y), svcmpeq_n_b8(pg, svindex_s8(svptrue_b8(), 0, 1), length - 1)));\n        vowels = svorr_b8(vowels, y_check);\n        count += svcntp_b8(svptrue_b8(), vowels);\n        i += svcntb();\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <cctype>\n\nint vowels_count_simd(const std::string s) {\n    int count = 0;\n    const char* str = s.c_str();\n    svbool_t pg;\n    svint8_t vec, vowels1, vowels2, y_check;\n    svint8_t a = svdup_s8('a'), e = svdup_s8('e'), i = svdup_s8('i'), o = svdup_s8('o'), u = svdup_s8('u'), y = svdup_s8('y');\n    svint8_t A = svdup_s8('A'), E = svdup_s8('E'), I = svdup_s8('I'), O = svdup_s8('O'), U = svdup_s8('U'), Y = svdup_s8('Y');\n\n    size_t length = s.length();\n    size_t i = 0;\n\n    while (svptest_any(svptrue_b8(), pg = svwhilelt_b8(i, length))) {\n        vec = svld1_s8(pg, reinterpret_cast<const int8_t*>(str + i));\n        vowels1 = svorr_s8(svorr_s8(svorr_s8(svorr_s8(svcmpeq_s8(pg, vec, a), svcmpeq_s8(pg, vec, e)), svcmpeq_s8(pg, vec, i)), svcmpeq_s8(pg, vec, o)), svcmpeq_s8(pg, vec, u));\n        vowels2 = svorr_s8(svorr_s8(svorr_s8(svorr_s8(svcmpeq_s8(pg, vec, A), svcmpeq_s8(pg, vec, E)), svcmpeq_s8(pg, vec, I)), svcmpeq_s8(pg, vec, O)), svcmpeq_s8(pg, vec, U));\n        y_check = svand_s8(svorr_s8(svcmpeq_s8(pg, vec, y), svcmpeq_s8(pg, vec, Y)), svcmpeq_s8(pg, svindex_s8(svptrue_b8(), 0, 1), svdup_s8(length - 1)));\n\n        count += svcntp_b8(svptrue_b8(), svorr_s8(svorr_s8(vowels1, vowels2), y_check));\n\n        i += svcntb();\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <cctype>\n\nint vowels_count_simd(const std::string s) {\n    int count = 0;\n    const char* str = s.c_str();\n    svbool_t pg;\n    svint8_t vec, vowels1, vowels2, y_check;\n    svint8_t a = svdup_s8('a'), e = svdup_s8('e'), i = svdup_s8('i'), o = svdup_s8('o'), u = svdup_s8('u'), y = svdup_s8('y');\n    svint8_t A = svdup_s8('A'), E = svdup_s8('E'), I = svdup_s8('I'), O = svdup_s8('O'), U = svdup_s8('U'), Y = svdup_s8('Y');\n\n    size_t length = s.length();\n    size_t i = 0;\n\n    while (i < length) {\n        size_t vl = svcntb();\n        if (i + vl > length) {\n            vl = length - i;\n        }\n        pg = svwhilelt_b8(i, length);\n        vec = svld1_s8(pg, reinterpret_cast<const int8_t*>(str + i));\n\n        vowels1 = svorr_z(svorr_z(svorr_z(svorr_z(sveq_z(pg, vec, a), sveq_z(pg, vec, e)), sveq_z(pg, vec, i)), sveq_z(pg, vec, o)), sveq_z(pg, vec, u));\n        vowels2 = svorr_z(svorr_z(svorr_z(svorr_z(sveq_z(pg, vec, A), sveq_z(pg, vec, E)), sveq_z(pg, vec, I)), sveq_z(pg, vec, O)), sveq_z(pg, vec, U));\n        y_check = svand_z(sveq_z(pg, vec, y), svcmpeq_n_b8(pg, svindex_s8(0, 1), length - i - 1));\n        y_check = svorr_z(y_check, svand_z(sveq_z(pg, vec, Y), svcmpeq_n_b8(pg, svindex_s8(0, 1), length - i - 1)));\n\n        svbool_t vowels = svorr_z(svorr_z(vowels1, vowels2), y_check);\n\n        count += svcntp_b8(svptrue_b8(), vowels);\n\n        i += vl;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <cctype>\n\nint vowels_count_simd(const std::string s) {\n    int count = 0;\n    const char* str = s.c_str();\n    svbool_t pg;\n    svint8_t vec, vowels1, vowels2, y_check;\n    int64_t i = 0;\n    size_t len = s.length();\n\n    // Define vectors for vowels 'a', 'e', 'i', 'o', 'u'\n    vowels1 = svdup_s8('a');\n    vowels2 = svdup_s8('e');\n    svint8_t vowels3 = svdup_s8('i');\n    svint8_t vowels4 = svdup_s8('o');\n    svint8_t vowels5 = svdup_s8('u');\n    svint8_t y_vowel = svdup_s8('y');\n\n    while (svptest_any(svptrue_b8(), pg = svwhilelt_b8(i, len))) {\n        vec = svld1_s8(pg, reinterpret_cast<const int8_t*>(str + i));\n\n        // Check for vowels 'a', 'e', 'i', 'o', 'u' (case insensitive)\n        svbool_t vowel_mask = svorr_b8(svorr_b8(svorr_b8(svorr_b8(svcmpeq_s8(pg, svcvt_s8_s32_z(pg, svcvt_u32_s8_z(pg, vec))), vowels1),\n                                                            svcvt_s8_s32_z(pg, svcvt_u32_s8_z(pg, vec))), vowels2),\n                                                  svcvt_s8_s32_z(pg, svcvt_u32_s8_z(pg, vec))), vowels3);\n        vowel_mask = svorr_b8(vowel_mask, svcvt_s8_s32_z(pg, svcvt_u32_s8_z(pg, vec)), vowels4);\n        vowel_mask = svorr_b8(vowel_mask, svcvt_s8_s32_z(pg, svcvt_u32_s8_z(pg, vec)), vowels5);\n\n        // Check for 'y' at the end of the string (case insensitive)\n        y_check = svcvt_s8_s32_z(pg, svcvt_u32_s8_z(pg, vec));\n        y_check = svand_b8(y_check, svcmpeq_s8(pg, y_check, y_vowel));\n        y_check = svand_b8(y_check, svcmpeq_s8(pg, svindex_s8(svptrue_b8(), 0, 1), svdup_s8(len - i - 1)));\n\n        // Combine masks\n        vowel_mask = svorr_b8(vowel_mask, y_check);\n\n        // Count vowels\n        count += svcntp_b8(svptrue_b8(), vowel_mask);\n\n        i += svcntb();\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    const char* str = s.c_str();\n    size_t len = s.length();\n\n    while (len > 0) {\n        svbool_t pg = svwhilelt_b8(0, len);\n        svuint8_t vec = svld1(pg, reinterpret_cast<const uint8_t*>(str));\n        svuint8_t upper_mask = svdup_u8('A' - 1);\n        svuint8_t lower_mask = svdup_u8('Z' + 1);\n        svbool_t upper_check = svcmplt(svcmpgt(pg, vec, upper_mask), vec, lower_mask);\n        svuint16_t sum_vec = svaddw_u16_z(svptrue_b16(), svdup_u16(0), svsel_u8(upper_check, vec, svdup_u8(0)));\n        sum += svaddv_u32(svaddd_u32_z(svptrue_b32(), svdup_u32(0), svadd_u32_x(svptrue_b32(), sum_vec)));\n\n        str += svcntb();\n        len -= svcntb();\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    const char* str = s.c_str();\n    size_t len = s.length();\n\n    while (len > 0) {\n        svbool_t pg = svwhilelt_b8(0, len);\n        svuint8_t vec = svld1(pg, reinterpret_cast<const uint8_t*>(str));\n        svuint8_t upper_mask = svdup_u8('A' - 1);\n        svuint8_t lower_mask = svdup_u8('Z' + 1);\n        svbool_t upper_check = svcmplt(svcmpgt(pg, vec, upper_mask), vec, lower_mask);\n        svuint16_t sum_vec = svaddw_u16_z(svptrue_b16(), svdup_u16(0), svsel_u8(upper_check, vec, svdup_u8(0)));\n        sum += svaddv_u32(svaddd_u32_z(svptrue_b32(), svdup_u32(0), svadd_u32_x(svptrue_b32(), sum_vec)));\n\n        str += svcntb();\n        len -= svcntb();\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    const char* str = s.c_str();\n    size_t len = s.length();\n\n    while (len > 0) {\n        svbool_t pg = svwhilelt_b8(0, len);\n        svuint8_t vec = svld1(pg, reinterpret_cast<const uint8_t*>(str));\n        svuint8_t upper_mask = svdup_u8('A' - 1);\n        svuint8_t lower_mask = svdup_u8('Z' + 1);\n        svbool_t upper_check = svcmplt(svcmpgt(pg, vec, upper_mask), vec, lower_mask);\n        svuint16_t sum_vec = svaddw_u16_z(svptrue_b16(), svdup_u16(0), svsel_u8(upper_check, vec, svdup_u8(0)));\n        sum += svaddv_u32(svaddd_u32_z(svptrue_b32(), svdup_u32(0), svadd_u32_x(svptrue_b32(), sum_vec)));\n\n        str += svcntb();\n        len -= svcntb();\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    const char* str = s.c_str();\n    size_t len = s.length();\n\n    while (len > 0) {\n        svbool_t pg = svwhilelt_b8(0, len);\n        svuint8_t vec = svld1(pg, reinterpret_cast<const uint8_t*>(str));\n        svuint8_t upper_mask = svdup_u8('A' - 1);\n        svuint8_t lower_mask = svdup_u8('Z' + 1);\n        svbool_t upper_check = svcmplt(svcmpgt(pg, vec, upper_mask), vec, lower_mask);\n        svuint16_t sum_vec = svaddw_u16_z(svptrue_b16(), svdup_u16(0), svsel_u8(upper_check, vec, svdup_u8(0)));\n        sum += svaddv_u32(svaddd_u32_z(svptrue_b32(), svdup_u32(0), svreinterpret_u32_u16(sum_vec)));\n\n        str += svcntb();\n        len -= svcntb();\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    const char* str = s.c_str();\n    size_t len = s.length();\n\n    while (len > 0) {\n        svbool_t pg = svwhilelt_b8(0, len);\n        svuint8_t vec = svld1(pg, reinterpret_cast<const uint8_t*>(str));\n        svuint8_t upper_mask = svdup_u8('A' - 1);\n        svuint8_t lower_mask = svdup_u8('Z' + 1);\n        svbool_t upper_check = svcmplt(svcmpgt(pg, vec, upper_mask), vec, lower_mask);\n        svuint16_t sum_vec = svaddw_u16_z(svptrue_b16(), svdup_u16(0), svsel_u8(upper_check, vec, svdup_u8(0)));\n        sum += svaddv_u32(svaddd_u32_z(svptrue_b32(), svdup_u32(0), svreinterpret_u32_u16(sum_vec)));\n\n        str += svcntb();\n        len -= svcntb();\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int64_t min_even_value = std::numeric_limits<int64_t>::max();\n    int64_t min_index = -1;\n\n    svbool_t pg = svptrue_b32();\n    svint32_t min_vec = svdup_s32(static_cast<int32_t>(min_even_value));\n    svint32_t idx_vec = svindex_s32(0, 1);\n\n    for (size_t i = 0; i < arr.size(); i += svcntw()) {\n        size_t vl = svcntw();\n        if (i + vl > arr.size()) {\n            vl = arr.size() - i;\n            pg = svwhilelt_b32(0, vl);\n        }\n\n        svint32_t vec = svld1(pg, &arr[i]);\n        svbool_t even_mask = sveven_s32(vec);\n\n        if (svptest_any(svptrue_b32(), even_mask)) {\n            svint32_t even_vec = svsel_s32(even_mask, vec, svdup_s32(static_cast<int32_t>(min_even_value)));\n            svbool_t min_mask = svcmplt_s32(pg, even_vec, min_vec);\n\n            if (svptest_any(svptrue_b32(), min_mask)) {\n                min_vec = svsel_s32(min_mask, even_vec, min_vec);\n                idx_vec = svsel_s32(min_mask, svadd_zi_s32(pg, idx_vec, static_cast<int32_t>(i)), idx_vec);\n            }\n        }\n    }\n\n    int32_t result_value = svnth_s32(svptrue_b32(), min_vec, 0);\n    int32_t result_index = svnth_s32(svptrue_b32(), idx_vec, 0);\n\n    if (result_value == static_cast<int32_t>(min_even_value)) {\n        return {};\n    }\n\n    return {result_value, result_index};\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int64_t min_even_value = std::numeric_limits<int64_t>::max();\n    int64_t min_index = -1;\n\n    svbool_t pg = svptrue_b32();\n    svint32_t min_vec = svdup_s32(min_even_value);\n    svint32_t idx_vec = svindex_s32(0, 1);\n\n    for (size_t i = 0; i < arr.size(); i += svcntw()) {\n        size_t vl = svmin(svcntw(), arr.size() - i);\n        pg = svwhilelt_b32(0, vl);\n\n        svint32_t vec = svld1_s32(pg, arr.data() + i);\n        svbool_t even_mask = sveven_s32_m(svundef_b32(), vec, pg);\n\n        if (svptest_any(svptrue_b32(), even_mask)) {\n            svint32_t even_vec = svsel_s32(even_mask, vec, svdup_s32(min_even_value));\n            svint32_t even_idx = svsel_s32(even_mask, idx_vec, svdup_s32(-1));\n\n            svbool_t min_mask = svcmplt_s32_m(svundef_b32(), even_vec, min_vec, pg);\n            min_vec = svsel_s32(min_mask, even_vec, min_vec);\n            min_index = svmad_s32_z(pg, min_mask, min_index, even_idx, svdup_s32(1));\n        }\n\n        idx_vec = svadd_z(pg, idx_vec, svdup_s32(svcntw()));\n    }\n\n    int result_value = svnth_s32(svptrue_b32(), min_vec, 0);\n    int result_index = svnth_s32(svptrue_b32(), svdup_s32(min_index), 0);\n\n    if (result_value == std::numeric_limits<int64_t>::max()) {\n        return {};\n    } else {\n        return {result_value, result_index};\n    }\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int64_t min_even_value = std::numeric_limits<int64_t>::max();\n    int64_t min_index = -1;\n\n    svbool_t pg = svptrue_b32();\n    svint32_t min_vec = svdup_s32(min_even_value);\n    svint32_t idx_vec = svindex_s32(0, 1);\n\n    for (size_t i = 0; i < arr.size(); i += svcntw()) {\n        size_t vl = svmin(svcntw(), arr.size() - i);\n        pg = svwhilelt_b32(0, vl);\n\n        svint32_t vec = svld1(pg, arr.data() + i);\n        svbool_t even_mask = sveven_s32_m(svundef_b32(), vec, pg);\n\n        if (svptest_any(even_mask)) {\n            svint32_t even_vec = svsel_s32(even_mask, vec, svdup_s32(min_even_value));\n            svint32_t even_idx = svsel_s32(even_mask, idx_vec, svdup_s32(-1));\n\n            svbool_t min_even_mask = svcmplt_s32_m(svundef_b32(), even_vec, min_vec, pg);\n            min_vec = svsel_s32(min_even_mask, even_vec, min_vec);\n            min_idx = svsel_s32(min_even_mask, even_idx, min_idx);\n        }\n\n        idx_vec = svadd_z(pg, idx_vec, svdup_s32(svcntw()));\n    }\n\n    int32_t result_value = svnth_s32(svptrue_b32(), min_vec, 0);\n    int32_t result_index = svnth_s32(svptrue_b32(), min_idx, 0);\n\n    if (result_value == std::numeric_limits<int64_t>::max()) {\n        return {};\n    } else {\n        return {result_value, result_index};\n    }\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int64_t min_even_value = std::numeric_limits<int64_t>::max();\n    int64_t min_index = -1;\n\n    svbool_t pg = svptrue_b32();\n    svint32_t min_vec = svdup_s32(min_even_value);\n    svint32_t index_vec = svindex_s32(0, 1);\n\n    for (size_t i = 0; i < arr.size(); i += svcntw()) {\n        size_t vl = svminv_u32(svptrue_b32(), svwhilelt_b32(i, arr.size()));\n        svint32_t vec = svld1_s32(pg, arr.data() + i);\n        svbool_t even_mask = sveven_s32_m(svundef_b32(), vec, pg);\n        svint32_t even_vec = svsel_s32(even_mask, vec, svdup_s32(min_even_value));\n        svbool_t min_mask = svcmplt_s32(even_vec, min_vec, pg);\n        min_vec = svsel_s32(min_mask, even_vec, min_vec);\n        index_vec = svsel_s32(min_mask, svadd_zi_s32(pg, index_vec, i), index_vec);\n    }\n\n    int32_t result_min_value = svminv_s32_m(svptrue_b32(), min_vec);\n    int32_t result_index = svminv_s32_m(svptrue_b32(), index_vec);\n\n    if (result_min_value == min_even_value) {\n        return {};\n    }\n\n    return {result_min_value, result_index};\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int64_t min_even_value = std::numeric_limits<int64_t>::max();\n    int64_t min_index = -1;\n\n    svbool_t pg = svptrue_b32();\n    svint32_t min_vec = svdup_s32(min_even_value);\n    svint32_t index_vec = svindex_s32(0, 1);\n\n    for (size_t i = 0; i < arr.size(); i += svcntw()) {\n        size_t vl = svcntw() < arr.size() - i ? svcntw() : arr.size() - i;\n        pg = svwhilelt_b32(svptrue_b32(), i, arr.size());\n\n        svint32_t vec = svld1(pg, arr.data() + i);\n        svbool_t even_mask = sveven_s32_m(svundef_b32(), vec, pg);\n\n        if (svptest_any(even_mask)) {\n            svint32_t even_vec = svsel_s32(even_mask, vec, svdup_s32(min_even_value));\n            svint32_t even_indices = svsel_s32(even_mask, index_vec, svdup_s32(-1));\n\n            svbool_t min_even_mask = svcmplt_s32_m(svundef_b32(), even_vec, min_vec, pg);\n            min_vec = svsel_s32(min_even_mask, even_vec, min_vec);\n            min_index = svmad_s32_z(pg, min_index, min_even_mask, even_indices, 1);\n        }\n\n        index_vec = svadd_x(svptrue_b32(), index_vec, svcntw());\n    }\n\n    int result_value = svnth_s32(svptrue_b32(), min_vec, 0);\n    int result_index = svnth_s32(svptrue_b32(), svdup_s32(min_index), 0);\n\n    if (result_value == std::numeric_limits<int64_t>::max()) {\n        return {};\n    } else {\n        return {result_value, result_index};\n    }\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <unordered_map>\n\nint search_simd(std::vector<int> lst) {\n    std::unordered_map<int, int> frequency_map;\n    int *data = lst.data();\n    size_t size = lst.size();\n\n    while (size > 0) {\n        svbool_t pg = svwhilelt_b32(0, size);\n        svint32_t vec = svld1(pg, data);\n\n        for (int i = 0; i < svcntw(); ++i) {\n            if (svptest_any(svptrue_b32(), pg)) {\n                int value = svnth_u32(pg, vec, i);\n                frequency_map[value]++;\n            }\n            pg = svpnext_b32(pg);\n        }\n\n        data += svcntw();\n        size -= svcntw();\n    }\n\n    int result = -1;\n    for (const auto& pair : frequency_map) {\n        if (pair.first > 0 && pair.second >= pair.first) {\n            result = std::max(result, pair.first);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <unordered_map>\n\nint search_simd(std::vector<int> lst) {\n    std::unordered_map<int, int> frequency;\n    int *data = lst.data();\n    size_t size = lst.size();\n\n    while (size > 0) {\n        svbool_t pg = svwhilelt_b32(0, size);\n        svint32_t vec = svld1(pg, data);\n\n        for (int i = 0; i < svcntw(); ++i) {\n            if (svptest_any(svptrue_b32(), pg)) {\n                int val = svnth_u32(pg, vec, i);\n                frequency[val]++;\n            }\n            pg = svpnext_b32(pg);\n        }\n\n        data += svcntw();\n        size -= svcntw();\n    }\n\n    int result = -1;\n    for (const auto& pair : frequency) {\n        if (pair.first > 0 && pair.second >= pair.first) {\n            result = std::max(result, pair.first);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <unordered_map>\n\nint search_simd(std::vector<int> lst) {\n    std::unordered_map<int, int> frequency;\n    int *data = lst.data();\n    size_t size = lst.size();\n\n    while (size > 0) {\n        svbool_t pg = svwhilelt_b32(0, size);\n        svint32_t vec = svld1(pg, data);\n\n        for (int i = 0; i < svcntw(); ++i) {\n            if (svptest_any(svptrue_b32(), pg)) {\n                int value = svnth_u32(pg, vec, i);\n                frequency[value]++;\n            }\n            pg = svpnext_b32(pg);\n        }\n\n        data += svcntw();\n        size -= svcntw();\n    }\n\n    int result = -1;\n    for (const auto& pair : frequency) {\n        if (pair.first > 0 && pair.second >= pair.first) {\n            result = std::max(result, pair.first);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <unordered_map>\n\nint search_simd(std::vector<int> lst) {\n    std::unordered_map<int, int> frequency_map;\n    int *data = lst.data();\n    size_t size = lst.size();\n\n    // Calculate frequencies using SVE\n    while (size > 0) {\n        svbool_t pg = svwhilelt_b32(0, size);\n        svint32_t vec = svld1(pg, data);\n\n        // Count occurrences of each element in the vector\n        for (int i = 0; i < svcntw(); ++i) {\n            if (svptest_any(svptrue_b32(), svcmpeq_n_b32(pg, vec, data[i]))) {\n                frequency_map[data[i]]++;\n            }\n        }\n\n        data += svcntw();\n        size -= svcntw();\n    }\n\n    // Find the greatest integer with frequency >= its value\n    int result = -1;\n    for (const auto& pair : frequency_map) {\n        if (pair.second >= pair.first && pair.first > result) {\n            result = pair.first;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <unordered_map>\n\nint search_simd(std::vector<int> lst) {\n    std::unordered_map<int, int> frequency;\n    int *data = lst.data();\n    size_t size = lst.size();\n\n    while (size > 0) {\n        svbool_t pg = svwhilelt_b32(0, size);\n        svint32_t vec = svld1(pg, data);\n\n        for (int i = 0; i < svcntw(); ++i) {\n            if (svptest_any(svptrue_b32(), pg)) {\n                int val = svnth_u32(pg, vec, i);\n                frequency[val]++;\n            }\n            pg = svpnext_b32(pg);\n        }\n\n        data += svcntw();\n        size -= svcntw();\n    }\n\n    int result = -1;\n    for (const auto &pair : frequency) {\n        if (pair.first > 0 && pair.second >= pair.first) {\n            result = std::max(result, pair.first);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    size_t n = q.size();\n    if (n == 0) return false;\n\n    // Check if the vector is a palindrome\n    svint32_t vec = svld1_s32(svundef_u32(), q.data());\n    svint32_t rev_vec = svld1_s32(svundef_u32(), q.rbegin());\n    svbool_t pg = svptrue_b32();\n    if (!svall_b32(pg, sveq_s32(pg, vec, rev_vec))) {\n        return false;\n    }\n\n    // Calculate the sum of the vector elements\n    int64_t sum = 0;\n    svint32_t sum_vec = svdup_s32(0);\n    for (size_t i = 0; i < n; i += svcntw()) {\n        svint32_t tmp_vec = svld1_s32(svundef_u32(), &q[i]);\n        sum_vec = svadd_s32_m(pg, sum_vec, tmp_vec);\n    }\n    sum = svaddv_s32(svptrue_b32(), sum_vec);\n\n    // Check if the sum is less than or equal to the maximum possible weight\n    return sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    size_t n = q.size();\n    if (n == 0) return false;\n\n    // Check if the vector is a palindrome\n    svint32_t *q_ptr = reinterpret_cast<svint32_t*>(q.data());\n    size_t i = 0;\n    bool is_palindrome = true;\n    for (; i <= n / 2; i += svcntw()) {\n        svint32_t vec1 = svld1_s32(q_ptr + i);\n        svint32_t vec2 = svld1_s32(q_ptr + n - i - svcntw());\n        svbool_t pg = svcmpeq_s32(svptrue_b32(), vec1, vec2);\n        if (!svall_b32(svptrue_b32(), pg)) {\n            is_palindrome = false;\n            break;\n        }\n    }\n    if (!is_palindrome) return false;\n\n    // Calculate the sum of the elements\n    svint32_t sum_vec = svdup_s32(0);\n    i = 0;\n    for (; i < n; i += svcntw()) {\n        svint32_t vec = svld1_s32(q_ptr + i);\n        sum_vec = svadd_s32_m(svptrue_b32(), sum_vec, vec);\n    }\n    int64_t sum = svaddv_s32(svptrue_b32(), sum_vec);\n\n    return sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    size_t n = q.size();\n    if (n == 0) return false;\n\n    // Check if the vector is a palindrome\n    svint32_t *data = reinterpret_cast<svint32_t*>(q.data());\n    size_t i = 0;\n    bool is_palindrome = true;\n    for (; i <= n / 2; i += svcntw()) {\n        svint32_t vec1 = svld1_s32(&data[i]);\n        svint32_t vec2 = svld1_s32(&data[n - i - svcntw()]);\n        svbool_t pg = svcmpeq_s32(svptrue_b32(), vec1, vec2);\n        if (!svptest_any(svptrue_b32(), pg)) {\n            is_palindrome = false;\n            break;\n        }\n    }\n    if (!is_palindrome) return false;\n\n    // Calculate the sum of the vector elements\n    svint32_t sum_vec = svdup_s32(0);\n    i = 0;\n    for (; i < n; i += svcntw()) {\n        svint32_t vec = svld1_s32(&data[i]);\n        sum_vec = svadd_s32_m(svptrue_b32(), sum_vec, vec, sum_vec);\n    }\n    int64_t sum = svaddv_s32(svptrue_b32(), sum_vec);\n\n    return sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    size_t n = q.size();\n    if (n == 0) return false;\n\n    // Check if the vector is a palindrome\n    svint32_t *q_ptr = reinterpret_cast<svint32_t*>(q.data());\n    size_t i = 0;\n    bool is_palindrome = true;\n    for (; i <= n / 2; i += svcntw()) {\n        svint32_t vec1 = svld1_s32(q_ptr + i);\n        svint32_t vec2 = svld1_s32(q_ptr + n - i - svcntw());\n        svbool_t pg = svcmpeq_s32(svptrue_b32(), vec1, vec2);\n        if (!svall_b32(svptrue_b32(), pg)) {\n            is_palindrome = false;\n            break;\n        }\n    }\n    if (!is_palindrome) return false;\n\n    // Calculate the sum of the vector elements\n    svint32_t sum_vec = svdup_s32(0);\n    i = 0;\n    for (; i < n; i += svcntw()) {\n        svint32_t vec = svld1_s32(q_ptr + i);\n        sum_vec = svadd_s32_z(svptrue_b32(), sum_vec, vec);\n    }\n    int64_t sum = svaddv_s32(svptrue_b32(), sum_vec);\n\n    return sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    size_t n = q.size();\n    if (n == 0) return false;\n\n    // Check if the vector is a palindrome\n    svint32_t *q_ptr = reinterpret_cast<svint32_t*>(q.data());\n    size_t i = 0;\n    bool is_palindrome = true;\n    for (; i <= n / 2; i += svcntw()) {\n        svint32_t vec1 = svld1_s32(q_ptr + i);\n        svint32_t vec2 = svld1_s32(q_ptr + n - i - svcntw());\n        svbool_t pg = svcmpeq_s32(svptrue_b32(), vec1, vec2);\n        if (!svall_b32(svptrue_b32(), pg)) {\n            is_palindrome = false;\n            break;\n        }\n    }\n    if (!is_palindrome) return false;\n\n    // Calculate the sum of the vector elements\n    svint32_t sum_vec = svdup_s32(0);\n    i = 0;\n    for (; i < n; i += svcntw()) {\n        svint32_t vec = svld1_s32(q_ptr + i);\n        sum_vec = svadd_s32_z(svptrue_b32(), sum_vec, vec);\n    }\n    int64_t sum = svaddv_s32(svptrue_b32(), sum_vec);\n\n    return sum <= w;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    svbool_t pg = svptrue_b32();\n    svint32_t zero = svdup_s32(0);\n\n    for (int i = 0; i < n / 2; i += svcntw()) {\n        svint32_t a = svld1_s32(pg, &arr[i]);\n        svint32_t b = svld1_s32(pg, &arr[n - i - 1]);\n\n        svbool_t neq = svcmpne_s32(pg, a, b);\n        svint32_t count = svcntb_h(svptrue_b8(), svand_b32(neq, neq));\n\n        changes += svaddv_s32_z(pg, count, zero);\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    // Calculate the number of elements to process in each iteration\n    svbool_t pg = svptrue_b32();\n    svint32_t zero = svdup_s32(0);\n\n    for (int i = 0; i < n / 2; i += svcntw()) {\n        // Load vectors from the start and end of the array\n        svint32_t a = svld1(pg, &arr[i]);\n        svint32_t b = svld1(pg, &arr[n - i - svcntw()]);\n\n        // Compare the vectors and count the number of differences\n        svbool_t neq = svcmpne(a, b);\n        changes += svcntp_b32(neq, pg);\n    }\n\n    // Handle the middle elements if the array size is odd\n    if (n % 2 != 0) {\n        for (int i = n / 2; i < n - n / 2; ++i) {\n            if (arr[i] != arr[n - i - 1]) {\n                ++changes;\n            }\n        }\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    // Calculate the number of elements to process in each iteration\n    svbool_t pg = svptrue_b32();\n    svint32_t zero = svdup_s32(0);\n\n    for (int i = 0; i < n / 2; i += svcntw()) {\n        // Load vectors from the start and end of the array\n        svint32_t a = svld1(pg, &arr[i]);\n        svint32_t b = svld1(pg, &arr[n - i - svcntw()]);\n\n        // Compare the vectors and count the number of differences\n        svbool_t neq = svcmpne(a, b);\n        changes += svcntp_b32(neq, pg);\n    }\n\n    // Handle the middle elements if the array size is odd\n    if (n % 2 != 0) {\n        for (int i = n / 2; i < n - n / 2; ++i) {\n            if (arr[i] != arr[n - i - 1]) {\n                ++changes;\n            }\n        }\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    svbool_t pg = svptrue_b32();\n    svint32_t zero = svdup_s32(0);\n\n    for (int i = 0; i < n / 2; i += svcntw()) {\n        svint32_t a = svld1(pg, &arr[i]);\n        svint32_t b = svld1(pg, &arr[n - i - 1]);\n\n        svint32_t neq = svcmpne(a, b);\n        svint32_t cnt = svcntb_h(svtbl_u8(svpgather(pg, neq), svindex_u8(zero, 1)));\n\n        changes += svaddv_i32(cnt);\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    // Calculate the number of elements to process in each iteration\n    svbool_t pg = svptrue_b32();\n    svint32_t zero = svdup_s32(0);\n\n    for (int i = 0; i < n / 2; i += svcntw()) {\n        // Load vectors from the start and end of the array\n        svint32_t vec_start = svld1(pg, &arr[i]);\n        svint32_t vec_end = svld1(pg, &arr[n - i - svcntw()]);\n\n        // Compare the vectors and count the number of differences\n        svbool_t neq = svcmpne_s32(pg, vec_start, vec_end);\n        changes += svcntp_b32(neq);\n    }\n\n    // Handle any remaining elements that were not processed in the loop\n    for (int i = n / 2; i < n - n / 2; ++i) {\n        if (arr[i] != arr[n - i - 1]) {\n            ++changes;\n        }\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    auto sum_chars = [](const std::vector<std::string> & lst) {\n        svuint64_t sum = svdup_u64(0);\n        for (const auto & str : lst) {\n            size_t len = str.size();\n            svuint64_t vec_len = svdup_u64(len);\n            sum = svadd_u64_m(svpgather_b(svptrue_b(), reinterpret_cast<const uint8_t*>(&len), svindex_u64(0, 1)), sum, vec_len);\n        }\n        uint64_t total_sum = 0;\n        svbool_t pg = svptrue_b();\n        while (svptest_any(svptrue_b(), pg)) {\n            svuint64_t tmp = svaddv_u64(pg, sum);\n            total_sum += tmp[0];\n            pg = svpfalse_b();\n        }\n        return total_sum;\n    };\n\n    uint64_t total1 = sum_chars(lst1);\n    uint64_t total2 = sum_chars(lst2);\n\n    return total1 < total2 ? lst1 : lst2;\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    size_t total_chars_lst1 = 0;\n    size_t total_chars_lst2 = 0;\n\n    // Calculate total number of characters in lst1 using SVE\n    for (const auto& str : lst1) {\n        size_t len = str.length();\n        svuint8_t pg = svptrue_b8();\n        svuint64_t sum = svdup_u64(0);\n        const char* ptr = str.c_str();\n\n        while (svptest_any(svptrue_b8(), pg)) {\n            svuint8_t vec = svld1(pg, reinterpret_cast<const uint8_t*>(ptr));\n            sum = svadd_u64_m(pg, sum, svcntb_u8(vec));\n            ptr += svcntb();\n            pg = svwhilelt_b8(ptr - str.c_str(), len);\n        }\n\n        total_chars_lst1 += sum[0];\n    }\n\n    // Calculate total number of characters in lst2 using SVE\n    for (const auto& str : lst2) {\n        size_t len = str.length();\n        svuint8_t pg = svptrue_b8();\n        svuint64_t sum = svdup_u64(0);\n        const char* ptr = str.c_str();\n\n        while (svptest_any(svptrue_b8(), pg)) {\n            svuint8_t vec = svld1(pg, reinterpret_cast<const uint8_t*>(ptr));\n            sum = svadd_u64_m(pg, sum, svcntb_u8(vec));\n            ptr += svcntb();\n            pg = svwhilelt_b8(ptr - str.c_str(), len);\n        }\n\n        total_chars_lst2 += sum[0];\n    }\n\n    // Compare total characters and return the appropriate vector\n    if (total_chars_lst1 < total_chars_lst2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    auto sum_chars = [](const std::vector<std::string> & lst) {\n        svuint64_t sum = svdup_u64(0);\n        for (const auto & str : lst) {\n            size_t len = str.size();\n            svuint64_t vec_len = svdup_u64(len);\n            sum = svadd_u64_m(svpgather_b(svptrue_b(), reinterpret_cast<const uint8_t*>(&len), svindex_u64(0, 1)), sum, vec_len);\n        }\n        uint64_t total_sum = 0;\n        svbool_t pg = svptrue_b();\n        while (svptest_any(svptrue_b(), pg)) {\n            svuint64_t tmp = svaddv_u64(pg, sum);\n            total_sum += tmp[0];\n            pg = svpfalse_b();\n        }\n        return total_sum;\n    };\n\n    uint64_t total1 = sum_chars(lst1);\n    uint64_t total2 = sum_chars(lst2);\n\n    return total1 < total2 ? lst1 : lst2;\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    size_t total_chars_lst1 = 0;\n    size_t total_chars_lst2 = 0;\n\n    // Calculate total number of characters in lst1 using SVE\n    for (const auto& str : lst1) {\n        size_t len = str.length();\n        svuint8_t pg = svptrue_b8();\n        svuint64_t sum = svdup_u64(0);\n        const char* ptr = str.c_str();\n\n        while (svptest_any(svptrue_b8(), pg)) {\n            svuint8_t vec = svld1(pg, reinterpret_cast<const uint8_t*>(ptr));\n            svuint64_t cnt = svcntb(pg, vec);\n            sum = svadd_u64_m(svptrue_b8(), sum, cnt);\n            ptr += svcntb(svptrue_b8(), svundef_u8());\n            pg = svwhilelt_b8(ptr - str.c_str(), len);\n        }\n\n        total_chars_lst1 += svaddv_u64(sum);\n    }\n\n    // Calculate total number of characters in lst2 using SVE\n    for (const auto& str : lst2) {\n        size_t len = str.length();\n        svuint8_t pg = svptrue_b8();\n        svuint64_t sum = svdup_u64(0);\n        const char* ptr = str.c_str();\n\n        while (svptest_any(svptrue_b8(), pg)) {\n            svuint8_t vec = svld1(pg, reinterpret_cast<const uint8_t*>(ptr));\n            svuint64_t cnt = svcntb(pg, vec);\n            sum = svadd_u64_m(svptrue_b8(), sum, cnt);\n            ptr += svcntb(svptrue_b8(), svundef_u8());\n            pg = svwhilelt_b8(ptr - str.c_str(), len);\n        }\n\n        total_chars_lst2 += svaddv_u64(sum);\n    }\n\n    return total_chars_lst1 < total_chars_lst2 ? lst1 : lst2;\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    size_t total_chars_lst1 = 0;\n    size_t total_chars_lst2 = 0;\n\n    // Calculate total number of characters in lst1 using SVE\n    for (const auto& str : lst1) {\n        size_t len = str.size();\n        svuint8_t pg = svptrue_b8();\n        svuint64_t sum = svdup_u64(0);\n        const char* ptr = str.c_str();\n\n        while (svptest_any(svptrue_b8(), pg)) {\n            svuint8_t vec = svld1(pg, reinterpret_cast<const uint8_t*>(ptr));\n            sum = svadd_u64_m(pg, sum, svcntb_u8(vec));\n            ptr += svcntb();\n            pg = svwhilelt_b8(ptr - str.c_str(), len);\n        }\n\n        total_chars_lst1 += sum[0];\n    }\n\n    // Calculate total number of characters in lst2 using SVE\n    for (const auto& str : lst2) {\n        size_t len = str.size();\n        svuint8_t pg = svptrue_b8();\n        svuint64_t sum = svdup_u64(0);\n        const char* ptr = str.c_str();\n\n        while (svptest_any(svptrue_b8(), pg)) {\n            svuint8_t vec = svld1(pg, reinterpret_cast<const uint8_t*>(ptr));\n            sum = svadd_u64_m(pg, sum, svcntb_u8(vec));\n            ptr += svcntb();\n            pg = svwhilelt_b8(ptr - str.c_str(), len);\n        }\n\n        total_chars_lst2 += sum[0];\n    }\n\n    return total_chars_lst1 < total_chars_lst2 ? lst1 : lst2;\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    svuint64_t vec_x = svdup_u64(x);\n    svuint64_t vec_n = svdup_u64(n);\n    svuint64_t vec_one = svdup_u64(1);\n    svuint64_t vec_zero = svdup_u64(0);\n    svuint64_t vec_pow = svdup_u64(1);\n    svbool_t pg = svptrue_b64();\n\n    if (x == 1) return true;\n    if (n <= 1) return false;\n\n    while (svptest_any(svcmpne(svand(pg, svcmpne(vec_pow, vec_x)), vec_zero))) {\n        vec_pow = svmul_u64_z(pg, vec_pow, vec_n);\n        if (svcmpeq(svand(pg, svcmpgt(vec_pow, vec_x)), vec_one)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n == 0 || (n == 1 && x != 1)) {\n        return false;\n    }\n\n    svuint64_t vec_x = svdup_u64(x);\n    svuint64_t vec_n = svdup_u64(n);\n    svuint64_t vec_one = svdup_u64(1);\n    svuint64_t vec_pow = svdup_u64(1);\n\n    while (svptest_any(svcmpne(svand(vec_pow, vec_x), vec_x))) {\n        vec_pow = svmul_u64_z(svptrue_b64(), vec_pow, vec_n);\n        if (svcmpeq(svand(vec_pow, vec_x), vec_x)) {\n            return true;\n        }\n        if (vec_pow > vec_x) {\n            return false;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n == 0 || (n == 1 && x != 1)) {\n        return false;\n    }\n    if (x == 1) {\n        return true;\n    }\n\n    svuint64_t vec_x = svdup_u64(x);\n    svuint64_t vec_n = svdup_u64(n);\n    svuint64_t vec_one = svdup_u64(1);\n    svuint64_t vec_pow = svdup_u64(1);\n\n    svbool_t pg = svptrue_b64();\n    do {\n        vec_pow = svmul_u64_z(pg, vec_pow, vec_n);\n        svbool_t cmp = sveor_b_z(pg, svecmpeq_u64(pg, vec_pow, vec_x), svecmplt_u64(pg, vec_pow, vec_x));\n        if (svptest_any(svptrue_b64(), cmp)) {\n            return false;\n        }\n        pg = svecmpne_u64(pg, vec_pow, vec_x);\n    } while (svptest_any(svptrue_b64(), pg));\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n == 0 || (n == 1 && x != 1)) {\n        return false;\n    }\n    if (x == 1) {\n        return true;\n    }\n\n    svuint64_t vec_x = svdup_u64(x);\n    svuint64_t vec_n = svdup_u64(n);\n    svuint64_t vec_one = svdup_u64(1);\n    svuint64_t vec_pow = svdup_u64(1);\n\n    while (svptest_any(svcmpne(svand(vec_pow, vec_x), vec_x))) {\n        vec_pow = svmul_u64_z(svptrue_b64(), vec_pow, vec_n);\n        if (svcmpeq(svand(vec_pow, vec_x), vec_x)) {\n            return true;\n        }\n        if (vec_pow > vec_x) {\n            return false;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```c\n#include <arm_sve.h> \n\nbool is_simple_power_simd(uint64_t x, uint64_t n){\n    svuint64_t vec_x = svdup_u64(x);\n    svuint64_t vec_n = svdup_u64(n);\n    svuint64_t vec_one = svdup_u64(1);\n    svuint64_t vec_zero = svdup_u64(0);\n    svuint64_t vec_pow = svdup_u64(1);\n    svbool_t pg = svptrue_b64();\n\n    if (x == 1) {\n        return true;\n    }\n    if (n <= 1) {\n        return false;\n    }\n\n    while (svptest_any(svcmpne(svand(pg, svcmpne(vec_pow, vec_x)), vec_zero))) {\n        vec_pow = svmul_u64_z(pg, vec_pow, vec_n);\n        if (svcmpeq(svand(pg, svcmpgt(vec_pow, vec_x)), vec_zero)) {\n            break;\n        }\n    }\n\n    return svcmpeq(svand(pg, svcmpne(vec_pow, vec_x)), vec_zero);\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n\nint hex_key_simd(const std::string & num){\n    int count = 0;\n    const char *str = num.c_str();\n    size_t len = num.length();\n\n    // Prime hex digits: 2, 3, 5, 7, B(11), D(13)\n    uint8_t primes[] = {0x32, 0x33, 0x35, 0x37, 0x42, 0x44}; // ASCII values of '2', '3', '5', '7', 'B', 'D'\n\n    while (len > 0) {\n        svbool_t pg = svwhilelt_b8(0, len);\n        svuint8_t vec = svld1(pg, (const uint8_t *)str);\n\n        svbool_t is_prime = svcmpeq_n_u8_z(pg, vec, primes[0]);\n        for (int i = 1; i < 6; ++i) {\n            is_prime = svorr_z(pg, is_prime, svcmpeq_n_u8_z(pg, vec, primes[i]));\n        }\n\n        count += svcntp_b8(is_prime);\n\n        str += svcntb();\n        len -= svcntb();\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n\nint hex_key_simd(const std::string & num){\n    int count = 0;\n    const char *str = num.c_str();\n    size_t len = num.length();\n\n    while (len > 0) {\n        svbool_t pg = svwhilelt_b8(0, len);\n        svuint8_t vec = svld1(pg, (const uint8_t *)str);\n\n        // Create vectors for prime hex digits\n        svuint8_t prime_hex_digits = svdup_u8(0);\n        prime_hex_digits = svset_u8(prime_hex_digits, 2, 1);\n        prime_hex_digits = svset_u8(prime_hex_digits, 3, 1);\n        prime_hex_digits = svset_u8(prime_hex_digits, 5, 1);\n        prime_hex_digits = svset_u8(prime_hex_digits, 7, 1);\n        prime_hex_digits = svset_u8(prime_hex_digits, 'B', 1);\n        prime_hex_digits = svset_u8(prime_hex_digits, 'D', 1);\n\n        // Check if each element in vec is a prime hex digit\n        svbool_t is_prime = svcmpeq(svlookup_u8(pg, prime_hex_digits, vec), svdup_u8(1));\n\n        // Count the number of true values in is_prime\n        count += svcntp_b8(is_prime);\n\n        str += svcntb();\n        len -= svcntb();\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    int count = 0;\n    const char *str = num.c_str();\n    size_t len = num.length();\n\n    // Prime hex digits: 2, 3, 5, 7, B(11), D(13)\n    uint8_t prime_hex_digits[16] = {0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0};\n\n    while (len > 0) {\n        svbool_t pg = svwhilelt_b8(0, len);\n        svuint8_t vec = svld1(pg, reinterpret_cast<const uint8_t*>(str));\n\n        // Convert hex characters to values 0-15\n        vec = svsub_u8_z(pg, vec, svdup_u8('0'));\n        svuint8_t mask = svcmpgt_u8_z(pg, vec, svdup_u8('9'));\n        vec = svadd_u8_z(mask, vec, svdup_u8('A' - '0' - 10));\n\n        // Check if each value is a prime hex digit\n        svuint8_t indices = svld1(pg, prime_hex_digits);\n        svbool_t is_prime = svcmpeq_u8(pg, indices, svdup_u8(1));\n\n        // Count true values\n        count += svcntp_b_z(pg, is_prime);\n\n        str += svcntb();\n        len -= svcntb();\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    int count = 0;\n    const char *str = num.c_str();\n    size_t len = num.length();\n\n    while (len > 0) {\n        svbool_t pg = svwhilelt_b8(0, len);\n        svuint8_t vec = svld1(pg, reinterpret_cast<const uint8_t*>(str));\n\n        // Create vectors for prime hex digits\n        svuint8_t prime_hex_digits = svdup_u8(0);\n        prime_hex_digits = svorr_u8_z(pg, prime_hex_digits, svcvt_u8_u32_z(pg, svcmpeq_n_u32_z(svreinterpret_u32_u8(pg, vec), '2')));\n        prime_hex_digits = svorr_u8_z(pg, prime_hex_digits, svcvt_u8_u32_z(pg, svcmpeq_n_u32_z(svreinterpret_u32_u8(pg, vec), '3')));\n        prime_hex_digits = svorr_u8_z(pg, prime_hex_digits, svcvt_u8_u32_z(pg, svcmpeq_n_u32_z(svreinterpret_u32_u8(pg, vec), '5')));\n        prime_hex_digits = svorr_u8_z(pg, prime_hex_digits, svcvt_u8_u32_z(pg, svcmpeq_n_u32_z(svreinterpret_u32_u8(pg, vec), '7')));\n        prime_hex_digits = svorr_u8_z(pg, prime_hex_digits, svcvt_u8_u32_z(pg, svcmpeq_n_u32_z(svreinterpret_u32_u8(pg, vec), 'B')));\n        prime_hex_digits = svorr_u8_z(pg, prime_hex_digits, svcvt_u8_u32_z(pg, svcmpeq_n_u32_z(svreinterpret_u32_u8(pg, vec), 'D')));\n\n        // Count the number of true values in the mask\n        count += svcntp_b_z(pg, prime_hex_digits);\n\n        str += svcntb();\n        len -= svcntb();\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    int count = 0;\n    const char *str = num.c_str();\n    size_t len = num.length();\n\n    // Prime hex digits: 2, 3, 5, 7, B(11), D(13)\n    uint8_t primes[] = {0x32, 0x33, 0x35, 0x37, 0x42, 0x44}; // ASCII values\n\n    while (len > 0) {\n        svbool_t pg = svwhilelt_b8(0, len);\n        svuint8_t vec = svld1(pg, (const uint8_t *)str);\n\n        svbool_t is_prime = svcmpeq_n_u8_z(pg, vec, primes[0]);\n        for (int i = 1; i < 6; ++i) {\n            is_prime = svorr_z(pg, is_prime, svcmpeq_n_u8_z(pg, vec, primes[i]));\n        }\n\n        count += svcntp_b8(is_prime);\n\n        str += svcntb();\n        len -= svcntb();\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s) {\n    size_t n = s.size();\n    if (n < 3) return false;\n\n    const char *str = s.data();\n    svbool_t pg = svptrue_b8();\n\n    for (size_t i = 0; i <= n - 3; i += svcntb()) {\n        svuint8_t v1 = svld1(pg, reinterpret_cast<const uint8_t*>(str + i));\n        svuint8_t v2 = svld1(pg, reinterpret_cast<const uint8_t*>(str + i + 1));\n        svuint8_t v3 = svld1(pg, reinterpret_cast<const uint8_t*>(str + i + 2));\n\n        svbool_t cmp1 = svcmpeq(svuzp1(v1, v2));\n        svbool_t cmp2 = svcmpeq(svuzp1(v2, v3));\n        svbool_t cmp3 = svcmpeq(svuzp1(v1, v3));\n\n        svbool_t result = svorr(svorr(cmp1, cmp2), cmp3);\n        if (svptest_any(svptrue_b8(), result)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s) {\n    size_t len = s.length();\n    if (len < 3) {\n        return false;\n    }\n\n    const char *str = s.c_str();\n    svbool_t pg = svptrue_b8();\n\n    for (size_t i = 0; i <= len - 3; i += svcntb()) {\n        svuint8_t vec1 = svld1(pg, reinterpret_cast<const uint8_t*>(str + i));\n        svuint8_t vec2 = svld1(pg, reinterpret_cast<const uint8_t*>(str + i + 1));\n        svuint8_t vec3 = svld1(pg, reinterpret_cast<const uint8_t*>(str + i + 2));\n\n        svbool_t cmp1 = svcmpeq(svuzp1_b8(vec1, vec2));\n        svbool_t cmp2 = svcmpeq(svuzp1_b8(vec2, vec3));\n        svbool_t cmp3 = svcmpeq(svuzp1_b8(vec1, vec3));\n\n        svbool_t result = svorr_z(pg, cmp1, svorr_z(pg, cmp2, cmp3));\n        if (svptest_any(svptrue_b8(), result)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s) {\n    size_t len = s.length();\n    if (len < 3) {\n        return false;\n    }\n\n    const char *str = s.c_str();\n    svbool_t pg = svptrue_b8();\n\n    for (size_t i = 0; i <= len - 3; i += svcntb()) {\n        svuint8_t vec1 = svld1(pg, reinterpret_cast<const uint8_t*>(str + i));\n        svuint8_t vec2 = svld1(pg, reinterpret_cast<const uint8_t*>(str + i + 1));\n        svuint8_t vec3 = svld1(pg, reinterpret_cast<const uint8_t*>(str + i + 2));\n\n        svbool_t cmp1 = svcmpeq(svcmpne(svcmpeq(vec1, vec2), pg), vec1, vec3);\n        if (svptest_any(cmp1)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s) {\n    size_t len = s.length();\n    if (len < 3) {\n        return false;\n    }\n\n    const char *str = s.c_str();\n    svbool_t pg = svptrue_b8();\n\n    for (size_t i = 0; i <= len - 3; i += svcntb()) {\n        svuint8_t v1 = svld1(pg, reinterpret_cast<const uint8_t*>(str + i));\n        svuint8_t v2 = svld1(pg, reinterpret_cast<const uint8_t*>(str + i + 1));\n        svuint8_t v3 = svld1(pg, reinterpret_cast<const uint8_t*>(str + i + 2));\n\n        svbool_t cmp1 = svcmpeq(svcmpne(v1, v2), v3);\n        if (svptest_any(cmp1)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s) {\n    size_t n = s.size();\n    if (n < 3) return false;\n\n    const char *str = s.data();\n    svbool_t pg = svptrue_b8();\n\n    for (size_t i = 0; i <= n - 3; i += svcntb()) {\n        svuint8_t v1 = svld1(pg, reinterpret_cast<const uint8_t*>(str + i));\n        svuint8_t v2 = svld1(pg, reinterpret_cast<const uint8_t*>(str + i + 1));\n        svuint8_t v3 = svld1(pg, reinterpret_cast<const uint8_t*>(str + i + 2));\n\n        svbool_t cmp1 = svcmpeq(svuzp1(v1, v2));\n        svbool_t cmp2 = svcmpeq(svuzp1(v2, v3));\n        svbool_t cmp3 = svcmpeq(svuzp1(v1, v3));\n\n        svbool_t result = svorr(svorr(cmp1, cmp2), cmp3);\n        if (svptest_any(svptrue_b8(), result)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <cmath>\n\nbool prime_length_simd(const std::string & str) {\n    size_t length = str.length();\n    if (length < 2) return false;\n\n    svbool_t pg = svptrue_b8();\n    svuint8_t vlength = svdup_u8(length);\n    svuint8_t vzero = svdup_u8(0);\n    svuint8_t vone = svdup_u8(1);\n    svuint8_t vtwo = svdup_u8(2);\n\n    // Check divisibility from 2 to sqrt(length)\n    uint8_t limit = static_cast<uint8_t>(std::sqrt(length)) + 1;\n    for (uint8_t i = 2; i < limit; ++i) {\n        svuint8_t vi = svdup_u8(i);\n        svuint8_t vmod = svmod_u8_z(pg, vlength, vi);\n        if (svptest_any(svptrue_b8(), svcmpeq_u8_z(pg, vmod, vzero))) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cmath>\n#include <string>\n\nbool prime_length_simd(const std::string & str) {\n    size_t length = str.length();\n    if (length < 2) return false;\n\n    svbool_t pg = svptrue_b8();\n    svuint8_t v_length = svdup_u8(length);\n    svuint8_t v_two = svdup_u8(2);\n    svuint8_t v_sqrt_length = svdup_u8(static_cast<uint8_t>(std::sqrt(length)));\n\n    svbool_t is_divisible = svwhilelt_b8(pg, v_two, v_sqrt_length);\n    while (svptest_any(is_divisible)) {\n        svuint8_t v_zero = svdup_u8(0);\n        svuint8_t v_mod = svmod_u8_m(is_divisible, v_length, v_two);\n        is_divisible = svcmpeq_u8_m(is_divisible, v_mod, v_zero);\n        v_two = svadd_u8_m(is_divisible, v_two, svdup_u8(1));\n    }\n\n    return !svptest_any(svcmpeq_u8(pg, v_length, svdup_u8(1)));\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cmath>\n#include <string>\n\nbool prime_length_simd(const std::string & str) {\n    size_t length = str.length();\n    if (length < 2) return false;\n\n    svbool_t pg = svptrue_b8();\n    svuint8_t vlength = svdup_u8(length);\n    svuint8_t vzero = svdup_u8(0);\n    svuint8_t vone = svdup_u8(1);\n    svuint8_t vtwo = svdup_u8(2);\n\n    // Check divisibility by 2\n    svbool_t is_divisible_by_2 = svcmpeq_u8(pg, svand_u8_z(pg, vlength, vone), vzero);\n    if (svptest_any(svnot_b_z(pg, is_divisible_by_2))) {\n        if (length == 2) return true;\n        return false;\n    }\n\n    // Check divisibility from 3 to sqrt(length)\n    uint8_t limit = static_cast<uint8_t>(std::sqrt(length)) + 1;\n    for (uint8_t i = 3; i < limit; i += 2) {\n        svuint8_t vi = svdup_u8(i);\n        svbool_t is_divisible = svcmpeq_u8(pg, svmod_u8_z(pg, vlength, vi), vzero);\n        if (svptest_any(is_divisible)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cmath>\n#include <string>\n\nbool prime_length_simd(const std::string & str) {\n    size_t length = str.length();\n    if (length < 2) return false;\n\n    svbool_t pg = svptrue_b8();\n    svuint8_t v_length = svdup_u8(length);\n    svuint8_t v_two = svdup_u8(2);\n    svuint8_t v_sqrt_length = svdup_u8(static_cast<uint8_t>(std::sqrt(length)));\n\n    for (uint8_t i = 2; i <= v_sqrt_length[0]; ++i) {\n        svuint8_t v_i = svdup_u8(i);\n        svbool_t is_divisible = svcmpeq_u8(pg, svumul_u8_z(pg, v_i, svdiv_u8_z(pg, v_length, v_i)), v_length);\n        if (svptest_any(svptrue_b8(), is_divisible)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cmath>\n#include <string>\n\nbool prime_length_simd(const std::string & str) {\n    size_t length = str.length();\n    if (length < 2) return false;\n\n    svbool_t pg = svptrue_b8();\n    svuint8_t v_length = svdup_u8(length);\n    svuint8_t v_two = svdup_u8(2);\n    svuint8_t v_sqrt_length = svdup_u8(static_cast<uint8_t>(std::sqrt(length)));\n\n    // Check divisibility from 2 to sqrt(length)\n    for (uint8_t i = 2; i <= std::sqrt(length); ++i) {\n        svuint8_t v_i = svdup_u8(i);\n        svbool_t is_divisible = svcmpeq_u8(pg, svand_u8_z(pg, svmod_u8_z(pg, v_length, v_i), svdup_u8(0)), svdup_u8(0));\n        if (svptest_any(is_divisible)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string solve_simd(uint64_t N) {\n    uint64_t sum = 0;\n    while (N > 0) {\n        uint64_t digit_sum = 0;\n        svuint64_t vec_n = svdup_u64(N);\n        svuint64_t vec_mask = svdup_u64(0xFF);\n        svuint64_t vec_zero = svdup_u64(0);\n\n        // Process 8 bytes at a time\n        while (svany(svcmpne(svand(vec_n, vec_mask), vec_zero))) {\n            svuint64_t vec_digits = svand(vec_n, vec_mask);\n            svuint64_t vec_ones = svcntb_u8(svcmpeq_u8(svreinterpret_u8_u64(vec_digits), svdup_u8(1)));\n            digit_sum += svcadd_u64_z(svptrue_b64(), vec_ones);\n            vec_n = svlsr_n_u64(vec_n, 8);\n        }\n\n        sum += digit_sum;\n        N >>= 8;\n    }\n\n    std::string binary = \"\";\n    if (sum == 0) return \"0\";\n    while (sum > 0) {\n        binary = (sum % 2 == 0 ? \"0\" : \"1\") + binary;\n        sum /= 2;\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string solve_simd(uint64_t N) {\n    uint64_t sum = 0;\n    while (N > 0) {\n        uint64_t digit_sum = 0;\n        svuint64_t vec_n = svdup_u64(N);\n        svuint64_t vec_mask = svdup_u64(0xFF);\n        svuint64_t vec_zero = svdup_u64(0);\n\n        // Process 8 bytes at a time\n        while (svany(svcmpne(svand(vec_n, vec_mask), vec_zero))) {\n            svuint64_t vec_digits = svand(vec_n, vec_mask);\n            svuint64_t vec_ones = svcntb_u8(svcmpeq_u8_z(svptrue_b8(), svreinterpret_u8_u64(vec_digits), svdup_u8(1)));\n            digit_sum += svcadd_u64(svptrue_b64(), vec_ones);\n            vec_n = svlsr_n_u64_z(svptrue_b64(), vec_n, 8);\n        }\n\n        sum += digit_sum;\n        N /= 256;\n    }\n\n    std::string binary_sum = \"\";\n    if (sum == 0) return \"0\";\n    while (sum > 0) {\n        binary_sum = (sum % 2 == 0 ? \"0\" : \"1\") + binary_sum;\n        sum /= 2;\n    }\n    return binary_sum;\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string solve_simd(uint64_t N) {\n    uint64_t sum = 0;\n    while (N > 0) {\n        uint64_t digit_sum = 0;\n        svuint64_t vec_n = svdup_u64(N);\n        svuint64_t vec_ones = svdup_u64(1);\n        svbool_t pg = svptrue_b64();\n\n        // Sum bits in parallel\n        while (svany(svcmpne(pg, vec_n, svdup_u64(0)))) {\n            svuint64_t vec_parity = svand_z(pg, vec_n, vec_ones);\n            digit_sum += svcntp_b64(svptest_any(pg, vec_parity));\n            vec_n = svlsr_z(pg, vec_n, svdup_u64(1));\n        }\n\n        sum += digit_sum;\n        N /= 10;\n    }\n\n    // Convert sum to binary string\n    std::string binary = \"\";\n    if (sum == 0) return \"0\";\n    while (sum > 0) {\n        binary = (sum % 2 == 0 ? \"0\" : \"1\") + binary;\n        sum /= 2;\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string solve_simd(uint64_t N) {\n    uint64_t sum = 0;\n    while (N > 0) {\n        uint64_t digit_sum = 0;\n        svuint64_t vec_n = svdup_u64(N);\n        svuint64_t vec_mask = svdup_u64(0xFF);\n        svuint64_t vec_zero = svdup_u64(0);\n\n        // Process 8 bytes at a time\n        while (svany(svcmpne(svand(vec_n, vec_mask), vec_zero))) {\n            svuint64_t vec_digits = svand(vec_n, vec_mask);\n            svuint64_t vec_ones = svcntb_u8(svreinterpret_u8_u64(vec_digits));\n            digit_sum += svcadd_u64(vec_ones, vec_zero);\n            vec_n = svlsr_n_u64(vec_n, 8);\n        }\n\n        sum += digit_sum;\n        N /= 256;\n    }\n\n    std::string binary = \"\";\n    if (sum == 0) return \"0\";\n    while (sum > 0) {\n        binary = (sum % 2 == 0 ? \"0\" : \"1\") + binary;\n        sum /= 2;\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string solve_simd(uint64_t N) {\n    uint64_t sum = 0;\n    while (N > 0) {\n        uint64_t digit_sum = 0;\n        svuint64_t vec_n = svdup_u64(N);\n        svuint64_t vec_ones = svdup_u64(1);\n        svbool_t pg = svptrue_b64();\n\n        // Sum the bits of N in parallel\n        while (svany(svcmpne(pg, vec_n, svdup_u64(0)))) {\n            svuint64_t vec_bits = sveor_z(pg, svand_z(pg, vec_n, vec_ones), svlsr_z(pg, vec_n, svdup_u64(1)));\n            digit_sum += svcntp_b64(svcmpne(pg, vec_bits, svdup_u64(0)));\n            vec_n = svlsr_z(pg, vec_n, svdup_u64(1));\n        }\n\n        sum += digit_sum;\n        N /= 10;\n    }\n\n    // Convert sum to binary string\n    std::string binary = \"\";\n    if (sum == 0) return \"0\";\n    while (sum > 0) {\n        binary = (sum % 2 == 0 ? \"0\" : \"1\") + binary;\n        sum /= 2;\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int sum = 0;\n    svbool_t pg;\n    svint32_t vsum = svdup_s32(0);\n    size_t index = 1; // Start from the first odd index\n\n    while (svptest_any(svptrue_b32(), pg = svwhilelt_b32(index, lst.size()))) {\n        svint32_t vlst = svld1_s32(pg, lst.data() + index);\n        svbool_t peven = sveven_s32(vlst);\n        vsum = svadd_m_n(svptrue_b32(), vsum, vlst, peven);\n        index += svcntw();\n    }\n\n    sum = svaddv_i32(vsum);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int sum = 0;\n    svbool_t pg;\n    svint32_t vsum = svdup_s32(0);\n    size_t index = 1; // Start from the first odd index\n\n    while (svptest_any(svptrue_b32(), pg = svwhilelt_b32(index, lst.size()))) {\n        svint32_t vlst = svld1_s32(pg, lst.data() + index);\n        svint32_t veven_mask = sveor_b32(svptrue_b32(), svcmpeq_n_s32(pg, svand_s32_z(pg, vlst, svdup_s32(1)), 0));\n        svint32_t veven_elements = svsel_s32(veven_mask, vlst, svdup_s32(0));\n        vsum = svadd_s32_m(pg, vsum, veven_elements);\n        index += svcntw();\n    }\n\n    sum = svaddv_s32(vsum);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int sum = 0;\n    svbool_t pg;\n    svint32_t vec, even_elements;\n    size_t index = 1; // Start from the first odd index\n\n    while (index < lst.size()) {\n        // Load elements starting from the current index\n        pg = svwhilelt_b32(index, lst.size());\n        vec = svld1(pg, lst.data() + index);\n\n        // Create a predicate for even elements\n        svbool_t even_pred = sveven_m_n_u32(pg, vec);\n\n        // Zero out odd elements\n        even_elements = svsel_z(pg, even_pred, vec, svdup_n_s32(0));\n\n        // Sum the even elements\n        sum += svaddv_i32(even_elements);\n\n        // Move to the next set of elements, skipping one to maintain odd indices\n        index += svcntw();\n        index++;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int sum = 0;\n    svbool_t pg;\n    svint32_t vec, even_elements;\n    size_t index = 1; // Start from the first odd index\n\n    while (index < lst.size()) {\n        // Load elements starting from the current index\n        pg = svwhilelt_b32(index, lst.size());\n        vec = svld1_s32(pg, lst.data() + index);\n\n        // Create a predicate for even elements\n        svbool_t even_pred = sveven_s32(pg, vec);\n\n        // Zero out odd elements\n        even_elements = svsel_s32(even_pred, vec, svdup_s32_z(pg, 0));\n\n        // Sum the even elements\n        sum += svaddv_s32(pg, even_elements);\n\n        // Move to the next set of elements, skipping one to maintain odd indices\n        index += svcntw();\n        index++;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int sum = 0;\n    svbool_t pg;\n    svint32_t vec, even_elements;\n    size_t index = 1; // Start from the first odd index\n\n    while (index < lst.size()) {\n        // Load elements starting from the current index\n        pg = svwhilelt_b32(index, lst.size());\n        vec = svld1_s32(pg, lst.data() + index);\n\n        // Create a predicate for even elements\n        svbool_t even_pred = sveven_s32_z(pg, vec);\n\n        // Zero out odd elements\n        even_elements = svsel_s32(even_pred, vec, svdup_s32_z(pg, 0));\n\n        // Sum the even elements\n        sum += svaddv_s32_m(svundef_s32(), even_elements, pg);\n\n        // Move to the next set of elements, skipping one to maintain odd indices\n        index += svcntw();\n        index++;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    std::string result(s.size(), ' ');\n    svbool_t pg;\n    svuint8_t vec, shifted_vec, base, wrap_around;\n\n    size_t i = 0;\n    while (i < s.size()) {\n        size_t vl = svcntb();\n        if (i + vl > s.size()) {\n            vl = s.size() - i;\n        }\n        pg = svwhilelt_b8(i, s.size());\n\n        vec = svld1(pg, reinterpret_cast<const uint8_t*>(s.data() + i));\n        base = svdup_u8('a');\n        wrap_around = svdup_u8(26);\n\n        // Shift each character by 4 positions\n        shifted_vec = svadd_z(pg, vec, svdup_u8(4));\n\n        // Wrap around if it goes past 'z'\n        shifted_vec = svsub_z(pg, shifted_vec, svand_z(pg, svcmpgt_z(pg, shifted_vec, svadd_z(pg, base, wrap_around)), wrap_around));\n\n        svst1(pg, reinterpret_cast<uint8_t*>(result.data() + i), shifted_vec);\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    std::string result(s.size(), ' ');\n    svbool_t pg;\n    svuint8_t vec, shifted_vec;\n    const int shift = 4; // 2 * 2\n\n    for (size_t i = 0; i < s.size(); i += svcntb()) {\n        size_t vl = svcntb();\n        if (i + vl > s.size()) {\n            vl = s.size() - i;\n        }\n        pg = svwhilelt_b8(i, s.size());\n        vec = svld1(pg, reinterpret_cast<const uint8_t*>(s.data() + i));\n        shifted_vec = svadd_z(pg, vec, svdup_n_u8(shift));\n        \n        // Handle wrap-around for lowercase letters\n        svbool_t overflow = svcmpgt_z(pg, shifted_vec, svdup_n_u8('z'));\n        shifted_vec = svsel_z(pg, overflow, svsub_z(pg, shifted_vec, svdup_n_u8(26)), shifted_vec);\n        \n        svst1(pg, reinterpret_cast<uint8_t*>(result.data() + i), shifted_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    std::string result(s.size(), ' ');\n    svbool_t pg;\n    svuint8_t vec, shifted_vec;\n    const int shift = 4; // 2 * 2\n\n    for (size_t i = 0; i < s.size(); i += svcntb()) {\n        size_t vl = svcntb();\n        if (i + vl > s.size()) {\n            vl = s.size() - i;\n        }\n        pg = svwhilelt_b8(i, s.size());\n        vec = svld1(pg, reinterpret_cast<const uint8_t*>(s.data() + i));\n        shifted_vec = svadd_z(pg, vec, svdup_n_u8(shift));\n        \n        // Handle wrap-around for lowercase letters\n        svbool_t overflow = svcmpgt_z(pg, shifted_vec, svdup_n_u8('z'));\n        shifted_vec = svsel_z(pg, overflow, svsub_z(pg, shifted_vec, svdup_n_u8(26)), shifted_vec);\n        \n        svst1(pg, reinterpret_cast<uint8_t*>(result.data() + i), shifted_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    std::string result(s.size(), ' ');\n    svbool_t pg;\n    svuint8_t vec, shifted_vec, base, wrap_around, mask;\n\n    size_t i = 0;\n    while (i < s.size()) {\n        size_t vl = svcntb();\n        if (i + vl > s.size()) {\n            vl = s.size() - i;\n        }\n        pg = svwhilelt_b8(i, s.size());\n\n        vec = svld1(pg, reinterpret_cast<const uint8_t*>(s.data() + i));\n        base = svdup_u8('a');\n        mask = svdup_u8('z' - 'a');\n\n        // Shift each character by 4 positions\n        shifted_vec = svadd_u8_z(pg, vec, svdup_u8(4));\n\n        // Wrap around if it goes past 'z'\n        wrap_around = svsub_u8_z(pg, shifted_vec, mask);\n        wrap_around = svadd_u8_z(pg, wrap_around, base);\n\n        // Use select to choose between shifted_vec and wrap_around\n        shifted_vec = svsel_u8(pg, svcmplt_u8(pg, shifted_vec, svdup_u8('a' + 26)), wrap_around, shifted_vec);\n\n        svst1(pg, reinterpret_cast<uint8_t*>(result.data() + i), shifted_vec);\n\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    std::string result(s.size(), ' ');\n    svbool_t pg;\n    svuint8_t vec, shifted_vec;\n    const int shift = 4; // 2 * 2\n\n    for (size_t i = 0; i < s.size(); i += svcntb()) {\n        size_t vl = svcntb();\n        if (i + vl > s.size()) {\n            vl = s.size() - i;\n        }\n        pg = svwhilelt_b8(i, s.size());\n        vec = svld1(pg, reinterpret_cast<const uint8_t*>(s.data() + i));\n        shifted_vec = svadd_z(pg, vec, svdup_n_u8(shift));\n        // Handle wrap-around for lowercase letters\n        shifted_vec = svwhere(svcmpgt_m(pg, shifted_vec, svdup_n_u8('z')), svsub_z(pg, shifted_vec, svdup_n_u8(26)), shifted_vec);\n        svst1(pg, reinterpret_cast<uint8_t*>(result.data() + i), shifted_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message) {\n    size_t len = message.length();\n    std::string result(len, ' ');\n\n    const char vowels_lower[6] = {'a', 'e', 'i', 'o', 'u', '\\0'};\n    const char vowels_upper[6] = {'A', 'E', 'I', 'O', 'U', '\\0'};\n    const char replacements_lower[6] = {'c', 'g', 'k', 'q', 'w', '\\0'};\n    const char replacements_upper[6] = {'C', 'G', 'K', 'Q', 'W', '\\0'};\n\n    svbool_t pg;\n    svuint8_t msg_vec, res_vec;\n    svuint8_t vowels_lower_vec, vowels_upper_vec, replacements_lower_vec, replacements_upper_vec;\n\n    for (size_t i = 0; i < len; i += svcntb()) {\n        size_t vl = svlen(svptrue_b8());\n        if (i + vl > len) {\n            vl = len - i;\n            pg = svwhilelt_b8(i, len);\n        } else {\n            pg = svptrue_b8();\n        }\n\n        msg_vec = svld1(pg, reinterpret_cast<const uint8_t*>(&message[i]));\n\n        // Swap case\n        res_vec = svbic_z(pg, msg_vec, svdup_u8(0x20));\n\n        // Replace vowels\n        for (int j = 0; j < 5; ++j) {\n            vowels_lower_vec = svdup_u8(vowels_lower[j]);\n            vowels_upper_vec = svdup_u8(vowels_upper[j]);\n            replacements_lower_vec = svdup_u8(replacements_lower[j]);\n            replacements_upper_vec = svdup_u8(replacements_upper[j]);\n\n            res_vec = svsel(svcmpeq_m(pg, msg_vec, vowels_lower_vec), replacements_lower_vec, res_vec);\n            res_vec = svsel(svcmpeq_m(pg, msg_vec, vowels_upper_vec), replacements_upper_vec, res_vec);\n        }\n\n        svst1(pg, reinterpret_cast<uint8_t*>(&result[i]), res_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message) {\n    size_t len = message.length();\n    std::string result(len, ' ');\n\n    const char vowels_lower[6] = {'a', 'e', 'i', 'o', 'u', '\\0'};\n    const char vowels_upper[6] = {'A', 'E', 'I', 'O', 'U', '\\0'};\n    const char replacements_lower[6] = {'c', 'g', 'k', 'q', 'w', '\\0'};\n    const char replacements_upper[6] = {'C', 'G', 'K', 'Q', 'W', '\\0'};\n\n    svbool_t pg;\n    svuint8_t msg_vec, res_vec, vowels_lower_vec, vowels_upper_vec, replacements_lower_vec, replacements_upper_vec;\n\n    for (size_t i = 0; i < len; i += svcntb()) {\n        size_t vl = svcntb() < (len - i) ? svcntb() : (len - i);\n        pg = svptrue_b8();\n\n        msg_vec = svld1(pg, reinterpret_cast<const uint8_t*>(&message[i]));\n\n        // Swap case\n        res_vec = svbic_z(pg, msg_vec, svdup_u8(0x20));\n\n        // Replace vowels\n        for (int j = 0; j < 5; ++j) {\n            vowels_lower_vec = svdup_u8(vowels_lower[j]);\n            vowels_upper_vec = svdup_u8(vowels_upper[j]);\n            replacements_lower_vec = svdup_u8(replacements_lower[j]);\n            replacements_upper_vec = svdup_u8(replacements_upper[j]);\n\n            pg = sveor_b8(sveor_b8(svcmpeq_b8(svcmpeq_b8(msg_vec, vowels_lower_vec), vowels_lower_vec),\n                                   svcmpeq_b8(svcmpeq_b8(msg_vec, vowels_upper_vec), vowels_upper_vec)), pg);\n\n            res_vec = svsel_b8(pg, res_vec, svsel_b8(svcmpeq_b8(msg_vec, vowels_lower_vec), replacements_lower_vec, replacements_upper_vec));\n        }\n\n        svst1(pg, reinterpret_cast<uint8_t*>(&result[i]), res_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message) {\n    size_t len = message.length();\n    std::string result(len, ' ');\n\n    const char vowels_lower[] = \"aeiou\";\n    const char vowels_upper[] = \"AEIOU\";\n    const char replacements_lower[] = \"cgikm\";\n    const char replacements_upper[] = \"CGIKM\";\n\n    svbool_t pg;\n    svuint8_t msg_vec, result_vec;\n    svuint8_t vowels_lower_vec, vowels_upper_vec, replacements_lower_vec, replacements_upper_vec;\n\n    for (size_t i = 0; i < len; i += svcntb()) {\n        size_t vl = svlen(svptrue_b8());\n        if (i + vl > len) {\n            vl = len - i;\n            pg = svwhilelt_b8(i, len);\n        } else {\n            pg = svptrue_b8();\n        }\n\n        msg_vec = svld1(pg, reinterpret_cast<const uint8_t*>(&message[i]));\n\n        // Swap case\n        result_vec = svsel_b8(svand_b8(svtst_b8(msg_vec, svdup_u8(0x20)), pg), svsub_u8(msg_vec, svdup_u8(0x20)), svadd_u8(msg_vec, svdup_u8(0x20)));\n\n        // Replace vowels\n        for (int j = 0; j < 5; ++j) {\n            vowels_lower_vec = svdup_u8(vowels_lower[j]);\n            vowels_upper_vec = svdup_u8(vowels_upper[j]);\n            replacements_lower_vec = svdup_u8(replacements_lower[j]);\n            replacements_upper_vec = svdup_u8(replacements_upper[j]);\n\n            result_vec = svsel_b8(svcmpeq_b8(msg_vec, vowels_lower_vec, pg), replacements_lower_vec, result_vec);\n            result_vec = svsel_b8(svcmpeq_b8(msg_vec, vowels_upper_vec, pg), replacements_upper_vec, result_vec);\n        }\n\n        svst1(pg, reinterpret_cast<uint8_t*>(&result[i]), result_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message) {\n    size_t len = message.length();\n    std::string result(len, ' ');\n\n    const char vowels_lower[] = \"aeiou\";\n    const char vowels_upper[] = \"AEIOU\";\n    const char replacements_lower[] = \"cgikm\";\n    const char replacements_upper[] = \"CGIKM\";\n\n    svbool_t pg = svptrue_b8();\n    size_t i = 0;\n\n    while (i < len) {\n        svuint8_t vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(message.data() + i));\n\n        // Swap case\n        svuint8_t is_lower = svcmpgt(svand_x(pg, vec, svdup_u8(0x60)), svdup_u8(0x5a));\n        svuint8_t swapped_case = sveor_x(pg, vec, svdup_u8(0x20));\n\n        // Replace vowels\n        for (int j = 0; j < 5; ++j) {\n            svbool_t is_vowel_lower = sveq(svand_x(pg, swapped_case, svdup_u8(0xdf)), svdup_u8(vowels_lower[j]));\n            svbool_t is_vowel_upper = sveq(swapped_case, svdup_u8(vowels_upper[j]));\n            swapped_case = svsel(svorr(is_vowel_lower, is_vowel_upper), svsel(is_vowel_lower, svdup_u8(replacements_lower[j]), svdup_u8(replacements_upper[j])), swapped_case);\n        }\n\n        svst1_u8(pg, reinterpret_cast<uint8_t*>(result.data() + i), swapped_case);\n\n        i += svcntb();\n        pg = svwhilelt_b8(i, len);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message) {\n    size_t len = message.length();\n    std::string result(len, ' ');\n\n    const char vowels_lower[6] = {'a', 'e', 'i', 'o', 'u', '\\0'};\n    const char vowels_upper[6] = {'A', 'E', 'I', 'O', 'U', '\\0'};\n    const char replacements_lower[6] = {'c', 'g', 'k', 'q', 'w', '\\0'};\n    const char replacements_upper[6] = {'C', 'G', 'K', 'Q', 'W', '\\0'};\n\n    svbool_t pg;\n    svuint8_t msg_vec, result_vec, vowels_lower_vec, vowels_upper_vec, replacements_lower_vec, replacements_upper_vec;\n\n    for (size_t i = 0; i < len; i += svcntb()) {\n        size_t vl = svlen(svptrue_b8());\n        if (i + vl > len) {\n            vl = len - i;\n            pg = svwhilelt_b8(i, len);\n        } else {\n            pg = svptrue_b8();\n        }\n\n        msg_vec = svld1(pg, reinterpret_cast<const uint8_t*>(&message[i]));\n\n        // Swap case\n        result_vec = svsel_b8(svcmpgt_b8(msg_vec, svdup_u8('Z')), svsub_u8(msg_vec, svdup_u8('a' - 'A')), svadd_u8(msg_vec, svdup_u8('a' - 'A')));\n\n        // Replace vowels\n        for (int j = 0; j < 5; ++j) {\n            vowels_lower_vec = svdup_u8(vowels_lower[j]);\n            vowels_upper_vec = svdup_u8(vowels_upper[j]);\n            replacements_lower_vec = svdup_u8(replacements_lower[j]);\n            replacements_upper_vec = svdup_u8(replacements_upper[j]);\n\n            result_vec = svsel_b8(sveq_b8(msg_vec, vowels_lower_vec), replacements_lower_vec, result_vec);\n            result_vec = svsel_b8(sveq_b8(msg_vec, vowels_upper_vec), replacements_upper_vec, result_vec);\n        }\n\n        svst1(pg, reinterpret_cast<uint8_t*>(&result[i]), result_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        size_t len = key.length();\n\n        if (len == 0) {\n            continue;\n        }\n\n        const char* str = key.c_str();\n        size_t i = 0;\n\n        while (i < len) {\n            svbool_t pg = svwhilelt_b8(i, len);\n            svuint8_t vec = svld1(pg, reinterpret_cast<const uint8_t*>(str + i));\n\n            svbool_t lower = svcmplt(svand(pg, svcgt(vec, svdup_u8('a' - 1))), svdup_u8('z' + 1));\n            svbool_t upper = svcmplt(svand(pg, svcgt(vec, svdup_u8('A' - 1))), svdup_u8('Z' + 1));\n\n            if (!svptest_any(svptrue_b8(), lower)) {\n                all_lower = false;\n            }\n            if (!svptest_any(svptrue_b8(), upper)) {\n                all_upper = false;\n            }\n\n            if (!all_lower && !all_upper) {\n                return false;\n            }\n\n            i += svcntb();\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        size_t len = key.length();\n\n        if (len == 0) {\n            continue;\n        }\n\n        const char* str = key.c_str();\n        size_t i = 0;\n\n        while (i < len) {\n            svbool_t pg = svwhilelt_b8(i, len);\n            svuint8_t vec = svld1(pg, reinterpret_cast<const uint8_t*>(str + i));\n\n            svbool_t lower = svcmplt(svand(pg, svptrue_b8()), vec, svdup_u8('a'));\n            svbool_t upper = svcmpgt(svand(pg, svptrue_b8()), vec, svdup_u8('Z'));\n\n            all_lower = all_lower && svptest_any(svptrue_b8(), svandnot(lower, pg));\n            all_upper = all_upper && svptest_any(svptrue_b8(), svandnot(upper, pg));\n\n            i += svcntb();\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        size_t len = key.length();\n\n        if (len == 0) {\n            continue;\n        }\n\n        const char* str = key.c_str();\n        size_t i = 0;\n\n        while (i < len) {\n            svbool_t pg = svwhilelt_b8(i, len);\n            svuint8_t vec = svld1(pg, reinterpret_cast<const uint8_t*>(str + i));\n\n            svbool_t lower = svcmple_z(pg, vec, svdup_u8('z'));\n            svbool_t upper = svcmpge_z(pg, vec, svdup_u8('A'));\n            svbool_t alpha = svand_z(pg, lower, svcmpge_z(pg, vec, svdup_u8('A')));\n\n            all_lower = all_lower && svptest_any(svptrue_b8(), svand_z(pg, alpha, svcmpgt_z(pg, vec, svdup_u8('Z'))));\n            all_upper = all_upper && svptest_any(svptrue_b8(), svand_z(pg, alpha, svcmple_z(pg, vec, svdup_u8('Z'))));\n\n            i += svcntb();\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        size_t len = key.length();\n\n        if (len == 0) {\n            continue;\n        }\n\n        const char* str = key.c_str();\n        size_t i = 0;\n\n        while (i < len) {\n            svbool_t pg = svwhilelt_b8(i, len);\n            svuint8_t vec = svld1(pg, reinterpret_cast<const uint8_t*>(str + i));\n\n            svbool_t lower = svcmple_z(pg, vec, svdup_n_u8('z')) & svcmpge_z(pg, vec, svdup_n_u8('a'));\n            svbool_t upper = svcmple_z(pg, vec, svdup_n_u8('Z')) & svcmpge_z(pg, vec, svdup_n_u8('A'));\n\n            all_lower &= svptest_any(svptrue_b8(), lower);\n            all_upper &= svptest_any(svptrue_b8(), upper);\n\n            i += svcntb();\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        size_t len = key.length();\n\n        if (len == 0) {\n            continue;\n        }\n\n        const char* str = key.c_str();\n        size_t i = 0;\n\n        while (i < len) {\n            svbool_t pg = svwhilelt_b8(i, len);\n            svuint8_t vec = svld1(pg, reinterpret_cast<const uint8_t*>(str + i));\n\n            svbool_t lower = svcmplt(svand(pg, svcgt(vec, svdup_u8('a' - 1))), svdup_u8('z' + 1));\n            svbool_t upper = svcmplt(svand(pg, svcgt(vec, svdup_u8('A' - 1))), svdup_u8('Z' + 1));\n\n            if (!svptest_any(svptrue_b8(), lower)) {\n                all_lower = false;\n            }\n            if (!svptest_any(svptrue_b8(), upper)) {\n                all_upper = false;\n            }\n\n            if (!all_lower && !all_upper) {\n                return false;\n            }\n\n            i += svcntb();\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n\n    // Create a boolean array \"is_prime[0..n-1]\" and initialize all entries as true.\n    // A value in is_prime[i] will finally be false if i is Not a prime, else true.\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false; // 0 and 1 are not prime numbers\n\n    for (int p = 2; p * p < n; ++p) {\n        if (is_prime[p]) {\n            // Mark all multiples of p as false starting from p*p\n            int start = p * p;\n            svbool_t pg = svptrue_b32();\n            svint32_t v_p = svdup_s32(p);\n            svint32_t v_start = svdup_s32(start);\n\n            for (int i = start; i < n; i += svcntw()) {\n                svint32_t v_index = svindex_s32(v_start, 1);\n                svint32_t v_mul = svmul_s32_z(pg, v_index, v_p);\n                svbool_t v_mask = svwhilelt_b32(svptrue_b32(), i, n);\n                svst1_b_z(v_mask, is_prime.data() + i, svcmpeq_n_b32(v_mask, v_mul, 0));\n                v_start = svadd_z(pg, v_start, svdup_s32(svcntw()));\n            }\n        }\n    }\n\n    // Collecting all prime numbers\n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n\n    uint8_t* is_prime = new uint8_t[n];\n    for (int i = 0; i < n; ++i) is_prime[i] = 1;\n    is_prime[0] = is_prime[1] = 0;\n\n    for (int i = 2; i * i < n; ++i) {\n        if (is_prime[i]) {\n            svbool_t pg = svptrue_b8();\n            int j = i * i;\n            while (j < n) {\n                svuint8_t v_is_prime = svld1_u8(pg, &is_prime[j]);\n                svuint8_t v_zero = svdup_u8(0);\n                svuint8_t v_mask = svcmpeq_u8(pg, v_is_prime, v_zero);\n                svst1_u8(pg, &is_prime[j], v_mask);\n                j += i;\n                pg = svwhilelt_b8(j, n);\n            }\n        }\n    }\n\n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) primes.push_back(i);\n    }\n\n    delete[] is_prime;\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n\n    // Create a boolean array \"is_prime[0..n-1]\" and initialize all entries as true.\n    // A value in is_prime[i] will finally be false if i is Not a prime, else true.\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false; // 0 and 1 are not prime numbers\n\n    int p = 2;\n    while (p * p < n) {\n        // If is_prime[p] is not changed, then it is a prime\n        if (is_prime[p]) {\n            // Update all multiples of p to not prime\n            int start = p * p;\n            svbool_t pg = svptrue_b32();\n            svint32_t v_p = svdup_s32(p);\n            svint32_t v_start = svdup_s32(start);\n\n            for (int i = start; i < n; i += p) {\n                svint32_t v_i = svld1_s32(pg, &is_prime[i]);\n                svint32_t v_zero = svdup_s32(0);\n                svst1_b(pg, &is_prime[i], svcmpeq_s32(pg, v_i, v_zero));\n                v_start = svadd_s32_z(pg, v_start, v_p);\n            }\n        }\n        p++;\n    }\n\n    // Collecting all prime numbers\n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n\n    // Create a boolean array \"is_prime[0..n-1]\" and initialize all entries as true.\n    // A value in is_prime[i] will finally be false if i is Not a prime, else true.\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false; // 0 and 1 are not prime numbers\n\n    for (int p = 2; p * p < n; ++p) {\n        if (is_prime[p]) {\n            // Mark all multiples of p as false starting from p*p\n            int start = p * p;\n            svbool_t pg = svptrue_b32();\n            svint32_t v_p = svdup_s32(p);\n            svint32_t v_start = svdup_s32(start);\n\n            for (int i = start; i < n; i += svcntw()) {\n                svint32_t v_index = svindex_s32(v_start, 1);\n                svint32_t v_mul = svmul_s32_z(pg, v_index, v_p);\n                svbool_t v_mask = svwhilelt_b32(svptrue_b32(), i, n);\n                svbool_t v_store_mask = svand_b_z(v_mask, pg, svcmpeq_s32(pg, v_mul, v_index));\n                svst1b(svnot_b_z(v_store_mask, pg), is_prime.data() + i, svfalse_b());\n                v_start = svadd_s32_z(pg, v_start, svdup_s32(svcntw()));\n            }\n        }\n    }\n\n    // Collecting all prime numbers\n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n\n    sve_int32_t ones = svdup_s32(1);\n    sve_int32_t twos = svdup_s32(2);\n    sve_int32_t threes = svdup_s32(3);\n\n    int i = 2;\n    while (i < n) {\n        sve_int32_t indices = svindex_s32(0, 1);\n        sve_int32_t values = svadd_z(svptrue_b32(), indices, svdup_s32(i));\n        sve_bool_t is_prime = svcmpgt(svptrue_b32(), values, threes);\n\n        for (int j = 2; j * j <= i; j++) {\n            sve_int32_t divisors = svdup_s32(j);\n            sve_int32_t remainders = svmod_z(svptrue_b32(), values, divisors);\n            is_prime = svand_z(svptrue_b32(), is_prime, svcmpeq(svptrue_b32(), remainders, ones));\n        }\n\n        sve_int32_t filtered_values = svsel_z(svptrue_b32(), is_prime, values, svdup_s32(0));\n        for (int j = 0; j < svcntw(); j++) {\n            int value = svnth_u32(is_prime, filtered_values, j);\n            if (value != 0 && value < n) {\n                primes.push_back(value);\n            }\n        }\n\n        i += svcntw();\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n\nint count_upper_simd(const std::string & s){\n    int count = 0;\n    size_t len = s.length();\n    const char* str = s.c_str();\n\n    // Create a predicate for even indices\n    svbool_t pg_even = svptrue_b8();\n    for (size_t i = 0; i < len; i += svcntb()) {\n        svuint8_t vec = svld1_u8(pg_even, reinterpret_cast<const uint8_t*>(str + i));\n        svbool_t pg_upper_vowel = svcmpeq_u8(pg_even, vec, svdup_u8('A')) |\n                                 svcmpeq_u8(pg_even, vec, svdup_u8('E')) |\n                                 svcmpeq_u8(pg_even, vec, svdup_u8('I')) |\n                                 svcmpeq_u8(pg_even, vec, svdup_u8('O')) |\n                                 svcmpeq_u8(pg_even, vec, svdup_u8('U'));\n        pg_upper_vowel = svand_b8(pg_even, pg_upper_vowel, svindex_b8(svptrue_b8(), 0, 1) % 2 == 0);\n        count += svcntp_b8(svptrue_b8(), pg_upper_vowel);\n        pg_even = svptrue_b8(svwhilelt_b8(i + svcntb(), len));\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n\nint count_upper_simd(const std::string & s){\n    int count = 0;\n    size_t len = s.length();\n    const char* str = s.c_str();\n\n    // Create a predicate for even indices\n    svbool_t pg_even = svptrue_b8();\n    for (size_t i = 0; i < len; i += svcntb()) {\n        svuint8_t vec = svld1_u8(pg_even, reinterpret_cast<const uint8_t*>(str + i));\n        svbool_t pg_upper_vowel = svcmpeq_u8(pg_even, vec, svdup_u8('A')) |\n                                 svcmpeq_u8(pg_even, vec, svdup_u8('E')) |\n                                 svcmpeq_u8(pg_even, vec, svdup_u8('I')) |\n                                 svcmpeq_u8(pg_even, vec, svdup_u8('O')) |\n                                 svcmpeq_u8(pg_even, vec, svdup_u8('U'));\n        pg_upper_vowel = svand_b8(pg_even, pg_upper_vowel, svindex_b8(svptrue_b8(), 0, 1) % 2 == 0);\n        count += svcntp_b8(svptrue_b8(), pg_upper_vowel);\n        pg_even = svptrue_b8(svwhilelt_b8(i + svcntb(), len));\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint count_upper_simd(const std::string & s) {\n    int count = 0;\n    size_t len = s.length();\n    const char *str = s.c_str();\n\n    // Create a predicate for even indices\n    svbool_t pg_even = svptrue_b8();\n    for (size_t i = 0; i < len; i += svcntb()) {\n        svuint8_t vec = svld1_u8(pg_even, reinterpret_cast<const uint8_t*>(str + i));\n        svbool_t pg_upper = svcmplt(svptrue_b8(), vec, svdup_u8('A'));\n        pg_upper = svorr_b8(pg_upper, svcmpgt(svptrue_b8(), vec, svdup_u8('Z')));\n        pg_upper = svnot_b8(pg_upper);\n        pg_even = svzip1_b8(svcreate2_b8(svptrue_b8(), svfalse_b8()), svfalse_b8());\n        svbool_t pg_result = svand_b8(pg_even, pg_upper);\n        count += svcntp_b8(svptrue_b8(), pg_result);\n        pg_even = svext_b8(pg_even, pg_even, svcntb() / 2);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n\nint count_upper_simd(const std::string & s){\n    int count = 0;\n    size_t len = s.length();\n    const char* str = s.c_str();\n\n    // Create a predicate for even indices\n    svbool_t pg_even = svptrue_b8();\n    for (size_t i = 0; i < len; i += svcntb()) {\n        svuint8_t vec = svld1_u8(pg_even, reinterpret_cast<const uint8_t*>(str + i));\n        svbool_t pg_even_indices = svwhilelt_b8(i, len);\n        pg_even_indices = svand_b8(pg_even_indices, pg_even);\n\n        // Check for uppercase vowels at even indices\n        svbool_t pg_upper_a = sveq_m_n_u8(pg_even_indices, vec, 'A');\n        svbool_t pg_upper_e = sveq_m_n_u8(pg_even_indices, vec, 'E');\n        svbool_t pg_upper_i = sveq_m_n_u8(pg_even_indices, vec, 'I');\n        svbool_t pg_upper_o = sveq_m_n_u8(pg_even_indices, vec, 'O');\n        svbool_t pg_upper_u = sveq_m_n_u8(pg_even_indices, vec, 'U');\n\n        svbool_t pg_vowels = svor_b8(svor_b8(svor_b8(svor_b8(pg_upper_a, pg_upper_e), pg_upper_i), pg_upper_o), pg_upper_u);\n\n        count += svpopcnt_b8(pg_vowels);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint count_upper_simd(const std::string & s) {\n    int count = 0;\n    size_t len = s.length();\n    const char *str = s.c_str();\n\n    // Create a predicate for even indices\n    svbool_t pg_even = svptrue_b8();\n    for (size_t i = 0; i < len; i += svcntb()) {\n        size_t vl = svmin(svcntb(), len - i);\n        svbool_t pg = svwhilelt_b8(i, len);\n\n        // Load characters from the string\n        svuint8_t chars = svld1(pg, reinterpret_cast<const uint8_t*>(str + i));\n\n        // Check for even indices\n        svbool_t even_indices = svand_b8(pg, pg_even);\n\n        // Check if characters are uppercase vowels\n        svbool_t is_upper_vowel = sveor_b8(svcmpeq_b8(chars, svdup_u8('A')),\n                                          sveor_b8(svcmpeq_b8(chars, svdup_u8('E')),\n                                                   sveor_b8(svcmpeq_b8(chars, svdup_u8('I')),\n                                                            sveor_b8(svcmpeq_b8(chars, svdup_u8('O')),\n                                                                     svcmpeq_b8(chars, svdup_u8('U'))))));\n\n        // Combine conditions for even indices and uppercase vowels\n        svbool_t result = svand_b8(even_indices, is_upper_vowel);\n\n        // Count true values in the result predicate\n        count += svcntp_b8(result);\n\n        // Shift the even index predicate for the next iteration\n        pg_even = svshl_z(pg_even, pg_even, svdup_n_s8(1));\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    int *result_ptr = result.data();\n\n    // Determine the increment based on whether n is odd or even\n    int increment = (n % 2 == 0) ? 2 : 1;\n\n    // Create an initial vector with the first value n\n    svint32_t v = svdup_s32(n);\n\n    // Calculate the number of elements that can fit in a vector\n    svbool_t pg = svwhilelt_b32(0, n);\n    int64_t vl = svcntw();\n\n    // Fill the result array with the number of stones in each level\n    while (svptest_any(svptrue_b32(), pg)) {\n        svst1_s32(pg, result_ptr, v);\n        v = svadd_s32_x(pg, v, svdup_s32(increment + 2));\n        result_ptr += vl;\n        n -= vl;\n        pg = svwhilelt_b32(0, n);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    int *result_ptr = result.data();\n\n    svint32_t v_n = svdup_s32(n);\n    svint32_t v_increment = svdup_s32((n % 2 == 0) ? 2 : 1);\n    svint32_t v_index = svindex_s32(0, 1);\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    do {\n        svint32_t v_stones = svadd_s32_z(pg, v_n, svmul_s32_z(pg, v_index, v_increment));\n        svst1_s32(pg, result_ptr, v_stones);\n        result_ptr += svcntw();\n        v_index = svadd_s32_z(pg, v_index, svdup_s32(svcntw()));\n        pg = svwhilelt_b32(result_ptr - result.data(), n);\n    } while (svptest_any(svptrue_b32(), pg));\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    int *result_ptr = result.data();\n\n    svint32_t v_n = svdup_s32(n);\n    svint32_t v_increment = svdup_s32((n % 2 == 0) ? 2 : 1);\n    svint32_t v_index = svindex_s32(0, 1);\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    do {\n        svint32_t v_stones = svadd_s32_z(pg, v_n, svmul_s32_z(pg, v_index, v_increment));\n        svst1_s32(pg, result_ptr, v_stones);\n        result_ptr += svcntw();\n        v_index = svadd_s32_z(pg, v_index, svdup_s32(svcntw()));\n        pg = svwhilelt_b32(result_ptr - result.data(), n);\n    } while (svptest_any(svptrue_b32(), pg));\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    int *result_ptr = result.data();\n\n    svint32_t v_n = svdup_s32(n);\n    svint32_t v_increment = svdup_s32((n % 2 == 0) ? 2 : 1);\n    svint32_t v_index = svindex_s32(0, 1);\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    do {\n        svint32_t v_stones = svadd_s32_z(pg, v_n, svmul_s32_z(pg, v_index, v_increment));\n        svst1_s32(pg, result_ptr, v_stones);\n        result_ptr += svcntw();\n        n -= svcntw();\n        v_index = svadd_s32_x(svptrue_b32(), v_index, svdup_s32(svcntw()));\n        pg = svwhilelt_b32(result_ptr - result.data(), n);\n    } while (svptest_any(svptrue_b32(), pg));\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    int *result_ptr = result.data();\n\n    svint32_t v_n = svdup_s32(n);\n    svint32_t v_increment = svdup_s32((n % 2 == 0) ? 2 : 1);\n    svint32_t v_index = svindex_s32(0, 1);\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    do {\n        svint32_t v_stones = svadd_s32_z(pg, v_n, svmul_s32_z(pg, v_index, v_increment));\n        svst1_s32(pg, result_ptr, v_stones);\n        result_ptr += svcntw();\n        n -= svcntw();\n        v_index = svadd_s32_x(svptrue_b32(), v_index, svcntw());\n        pg = svwhilelt_b32(result_ptr - result.data(), n);\n    } while (svptest_any(svptrue_b32(), pg));\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <bitset>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n\n    int64_t count = m - n + 1;\n    svint64_t sum = svdup_s64(0);\n    svbool_t pg = svptrue_b64();\n\n    for (int64_t i = n; i <= m; i += svcntw()) {\n        svint64_t vec = svld1(pg, &i);\n        sum = svadd_s64_m(pg, sum, vec);\n        i += svcntw() - 1;\n    }\n\n    int64_t total_sum = svaddv_s64(sum);\n    int64_t avg = total_sum / count;\n\n    return std::bitset<64>(avg).to_string().substr(64 - std::ceil(std::log2(avg + 1)));\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <bitset>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n\n    int64_t count = m - n + 1;\n    svint64_t sum = svdup_s64(0);\n    svbool_t pg = svptrue_b64();\n\n    for (int64_t i = n; i <= m; i += svcntw()) {\n        svint64_t vec = svld1(pg, &i);\n        sum = svadd_s64_m(pg, sum, vec);\n        i += svcntw() - 1;\n    }\n\n    int64_t total_sum = 0;\n    svst1(pg, &total_sum, svaddv_s64_m(pg, sum));\n\n    int64_t avg = total_sum / count;\n    return std::bitset<64>(avg).to_string().substr(64 - std::ceil(std::log2(avg + 1)));\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <bitset>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n\n    int64_t count = m - n + 1;\n    svint64_t sum = svdup_s64(0);\n    svbool_t pg = svptrue_b64();\n\n    for (int64_t i = n; i <= m; i += svcntw()) {\n        svint64_t vec = svld1(pg, &i);\n        sum = svadd_s64_m(pg, sum, vec);\n        i += svcntw() - 1;\n    }\n\n    int64_t total_sum = 0;\n    svst1(pg, &total_sum, sum);\n\n    int64_t avg = total_sum / count;\n    return std::bitset<64>(avg).to_string().substr(64 - std::ceil(std::log2(avg + 1)));\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <bitset>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n\n    int64_t count = m - n + 1;\n    svint64_t sum = svdup_s64(0);\n    svbool_t pg = svptrue_b64();\n\n    for (int64_t i = n; i <= m; i += svcntw()) {\n        svint64_t vec = svld1(pg, &i);\n        sum = svadd_s64_m(pg, sum, vec);\n        i += svcntw() - 1;\n    }\n\n    int64_t total_sum = 0;\n    svst1(pg, &total_sum, svaddv_s64_m(pg, sum));\n\n    int64_t avg = total_sum / count;\n    return std::bitset<64>(avg).to_string().substr(64 - std::ceil(std::log2(avg + 1)));\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <bitset>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n\n    int64_t count = m - n + 1;\n    svint64_t sum = svdup_s64(0);\n    svbool_t pg = svptrue_b64();\n\n    for (int64_t i = n; i <= m; i += svcntw()) {\n        svint64_t vec = svld1(pg, &i);\n        sum = svadd_s64_m(pg, sum, vec);\n        i += svcntw() - 1;\n    }\n\n    int64_t total_sum = 0;\n    svst1(pg, &total_sum, sum);\n\n    int64_t avg = total_sum / count;\n    return std::bitset<64>(avg).to_string().substr(64 - std::bitset<64>(avg).count());\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    int *result_ptr = result.data();\n\n    svbool_t pg;\n    svint32_t index, even_mask, odd_mask, ones, factorial, sum, temp;\n    int i = 0;\n\n    while (svptest_any(svptrue_b32(), pg = svwhilelt_b32(i, n))) {\n        index = svadd_z(pg, svindex_s32(1, 1), svdup_s32(i));\n        even_mask = sveven_m(pg, index);\n        odd_mask = svnot_b32(even_mask);\n        ones = svdup_s32(1);\n\n        // Calculate factorial for even indices\n        factorial = ones;\n        for (int j = 1; j <= n; ++j) {\n            svint32_t j_vec = svdup_s32(j);\n            svint32_t le_mask = svcmple_z(pg, index, j_vec);\n            factorial = svmul_z(svand_b32(pg, le_mask, even_mask), factorial, j_vec);\n        }\n        factorial = svmod_z(pg, factorial, svdup_s32(10000));\n\n        // Calculate sum for odd indices\n        sum = ones;\n        for (int j = 2; j <= n; ++j) {\n            svint32_t j_vec = svdup_s32(j);\n            svint32_t lt_mask = svcmplt_z(pg, index, j_vec);\n            sum = svadd_z(svand_b32(pg, lt_mask, odd_mask), sum, j_vec);\n        }\n\n        // Combine results\n        temp = svsel_z(pg, even_mask, factorial, sum);\n        svst1(pg, result_ptr + i, temp);\n\n        i += svcntw();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    int *result_ptr = result.data();\n\n    svint32_t factorial = svdup_s32(1);\n    svint32_t sum = svdup_s32(0);\n    svint32_t index = svindex_s32(1, 1);\n    svbool_t pg = svwhilelt_b32(0, n);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t even_mask = sveor_b_z(pg, svcmpeq_n_s32(pg, svand_s32_z(pg, index, svdup_s32(1)), 0), pg);\n        svint32_t odd_mask = svnot_b_z(pg, even_mask);\n\n        // Calculate factorial for even indices\n        factorial = svmul_s32_z(even_mask, factorial, index);\n        factorial = svmod_s32_z(even_mask, factorial, svdup_s32(10000));\n\n        // Calculate sum for odd indices\n        sum = svadd_s32_z(odd_mask, sum, index);\n\n        // Store results\n        svst1_s32(pg, result_ptr, sveor_s32_z(pg, factorial, sum));\n\n        // Update index and masks for next iteration\n        index = svadd_s32_x(pg, index, svdup_s32(svcntb()));\n        pg = svwhilelt_b32(index, n);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    int *result_ptr = result.data();\n\n    svbool_t pg;\n    svint32_t index, even_mask, odd_mask, ones, factorial, sum, temp;\n    int factorial_scalar = 1, sum_scalar = 0;\n\n    for (int i = 0; i < n; i += svcntw()) {\n        pg = svwhilelt_b32(i, n);\n        index = svadd_z(pg, svindex_s32(1, 1), svdup_s32(i));\n        even_mask = sveven_m(pg, index);\n        odd_mask = svnot_b_z(pg, even_mask);\n\n        // Calculate factorial for even indices\n        factorial = svdup_s32(factorial_scalar);\n        for (int j = 1; j <= n; ++j) {\n            svint32_t j_vec = svdup_s32(j);\n            factorial = svmul_z(pg, factorial, j_vec);\n            factorial = svand_z(pg, factorial, even_mask);\n            factorial_scalar *= j;\n            factorial_scalar %= 10000;\n        }\n\n        // Calculate sum for odd indices\n        sum = svdup_s32(sum_scalar);\n        for (int j = 1; j <= n; ++j) {\n            sum = svadd_z(pg, sum, svdup_s32(j));\n            sum = svand_z(pg, sum, odd_mask);\n            sum_scalar += j;\n        }\n\n        // Combine results\n        temp = svorr_z(pg, factorial, sum);\n        svst1(pg, result_ptr + i, temp);\n\n        // Update scalar values for next iteration\n        factorial_scalar = 1;\n        sum_scalar = 0;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    int *result_ptr = result.data();\n\n    svbool_t pg;\n    svint32_t index, even_mask, odd_mask, ones, factorial, sum, current_value;\n    int i = 0;\n\n    while (svany(svptrue_b32(), pg = svwhilelt_b32(i, n))) {\n        index = svindex_s32(i, 1);\n        even_mask = sveven_m(pg, index);\n        odd_mask = svnot_b_z(pg, even_mask);\n        ones = svdup_s32(1);\n\n        // Calculate factorial for even indices\n        factorial = ones;\n        for (int j = 2; j <= n; ++j) {\n            svint32_t j_vec = svdup_s32(j);\n            svint32_t mask = svcmplt_s32(pg, index, j_vec);\n            factorial = svmul_s32_z(mask, factorial, j_vec);\n            factorial = svmod_s32_z(mask, factorial, svdup_s32(10000));\n        }\n\n        // Calculate sum for odd indices\n        sum = ones;\n        for (int j = 2; j <= n; ++j) {\n            svint32_t j_vec = svdup_s32(j);\n            svint32_t mask = svcmplt_s32(pg, index, j_vec);\n            sum = svadd_s32_z(mask, sum, j_vec);\n        }\n\n        // Select between factorial and sum based on index parity\n        current_value = svsel_s32(even_mask, factorial, sum);\n\n        // Store results\n        svst1_s32(pg, result_ptr + i, current_value);\n\n        i += svcntw();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    int *result_ptr = result.data();\n\n    svbool_t pg;\n    svint32_t index, even_mask, odd_mask, ones, factorial, sum, current_value;\n    int i = 0;\n\n    while (svany(svptrue_b32(), pg = svwhilelt_b32(i, n))) {\n        index = svindex_s32(svzerob(), 1, pg);\n        even_mask = sveq_n_s32(pg, svand_s32_z(pg, index, svdup_s32(1)), 0);\n        odd_mask = svnot_b_z(pg, even_mask);\n\n        // Calculate factorial for even indices\n        factorial = svdup_s32(1);\n        for (int j = 1; j <= n; ++j) {\n            svint32_t j_vec = svdup_s32(j);\n            svbool_t lt_mask = svwhilelt_b32(0, j);\n            lt_mask = svand_b_z(pg, lt_mask, even_mask);\n            factorial = svmul_s32_z(factorial, lt_mask, svmul_s32_z(svld1_s32_z(lt_mask, &j), lt_mask, factorial));\n            factorial = svmod_n_s32_z(factorial, lt_mask, 10000);\n        }\n\n        // Calculate sum for odd indices\n        sum = svdup_s32(0);\n        ones = svdup_s32(1);\n        for (int j = 1; j <= n; ++j) {\n            svint32_t j_vec = svdup_s32(j);\n            svbool_t lt_mask = svwhilelt_b32(0, j);\n            lt_mask = svand_b_z(pg, lt_mask, odd_mask);\n            sum = svadd_s32_z(sum, lt_mask, svadd_s32_z(svld1_s32_z(lt_mask, &j), lt_mask, sum));\n        }\n\n        // Combine results\n        current_value = svsel_s32(even_mask, factorial, sum);\n        svst1_s32(pg, &result_ptr[i], current_value);\n\n        i += svcntw();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    // Create a predicate for the loop\n    svbool_t pg = svptrue_b32();\n\n    // Loop through numbers in steps of the vector length\n    for (int i = 1; i <= n; i += svcntw()) {\n        // Load numbers into a vector\n        svint32_t nums = svindex_s32(i, 1);\n\n        // Create a mask for numbers less than or equal to n\n        svbool_t mask = svle_s32(pg, nums, n);\n\n        // Function to check if a number is a palindrome\n        auto is_palindrome = [](int x) {\n            int original = x, reversed = 0;\n            while (x > 0) {\n                int digit = x % 10;\n                reversed = reversed * 10 + digit;\n                x /= 10;\n            }\n            return original == reversed;\n        };\n\n        // Apply the palindrome check to each element in the vector\n        svbool_t palindromes = svwhilelt_b32(mask, 0);\n        for (int j = 0; j < svcntw(); ++j) {\n            if (svptest_any(svptrue_b32(), svand_b32(mask, palindromes))) {\n                int num = svnth_u32(mask, nums, j);\n                if (is_palindrome(num)) {\n                    if (num % 2 == 0) {\n                        even_count++;\n                    } else {\n                        odd_count++;\n                    }\n                }\n            }\n            palindromes = svext_b32(palindromes, svpfalse_b32());\n        }\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    // Create a predicate for the loop\n    svbool_t pg = svptrue_b32();\n\n    // Loop through numbers in steps of the vector length\n    for (int i = 1; i <= n; i += svcntw()) {\n        // Load numbers into a vector\n        svint32_t nums = svindex_s32(i, 1);\n\n        // Create a vector to store palindrome checks\n        svint32_t palindromes = svdup_s32(1);\n\n        // Check each number if it is a palindrome\n        for (int j = 0; j < svcntw(); ++j) {\n            int num = i + j;\n            if (num > n) break;\n            int original = num;\n            int reversed = 0;\n            while (num > 0) {\n                int digit = num % 10;\n                reversed = reversed * 10 + digit;\n                num /= 10;\n            }\n            palindromes = svand_s32_z(pg, palindromes, svcmpeq_s32(pg, svdup_s32(original), svdup_s32(reversed)));\n        }\n\n        // Count even and odd palindromes\n        svint32_t evens = sveor_s32_z(pg, palindromes, svand_s32_z(pg, palindromes, svdup_s32(1)));\n        svint32_t odds = svand_s32_z(pg, palindromes, svdup_s32(1));\n\n        even_count += svcntp_b32(svgtz_s32(pg, evens));\n        odd_count += svcntp_b32(svgtz_s32(pg, odds));\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    // Create a predicate for the loop\n    svbool_t pg = svptrue_b32();\n\n    // Loop through numbers in steps of the vector length\n    for (int i = 1; i <= n; i += svcntw()) {\n        // Load a vector of numbers\n        svint32_t vec = svindex_s32(i, 1);\n\n        // Create a mask for numbers less than or equal to n\n        svbool_t mask = svle_s32(pg, vec, n);\n\n        // Function to check if a number is a palindrome\n        auto is_palindrome = [](int num) {\n            int original = num, reversed = 0;\n            while (num > 0) {\n                int digit = num % 10;\n                reversed = reversed * 10 + digit;\n                num /= 10;\n            }\n            return original == reversed;\n        };\n\n        // Check each number in the vector if it is a palindrome\n        svbool_t palindromes = svwhilelt_b32(mask, 0, svcntw());\n        for (int j = 0; j < svcntw(); ++j) {\n            if (svtst_b32(palindromes, svptrue_b32())) {\n                int num = svlastb_h32(svext_z32(pg, vec, svdup_n_s32(0)));\n                if (is_palindrome(num)) {\n                    if (num % 2 == 0) {\n                        even_count++;\n                    } else {\n                        odd_count++;\n                    }\n                }\n                palindromes = svpfalse_b32();\n            }\n            palindromes = svext_b32(pg, palindromes, svpfalse_b32());\n        }\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    // Create a predicate for the loop\n    svbool_t pg = svptrue_b32();\n\n    // Loop through numbers in steps of the vector length\n    for (int i = 1; i <= n; i += svcntw()) {\n        // Load a vector of numbers starting from i\n        svint32_t vec = svindex_s32(i, 1);\n\n        // Create a vector of numbers to compare with reversed numbers\n        svint32_t reversed_vec = vec;\n\n        // Reverse the digits of each number in the vector\n        for (int j = 0; j < 3; ++j) {\n            svint32_t temp = svreinterpret_s32_u32(svrev_b16(svreinterpret_u32_s32(reversed_vec)));\n            reversed_vec = svadd_z(pg, svlsr_z(pg, temp, 16), svand_z(pg, reversed_vec, 0xFFFF));\n        }\n\n        // Check if the original numbers are equal to their reversed versions\n        svbool_t palindrome_mask = sveq_m(pg, vec, reversed_vec);\n\n        // Count even and odd palindromes\n        svbool_t even_mask = svand_m(palindrome_mask, svcmpeq_n_m(palindrome_mask, vec, 0));\n        svbool_t odd_mask = svand_m(palindrome_mask, svcmpne_n_m(palindrome_mask, vec, 0));\n\n        even_count += svcntp_b32(even_mask);\n        odd_count += svcntp_b32(odd_mask);\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    // Create a predicate for the loop\n    svbool_t pg = svptrue_b32();\n\n    // Loop through numbers in steps of the vector length\n    for (int i = 1; i <= n; i += svcntw()) {\n        // Load a vector of numbers\n        svint32_t vec = svindex_s32(i, 1);\n\n        // Create a mask for numbers less than or equal to n\n        svbool_t mask = svle_s32(pg, vec, n);\n\n        // Function to check if a number is a palindrome\n        auto is_palindrome = [](int num) {\n            int original = num, reversed = 0;\n            while (num > 0) {\n                int digit = num % 10;\n                reversed = reversed * 10 + digit;\n                num /= 10;\n            }\n            return original == reversed;\n        };\n\n        // Apply the palindrome check to each element in the vector\n        svbool_t palindromes = svdup_b32(false);\n        for (int j = 0; j < svcntw(); ++j) {\n            if (svptest_any(mask)) {\n                palindromes = svorr_b32(palindromes, svdup_b32(is_palindrome(svlastb(vec))));\n                vec = svext(svundef_s32(), vec, 1);\n                mask = svext(svundef_b32(), mask, 1);\n            }\n        }\n\n        // Count even and odd palindromes\n        svbool_t even_palindromes = svand_b32(palindromes, sveven_s32_m(mask, vec));\n        svbool_t odd_palindromes = svand_b32(palindromes, svnot_b32(even_palindromes));\n\n        even_count += svcntp_b32(even_palindromes);\n        odd_count += svcntp_b32(odd_palindromes);\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint count_nums_simd(const std::vector<int>& n) {\n    int count = 0;\n    size_t size = n.size();\n    const int* data = n.data();\n\n    svbool_t pg;\n    svint32_t vec;\n    svint32_t sum_digits = svdup_s32(0);\n    svint32_t ones = svdup_s32(1);\n\n    for (size_t i = 0; i < size; i += svcntw()) {\n        pg = svwhilelt_b32(i, size);\n        vec = svld1_s32(pg, &data[i]);\n\n        svint32_t abs_vec = svabs_s32_z(pg, vec);\n        svint32_t sign_vec = svsub_z(pg, svdup_s32(0), svsel_s32(svcmplt_s32(pg, vec, svdup_s32(0))), svdup_s32(0));\n\n        svint32_t digit_sum = svdup_s32(0);\n        for (int j = 0; j < 10; ++j) { // Assuming numbers have at most 10 digits\n            svint32_t digit = svand_s32_z(pg, abs_vec, svdup_s32(9));\n            digit_sum = svadd_z(pg, digit_sum, digit);\n            abs_vec = svlsr_n_s32_z(pg, abs_vec, 4); // Divide by 10\n        }\n\n        digit_sum = svadd_z(pg, digit_sum, sign_vec);\n        svbool_t gt_zero = svcmpgt_s32(pg, digit_sum, svdup_s32(0));\n        count += svcntp_b32(gt_zero);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint count_nums_simd(const std::vector<int>& n) {\n    int count = 0;\n    size_t size = n.size();\n    const int* data = n.data();\n\n    svbool_t pg;\n    svint32_t vec;\n    svint32_t sum_digits = svdup_s32(0);\n    svint32_t ones = svdup_s32(1);\n\n    for (size_t i = 0; i < size; i += svcntw()) {\n        pg = svwhilelt_b32(i, size);\n        vec = svld1_s32(pg, &data[i]);\n\n        svint32_t abs_vec = svabs_s32_z(pg, vec);\n        svint32_t sign_vec = svsub_z(pg, svdup_s32(0), svsel_s32(svcmplt_s32(pg, vec, svdup_s32(0))), svdup_s32(0));\n\n        svint32_t digit_sum = svdup_s32(0);\n        for (int j = 0; j < 10; ++j) { // Assuming numbers have at most 10 digits\n            svint32_t digit = svmod_s32_z(pg, abs_vec, svdup_s32(10));\n            digit_sum = svadd_z(pg, digit_sum, digit);\n            abs_vec = svdiv_s32_z(pg, abs_vec, svdup_s32(10));\n        }\n\n        digit_sum = svadd_z(pg, digit_sum, sign_vec);\n        svbool_t gt_zero = svcmpgt_s32(pg, digit_sum, svdup_s32(0));\n        count += svcntp_b32(gt_zero);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint count_nums_simd(const std::vector<int>& n) {\n    int count = 0;\n    size_t size = n.size();\n    const int* data = n.data();\n\n    svbool_t pg;\n    svint32_t vec;\n    svint32_t sum_digits = svdup_s32(0);\n    svint32_t ones = svdup_s32(1);\n\n    for (size_t i = 0; i < size; i += svcntw()) {\n        pg = svwhilelt_b32(i, size);\n        vec = svld1_s32(pg, &data[i]);\n\n        svint32_t abs_vec = svabs_s32_z(pg, vec);\n        svint32_t sign_vec = svsub_z(pg, svdup_s32(0), svsel_s32(svcmplt_s32(pg, vec, svdup_s32(0)), svdup_s32(1), svdup_s32(0)));\n\n        svint32_t digit_sum = svdup_s32(0);\n        for (int shift = 0; shift < 32; shift += 4) {\n            svint32_t digit = svand_s32_z(pg, abs_vec, svdup_s32(0xF << shift));\n            digit = svlsr_n_s32_z(pg, digit, shift);\n            digit_sum = svadd_z(pg, digit_sum, digit);\n        }\n\n        digit_sum = svsub_z(pg, digit_sum, svmul_z(pg, sign_vec, svld1_s32(pg, &data[i])));\n\n        svbool_t gt_zero = svcmpgt_s32(pg, digit_sum, svdup_s32(0));\n        count += svcntp_b32(gt_zero);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint count_nums_simd(const std::vector<int>& n) {\n    int count = 0;\n    size_t size = n.size();\n    const int* data = n.data();\n\n    svbool_t pg;\n    svint32_t vec;\n    svint32_t sum_digits = svdup_s32(0);\n    svint32_t ones = svdup_s32(1);\n\n    for (size_t i = 0; i < size; i += svcntw()) {\n        pg = svwhilelt_b32(i, size);\n        vec = svld1_s32(pg, &data[i]);\n\n        svint32_t abs_vec = svabs_s32_z(pg, vec);\n        svint32_t sign_vec = svsub_z(pg, svdup_s32(0), svsel_s32(svcmplt_s32(pg, vec, svdup_s32(0))), svdup_s32(0));\n\n        svint32_t digit_sum = svdup_s32(0);\n        for (int j = 0; j < 10; ++j) { // Assuming numbers have at most 10 digits\n            svint32_t digit = svand_s32_z(pg, abs_vec, svdup_s32(9));\n            digit_sum = svadd_z(pg, digit_sum, digit);\n            abs_vec = svlsr_n_s32_z(pg, abs_vec, 4); // Divide by 10\n        }\n\n        digit_sum = svadd_z(pg, digit_sum, sign_vec);\n        svbool_t gt_zero = svcmpgt_s32(pg, digit_sum, svdup_s32(0));\n        count += svcntp_b32(gt_zero);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint count_nums_simd(const std::vector<int>& n) {\n    int count = 0;\n    size_t size = n.size();\n    const int* data = n.data();\n\n    svbool_t pg;\n    svint32_t vec;\n    svint32_t sum_digits = svdup_s32(0);\n\n    for (size_t i = 0; i < size; i += svcntw()) {\n        pg = svwhilelt_b32(i, size);\n        vec = svld1_s32(pg, &data[i]);\n\n        svint32_t abs_vec = svabs_s32_z(pg, vec);\n        svint32_t sign_vec = svsub_z(pg, svdup_s32(0), svsel_s32(svcmplt_s32(pg, vec, svdup_s32(0))), svdup_s32(0));\n\n        svint32_t digit_sum = svdup_s32(0);\n        for (int shift = 0; shift < 32; shift += 10) { // Process up to 3 digits at a time\n            svint32_t digits = svand_s32_z(pg, abs_vec, svdup_s32(1023 << shift));\n            digits = svlsr_n_s32_z(pg, digits, shift);\n            digit_sum = svadd_z(pg, digit_sum, digits);\n        }\n\n        digit_sum = svsub_z(pg, digit_sum, sign_vec);\n        svbool_t gt_zero = svcmpgt_s32(pg, digit_sum, svdup_s32(0));\n        count += svcntp_b32(gt_zero);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    size_t N = arr.size();\n    if (N == 0) return true;\n\n    // Create an SVE vector from the input array\n    svint32_t vec = svld1_s32(svundef_s32(), arr.data());\n\n    // Create a sorted version of the vector for comparison\n    std::vector<int> sorted_arr(arr);\n    std::sort(sorted_arr.begin(), sorted_arr.end());\n    svint32_t sorted_vec = svld1_s32(svundef_s32(), sorted_arr.data());\n\n    // Check if the original vector is already sorted\n    svbool_t pg = svcmpeq_s32(svptrue_b32(), vec, sorted_vec);\n    if (svptest_any(svptrue_b32(), pg)) return true;\n\n    // Try all possible right shifts\n    for (size_t i = 1; i < N; ++i) {\n        // Perform a right shift\n        svint32_t shifted_vec = svext_s32(sorted_vec, svindex_s32(0, 1), N - 1);\n        sorted_vec = svsel_s32(svptrue_b32(), shifted_vec, sorted_vec);\n\n        // Compare with the original vector\n        pg = svcmpeq_s32(svptrue_b32(), vec, sorted_vec);\n        if (svptest_any(svptrue_b32(), pg)) return true;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return true;\n    }\n\n    size_t N = arr.size();\n    int* data = arr.data();\n\n    // Create a predicate to check if the array is sorted\n    svbool_t pg = svptrue_b32();\n    svint32_t vec = svld1(pg, data);\n    svint32_t shifted_vec = svext(svundef_s32(), vec, svindex_s32(0, 1));\n    svbool_t sorted_check = svcmplt_s32(pg, shifted_vec, vec);\n\n    // Count the number of places where the array is not sorted\n    int count = svcntpne_b32(pg, sorted_check, svfalse_b());\n\n    // If the array is already sorted or can be sorted with one rotation, count should be 0 or 1\n    return count <= 1;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return true;\n    }\n\n    size_t N = arr.size();\n    int *data = arr.data();\n\n    // Create a predicate for the original array\n    svint32_t vec = svld1_s32(svundef_s32(), data);\n    svbool_t pred = svcmpgt_s32(svptrue_b32(), svext_s32(vec, vec, N - 1), vec);\n\n    // Check if the array is already sorted\n    if (!svptest_any(svptrue_b32(), pred)) {\n        return true;\n    }\n\n    // Try all possible rotations\n    for (size_t i = 1; i < N; ++i) {\n        vec = svext_s32(vec, vec, 1);\n        pred = svcmpgt_s32(svptrue_b32(), svext_s32(vec, vec, N - 1), vec);\n        if (!svptest_any(svptrue_b32(), pred)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    size_t N = arr.size();\n    if (N == 0) return true;\n\n    // Create an SVE vector from the input array\n    svint32_t vec = svld1_s32(svundef_s32(), arr.data());\n\n    // Create a sorted version of the vector\n    std::vector<int> sorted_arr(arr);\n    std::sort(sorted_arr.begin(), sorted_arr.end());\n    svint32_t sorted_vec = svld1_s32(svundef_s32(), sorted_arr.data());\n\n    // Check all possible rotations\n    for (size_t i = 0; i < N; ++i) {\n        // Compare the current rotation with the sorted vector\n        svbool_t pg = svcmpeq_s32(svptrue_b32(), vec, sorted_vec);\n\n        // If all elements match, return true\n        if (svptest_any(svptrue_b32(), pg)) {\n            return true;\n        }\n\n        // Perform a right shift operation\n        int last_element = arr[N - 1];\n        for (size_t j = N - 1; j > 0; --j) {\n            arr[j] = arr[j - 1];\n        }\n        arr[0] = last_element;\n\n        // Update the SVE vector with the new rotation\n        vec = svld1_s32(svundef_s32(), arr.data());\n    }\n\n    // If no rotation matches the sorted vector, return false\n    return false;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return true;\n    }\n\n    size_t N = arr.size();\n    int *data = arr.data();\n\n    // Create a vector of indices\n    std::vector<int> indices(N);\n    for (size_t i = 0; i < N; ++i) {\n        indices[i] = i;\n    }\n\n    // Sort indices based on the values in arr\n    std::sort(indices.begin(), indices.end(), [&](int a, int b) {\n        return data[a] < data[b];\n    });\n\n    // Check if the sorted indices form a contiguous sequence\n    svbool_t pg = svptrue_b32();\n    svint32_t idx_vec = svld1(pg, indices.data());\n    svint32_t one_vec = svdup_s32(1);\n    svint32_t expected_vec = svadd_z(pg, idx_vec, one_vec);\n\n    // Wrap around the last element\n    svint32_t wrap_vec = svsub_z(pg, expected_vec, svdup_s32(N));\n    svbool_t match1 = sveq_m(pg, idx_vec, expected_vec);\n    svbool_t match2 = sveq_m(pg, idx_vec, wrap_vec);\n\n    // Check if all elements match either expected or wrapped values\n    svbool_t overall_match = svorr_b_z(pg, match1, match2);\n    return svptest_any(svptrue_b32(), overall_match);\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    svbool_t pg;\n    svint32_t vec1, vec2, even_mask;\n    size_t vl = svcntw();\n\n    // Check if there are any odd numbers in lst1\n    for (size_t i = 0; i < lst1.size(); i += vl) {\n        vl = svmin(vl, lst1.size() - i);\n        pg = svwhilelt_b32(0, vl);\n        vec1 = svld1(pg, &lst1[i]);\n        even_mask = sveor_b_z(pg, svcmpeq_n_s32(pg, svand_s32_z(pg, vec1, svdup_s32(1)), 0), pg);\n        if (!svptest_any(svptrue_b32(), even_mask)) {\n            // Found an odd number in lst1, check if we can replace it with an even number from lst2\n            bool found_even_in_lst2 = false;\n            for (size_t j = 0; j < lst2.size() && !found_even_in_lst2; j += vl) {\n                vl = svmin(vl, lst2.size() - j);\n                pg = svwhilelt_b32(0, vl);\n                vec2 = svld1(pg, &lst2[j]);\n                even_mask = svcmpeq_n_s32(pg, svand_s32_z(pg, vec2, svdup_s32(1)), 0);\n                if (svptest_any(svptrue_b32(), even_mask)) {\n                    found_even_in_lst2 = true;\n                }\n            }\n            if (!found_even_in_lst2) {\n                return \"NO\";\n            }\n        }\n    }\n    return \"YES\";\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    svbool_t pg;\n    svint32_t vec1, vec2, even_mask;\n    size_t vl = svcntw();\n\n    // Check if there are enough even numbers in lst2 to replace odd numbers in lst1\n    int odd_count = 0;\n    int even_count_in_lst2 = 0;\n\n    // Count odd numbers in lst1\n    for (size_t i = 0; i < lst1.size(); i += vl) {\n        vl = svld1_bf16(pg, &lst1[i]);\n        vec1 = svld1_s32(pg, &lst1[i]);\n        even_mask = svevnm_s32_z(pg, vec1);\n        odd_count += svpopcntb(pg, svnot_b_z(pg, even_mask));\n    }\n\n    // Count even numbers in lst2\n    for (size_t i = 0; i < lst2.size(); i += vl) {\n        vl = svld1_bf16(pg, &lst2[i]);\n        vec2 = svld1_s32(pg, &lst2[i]);\n        even_mask = svevnm_s32_z(pg, vec2);\n        even_count_in_lst2 += svpopcntb(pg, even_mask);\n    }\n\n    // If there are enough even numbers in lst2 to replace all odd numbers in lst1, return \"YES\"\n    if (even_count_in_lst2 >= odd_count) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    svbool_t pg;\n    svint32_t vec1, vec2;\n    int count_odd_lst1 = 0;\n\n    // Process lst1 to count odd numbers\n    for (size_t i = 0; i < lst1.size(); i += svcntw()) {\n        size_t vl = svcntw();\n        if (i + vl > lst1.size()) {\n            vl = lst1.size() - i;\n        }\n        pg = svwhilelt_b32(0, vl);\n        vec1 = svld1(pg, &lst1[i]);\n        svbool_t odd_mask = svcmpne_n_s32(pg, svand_s32_z(pg, vec1, svdup_s32(1)), 0);\n        count_odd_lst1 += svcntp_b32(svptrue_b32(), odd_mask);\n    }\n\n    // If there are no odd numbers in lst1, return \"YES\"\n    if (count_odd_lst1 == 0) {\n        return \"YES\";\n    }\n\n    // Process lst2 to check for even numbers\n    int count_even_lst2 = 0;\n    for (size_t i = 0; i < lst2.size(); i += svcntw()) {\n        size_t vl = svcntw();\n        if (i + vl > lst2.size()) {\n            vl = lst2.size() - i;\n        }\n        pg = svwhilelt_b32(0, vl);\n        vec2 = svld1(pg, &lst2[i]);\n        svbool_t even_mask = svecmpeq_n_s32(pg, svand_s32_z(pg, vec2, svdup_s32(1)), 0);\n        count_even_lst2 += svcntp_b32(svptrue_b32(), even_mask);\n    }\n\n    // If there are enough even numbers in lst2 to replace all odd numbers in lst1, return \"YES\"\n    if (count_even_lst2 >= count_odd_lst1) {\n        return \"YES\";\n    }\n\n    return \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    svbool_t pg;\n    svint32_t vec1, vec2, even_mask;\n    size_t vl = svcntw();\n\n    // Check if there are enough even numbers in lst2 to replace odd numbers in lst1\n    int odd_count = 0;\n    int even_count_in_lst2 = 0;\n\n    // Count odd numbers in lst1\n    for (size_t i = 0; i < lst1.size(); i += vl) {\n        vl = svld1_bf16(pg, &lst1[i]);\n        vec1 = svld1_s32(pg, &lst1[i]);\n        even_mask = svevnm_s32_z(pg, vec1);\n        odd_count += svpopcntb(pg, svnot_b_z(pg, even_mask));\n    }\n\n    // Count even numbers in lst2\n    for (size_t i = 0; i < lst2.size(); i += vl) {\n        vl = svld1_bf16(pg, &lst2[i]);\n        vec2 = svld1_s32(pg, &lst2[i]);\n        even_mask = svevnm_s32_z(pg, vec2);\n        even_count_in_lst2 += svpopcntb(pg, even_mask);\n    }\n\n    // If there are enough even numbers in lst2 to replace all odd numbers in lst1, return \"YES\"\n    if (even_count_in_lst2 >= odd_count) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    svbool_t pg;\n    svint32_t vec1, vec2, even_mask;\n    size_t vl = svcntw();\n\n    // Check if there are enough even numbers in lst2 to replace odd numbers in lst1\n    int odd_count = 0;\n    int even_count_in_lst2 = 0;\n\n    // Count odd numbers in lst1\n    for (size_t i = 0; i < lst1.size(); i += vl) {\n        vl = svld1_bf16(pg, &lst1[i]);\n        vec1 = svld1_s32(pg, &lst1[i]);\n        even_mask = svevnm_s32_z(pg, vec1);\n        odd_count += svpopcntb_z(pg, svnot_b_z(pg, even_mask));\n    }\n\n    // Count even numbers in lst2\n    for (size_t i = 0; i < lst2.size(); i += vl) {\n        vl = svld1_bf16(pg, &lst2[i]);\n        vec2 = svld1_s32(pg, &lst2[i]);\n        even_mask = svevnm_s32_z(pg, vec2);\n        even_count_in_lst2 += svpopcntb_z(pg, even_mask);\n    }\n\n    // If there are enough even numbers in lst2 to replace all odd numbers in lst1\n    if (even_count_in_lst2 >= odd_count) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    for (const auto &str : lst) {\n        size_t len = str.size();\n        const char *ptr = str.c_str();\n        uint32_t odd_count = 0;\n\n        while (len > 0) {\n            svbool_t pg = svwhilelt_b8(0, len);\n            svuint8_t vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(ptr));\n            svuint8_t odds = svand_u8_z(pg, vec, svdup_u8(1));\n            odd_count += svcntp_b_z(pg, odds);\n\n            ptr += svcntb();\n            len -= svcntb();\n        }\n\n        std::string res = \"the number of odd elements \";\n        res += std::to_string(odd_count);\n        res += \"n the str\";\n        res += std::to_string(odd_count);\n        res += \"ng \";\n        res += std::to_string(odd_count);\n        res += \" of the \";\n        res += std::to_string(odd_count);\n        res += \"nput.\";\n        result.push_back(res);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    for (const auto &str : lst) {\n        size_t len = str.size();\n        const char *ptr = str.c_str();\n        uint64_t odd_count = 0;\n\n        while (len > 0) {\n            svbool_t pg = svwhilelt_b8(0, len);\n            svuint8_t vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(ptr));\n            svuint8_t odds = svand_u8_z(pg, vec, svdup_u8(1));\n            odd_count += svcntp_b_z(pg, odds);\n\n            ptr += svcntb();\n            len -= svcntb();\n        }\n\n        std::string res = \"the number of odd elements \";\n        res += std::to_string(odd_count);\n        res += \"n the str\";\n        res += std::to_string(odd_count);\n        res += \"ng \";\n        res += std::to_string(odd_count);\n        res += \" of the \";\n        res += std::to_string(odd_count);\n        res += \"nput.\";\n        result.push_back(res);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    for (const auto &str : lst) {\n        size_t len = str.size();\n        const char *ptr = str.c_str();\n        uint32_t odd_count = 0;\n\n        while (len > 0) {\n            svbool_t pg = svwhilelt_b8(0, len);\n            svuint8_t vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(ptr));\n            svuint8_t odds = svand_u8_z(pg, vec, svdup_u8(1));\n            odd_count += svcntp_b_z(pg, odds);\n\n            ptr += svcntb();\n            len -= svcntb();\n        }\n\n        std::string res = \"the number of odd elements \";\n        res += std::to_string(odd_count);\n        res += \"n the str\";\n        res += std::to_string(odd_count);\n        res += \"ng \";\n        res += std::to_string(odd_count);\n        res += \" of the \";\n        res += std::to_string(odd_count);\n        res += \"nput.\";\n        result.push_back(res);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    for (const auto &str : lst) {\n        int odd_count = 0;\n        size_t len = str.size();\n        const char *ptr = str.c_str();\n\n        while (len > 0) {\n            svbool_t pg = svwhilelt_b8(0, len);\n            svuint8_t vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(ptr));\n            svuint8_t odds = svand_u8_z(pg, vec, svdup_u8(1));\n            odd_count += svcntp_b_z(pg, odds);\n            ptr += svcntb();\n            len -= svcntb();\n        }\n\n        std::string res = \"the number of odd elements \";\n        res += std::to_string(odd_count);\n        res += \"n the str\";\n        res += std::to_string(odd_count);\n        res += \"ng \";\n        res += std::to_string(odd_count);\n        res += \" of the \";\n        res += std::to_string(odd_count);\n        res += \"nput.\";\n        result.push_back(res);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    for (const auto & str : lst) {\n        size_t len = str.size();\n        const char * ptr = str.c_str();\n        uint64_t odd_count = 0;\n\n        while (len > 0) {\n            svbool_t pg = svwhilelt_b8(0, len);\n            svuint8_t vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(ptr));\n            svuint8_t odds = svand_u8_z(pg, vec, svdup_u8(1));\n            odd_count += svcntp_b_z(pg, odds);\n\n            ptr += svcntb();\n            len -= svcntb();\n        }\n\n        std::string res = \"the number of odd elements \";\n        res += std::to_string(odd_count);\n        res += \"n the str\";\n        res += std::to_string(odd_count);\n        res += \"ng \";\n        res += std::to_string(odd_count);\n        res += \" of the \";\n        res += std::to_string(odd_count);\n        res += \"nput.\";\n        result.push_back(res);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int64_t min_sum = std::numeric_limits<int64_t>::max();\n    int64_t current_min = 0;\n\n    size_t i = 0;\n    svbool_t pg;\n    svint64_t v_min_sum = svdup_s64(min_sum);\n    svint64_t v_current_min = svdup_s64(current_min);\n\n    do {\n        size_t vl = svcntd();\n        if (i + vl > nums.size()) {\n            vl = nums.size() - i;\n        }\n        pg = svwhilelt_b64(i, nums.size());\n\n        svint64_t v_nums = svld1(pg, &nums[i]);\n        v_current_min = svmin_s64_z(pg, svadd_s64_z(pg, v_current_min, v_nums), v_nums);\n        v_min_sum = svmin_s64_z(pg, v_min_sum, v_current_min);\n\n        i += vl;\n    } while (svptest_any(svptrue_b64(), pg));\n\n    min_sum = svminv_s64(v_min_sum);\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int64_t min_sum = std::numeric_limits<int64_t>::max();\n    int64_t current_min = 0;\n\n    size_t i = 0;\n    svbool_t pg;\n    svint64_t v_min_sum = svdup_s64(min_sum);\n    svint64_t v_current_min = svdup_s64(current_min);\n\n    do {\n        size_t vl = svcntd();\n        if (i + vl > nums.size()) {\n            vl = nums.size() - i;\n        }\n        pg = svwhilelt_b64(i, nums.size());\n\n        svint64_t v_nums = svld1(pg, &nums[i]);\n        v_current_min = svmin_s64_z(pg, svadd_s64_z(pg, v_current_min, v_nums), v_nums);\n        v_min_sum = svmin_s64_z(pg, v_min_sum, v_current_min);\n\n        i += vl;\n    } while (svptest_any(svptrue_b64(), pg));\n\n    min_sum = svminv_s64(v_min_sum);\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int64_t min_sum = std::numeric_limits<int64_t>::max();\n    int64_t current_min = 0;\n\n    size_t i = 0;\n    svbool_t pg;\n    svint64_t v_min_sum = svdup_s64(min_sum);\n    svint64_t v_current_min = svdup_s64(current_min);\n\n    do {\n        size_t vl = svcntd();\n        if (i + vl > nums.size()) {\n            vl = nums.size() - i;\n        }\n        pg = svwhilelt_b64(i, nums.size());\n\n        svint64_t v_nums = svld1(pg, &nums[i]);\n        v_current_min = svmin_s64_z(pg, svadd_s64_z(pg, v_current_min, v_nums), v_nums);\n        v_min_sum = svmin_s64_z(pg, v_min_sum, v_current_min);\n\n        i += vl;\n    } while (svptest_any(svptrue_b64(), pg));\n\n    min_sum = svminv_s64(v_min_sum);\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int64_t min_sum = std::numeric_limits<int64_t>::max();\n    int64_t current_min = 0;\n\n    size_t i = 0;\n    svbool_t pg;\n    svint64_t v_min_sum = svdup_s64(min_sum);\n    svint64_t v_current_min = svdup_s64(current_min);\n\n    do {\n        size_t vl = svcntd();\n        if (i + vl > nums.size()) {\n            vl = nums.size() - i;\n        }\n        pg = svwhilelt_b64(i, nums.size());\n\n        svint64_t v_nums = svld1(pg, &nums[i]);\n        v_current_min = svmin_s64_z(pg, svadd_s64_z(pg, v_current_min, v_nums), v_nums);\n        v_min_sum = svmin_s64_z(pg, v_min_sum, v_current_min);\n\n        i += vl;\n    } while (svptest_any(svptrue_b64(), pg));\n\n    min_sum = svminv_s64(v_min_sum);\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int64_t min_sum = std::numeric_limits<int64_t>::max();\n    int64_t current_min = 0;\n\n    size_t i = 0;\n    svbool_t pg;\n    svint64_t v_min_sum = svdup_s64(min_sum);\n    svint64_t v_current_min = svdup_s64(current_min);\n\n    do {\n        size_t vl = svcntd();\n        if (i + vl > nums.size()) {\n            vl = nums.size() - i;\n        }\n        pg = svwhilelt_b64(i, nums.size());\n\n        svint64_t v_nums = svld1(pg, &nums[i]);\n        v_current_min = svmin_s64_z(pg, svadd_s64_z(pg, v_current_min, v_nums), v_nums);\n        v_min_sum = svmin_s64_z(pg, v_min_sum, v_current_min);\n\n        i += vl;\n    } while (svptest_any(svptrue_b64(), pg));\n\n    min_sum = svminv_s64(v_min_sum);\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    int total_dips = 0;\n    size_t num_rows = grid.size();\n    if (num_rows == 0) return 0;\n    size_t num_cols = grid[0].size();\n    if (num_cols == 0) return 0;\n\n    svbool_t pg = svptrue_b8();\n    svint8_t sv_capacity = svdup_n_s8(capacity);\n\n    for (const auto& row : grid) {\n        const int8_t* row_ptr = reinterpret_cast<const int8_t*>(row.data());\n        size_t col = 0;\n        int row_sum = 0;\n\n        for (; col <= num_cols - svcntb(); col += svcntb()) {\n            svint8_t sv_row = svld1_s8(pg, &row_ptr[col]);\n            svint8_t sv_ones = svcnt_s8_z(pg, sv_row);\n            int ones_count = svaddv_s32_z(pg, sv_cvt_s32_s8_z(pg, sv_ones));\n            row_sum += ones_count;\n        }\n\n        for (; col < num_cols; ++col) {\n            row_sum += row_ptr[col];\n        }\n\n        total_dips += (row_sum + capacity - 1) / capacity;\n    }\n\n    return total_dips;\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    int total_dips = 0;\n    size_t num_rows = grid.size();\n    if (num_rows == 0) return 0;\n    size_t num_cols = grid[0].size();\n    if (num_cols == 0) return 0;\n\n    svbool_t pg = svptrue_b8();\n    svint8_t sv_capacity = svdup_n_s8(capacity);\n\n    for (const auto& row : grid) {\n        const int8_t* row_ptr = reinterpret_cast<const int8_t*>(row.data());\n        size_t col = 0;\n        int row_sum = 0;\n\n        for (; col <= num_cols - svcntb(); col += svcntb()) {\n            svint8_t sv_row = svld1_s8(pg, &row_ptr[col]);\n            svint8_t sv_ones = svcnt_s8_z(pg, sv_row);\n            int ones_count = svaddv_s32_z(pg, sv_cvt_s32_s8_z(pg, sv_ones));\n            row_sum += ones_count;\n        }\n\n        for (; col < num_cols; ++col) {\n            row_sum += row_ptr[col];\n        }\n\n        total_dips += (row_sum + capacity - 1) / capacity;\n    }\n\n    return total_dips;\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    int total_dips = 0;\n    size_t num_rows = grid.size();\n    if (num_rows == 0) return 0;\n    size_t num_cols = grid[0].size();\n    if (num_cols == 0) return 0;\n\n    svbool_t pg = svptrue_b8();\n    svint8_t sv_capacity = svdup_n_s8(capacity);\n\n    for (const auto& row : grid) {\n        const int8_t* row_ptr = reinterpret_cast<const int8_t*>(row.data());\n        size_t col = 0;\n        int row_sum = 0;\n\n        for (; col <= num_cols - svcntb(); col += svcntb()) {\n            svint8_t sv_row = svld1_s8(pg, &row_ptr[col]);\n            svint8_t sv_ones = svcnt_s8_m(svcmpeq_s8(pg, sv_row, svdup_n_s8(1)));\n            int ones_count = svaddv_s32_z(svptrue_b32(), sv_cvt_s32_s8_z(svptrue_b32(), sv_ones));\n            row_sum += ones_count;\n        }\n\n        for (; col < num_cols; ++col) {\n            row_sum += (row_ptr[col] == 1);\n        }\n\n        total_dips += (row_sum + capacity - 1) / capacity;\n    }\n\n    return total_dips;\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    int total_dips = 0;\n    size_t num_rows = grid.size();\n    if (num_rows == 0) return 0;\n    size_t num_cols = grid[0].size();\n    \n    // Calculate the number of elements per vector\n    svbool_t pg = svptrue_b8();\n    size_t vl = svcntb();\n\n    for (size_t row = 0; row < num_rows; ++row) {\n        const int* row_ptr = grid[row].data();\n        size_t col = 0;\n\n        int row_sum = 0;\n        while (col < num_cols) {\n            // Load a vector of elements\n            svuint8_t vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(row_ptr + col));\n            // Sum the elements in the vector\n            int vec_sum = svaddv_u8_z(pg, vec);\n            row_sum += vec_sum;\n            // Move to the next vector\n            col += vl;\n        }\n\n        // Calculate the number of dips for the current row\n        total_dips += (row_sum + capacity - 1) / capacity;\n    }\n\n    return total_dips;\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    int total_dips = 0;\n    size_t num_rows = grid.size();\n    if (num_rows == 0) return 0;\n    size_t num_cols = grid[0].size();\n    \n    // Calculate the number of elements per vector\n    svbool_t pg = svptrue_b8();\n    size_t vl = svcntb();\n\n    for (size_t i = 0; i < num_rows; ++i) {\n        const int* row = grid[i].data();\n        size_t col = 0;\n        int row_sum = 0;\n\n        // Process the row in chunks of 'vl' elements\n        for (; col + vl <= num_cols; col += vl) {\n            svint8_t vec = svld1_s8(pg, reinterpret_cast<const int8_t*>(row + col));\n            svint8_t ones = sveq_s8(pg, vec, svdup_s8(1));\n            int ones_count = svaddv_s32(svptrue_b32(), svcvt_s32_s8_z(svptrue_b32(), ones));\n            row_sum += ones_count;\n        }\n\n        // Process the remaining elements\n        for (; col < num_cols; ++col) {\n            row_sum += (row[col] == 1);\n        }\n\n        // Calculate the number of dips for this row\n        total_dips += (row_sum + capacity - 1) / capacity;\n    }\n\n    return total_dips;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t result = 0;\n    svbool_t pg;\n    svint16_t vec, odds, even_positions, mask;\n    svint64_t sum = svdup_s64(0);\n\n    size_t index = 0;\n    do {\n        pg = svwhilelt_b16(index, lst.size());\n        vec = svld1_s16(pg, lst.data() + index);\n        even_positions = svindex_s16(0, 2);\n        mask = svand_b16(pg, sveq_s16(pg, svand_s16(pg, vec, svdup_s16(1)), svdup_s16(1)));\n        mask = svand_b16(mask, sveq_s16(pg, svreinterpret_s16_b16(svcmpeq_n_b16(pg, svreinterpret_b16_s16(even_positions), index)), svdup_s16(1)));\n        odds = svsel_s16(mask, vec, svdup_s16(0));\n        sum = svadd_s64(sum, svsum_s16_m(svptrue_b64(), odds));\n        index += svcntw();\n    } while (svptest_any(svptrue_b16(), pg));\n\n    return svlastb_s64(sum);\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t result = 0;\n    svbool_t pg;\n    svint16_t vsum = svdup_s16(0);\n    size_t index = 0;\n\n    do {\n        pg = svwhilelt_b16(index, lst.size());\n        svint16_t vec = svld1/pg_s16(pg, &lst[index]);\n        svint16_t even_indices = svindex_s16(0, 2);\n        svint16_t selected = svsel_s16(svcmpeq_s16(pg, svand_s16_z(pg, vec, svdup_s16(1)), svdup_s16(1)), vec, svdup_s16(0));\n        vsum = svadd_s16_m(pg, vsum, selected);\n        index += svcntw();\n    } while (svptest_any(svptrue_b16(), pg));\n\n    int16_t sum_array[svcntw()];\n    svst1_s16(svptrue_b16(), sum_array, vsum);\n    for (size_t i = 0; i < svcntw(); ++i) {\n        result += sum_array[i];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t result = 0;\n    svbool_t pg;\n    svint16_t vsum = svdup_s16(0);\n\n    for (size_t i = 0; i < lst.size(); i += svcntw()) {\n        pg = svwhilelt_b16(i, lst.size());\n        svint16_t vec = svld1_s16(pg, &lst[i]);\n        svint16_t even_idx_vec = svindex_s16(0, 2);\n        svint16_t even_pos_vec = svsel_s16(svcmpeq_s16(pg, svand_s16_z(pg, svindex_s16(0, 1), svdup_s16(1)), svdup_s16(0)), vec, svdup_s16(0));\n        svint16_t odd_elements = svsel_s16(svtst_s16(pg, even_pos_vec, svdup_s16(1)), even_pos_vec, svdup_s16(0));\n        vsum = svadd_s16_m(pg, vsum, odd_elements);\n    }\n\n    result = svaddv_s16(vsum);\n    return result;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t result = 0;\n    svbool_t pg;\n    svint16_t vec, odds, evens, mask, filtered;\n    svint64_t partial_sum;\n\n    // Calculate the number of elements in the vector\n    size_t num_elements = lst.size();\n\n    // Create a predicate for the number of elements\n    pg = svwhilelt_b16(svptrue_b16(), 0, num_elements);\n\n    // Load the vector with data from the list\n    vec = svld1_s16(pg, lst.data());\n\n    // Generate a vector of indices\n    svint16_t indices = svindex_s16_z(pg, 0, 1);\n\n    // Create a mask for even indices\n    evens = sveor_s16_z(pg, indices, svdup_n_s16(1));\n\n    // Mask the vector to keep only even indices\n    vec = svmul_s16_z(pg, vec, evens);\n\n    // Create a mask for odd values\n    odds = sveor_s16_z(pg, vec, svdup_n_s16(1));\n\n    // Mask the vector to keep only odd values at even indices\n    filtered = svmul_s16_z(pg, vec, odds);\n\n    // Sum the filtered vector\n    partial_sum = svaddv_s16(pg, filtered);\n\n    // Extract the result from the partial sum\n    result = svlastb_s64(partial_sum);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t result = 0;\n    svbool_t pg;\n    svint16_t vec, odds, even_positions, mask;\n    svint64_t sum = svdup_s64(0);\n\n    size_t index = 0;\n    do {\n        pg = svwhilelt_b16(index, lst.size());\n        vec = svld1_s16(pg, lst.data() + index);\n        even_positions = svindex_s16(0, 2);\n        mask = svand_b16(pg, sveor_b16(sveq_s16(even_positions, svindex_s16(0, 1)), svmov_b16(sveq_s16(svand_s16(vec, svdup_s16(1)), svdup_s16(1)))));\n        odds = svsel_s16(mask, vec, svdup_s16(0));\n        sum = svadd_s64(sum, svsum_s16_m(svptrue_b64(), odds));\n        index += svcntw();\n    } while (svptest_any(svptrue_b16(), pg));\n\n    return svlastb_s64(sum);\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    svint32_t pg;\n    svint32_t vsum = svdup_s32(0);\n    int i = 0;\n\n    // Process elements in vectorized chunks\n    for (; i <= k - svcntw(); i += svcntw()) {\n        svint32_t vec = svld1_s32(svundef_s32(), &arr[i]);\n        pg = svcmplt_s32_z(svptrue_b32(), vec, 100);\n        vsum = svadd_m_n(svptrue_b32(), vsum, vsum, vec, pg);\n    }\n\n    // Sum up the vector sum\n    sum = svaddv_i32(vsum);\n\n    // Process remaining elements\n    for (; i < k; ++i) {\n        if (arr[i] < 100) {\n            sum += arr[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    svbool_t pg;\n    svint32_t vsum = svdup_s32(0);\n    int i = 0;\n\n    // Process elements in chunks of SVL (Scalable Vector Length)\n    for (; i <= k - SVL_32; i += SVL_32) {\n        svint32_t vec = svld1_s32(svundef_s32(), &arr[i]);\n        svbool_t cond = svcmple_n_s32(svptrue_b32(), vec, 99);\n        vsum = svadd_m_n_s32(vsum, cond, vsum, vec, 0);\n    }\n\n    // Handle remaining elements\n    if (i < k) {\n        pg = svwhilelt_b32(i, k);\n        svint32_t vec = svld1_s32(pg, &arr[i]);\n        svbool_t cond = svcmple_n_s32(pg, vec, 99);\n        vsum = svadd_m_n_s32(vsum, cond, vsum, vec, 0);\n    }\n\n    // Sum up the vector elements\n    sum = svaddv_s32(vsum);\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    svbool_t pg;\n    svint32_t vec, filtered_vec;\n    int i = 0;\n\n    while (i < k) {\n        size_t vl = svcntw();\n        if (i + vl > k) {\n            vl = k - i;\n        }\n        pg = svwhilelt_b32(i, k);\n        vec = svld1(pg, &arr[i]);\n        svbool_t cond = svcmple_n_s32(pg, vec, 99);\n        filtered_vec = svsel_s32(pg, cond, vec, svdup_n_s32(0));\n        sum += svaddv_s32(pg, filtered_vec);\n        i += vl;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    svbool_t pg;\n    svint32_t vec, filtered_vec;\n    int i = 0;\n\n    while (i < k) {\n        // Load up to 16 elements into a vector\n        size_t vl = svcntw();\n        if (i + vl > k) {\n            vl = k - i;\n        }\n        pg = svwhilelt_b32(0, vl);\n        vec = svld1(pg, &arr[i]);\n\n        // Filter elements with at most two digits\n        svint32_t threshold = svdup_n_s32(100);\n        filtered_vec = svmin_s32_z(pg, vec, threshold);\n\n        // Sum the filtered elements\n        sum += svaddv_s32_m(svundef_s32(), pg, filtered_vec);\n\n        i += vl;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint add_elements_simd(const std::vector<int>& arr, int k) {\n    int sum = 0;\n    svint32_t pg;\n    svint32_t vsum = svdup_s32(0);\n    const int* ptr = arr.data();\n\n    // Process elements in chunks of SVL (Scalable Vector Length)\n    while (k > 0) {\n        size_t vl = svcntw();\n        if (k < vl) {\n            vl = k;\n        }\n        pg = svwhilelt_b32(0, vl);\n\n        svint32_t v = svld1(pg, ptr);\n        svbool_t pgtwo_digits = svcmplt_s32(pg, v, svdup_s32(100));\n        vsum = svadd_m_n(svptrue_b32(), vsum, v, pgtwo_digits);\n\n        ptr += vl;\n        k -= vl;\n    }\n\n    // Sum up the vector elements\n    sum = svaddv_i32(vsum);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    if (lst.size() <= 1) {\n        return true;\n    }\n\n    svbool_t pg = svptrue_b32();\n    svint32_t prev = svld1_s32(pg, &lst[0]);\n    bool sorted = true;\n    bool has_duplicates = false;\n\n    for (size_t i = 1; i < lst.size(); i += svcntw()) {\n        size_t elements = svcntw();\n        if (i + elements > lst.size()) {\n            elements = lst.size() - i;\n            pg = svptrue_b32()->base.sv_ptrue_bits(elements);\n        }\n\n        svint32_t curr = svld1_s32(pg, &lst[i]);\n\n        svbool_t lt = svcmplt_s32(pg, prev, curr);\n        svbool_t eq = sveq_s32(pg, prev, curr);\n\n        sorted &= svptest_any(svptrue_b32(), lt);\n        has_duplicates |= svptest_any(svptrue_b32(), eq);\n\n        prev = curr;\n    }\n\n    return sorted && !has_duplicates;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    if (lst.size() <= 1) {\n        return true;\n    }\n\n    svbool_t pg = svptrue_b32();\n    svint32_t prev = svld1_s32(pg, lst.data());\n    bool result = true;\n\n    for (size_t i = 1; i < lst.size(); i += svcntw()) {\n        svint32_t curr = svld1_s32(pg, &lst[i]);\n\n        svbool_t lt = svcmplt_s32(pg, prev, curr);\n        svbool_t eq = sveq_s32(pg, prev, curr);\n\n        if (!svall_s(pg, lt) || svany_s(eq)) {\n            result = false;\n            break;\n        }\n\n        prev = curr;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    if (lst.size() <= 1) {\n        return true;\n    }\n\n    svbool_t pg = svptrue_b32();\n    svint32_t prev = svld1_s32(pg, lst.data());\n    bool result = true;\n\n    for (size_t i = 1; i < lst.size(); i += svcntw()) {\n        svint32_t curr = svld1_s32(pg, lst.data() + i);\n        svbool_t le = svcmple_s32(pg, prev, curr);\n        svbool_t eq = sveq_s32(pg, prev, curr);\n\n        if (!svptest_any(svptrue_b32(), le)) {\n            result = false;\n            break;\n        }\n\n        if (svptest_any(svptrue_b32(), eq)) {\n            svbool_t dup_check = svcmpeq_s32(pg, curr, svext_f32index(svunpklo_f32(svzip1_f32(svreinterpret_f32_s32(curr), svreinterpret_f32_s32(curr))), 1));\n            if (svptest_any(svptrue_b32(), dup_check)) {\n                result = false;\n                break;\n            }\n        }\n\n        prev = curr;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    if (lst.size() <= 1) {\n        return true;\n    }\n\n    svbool_t pg = svptrue_b32();\n    svint32_t prev = svld1_s32(pg, lst.data());\n    bool result = true;\n\n    for (size_t i = 1; i < lst.size(); i += svcntw()) {\n        svint32_t curr = svld1_s32(pg, lst.data() + i);\n        svbool_t lt = svcmplt_s32(pg, prev, curr);\n        svbool_t eq = sveq_s32(pg, prev, curr);\n\n        if (!svall_s(pg, lt) || svany_s(eq)) {\n            result = false;\n            break;\n        }\n\n        prev = curr;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    if (lst.size() <= 1) {\n        return true;\n    }\n\n    svbool_t pg = svptrue_b32();\n    svint32_t prev = svld1_s32(pg, lst.data());\n    bool result = true;\n\n    for (size_t i = 1; i < lst.size(); i += svcntw()) {\n        svint32_t curr = svld1_s32(pg, lst.data() + i);\n        svbool_t le = svcmple_s32(pg, prev, curr);\n        svbool_t eq = sveq_s32(pg, prev, curr);\n\n        if (!svall_b32(pg, le)) {\n            result = false;\n            break;\n        }\n\n        if (svany_b32(eq)) {\n            svbool_t dup_check = svand_b32(pg, eq, svcmpeq_s32(pg, curr, svext_s32(curr, curr, 1)));\n            if (svany_b32(pg, dup_check)) {\n                result = false;\n                break;\n            }\n        }\n\n        prev = curr;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    svbool_t pg = svptrue_b32();\n    svint32_t sum_magnitudes = svdup_s32(0);\n    svint32_t prod_signs = svdup_s32(1);\n\n    for (size_t i = 0; i < arr.size(); i += svcntw()) {\n        size_t vl = svminv_u32(svptrue_b32(), svcntw(), arr.size() - i);\n        svint32_t vec = svld1_s32(pg, arr.data() + i);\n\n        svint32_t magnitudes = svabs_s32_z(pg, vec);\n        sum_magnitudes = svaddv_s32_z(pg, sum_magnitudes, magnitudes);\n\n        svint32_t signs = svcmpne_n_s32_z(pg, vec, 0);\n        signs = svsub_z(pg, signs, svcmpeq_n_s32_z(pg, vec, 0));\n        prod_signs = svmul_z(pg, prod_signs, signs);\n    }\n\n    int total_sum_magnitudes = svaddv_s32_m(svptrue_b32(), sum_magnitudes);\n    int total_prod_signs = svaddv_s32_m(svptrue_b32(), prod_signs);\n\n    return total_sum_magnitudes * total_prod_signs;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    svbool_t pg = svptrue_b32();\n    svint32_t sum_magnitudes = svdup_s32(0);\n    svint32_t prod_signs = svdup_s32(1);\n\n    for (size_t i = 0; i < arr.size(); i += svcntw()) {\n        size_t vl = svcntw() < arr.size() - i ? svcntw() : arr.size() - i;\n        svint32_t vec = svld1_s32(pg, arr.data() + i);\n\n        svint32_t magnitudes = svabs_s32_z(pg, vec);\n        sum_magnitudes = svaddv_s32_z(pg, sum_magnitudes, magnitudes);\n\n        svint32_t signs = svcmpne_n_s32_z(pg, vec, 0);\n        signs = svsub_z(pg, signs, svcmpeq_n_s32_z(pg, vec, 0));\n        prod_signs = svmul_z(pg, prod_signs, signs);\n    }\n\n    int total_sum_magnitudes = svaddv_s32_m(svptrue_b32(), sum_magnitudes);\n    int total_prod_signs = svaddv_s32_m(svptrue_b32(), prod_signs);\n\n    return total_sum_magnitudes * total_prod_signs;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    svbool_t pg = svptrue_b32();\n    svint32_t sum_magnitudes = svdup_s32(0);\n    svint32_t prod_signs = svdup_s32(1);\n\n    for (size_t i = 0; i < arr.size(); i += svcntw()) {\n        size_t vl = svcntw() < arr.size() - i ? svcntw() : arr.size() - i;\n        svint32_t vec = svld1_s32(pg, arr.data() + i);\n\n        svint32_t magnitudes = svabs_s32_z(pg, vec);\n        sum_magnitudes = svaddv_s32_z(pg, sum_magnitudes, magnitudes);\n\n        svint32_t signs = svcmpne_n_s32_z(pg, vec, 0);\n        signs = svsub_z(pg, signs, svcmpeq_n_s32_z(pg, vec, 0));\n        prod_signs = svmul_z(pg, prod_signs, signs);\n    }\n\n    int total_sum_magnitudes = svaddv_s32_m(svptrue_b32(), sum_magnitudes);\n    int total_prod_signs = svaddv_s32_m(svptrue_b32(), prod_signs);\n\n    return total_sum_magnitudes * total_prod_signs;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    svbool_t pg = svptrue_b32();\n    svint32_t sum_magnitudes = svdup_s32(0);\n    svint32_t prod_signs = svdup_s32(1);\n\n    for (size_t i = 0; i < arr.size(); i += svcntw()) {\n        size_t vl = svminv_u32(svptrue_b32(), svcntw(), arr.size() - i);\n        svint32_t vec = svld1_s32(pg, arr.data() + i);\n\n        svint32_t magnitudes = svabs_s32_z(pg, vec);\n        sum_magnitudes = svaddv_s32_z(pg, sum_magnitudes, magnitudes);\n\n        svint32_t signs = svcmpne_n_s32_z(pg, vec, 0);\n        signs = svsub_z(pg, signs, svcmpeq_n_s32_z(pg, vec, 0));\n        prod_signs = svmul_z(pg, prod_signs, signs);\n    }\n\n    int total_sum_magnitudes = svaddv_s32_m(svptrue_b32(), sum_magnitudes);\n    int total_prod_signs = svaddv_s32_m(svptrue_b32(), prod_signs);\n\n    return total_sum_magnitudes * total_prod_signs;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    svbool_t pg = svptrue_b32();\n    svint32_t sum_magnitudes = svdup_s32(0);\n    svint32_t prod_signs = svdup_s32(1);\n\n    for (size_t i = 0; i < arr.size(); i += svcntw()) {\n        size_t vl = svcntw() < arr.size() - i ? svcntw() : arr.size() - i;\n        svint32_t vec = svld1_s32(pg, arr.data() + i);\n\n        svint32_t magnitudes = svabs_s32_z(pg, vec);\n        sum_magnitudes = svaddv_s32_z(pg, sum_magnitudes, magnitudes);\n\n        svint32_t signs = svcmpne_n_s32_z(pg, vec, 0);\n        signs = svsub_z(pg, signs, svcmpeq_n_s32_z(pg, vec, 0));\n        prod_signs = svmul_z(pg, prod_signs, signs);\n    }\n\n    int total_sum_magnitudes = svaddv_s32_m(svptrue_b32(), sum_magnitudes);\n    int total_prod_signs = svaddv_s32_m(svptrue_b32(), prod_signs);\n\n    return total_sum_magnitudes * total_prod_signs;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <climits>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k) {\n    int N = grid.size();\n    std::vector<int> min_path(k, INT_MAX);\n    svint32_t sv_min_path = svdup_s32(INT_MAX);\n    svint32_t sv_current_path[k];\n    for (int i = 0; i < k; ++i) {\n        sv_current_path[i] = svdup_s32(0);\n    }\n\n    for (int start_row = 0; start_row < N; ++start_row) {\n        for (int start_col = 0; start_col < N; ++start_col) {\n            std::vector<int> current_path;\n            current_path.push_back(grid[start_row][start_col]);\n            sv_current_path[0] = svdup_s32(grid[start_row][start_col]);\n\n            for (int step = 1; step < k; ++step) {\n                int current_size = current_path.size();\n                std::vector<int> next_path;\n                svint32_t sv_next_path[current_size * 4];\n\n                for (int i = 0; i < current_size; ++i) {\n                    int row = start_row + (i / N) - (step - 1) / 2;\n                    int col = start_col + (i % N) - (step - 1) % 2;\n                    int count = 0;\n\n                    if (row > 0) {\n                        next_path.push_back(current_path[i] * 1000 + grid[row - 1][col]);\n                        sv_next_path[count++] = svadd_s32(sv_current_path[i], svld1_s32(&grid[row - 1][col]));\n                    }\n                    if (row < N - 1) {\n                        next_path.push_back(current_path[i] * 1000 + grid[row + 1][col]);\n                        sv_next_path[count++] = svadd_s32(sv_current_path[i], svld1_s32(&grid[row + 1][col]));\n                    }\n                    if (col > 0) {\n                        next_path.push_back(current_path[i] * 1000 + grid[row][col - 1]);\n                        sv_next_path[count++] = svadd_s32(sv_current_path[i], svld1_s32(&grid[row][col - 1]));\n                    }\n                    if (col < N - 1) {\n                        next_path.push_back(current_path[i] * 1000 + grid[row][col + 1]);\n                        sv_next_path[count++] = svadd_s32(sv_current_path[i], svld1_s32(&grid[row][col + 1]));\n                    }\n\n                    for (int j = 0; j < count; ++j) {\n                        sv_current_path[i * 4 + j] = sv_next_path[j];\n                    }\n                }\n\n                current_path = next_path;\n            }\n\n            for (int i = 0; i < current_path.size(); ++i) {\n                int value = current_path[i] % 1000;\n                svint32_t sv_value = svdup_s32(value);\n                svbool_t pg = svcmplt_s32(sv_value, sv_min_path);\n                if (svptest_any(svptrue_b32(), pg)) {\n                    min_path = current_path;\n                    sv_min_path = sv_value;\n                }\n            }\n        }\n    }\n\n    for (int i = 0; i < k; ++i) {\n        min_path[i] %= 1000;\n    }\n\n    return min_path;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <climits>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k, INT_MAX);\n    int path[k];\n    \n    auto min_path = [&](int x, int y, int depth) {\n        if (depth == k) {\n            svbool_t pg = svptrue_b32();\n            svint32_t current_path = svld1(pg, path);\n            svint32_t best_path = svld1(pg, result.data());\n            svbool_t is_less = svcmpgt(pg, best_path, current_path);\n            if (svptest_any(svptrue_b32(), is_less)) {\n                for (int i = 0; i < k; ++i) {\n                    result[i] = path[i];\n                }\n            }\n            return;\n        }\n        \n        static const int dx[] = {-1, 1, 0, 0};\n        static const int dy[] = {0, 0, -1, 1};\n        \n        path[depth] = grid[x][y];\n        for (int dir = 0; dir < 4; ++dir) {\n            int nx = x + dx[dir];\n            int ny = y + dy[dir];\n            if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n                min_path(nx, ny, depth + 1);\n            }\n        }\n    };\n    \n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            min_path(i, j, 0);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <climits>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k) {\n    int N = grid.size();\n    std::vector<int> min_path(k, INT_MAX);\n    svint32_t sv_min_path = svdup_s32(INT_MAX);\n    svint32_t sv_current_path[k];\n    for (int i = 0; i < k; ++i) {\n        sv_current_path[i] = svdup_s32(0);\n    }\n\n    for (int start_row = 0; start_row < N; ++start_row) {\n        for (int start_col = 0; start_col < N; ++start_col) {\n            std::vector<int> current_path;\n            current_path.push_back(grid[start_row][start_col]);\n            sv_current_path[0] = svdup_s32(grid[start_row][start_col]);\n\n            for (int step = 1; step < k; ++step) {\n                int current_size = current_path.size();\n                svbool_t pg = svptrue_b32();\n                svint32_t sv_min_next = svdup_s32(INT_MAX);\n\n                for (int i = 0; i < current_size; ++i) {\n                    int row = start_row + (i / N) - (step - 1) / 2;\n                    int col = start_col + (i % N) - (step - 1) / 2;\n\n                    if (row >= 0 && row < N && col >= 0 && col < N) {\n                        svint32_t sv_next = svld1_s32(pg, &grid[row][col]);\n                        sv_min_next = svmin_s32_z(pg, sv_min_next, sv_next);\n                    }\n                }\n\n                sv_current_path[step] = sv_min_next;\n                current_path.push_back(svminv_s32_m(svptrue_b32(), sv_min_next));\n            }\n\n            for (int i = 0; i < k; ++i) {\n                svbool_t pg = svptrue_b32();\n                svint32_t sv_current = svld1_s32(pg, &current_path[i]);\n                svint32_t sv_min = svld1_s32(pg, &min_path[i]);\n                svbool_t cmp = svcmplt_s32(pg, sv_current, sv_min);\n                if (svptest_any(svptrue_b32(), cmp)) {\n                    for (int j = 0; j < k; ++j) {\n                        min_path[j] = current_path[j];\n                    }\n                    break;\n                } else if (svptest_any(svptrue_b32(), svcmeq_s32(pg, sv_current, sv_min))) {\n                    continue;\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n\n    return min_path;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <climits>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k) {\n    int N = grid.size();\n    std::vector<int> min_path(k, INT_MAX);\n    svint32_t sv_min_path = svdup_s32(INT_MAX);\n    svint32_t sv_temp_path[k];\n    for (int i = 0; i < k; ++i) {\n        sv_temp_path[i] = svdup_s32(INT_MAX);\n    }\n\n    for (int start_row = 0; start_row < N; ++start_row) {\n        for (int start_col = 0; start_col < N; ++start_col) {\n            std::vector<int> path;\n            path.push_back(grid[start_row][start_col]);\n            svint32_t sv_current_path[k];\n            sv_current_path[0] = svdup_s32(grid[start_row][start_col]);\n            for (int i = 1; i < k; ++i) {\n                sv_current_path[i] = svdup_s32(INT_MAX);\n            }\n\n            std::vector<std::pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n            std::vector<std::pair<int, int>> next_cells;\n            next_cells.push_back({start_row, start_col});\n\n            for (int step = 1; step < k; ++step) {\n                std::vector<std::pair<int, int>> current_cells = next_cells;\n                next_cells.clear();\n\n                for (const auto& [row, col] : current_cells) {\n                    for (const auto& [dr, dc] : directions) {\n                        int new_row = row + dr;\n                        int new_col = col + dc;\n                        if (new_row >= 0 && new_row < N && new_col >= 0 && new_col < N) {\n                            next_cells.push_back({new_row, new_col});\n                            svint32_t sv_new_value = svdup_s32(grid[new_row][new_col]);\n                            sv_current_path[step] = svmin_s32(sv_current_path[step], sv_new_value);\n                        }\n                    }\n                }\n            }\n\n            for (int i = 0; i < k; ++i) {\n                sv_min_path = svmin_s32(sv_min_path, sv_current_path[i]);\n            }\n        }\n    }\n\n    int min_path_array[k];\n    svst1_s32(min_path_array, sv_min_path);\n\n    for (int i = 0; i < k; ++i) {\n        min_path[i] = min_path_array[i];\n    }\n\n    return min_path;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <climits>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k, INT_MAX);\n    int path[k];\n    \n    auto min_path = [&](int x, int y, int depth) {\n        if (depth == k) {\n            svbool_t pg = svptrue_b32();\n            svint32_t sv_result = svld1(pg, result.data());\n            svint32_t sv_path = svld1(pg, path);\n            svbool_t cmp = svcmplt(pg, sv_path, sv_result);\n            if (svptest_any(svptrue_b32(), cmp)) {\n                svst1(pg, result.data(), sv_path);\n            }\n            return;\n        }\n        \n        static const int dx[] = {-1, 1, 0, 0};\n        static const int dy[] = {0, 0, -1, 1};\n        \n        path[depth] = grid[x][y];\n        for (int dir = 0; dir < 4; ++dir) {\n            int nx = x + dx[dir];\n            int ny = y + dy[dir];\n            if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n                min_path(nx, ny, depth + 1);\n            }\n        }\n    };\n    \n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            min_path(i, j, 0);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t digits_simd(uint64_t n) {\n    uint64_t result = 1;\n    uint64_t has_odd = 0;\n\n    while (n > 0) {\n        uint64_t digit = n % 10;\n        n /= 10;\n\n        svuint64_t vec_digit = svdup_u64(digit);\n        svuint64_t vec_one = svdup_u64(1);\n        svuint64_t vec_zero = svdup_u64(0);\n        svuint64_t vec_two = svdup_u64(2);\n\n        svbool_t pg = svptrue_b64();\n        svuint64_t vec_odd_check = svand_z(pg, svcgt_z(pg, vec_digit, vec_zero), svcmpeq_z(pg, svand_z(pg, vec_digit, vec_two), vec_zero));\n        svuint64_t vec_result = svmul_z(pg, svdup_u64(result), svsel_z(pg, vec_odd_check, vec_digit, vec_one));\n\n        result = svlastb_u64(vec_result);\n        has_odd |= svlastb_u64(svsel_z(pg, vec_odd_check, vec_one, vec_zero));\n    }\n\n    return has_odd ? result : 0;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t digits_simd(uint64_t n) {\n    uint64_t result = 1;\n    uint64_t has_odd = 0;\n\n    while (n > 0) {\n        uint64_t digit = n % 10;\n        n /= 10;\n\n        svuint64_t vec_digit = svdup_u64(digit);\n        svuint64_t vec_one = svdup_u64(1);\n        svuint64_t vec_zero = svdup_u64(0);\n        svuint64_t vec_two = svdup_u64(2);\n\n        svbool_t pg = svptrue_b64();\n        svuint64_t vec_odd_check = svand_z(pg, svcgt_z(pg, vec_digit, vec_zero), svnot_z(pg, sveor_z(pg, vec_digit, vec_two)));\n\n        result = svmad_z(pg, svdup_u64(result), vec_digit, vec_one);\n        has_odd = svorr_z(pg, svdup_u64(has_odd), svand_z(pg, vec_odd_check, vec_one));\n    }\n\n    return svptest_any(svptrue_b64(), svreinterpret_u64_b64(svcmpeq_n_u64(svptrue_b64(), svdup_u64(has_odd), svdup_u64(0)))) ? 0 : result;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t digits_simd(uint64_t n) {\n    uint64_t result = 1;\n    uint64_t has_odd = 0;\n\n    while (n > 0) {\n        uint64_t digit = n % 10;\n        n /= 10;\n\n        svuint64_t vec_digit = svdup_u64(digit);\n        svuint64_t vec_one = svdup_u64(1);\n        svuint64_t vec_zero = svdup_u64(0);\n        svuint64_t vec_two = svdup_u64(2);\n\n        svbool_t pg = svptrue_b64();\n        svuint64_t vec_odd_check = svand_z(pg, svcgt_z(pg, vec_digit, vec_zero), svcmpeq_z(pg, svand_z(pg, vec_digit, vec_two), vec_zero));\n        svuint64_t vec_result = svmul_z(pg, svdup_u64(result), svsel_z(pg, vec_odd_check, vec_digit, vec_one));\n        result = svlastb_u64(vec_result);\n\n        has_odd |= svlastb_u64(svsel_z(pg, vec_odd_check, vec_one, vec_zero));\n    }\n\n    return has_odd ? result : 0;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t digits_simd(uint64_t n) {\n    uint64_t result = 1;\n    uint64_t has_odd = 0;\n\n    while (n > 0) {\n        uint64_t digit = n % 10;\n        n /= 10;\n\n        svuint64_t vec_digit = svdup_u64(digit);\n        svuint64_t vec_one = svdup_u64(1);\n        svuint64_t vec_zero = svdup_u64(0);\n        svuint64_t vec_two = svdup_u64(2);\n\n        svbool_t pg = svptrue_b64();\n        svuint64_t vec_odd_check = svand_z(pg, svcgt_z(pg, vec_digit, vec_zero), svnot_z(pg, sveor_z(pg, vec_digit, vec_two)));\n\n        result = svmad_z(pg, svdup_u64(result), vec_digit, vec_one);\n        has_odd = svorr_z(pg, svdup_u64(has_odd), svand_z(pg, svdup_u64(1), svreinterpret_u64_b64(vec_odd_check)));\n    }\n\n    return has_odd ? result : 0;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t digits_simd(uint64_t n) {\n    uint64_t result = 1;\n    uint64_t has_odd = 0;\n\n    while (n > 0) {\n        uint64_t digit = n % 10;\n        n /= 10;\n\n        svuint64_t vec_digit = svdup_u64(digit);\n        svuint64_t vec_one = svdup_u64(1);\n        svuint64_t vec_zero = svdup_u64(0);\n        svuint64_t vec_two = svdup_u64(2);\n\n        svbool_t pg = svptrue_b64();\n        svuint64_t vec_odd_check = svand_z(pg, svcgt_z(pg, vec_digit, vec_zero), svcmpeq_z(pg, svand_z(pg, vec_digit, vec_two), vec_zero));\n        svuint64_t vec_result = svmul_z(pg, svdup_u64(result), svsel_z(pg, vec_odd_check, vec_digit, vec_one));\n        result = svlastb_u64(vec_result);\n\n        has_odd |= svlastb_u64(svsel_z(pg, vec_odd_check, vec_one, vec_zero));\n    }\n\n    return has_odd ? result : 0;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cmath>\n#include <vector>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t result = 0;\n    size_t i = 0;\n    svbool_t pg;\n\n    // Process the vector in chunks of SV_FLOAT_SIZE elements\n    for (; i <= lst.size() - SV_FLOAT_SIZE; i += SV_FLOAT_SIZE) {\n        // Load the vector\n        svfloat32_t vec = svld1_f32(svundef_b32(), &lst[i]);\n\n        // Apply ceiling to each element\n        vec = svceil_f32_z(pg, vec);\n\n        // Square each element\n        vec = svmul_f32_z(pg, vec, vec);\n\n        // Sum the elements of the vector\n        result += svaddl_u32_z(pg, svdup_u32(0), svcvt_u32_f32_z(pg, vec));\n    }\n\n    // Handle the remaining elements\n    for (; i < lst.size(); ++i) {\n        int32_t ceil_val = static_cast<int32_t>(std::ceil(lst[i]));\n        result += ceil_val * ceil_val;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cmath>\n#include <vector>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    size_t i = 0;\n    svbool_t pg;\n\n    // Process elements in chunks of SV_FLOAT_SIZE\n    for (; i <= lst.size() - SV_FLOAT_SIZE; i += SV_FLOAT_SIZE) {\n        svfloat32_t vec = svld1_f32(svundef_b32(), &lst[i]);\n        svfloat32_t ceil_vec = svrintp_f32_x(pg, vec);\n        svfloat32_t square_vec = svmul_f32_z(pg, ceil_vec, ceil_vec);\n        sum += svaddl_u32_z(pg, sum, svcvt_u32_f32_z(pg, square_vec));\n    }\n\n    // Handle remaining elements\n    for (; i < lst.size(); ++i) {\n        int64_t ceil_val = static_cast<int64_t>(std::ceil(lst[i]));\n        sum += ceil_val * ceil_val;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cmath>\n#include <vector>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    size_t i = 0;\n    svbool_t pg;\n\n    // Process elements in chunks of SV_FLOAT_F32\n    for (; i <= lst.size() - svcntw(); i += svcntw()) {\n        pg = svptrue_b32();\n        svfloat32_t vec = svld1_f32(pg, &lst[i]);\n        svfloat32_t ceil_vec = svceil_f32_x(pg, vec);\n        svfloat32_t square_vec = svmul_f32_m(pg, ceil_vec, ceil_vec);\n        svint64_t int_square_vec = svcvt_s64_f32_z(pg, square_vec);\n        sum += svaddl_u64(svptrue_b64(), int_square_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < lst.size(); ++i) {\n        int64_t ceil_val = static_cast<int64_t>(std::ceil(lst[i]));\n        sum += ceil_val * ceil_val;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cmath>\n#include <vector>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t result = 0;\n    size_t i = 0;\n    svbool_t pg;\n\n    // Process elements in chunks of SV_FLOAT_SIZE\n    for (; i <= lst.size() - SV_FLOAT_SIZE; i += SV_FLOAT_SIZE) {\n        svfloat32_t vec = svld1_f32(svundef_b32(), &lst[i]);\n        svfloat32_t ceil_vec = svrintp_f32_x(pg, vec);\n        svfloat32_t square_vec = svmul_f32_z(pg, ceil_vec, ceil_vec);\n        svint64_t sum_vec = svaddl_s32_z(svptrue_b64(), svreinterpret_s32_f32(square_vec), svreinterpret_s32_f32(square_vec));\n        result += svaddv_u64(svptrue_b64(), svreinterpret_u64_s64(sum_vec));\n    }\n\n    // Handle remaining elements\n    for (; i < lst.size(); ++i) {\n        int64_t ceil_val = static_cast<int64_t>(std::ceil(lst[i]));\n        result += ceil_val * ceil_val;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cmath>\n#include <vector>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t result = 0;\n    size_t i = 0;\n    svbool_t pg;\n\n    // Process the vector in chunks of SV_FLOAT_SIZE elements\n    for (; i <= lst.size() - SV_FLOAT_SIZE; i += SV_FLOAT_SIZE) {\n        // Load the vector\n        svfloat32_t vec = svld1_f32(svundef_b32(), &lst[i]);\n\n        // Apply ceiling to each element\n        vec = svceil_f32_z(pg, vec);\n\n        // Square each element\n        vec = svmul_f32_z(pg, vec, vec);\n\n        // Sum the elements of the vector\n        result += svaddv_u64_z(pg, svcvt_u64_f32_z(pg, vec));\n    }\n\n    // Handle the remaining elements\n    for (; i < lst.size(); ++i) {\n        int64_t ceil_val = static_cast<int64_t>(std::ceil(lst[i]));\n        result += ceil_val * ceil_val;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n < 2) return -1;\n\n    svbool_t pg = svptrue_b32();\n    svint32_t prev = svld1_s32(pg, arr.data());\n    int result = -1;\n\n    for (int i = 1; i < n; i += svcntw()) {\n        svint32_t curr = svld1_s32(pg, arr.data() + i);\n        svbool_t cmp = svcmplt_s32(pg, curr, prev);\n        int idx = svlastb_i_s32(cmp);\n        if (idx != -1) {\n            result = i + idx;\n        }\n        prev = curr;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n < 2) return -1;\n\n    svbool_t pg = svptrue_b32();\n    svint32_t prev = svld1_s32(pg, arr.data());\n    int result = -1;\n\n    for (int i = 1; i < n; i += svcntw()) {\n        svint32_t curr = svld1_s32(pg, arr.data() + i);\n        svbool_t cmp = svcmplt_s32(pg, curr, prev);\n        svint32_t idx = svindex_s32_z(pg, i, 1);\n        svint32_t max_idx = svmaxv_s32_m(svwhilelt_b32(i, n), cmp, idx, -1);\n        result = std::max(result, svlastb_s32(max_idx));\n        prev = curr;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n < 2) return -1;\n\n    svbool_t pg = svptrue_b32();\n    svint32_t prev = svld1_s32(pg, arr.data());\n    int result = -1;\n\n    for (int i = 1; i < n; i += svcntw()) {\n        svint32_t curr = svld1_s32(pg, arr.data() + i);\n        svbool_t cmp = svcmplt_s32(pg, curr, prev);\n        svint32_t idx = svindex_s32_z(pg, i, 1);\n        svint32_t max_idx = svmaxv_s32_m(pg, cmp, idx, -1);\n        result = std::max(result, svlastb_s32(cmp) ? svlast_s32(max_idx) : -1);\n        prev = curr;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n < 2) return -1;\n\n    svbool_t pg = svptrue_b32();\n    svint32_t prev = svld1_s32(pg, arr.data());\n    int result = -1;\n\n    for (int i = 1; i < n; i += svcntw()) {\n        svint32_t curr = svld1_s32(pg, arr.data() + i);\n        svbool_t cmp = svcmplt_s32(pg, curr, prev);\n        int idx = svlastb_i_s32(cmp);\n        if (idx != -1) {\n            result = i + idx;\n        }\n        prev = curr;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n < 2) return -1;\n\n    svbool_t pg = svptrue_b32();\n    svint32_t prev = svld1_s32(pg, arr.data());\n    int result = -1;\n\n    for (int i = 1; i < n; i += svcntw()) {\n        svint32_t curr = svld1_s32(pg, arr.data() + i);\n        svbool_t cmp = svcmplt_s32(pg, curr, prev);\n        svint32_t idx = svindex_s32_z(pg, i, 1);\n        svint32_t max_idx = svmaxv_s32_m(pg, cmp, idx, -1);\n        result = std::max(result, svlastb_s32(cmp) ? svlast_s32(max_idx) : -1);\n        prev = curr;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    int64_t largest_negative = std::numeric_limits<int64_t>::min();\n    int64_t smallest_positive = std::numeric_limits<int64_t>::max();\n\n    svbool_t pg = svptrue_b32();\n    svint32_t largest_neg_vec = svdup_n_s32(static_cast<int32_t>(largest_negative));\n    svint32_t smallest_pos_vec = svdup_n_s32(static_cast<int32_t>(smallest_positive));\n\n    const int *ptr = lst.data();\n    size_t count = lst.size();\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec = svld1_s32(pg, ptr);\n\n        svbool_t neg_mask = svcmplt_s32(pg, vec, svdup_n_s32(0));\n        svbool_t pos_mask = svcmpgt_s32(pg, vec, svdup_n_s32(0));\n\n        largest_neg_vec = svsel_s32(neg_mask, svmax_s32_z(neg_mask, largest_neg_vec, vec), largest_neg_vec);\n        smallest_pos_vec = svsel_s32(pos_mask, svmin_s32_z(pos_mask, smallest_pos_vec, vec), smallest_pos_vec);\n\n        ptr += svcntw();\n        count -= svcntw();\n        pg = svwhilelt_b32(0, count);\n    }\n\n    int32_t largest_neg = svmaxv_s32_m(svptrue_b32(), largest_neg_vec);\n    int32_t smallest_pos = svminv_s32_m(svptrue_b32(), smallest_pos_vec);\n\n    if (largest_neg == static_cast<int32_t>(largest_negative)) {\n        largest_neg = 0;\n    }\n    if (smallest_pos == static_cast<int32_t>(smallest_positive)) {\n        smallest_pos = 0;\n    }\n\n    return {largest_neg, smallest_pos};\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    int64_t largest_negative = std::numeric_limits<int64_t>::min();\n    int64_t smallest_positive = std::numeric_limits<int64_t>::max();\n\n    svbool_t pg = svptrue_b32();\n    svint32_t largest_neg_vec = svdup_n_s32(largest_negative);\n    svint32_t smallest_pos_vec = svdup_n_s32(smallest_positive);\n\n    const int *ptr = lst.data();\n    size_t count = lst.size();\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec = svld1_s32(pg, ptr);\n\n        svbool_t neg_mask = svcmplt_s32(pg, vec, svdup_n_s32(0));\n        svbool_t pos_mask = svcmpgt_s32(pg, vec, svdup_n_s32(0));\n\n        largest_neg_vec = svsel_s32(neg_mask, svmax_s32_z(pg, largest_neg_vec, vec), largest_neg_vec);\n        smallest_pos_vec = svsel_s32(pos_mask, svmin_s32_z(pg, smallest_pos_vec, vec), smallest_pos_vec);\n\n        ptr += svcntw();\n        count -= svcntw();\n        pg = svwhilelt_b32(0, count);\n    }\n\n    int32_t result_largest_neg = svmaxv_s32_m(svptrue_b32(), largest_neg_vec);\n    int32_t result_smallest_pos = svminv_s32_m(svptrue_b32(), smallest_pos_vec);\n\n    if (result_largest_neg == largest_negative) {\n        result_largest_neg = 0;\n    }\n    if (result_smallest_pos == smallest_positive) {\n        result_smallest_pos = 0;\n    }\n\n    return {result_largest_neg, result_smallest_pos};\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    int64_t largest_negative = std::numeric_limits<int64_t>::min();\n    int64_t smallest_positive = std::numeric_limits<int64_t>::max();\n\n    svbool_t pg = svptrue_b32();\n    svint32_t largest_neg_vec = svdup_n_s32(largest_negative);\n    svint32_t smallest_pos_vec = svdup_n_s32(smallest_positive);\n\n    const int *ptr = lst.data();\n    size_t count = lst.size();\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec = svld1_s32(pg, ptr);\n        svbool_t neg_mask = svcmplt_s32(pg, vec, svdup_n_s32(0));\n        svbool_t pos_mask = svcmpgt_s32(pg, vec, svdup_n_s32(0));\n\n        largest_neg_vec = svsel_s32(neg_mask, svmax_s32_z(pg, largest_neg_vec, vec), largest_neg_vec);\n        smallest_pos_vec = svsel_s32(pos_mask, svmin_s32_z(pg, smallest_pos_vec, vec), smallest_pos_vec);\n\n        ptr += svcntw();\n        count -= svcntw();\n        pg = svwhilelt_b32(0, count);\n    }\n\n    int32_t result_largest_neg = svmaxv_s32_m(svptrue_b32(), largest_neg_vec);\n    int32_t result_smallest_pos = svminv_s32_m(svptrue_b32(), smallest_pos_vec);\n\n    if (result_largest_neg == largest_negative) {\n        result_largest_neg = 0;\n    }\n    if (result_smallest_pos == smallest_positive) {\n        result_smallest_pos = 0;\n    }\n\n    return {result_largest_neg, result_smallest_pos};\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    int64_t largest_negative = std::numeric_limits<int64_t>::min();\n    int64_t smallest_positive = std::numeric_limits<int64_t>::max();\n\n    svbool_t pg = svptrue_b32();\n    svint32_t largest_neg_vec = svdup_n_s32(static_cast<int32_t>(largest_negative));\n    svint32_t smallest_pos_vec = svdup_n_s32(static_cast<int32_t>(smallest_positive));\n\n    const int *ptr = lst.data();\n    size_t count = lst.size();\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec = svld1_s32(pg, ptr);\n\n        svbool_t neg_mask = svcmplt_s32(pg, vec, svdup_n_s32(0));\n        svbool_t pos_mask = svcmpgt_s32(pg, vec, svdup_n_s32(0));\n\n        largest_neg_vec = svsel_s32(neg_mask, svmax_s32_z(neg_mask, largest_neg_vec, vec), largest_neg_vec);\n        smallest_pos_vec = svsel_s32(pos_mask, svmin_s32_z(pos_mask, smallest_pos_vec, vec), smallest_pos_vec);\n\n        ptr += svcntw();\n        count -= svcntw();\n        pg = svwhilelt_b32(0, count);\n    }\n\n    int32_t result_largest_neg = svmaxv_s32_m(svptrue_b32(), largest_neg_vec, static_cast<int32_t>(largest_negative));\n    int32_t result_smallest_pos = svminv_s32_m(svptrue_b32(), smallest_pos_vec, static_cast<int32_t>(smallest_positive));\n\n    if (result_largest_neg == static_cast<int32_t>(largest_negative)) {\n        result_largest_neg = 0;\n    }\n    if (result_smallest_pos == static_cast<int32_t>(smallest_positive)) {\n        result_smallest_pos = 0;\n    }\n\n    return {result_largest_neg, result_smallest_pos};\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    int64_t largest_negative = std::numeric_limits<int64_t>::min();\n    int64_t smallest_positive = std::numeric_limits<int64_t>::max();\n\n    svbool_t pg = svptrue_b32();\n    svint32_t largest_neg_vec = svdup_n_s32(static_cast<int32_t>(largest_negative));\n    svint32_t smallest_pos_vec = svdup_n_s32(static_cast<int32_t>(smallest_positive));\n\n    size_t i = 0;\n    for (; i <= lst.size() - svcntw(); i += svcntw()) {\n        svint32_t vec = svld1_s32(pg, &lst[i]);\n        svbool_t neg_mask = svcmplt_s32(pg, vec, svdup_n_s32(0));\n        svbool_t pos_mask = svcmpgt_s32(pg, vec, svdup_n_s32(0));\n\n        largest_neg_vec = svsel_s32(neg_mask, svmax_s32_z(pg, largest_neg_vec, vec), largest_neg_vec);\n        smallest_pos_vec = svsel_s32(pos_mask, svmin_s32_z(pg, smallest_pos_vec, vec), smallest_pos_vec);\n    }\n\n    int32_t largest_neg_arr[svcntw()];\n    int32_t smallest_pos_arr[svcntw()];\n    svst1_s32(pg, largest_neg_arr, largest_neg_vec);\n    svst1_s32(pg, smallest_pos_arr, smallest_pos_vec);\n\n    for (size_t j = 0; j < svcntw(); ++j) {\n        if (largest_neg_arr[j] > largest_negative && largest_neg_arr[j] < 0) {\n            largest_negative = largest_neg_arr[j];\n        }\n        if (smallest_pos_arr[j] < smallest_positive && smallest_pos_arr[j] > 0) {\n            smallest_positive = smallest_pos_arr[j];\n        }\n    }\n\n    for (; i < lst.size(); ++i) {\n        if (lst[i] < 0 && lst[i] > largest_negative) {\n            largest_negative = lst[i];\n        }\n        if (lst[i] > 0 && lst[i] < smallest_positive) {\n            smallest_positive = lst[i];\n        }\n    }\n\n    if (largest_negative == std::numeric_limits<int64_t>::min()) {\n        largest_negative = 0;\n    }\n    if (smallest_positive == std::numeric_limits<int64_t>::max()) {\n        smallest_positive = 0;\n    }\n\n    return {static_cast<int>(largest_negative), static_cast<int>(smallest_positive)};\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t special_factorial_simd(uint64_t n) {\n    uint64_t result = 1;\n    svbool_t pg;\n    svuint64_t v_result = svdup_u64(1);\n    svuint64_t v_n = svdup_u64(n);\n    svuint64_t v_i = svindex_u64(1, 1);\n\n    do {\n        pg = svwhilelt_u64(svptrue_b64(), v_i, v_n);\n        v_result = svmul_u64_z(pg, v_result, svfactorial_u64_z(pg, v_i));\n        v_i = svadd_u64_z(pg, v_i, svptrue_b64());\n    } while (svptest_any(svptrue_b64(), pg));\n\n    svuint64_t v_sum = svaddv_u64(svptrue_b64(), v_result);\n    return v_sum;\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t special_factorial_simd(uint64_t n) {\n    uint64_t result = 1;\n    svbool_t pg;\n    svuint64_t v_result = svdup_u64(1);\n    svuint64_t v_n = svdup_u64(n);\n    svuint64_t v_i = svindex_u64(1, 1);\n\n    while (svany(svcmpgt(pg, v_n, v_i))) {\n        pg = svcmpgt(pg, v_n, v_i);\n        v_result = svmul_u64_z(pg, v_result, svfactorial_u64_z(pg, v_i));\n        v_i = svadd_u64_z(pg, v_i, svdup_u64(1));\n    }\n\n    svuint64_t v_sum = svaddv_u64(v_result);\n    return v_sum;\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t special_factorial_simd(uint64_t n) {\n    uint64_t result = 1;\n    svbool_t pg;\n    svuint64_t v_result = svdup_u64(1);\n    svuint64_t v_n = svdup_u64(n);\n    svuint64_t v_i = svindex_u64(1, 1);\n\n    do {\n        pg = svwhilelt_u64(svptrue_b64(), v_i, v_n);\n        v_result = svmul_u64_z(pg, v_result, svfactorial_u64_z(pg, v_i));\n        v_i = svadd_u64_z(pg, v_i, svptrue_b64());\n    } while (svptest_any(svptrue_b64(), pg));\n\n    svuint64_t v_sum = svaddv_u64(svptrue_b64(), v_result);\n    return v_sum;\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t special_factorial_simd(uint64_t n) {\n    uint64_t result = 1;\n    svbool_t pg;\n    svuint64_t v_result = svdup_u64(1);\n    svuint64_t v_n = svdup_u64(n);\n    svuint64_t v_i = svindex_u64(1, 1);\n\n    do {\n        pg = svwhilelt_u64(svptrue_b64(), v_i, v_n);\n        v_result = svmul_u64_z(pg, v_result, svfactorial_u64_z(pg, v_i));\n        v_i = svadd_u64_z(pg, v_i, svdup_u64(1));\n    } while (svptest_any(svptrue_b64(), pg));\n\n    svuint64_t v_sum = svaddv_u64(svptrue_b64(), v_result);\n    return v_sum;\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t special_factorial_simd(uint64_t n) {\n    uint64_t result = 1;\n    svbool_t pg;\n    svuint64_t v_result = svdup_u64(1);\n    svuint64_t v_n = svdup_u64(n);\n    svuint64_t v_i = svindex_u64(1, 1);\n\n    while (svany(svcmpgt(svsub_u64(v_n, v_i), svdup_u64(0)))) {\n        pg = svcmpgt(svsub_u64(v_n, v_i), svdup_u64(0));\n        v_result = svmul_u64_z(pg, v_result, svfac_u64_z(pg, v_i));\n        v_i = svadd_u64_z(pg, v_i, svdup_u64(1));\n    }\n\n    svuint64_t v_sum = svaddv_u64(v_result);\n    return v_sum;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    int sum = 0;\n    size_t n = lst.size();\n    const int *ptr = lst.data();\n\n    svbool_t pg;\n    svint32_t vsum = svdup_s32(0);\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        pg = svwhilelt_b32(i, n);\n        svint32_t v = svld1_s32(pg, ptr + i);\n\n        svint32_t index = svindex_s32(svdup_s32(i), 1);\n        svbool_t multiple_of_3 = svcmpeq_n_s32(pg, svand_n_s32(pg, index, 3), 0);\n        svbool_t multiple_of_4_not_3 = svcmpeq_n_s32(pg, svand_n_s32(pg, index, 4), 0) && !svcmpeq_n_s32(pg, svand_n_s32(pg, index, 3), 0);\n\n        svint32_t squared = svmul_s32_z(pg, multiple_of_3, v, v);\n        svint32_t cubed = svmul_s32_z(pg, multiple_of_4_not_3, svmul_s32_z(pg, multiple_of_4_not_3, v, v), v);\n\n        v = svsel_s32(pg, svsel_s32(pg, multiple_of_3, squared, v), cubed);\n        vsum = svadd_s32_m(pg, vsum, v);\n    }\n\n    sum = svaddv_s32(vsum);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    int sum = 0;\n    size_t n = lst.size();\n    const int *ptr = lst.data();\n\n    svbool_t pg;\n    svint32_t vsum = svdup_s32(0);\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        pg = svwhilelt_b32(i, n);\n        svint32_t v = svld1_s32(pg, ptr + i);\n\n        svint32_t index = svindex_s32(svdup_s32(i), 1);\n        svbool_t multiple_of_3 = svcmpeq_n_s32(pg, svand_n_s32(pg, index, 3), 0);\n        svbool_t multiple_of_4_not_3 = svcmpeq_n_s32(pg, svand_n_s32(pg, index, 4), 0) && svcmpne_n_s32(pg, svand_n_s32(pg, index, 3), 0);\n\n        svint32_t squared = svmul_s32_z(pg, multiple_of_3, v, v);\n        svint32_t cubed = svmul_s32_z(pg, multiple_of_4_not_3, svmul_s32_z(pg, multiple_of_4_not_3, v, v), v);\n\n        v = svsel_s32(pg, svsel_s32(pg, multiple_of_3, squared, v), cubed);\n        vsum = svadd_s32_m(pg, vsum, v);\n    }\n\n    sum = svaddv_s32(vsum);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    int sum = 0;\n    size_t n = lst.size();\n    const int *data = lst.data();\n\n    svbool_t pg;\n    svint32_t vsum = svdup_s32(0);\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        pg = svwhilelt_b32(i, n);\n        svint32_t v = svld1_s32(pg, &data[i]);\n\n        svint32_t index = svindex_s32(svdup_s32(i), 1);\n        svbool_t multiple_of_3 = svcmpeq_n_s32(pg, svand_n_s32(pg, index, 3), 0);\n        svbool_t multiple_of_4_not_3 = svcmpeq_n_s32(pg, svand_n_s32(pg, index, 4), 0) && !svcmpeq_n_s32(pg, svand_n_s32(pg, index, 3), 0);\n\n        svint32_t squared = svmul_s32_z(pg, multiple_of_3, v, v);\n        svint32_t cubed = svmul_s32_z(pg, multiple_of_4_not_3, squared, v);\n\n        v = svsel_s32(pg, cubed, v);\n        v = svsel_s32(pg, squared, v);\n\n        vsum = svadd_s32_m(pg, vsum, v);\n    }\n\n    sum = svaddv_s32(vsum);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    int sum = 0;\n    size_t n = lst.size();\n    const int *ptr = lst.data();\n\n    svbool_t pg;\n    svint32_t vsum = svdup_s32(0);\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        pg = svwhilelt_b32(i, n);\n        svint32_t v = svld1_s32(pg, ptr + i);\n\n        svint32_t index = svindex_s32(svdup_s32(i), 1);\n        svbool_t multiple_of_3 = svcmpeq_n_s32(pg, svand_n_s32(pg, index, 3), 0);\n        svbool_t multiple_of_4_not_3 = svcmpeq_n_s32(pg, svand_n_s32(pg, index, 4), 0) && svcmpne_n_s32(pg, svand_n_s32(pg, index, 3), 0);\n\n        svint32_t squared = svmul_s32_z(pg, multiple_of_3, v, v);\n        svint32_t cubed = svmul_s32_z(pg, multiple_of_4_not_3, svmul_s32_z(pg, multiple_of_4_not_3, v, v), v);\n\n        v = svsel_s32(pg, svsel_s32(pg, multiple_of_3, squared, v), cubed);\n        vsum = svadd_s32_m(pg, vsum, v);\n    }\n\n    sum = svaddv_s32(vsum);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    int sum = 0;\n    size_t n = lst.size();\n    const int *ptr = lst.data();\n\n    svbool_t pg;\n    svint32_t vsum = svdup_s32(0);\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        pg = svwhilelt_b32(i, n);\n        svint32_t v = svld1_s32(pg, ptr + i);\n\n        svint32_t index = svindex_s32(svdup_s32(i), 1);\n        svbool_t multiple_of_3 = svcmpeq_n_s32(pg, svand_n_s32(pg, index, 3), 0);\n        svbool_t multiple_of_4_not_3 = svcmpeq_n_s32(pg, svand_n_s32(pg, index, 4), 0) && svcmpne_n_s32(pg, svand_n_s32(pg, index, 3), 0);\n\n        svint32_t squared = svmul_s32_z(pg, multiple_of_3, v, v);\n        svint32_t cubed = svmul_s32_z(pg, multiple_of_4_not_3, squared, v);\n\n        v = svsel_s32(pg, cubed, v);\n        v = svsel_s32(pg, squared, v);\n\n        vsum = svadd_s32_m(pg, vsum, v);\n    }\n\n    sum = svaddv_s32(vsum);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    svbool_t pg;\n    svint32_t vec, first_digit_odd, last_digit_odd, greater_than_10;\n    int i = 0;\n\n    while (svcntb(pg = svwhilelt_b32(i, nums.size()))) {\n        vec = svld1(pg, &nums[i]);\n\n        greater_than_10 = svcmpgt_s32(pg, vec, svdup_s32(10));\n\n        svint32_t abs_vec = svabs_s32_x(pg, vec);\n        svint32_t last_digit = svand_s32_x(pg, abs_vec, svdup_s32(9));\n        last_digit_odd = svcmpeq_s32(pg, svand_s32_x(pg, last_digit, svdup_s32(1)), svdup_s32(1));\n\n        svint32_t first_digit = abs_vec;\n        do {\n            first_digit = svlsr_n_s32_x(pg, first_digit, 4);\n        } while (svptest_any(svptrue_b32(), svcmpne_s32(pg, first_digit, svdup_s32(0))));\n        first_digit = svand_s32_x(pg, first_digit, svdup_s32(9));\n        first_digit_odd = svcmpeq_s32(pg, svand_s32_x(pg, first_digit, svdup_s32(1)), svdup_s32(1));\n\n        svbool_t condition = svand_b_z(pg, svand_b_z(pg, greater_than_10, first_digit_odd), last_digit_odd);\n\n        count += svcntp_b32(condition);\n\n        i += svcntb(pg);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    svbool_t pg;\n    svint32_t vec, first_digit_odd, last_digit_odd, greater_than_10;\n\n    size_t i = 0;\n    for (; i <= nums.size() - svcntw(); i += svcntw()) {\n        pg = svptrue_b32();\n        vec = svld1(pg, &nums[i]);\n\n        greater_than_10 = svcmpgt(svptrue_b32(), vec, svdup_n_s32(10));\n\n        svint32_t abs_vec = svabs_s32_z(pg, vec);\n        svint32_t last_digit = svand_z(pg, abs_vec, svdup_n_s32(9));\n        last_digit_odd = svcmpeq(svptrue_b32(), svand_z(pg, last_digit, svdup_n_s32(1)), svdup_n_s32(1));\n\n        svint32_t first_digit = abs_vec;\n        do {\n            first_digit = svlsr_z(pg, first_digit, svdup_n_u32(4)); // Shift right by 4 bits (divide by 16)\n            first_digit = svlsr_z(pg, first_digit, svdup_n_u32(2)); // Shift right by 2 bits (divide by 4)\n        } while (svptest_any(svptrue_b32(), svcmpne(svptrue_b32(), first_digit, svdup_n_s32(0))));\n        first_digit_odd = svcmpeq(svptrue_b32(), svand_z(pg, first_digit, svdup_n_s32(1)), svdup_n_s32(1));\n\n        svbool_t result = svand_z(svand_z(pg, greater_than_10, first_digit_odd), last_digit_odd);\n        count += svcntp_b32(result);\n    }\n\n    for (; i < nums.size(); ++i) {\n        int num = nums[i];\n        if (num > 10) {\n            int abs_num = std::abs(num);\n            int last_digit = abs_num % 10;\n            int first_digit = abs_num;\n            while (first_digit >= 10) {\n                first_digit /= 10;\n            }\n            if ((first_digit % 2 != 0) && (last_digit % 2 != 0)) {\n                ++count;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    svbool_t pg;\n    svint32_t vec, first_digit_odd, last_digit_odd, greater_than_10;\n    int i = 0;\n\n    while (svptest_any(svptrue_b32(), pg = svwhilelt_b32(i, nums.size()))) {\n        vec = svld1(pg, nums.data() + i);\n\n        greater_than_10 = svgt_s32(pg, vec, svdup_s32(10));\n\n        svint32_t abs_vec = svabs_s32_x(pg, vec);\n        svint32_t last_digit = svand_s32_x(pg, abs_vec, svdup_s32(9));\n        last_digit_odd = svcmpeq_s32(pg, svand_s32_x(pg, last_digit, svdup_s32(1)), svdup_s32(1));\n\n        svint32_t first_digit = abs_vec;\n        while (svany(svgt_s32(pg, first_digit, svdup_s32(9)))) {\n            first_digit = svlsr_n_s32_x(pg, first_digit, 4);\n        }\n        first_digit_odd = svcmpeq_s32(pg, svand_s32_x(pg, first_digit, svdup_s32(1)), svdup_s32(1));\n\n        svbool_t result = svand_b_z(pg, svand_b_z(pg, greater_than_10, first_digit_odd), last_digit_odd);\n\n        count += svcntp_b32(result);\n\n        i += svcntb();\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    svbool_t pg;\n    svint32_t vec, first_digit_odd, last_digit_odd, greater_than_10;\n\n    size_t i = 0;\n    for (; i <= nums.size() - svcntw(); i += svcntw()) {\n        pg = svptrue_b32();\n        vec = svld1(pg, &nums[i]);\n\n        greater_than_10 = svcmpgt(svptrue_b32(), vec, svdup_n_s32(10));\n\n        svint32_t abs_vec = svabs_s32_z(pg, vec);\n        svint32_t last_digit = svand_s32_z(pg, abs_vec, svdup_n_s32(9));\n        last_digit_odd = svcmpeq(svptrue_b32(), svand_s32_z(pg, last_digit, svdup_n_s32(1)), svdup_n_s32(1));\n\n        svint32_t first_digit = abs_vec;\n        do {\n            first_digit = svlsr_n_s32_z(pg, first_digit, 4);\n        } while (svptest_any(svptrue_b32(), svcmpgt(svptrue_b32(), first_digit, svdup_n_s32(9))));\n        first_digit_odd = svcmpeq(svptrue_b32(), svand_s32_z(pg, first_digit, svdup_n_s32(1)), svdup_n_s32(1));\n\n        svbool_t result = svand_b_z(pg, svand_b_z(pg, greater_than_10, first_digit_odd), last_digit_odd);\n        count += svcntp_b32(result);\n    }\n\n    for (; i < nums.size(); ++i) {\n        int num = nums[i];\n        if (num > 10) {\n            int abs_num = abs(num);\n            int last_digit = abs_num % 10;\n            int first_digit = abs_num;\n            while (first_digit >= 10) {\n                first_digit /= 10;\n            }\n            if ((last_digit % 2 == 1) && (first_digit % 2 == 1)) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    svbool_t pg;\n    svint32_t vec, first_digit_odd, last_digit_odd, greater_than_10;\n    int i = 0;\n\n    while (svptest_any(svptrue_b32(), pg = svwhilelt_b32(i, nums.size()))) {\n        vec = svld1(pg, nums.data() + i);\n\n        greater_than_10 = svcmpgt_s32(pg, vec, svdup_s32(10));\n\n        svint32_t abs_vec = svabs_s32_x(pg, vec);\n        svint32_t last_digit = svand_s32_x(pg, abs_vec, svdup_s32(9));\n        last_digit_odd = svcmpeq_s32(pg, svand_s32_x(pg, last_digit, svdup_s32(1)), svdup_s32(1));\n\n        svint32_t first_digit = abs_vec;\n        while (svptest_any(svptrue_b32(), svcmpgt_s32(pg, first_digit, svdup_s32(9)))) {\n            first_digit = svlsr_n_s32_x(pg, first_digit, 4);\n        }\n        first_digit_odd = svcmpeq_s32(pg, svand_s32_x(pg, first_digit, svdup_s32(1)), svdup_s32(1));\n\n        svbool_t result = svand_b_z(pg, svand_b_z(pg, greater_than_10, first_digit_odd), last_digit_odd);\n        count += svcntp_b32(svptrue_b32(), result);\n\n        i += svcntb();\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t get_max_triples_simd(uint64_t n){\n    uint64_t count = 0;\n    svbool_t pg;\n    svint64_t index, squares, values, mod_values;\n    svint64_t ones = svdup_s64(1);\n    svint64_t threes = svdup_s64(3);\n\n    // Allocate memory for the array\n    int64_t *a = (int64_t *)malloc(n * sizeof(int64_t));\n\n    // Calculate the values of the array in parallel\n    for (uint64_t i = 0; i < n; i += svcntw()) {\n        pg =svptrue_b64();\n        index = svindex_s64(svdup_s64(i), 1);\n        squares = svmul_s64_z(pg, index, index);\n        values = svmls_s64_z(pg, squares, index, ones);\n        svst1_s64(pg, &a[i], values);\n    }\n\n    // Calculate the number of valid triples\n    for (uint64_t i = 0; i < n; i++) {\n        for (uint64_t j = i + 1; j < n; j++) {\n            for (uint64_t k = j + 1; k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    // Free the allocated memory\n    free(a);\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t get_max_triples_simd(uint64_t n){\n    uint64_t count = 0;\n    svbool_t pg;\n    svint64_t index, squares, values, mod3;\n    svint64_t ones = svdup_s64(1);\n    svint64_t threes = svdup_s64(3);\n\n    for (uint64_t i = 0; i < n; i += svcntw()) {\n        pg =svptrue_b64();\n        index = svindex_s64(svdup_s64(i), 1);\n        squares = svmul_s64_z(pg, index, index);\n        values = svmls_s64_z(pg, squares, index, ones);\n        mod3 = svmod_s64_z(pg, values, threes);\n\n        for (uint64_t j = i + 1; j < n; j += svcntw()) {\n            svbool_t pg_j = svptrue_b64();\n            svint64_t index_j = svindex_s64(svdup_s64(j), 1);\n            svint64_t squares_j = svmul_s64_z(pg_j, index_j, index_j);\n            svint64_t values_j = svmls_s64_z(pg_j, squares_j, index_j, ones);\n            svint64_t mod3_j = svmod_s64_z(pg_j, values_j, threes);\n\n            for (uint64_t k = j + 1; k < n; k += svcntw()) {\n                svbool_t pg_k = svptrue_b64();\n                svint64_t index_k = svindex_s64(svdup_s64(k), 1);\n                svint64_t squares_k = svmul_s64_z(pg_k, index_k, index_k);\n                svint64_t values_k = svmls_s64_z(pg_k, squares_k, index_k, ones);\n                svint64_t mod3_k = svmod_s64_z(pg_k, values_k, threes);\n\n                svint64_t sum_mod3 = svadd_s64_z(pg, mod3, mod3_j);\n                sum_mod3 = svadd_s64_z(pg, sum_mod3, mod3_k);\n                sum_mod3 = svmod_s64_z(pg, sum_mod3, threes);\n\n                count += svcntp_b64(svcmpeq_s64(pg, sum_mod3, svdup_s64(0)));\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t get_max_triples_simd(uint64_t n){\n    uint64_t count = 0;\n    svbool_t pg;\n    svint64_t index, squares, values, mod_values;\n    svint64_t ones = svdup_s64(1);\n    svint64_t threes = svdup_s64(3);\n\n    // Allocate memory for the array\n    int64_t *a = (int64_t *)malloc(n * sizeof(int64_t));\n\n    // Calculate the values of the array in parallel\n    for (uint64_t i = 0; i < n; i += svcntw()) {\n        pg =svptrue_b64();\n        index = svindex_s64(svdup_s64(i), 1);\n        squares = svmul_s64_z(pg, index, index);\n        values = svmls_s64_z(pg, squares, index, ones);\n        svst1_s64(pg, &a[i], values);\n    }\n\n    // Calculate the number of valid triples\n    for (uint64_t i = 0; i < n; i++) {\n        for (uint64_t j = i + 1; j < n; j++) {\n            for (uint64_t k = j + 1; k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    // Free allocated memory\n    free(a);\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t get_max_triples_simd(uint64_t n){\n    uint64_t count = 0;\n    svbool_t pg;\n    svint64_t index, squares, values, mod_values;\n    svint64_t ones = svdup_s64(1);\n    svint64_t threes = svdup_s64(3);\n\n    // Allocate memory for the array\n    int64_t *a = (int64_t *)malloc(n * sizeof(int64_t));\n\n    // Calculate the values of the array in parallel\n    for (uint64_t i = 0; i < n; i += svcntw()) {\n        pg =svptrue_b64();\n        index = svindex_s64(svdup_s64(i), 1);\n        squares = svmul_s64_z(pg, index, index);\n        values = svmls_s64_z(pg, squares, index, ones);\n        svst1_s64(pg, &a[i], values);\n    }\n\n    // Calculate the number of valid triples\n    for (uint64_t i = 0; i < n; i++) {\n        for (uint64_t j = i + 1; j < n; j++) {\n            for (uint64_t k = j + 1; k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    // Free allocated memory\n    free(a);\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t get_max_triples_simd(uint64_t n){\n    uint64_t count = 0;\n    svbool_t pg;\n    svint64_t index, squares, values, mod3;\n    svint64_t ones = svdup_s64(1);\n    svint64_t threes = svdup_s64(3);\n\n    for (uint64_t i = 0; i < n; i += svcntw()) {\n        pg =svptrue_b64();\n        index = svindex_s64(svdup_s64(i), 1);\n        squares = svmul_s64_z(pg, index, index);\n        values = svmls_s64_z(pg, squares, index, ones);\n        mod3 = svmod_s64_z(pg, values, threes);\n\n        for (uint64_t j = i + 1; j < n; j += svcntw()) {\n            svbool_t pg_j = svptrue_b64();\n            svint64_t index_j = svindex_s64(svdup_s64(j), 1);\n            svint64_t squares_j = svmul_s64_z(pg_j, index_j, index_j);\n            svint64_t values_j = svmls_s64_z(pg_j, squares_j, index_j, ones);\n            svint64_t mod3_j = svmod_s64_z(pg_j, values_j, threes);\n\n            for (uint64_t k = j + 1; k < n; k += svcntw()) {\n                svbool_t pg_k = svptrue_b64();\n                svint64_t index_k = svindex_s64(svdup_s64(k), 1);\n                svint64_t squares_k = svmul_s64_z(pg_k, index_k, index_k);\n                svint64_t values_k = svmls_s64_z(pg_k, squares_k, index_k, ones);\n                svint64_t mod3_k = svmod_s64_z(pg_k, values_k, threes);\n\n                svint64_t sum_mod3 = svadd_s64_z(pg, mod3, mod3_j);\n                sum_mod3 = svadd_s64_z(pg, sum_mod3, mod3_k);\n                sum_mod3 = svmod_s64_z(pg, sum_mod3, threes);\n\n                count += svcntp_b64(svcmpeq_s64(pg, sum_mod3, svdup_s64(0)));\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint x_or_y_simd(int n, int x, int y) {\n    svbool_t pg = svptrue_b32();\n    svint32_t vn = svdup_n_s32(n);\n    svint32_t vx = svdup_n_s32(x);\n    svint32_t vy = svdup_n_s32(y);\n\n    // Check if n is less than 2 (not prime)\n    svbool_t is_not_prime = svcmplt_s32(pg, vn, svdup_n_s32(2));\n\n    // Check divisibility from 2 to sqrt(n)\n    for (int i = 2; i * i <= n; ++i) {\n        svint32_t vi = svdup_n_s32(i);\n        svbool_t divisible = sveor_b_z(pg, svcmpeq_s32(pg, svmod_s32_z(pg, vn, vi), svdup_n_s32(0)), is_not_prime);\n        is_not_prime = svorr_b_z(pg, is_not_prime, divisible);\n    }\n\n    // Select x if prime, y otherwise\n    svint32_t result = svsel_s32(is_not_prime, vy, vx);\n\n    // Return the first element of the vector result\n    return svlastb_h32(svwhilelt_b32(0, 1), result);\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    svbool_t pg = svptrue_b32();\n    svint32_t vn = svdup_s32(n);\n    svint32_t vx = svdup_s32(x);\n    svint32_t vy = svdup_s32(y);\n\n    // Check if n is less than 2 (not prime)\n    svbool_t is_not_prime = svcmplt_s32(pg, vn, svdup_s32(2));\n\n    // Check divisibility from 2 to sqrt(n)\n    for (int i = 2; i * i <= n; ++i) {\n        svint32_t vi = svdup_s32(i);\n        svbool_t divisible = sveor_b_z(pg, svcmpeq_s32(pg, svmod_s32_z(pg, vn, vi), svdup_s32(0)), is_not_prime);\n        is_not_prime = svorr_b_z(pg, is_not_prime, divisible);\n    }\n\n    // Select x if prime, y otherwise\n    svint32_t result = svsel_s32(is_not_prime, vy, vx);\n\n    // Return the first element of the vector result\n    return svlastb_h(svptrue_b32(), result);\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint x_or_y_simd(int n, int x, int y) {\n    svbool_t pg = svptrue_b32();\n    svint32_t vn = svdup_n_s32(n);\n    svint32_t vx = svdup_n_s32(x);\n    svint32_t vy = svdup_n_s32(y);\n\n    // Check if n is less than 2 (not prime)\n    svbool_t is_not_prime = svcmplt_s32(pg, vn, svdup_n_s32(2));\n\n    // Check divisibility from 2 to sqrt(n)\n    for (int i = 2; i * i <= n; ++i) {\n        svint32_t vi = svdup_n_s32(i);\n        svbool_t divisible = sveor_b_z(pg, svcmpeq_s32(pg, svmod_s32_z(pg, vn, vi), svdup_n_s32(0)), is_not_prime);\n        is_not_prime = svorr_b_z(pg, is_not_prime, divisible);\n    }\n\n    // Select x if prime, y otherwise\n    svint32_t result = svsel_s32(is_not_prime, vy, vx);\n\n    // Return the first element of the vector result\n    return svlastb_h32(svwhilelt_b32(0, 1), result);\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint x_or_y_simd(int n, int x, int y) {\n    svbool_t pg = svptrue_b32();\n    svint32_t vn = svdup_n_s32(n);\n    svint32_t vx = svdup_n_s32(x);\n    svint32_t vy = svdup_n_s32(y);\n\n    // Check if n is less than 2 (not prime)\n    svbool_t is_not_prime = svcmplt_s32(pg, vn, svdup_n_s32(2));\n\n    // Check divisibility from 2 to sqrt(n)\n    for (int i = 2; i * i <= n; ++i) {\n        svint32_t vi = svdup_n_s32(i);\n        svbool_t divisible = sveor_b_z(pg, svcmpeq_s32(pg, svmod_s32_z(pg, vn, vi), svdup_n_s32(0)), is_not_prime);\n        is_not_prime = svorr_b_z(pg, is_not_prime, divisible);\n    }\n\n    // Select x if prime, y otherwise\n    svint32_t result = svsel_s32(is_not_prime, vy, vx);\n\n    // Return the first element of the vector result\n    return svlastb_h32(svwhilelt_b32(svptrue_b32(), 0, 1), result);\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    svbool_t pg = svptrue_b32();\n    svint32_t vn = svdup_n_s32(n);\n    svint32_t vx = svdup_n_s32(x);\n    svint32_t vy = svdup_n_s32(y);\n\n    // Check if n is less than 2 (not prime)\n    svbool_t is_not_prime = svcmplt_s32(pg, vn, svdup_n_s32(2));\n\n    // Check divisibility from 2 to sqrt(n)\n    for (int i = 2; i * i <= n; ++i) {\n        svint32_t vi = svdup_n_s32(i);\n        svbool_t divisible = sveor_b_z(pg, svcmpeq_s32(pg, svmod_s32_z(pg, vn, vi), svdup_n_s32(0)), is_not_prime);\n        is_not_prime = svorr_b_z(pg, is_not_prime, divisible);\n    }\n\n    // Select x if prime, y otherwise\n    svint32_t result = svsel_s32(is_not_prime, vy, vx);\n\n    // Extract the result from the vector\n    return svlastb_s32(result);\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    uint64_t result = 0;\n    size_t n = lst.size();\n\n    if (n == 0) {\n        return 0;\n    }\n\n    svbool_t pg = svptrue_b32();\n    svfloat32_t sum_of_squares = svdup_f32(0.0f);\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        size_t vl = svminv_u32(svptrue_b32(), svcntw(), n - i);\n        pg = svwhilelt_b32(svptrue_b32(), i, n);\n\n        svfloat32_t vec = svld1(pg, &lst[i]);\n        svint32_t int_vec = svcvt_s32_f32_z(pg, vec);\n        svbool_t is_odd = svcmpeq_n_s32_z(pg, svand_s32_z(pg, int_vec, svdup_s32(1)), 1);\n        svbool_t is_positive = svcmpgt_n_f32_z(pg, vec, 0.0f);\n        svbool_t is_integer = sveq_f32_z(pg, svconvert_f32_s32_z(pg, int_vec), vec);\n        svbool_t mask = svand_z(pg, svand_z(pg, is_odd, is_positive), is_integer);\n\n        svfloat32_t squares = svmul_f32_z(mask, vec, vec);\n        sum_of_squares = svadd_f32_m(pg, sum_of_squares, squares);\n    }\n\n    float64_t sum = svaddv_f32(sum_of_squares);\n    result = static_cast<uint64_t>(sum);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    uint64_t result = 0;\n    size_t n = lst.size();\n\n    if (n == 0) {\n        return 0;\n    }\n\n    svbool_t pg = svptrue_b32();\n    svfloat32_t sum_of_squares = svdup_f32(0.0f);\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        size_t vl = svminv_u32(svptrue_b32(), svcntw(), n - i);\n        pg = svwhilelt_b32(svptrue_b32(), i, n);\n\n        svfloat32_t vec = svld1(pg, &lst[i]);\n        svint32_t int_vec = svcvt_s32_f32_z(pg, vec);\n        svbool_t is_odd = svcmpne_n_s32(pg, svand_s32_z(pg, int_vec, svdup_s32(1)), 0);\n        svbool_t is_positive = svcmpgt_n_f32(pg, vec, 0.0f);\n        svbool_t is_integer = sveq_f32(pg, svconvert_f32_s32_z(pg, int_vec), vec);\n        svbool_t mask = svand_b_z(pg, svand_b_z(pg, is_odd, is_positive), is_integer);\n\n        svfloat32_t squares = svmul_f32_z(mask, vec, vec);\n        sum_of_squares = svadd_f32_m(pg, sum_of_squares, squares);\n    }\n\n    float sum_array[svcntw()];\n    svst1_f32(svptrue_b32(), sum_array, sum_of_squares);\n\n    for (size_t i = 0; i < svcntw(); ++i) {\n        result += static_cast<uint64_t>(sum_array[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    uint64_t result = 0;\n    size_t n = lst.size();\n\n    if (n == 0) return 0;\n\n    svbool_t pg;\n    svfloat32_t vec;\n    svint32_t int_vec, odd_mask, zero_mask, positive_mask;\n    svuint64_t sum_of_squares = svdup_u64(0);\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        pg = svwhilelt_b32(i, n);\n        vec = svld1_f32(pg, lst.data() + i);\n\n        int_vec = svcvt_s32_f32_z(pg, vec);\n        odd_mask = svand_z(pg, svcmpne_n_s32(pg, svand_z(pg, int_vec, svdup_s32(1)), 0), svcmpeq_n_f32(pg, vec, svcvt_f32_s32_z(pg, int_vec)));\n        positive_mask = svcmpgt_n_f32(pg, vec, 0.0f);\n        zero_mask = svand_z(pg, odd_mask, positive_mask);\n\n        svfloat32_t squares = svmul_z(zero_mask, vec, vec);\n        svuint64_t sum = svaddl_u32(svaddl_u32(svdup_u64(0), squares));\n        sum_of_squares = svadd_u64_m(pg, sum_of_squares, sum);\n    }\n\n    return svaddv_u64(sum_of_squares);\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    uint64_t result = 0;\n    size_t n = lst.size();\n\n    if (n == 0) {\n        return 0;\n    }\n\n    svbool_t pg = svptrue_b32();\n    svfloat32_t sum_of_squares = svdup_f32(0.0f);\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        size_t vl = svminvuw(svptrue_b32(), svcntw(), n - i);\n        pg = svwhilelt_b32(svptrue_b32(), i, n);\n\n        svfloat32_t vec = svld1(pg, &lst[i]);\n        svint32_t int_vec = svcvt_s32_f32_z(pg, vec);\n        svbool_t is_odd = svcmpne_n_s32(pg, svand_s32_z(pg, int_vec, svdup_s32(1)), 0);\n        svbool_t is_positive = svcmpgt_n_f32(pg, vec, 0.0f);\n        svbool_t is_integer = sveq_f32(pg, svconvert_f32_s32_z(pg, int_vec), vec);\n        svbool_t mask = svand_b_z(pg, svand_b_z(pg, is_odd, is_positive), is_integer);\n\n        svfloat32_t squares = svmul_f32_z(mask, vec, vec);\n        sum_of_squares = svadd_f32_m(pg, sum_of_squares, squares);\n    }\n\n    float sum_array[svcntw()];\n    svst1_f32(svptrue_b32(), sum_array, sum_of_squares);\n\n    for (size_t i = 0; i < svcntw(); ++i) {\n        result += static_cast<uint64_t>(sum_array[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    uint64_t result = 0;\n    size_t n = lst.size();\n\n    if (n == 0) return 0;\n\n    svbool_t pg;\n    svfloat32_t vec;\n    svint32_t int_vec, odd_mask, non_neg_mask;\n    svuint64_t sum_of_squares = svdup_u64(0);\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        pg = svwhilelt_b32(i, n);\n        vec = svld1(pg, &lst[i]);\n        int_vec = svcvt_s32_f32_z(pg, vec);\n        odd_mask = svcmpne_n_s32_z(pg, svand_s32_z(pg, int_vec, svdup_s32(1)), 0);\n        non_neg_mask = svcmpge_n_f32_z(pg, vec, 0.0f);\n        pg = svand_z(pg, odd_mask, non_neg_mask);\n        svfloat32_t squares = svmul_f32_z(pg, vec, vec);\n        svuint64_t sum = svaddl_u32_z(svpgt_b32(squares, svdup_f32(0)), squares);\n        sum_of_squares = svadd_u64_m(pg, sum_of_squares, sum);\n    }\n\n    return svaddv_u64(sum_of_squares);\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t n = game.size();\n    std::vector<int> result(n);\n\n    // Calculate the number of elements that fit in one sve vector\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < n; i += vl) {\n        // Load vectors from memory\n        svint32_t game_vec = svld1(pg, &game[i]);\n        svint32_t guess_vec = svld1(pg, &guess[i]);\n\n        // Calculate the absolute difference\n        svint32_t diff_vec = svabs_s32_z(pg, svsub_z(pg, game_vec, guess_vec));\n\n        // Store the result back to memory\n        svst1(pg, &result[i], diff_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t n = game.size();\n    std::vector<int> result(n);\n\n    // Calculate the number of elements that fit in a sve vector\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < n; i += vl) {\n        // Load vectors from memory\n        svint32_t game_vec = svld1(pg, &game[i]);\n        svint32_t guess_vec = svld1(pg, &guess[i]);\n\n        // Calculate the absolute difference\n        svint32_t diff_vec = svabs_s32_z(pg, svsub_z(pg, game_vec, guess_vec));\n\n        // Store the result back to memory\n        svst1(pg, &result[i], diff_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t n = game.size();\n    std::vector<int> result(n);\n\n    // Calculate the number of elements that fit in one sve vector\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < n; i += vl) {\n        // Load vectors from memory\n        svint32_t game_vec = svld1(pg, &game[i]);\n        svint32_t guess_vec = svld1(pg, &guess[i]);\n\n        // Calculate the absolute difference\n        svint32_t diff_vec = svabs_s32_z(pg, svsub_z(pg, game_vec, guess_vec));\n\n        // Store the result back to memory\n        svst1(pg, &result[i], diff_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t n = game.size();\n    std::vector<int> result(n);\n\n    // Calculate the number of elements per SVE vector\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < n; i += vl) {\n        // Load vectors from memory\n        svint32_t game_vec = svld1(pg, &game[i]);\n        svint32_t guess_vec = svld1(pg, &guess[i]);\n\n        // Calculate the absolute difference\n        svint32_t diff_vec = svabs_s32_z(pg, svsub_z(pg, game_vec, guess_vec));\n\n        // Store the result back to memory\n        svst1(pg, &result[i], diff_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t n = game.size();\n    std::vector<int> result(n);\n\n    // Determine the number of elements per SVE vector\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < n; i += vl) {\n        // Load vectors from memory\n        svint32_t game_vec = svld1(pg, &game[i]);\n        svint32_t guess_vec = svld1(pg, &guess[i]);\n\n        // Calculate the absolute difference\n        svint32_t diff_vec = svabs_s32_z(pg, svsub_z(pg, game_vec, guess_vec));\n\n        // Store the result back to memory\n        svst1(pg, &result[i], diff_vec);\n    }\n\n    return result;\n}\n```"}

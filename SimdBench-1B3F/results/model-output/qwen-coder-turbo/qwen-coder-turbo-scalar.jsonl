{"task_id": "SimdBench_0", "completion": "```c\n#include <stddef.h>\n\nvoid conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0", "completion": "```c\n#include <stddef.h>\n\nvoid conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0", "completion": "```c\n#include <stddef.h>\n\nvoid conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0", "completion": "```c\n#include <stddef.h>\n\nvoid conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0", "completion": "```c\n#include <stddef.h>\n\nvoid conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_1", "completion": "```c\nvoid load_modify_store(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        int element = src[i];\n        int tmp1 = (element * scale) >> 3;\n        int tmp2 = (element * scale) << 3;\n        int result = (element * scale + tmp1 * tmp2) / 7;\n        dst[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_1", "completion": "```c\nvoid load_modify_store(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        int element = src[i];\n        int tmp1 = (element * scale) >> 3;\n        int tmp2 = (element * scale) << 3;\n        int result = (element * scale + tmp1 * tmp2) / 7;\n        dst[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_1", "completion": "```c\nvoid load_modify_store(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        int element = src[i];\n        int tmp1 = (element * scale) >> 3;\n        int tmp2 = (element * scale) << 3;\n        int result = (element * scale + tmp1 * tmp2) / 7;\n        dst[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_1", "completion": "```c\nvoid load_modify_store(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        int element = src[i];\n        int tmp1 = (element * scale) >> 3;\n        int tmp2 = (element * scale) << 3;\n        int result = (element * scale + tmp1 * tmp2) / 7;\n        dst[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_1", "completion": "```c\nvoid load_modify_store(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        int element = src[i];\n        int tmp1 = (element * scale) >> 3;\n        int tmp2 = (element * scale) << 3;\n        int result = (element * scale + tmp1 * tmp2) / 7;\n        dst[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_2", "completion": "```c\n#include <stddef.h>\n\nvoid strided_load_store(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; ++r) {\n        dst[r] = src[r * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2", "completion": "```c\n#include <stddef.h>\n\nvoid strided_load_store(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; ++r) {\n        dst[r] = src[r * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2", "completion": "```c\n#include <stddef.h>\n\nvoid strided_load_store(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; ++r) {\n        dst[r] = src[r * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2", "completion": "```c\n#include <stddef.h>\n\nvoid strided_load_store(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; ++r) {\n        dst[r] = src[r * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2", "completion": "```c\n#include <stddef.h>\n\nvoid strided_load_store(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; ++r) {\n        dst[r] = src[r * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_3", "completion": "```c\n#include <stddef.h>\n\nvoid indexed_access(const float *src, const int *indices, float *dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = src[indices[i]];\n    }\n}\n```"}
{"task_id": "SimdBench_3", "completion": "```c\n#include <stddef.h>\n\nvoid indexed_access(const float *src, const int *indices, float *dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[indices[i]] = src[i]; // Scatter operation\n    }\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = src[indices[i]]; // Gather operation\n    }\n}\n```"}
{"task_id": "SimdBench_3", "completion": "```c\n#include <stddef.h>\n\nvoid indexed_access(const float *src, const int *indices, float *dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = src[indices[i]];\n    }\n}\n```"}
{"task_id": "SimdBench_3", "completion": "```c\n#include <stddef.h>\n\nvoid indexed_access(const float *src, const int *indices, float *dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = src[indices[i]]; // Gather operation\n    }\n    for (size_t i = 0; i < length; ++i) {\n        src[indices[i]] = dst[i]; // Scatter operation\n    }\n}\n```"}
{"task_id": "SimdBench_3", "completion": "```c\n#include <stddef.h>\n\nvoid indexed_access(const float *src, const int *indices, float *dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = src[indices[i]];\n    }\n}\n```"}
{"task_id": "SimdBench_4", "completion": "```c\nvoid range_reverse(int16_t *arr, uint64_t start, uint64_t end) {\n    for (uint64_t i = start, j = end; i < j; ++i, --j) {\n        int16_t temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n}\n```"}
{"task_id": "SimdBench_4", "completion": "```c\nvoid range_reverse(int16_t *arr, uint64_t start, uint64_t end) {\n    for (uint64_t i = start, j = end; i < j; ++i, --j) {\n        int16_t temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n}\n```"}
{"task_id": "SimdBench_4", "completion": "```c\nvoid range_reverse(int16_t *arr, uint64_t start, uint64_t end) {\n    for (uint64_t i = start, j = end; i < j; ++i, --j) {\n        int16_t temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n}\n```"}
{"task_id": "SimdBench_4", "completion": "```c\nvoid range_reverse(int16_t *arr, uint64_t start, uint64_t end) {\n    for (uint64_t i = start, j = end; i < j; ++i, --j) {\n        int16_t temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n}\n```"}
{"task_id": "SimdBench_4", "completion": "```c\nvoid range_reverse(int16_t *arr, uint64_t start, uint64_t end) {\n    for (uint64_t i = start, j = end; i < j; ++i, --j) {\n        int16_t temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n}\n```"}
{"task_id": "SimdBench_5", "completion": "```c\nvoid extract_tensor_slice(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            size_t src_index = ((i * dim2 + j) * dim3) + slice_idx;\n            size_t dst_index = i * dim2 + j;\n            slice[dst_index] = tensor[src_index];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5", "completion": "```c\nvoid extract_tensor_slice(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            size_t src_index = (i * dim2 + j) * dim3 + slice_idx;\n            size_t dst_index = i * dim2 + j;\n            slice[dst_index] = tensor[src_index];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5", "completion": "```c\nvoid extract_tensor_slice(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            size_t src_index = (i * dim2 + j) * dim3 + slice_idx;\n            size_t dst_index = i * dim2 + j;\n            slice[dst_index] = tensor[src_index];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5", "completion": "```c\nvoid extract_tensor_slice(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            size_t src_index = ((i * dim2 + j) * dim3) + slice_idx;\n            size_t dst_index = i * dim2 + j;\n            slice[dst_index] = tensor[src_index];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5", "completion": "```c\nvoid extract_tensor_slice(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            size_t src_index = (i * dim2 + j) * dim3 + slice_idx;\n            size_t dst_index = i * dim2 + j;\n            slice[dst_index] = tensor[src_index];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6", "completion": "```c\n#include <stddef.h>\n\nvoid blocked_matrix_transpose(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t row = 0; row < rows; row += block_size) {\n        for (size_t col = 0; col < cols; col += block_size) {\n            for (size_t i = 0; i < block_size && row + i < rows; ++i) {\n                for (size_t j = 0; j < block_size && col + j < cols; ++j) {\n                    dst[(col + j) * rows + (row + i)] = src[(row + i) * cols + (col + j)];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid blocked_matrix_transpose(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t row = 0; row < rows; row += block_size) {\n        for (size_t col = 0; col < cols; col += block_size) {\n            for (size_t i = 0; i < block_size && row + i < rows; ++i) {\n                for (size_t j = 0; j < block_size && col + j < cols; ++j) {\n                    dst[(col + j) * rows + (row + i)] = src[(row + i) * cols + (col + j)];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6", "completion": "```c\n#include <stddef.h>\n\nvoid blocked_matrix_transpose(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t row = 0; row < rows; row += block_size) {\n        for (size_t col = 0; col < cols; col += block_size) {\n            for (size_t i = 0; i < block_size && row + i < rows; ++i) {\n                for (size_t j = 0; j < block_size && col + j < cols; ++j) {\n                    dst[(col + j) * rows + (row + i)] = src[(row + i) * cols + (col + j)];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6", "completion": "```c\n#include <stdint.h>\n\nvoid blocked_matrix_transpose(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t row = 0; row < rows; row += block_size) {\n        for (size_t col = 0; col < cols; col += block_size) {\n            for (size_t i = 0; i < block_size && row + i < rows; ++i) {\n                for (size_t j = 0; j < block_size && col + j < cols; ++j) {\n                    dst[(col + j) * rows + (row + i)] = src[(row + i) * cols + (col + j)];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid blocked_matrix_transpose(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t row = 0; row < rows; row += block_size) {\n        for (size_t col = 0; col < cols; col += block_size) {\n            for (size_t i = 0; i < block_size && row + i < rows; ++i) {\n                for (size_t j = 0; j < block_size && col + j < cols; ++j) {\n                    dst[(col + j) * rows + (row + i)] = src[(row + i) * cols + (col + j)];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_7", "completion": "```c\nfloat diagonal_sum_3d(const float *array, size_t dim) {\n    float sum = 0.0f;\n    for (size_t i = 0; i < dim; ++i) {\n        sum += array[i * dim * dim + i * dim + i];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7", "completion": "```c\nfloat diagonal_sum_3d(const float *array, size_t dim) {\n    float sum = 0.0f;\n    for (size_t i = 0; i < dim; ++i) {\n        sum += array[i * dim * dim + i * dim + i];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7", "completion": "```c\nfloat diagonal_sum_3d(const float *array, size_t dim) {\n    float sum = 0.0f;\n    for (size_t i = 0; i < dim; ++i) {\n        sum += array[i * dim * dim + i * dim + i];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7", "completion": "```c\nfloat diagonal_sum_3d(const float *array, size_t dim) {\n    float sum = 0.0f;\n    for (size_t i = 0; i < dim; ++i) {\n        sum += array[i * dim * dim + i * dim + i];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7", "completion": "```c\nfloat diagonal_sum_3d(const float *array, size_t dim) {\n    float sum = 0.0f;\n    for (size_t i = 0; i < dim; ++i) {\n        sum += array[i * dim * dim + i * dim + i];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_8", "completion": "```c\n#include <stddef.h>\n\nvoid conditional_scale(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            if (src[i * cols + j] > threshold) {\n                dst[i * cols + j] = src[i * cols + j] * scale;\n            } else {\n                dst[i * cols + j] = src[i * cols + j];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8", "completion": "```c\n#include <stddef.h>\n\nvoid conditional_scale(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            if (src[i * cols + j] > threshold) {\n                dst[i * cols + j] = src[i * cols + j] * scale;\n            } else {\n                dst[i * cols + j] = src[i * cols + j];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8", "completion": "```c\n#include <stddef.h>\n\nvoid conditional_scale(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            if (src[i * cols + j] > threshold) {\n                dst[i * cols + j] = src[i * cols + j] * scale;\n            } else {\n                dst[i * cols + j] = src[i * cols + j];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8", "completion": "```c\n#include <stddef.h>\n\nvoid conditional_scale(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            if (src[i * cols + j] > threshold) {\n                dst[i * cols + j] = src[i * cols + j] * scale;\n            } else {\n                dst[i * cols + j] = src[i * cols + j];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8", "completion": "```c\n#include <stddef.h>\n\nvoid conditional_scale(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            if (src[i * cols + j] > threshold) {\n                dst[i * cols + j] = src[i * cols + j] * scale;\n            } else {\n                dst[i * cols + j] = src[i * cols + j];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9", "completion": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid reorder_matrix_rows(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; ++i) {\n        size_t src_index = indices[i] * cols;\n        size_t dst_index = i * cols;\n        for (size_t j = 0; j < cols; ++j) {\n            dst[dst_index + j] = src[src_index + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9", "completion": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid reorder_matrix_rows(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            dst[i * cols + j] = src[indices[i] * cols + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9", "completion": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid reorder_matrix_rows(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; ++i) {\n        size_t index = indices[i];\n        if (index >= rows) {\n            fprintf(stderr, \"Invalid index: %zu\\n\", index);\n            exit(EXIT_FAILURE);\n        }\n        for (size_t j = 0; j < cols; ++j) {\n            dst[i * cols + j] = src[index * cols + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9", "completion": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid reorder_matrix_rows(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; ++i) {\n        size_t src_index = indices[i] * cols;\n        size_t dst_index = i * cols;\n        for (size_t j = 0; j < cols; ++j) {\n            dst[dst_index + j] = src[src_index + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9", "completion": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid reorder_matrix_rows(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; ++i) {\n        size_t src_index = indices[i] * cols;\n        size_t dst_index = i * cols;\n        for (size_t j = 0; j < cols; ++j) {\n            dst[dst_index + j] = src[src_index + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_10", "completion": "```c\n#include <stdint.h>\n\nvoid vector_vector_add(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = ((src1[i] + src2[i]) + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10", "completion": "```c\n#include <stdint.h>\n\nvoid vector_vector_add(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10", "completion": "```c\n#include <stdint.h>\n\nvoid vector_vector_add(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = ((src1[i] + src2[i]) + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10", "completion": "```c\n#include <stdint.h>\n\nvoid vector_vector_add(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = ((src1[i] + src2[i]) + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10", "completion": "```c\n#include <stdint.h>\n\nvoid vector_vector_add(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_11", "completion": "```c\n#include <limits.h>\n\nint vector_even_min(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    int min_value = INT_MAX;\n    for (size_t i = 0; i < length; i += 2) {\n        if (src[i] % 2 == 0 && src[i] < min_value) {\n            min_value = src[i];\n        }\n    }\n\n    return min_value == INT_MAX ? -1 : min_value;\n}\n```"}
{"task_id": "SimdBench_11", "completion": "```c\n#include <limits.h>\n\nint vector_even_min(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    int min_value = INT_MAX;\n    for (size_t i = 0; i < length; i += 2) {\n        if (src[i] % 2 == 0 && src[i] < min_value) {\n            min_value = src[i];\n        }\n    }\n\n    return min_value == INT_MAX ? -1 : min_value;\n}\n```"}
{"task_id": "SimdBench_11", "completion": "```c\n#include <limits.h>\n\nint vector_even_min(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    int min_value = INT_MAX;\n    for (size_t i = 0; i < length; i += 2) {\n        if (src[i] % 2 == 0 && src[i] < min_value) {\n            min_value = src[i];\n        }\n    }\n\n    return min_value == INT_MAX ? -1 : min_value;\n}\n```"}
{"task_id": "SimdBench_11", "completion": "```c\n#include <limits.h>\n\nint vector_even_min(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    int min_value = INT_MAX;\n    for (size_t i = 0; i < length; i += 2) {\n        if (src[i] % 2 == 0 && src[i] < min_value) {\n            min_value = src[i];\n        }\n    }\n\n    return min_value == INT_MAX ? -1 : min_value;\n}\n```"}
{"task_id": "SimdBench_11", "completion": "```c\n#include <limits.h>\n\nint vector_even_min(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    int min_value = INT_MAX;\n    for (size_t i = 0; i < length; i += 2) {\n        if (src[i] % 2 == 0 && src[i] < min_value) {\n            min_value = src[i];\n        }\n    }\n\n    return min_value == INT_MAX ? -1 : min_value;\n}\n```"}
{"task_id": "SimdBench_12", "completion": "```c\n#include <stdint.h>\n\nvoid mixed_right_shift(const int *src, int *dst, uint8_t shift, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = (src[i] >> shift) + ((uint32_t)(src[i]) >> shift);\n    }\n}\n```"}
{"task_id": "SimdBench_12", "completion": "```c\n#include <stdint.h>\n\nvoid mixed_right_shift(const int *src, int *dst, uint8_t shift, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = (src[i] >> shift) + ((uint32_t)(src[i]) >> shift);\n    }\n}\n```"}
{"task_id": "SimdBench_12", "completion": "```c\n#include <stdint.h>\n\nvoid mixed_right_shift(const int *src, int *dst, uint8_t shift, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = (src[i] >> shift) + ((uint32_t)(src[i]) >> shift);\n    }\n}\n```"}
{"task_id": "SimdBench_12", "completion": "```c\n#include <stdint.h>\n\nvoid mixed_right_shift(const int *src, int *dst, uint8_t shift, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = (src[i] >> shift) + ((uint32_t)(src[i]) >> shift);\n    }\n}\n```"}
{"task_id": "SimdBench_12", "completion": "```c\n#include <stdint.h>\n\nvoid mixed_right_shift(const int *src, int *dst, uint8_t shift, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = (src[i] >> shift) + ((uint32_t)(src[i]) >> shift);\n    }\n}\n```"}
{"task_id": "SimdBench_13", "completion": "```c\n#include <stdint.h>\n\nint64_t matrix_sum(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            sum += matrix[i * cols + j];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13", "completion": "```c\n#include <stdint.h>\n\nint64_t matrix_sum(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            sum += matrix[i * cols + j];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13", "completion": "```c\n#include <stdint.h>\n\nint64_t matrix_sum(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            sum += matrix[i * cols + j];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13", "completion": "```c\n#include <stdint.h>\n\nint64_t matrix_sum(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            sum += matrix[i * cols + j];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13", "completion": "```c\n#include <stdint.h>\n\nint64_t matrix_sum(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            sum += matrix[i * cols + j];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_14", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nsize_t argmax(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n\n    for (size_t i = 1; i < length; ++i) {\n        if (src[i] > max_value) {\n            max_value = src[i];\n            max_index = i;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nsize_t argmax(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n\n    for (size_t i = 1; i < length; ++i) {\n        if (src[i] > max_value) {\n            max_value = src[i];\n            max_index = i;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nsize_t argmax(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n\n    for (size_t i = 1; i < length; ++i) {\n        if (src[i] > max_value) {\n            max_value = src[i];\n            max_index = i;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nsize_t argmax(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n\n    for (size_t i = 1; i < length; ++i) {\n        if (src[i] > max_value) {\n            max_value = src[i];\n            max_index = i;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nsize_t argmax(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n\n    for (size_t i = 1; i < length; ++i) {\n        if (src[i] > max_value) {\n            max_value = src[i];\n            max_index = i;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_15", "completion": "```c\n#include <stdint.h>\n\nvoid vector_blend(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if ((i & mask) != 0) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15", "completion": "```c\n#include <stdint.h>\n\nvoid vector_blend(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if ((i & mask) != 0) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15", "completion": "```c\n#include <stdint.h>\n\nvoid vector_blend(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if ((i & mask) != 0) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15", "completion": "```c\n#include <stdint.h>\n\nvoid vector_blend(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if ((i & mask) != 0) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15", "completion": "```c\n#include <stdint.h>\n\nvoid vector_blend(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if ((i & mask) != 0) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_16", "completion": "```c\n#include <stdint.h>\n\nvoid population_count(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = __builtin_popcount(src[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_16", "completion": "```c\n#include <stdint.h>\n\nvoid population_count(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = __builtin_popcount(src[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_16", "completion": "```c\n#include <stdint.h>\n\nvoid population_count(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = __builtin_popcount(src[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_16", "completion": "```c\n#include <stdint.h>\n\nvoid population_count(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = __builtin_popcount(src[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_16", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid population_count(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = __builtin_popcount(src[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_17", "completion": "```c\n#include <stdint.h>\n#include <limits.h>\n\nvoid saturating_add(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        uint32_t sum = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = (sum > UINT16_MAX) ? UINT16_MAX : (uint16_t)sum;\n    }\n}\n```"}
{"task_id": "SimdBench_17", "completion": "```c\n#include <stdint.h>\n#include <limits.h>\n\nvoid saturating_add(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        uint32_t sum = (uint32_t)src1[i] + (uint32_t)src2[i];\n        if (sum > UINT16_MAX) {\n            dst[i] = UINT16_MAX;\n        } else {\n            dst[i] = (uint16_t)sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_17", "completion": "```c\n#include <stdint.h>\n#include <limits.h>\n\nvoid saturating_add(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        uint32_t sum = (uint32_t)src1[i] + (uint32_t)src2[i];\n        if (sum > UINT16_MAX) {\n            dst[i] = UINT16_MAX;\n        } else {\n            dst[i] = (uint16_t)sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_17", "completion": "```c\n#include <stdint.h>\n#include <limits.h>\n\nvoid saturating_add(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        uint32_t sum = (uint32_t)src1[i] + (uint32_t)src2[i];\n        if (sum > UINT16_MAX) {\n            dst[i] = UINT16_MAX;\n        } else {\n            dst[i] = (uint16_t)sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_17", "completion": "```c\n#include <stdint.h>\n#include <limits.h>\n\nvoid saturating_add(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        uint32_t sum = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = (sum > UINT16_MAX) ? UINT16_MAX : (uint16_t)sum;\n    }\n}\n```"}
{"task_id": "SimdBench_18", "completion": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid range_matrix_mul(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            C[i * p + j] = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                if (A[i * n + k] >= -100 && A[i * n + k] <= 100 && B[k * p + j] >= -100 && B[k * p + j] <= 100) {\n                    C[i * p + j] += A[i * n + k] * B[k * p + j];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18", "completion": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid range_matrix_mul(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            C[i * p + j] = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                if (A[i * n + k] >= -100 && A[i * n + k] <= 100 && B[k * p + j] >= -100 && B[k * p + j] <= 100) {\n                    C[i * p + j] += A[i * n + k] * B[k * p + j];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18", "completion": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid range_matrix_mul(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            C[i * p + j] = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                if (A[i * n + k] >= -100 && A[i * n + k] <= 100 && B[k * p + j] >= -100 && B[k * p + j] <= 100) {\n                    C[i * p + j] += A[i * n + k] * B[k * p + j];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18", "completion": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid range_matrix_mul(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            C[i * p + j] = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                if (A[i * n + k] >= -100 && A[i * n + k] <= 100 && B[k * p + j] >= -100 && B[k * p + j] <= 100) {\n                    C[i * p + j] += A[i * n + k] * B[k * p + j];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18", "completion": "```c\n#include <stdio.h>\n\nvoid range_matrix_mul(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            C[i * p + j] = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                if (A[i * n + k] >= -100 && A[i * n + k] <= 100 && B[k * p + j] >= -100 && B[k * p + j] <= 100) {\n                    C[i * p + j] += A[i * n + k] * B[k * p + j];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19", "completion": "```c\nfor (size_t i = 0; i < dim1; ++i) {\n    for (size_t j = 0; j < dim2; ++j) {\n        for (size_t k = 0; k < dim3; ++k) {\n            C[i * dim2 * dim3 + j * dim3 + k] = A[i * dim2 * dim3 + j * dim3 + k] + B[i * dim2 * dim3 + j * dim3 + k];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19", "completion": "```c\nfor (size_t i = 0; i < dim1; ++i) {\n    for (size_t j = 0; j < dim2; ++j) {\n        for (size_t k = 0; k < dim3; ++k) {\n            C[i * dim2 * dim3 + j * dim3 + k] = A[i * dim2 * dim3 + j * dim3 + k] + B[i * dim2 * dim3 + j * dim3 + k];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19", "completion": "```c\nfor (size_t i = 0; i < dim1; ++i) {\n    for (size_t j = 0; j < dim2; ++j) {\n        for (size_t k = 0; k < dim3; ++k) {\n            C[i * dim2 * dim3 + j * dim3 + k] = A[i * dim2 * dim3 + j * dim3 + k] + B[i * dim2 * dim3 + j * dim3 + k];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19", "completion": "```c\nfor (size_t i = 0; i < dim1; ++i) {\n    for (size_t j = 0; j < dim2; ++j) {\n        for (size_t k = 0; k < dim3; ++k) {\n            C[i * dim2 * dim3 + j * dim3 + k] = A[i * dim2 * dim3 + j * dim3 + k] + B[i * dim2 * dim3 + j * dim3 + k];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19", "completion": "```c\nfor (size_t i = 0; i < dim1; ++i) {\n    for (size_t j = 0; j < dim2; ++j) {\n        for (size_t k = 0; k < dim3; ++k) {\n            C[i * dim2 * dim3 + j * dim3 + k] = A[i * dim2 * dim3 + j * dim3 + k] + B[i * dim2 * dim3 + j * dim3 + k];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_20", "completion": "```c\n#include <math.h>\n\nvoid vector_add_round_nearest(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = round(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20", "completion": "```c\n#include <math.h>\n\nvoid vector_add_round_nearest(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = round(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20", "completion": "```c\n#include <math.h>\n\nvoid vector_add_round_nearest(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = round(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20", "completion": "```c\n#include <math.h>\n\nvoid vector_add_round_nearest(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = round(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20", "completion": "```c\n#include <math.h>\n\nvoid vector_add_round_nearest(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = round(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_21", "completion": "```c\n#include <math.h>\n\nvoid vector_mul_round_up(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (i % 2 == 0 && fabs(src1[i] - src2[i]) <= 50) {\n            dst[i] = ceil(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21", "completion": "```c\n#include <math.h>\n\nvoid vector_mul_round_up(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (i % 2 == 0 && fabs(src1[i] - src2[i]) <= 50) {\n            dst[i] = ceil(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21", "completion": "```c\n#include <math.h>\n\nvoid vector_mul_round_up(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (i % 2 == 0 && fabs(src1[i] - src2[i]) <= 50) {\n            dst[i] = ceil(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21", "completion": "```c\n#include <math.h>\n\nvoid vector_mul_round_up(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (i % 2 == 0 && fabs(src1[i] - src2[i]) <= 50) {\n            dst[i] = ceil(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21", "completion": "```c\n#include <math.h>\n\nvoid vector_mul_round_up(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (i % 2 == 0 && fabs(src1[i] - src2[i]) <= 50) {\n            dst[i] = ceil(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_22", "completion": "```c\nfor (size_t i = 0; i < m * n; ++i) {\n    dst[i] = mat[i] * scalar;\n}\n```"}
{"task_id": "SimdBench_22", "completion": "```c\nfor (size_t i = 0; i < m * n; ++i) {\n    dst[i] = mat[i] * scalar;\n}\n```"}
{"task_id": "SimdBench_22", "completion": "```c\nfor (size_t i = 0; i < m * n; ++i) {\n    dst[i] = mat[i] * scalar;\n}\n```"}
{"task_id": "SimdBench_22", "completion": "```c\nfor (size_t i = 0; i < m * n; ++i) {\n    dst[i] = mat[i] * scalar;\n}\n```"}
{"task_id": "SimdBench_22", "completion": "```c\nfor (size_t i = 0; i < m * n; ++i) {\n    dst[i] = mat[i] * scalar;\n}\n```"}
{"task_id": "SimdBench_23", "completion": "```c\n#include <math.h>\n\nvoid matrix_normalize_rows(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float sum_of_squares = 0.0f;\n        for (size_t j = 0; j < n; ++j) {\n            sum_of_squares += mat[i * n + j] * mat[i * n + j];\n        }\n        float l2_norm = sqrt(sum_of_squares);\n        if (l2_norm != 0.0f) {\n            for (size_t j = 0; j < n; ++j) {\n                mat[i * n + j] /= l2_norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23", "completion": "```c\n#include <math.h>\n\nvoid matrix_normalize_rows(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float sum_of_squares = 0.0f;\n        for (size_t j = 0; j < n; ++j) {\n            sum_of_squares += mat[i * n + j] * mat[i * n + j];\n        }\n        float l2_norm = sqrt(sum_of_squares);\n        if (l2_norm != 0.0f) {\n            for (size_t j = 0; j < n; ++j) {\n                mat[i * n + j] /= l2_norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23", "completion": "```c\n#include <math.h>\n\nvoid matrix_normalize_rows(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float sum_of_squares = 0.0f;\n        for (size_t j = 0; j < n; ++j) {\n            sum_of_squares += mat[i * n + j] * mat[i * n + j];\n        }\n        float l2_norm = sqrt(sum_of_squares);\n        if (l2_norm != 0.0f) {\n            for (size_t j = 0; j < n; ++j) {\n                mat[i * n + j] /= l2_norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23", "completion": "```c\n#include <math.h>\n\nvoid matrix_normalize_rows(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float sum_of_squares = 0.0f;\n        for (size_t j = 0; j < n; ++j) {\n            sum_of_squares += mat[i * n + j] * mat[i * n + j];\n        }\n        float l2_norm = sqrt(sum_of_squares);\n        if (l2_norm != 0.0f) {\n            for (size_t j = 0; j < n; ++j) {\n                mat[i * n + j] /= l2_norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23", "completion": "```c\n#include <math.h>\n\nvoid matrix_normalize_rows(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float sum_of_squares = 0.0f;\n        for (size_t j = 0; j < n; ++j) {\n            sum_of_squares += mat[i * n + j] * mat[i * n + j];\n        }\n        float l2_norm = sqrt(sum_of_squares);\n        if (l2_norm != 0.0f) {\n            for (size_t j = 0; j < n; ++j) {\n                mat[i * n + j] /= l2_norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24", "completion": "```c\n#include <math.h>\n\nvoid matrix_mul_round_int(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24", "completion": "```c\n#include <math.h>\n\nvoid matrix_mul_round_int(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24", "completion": "```c\n#include <math.h>\n\nvoid matrix_mul_round_int(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24", "completion": "```c\n#include <math.h>\n\nvoid matrix_mul_round_int(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24", "completion": "```c\n#include <math.h>\n\nvoid matrix_mul_round_int(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25", "completion": "```c\n#include <math.h>\n\nvoid matrix_transpose_round_quarter(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            float value = src[i * cols + j];\n            float rounded_value = round(value / 0.25f) * 0.25f;\n            dst[j * rows + i] = rounded_value;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25", "completion": "```c\n#include <math.h>\n\nvoid matrix_transpose_round_quarter(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            float value = src[i * cols + j];\n            float rounded_value = round(value * 4) / 4;\n            dst[j * rows + i] = rounded_value;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25", "completion": "```c\n#include <math.h>\n\nvoid matrix_transpose_round_quarter(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            float value = src[i * cols + j];\n            float rounded_value = round(value / 0.25f) * 0.25f;\n            dst[j * rows + i] = rounded_value;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25", "completion": "```c\n#include <math.h>\n\nvoid matrix_transpose_round_quarter(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            float value = src[i * cols + j];\n            float rounded_value = round(value / 0.25f) * 0.25f;\n            dst[j * rows + i] = rounded_value;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25", "completion": "```c\n#include <math.h>\n\nvoid matrix_transpose_round_quarter(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            float value = src[i * cols + j];\n            float rounded_value = round(value * 4) / 4;\n            dst[j * rows + i] = rounded_value;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26", "completion": "```c\n#include <math.h>\n\nvoid tensor3d_sub_round_zero(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1 * dim2 * dim3; ++i) {\n        dst[i] = trunc(tensor1[i] - tensor2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_26", "completion": "```c\n#include <math.h>\n\nvoid tensor3d_sub_round_zero(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1 * dim2 * dim3; ++i) {\n        dst[i] = trunc(tensor1[i] - tensor2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_26", "completion": "```c\n#include <math.h>\n\nvoid tensor3d_sub_round_zero(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1 * dim2 * dim3; ++i) {\n        dst[i] = truncf(tensor1[i] - tensor2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_26", "completion": "```c\n#include <math.h>\n\nvoid tensor3d_sub_round_zero(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1 * dim2 * dim3; ++i) {\n        dst[i] = trunc(tensor1[i] - tensor2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_26", "completion": "```c\n#include <math.h>\n\nvoid tensor3d_sub_round_zero(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1 * dim2 * dim3; ++i) {\n        dst[i] = truncf(tensor1[i] - tensor2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_27", "completion": "```c\n#include <stddef.h>\n\nvoid matrix_hadamard_product(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m * n; ++i) {\n        dst[i] = mat1[i] * mat2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_27", "completion": "```c\nfor (size_t i = 0; i < m * n; ++i) {\n    dst[i] = mat1[i] * mat2[i];\n}\n```"}
{"task_id": "SimdBench_27", "completion": "```c\nfor (size_t i = 0; i < m * n; ++i) {\n    dst[i] = mat1[i] * mat2[i];\n}\n```"}
{"task_id": "SimdBench_27", "completion": "```c\nfor (size_t i = 0; i < m * n; ++i) {\n    dst[i] = mat1[i] * mat2[i];\n}\n```"}
{"task_id": "SimdBench_27", "completion": "```c\nfor (size_t i = 0; i < m * n; ++i) {\n    dst[i] = mat1[i] * mat2[i];\n}\n```"}
{"task_id": "SimdBench_28", "completion": "```c\nfor (size_t i = 0; i < m; ++i) {\n    float sum = 0.0f;\n    for (size_t j = 0; j < n; ++j) {\n        sum += mat[i * n + j] * vec[j];\n    }\n    dst[i] = sum;\n}\n```"}
{"task_id": "SimdBench_28", "completion": "```c\nfor (size_t i = 0; i < m; ++i) {\n    float sum = 0.0f;\n    for (size_t j = 0; j < n; ++j) {\n        sum += mat[i * n + j] * vec[j];\n    }\n    dst[i] = sum;\n}\n```"}
{"task_id": "SimdBench_28", "completion": "```c\nvoid matrix_vector_mul(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        dst[i] = 0.0f;\n        for (size_t j = 0; j < n; ++j) {\n            dst[i] += mat[i * n + j] * vec[j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_28", "completion": "```c\nfor (size_t i = 0; i < m; ++i) {\n    float sum = 0.0f;\n    for (size_t j = 0; j < n; ++j) {\n        sum += mat[i * n + j] * vec[j];\n    }\n    dst[i] = sum;\n}\n```"}
{"task_id": "SimdBench_28", "completion": "```c\nfor (size_t i = 0; i < m; ++i) {\n    float sum = 0.0f;\n    for (size_t j = 0; j < n; ++j) {\n        sum += mat[i * n + j] * vec[j];\n    }\n    dst[i] = sum;\n}\n```"}
{"task_id": "SimdBench_29", "completion": "```c\ndouble matrix_average(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < n; ++j) {\n            sum += mat[i * n + j];\n        }\n    }\n    return sum / (m * n);\n}\n```"}
{"task_id": "SimdBench_29", "completion": "```c\ndouble matrix_average(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < n; ++j) {\n            sum += mat[i * n + j];\n        }\n    }\n    return sum / (m * n);\n}\n```"}
{"task_id": "SimdBench_29", "completion": "```c\ndouble matrix_average(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < n; ++j) {\n            sum += mat[i * n + j];\n        }\n    }\n    return sum / (m * n);\n}\n```"}
{"task_id": "SimdBench_29", "completion": "```c\ndouble matrix_average(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    for (size_t i = 0; i < m * n; ++i) {\n        sum += mat[i];\n    }\n    return sum / (m * n);\n}\n```"}
{"task_id": "SimdBench_29", "completion": "```c\ndouble matrix_average(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    for (size_t i = 0; i < m * n; ++i) {\n        sum += mat[i];\n    }\n    return sum / (m * n);\n}\n```"}
{"task_id": "SimdBench_30", "completion": "```c\n#include <stdbool.h>\n#include <stddef.h>\n\nbool matrix_rows_sorted_verify(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool ascending = directions[i];\n        for (size_t j = 1; j < cols; ++j) {\n            if ((ascending && matrix[i * cols + j] < matrix[i * cols + j - 1]) ||\n                (!ascending && matrix[i * cols + j] > matrix[i * cols + j - 1])) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30", "completion": "```c\n#include <stdbool.h>\n#include <stddef.h>\n\nbool matrix_rows_sorted_verify(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool ascending = directions[i];\n        for (size_t j = 1; j < cols; ++j) {\n            if ((ascending && matrix[i * cols + j] < matrix[i * cols + j - 1]) ||\n                (!ascending && matrix[i * cols + j] > matrix[i * cols + j - 1])) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30", "completion": "```c\n#include <stdbool.h>\n#include <stddef.h>\n\nbool matrix_rows_sorted_verify(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool is_ascending = directions[i];\n        for (size_t j = 1; j < cols; ++j) {\n            if (is_ascending && matrix[i * cols + j] < matrix[i * cols + j - 1]) {\n                return false;\n            } else if (!is_ascending && matrix[i * cols + j] > matrix[i * cols + j - 1]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30", "completion": "```c\n#include <stdbool.h>\n#include <stddef.h>\n\nbool matrix_rows_sorted_verify(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool is_ascending = directions[i];\n        for (size_t j = 1; j < cols; ++j) {\n            if ((is_ascending && matrix[i * cols + j] < matrix[i * cols + j - 1]) ||\n                (!is_ascending && matrix[i * cols + j] > matrix[i * cols + j - 1])) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30", "completion": "```c\n#include <stdbool.h>\n#include <stddef.h>\n\nbool matrix_rows_sorted_verify(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool is_ascending = directions[i];\n        for (size_t j = 1; j < cols; ++j) {\n            if ((is_ascending && matrix[i * cols + j] < matrix[i * cols + j - 1]) ||\n                (!is_ascending && matrix[i * cols + j] > matrix[i * cols + j - 1])) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_31", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid nearest_multiple(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        int16_t value = src[i];\n        int16_t quotient = value / base;\n        int16_t lower = quotient * base;\n        int16_t upper = (quotient + 1) * base;\n        \n        if (value - lower <= upper - value) {\n            dst[i] = lower;\n        } else {\n            dst[i] = upper;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_31", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid nearest_multiple(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        int16_t value = src[i];\n        int16_t quotient = value / base;\n        int16_t lower = quotient * base;\n        int16_t upper = (quotient + 1) * base;\n        \n        if (value - lower <= upper - value) {\n            dst[i] = lower;\n        } else {\n            dst[i] = upper;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_31", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid nearest_multiple(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        int16_t value = src[i];\n        int16_t quotient = value / base;\n        int16_t lower = quotient * base;\n        int16_t upper = (quotient + 1) * base;\n        \n        if (value - lower <= upper - value) {\n            dst[i] = lower;\n        } else {\n            dst[i] = upper;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_31", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid nearest_multiple(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        int16_t value = src[i];\n        int16_t quotient = value / base;\n        int16_t lower = quotient * base;\n        int16_t upper = (quotient + 1) * base;\n        dst[i] = (value - lower <= upper - value) ? lower : upper;\n    }\n}\n```"}
{"task_id": "SimdBench_31", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid nearest_multiple(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        int16_t value = src[i];\n        int16_t quotient = value / base;\n        int16_t lower = quotient * base;\n        int16_t upper = (quotient + 1) * base;\n        \n        if (value - lower <= upper - value) {\n            dst[i] = lower;\n        } else {\n            dst[i] = upper;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_32", "completion": "```cpp\n#include <cmath>\n\nbool matrix_has_row(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool match = true;\n        for (size_t j = 0; j < cols; ++j) {\n            if (!std::abs(matrix[i * cols + j] - vector[j]) < 1e-9) {\n                match = false;\n                break;\n            }\n        }\n        if (match) return true;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32", "completion": "```cpp\n#include <cmath>\n\nbool matrix_has_row(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool match = true;\n        for (size_t j = 0; j < cols; ++j) {\n            if (!std::abs(matrix[i * cols + j] - vector[j]) < 1e-9) {\n                match = false;\n                break;\n            }\n        }\n        if (match) return true;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32", "completion": "```cpp\n#include <cmath>\n\nbool matrix_has_row(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool match = true;\n        for (size_t j = 0; j < cols; ++j) {\n            if (!std::abs(matrix[i * cols + j] - vector[j]) < 1e-9) {\n                match = false;\n                break;\n            }\n        }\n        if (match) return true;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32", "completion": "```cpp\n#include <cmath>\n\nbool matrix_has_row(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool match = true;\n        for (size_t j = 0; j < cols; ++j) {\n            if (!std::abs(matrix[i * cols + j] - vector[j]) < 1e-9) {\n                match = false;\n                break;\n            }\n        }\n        if (match) return true;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32", "completion": "```cpp\n#include <cmath>\n\nbool matrix_has_row(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool match = true;\n        for (size_t j = 0; j < cols; ++j) {\n            if (!std::abs(matrix[i * cols + j] - vector[j]) < 1e-9) {\n                match = false;\n                break;\n            }\n        }\n        if (match) return true;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_33", "completion": "```c\n#include <stddef.h>\n\nsize_t tensor_4d_equal_count(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t count = 0;\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    \n    for (size_t i = 0; i < total_elements; ++i) {\n        if (A[i] == B[i]) {\n            ++count;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_33", "completion": "```c\n#include <stddef.h>\n\nsize_t tensor_4d_equal_count(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t count = 0;\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    \n    for (size_t i = 0; i < total_elements; ++i) {\n        if (A[i] == B[i]) {\n            ++count;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_33", "completion": "```c\n#include <stddef.h>\n\nsize_t tensor_4d_equal_count(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t count = 0;\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    \n    for (size_t i = 0; i < total_elements; ++i) {\n        if (A[i] == B[i]) {\n            ++count;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_33", "completion": "```c\n#include <stddef.h>\n\nsize_t tensor_4d_equal_count(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t count = 0;\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    \n    for (size_t i = 0; i < total_elements; ++i) {\n        if (A[i] == B[i]) {\n            ++count;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_33", "completion": "```c\n#include <stddef.h>\n\nsize_t tensor_4d_equal_count(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t count = 0;\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    \n    for (size_t i = 0; i < total_elements; ++i) {\n        if (A[i] == B[i]) {\n            ++count;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_34", "completion": "```c\n#include <stdlib.h>\n#include <stdint.h>\n\nvoid axm_abs(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; ++i) {\n        y[i] = abs(a * x[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_34", "completion": "```c\n#include <stdlib.h>\n#include <stdint.h>\n\nvoid axm_abs(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; ++i) {\n        y[i] = abs(a * x[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_34", "completion": "```c\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n\nvoid axm_abs(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; ++i) {\n        y[i] = abs(a * x[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_34", "completion": "```c\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n\nvoid axm_abs(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; ++i) {\n        y[i] = abs(a * x[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_34", "completion": "```c\n#include <stdlib.h>\n#include <stdint.h>\n\nvoid axm_abs(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; ++i) {\n        y[i] = abs(a * x[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_35", "completion": "```c\nMinMaxPair min_max_pair(const int16_t* vec, size_t length) {\n    MinMaxPair result = {vec[0], vec[0]};\n    \n    for (size_t i = 1; i < length; ++i) {\n        if (vec[i] < result.min_num) {\n            result.min_num = vec[i];\n        }\n        if (vec[i] > result.max_num) {\n            result.max_num = vec[i];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35", "completion": "```c\nMinMaxPair min_max_pair(const int16_t* vec, size_t length) {\n    MinMaxPair result = {vec[0], vec[0]};\n    \n    for (size_t i = 1; i < length; ++i) {\n        if (vec[i] < result.min_num) {\n            result.min_num = vec[i];\n        }\n        if (vec[i] > result.max_num) {\n            result.max_num = vec[i];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35", "completion": "```c\nMinMaxPair min_max_pair(const int16_t* vec, size_t length) {\n    MinMaxPair result = {vec[0], vec[0]};\n    \n    for (size_t i = 1; i < length; ++i) {\n        if (vec[i] < result.min_num) {\n            result.min_num = vec[i];\n        }\n        if (vec[i] > result.max_num) {\n            result.max_num = vec[i];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35", "completion": "```c\nMinMaxPair min_max_pair(const int16_t* vec, size_t length) {\n    MinMaxPair result = {vec[0], vec[0]};\n    \n    for (size_t i = 1; i < length; ++i) {\n        if (vec[i] < result.min_num) {\n            result.min_num = vec[i];\n        }\n        if (vec[i] > result.max_num) {\n            result.max_num = vec[i];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35", "completion": "```c\nMinMaxPair min_max_pair(const int16_t* vec, size_t length) {\n    MinMaxPair result = {vec[0], vec[0]};\n    \n    for (size_t i = 1; i < length; ++i) {\n        if (vec[i] < result.min_num) {\n            result.min_num = vec[i];\n        }\n        if (vec[i] > result.max_num) {\n            result.max_num = vec[i];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_36", "completion": "```cpp\n#include <iostream>\n#include <vector>\n\nbool matrix_rows_strictly_increasing(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 1; j < cols; ++j) {\n            if (*(matrix + i * cols + j) <= *(matrix + i * cols + j - 1)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36", "completion": "```c\n#include <stdbool.h>\n\nbool matrix_rows_strictly_increasing(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 1; j < cols; ++j) {\n            if (*(matrix + i * cols + j) <= *(matrix + i * cols + j - 1)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36", "completion": "```c\n#include <stdbool.h>\n\nbool matrix_rows_strictly_increasing(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 1; j < cols; ++j) {\n            if (matrix[i * cols + j] <= matrix[i * cols + j - 1]) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36", "completion": "```cpp\n#include <iostream>\n#include <vector>\n\nbool matrix_rows_strictly_increasing(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row_start = matrix + i * cols;\n        for (size_t j = 1; j < cols; ++j) {\n            if (row_start[j] <= row_start[j - 1]) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36", "completion": "```c\n#include <stdbool.h>\n\nbool matrix_rows_strictly_increasing(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 1; j < cols; ++j) {\n            if (*(matrix + i * cols + j) <= *(matrix + i * cols + j - 1)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37", "completion": "```cpp\n#include <iostream>\n#include <vector>\n\nbool matrix_blocks_equal(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    const int* first_block = matrix;\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            const int* current_block = &matrix[i * cols + j];\n            for (size_t k = 0; k < block_size; ++k) {\n                for (size_t l = 0; l < block_size; ++l) {\n                    if (*(current_block + k * cols + l) != *first_block) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37", "completion": "```cpp\n#include <iostream>\n#include <vector>\n\nbool matrix_blocks_equal(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    const int* first_block = matrix;\n    for (size_t i = 1; i < rows / block_size; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            if (*(first_block + i * cols + j) != *first_block) {\n                return false;\n            }\n        }\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 1; j < cols / block_size; ++j) {\n            if (*(first_block + i * cols + j * block_size) != *first_block) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37", "completion": "```cpp\n#include <iostream>\n#include <vector>\n\nbool matrix_blocks_equal(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    const int* first_block = matrix;\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            const int* current_block = &matrix[i * cols + j];\n            for (size_t k = 0; k < block_size; ++k) {\n                for (size_t l = 0; l < block_size; ++l) {\n                    if (*(current_block + k * cols + l) != *first_block) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37", "completion": "```cpp\n#include <iostream>\n#include <vector>\n\nbool matrix_blocks_equal(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    const int* first_block = matrix;\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            const int* current_block = &matrix[i * cols + j];\n            for (size_t k = 0; k < block_size; ++k) {\n                for (size_t l = 0; l < block_size; ++l) {\n                    if (*(current_block + k * cols + l) != *first_block) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37", "completion": "```cpp\n#include <iostream>\n#include <vector>\n\nbool matrix_blocks_equal(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    const int* first_block = matrix;\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            const int* current_block = &matrix[i * cols + j];\n            for (size_t k = 0; k < block_size; ++k) {\n                for (size_t l = 0; l < block_size; ++l) {\n                    if (*(current_block + k * cols + l) != *first_block) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_38", "completion": "```cpp\n#include <cmath>\n#include <cstddef>\n\nbool vector_block_equal(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (!vec || length == 0 || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    for (size_t i = 1; i * block_size < length; ++i) {\n        const double* block_start = vec + i * block_size;\n        bool equal = true;\n        for (size_t j = 0; j < block_size && equal; ++j) {\n            if (std::fabs(block_start[j] - vec[j]) > tolerance) {\n                equal = false;\n            }\n        }\n        if (!equal) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38", "completion": "```cpp\n#include <cmath>\n#include <cstddef>\n\nbool vector_block_equal(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (!vec || length == 0 || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    for (size_t i = block_size; i < length; i += block_size) {\n        bool equal = true;\n        for (size_t j = 0; j < block_size; ++j) {\n            if (std::abs(vec[i + j] - vec[j]) > tolerance) {\n                equal = false;\n                break;\n            }\n        }\n        if (!equal) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38", "completion": "```cpp\n#include <cmath>\n#include <cstddef>\n\nbool vector_block_equal(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (!vec || length == 0 || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    for (size_t i = 1; i <= length / block_size - 1; ++i) {\n        bool block_equal = true;\n        for (size_t j = 0; j < block_size; ++j) {\n            if (std::abs(vec[i * block_size + j] - vec[j]) > tolerance) {\n                block_equal = false;\n                break;\n            }\n        }\n        if (!block_equal) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38", "completion": "```cpp\n#include <cmath>\n#include <cstddef>\n\nbool vector_block_equal(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (!vec || length == 0 || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    for (size_t i = block_size; i < length; i += block_size) {\n        bool block_equal = true;\n        for (size_t j = 0; j < block_size; ++j) {\n            if (std::fabs(vec[i + j] - vec[j]) > tolerance) {\n                block_equal = false;\n                break;\n            }\n        }\n        if (!block_equal) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38", "completion": "```cpp\n#include <cmath>\n#include <cstddef>\n\nbool vector_block_equal(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (!vec || length == 0 || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    for (size_t i = block_size; i < length; i += block_size) {\n        bool block_equal = true;\n        for (size_t j = 0; j < block_size; ++j) {\n            if (std::fabs(vec[i + j] - vec[j]) > tolerance) {\n                block_equal = false;\n                break;\n            }\n        }\n        if (!block_equal) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_39", "completion": "```c\n#include <math.h>\n\nvoid matrix_row_norm_compare(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        double sum = 0.0;\n        for (size_t j = 0; j < cols; ++j) {\n            sum += matrix[i * cols + j] * matrix[i * cols + j];\n        }\n        result[i] = sqrt(sum) > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_39", "completion": "```c\n#include <math.h>\n\nvoid matrix_row_norm_compare(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        double norm = 0.0;\n        for (size_t j = 0; j < cols; ++j) {\n            norm += matrix[i * cols + j] * matrix[i * cols + j];\n        }\n        result[i] = sqrt(norm) > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_39", "completion": "```c\n#include <math.h>\n\nvoid matrix_row_norm_compare(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        double sum = 0.0;\n        for (size_t j = 0; j < cols; ++j) {\n            sum += matrix[i * cols + j] * matrix[i * cols + j];\n        }\n        result[i] = sqrt(sum) > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_39", "completion": "```c\n#include <math.h>\n\nvoid matrix_row_norm_compare(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        double norm = 0.0;\n        for (size_t j = 0; j < cols; ++j) {\n            norm += matrix[i * cols + j] * matrix[i * cols + j];\n        }\n        norm = sqrt(norm);\n        result[i] = norm > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_39", "completion": "```c\n#include <math.h>\n\nvoid matrix_row_norm_compare(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        double norm = 0.0;\n        for (size_t j = 0; j < cols; ++j) {\n            norm += matrix[i * cols + j] * matrix[i * cols + j];\n        }\n        norm = sqrt(norm);\n        result[i] = norm > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40", "completion": "```c\nfor (size_t i = 0; i < length; ++i) {\n    C[i] = A[i] | B[i];\n}\n```"}
{"task_id": "SimdBench_40", "completion": "```c\nfor (size_t i = 0; i < length; ++i) {\n    C[i] = A[i] | B[i];\n}\n```"}
{"task_id": "SimdBench_40", "completion": "```c\nfor (size_t i = 0; i < length; ++i) {\n    C[i] = A[i] | B[i];\n}\n```"}
{"task_id": "SimdBench_40", "completion": "```c\nfor (size_t i = 0; i < length; ++i) {\n    C[i] = A[i] | B[i];\n}\n```"}
{"task_id": "SimdBench_40", "completion": "```c\nfor (size_t i = 0; i < length; ++i) {\n    C[i] = A[i] | B[i];\n}\n```"}
{"task_id": "SimdBench_41", "completion": "```c\n#include <stdint.h>\n\nint64_t squarediff(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_of_squares = 0;\n    int64_t sum_of_products = 0;\n\n    for (size_t i = 0; i < length; ++i) {\n        sum_of_squares += (int64_t)A[i] * A[i];\n        sum_of_products += (int64_t)A[i] * B[i];\n    }\n\n    return sum_of_squares - 2 * sum_of_products;\n}\n```"}
{"task_id": "SimdBench_41", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nint64_t squarediff(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_of_squares = 0;\n    int64_t sum_of_products = 0;\n\n    for (size_t i = 0; i < length; ++i) {\n        sum_of_squares += (int64_t)A[i] * A[i];\n        sum_of_products += (int64_t)A[i] * B[i];\n    }\n\n    return sum_of_squares - 2 * sum_of_products;\n}\n```"}
{"task_id": "SimdBench_41", "completion": "```c\n#include <stdint.h>\n\nint64_t squarediff(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_of_squares = 0;\n    int64_t sum_of_products = 0;\n\n    for (size_t i = 0; i < length; ++i) {\n        sum_of_squares += (int64_t)A[i] * A[i];\n        sum_of_products += (int64_t)A[i] * B[i];\n    }\n\n    return sum_of_squares - 2 * sum_of_products;\n}\n```"}
{"task_id": "SimdBench_41", "completion": "```c\n#include <stdint.h>\n\nint64_t squarediff(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_of_squares = 0;\n    int64_t sum_of_products = 0;\n\n    for (size_t i = 0; i < length; ++i) {\n        sum_of_squares += (int64_t)A[i] * A[i];\n        sum_of_products += (int64_t)A[i] * B[i];\n    }\n\n    return sum_of_squares - 2 * sum_of_products;\n}\n```"}
{"task_id": "SimdBench_41", "completion": "```c\n#include <stdint.h>\n\nint64_t squarediff(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_of_squares = 0;\n    int64_t sum_of_products = 0;\n\n    for (size_t i = 0; i < length; ++i) {\n        sum_of_squares += (int64_t)A[i] * A[i];\n        sum_of_products += (int64_t)A[i] * B[i];\n    }\n\n    return sum_of_squares - 2 * sum_of_products;\n}\n```"}
{"task_id": "SimdBench_42", "completion": "```c\nfor (size_t i = 0; i < length; ++i) {\n    C[i] = A[i] & ~B[i];\n}\n```"}
{"task_id": "SimdBench_42", "completion": "```c\n#include <stdint.h>\n\nvoid tensor_bit_clear(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42", "completion": "```c\n#include <stdint.h>\n\nvoid tensor_bit_clear(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42", "completion": "```c\n#include <stdint.h>\n\nvoid tensor_bit_clear(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42", "completion": "```c\n#include <stdint.h>\n\nvoid tensor_bit_clear(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_43", "completion": "```c\n#include <stdint.h>\n\nvoid tensor_three_valued_logic(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43", "completion": "```c\n#include <stdint.h>\n\nvoid tensor_three_valued_logic(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43", "completion": "```c\n#include <stdint.h>\n\nvoid tensor_three_valued_logic(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43", "completion": "```c\n#include <stdint.h>\n\nvoid tensor_three_valued_logic(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43", "completion": "```c\n#include <stdint.h>\n\nvoid tensor_three_valued_logic(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44", "completion": "```c\n#include <stdint.h>\n\nvoid tensor_bit_op(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n\n    for (size_t i = 0; i < midpoint; ++i) {\n        C[i] = A[i] ^ B[i];\n    }\n\n    for (size_t i = midpoint; i < length; ++i) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_44", "completion": "```c\n#include <stdint.h>\n\nvoid tensor_bit_op(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n\n    for (size_t i = 0; i < midpoint; ++i) {\n        C[i] = A[i] ^ B[i];\n    }\n\n    for (size_t i = midpoint; i < length; ++i) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_44", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nvoid tensor_bit_op(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n\n    for (size_t i = 0; i < midpoint; ++i) {\n        C[i] = A[i] ^ B[i];\n    }\n\n    for (size_t i = midpoint; i < length; ++i) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_44", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nvoid tensor_bit_op(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n\n    for (size_t i = 0; i < midpoint; ++i) {\n        C[i] = A[i] ^ B[i];\n    }\n\n    for (size_t i = midpoint; i < length; ++i) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_44", "completion": "```c\n#include <stdint.h>\n\nvoid tensor_bit_op(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n\n    for (size_t i = 0; i < midpoint; ++i) {\n        C[i] = A[i] ^ B[i];\n    }\n\n    for (size_t i = midpoint; i < length; ++i) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_45", "completion": "```cpp\n#include <iostream>\n#include <vector>\n\nvoid tensor_multi_select(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            for (size_t k = 0; k < dim3; ++k) {\n                size_t index = i * dim2 * dim3 + j * dim3 + k;\n                if (cond1[index] && cond2[index]) {\n                    out[index] = A[index];\n                } else if (cond1[index] && !cond2[index]) {\n                    out[index] = B[index];\n                } else if (!cond1[index] && cond2[index]) {\n                    out[index] = C[index];\n                } else {\n                    out[index] = D[index];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45", "completion": "```c\n#include <stdbool.h>\n\nvoid tensor_multi_select(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            for (size_t k = 0; k < dim3; ++k) {\n                size_t index = i * dim2 * dim3 + j * dim3 + k;\n                if (cond1[index] && cond2[index]) {\n                    out[index] = A[index];\n                } else if (cond1[index] && !cond2[index]) {\n                    out[index] = B[index];\n                } else if (!cond1[index] && cond2[index]) {\n                    out[index] = C[index];\n                } else {\n                    out[index] = D[index];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45", "completion": "```cpp\n#include <iostream>\n#include <vector>\n\nvoid tensor_multi_select(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            for (size_t k = 0; k < dim3; ++k) {\n                size_t index = i * dim2 * dim3 + j * dim3 + k;\n                if (cond1[index] && cond2[index]) {\n                    out[index] = A[index];\n                } else if (cond1[index] && !cond2[index]) {\n                    out[index] = B[index];\n                } else if (!cond1[index] && cond2[index]) {\n                    out[index] = C[index];\n                } else {\n                    out[index] = D[index];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45", "completion": "```cpp\n#include <iostream>\n#include <vector>\n\nvoid tensor_multi_select(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            for (size_t k = 0; k < dim3; ++k) {\n                size_t index = i * dim2 * dim3 + j * dim3 + k;\n                if (cond1[index] && cond2[index]) {\n                    out[index] = A[index];\n                } else if (cond1[index] && !cond2[index]) {\n                    out[index] = B[index];\n                } else if (!cond1[index] && cond2[index]) {\n                    out[index] = C[index];\n                } else {\n                    out[index] = D[index];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45", "completion": "```cpp\n#include <iostream>\n#include <vector>\n\nvoid tensor_multi_select(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            for (size_t k = 0; k < dim3; ++k) {\n                size_t index = i * dim2 * dim3 + j * dim3 + k;\n                if (cond1[index] && cond2[index]) {\n                    out[index] = A[index];\n                } else if (cond1[index] && !cond2[index]) {\n                    out[index] = B[index];\n                } else if (!cond1[index] && cond2[index]) {\n                    out[index] = C[index];\n                } else {\n                    out[index] = D[index];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_46", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid tensor_bit_count(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1 * dim2 * dim3; ++i) {\n        uint32_t value = A[i];\n        uint8_t count = 0;\n        while (value > 0) {\n            count += value & 1;\n            value >>= 1;\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_46", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid tensor_bit_count(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1 * dim2 * dim3; ++i) {\n        uint32_t value = A[i];\n        uint8_t count = 0;\n        while (value) {\n            count += value & 1;\n            value >>= 1;\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_46", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid tensor_bit_count(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1 * dim2 * dim3; ++i) {\n        uint32_t value = A[i];\n        uint8_t count = 0;\n        while (value > 0) {\n            count += value & 1;\n            value >>= 1;\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_46", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid tensor_bit_count(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1 * dim2 * dim3; ++i) {\n        uint32_t value = A[i];\n        uint8_t count = 0;\n        while (value) {\n            count += value & 1;\n            value >>= 1;\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_46", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid tensor_bit_count(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1 * dim2 * dim3; ++i) {\n        uint32_t value = A[i];\n        uint8_t count = 0;\n        while (value) {\n            count += value & 1;\n            value >>= 1;\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_47", "completion": "```c\n#include <stdlib.h>\n\nvoid matrix_conditional_abs(const int* A, int* B, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows * cols; ++i) {\n        if (A[i] % 3 == 0) {\n            B[i] = abs(A[i]);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47", "completion": "```c\n#include <stdlib.h>\n\nvoid matrix_conditional_abs(const int* A, int* B, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows * cols; ++i) {\n        if (A[i] % 3 == 0) {\n            B[i] = abs(A[i]);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47", "completion": "```c\n#include <stdlib.h>\n\nvoid matrix_conditional_abs(const int* A, int* B, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows * cols; ++i) {\n        if (A[i] % 3 == 0) {\n            B[i] = abs(A[i]);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47", "completion": "```c\n#include <stdlib.h>\n\nvoid matrix_conditional_abs(const int* A, int* B, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows * cols; ++i) {\n        if (A[i] % 3 == 0) {\n            B[i] = abs(A[i]);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47", "completion": "```c\n#include <stdlib.h>\n\nvoid matrix_conditional_abs(const int* A, int* B, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows * cols; ++i) {\n        if (A[i] % 3 == 0) {\n            B[i] = abs(A[i]);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48", "completion": "```c\n#include <stdint.h>\n\nvoid matrix_conditional_bit_rotate(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if ((src[i] & 0xF) == 0xF) {\n            dst[i] = (src[i] << rotate_bits) | (src[i] >> (32 - rotate_bits));\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48", "completion": "```c\n#include <stdint.h>\n\nvoid matrix_conditional_bit_rotate(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if ((src[i] & 0xF) == 0xF) {\n            dst[i] = (src[i] << rotate_bits) | (src[i] >> (32 - rotate_bits));\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48", "completion": "```c\n#include <stdint.h>\n\nvoid matrix_conditional_bit_rotate(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if ((src[i] & 0xF) == 0xF) {\n            dst[i] = (src[i] << rotate_bits) | (src[i] >> (32 - rotate_bits));\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48", "completion": "```c\n#include <stdint.h>\n\nvoid matrix_conditional_bit_rotate(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if ((src[i] & 0xF) == 0xF) {\n            dst[i] = (src[i] << rotate_bits) | (src[i] >> (32 - rotate_bits));\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48", "completion": "```c\n#include <stdint.h>\n\nvoid matrix_conditional_bit_rotate(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if ((src[i] & 0xF) == 0xF) {\n            dst[i] = (src[i] << rotate_bits) | (src[i] >> (32 - rotate_bits));\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49", "completion": "```c\n#include <math.h>\n\nvoid tensor_ternary_compare(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > fabs(epsilon)) {\n            out[i] = 1;\n        } else if (diff < -fabs(epsilon)) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49", "completion": "```c\n#include <math.h>\n\nvoid tensor_ternary_compare(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > fabs(epsilon)) {\n            out[i] = 1;\n        } else if (diff < -fabs(epsilon)) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49", "completion": "```c\n#include <math.h>\n\nvoid tensor_ternary_compare(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > fabs(epsilon)) {\n            out[i] = 1;\n        } else if (diff < -fabs(epsilon)) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49", "completion": "```c\n#include <math.h>\n\nvoid tensor_ternary_compare(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > fabs(epsilon)) {\n            out[i] = 1;\n        } else if (diff < -fabs(epsilon)) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49", "completion": "```c\n#include <math.h>\n\nvoid tensor_ternary_compare(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > fabs(epsilon)) {\n            out[i] = 1;\n        } else if (diff < -fabs(epsilon)) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50", "completion": "```c\n#include <stdint.h>\n#include <limits.h>\n\nvoid float_to_int_saturate(const float* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        if (A[i] > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (A[i] < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50", "completion": "```c\n#include <stdint.h>\n#include <limits.h>\n\nvoid float_to_int_saturate(const float* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        if (A[i] > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (A[i] < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50", "completion": "```c\n#include <stdint.h>\n#include <limits.h>\n\nvoid float_to_int_saturate(const float* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        if (A[i] > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (A[i] < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50", "completion": "```c\n#include <stdint.h>\n#include <limits.h>\n\nvoid float_to_int_saturate(const float* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        if (A[i] > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (A[i] < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50", "completion": "```c\n#include <stdint.h>\n#include <limits.h>\n\nvoid float_to_int_saturate(const float* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        if (A[i] > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (A[i] < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_51", "completion": "```c\n#include <stdint.h>\n#include <stdlib.h>\n\nvoid int_to_float_scaled(const int32_t* A, int8_t scale, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        B[i] = (float)A[i] * (scale / 127.0f);\n    }\n}\n```"}
{"task_id": "SimdBench_51", "completion": "```c\nvoid int_to_float_scaled(const int32_t* A, int8_t scale, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        B[i] = static_cast<float>(A[i]) * (scale / 127.0f);\n    }\n}\n```"}
{"task_id": "SimdBench_51", "completion": "```c\n#include <stdint.h>\n#include <stdlib.h>\n\nvoid int_to_float_scaled(const int32_t* A, int8_t scale, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        B[i] = (float)A[i] * (scale / 127.0f);\n    }\n}\n```"}
{"task_id": "SimdBench_51", "completion": "```c\nvoid int_to_float_scaled(const int32_t* A, int8_t scale, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        B[i] = static_cast<float>(A[i]) * (scale / 127.0f);\n    }\n}\n```"}
{"task_id": "SimdBench_51", "completion": "```c\n#include <stdint.h>\n#include <stdlib.h>\n\nvoid int_to_float_scaled(const int32_t* A, int8_t scale, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_52", "completion": "```c\n#include <math.h>\n\nvoid float_div_round(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        C[i] = round(A[i] / B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_52", "completion": "```c\n#include <math.h>\n\nvoid float_div_round(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        C[i] = (int32_t)round(A[i] / B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_52", "completion": "```c\n#include <math.h>\n\nvoid float_div_round(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        C[i] = (int32_t)round(A[i] / B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_52", "completion": "```c\n#include <math.h>\n\nvoid float_div_round(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        C[i] = (int32_t)round(A[i] / B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_52", "completion": "```c\n#include <math.h>\n\nvoid float_div_round(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        C[i] = (int32_t)round(A[i] / B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_53", "completion": "```c\n#include <limits.h>\n#include <math.h>\n\nvoid double_to_float_saturate(const double* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53", "completion": "```c\n#include <limits.h>\n#include <math.h>\n\nvoid double_to_float_saturate(const double* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53", "completion": "```c\n#include <float.h>\n#include <math.h>\n\nvoid double_to_float_saturate(const double* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53", "completion": "```c\n#include <float.h>\n#include <math.h>\n\nvoid double_to_float_saturate(const double* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53", "completion": "```c\n#include <float.h>\n#include <math.h>\n\nvoid double_to_float_saturate(const double* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_54", "completion": "```c\n#include <stdint.h>\n\nvoid int16_to_int32(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54", "completion": "```c\n#include <stdint.h>\n\nvoid int16_to_int32(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54", "completion": "```c\nvoid int16_to_int32(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54", "completion": "```c\n#include <stdint.h>\n\nvoid int16_to_int32(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54", "completion": "```c\n#include <stdint.h>\n\nvoid int16_to_int32(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_55", "completion": "```c\n#include <stdio.h>\n#include <stdint.h>\n\nvoid conditional_normalize(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    for (size_t i = 0; i < size; ++i) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            B[i] = (val < 0.0f) ? 0.0f : ((val > 1.0f) ? 1.0f : val);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55", "completion": "```c\n#include <stdio.h>\n#include <stdint.h>\n#include <math.h>\n\nvoid conditional_normalize(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    for (size_t i = 0; i < size; ++i) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            B[i] = fmax(0.0f, fmin(1.0f, val));\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55", "completion": "```c\n#include <stdio.h>\n#include <stdint.h>\n\nvoid conditional_normalize(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    for (size_t i = 0; i < size; ++i) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            B[i] = (val < 0.0f) ? 0.0f : ((val > 1.0f) ? 1.0f : val);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55", "completion": "```c\n#include <stdio.h>\n#include <stdint.h>\n#include <math.h>\n\nvoid conditional_normalize(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    for (size_t i = 0; i < size; ++i) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            B[i] = fmax(0.0f, fmin(1.0f, val));\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55", "completion": "```c\n#include <stdio.h>\n#include <stdint.h>\n\nvoid conditional_normalize(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    for (size_t i = 0; i < size; ++i) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            B[i] = val < 0.0f ? 0.0f : (val > 1.0f ? 1.0f : val);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_56", "completion": "```c\n#include <math.h>\n\nvoid int_to_float_sqrt(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        uint32_t value = A[i];\n        float high_16_bits = (value >> 16) & 0xFFFF;\n        B[i] = sqrtf(high_16_bits);\n    }\n}\n```"}
{"task_id": "SimdBench_56", "completion": "```c\n#include <math.h>\n\nvoid int_to_float_sqrt(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        uint32_t value = A[i];\n        float float_value = (float)(value >> 16);\n        B[i] = sqrtf(float_value);\n    }\n}\n```"}
{"task_id": "SimdBench_56", "completion": "```c\n#include <math.h>\n\nvoid int_to_float_sqrt(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        uint32_t value = A[i];\n        float float_value = (float)(value >> 16);\n        B[i] = sqrtf(float_value);\n    }\n}\n```"}
{"task_id": "SimdBench_56", "completion": "```c\n#include <math.h>\n\nvoid int_to_float_sqrt(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        uint32_t value = A[i];\n        float float_value = (float)(value >> 16);\n        B[i] = sqrtf(float_value);\n    }\n}\n```"}
{"task_id": "SimdBench_56", "completion": "```c\n#include <math.h>\n\nvoid int_to_float_sqrt(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        uint32_t value = A[i];\n        float float_value = (float)(value >> 16);\n        B[i] = sqrtf(float_value);\n    }\n}\n```"}
{"task_id": "SimdBench_57", "completion": "```c\n#include <stdint.h>\n\nvoid int_bits_to_float(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        B[i] = *(float*)&A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_57", "completion": "```c\n#include <stdint.h>\n\nvoid int_bits_to_float(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        *(float*)&B[i] = *(const float*)&A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_57", "completion": "```c\n#include <stdint.h>\n\nvoid int_bits_to_float(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        *(float*)&B[i] = *(const float*)&A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_57", "completion": "```c\n#include <stdint.h>\n#include <string.h>\n\nvoid int_bits_to_float(const uint32_t* A, float* B, size_t size) {\n    memcpy(B, A, size * sizeof(uint32_t));\n}\n```"}
{"task_id": "SimdBench_57", "completion": "```c\n#include <stdint.h>\n\nvoid int_bits_to_float(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        B[i] = *(float*)&A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_58", "completion": "```c\n#include <stddef.h>\n\nvoid conditional_diff(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        if (i == 0) {\n            diff[i] = 0.0f;\n        } else {\n            diff[i] = cond[i] ? static_cast<float>(A[i] - A[i - 1]) : 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58", "completion": "```c\n#include <stddef.h>\n\nvoid conditional_diff(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    diff[0] = 0.0f;\n    for (size_t i = 1; i < size; ++i) {\n        if (cond[i]) {\n            diff[i] = static_cast<float>(A[i] - A[i - 1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58", "completion": "```c\nvoid conditional_diff(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        if (i == 0) {\n            diff[i] = 0.0f;\n        } else {\n            diff[i] = cond[i] ? static_cast<float>(A[i] - A[i - 1]) : 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58", "completion": "```c\nvoid conditional_diff(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    diff[0] = 0.0f;\n    for (size_t i = 1; i < size; ++i) {\n        if (cond[i]) {\n            diff[i] = static_cast<float>(A[i] - A[i - 1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58", "completion": "```c\n#include <stdint.h>\n#include <stdbool.h>\n\nvoid conditional_diff(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        if (i == 0) {\n            diff[i] = 0.0f;\n        } else {\n            diff[i] = cond[i] ? (float)(A[i] - A[i - 1]) : 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_59", "completion": "```c\n#include <stdint.h>\n\nvoid widening_uint(const uint32_t* src, uint64_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = ((uint64_t)1 << 32) | src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_59", "completion": "```c\n#include <stdint.h>\n\nvoid widening_uint(const uint32_t* src, uint64_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = ((uint64_t)1 << 32) | src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_59", "completion": "```c\n#include <stdint.h>\n\nvoid widening_uint(const uint32_t* src, uint64_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = ((uint64_t)1 << 32) | src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_59", "completion": "```c\n#include <stdint.h>\n\nvoid widening_uint(const uint32_t* src, uint64_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = ((uint64_t)1 << 32) | src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_59", "completion": "```c\n#include <stdint.h>\n\nvoid widening_uint(const uint32_t* src, uint64_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = ((uint64_t)1 << 32) | src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_60", "completion": "```c\n#include <stddef.h>\n\ndouble indexed_sum(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    for (size_t i = 0; i < length; ++i) {\n        if (index[i] >= 0 && index[i] < length) {\n            sum += vec[index[i]];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60", "completion": "```c\n#include <stddef.h>\n\ndouble indexed_sum(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    for (size_t i = 0; i < length; ++i) {\n        if (index[i] >= 0 && index[i] < length) {\n            sum += vec[index[i]];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60", "completion": "```c\n#include <stddef.h>\n\ndouble indexed_sum(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    for (size_t i = 0; i < length; ++i) {\n        if (index[i] >= 0 && index[i] < length) {\n            sum += vec[index[i]];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60", "completion": "```c\n#include <stddef.h>\n\ndouble indexed_sum(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    for (size_t i = 0; i < length; ++i) {\n        if (index[i] >= 0 && index[i] < length) {\n            sum += vec[index[i]];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60", "completion": "```c\n#include <stddef.h>\n\ndouble indexed_sum(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    for (size_t i = 0; i < length; ++i) {\n        if (index[i] >= 0 && index[i] < length) {\n            sum += vec[index[i]];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_61", "completion": "```c\n#include <math.h>\n\nvoid simple_conv2d(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    sum += input[(i + ki) * input_size + (j + kj)] * kernel[ki * kernel_size + kj];\n                }\n            }\n            output[i * output_size + j] = fmax(sum, 0.0);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61", "completion": "```c\n#include <math.h>\n\nvoid simple_conv2d(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    sum += input[(i + ki) * input_size + (j + kj)] * kernel[ki * kernel_size + kj];\n                }\n            }\n            output[i * output_size + j] = fmax(sum, 0.0);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61", "completion": "```c\n#include <math.h>\n\nvoid simple_conv2d(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    sum += input[(i + ki) * input_size + (j + kj)] * kernel[ki * kernel_size + kj];\n                }\n            }\n            output[i * output_size + j] = fmax(sum, 0.0);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61", "completion": "```c\n#include <math.h>\n\nvoid simple_conv2d(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    sum += input[(i + ki) * input_size + (j + kj)] * kernel[ki * kernel_size + kj];\n                }\n            }\n            output[i * output_size + j] = fmax(sum, 0.0);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61", "completion": "```c\n#include <math.h>\n\nvoid simple_conv2d(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    sum += input[(i + ki) * input_size + (j + kj)] * kernel[ki * kernel_size + kj];\n                }\n            }\n            output[i * output_size + j] = fmax(sum, 0.0);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_62", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <limits>\n\nbool has_close_elements(const std::vector<double> & numbers, double threshold) {\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            if (std::abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <limits>\n\nbool has_close_elements(const std::vector<double> & numbers, double threshold) {\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            if (std::abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <limits>\n\nbool has_close_elements(const std::vector<double> & numbers, double threshold) {\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            if (std::abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <limits>\n\nbool has_close_elements(const std::vector<double> & numbers, double threshold) {\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            if (std::abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <limits>\n\nbool has_close_elements(const std::vector<double> & numbers, double threshold) {\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            if (std::abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63", "completion": "```cpp\n#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0;\n    for (int op : operations) {\n        balance += op;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63", "completion": "```cpp\n#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0;\n    for (int op : operations) {\n        balance += op;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63", "completion": "```cpp\n#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0;\n    for (int op : operations) {\n        balance += op;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63", "completion": "```cpp\n#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0;\n    for (int op : operations) {\n        balance += op;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63", "completion": "```cpp\n#include <vector>\nusing namespace std;\n\nbool below_zero(vector<int> operations) {\n    int balance = 0;\n    for (int op : operations) {\n        balance += op;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_64", "completion": "```cpp\n#include <vector>\n#include <numeric>\n#include <cmath>\n\ndouble mean_absolute_deviation(std::vector<double> numbers) {\n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / numbers.size();\n    double mad = 0.0;\n\n    for (double num : numbers) {\n        mad += std::abs(num - mean);\n    }\n\n    return mad / numbers.size();\n}\n```"}
{"task_id": "SimdBench_64", "completion": "```cpp\n#include <vector>\n#include <numeric>\n#include <cmath>\n\ndouble mean_absolute_deviation(std::vector<double> numbers) {\n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / numbers.size();\n    double mad = 0.0;\n\n    for (double num : numbers) {\n        mad += std::abs(num - mean);\n    }\n\n    return mad / numbers.size();\n}\n```"}
{"task_id": "SimdBench_64", "completion": "```cpp\n#include <vector>\n#include <numeric>\n#include <cmath>\n\ndouble mean_absolute_deviation(const std::vector<double>& numbers) {\n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / numbers.size();\n    \n    double mad = 0.0;\n    for (double num : numbers) {\n        mad += std::abs(num - mean);\n    }\n    \n    return mad / numbers.size();\n}\n```"}
{"task_id": "SimdBench_64", "completion": "```cpp\n#include <vector>\n#include <numeric>\n#include <cmath>\n\ndouble mean_absolute_deviation(std::vector<double> numbers) {\n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / numbers.size();\n    double mad = 0.0;\n\n    for (double num : numbers) {\n        mad += std::abs(num - mean);\n    }\n\n    return mad / numbers.size();\n}\n```"}
{"task_id": "SimdBench_64", "completion": "```cpp\n#include <vector>\n#include <numeric>\n#include <cmath>\n\ndouble mean_absolute_deviation(std::vector<double> numbers) {\n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / numbers.size();\n    double mad = 0.0;\n\n    for (double num : numbers) {\n        mad += std::abs(num - mean);\n    }\n\n    return mad / numbers.size();\n}\n```"}
{"task_id": "SimdBench_65", "completion": "```cpp\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter) {\n    std::vector<int> result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_65", "completion": "```cpp\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter) {\n    std::vector<int> result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_65", "completion": "```cpp\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter) {\n    std::vector<int> result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_65", "completion": "```cpp\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter) {\n    std::vector<int> result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_65", "completion": "```cpp\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter) {\n    std::vector<int> result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_66", "completion": "```cpp\n#include <vector>\n#include <numeric>\n\nstd::vector<int64_t> sum_product(const std::vector<int16_t>& numbers) {\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n    int64_t sum = std::accumulate(numbers.begin(), numbers.end(), 0);\n    int64_t product = std::accumulate(numbers.begin(), numbers.end(), 1, std::multiplies<int16_t>());\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66", "completion": "```cpp\n#include <vector>\n#include <numeric>\n\nstd::vector<int64_t> sum_product(const std::vector<int16_t>& numbers) {\n    int64_t sum = std::accumulate(numbers.begin(), numbers.end(), 0);\n    int64_t product = (numbers.empty()) ? 1 : std::accumulate(numbers.begin(), numbers.end(), 1LL, std::multiplies<int16_t>());\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66", "completion": "```cpp\n#include <vector>\n#include <numeric>\n\nstd::vector<int64_t> sum_product(const std::vector<int16_t>& numbers) {\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n    int64_t sum = std::accumulate(numbers.begin(), numbers.end(), 0);\n    int64_t product = std::accumulate(numbers.begin(), numbers.end(), 1, std::multiplies<int16_t>());\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66", "completion": "```cpp\n#include <vector>\n#include <numeric>\n\nstd::vector<int64_t> sum_product(const std::vector<int16_t>& numbers) {\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n    int64_t sum = std::accumulate(numbers.begin(), numbers.end(), 0);\n    int64_t product = std::accumulate(numbers.begin(), numbers.end(), 1, std::multiplies<int16_t>());\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66", "completion": "```cpp\n#include <vector>\n#include <numeric>\n\nstd::vector<int64_t> sum_product(const std::vector<int16_t>& numbers) {\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n    int64_t sum = std::accumulate(numbers.begin(), numbers.end(), 0);\n    int64_t product = std::accumulate(numbers.begin(), numbers.end(), 1, std::multiplies<int16_t>());\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_67", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max(std::vector<int> numbers) {\n    std::vector<int> result;\n    if (!numbers.empty()) {\n        int max_so_far = numbers[0];\n        for (int num : numbers) {\n            max_so_far = std::max(max_so_far, num);\n            result.push_back(max_so_far);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_67", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max(std::vector<int> numbers) {\n    std::vector<int> result;\n    if (!numbers.empty()) {\n        int current_max = numbers[0];\n        for (int num : numbers) {\n            current_max = std::max(current_max, num);\n            result.push_back(current_max);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_67", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max(std::vector<int> numbers) {\n    std::vector<int> result;\n    if (!numbers.empty()) {\n        int current_max = numbers[0];\n        for (int num : numbers) {\n            current_max = std::max(current_max, num);\n            result.push_back(current_max);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_67", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max(std::vector<int> numbers) {\n    std::vector<int> result;\n    if (!numbers.empty()) {\n        int current_max = numbers[0];\n        for (int num : numbers) {\n            current_max = std::max(current_max, num);\n            result.push_back(current_max);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_67", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max(std::vector<int> numbers) {\n    std::vector<int> result;\n    if (!numbers.empty()) {\n        int current_max = numbers[0];\n        for (int num : numbers) {\n            current_max = std::max(current_max, num);\n            result.push_back(current_max);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_68", "completion": "```cpp\n#include <iostream>\n#include <string>\n\nstd::string string_xor(std::string a, std::string b) {\n    std::string result;\n    for (size_t i = 0; i < a.length(); ++i) {\n        if (a[i] == b[i]) {\n            result += '0';\n        } else {\n            result += '1';\n        }\n    }\n    return result;\n}\n\nint main() {\n    std::cout << string_xor(\"010\", \"110\") << std::endl; // Output: \"100\"\n    return 0;\n}\n```"}
{"task_id": "SimdBench_68", "completion": "```cpp\n#include <iostream>\n#include <string>\n\nstd::string string_xor(std::string a, std::string b) {\n    std::string result;\n    for (size_t i = 0; i < a.length(); ++i) {\n        if (a[i] == b[i]) {\n            result += '0';\n        } else {\n            result += '1';\n        }\n    }\n    return result;\n}\n\nint main() {\n    std::cout << string_xor(\"010\", \"110\") << std::endl; // Output: \"100\"\n    return 0;\n}\n```"}
{"task_id": "SimdBench_68", "completion": "```cpp\n#include <iostream>\n#include <string>\n\nstd::string string_xor(std::string a, std::string b) {\n    std::string result;\n    for (size_t i = 0; i < a.length(); ++i) {\n        if (a[i] == b[i]) {\n            result += '0';\n        } else {\n            result += '1';\n        }\n    }\n    return result;\n}\n\nint main() {\n    std::cout << string_xor(\"010\", \"110\") << std::endl; // Output: \"100\"\n    return 0;\n}\n```"}
{"task_id": "SimdBench_68", "completion": "```cpp\n#include <iostream>\n#include <string>\n\nstd::string string_xor(std::string a, std::string b) {\n    std::string result;\n    for (size_t i = 0; i < a.length(); ++i) {\n        if (a[i] == b[i]) {\n            result += '0';\n        } else {\n            result += '1';\n        }\n    }\n    return result;\n}\n\nint main() {\n    std::cout << string_xor(\"010\", \"110\") << std::endl; // Output: \"100\"\n    return 0;\n}\n```"}
{"task_id": "SimdBench_68", "completion": "```cpp\n#include <iostream>\n#include <string>\n\nstd::string string_xor(std::string a, std::string b) {\n    std::string result;\n    for (size_t i = 0; i < a.length(); ++i) {\n        if (a[i] == b[i]) {\n            result += '0';\n        } else {\n            result += '1';\n        }\n    }\n    return result;\n}\n\nint main() {\n    std::cout << string_xor(\"010\", \"110\") << std::endl; // Output: \"100\"\n    return 0;\n}\n```"}
{"task_id": "SimdBench_69", "completion": "```cpp\n#include <optional>\n#include <string>\n#include <vector>\n\nstd::optional<std::string> longest(const std::vector<std::string> & strings) {\n    if (strings.empty()) {\n        return std::nullopt;\n    }\n\n    const std::string *longest_str = &strings[0];\n    for (const auto &str : strings) {\n        if (str.length() > longest_str->length()) {\n            longest_str = &str;\n        }\n    }\n\n    return *longest_str;\n}\n```"}
{"task_id": "SimdBench_69", "completion": "```cpp\n#include <vector>\n#include <optional>\n#include <string>\n#include <algorithm>\n\nstd::optional<std::string> longest(const std::vector<std::string> & strings) {\n    if (strings.empty()) {\n        return std::nullopt;\n    }\n    auto comp = [](const std::string & a, const std::string & b) {\n        return a.size() < b.size();\n    };\n    return *std::max_element(strings.begin(), strings.end(), comp);\n}\n```"}
{"task_id": "SimdBench_69", "completion": "```cpp\n#include <optional>\n#include <string>\n#include <vector>\n\nstd::optional<std::string> longest(const std::vector<std::string> & strings) {\n    if (strings.empty()) {\n        return std::nullopt;\n    }\n\n    const std::string *longest_str = &strings[0];\n    for (const auto &str : strings) {\n        if (str.length() > longest_str->length()) {\n            longest_str = &str;\n        }\n    }\n    return *longest_str;\n}\n```"}
{"task_id": "SimdBench_69", "completion": "```cpp\n#include <optional>\n#include <string>\n#include <vector>\n\nstd::optional<std::string> longest(const std::vector<std::string> & strings) {\n    if (strings.empty()) {\n        return std::nullopt;\n    }\n\n    const std::string *longest_str = &strings[0];\n    for (const auto &str : strings) {\n        if (str.length() > longest_str->length()) {\n            longest_str = &str;\n        }\n    }\n    return *longest_str;\n}\n```"}
{"task_id": "SimdBench_69", "completion": "```cpp\n#include <optional>\n#include <string>\n#include <vector>\n\nstd::optional<std::string> longest(const std::vector<std::string> & strings) {\n    if (strings.empty()) {\n        return std::nullopt;\n    }\n\n    const std::string *longest_str = &strings[0];\n    for (const auto &str : strings) {\n        if (str.length() > longest_str->length()) {\n            longest_str = &str;\n        }\n    }\n    return *longest_str;\n}\n```"}
{"task_id": "SimdBench_70", "completion": "```cpp\n#include <algorithm>\n\nuint64_t greatest_common_divisor(uint64_t a, uint64_t b) {\n    return std::gcd(a, b);\n}\n```"}
{"task_id": "SimdBench_70", "completion": "```cpp\n#include <iostream>\n\nuint64_t greatest_common_divisor(uint64_t a, uint64_t b) {\n    while (b != 0) {\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nint main() {\n    std::cout << greatest_common_divisor(3, 5) << std::endl; // Output: 1\n    std::cout << greatest_common_divisor(25, 15) << std::endl; // Output: 5\n    return 0;\n}\n```"}
{"task_id": "SimdBench_70", "completion": "```cpp\n#include <algorithm>\n\nuint64_t greatest_common_divisor(uint64_t a, uint64_t b) {\n    return std::gcd(a, b);\n}\n```"}
{"task_id": "SimdBench_70", "completion": "```cpp\n#include <algorithm>\n\nuint64_t greatest_common_divisor(uint64_t a, uint64_t b) {\n    return std::gcd(a, b);\n}\n```"}
{"task_id": "SimdBench_70", "completion": "```cpp\n#include <algorithm>\n\nuint64_t greatest_common_divisor(uint64_t a, uint64_t b) {\n    return std::gcd(a, b);\n}\n```"}
{"task_id": "SimdBench_71", "completion": "```cpp\n#include <algorithm>\n#include <limits>\n#include <vector>\n\nstd::pair<float, float> find_closest_elements(const std::vector<float>& numbers) {\n    if (numbers.size() < 2) {\n        throw std::invalid_argument(\"Vector must contain at least two elements\");\n    }\n\n    std::vector<float> sorted_numbers(numbers);\n    std::sort(sorted_numbers.begin(), sorted_numbers.end());\n\n    float min_diff = std::numeric_limits<float>::max();\n    std::pair<float, float> closest_pair;\n\n    for (size_t i = 0; i < sorted_numbers.size() - 1; ++i) {\n        float diff = sorted_numbers[i + 1] - sorted_numbers[i];\n        if (diff < min_diff) {\n            min_diff = diff;\n            closest_pair = {sorted_numbers[i], sorted_numbers[i + 1]};\n        }\n    }\n\n    return closest_pair;\n}\n```"}
{"task_id": "SimdBench_71", "completion": "```cpp\n#include <algorithm>\n#include <limits>\n#include <vector>\n\nstd::pair<float, float> find_closest_elements(const std::vector<float>& numbers) {\n    if (numbers.size() < 2) {\n        throw std::invalid_argument(\"Vector must contain at least two elements\");\n    }\n\n    std::vector<float> sorted_numbers(numbers);\n    std::sort(sorted_numbers.begin(), sorted_numbers.end());\n\n    float min_diff = std::numeric_limits<float>::max();\n    std::pair<float, float> closest_pair;\n\n    for (size_t i = 0; i < sorted_numbers.size() - 1; ++i) {\n        float diff = sorted_numbers[i + 1] - sorted_numbers[i];\n        if (diff < min_diff) {\n            min_diff = diff;\n            closest_pair = {sorted_numbers[i], sorted_numbers[i + 1]};\n        }\n    }\n\n    return closest_pair;\n}\n```"}
{"task_id": "SimdBench_71", "completion": "```cpp\n#include <algorithm>\n#include <limits>\n#include <vector>\n\nstd::pair<float, float> find_closest_elements(const std::vector<float>& numbers) {\n    if (numbers.size() < 2) {\n        throw std::invalid_argument(\"Input vector must contain at least two elements.\");\n    }\n\n    std::vector<float> sorted_numbers(numbers);\n    std::sort(sorted_numbers.begin(), sorted_numbers.end());\n\n    float min_diff = std::numeric_limits<float>::max();\n    std::pair<float, float> closest_pair;\n\n    for (size_t i = 0; i < sorted_numbers.size() - 1; ++i) {\n        float diff = sorted_numbers[i + 1] - sorted_numbers[i];\n        if (diff < min_diff) {\n            min_diff = diff;\n            closest_pair = {sorted_numbers[i], sorted_numbers[i + 1]};\n        }\n    }\n\n    return closest_pair;\n}\n```"}
{"task_id": "SimdBench_71", "completion": "```cpp\n#include <algorithm>\n#include <limits>\n#include <vector>\n\nstd::pair<float, float> find_closest_elements(const std::vector<float>& numbers) {\n    if (numbers.size() < 2) {\n        throw std::invalid_argument(\"Vector must contain at least two elements\");\n    }\n\n    std::vector<float> sorted_numbers(numbers);\n    std::sort(sorted_numbers.begin(), sorted_numbers.end());\n\n    float min_diff = std::numeric_limits<float>::max();\n    std::pair<float, float> closest_pair;\n\n    for (size_t i = 0; i < sorted_numbers.size() - 1; ++i) {\n        float diff = sorted_numbers[i + 1] - sorted_numbers[i];\n        if (diff < min_diff) {\n            min_diff = diff;\n            closest_pair = {sorted_numbers[i], sorted_numbers[i + 1]};\n        }\n    }\n\n    return closest_pair;\n}\n```"}
{"task_id": "SimdBench_71", "completion": "```cpp\n#include <algorithm>\n#include <limits>\n#include <vector>\n\nstd::pair<float, float> find_closest_elements(const std::vector<float>& numbers) {\n    if (numbers.size() < 2) {\n        throw std::invalid_argument(\"Input vector must contain at least two elements.\");\n    }\n\n    std::vector<float> sorted_numbers(numbers);\n    std::sort(sorted_numbers.begin(), sorted_numbers.end());\n\n    float min_diff = std::numeric_limits<float>::max();\n    std::pair<float, float> closest_pair;\n\n    for (size_t i = 0; i < sorted_numbers.size() - 1; ++i) {\n        float diff = sorted_numbers[i + 1] - sorted_numbers[i];\n        if (diff < min_diff) {\n            min_diff = diff;\n            closest_pair = {sorted_numbers[i], sorted_numbers[i + 1]};\n        }\n    }\n\n    return closest_pair;\n}\n```"}
{"task_id": "SimdBench_72", "completion": "```cpp\n#include <algorithm>\n#include <vector>\n\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    std::vector<float> result;\n    for (float num : numbers) {\n        result.push_back((num - min_val) / (max_val - min_val));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_72", "completion": "```cpp\n#include <algorithm>\n#include <vector>\n\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    std::vector<float> result;\n    for (float num : numbers) {\n        result.push_back((num - min_val) / (max_val - min_val));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_72", "completion": "```cpp\n#include <algorithm>\n#include <vector>\n\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    std::vector<float> result;\n    for (float num : numbers) {\n        result.push_back((num - min_val) / (max_val - min_val));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_72", "completion": "```cpp\n#include <algorithm>\n#include <vector>\n\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    std::vector<float> result;\n    for (float num : numbers) {\n        result.push_back((num - min_val) / (max_val - min_val));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_72", "completion": "```cpp\n#include <algorithm>\n#include <vector>\n\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    std::vector<float> result;\n    for (float num : numbers) {\n        result.push_back((num - min_val) / (max_val - min_val));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_73", "completion": "```c\n#include <stdint.h>\n\nuint64_t largest_divisor(uint64_t n) {\n    for (uint64_t i = n / 2; i > 0; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return 1; // If no divisor found other than 1, return 1\n}\n```"}
{"task_id": "SimdBench_73", "completion": "```c\n#include <stdint.h>\n\nuint64_t largest_divisor(uint64_t n) {\n    for (uint64_t i = n / 2; i > 0; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return 1; // If no divisor found other than 1, return 1\n}\n```"}
{"task_id": "SimdBench_73", "completion": "```c\n#include <stdint.h>\n\nuint64_t largest_divisor(uint64_t n) {\n    for (uint64_t i = n / 2; i > 0; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return 1; // If no divisor found other than 1, return 1\n}\n```"}
{"task_id": "SimdBench_73", "completion": "```c\n#include <stdint.h>\n\nuint64_t largest_divisor(uint64_t n) {\n    for (uint64_t i = n / 2; i > 0; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return 1; // Every number is divisible by 1\n}\n```"}
{"task_id": "SimdBench_73", "completion": "```c\n#include <stdint.h>\n\nuint64_t largest_divisor(uint64_t n) {\n    for (uint64_t i = n / 2; i > 0; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return 1; // If no divisor found other than 1, return 1\n}\n```"}
{"task_id": "SimdBench_74", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nstd::vector<int> factorize(int n) {\n    std::vector<int> factors;\n    // Divide by 2 until n is odd\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    // Check for odd factors\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    // If n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nstd::vector<int> factorize(int n) {\n    std::vector<int> factors;\n    // Divide by 2 until n is odd\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    // Check for odd factors\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    // If n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nstd::vector<int> factorize(int n) {\n    std::vector<int> factors;\n    // Divide by 2 until n is odd\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    // Check for odd factors\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    // If n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nstd::vector<int> factorize(int n) {\n    std::vector<int> factors;\n    // Divide by 2 until n is odd\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    // Check for odd factors\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    // If n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nstd::vector<int> factorize(int n) {\n    std::vector<int> factors;\n    // Divide by 2 until n is odd\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    // Check for odd factors\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    // If n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n```"}
{"task_id": "SimdBench_75", "completion": "```cpp\nstd::vector<float> get_positive(const std::vector<float> & l) {\n    std::vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75", "completion": "```cpp\nstd::vector<float> get_positive(const std::vector<float> & l) {\n    std::vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75", "completion": "```cpp\nstd::vector<float> get_positive(const std::vector<float> & l) {\n    std::vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75", "completion": "```cpp\nstd::vector<float> get_positive(const std::vector<float> & l) {\n    std::vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75", "completion": "```cpp\nstd::vector<float> get_positive(const std::vector<float> & l) {\n    std::vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_76", "completion": "```cpp\nbool is_prime(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int64_t i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76", "completion": "```cpp\nbool is_prime(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int64_t i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76", "completion": "```cpp\nbool is_prime(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int64_t i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76", "completion": "```cpp\nbool is_prime(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int64_t i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76", "completion": "```cpp\n#include <iostream>\n#include <cmath>\n\nbool is_prime(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int64_t i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nint main() {\n    std::cout << std::boolalpha;\n    std::cout << is_prime(6) << std::endl;       // false\n    std::cout << is_prime(101) << std::endl;     // true\n    std::cout << is_prime(11) << std::endl;      // true\n    std::cout << is_prime(13441) << std::endl;   // true\n    std::cout << is_prime(61) << std::endl;      // true\n    std::cout << is_prime(4) << std::endl;       // false\n    std::cout << is_prime(1) << std::endl;       // false\n    return 0;\n}\n```"}
{"task_id": "SimdBench_77", "completion": "```cpp\n#include <algorithm>\n#include <cctype>\n\nstd::string solve(const std::string & s) {\n    bool hasLetters = false;\n    for (char c : s) {\n        if (std::isalpha(c)) {\n            hasLetters = true;\n            break;\n        }\n    }\n\n    if (!hasLetters) {\n        std::string reversed(s.rbegin(), s.rend());\n        return reversed;\n    } else {\n        std::string result = s;\n        std::transform(result.begin(), result.end(), result.begin(),\n                       [](unsigned char c) -> unsigned char {\n                           if (std::isalpha(c)) {\n                               return std::islower(c) ? std::toupper(c) : std::tolower(c);\n                           }\n                           return c;\n                       });\n        return result;\n    }\n}\n```"}
{"task_id": "SimdBench_77", "completion": "```cpp\n#include <algorithm>\n#include <cctype>\n\nstd::string solve(const std::string & s) {\n    bool hasLetters = false;\n    for (char c : s) {\n        if (std::isalpha(c)) {\n            hasLetters = true;\n            break;\n        }\n    }\n\n    if (!hasLetters) {\n        std::string reversed(s.rbegin(), s.rend());\n        return reversed;\n    } else {\n        std::string result = s;\n        std::transform(result.begin(), result.end(), result.begin(),\n                       [](unsigned char c){ return std::isalpha(c) ? (std::islower(c) ? std::toupper(c) : std::tolower(c)) : c; });\n        return result;\n    }\n}\n```"}
{"task_id": "SimdBench_77", "completion": "```cpp\n#include <algorithm>\n#include <cctype>\n\nstd::string solve(const std::string & s) {\n    bool hasLetters = false;\n    for (char c : s) {\n        if (std::isalpha(c)) {\n            hasLetters = true;\n            break;\n        }\n    }\n\n    if (!hasLetters) {\n        std::string reversed(s.rbegin(), s.rend());\n        return reversed;\n    } else {\n        std::string result = s;\n        std::transform(result.begin(), result.end(), result.begin(), [](unsigned char c) -> unsigned char {\n            if (std::isalpha(c)) {\n                return std::islower(c) ? std::toupper(c) : std::tolower(c);\n            }\n            return c;\n        });\n        return result;\n    }\n}\n```"}
{"task_id": "SimdBench_77", "completion": "```cpp\n#include <algorithm>\n#include <cctype>\n\nstd::string solve(const std::string & s) {\n    bool hasLetters = false;\n    for (char c : s) {\n        if (std::isalpha(c)) {\n            hasLetters = true;\n            break;\n        }\n    }\n\n    if (!hasLetters) {\n        std::string reversed(s.rbegin(), s.rend());\n        return reversed;\n    } else {\n        std::string result = s;\n        std::transform(result.begin(), result.end(), result.begin(), [](unsigned char c) -> unsigned char {\n            if (std::isalpha(c)) {\n                return std::islower(c) ? std::toupper(c) : std::tolower(c);\n            }\n            return c;\n        });\n        return result;\n    }\n}\n```"}
{"task_id": "SimdBench_77", "completion": "```cpp\n#include <algorithm>\n#include <cctype>\n\nstd::string solve(const std::string & s) {\n    bool hasLetters = false;\n    for (char c : s) {\n        if (std::isalpha(c)) {\n            hasLetters = true;\n            break;\n        }\n    }\n\n    if (!hasLetters) {\n        std::string reversed(s.rbegin(), s.rend());\n        return reversed;\n    } else {\n        std::string result = s;\n        std::transform(result.begin(), result.end(), result.begin(),\n                       [](unsigned char c) -> unsigned char {\n                           if (std::isalpha(c)) {\n                               return std::islower(c) ? std::toupper(c) : std::tolower(c);\n                           }\n                           return c;\n                       });\n        return result;\n    }\n}\n```"}
{"task_id": "SimdBench_78", "completion": "```cpp\n#include <algorithm>\n#include <vector>\n\nstd::vector<int> sort_third(std::vector<int> l) {\n    std::vector<int> indices_divisible_by_three;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if ((i + 1) % 3 == 0) {\n            indices_divisible_by_three.push_back(l[i]);\n        }\n    }\n    std::sort(indices_divisible_by_three.begin(), indices_divisible_by_three.end());\n    size_t j = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if ((i + 1) % 3 == 0) {\n            l[i] = indices_divisible_by_three[j++];\n        }\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_78", "completion": "```cpp\n#include <algorithm>\n#include <vector>\n\nstd::vector<int> sort_third(std::vector<int> l) {\n    std::vector<int> indices_divisible_by_three;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if ((i + 1) % 3 == 0) {\n            indices_divisible_by_three.push_back(l[i]);\n        }\n    }\n    std::sort(indices_divisible_by_three.begin(), indices_divisible_by_three.end());\n    size_t j = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if ((i + 1) % 3 == 0) {\n            l[i] = indices_divisible_by_three[j++];\n        }\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_78", "completion": "```cpp\n#include <algorithm>\n#include <vector>\n\nstd::vector<int> sort_third(std::vector<int> l) {\n    std::vector<int> indices_divisible_by_three;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if ((i + 1) % 3 == 0) {\n            indices_divisible_by_three.push_back(l[i]);\n        }\n    }\n    std::sort(indices_divisible_by_three.begin(), indices_divisible_by_three.end());\n    size_t j = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if ((i + 1) % 3 == 0) {\n            l[i] = indices_divisible_by_three[j++];\n        }\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_78", "completion": "```cpp\n#include <algorithm>\n#include <vector>\n\nstd::vector<int> sort_third(std::vector<int> l) {\n    std::vector<int> indices_divisible_by_three;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if ((i + 1) % 3 == 0) {\n            indices_divisible_by_three.push_back(i);\n        }\n    }\n    std::sort(indices_divisible_by_three.begin(), indices_divisible_by_three.end());\n    for (int index : indices_divisible_by_three) {\n        int min_index = index;\n        for (int j = index + 1; j < l.size(); ++j) {\n            if (l[j] < l[min_index]) {\n                min_index = j;\n            }\n        }\n        std::swap(l[index], l[min_index]);\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_78", "completion": "```cpp\n#include <algorithm>\n#include <vector>\n\nstd::vector<int> sort_third(std::vector<int> l) {\n    std::vector<int> indices_divisible_by_three;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if ((i + 1) % 3 == 0) {\n            indices_divisible_by_three.push_back(l[i]);\n        }\n    }\n    std::sort(indices_divisible_by_three.begin(), indices_divisible_by_three.end());\n    size_t j = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if ((i + 1) % 3 == 0) {\n            l[i] = indices_divisible_by_three[j++];\n        }\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_79", "completion": "```cpp\nfloat max_element(std::vector<float> l) {\n    return *std::max_element(l.begin(), l.end());\n}\n```"}
{"task_id": "SimdBench_79", "completion": "```cpp\n#include <algorithm>\n#include <vector>\n\nfloat max_element(std::vector<float> l) {\n    return *std::max_element(l.begin(), l.end());\n}\n```"}
{"task_id": "SimdBench_79", "completion": "```cpp\n#include <algorithm>\n#include <vector>\n\nfloat max_element(std::vector<float> l) {\n    return *std::max_element(l.begin(), l.end());\n}\n```"}
{"task_id": "SimdBench_79", "completion": "```cpp\n#include <algorithm>\n\nfloat max_element(std::vector<float> l) {\n    return *std::max_element(l.begin(), l.end());\n}\n```"}
{"task_id": "SimdBench_79", "completion": "```cpp\nfloat max_element(std::vector<float> l) {\n    return *std::max_element(l.begin(), l.end());\n}\n```"}
{"task_id": "SimdBench_80", "completion": "```c\n#include <stdio.h>\n\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 1; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int num = i;\n            while (num > 0) {\n                if (num % 10 == 7) {\n                    count++;\n                }\n                num /= 10;\n            }\n        }\n    }\n    return count;\n}\n\nint main() {\n    printf(\"%d\\n\", fizz_buzz(50)); // Output: 0\n    printf(\"%d\\n\", fizz_buzz(78)); // Output: 2\n    printf(\"%d\\n\", fizz_buzz(79)); // Output: 3\n    return 0;\n}\n```"}
{"task_id": "SimdBench_80", "completion": "```c\n#include <stdio.h>\n\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 1; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int num = i;\n            while (num > 0) {\n                if (num % 10 == 7) {\n                    count++;\n                }\n                num /= 10;\n            }\n        }\n    }\n    return count;\n}\n\nint main() {\n    printf(\"%d\\n\", fizz_buzz(50)); // Output: 0\n    printf(\"%d\\n\", fizz_buzz(78)); // Output: 2\n    printf(\"%d\\n\", fizz_buzz(79)); // Output: 3\n    return 0;\n}\n```"}
{"task_id": "SimdBench_80", "completion": "```c\n#include <stdio.h>\n\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 1; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int num = i;\n            while (num > 0) {\n                if (num % 10 == 7) {\n                    count++;\n                }\n                num /= 10;\n            }\n        }\n    }\n    return count;\n}\n\nint main() {\n    printf(\"%d\\n\", fizz_buzz(50)); // Output: 0\n    printf(\"%d\\n\", fizz_buzz(78)); // Output: 2\n    printf(\"%d\\n\", fizz_buzz(79)); // Output: 3\n    return 0;\n}\n```"}
{"task_id": "SimdBench_80", "completion": "```c\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 1; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int num = i;\n            while (num > 0) {\n                if (num % 10 == 7) {\n                    count++;\n                }\n                num /= 10;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80", "completion": "```c\n#include <stdio.h>\n\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 1; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int num = i;\n            while (num > 0) {\n                if (num % 10 == 7) {\n                    count++;\n                }\n                num /= 10;\n            }\n        }\n    }\n    return count;\n}\n\nint main() {\n    printf(\"%d\\n\", fizz_buzz(50)); // Output: 0\n    printf(\"%d\\n\", fizz_buzz(78)); // Output: 2\n    printf(\"%d\\n\", fizz_buzz(79)); // Output: 3\n    return 0;\n}\n```"}
{"task_id": "SimdBench_81", "completion": "```cpp\n#include <algorithm>\n#include <vector>\n\nstd::vector<float> sort_even(std::vector<float> l) {\n    std::vector<float> even_elements;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_elements.push_back(l[i]);\n    }\n    std::sort(even_elements.begin(), even_elements.end());\n    for (size_t i = 0, j = 0; i < l.size(); i += 2, ++j) {\n        l[i] = even_elements[j];\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_81", "completion": "```cpp\n#include <algorithm>\n#include <vector>\n\nstd::vector<float> sort_even(std::vector<float> l) {\n    std::vector<float> even_elements;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_elements.push_back(l[i]);\n    }\n    std::sort(even_elements.begin(), even_elements.end());\n    for (size_t i = 0, j = 0; i < l.size(); i += 2, ++j) {\n        l[i] = even_elements[j];\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_81", "completion": "```cpp\n#include <algorithm>\n#include <vector>\n\nstd::vector<float> sort_even(std::vector<float> l) {\n    std::vector<float> even_elements;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_elements.push_back(l[i]);\n    }\n    std::sort(even_elements.begin(), even_elements.end());\n    for (size_t i = 0, j = 0; i < l.size(); i += 2, ++j) {\n        l[i] = even_elements[j];\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_81", "completion": "```cpp\n#include <algorithm>\n#include <vector>\n\nstd::vector<float> sort_even(std::vector<float> l) {\n    std::vector<float> even_elements;\n    \n    // Extract even-indexed elements\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_elements.push_back(l[i]);\n    }\n    \n    // Sort the extracted elements\n    std::sort(even_elements.begin(), even_elements.end());\n    \n    // Place the sorted elements back into their original positions\n    for (size_t i = 0, j = 0; i < l.size(); i += 2, ++j) {\n        l[i] = even_elements[j];\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_81", "completion": "```cpp\n#include <algorithm>\n#include <vector>\n\nstd::vector<float> sort_even(std::vector<float> l) {\n    std::vector<float> even_elements;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_elements.push_back(l[i]);\n    }\n    std::sort(even_elements.begin(), even_elements.end());\n    for (size_t i = 0, j = 0; i < l.size(); i += 2, ++j) {\n        l[i] = even_elements[j];\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_82", "completion": "```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nbool triples_sum_to_zero(std::vector<int> l) {\n    std::sort(l.begin(), l.end());\n    for (size_t i = 0; i < l.size() - 2; ++i) {\n        size_t j = i + 1;\n        size_t k = l.size() - 1;\n        while (j < k) {\n            int sum = l[i] + l[j] + l[k];\n            if (sum == 0) {\n                return true;\n            } else if (sum < 0) {\n                ++j;\n            } else {\n                --k;\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    assert(triples_sum_to_zero({1, 3, 5, 0}) == false);\n    assert(triples_sum_to_zero({1, 3, -2, 1}) == true);\n    assert(triples_sum_to_zero({1, 2, 3, 7}) == false);\n    assert(triples_sum_to_zero({2, 4, -5, 3, 9, 7}) == true);\n    assert(triples_sum_to_zero({1}) == false);\n    std::cout << \"All tests passed successfully.\" << std::endl;\n    return 0;\n}\n```"}
{"task_id": "SimdBench_82", "completion": "```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nbool triples_sum_to_zero(std::vector<int> l) {\n    std::sort(l.begin(), l.end());\n    for (size_t i = 0; i < l.size() - 2; ++i) {\n        size_t j = i + 1;\n        size_t k = l.size() - 1;\n        while (j < k) {\n            int sum = l[i] + l[j] + l[k];\n            if (sum == 0) {\n                return true;\n            } else if (sum < 0) {\n                ++j;\n            } else {\n                --k;\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    assert(triples_sum_to_zero({1, 3, 5, 0}) == false);\n    assert(triples_sum_to_zero({1, 3, -2, 1}) == true);\n    assert(triples_sum_to_zero({1, 2, 3, 7}) == false);\n    assert(triples_sum_to_zero({2, 4, -5, 3, 9, 7}) == true);\n    assert(triples_sum_to_zero({1}) == false);\n    std::cout << \"All tests passed successfully.\" << std::endl;\n    return 0;\n}\n```"}
{"task_id": "SimdBench_82", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool triples_sum_to_zero(std::vector<int> l) {\n    std::sort(l.begin(), l.end());\n    for (size_t i = 0; i < l.size() - 2; ++i) {\n        size_t j = i + 1;\n        size_t k = l.size() - 1;\n        while (j < k) {\n            int sum = l[i] + l[j] + l[k];\n            if (sum == 0) {\n                return true;\n            } else if (sum < 0) {\n                ++j;\n            } else {\n                --k;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82", "completion": "```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nbool triples_sum_to_zero(std::vector<int> l) {\n    std::sort(l.begin(), l.end());\n    for (size_t i = 0; i < l.size() - 2; ++i) {\n        size_t j = i + 1;\n        size_t k = l.size() - 1;\n        while (j < k) {\n            int sum = l[i] + l[j] + l[k];\n            if (sum == 0) {\n                return true;\n            } else if (sum < 0) {\n                ++j;\n            } else {\n                --k;\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    assert(triples_sum_to_zero({1, 3, 5, 0}) == false);\n    assert(triples_sum_to_zero({1, 3, -2, 1}) == true);\n    assert(triples_sum_to_zero({1, 2, 3, 7}) == false);\n    assert(triples_sum_to_zero({2, 4, -5, 3, 9, 7}) == true);\n    assert(triples_sum_to_zero({1}) == false);\n    std::cout << \"All tests passed successfully.\" << std::endl;\n    return 0;\n}\n```"}
{"task_id": "SimdBench_82", "completion": "```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nbool triples_sum_to_zero(std::vector<int> l) {\n    std::sort(l.begin(), l.end());\n    for (size_t i = 0; i < l.size() - 2; ++i) {\n        size_t j = i + 1;\n        size_t k = l.size() - 1;\n        while (j < k) {\n            int sum = l[i] + l[j] + l[k];\n            if (sum == 0) {\n                return true;\n            } else if (sum < 0) {\n                ++j;\n            } else {\n                --k;\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    assert(triples_sum_to_zero({1, 3, 5, 0}) == false);\n    assert(triples_sum_to_zero({1, 3, -2, 1}) == true);\n    assert(triples_sum_to_zero({1, 2, 3, 7}) == false);\n    assert(triples_sum_to_zero({2, 4, -5, 3, 9, 7}) == true);\n    assert(triples_sum_to_zero({1}) == false);\n    std::cout << \"All tests passed!\" << std::endl;\n    return 0;\n}\n```"}
{"task_id": "SimdBench_83", "completion": "```cpp\nstd::vector<int> incr_list(std::vector<int> l) {\n    for (auto& elem : l) {\n        ++elem;\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_83", "completion": "```cpp\nstd::vector<int> incr_list(std::vector<int> l) {\n    for (auto& elem : l) {\n        ++elem;\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_83", "completion": "```cpp\nstd::vector<int> incr_list(std::vector<int> l) {\n    for (auto& elem : l) {\n        ++elem;\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_83", "completion": "```cpp\nstd::vector<int> incr_list(std::vector<int> l) {\n    for (auto& elem : l) {\n        ++elem;\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_83", "completion": "```cpp\nstd::vector<int> incr_list(std::vector<int> l) {\n    for (auto& elem : l) {\n        ++elem;\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_84", "completion": "```cpp\n#include <unordered_set>\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    unordered_set<int> seen;\n    for (int num : l) {\n        if (seen.count(-num)) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84", "completion": "```cpp\n#include <unordered_set>\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    unordered_set<int> seen;\n    for (int num : l) {\n        if (seen.count(-num)) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84", "completion": "```cpp\n#include <unordered_set>\n#include <vector>\n\nbool pairs_sum_to_zero(std::vector<int> l) {\n    std::unordered_set<int> seen;\n    for (int num : l) {\n        if (seen.count(-num)) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84", "completion": "```cpp\n#include <unordered_set>\n#include <vector>\n\nbool pairs_sum_to_zero(std::vector<int> l) {\n    std::unordered_set<int> seen;\n    for (int num : l) {\n        if (seen.count(-num)) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84", "completion": "```cpp\n#include <unordered_set>\nusing namespace std;\n\nbool pairs_sum_to_zero(vector<int> l) {\n    unordered_set<int> seen;\n    for (int num : l) {\n        if (seen.count(-num)) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_85", "completion": "```cpp\n#include <iostream>\n#include <string>\n#include <vector>\n\nstd::string change_base(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    std::string result = \"\";\n    while (x > 0) {\n        result = std::to_string(x % base) + result;\n        x /= base;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_85", "completion": "```cpp\n#include <iostream>\n#include <string>\n#include <vector>\n\nstd::string change_base(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    std::string result = \"\";\n    while (x > 0) {\n        result = std::to_string(x % base) + result;\n        x /= base;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_85", "completion": "```cpp\n#include <iostream>\n#include <string>\n#include <vector>\n\nstd::string change_base(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    std::string result = \"\";\n    while (x > 0) {\n        result = std::to_string(x % base) + result;\n        x /= base;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_85", "completion": "```cpp\n#include <iostream>\n#include <string>\n#include <vector>\n\nstd::string change_base(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    std::string result = \"\";\n    while (x > 0) {\n        result = std::to_string(x % base) + result;\n        x /= base;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_85", "completion": "```cpp\n#include <iostream>\n#include <string>\n#include <vector>\n\nstd::string change_base(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    std::string result = \"\";\n    while (x > 0) {\n        result = std::to_string(x % base) + result;\n        x /= base;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_86", "completion": "```cpp\nbool is_palindrome(std::string text) {\n    int left = 0;\n    int right = text.length() - 1;\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_86", "completion": "```cpp\n#include <iostream>\n#include <algorithm>\n\nbool is_palindrome(std::string text) {\n    int left = 0;\n    int right = text.length() - 1;\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_86", "completion": "```cpp\n#include <iostream>\n#include <algorithm>\n\nbool is_palindrome(std::string text) {\n    int left = 0;\n    int right = text.length() - 1;\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n\nint main() {\n    std::cout << std::boolalpha; // Print bools as true/false instead of 1/0\n    std::cout << is_palindrome(\"\") << std::endl; // true\n    std::cout << is_palindrome(\"aba\") << std::endl; // true\n    std::cout << is_palindrome(\"aaaaa\") << std::endl; // true\n    std::cout << is_palindrome(\"zbcd\") << std::endl; // false\n    return 0;\n}\n```"}
{"task_id": "SimdBench_86", "completion": "```cpp\nbool is_palindrome(std::string text) {\n    int left = 0;\n    int right = text.length() - 1;\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_86", "completion": "```cpp\nbool is_palindrome(std::string text) {\n    int left = 0;\n    int right = text.length() - 1;\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_87", "completion": "```cpp\n#include <iostream>\n#include <string>\n\nstd::string encode_shift(std::string s){\n    std::string out;\n    int i;\n    for (i=0;i<s.length();i++){\n        int w=((int)s[i]+5-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\n\nstd::string decode_shift(std::string s){\n    std::string out;\n    int i;\n    for (i=0;i<s.length();i++){\n        int w=((int)s[i]-5-(int)'a'+26)%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\n\nint main() {\n    std::string original = \"hello\";\n    std::string encoded = encode_shift(original);\n    std::string decoded = decode_shift(encoded);\n    \n    std::cout << \"Original: \" << original << std::endl;\n    std::cout << \"Encoded: \" << encoded << std::endl;\n    std::cout << \"Decoded: \" << decoded << std::endl;\n    \n    return 0;\n}\n```"}
{"task_id": "SimdBench_87", "completion": "```cpp\n#include <string>\n\nstd::string decode_shift(std::string s){\n    std::string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out += (char)w;\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_87", "completion": "```cpp\nstd::string decode_shift(std::string s){\n    std::string out;\n    int i;\n    for (i=0;i<s.length();i++){\n        int w=((int)s[i]-5-(int)'a'+26)%26+(int)'a';\n        out=out+(char)w;\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_87", "completion": "```cpp\n#include <string>\n\nstd::string decode_shift(std::string s){\n    std::string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out += (char)w;\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_87", "completion": "```cpp\n#include <string>\n\nstd::string decode_shift(std::string s){\n    std::string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out += (char)w;\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_88", "completion": "```cpp\nbool below_threshold(std::vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88", "completion": "```cpp\nbool below_threshold(std::vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88", "completion": "```cpp\nbool below_threshold(std::vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88", "completion": "```cpp\nbool below_threshold(std::vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88", "completion": "```cpp\nbool below_threshold(std::vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_89", "completion": "```cpp\nbool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    for (char c : brackets) {\n        if (c == '<') {\n            balance++;\n        } else if (c == '>') {\n            balance--;\n            if (balance < 0) {\n                return false;\n            }\n        }\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89", "completion": "```cpp\nbool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    for (char c : brackets) {\n        if (c == '<') {\n            balance++;\n        } else if (c == '>') {\n            balance--;\n            if (balance < 0) {\n                return false;\n            }\n        }\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89", "completion": "```cpp\nbool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    for (char c : brackets) {\n        if (c == '<') {\n            balance++;\n        } else if (c == '>') {\n            balance--;\n            if (balance < 0) {\n                return false;\n            }\n        }\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89", "completion": "```cpp\n#include <stack>\n#include <string>\n\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> stack;\n    for (char c : brackets) {\n        if (c == '<') {\n            stack.push(c);\n        } else if (c == '>') {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.empty();\n}\n```"}
{"task_id": "SimdBench_89", "completion": "```cpp\n#include <stack>\n#include <string>\n\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> stack;\n    for (char c : brackets) {\n        if (c == '<') {\n            stack.push(c);\n        } else if (c == '>') {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.empty();\n}\n```"}
{"task_id": "SimdBench_90", "completion": "```cpp\n#include <stack>\n#include <string>\n\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> stack;\n    for (char c : brackets) {\n        if (c == '(') {\n            stack.push(c);\n        } else if (c == ')') {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.empty();\n}\n```"}
{"task_id": "SimdBench_90", "completion": "```cpp\n#include <stack>\n#include <string>\n\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> stack;\n    for (char c : brackets) {\n        if (c == '(') {\n            stack.push(c);\n        } else if (c == ')') {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.empty();\n}\n```"}
{"task_id": "SimdBench_90", "completion": "```cpp\n#include <stack>\n#include <string>\n\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> stack;\n    for (char c : brackets) {\n        if (c == '(') {\n            stack.push(c);\n        } else if (c == ')') {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.empty();\n}\n```"}
{"task_id": "SimdBench_90", "completion": "```cpp\n#include <stack>\n#include <string>\n\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> stack;\n    for (char c : brackets) {\n        if (c == '(') {\n            stack.push(c);\n        } else if (c == ')') {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.empty();\n}\n```"}
{"task_id": "SimdBench_90", "completion": "```cpp\n#include <stack>\n#include <string>\n\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> stack;\n    for (char c : brackets) {\n        if (c == '(') {\n            stack.push(c);\n        } else if (c == ')') {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.empty();\n}\n```"}
{"task_id": "SimdBench_91", "completion": "```cpp\n#include <vector>\n\nstd::vector<float> derivative(const std::vector<float>& xs) {\n    std::vector<float> result;\n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(xs[i] * static_cast<float>(i));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_91", "completion": "```cpp\n#include <vector>\n\nstd::vector<float> derivative(const std::vector<float>& xs) {\n    std::vector<float> result;\n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(xs[i] * static_cast<float>(i));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_91", "completion": "```cpp\nstd::vector<float> derivative(std::vector<float> xs) {\n    std::vector<float> result;\n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(xs[i] * static_cast<float>(i));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_91", "completion": "```cpp\n#include <vector>\n\nstd::vector<float> derivative(const std::vector<float>& xs) {\n    std::vector<float> result;\n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(xs[i] * static_cast<float>(i));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_91", "completion": "```cpp\nstd::vector<float> derivative(std::vector<float> xs) {\n    std::vector<float> result;\n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(xs[i] * static_cast<float>(i));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_92", "completion": "```cpp\n#include <iostream>\n#include <string>\n\nint vowels_count(std::string s) {\n    int count = 0;\n    for (char c : s) {\n        c = tolower(c);\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            ++count;\n        } else if (c == 'y' && &c == &s.back()) {\n            ++count;\n        }\n    }\n    return count;\n}\n\nint main() {\n    std::cout << vowels_count(\"abcde\") << std::endl; // Output: 2\n    std::cout << vowels_count(\"ACEDY\") << std::endl; // Output: 3\n    return 0;\n}\n```"}
{"task_id": "SimdBench_92", "completion": "```cpp\n#include <iostream>\n#include <string>\n\nint vowels_count(std::string s) {\n    int count = 0;\n    for (char c : s) {\n        c = tolower(c);\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            ++count;\n        }\n    }\n    if (!s.empty() && tolower(s.back()) == 'y') {\n        ++count;\n    }\n    return count;\n}\n\nint main() {\n    std::cout << vowels_count(\"abcde\") << std::endl; // Output: 2\n    std::cout << vowels_count(\"ACEDY\") << std::endl; // Output: 3\n    return 0;\n}\n```"}
{"task_id": "SimdBench_92", "completion": "```cpp\n#include <iostream>\n#include <string>\n\nint vowels_count(std::string s) {\n    int count = 0;\n    for (char c : s) {\n        c = tolower(c);\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            ++count;\n        } else if (c == 'y' && &c == &s.back()) {\n            ++count;\n        }\n    }\n    return count;\n}\n\nint main() {\n    std::cout << vowels_count(\"abcde\") << std::endl; // Output: 2\n    std::cout << vowels_count(\"ACEDY\") << std::endl; // Output: 3\n    return 0;\n}\n```"}
{"task_id": "SimdBench_92", "completion": "```cpp\n#include <iostream>\n#include <string>\n\nint vowels_count(std::string s) {\n    int count = 0;\n    for (char c : s) {\n        c = tolower(c);\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            ++count;\n        }\n    }\n    if (!s.empty() && tolower(s.back()) == 'y') {\n        ++count;\n    }\n    return count;\n}\n\nint main() {\n    std::cout << vowels_count(\"abcde\") << std::endl; // Output: 2\n    std::cout << vowels_count(\"ACEDY\") << std::endl; // Output: 3\n    return 0;\n}\n```"}
{"task_id": "SimdBench_92", "completion": "```cpp\n#include <iostream>\n#include <string>\n\nint vowels_count(std::string s) {\n    int count = 0;\n    for (char c : s) {\n        c = tolower(c);\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            ++count;\n        }\n    }\n    if (!s.empty() && tolower(s.back()) == 'y') {\n        ++count;\n    }\n    return count;\n}\n\nint main() {\n    std::cout << vowels_count(\"abcde\") << std::endl; // Output: 2\n    std::cout << vowels_count(\"ACEDY\") << std::endl; // Output: 3\n    return 0;\n}\n```"}
{"task_id": "SimdBench_93", "completion": "```cpp\n#include <iostream>\n#include <string>\n\nint digitSum(std::string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n\nint main() {\n    std::cout << digitSum(\"\") << std::endl; // Output: 0\n    std::cout << digitSum(\"abAB\") << std::endl; // Output: 131\n    std::cout << digitSum(\"abcCd\") << std::endl; // Output: 67\n    std::cout << digitSum(\"helloE\") << std::endl; // Output: 69\n    std::cout << digitSum(\"woArBld\") << std::endl; // Output: 131\n    std::cout << digitSum(\"aAaaaXa\") << std::endl; // Output: 153\n    return 0;\n}\n```"}
{"task_id": "SimdBench_93", "completion": "```cpp\n#include <iostream>\n#include <string>\n\nint digitSum(std::string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n\nint main() {\n    std::cout << digitSum(\"\") << std::endl; // Output: 0\n    std::cout << digitSum(\"abAB\") << std::endl; // Output: 131\n    std::cout << digitSum(\"abcCd\") << std::endl; // Output: 67\n    std::cout << digitSum(\"helloE\") << std::endl; // Output: 69\n    std::cout << digitSum(\"woArBld\") << std::endl; // Output: 131\n    std::cout << digitSum(\"aAaaaXa\") << std::endl; // Output: 153\n    return 0;\n}\n```"}
{"task_id": "SimdBench_93", "completion": "```cpp\n#include <iostream>\n#include <string>\n\nint digitSum(std::string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n\nint main() {\n    std::cout << digitSum(\"\") << std::endl; // Output: 0\n    std::cout << digitSum(\"abAB\") << std::endl; // Output: 131\n    std::cout << digitSum(\"abcCd\") << std::endl; // Output: 67\n    std::cout << digitSum(\"helloE\") << std::endl; // Output: 69\n    std::cout << digitSum(\"woArBld\") << std::endl; // Output: 131\n    std::cout << digitSum(\"aAaaaXa\") << std::endl; // Output: 153\n    return 0;\n}\n```"}
{"task_id": "SimdBench_93", "completion": "```cpp\n#include <iostream>\n#include <string>\n\nint digitSum(std::string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n\nint main() {\n    std::cout << digitSum(\"\") << std::endl; // Output: 0\n    std::cout << digitSum(\"abAB\") << std::endl; // Output: 131\n    std::cout << digitSum(\"abcCd\") << std::endl; // Output: 67\n    std::cout << digitSum(\"helloE\") << std::endl; // Output: 69\n    std::cout << digitSum(\"woArBld\") << std::endl; // Output: 131\n    std::cout << digitSum(\"aAaaaXa\") << std::endl; // Output: 153\n    return 0;\n}\n```"}
{"task_id": "SimdBench_93", "completion": "```cpp\n#include <iostream>\n#include <string>\n\nint digitSum(std::string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n\nint main() {\n    std::cout << digitSum(\"\") << std::endl; // Output: 0\n    std::cout << digitSum(\"abAB\") << std::endl; // Output: 131\n    std::cout << digitSum(\"abcCd\") << std::endl; // Output: 67\n    std::cout << digitSum(\"helloE\") << std::endl; // Output: 69\n    std::cout << digitSum(\"woArBld\") << std::endl; // Output: 131\n    std::cout << digitSum(\"aAaaaXa\") << std::endl; // Output: 153\n    return 0;\n}\n```"}
{"task_id": "SimdBench_94", "completion": "```cpp\nstd::vector<int> pluck(std::vector<int> arr) {\n    int min_even = INT_MAX;\n    int index = -1;\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0 && arr[i] < min_even) {\n            min_even = arr[i];\n            index = i;\n        }\n    }\n    if (index == -1) {\n        return {};\n    }\n    return {min_even, index};\n}\n```"}
{"task_id": "SimdBench_94", "completion": "```cpp\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck(std::vector<int> arr) {\n    int min_even = std::numeric_limits<int>::max();\n    int min_index = -1;\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0 && arr[i] < min_even) {\n            min_even = arr[i];\n            min_index = i;\n        }\n    }\n\n    if (min_index == -1) {\n        return {};\n    } else {\n        return {min_even, min_index};\n    }\n}\n```"}
{"task_id": "SimdBench_94", "completion": "```cpp\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck(std::vector<int> arr) {\n    int min_even = std::numeric_limits<int>::max();\n    int index = -1;\n    \n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0 && arr[i] < min_even) {\n            min_even = arr[i];\n            index = i;\n        }\n    }\n    \n    if (index == -1) {\n        return {};\n    } else {\n        return {min_even, index};\n    }\n}\n```"}
{"task_id": "SimdBench_94", "completion": "```cpp\nstd::vector<int> pluck(std::vector<int> arr) {\n    int minEven = INT_MAX;\n    int index = -1;\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0 && arr[i] < minEven) {\n            minEven = arr[i];\n            index = i;\n        }\n    }\n    if (index == -1) {\n        return {};\n    }\n    return {minEven, index};\n}\n```"}
{"task_id": "SimdBench_94", "completion": "```cpp\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck(std::vector<int> arr) {\n    int minEvenValue = std::numeric_limits<int>::max();\n    int minIndex = -1;\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0 && arr[i] < minEvenValue) {\n            minEvenValue = arr[i];\n            minIndex = i;\n        }\n    }\n\n    if (minIndex == -1) {\n        return {};\n    } else {\n        return {minEvenValue, minIndex};\n    }\n}\n```"}
{"task_id": "SimdBench_95", "completion": "```cpp\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint search(std::vector<int> lst) {\n    std::unordered_map<int, int> freq;\n    for (int num : lst) {\n        freq[num]++;\n    }\n    \n    std::vector<int> valid_nums;\n    for (const auto& pair : freq) {\n        if (pair.first <= pair.second) {\n            valid_nums.push_back(pair.first);\n        }\n    }\n    \n    if (valid_nums.empty()) {\n        return -1;\n    }\n    \n    return *std::max_element(valid_nums.begin(), valid_nums.end());\n}\n```"}
{"task_id": "SimdBench_95", "completion": "```cpp\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint search(std::vector<int> lst) {\n    std::unordered_map<int, int> freq;\n    for (int num : lst) {\n        freq[num]++;\n    }\n    \n    std::sort(lst.begin(), lst.end());\n    int result = -1;\n    for (int i = 0; i < lst.size(); ++i) {\n        if (freq[lst[i]] >= lst[i]) {\n            result = lst[i];\n            break;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_95", "completion": "```cpp\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint search(std::vector<int> lst) {\n    std::unordered_map<int, int> freq;\n    for (int num : lst) {\n        freq[num]++;\n    }\n    \n    std::sort(lst.begin(), lst.end());\n    int result = -1;\n    for (int i = 0; i < lst.size(); ++i) {\n        if (freq[lst[i]] >= lst[i]) {\n            result = lst[i];\n            break;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_95", "completion": "```cpp\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint search(std::vector<int> lst) {\n    std::unordered_map<int, int> freq;\n    for (int num : lst) {\n        freq[num]++;\n    }\n    \n    std::vector<int> valid_nums;\n    for (const auto& pair : freq) {\n        if (pair.first <= pair.second) {\n            valid_nums.push_back(pair.first);\n        }\n    }\n    \n    if (valid_nums.empty()) {\n        return -1;\n    }\n    \n    return *std::max_element(valid_nums.begin(), valid_nums.end());\n}\n```"}
{"task_id": "SimdBench_95", "completion": "```cpp\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint search(std::vector<int> lst) {\n    std::unordered_map<int, int> freq;\n    for (int num : lst) {\n        freq[num]++;\n    }\n    \n    std::sort(lst.begin(), lst.end());\n    int result = -1;\n    for (int i = 0; i < lst.size(); ++i) {\n        if (freq[lst[i]] >= lst[i]) {\n            result = lst[i];\n            break;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_96", "completion": "```cpp\n#include <vector>\n#include <numeric>\n#include <algorithm>\n\nbool will_it_fly(std::vector<int> q, int w) {\n    int sum = std::accumulate(q.begin(), q.end(), 0);\n    std::vector<int> reversed_q(q.rbegin(), q.rend());\n    return q == reversed_q && sum <= w;\n}\n```"}
{"task_id": "SimdBench_96", "completion": "```cpp\n#include <vector>\n#include <numeric>\n#include <algorithm>\n\nbool will_it_fly(std::vector<int> q, int w) {\n    int sum = std::accumulate(q.begin(), q.end(), 0);\n    std::vector<int> reversed_q(q.rbegin(), q.rend());\n    return q == reversed_q && sum <= w;\n}\n```"}
{"task_id": "SimdBench_96", "completion": "```cpp\n#include <vector>\n#include <numeric>\n#include <algorithm>\n\nbool will_it_fly(std::vector<int> q, int w) {\n    int sum = std::accumulate(q.begin(), q.end(), 0);\n    auto reversed_q = q;\n    std::reverse(reversed_q.begin(), reversed_q.end());\n    return q == reversed_q && sum <= w;\n}\n```"}
{"task_id": "SimdBench_96", "completion": "```cpp\n#include <vector>\n#include <numeric>\n#include <algorithm>\n\nbool will_it_fly(std::vector<int> q, int w) {\n    int sum = std::accumulate(q.begin(), q.end(), 0);\n    std::vector<int> reversed_q(q.rbegin(), q.rend());\n    return q == reversed_q && sum <= w;\n}\n```"}
{"task_id": "SimdBench_96", "completion": "```cpp\n#include <vector>\n#include <numeric>\n#include <algorithm>\n\nbool will_it_fly(std::vector<int> q, int w) {\n    int sum = std::accumulate(q.begin(), q.end(), 0);\n    std::vector<int> reversed_q(q.rbegin(), q.rend());\n    return q == reversed_q && sum <= w;\n}\n```"}
{"task_id": "SimdBench_97", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nint smallest_change(std::vector<int> arr) {\n    int left = 0;\n    int right = arr.size() - 1;\n    int changes = 0;\n\n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            changes++;\n        }\n        left++;\n        right--;\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nint smallest_change(std::vector<int> arr) {\n    int changes = 0;\n    int left = 0;\n    int right = arr.size() - 1;\n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            changes++;\n        }\n        left++;\n        right--;\n    }\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nint smallest_change(std::vector<int> arr) {\n    int left = 0;\n    int right = arr.size() - 1;\n    int changes = 0;\n\n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            changes++;\n        }\n        left++;\n        right--;\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nint smallest_change(std::vector<int> arr) {\n    int changes = 0;\n    int left = 0;\n    int right = arr.size() - 1;\n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            changes++;\n        }\n        left++;\n        right--;\n    }\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nint smallest_change(std::vector<int> arr) {\n    int left = 0;\n    int right = arr.size() - 1;\n    int changes = 0;\n\n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            changes++;\n        }\n        left++;\n        right--;\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_98", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    int count1 = 0, count2 = 0;\n    for (const auto& str : lst1) {\n        count1 += str.size();\n    }\n    for (const auto& str : lst2) {\n        count2 += str.size();\n    }\n    if (count1 <= count2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    int count1 = 0, count2 = 0;\n    for (const auto& str : lst1) {\n        count1 += str.size();\n    }\n    for (const auto& str : lst2) {\n        count2 += str.size();\n    }\n    if (count1 <= count2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <numeric>\n\nstd::vector<std::string> total_match(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    auto count_chars = [](const std::vector<std::string>& vec) {\n        return std::accumulate(vec.begin(), vec.end(), 0, [](int sum, const std::string& str) {\n            return sum + str.size();\n        });\n    };\n\n    int count1 = count_chars(lst1);\n    int count2 = count_chars(lst2);\n\n    if (count1 <= count2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    int count1 = 0, count2 = 0;\n    for (const auto& str : lst1) {\n        count1 += str.size();\n    }\n    for (const auto& str : lst2) {\n        count2 += str.size();\n    }\n    if (count1 <= count2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <numeric>\n\nstd::vector<std::string> total_match(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    auto count_chars = [](const std::vector<std::string>& vec) {\n        return std::accumulate(vec.begin(), vec.end(), 0, [](int sum, const std::string& str) {\n            return sum + str.size();\n        });\n    };\n\n    int count1 = count_chars(lst1);\n    int count2 = count_chars(lst2);\n\n    if (count1 <= count2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_99", "completion": "```cpp\n#include <cmath>\n#include <iostream>\n\nbool is_simple_power(uint64_t x, uint64_t n) {\n    if (n == 1) return x == 1;\n    double log_val = std::log(x) / std::log(n);\n    return std::floor(log_val) == log_val;\n}\n```"}
{"task_id": "SimdBench_99", "completion": "```cpp\n#include <cmath>\n\nbool is_simple_power(uint64_t x, uint64_t n) {\n    if (n == 1) return x == 1;\n    double log_val = std::log(x) / std::log(n);\n    return std::floor(log_val) == log_val;\n}\n```"}
{"task_id": "SimdBench_99", "completion": "```cpp\n#include <cmath>\n\nbool is_simple_power(uint64_t x, uint64_t n) {\n    if (n == 1) return x == 1;\n    double log_val = std::log(x) / std::log(n);\n    return std::floor(log_val) == log_val;\n}\n```"}
{"task_id": "SimdBench_99", "completion": "```cpp\n#include <cmath>\n#include <iostream>\n\nbool is_simple_power(uint64_t x, uint64_t n) {\n    if (n == 1) return x == 1;\n    double log_val = std::log(x) / std::log(n);\n    return std::floor(log_val) == log_val;\n}\n```"}
{"task_id": "SimdBench_99", "completion": "```cpp\n#include <cmath>\n#include <iostream>\n\nbool is_simple_power(uint64_t x, uint64_t n) {\n    if (n == 1) return x == 1;\n    double log_val = std::log(x) / std::log(n);\n    return std::floor(log_val) == log_val;\n}\n```"}
{"task_id": "SimdBench_100", "completion": "```cpp\n#include <iostream>\n#include <string>\n\nint hex_key(const std::string & num) {\n    int count = 0;\n    for (char c : num) {\n        if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n            ++count;\n        }\n    }\n    return count;\n}\n\nint main() {\n    // Test cases\n    std::cout << hex_key(\"AB\") << std::endl; // Output: 1\n    std::cout << hex_key(\"1077E\") << std::endl; // Output: 2\n    std::cout << hex_key(\"ABED1A33\") << std::endl; // Output: 4\n    std::cout << hex_key(\"123456789ABCDEF0\") << std::endl; // Output: 6\n    std::cout << hex_key(\"2020\") << std::endl; // Output: 2\n    return 0;\n}\n```"}
{"task_id": "SimdBench_100", "completion": "```cpp\n#include <iostream>\n#include <string>\n\nint hex_key(const std::string & num) {\n    int count = 0;\n    for (char c : num) {\n        if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n            ++count;\n        }\n    }\n    return count;\n}\n\nint main() {\n    // Test cases\n    std::cout << hex_key(\"AB\") << std::endl; // Output: 1\n    std::cout << hex_key(\"1077E\") << std::endl; // Output: 2\n    std::cout << hex_key(\"ABED1A33\") << std::endl; // Output: 4\n    std::cout << hex_key(\"123456789ABCDEF0\") << std::endl; // Output: 6\n    std::cout << hex_key(\"2020\") << std::endl; // Output: 2\n    return 0;\n}\n```"}
{"task_id": "SimdBench_100", "completion": "```cpp\n#include <iostream>\n#include <string>\n\nint hex_key(const std::string & num) {\n    int count = 0;\n    for (char c : num) {\n        if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n            ++count;\n        }\n    }\n    return count;\n}\n\nint main() {\n    // Test cases\n    std::cout << hex_key(\"AB\") << std::endl; // Output: 1\n    std::cout << hex_key(\"1077E\") << std::endl; // Output: 2\n    std::cout << hex_key(\"ABED1A33\") << std::endl; // Output: 4\n    std::cout << hex_key(\"123456789ABCDEF0\") << std::endl; // Output: 6\n    std::cout << hex_key(\"2020\") << std::endl; // Output: 2\n    return 0;\n}\n```"}
{"task_id": "SimdBench_100", "completion": "```cpp\n#include <iostream>\n#include <string>\n\nint hex_key(const std::string & num) {\n    int count = 0;\n    for (char c : num) {\n        if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n            ++count;\n        }\n    }\n    return count;\n}\n\nint main() {\n    // Test cases\n    std::cout << hex_key(\"AB\") << std::endl; // Output: 1\n    std::cout << hex_key(\"1077E\") << std::endl; // Output: 2\n    std::cout << hex_key(\"ABED1A33\") << std::endl; // Output: 4\n    std::cout << hex_key(\"123456789ABCDEF0\") << std::endl; // Output: 6\n    std::cout << hex_key(\"2020\") << std::endl; // Output: 2\n    return 0;\n}\n```"}
{"task_id": "SimdBench_100", "completion": "```cpp\n#include <iostream>\n#include <string>\n\nint hex_key(const std::string & num) {\n    int count = 0;\n    for (char c : num) {\n        if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n            ++count;\n        }\n    }\n    return count;\n}\n\nint main() {\n    // Test cases\n    std::cout << hex_key(\"AB\") << std::endl; // Output: 1\n    std::cout << hex_key(\"1077E\") << std::endl; // Output: 2\n    std::cout << hex_key(\"ABED1A33\") << std::endl; // Output: 4\n    std::cout << hex_key(\"123456789ABCDEF0\") << std::endl; // Output: 6\n    std::cout << hex_key(\"2020\") << std::endl; // Output: 2\n    return 0;\n}\n```"}
{"task_id": "SimdBench_101", "completion": "```cpp\nbool is_happy(const std::string & s) {\n    if (s.length() < 3) return false;\n    for (size_t i = 0; i < s.length() - 2; ++i) {\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_101", "completion": "```cpp\nbool is_happy(const std::string & s) {\n    if (s.length() < 3) {\n        return false;\n    }\n    for (size_t i = 0; i < s.length() - 2; ++i) {\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_101", "completion": "```cpp\nbool is_happy(const std::string & s) {\n    if (s.length() < 3) return false;\n    for (size_t i = 0; i < s.length() - 2; ++i) {\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_101", "completion": "```cpp\nbool is_happy(const std::string & s) {\n    if (s.length() < 3) {\n        return false;\n    }\n    for (size_t i = 0; i < s.length() - 2; ++i) {\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_101", "completion": "```cpp\nbool is_happy(const std::string & s) {\n    if (s.length() < 3) return false;\n    for (size_t i = 0; i < s.length() - 2; ++i) {\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_102", "completion": "```cpp\n#include <cmath>\n#include <string>\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num <= 3) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n    for (int i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length(const std::string & str) {\n    return is_prime(str.length());\n}\n```"}
{"task_id": "SimdBench_102", "completion": "```cpp\n#include <cmath>\n#include <string>\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num <= 3) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n    for (int i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length(const std::string & str) {\n    return is_prime(str.length());\n}\n```"}
{"task_id": "SimdBench_102", "completion": "```cpp\n#include <cmath>\n#include <string>\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num <= 3) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n    for (int i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length(const std::string & str) {\n    return is_prime(str.length());\n}\n```"}
{"task_id": "SimdBench_102", "completion": "```cpp\n#include <cmath>\n#include <string>\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num <= 3) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n    for (int i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length(const std::string & str) {\n    return is_prime(str.length());\n}\n```"}
{"task_id": "SimdBench_102", "completion": "```cpp\n#include <cmath>\n#include <string>\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    if (num <= 3) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n    for (int i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length(const std::string & str) {\n    return is_prime(str.length());\n}\n```"}
{"task_id": "SimdBench_103", "completion": "```cpp\n#include <bitset>\n#include <string>\n\nstd::string solve(uint64_t N) {\n    int sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n    std::bitset<64> binary(sum);\n    return binary.to_string();\n}\n```"}
{"task_id": "SimdBench_103", "completion": "```cpp\n#include <bitset>\n#include <string>\n\nstd::string solve(uint64_t N) {\n    int sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n    std::string binary = std::bitset<64>(sum).to_string();\n    // Remove leading zeros\n    size_t first_one = binary.find('1');\n    if (first_one != std::string::npos) {\n        binary = binary.substr(first_one);\n    } else {\n        binary = \"0\";\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103", "completion": "```cpp\n#include <bitset>\n#include <string>\n\nstd::string solve(uint64_t N) {\n    int sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n    std::bitset<64> binary(sum);\n    return binary.to_string();\n}\n```"}
{"task_id": "SimdBench_103", "completion": "```cpp\n#include <bitset>\n#include <string>\n\nstd::string solve(uint64_t N) {\n    int sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n    std::bitset<64> binary(sum);\n    return binary.to_string();\n}\n```"}
{"task_id": "SimdBench_103", "completion": "```cpp\n#include <bitset>\n#include <sstream>\n\nstd::string solve(uint64_t N) {\n    int sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n    std::ostringstream oss;\n    oss << std::bitset<64>(sum).to_string();\n    auto str = oss.str();\n    // Remove leading zeros\n    str.erase(0, str.find_first_not_of('0'));\n    return str.empty() ? \"0\" : str;\n}\n```"}
{"task_id": "SimdBench_104", "completion": "```cpp\nint add(std::vector<int> lst) {\n    int sum = 0;\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104", "completion": "```cpp\nint add(std::vector<int> lst) {\n    int sum = 0;\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104", "completion": "```cpp\nint add(std::vector<int> lst) {\n    int sum = 0;\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104", "completion": "```cpp\nint add(std::vector<int> lst) {\n    int sum = 0;\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104", "completion": "```cpp\nint add(std::vector<int> lst) {\n    int sum = 0;\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_105", "completion": "```cpp\n#include <iostream>\n#include <string>\n\nstd::string encrypt(const std::string & s) {\n    std::string result;\n    for (char c : s) {\n        if (isalpha(c)) {\n            char base = islower(c) ? 'a' : 'A';\n            result += (base + (c - base + 4) % 26);\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n\nint main() {\n    std::cout << encrypt(\"hi\") << std::endl; // Output: lm\n    std::cout << encrypt(\"asdfghjkl\") << std::endl; // Output: ewhjklnop\n    std::cout << encrypt(\"gf\") << std::endl; // Output: kj\n    std::cout << encrypt(\"et\") << std::endl; // Output: ix\n    return 0;\n}\n```"}
{"task_id": "SimdBench_105", "completion": "```cpp\n#include <iostream>\n#include <string>\n\nstd::string encrypt(const std::string & s) {\n    std::string result;\n    for (char c : s) {\n        if (isalpha(c)) {\n            char base = islower(c) ? 'a' : 'A';\n            result += (base + (c - base + 4) % 26);\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n\nint main() {\n    std::cout << encrypt(\"hi\") << std::endl; // Output: lm\n    std::cout << encrypt(\"asdfghjkl\") << std::endl; // Output: ewhjklnop\n    std::cout << encrypt(\"gf\") << std::endl; // Output: kj\n    std::cout << encrypt(\"et\") << std::endl; // Output: ix\n    return 0;\n}\n```"}
{"task_id": "SimdBench_105", "completion": "```cpp\n#include <iostream>\n#include <string>\n\nstd::string encrypt(const std::string & s) {\n    std::string result;\n    for (char c : s) {\n        if (isalpha(c)) {\n            char base = islower(c) ? 'a' : 'A';\n            int shift = 2 * 2; // Shift down by two multiplied to two places\n            result += (base + (c - base + shift) % 26);\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n\nint main() {\n    std::cout << encrypt(\"hi\") << std::endl; // Output: lm\n    std::cout << encrypt(\"asdfghjkl\") << std::endl; // Output: ewhjklnop\n    std::cout << encrypt(\"gf\") << std::endl; // Output: kj\n    std::cout << encrypt(\"et\") << std::endl; // Output: ix\n    return 0;\n}\n```"}
{"task_id": "SimdBench_105", "completion": "```cpp\n#include <iostream>\n#include <string>\n\nstd::string encrypt(const std::string & s) {\n    std::string result;\n    for (char c : s) {\n        if (isalpha(c)) {\n            char base = islower(c) ? 'a' : 'A';\n            int shift = 2 * 2; // Shift down by two multiplied to two places\n            result += (base + (c - base + shift) % 26);\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n\nint main() {\n    std::cout << encrypt(\"hi\") << std::endl; // Output: lm\n    std::cout << encrypt(\"asdfghjkl\") << std::endl; // Output: ewhjklnop\n    std::cout << encrypt(\"gf\") << std::endl; // Output: kj\n    std::cout << encrypt(\"et\") << std::endl; // Output: ix\n    return 0;\n}\n```"}
{"task_id": "SimdBench_105", "completion": "```cpp\n#include <iostream>\n#include <string>\n\nstd::string encrypt(const std::string & s) {\n    std::string result;\n    for (char c : s) {\n        if (isalpha(c)) {\n            char base = islower(c) ? 'a' : 'A';\n            result += (base + (c - base + 4) % 26);\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n\nint main() {\n    std::cout << encrypt(\"hi\") << std::endl; // Output: lm\n    std::cout << encrypt(\"asdfghjkl\") << std::endl; // Output: ewhjklnop\n    std::cout << encrypt(\"gf\") << std::endl; // Output: kj\n    std::cout << encrypt(\"et\") << std::endl; // Output: ix\n    return 0;\n}\n```"}
{"task_id": "SimdBench_106", "completion": "```cpp\n#include <iostream>\n#include <string>\n\nstd::string encode(const std::string & message) {\n    std::string encoded = \"\";\n    for (char c : message) {\n        if (isalpha(c)) {\n            // Swap case\n            char swappedCase = islower(c) ? toupper(c) : tolower(c);\n            // Replace vowels\n            switch (tolower(swappedCase)) {\n                case 'a': encoded += 'C'; break;\n                case 'e': encoded += 'G'; break;\n                case 'i': encoded += 'K'; break;\n                case 'o': encoded += 'Q'; break;\n                case 'u': encoded += 'W'; break;\n                default: encoded += swappedCase; break;\n            }\n        } else {\n            encoded += c;\n        }\n    }\n    return encoded;\n}\n\nint main() {\n    std::cout << encode(\"test\") << std::endl; // Output: \"TGST\"\n    std::cout << encode(\"This is a message\") << std::endl; // Output: \"tHKS KS C MGSSCGG\"\n    return 0;\n}\n```"}
{"task_id": "SimdBench_106", "completion": "```cpp\n#include <iostream>\n#include <string>\n\nstd::string encode(const std::string & message) {\n    std::string encoded = \"\";\n    for (char c : message) {\n        if (isalpha(c)) {\n            // Swap case\n            char swappedCase = islower(c) ? toupper(c) : tolower(c);\n            // Replace vowels with the letter 2 places ahead\n            switch (tolower(swappedCase)) {\n                case 'a': encoded += 'C'; break;\n                case 'e': encoded += 'G'; break;\n                case 'i': encoded += 'K'; break;\n                case 'o': encoded += 'Q'; break;\n                case 'u': encoded += 'W'; break;\n                default: encoded += swappedCase; break;\n            }\n        } else {\n            encoded += c;\n        }\n    }\n    return encoded;\n}\n\nint main() {\n    std::cout << encode(\"test\") << std::endl; // Output: \"TGST\"\n    std::cout << encode(\"This is a message\") << std::endl; // Output: \"tHKS KS C MGSSCGG\"\n    return 0;\n}\n```"}
{"task_id": "SimdBench_106", "completion": "```cpp\n#include <iostream>\n#include <string>\n\nstd::string encode(const std::string & message) {\n    std::string encoded = \"\";\n    for (char c : message) {\n        if (isalpha(c)) {\n            // Swap case\n            char swappedCase = islower(c) ? toupper(c) : tolower(c);\n            // Replace vowels\n            switch (swappedCase) {\n                case 'a': encoded += 'C'; break;\n                case 'e': encoded += 'G'; break;\n                case 'i': encoded += 'K'; break;\n                case 'o': encoded += 'Q'; break;\n                case 'u': encoded += 'W'; break;\n                case 'A': encoded += 'C'; break;\n                case 'E': encoded += 'G'; break;\n                case 'I': encoded += 'K'; break;\n                case 'O': encoded += 'Q'; break;\n                case 'U': encoded += 'W'; break;\n                default: encoded += swappedCase; break;\n            }\n        } else {\n            encoded += c;\n        }\n    }\n    return encoded;\n}\n\nint main() {\n    std::cout << encode(\"test\") << std::endl; // Output: \"TGST\"\n    std::cout << encode(\"This is a message\") << std::endl; // Output: \"tHKS KS C MGSSCGG\"\n    return 0;\n}\n```"}
{"task_id": "SimdBench_106", "completion": "```cpp\n#include <iostream>\n#include <string>\n#include <cctype>\n\nstd::string encode(const std::string & message) {\n    std::string encoded = \"\";\n    for (char c : message) {\n        if (isalpha(c)) {\n            // Swap case\n            char swappedCase = islower(c) ? toupper(c) : tolower(c);\n            // Replace vowels\n            switch (swappedCase) {\n                case 'a': swappedCase = 'C'; break;\n                case 'e': swappedCase = 'G'; break;\n                case 'i': swappedCase = 'K'; break;\n                case 'o': swappedCase = 'Q'; break;\n                case 'u': swappedCase = 'W'; break;\n                case 'A': swappedCase = 'C'; break;\n                case 'E': swappedCase = 'G'; break;\n                case 'I': swappedCase = 'K'; break;\n                case 'O': swappedCase = 'Q'; break;\n                case 'U': swappedCase = 'W'; break;\n            }\n            encoded += swappedCase;\n        } else {\n            encoded += c;\n        }\n    }\n    return encoded;\n}\n\nint main() {\n    std::cout << encode(\"test\") << std::endl; // Output: \"TGST\"\n    std::cout << encode(\"This is a message\") << std::endl; // Output: \"tHKS KS C MGSSCGG\"\n    return 0;\n}\n```"}
{"task_id": "SimdBench_106", "completion": "```cpp\n#include <iostream>\n#include <string>\n\nstd::string encode(const std::string & message) {\n    std::string encoded = \"\";\n    for (char c : message) {\n        if (isalpha(c)) {\n            // Swap case\n            char swappedCase = islower(c) ? toupper(c) : tolower(c);\n            // Replace vowels\n            switch (swappedCase) {\n                case 'a': encoded += 'C'; break;\n                case 'e': encoded += 'G'; break;\n                case 'i': encoded += 'K'; break;\n                case 'o': encoded += 'Q'; break;\n                case 'u': encoded += 'W'; break;\n                default: encoded += swappedCase; break;\n            }\n        } else {\n            encoded += c;\n        }\n    }\n    return encoded;\n}\n\nint main() {\n    std::cout << encode(\"test\") << std::endl; // Output: \"TGST\"\n    std::cout << encode(\"This is a message\") << std::endl; // Output: \"tHKS KS C MGSSCGG\"\n    return 0;\n}\n```"}
{"task_id": "SimdBench_107", "completion": "```cpp\n#include <map>\n#include <cctype>\n#include <algorithm>\n\nbool check_dict_case(const std::map<std::string, std::string>& dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool hasLower = false;\n    bool hasUpper = false;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        if (std::all_of(key.begin(), key.end(), ::islower)) {\n            hasLower = true;\n        } else if (std::all_of(key.begin(), key.end(), ::isupper)) {\n            hasUpper = true;\n        } else {\n            return false;\n        }\n\n        if (hasLower && hasUpper) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_107", "completion": "```cpp\n#include <map>\n#include <cctype>\n#include <algorithm>\n\nbool check_dict_case(const std::map<std::string, std::string>& dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool hasLower = false;\n    bool hasUpper = false;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        if (std::all_of(key.begin(), key.end(), ::islower)) {\n            hasLower = true;\n        } else if (std::all_of(key.begin(), key.end(), ::isupper)) {\n            hasUpper = true;\n        } else {\n            return false;\n        }\n\n        if (hasLower && hasUpper) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_107", "completion": "```cpp\n#include <map>\n#include <cctype>\n#include <algorithm>\n\nbool check_dict_case(const std::map<std::string, std::string>& dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool hasLower = false;\n    bool hasUpper = false;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        if (std::all_of(key.begin(), key.end(), ::islower)) {\n            hasLower = true;\n        } else if (std::all_of(key.begin(), key.end(), ::isupper)) {\n            hasUpper = true;\n        } else {\n            return false;\n        }\n\n        if (hasLower && hasUpper) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_107", "completion": "```cpp\n#include <map>\n#include <cctype>\n#include <algorithm>\n\nbool check_dict_case(const std::map<std::string, std::string>& dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool hasLower = false;\n    bool hasUpper = false;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        if (std::all_of(key.begin(), key.end(), ::islower)) {\n            hasLower = true;\n        } else if (std::all_of(key.begin(), key.end(), ::isupper)) {\n            hasUpper = true;\n        } else {\n            return false;\n        }\n\n        if (hasLower && hasUpper) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_107", "completion": "```cpp\n#include <map>\n#include <cctype>\n#include <algorithm>\n\nbool check_dict_case(const std::map<std::string, std::string>& dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool hasLower = false;\n    bool hasUpper = false;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        if (std::all_of(key.begin(), key.end(), ::islower)) {\n            hasLower = true;\n        } else if (std::all_of(key.begin(), key.end(), ::isupper)) {\n            hasUpper = true;\n        } else {\n            return false;\n        }\n\n        if (hasLower && hasUpper) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_108", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i <= std::sqrt(num); ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nstd::vector<int> count_up_to(int n) {\n    std::vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i <= std::sqrt(num); ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nstd::vector<int> count_up_to(int n) {\n    std::vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i <= std::sqrt(num); ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nstd::vector<int> count_up_to(int n) {\n    std::vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i <= std::sqrt(num); ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nstd::vector<int> count_up_to(int n) {\n    std::vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i <= std::sqrt(num); ++i) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nstd::vector<int> count_up_to(int n) {\n    std::vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime(i)) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n```"}
{"task_id": "SimdBench_109", "completion": "```cpp\n#include <cctype>\n#include <string>\n\nint count_upper(const std::string & s) {\n    int count = 0;\n    for (size_t i = 0; i < s.length(); i += 2) {\n        if (std::isupper(s[i]) && (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_109", "completion": "```cpp\n#include <cctype>\n#include <string>\n\nint count_upper(const std::string & s) {\n    int count = 0;\n    for (size_t i = 0; i < s.length(); i += 2) {\n        if (std::isupper(s[i]) && (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_109", "completion": "```cpp\n#include <cctype>\n#include <string>\n\nint count_upper(const std::string & s) {\n    int count = 0;\n    for (size_t i = 0; i < s.length(); i += 2) {\n        if (std::isupper(s[i]) && (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_109", "completion": "```cpp\n#include <cctype>\n#include <string>\n\nint count_upper(const std::string & s) {\n    int count = 0;\n    for (size_t i = 0; i < s.length(); i += 2) {\n        if (std::isupper(s[i]) && (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_109", "completion": "```cpp\n#include <cctype>\n#include <string>\n\nint count_upper(const std::string & s) {\n    int count = 0;\n    for (size_t i = 0; i < s.length(); i += 2) {\n        if (std::isupper(s[i]) && (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_110", "completion": "```cpp\n#include <vector>\nusing namespace std;\n\nstd::vector<int> make_a_pile(int n) {\n    vector<int> result;\n    int current = n;\n    for (int i = 0; i < n; ++i) {\n        result.push_back(current);\n        if (n % 2 == 0) {\n            current += 2;\n        } else {\n            current += 2;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_110", "completion": "```cpp\nstd::vector<int> make_a_pile(int n) {\n    std::vector<int> result;\n    int current = n;\n    for (int i = 0; i < n; ++i) {\n        result.push_back(current);\n        if (n % 2 == 0) {\n            current += 2;\n        } else {\n            current += 2;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_110", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> make_a_pile(int n) {\n    std::vector<int> pile;\n    int current_stones = n;\n    for (int i = 0; i < n; ++i) {\n        pile.push_back(current_stones);\n        if (n % 2 == 0) {\n            current_stones += 2;\n        } else {\n            current_stones += 2;\n        }\n    }\n    return pile;\n}\n```"}
{"task_id": "SimdBench_110", "completion": "```cpp\n#include <vector>\nusing namespace std;\n\nstd::vector<int> make_a_pile(int n) {\n    vector<int> result;\n    int current = n;\n    for (int i = 0; i < n; ++i) {\n        result.push_back(current);\n        if (n % 2 == 0) {\n            current += 2;\n        } else {\n            current += 2;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_110", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> make_a_pile(int n) {\n    std::vector<int> pile;\n    int current_stones = n;\n    for (int i = 0; i < n; ++i) {\n        pile.push_back(current_stones);\n        if (n % 2 == 0) {\n            current_stones += 2;\n        } else {\n            current_stones += 2;\n        }\n    }\n    return pile;\n}\n```"}
{"task_id": "SimdBench_111", "completion": "```cpp\n#include <iostream>\n#include <cmath>\n#include <bitset>\n\nstd::string rounded_avg(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n    int64_t sum = 0;\n    for (int64_t i = n; i <= m; ++i) {\n        sum += i;\n    }\n    int64_t avg = std::round(static_cast<double>(sum) / (m - n + 1));\n    return std::bitset<64>(avg).to_string().substr(64 - std::ceil(std::log2(avg + 1)));\n}\n```"}
{"task_id": "SimdBench_111", "completion": "```cpp\n#include <iostream>\n#include <cmath>\n#include <bitset>\n\nstd::string rounded_avg(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n    int64_t sum = 0;\n    for (int64_t i = n; i <= m; ++i) {\n        sum += i;\n    }\n    int64_t avg = std::round(static_cast<double>(sum) / (m - n + 1));\n    return std::bitset<64>(avg).to_string().substr(64 - std::ceil(std::log2(avg + 1)));\n}\n```"}
{"task_id": "SimdBench_111", "completion": "```cpp\n#include <iostream>\n#include <cmath>\n#include <bitset>\n\nstd::string rounded_avg(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n    int64_t sum = 0;\n    for (int64_t i = n; i <= m; ++i) {\n        sum += i;\n    }\n    int64_t avg = std::round(static_cast<double>(sum) / (m - n + 1));\n    return std::bitset<64>(avg).to_string().substr(64 - std::ceil(std::log2(avg + 1)));\n}\n```"}
{"task_id": "SimdBench_111", "completion": "```cpp\n#include <iostream>\n#include <cmath>\n#include <bitset>\n\nstd::string rounded_avg(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n    int64_t sum = 0;\n    for (int64_t i = n; i <= m; ++i) {\n        sum += i;\n    }\n    int64_t avg = std::round(static_cast<double>(sum) / (m - n + 1));\n    return std::bitset<64>(avg).to_string().substr(64 - std::ceil(std::log2(avg + 1)));\n}\n```"}
{"task_id": "SimdBench_111", "completion": "```cpp\n#include <iostream>\n#include <cmath>\n#include <bitset>\n\nstd::string rounded_avg(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n    int64_t sum = 0;\n    for (int64_t i = n; i <= m; ++i) {\n        sum += i;\n    }\n    int64_t avg = std::round(static_cast<double>(sum) / (m - n + 1));\n    return std::bitset<64>(avg).to_string().substr(64 - std::ceil(std::log2(avg + 1)));\n}\n```"}
{"task_id": "SimdBench_112", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> func(int n) {\n    std::vector<int> result(n);\n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            int factorial = 1;\n            for (int j = 1; j <= i; ++j) {\n                factorial = (factorial * j) % 10000;\n            }\n            result[i - 1] = factorial;\n        } else {\n            int sum = (i * (i + 1)) / 2;\n            result[i - 1] = sum;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_112", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> func(int n) {\n    std::vector<int> result(n);\n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            int factorial = 1;\n            for (int j = 1; j <= i; ++j) {\n                factorial = (factorial * j) % 10000;\n            }\n            result[i - 1] = factorial;\n        } else {\n            int sum = i * (i + 1) / 2;\n            result[i - 1] = sum;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_112", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> func(int n) {\n    std::vector<int> result(n);\n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            int factorial = 1;\n            for (int j = 1; j <= i; ++j) {\n                factorial = (factorial * j) % 10000;\n            }\n            result[i - 1] = factorial;\n        } else {\n            int sum = (i * (i + 1)) / 2;\n            result[i - 1] = sum;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_112", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> func(int n) {\n    std::vector<int> result(n);\n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            int factorial = 1;\n            for (int j = 1; j <= i; ++j) {\n                factorial = (factorial * j) % 10000;\n            }\n            result[i - 1] = factorial;\n        } else {\n            int sum = (i * (i + 1)) / 2;\n            result[i - 1] = sum;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_112", "completion": "```cpp\n#include <vector>\nusing namespace std;\n\nstd::vector<int> func(int n) {\n    std::vector<int> result(n);\n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            int factorial = 1;\n            for (int j = 1; j <= i; ++j) {\n                factorial = (factorial * j) % 10000;\n            }\n            result[i - 1] = factorial;\n        } else {\n            int sum = (i * (i + 1)) / 2;\n            result[i - 1] = sum;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_113", "completion": "```cpp\n#include <vector>\n#include <string>\n\nbool isPalindrome(int num) {\n    std::string str = std::to_string(num);\n    int left = 0;\n    int right = str.size() - 1;\n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n\nstd::vector<int> even_odd_palindrome(int n) {\n    int evenCount = 0;\n    int oddCount = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (isPalindrome(i)) {\n            if (i % 2 == 0) {\n                evenCount++;\n            } else {\n                oddCount++;\n            }\n        }\n    }\n    return {evenCount, oddCount};\n}\n```"}
{"task_id": "SimdBench_113", "completion": "```cpp\n#include <vector>\n#include <string>\n\nbool isPalindrome(int num) {\n    std::string str = std::to_string(num);\n    int left = 0;\n    int right = str.length() - 1;\n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n\nstd::vector<int> even_odd_palindrome(int n) {\n    int evenCount = 0;\n    int oddCount = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (isPalindrome(i)) {\n            if (i % 2 == 0) {\n                evenCount++;\n            } else {\n                oddCount++;\n            }\n        }\n    }\n    return {evenCount, oddCount};\n}\n```"}
{"task_id": "SimdBench_113", "completion": "```cpp\n#include <vector>\n#include <string>\n\nbool is_palindrome(int num) {\n    std::string str = std::to_string(num);\n    int left = 0;\n    int right = str.size() - 1;\n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n\nstd::vector<int> even_odd_palindrome(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (is_palindrome(i)) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113", "completion": "```cpp\n#include <vector>\n#include <string>\n\nbool isPalindrome(int num) {\n    std::string str = std::to_string(num);\n    int left = 0;\n    int right = str.length() - 1;\n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n\nstd::vector<int> even_odd_palindrome(int n) {\n    int evenCount = 0;\n    int oddCount = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (isPalindrome(i)) {\n            if (i % 2 == 0) {\n                evenCount++;\n            } else {\n                oddCount++;\n            }\n        }\n    }\n    return {evenCount, oddCount};\n}\n```"}
{"task_id": "SimdBench_113", "completion": "```cpp\n#include <vector>\n#include <string>\n\nbool isPalindrome(int num) {\n    std::string str = std::to_string(num);\n    int left = 0;\n    int right = str.size() - 1;\n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n\nstd::vector<int> even_odd_palindrome(int n) {\n    int evenCount = 0;\n    int oddCount = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (isPalindrome(i)) {\n            if (i % 2 == 0) {\n                evenCount++;\n            } else {\n                oddCount++;\n            }\n        }\n    }\n    return {evenCount, oddCount};\n}\n```"}
{"task_id": "SimdBench_114", "completion": "```cpp\n#include <vector>\n#include <string>\n\nint count_nums(std::vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        if (num == 0) continue;\n        bool is_negative = num < 0;\n        int sum = 0;\n        while (num != 0) {\n            int digit = abs(num % 10);\n            sum += digit;\n            num /= 10;\n        }\n        if (is_negative) sum -= 2 * (sum % 10);\n        if (sum > 0) count++;\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_114", "completion": "```cpp\n#include <vector>\n#include <string>\n\nint count_nums(std::vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        if (num == 0) continue;\n        bool is_negative = num < 0;\n        int sum = 0;\n        while (num != 0) {\n            int digit = abs(num % 10);\n            sum += digit;\n            num /= 10;\n        }\n        if (is_negative) sum -= 2 * (sum % 10);\n        if (sum > 0) count++;\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_114", "completion": "```cpp\n#include <vector>\n#include <string>\n\nint count_nums(std::vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        if (num == 0) continue;\n        bool is_negative = num < 0;\n        int sum = 0;\n        while (num != 0) {\n            int digit = abs(num % 10);\n            sum += digit;\n            num /= 10;\n        }\n        if (is_negative) sum -= 2 * (sum % 10);\n        if (sum > 0) count++;\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_114", "completion": "```cpp\n#include <vector>\n#include <string>\n\nint count_nums(std::vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        if (num == 0) continue;\n        bool is_negative = num < 0;\n        int sum = 0;\n        while (num != 0) {\n            int digit = abs(num % 10);\n            sum += digit;\n            num /= 10;\n        }\n        if (is_negative) sum -= 2 * (sum % 10);\n        if (sum > 0) count++;\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_114", "completion": "```cpp\n#include <vector>\n#include <string>\n\nint count_nums(std::vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        if (num == 0) continue;\n        bool is_negative = num < 0;\n        int sum = 0;\n        while (num != 0) {\n            int digit = abs(num % 10);\n            sum += digit;\n            num /= 10;\n        }\n        if (is_negative) sum -= 2 * (sum % 10);\n        if (sum > 0) count++;\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_115", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool move_one_ball(std::vector<int> arr) {\n    if (arr.empty()) {\n        return true;\n    }\n\n    int n = arr.size();\n    int count = 0;\n\n    for (int i = 1; i < n; ++i) {\n        if (arr[i] < arr[i - 1]) {\n            count++;\n            if (count > 1) {\n                return false;\n            }\n        }\n    }\n\n    if (count == 1 && arr.front() < arr.back()) {\n        return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_115", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool move_one_ball(std::vector<int> arr) {\n    if (arr.empty()) {\n        return true;\n    }\n\n    int n = arr.size();\n    int count = 0;\n\n    for (int i = 1; i < n; ++i) {\n        if (arr[i] < arr[i - 1]) {\n            count++;\n            if (count > 1) {\n                return false;\n            }\n        }\n    }\n\n    if (count == 1 && arr[0] < arr[n - 1]) {\n        return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_115", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool move_one_ball(std::vector<int> arr) {\n    if (arr.empty()) {\n        return true;\n    }\n\n    int n = arr.size();\n    int count = 0;\n\n    for (int i = 1; i < n; ++i) {\n        if (arr[i] < arr[i - 1]) {\n            count++;\n            if (count > 1) {\n                return false;\n            }\n        }\n    }\n\n    if (count == 1 && arr[0] < arr[n - 1]) {\n        return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_115", "completion": "```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nbool move_one_ball(std::vector<int> arr) {\n    if (arr.empty()) {\n        return true;\n    }\n\n    int n = arr.size();\n    int count = 0;\n\n    for (int i = 1; i < n; ++i) {\n        if (arr[i] < arr[i - 1]) {\n            count++;\n        }\n    }\n\n    if (arr[0] < arr[n - 1]) {\n        count++;\n    }\n\n    return count <= 1;\n}\n```"}
{"task_id": "SimdBench_115", "completion": "```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nbool move_one_ball(std::vector<int> arr) {\n    if (arr.empty()) {\n        return true;\n    }\n\n    int n = arr.size();\n    int count = 0;\n\n    for (int i = 1; i < n; ++i) {\n        if (arr[i] < arr[i - 1]) {\n            count++;\n        }\n    }\n\n    if (arr[0] < arr[n - 1]) {\n        count++;\n    }\n\n    return count <= 1;\n}\n```"}
{"task_id": "SimdBench_116", "completion": "```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstd::string myexchange(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int oddCountLst1 = std::count_if(lst1.begin(), lst1.end(), [](int x) { return x % 2 != 0; });\n    int evenCountLst2 = std::count_if(lst2.begin(), lst2.end(), [](int x) { return x % 2 == 0; });\n\n    if (oddCountLst1 <= evenCountLst2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116", "completion": "```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstd::string myexchange(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int oddCountLst1 = std::count_if(lst1.begin(), lst1.end(), [](int x) { return x % 2 != 0; });\n    int evenCountLst2 = std::count_if(lst2.begin(), lst2.end(), [](int x) { return x % 2 == 0; });\n\n    if (oddCountLst1 <= evenCountLst2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116", "completion": "```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstd::string myexchange(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int oddCountLst1 = std::count_if(lst1.begin(), lst1.end(), [](int x) { return x % 2 != 0; });\n    int evenCountLst2 = std::count_if(lst2.begin(), lst2.end(), [](int x) { return x % 2 == 0; });\n\n    if (oddCountLst1 <= evenCountLst2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116", "completion": "```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstd::string myexchange(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int oddCountLst1 = std::count_if(lst1.begin(), lst1.end(), [](int x) { return x % 2 != 0; });\n    int evenCountLst2 = std::count_if(lst2.begin(), lst2.end(), [](int x) { return x % 2 == 0; });\n\n    if (oddCountLst1 <= evenCountLst2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116", "completion": "```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstd::string myexchange(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int oddCountLst1 = std::count_if(lst1.begin(), lst1.end(), [](int x) { return x % 2 != 0; });\n    int evenCountLst2 = std::count_if(lst2.begin(), lst2.end(), [](int x) { return x % 2 == 0; });\n\n    if (oddCountLst1 <= evenCountLst2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_117", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        int count = 0;\n        for (char c : str) {\n            if ((c - '0') % 2 != 0) {\n                ++count;\n            }\n        }\n        std::string temp = \"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\";\n        result.push_back(temp);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    for (const auto& s : lst) {\n        int count = 0;\n        for (char c : s) {\n            if ((c - '0') % 2 != 0) {\n                ++count;\n            }\n        }\n        std::string temp = \"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\";\n        result.push_back(temp);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        int count = 0;\n        for (char c : str) {\n            if ((c - '0') % 2 != 0) {\n                ++count;\n            }\n        }\n        std::string temp = \"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\";\n        result.push_back(temp);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        int count = 0;\n        for (char c : str) {\n            if ((c - '0') % 2 != 0) {\n                ++count;\n            }\n        }\n        std::string temp = \"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\";\n        result.push_back(temp);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        int count = 0;\n        for (char c : str) {\n            if ((c - '0') % 2 != 0) {\n                ++count;\n            }\n        }\n        std::string temp = \"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\";\n        result.push_back(temp);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_118", "completion": "```cpp\nint64_t minSubArraySum(const std::vector<int64_t>& nums) {\n    int64_t min_sum = INT64_MAX;\n    int64_t current_sum = 0;\n\n    for (int64_t num : nums) {\n        current_sum = std::min(num, current_sum + num);\n        min_sum = std::min(min_sum, current_sum);\n    }\n\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118", "completion": "```cpp\n#include <climits>\n#include <vector>\n\nint64_t minSubArraySum(const std::vector<int64_t>& nums) {\n    int64_t min_sum = INT_MAX;\n    int64_t current_sum = 0;\n\n    for (int64_t num : nums) {\n        current_sum = std::min(num, current_sum + num);\n        min_sum = std::min(min_sum, current_sum);\n    }\n\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118", "completion": "```cpp\nint64_t minSubArraySum(const std::vector<int64_t>& nums) {\n    int64_t min_sum = INT64_MAX;\n    int64_t current_sum = 0;\n    \n    for (int64_t num : nums) {\n        current_sum = std::min(num, current_sum + num);\n        min_sum = std::min(min_sum, current_sum);\n    }\n    \n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118", "completion": "```cpp\nint64_t minSubArraySum(const std::vector<int64_t>& nums) {\n    int64_t min_sum = nums[0];\n    int64_t current_sum = nums[0];\n    \n    for (size_t i = 1; i < nums.size(); ++i) {\n        current_sum = std::min(nums[i], current_sum + nums[i]);\n        min_sum = std::min(min_sum, current_sum);\n    }\n    \n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118", "completion": "```cpp\nint64_t minSubArraySum(const std::vector<int64_t>& nums) {\n    int64_t min_sum = INT64_MAX;\n    int64_t current_sum = 0;\n\n    for (int64_t num : nums) {\n        current_sum = std::min(num, current_sum + num);\n        min_sum = std::min(min_sum, current_sum);\n    }\n\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_119", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nint max_fill(const std::vector<std::vector<int>>& grid, int capacity) {\n    int total_water = 0;\n    for (const auto& row : grid) {\n        total_water += std::count(row.begin(), row.end(), 1);\n    }\n    return (total_water + capacity - 1) / capacity;\n}\n```"}
{"task_id": "SimdBench_119", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nint max_fill(const std::vector<std::vector<int>>& grid, int capacity) {\n    int total_water = 0;\n    for (const auto& row : grid) {\n        total_water += std::count(row.begin(), row.end(), 1);\n    }\n    return (total_water + capacity - 1) / capacity;\n}\n```"}
{"task_id": "SimdBench_119", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nint max_fill(const std::vector<std::vector<int>>& grid, int capacity) {\n    int total_water = 0;\n    for (const auto& row : grid) {\n        total_water += std::count(row.begin(), row.end(), 1);\n    }\n    return (total_water + capacity - 1) / capacity;\n}\n```"}
{"task_id": "SimdBench_119", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nint max_fill(const std::vector<std::vector<int>>& grid, int capacity) {\n    int total_water = 0;\n    for (const auto& row : grid) {\n        total_water += std::count(row.begin(), row.end(), 1);\n    }\n    return (total_water + capacity - 1) / capacity;\n}\n```"}
{"task_id": "SimdBench_119", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nint max_fill(const std::vector<std::vector<int>>& grid, int capacity) {\n    int total_water = 0;\n    for (const auto& row : grid) {\n        total_water += std::count(row.begin(), row.end(), 1);\n    }\n    return (total_water + capacity - 1) / capacity;\n}\n```"}
{"task_id": "SimdBench_120", "completion": "```cpp\nint64_t solution(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120", "completion": "```cpp\nint64_t solution(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120", "completion": "```cpp\nint64_t solution(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120", "completion": "```cpp\nint64_t solution(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120", "completion": "```cpp\nint64_t solution(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121", "completion": "```cpp\nint add_elements(std::vector<int> arr, int k){\n    int sum = 0;\n    for(int i = 0; i < k; ++i){\n        if(arr[i] >= -99 && arr[i] <= 99){\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121", "completion": "```cpp\nint add_elements(std::vector<int> arr, int k){\n    int sum = 0;\n    for(int i = 0; i < k; ++i){\n        if(arr[i] >= -99 && arr[i] <= 99){\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121", "completion": "```cpp\nint add_elements(std::vector<int> arr, int k){\n    int sum = 0;\n    for(int i = 0; i < k; ++i){\n        if(arr[i] >= -99 && arr[i] <= 99){\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121", "completion": "```cpp\nint add_elements(std::vector<int> arr, int k){\n    int sum = 0;\n    for(int i = 0; i < k; ++i){\n        if(arr[i] >= -99 && arr[i] <= 99){\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121", "completion": "```cpp\nint add_elements(std::vector<int> arr, int k){\n    int sum = 0;\n    for(int i = 0; i < k; ++i){\n        if(arr[i] >= -99 && arr[i] <= 99){\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_122", "completion": "```cpp\nbool is_sorted(const std::vector<int> & lst) {\n    if (lst.size() <= 1) return true;\n    \n    for (size_t i = 1; i < lst.size(); ++i) {\n        if (lst[i] < lst[i - 1]) return false;\n        if (i > 1 && lst[i] == lst[i - 1] && lst[i] == lst[i - 2]) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_122", "completion": "```cpp\nbool is_sorted(const std::vector<int> & lst) {\n    if (lst.size() <= 1) return true;\n    \n    for (size_t i = 1; i < lst.size(); ++i) {\n        if (lst[i] < lst[i - 1]) return false;\n        if (i > 1 && lst[i] == lst[i - 1] && lst[i] == lst[i - 2]) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_122", "completion": "```cpp\nbool is_sorted(const std::vector<int> & lst) {\n    if (lst.size() <= 1) return true;\n    \n    for (size_t i = 1; i < lst.size(); ++i) {\n        if (lst[i] < lst[i - 1]) return false;\n        if (i > 1 && lst[i] == lst[i - 1] && lst[i] == lst[i - 2]) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_122", "completion": "```cpp\nbool is_sorted(const std::vector<int> & lst) {\n    if (lst.size() <= 1) return true;\n    \n    for (size_t i = 1; i < lst.size(); ++i) {\n        if (lst[i] < lst[i - 1]) return false;\n        if (i > 1 && lst[i] == lst[i - 1] && lst[i] == lst[i - 2]) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_122", "completion": "```cpp\nbool is_sorted(const std::vector<int> & lst) {\n    if (lst.size() <= 1) return true;\n    \n    for (size_t i = 1; i < lst.size(); ++i) {\n        if (lst[i] < lst[i - 1]) return false;\n        if (i > 1 && lst[i] == lst[i - 1] && lst[i] == lst[i - 2]) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_123", "completion": "```cpp\n#include <vector>\n#include <numeric>\n\nint prod_signs(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n    \n    int sign_product = std::accumulate(arr.begin(), arr.end(), 1,\n                                       [](int acc, int num) {\n                                           return acc * (num > 0 ? 1 : (num < 0 ? -1 : 0));\n                                       });\n    \n    int magnitude_sum = std::accumulate(arr.begin(), arr.end(), 0,\n                                        [](int acc, int num) {\n                                            return acc + std::abs(num);\n                                        });\n    \n    return sign_product * magnitude_sum;\n}\n```"}
{"task_id": "SimdBench_123", "completion": "```cpp\n#include <vector>\n#include <numeric>\n\nint prod_signs(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n    \n    int sign_product = std::accumulate(arr.begin(), arr.end(), 1, [](int acc, int num) {\n        return acc * (num > 0 ? 1 : (num < 0 ? -1 : 0));\n    });\n    \n    int magnitude_sum = std::accumulate(arr.begin(), arr.end(), 0, [](int acc, int num) {\n        return acc + std::abs(num);\n    });\n    \n    return sign_product * magnitude_sum;\n}\n```"}
{"task_id": "SimdBench_123", "completion": "```cpp\n#include <vector>\n#include <numeric>\n\nint prod_signs(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n    \n    int sign_product = std::accumulate(arr.begin(), arr.end(), 1, [](int acc, int num) {\n        return acc * (num > 0 ? 1 : (num < 0 ? -1 : 0));\n    });\n    \n    int magnitude_sum = std::accumulate(arr.begin(), arr.end(), 0, [](int acc, int num) {\n        return acc + std::abs(num);\n    });\n    \n    return sign_product * magnitude_sum;\n}\n```"}
{"task_id": "SimdBench_123", "completion": "```cpp\n#include <vector>\n#include <numeric>\n\nint prod_signs(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n    \n    int sign_product = std::accumulate(arr.begin(), arr.end(), 1, [](int acc, int num) {\n        return acc * (num > 0 ? 1 : (num < 0 ? -1 : 0));\n    });\n    \n    int magnitude_sum = std::accumulate(arr.begin(), arr.end(), 0, [](int acc, int num) {\n        return acc + std::abs(num);\n    });\n    \n    return sign_product * magnitude_sum;\n}\n```"}
{"task_id": "SimdBench_123", "completion": "```cpp\n#include <vector>\n#include <numeric>\n#include <cstdlib>\n\nint prod_signs(const std::vector<int> & arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n    \n    int sign_product = std::accumulate(arr.begin(), arr.end(), 1, [](int acc, int num) {\n        return acc * (num > 0 ? 1 : (num < 0 ? -1 : 0));\n    });\n    \n    int magnitude_sum = std::accumulate(arr.begin(), arr.end(), 0, [](int acc, int num) {\n        return acc + std::abs(num);\n    });\n    \n    return sign_product * magnitude_sum;\n}\n```"}
{"task_id": "SimdBench_124", "completion": "```cpp\n#include <vector>\n#include <queue>\n#include <climits>\n\nstruct Cell {\n    int x, y, dist;\n    std::vector<int> path;\n\n    Cell(int _x, int _y, int _dist, const std::vector<int>& _path)\n        : x(_x), y(_y), dist(_dist), path(_path) {}\n};\n\nbool isValid(int x, int y, int n) {\n    return x >= 0 && x < n && y >= 0 && y < n;\n}\n\nstd::vector<int> minPath(const std::vector<std::vector<int>>& grid, int k) {\n    int n = grid.size();\n    std::priority_queue<Cell, std::vector<Cell>, std::greater<Cell>> pq;\n    std::vector<std::vector<bool>> visited(n, std::vector<bool>(n, false));\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            pq.push(Cell(i, j, 1, {grid[i][j]}));\n        }\n    }\n\n    while (!pq.empty()) {\n        auto current = pq.top();\n        pq.pop();\n\n        if (current.dist == k) {\n            return current.path;\n        }\n\n        static const std::vector<std::pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        for (const auto& dir : directions) {\n            int newX = current.x + dir.first;\n            int newY = current.y + dir.second;\n\n            if (isValid(newX, newY, n) && !visited[newX][newY]) {\n                visited[newX][newY] = true;\n                std::vector<int> newPath = current.path;\n                newPath.push_back(grid[newX][newY]);\n                pq.push(Cell(newX, newY, current.dist + 1, newPath));\n            }\n        }\n    }\n\n    return {};\n}\n```"}
{"task_id": "SimdBench_124", "completion": "```cpp\n#include <vector>\n#include <queue>\n#include <climits>\n\nstruct Cell {\n    int x, y, dist;\n    std::vector<int> path;\n\n    Cell(int _x, int _y, int _dist, const std::vector<int>& _path)\n        : x(_x), y(_y), dist(_dist), path(_path) {}\n};\n\nbool isValid(int x, int y, int n) {\n    return x >= 0 && x < n && y >= 0 && y < n;\n}\n\nstd::vector<int> minPath(const std::vector<std::vector<int>>& grid, int k) {\n    int n = grid.size();\n    std::priority_queue<Cell, std::vector<Cell>, std::greater<Cell>> pq;\n    std::vector<std::vector<bool>> visited(n, std::vector<bool>(n, false));\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            pq.push(Cell(i, j, 1, {grid[i][j]}));\n        }\n    }\n\n    while (!pq.empty()) {\n        auto current = pq.top();\n        pq.pop();\n\n        if (current.dist == k) {\n            return current.path;\n        }\n\n        static const std::vector<std::pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n        for (const auto& dir : directions) {\n            int newX = current.x + dir.first;\n            int newY = current.y + dir.second;\n\n            if (isValid(newX, newY, n) && !visited[newX][newY]) {\n                visited[newX][newY] = true;\n                std::vector<int> newPath = current.path;\n                newPath.push_back(grid[newX][newY]);\n                pq.push(Cell(newX, newY, current.dist + 1, newPath));\n            }\n        }\n    }\n\n    return {};\n}\n```"}
{"task_id": "SimdBench_124", "completion": "```cpp\n#include <vector>\n#include <queue>\n#include <climits>\n\nstruct Cell {\n    int x, y, dist;\n    std::vector<int> path;\n\n    Cell(int _x, int _y, int _dist, const std::vector<int>& _path)\n        : x(_x), y(_y), dist(_dist), path(_path) {}\n};\n\nbool isValid(int x, int y, int n) {\n    return x >= 0 && x < n && y >= 0 && y < n;\n}\n\nstd::vector<int> minPath(const std::vector<std::vector<int>>& grid, int k) {\n    int n = grid.size();\n    std::priority_queue<Cell, std::vector<Cell>, std::greater<Cell>> pq;\n    std::vector<std::vector<bool>> visited(n, std::vector<bool>(n, false));\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            pq.push(Cell(i, j, 1, {grid[i][j]}));\n        }\n    }\n\n    while (!pq.empty()) {\n        auto current = pq.top();\n        pq.pop();\n\n        if (current.dist == k) {\n            return current.path;\n        }\n\n        static const std::vector<std::pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n        for (const auto& dir : directions) {\n            int nx = current.x + dir.first;\n            int ny = current.y + dir.second;\n\n            if (isValid(nx, ny, n) && !visited[nx][ny]) {\n                visited[nx][ny] = true;\n                std::vector<int> newPath = current.path;\n                newPath.push_back(grid[nx][ny]);\n                pq.push(Cell(nx, ny, current.dist + 1, newPath));\n            }\n        }\n    }\n\n    return {};\n}\n```"}
{"task_id": "SimdBench_124", "completion": "```cpp\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n\nstruct Cell {\n    int x, y, dist;\n    std::vector<int> path;\n\n    Cell(int _x, int _y, int _dist, const std::vector<int>& _path)\n        : x(_x), y(_y), dist(_dist), path(_path) {}\n};\n\nbool isValid(int x, int y, int n) {\n    return x >= 0 && x < n && y >= 0 && y < n;\n}\n\nstd::vector<int> minPath(const std::vector<std::vector<int>>& grid, int k) {\n    int n = grid.size();\n    std::priority_queue<Cell, std::vector<Cell>, std::greater<Cell>> pq;\n    std::vector<std::vector<bool>> visited(n, std::vector<bool>(n, false));\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            pq.push(Cell(i, j, 1, {grid[i][j]}));\n        }\n    }\n\n    while (!pq.empty()) {\n        auto current = pq.top();\n        pq.pop();\n\n        if (current.dist == k) {\n            return current.path;\n        }\n\n        static const std::vector<std::pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        for (const auto& dir : directions) {\n            int newX = current.x + dir.first;\n            int newY = current.y + dir.second;\n\n            if (isValid(newX, newY, n) && !visited[newX][newY]) {\n                visited[newX][newY] = true;\n                std::vector<int> newPath = current.path;\n                newPath.push_back(grid[newX][newY]);\n                pq.push(Cell(newX, newY, current.dist + 1, newPath));\n            }\n        }\n    }\n\n    return {};\n}\n```"}
{"task_id": "SimdBench_124", "completion": "```cpp\n#include <vector>\n#include <queue>\n#include <climits>\n\nstruct Cell {\n    int x, y, dist;\n    std::vector<int> path;\n\n    Cell(int x, int y, int dist, const std::vector<int>& path)\n        : x(x), y(y), dist(dist), path(path) {}\n\n    bool operator<(const Cell& other) const {\n        return path > other.path;\n    }\n};\n\nstd::vector<int> minPath(const std::vector<std::vector<int>>& grid, int k) {\n    int n = grid.size();\n    std::priority_queue<Cell> pq;\n    std::vector<std::vector<bool>> visited(n, std::vector<bool>(n, false));\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            pq.push({i, j, 1, {grid[i][j]}});\n        }\n    }\n\n    while (!pq.empty()) {\n        auto [x, y, dist, path] = pq.top();\n        pq.pop();\n\n        if (dist == k) {\n            return path;\n        }\n\n        if (visited[x][y]) continue;\n        visited[x][y] = true;\n\n        static const std::vector<std::pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n        for (const auto& [dx, dy] : directions) {\n            int nx = x + dx, ny = y + dy;\n            if (nx >= 0 && nx < n && ny >= 0 && ny < n) {\n                pq.push({nx, ny, dist + 1, path});\n            }\n        }\n    }\n\n    return {};\n}\n```"}
{"task_id": "SimdBench_125", "completion": "```cpp\n#include <iostream>\n\nuint64_t digits(uint64_t n) {\n    uint64_t product = 1;\n    bool hasOdd = false;\n    while (n > 0) {\n        uint64_t digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n            hasOdd = true;\n        }\n        n /= 10;\n    }\n    return hasOdd ? product : 0;\n}\n\nint main() {\n    std::cout << digits(1) << std::endl;   // Output: 1\n    std::cout << digits(4) << std::endl;   // Output: 0\n    std::cout << digits(235) << std::endl; // Output: 15\n    return 0;\n}\n```"}
{"task_id": "SimdBench_125", "completion": "```cpp\n#include <iostream>\n\nuint64_t digits(uint64_t n) {\n    uint64_t product = 1;\n    bool hasOdd = false;\n    while (n > 0) {\n        uint64_t digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n            hasOdd = true;\n        }\n        n /= 10;\n    }\n    return hasOdd ? product : 0;\n}\n\nint main() {\n    std::cout << digits(1) << std::endl;   // Output: 1\n    std::cout << digits(4) << std::endl;   // Output: 0\n    std::cout << digits(235) << std::endl; // Output: 15\n    return 0;\n}\n```"}
{"task_id": "SimdBench_125", "completion": "```cpp\n#include <iostream>\n\nuint64_t digits(uint64_t n) {\n    uint64_t product = 1;\n    bool hasOdd = false;\n    while (n > 0) {\n        uint64_t digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n            hasOdd = true;\n        }\n        n /= 10;\n    }\n    return hasOdd ? product : 0;\n}\n\nint main() {\n    std::cout << digits(1) << std::endl;   // Output: 1\n    std::cout << digits(4) << std::endl;   // Output: 0\n    std::cout << digits(235) << std::endl; // Output: 15\n    return 0;\n}\n```"}
{"task_id": "SimdBench_125", "completion": "```cpp\n#include <iostream>\n\nuint64_t digits(uint64_t n) {\n    uint64_t product = 1;\n    bool hasOdd = false;\n\n    while (n > 0) {\n        uint64_t digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n            hasOdd = true;\n        }\n        n /= 10;\n    }\n\n    return hasOdd ? product : 0;\n}\n\nint main() {\n    std::cout << digits(1) << std::endl;   // Output: 1\n    std::cout << digits(4) << std::endl;   // Output: 0\n    std::cout << digits(235) << std::endl; // Output: 15\n    return 0;\n}\n```"}
{"task_id": "SimdBench_125", "completion": "```cpp\n#include <iostream>\n\nuint64_t digits(uint64_t n) {\n    uint64_t product = 1;\n    bool hasOdd = false;\n    while (n > 0) {\n        uint64_t digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n            hasOdd = true;\n        }\n        n /= 10;\n    }\n    return hasOdd ? product : 0;\n}\n\nint main() {\n    std::cout << digits(1) << std::endl;   // Output: 1\n    std::cout << digits(4) << std::endl;   // Output: 0\n    std::cout << digits(235) << std::endl; // Output: 15\n    return 0;\n}\n```"}
{"task_id": "SimdBench_126", "completion": "```cpp\n#include <cmath>\n#include <vector>\n\nuint64_t sum_squares(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    for (float num : lst) {\n        int ceil_num = static_cast<int>(std::ceil(num));\n        sum += static_cast<uint64_t>(ceil_num * ceil_num);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126", "completion": "```cpp\n#include <cmath>\n#include <numeric>\n#include <vector>\n\nuint64_t sum_squares(const std::vector<float> & lst) {\n    return std::accumulate(lst.begin(), lst.end(), 0ULL, [](uint64_t acc, float num) {\n        return acc + static_cast<uint64_t>(std::ceil(num)) * static_cast<uint64_t>(std::ceil(num));\n    });\n}\n```"}
{"task_id": "SimdBench_126", "completion": "```cpp\n#include <cmath>\n#include <numeric>\n#include <vector>\n\nuint64_t sum_squares(const std::vector<float> & lst) {\n    return std::accumulate(lst.begin(), lst.end(), 0ULL, [](uint64_t acc, float num) {\n        return acc + static_cast<uint64_t>(std::pow(std::ceil(num), 2));\n    });\n}\n```"}
{"task_id": "SimdBench_126", "completion": "```cpp\n#include <cmath>\n#include <vector>\n\nuint64_t sum_squares(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    for (float num : lst) {\n        int ceil_num = static_cast<int>(std::ceil(num));\n        sum += static_cast<uint64_t>(ceil_num * ceil_num);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126", "completion": "```cpp\n#include <cmath>\n#include <vector>\n\nuint64_t sum_squares(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    for(float num : lst){\n        int ceil_num = static_cast<int>(std::ceil(num));\n        sum += static_cast<uint64_t>(ceil_num * ceil_num);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_127", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nint can_arrange(const std::vector<int> & arr) {\n    for (size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            return static_cast<int>(i);\n        }\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_127", "completion": "```cpp\nint can_arrange(const std::vector<int> & arr) {\n    for (size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            return static_cast<int>(i);\n        }\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_127", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nint can_arrange(const std::vector<int> & arr) {\n    for (size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] >= arr[i - 1]) {\n            return static_cast<int>(i);\n        }\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_127", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nint can_arrange(const std::vector<int> & arr) {\n    for (size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            return static_cast<int>(i);\n        }\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_127", "completion": "```cpp\nint can_arrange(const std::vector<int> & arr) {\n    for (size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            return static_cast<int>(i);\n        }\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_128", "completion": "```cpp\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers(const std::vector<int>& lst) {\n    int max_neg = std::numeric_limits<int>::min();\n    int min_pos = std::numeric_limits<int>::max();\n    bool has_neg = false;\n    bool has_pos = false;\n\n    for (int num : lst) {\n        if (num < 0 && num > max_neg) {\n            max_neg = num;\n            has_neg = true;\n        } else if (num > 0 && num < min_pos) {\n            min_pos = num;\n            has_pos = true;\n        }\n    }\n\n    return {has_neg ? max_neg : 0, has_pos ? min_pos : 0};\n}\n```"}
{"task_id": "SimdBench_128", "completion": "```cpp\nstd::vector<int> largest_smallest_integers(const std::vector<int>& lst) {\n    int max_neg = INT_MIN;\n    int min_pos = INT_MAX;\n    bool has_neg = false;\n    bool has_pos = false;\n\n    for (int num : lst) {\n        if (num < 0 && num > max_neg) {\n            max_neg = num;\n            has_neg = true;\n        } else if (num > 0 && num < min_pos) {\n            min_pos = num;\n            has_pos = true;\n        }\n    }\n\n    return {has_neg ? max_neg : 0, has_pos ? min_pos : 0};\n}\n```"}
{"task_id": "SimdBench_128", "completion": "```cpp\nstd::vector<int> largest_smallest_integers(const std::vector<int>& lst) {\n    if (lst.empty()) return {0, 0};\n\n    int max_neg = INT_MIN;\n    int min_pos = INT_MAX;\n    bool has_neg = false;\n    bool has_pos = false;\n\n    for (int num : lst) {\n        if (num < 0 && num > max_neg) {\n            max_neg = num;\n            has_neg = true;\n        } else if (num > 0 && num < min_pos) {\n            min_pos = num;\n            has_pos = true;\n        }\n    }\n\n    if (!has_neg) max_neg = 0;\n    if (!has_pos) min_pos = 0;\n\n    return {max_neg, min_pos};\n}\n```"}
{"task_id": "SimdBench_128", "completion": "```cpp\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    int max_neg = std::numeric_limits<int>::min();\n    int min_pos = std::numeric_limits<int>::max();\n    bool has_neg = false;\n    bool has_pos = false;\n\n    for (int num : lst) {\n        if (num < 0 && num > max_neg) {\n            max_neg = num;\n            has_neg = true;\n        } else if (num > 0 && num < min_pos) {\n            min_pos = num;\n            has_pos = true;\n        }\n    }\n\n    if (!has_neg) {\n        max_neg = 0;\n    }\n    if (!has_pos) {\n        min_pos = 0;\n    }\n\n    return {max_neg, min_pos};\n}\n```"}
{"task_id": "SimdBench_128", "completion": "```cpp\nstd::vector<int> largest_smallest_integers(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    int max_neg = INT_MIN;\n    int min_pos = INT_MAX;\n    bool has_neg = false;\n    bool has_pos = false;\n\n    for (int num : lst) {\n        if (num < 0 && num > max_neg) {\n            max_neg = num;\n            has_neg = true;\n        } else if (num > 0 && num < min_pos) {\n            min_pos = num;\n            has_pos = true;\n        }\n    }\n\n    if (!has_neg) {\n        max_neg = 0;\n    }\n    if (!has_pos) {\n        min_pos = 0;\n    }\n\n    return {max_neg, min_pos};\n}\n```"}
{"task_id": "SimdBench_129", "completion": "```c\n#include <stdint.h>\n\nuint64_t factorial(uint64_t num) {\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= num; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\nuint64_t special_factorial(uint64_t n) {\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; ++i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_129", "completion": "```c\n#include <stdint.h>\n\nuint64_t factorial(uint64_t num) {\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= num; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\nuint64_t special_factorial(uint64_t n) {\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; ++i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_129", "completion": "```c\n#include <stdint.h>\n\nuint64_t factorial(uint64_t num) {\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= num; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\nuint64_t special_factorial(uint64_t n) {\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; ++i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_129", "completion": "```c\n#include <stdint.h>\n\nuint64_t factorial(uint64_t num) {\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= num; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\nuint64_t special_factorial(uint64_t n) {\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; ++i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_129", "completion": "```c\n#include <stdint.h>\n\nuint64_t factorial(uint64_t num) {\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= num; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\nuint64_t special_factorial(uint64_t n) {\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; ++i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_130", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint sum_squares(const std::vector<int> & lst) {\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            sum += std::pow(lst[i], 2);\n        } else if (i % 4 == 0) {\n            sum += std::pow(lst[i], 3);\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint sum_squares(const std::vector<int> & lst) {\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            sum += std::pow(lst[i], 2);\n        } else if (i % 4 == 0) {\n            sum += std::pow(lst[i], 3);\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint sum_squares(const std::vector<int> & lst) {\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            sum += std::pow(lst[i], 2);\n        } else if (i % 4 == 0) {\n            sum += std::pow(lst[i], 3);\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint sum_squares(const std::vector<int> & lst) {\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            sum += std::pow(lst[i], 2);\n        } else if (i % 4 == 0) {\n            sum += std::pow(lst[i], 3);\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint sum_squares(const std::vector<int> & lst) {\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            sum += std::pow(lst[i], 2);\n        } else if (i % 4 == 0) {\n            sum += std::pow(lst[i], 3);\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_131", "completion": "```cpp\n#include <vector>\n#include <string>\n\nint specialFilter(const std::vector<int> & nums) {\n    int count = 0;\n    for (int num : nums) {\n        if (num > 10) {\n            std::string numStr = std::to_string(num);\n            char firstDigit = numStr[0];\n            char lastDigit = numStr.back();\n            if ((firstDigit - '0') % 2 != 0 && (lastDigit - '0') % 2 != 0) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_131", "completion": "```cpp\n#include <vector>\n#include <string>\n\nint specialFilter(const std::vector<int> & nums) {\n    int count = 0;\n    for (int num : nums) {\n        if (num > 10) {\n            std::string numStr = std::to_string(num);\n            char firstDigit = numStr[0];\n            char lastDigit = numStr.back();\n            if ((firstDigit - '0') % 2 != 0 && (lastDigit - '0') % 2 != 0) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_131", "completion": "```cpp\n#include <vector>\n#include <string>\n\nint specialFilter(const std::vector<int> & nums) {\n    int count = 0;\n    for (int num : nums) {\n        if (num > 10) {\n            std::string numStr = std::to_string(num);\n            char firstDigit = numStr[0];\n            char lastDigit = numStr.back();\n            if ((firstDigit - '0') % 2 != 0 && (lastDigit - '0') % 2 != 0) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_131", "completion": "```cpp\n#include <vector>\n#include <string>\n\nint specialFilter(const std::vector<int> & nums) {\n    int count = 0;\n    for (int num : nums) {\n        if (num > 10) {\n            std::string numStr = std::to_string(num);\n            char firstDigit = numStr[0];\n            char lastDigit = numStr.back();\n            if ((firstDigit - '0') % 2 != 0 && (lastDigit - '0') % 2 != 0) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_131", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint specialFilter(const std::vector<int> & nums) {\n    int count = 0;\n    for (int num : nums) {\n        if (num > 10) {\n            int lastDigit = abs(num) % 10;\n            int firstDigit = abs(num);\n            while (firstDigit >= 10) {\n                firstDigit /= 10;\n            }\n            if (firstDigit % 2 != 0 && lastDigit % 2 != 0) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_132", "completion": "```cpp\n#include <vector>\n\nuint64_t get_max_triples(uint64_t n) {\n    std::vector<uint64_t> a(n);\n    for (uint64_t i = 0; i < n; ++i) {\n        a[i] = i * i - i + 1;\n    }\n\n    uint64_t count = 0;\n    for (uint64_t i = 0; i < n - 2; ++i) {\n        for (uint64_t j = i + 1; j < n - 1; ++j) {\n            for (uint64_t k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    ++count;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_132", "completion": "```cpp\n#include <vector>\n\nuint64_t get_max_triples(uint64_t n) {\n    std::vector<uint64_t> a(n);\n    for (uint64_t i = 0; i < n; ++i) {\n        a[i] = i * i - i + 1;\n    }\n\n    uint64_t count = 0;\n    for (uint64_t i = 0; i < n - 2; ++i) {\n        for (uint64_t j = i + 1; j < n - 1; ++j) {\n            for (uint64_t k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    ++count;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_132", "completion": "```cpp\n#include <vector>\n\nuint64_t get_max_triples(uint64_t n) {\n    std::vector<uint64_t> a(n);\n    for (uint64_t i = 0; i < n; ++i) {\n        a[i] = i * i - i + 1;\n    }\n\n    uint64_t count = 0;\n    for (uint64_t i = 0; i < n - 2; ++i) {\n        for (uint64_t j = i + 1; j < n - 1; ++j) {\n            for (uint64_t k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    ++count;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_132", "completion": "```cpp\n#include <vector>\n\nuint64_t get_max_triples(uint64_t n) {\n    std::vector<uint64_t> a(n);\n    for (uint64_t i = 0; i < n; ++i) {\n        a[i] = i * i - i + 1;\n    }\n\n    uint64_t count = 0;\n    for (uint64_t i = 0; i < n - 2; ++i) {\n        for (uint64_t j = i + 1; j < n - 1; ++j) {\n            for (uint64_t k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    ++count;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_132", "completion": "```cpp\n#include <vector>\n\nuint64_t get_max_triples(uint64_t n) {\n    std::vector<uint64_t> a(n);\n    for (uint64_t i = 0; i < n; ++i) {\n        a[i] = i * i - i + 1;\n    }\n\n    uint64_t count = 0;\n    for (uint64_t i = 0; i < n - 2; ++i) {\n        for (uint64_t j = i + 1; j < n - 1; ++j) {\n            for (uint64_t k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    ++count;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_133", "completion": "```c\n#include <stdbool.h>\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint x_or_y(int n, int x, int y) {\n    return is_prime(n) ? x : y;\n}\n```"}
{"task_id": "SimdBench_133", "completion": "```c\n#include <stdbool.h>\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint x_or_y(int n, int x, int y) {\n    return is_prime(n) ? x : y;\n}\n```"}
{"task_id": "SimdBench_133", "completion": "```c\n#include <stdbool.h>\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint x_or_y(int n, int x, int y) {\n    return is_prime(n) ? x : y;\n}\n```"}
{"task_id": "SimdBench_133", "completion": "```c\n#include <stdbool.h>\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint x_or_y(int n, int x, int y) {\n    return is_prime(n) ? x : y;\n}\n```"}
{"task_id": "SimdBench_133", "completion": "```c\n#include <stdbool.h>\n\nbool is_prime(int num) {\n    if (num <= 1) return false;\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) return false;\n    }\n    return true;\n}\n\nint x_or_y(int n, int x, int y) {\n    return is_prime(n) ? x : y;\n}\n```"}
{"task_id": "SimdBench_134", "completion": "```cpp\n#include <cmath>\n#include <vector>\n\nuint64_t double_the_difference(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    for (float num : lst) {\n        if (num > 0 && fmod(num, 1) == 0 && static_cast<int>(num) % 2 != 0) {\n            sum += static_cast<uint64_t>(std::pow(num, 2));\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nuint64_t double_the_difference(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    for (float num : lst) {\n        if (num > 0 && floor(num) == num && static_cast<int>(num) % 2 != 0) {\n            sum += static_cast<uint64_t>(pow(num, 2));\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nuint64_t double_the_difference(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    for (float num : lst) {\n        if (num > 0 && floor(num) == num && static_cast<int>(num) % 2 != 0) {\n            sum += static_cast<uint64_t>(pow(num, 2));\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134", "completion": "```cpp\n#include <cmath>\n#include <vector>\n\nuint64_t double_the_difference(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    for (float num : lst) {\n        if (num > 0 && fmod(num, 1) == 0 && static_cast<int>(num) % 2 != 0) {\n            sum += static_cast<uint64_t>(std::pow(num, 2));\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nuint64_t double_the_difference(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    for (float num : lst) {\n        if (num > 0 && floor(num) == num && static_cast<int>(num) % 2 != 0) {\n            sum += static_cast<uint64_t>(pow(num, 2));\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_135", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nstd::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result;\n    for (size_t i = 0; i < game.size(); ++i) {\n        result.push_back(std::abs(game[i] - guess[i]));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nstd::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result;\n    for (size_t i = 0; i < game.size(); ++i) {\n        result.push_back(std::abs(game[i] - guess[i]));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nstd::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result;\n    for (size_t i = 0; i < game.size(); ++i) {\n        result.push_back(std::abs(game[i] - guess[i]));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nstd::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result;\n    for (size_t i = 0; i < game.size(); ++i) {\n        result.push_back(std::abs(game[i] - guess[i]));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nstd::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result;\n    for (size_t i = 0; i < game.size(); ++i) {\n        result.push_back(std::abs(game[i] - guess[i]));\n    }\n    return result;\n}\n```"}

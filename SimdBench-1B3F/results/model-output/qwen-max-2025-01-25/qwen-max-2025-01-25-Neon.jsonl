{"task_id": "SimdBench_0_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n\n    // Process 2 elements at a time using NEON intrinsics\n    for (; i + 1 < length; i += 2) {\n        // Load 2 mask values\n        uint8x8_t mask_vec = vld1_u8((const uint8_t*)(mask + i));\n\n        // Compare mask values to create a selection mask\n        uint8x8_t true_vec = vmov_n_u8(1);\n        uint8x8_t mask_cmp = vceq_u8(mask_vec, true_vec);\n\n        // Load 2 source and destination values\n        int64x2_t src_vec = vld1q_s64(src + i);\n        int64x2_t dst_vec = vld1q_s64(dst + i);\n\n        // Use the mask to conditionally select between src and dst values\n        int64x2_t result = vbslq_s64(vreinterpretq_u64_u8(vdupq_lane_u8(mask_cmp, 0)), src_vec, dst_vec);\n\n        // Store the result back to the destination array\n        vst1q_s64(dst + i, result);\n    }\n\n    // Handle any remaining elements\n    for (; i < length; ++i) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n\n    // Process 2 elements at a time using Neon intrinsics\n    for (; i + 1 < length; i += 2) {\n        // Load 2 mask values\n        uint8x8_t mask_vec = vld1_u8((const uint8_t*)(mask + i));\n\n        // Compare mask values to create a selection mask\n        uint8x8_t mask_cmp = vceq_u8(mask_vec, vdup_n_u8(1));\n\n        // Load 2 source values\n        int64x2_t src_vec = vld1q_s64(src + i);\n\n        // Load 2 destination values\n        int64x2_t dst_vec = vld1q_s64(dst + i);\n\n        // Blend values based on the mask\n        dst_vec = vbslq_s64(vreinterpretq_u64_u8(vdupq_lane_u8(mask_cmp, 0)), src_vec, dst_vec);\n\n        // Store the result back to the destination\n        vst1q_s64(dst + i, dst_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < length; ++i) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n\n    // Process 2 elements at a time using Neon intrinsics\n    for (; i + 1 < length; i += 2) {\n        // Load 2 mask values\n        uint8x8_t mask_vec = vld1_u8((const uint8_t *)(mask + i));\n\n        // Compare mask values to create a selection mask\n        uint64x2_t mask_cmp = vcgtq_u64(vreinterpretq_u64_u8(mask_vec), vmovq_n_u64(0));\n\n        // Load 2 source values\n        int64x2_t src_vec = vld1q_s64(src + i);\n\n        // Load 2 destination values\n        int64x2_t dst_vec = vld1q_s64(dst + i);\n\n        // Selectively move values based on the mask\n        int64x2_t result = vbslq_s64(vreinterpretq_u64_u8(mask_cmp), src_vec, dst_vec);\n\n        // Store the result back to the destination array\n        vst1q_s64(dst + i, result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; ++i) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n\n    // Process 2 elements at a time using NEON intrinsics\n    for (; i + 1 < length; i += 2) {\n        // Load 2 mask values\n        uint8x8_t mask_vec = vld1_u8((const uint8_t*)(mask + i));\n\n        // Compare mask values to create a selection mask\n        uint8x8_t mask_cmp = vceq_u8(mask_vec, vdup_n_u8(1));\n\n        // Load 2 source values\n        int64x2_t src_vec = vld1q_s64(src + i);\n\n        // Load 2 destination values\n        int64x2_t dst_vec = vld1q_s64(dst + i);\n\n        // Use the mask to conditionally select between src and dst values\n        int64x2_t result = vbslq_s64(vreinterpretq_u64_u8(vdupq_lane_u8(mask_cmp, 0)), src_vec, dst_vec);\n\n        // Store the result back to the destination array\n        vst1q_s64(dst + i, result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; ++i) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n\n    // Process 2 elements at a time using NEON intrinsics\n    for (; i + 1 < length; i += 2) {\n        // Load 2 mask values\n        uint8x8_t mask_vec = vld1_u8((const uint8_t*)(mask + i));\n\n        // Create a mask for 64-bit elements\n        uint64x2_t mask_64 = vmovl_u32(vget_low_u32(vmovl_u16(vget_low_u16(vmovl_u8(mask_vec)))));\n\n        // Load 2 src and dst elements\n        int64x2_t src_vec = vld1q_s64(src + i);\n        int64x2_t dst_vec = vld1q_s64(dst + i);\n\n        // Conditionally select elements based on the mask\n        int64x2_t result = vbslq_s64(vreinterpretq_u64_u8(vshrq_n_u8(vreinterpretq_u8_u64(mask_64), 7)), src_vec, dst_vec);\n\n        // Store the result back to dst\n        vst1q_s64(dst + i, result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; ++i) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_1_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    int32x4_t vscale = vdupq_n_s32(scale);\n    int32x4_t vseven = vdupq_n_s32(7);\n    int32x4_t vthree = vdupq_n_s32(3);\n\n    for (size_t i = 0; i + 4 <= length; i += 4) {\n        // Load 4 elements from src\n        int32x4_t vsrc = vld1q_s32(&src[i]);\n\n        // Compute element * scale\n        int32x4_t vmul = vmulq_s32(vsrc, vscale);\n\n        // Calculate tmp1: (element * scale) >> 3\n        int32x4_t vtmp1 = vshrq_n_s32(vmul, 3);\n\n        // Calculate tmp2: (element * scale) << 3\n        int32x4_t vtmp2 = vshlq_s32(vmul, vthree);\n\n        // Compute tmp1 * tmp2\n        int32x4_t vtmp1_tmp2 = vmulq_s32(vtmp1, vtmp2);\n\n        // Compute final result: (element * scale + tmp1 * tmp2) / 7\n        int32x4_t vresult = vaddq_s32(vmul, vtmp1_tmp2);\n        vresult = vdivq_s32(vresult, vseven);\n\n        // Store the result into dst\n        vst1q_s32(&dst[i], vresult);\n    }\n\n    // Handle remaining elements\n    for (size_t i = length - (length % 4); i < length; ++i) {\n        int tmp1 = (src[i] * scale) >> 3;\n        int tmp2 = (src[i] * scale) << 3;\n        dst[i] = (src[i] * scale + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    int32x4_t vscale = vdupq_n_s32(scale);\n    int32x4_t vseven = vdupq_n_s32(7);\n\n    for (size_t i = 0; i + 4 <= length; i += 4) {\n        // Load 4 elements from src\n        int32x4_t vsrc = vld1q_s32(&src[i]);\n\n        // Compute element * scale\n        int32x4_t vmul = vmulq_s32(vsrc, vscale);\n\n        // Calculate tmp1: (element * scale) >> 3\n        int32x4_t vtmp1 = vshrq_n_s32(vmul, 3);\n\n        // Calculate tmp2: (element * scale) << 3\n        int32x4_t vtmp2 = vshlq_n_s32(vmul, 3);\n\n        // Compute tmp1 * tmp2\n        int32x4_t vtmp1_tmp2 = vmulq_s32(vtmp1, vtmp2);\n\n        // Compute final result: (element * scale + tmp1 * tmp2) / 7\n        int32x4_t vresult = vaddq_s32(vmul, vtmp1_tmp2);\n        vresult = vdivq_s32(vresult, vseven);\n\n        // Store the result into dst\n        vst1q_s32(&dst[i], vresult);\n    }\n\n    // Handle remaining elements\n    for (size_t i = length - (length % 4); i < length; ++i) {\n        int tmp1 = (src[i] * scale) >> 3;\n        int tmp2 = (src[i] * scale) << 3;\n        dst[i] = (src[i] * scale + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    int32x4_t v_scale = vdupq_n_s32(scale);\n    int32x4_t v_divisor = vdupq_n_s32(7);\n\n    for (size_t i = 0; i + 4 <= length; i += 4) {\n        // Load 4 elements from src\n        int32x4_t v_src = vld1q_s32(&src[i]);\n\n        // Compute tmp1: (element * scale) >> 3\n        int32x4_t v_tmp1 = vshrq_n_s32(vmulq_s32(v_src, v_scale), 3);\n\n        // Compute tmp2: (element * scale) << 3\n        int32x4_t v_tmp2 = vshlq_n_s32(vmulq_s32(v_src, v_scale), 3);\n\n        // Compute final result: (element * scale + tmp1 * tmp2) / 7\n        int32x4_t v_result = vaddq_s32(vmulq_s32(v_src, v_scale), vmulq_s32(v_tmp1, v_tmp2));\n        v_result = vdivq_s32(v_result, v_divisor);\n\n        // Store the result into dst\n        vst1q_s32(&dst[i], v_result);\n    }\n\n    // Handle remaining elements\n    for (size_t i = length - (length % 4); i < length; ++i) {\n        int tmp1 = (src[i] * scale) >> 3;\n        int tmp2 = (src[i] * scale) << 3;\n        dst[i] = (src[i] * scale + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    int32x4_t vscale = vdupq_n_s32(scale);\n    int32x4_t vseven = vdupq_n_s32(7);\n\n    for (size_t i = 0; i + 4 <= length; i += 4) {\n        // Load 4 elements from src\n        int32x4_t vsrc = vld1q_s32(&src[i]);\n\n        // Compute element * scale\n        int32x4_t vmul = vmulq_s32(vsrc, vscale);\n\n        // Calculate tmp1: (element * scale) >> 3\n        int32x4_t vtmp1 = vshrq_n_s32(vmul, 3);\n\n        // Calculate tmp2: (element * scale) << 3\n        int32x4_t vtmp2 = vshlq_n_s32(vmul, 3);\n\n        // Compute tmp1 * tmp2\n        int32x4_t vtmp1_tmp2 = vmulq_s32(vtmp1, vtmp2);\n\n        // Compute final result: (element * scale + tmp1 * tmp2) / 7\n        int32x4_t vresult = vaddq_s32(vmul, vtmp1_tmp2);\n        vresult = vdivq_s32(vresult, vseven);\n\n        // Store the result into dst\n        vst1q_s32(&dst[i], vresult);\n    }\n\n    // Handle remaining elements\n    for (size_t i = length - (length % 4); i < length; ++i) {\n        int tmp1 = (src[i] * scale) >> 3;\n        int tmp2 = (src[i] * scale) << 3;\n        dst[i] = (src[i] * scale + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    int32x4_t vscale = vdupq_n_s32(scale);\n    int32x4_t vseven = vdupq_n_s32(7);\n\n    for (size_t i = 0; i + 4 <= length; i += 4) {\n        // Load 4 elements from src\n        int32x4_t vsrc = vld1q_s32(&src[i]);\n\n        // Compute element * scale\n        int32x4_t vmul = vmulq_s32(vsrc, vscale);\n\n        // Compute tmp1: (element * scale) >> 3\n        int32x4_t vtmp1 = vshrq_n_s32(vmul, 3);\n\n        // Compute tmp2: (element * scale) << 3\n        int32x4_t vtmp2 = vshlq_n_s32(vmul, 3);\n\n        // Compute tmp1 * tmp2\n        int32x4_t vtmp1tmp2 = vmulq_s32(vtmp1, vtmp2);\n\n        // Compute final result: (element * scale + tmp1 * tmp2) / 7\n        int32x4_t vresult = vaddq_s32(vmul, vtmp1tmp2);\n        vresult = vdivq_s32(vresult, vseven);\n\n        // Store the result into dst\n        vst1q_s32(&dst[i], vresult);\n    }\n\n    // Handle remaining elements\n    for (size_t i = length - (length % 4); i < length; ++i) {\n        int tmp1 = (src[i] * scale) >> 3;\n        int tmp2 = (src[i] * scale) << 3;\n        dst[i] = (src[i] * scale + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_2_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; r++) {\n        // Calculate the index for the source array\n        size_t src_idx = r * cols + stride;\n\n        // Load a single double from the source array\n        float64x1_t val = vld1_f64(&src[src_idx]);\n\n        // Store the loaded value into the destination array\n        vst1_f64(&dst[r], val);\n    }\n}\n```"}
{"task_id": "SimdBench_2_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; r++) {\n        // Calculate the index for the source array\n        size_t src_index = r * cols + stride;\n\n        // Load a single double from the source array\n        float64x1_t val = vld1_f64(&src[src_index]);\n\n        // Store the loaded value into the destination array\n        vst1_f64(&dst[r], val);\n    }\n}\n```"}
{"task_id": "SimdBench_2_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; r++) {\n        // Calculate the index for the source array\n        size_t src_index = r * cols + stride;\n\n        // Load a single double-precision floating-point value using Neon intrinsic\n        float64x1_t val = vld1_f64(&src[src_index]);\n\n        // Store the loaded value into the destination array\n        vst1_f64(&dst[r], val);\n    }\n}\n```"}
{"task_id": "SimdBench_2_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; r++) {\n        // Calculate the index for the source array\n        size_t src_idx = r * cols + stride;\n\n        // Load a single double from the source array\n        float64x1_t val = vld1_f64(&src[src_idx]);\n\n        // Store the loaded value into the destination array\n        vst1_f64(&dst[r], val);\n    }\n}\n```"}
{"task_id": "SimdBench_2_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; r++) {\n        // Calculate the index for the source array\n        size_t src_idx = r * cols + stride;\n\n        // Load a single double-precision value from the source array\n        float64x1_t val = vld1_f64(&src[src_idx]);\n\n        // Store the loaded value into the destination array at position r\n        vst1_f64(&dst[r], val);\n    }\n}\n```"}
{"task_id": "SimdBench_3_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n\n    // Gather operation using Neon intrinsics\n    for (; i <= length - 4; i += 4) {\n        // Load 4 indices\n        int32x4_t idx_vec = vld1q_s32(indices + i);\n\n        // Use tbl instruction to gather values from src\n        float32x4_t gathered = vld1q_f32(src + vgetq_lane_s32(idx_vec, 0));\n        gathered = vsetq_lane_f32(src[vgetq_lane_s32(idx_vec, 1)], gathered, 1);\n        gathered = vsetq_lane_f32(src[vgetq_lane_s32(idx_vec, 2)], gathered, 2);\n        gathered = vsetq_lane_f32(src[vgetq_lane_s32(idx_vec, 3)], gathered, 3);\n\n        // Store the gathered values into dst\n        vst1q_f32(dst + i, gathered);\n    }\n\n    // Handle remaining elements for gather\n    for (; i < length; ++i) {\n        dst[i] = src[indices[i]];\n    }\n\n    // Scatter operation\n    i = 0;\n    for (; i <= length - 4; i += 4) {\n        // Load 4 indices\n        int32x4_t idx_vec = vld1q_s32(indices + i);\n\n        // Load 4 values from src\n        float32x4_t src_vec = vld1q_f32(src + i);\n\n        // Scatter values into dst using indices\n        dst[vgetq_lane_s32(idx_vec, 0)] = vgetq_lane_f32(src_vec, 0);\n        dst[vgetq_lane_s32(idx_vec, 1)] = vgetq_lane_f32(src_vec, 1);\n        dst[vgetq_lane_s32(idx_vec, 2)] = vgetq_lane_f32(src_vec, 2);\n        dst[vgetq_lane_s32(idx_vec, 3)] = vgetq_lane_f32(src_vec, 3);\n    }\n\n    // Handle remaining elements for scatter\n    for (; i < length; ++i) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n\n    // Gather operation using Neon intrinsics\n    for (; i <= length - 4; i += 4) {\n        // Load 4 indices\n        int32x4_t idx_vec = vld1q_s32(indices + i);\n\n        // Use tbl instruction to gather values from src\n        float32x4_t gathered = vld1q_f32(src + vgetq_lane_s32(idx_vec, 0));\n        gathered = vsetq_lane_f32(src[vgetq_lane_s32(idx_vec, 1)], gathered, 1);\n        gathered = vsetq_lane_f32(src[vgetq_lane_s32(idx_vec, 2)], gathered, 2);\n        gathered = vsetq_lane_f32(src[vgetq_lane_s32(idx_vec, 3)], gathered, 3);\n\n        // Store the gathered values into dst\n        vst1q_f32(dst + i, gathered);\n    }\n\n    // Handle remaining elements for gather\n    for (; i < length; ++i) {\n        dst[i] = src[indices[i]];\n    }\n\n    // Scatter operation\n    i = 0;\n    for (; i <= length - 4; i += 4) {\n        // Load 4 indices\n        int32x4_t idx_vec = vld1q_s32(indices + i);\n\n        // Load 4 values from src\n        float32x4_t src_vec = vld1q_f32(src + i);\n\n        // Scatter values into dst using indices\n        dst[vgetq_lane_s32(idx_vec, 0)] = vgetq_lane_f32(src_vec, 0);\n        dst[vgetq_lane_s32(idx_vec, 1)] = vgetq_lane_f32(src_vec, 1);\n        dst[vgetq_lane_s32(idx_vec, 2)] = vgetq_lane_f32(src_vec, 2);\n        dst[vgetq_lane_s32(idx_vec, 3)] = vgetq_lane_f32(src_vec, 3);\n    }\n\n    // Handle remaining elements for scatter\n    for (; i < length; ++i) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n\n    // Gather operation using Neon intrinsics\n    for (; i <= length - 4; i += 4) {\n        // Load 4 indices\n        int32x4_t idx_vec = vld1q_s32(indices + i);\n\n        // Use tbl instruction to gather elements from src\n        float32x4_t gathered = vld1q_f32(src + vgetq_lane_s32(idx_vec, 0));\n        gathered = vsetq_lane_f32(src[vgetq_lane_s32(idx_vec, 1)], gathered, 1);\n        gathered = vsetq_lane_f32(src[vgetq_lane_s32(idx_vec, 2)], gathered, 2);\n        gathered = vsetq_lane_f32(src[vgetq_lane_s32(idx_vec, 3)], gathered, 3);\n\n        // Store gathered values into dst\n        vst1q_f32(dst + i, gathered);\n    }\n\n    // Handle remaining elements for gather\n    for (; i < length; ++i) {\n        dst[i] = src[indices[i]];\n    }\n\n    // Scatter operation\n    i = 0;\n    for (; i <= length - 4; i += 4) {\n        // Load 4 indices\n        int32x4_t idx_vec = vld1q_s32(indices + i);\n\n        // Load 4 source values\n        float32x4_t src_vec = vld1q_f32(src + i);\n\n        // Scatter values into dst using indices\n        dst[vgetq_lane_s32(idx_vec, 0)] = vgetq_lane_f32(src_vec, 0);\n        dst[vgetq_lane_s32(idx_vec, 1)] = vgetq_lane_f32(src_vec, 1);\n        dst[vgetq_lane_s32(idx_vec, 2)] = vgetq_lane_f32(src_vec, 2);\n        dst[vgetq_lane_s32(idx_vec, 3)] = vgetq_lane_f32(src_vec, 3);\n    }\n\n    // Handle remaining elements for scatter\n    for (; i < length; ++i) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n\n    // Gather operation using Neon intrinsics\n    for (; i <= length - 4; i += 4) {\n        // Load 4 indices\n        int32x4_t idx_vec = vld1q_s32(indices + i);\n\n        // Use tbl instruction to gather values from src\n        float32x4_t gathered = vld1q_f32(src + vgetq_lane_s32(idx_vec, 0));\n        gathered = vsetq_lane_f32(src[vgetq_lane_s32(idx_vec, 1)], gathered, 1);\n        gathered = vsetq_lane_f32(src[vgetq_lane_s32(idx_vec, 2)], gathered, 2);\n        gathered = vsetq_lane_f32(src[vgetq_lane_s32(idx_vec, 3)], gathered, 3);\n\n        // Store gathered values into dst\n        vst1q_f32(dst + i, gathered);\n    }\n\n    // Handle remaining elements for gather\n    for (; i < length; ++i) {\n        dst[i] = src[indices[i]];\n    }\n\n    // Scatter operation\n    i = 0;\n    for (; i <= length - 4; i += 4) {\n        // Load 4 indices\n        int32x4_t idx_vec = vld1q_s32(indices + i);\n\n        // Load 4 values from src\n        float32x4_t src_vec = vld1q_f32(src + i);\n\n        // Scatter values into dst using indices\n        dst[vgetq_lane_s32(idx_vec, 0)] = vgetq_lane_f32(src_vec, 0);\n        dst[vgetq_lane_s32(idx_vec, 1)] = vgetq_lane_f32(src_vec, 1);\n        dst[vgetq_lane_s32(idx_vec, 2)] = vgetq_lane_f32(src_vec, 2);\n        dst[vgetq_lane_s32(idx_vec, 3)] = vgetq_lane_f32(src_vec, 3);\n    }\n\n    // Handle remaining elements for scatter\n    for (; i < length; ++i) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n\n    // Gather operation using Neon intrinsics\n    for (; i <= length - 4; i += 4) {\n        // Load 4 indices\n        int32x4_t idx_vec = vld1q_s32(indices + i);\n\n        // Use tbl instruction to gather values from src\n        float32x4_t gathered = vld1q_f32(src + vgetq_lane_s32(idx_vec, 0));\n        gathered = vsetq_lane_f32(src[vgetq_lane_s32(idx_vec, 1)], gathered, 1);\n        gathered = vsetq_lane_f32(src[vgetq_lane_s32(idx_vec, 2)], gathered, 2);\n        gathered = vsetq_lane_f32(src[vgetq_lane_s32(idx_vec, 3)], gathered, 3);\n\n        // Store gathered values into dst\n        vst1q_f32(dst + i, gathered);\n    }\n\n    // Handle remaining elements for gather\n    for (; i < length; ++i) {\n        dst[i] = src[indices[i]];\n    }\n\n    // Scatter operation\n    i = 0;\n    for (; i <= length - 4; i += 4) {\n        // Load 4 indices\n        int32x4_t idx_vec = vld1q_s32(indices + i);\n\n        // Load 4 values from src\n        float32x4_t src_vec = vld1q_f32(src + i);\n\n        // Scatter values into dst using indices\n        dst[vgetq_lane_s32(idx_vec, 0)] = vgetq_lane_f32(src_vec, 0);\n        dst[vgetq_lane_s32(idx_vec, 1)] = vgetq_lane_f32(src_vec, 1);\n        dst[vgetq_lane_s32(idx_vec, 2)] = vgetq_lane_f32(src_vec, 2);\n        dst[vgetq_lane_s32(idx_vec, 3)] = vgetq_lane_f32(src_vec, 3);\n    }\n\n    // Handle remaining elements for scatter\n    for (; i < length; ++i) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_4_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t size = end - start + 1;\n    uint64_t vec_size = size / 8 * 8;\n\n    int16_t *start_ptr = arr + start;\n    int16_t *end_ptr = arr + end;\n\n    for (uint64_t i = 0; i < vec_size / 2; i += 8) {\n        int16x8_t front = vld1q_s16(start_ptr + i);\n        int16x8_t back = vld1q_s16(end_ptr - i - 7);\n\n        int16x8_t rev_front = vrev64q_s16(front);\n        int16x8_t rev_back = vrev64q_s16(back);\n\n        int16x8_t tmp = vextq_s16(rev_front, rev_front, 4);\n        rev_front = vextq_s16(rev_back, rev_back, 4);\n        rev_back = tmp;\n\n        vst1q_s16(start_ptr + i, rev_back);\n        vst1q_s16(end_ptr - i - 7, rev_front);\n    }\n\n    for (uint64_t i = vec_size; i < size / 2; ++i) {\n        int16_t temp = start_ptr[i];\n        start_ptr[i] = end_ptr[-i];\n        end_ptr[-i] = temp;\n    }\n}\n```"}
{"task_id": "SimdBench_4_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t len = end - start + 1;\n    uint64_t vec_len = len / 8 * 8;\n\n    int16_t *start_ptr = arr + start;\n    int16_t *end_ptr = arr + end;\n\n    for (uint64_t i = 0; i < vec_len / 2; i += 8) {\n        int16x8_t front = vld1q_s16(start_ptr + i);\n        int16x8_t back = vld1q_s16(end_ptr - i - 7);\n\n        int16x8_t rev_front = vrev64q_s16(front);\n        int16x8_t rev_back = vrev64q_s16(back);\n\n        int16x8_t tmp = vextq_s16(rev_front, rev_front, 4);\n        rev_front = vextq_s16(rev_back, rev_back, 4);\n        rev_back = tmp;\n\n        vst1q_s16(start_ptr + i, rev_back);\n        vst1q_s16(end_ptr - i - 7, rev_front);\n    }\n\n    for (uint64_t i = vec_len; i < len / 2; ++i) {\n        int16_t temp = start_ptr[i];\n        start_ptr[i] = end_ptr[-i];\n        end_ptr[-i] = temp;\n    }\n}\n```"}
{"task_id": "SimdBench_4_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t len = end - start + 1;\n    uint64_t vec_len = len / 8 * 8;\n\n    int16_t *start_ptr = arr + start;\n    int16_t *end_ptr = arr + end;\n\n    for (uint64_t i = 0; i < vec_len / 2; i += 8) {\n        int16x8_t front = vld1q_s16(start_ptr + i);\n        int16x8_t back = vld1q_s16(end_ptr - i - 7);\n\n        int16x8_t rev_front = vrev64q_s16(front);\n        int16x8_t rev_back = vrev64q_s16(back);\n\n        int16x8_t tmp = vextq_s16(rev_front, rev_front, 4);\n        rev_front = vextq_s16(rev_back, rev_back, 4);\n        rev_back = tmp;\n\n        vst1q_s16(start_ptr + i, rev_back);\n        vst1q_s16(end_ptr - i - 7, rev_front);\n    }\n\n    for (uint64_t i = vec_len; i < len / 2; ++i) {\n        int16_t temp = start_ptr[i];\n        start_ptr[i] = end_ptr[-i];\n        end_ptr[-i] = temp;\n    }\n}\n```"}
{"task_id": "SimdBench_4_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t len = end - start + 1;\n    uint64_t vec_len = len / 8 * 8;\n\n    int16_t *start_ptr = arr + start;\n    int16_t *end_ptr = arr + end;\n\n    for (uint64_t i = 0; i < vec_len / 2; i += 8) {\n        int16x8_t front = vld1q_s16(start_ptr + i);\n        int16x8_t back = vld1q_s16(end_ptr - i - 7);\n\n        int16x8_t rev_front = vrev64q_s16(front);\n        int16x8_t rev_back = vrev64q_s16(back);\n\n        int16x8_t tmp = vextq_s16(rev_front, rev_front, 4);\n        rev_front = vextq_s16(rev_back, rev_back, 4);\n        rev_back = tmp;\n\n        vst1q_s16(start_ptr + i, rev_back);\n        vst1q_s16(end_ptr - i - 7, rev_front);\n    }\n\n    for (uint64_t i = vec_len; i < len / 2; ++i) {\n        int16_t temp = start_ptr[i];\n        start_ptr[i] = end_ptr[-i];\n        end_ptr[-i] = temp;\n    }\n}\n```"}
{"task_id": "SimdBench_4_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t len = end - start + 1;\n    uint64_t vec_len = len / 8 * 8;\n\n    int16_t *start_ptr = arr + start;\n    int16_t *end_ptr = arr + end;\n\n    for (uint64_t i = 0; i < vec_len / 2; i += 8) {\n        int16x8_t front = vld1q_s16(start_ptr + i);\n        int16x8_t back = vld1q_s16(end_ptr - i - 7);\n\n        int16x8_t rev_front = vrev64q_s16(front);\n        int16x8_t rev_back = vrev64q_s16(back);\n\n        int16x8_t tmp = vextq_s16(rev_front, rev_front, 4);\n        rev_front = vextq_s16(rev_back, rev_back, 4);\n        rev_back = tmp;\n\n        vst1q_s16(start_ptr + i, rev_back);\n        vst1q_s16(end_ptr - i - 7, rev_front);\n    }\n\n    for (uint64_t i = vec_len; i < len / 2; ++i) {\n        int16_t temp = start_ptr[i];\n        start_ptr[i] = end_ptr[-i];\n        end_ptr[-i] = temp;\n    }\n}\n```"}
{"task_id": "SimdBench_5_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_offset = slice_idx * dim1 * dim2;\n    size_t total_elements = dim1 * dim2;\n\n    for (size_t i = 0; i < total_elements; i += 16) {\n        uint8x16_t vec = vld1q_u8(tensor + slice_offset + i);\n        vst1q_u8(slice + i, vec);\n    }\n}\n```"}
{"task_id": "SimdBench_5_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_offset = slice_idx * dim1 * dim2;\n    size_t total_elements = dim1 * dim2;\n\n    for (size_t i = 0; i < total_elements; i += 16) {\n        uint8x16_t vec = vld1q_u8(tensor + slice_offset + i);\n        vst1q_u8(slice + i, vec);\n    }\n}\n```"}
{"task_id": "SimdBench_5_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_offset = slice_idx * dim1 * dim2;\n    size_t total_elements = dim1 * dim2;\n\n    for (size_t i = 0; i < total_elements; i += 16) {\n        // Load 16 elements from the source tensor at the computed offset\n        uint8x16_t vec = vld1q_u8(tensor + slice_offset + i);\n\n        // Store the 16 elements into the destination slice\n        vst1q_u8(slice + i, vec);\n    }\n}\n```"}
{"task_id": "SimdBench_5_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_offset = slice_idx * dim1 * dim2;\n    size_t total_elements = dim1 * dim2;\n\n    for (size_t i = 0; i < total_elements; i += 16) {\n        uint8x16_t vec = vld1q_u8(tensor + slice_offset + i);\n        vst1q_u8(slice + i, vec);\n    }\n}\n```"}
{"task_id": "SimdBench_5_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t row_stride = dim2 * dim3;\n    size_t slice_offset = slice_idx * dim2;\n\n    for (size_t i = 0; i < dim1; ++i) {\n        const uint8_t *row_start = tensor + i * row_stride + slice_offset;\n        uint8_t *slice_row_start = slice + i * dim2;\n\n        size_t j = 0;\n        for (; j + 16 <= dim2; j += 16) {\n            uint8x16_t vec = vld1q_u8(row_start + j);\n            vst1q_u8(slice_row_start + j, vec);\n        }\n        for (; j < dim2; ++j) {\n            slice_row_start[j] = row_start[j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t block_rows = (i + block_size > rows) ? (rows - i) : block_size;\n            size_t block_cols = (j + block_size > cols) ? (cols - j) : block_size;\n\n            for (size_t bi = 0; bi < block_rows; ++bi) {\n                for (size_t bj = 0; bj < block_cols; bj += 8) {\n                    size_t src_idx = (i + bi) * cols + (j + bj);\n                    size_t dst_idx = (j + bj) * rows + (i + bi);\n\n                    int16x8_t vec = vld1q_s16(&src[src_idx]);\n                    vst1q_s16(&dst[dst_idx], vec);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t row_limit = (i + block_size > rows) ? rows : i + block_size;\n            size_t col_limit = (j + block_size > cols) ? cols : j + block_size;\n\n            for (size_t ii = i; ii < row_limit; ++ii) {\n                for (size_t jj = j; jj < col_limit; jj += 8) {\n                    // Load 8 elements from the source matrix\n                    int16x8_t vec = vld1q_s16(&src[ii * cols + jj]);\n\n                    // Store the transposed elements into the destination matrix\n                    int16_t tmp[8];\n                    vst1q_s16(tmp, vec);\n                    for (int k = 0; k < 8 && jj + k < col_limit; ++k) {\n                        dst[(jj + k) * rows + ii] = tmp[k];\n                    }\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t block_rows = (i + block_size > rows) ? (rows - i) : block_size;\n            size_t block_cols = (j + block_size > cols) ? (cols - j) : block_size;\n\n            for (size_t bi = 0; bi < block_rows; ++bi) {\n                for (size_t bj = 0; bj < block_cols; bj += 8) {\n                    size_t src_idx = (i + bi) * cols + (j + bj);\n                    size_t dst_idx = (j + bj) * rows + (i + bi);\n\n                    int16x8_t vec = vld1q_s16(&src[src_idx]);\n                    vst1q_s16(&dst[dst_idx], vec);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t block_rows = (i + block_size > rows) ? (rows - i) : block_size;\n            size_t block_cols = (j + block_size > cols) ? (cols - j) : block_size;\n\n            for (size_t bi = 0; bi < block_rows; ++bi) {\n                for (size_t bj = 0; bj < block_cols; bj += 8) {\n                    size_t src_idx = (i + bi) * cols + (j + bj);\n                    size_t dst_idx = (j + bj) * rows + (i + bi);\n\n                    int16x8_t vec = vld1q_s16(&src[src_idx]);\n                    vst1q_s16(&dst[dst_idx], vec);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t block_rows = (i + block_size > rows) ? (rows - i) : block_size;\n            size_t block_cols = (j + block_size > cols) ? (cols - j) : block_size;\n\n            for (size_t bi = 0; bi < block_rows; ++bi) {\n                for (size_t bj = 0; bj < block_cols; bj += 8) {\n                    size_t src_idx = (i + bi) * cols + (j + bj);\n                    size_t dst_idx = (j + bj) * rows + (i + bi);\n\n                    int16x8_t vec = vld1q_s16(&src[src_idx]);\n                    vst1q_s16(&dst[dst_idx], vec);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_7_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    float32x4_t vsum = vdupq_n_f32(0.0f);\n\n    size_t i = 0;\n    size_t simd_length = dim / 4 * 4;\n\n    for (; i < simd_length; i += 4) {\n        // Load 4 elements at once\n        float32x4_t vdiag = vld1q_f32(&array[i * dim * dim + i * dim + i]);\n        // Accumulate the sum\n        vsum = vaddq_f32(vsum, vdiag);\n    }\n\n    // Horizontal sum of the SIMD register\n    float temp[4];\n    vst1q_f32(temp, vsum);\n    sum += temp[0] + temp[1] + temp[2] + temp[3];\n\n    // Handle remaining elements\n    for (; i < dim; ++i) {\n        sum += array[i * dim * dim + i * dim + i];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    float32x4_t vsum = vdupq_n_f32(0.0f);\n\n    size_t i = 0;\n    size_t simd_end = (dim / 4) * 4;\n\n    for (; i < simd_end; i += 4) {\n        // Load 4 elements at once where indices are equal in 3D space\n        float32x4_t vdiag = vld1q_f32(&array[i * dim * dim + i * dim + i]);\n        // Accumulate the loaded elements into the vector sum\n        vsum = vaddq_f32(vsum, vdiag);\n    }\n\n    // Horizontal sum of the accumulated SIMD register\n    float temp[4];\n    vst1q_f32(temp, vsum);\n    sum += temp[0] + temp[1] + temp[2] + temp[3];\n\n    // Handle remaining elements that don't fit into a full SIMD register\n    for (; i < dim; ++i) {\n        sum += array[i * dim * dim + i * dim + i];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    float32x4_t vsum = vdupq_n_f32(0.0f);\n\n    size_t i = 0;\n    size_t limit = dim - (dim % 4);\n\n    for (; i < limit; i += 4) {\n        // Calculate the indices for the diagonal elements in blocks of 4\n        size_t idx0 = i * dim * dim + i * dim + i;\n        size_t idx1 = (i + 1) * dim * dim + (i + 1) * dim + (i + 1);\n        size_t idx2 = (i + 2) * dim * dim + (i + 2) * dim + (i + 2);\n        size_t idx3 = (i + 3) * dim * dim + (i + 3) * dim + (i + 3);\n\n        // Load the diagonal elements into a vector\n        float32x4_t vdiag = vld1q_f32(&array[idx0]);\n\n        // Accumulate the sum using SIMD\n        vsum = vaddq_f32(vsum, vdiag);\n    }\n\n    // Horizontal sum of the SIMD register\n    float temp[4];\n    vst1q_f32(temp, vsum);\n    sum += temp[0] + temp[1] + temp[2] + temp[3];\n\n    // Handle remaining elements\n    for (; i < dim; ++i) {\n        size_t idx = i * dim * dim + i * dim + i;\n        sum += array[idx];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    float32x4_t vsum = vdupq_n_f32(0.0f);\n\n    size_t i = 0;\n    size_t simd_size = dim / 4 * 4;\n\n    for (; i < simd_size; i += 4) {\n        // Load 4 elements at once where indices are equal (i, i, i)\n        float32x4_t vdiag = vld1q_f32(&array[i * dim * dim + i * dim + i]);\n        // Accumulate the loaded elements into the vector sum\n        vsum = vaddq_f32(vsum, vdiag);\n    }\n\n    // Horizontal sum of the accumulated vector\n    float32x2_t vsum_low = vget_low_f32(vsum);\n    float32x2_t vsum_high = vget_high_f32(vsum);\n    vsum_low = vpadd_f32(vsum_low, vsum_high);\n    sum += vget_lane_f32(vsum_low, 0) + vget_lane_f32(vsum_low, 1);\n\n    // Handle remaining elements that don't fit in the SIMD loop\n    for (; i < dim; ++i) {\n        sum += array[i * dim * dim + i * dim + i];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 3 < dim; i += 4) {\n        // Load 4 diagonal elements into a NEON register\n        float32x4_t diag_elements = vld1q_f32(&array[i * dim * dim + i * dim + i]);\n\n        // Sum the elements in the NEON register horizontally\n        float32x2_t sum_partial = vadd_f32(vget_low_f32(diag_elements), vget_high_f32(diag_elements));\n        sum_partial = vpadd_f32(sum_partial, sum_partial);\n\n        // Add the result to the scalar sum\n        sum += vget_lane_f32(sum_partial, 0);\n    }\n\n    // Process remaining elements (if dim is not a multiple of 4)\n    for (; i < dim; ++i) {\n        sum += array[i * dim * dim + i * dim + i];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_8_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    float64x2_t v_threshold = vmovq_n_f64(threshold);\n    float64x2_t v_scale = vmovq_n_f64(scale);\n\n    for (size_t i = 0; i < rows; ++i) {\n        size_t j = 0;\n\n        // Process two elements at a time using Neon intrinsics\n        for (; j + 1 < cols; j += 2) {\n            float64x2_t v_src = vld1q_f64(&src[i * cols + j]);\n            uint64x2_t v_cmp = vcgtq_f64(v_src, v_threshold);\n            float64x2_t v_scaled = vmulq_f64(v_src, v_scale);\n            float64x2_t v_result = vbslq_f64(v_cmp, v_scaled, v_src);\n            vst1q_f64(&dst[i * cols + j], v_result);\n        }\n\n        // Handle remaining elements (if any)\n        for (; j < cols; ++j) {\n            if (src[i * cols + j] > threshold) {\n                dst[i * cols + j] = src[i * cols + j] * scale;\n            } else {\n                dst[i * cols + j] = src[i * cols + j];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    float64x2_t v_threshold = vmovq_n_f64(threshold);\n    float64x2_t v_scale = vmovq_n_f64(scale);\n\n    for (size_t i = 0; i < rows; ++i) {\n        size_t j = 0;\n\n        // Process two elements at a time using Neon intrinsics\n        for (; j <= cols - 2; j += 2) {\n            float64x2_t v_src = vld1q_f64(&src[i * cols + j]);\n            uint64x2_t v_cmp = vcgtq_f64(v_src, v_threshold);\n            float64x2_t v_scaled = vmulq_f64(v_src, v_scale);\n            float64x2_t v_result = vbslq_f64(v_cmp, v_scaled, v_src);\n            vst1q_f64(&dst[i * cols + j], v_result);\n        }\n\n        // Handle remaining elements (if any)\n        for (; j < cols; ++j) {\n            if (src[i * cols + j] > threshold) {\n                dst[i * cols + j] = src[i * cols + j] * scale;\n            } else {\n                dst[i * cols + j] = src[i * cols + j];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    float64x2_t v_threshold = vmovq_n_f64(threshold);\n    float64x2_t v_scale = vmovq_n_f64(scale);\n\n    for (size_t i = 0; i < rows; ++i) {\n        size_t j = 0;\n\n        // Process two elements at a time using Neon intrinsics\n        for (; j <= cols - 2; j += 2) {\n            float64x2_t v_src = vld1q_f64(&src[i * cols + j]);\n            uint64x2_t mask = vcgtq_f64(v_src, v_threshold);\n            float64x2_t v_scaled = vmulq_f64(v_src, v_scale);\n            float64x2_t v_result = vbslq_f64(mask, v_scaled, v_src);\n            vst1q_f64(&dst[i * cols + j], v_result);\n        }\n\n        // Handle remaining elements (if any)\n        for (; j < cols; ++j) {\n            double value = src[i * cols + j];\n            dst[i * cols + j] = (value > threshold) ? value * scale : value;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    float64x2_t v_threshold = vmovq_n_f64(threshold);\n    float64x2_t v_scale = vmovq_n_f64(scale);\n\n    for (size_t i = 0; i < rows; ++i) {\n        size_t j = 0;\n\n        // Process two elements at a time using Neon intrinsics\n        for (; j <= cols - 2; j += 2) {\n            float64x2_t v_src = vld1q_f64(&src[i * cols + j]);\n            uint64x2_t v_cmp = vcgtq_f64(v_src, v_threshold);\n            float64x2_t v_scaled = vmulq_f64(v_src, v_scale);\n            float64x2_t v_result = vbslq_f64(v_cmp, v_scaled, v_src);\n            vst1q_f64(&dst[i * cols + j], v_result);\n        }\n\n        // Handle remaining elements (if any)\n        for (; j < cols; ++j) {\n            if (src[i * cols + j] > threshold) {\n                dst[i * cols + j] = src[i * cols + j] * scale;\n            } else {\n                dst[i * cols + j] = src[i * cols + j];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    float64x2_t v_threshold = vmovq_n_f64(threshold);\n    float64x2_t v_scale = vmovq_n_f64(scale);\n\n    for (size_t i = 0; i < rows; ++i) {\n        size_t j = 0;\n\n        // Process two elements at a time using Neon intrinsics\n        for (; j + 1 < cols; j += 2) {\n            float64x2_t v_src = vld1q_f64(&src[i * cols + j]);\n            uint64x2_t mask = vcgtq_f64(v_src, v_threshold);\n            float64x2_t v_scaled = vmulq_f64(v_src, v_scale);\n            float64x2_t v_result = vbslq_f64(mask, v_scaled, v_src);\n            vst1q_f64(&dst[i * cols + j], v_result);\n        }\n\n        // Handle remaining elements (if any)\n        for (; j < cols; ++j) {\n            double value = src[i * cols + j];\n            dst[i * cols + j] = (value > threshold) ? value * scale : value;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; ++i) {\n        size_t idx = indices[i];\n        const double *src_row = src + idx * cols;\n        double *dst_row = dst + i * cols;\n\n        size_t j = 0;\n        // Process 2 doubles at a time using Neon intrinsics\n        for (; j + 1 < cols; j += 2) {\n            float64x2_t vec = vld1q_f64(src_row + j);\n            vst1q_f64(dst_row + j, vec);\n        }\n\n        // Handle remaining elements (if cols is odd)\n        for (; j < cols; ++j) {\n            dst_row[j] = src_row[j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; ++i) {\n        size_t src_row_idx = indices[i] * cols;\n        size_t dst_row_idx = i * cols;\n\n        size_t j = 0;\n        // Process 2 doubles at a time using Neon intrinsics\n        for (; j + 1 < cols; j += 2) {\n            float64x2_t vec = vld1q_f64(&src[src_row_idx + j]);\n            vst1q_f64(&dst[dst_row_idx + j], vec);\n        }\n\n        // Handle remaining elements (if cols is odd)\n        for (; j < cols; ++j) {\n            dst[dst_row_idx + j] = src[src_row_idx + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; ++i) {\n        size_t idx = indices[i];\n        const double *src_row = src + idx * cols;\n        double *dst_row = dst + i * cols;\n\n        size_t j = 0;\n        // Process 2 doubles at a time using Neon intrinsics\n        for (; j + 1 < cols; j += 2) {\n            float64x2_t vec = vld1q_f64(src_row + j);\n            vst1q_f64(dst_row + j, vec);\n        }\n\n        // Handle remaining elements (if cols is odd)\n        for (; j < cols; ++j) {\n            dst_row[j] = src_row[j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; ++i) {\n        size_t idx = indices[i];\n        const double *src_row = src + idx * cols;\n        double *dst_row = dst + i * cols;\n\n        size_t j = 0;\n        // Process 2 doubles at a time using Neon intrinsics\n        for (; j <= cols - 2; j += 2) {\n            float64x2_t vec = vld1q_f64(src_row + j);\n            vst1q_f64(dst_row + j, vec);\n        }\n\n        // Handle remaining elements\n        for (; j < cols; ++j) {\n            dst_row[j] = src_row[j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; ++i) {\n        size_t idx = indices[i];\n        const double *src_row = src + idx * cols;\n        double *dst_row = dst + i * cols;\n\n        size_t j = 0;\n        for (; j + 2 <= cols; j += 2) {\n            float64x2_t vec = vld1q_f64(src_row + j);\n            vst1q_f64(dst_row + j, vec);\n        }\n\n        for (; j < cols; ++j) {\n            dst_row[j] = src_row[j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_10_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    int64x2_t v_scalar = vdupq_n_s64(scalar);\n\n    for (; i + 2 <= length; i += 2) {\n        int64x2_t v_src1 = vld1q_s64(&src1[i]);\n        int64x2_t v_src2 = vld1q_s64(&src2[i]);\n\n        int64x2_t v_res = vaddq_s64(v_src1, v_src2);\n        v_res = vaddq_s64(v_res, v_scalar);\n        v_res = vrshrq_n_s64(v_res, 1);\n\n        vst1q_s64(&dst[i], v_res);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n\n    // Broadcast the scalar value into a vector\n    int64x2_t scalar_vec = vdupq_n_s64(scalar);\n\n    // Process two elements at a time using NEON intrinsics\n    for (; i + 1 < length; i += 2) {\n        // Load two 64-bit integers from src1 and src2\n        int64x2_t vec1 = vld1q_s64(&src1[i]);\n        int64x2_t vec2 = vld1q_s64(&src2[i]);\n\n        // Add the vectors element-wise\n        int64x2_t result = vaddq_s64(vec1, vec2);\n\n        // Add the scalar to each element of the result\n        result = vaddq_s64(result, scalar_vec);\n\n        // Divide by 2 (round toward zero)\n        result = vrshrq_n_s64(result, 1);\n\n        // Store the result into the destination array\n        vst1q_s64(&dst[i], result);\n    }\n\n    // Handle any remaining elements that don't fit into the SIMD processing\n    for (; i < length; ++i) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    int64x2_t v_scalar = vdupq_n_s64(scalar);\n    int64x2_t v_two = vdupq_n_s64(2);\n\n    for (; i + 2 <= length; i += 2) {\n        int64x2_t v_src1 = vld1q_s64(&src1[i]);\n        int64x2_t v_src2 = vld1q_s64(&src2[i]);\n\n        int64x2_t v_sum = vaddq_s64(v_src1, v_src2);\n        v_sum = vaddq_s64(v_sum, v_scalar);\n\n        int64x2_t v_result = vrshrq_n_s64(v_sum, 1); // Divide by 2 with round-toward-zero semantics\n        vst1q_s64(&dst[i], v_result);\n    }\n\n    for (; i < length; ++i) {\n        int64_t sum = src1[i] + src2[i] + scalar;\n        dst[i] = sum / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    int64x2_t v_scalar = vdupq_n_s64(scalar);\n\n    for (; i + 2 <= length; i += 2) {\n        // Load 2 elements from src1 and src2\n        int64x2_t v_src1 = vld1q_s64(&src1[i]);\n        int64x2_t v_src2 = vld1q_s64(&src2[i]);\n\n        // Perform element-wise addition of src1 and src2\n        int64x2_t v_sum = vaddq_s64(v_src1, v_src2);\n\n        // Add the scalar value to each element\n        v_sum = vaddq_s64(v_sum, v_scalar);\n\n        // Divide by 2 (round toward zero)\n        int64x2_t v_result = vrshrq_n_s64(v_sum, 1);\n\n        // Store the result into dst\n        vst1q_s64(&dst[i], v_result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; ++i) {\n        int64_t sum = src1[i] + src2[i] + scalar;\n        dst[i] = sum / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n\n    // Broadcast the scalar value into a vector\n    int64x2_t scalar_vec = vdupq_n_s64(scalar);\n\n    // Process two elements at a time using NEON intrinsics\n    for (; i + 1 < length; i += 2) {\n        // Load two elements from src1 and src2\n        int64x2_t vec1 = vld1q_s64(&src1[i]);\n        int64x2_t vec2 = vld1q_s64(&src2[i]);\n\n        // Perform element-wise addition of vec1 and vec2\n        int64x2_t result = vaddq_s64(vec1, vec2);\n\n        // Add the scalar value to each element of the result\n        result = vaddq_s64(result, scalar_vec);\n\n        // Divide the result by 2 (round toward zero)\n        result = vrshrq_n_s64(result, 1);\n\n        // Store the result into the destination array\n        vst1q_s64(&dst[i], result);\n    }\n\n    // Handle any remaining elements that do not fit into the SIMD vector\n    for (; i < length; ++i) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_11_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    int min_val = INT32_MAX;\n    size_t i = 0;\n\n    // Process elements in chunks of 4 using NEON intrinsics\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 elements from the source array\n        int32x4_t vec = vld1q_s32(&src[i]);\n\n        // Create a mask to select even indices (0, 2)\n        uint32x4_t mask = {0xFFFFFFFF, 0, 0xFFFFFFFF, 0};\n        int32x4_t masked_vec = vandq_s32(vec, vreinterpretq_s32_u32(mask));\n\n        // Find the minimum value in the masked vector\n        int32x2_t min_pair = vpmin_s32(vget_low_s32(masked_vec), vget_high_s32(masked_vec));\n        int32x2_t min_single = vpmin_s32(min_pair, min_pair);\n        int min_current = vget_lane_s32(min_single, 0);\n\n        // Update the global minimum\n        if (min_current < min_val && min_current != 0) {\n            min_val = min_current;\n        }\n    }\n\n    // Process remaining elements (if any)\n    for (; i < length; ++i) {\n        if (i % 2 == 0 && src[i] < min_val) {\n            min_val = src[i];\n        }\n    }\n\n    return (min_val == INT32_MAX) ? -1 : min_val;\n}\n```"}
{"task_id": "SimdBench_11_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    int min_val = INT32_MAX;\n    size_t i = 0;\n\n    // Process elements in chunks of 4 using NEON intrinsics\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 elements from the source array\n        int32x4_t vec = vld1q_s32(&src[i]);\n\n        // Create a mask to select even indices (0, 2)\n        uint32x4_t mask = {0xFFFFFFFF, 0, 0xFFFFFFFF, 0};\n        int32x4_t masked_vec = vandq_s32(vec, vreinterpretq_s32_u32(mask));\n\n        // Compute the minimum of the selected elements\n        int32x2_t min_pairs = vmin_s32(vget_low_s32(masked_vec), vget_high_s32(masked_vec));\n        int32x2_t min_single = vpmin_s32(min_pairs, min_pairs);\n\n        // Extract the minimum value from the NEON register\n        int candidate = vget_lane_s32(min_single, 0);\n        if (candidate < min_val && candidate != 0) {\n            min_val = candidate;\n        }\n    }\n\n    // Process remaining elements\n    for (; i < length; ++i) {\n        if (i % 2 == 0 && src[i] < min_val) {\n            min_val = src[i];\n        }\n    }\n\n    return (min_val == INT32_MAX) ? -1 : min_val;\n}\n```"}
{"task_id": "SimdBench_11_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    int min_val = INT32_MAX;\n    size_t i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 8 <= length; i += 8) {\n        // Load 8 integers from the source array\n        int32x4_t vec0 = vld1q_s32(src + i);\n        int32x4_t vec1 = vld1q_s32(src + i + 4);\n\n        // Extract even-indexed elements using interleaving and masking\n        int32x4_t even_vec0 = vuzp1q_s32(vec0, vec1); // Even elements from vec0 and vec1\n\n        // Compute the minimum of the even elements in this batch\n        int32x2_t min_even = vpmin_s32(vget_low_s32(even_vec0), vget_high_s32(even_vec0));\n        min_even = vpmin_s32(min_even, min_even);\n\n        // Update the global minimum value\n        min_val = std::min(min_val, vget_lane_s32(min_even, 0));\n    }\n\n    // Process remaining elements (if any)\n    for (; i < length; i++) {\n        if (i % 2 == 0) { // Check if index is even\n            min_val = std::min(min_val, src[i]);\n        }\n    }\n\n    return (min_val == INT32_MAX) ? -1 : min_val;\n}\n```"}
{"task_id": "SimdBench_11_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    int min_val = INT32_MAX;\n    size_t i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 8 <= length; i += 8) {\n        // Load 8 integers from the source array\n        int32x4_t vec0 = vld1q_s32(&src[i]);\n        int32x4_t vec1 = vld1q_s32(&src[i + 4]);\n\n        // Extract even-indexed elements (0, 2, 4, 6)\n        int32x2_t even0 = vuzp_s32(vget_low_s32(vec0), vget_high_s32(vec0)).val[0];\n        int32x2_t even1 = vuzp_s32(vget_low_s32(vec1), vget_high_s32(vec1)).val[0];\n\n        // Combine the two even-element vectors into one\n        int32x4_t even_combined = vcombine_s32(even0, even1);\n\n        // Find the minimum value in the combined vector\n        int32x2_t min_vec = vpmin_s32(vget_low_s32(even_combined), vget_high_s32(even_combined));\n        min_vec = vpmin_s32(min_vec, min_vec);\n\n        // Update the scalar minimum value\n        min_val = std::min(min_val, vget_lane_s32(min_vec, 0));\n    }\n\n    // Handle remaining elements\n    for (; i < length; i += 2) {\n        if (i % 2 == 0 && src[i] < min_val) {\n            min_val = src[i];\n        }\n    }\n\n    return (min_val == INT32_MAX) ? -1 : min_val;\n}\n```"}
{"task_id": "SimdBench_11_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    int min_val = INT32_MAX;\n    size_t i = 0;\n\n    // Process elements in chunks of 4 using NEON intrinsics\n    for (; i + 8 <= length; i += 8) {\n        // Load 8 integers from the source array\n        int32x4_t vec0 = vld1q_s32(src + i);\n        int32x4_t vec1 = vld1q_s32(src + i + 4);\n\n        // Extract even-indexed elements\n        int32x2_t even0 = vuzp1_s32(vget_low_s32(vec0), vget_high_s32(vec0));\n        int32x2_t even1 = vuzp1_s32(vget_low_s32(vec1), vget_high_s32(vec1));\n\n        // Combine even-indexed elements into a single vector\n        int32x4_t even_combined = vcombine_s32(even0, even1);\n\n        // Find the minimum value in the combined vector\n        int32x2_t min_vec = vpmin_s32(vget_low_s32(even_combined), vget_high_s32(even_combined));\n        min_vec = vpmin_s32(min_vec, min_vec);\n\n        // Update the scalar minimum value\n        min_val = std::min(min_val, vget_lane_s32(min_vec, 0));\n    }\n\n    // Process remaining elements\n    for (; i < length; i += 2) {\n        if (i % 2 == 0 && src[i] < min_val) {\n            min_val = src[i];\n        }\n    }\n\n    return (min_val == INT32_MAX) ? -1 : min_val;\n}\n```"}
{"task_id": "SimdBench_12_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 integers from the source array into a NEON register\n        int32x4_t src_vec = vld1q_s32(&src[i]);\n        \n        // Perform arithmetic right shift\n        int32x4_t arith_shift_vec = vshrq_n_s32(src_vec, shift);\n        \n        // Convert to unsigned for logical right shift, then cast back to signed\n        uint32x4_t src_unsigned_vec = vreinterpretq_u32_s32(src_vec);\n        uint32x4_t logic_shift_vec_unsigned = vshrq_n_u32(src_unsigned_vec, shift);\n        int32x4_t logic_shift_vec = vreinterpretq_s32_u32(logic_shift_vec_unsigned);\n        \n        // Add the results of arithmetic and logical shifts\n        int32x4_t result_vec = vaddq_s32(arith_shift_vec, logic_shift_vec);\n        \n        // Store the result back to the destination array\n        vst1q_s32(&dst[i], result_vec);\n    }\n    \n    // Handle any remaining elements that don't fit into a full NEON vector\n    for (; i < length; ++i) {\n        int arith_shift = src[i] >> shift;\n        int logic_shift = (unsigned int)(src[i]) >> shift;\n        dst[i] = arith_shift + logic_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    const size_t simd_width = 4; // NEON processes 4 integers at a time\n\n    for (; i + simd_width <= length; i += simd_width) {\n        // Load 4 integers from the source array into a NEON register\n        int32x4_t src_vec = vld1q_s32(&src[i]);\n\n        // Perform arithmetic right shift\n        int32x4_t arith_shifted = vshrq_n_s32(src_vec, shift);\n\n        // Convert to unsigned for logical right shift\n        uint32x4_t src_unsigned = vreinterpretq_u32_s32(src_vec);\n        uint32x4_t logic_shifted_unsigned = vshrq_n_u32(src_unsigned, shift);\n\n        // Convert back to signed after logical shift\n        int32x4_t logic_shifted = vreinterpretq_s32_u32(logic_shifted_unsigned);\n\n        // Add the results of arithmetic and logical shifts\n        int32x4_t result = vaddq_s32(arith_shifted, logic_shifted);\n\n        // Store the result back to the destination array\n        vst1q_s32(&dst[i], result);\n    }\n\n    // Handle any remaining elements that don't fit into a full NEON register\n    for (; i < length; ++i) {\n        int arith_shifted = src[i] >> shift;\n        int logic_shifted = (unsigned int)(src[i]) >> shift;\n        dst[i] = arith_shifted + logic_shifted;\n    }\n}\n```"}
{"task_id": "SimdBench_12_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 integers from the source array into a NEON register\n        int32x4_t src_vec = vld1q_s32(&src[i]);\n        \n        // Perform arithmetic right shift\n        int32x4_t arith_shift_vec = vshrq_n_s32(src_vec, shift);\n        \n        // Convert to unsigned for logical right shift, then cast back to signed\n        uint32x4_t src_unsigned_vec = vreinterpretq_u32_s32(src_vec);\n        uint32x4_t logic_shift_vec_unsigned = vshrq_n_u32(src_unsigned_vec, shift);\n        int32x4_t logic_shift_vec = vreinterpretq_s32_u32(logic_shift_vec_unsigned);\n        \n        // Add the results of arithmetic and logical shifts\n        int32x4_t result_vec = vaddq_s32(arith_shift_vec, logic_shift_vec);\n        \n        // Store the result back to the destination array\n        vst1q_s32(&dst[i], result_vec);\n    }\n    \n    // Handle any remaining elements that didn't fit into the SIMD processing\n    for (; i < length; ++i) {\n        int arith_shift = src[i] >> shift;\n        int logic_shift = (unsigned int)(src[i]) >> shift;\n        dst[i] = arith_shift + logic_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    const size_t simd_width = 4; // NEON processes 4 integers at a time\n\n    for (; i + simd_width <= length; i += simd_width) {\n        // Load 4 integers from the source array\n        int32x4_t src_vec = vld1q_s32(&src[i]);\n\n        // Perform arithmetic right shift\n        int32x4_t arith_shift_vec = vshrq_n_s32(src_vec, shift);\n\n        // Convert to unsigned for logical right shift\n        uint32x4_t src_unsigned_vec = vreinterpretq_u32_s32(src_vec);\n        uint32x4_t logic_shift_vec_unsigned = vshrq_n_u32(src_unsigned_vec, shift);\n\n        // Convert back to signed\n        int32x4_t logic_shift_vec = vreinterpretq_s32_u32(logic_shift_vec_unsigned);\n\n        // Add the results of arithmetic and logical shifts\n        int32x4_t result_vec = vaddq_s32(arith_shift_vec, logic_shift_vec);\n\n        // Store the result into the destination array\n        vst1q_s32(&dst[i], result_vec);\n    }\n\n    // Handle any remaining elements that don't fit into a full SIMD vector\n    for (; i < length; ++i) {\n        int arith_shift = src[i] >> shift;\n        int logic_shift = (unsigned int)(src[i]) >> shift;\n        dst[i] = arith_shift + logic_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    \n    for (; i + 4 <= length; i += 4) {\n        // Load 4 integers from the source array\n        int32x4_t src_vec = vld1q_s32(&src[i]);\n        \n        // Perform arithmetic right shift\n        int32x4_t arith_shift_vec = vshrq_n_s32(src_vec, shift);\n        \n        // Convert to unsigned for logical right shift\n        uint32x4_t src_unsigned_vec = vreinterpretq_u32_s32(src_vec);\n        uint32x4_t logic_shift_vec_unsigned = vshrq_n_u32(src_unsigned_vec, shift);\n        \n        // Convert back to signed after logical shift\n        int32x4_t logic_shift_vec = vreinterpretq_s32_u32(logic_shift_vec_unsigned);\n        \n        // Add the results of arithmetic and logical shifts\n        int32x4_t result_vec = vaddq_s32(arith_shift_vec, logic_shift_vec);\n        \n        // Store the result in the destination array\n        vst1q_s32(&dst[i], result_vec);\n    }\n    \n    // Handle any remaining elements that don't fit into a full vector\n    for (; i < length; ++i) {\n        int arith_shift = src[i] >> shift;\n        int logic_shift = (unsigned int)(src[i]) >> shift;\n        dst[i] = arith_shift + logic_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_13_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64_t total_sum = 0;\n    size_t simd_elements = 4; // NEON processes 4 integers at a time\n    size_t simd_aligned_cols = (cols / simd_elements) * simd_elements;\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int *row_ptr = matrix + i * cols;\n        int32x4_t vec_sum = vdupq_n_s32(0);\n\n        size_t j = 0;\n        for (; j < simd_aligned_cols; j += simd_elements) {\n            int32x4_t vec = vld1q_s32(row_ptr + j);\n            vec_sum = vaddq_s32(vec_sum, vec);\n        }\n\n        // Horizontal sum of the vector\n        int32_t partial_sum[4];\n        vst1q_s32(partial_sum, vec_sum);\n        total_sum += partial_sum[0] + partial_sum[1] + partial_sum[2] + partial_sum[3];\n\n        // Handle remaining elements in the row\n        for (; j < cols; ++j) {\n            total_sum += row_ptr[j];\n        }\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_13_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64_t total_sum = 0;\n    size_t simd_elements = 4; // NEON processes 4 integers at a time (128-bit register)\n    size_t simd_aligned_cols = (cols / simd_elements) * simd_elements;\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int *row_ptr = matrix + i * cols;\n        int32x4_t vec_sum = vdupq_n_s32(0); // Initialize vector sum to zero\n\n        size_t j = 0;\n        for (; j < simd_aligned_cols; j += simd_elements) {\n            int32x4_t vec = vld1q_s32(row_ptr + j); // Load 4 integers into a NEON register\n            vec_sum = vaddq_s32(vec_sum, vec);     // Accumulate the sum\n        }\n\n        // Horizontal sum of the vector\n        int32_t partial_sum[4];\n        vst1q_s32(partial_sum, vec_sum);\n        total_sum += partial_sum[0] + partial_sum[1] + partial_sum[2] + partial_sum[3];\n\n        // Handle remaining elements in the row\n        for (; j < cols; ++j) {\n            total_sum += row_ptr[j];\n        }\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_13_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64_t total_sum = 0;\n    size_t simd_elements = 4; // NEON processes 4 integers at a time\n    size_t simd_aligned_cols = (cols / simd_elements) * simd_elements;\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int *row_ptr = matrix + i * cols;\n        int32x4_t vec_sum = vdupq_n_s32(0);\n\n        size_t j = 0;\n        for (; j < simd_aligned_cols; j += simd_elements) {\n            int32x4_t vec = vld1q_s32(row_ptr + j);\n            vec_sum = vaddq_s32(vec_sum, vec);\n        }\n\n        // Horizontal sum of the SIMD vector\n        int32_t partial_sum[4];\n        vst1q_s32(partial_sum, vec_sum);\n        total_sum += partial_sum[0] + partial_sum[1] + partial_sum[2] + partial_sum[3];\n\n        // Handle remaining elements in the row\n        for (; j < cols; ++j) {\n            total_sum += row_ptr[j];\n        }\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_13_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64_t total_sum = 0;\n    size_t simd_elements = 4; // NEON processes 4 integers at a time\n    size_t simd_aligned_cols = (cols / simd_elements) * simd_elements;\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int *row_ptr = matrix + i * cols;\n        int32x4_t vec_sum = vdupq_n_s32(0);\n\n        size_t j = 0;\n        for (; j < simd_aligned_cols; j += simd_elements) {\n            int32x4_t vec = vld1q_s32(row_ptr + j);\n            vec_sum = vaddq_s32(vec_sum, vec);\n        }\n\n        int32_t temp[4];\n        vst1q_s32(temp, vec_sum);\n        total_sum += temp[0] + temp[1] + temp[2] + temp[3];\n\n        for (; j < cols; ++j) {\n            total_sum += row_ptr[j];\n        }\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_13_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64_t total_sum = 0;\n    size_t simd_elements = 4; // NEON processes 4 integers at a time (128-bit register)\n    size_t simd_aligned_cols = (cols / simd_elements) * simd_elements;\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int *row_ptr = matrix + i * cols;\n        int32x4_t vec_sum = vdupq_n_s32(0); // Initialize SIMD accumulator to zero\n\n        size_t j = 0;\n        // Process columns in chunks of 4 using NEON intrinsics\n        for (; j < simd_aligned_cols; j += simd_elements) {\n            int32x4_t vec = vld1q_s32(row_ptr + j); // Load 4 integers into a NEON register\n            vec_sum = vaddq_s32(vec_sum, vec);     // Accumulate the sum\n        }\n\n        // Horizontally add the elements in the NEON register\n        int32x2_t vec_sum_low = vget_low_s32(vec_sum);\n        int32x2_t vec_sum_high = vget_high_s32(vec_sum);\n        int32x2_t partial_sum = vpadd_s32(vec_sum_low, vec_sum_high);\n        total_sum += vget_lane_s32(partial_sum, 0) + vget_lane_s32(partial_sum, 1);\n\n        // Process remaining elements that don't fit into a full NEON register\n        for (; j < cols; ++j) {\n            total_sum += row_ptr[j];\n        }\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_14_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t i = 0;\n    int8_t max_val = INT8_MIN;\n    size_t max_idx = 0;\n\n    // Process 16 elements at a time using NEON intrinsics\n    for (; i <= length - 16; i += 16) {\n        // Load 16 elements from the source array\n        int8x16_t vec = vld1q_s8(&src[i]);\n\n        // Find the maximum value in the vector\n        int8x16_t max_vec = vpmaxq_s8(vec, vec);\n        max_vec = vpmaxq_s8(max_vec, max_vec);\n        max_vec = vpmaxq_s8(max_vec, max_vec);\n\n        // Extract the maximum value from the vector\n        int8_t current_max = vmaxvq_s8(vec);\n\n        // Compare with the global maximum and update if necessary\n        if (current_max > max_val) {\n            max_val = current_max;\n\n            // Find the index of the maximum value within the vector\n            int8x16_t cmp_vec = vceqq_s8(vec, vdupq_n_s8(max_val));\n            uint8x16_t mask = vreinterpretq_u8_s8(cmp_vec);\n            uint8x16_t idx_vec = vidupq_u8(mask, 0);\n            uint8x16_t masked_idx = vandq_u8(idx_vec, mask);\n\n            // Find the first non-zero index in the masked index vector\n            uint8_t indices[16];\n            vst1q_u8(indices, masked_idx);\n            for (int j = 0; j < 16; ++j) {\n                if (indices[j] != 0) {\n                    max_idx = i + j;\n                    break;\n                }\n            }\n        }\n    }\n\n    // Process remaining elements\n    for (; i < length; ++i) {\n        if (src[i] > max_val) {\n            max_val = src[i];\n            max_idx = i;\n        }\n    }\n\n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_14_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t i = 0;\n    int8_t max_val = INT8_MIN;\n    size_t max_idx = 0;\n\n    // Process 16 elements at a time using NEON intrinsics\n    for (; i + 15 < length; i += 16) {\n        // Load 16 elements into a NEON register\n        int8x16_t vec = vld1q_s8(&src[i]);\n\n        // Find the maximum value in the vector\n        int8x16_t max_vec = vpmaxq_s8(vec, vec);\n        max_vec = vpmaxq_s8(max_vec, max_vec);\n        max_vec = vpmaxq_s8(max_vec, max_vec);\n\n        // Extract the maximum value from the vector\n        int8_t current_max = vmaxvq_s8(vec);\n\n        // Compare with the global maximum and update if necessary\n        if (current_max > max_val) {\n            max_val = current_max;\n\n            // Find the index of the maximum value within the vector\n            uint8x16_t cmp = vceqq_s8(vec, vdupq_n_s8(max_val));\n            uint64x2_t mask = vreinterpretq_u64_u8(cmp);\n            uint64_t idx_mask = vgetq_lane_u64(mask, 0) | (vgetq_lane_u64(mask, 1) << 8);\n            size_t offset = __builtin_ctzll(idx_mask);\n            max_idx = i + offset;\n        }\n    }\n\n    // Process remaining elements\n    for (; i < length; ++i) {\n        if (src[i] > max_val) {\n            max_val = src[i];\n            max_idx = i;\n        }\n    }\n\n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_14_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t i = 0;\n    int8_t max_val = INT8_MIN;\n    size_t max_idx = 0;\n\n    // Process 16 elements at a time using NEON intrinsics\n    for (; i + 16 <= length; i += 16) {\n        // Load 16 elements into a NEON register\n        int8x16_t vec = vld1q_s8(&src[i]);\n\n        // Find the maximum value in the vector\n        int8x16_t max_vec = vpmaxq_s8(vec, vec);\n        max_vec = vpmaxq_s8(max_vec, max_vec);\n        max_vec = vpmaxq_s8(max_vec, max_vec);\n\n        // Extract the maximum value from the vector\n        int8_t current_max = vmaxvq_s8(vec);\n\n        // Compare and update the global maximum value and index\n        if (current_max > max_val) {\n            max_val = current_max;\n            // Find the index of the maximum value within the vector\n            for (size_t j = 0; j < 16; ++j) {\n                if (src[i + j] == current_max) {\n                    max_idx = i + j;\n                    break;\n                }\n            }\n        }\n    }\n\n    // Process remaining elements\n    for (; i < length; ++i) {\n        if (src[i] > max_val) {\n            max_val = src[i];\n            max_idx = i;\n        }\n    }\n\n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_14_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t i = 0;\n    int8_t max_val = INT8_MIN;\n    size_t max_idx = 0;\n\n    // Process 16 elements at a time using NEON intrinsics\n    for (; i <= length - 16; i += 16) {\n        // Load 16 elements from the source array\n        int8x16_t vec = vld1q_s8(&src[i]);\n\n        // Find the maximum value in the vector\n        int8x16_t max_vec = vpmaxq_s8(vec, vec);\n        max_vec = vpmaxq_s8(max_vec, max_vec);\n        max_vec = vpmaxq_s8(max_vec, max_vec);\n\n        // Extract the maximum value from the vector\n        int8_t current_max = vmaxvq_s8(vec);\n\n        // Compare with the global maximum and update if necessary\n        if (current_max > max_val) {\n            max_val = current_max;\n            // Find the index of the maximum value within the vector\n            for (size_t j = 0; j < 16; ++j) {\n                if (src[i + j] == current_max) {\n                    max_idx = i + j;\n                    break;\n                }\n            }\n        }\n    }\n\n    // Process remaining elements\n    for (; i < length; ++i) {\n        if (src[i] > max_val) {\n            max_val = src[i];\n            max_idx = i;\n        }\n    }\n\n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_14_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t i = 0;\n    int8_t max_val = INT8_MIN;\n    size_t max_idx = 0;\n\n    // Process 16 elements at a time using NEON intrinsics\n    for (; i <= length - 16; i += 16) {\n        // Load 16 elements from the source array\n        int8x16_t vec = vld1q_s8(&src[i]);\n\n        // Find the maximum value in the vector\n        int8x16_t max_vec = vpmaxq_s8(vec, vec);\n        max_vec = vpmaxq_s8(max_vec, max_vec);\n        max_vec = vpmaxq_s8(max_vec, max_vec);\n\n        // Extract the maximum value from the vector\n        int8_t current_max = vmaxvq_s8(vec);\n\n        // Compare with the global maximum and update if necessary\n        if (current_max > max_val) {\n            max_val = current_max;\n\n            // Find the index of the maximum value within the vector\n            uint8x16_t cmp = vceqq_s8(vec, vdupq_n_s8(max_val));\n            uint8x16_t idx_vec = vidupq_u8(0, 0); // Generate indices 0 to 15\n            uint8x16_t masked_idx = vandq_u8(idx_vec, cmp);\n\n            // Find the first non-zero index\n            uint8x8_t low = vget_low_u8(masked_idx);\n            uint8x8_t high = vget_high_u8(masked_idx);\n            uint8x8_t nz_low = vcltz_s8(vreinterpret_s8_u8(low));\n            uint8x8_t nz_high = vcltz_s8(vreinterpret_s8_u8(high));\n\n            if (vmaxv_u8(nz_low) != 0) {\n                max_idx = i + vaddv_u8(low);\n            } else {\n                max_idx = i + 8 + vaddv_u8(high);\n            }\n        }\n    }\n\n    // Process remaining elements\n    for (; i < length; ++i) {\n        if (src[i] > max_val) {\n            max_val = src[i];\n            max_idx = i;\n        }\n    }\n\n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_15_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n\n    // Process 8 elements at a time using NEON intrinsics\n    for (; i + 8 <= length; i += 8) {\n        // Load 8 elements from src1 and src2\n        uint16x8_t v_src1 = vld1q_u16(&src1[i]);\n        uint16x8_t v_src2 = vld1q_u16(&src2[i]);\n\n        // Create a mask for the indices\n        uint32x4_t idx_mask_low = vmovq_n_u32(mask);\n        uint32x4_t idx_mask_high = vmovq_n_u32(mask);\n\n        // Generate index values for the current block (i to i+7)\n        uint32x4_t indices_low = vaddq_u32(vmovq_n_u32(i), vmovq_n_u32(0));\n        uint32x4_t indices_high = vaddq_u32(vmovq_n_u32(i), vmovq_n_u32(4));\n\n        // Perform bitwise AND with the mask\n        uint32x4_t masked_indices_low = vandq_u32(indices_low, idx_mask_low);\n        uint32x4_t masked_indices_high = vandq_u32(indices_high, idx_mask_high);\n\n        // Compare if the result is non-zero\n        uint16x8_t blend_mask = vcombine_u16(\n            vreinterpret_u16_u32(vcgtq_u32(masked_indices_low, vmovq_n_u32(0))),\n            vreinterpret_u16_u32(vcgtq_u32(masked_indices_high, vmovq_n_u32(0)))\n        );\n\n        // Blend values based on the mask\n        uint16x8_t result = vbslq_u16(blend_mask, v_src1, v_src2);\n\n        // Store the result in the destination array\n        vst1q_u16(&dst[i], result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; ++i) {\n        dst[i] = ((i & mask) != 0) ? src1[i] : src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_15_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n\n    // Process 8 elements at a time using NEON intrinsics\n    for (; i + 8 <= length; i += 8) {\n        // Load 8 elements from src1 and src2\n        uint16x8_t v_src1 = vld1q_u16(&src1[i]);\n        uint16x8_t v_src2 = vld1q_u16(&src2[i]);\n\n        // Create a mask for the indices\n        uint32x4_t idx_mask_low = vmovq_n_u32(mask);\n        uint32x4_t idx_mask_high = vmovq_n_u32(mask);\n\n        // Generate index values for the current block (i to i+7)\n        uint32x4_t indices_low = vaddq_u32(vmovq_n_u32(i), vmovq_n_u32(0));\n        uint32x4_t indices_high = vaddq_u32(vmovq_n_u32(i), vmovq_n_u32(4));\n\n        // Perform bitwise AND with the mask\n        uint32x4_t masked_indices_low = vandq_u32(indices_low, idx_mask_low);\n        uint32x4_t masked_indices_high = vandq_u32(indices_high, idx_mask_high);\n\n        // Compare if the result of the AND is non-zero\n        uint16x8_t blend_mask = vcombine_u16(\n            vshrn_n_u32(masked_indices_low, 16),\n            vshrn_n_u32(masked_indices_high, 16)\n        );\n\n        // Blend based on the mask\n        uint16x8_t result = vbslq_u16(vreinterpretq_u16_u32(vorrq_u32(masked_indices_low, masked_indices_high)), v_src1, v_src2);\n\n        // Store the result into dst\n        vst1q_u16(&dst[i], result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; ++i) {\n        dst[i] = ((i & mask) != 0) ? src1[i] : src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_15_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n\n    // Process 8 elements at a time using NEON intrinsics\n    for (; i + 8 <= length; i += 8) {\n        // Load 8 elements from src1 and src2\n        uint16x8_t v_src1 = vld1q_u16(&src1[i]);\n        uint16x8_t v_src2 = vld1q_u16(&src2[i]);\n\n        // Create a mask for the indices [i, i+7]\n        uint32x4_t idx_low = {i, i + 1, i + 2, i + 3};\n        uint32x4_t idx_high = {i + 4, i + 5, i + 6, i + 7};\n\n        // Perform bitwise AND with the mask\n        uint32x4_t mask_low = vtstq_u32(idx_low, vdupq_n_u32(mask));\n        uint32x4_t mask_high = vtstq_u32(idx_high, vdupq_n_u32(mask));\n\n        // Convert the masks to 16-bit\n        uint16x8_t blend_mask = vcombine_u16(vmovn_u32(mask_low), vmovn_u32(mask_high));\n\n        // Blend the values based on the mask\n        uint16x8_t result = vbslq_u16(blend_mask, v_src1, v_src2);\n\n        // Store the result in the destination array\n        vst1q_u16(&dst[i], result);\n    }\n\n    // Handle any remaining elements\n    for (; i < length; ++i) {\n        dst[i] = ((i & mask) != 0) ? src1[i] : src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_15_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n\n    // Process 8 elements at a time using NEON intrinsics\n    for (; i + 8 <= length; i += 8) {\n        // Load 8 elements from src1 and src2\n        uint16x8_t src1_vec = vld1q_u16(&src1[i]);\n        uint16x8_t src2_vec = vld1q_u16(&src2[i]);\n\n        // Create a mask for the indices\n        uint32x4_t index_mask_low = vmovq_n_u32(mask);\n        uint32x4_t index_mask_high = vmovq_n_u32(mask);\n\n        // Generate index vectors for low and high parts\n        uint32x4_t indices_low = vidupq_u32((uint32_t)(i), 1);       // Incrementing indices starting from i\n        uint32x4_t indices_high = vidupq_u32((uint32_t)(i + 4), 1); // Incrementing indices starting from i+4\n\n        // Perform bitwise AND with the mask\n        uint32x4_t masked_indices_low = vandq_u32(indices_low, index_mask_low);\n        uint32x4_t masked_indices_high = vandq_u32(indices_high, index_mask_high);\n\n        // Compare if the result is non-zero (true -> all ones, false -> all zeros)\n        uint16x8_t blend_mask;\n        blend_mask = vcombine_u16(\n            vreinterpret_u16_u32(vcgtq_u32(masked_indices_low, vmovq_n_u32(0))),\n            vreinterpret_u16_u32(vcgtq_u32(masked_indices_high, vmovq_n_u32(0)))\n        );\n\n        // Blend based on the mask\n        uint16x8_t result = vbslq_u16(blend_mask, src1_vec, src2_vec);\n\n        // Store the result into dst\n        vst1q_u16(&dst[i], result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; ++i) {\n        dst[i] = ((i & mask) != 0) ? src1[i] : src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_15_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n\n    // Process 8 elements at a time using NEON intrinsics\n    for (; i + 8 <= length; i += 8) {\n        // Load 8 elements from src1 and src2\n        uint16x8_t v_src1 = vld1q_u16(&src1[i]);\n        uint16x8_t v_src2 = vld1q_u16(&src2[i]);\n\n        // Create a mask for the indices based on the given mask\n        uint32x4_t idx_mask_low = vmovq_n_u32(mask);\n        uint32x4_t idx_mask_high = vmovq_n_u32(mask);\n\n        // Generate index values for the current vector (i, i+1, ..., i+7)\n        uint32x4_t idx_low = vidupq_u32((uint32_t)(i), 1);   // Increment by 1\n        uint32x4_t idx_high = vidupq_u32((uint32_t)(i + 4), 1);\n\n        // Perform bitwise AND between indices and mask\n        uint32x4_t masked_idx_low = vandq_u32(idx_low, idx_mask_low);\n        uint32x4_t masked_idx_high = vandq_u32(idx_high, idx_mask_high);\n\n        // Check if the result of the AND is non-zero\n        uint16x8_t blend_mask;\n        blend_mask = vcombine_u16(\n            vmovn_u32(vreinterpretq_u32_u16(vorrq_u16(vreinterpretq_u16_u32(masked_idx_low), vreinterpretq_u16_u32(masked_idx_low)))),\n            vmovn_u32(vreinterpretq_u32_u16(vorrq_u16(vreinterpretq_u16_u32(masked_idx_high), vreinterpretq_u16_u32(masked_idx_high))))\n        );\n\n        // Blend src1 and src2 based on the mask\n        uint16x8_t result = vbslq_u16(blend_mask, v_src1, v_src2);\n\n        // Store the result into dst\n        vst1q_u16(&dst[i], result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; ++i) {\n        dst[i] = ((i & mask) != 0) ? src1[i] : src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_16_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 uint32_t elements from the source array\n        uint32x4_t input = vld1q_u32(&src[i]);\n\n        // Compute population count for each lane\n        uint8x16_t count8 = vcntq_u8(vreinterpretq_u8_u32(input));\n        uint16x8_t count16 = vpaddlq_u8(count8);\n        uint32x4_t count32 = vpaddlq_u16(count16);\n\n        // Store the results into the destination array\n        vst1q_u32(&dst[i], count32);\n    }\n\n    // Handle remaining elements (if any)\n    for (; i < length; ++i) {\n        dst[i] = __builtin_popcount(src[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_16_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 uint32_t elements from the source array\n        uint32x4_t input = vld1q_u32(&src[i]);\n\n        // Compute population count for each lane\n        uint8x16_t count8 = vcntq_u8(vreinterpretq_u8_u32(input));\n        uint16x8_t count16 = vpaddlq_u8(count8);\n        uint32x4_t count32 = vpaddlq_u16(count16);\n\n        // Store the results into the destination array\n        vst1q_u32(&dst[i], count32);\n    }\n\n    // Handle remaining elements (if any)\n    for (; i < length; ++i) {\n        dst[i] = __builtin_popcount(src[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_16_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 uint32_t values from the source array\n        uint32x4_t input = vld1q_u32(&src[i]);\n\n        // Compute the population count for each lane\n        uint8x16_t count8 = vcntq_u8(vreinterpretq_u8_u32(input));\n        uint16x8_t count16 = vpaddlq_u8(count8);\n        uint32x4_t count32 = vpaddlq_u16(count16);\n\n        // Store the results into the destination array\n        vst1q_u32(&dst[i], count32);\n    }\n\n    // Handle any remaining elements\n    for (; i < length; ++i) {\n        dst[i] = __builtin_popcount(src[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_16_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 uint32_t elements from the source array\n        uint32x4_t src_vec = vld1q_u32(&src[i]);\n\n        // Compute the population count for each element in the vector\n        uint8x16_t popcount_vec = vcntq_u8(vreinterpretq_u8_u32(src_vec));\n\n        // Sum the counts across lanes to get the total population count for each uint32_t\n        uint16x8_t sum1 = vpaddlq_u8(popcount_vec);\n        uint32x4_t sum2 = vpaddlq_u16(sum1);\n\n        // Store the results into the destination array\n        vst1q_u32(&dst[i], sum2);\n    }\n\n    // Handle any remaining elements that don't fit into a full vector\n    for (; i < length; ++i) {\n        dst[i] = __builtin_popcount(src[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_16_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 uint32_t elements from the source array\n        uint32x4_t input = vld1q_u32(&src[i]);\n\n        // Compute the population count for each lane\n        uint8x16_t count8 = vcntq_u8(vreinterpretq_u8_u32(input));\n        uint16x8_t count16 = vpaddlq_u8(count8);\n        uint32x4_t count32 = vpaddlq_u16(count16);\n\n        // Store the results into the destination array\n        vst1q_u32(&dst[i], count32);\n    }\n\n    // Handle any remaining elements\n    for (; i < length; ++i) {\n        dst[i] = __builtin_popcount(src[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_17_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 8 elements at a time using NEON intrinsics\n    for (; i + 8 <= length; i += 8) {\n        // Load 8 elements from src1 and src2\n        uint16x8_t v_src1 = vld1q_u16(&src1[i]);\n        uint16x8_t v_src2 = vld1q_u16(&src2[i]);\n        \n        // Perform saturating addition\n        uint16x8_t v_dst = vqaddq_u16(v_src1, v_src2);\n        \n        // Store the result in dst\n        vst1q_u16(&dst[i], v_dst);\n    }\n    \n    // Handle remaining elements (if any)\n    for (; i < length; ++i) {\n        dst[i] = __builtin_add_overflow(src1[i], src2[i], &dst[i]) ? UINT16_MAX : dst[i];\n    }\n}\n```"}
{"task_id": "SimdBench_17_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n\n    // Process 8 elements at a time using Neon intrinsics\n    for (; i + 8 <= length; i += 8) {\n        // Load 8 elements from src1 and src2\n        uint16x8_t v_src1 = vld1q_u16(&src1[i]);\n        uint16x8_t v_src2 = vld1q_u16(&src2[i]);\n\n        // Perform saturating addition\n        uint16x8_t v_dst = vqaddq_u16(v_src1, v_src2);\n\n        // Store the result into dst\n        vst1q_u16(&dst[i], v_dst);\n    }\n\n    // Handle remaining elements (if any) with scalar code\n    for (; i < length; ++i) {\n        dst[i] = __builtin_add_overflow(src1[i], src2[i], &dst[i]) ? UINT16_MAX : dst[i];\n    }\n}\n```"}
{"task_id": "SimdBench_17_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n\n    // Process 8 elements at a time using NEON intrinsics\n    for (; i + 8 <= length; i += 8) {\n        // Load 8 elements from src1 and src2\n        uint16x8_t v_src1 = vld1q_u16(&src1[i]);\n        uint16x8_t v_src2 = vld1q_u16(&src2[i]);\n\n        // Perform saturating addition\n        uint16x8_t v_dst = vqaddq_u16(v_src1, v_src2);\n\n        // Store the result into dst\n        vst1q_u16(&dst[i], v_dst);\n    }\n\n    // Handle remaining elements (if any) with scalar code\n    for (; i < length; ++i) {\n        dst[i] = __builtin_add_overflow(src1[i], src2[i], &dst[i]) ? UINT16_MAX : dst[i];\n    }\n}\n```"}
{"task_id": "SimdBench_17_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n\n    // Process 8 elements at a time using NEON intrinsics\n    for (; i <= length - 8; i += 8) {\n        // Load 8 elements from src1 and src2\n        uint16x8_t v_src1 = vld1q_u16(&src1[i]);\n        uint16x8_t v_src2 = vld1q_u16(&src2[i]);\n\n        // Perform saturating addition\n        uint16x8_t v_dst = vqaddq_u16(v_src1, v_src2);\n\n        // Store the result into dst\n        vst1q_u16(&dst[i], v_dst);\n    }\n\n    // Handle remaining elements (if any) with scalar code\n    for (; i < length; ++i) {\n        dst[i] = __builtin_add_overflow(src1[i], src2[i], &dst[i]) ? UINT16_MAX : dst[i];\n    }\n}\n```"}
{"task_id": "SimdBench_17_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n\n    // Process 8 elements at a time using NEON intrinsics\n    for (; i + 8 <= length; i += 8) {\n        // Load 8 elements from src1 and src2\n        uint16x8_t v_src1 = vld1q_u16(&src1[i]);\n        uint16x8_t v_src2 = vld1q_u16(&src2[i]);\n\n        // Perform saturating addition\n        uint16x8_t v_dst = vqaddq_u16(v_src1, v_src2);\n\n        // Store the result in dst\n        vst1q_u16(&dst[i], v_dst);\n    }\n\n    // Handle remaining elements (if any) with scalar code\n    for (; i < length; ++i) {\n        dst[i] = __builtin_add_overflow(src1[i], src2[i], &dst[i]) ? UINT16_MAX : dst[i];\n    }\n}\n```"}
{"task_id": "SimdBench_18_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t k = 0; k < p; ++k) {\n            float64x2_t c_sum_vec = vdupq_n_f64(0.0);\n\n            for (size_t j = 0; j < n; j += 2) {\n                float64x2_t a_vec = vld1q_f64(&A[i * n + j]);\n                float64x2_t b_vec = vld1q_f64(&B[j * p + k]);\n\n                // Create masks for the range [-100, 100]\n                uint64x2_t a_mask = vandq_u64(vcgeq_f64(a_vec, vdupq_n_f64(-100.0)), \n                                              vcgeq_f64(vdupq_n_f64(100.0), a_vec));\n                uint64x2_t b_mask = vandq_u64(vcgeq_f64(b_vec, vdupq_n_f64(-100.0)), \n                                              vcgeq_f64(vdupq_n_f64(100.0), b_vec));\n                uint64x2_t mask = vandq_u64(a_mask, b_mask);\n\n                // Multiply elements and apply mask\n                float64x2_t mul_vec = vmulq_f64(a_vec, b_vec);\n                mul_vec = vbslq_f64(mask, mul_vec, vdupq_n_f64(0.0));\n\n                // Accumulate results\n                c_sum_vec = vaddq_f64(c_sum_vec, mul_vec);\n            }\n\n            // Horizontal sum of the vector\n            double result = vaddvq_f64(c_sum_vec);\n\n            // Store the result in C\n            C[i * p + k] = result;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t k = 0; k < p; ++k) {\n            float64x2_t c_sum_vec = vdupq_n_f64(0.0);\n\n            for (size_t j = 0; j < n; j += 2) {\n                float64x2_t a_vec = vld1q_f64(&A[i * n + j]);\n                float64x2_t b_vec = vld1q_f64(&B[j * p + k]);\n\n                // Create masks for values in the range [-100, 100]\n                uint64x2_t a_mask = vandq_u64(vcgeq_f64(a_vec, vdupq_n_f64(-100.0)),\n                                              vcgeq_f64(vdupq_n_f64(100.0), a_vec));\n                uint64x2_t b_mask = vandq_u64(vcgeq_f64(b_vec, vdupq_n_f64(-100.0)),\n                                              vcgeq_f64(vdupq_n_f64(100.0), b_vec));\n                uint64x2_t mask = vandq_u64(a_mask, b_mask);\n\n                // Multiply and accumulate only if both values are in range\n                float64x2_t mul_vec = vmulq_f64(a_vec, b_vec);\n                c_sum_vec = vaddq_f64(c_sum_vec, vbslq_f64(mask, mul_vec, vdupq_n_f64(0.0)));\n            }\n\n            // Horizontal sum of the vector\n            double result = vaddvq_f64(c_sum_vec);\n            C[i * p + k] = result;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t k = 0; k < p; ++k) {\n            float64x2_t c_sum = vdupq_n_f64(0.0);\n\n            for (size_t j = 0; j < n; j += 2) {\n                float64x2_t a_vec = vld1q_f64(&A[i * n + j]);\n                float64x2_t b_vec = vld1q_f64(&B[j * p + k]);\n\n                // Create masks for the range [-100, 100]\n                uint64x2_t a_mask = vandq_u64(vcgeq_f64(a_vec, vdupq_n_f64(-100.0)), \n                                              vcgeq_f64(vdupq_n_f64(100.0), a_vec));\n                uint64x2_t b_mask = vandq_u64(vcgeq_f64(b_vec, vdupq_n_f64(-100.0)), \n                                              vcgeq_f64(vdupq_n_f64(100.0), b_vec));\n                uint64x2_t mask = vandq_u64(a_mask, b_mask);\n\n                // Multiply and accumulate only if both values are in range\n                float64x2_t prod = vmulq_f64(a_vec, b_vec);\n                c_sum = vaddq_f64(c_sum, vbslq_f64(mask, prod, vdupq_n_f64(0.0)));\n            }\n\n            // Horizontal sum of the vector\n            double result[2];\n            vst1q_f64(result, c_sum);\n            C[i * p + k] = result[0] + result[1];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            float64x2_t c_sum = vdupq_n_f64(0.0);\n\n            for (size_t k = 0; k < n; k += 2) {\n                float64x2_t a_vec = vld1q_f64(&A[i * n + k]);\n                float64x2_t b_vec = vld1q_f64(&B[k * p + j]);\n\n                // Create masks for the range [-100, 100]\n                uint64x2_t a_mask = vandq_u64(vcgeq_f64(a_vec, vdupq_n_f64(-100.0)), \n                                              vcgeq_f64(vdupq_n_f64(100.0), a_vec));\n                uint64x2_t b_mask = vandq_u64(vcgeq_f64(b_vec, vdupq_n_f64(-100.0)), \n                                              vcgeq_f64(vdupq_n_f64(100.0), b_vec));\n                uint64x2_t mask = vandq_u64(a_mask, b_mask);\n\n                // Multiply elements and apply mask\n                float64x2_t prod = vmulq_f64(a_vec, b_vec);\n                prod = vbslq_f64(mask, prod, vdupq_n_f64(0.0));\n\n                // Accumulate results\n                c_sum = vaddq_f64(c_sum, prod);\n            }\n\n            // Horizontal sum of c_sum\n            double result[2];\n            vst1q_f64(result, c_sum);\n            C[i * p + j] = result[0] + result[1];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t k = 0; k < p; ++k) {\n            float64x2_t c_sum = vdupq_n_f64(0.0);\n\n            for (size_t j = 0; j < n; j += 2) {\n                float64x2_t a_vec = vld1q_f64(&A[i * n + j]);\n                float64x2_t b_vec = vld1q_f64(&B[j * p + k]);\n\n                // Create masks for the range [-100, 100]\n                uint64x2_t mask_a = vandq_u64(vcgeq_f64(a_vec, vdupq_n_f64(-100.0)), \n                                              vcgeq_f64(vdupq_n_f64(100.0), a_vec));\n                uint64x2_t mask_b = vandq_u64(vcgeq_f64(b_vec, vdupq_n_f64(-100.0)), \n                                              vcgeq_f64(vdupq_n_f64(100.0), b_vec));\n                uint64x2_t mask = vandq_u64(mask_a, mask_b);\n\n                // Mask out values outside the range\n                float64x2_t masked_a = vbslq_f64(mask, a_vec, vdupq_n_f64(0.0));\n                float64x2_t masked_b = vbslq_f64(mask, b_vec, vdupq_n_f64(0.0));\n\n                // Multiply and accumulate\n                c_sum = vmlaq_f64(c_sum, masked_a, masked_b);\n            }\n\n            // Horizontal sum of the vector\n            double result[2];\n            vst1q_f64(result, c_sum);\n            C[i * p + k] = result[0] + result[1];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n\n    // Process 2 elements at a time using Neon intrinsics (int64x2_t processes 2 int64_t values)\n    size_t simd_iterations = total_elements / 2;\n    size_t remainder = total_elements % 2;\n\n    for (size_t i = 0; i < simd_iterations; ++i) {\n        // Load 2 int64_t elements from A and B\n        int64x2_t vecA = vld1q_s64(&A[i * 2]);\n        int64x2_t vecB = vld1q_s64(&B[i * 2]);\n\n        // Perform element-wise addition\n        int64x2_t vecC = vaddq_s64(vecA, vecB);\n\n        // Store the result in C\n        vst1q_s64(&C[i * 2], vecC);\n    }\n\n    // Handle remaining elements (if total_elements is not a multiple of 2)\n    if (remainder > 0) {\n        for (size_t i = simd_iterations * 2; i < total_elements; ++i) {\n            C[i] = A[i] + B[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    // Process 2 elements at a time using Neon intrinsics (int64x2_t)\n    for (; i + 1 < total_elements; i += 2) {\n        // Load 2 elements from A and B\n        int64x2_t vecA = vld1q_s64(&A[i]);\n        int64x2_t vecB = vld1q_s64(&B[i]);\n\n        // Perform element-wise addition\n        int64x2_t vecC = vaddq_s64(vecA, vecB);\n\n        // Store the result in C\n        vst1q_s64(&C[i], vecC);\n    }\n\n    // Handle remaining elements (if total_elements is odd)\n    for (; i < total_elements; ++i) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n\n    // Process 2 elements at a time using Neon intrinsics (int64x2_t processes two 64-bit integers)\n    size_t simd_size = 2;\n    size_t simd_aligned_elements = total_elements / simd_size * simd_size;\n\n    size_t i = 0;\n\n    // SIMD loop for aligned elements\n    for (; i < simd_aligned_elements; i += simd_size) {\n        // Load 2 elements from A and B into Neon registers\n        int64x2_t vec_a = vld1q_s64(&A[i]);\n        int64x2_t vec_b = vld1q_s64(&B[i]);\n\n        // Perform element-wise addition\n        int64x2_t vec_c = vaddq_s64(vec_a, vec_b);\n\n        // Store the result back to C\n        vst1q_s64(&C[i], vec_c);\n    }\n\n    // Handle remaining elements that are not aligned with SIMD size\n    for (; i < total_elements; ++i) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n\n    // Process 2 elements at a time using Neon intrinsics (int64x2_t processes two 64-bit integers)\n    size_t simd_iterations = total_elements / 2;\n    size_t remainder = total_elements % 2;\n\n    for (size_t i = 0; i < simd_iterations; ++i) {\n        // Load 2 elements from A and B into Neon registers\n        int64x2_t vec_a = vld1q_s64(&A[i * 2]);\n        int64x2_t vec_b = vld1q_s64(&B[i * 2]);\n\n        // Perform element-wise addition\n        int64x2_t vec_c = vaddq_s64(vec_a, vec_b);\n\n        // Store the result back to C\n        vst1q_s64(&C[i * 2], vec_c);\n    }\n\n    // Handle any remaining elements that couldn't be processed in the SIMD loop\n    if (remainder > 0) {\n        for (size_t i = total_elements - remainder; i < total_elements; ++i) {\n            C[i] = A[i] + B[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n\n    // Process 2 elements at a time using Neon intrinsics (128-bit registers for int64x2_t)\n    size_t simd_size = total_elements / 2 * 2; // Round down to the nearest multiple of 2\n\n    size_t i = 0;\n    for (; i < simd_size; i += 2) {\n        // Load 2 int64 elements from A and B\n        int64x2_t vec_a = vld1q_s64(&A[i]);\n        int64x2_t vec_b = vld1q_s64(&B[i]);\n\n        // Perform element-wise addition\n        int64x2_t vec_c = vaddq_s64(vec_a, vec_b);\n\n        // Store the result in C\n        vst1q_s64(&C[i], vec_c);\n    }\n\n    // Handle remaining elements (if total_elements is odd)\n    for (; i < total_elements; ++i) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_20_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 3 < length; i += 4) {\n        // Load 4 floats from src1 and src2\n        float32x4_t v_src1 = vld1q_f32(&src1[i]);\n        float32x4_t v_src2 = vld1q_f32(&src2[i]);\n        \n        // Perform element-wise addition\n        float32x4_t v_sum = vaddq_f32(v_src1, v_src2);\n        \n        // Round to nearest integer (convert to int and back to float)\n        int32x4_t v_rounded = vcvtaq_s32_f32(v_sum);\n        float32x4_t v_result = vcvtq_f32_s32(v_rounded);\n        \n        // Store the result into dst\n        vst1q_f32(&dst[i], v_result);\n    }\n    \n    // Handle remaining elements (if any)\n    for (; i < length; ++i) {\n        float sum = src1[i] + src2[i];\n        dst[i] = nearbyintf(sum); // Use nearbyintf for rounding to nearest integer\n    }\n}\n```"}
{"task_id": "SimdBench_20_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 3 < length; i += 4) {\n        // Load 4 floats from src1 and src2\n        float32x4_t v_src1 = vld1q_f32(&src1[i]);\n        float32x4_t v_src2 = vld1q_f32(&src2[i]);\n        \n        // Perform element-wise addition\n        float32x4_t v_sum = vaddq_f32(v_src1, v_src2);\n        \n        // Round to nearest integer (convert to int and back to float)\n        int32x4_t v_rounded = vcvtaq_s32_f32(v_sum);\n        float32x4_t v_result = vcvtq_f32_s32(v_rounded);\n        \n        // Store the result in dst\n        vst1q_f32(&dst[i], v_result);\n    }\n    \n    // Handle remaining elements (if any)\n    for (; i < length; ++i) {\n        float sum = src1[i] + src2[i];\n        dst[i] = nearbyintf(sum); // Use standard library function for rounding\n    }\n}\n```"}
{"task_id": "SimdBench_20_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 3 < length; i += 4) {\n        // Load 4 floats from src1 and src2\n        float32x4_t v_src1 = vld1q_f32(&src1[i]);\n        float32x4_t v_src2 = vld1q_f32(&src2[i]);\n        \n        // Perform element-wise addition\n        float32x4_t v_sum = vaddq_f32(v_src1, v_src2);\n        \n        // Round to nearest integer (convert to int and back to float)\n        int32x4_t v_rounded = vrndnq_s32(vcvtaq_s32_f32(v_sum));\n        float32x4_t v_result = vcvtq_f32_s32(v_rounded);\n        \n        // Store the result in dst\n        vst1q_f32(&dst[i], v_result);\n    }\n    \n    // Handle remaining elements (if any)\n    for (; i < length; ++i) {\n        float sum = src1[i] + src2[i];\n        dst[i] = nearbyintf(sum); // Use nearbyintf for rounding to nearest integer\n    }\n}\n```"}
{"task_id": "SimdBench_20_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 floats from src1 and src2\n        float32x4_t v_src1 = vld1q_f32(&src1[i]);\n        float32x4_t v_src2 = vld1q_f32(&src2[i]);\n\n        // Perform element-wise addition\n        float32x4_t v_sum = vaddq_f32(v_src1, v_src2);\n\n        // Round to nearest integer using VRNDNQ_F32\n        float32x4_t v_rounded = vrndnq_f32(v_sum);\n\n        // Store the result into dst\n        vst1q_f32(&dst[i], v_rounded);\n    }\n\n    // Handle remaining elements (if any)\n    for (; i < length; ++i) {\n        dst[i] = nearbyintf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 3 < length; i += 4) {\n        // Load 4 floats from src1 and src2\n        float32x4_t v_src1 = vld1q_f32(&src1[i]);\n        float32x4_t v_src2 = vld1q_f32(&src2[i]);\n        \n        // Perform element-wise addition\n        float32x4_t v_sum = vaddq_f32(v_src1, v_src2);\n        \n        // Round to nearest integer (convert to int and back to float)\n        int32x4_t v_rounded = vcvtaq_s32_f32(v_sum);\n        float32x4_t v_result = vcvtq_f32_s32(v_rounded);\n        \n        // Store the result in dst\n        vst1q_f32(&dst[i], v_result);\n    }\n    \n    // Handle remaining elements (if any)\n    for (; i < length; ++i) {\n        float sum = src1[i] + src2[i];\n        dst[i] = nearbyintf(sum); // Use nearbyintf for scalar rounding\n    }\n}\n```"}
{"task_id": "SimdBench_21_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    const float32x4_t v_five = vdupq_n_f32(50.0f);\n    const float32x4_t v_minus_one = vdupq_n_f32(-1.0f);\n    const uint32x4_t v_index_mask = vdupq_n_u32(0x00000001); // Mask for checking even indices\n\n    size_t i = 0;\n\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 elements from src1 and src2\n        float32x4_t v_src1 = vld1q_f32(&src1[i]);\n        float32x4_t v_src2 = vld1q_f32(&src2[i]);\n\n        // Compute absolute difference\n        float32x4_t v_diff = vabdq_f32(v_src1, v_src2);\n\n        // Check if the absolute difference is within 50\n        uint32x4_t v_within_range = vcltq_f32(v_diff, v_five);\n\n        // Create index mask (i, i+1, i+2, i+3)\n        uint32x4_t v_indices = vaddq_u32(vdupq_n_u32(i), vmovl_u16(vcreate_u16(0, 1, 2, 3)));\n\n        // Check if indices are multiples of 2\n        uint32x4_t v_even_indices = vbicq_u32(v_indices, v_index_mask);\n\n        // Combine conditions: within range AND even indices\n        uint32x4_t v_condition = vandq_u32(v_within_range, vceqzq_u32(v_andq_u32(v_indices, v_index_mask)));\n\n        // Perform element-wise multiplication\n        float32x4_t v_mul = vmulq_f32(v_src1, v_src2);\n\n        // Round up towards positive infinity\n        float32x4_t v_rounded = vrndpq_f32(v_mul);\n\n        // Blend results based on condition\n        float32x4_t v_result = vbslq_f32(v_condition, v_rounded, v_minus_one);\n\n        // Store results to dst\n        vst1q_f32(&dst[i], v_result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; ++i) {\n        float diff = fabs(src1[i] - src2[i]);\n        if (diff < 50.0f && (i % 2 == 0)) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    const float32x4_t v_five = vdupq_n_f32(50.0f);\n    const float32x4_t v_minus_one = vdupq_n_f32(-1.0f);\n\n    for (size_t i = 0; i < length; i += 4) {\n        // Load 4 elements from src1 and src2\n        float32x4_t v_src1 = vld1q_f32(&src1[i]);\n        float32x4_t v_src2 = vld1q_f32(&src2[i]);\n\n        // Compute absolute difference\n        float32x4_t v_diff = vabdq_f32(v_src1, v_src2);\n\n        // Check if absolute difference is within 50\n        uint32x4_t mask_within_50 = vcltq_f32(v_diff, v_five);\n\n        // Check if index is a multiple of 2\n        uint32x4_t mask_index_multiple_of_2 = vmovq_n_u32(0);\n        mask_index_multiple_of_2 = vorrq_u32(mask_index_multiple_of_2, vmovq_n_u32((i + 0) % 2 == 0 ? 0xFFFFFFFF : 0));\n        mask_index_multiple_of_2 = vorrq_u32(mask_index_multiple_of_2, vmovq_n_u32((i + 1) % 2 == 0 ? 0xFFFFFFFF : 0));\n        mask_index_multiple_of_2 = vorrq_u32(mask_index_multiple_of_2, vmovq_n_u32((i + 2) % 2 == 0 ? 0xFFFFFFFF : 0));\n        mask_index_multiple_of_2 = vorrq_u32(mask_index_multiple_of_2, vmovq_n_u32((i + 3) % 2 == 0 ? 0xFFFFFFFF : 0));\n\n        // Combine masks\n        uint32x4_t mask_combined = vandq_u32(mask_within_50, mask_index_multiple_of_2);\n\n        // Perform element-wise multiplication\n        float32x4_t v_mul = vmulq_f32(v_src1, v_src2);\n\n        // Round up to positive infinity\n        float32x4_t v_rounded = vrndpq_f32(v_mul);\n\n        // Blend results: -1 for elements not meeting conditions\n        float32x4_t v_result = vbslq_f32(mask_combined, v_rounded, v_minus_one);\n\n        // Store the result into dst\n        vst1q_f32(&dst[i], v_result);\n    }\n\n    // Handle remaining elements (if any)\n    for (size_t i = (length / 4) * 4; i < length; ++i) {\n        float diff = std::abs(src1[i] - src2[i]);\n        if (diff < 50.0f && i % 2 == 0) {\n            dst[i] = std::ceil(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    const float32x4_t v_five = vdupq_n_f32(50.0f);\n    const float32x4_t v_minus_one = vdupq_n_f32(-1.0f);\n\n    size_t i = 0;\n\n    for (; i + 3 < length; i += 4) {\n        // Load 4 elements from src1 and src2\n        float32x4_t v_src1 = vld1q_f32(&src1[i]);\n        float32x4_t v_src2 = vld1q_f32(&src2[i]);\n\n        // Compute absolute difference\n        float32x4_t v_diff = vabdq_f32(v_src1, v_src2);\n\n        // Check if the absolute difference is within 50\n        uint32x4_t mask_within_50 = vcltq_f32(v_diff, v_five);\n\n        // Check if index is a multiple of 2 (i.e., even indices)\n        uint32x4_t mask_even_indices = vmovq_n_u32(0xAA); // Alternating bits: 10101010...\n\n        // Combine masks\n        uint32x4_t combined_mask = vandq_u32(mask_within_50, mask_even_indices);\n\n        // Perform element-wise multiplication\n        float32x4_t v_mul = vmulq_f32(v_src1, v_src2);\n\n        // Round up towards positive infinity\n        float32x4_t v_rounded = vrndpq_f32(v_mul);\n\n        // Blend results based on the mask (-1 for elements not meeting conditions)\n        float32x4_t v_result = vbslq_f32(combined_mask, v_rounded, v_minus_one);\n\n        // Store the result in dst\n        vst1q_f32(&dst[i], v_result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; ++i) {\n        float diff = fabs(src1[i] - src2[i]);\n        if (diff < 50.0f && (i % 2 == 0)) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    const float32x4_t v_five = vdupq_n_f32(50.0f);\n    const float32x4_t v_minus_one = vdupq_n_f32(-1.0f);\n\n    for (size_t i = 0; i + 4 <= length; i += 4) {\n        // Load 4 elements from src1 and src2\n        float32x4_t v_src1 = vld1q_f32(&src1[i]);\n        float32x4_t v_src2 = vld1q_f32(&src2[i]);\n\n        // Compute absolute difference\n        float32x4_t v_diff = vabdq_f32(v_src1, v_src2);\n\n        // Check if absolute difference is within 50\n        uint32x4_t v_mask_diff = vcleq_f32(v_diff, v_five);\n\n        // Check if index is a multiple of 2\n        uint32x4_t v_mask_index = vmovq_n_u32(0);\n        v_mask_index = vorrq_u32(v_mask_index, vmovq_n_u32((i % 2 == 0) ? 0xFFFFFFFF : 0));\n        v_mask_index = vorrq_u32(v_mask_index, vmovq_n_u32(((i + 1) % 2 == 0) ? 0xFFFFFFFF : 0));\n        v_mask_index = vorrq_u32(v_mask_index, vmovq_n_u32(((i + 2) % 2 == 0) ? 0xFFFFFFFF : 0));\n        v_mask_index = vorrq_u32(v_mask_index, vmovq_n_u32(((i + 3) % 2 == 0) ? 0xFFFFFFFF : 0));\n\n        // Combine masks\n        uint32x4_t v_mask_combined = vandq_u32(v_mask_diff, v_mask_index);\n\n        // Perform element-wise multiplication\n        float32x4_t v_mul = vmulq_f32(v_src1, v_src2);\n\n        // Round up towards positive infinity\n        float32x4_t v_ceil = vrndpq_f32(v_mul);\n\n        // Blend results: -1 for elements not meeting conditions\n        float32x4_t v_result = vbslq_f32(v_mask_combined, v_ceil, v_minus_one);\n\n        // Store the result into dst\n        vst1q_f32(&dst[i], v_result);\n    }\n\n    // Handle remaining elements\n    for (size_t i = length - (length % 4); i < length; ++i) {\n        float diff = std::abs(src1[i] - src2[i]);\n        if (diff <= 50.0f && i % 2 == 0) {\n            dst[i] = std::ceil(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    const float32x4_t v_five = vdupq_n_f32(50.0f);\n    const float32x4_t v_minus_one = vdupq_n_f32(-1.0f);\n    const uint32x4_t v_index_mask = vdupq_n_u32(0x00000001); // Mask to check if index is odd\n\n    for (size_t i = 0; i < length; i += 4) {\n        // Load 4 elements from src1 and src2\n        float32x4_t v_src1 = vld1q_f32(&src1[i]);\n        float32x4_t v_src2 = vld1q_f32(&src2[i]);\n\n        // Compute absolute difference\n        float32x4_t v_diff = vabdq_f32(v_src1, v_src2);\n\n        // Check if absolute difference is within 50\n        uint32x4_t v_diff_mask = vcltq_f32(v_diff, v_five);\n\n        // Create index mask for i, i+1, i+2, i+3\n        uint32x4_t v_indices = {i, i + 1, i + 2, i + 3};\n        uint32x4_t v_index_check = vandq_u32(v_indices, v_index_mask);\n        uint32x4_t v_even_mask = vceqzq_u32(v_index_check);\n\n        // Combine masks: both conditions must be true\n        uint32x4_t v_combined_mask = vandq_u32(v_diff_mask, v_even_mask);\n\n        // Perform element-wise multiplication\n        float32x4_t v_mul = vmulq_f32(v_src1, v_src2);\n\n        // Round up towards positive infinity\n        float32x4_t v_rounded = vrndpq_f32(v_mul);\n\n        // Blend results: use -1 where conditions are not met\n        float32x4_t v_result = vbslq_f32(v_combined_mask, v_rounded, v_minus_one);\n\n        // Store the result into dst\n        vst1q_f32(&dst[i], v_result);\n    }\n\n    // Handle remaining elements (if length is not a multiple of 4)\n    for (size_t i = (length / 4) * 4; i < length; ++i) {\n        if ((i % 2 == 0) && (fabs(src1[i] - src2[i]) < 50.0f)) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_22_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    float64x2_t vec_scalar = vmovq_n_f64(scalar);\n    size_t simd_width = 2;\n    size_t total_elements = m * n;\n\n    size_t i = 0;\n    for (; i + simd_width <= total_elements; i += simd_width) {\n        float64x2_t vec_mat = vld1q_f64(&mat[i]);\n        float64x2_t vec_result = vmulq_f64(vec_mat, vec_scalar);\n        vst1q_f64(&dst[i], vec_result);\n    }\n\n    for (; i < total_elements; ++i) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    float64x2_t vec_scalar = vmovq_n_f64(scalar);\n    size_t total_elements = m * n;\n\n    size_t i = 0;\n    for (; i + 1 < total_elements; i += 2) {\n        float64x2_t vec_mat = vld1q_f64(&mat[i]);\n        float64x2_t vec_result = vmulq_f64(vec_mat, vec_scalar);\n        vst1q_f64(&dst[i], vec_result);\n    }\n\n    for (; i < total_elements; ++i) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    float64x2_t vec_scalar = vmovq_n_f64(scalar);\n    size_t total_elements = m * n;\n\n    for (size_t i = 0; i < total_elements; i += 2) {\n        float64x2_t vec_mat = vld1q_f64(&mat[i]);\n        float64x2_t vec_result = vmulq_f64(vec_mat, vec_scalar);\n        vst1q_f64(&dst[i], vec_result);\n    }\n\n    // Handle any remaining elements if the total number of elements is odd\n    if (total_elements % 2 != 0) {\n        dst[total_elements - 1] = mat[total_elements - 1] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    float64x2_t vec_scalar = vmovq_n_f64(scalar);\n    size_t i, j;\n\n    for (i = 0; i < m; ++i) {\n        for (j = 0; j + 2 <= n; j += 2) {\n            float64x2_t vec_mat = vld1q_f64(&mat[i * n + j]);\n            float64x2_t vec_result = vmulq_f64(vec_mat, vec_scalar);\n            vst1q_f64(&dst[i * n + j], vec_result);\n        }\n\n        if (j < n) {\n            dst[i * n + j] = mat[i * n + j] * scalar;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_22_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    float64x2_t vec_scalar = vmovq_n_f64(scalar);\n\n    size_t i = 0;\n    for (; i + 1 < total_elements; i += 2) {\n        float64x2_t vec_mat = vld1q_f64(&mat[i]);\n        float64x2_t vec_result = vmulq_f64(vec_mat, vec_scalar);\n        vst1q_f64(&dst[i], vec_result);\n    }\n\n    for (; i < total_elements; ++i) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_23_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float* row = mat + i * n;\n        float32x4_t sum_sq = vmovq_n_f32(0.0f);\n\n        // Compute sum of squares using SIMD\n        size_t j = 0;\n        for (; j + 4 <= n; j += 4) {\n            float32x4_t vec = vld1q_f32(row + j);\n            sum_sq = vfmaq_f32(sum_sq, vec, vec);\n        }\n\n        // Horizontal add for the remaining elements\n        float sum = 0.0f;\n        for (; j < n; ++j) {\n            sum += row[j] * row[j];\n        }\n\n        // Horizontal add for the accumulated SIMD result\n        float32x2_t sum_sq_low = vadd_f32(vget_low_f32(sum_sq), vget_high_f32(sum_sq));\n        sum += vget_lane_f32(vpadd_f32(sum_sq_low, sum_sq_low), 0);\n\n        // Compute L2 norm\n        float norm = std::sqrt(sum);\n\n        // Normalize the row using SIMD\n        j = 0;\n        float32x4_t inv_norm = vmovq_n_f32(1.0f / norm);\n        for (; j + 4 <= n; j += 4) {\n            float32x4_t vec = vld1q_f32(row + j);\n            vec = vmulq_f32(vec, inv_norm);\n            vst1q_f32(row + j, vec);\n        }\n\n        // Normalize the remaining elements\n        for (; j < n; ++j) {\n            row[j] /= norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float* row = mat + i * n;\n        float32x4_t sum_vec = vmovq_n_f32(0.0f);\n\n        // Compute the sum of squares using SIMD\n        size_t j = 0;\n        for (; j + 4 <= n; j += 4) {\n            float32x4_t val = vld1q_f32(row + j);\n            sum_vec = vfmaq_f32(sum_vec, val, val);\n        }\n\n        // Horizontal sum of the vector\n        float sum = vaddvq_f32(sum_vec);\n\n        // Handle remaining elements\n        for (; j < n; ++j) {\n            sum += row[j] * row[j];\n        }\n\n        // Compute L2 norm\n        float norm = std::sqrt(sum);\n\n        // Normalize the row\n        j = 0;\n        float32x4_t norm_vec = vmovq_n_f32(norm);\n        for (; j + 4 <= n; j += 4) {\n            float32x4_t val = vld1q_f32(row + j);\n            float32x4_t normalized = vdivq_f32(val, norm_vec);\n            vst1q_f32(row + j, normalized);\n        }\n\n        // Handle remaining elements\n        for (; j < n; ++j) {\n            row[j] /= norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float* row = mat + i * n;\n        float32x4_t sum_sq = vmovq_n_f32(0.0f);\n\n        // Process 4 elements at a time using NEON intrinsics\n        size_t j = 0;\n        for (; j + 3 < n; j += 4) {\n            float32x4_t vec = vld1q_f32(row + j);\n            sum_sq = vfmaq_f32(sum_sq, vec, vec); // Multiply and accumulate: sum_sq += vec * vec\n        }\n\n        // Horizontal sum of the accumulated squared values in sum_sq\n        float32x2_t sum_sq_low = vadd_f32(vget_low_f32(sum_sq), vget_high_f32(sum_sq));\n        sum_sq_low = vpadd_f32(sum_sq_low, sum_sq_low);\n        float norm_sq = vget_lane_f32(sum_sq_low, 0);\n\n        // Handle remaining elements in the row (if n is not a multiple of 4)\n        for (; j < n; ++j) {\n            norm_sq += row[j] * row[j];\n        }\n\n        // Compute the L2 norm\n        float norm = std::sqrt(norm_sq);\n\n        // Normalize the row\n        j = 0;\n        float32x4_t inv_norm = vmovq_n_f32(1.0f / norm);\n        for (; j + 3 < n; j += 4) {\n            float32x4_t vec = vld1q_f32(row + j);\n            vec = vmulq_f32(vec, inv_norm);\n            vst1q_f32(row + j, vec);\n        }\n\n        // Normalize remaining elements in the row\n        for (; j < n; ++j) {\n            row[j] /= norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float* row = mat + i * n;\n        float32x4_t sum_sq = vmovq_n_f32(0.0f);\n\n        // Compute sum of squares using SIMD\n        size_t j = 0;\n        for (; j + 4 <= n; j += 4) {\n            float32x4_t vec = vld1q_f32(row + j);\n            sum_sq = vfmaq_f32(sum_sq, vec, vec);\n        }\n\n        // Horizontal add for the remaining elements\n        float sum = 0.0f;\n        for (; j < n; ++j) {\n            sum += row[j] * row[j];\n        }\n\n        // Sum up the partial sums from the SIMD register\n        float32x2_t sum_sq_low = vadd_f32(vget_low_f32(sum_sq), vget_high_f32(sum_sq));\n        sum += vget_lane_f32(vpadd_f32(sum_sq_low, sum_sq_low), 0);\n\n        // Compute L2 norm\n        float norm = std::sqrt(sum);\n\n        // Normalize the row using SIMD\n        j = 0;\n        float32x4_t norm_vec = vmovq_n_f32(norm);\n        for (; j + 4 <= n; j += 4) {\n            float32x4_t vec = vld1q_f32(row + j);\n            vec = vdivq_f32(vec, norm_vec);\n            vst1q_f32(row + j, vec);\n        }\n\n        // Normalize the remaining elements\n        for (; j < n; ++j) {\n            row[j] /= norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float* row = mat + i * n;\n        float32x4_t sum_sq = vmovq_n_f32(0.0f);\n\n        // Compute the sum of squares using SIMD\n        size_t j = 0;\n        for (; j + 3 < n; j += 4) {\n            float32x4_t vec = vld1q_f32(row + j);\n            sum_sq = vfmaq_f32(sum_sq, vec, vec);\n        }\n\n        // Horizontal add the partial sums in sum_sq\n        float32x2_t sum_sq_low = vadd_f32(vget_low_f32(sum_sq), vget_high_f32(sum_sq));\n        float norm_sq = vget_lane_f32(vpadd_f32(sum_sq_low, sum_sq_low), 0);\n\n        // Add remaining elements that didn't fit into SIMD registers\n        for (; j < n; ++j) {\n            norm_sq += row[j] * row[j];\n        }\n\n        // Compute the L2 norm\n        float norm = std::sqrt(norm_sq);\n\n        // Normalize the row using SIMD\n        j = 0;\n        float32x4_t inv_norm = vmovq_n_f32(1.0f / norm);\n        for (; j + 3 < n; j += 4) {\n            float32x4_t vec = vld1q_f32(row + j);\n            float32x4_t normalized = vmulq_f32(vec, inv_norm);\n            vst1q_f32(row + j, normalized);\n        }\n\n        // Normalize remaining elements\n        for (; j < n; ++j) {\n            row[j] /= norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            float64x2_t sum_vec = vdupq_n_f64(0.0);\n\n            size_t k = 0;\n            for (; k + 1 < n; k += 2) {\n                float64x2_t mat1_vec = vld1q_f64(&mat1[i * n + k]);\n                float64x2_t mat2_vec = vld1q_f64(&mat2[k * p + j]);\n\n                sum_vec = vfmaq_f64(sum_vec, mat1_vec, mat2_vec);\n            }\n\n            double sum = vaddvq_f64(sum_vec);\n\n            for (; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n\n            dst[i * p + j] = nearbyint(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            float64x2_t sum_vec = vdupq_n_f64(0.0);\n\n            size_t k = 0;\n            for (; k + 1 < n; k += 2) {\n                float64x2_t mat1_vec = vld1q_f64(&mat1[i * n + k]);\n                float64x2_t mat2_vec = vld1q_f64(&mat2[k * p + j]);\n\n                sum_vec = vfmaq_f64(sum_vec, mat1_vec, mat2_vec);\n            }\n\n            double sum = vaddvq_f64(sum_vec);\n\n            for (; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n\n            dst[i * p + j] = nearbyint(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            float64x2_t sum_vec = vdupq_n_f64(0.0);\n\n            for (size_t k = 0; k < n; k += 2) {\n                float64x2_t mat1_vec = vld1q_f64(&mat1[i * n + k]);\n                float64x2_t mat2_vec = vld1q_f64(&mat2[k * p + j]);\n\n                sum_vec = vfmaq_f64(sum_vec, mat1_vec, mat2_vec);\n            }\n\n            double sum = vaddvq_f64(sum_vec);\n\n            // Handle remaining elements if n is not a multiple of 2\n            for (size_t k = (n / 2) * 2; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n\n            // Round to nearest integer and store in dst\n            dst[i * p + j] = nearbyint(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            float64x2_t sum_vec = vdupq_n_f64(0.0);\n\n            size_t k = 0;\n            for (; k + 1 < n; k += 2) {\n                float64x2_t mat1_vec = vld1q_f64(&mat1[i * n + k]);\n                float64x2_t mat2_vec = vld1q_f64(&mat2[k * p + j]);\n\n                sum_vec = vfmaq_f64(sum_vec, mat1_vec, mat2_vec);\n            }\n\n            double sum = vaddvq_f64(sum_vec);\n\n            for (; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n\n            dst[i * p + j] = nearbyint(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            float64x2_t sum_vec = vdupq_n_f64(0.0);\n\n            size_t k = 0;\n            for (; k + 1 < n; k += 2) {\n                float64x2_t mat1_vec = vld1q_f64(&mat1[i * n + k]);\n                float64x2_t mat2_vec = vld1q_f64(&mat2[k * p + j]);\n\n                sum_vec = vfmaq_f64(sum_vec, mat1_vec, mat2_vec);\n            }\n\n            double sum = vaddvq_f64(sum_vec);\n\n            for (; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n\n            dst[i * p + j] = nearbyint(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    // Define constants for rounding to the nearest quarter\n    const float32x4_t quarter = vdupq_n_f32(0.25f);\n    const float32x4_t half_quarter = vdupq_n_f32(0.125f);\n\n    for (size_t row = 0; row < rows; row++) {\n        for (size_t col = 0; col < cols; col += 4) {\n            // Load 4 elements from the source matrix\n            float32x4_t src_vec = vld1q_f32(&src[row * cols + col]);\n\n            // Round to the nearest quarter: (x + 0.125) / 0.25\n            float32x4_t rounded = vmulq_f32(vaddq_f32(src_vec, half_quarter), quarter);\n\n            // Store the transposed result in the destination matrix\n            for (int i = 0; i < 4; i++) {\n                if (col + i < cols) {\n                    dst[(col + i) * rows + row] = vgetq_lane_f32(rounded, i);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    const float32x4_t quarter = vdupq_n_f32(0.25f);\n    const float32x4_t halfQuarter = vdupq_n_f32(0.125f);\n\n    for (size_t col = 0; col < cols; col += 4) {\n        for (size_t row = 0; row < rows; ++row) {\n            // Load 4 elements from the source matrix (row-major order)\n            float32x4_t srcVec;\n            if (col + 4 <= cols) {\n                srcVec = vld1q_f32(&src[row * cols + col]);\n            } else {\n                // Handle cases where fewer than 4 columns remain\n                float buffer[4] = {0};\n                for (size_t i = 0; i < cols - col; ++i) {\n                    buffer[i] = src[row * cols + col + i];\n                }\n                srcVec = vld1q_f32(buffer);\n            }\n\n            // Round to the nearest quarter\n            srcVec = vaddq_f32(srcVec, halfQuarter); // Add 0.125 for rounding\n            srcVec = vmulq_f32(srcVec, quarter);     // Multiply by 4\n            int32x4_t rounded = vcvtq_s32_f32(srcVec); // Convert to integer\n            srcVec = vcvtq_f32_s32(rounded);         // Convert back to float\n            srcVec = vmulq_f32(srcVec, quarter);     // Divide by 4\n\n            // Store transposed result into destination matrix (column-major order)\n            if (row % 4 == 0 && row + 4 <= rows) {\n                // Transpose and store 4x4 block\n                float32x4_t row1 = vld1q_f32(&src[(row + 0) * cols + col]);\n                float32x4_t row2 = vld1q_f32(&src[(row + 1) * cols + col]);\n                float32x4_t row3 = vld1q_f32(&src[(row + 2) * cols + col]);\n                float32x4_t row4 = vld1q_f32(&src[(row + 3) * cols + col]);\n\n                // Transpose 4x4 block\n                float32x4x2_t zip1 = vzipq_f32(row1, row2);\n                float32x4x2_t zip2 = vzipq_f32(row3, row4);\n                float32x4x2_t zip3 = vzipq_f32(zip1.val[0], zip2.val[0]);\n                float32x4x2_t zip4 = vzipq_f32(zip1.val[1], zip2.val[1]);\n\n                // Store transposed rows into destination\n                vst1q_f32(&dst[(col + 0) * rows + row], zip3.val[0]);\n                vst1q_f32(&dst[(col + 1) * rows + row], zip3.val[1]);\n                vst1q_f32(&dst[(col + 2) * rows + row], zip4.val[0]);\n                vst1q_f32(&dst[(col + 3) * rows + row], zip4.val[1]);\n            } else {\n                // Store individual elements for incomplete rows\n                for (size_t i = 0; i < 4; ++i) {\n                    if (col + i < cols) {\n                        dst[(col + i) * rows + row] = vgetq_lane_f32(srcVec, i);\n                    }\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    const float32x4_t quarter = vdupq_n_f32(0.25f);\n    const float32x4_t halfQuarter = vdupq_n_f32(0.125f);\n\n    for (size_t col = 0; col < cols; col += 4) {\n        for (size_t row = 0; row < rows; ++row) {\n            // Load 4 elements from the source matrix (row-major order)\n            float32x4_t srcVec = vld1q_f32(&src[row * cols + col]);\n\n            // Round to the nearest quarter\n            float32x4_t rounded = vmulq_f32(srcVec, quarter);\n            rounded = vaddq_f32(rounded, halfQuarter);\n            int32x4_t roundedInt = vcvtq_s32_f32(rounded);\n            rounded = vcvtq_f32_s32(roundedInt);\n            rounded = vmulq_f32(rounded, quarter);\n\n            // Store the transposed result into the destination matrix (column-major order)\n            for (int i = 0; i < 4 && (col + i) < cols; ++i) {\n                dst[(col + i) * rows + row] = vgetq_lane_f32(rounded, i);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    // Vector of 0.25 for rounding to the nearest quarter\n    const float32x4_t quarter = vdupq_n_f32(0.25f);\n    const float32x4_t two = vdupq_n_f32(2.0f);\n\n    for (size_t row = 0; row < rows; row++) {\n        for (size_t col = 0; col < cols; col += 4) {\n            // Load 4 elements from the source matrix\n            float32x4_t src_vec = vld1q_f32(&src[row * cols + col]);\n\n            // Multiply by 4 to scale up for rounding\n            float32x4_t scaled = vmulq_f32(src_vec, two);\n\n            // Add 0.5 for rounding\n            float32x4_t rounded = vaddq_f32(scaled, vdupq_n_f32(0.5f));\n\n            // Truncate to integer (effectively rounding)\n            int32x4_t truncated = vcvtq_s32_f32(rounded);\n\n            // Convert back to float and scale down\n            float32x4_t result = vcvtq_f32_s32(truncated);\n            result = vmulq_f32(result, quarter);\n\n            // Store the transposed result in the destination matrix\n            for (int i = 0; i < 4; i++) {\n                if (col + i < cols) {\n                    dst[(col + i) * rows + row] = vgetq_lane_f32(result, i);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    const float32x4_t quarter = vdupq_n_f32(0.25f);\n    const float32x4_t halfQuarter = vdupq_n_f32(0.125f);\n\n    for (size_t col = 0; col < cols; col += 4) {\n        for (size_t row = 0; row < rows; ++row) {\n            // Load 4 elements from the source matrix (row-major order)\n            float32x4_t srcVec = vld1q_f32(&src[row * cols + col]);\n\n            // Round to the nearest quarter: (x / 0.25 + 0.5) * 0.25\n            float32x4_t rounded = vmulq_f32(vaddq_f32(vdivq_f32(srcVec, quarter), halfQuarter), quarter);\n\n            // Store transposed result into destination matrix (column-major order)\n            vst1q_f32(&dst[col * rows + row], rounded);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n\n    size_t i = 0;\n    for (; i + 4 <= total_elements; i += 4) {\n        // Load 4 elements from tensor1 and tensor2\n        float32x4_t vec1 = vld1q_f32(&tensor1[i]);\n        float32x4_t vec2 = vld1q_f32(&tensor2[i]);\n\n        // Perform element-wise subtraction\n        float32x4_t result = vsubq_f32(vec1, vec2);\n\n        // Round towards zero using truncation\n        int32x4_t truncated = vcvtq_s32_f32(result);\n        float32x4_t rounded = vcvtq_f32_s32(truncated);\n\n        // Store the result into dst\n        vst1q_f32(&dst[i], rounded);\n    }\n\n    // Handle remaining elements (if any)\n    for (; i < total_elements; ++i) {\n        float diff = tensor1[i] - tensor2[i];\n        dst[i] = (diff >= 0.0f) ? floorf(diff) : ceilf(diff);\n    }\n}\n```"}
{"task_id": "SimdBench_26_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 3 < total_elements; i += 4) {\n        // Load 4 floats from tensor1 and tensor2\n        float32x4_t v_tensor1 = vld1q_f32(&tensor1[i]);\n        float32x4_t v_tensor2 = vld1q_f32(&tensor2[i]);\n\n        // Perform element-wise subtraction\n        float32x4_t v_sub = vsubq_f32(v_tensor1, v_tensor2);\n\n        // Round towards zero (truncate)\n        int32x4_t v_rounded = vcvtq_s32_f32(v_sub);\n        float32x4_t v_result = vcvtq_f32_s32(v_rounded);\n\n        // Store the result into dst\n        vst1q_f32(&dst[i], v_result);\n    }\n\n    // Handle remaining elements (if any) with scalar operations\n    for (; i < total_elements; ++i) {\n        float result = (float)((int)(tensor1[i] - tensor2[i]));\n        dst[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_26_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 4 <= total_elements; i += 4) {\n        // Load 4 floats from tensor1 and tensor2\n        float32x4_t v_tensor1 = vld1q_f32(tensor1 + i);\n        float32x4_t v_tensor2 = vld1q_f32(tensor2 + i);\n\n        // Perform element-wise subtraction\n        float32x4_t v_result = vsubq_f32(v_tensor1, v_tensor2);\n\n        // Round towards zero using truncation\n        int32x4_t v_truncated = vcvtq_s32_f32(v_result);\n        float32x4_t v_rounded = vcvtq_f32_s32(v_truncated);\n\n        // Store the result into dst\n        vst1q_f32(dst + i, v_rounded);\n    }\n\n    // Handle remaining elements (if any)\n    for (; i < total_elements; ++i) {\n        float result = tensor1[i] - tensor2[i];\n        dst[i] = (result > 0.0f) ? floorf(result) : ceilf(result);\n    }\n}\n```"}
{"task_id": "SimdBench_26_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n\n    size_t i = 0;\n    for (; i + 4 <= total_elements; i += 4) {\n        // Load 4 elements from tensor1 and tensor2\n        float32x4_t vec1 = vld1q_f32(tensor1 + i);\n        float32x4_t vec2 = vld1q_f32(tensor2 + i);\n\n        // Perform element-wise subtraction\n        float32x4_t result = vsubq_f32(vec1, vec2);\n\n        // Round towards zero using truncation\n        int32x4_t truncated = vcvtq_s32_f32(result);\n        float32x4_t rounded = vcvtq_f32_s32(truncated);\n\n        // Store the result in dst\n        vst1q_f32(dst + i, rounded);\n    }\n\n    // Handle remaining elements (if any)\n    for (; i < total_elements; ++i) {\n        float res = tensor1[i] - tensor2[i];\n        dst[i] = (res > 0.0f) ? floorf(res) : ceilf(res);\n    }\n}\n```"}
{"task_id": "SimdBench_26_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 4 <= total_elements; i += 4) {\n        // Load 4 floats from tensor1 and tensor2\n        float32x4_t v_tensor1 = vld1q_f32(tensor1 + i);\n        float32x4_t v_tensor2 = vld1q_f32(tensor2 + i);\n\n        // Perform element-wise subtraction\n        float32x4_t v_sub = vsubq_f32(v_tensor1, v_tensor2);\n\n        // Round towards zero (truncate)\n        int32x4_t v_rounded = vcvtq_s32_f32(v_sub);\n        float32x4_t v_result = vcvtq_f32_s32(v_rounded);\n\n        // Store the result into dst\n        vst1q_f32(dst + i, v_result);\n    }\n\n    // Handle remaining elements (if any)\n    for (; i < total_elements; ++i) {\n        float result = (float)((int)(tensor1[i] - tensor2[i]));\n        dst[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_27_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t simd_width = 2; // Number of doubles processed per NEON register (128-bit)\n    size_t simd_aligned_n = n - (n % simd_width);\n\n    for (size_t i = 0; i < m; ++i) {\n        size_t j = 0;\n\n        // Process elements in chunks of 2 using NEON intrinsics\n        for (; j < simd_aligned_n; j += simd_width) {\n            float64x2_t vec1 = vld1q_f64(&mat1[i * n + j]);\n            float64x2_t vec2 = vld1q_f64(&mat2[i * n + j]);\n            float64x2_t result = vmulq_f64(vec1, vec2);\n            vst1q_f64(&dst[i * n + j], result);\n        }\n\n        // Process remaining elements that don't fit into a full SIMD register\n        for (; j < n; ++j) {\n            dst[i * n + j] = mat1[i * n + j] * mat2[i * n + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_27_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t simd_width = 2; // Number of doubles processed per NEON register (128-bit)\n    size_t vec_size = n / simd_width * simd_width;\n\n    for (size_t i = 0; i < m; ++i) {\n        size_t j = 0;\n        // Process elements in chunks of 2 using NEON intrinsics\n        for (; j < vec_size; j += simd_width) {\n            float64x2_t v1 = vld1q_f64(&mat1[i * n + j]);\n            float64x2_t v2 = vld1q_f64(&mat2[i * n + j]);\n            float64x2_t result = vmulq_f64(v1, v2);\n            vst1q_f64(&dst[i * n + j], result);\n        }\n        // Handle remaining elements that don't fit into SIMD width\n        for (; j < n; ++j) {\n            dst[i * n + j] = mat1[i * n + j] * mat2[i * n + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_27_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t simd_width = 2; // Number of doubles processed per NEON register (128-bit)\n    size_t simd_aligned_n = n - (n % simd_width);\n\n    for (size_t i = 0; i < m; ++i) {\n        size_t j = 0;\n\n        // Process elements in chunks of 2 using NEON intrinsics\n        for (; j < simd_aligned_n; j += simd_width) {\n            float64x2_t vec1 = vld1q_f64(&mat1[i * n + j]);\n            float64x2_t vec2 = vld1q_f64(&mat2[i * n + j]);\n            float64x2_t result = vmulq_f64(vec1, vec2);\n            vst1q_f64(&dst[i * n + j], result);\n        }\n\n        // Handle remaining elements that don't fit into SIMD width\n        for (; j < n; ++j) {\n            dst[i * n + j] = mat1[i * n + j] * mat2[i * n + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_27_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t simd_width = 2; // Number of doubles processed per NEON register (128-bit)\n    size_t vec_size = n / simd_width * simd_width;\n\n    for (size_t i = 0; i < m; ++i) {\n        size_t j = 0;\n        // Process elements in chunks of 2 using NEON intrinsics\n        for (; j < vec_size; j += simd_width) {\n            float64x2_t v1 = vld1q_f64(&mat1[i * n + j]);\n            float64x2_t v2 = vld1q_f64(&mat2[i * n + j]);\n            float64x2_t result = vmulq_f64(v1, v2);\n            vst1q_f64(&dst[i * n + j], result);\n        }\n        // Handle remaining elements that don't fit into a full SIMD vector\n        for (; j < n; ++j) {\n            dst[i * n + j] = mat1[i * n + j] * mat2[i * n + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_27_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t simd_width = 2; // Number of doubles processed per NEON register (128-bit)\n    size_t simd_elements = n / simd_width;\n\n    for (size_t i = 0; i < m; ++i) {\n        size_t j = 0;\n        // Process elements in chunks of 2 using NEON intrinsics\n        for (; j < simd_elements * simd_width; j += simd_width) {\n            float64x2_t vec1 = vld1q_f64(&mat1[i * n + j]);\n            float64x2_t vec2 = vld1q_f64(&mat2[i * n + j]);\n            float64x2_t result = vmulq_f64(vec1, vec2);\n            vst1q_f64(&dst[i * n + j], result);\n        }\n        // Handle remaining elements that don't fit into SIMD width\n        for (; j < n; ++j) {\n            dst[i * n + j] = mat1[i * n + j] * mat2[i * n + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_28_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float32x4_t sum_vec = vdupq_n_f32(0.0f);\n        size_t j = 0;\n\n        // Process 4 elements at a time using NEON intrinsics\n        for (; j + 3 < n; j += 4) {\n            float32x4_t mat_row = vld1q_f32(&mat[i * n + j]);\n            float32x4_t vec_vals = vld1q_f32(&vec[j]);\n            sum_vec = vfmaq_f32(sum_vec, mat_row, vec_vals);\n        }\n\n        // Accumulate the partial sums into a single scalar\n        float sum = vaddvq_f32(sum_vec);\n\n        // Process any remaining elements\n        for (; j < n; ++j) {\n            sum += mat[i * n + j] * vec[j];\n        }\n\n        // Store the result in the destination vector\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float32x4_t sum_vec = vdupq_n_f32(0.0f);\n        size_t j = 0;\n\n        // Process 4 elements at a time using NEON intrinsics\n        for (; j + 3 < n; j += 4) {\n            float32x4_t mat_row = vld1q_f32(&mat[i * n + j]);\n            float32x4_t vec_vals = vld1q_f32(&vec[j]);\n            sum_vec = vfmaq_f32(sum_vec, mat_row, vec_vals);\n        }\n\n        // Horizontal sum of the NEON vector\n        float32x2_t sum_low_high = vpadd_f32(vget_low_f32(sum_vec), vget_high_f32(sum_vec));\n        float32x2_t sum_final = vpadd_f32(sum_low_high, sum_low_high);\n        float result = vget_lane_f32(sum_final, 0);\n\n        // Process remaining elements\n        for (; j < n; ++j) {\n            result += mat[i * n + j] * vec[j];\n        }\n\n        dst[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_28_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float32x4_t sum_vec = vdupq_n_f32(0.0f);\n        size_t j = 0;\n\n        // Process 4 elements at a time using NEON intrinsics\n        for (; j + 3 < n; j += 4) {\n            float32x4_t mat_row = vld1q_f32(&mat[i * n + j]);\n            float32x4_t vec_vals = vld1q_f32(&vec[j]);\n            sum_vec = vfmaq_f32(sum_vec, mat_row, vec_vals);\n        }\n\n        // Accumulate the partial sums into a single scalar\n        float sum = vaddvq_f32(sum_vec);\n\n        // Process remaining elements that didn't fit into the SIMD lanes\n        for (; j < n; ++j) {\n            sum += mat[i * n + j] * vec[j];\n        }\n\n        // Store the result in the destination vector\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float32x4_t sum_vec = vdupq_n_f32(0.0f);\n        size_t j = 0;\n\n        // Process 4 elements at a time using NEON intrinsics\n        for (; j + 3 < n; j += 4) {\n            float32x4_t mat_row = vld1q_f32(&mat[i * n + j]);\n            float32x4_t vec_vals = vld1q_f32(&vec[j]);\n            sum_vec = vfmaq_f32(sum_vec, mat_row, vec_vals);\n        }\n\n        // Horizontal add the partial sums in sum_vec\n        float32x2_t sum_low = vadd_f32(vget_low_f32(sum_vec), vget_high_f32(sum_vec));\n        sum_low = vpadd_f32(sum_low, sum_low);\n        float result = vget_lane_f32(sum_low, 0);\n\n        // Process remaining elements that didn't fit into the SIMD loop\n        for (; j < n; ++j) {\n            result += mat[i * n + j] * vec[j];\n        }\n\n        dst[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_28_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float32x4_t sum_vec = vdupq_n_f32(0.0f);\n        size_t j = 0;\n\n        // Process 4 elements at a time using NEON intrinsics\n        for (; j + 3 < n; j += 4) {\n            float32x4_t mat_row = vld1q_f32(&mat[i * n + j]);\n            float32x4_t vec_vals = vld1q_f32(&vec[j]);\n            sum_vec = vfmaq_f32(sum_vec, mat_row, vec_vals);\n        }\n\n        // Horizontal sum of the partial results in sum_vec\n        float32x2_t sum_low = vadd_f32(vget_low_f32(sum_vec), vget_high_f32(sum_vec));\n        sum_low = vpadd_f32(sum_low, sum_low);\n        float result = vget_lane_f32(sum_low, 0);\n\n        // Process remaining elements that didn't fit into the SIMD loop\n        for (; j < n; ++j) {\n            result += mat[i * n + j] * vec[j];\n        }\n\n        // Store the final result in the destination vector\n        dst[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_29_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t simd_elements = total_elements / 2 * 2; // Process in pairs for SIMD\n    float64x2_t vec_sum = vdupq_n_f64(0.0);        // Initialize sum vector to zero\n    double scalar_sum = 0.0;                       // For leftover elements\n\n    size_t i = 0;\n    // Process elements in chunks of 2 using SIMD\n    for (; i < simd_elements; i += 2) {\n        float64x2_t vec = vld1q_f64(&mat[i]);      // Load 2 doubles into a vector\n        vec_sum = vaddq_f64(vec_sum, vec);         // Accumulate the sum\n    }\n\n    // Sum the elements in the SIMD register\n    double simd_sum = vgetq_lane_f64(vec_sum, 0) + vgetq_lane_f64(vec_sum, 1);\n\n    // Handle any leftover elements\n    for (; i < total_elements; ++i) {\n        scalar_sum += mat[i];\n    }\n\n    // Compute the total sum and average\n    double total_sum = simd_sum + scalar_sum;\n    return total_sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t simd_elements = total_elements / 2 * 2; // Process in pairs for SIMD\n    float64x2_t sum_vec = vdupq_n_f64(0.0);        // Initialize sum vector to zero\n    double sum_scalar = 0.0;\n\n    size_t i = 0;\n    for (; i < simd_elements; i += 2) {\n        float64x2_t data = vld1q_f64(&mat[i]);     // Load two doubles into a vector\n        sum_vec = vaddq_f64(sum_vec, data);        // Accumulate the sum\n    }\n\n    // Horizontal add of the vector elements\n    sum_scalar += vgetq_lane_f64(sum_vec, 0) + vgetq_lane_f64(sum_vec, 1);\n\n    // Handle remaining elements (if total_elements is odd)\n    for (; i < total_elements; ++i) {\n        sum_scalar += mat[i];\n    }\n\n    return sum_scalar / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t simd_elements = total_elements / 2 * 2; // Process in pairs for SIMD\n    float64x2_t vec_sum = vdupq_n_f64(0.0);        // Initialize sum vector to zero\n    double scalar_sum = 0.0;                       // For leftover elements\n\n    size_t i = 0;\n    for (; i < simd_elements; i += 2) {\n        float64x2_t vec = vld1q_f64(&mat[i]);      // Load two doubles into a vector\n        vec_sum = vaddq_f64(vec_sum, vec);         // Accumulate the sum\n    }\n\n    // Handle leftover elements (if total_elements is odd)\n    for (; i < total_elements; ++i) {\n        scalar_sum += mat[i];\n    }\n\n    // Horizontal add of the vector sum\n    double sum = vaddvq_f64(vec_sum) + scalar_sum;\n\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t simd_elements = total_elements / 2 * 2; // Process in pairs for SIMD\n    float64x2_t vec_sum = vdupq_n_f64(0.0);        // Initialize sum vector to zero\n    double scalar_sum = 0.0;                       // For leftover elements\n\n    size_t i = 0;\n    // Process elements in chunks of 2 using SIMD\n    for (; i < simd_elements; i += 2) {\n        float64x2_t vec = vld1q_f64(&mat[i]);      // Load 2 doubles into a vector\n        vec_sum = vaddq_f64(vec_sum, vec);         // Accumulate the sum\n    }\n\n    // Add up the values in the SIMD register\n    double simd_sum = vaddvq_f64(vec_sum);\n\n    // Handle any leftover elements\n    for (; i < total_elements; ++i) {\n        scalar_sum += mat[i];\n    }\n\n    // Compute the total sum and average\n    double total_sum = simd_sum + scalar_sum;\n    return total_sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t simd_elements = total_elements / 2 * 2; // Process in pairs for SIMD\n    float64x2_t vec_sum = vdupq_n_f64(0.0);        // Initialize sum vector to zero\n    size_t i = 0;\n\n    // Process elements in chunks of 2 using NEON intrinsics\n    for (; i < simd_elements; i += 2) {\n        float64x2_t vec = vld1q_f64(&mat[i]);      // Load 2 doubles into a vector\n        vec_sum = vaddq_f64(vec_sum, vec);         // Accumulate the sum\n    }\n\n    // Horizontal sum of the accumulated vector\n    double sum = vaddvq_f64(vec_sum);\n\n    // Add remaining elements that couldn't be processed in pairs\n    for (; i < total_elements; ++i) {\n        sum += mat[i];\n    }\n\n    // Calculate and return the average\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_30_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        bool ascending = directions[i];\n        size_t j = 0;\n\n        // Process 4 elements at a time using NEON intrinsics\n        for (; j <= cols - 4; j += 4) {\n            int32x4_t current = vld1q_s32(row + j);\n            int32x4_t next = vld1q_s32(row + j + 1);\n\n            uint32x4_t mask;\n            if (ascending) {\n                mask = vcltq_s32(current, next); // Check if current < next\n            } else {\n                mask = vcgtq_s32(current, next); // Check if current > next\n            }\n\n            if (vmaxvq_u32(mask) != 0) { // If any element violates the order\n                return false;\n            }\n        }\n\n        // Process remaining elements\n        for (; j < cols - 1; ++j) {\n            if ((ascending && row[j] > row[j + 1]) || (!ascending && row[j] < row[j + 1])) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        bool ascending = directions[i];\n        size_t j = 0;\n\n        if (ascending) {\n            for (; j <= cols - 4; j += 4) {\n                int32x4_t current = vld1q_s32(row + j);\n                int32x4_t next = vld1q_s32(row + j + 1);\n\n                uint32x4_t mask = vcgtq_s32(current, next);\n                if (vmaxvq_u32(mask) != 0) {\n                    return false;\n                }\n            }\n        } else {\n            for (; j <= cols - 4; j += 4) {\n                int32x4_t current = vld1q_s32(row + j);\n                int32x4_t next = vld1q_s32(row + j + 1);\n\n                uint32x4_t mask = vcltq_s32(current, next);\n                if (vmaxvq_u32(mask) != 0) {\n                    return false;\n                }\n            }\n        }\n\n        for (; j < cols - 1; ++j) {\n            if ((ascending && row[j] > row[j + 1]) || (!ascending && row[j] < row[j + 1])) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        bool ascending = directions[i];\n        size_t j = 0;\n\n        // Process 4 elements at a time using NEON intrinsics\n        for (; j <= cols - 4; j += 4) {\n            int32x4_t current = vld1q_s32(row + j);\n            int32x4_t next = vld1q_s32(row + j + 1);\n\n            uint32x4_t mask;\n            if (ascending) {\n                mask = vcltq_s32(current, next); // Check if current < next\n            } else {\n                mask = vcgtq_s32(current, next); // Check if current > next\n            }\n\n            if (vaddvq_u32(mask) != 4) { // If any element fails the condition\n                return false;\n            }\n        }\n\n        // Process remaining elements\n        for (; j < cols - 1; ++j) {\n            if ((ascending && row[j] >= row[j + 1]) || (!ascending && row[j] <= row[j + 1])) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        bool ascending = directions[i];\n        size_t j = 0;\n\n        // Process 4 elements at a time using NEON intrinsics\n        for (; j <= cols - 4; j += 4) {\n            int32x4_t current = vld1q_s32(row + j);\n            int32x4_t next = vld1q_s32(row + j + 1);\n\n            uint32x4_t mask;\n            if (ascending) {\n                mask = vcltq_s32(current, next); // Check if current < next\n            } else {\n                mask = vcgtq_s32(current, next); // Check if current > next\n            }\n\n            if (vaddvq_u32(mask) != 4) { // If any element fails the condition\n                return false;\n            }\n        }\n\n        // Process remaining elements\n        for (; j < cols - 1; ++j) {\n            if ((ascending && row[j] >= row[j + 1]) || (!ascending && row[j] <= row[j + 1])) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        bool ascending = directions[i];\n        size_t j = 0;\n\n        // Process 4 elements at a time using NEON intrinsics\n        for (; j <= cols - 4; j += 4) {\n            int32x4_t current = vld1q_s32(row + j);\n            int32x4_t next = vld1q_s32(row + j + 1);\n\n            uint32x4_t cmp;\n            if (ascending) {\n                cmp = vcltq_s32(current, next); // Check if current < next\n            } else {\n                cmp = vcgtq_s32(current, next); // Check if current > next\n            }\n\n            uint64x2_t cmp_pairs = vreinterpretq_u64_u32(cmp);\n            if (vgetq_lane_u64(cmp_pairs, 0) != 0xFFFFFFFFFFFFFFFF || \n                vgetq_lane_u64(cmp_pairs, 1) != 0xFFFFFFFFFFFFFFFF) {\n                return false;\n            }\n        }\n\n        // Process remaining elements\n        for (; j < cols - 1; ++j) {\n            if ((ascending && row[j] >= row[j + 1]) || (!ascending && row[j] <= row[j + 1])) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_31_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    const int16x8_t vbase = vmovq_n_s16(base);\n    const int16x8_t vzero = vmovq_n_s16(0);\n\n    size_t i = 0;\n    for (; i + 8 <= length; i += 8) {\n        // Load 8 elements from the source array\n        int16x8_t vsrc = vld1q_s16(&src[i]);\n\n        // Compute the quotient (vsrc / base) using division\n        int16x8_t vquotient = vdivq_s16(vsrc, vbase);\n\n        // Multiply the quotient by base to get the nearest multiple of base\n        int16x8_t vmultiple = vmulq_s16(vquotient, vbase);\n\n        // Ensure the result is not greater than the original value\n        int16x8_t vresult = vminq_s16(vmultiple, vsrc);\n\n        // Store the result into the destination array\n        vst1q_s16(&dst[i], vresult);\n    }\n\n    // Handle any remaining elements\n    for (; i < length; ++i) {\n        int16_t quotient = src[i] / base;\n        dst[i] = (int16_t)(quotient * base);\n    }\n}\n```"}
{"task_id": "SimdBench_31_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    const int16x8_t vbase = vmovq_n_s16(base);\n    const int16x8_t vzero = vmovq_n_s16(0);\n\n    size_t i = 0;\n    for (; i + 8 <= length; i += 8) {\n        // Load 8 elements from src\n        int16x8_t vsrc = vld1q_s16(&src[i]);\n\n        // Compute quotient (vsrc / base) using division\n        int16x8_t vquotient = vdivq_s16(vsrc, vbase);\n\n        // Compute the nearest multiple of base no greater than src\n        int16x8_t vmultiple = vmulq_s16(vquotient, vbase);\n\n        // Store the result into dst\n        vst1q_s16(&dst[i], vmultiple);\n    }\n\n    // Handle remaining elements\n    for (; i < length; ++i) {\n        int16_t quotient = src[i] / base;\n        dst[i] = quotient * base;\n    }\n}\n```"}
{"task_id": "SimdBench_31_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    const int16x8_t vbase = vdupq_n_s16(base);\n    size_t i = 0;\n\n    for (; i + 8 <= length; i += 8) {\n        // Load 8 elements from the source array\n        int16x8_t vsrc = vld1q_s16(&src[i]);\n\n        // Compute the quotient (vsrc / base) using division\n        int16x8_t vquotient = vdivq_s16(vsrc, vbase);\n\n        // Multiply the quotient by base to get the nearest multiple of base\n        int16x8_t vmultiple = vmulq_s16(vquotient, vbase);\n\n        // Store the result into the destination array\n        vst1q_s16(&dst[i], vmultiple);\n    }\n\n    // Handle remaining elements\n    for (; i < length; ++i) {\n        dst[i] = (src[i] / base) * base;\n    }\n}\n```"}
{"task_id": "SimdBench_31_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    const int16x8_t vbase = vmovq_n_s16(base);\n    const int16x8_t vzero = vmovq_n_s16(0);\n\n    size_t i = 0;\n    for (; i + 8 <= length; i += 8) {\n        // Load 8 elements from the source array\n        int16x8_t vsrc = vld1q_s16(&src[i]);\n\n        // Compute the quotient (vsrc / base) using division\n        int16x8_t vquotient = vdivq_s16(vsrc, vbase);\n\n        // Multiply the quotient by base to get the nearest multiple of base\n        int16x8_t vmultiple = vmulq_s16(vquotient, vbase);\n\n        // Ensure the result does not exceed the original value in src\n        int16x8_t vresult = vminq_s16(vmultiple, vsrc);\n\n        // Store the result into the destination array\n        vst1q_s16(&dst[i], vresult);\n    }\n\n    // Handle any remaining elements\n    for (; i < length; ++i) {\n        int16_t quotient = src[i] / base;\n        dst[i] = quotient * base;\n    }\n}\n```"}
{"task_id": "SimdBench_31_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    const int16x8_t vbase = vdupq_n_s16(base);\n    const int16x8_t vzero = vdupq_n_s16(0);\n\n    size_t i = 0;\n    for (; i + 8 <= length; i += 8) {\n        // Load 8 elements from src\n        int16x8_t vsrc = vld1q_s16(&src[i]);\n\n        // Compute the quotient (vsrc / base) using division\n        int16x8_t vquotient = vdivq_s16(vsrc, vbase);\n\n        // Multiply the quotient by base to get the nearest multiple of base\n        int16x8_t vmultiple = vmulq_s16(vquotient, vbase);\n\n        // Ensure the result does not exceed the original value in src\n        int16x8_t vresult = vminq_s16(vmultiple, vsrc);\n\n        // Store the result into dst\n        vst1q_s16(&dst[i], vresult);\n    }\n\n    // Handle remaining elements\n    for (; i < length; ++i) {\n        int16_t quotient = src[i] / base;\n        dst[i] = quotient * base;\n    }\n}\n```"}
{"task_id": "SimdBench_32_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool match = true;\n        size_t j = 0;\n\n        // Process 2 elements at a time using Neon intrinsics\n        for (; j + 1 < cols; j += 2) {\n            float64x2_t vec_matrix = vld1q_f64(&matrix[i * cols + j]);\n            float64x2_t vec_vector = vld1q_f64(&vector[j]);\n            uint64x2_t cmp_result = vceqq_f64(vec_matrix, vec_vector);\n\n            if (vgetq_lane_u64(cmp_result, 0) == 0 || vgetq_lane_u64(cmp_result, 1) == 0) {\n                match = false;\n                break;\n            }\n        }\n\n        // Process remaining elements (if any)\n        for (; j < cols; ++j) {\n            if (matrix[i * cols + j] != vector[j]) {\n                match = false;\n                break;\n            }\n        }\n\n        if (match) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool match = true;\n        size_t j = 0;\n\n        // Process 2 elements at a time using Neon intrinsics\n        for (; j + 1 < cols; j += 2) {\n            float64x2_t vec_matrix = vld1q_f64(&matrix[i * cols + j]);\n            float64x2_t vec_vector = vld1q_f64(&vector[j]);\n            uint64x2_t cmp_result = vceqq_f64(vec_matrix, vec_vector);\n\n            if (vgetq_lane_u64(cmp_result, 0) == 0 || vgetq_lane_u64(cmp_result, 1) == 0) {\n                match = false;\n                break;\n            }\n        }\n\n        // Process remaining elements (if any)\n        for (; j < cols; ++j) {\n            if (matrix[i * cols + j] != vector[j]) {\n                match = false;\n                break;\n            }\n        }\n\n        if (match) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    // Ensure cols is a multiple of 2 for SIMD processing\n    size_t simd_cols = cols - (cols % 2);\n\n    // Load the vector into SIMD registers\n    float64x2_t vec_part1 = vld1q_f64(vector);\n    float64x2_t vec_part2 = vld1q_f64(vector + 2);\n\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row = matrix + i * cols;\n        bool match = true;\n\n        // Compare using SIMD for chunks of 2 elements\n        for (size_t j = 0; j < simd_cols; j += 2) {\n            float64x2_t row_part = vld1q_f64(row + j);\n            uint64x2_t cmp_result = vceqq_f64(row_part, vec_part1);\n\n            if (vgetq_lane_u64(cmp_result, 0) == 0 || vgetq_lane_u64(cmp_result, 1) == 0) {\n                match = false;\n                break;\n            }\n        }\n\n        // Handle remaining elements (if any)\n        for (size_t j = simd_cols; j < cols; ++j) {\n            if (row[j] != vector[j]) {\n                match = false;\n                break;\n            }\n        }\n\n        if (match) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool match = true;\n        size_t j = 0;\n\n        // Process 2 elements at a time using Neon intrinsics\n        for (; j + 1 < cols; j += 2) {\n            float64x2_t vec_matrix = vld1q_f64(&matrix[i * cols + j]);\n            float64x2_t vec_vector = vld1q_f64(&vector[j]);\n            uint64x2_t comparison = vceqq_f64(vec_matrix, vec_vector);\n\n            if (vgetq_lane_u64(comparison, 0) == 0 || vgetq_lane_u64(comparison, 1) == 0) {\n                match = false;\n                break;\n            }\n        }\n\n        // Process remaining elements (if any)\n        for (; j < cols; ++j) {\n            if (matrix[i * cols + j] != vector[j]) {\n                match = false;\n                break;\n            }\n        }\n\n        if (match) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool match = true;\n        size_t j = 0;\n\n        // Process 2 elements at a time using Neon intrinsics\n        for (; j + 1 < cols; j += 2) {\n            float64x2_t vec_matrix = vld1q_f64(&matrix[i * cols + j]);\n            float64x2_t vec_vector = vld1q_f64(&vector[j]);\n            uint64x2_t comparison = vceqq_f64(vec_matrix, vec_vector);\n\n            if (vgetq_lane_u64(comparison, 0) == 0 || vgetq_lane_u64(comparison, 1) == 0) {\n                match = false;\n                break;\n            }\n        }\n\n        // Process remaining elements (if any)\n        for (; j < cols; ++j) {\n            if (matrix[i * cols + j] != vector[j]) {\n                match = false;\n                break;\n            }\n        }\n\n        if (match) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_33_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t i = 0;\n    size_t equal_count = 0;\n\n    // Process 16 elements at a time using NEON intrinsics\n    for (; i <= total_elements - 16; i += 16) {\n        // Load 16 elements from A and B into NEON registers\n        uint8x16_t vecA = vld1q_u8(&A[i]);\n        uint8x16_t vecB = vld1q_u8(&B[i]);\n\n        // Compare the two vectors for equality\n        uint8x16_t cmp = vceqq_u8(vecA, vecB);\n\n        // Count the number of true (equal) elements in the comparison result\n        uint8x16_t mask = vandq_u8(cmp, vdupq_n_u8(1));\n        uint16x8_t sum1 = vpaddlq_u8(mask);\n        uint32x4_t sum2 = vpaddlq_u16(sum1);\n        uint64x2_t sum3 = vpaddlq_u32(sum2);\n\n        // Extract the counts from the NEON register\n        equal_count += vgetq_lane_u64(sum3, 0) + vgetq_lane_u64(sum3, 1);\n    }\n\n    // Process remaining elements sequentially\n    for (; i < total_elements; ++i) {\n        if (A[i] == B[i]) {\n            ++equal_count;\n        }\n    }\n\n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_33_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    size_t i = 0;\n    for (; i + 16 <= total_elements; i += 16) {\n        uint8x16_t vecA = vld1q_u8(&A[i]);\n        uint8x16_t vecB = vld1q_u8(&B[i]);\n\n        uint8x16_t cmp = vceqq_u8(vecA, vecB);\n        uint8x16_t mask = vandq_u8(cmp, vdupq_n_u8(1));\n\n        uint8x8_t sum_low = vpadd_u8(vget_low_u8(mask), vget_high_u8(mask));\n        uint8x8_t sum_high = vpadd_u8(sum_low, sum_low);\n        uint8x8_t sum_final = vpadd_u8(sum_high, sum_high);\n\n        count += vget_lane_u8(sum_final, 0);\n    }\n\n    for (; i < total_elements; ++i) {\n        if (A[i] == B[i]) {\n            ++count;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t i = 0;\n    size_t equal_count = 0;\n\n    // Process 16 elements at a time using NEON intrinsics\n    for (; i <= total_elements - 16; i += 16) {\n        uint8x16_t vecA = vld1q_u8(&A[i]);\n        uint8x16_t vecB = vld1q_u8(&B[i]);\n\n        // Compare the two vectors for equality\n        uint8x16_t cmp = vceqq_u8(vecA, vecB);\n\n        // Count the number of true (equal) elements in the comparison result\n        uint8x16_t mask = vandq_u8(cmp, vdupq_n_u8(1));\n        uint8x8_t sum1 = vpadd_u8(vget_low_u8(mask), vget_high_u8(mask));\n        uint8x8_t sum2 = vpadd_u8(sum1, sum1);\n        uint8x8_t sum3 = vpadd_u8(sum2, sum2);\n        uint32x2_t sum4 = vpaddl_u8(sum3);\n\n        // Add the results to the total count\n        equal_count += vget_lane_u32(sum4, 0);\n    }\n\n    // Process remaining elements\n    for (; i < total_elements; ++i) {\n        if (A[i] == B[i]) {\n            ++equal_count;\n        }\n    }\n\n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_33_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t i = 0;\n    size_t equal_count = 0;\n\n    // Process 16 elements at a time using NEON intrinsics\n    for (; i <= total_elements - 16; i += 16) {\n        // Load 16 elements from A and B\n        uint8x16_t vecA = vld1q_u8(&A[i]);\n        uint8x16_t vecB = vld1q_u8(&B[i]);\n\n        // Compare for equality\n        uint8x16_t cmp = vceqq_u8(vecA, vecB);\n\n        // Count the number of true values (each true is represented as 0xFF)\n        uint8x16_t mask = vdupq_n_u8(0x1);\n        uint8x16_t masked_cmp = vandq_u8(cmp, mask);\n\n        // Sum across lanes\n        uint16x8_t sum1 = vpaddlq_u8(masked_cmp);\n        uint32x4_t sum2 = vpaddlq_u16(sum1);\n        uint64x2_t sum3 = vpaddlq_u32(sum2);\n\n        // Extract the final count\n        uint64_t result = vgetq_lane_u64(sum3, 0) + vgetq_lane_u64(sum3, 1);\n        equal_count += result;\n    }\n\n    // Process remaining elements\n    for (; i < total_elements; ++i) {\n        if (A[i] == B[i]) {\n            ++equal_count;\n        }\n    }\n\n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_33_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t i = 0;\n    size_t equal_count = 0;\n\n    // Process 16 elements at a time using NEON intrinsics\n    for (; i <= total_elements - 16; i += 16) {\n        // Load 16 elements from A and B into NEON registers\n        uint8x16_t vecA = vld1q_u8(&A[i]);\n        uint8x16_t vecB = vld1q_u8(&B[i]);\n\n        // Compare the two vectors for equality\n        uint8x16_t cmpResult = vceqq_u8(vecA, vecB);\n\n        // Convert the comparison result to 16-bit values\n        uint16x8_t cmpLow = vmovl_u8(vget_low_u8(cmpResult));\n        uint16x8_t cmpHigh = vmovl_u8(vget_high_u8(cmpResult));\n\n        // Add up the low and high parts\n        uint32x4_t sumLow = vpaddlq_u16(cmpLow);\n        uint32x4_t sumHigh = vpaddlq_u16(cmpHigh);\n\n        // Combine the sums into a single vector\n        uint32x4_t totalSum = vaddq_u32(sumLow, sumHigh);\n\n        // Extract the counts from the vector and add to the total count\n        uint64x2_t totalSum64 = vpaddlq_u32(totalSum);\n        equal_count += vgetq_lane_u64(totalSum64, 0) + vgetq_lane_u64(totalSum64, 1);\n    }\n\n    // Process remaining elements (if any)\n    for (; i < total_elements; ++i) {\n        if (A[i] == B[i]) {\n            ++equal_count;\n        }\n    }\n\n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_34_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    int64x2_t va = vdupq_n_s64(a);\n\n    for (; i + 2 <= length; i += 2) {\n        int64x2_t vx = vld1q_s64(&x[i]);\n        int64x2_t vy = vld1q_s64(&y[i]);\n\n        int64x2_t vmul = vmulq_s64(va, vx);\n        int64x2_t vabs = vabsq_s64(vy);\n        int64x2_t vsub = vsubq_s64(vmul, vabs);\n\n        vst1q_s64(&y[i], vsub);\n    }\n\n    for (; i < length; ++i) {\n        y[i] = a * x[i] - llabs(y[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_34_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    int64x2_t va = vdupq_n_s64(a); // Broadcast scalar 'a' to all lanes of the vector\n\n    // Process 2 elements at a time (128-bit register for int64)\n    for (; i + 1 < length; i += 2) {\n        int64x2_t vx = vld1q_s64(&x[i]);       // Load 2 elements from x\n        int64x2_t vmul = vmulq_s64(va, vx);    // Multiply: a * x\n        int64x2_t vy = vld1q_s64(&y[i]);       // Load 2 elements from y\n        int64x2_t vabs = vabsq_s64(vy);        // Absolute value of y\n        int64x2_t vsub = vsubq_s64(vmul, vabs);// Subtract: (a * x) - abs(y)\n        vst1q_s64(&y[i], vsub);                // Store result back to y\n    }\n\n    // Handle remaining elements (if length is odd)\n    for (; i < length; ++i) {\n        y[i] = a * x[i] - llabs(y[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_34_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    int64x2_t va = vdupq_n_s64(a);\n\n    for (; i + 2 <= length; i += 2) {\n        int64x2_t vx = vld1q_s64(&x[i]);\n        int64x2_t vy = vld1q_s64(&y[i]);\n\n        int64x2_t vmul = vmulq_s64(va, vx);\n        int64x2_t vabs = vabsq_s64(vy);\n        int64x2_t vsub = vsubq_s64(vmul, vabs);\n\n        vst1q_s64(&y[i], vsub);\n    }\n\n    for (; i < length; ++i) {\n        y[i] = a * x[i] - llabs(y[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_34_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    int64x2_t va = vdupq_n_s64(a); // Broadcast scalar 'a' to all lanes of the vector\n\n    // Process 2 elements at a time (128-bit register for int64)\n    for (; i + 1 < length; i += 2) {\n        int64x2_t vx = vld1q_s64(&x[i]); // Load 2 elements from x\n        int64x2_t vy = vld1q_s64(&y[i]); // Load 2 elements from y\n\n        // Perform scalar-vector multiplication: a * x\n        int64x2_t vmul = vmulq_s64(va, vx);\n\n        // Compute absolute value of y\n        int64x2_t vabs = vabsq_s64(vy);\n\n        // Perform element-wise subtraction: (a * x) - |y|\n        int64x2_t vsub = vsubq_s64(vmul, vabs);\n\n        // Store the result back to y\n        vst1q_s64(&y[i], vsub);\n    }\n\n    // Handle remaining elements (if length is not a multiple of 2)\n    for (; i < length; ++i) {\n        y[i] = (a * x[i]) - llabs(y[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_34_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    int64x2_t va = vdupq_n_s64(a);\n\n    for (; i + 2 <= length; i += 2) {\n        int64x2_t vx = vld1q_s64(&x[i]);\n        int64x2_t vy = vld1q_s64(&y[i]);\n\n        int64x2_t vmul = vmulq_s64(va, vx);\n        int64x2_t vabs = vabsq_s64(vy);\n        int64x2_t vsub = vsubq_s64(vmul, vabs);\n\n        vst1q_s64(&y[i], vsub);\n    }\n\n    for (; i < length; ++i) {\n        y[i] = a * x[i] - llabs(y[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_35_Neon", "completion": "```c\n#include <arm_neon.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    int16_t min_val = 32767;\n    int16_t max_val = -32768;\n\n    size_t i = 0;\n\n    // Process 8 elements at a time using NEON intrinsics\n    for (; i <= length - 8; i += 8) {\n        // Load 8 elements into a NEON register\n        int16x8_t v = vld1q_s16(&vec[i]);\n\n        // Compute the minimum and maximum values in the vector\n        int16x8_t vmin = vpminq_s16(v, v);\n        vmin = vpminq_s16(vmin, vmin);\n        vmin = vpminq_s16(vmin, vmin);\n\n        int16x8_t vmax = vpmaxq_s16(v, v);\n        vmax = vpmaxq_s16(vmax, vmax);\n        vmax = vpmaxq_s16(vmax, vmax);\n\n        // Extract the minimum and maximum values from the NEON register\n        int16_t min_temp = vmin[0];\n        int16_t max_temp = vmax[0];\n\n        // Update the overall minimum and maximum values\n        if (min_temp < min_val) min_val = min_temp;\n        if (max_temp > max_val) max_val = max_temp;\n    }\n\n    // Process any remaining elements\n    for (; i < length; ++i) {\n        if (vec[i] < min_val) min_val = vec[i];\n        if (vec[i] > max_val) max_val = vec[i];\n    }\n\n    result.min_num = min_val;\n    result.max_num = max_val;\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_Neon", "completion": "```c\n#include <arm_neon.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    int16_t min_val = 32767;\n    int16_t max_val = -32768;\n\n    size_t i = 0;\n\n    // Process 8 elements at a time using NEON intrinsics\n    for (; i + 8 <= length; i += 8) {\n        // Load 8 values from the vector into a NEON register\n        int16x8_t v = vld1q_s16(&vec[i]);\n\n        // Compute the minimum and maximum values in the register\n        int16x8_t vmin = vpminq_s16(v, v);\n        vmin = vpminq_s16(vmin, vmin);\n        vmin = vpminq_s16(vmin, vmin);\n\n        int16x8_t vmax = vpmaxq_s16(v, v);\n        vmax = vpmaxq_s16(vmax, vmax);\n        vmax = vpmaxq_s16(vmax, vmax);\n\n        // Extract the minimum and maximum values from the NEON register\n        int16_t min_temp = vmin[0];\n        int16_t max_temp = vmax[0];\n\n        // Update the overall minimum and maximum\n        if (min_temp < min_val) min_val = min_temp;\n        if (max_temp > max_val) max_val = max_temp;\n    }\n\n    // Process any remaining elements\n    for (; i < length; ++i) {\n        if (vec[i] < min_val) min_val = vec[i];\n        if (vec[i] > max_val) max_val = vec[i];\n    }\n\n    result.min_num = min_val;\n    result.max_num = max_val;\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_Neon", "completion": "```c\n#include <arm_neon.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    int16_t min_val = INT16_MAX;\n    int16_t max_val = INT16_MIN;\n\n    size_t i = 0;\n\n    // Process 8 elements at a time using NEON intrinsics\n    for (; i <= length - 8; i += 8) {\n        // Load 8 elements into a NEON register\n        int16x8_t v = vld1q_s16(&vec[i]);\n\n        // Compute the minimum and maximum values in the vector\n        int16x8_t vmin = vpminq_s16(v, v);\n        vmin = vpminq_s16(vmin, vmin);\n        vmin = vpminq_s16(vmin, vmin);\n\n        int16x8_t vmax = vpmaxq_s16(v, v);\n        vmax = vpmaxq_s16(vmax, vmax);\n        vmax = vpmaxq_s16(vmax, vmax);\n\n        // Extract the minimum and maximum values from the NEON register\n        int16_t min_temp = vmin[0];\n        int16_t max_temp = vmax[0];\n\n        // Update the overall minimum and maximum values\n        if (min_temp < min_val) min_val = min_temp;\n        if (max_temp > max_val) max_val = max_temp;\n    }\n\n    // Process any remaining elements\n    for (; i < length; ++i) {\n        if (vec[i] < min_val) min_val = vec[i];\n        if (vec[i] > max_val) max_val = vec[i];\n    }\n\n    result.min_num = min_val;\n    result.max_num = max_val;\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_Neon", "completion": "```c\n#include <arm_neon.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    int16_t min_val = 32767;\n    int16_t max_val = -32768;\n\n    size_t i = 0;\n\n    // Process 8 elements at a time using NEON intrinsics\n    for (; i <= length - 8; i += 8) {\n        // Load 8 values from the vector into a NEON register\n        int16x8_t v = vld1q_s16(&vec[i]);\n\n        // Compute the minimum and maximum values in the register\n        int16x8_t vmin = vpminq_s16(v, v);\n        vmin = vpminq_s16(vmin, vmin);\n        vmin = vpminq_s16(vmin, vmin);\n\n        int16x8_t vmax = vpmaxq_s16(v, v);\n        vmax = vpmaxq_s16(vmax, vmax);\n        vmax = vpmaxq_s16(vmax, vmax);\n\n        // Extract the minimum and maximum values from the NEON register\n        int16_t min_temp = vmin[0];\n        int16_t max_temp = vmax[0];\n\n        // Update the overall minimum and maximum values\n        if (min_temp < min_val) min_val = min_temp;\n        if (max_temp > max_val) max_val = max_temp;\n    }\n\n    // Process any remaining elements\n    for (; i < length; ++i) {\n        if (vec[i] < min_val) min_val = vec[i];\n        if (vec[i] > max_val) max_val = vec[i];\n    }\n\n    // Assign the results to the output structure\n    result.min_num = min_val;\n    result.max_num = max_val;\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_Neon", "completion": "```c\n#include <arm_neon.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    int16_t min_val = 32767;\n    int16_t max_val = -32768;\n\n    size_t i = 0;\n\n    // Process 8 elements at a time using NEON intrinsics\n    for (; i <= length - 8; i += 8) {\n        // Load 8 elements into a NEON register\n        int16x8_t v = vld1q_s16(&vec[i]);\n\n        // Compute the minimum and maximum values in the vector\n        int16x8_t vmin = vpminq_s16(v, v);\n        vmin = vpminq_s16(vmin, vmin);\n        vmin = vpminq_s16(vmin, vmin);\n\n        int16x8_t vmax = vpmaxq_s16(v, v);\n        vmax = vpmaxq_s16(vmax, vmax);\n        vmax = vpmaxq_s16(vmax, vmax);\n\n        // Extract the minimum and maximum values from the NEON register\n        int16_t min_temp = vmin[0];\n        int16_t max_temp = vmax[0];\n\n        // Update the overall minimum and maximum values\n        if (min_temp < min_val) min_val = min_temp;\n        if (max_temp > max_val) max_val = max_temp;\n    }\n\n    // Process any remaining elements\n    for (; i < length; ++i) {\n        if (vec[i] < min_val) min_val = vec[i];\n        if (vec[i] > max_val) max_val = vec[i];\n    }\n\n    result.min_num = min_val;\n    result.max_num = max_val;\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_36_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        size_t j = 0;\n\n        // Process 4 elements at a time using NEON intrinsics\n        for (; j <= cols - 4; j += 4) {\n            int32x4_t current = vld1q_s32(row + j);\n            int32x4_t next = vld1q_s32(row + j + 1);\n\n            // Compare if current >= next (not strictly increasing)\n            uint32x4_t cmp = vcgeq_s32(current, next);\n\n            // If any lane is true (non-zero), the row is not strictly increasing\n            if (vmaxvq_u32(cmp) != 0) {\n                return false;\n            }\n        }\n\n        // Process remaining elements in the row\n        for (; j < cols - 1; ++j) {\n            if (row[j] >= row[j + 1]) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        size_t j = 0;\n\n        // Process 4 elements at a time using NEON intrinsics\n        for (; j <= cols - 4; j += 4) {\n            int32x4_t current = vld1q_s32(row + j);\n            int32x4_t next = vld1q_s32(row + j + 1);\n\n            // Compare current < next for all lanes\n            uint32x4_t comparison = vcltq_s32(current, next);\n\n            // Check if all lanes are true (strictly increasing)\n            if (vgetq_lane_u32(comparison, 0) == 0 ||\n                vgetq_lane_u32(comparison, 1) == 0 ||\n                vgetq_lane_u32(comparison, 2) == 0 ||\n                vgetq_lane_u32(comparison, 3) == 0) {\n                return false;\n            }\n        }\n\n        // Process remaining elements\n        for (; j < cols - 1; ++j) {\n            if (row[j] >= row[j + 1]) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        size_t j = 0;\n\n        // Process 4 elements at a time using NEON intrinsics\n        for (; j <= cols - 4; j += 4) {\n            int32x4_t current = vld1q_s32(row + j);\n            int32x4_t next = vld1q_s32(row + j + 1);\n\n            // Compare current < next for all lanes\n            uint32x4_t comparison = vcltq_s32(current, next);\n\n            // Check if all lanes are true (strictly increasing)\n            if (vgetq_lane_u32(comparison, 0) == 0 ||\n                vgetq_lane_u32(comparison, 1) == 0 ||\n                vgetq_lane_u32(comparison, 2) == 0 ||\n                vgetq_lane_u32(comparison, 3) == 0) {\n                return false;\n            }\n        }\n\n        // Process remaining elements in the row\n        for (; j < cols - 1; ++j) {\n            if (row[j] >= row[j + 1]) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        size_t j = 0;\n\n        // Process 4 elements at a time using NEON intrinsics\n        for (; j <= cols - 4; j += 4) {\n            int32x4_t current = vld1q_s32(row + j);\n            int32x4_t next = vld1q_s32(row + j + 1);\n\n            // Compare current < next for all lanes\n            uint32x4_t comparison = vcltq_s32(current, next);\n\n            // Check if all lanes are true (strictly increasing)\n            if (vaddvq_u32(comparison) != 4) {\n                return false;\n            }\n        }\n\n        // Handle remaining elements (less than 4)\n        for (; j < cols - 1; ++j) {\n            if (row[j] >= row[j + 1]) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        size_t j = 0;\n\n        // Process 4 elements at a time using NEON intrinsics\n        for (; j <= cols - 4; j += 4) {\n            int32x4_t current = vld1q_s32(row + j);\n            int32x4_t next = vld1q_s32(row + j + 1);\n\n            // Compare if current >= next (not strictly increasing)\n            uint32x4_t cmp = vcgeq_s32(current, next);\n\n            // If any lane is true (non-zero), the row is not strictly increasing\n            if (vmaxvq_u32(cmp) != 0) {\n                return false;\n            }\n        }\n\n        // Process remaining elements in the row\n        for (; j < cols - 1; ++j) {\n            if (row[j] >= row[j + 1]) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t block_rows = rows / block_size;\n    size_t block_cols = cols / block_size;\n    size_t block_elements = block_size * block_size;\n\n    // Load the first block into a reference buffer\n    int32x4_t reference[16]; // Assuming block_size <= 4 for simplicity\n    for (size_t i = 0; i < block_size; ++i) {\n        for (size_t j = 0; j < block_size; j += 4) {\n            reference[i * (block_size / 4) + (j / 4)] = vld1q_s32(&matrix[i * cols + j]);\n        }\n    }\n\n    // Compare all other blocks with the reference block\n    for (size_t br = 0; br < block_rows; ++br) {\n        for (size_t bc = 0; bc < block_cols; ++bc) {\n            if (br == 0 && bc == 0) continue; // Skip the first block\n\n            size_t block_start_row = br * block_size;\n            size_t block_start_col = bc * block_size;\n\n            for (size_t i = 0; i < block_size; ++i) {\n                for (size_t j = 0; j < block_size; j += 4) {\n                    int32x4_t current = vld1q_s32(&matrix[(block_start_row + i) * cols + (block_start_col + j)]);\n                    uint32x4_t cmp = vceqq_s32(current, reference[i * (block_size / 4) + (j / 4)]);\n                    if (vgetq_lane_u32(cmp, 0) == 0 || vgetq_lane_u32(cmp, 1) == 0 ||\n                        vgetq_lane_u32(cmp, 2) == 0 || vgetq_lane_u32(cmp, 3) == 0) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n\n    // Load the first block into a comparison reference\n    int32x4_t ref_block[4]; // Assuming block_size <= 4 for simplicity\n    for (size_t i = 0; i < block_size; ++i) {\n        ref_block[i] = vld1q_s32(matrix + i * cols);\n    }\n\n    // Compare all other blocks with the first block\n    for (size_t br = 0; br < num_blocks_row; ++br) {\n        for (size_t bc = 0; bc < num_blocks_col; ++bc) {\n            if (br == 0 && bc == 0) continue; // Skip the first block\n\n            size_t block_start_row = br * block_size;\n            size_t block_start_col = bc * block_size;\n\n            for (size_t i = 0; i < block_size; ++i) {\n                const int* current_block_row = matrix + (block_start_row + i) * cols + block_start_col;\n                int32x4_t current_block = vld1q_s32(current_block_row);\n\n                uint32x4_t cmp_result = vceqq_s32(current_block, ref_block[i]);\n                if (vgetq_lane_u32(cmp_result, 0) == 0 ||\n                    vgetq_lane_u32(cmp_result, 1) == 0 ||\n                    vgetq_lane_u32(cmp_result, 2) == 0 ||\n                    vgetq_lane_u32(cmp_result, 3) == 0) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_block_rows = rows / block_size;\n    size_t num_block_cols = cols / block_size;\n\n    // Load the first block into a comparison reference\n    int32x4_t ref_block[4]; // Assuming block_size <= 4 for simplicity\n    for (size_t i = 0; i < block_size; ++i) {\n        for (size_t j = 0; j < block_size; j += 4) {\n            ref_block[i * (block_size / 4) + (j / 4)] = vld1q_s32(&matrix[i * cols + j]);\n        }\n    }\n\n    // Compare all other blocks with the first block\n    for (size_t bi = 0; bi < num_block_rows; ++bi) {\n        for (size_t bj = 0; bj < num_block_cols; ++bj) {\n            if (bi == 0 && bj == 0) continue; // Skip the first block\n\n            size_t block_start_row = bi * block_size;\n            size_t block_start_col = bj * block_size;\n\n            for (size_t i = 0; i < block_size; ++i) {\n                for (size_t j = 0; j < block_size; j += 4) {\n                    int32x4_t current_block = vld1q_s32(&matrix[(block_start_row + i) * cols + block_start_col + j]);\n                    uint32x4_t cmp_result = vceqq_s32(current_block, ref_block[i * (block_size / 4) + (j / 4)]);\n                    if (vminvq_u32(cmp_result) == 0) {\n                        return false; // Mismatch found\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n    size_t block_elements = block_size * block_size;\n\n    // Load the first block into a reference buffer\n    int32x4_t ref_block_v[4];\n    const int* first_block = matrix;\n    for (size_t i = 0; i < block_size; ++i) {\n        for (size_t j = 0; j < block_size; j += 4) {\n            ref_block_v[i * (block_size / 4) + (j / 4)] = vld1q_s32(first_block + i * cols + j);\n        }\n    }\n\n    // Compare all other blocks with the first block\n    for (size_t bi = 0; bi < num_blocks_row; ++bi) {\n        for (size_t bj = 0; bj < num_blocks_col; ++bj) {\n            if (bi == 0 && bj == 0) continue; // Skip the first block\n\n            const int* current_block = matrix + bi * block_size * cols + bj * block_size;\n            bool mismatch_found = false;\n\n            for (size_t i = 0; i < block_size && !mismatch_found; ++i) {\n                for (size_t j = 0; j < block_size; j += 4) {\n                    int32x4_t current_v = vld1q_s32(current_block + i * cols + j);\n                    uint32x4_t cmp_result = vceqq_s32(current_v, ref_block_v[i * (block_size / 4) + (j / 4)]);\n                    if (vminvq_u32(cmp_result) == 0) {\n                        mismatch_found = true;\n                        break;\n                    }\n                }\n            }\n\n            if (mismatch_found) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n\n    // Load the first block into a reference buffer\n    int32x4_t ref_block[block_size][cols / 4];\n    for (size_t i = 0; i < block_size; ++i) {\n        for (size_t j = 0; j < cols / 4; ++j) {\n            ref_block[i][j] = vld1q_s32(&matrix[i * cols + j * 4]);\n        }\n    }\n\n    // Compare all other blocks with the reference block\n    for (size_t bi = 0; bi < num_blocks_row; ++bi) {\n        for (size_t bj = 0; bj < num_blocks_col; ++bj) {\n            if (bi == 0 && bj == 0) continue; // Skip the first block\n\n            bool block_equal = true;\n            for (size_t i = 0; i < block_size && block_equal; ++i) {\n                size_t row_offset = (bi * block_size + i) * cols + bj * block_size;\n                for (size_t j = 0; j < cols / 4 && block_equal; ++j) {\n                    int32x4_t current_block = vld1q_s32(&matrix[row_offset + j * 4]);\n                    uint32x4_t cmp_result = vceqq_s32(current_block, ref_block[i][j]);\n                    if (vgetq_lane_u32(cmp_result, 0) == 0 ||\n                        vgetq_lane_u32(cmp_result, 1) == 0 ||\n                        vgetq_lane_u32(cmp_result, 2) == 0 ||\n                        vgetq_lane_u32(cmp_result, 3) == 0) {\n                        block_equal = false;\n                    }\n                }\n            }\n\n            if (!block_equal) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || block_size == 0 || length < block_size || block_size % 2 != 0) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 2) {\n        return false;\n    }\n\n    float64x2_t vtolerance = vdupq_n_f64(tolerance);\n    float64x2_t vfirst_block[block_size / 2];\n\n    // Load the first block into SIMD registers\n    for (size_t i = 0; i < block_size / 2; ++i) {\n        vfirst_block[i] = vld1q_f64(vec + i * 2);\n    }\n\n    // Compare each subsequent block with the first block\n    for (size_t b = 1; b < num_blocks; ++b) {\n        const double* current_block = vec + b * block_size;\n\n        for (size_t i = 0; i < block_size / 2; ++i) {\n            float64x2_t vcurrent = vld1q_f64(current_block + i * 2);\n            float64x2_t vdiff = vabdq_f64(vcurrent, vfirst_block[i]);\n\n            uint64x2_t mask = vcltq_f64(vdiff, vtolerance);\n            if (vgetq_lane_u64(mask, 0) == 0 || vgetq_lane_u64(mask, 1) == 0) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || block_size == 0 || length < block_size || block_size % 2 != 0) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 2) {\n        return false;\n    }\n\n    float64x2_t vtoler = vdupq_n_f64(tolerance);\n    float64x2_t vfirst_block[block_size / 2];\n\n    // Load the first block into Neon registers\n    for (size_t i = 0; i < block_size; i += 2) {\n        vfirst_block[i / 2] = vld1q_f64(&vec[i]);\n    }\n\n    // Compare each subsequent block with the first block\n    for (size_t b = 1; b < num_blocks; ++b) {\n        for (size_t i = 0; i < block_size; i += 2) {\n            float64x2_t vcurrent = vld1q_f64(&vec[b * block_size + i]);\n            float64x2_t vdiff = vsubq_f64(vcurrent, vfirst_block[i / 2]);\n            float64x2_t vabs_diff = vabsq_f64(vdiff);\n\n            uint64x2_t mask = vcgtq_f64(vabs_diff, vtoler);\n            if (vgetq_lane_u64(mask, 0) || vgetq_lane_u64(mask, 1)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || block_size == 0 || length < block_size || block_size % 2 != 0) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 2) {\n        return false;\n    }\n\n    // Load the first block into Neon registers\n    float64x2_t first_block_0 = vld1q_f64(vec);\n    float64x2_t first_block_1 = vld1q_f64(vec + 2);\n\n    // Tolerance vector for comparison\n    float64x2_t tol_vec = vmovq_n_f64(tolerance);\n\n    for (size_t i = 1; i < num_blocks; ++i) {\n        const double* current_block = vec + i * block_size;\n\n        // Load the current block into Neon registers\n        float64x2_t current_block_0 = vld1q_f64(current_block);\n        float64x2_t current_block_1 = vld1q_f64(current_block + 2);\n\n        // Compute absolute differences\n        float64x2_t diff_0 = vabdq_f64(current_block_0, first_block_0);\n        float64x2_t diff_1 = vabdq_f64(current_block_1, first_block_1);\n\n        // Compare differences with tolerance\n        uint64x2_t cmp_0 = vcltq_f64(diff_0, tol_vec);\n        uint64x2_t cmp_1 = vcltq_f64(diff_1, tol_vec);\n\n        // Check if all elements satisfy the condition\n        if ((vgetq_lane_u64(cmp_0, 0) == 0) || (vgetq_lane_u64(cmp_0, 1) == 0) ||\n            (vgetq_lane_u64(cmp_1, 0) == 0) || (vgetq_lane_u64(cmp_1, 1) == 0)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || block_size == 0 || length < block_size || block_size % 2 != 0) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 2) {\n        return false;\n    }\n\n    float64x2_t vtolerance = vdupq_n_f64(tolerance);\n    float64x2_t vfirst_block[block_size / 2];\n\n    // Load the first block into SIMD registers\n    for (size_t i = 0; i < block_size; i += 2) {\n        vfirst_block[i / 2] = vld1q_f64(&vec[i]);\n    }\n\n    // Compare each subsequent block with the first block\n    for (size_t b = 1; b < num_blocks; ++b) {\n        size_t block_start = b * block_size;\n\n        for (size_t i = 0; i < block_size; i += 2) {\n            float64x2_t vcurrent = vld1q_f64(&vec[block_start + i]);\n            float64x2_t vdiff = vsubq_f64(vcurrent, vfirst_block[i / 2]);\n            float64x2_t vabs_diff = vabsq_f64(vdiff);\n\n            uint64x2_t mask = vcgtq_f64(vabs_diff, vtolerance);\n            if (vaddvq_u64(mask) != 0) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || block_size == 0 || length < block_size || block_size % 2 != 0) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 2) {\n        return false;\n    }\n\n    float64x2_t vtolerance = vdupq_n_f64(tolerance);\n    float64x2_t vfirst_block[block_size / 2];\n\n    // Load the first block into SIMD registers\n    for (size_t i = 0; i < block_size; i += 2) {\n        vfirst_block[i / 2] = vld1q_f64(&vec[i]);\n    }\n\n    // Compare each subsequent block with the first block\n    for (size_t b = 1; b < num_blocks; ++b) {\n        size_t block_start = b * block_size;\n\n        for (size_t i = 0; i < block_size; i += 2) {\n            float64x2_t vcurrent = vld1q_f64(&vec[block_start + i]);\n            float64x2_t vdiff = vabdq_f64(vcurrent, vfirst_block[i / 2]);\n\n            uint64x2_t mask = vcgtq_f64(vdiff, vtolerance);\n            if (vgetq_lane_u64(mask, 0) || vgetq_lane_u64(mask, 1)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_39_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        float64x2_t sum_vec = vmovq_n_f64(0.0);\n        size_t j = 0;\n\n        // Process 2 elements at a time using NEON intrinsics\n        for (; j + 1 < cols; j += 2) {\n            float64x2_t row_vec = vld1q_f64(&matrix[i * cols + j]);\n            sum_vec = vfmaq_f64(sum_vec, row_vec, row_vec);\n        }\n\n        // Horizontal add to compute the final squared norm for the row\n        double squared_norm = vaddvq_f64(sum_vec);\n\n        // Add remaining elements if cols is odd\n        for (; j < cols; ++j) {\n            double val = matrix[i * cols + j];\n            squared_norm += val * val;\n        }\n\n        // Compare the Euclidean norm with the threshold\n        double norm = sqrt(squared_norm);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        float64x2_t sum_vec = vmovq_n_f64(0.0);\n        size_t j = 0;\n\n        // Process columns in chunks of 2 using NEON intrinsics\n        for (; j + 1 < cols; j += 2) {\n            float64x2_t row_vec = vld1q_f64(&matrix[i * cols + j]);\n            sum_vec = vfmaq_f64(sum_vec, row_vec, row_vec);\n        }\n\n        // Horizontal add to compute the final squared norm for the row\n        double squared_norm = vaddvq_f64(sum_vec);\n\n        // Handle remaining elements (if cols is odd)\n        for (; j < cols; ++j) {\n            double val = matrix[i * cols + j];\n            squared_norm += val * val;\n        }\n\n        // Compare the Euclidean norm with the threshold\n        double norm = sqrt(squared_norm);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        float64x2_t sum_vec = vdupq_n_f64(0.0);\n        size_t j = 0;\n\n        // Process 2 elements at a time using NEON intrinsics\n        for (; j + 1 < cols; j += 2) {\n            float64x2_t row_vec = vld1q_f64(&matrix[i * cols + j]);\n            sum_vec = vfmaq_f64(sum_vec, row_vec, row_vec);\n        }\n\n        // Horizontal add to accumulate the partial sums\n        double sum = vaddvq_f64(sum_vec);\n\n        // Process remaining elements in the row\n        for (; j < cols; ++j) {\n            double val = matrix[i * cols + j];\n            sum += val * val;\n        }\n\n        // Compare the Euclidean norm with the threshold\n        double norm = sqrt(sum);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        float64x2_t sum_vec = vmovq_n_f64(0.0);\n        size_t j = 0;\n\n        // Process 2 elements at a time using NEON intrinsics\n        for (; j + 1 < cols; j += 2) {\n            float64x2_t row_vec = vld1q_f64(&matrix[i * cols + j]);\n            sum_vec = vfmaq_f64(sum_vec, row_vec, row_vec);\n        }\n\n        // Horizontal add to accumulate the partial sums\n        double sum = vaddvq_f64(sum_vec);\n\n        // Handle remaining elements in the row\n        for (; j < cols; ++j) {\n            double val = matrix[i * cols + j];\n            sum += val * val;\n        }\n\n        // Compare the Euclidean norm with the threshold\n        double norm = sqrt(sum);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        float64x2_t sum_vec = vdupq_n_f64(0.0);\n        size_t j = 0;\n\n        // Process columns in chunks of 2 using NEON intrinsics\n        for (; j + 1 < cols; j += 2) {\n            float64x2_t row_vec = vld1q_f64(&matrix[i * cols + j]);\n            sum_vec = vfmaq_f64(sum_vec, row_vec, row_vec);\n        }\n\n        // Horizontal add to compute the final squared norm for the row\n        double squared_norm = vaddvq_f64(sum_vec);\n\n        // Handle remaining elements (if cols is odd)\n        for (; j < cols; ++j) {\n            double val = matrix[i * cols + j];\n            squared_norm += val * val;\n        }\n\n        // Compare the Euclidean norm with the threshold\n        double norm = sqrt(squared_norm);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_40_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 elements from A and B into NEON registers\n        uint32x4_t vecA = vld1q_u32(&A[i]);\n        uint32x4_t vecB = vld1q_u32(&B[i]);\n        \n        // Perform bitwise OR operation\n        uint32x4_t vecC = vorrq_u32(vecA, vecB);\n        \n        // Store the result back to C\n        vst1q_u32(&C[i], vecC);\n    }\n    \n    // Process remaining elements (if any) with scalar operations\n    for (; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 elements from A and B into NEON registers\n        uint32x4_t vecA = vld1q_u32(&A[i]);\n        uint32x4_t vecB = vld1q_u32(&B[i]);\n        \n        // Perform bitwise OR operation\n        uint32x4_t vecC = vorrq_u32(vecA, vecB);\n        \n        // Store the result back to C\n        vst1q_u32(&C[i], vecC);\n    }\n    \n    // Process remaining elements (if any) using scalar operations\n    for (; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 elements from A and B into NEON registers\n        uint32x4_t vecA = vld1q_u32(&A[i]);\n        uint32x4_t vecB = vld1q_u32(&B[i]);\n        \n        // Perform bitwise OR operation\n        uint32x4_t vecC = vorrq_u32(vecA, vecB);\n        \n        // Store the result back to C\n        vst1q_u32(&C[i], vecC);\n    }\n    \n    // Process remaining elements (if any) using scalar operations\n    for (; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 elements from A and B into NEON registers\n        uint32x4_t vecA = vld1q_u32(&A[i]);\n        uint32x4_t vecB = vld1q_u32(&B[i]);\n        \n        // Perform bitwise OR operation\n        uint32x4_t vecC = vorrq_u32(vecA, vecB);\n        \n        // Store the result back to C\n        vst1q_u32(&C[i], vecC);\n    }\n    \n    // Process remaining elements (if any) with scalar code\n    for (; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 elements from A and B into NEON registers\n        uint32x4_t vecA = vld1q_u32(&A[i]);\n        uint32x4_t vecB = vld1q_u32(&B[i]);\n        \n        // Perform bitwise OR operation\n        uint32x4_t vecC = vorrq_u32(vecA, vecB);\n        \n        // Store the result back to C\n        vst1q_u32(&C[i], vecC);\n    }\n    \n    // Process remaining elements (if any) using scalar operations\n    for (; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_41_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n\n    size_t i = 0;\n\n    // Process 16 elements at a time using NEON intrinsics\n    for (; i + 15 < length; i += 16) {\n        // Load 16 elements from A and B into NEON registers\n        int8x16_t vec_a = vld1q_s8(&A[i]);\n        int8x16_t vec_b = vld1q_s8(&B[i]);\n\n        // Compute squares of A (a^2)\n        int16x8_t square_lo = vmull_s8(vget_low_s8(vec_a), vget_low_s8(vec_a));\n        int16x8_t square_hi = vmull_s8(vget_high_s8(vec_a), vget_high_s8(vec_a));\n\n        // Compute products of A and B (a*b)\n        int16x8_t product_lo = vmull_s8(vget_low_s8(vec_a), vget_low_s8(vec_b));\n        int16x8_t product_hi = vmull_s8(vget_high_s8(vec_a), vget_high_s8(vec_b));\n\n        // Add the low and high parts of squares\n        int32x4_t sum_square_lo = vpaddlq_s16(square_lo);\n        int32x4_t sum_square_hi = vpaddlq_s16(square_hi);\n\n        // Add the low and high parts of products\n        int32x4_t sum_product_lo = vpaddlq_s16(product_lo);\n        int32x4_t sum_product_hi = vpaddlq_s16(product_hi);\n\n        // Combine the results into 64-bit sums\n        int64x2_t sum_square_64 = vpaddlq_s32(vcombine_s32(sum_square_lo, sum_square_hi));\n        int64x2_t sum_product_64 = vpaddlq_s32(vcombine_s32(sum_product_lo, sum_product_hi));\n\n        // Accumulate into scalar sums\n        sum_squares += vgetq_lane_s64(sum_square_64, 0) + vgetq_lane_s64(sum_square_64, 1);\n        sum_products += vgetq_lane_s64(sum_product_64, 0) + vgetq_lane_s64(sum_product_64, 1);\n    }\n\n    // Process remaining elements\n    for (; i < length; ++i) {\n        sum_squares += (int64_t)A[i] * A[i];\n        sum_products += (int64_t)A[i] * B[i];\n    }\n\n    return sum_squares - sum_products;\n}\n```"}
{"task_id": "SimdBench_41_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n\n    size_t i = 0;\n\n    // Process 16 elements at a time using NEON intrinsics\n    for (; i + 15 < length; i += 16) {\n        // Load 16 elements from A and B into NEON registers\n        int8x16_t va = vld1q_s8(&A[i]);\n        int8x16_t vb = vld1q_s8(&B[i]);\n\n        // Compute squares of A (va * va)\n        int16x8_t va_low = vmovl_s8(vget_low_s8(va));\n        int16x8_t va_high = vmovl_s8(vget_high_s8(va));\n        int16x8_t va_sq_low = vmulq_s16(va_low, va_low);\n        int16x8_t va_sq_high = vmulq_s16(va_high, va_high);\n\n        // Compute products of A and B (va * vb)\n        int16x8_t vb_low = vmovl_s8(vget_low_s8(vb));\n        int16x8_t vb_high = vmovl_s8(vget_high_s8(vb));\n        int16x8_t prod_low = vmulq_s16(va_low, vb_low);\n        int16x8_t prod_high = vmulq_s16(va_high, vb_high);\n\n        // Accumulate the results for squares\n        int32x4_t sum_sq_low = vpaddlq_s16(va_sq_low);\n        int32x4_t sum_sq_high = vpaddlq_s16(va_sq_high);\n        int64x2_t sum_sq_total = vpaddlq_s32(sum_sq_low);\n        sum_sq_total = vpadalq_s32(sum_sq_total, sum_sq_high);\n        sum_squares += vgetq_lane_s64(sum_sq_total, 0) + vgetq_lane_s64(sum_sq_total, 1);\n\n        // Accumulate the results for products\n        int32x4_t sum_prod_low = vpaddlq_s16(prod_low);\n        int32x4_t sum_prod_high = vpaddlq_s16(prod_high);\n        int64x2_t sum_prod_total = vpaddlq_s32(sum_prod_low);\n        sum_prod_total = vpadalq_s32(sum_prod_total, sum_prod_high);\n        sum_products += vgetq_lane_s64(sum_prod_total, 0) + vgetq_lane_s64(sum_prod_total, 1);\n    }\n\n    // Process remaining elements\n    for (; i < length; ++i) {\n        sum_squares += (int64_t)A[i] * A[i];\n        sum_products += (int64_t)A[i] * B[i];\n    }\n\n    return sum_squares - sum_products;\n}\n```"}
{"task_id": "SimdBench_41_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n\n    size_t i = 0;\n\n    // Process 16 elements at a time using NEON intrinsics\n    for (; i + 15 < length; i += 16) {\n        // Load 16 elements from A and B into NEON registers\n        int8x16_t va = vld1q_s8(&A[i]);\n        int8x16_t vb = vld1q_s8(&B[i]);\n\n        // Compute squares of A (va * va)\n        int16x8_t va_low = vmovl_s8(vget_low_s8(va));\n        int16x8_t va_high = vmovl_s8(vget_high_s8(va));\n        int16x8_t square_low = vmulq_s16(va_low, va_low);\n        int16x8_t square_high = vmulq_s16(va_high, va_high);\n\n        // Compute products of A and B (va * vb)\n        int16x8_t vb_low = vmovl_s8(vget_low_s8(vb));\n        int16x8_t vb_high = vmovl_s8(vget_high_s8(vb));\n        int16x8_t product_low = vmulq_s16(va_low, vb_low);\n        int16x8_t product_high = vmulq_s16(va_high, vb_high);\n\n        // Sum the results horizontally\n        int32x4_t sum_square_low = vpaddlq_s16(square_low);\n        int32x4_t sum_square_high = vpaddlq_s16(square_high);\n        int32x4_t sum_product_low = vpaddlq_s16(product_low);\n        int32x4_t sum_product_high = vpaddlq_s16(product_high);\n\n        int32x2_t sum_square = vpadd_s32(vget_low_s32(sum_square_low), vget_high_s32(sum_square_low));\n        sum_square = vpadd_s32(sum_square, vget_low_s32(sum_square_high));\n        sum_square = vpadd_s32(sum_square, vget_high_s32(sum_square_high));\n\n        int32x2_t sum_product = vpadd_s32(vget_low_s32(sum_product_low), vget_high_s32(sum_product_low));\n        sum_product = vpadd_s32(sum_product, vget_low_s32(sum_product_high));\n        sum_product = vpadd_s32(sum_product, vget_high_s32(sum_product_high));\n\n        sum_squares += vget_lane_s32(sum_square, 0);\n        sum_products += vget_lane_s32(sum_product, 0);\n    }\n\n    // Process remaining elements\n    for (; i < length; ++i) {\n        sum_squares += (int64_t)A[i] * A[i];\n        sum_products += (int64_t)A[i] * B[i];\n    }\n\n    return sum_squares - sum_products;\n}\n```"}
{"task_id": "SimdBench_41_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int32x4_t sum_squares = vdupq_n_s32(0);\n    int32x4_t sum_products = vdupq_n_s32(0);\n\n    size_t i = 0;\n    for (; i + 16 <= length; i += 16) {\n        // Load 16 elements from A and B\n        int8x16_t va = vld1q_s8(&A[i]);\n        int8x16_t vb = vld1q_s8(&B[i]);\n\n        // Compute squares of A and B\n        int16x8_t va_low = vmovl_s8(vget_low_s8(va));\n        int16x8_t va_high = vmovl_s8(vget_high_s8(va));\n        int16x8_t vb_low = vmovl_s8(vget_low_s8(vb));\n        int16x8_t vb_high = vmovl_s8(vget_high_s8(vb));\n\n        int32x4_t square_a_low = vmull_s16(vget_low_s16(va_low), vget_low_s16(va_low));\n        int32x4_t square_a_high = vmull_s16(vget_high_s16(va_low), vget_high_s16(va_low));\n        int32x4_t square_b_low = vmull_s16(vget_low_s16(vb_low), vget_low_s16(vb_low));\n        int32x4_t square_b_high = vmull_s16(vget_high_s16(vb_low), vget_high_s16(vb_low));\n\n        int32x4_t square_a_low2 = vmull_s16(vget_low_s16(va_high), vget_low_s16(va_high));\n        int32x4_t square_a_high2 = vmull_s16(vget_high_s16(va_high), vget_high_s16(va_high));\n        int32x4_t square_b_low2 = vmull_s16(vget_low_s16(vb_high), vget_low_s16(vb_high));\n        int32x4_t square_b_high2 = vmull_s16(vget_high_s16(vb_high), vget_high_s16(vb_high));\n\n        // Accumulate squares\n        sum_squares = vaddq_s32(sum_squares, vpaddq_s32(square_a_low, square_a_high));\n        sum_squares = vaddq_s32(sum_squares, vpaddq_s32(square_b_low, square_b_high));\n        sum_squares = vaddq_s32(sum_squares, vpaddq_s32(square_a_low2, square_a_high2));\n        sum_squares = vaddq_s32(sum_squares, vpaddq_s32(square_b_low2, square_b_high2));\n\n        // Compute products of A and B\n        int32x4_t product_low = vmull_s16(vget_low_s16(va_low), vget_low_s16(vb_low));\n        int32x4_t product_high = vmull_s16(vget_high_s16(va_low), vget_high_s16(vb_low));\n        int32x4_t product_low2 = vmull_s16(vget_low_s16(va_high), vget_low_s16(vb_high));\n        int32x4_t product_high2 = vmull_s16(vget_high_s16(va_high), vget_high_s16(vb_high));\n\n        // Accumulate products\n        sum_products = vaddq_s32(sum_products, vpaddq_s32(product_low, product_high));\n        sum_products = vaddq_s32(sum_products, vpaddq_s32(product_low2, product_high2));\n    }\n\n    // Handle remaining elements\n    int64_t sum_squares_scalar = 0;\n    int64_t sum_products_scalar = 0;\n    for (; i < length; ++i) {\n        sum_squares_scalar += (int64_t)A[i] * A[i] + (int64_t)B[i] * B[i];\n        sum_products_scalar += (int64_t)A[i] * B[i];\n    }\n\n    // Sum up the SIMD results\n    int64_t total_sum_squares = sum_squares_scalar + vaddvq_s32(sum_squares);\n    int64_t total_sum_products = sum_products_scalar + vaddvq_s32(sum_products);\n\n    return total_sum_squares - total_sum_products;\n}\n```"}
{"task_id": "SimdBench_41_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int32x4_t sum_squares = vmovq_n_s32(0);\n    int32x4_t sum_products = vmovq_n_s32(0);\n\n    size_t i = 0;\n    for (; i + 16 <= length; i += 16) {\n        // Load 16 elements from A and B\n        int8x16_t va = vld1q_s8(&A[i]);\n        int8x16_t vb = vld1q_s8(&B[i]);\n\n        // Compute squares of A and B\n        int16x8_t va_low = vmovl_s8(vget_low_s8(va));\n        int16x8_t va_high = vmovl_s8(vget_high_s8(va));\n        int16x8_t vb_low = vmovl_s8(vget_low_s8(vb));\n        int16x8_t vb_high = vmovl_s8(vget_high_s8(vb));\n\n        int32x4_t square_a_low = vmull_s16(vget_low_s16(va_low), vget_low_s16(va_low));\n        int32x4_t square_a_high = vmull_s16(vget_high_s16(va_low), vget_high_s16(va_low));\n        int32x4_t square_b_low = vmull_s16(vget_low_s16(vb_low), vget_low_s16(vb_low));\n        int32x4_t square_b_high = vmull_s16(vget_high_s16(vb_low), vget_high_s16(vb_low));\n\n        int32x4_t square_a_low2 = vmull_s16(vget_low_s16(va_high), vget_low_s16(va_high));\n        int32x4_t square_a_high2 = vmull_s16(vget_high_s16(va_high), vget_high_s16(va_high));\n        int32x4_t square_b_low2 = vmull_s16(vget_low_s16(vb_high), vget_low_s16(vb_high));\n        int32x4_t square_b_high2 = vmull_s16(vget_high_s16(vb_high), vget_high_s16(vb_high));\n\n        // Accumulate squares\n        sum_squares = vaddq_s32(sum_squares, vaddq_s32(square_a_low, square_a_high));\n        sum_squares = vaddq_s32(sum_squares, vaddq_s32(square_b_low, square_b_high));\n        sum_squares = vaddq_s32(sum_squares, vaddq_s32(square_a_low2, square_a_high2));\n        sum_squares = vaddq_s32(sum_squares, vaddq_s32(square_b_low2, square_b_high2));\n\n        // Compute products of A and B\n        int32x4_t product_low = vmull_s16(vget_low_s16(va_low), vget_low_s16(vb_low));\n        int32x4_t product_high = vmull_s16(vget_high_s16(va_low), vget_high_s16(vb_low));\n        int32x4_t product_low2 = vmull_s16(vget_low_s16(va_high), vget_low_s16(vb_high));\n        int32x4_t product_high2 = vmull_s16(vget_high_s16(va_high), vget_high_s16(vb_high));\n\n        // Accumulate products\n        sum_products = vaddq_s32(sum_products, vaddq_s32(product_low, product_high));\n        sum_products = vaddq_s32(sum_products, vaddq_s32(product_low2, product_high2));\n    }\n\n    // Horizontal reduction of sum_squares and sum_products\n    int64_t total_squares = vaddvq_s32(sum_squares);\n    int64_t total_products = vaddvq_s32(sum_products);\n\n    // Handle remaining elements\n    for (; i < length; ++i) {\n        total_squares += (int64_t)A[i] * A[i] + (int64_t)B[i] * B[i];\n        total_products += (int64_t)A[i] * B[i];\n    }\n\n    return total_squares - total_products;\n}\n```"}
{"task_id": "SimdBench_42_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n\n    // Process 2 elements at a time using Neon intrinsics (128-bit registers)\n    for (; i + 1 < length; i += 2) {\n        // Load 2 elements from A and B into Neon registers\n        uint64x2_t vecA = vld1q_u64(&A[i]);\n        uint64x2_t vecB = vld1q_u64(&B[i]);\n\n        // Perform bitwise negation on vecB\n        uint64x2_t negVecB = vmvnq_u64(vecB);\n\n        // Perform bitwise AND between vecA and negVecB\n        uint64x2_t result = vandq_u64(vecA, negVecB);\n\n        // Store the result back to C\n        vst1q_u64(&C[i], result);\n    }\n\n    // Handle remaining elements (if length is odd)\n    for (; i < length; ++i) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    \n    // Process 2 elements at a time using Neon intrinsics (128-bit registers)\n    for (; i + 1 < length; i += 2) {\n        // Load 2 elements from A and B into Neon registers\n        uint64x2_t vecA = vld1q_u64(&A[i]);\n        uint64x2_t vecB = vld1q_u64(&B[i]);\n        \n        // Compute bitwise NOT of vecB\n        uint64x2_t negB = vmvnq_u64(vecB);\n        \n        // Perform bitwise AND between vecA and negB\n        uint64x2_t result = vandq_u64(vecA, negB);\n        \n        // Store the result back to C\n        vst1q_u64(&C[i], result);\n    }\n    \n    // Handle remaining elements (if length is odd)\n    for (; i < length; ++i) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n\n    // Process 2 elements at a time using NEON intrinsics (128-bit registers)\n    for (; i + 1 < length; i += 2) {\n        // Load 2 elements from A and B into NEON registers\n        uint64x2_t vecA = vld1q_u64(&A[i]);\n        uint64x2_t vecB = vld1q_u64(&B[i]);\n\n        // Perform bitwise negation on vecB\n        uint64x2_t negVecB = vmvnq_u64(vecB);\n\n        // Perform bitwise AND between vecA and negVecB\n        uint64x2_t result = vandq_u64(vecA, negVecB);\n\n        // Store the result back to C\n        vst1q_u64(&C[i], result);\n    }\n\n    // Handle remaining elements (if any) with scalar operations\n    for (; i < length; ++i) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n\n    // Process 2 elements at a time using Neon intrinsics (128-bit registers)\n    for (; i + 1 < length; i += 2) {\n        // Load 2 elements from A and B into Neon registers\n        uint64x2_t vecA = vld1q_u64(&A[i]);\n        uint64x2_t vecB = vld1q_u64(&B[i]);\n\n        // Perform bitwise NOT on vecB\n        uint64x2_t negVecB = vmvnq_u64(vecB);\n\n        // Perform bitwise AND between vecA and negVecB\n        uint64x2_t result = vandq_u64(vecA, negVecB);\n\n        // Store the result back to C\n        vst1q_u64(&C[i], result);\n    }\n\n    // Handle remaining elements (if length is odd)\n    for (; i < length; ++i) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    \n    // Process 2 elements at a time using NEON intrinsics (128-bit registers)\n    for (; i + 1 < length; i += 2) {\n        // Load 2 elements from A and B into NEON registers\n        uint64x2_t vecA = vld1q_u64(&A[i]);\n        uint64x2_t vecB = vld1q_u64(&B[i]);\n        \n        // Perform bitwise NOT on vecB\n        uint64x2_t negVecB = vmvnq_u64(vecB);\n        \n        // Perform bitwise AND between vecA and negVecB\n        uint64x2_t result = vandq_u64(vecA, negVecB);\n        \n        // Store the result back to C\n        vst1q_u64(&C[i], result);\n    }\n    \n    // Handle remaining elements (if length is odd)\n    for (; i < length; ++i) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_43_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    \n    // Process 16 elements at a time using NEON intrinsics\n    for (; i + 15 < length; i += 16) {\n        // Load 16 elements from A and B into NEON registers\n        int8x16_t vecA = vld1q_s8(&A[i]);\n        int8x16_t vecB = vld1q_s8(&B[i]);\n\n        // Compare if both A and B are positive (greater than 0)\n        uint8x16_t both_positive = vandq_u8(vcgtq_s8(vecA, vdupq_n_s8(0)), vcgtq_s8(vecB, vdupq_n_s8(0)));\n\n        // Compare if both A and B are negative (less than 0)\n        uint8x16_t both_negative = vandq_u8(vcltq_s8(vecA, vdupq_n_s8(0)), vcltq_s8(vecB, vdupq_n_s8(0)));\n\n        // Create result vector: 1 for both positive, -1 for both negative, 0 otherwise\n        int8x16_t result = vsubq_s8(vreinterpretq_s8_u8(both_positive), vreinterpretq_s8_u8(both_negative));\n\n        // Store the result back to C\n        vst1q_s8(&C[i], result);\n    }\n\n    // Handle remaining elements (if any) with scalar code\n    for (; i < length; ++i) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n\n    // Process 16 elements at a time using NEON intrinsics\n    for (; i + 15 < length; i += 16) {\n        // Load 16 elements from A and B into NEON registers\n        int8x16_t va = vld1q_s8(&A[i]);\n        int8x16_t vb = vld1q_s8(&B[i]);\n\n        // Compare if both A and B are positive (greater than 0)\n        uint8x16_t positive_mask = vandq_u8(vcgtq_s8(va, vdupq_n_s8(0)), vcgtq_s8(vb, vdupq_n_s8(0)));\n\n        // Compare if both A and B are negative (less than 0)\n        uint8x16_t negative_mask = vandq_u8(vcltq_s8(va, vdupq_n_s8(0)), vcltq_s8(vb, vdupq_n_s8(0)));\n\n        // Create result vector: 1 for positive_mask, -1 for negative_mask, 0 otherwise\n        int8x16_t result = vsubq_s8(vreinterpretq_s8_u8(positive_mask), vreinterpretq_s8_u8(negative_mask));\n\n        // Store the result back to C\n        vst1q_s8(&C[i], result);\n    }\n\n    // Handle remaining elements (if any) with scalar code\n    for (; i < length; ++i) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    \n    // Process 16 elements at a time using NEON intrinsics\n    for (; i + 15 < length; i += 16) {\n        // Load 16 elements from A and B into NEON registers\n        int8x16_t va = vld1q_s8(&A[i]);\n        int8x16_t vb = vld1q_s8(&B[i]);\n\n        // Compare if both A and B are positive (greater than 0)\n        uint8x16_t positive_mask = vandq_u8(vcgtq_s8(va, vdupq_n_s8(0)), vcgtq_s8(vb, vdupq_n_s8(0)));\n\n        // Compare if both A and B are negative (less than 0)\n        uint8x16_t negative_mask = vandq_u8(vcltq_s8(va, vdupq_n_s8(0)), vcltq_s8(vb, vdupq_n_s8(0)));\n\n        // Create result vector: 1 for positive_mask, -1 for negative_mask, 0 otherwise\n        int8x16_t result = vsubq_s8(vreinterpretq_s8_u8(positive_mask), vreinterpretq_s8_u8(negative_mask));\n\n        // Store the result back to C\n        vst1q_s8(&C[i], result);\n    }\n\n    // Handle remaining elements (if any) with scalar code\n    for (; i < length; ++i) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    \n    // Process 16 elements at a time using NEON intrinsics\n    for (; i + 15 < length; i += 16) {\n        // Load 16 elements from A and B into NEON registers\n        int8x16_t va = vld1q_s8(&A[i]);\n        int8x16_t vb = vld1q_s8(&B[i]);\n\n        // Compare if both A and B are positive (greater than 0)\n        uint8x16_t positive_mask = vandq_u8(vcgtq_s8(va, vdupq_n_s8(0)), vcgtq_s8(vb, vdupq_n_s8(0)));\n\n        // Compare if both A and B are negative (less than 0)\n        uint8x16_t negative_mask = vandq_u8(vcltq_s8(va, vdupq_n_s8(0)), vcltq_s8(vb, vdupq_n_s8(0)));\n\n        // Create result vector: 1 for positive, -1 for negative, 0 otherwise\n        int8x16_t result = vsubq_s8(vreinterpretq_s8_u8(positive_mask), vreinterpretq_s8_u8(negative_mask));\n\n        // Store the result back to C\n        vst1q_s8(&C[i], result);\n    }\n\n    // Process remaining elements (if any) with scalar code\n    for (; i < length; ++i) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    \n    // Process 16 elements at a time using NEON intrinsics\n    for (; i + 15 < length; i += 16) {\n        // Load 16 elements from A and B into NEON registers\n        int8x16_t va = vld1q_s8(&A[i]);\n        int8x16_t vb = vld1q_s8(&B[i]);\n\n        // Compare if both A and B are positive (greater than 0)\n        uint8x16_t positive_mask = vandq_u8(vcgtq_s8(va, vdupq_n_s8(0)), vcgtq_s8(vb, vdupq_n_s8(0)));\n\n        // Compare if both A and B are negative (less than 0)\n        uint8x16_t negative_mask = vandq_u8(vcltq_s8(va, vdupq_n_s8(0)), vcltq_s8(vb, vdupq_n_s8(0)));\n\n        // Create result vector: 1 for positive, -1 for negative, 0 otherwise\n        int8x16_t result = vsubq_s8(vreinterpretq_s8_u8(positive_mask), vreinterpretq_s8_u8(negative_mask));\n\n        // Store the result back to C\n        vst1q_s8(&C[i], result);\n    }\n\n    // Process remaining elements (if any) with scalar code\n    for (; i < length; ++i) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t mid = length / 2;\n    size_t i = 0;\n\n    // Process elements before the midpoint\n    for (; i <= mid - 8; i += 8) {\n        uint16x8_t va = vld1q_u16(&A[i]);\n        uint16x8_t vb = vld1q_u16(&B[i]);\n        uint16x8_t vc = veorq_u16(va, vb);\n        vst1q_u16(&C[i], vc);\n    }\n\n    // Handle remaining elements before the midpoint\n    for (; i < mid; ++i) {\n        C[i] = A[i] ^ B[i];\n    }\n\n    // Handle the midpoint element\n    C[mid] = A[mid];\n\n    // Process elements after the midpoint\n    i = mid + 1;\n    for (; i <= length - 8; i += 8) {\n        uint16x8_t va = vld1q_u16(&A[i]);\n        uint16x8_t vb = vld1q_u16(&B[i]);\n        uint16x8_t vc = vandq_u16(va, vb);\n        vst1q_u16(&C[i], vc);\n    }\n\n    // Handle remaining elements after the midpoint\n    for (; i < length; ++i) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_44_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t mid = length / 2;\n    size_t i = 0;\n\n    // Process elements before the midpoint\n    for (; i <= mid - 8; i += 8) {\n        uint16x8_t va = vld1q_u16(&A[i]);\n        uint16x8_t vb = vld1q_u16(&B[i]);\n        uint16x8_t vc = veorq_u16(va, vb);\n        vst1q_u16(&C[i], vc);\n    }\n\n    // Handle remaining elements before the midpoint\n    for (; i < mid; ++i) {\n        C[i] = A[i] ^ B[i];\n    }\n\n    // Handle the midpoint element\n    if (length % 2 == 0) {\n        C[mid] = A[mid];\n    } else {\n        C[mid] = A[mid];\n        ++mid;\n    }\n\n    // Process elements after the midpoint\n    for (i = mid; i <= length - 8; i += 8) {\n        uint16x8_t va = vld1q_u16(&A[i]);\n        uint16x8_t vb = vld1q_u16(&B[i]);\n        uint16x8_t vc = vandq_u16(va, vb);\n        vst1q_u16(&C[i], vc);\n    }\n\n    // Handle remaining elements after the midpoint\n    for (; i < length; ++i) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_44_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t mid = length / 2;\n    size_t i = 0;\n\n    // Process elements before the midpoint\n    for (; i <= mid - 8; i += 8) {\n        uint16x8_t va = vld1q_u16(&A[i]);\n        uint16x8_t vb = vld1q_u16(&B[i]);\n        uint16x8_t vc = veorq_u16(va, vb);\n        vst1q_u16(&C[i], vc);\n    }\n\n    // Handle remaining elements before the midpoint\n    for (; i < mid; ++i) {\n        C[i] = A[i] ^ B[i];\n    }\n\n    // Handle the midpoint element\n    if (length % 2 == 0) {\n        C[mid] = A[mid];\n    } else {\n        C[mid] = A[mid];\n        ++mid;\n    }\n\n    // Process elements after the midpoint\n    for (i = mid; i <= length - 8; i += 8) {\n        uint16x8_t va = vld1q_u16(&A[i]);\n        uint16x8_t vb = vld1q_u16(&B[i]);\n        uint16x8_t vc = vandq_u16(va, vb);\n        vst1q_u16(&C[i], vc);\n    }\n\n    // Handle remaining elements after the midpoint\n    for (; i < length; ++i) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_44_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t mid = length / 2;\n    size_t i = 0;\n\n    // Process elements before the midpoint\n    for (; i <= mid - 8; i += 8) {\n        uint16x8_t va = vld1q_u16(&A[i]);\n        uint16x8_t vb = vld1q_u16(&B[i]);\n        uint16x8_t vc = veorq_u16(va, vb);\n        vst1q_u16(&C[i], vc);\n    }\n\n    // Handle remaining elements before the midpoint\n    for (; i < mid; ++i) {\n        C[i] = A[i] ^ B[i];\n    }\n\n    // Handle the midpoint element\n    if (length % 2 == 0) {\n        C[mid] = A[mid];\n    } else {\n        C[mid] = A[mid];\n        ++mid;\n    }\n\n    // Process elements after the midpoint\n    for (i = mid; i <= length - 8; i += 8) {\n        uint16x8_t va = vld1q_u16(&A[i]);\n        uint16x8_t vb = vld1q_u16(&B[i]);\n        uint16x8_t vc = vandq_u16(va, vb);\n        vst1q_u16(&C[i], vc);\n    }\n\n    // Handle remaining elements after the midpoint\n    for (; i < length; ++i) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_44_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t mid = length / 2;\n    size_t i = 0;\n\n    // Process elements before the midpoint\n    for (; i <= mid - 8; i += 8) {\n        uint16x8_t va = vld1q_u16(&A[i]);\n        uint16x8_t vb = vld1q_u16(&B[i]);\n        uint16x8_t vc = veorq_u16(va, vb);\n        vst1q_u16(&C[i], vc);\n    }\n\n    // Handle remaining elements before the midpoint\n    for (; i < mid; ++i) {\n        C[i] = A[i] ^ B[i];\n    }\n\n    // Handle the midpoint element\n    C[mid] = A[mid];\n\n    // Process elements after the midpoint\n    i = mid + 1;\n    for (; i <= length - 8; i += 8) {\n        uint16x8_t va = vld1q_u16(&A[i]);\n        uint16x8_t vb = vld1q_u16(&B[i]);\n        uint16x8_t vc = vandq_u16(va, vb);\n        vst1q_u16(&C[i], vc);\n    }\n\n    // Handle remaining elements after the midpoint\n    for (; i < length; ++i) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_45_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n\n    for (size_t i = 0; i < total_elements; i += 4) {\n        // Load 4 elements from each input tensor\n        float32x4_t vec_A = vld1q_f32(A + i);\n        float32x4_t vec_B = vld1q_f32(B + i);\n        float32x4_t vec_C = vld1q_f32(C + i);\n        float32x4_t vec_D = vld1q_f32(D + i);\n\n        // Load 4 boolean conditions and convert them to 32-bit masks\n        uint32x4_t vec_cond1 = vld1q_u32((const uint32_t*)(cond1 + i));\n        uint32x4_t vec_cond2 = vld1q_u32((const uint32_t*)(cond2 + i));\n\n        // Compute masks for the four cases\n        uint32x4_t mask_case1 = vandq_u32(vec_cond1, vec_cond2); // cond1 && cond2\n        uint32x4_t mask_case2 = vandq_u32(vec_cond1, vmvnq_u32(vec_cond2)); // cond1 && !cond2\n        uint32x4_t mask_case3 = vandq_u32(vmvnq_u32(vec_cond1), vec_cond2); // !cond1 && cond2\n        uint32x4_t mask_case4 = vandq_u32(vmvnq_u32(vec_cond1), vmvnq_u32(vec_cond2)); // !cond1 && !cond2\n\n        // Select values based on the masks\n        float32x4_t result = vbslq_f32(mask_case1, vec_A, vec_D); // Case 1: A, otherwise D\n        result = vbslq_f32(mask_case2, vec_B, result); // Case 2: B, otherwise previous result\n        result = vbslq_f32(mask_case3, vec_C, result); // Case 3: C, otherwise previous result\n\n        // Store the result back to the output tensor\n        vst1q_f32(out + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_45_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n\n    for (size_t i = 0; i < total_elements; i += 4) {\n        // Load 4 elements from each input tensor\n        float32x4_t vec_A = vld1q_f32(A + i);\n        float32x4_t vec_B = vld1q_f32(B + i);\n        float32x4_t vec_C = vld1q_f32(C + i);\n        float32x4_t vec_D = vld1q_f32(D + i);\n\n        // Load 4 boolean conditions and convert them to 32-bit masks\n        uint32x4_t vec_cond1 = vld1q_u32((const uint32_t*)(cond1 + i));\n        uint32x4_t vec_cond2 = vld1q_u32((const uint32_t*)(cond2 + i));\n\n        // Compute masks for the four cases\n        uint32x4_t mask_case1 = vandq_u32(vec_cond1, vec_cond2); // cond1 && cond2\n        uint32x4_t mask_case2 = vandq_u32(vec_cond1, vmvnq_u32(vec_cond2)); // cond1 && !cond2\n        uint32x4_t mask_case3 = vandq_u32(vmvnq_u32(vec_cond1), vec_cond2); // !cond1 && cond2\n        uint32x4_t mask_case4 = vandq_u32(vmvnq_u32(vec_cond1), vmvnq_u32(vec_cond2)); // !cond1 && !cond2\n\n        // Select values based on the masks\n        float32x4_t result = vbslq_f32(mask_case1, vec_A, vec_D); // Case 1: A, otherwise D\n        result = vbslq_f32(mask_case2, vec_B, result); // Case 2: B, otherwise previous result\n        result = vbslq_f32(mask_case3, vec_C, result); // Case 3: C, otherwise previous result\n        result = vbslq_f32(mask_case4, vec_D, result); // Case 4: D, otherwise previous result\n\n        // Store the result back to the output tensor\n        vst1q_f32(out + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_45_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n\n    for (size_t i = 0; i < total_elements; i += 4) {\n        // Load 4 elements from each input tensor\n        float32x4_t vec_A = vld1q_f32(A + i);\n        float32x4_t vec_B = vld1q_f32(B + i);\n        float32x4_t vec_C = vld1q_f32(C + i);\n        float32x4_t vec_D = vld1q_f32(D + i);\n\n        // Load 4 boolean conditions from cond1 and cond2\n        uint32x4_t vec_cond1 = vld1q_u32((const uint32_t*)(cond1 + i));\n        uint32x4_t vec_cond2 = vld1q_u32((const uint32_t*)(cond2 + i));\n\n        // Convert boolean conditions to masks (0xFFFFFFFF for true, 0x0 for false)\n        uint32x4_t mask_cond1 = vreinterpretq_u32_u8(vcltq_u32(vec_cond1, vdupq_n_u32(1)));\n        uint32x4_t mask_cond2 = vreinterpretq_u32_u8(vcltq_u32(vec_cond2, vdupq_n_u32(1)));\n\n        // Compute combined masks for the four cases\n        uint32x4_t mask_case1 = vandq_u32(mask_cond1, mask_cond2); // cond1 && cond2\n        uint32x4_t mask_case2 = vandq_u32(mask_cond1, vmvnq_u32(mask_cond2)); // cond1 && !cond2\n        uint32x4_t mask_case3 = vandq_u32(vmvnq_u32(mask_cond1), mask_cond2); // !cond1 && cond2\n        uint32x4_t mask_case4 = vandq_u32(vmvnq_u32(mask_cond1), vmvnq_u32(mask_cond2)); // !cond1 && !cond2\n\n        // Select values based on masks\n        float32x4_t result = vbslq_f32(mask_case1, vec_A, vec_D);\n        result = vbslq_f32(mask_case2, vec_B, result);\n        result = vbslq_f32(mask_case3, vec_C, result);\n\n        // Store the result back to the output tensor\n        vst1q_f32(out + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_45_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n\n    for (size_t i = 0; i < total_elements; i += 4) {\n        // Load 4 elements from each input tensor\n        float32x4_t vecA = vld1q_f32(&A[i]);\n        float32x4_t vecB = vld1q_f32(&B[i]);\n        float32x4_t vecC = vld1q_f32(&C[i]);\n        float32x4_t vecD = vld1q_f32(&D[i]);\n\n        // Load 4 boolean conditions and convert them to uint32x4_t\n        uint32x4_t vecCond1 = vld1q_u32((const uint32_t*)&cond1[i]);\n        uint32x4_t vecCond2 = vld1q_u32((const uint32_t*)&cond2[i]);\n\n        // Compute masks for the conditions\n        uint32x4_t maskCond1AndCond2 = vandq_u32(vecCond1, vecCond2); // cond1 && cond2\n        uint32x4_t maskCond1NotCond2 = vbicq_u32(vecCond1, vecCond2); // cond1 && !cond2\n        uint32x4_t maskNotCond1Cond2 = vbicq_u32(vecCond2, vecCond1); // !cond1 && cond2\n        uint32x4_t maskNotCond1NotCond2 = vbicq_u32(vbicq_u32(vdupq_n_u32(0xFFFFFFFF), vecCond1), vecCond2); // !cond1 && !cond2\n\n        // Perform selection based on masks\n        float32x4_t result = vbslq_f32(maskCond1AndCond2, vecA, vecD);\n        result = vbslq_f32(maskCond1NotCond2, vecB, result);\n        result = vbslq_f32(maskNotCond1Cond2, vecC, result);\n\n        // Store the result back to the output tensor\n        vst1q_f32(&out[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_45_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n\n    for (size_t i = 0; i < total_elements; i += 4) {\n        // Load 4 elements from each input tensor\n        float32x4_t vec_A = vld1q_f32(A + i);\n        float32x4_t vec_B = vld1q_f32(B + i);\n        float32x4_t vec_C = vld1q_f32(C + i);\n        float32x4_t vec_D = vld1q_f32(D + i);\n\n        // Load 4 boolean conditions and convert them to 32-bit masks\n        uint32x4_t vec_cond1 = vld1q_u32((const uint32_t*)(cond1 + i));\n        uint32x4_t vec_cond2 = vld1q_u32((const uint32_t*)(cond2 + i));\n\n        // Compute masks for the four cases\n        uint32x4_t mask_case1 = vandq_u32(vec_cond1, vec_cond2); // cond1 && cond2\n        uint32x4_t mask_case2 = vandq_u32(vec_cond1, vmvnq_u32(vec_cond2)); // cond1 && !cond2\n        uint32x4_t mask_case3 = vandq_u32(vmvnq_u32(vec_cond1), vec_cond2); // !cond1 && cond2\n        uint32x4_t mask_case4 = vandq_u32(vmvnq_u32(vec_cond1), vmvnq_u32(vec_cond2)); // !cond1 && !cond2\n\n        // Select values based on the masks\n        float32x4_t result = vbslq_f32(mask_case1, vec_A, vec_D); // Case 1: A, otherwise D\n        result = vbslq_f32(mask_case2, vec_B, result); // Case 2: B, otherwise previous result\n        result = vbslq_f32(mask_case3, vec_C, result); // Case 3: C, otherwise previous result\n        result = vbslq_f32(mask_case4, vec_D, result); // Case 4: D, otherwise previous result\n\n        // Store the result back to the output tensor\n        vst1q_f32(out + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_46_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n\n    for (size_t i = 0; i < total_elements; i += 4) {\n        // Load 4 uint32_t elements from A into a Neon register\n        uint32x4_t vec = vld1q_u32(&A[i]);\n\n        // Count the number of bits set to 1 in each lane\n        uint8x8_t bit_count_low = vcnt_u8(vreinterpret_u8_u32(vec));\n        uint8x8_t bit_count_high = vcnt_u8(vreinterpret_u8_u32(vshrq_n_u32(vec, 8)));\n        uint8x8_t bit_count_16 = vpadd_u8(bit_count_low, bit_count_high);\n\n        bit_count_low = vcnt_u8(vreinterpret_u8_u32(vshrq_n_u32(vec, 16)));\n        bit_count_high = vcnt_u8(vreinterpret_u8_u32(vshrq_n_u32(vec, 24)));\n        uint8x8_t bit_count_32 = vpadd_u8(bit_count_low, bit_count_high);\n\n        uint8x8_t final_count = vpadd_u8(bit_count_16, bit_count_32);\n\n        // Store the results into the output array\n        vst1_lane_u32((uint32_t*)&out[i], vreinterpret_u32_u8(final_count), 0);\n    }\n}\n```"}
{"task_id": "SimdBench_46_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n\n    for (size_t i = 0; i < total_elements; i += 4) {\n        // Load 4 uint32_t elements from A into a Neon register\n        uint32x4_t vec = vld1q_u32(&A[i]);\n\n        // Count the number of bits set to 1 in each lane of the vector\n        uint8x8_t bit_count_low = vcnt_u8(vreinterpret_u8_u32(vec));\n        uint8x8_t bit_count_high = vcnt_u8(vreinterpret_u8_u32(vshrq_n_u32(vec, 8)));\n        uint8x8_t bit_count_combined = vpadd_u8(bit_count_low, bit_count_high);\n\n        // Extract the results and store them in the output array\n        uint16x4_t bit_count_final = vpaddl_u8(bit_count_combined);\n        uint8x8_t result = vmovn_u16(bit_count_final);\n\n        // Store the results back to the output array\n        vst1_u8(&out[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_46_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n\n    for (size_t i = 0; i < total_elements; i += 4) {\n        // Load 4 uint32_t elements from A into a Neon register\n        uint32x4_t vec = vld1q_u32(&A[i]);\n\n        // Count the number of bits set to 1 in each lane\n        uint8x8_t bit_count_low = vcnt_u8(vreinterpret_u8_u32(vec));\n        uint8x8_t bit_count_high = vcnt_u8(vreinterpret_u8_u32(vshrq_n_u32(vec, 8)));\n        uint8x8_t bit_count_combined = vpadd_u8(bit_count_low, bit_count_high);\n\n        // Extract the results and store them in the output array\n        uint16x4_t bit_count_final = vpaddl_u8(bit_count_combined);\n        uint8x8_t result = vmovn_u16(bit_count_final);\n\n        // Store the results back to the output array\n        vst1_lane_u32((uint32_t*)&out[i], vreinterpret_u32_u8(result), 0);\n    }\n}\n```"}
{"task_id": "SimdBench_46_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n\n    for (size_t i = 0; i < total_elements; i += 4) {\n        // Load 4 elements from A into a Neon register\n        uint32x4_t vec = vld1q_u32(&A[i]);\n\n        // Count the number of bits set to 1 in each element\n        uint8x8_t bit_count_low = vcnt_u8(vreinterpret_u8_u32(vec));\n        uint8x8_t bit_count_high = vcnt_u8(vreinterpret_u8_u32(vshrq_n_u32(vec, 8)));\n        uint8x8_t bit_count_combined = vpadd_u8(bit_count_low, bit_count_high);\n\n        // Extract the results and store them in the output array\n        uint16x4_t bit_count_final = vpaddl_u8(bit_count_combined);\n        uint8x8_t result = vmovn_u16(bit_count_final);\n\n        // Store the results back to the output array\n        vst1_lane_u32((uint32_t*)&out[i], vreinterpret_u32_u8(result), 0);\n    }\n}\n```"}
{"task_id": "SimdBench_46_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n\n    size_t i = 0;\n    for (; i + 4 <= total_elements; i += 4) {\n        // Load 4 elements from A into a Neon register\n        uint32x4_t vec = vld1q_u32(&A[i]);\n\n        // Count the number of bits set to 1 in each element\n        uint8x8_t bit_count_low = vcnt_u8(vreinterpret_u8_u32(vec));\n        uint8x8_t bit_count_high = vcnt_u8(vreinterpret_u8_u32(vshrq_n_u32(vec, 8)));\n        uint8x8_t bit_count_combined = vpadd_u8(bit_count_low, bit_count_high);\n\n        // Extract the results and store them in out\n        uint16x4_t bit_count_final = vpaddl_u8(bit_count_combined);\n        uint8x8_t result = vmovn_u16(bit_count_final);\n\n        vst1_u8(&out[i], result);\n    }\n\n    // Handle remaining elements\n    for (; i < total_elements; ++i) {\n        out[i] = __builtin_popcount(A[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_47_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t num_elements = rows * cols;\n    size_t i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 3 < num_elements; i += 4) {\n        // Load 4 elements from A into a NEON register\n        int32x4_t va = vld1q_s32(&A[i]);\n\n        // Create a mask to check divisibility by 3\n        int32x4_t divisible_by_3_mask = vceqq_s32(vmodq_s32(va, vmovq_n_s32(3)), vmovq_n_s32(0));\n\n        // Compute the absolute value of the elements in A\n        int32x4_t abs_a = vabsq_s32(va);\n\n        // Use the mask to select between abs(A) and A\n        int32x4_t result = vbslq_s32(divisible_by_3_mask, abs_a, va);\n\n        // Store the result into B\n        vst1q_s32(&B[i], result);\n    }\n\n    // Handle remaining elements (if any) with scalar code\n    for (; i < num_elements; ++i) {\n        if (A[i] % 3 == 0) {\n            B[i] = abs(A[i]);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t simd_elements = total_elements / 4 * 4;\n\n    int32x4_t vthree = vdupq_n_s32(3);\n    int32x4_t vzero = vdupq_n_s32(0);\n\n    size_t i = 0;\n    for (; i < simd_elements; i += 4) {\n        int32x4_t va = vld1q_s32(&A[i]);\n        int32x4_t vremainder = vqrdmulhq_s32(va, vthree);\n        vremainder = vmulq_s32(vremainder, vthree);\n        uint32x4_t vcondition = vceqq_s32(va, vremainder);\n\n        int32x4_t vabs = vabsq_s32(va);\n        int32x4_t vresult = vbslq_s32(vcondition, vabs, va);\n\n        vst1q_s32(&B[i], vresult);\n    }\n\n    for (; i < total_elements; ++i) {\n        if (A[i] % 3 == 0) {\n            B[i] = abs(A[i]);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t simd_elements = total_elements / 4 * 4;\n\n    const int32x4_t three_vec = vdupq_n_s32(3);\n    const int32x4_t zero_vec = vdupq_n_s32(0);\n\n    size_t i = 0;\n    for (; i < simd_elements; i += 4) {\n        // Load 4 elements from A\n        int32x4_t a_vec = vld1q_s32(&A[i]);\n\n        // Check if each element is divisible by 3\n        uint32x4_t divisible_mask = vceqq_s32(vqrdmulhq_n_s32(a_vec, 3), a_vec);\n\n        // Compute absolute values of the elements in A\n        int32x4_t abs_a_vec = vabsq_s32(a_vec);\n\n        // Select between original value and absolute value based on mask\n        int32x4_t result_vec = vbslq_s32(divisible_mask, abs_a_vec, a_vec);\n\n        // Store the result into B\n        vst1q_s32(&B[i], result_vec);\n    }\n\n    // Handle remaining elements (if any)\n    for (; i < total_elements; ++i) {\n        if (A[i] % 3 == 0) {\n            B[i] = abs(A[i]);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t num_elements = rows * cols;\n    size_t i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= num_elements - 4; i += 4) {\n        // Load 4 elements from A into a NEON register\n        int32x4_t va = vld1q_s32(&A[i]);\n\n        // Create a mask to check if each element is divisible by 3\n        int32x4_t vdiv3 = vmulq_n_s32(vdivq_s32(va, vdupq_n_s32(3)), 3);\n        uint32x4_t mask = vceqq_s32(va, vdiv3);\n\n        // Compute the absolute value of the elements in A\n        int32x4_t vabs = vabsq_s32(va);\n\n        // Use the mask to select between the original value and its absolute value\n        int32x4_t result = vbslq_s32(mask, vabs, va);\n\n        // Store the result back to B\n        vst1q_s32(&B[i], result);\n    }\n\n    // Handle remaining elements (if any) with scalar code\n    for (; i < num_elements; ++i) {\n        if (A[i] % 3 == 0) {\n            B[i] = abs(A[i]);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t num_elements = rows * cols;\n    size_t i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= num_elements - 4; i += 4) {\n        // Load 4 elements from A into a NEON register\n        int32x4_t va = vld1q_s32(&A[i]);\n\n        // Create a mask where each element is true if divisible by 3\n        uint32x4_t mask = vceqq_s32(vremq_n_s32(va, 3), vmovq_n_s32(0));\n\n        // Compute the absolute value of the elements in A\n        int32x4_t abs_a = vabsq_s32(va);\n\n        // Use the mask to blend between abs(A) and A\n        int32x4_t result = vbslq_s32(mask, abs_a, va);\n\n        // Store the result back to B\n        vst1q_s32(&B[i], result);\n    }\n\n    // Handle remaining elements (if any) with scalar code\n    for (; i < num_elements; ++i) {\n        if (A[i] % 3 == 0) {\n            B[i] = abs(A[i]);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    const uint32x4_t mask_low4 = vdupq_n_u32(0xF); // Mask for low 4 bits\n    const uint32x4_t ones = vdupq_n_u32(0xFFFFFFFF); // All ones for bitwise negation\n    const uint32x4_t rotate_bits_vec = vdupq_n_u32(rotate_bits); // Broadcast rotate_bits\n\n    for (size_t i = 0; i < length; i += 4) {\n        uint32x4_t src_vec = vld1q_u32(&src[i]); // Load 4 elements from src\n\n        // Extract low 4 bits and check if they are all 1s\n        uint32x4_t low4_bits = vandq_u32(src_vec, mask_low4);\n        uint32x4_t condition = vceqq_u32(low4_bits, mask_low4);\n\n        // Perform bitwise rotation for elements where condition is true\n        uint32x4_t rotated = vshrq_n_u32(src_vec, rotate_bits); // Right shift\n        uint32x4_t shifted_back = vshlq_u32(src_vec, vsubq_u32(vdupq_n_u32(32), rotate_bits_vec)); // Left shift\n        rotated = vorrq_u32(rotated, shifted_back); // Combine shifts\n\n        // Perform bitwise negation for elements where condition is false\n        uint32x4_t negated = veorq_u32(src_vec, ones);\n\n        // Select between rotated and negated based on the condition\n        uint32x4_t result = vbslq_u32(condition, rotated, negated);\n\n        // Store the result into dst\n        vst1q_u32(&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_48_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    const uint32x4_t mask_low4 = vdupq_n_u32(0xF); // Mask to extract low 4 bits\n    const uint32x4_t ones = vdupq_n_u32(0xFFFFFFFF); // All ones for bitwise negation\n    const uint32x4_t rotate_mask = vdupq_n_u32((1 << rotate_bits) - 1); // Mask for rotation\n\n    for (size_t i = 0; i < length; i += 4) {\n        uint32x4_t src_vec = vld1q_u32(&src[i]); // Load 4 elements from src\n\n        // Extract low 4 bits and check if they are all 1s\n        uint32x4_t low4_bits = vandq_u32(src_vec, mask_low4);\n        uint32x4_t condition = vceqq_u32(low4_bits, mask_low4);\n\n        // Perform bitwise negation\n        uint32x4_t negated = veorq_u32(src_vec, ones);\n\n        // Perform rotation\n        uint32x4_t rotated = vorrq_u32(\n            vshrq_n_u32(src_vec, rotate_bits),\n            vandq_u32(vshlq_n_u32(src_vec, 32 - rotate_bits), rotate_mask)\n        );\n\n        // Select between rotated and negated based on condition\n        uint32x4_t result = vbslq_u32(condition, rotated, negated);\n\n        // Store the result into dst\n        vst1q_u32(&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_48_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    const uint32x4_t low4_mask = vdupq_n_u32(0xF); // Mask to extract low 4 bits\n    const uint32x4_t ones = vdupq_n_u32(0xFFFFFFFF); // All ones for bitwise negation\n    const uint32x4_t rotate_bits_vec = vdupq_n_u32(rotate_bits); // Broadcast rotate_bits to vector\n\n    for (size_t i = 0; i < length; i += 4) {\n        // Load 4 elements from src\n        uint32x4_t src_vec = vld1q_u32(&src[i]);\n\n        // Extract low 4 bits of each element\n        uint32x4_t low4_bits = vandq_u32(src_vec, low4_mask);\n\n        // Check if low 4 bits are all 1s (0xF)\n        uint32x4_t condition = vceqq_u32(low4_bits, vdupq_n_u32(0xF));\n\n        // Perform bitwise rotation for elements where condition is true\n        uint32x4_t rotated = vshrq_n_u32(src_vec, rotate_bits);\n        rotated = vorrq_u32(rotated, vshlq_u32(src_vec, vsubq_u32(vdupq_n_u32(32), rotate_bits_vec)));\n\n        // Perform bitwise negation for elements where condition is false\n        uint32x4_t negated = vmvnq_u32(src_vec);\n\n        // Select between rotated and negated based on condition\n        uint32x4_t result = vbslq_u32(condition, rotated, negated);\n\n        // Store the result into dst\n        vst1q_u32(&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_48_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t i = 0;\n    const uint32x4_t low_4_bits_mask = vdupq_n_u32(0xF); // Mask to extract low 4 bits\n    const uint32x4_t ones = vdupq_n_u32(0xFFFFFFFF);     // All ones for bitwise negation\n\n    for (; i + 4 <= length; i += 4) {\n        uint32x4_t src_vec = vld1q_u32(&src[i]);               // Load 4 elements from src\n        uint32x4_t low_4_bits = vandq_u32(src_vec, low_4_bits_mask); // Extract low 4 bits\n        uint32x4_t condition = vceqq_u32(low_4_bits, low_4_bits_mask); // Check if low 4 bits are all 1s\n\n        // Rotate right by rotate_bits\n        uint32x4_t rotated = vshrq_n_u32(src_vec, rotate_bits);         // Shift right\n        uint32x4_t shifted_left = vshlq_n_u32(src_vec, 32 - rotate_bits); // Shift left\n        rotated = vorrq_u32(rotated, shifted_left);                      // Combine shifts\n\n        // Bitwise negation\n        uint32x4_t negated = veorq_u32(src_vec, ones);\n\n        // Select based on condition\n        uint32x4_t result = vbslq_u32(condition, rotated, negated);\n        vst1q_u32(&dst[i], result); // Store result into dst\n    }\n\n    // Handle remaining elements\n    for (; i < length; ++i) {\n        if ((src[i] & 0xF) == 0xF) {\n            dst[i] = (src[i] >> rotate_bits) | (src[i] << (32 - rotate_bits));\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    const uint32x4_t mask_low4 = vdupq_n_u32(0xF); // Mask to extract low 4 bits\n    const uint32x4_t ones = vdupq_n_u32(0xFFFFFFFF); // All ones for bitwise NOT\n    const uint32x4_t rotate_bits_vec = vdupq_n_u32(rotate_bits); // Broadcast rotate_bits\n\n    for (size_t i = 0; i < length; i += 4) {\n        // Load 4 elements from src\n        uint32x4_t src_vec = vld1q_u32(&src[i]);\n\n        // Extract low 4 bits of each element\n        uint32x4_t low4_bits = vandq_u32(src_vec, mask_low4);\n\n        // Check if low 4 bits are all 1s\n        uint32x4_t condition = vceqq_u32(low4_bits, mask_low4);\n\n        // Perform bitwise rotation for elements where condition is true\n        uint32x4_t rotated = vshrq_n_u32(src_vec, rotate_bits);\n        rotated = vorrq_u32(rotated, vshlq_u32(src_vec, vsubq_u32(vdupq_n_u32(32), rotate_bits_vec)));\n\n        // Perform bitwise NOT for elements where condition is false\n        uint32x4_t negated = vmvnq_u32(src_vec);\n\n        // Select between rotated and negated based on condition\n        uint32x4_t result = vbslq_u32(condition, rotated, negated);\n\n        // Store the result into dst\n        vst1q_u32(&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_49_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float32x4_t v_epsilon = vdupq_n_f32(epsilon);\n    float32x4_t v_neg_epsilon = vdupq_n_f32(-epsilon);\n    int32x4_t v_one = vdupq_n_s32(1);\n    int32x4_t v_zero = vdupq_n_s32(0);\n    int32x4_t v_neg_one = vdupq_n_s32(-1);\n\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        float32x4_t v_a = vld1q_f32(&A[i]);\n        float32x4_t v_b = vld1q_f32(&B[i]);\n\n        float32x4_t v_diff = vsubq_f32(v_a, v_b);\n\n        uint32x4_t v_gt = vcgtq_f32(v_diff, v_epsilon);\n        uint32x4_t v_lt = vcltq_f32(v_diff, v_neg_epsilon);\n\n        int32x4_t v_result = vbslq_s32(vreinterpretq_u32_u64(vandq_u32(vreinterpretq_u32_u64(v_gt), vmvnq_u32(vreinterpretq_u32_u64(v_lt)))), v_one, v_zero);\n        v_result = vbslq_s32(vreinterpretq_u32_u64(vandq_u32(vreinterpretq_u32_u64(v_lt), vmvnq_u32(vreinterpretq_u32_u64(v_gt)))), v_neg_one, v_result);\n\n        int8x8_t v_result_packed = vqmovn_s16(vcombine_s16(vqmovn_s32(v_result), vqmovn_s32(v_result)));\n        vst1_lane_s32((int32_t*)&out[i], vreinterpret_s32_s8(v_result_packed), 0);\n    }\n\n    for (; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > epsilon) {\n            out[i] = 1;\n        } else if (diff < -epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float32x4_t v_epsilon = vdupq_n_f32(epsilon);\n    float32x4_t v_neg_epsilon = vdupq_n_f32(-epsilon);\n\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 elements from A and B\n        float32x4_t v_a = vld1q_f32(&A[i]);\n        float32x4_t v_b = vld1q_f32(&B[i]);\n\n        // Compute difference: A - B\n        float32x4_t v_diff = vsubq_f32(v_a, v_b);\n\n        // Compare A - B > epsilon\n        uint32x4_t v_gt = vcgtq_f32(v_diff, v_epsilon);\n\n        // Compare A - B < -epsilon\n        uint32x4_t v_lt = vcltq_f32(v_diff, v_neg_epsilon);\n\n        // Combine results into ternary values: 1 for gt, -1 for lt, 0 otherwise\n        int8x8_t v_result = vbsl_s8(vreinterpret_s8_u32(vorrq_u32(v_gt, v_lt)),\n                                     vdup_n_s8(1),\n                                     vdup_n_s8(0));\n        v_result = vbsl_s8(vreinterpret_s8_u32(v_gt), vdup_n_s8(1), v_result);\n        v_result = vbsl_s8(vreinterpret_s8_u32(v_lt), vdup_n_s8(-1), v_result);\n\n        // Store the result into the output array\n        vst1_s8(&out[i], v_result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > epsilon) {\n            out[i] = 1;\n        } else if (diff < -epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float32x4_t v_epsilon = vdupq_n_f32(epsilon);\n    float32x4_t v_neg_epsilon = vdupq_n_f32(-epsilon);\n\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        float32x4_t v_a = vld1q_f32(&A[i]);\n        float32x4_t v_b = vld1q_f32(&B[i]);\n\n        float32x4_t v_diff = vsubq_f32(v_a, v_b);\n\n        uint32x4_t v_gt = vcgtq_f32(v_diff, v_epsilon);\n        uint32x4_t v_lt = vcltq_f32(v_diff, v_neg_epsilon);\n\n        int8x8_t v_result = vdup_n_s8(0);\n        v_result = vorr_s8(v_result, vreinterpret_s8_u8(vand_u8(vmovn_u16(vshll_n_u8(vget_low_u8(vreinterpret_u8_u32(v_gt)), 7)), vdup_n_u8(1))));\n        v_result = vorr_s8(v_result, vreinterpret_s8_u8(vand_u8(vmovn_u16(vshll_n_u8(vget_low_u8(vreinterpret_u8_u32(v_lt)), 7)), vdup_n_u8(-1))));\n\n        vst1_s8(&out[i], v_result);\n    }\n\n    for (; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > epsilon) {\n            out[i] = 1;\n        } else if (diff < -epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float32x4_t v_epsilon = vdupq_n_f32(epsilon);\n    float32x4_t v_neg_epsilon = vdupq_n_f32(-epsilon);\n\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 elements from A and B\n        float32x4_t v_a = vld1q_f32(&A[i]);\n        float32x4_t v_b = vld1q_f32(&B[i]);\n\n        // Compute difference: A - B\n        float32x4_t v_diff = vsubq_f32(v_a, v_b);\n\n        // Compare A[i] - B[i] > epsilon\n        uint32x4_t v_gt = vcgtq_f32(v_diff, v_epsilon);\n\n        // Compare A[i] - B[i] < -epsilon\n        uint32x4_t v_lt = vcltq_f32(v_diff, v_neg_epsilon);\n\n        // Combine results into ternary values\n        int8x8_t v_result = vdup_n_s8(0); // Initialize result to 0\n        v_result = vorr_s8(v_result, vand_s8(vreinterpret_s8_u32(v_gt), vdup_n_s8(1)));   // Set 1 where gt is true\n        v_result = vorr_s8(v_result, vand_s8(vreinterpret_s8_u32(v_lt), vdup_n_s8(-1))); // Set -1 where lt is true\n\n        // Store the result into the output array\n        int8x8_t v_packed_result = vzip_s8(v_result, v_result).val[0];\n        vst1_lane_s32((int32_t*)&out[i], vreinterpret_s32_s8(v_packed_result), 0);\n    }\n\n    // Handle remaining elements\n    for (; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > epsilon) {\n            out[i] = 1;\n        } else if (diff < -epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float32x4_t v_epsilon = vdupq_n_f32(epsilon);\n    float32x4_t v_neg_epsilon = vdupq_n_f32(-epsilon);\n    int32x4_t v_one = vdupq_n_s32(1);\n    int32x4_t v_zero = vdupq_n_s32(0);\n    int32x4_t v_neg_one = vdupq_n_s32(-1);\n\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        float32x4_t v_a = vld1q_f32(&A[i]);\n        float32x4_t v_b = vld1q_f32(&B[i]);\n\n        float32x4_t v_diff = vsubq_f32(v_a, v_b);\n\n        uint32x4_t v_gt = vcgtq_f32(v_diff, v_epsilon);\n        uint32x4_t v_lt = vcltq_f32(v_diff, v_neg_epsilon);\n\n        int32x4_t v_result = vbslq_s32(vreinterpretq_u32_u64(v_gt), v_one, v_zero);\n        v_result = vbslq_s32(vreinterpretq_u32_u64(v_lt), v_neg_one, v_result);\n\n        int8x8_t v_packed_result = vmovn_s32(v_result);\n        vst1_s8(&out[i], v_packed_result);\n    }\n\n    for (; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > epsilon) {\n            out[i] = 1;\n        } else if (diff < -epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <limits.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    const float32x4_t vmax = vdupq_n_f32((float)INT32_MAX);\n    const float32x4_t vmin = vdupq_n_f32((float)INT32_MIN);\n\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 floats from A\n        float32x4_t va = vld1q_f32(&A[i]);\n\n        // Clamp values between INT32_MIN and INT32_MAX\n        va = vmaxq_f32(va, vmin);\n        va = vminq_f32(va, vmax);\n\n        // Convert to int32_t with saturation\n        int32x4_t vb = vcvtq_s32_f32(va);\n\n        // Store the result into B\n        vst1q_s32(&B[i], vb);\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        float val = A[i];\n        if (val > (float)INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (val < (float)INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <limits.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    const float32x4_t max_val = vdupq_n_f32((float)INT32_MAX);\n    const float32x4_t min_val = vdupq_n_f32((float)INT32_MIN);\n\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 floats from A\n        float32x4_t va = vld1q_f32(&A[i]);\n\n        // Clamp values between INT32_MIN and INT32_MAX\n        va = vmaxq_f32(va, min_val);\n        va = vminq_f32(va, max_val);\n\n        // Convert the clamped float values to int32_t\n        int32x4_t vi = vcvtq_s32_f32(va);\n\n        // Store the result into B\n        vst1q_s32(&B[i], vi);\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        float val = A[i];\n        if (val > (float)INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (val < (float)INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <limits.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    const float32x4_t max_val = vdupq_n_f32((float)INT32_MAX);\n    const float32x4_t min_val = vdupq_n_f32((float)INT32_MIN);\n\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 floats from A\n        float32x4_t va = vld1q_f32(&A[i]);\n\n        // Clamp the values between INT32_MIN and INT32_MAX\n        va = vmaxq_f32(va, min_val);\n        va = vminq_f32(va, max_val);\n\n        // Convert the clamped float values to int32_t\n        int32x4_t vi = vcvtq_s32_f32(va);\n\n        // Store the result into B\n        vst1q_s32(&B[i], vi);\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        float val = A[i];\n        if (val > (float)INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (val < (float)INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <limits.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    const float32x4_t vmax = vdupq_n_f32((float)INT32_MAX);\n    const float32x4_t vmin = vdupq_n_f32((float)INT32_MIN);\n\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 floats from A\n        float32x4_t va = vld1q_f32(&A[i]);\n\n        // Clamp values between INT32_MIN and INT32_MAX\n        va = vmaxq_f32(va, vmin);\n        va = vminq_f32(va, vmax);\n\n        // Convert to int32_t with saturation\n        int32x4_t vb = vcvtq_s32_f32(va);\n\n        // Store the result into B\n        vst1q_s32(&B[i], vb);\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        float val = A[i];\n        if (val > (float)INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (val < (float)INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <limits.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    const float32x4_t max_val = vdupq_n_f32((float)INT32_MAX);\n    const float32x4_t min_val = vdupq_n_f32((float)INT32_MIN);\n\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 floats from A\n        float32x4_t va = vld1q_f32(&A[i]);\n\n        // Clamp the values between INT32_MIN and INT32_MAX\n        va = vmaxq_f32(va, min_val);\n        va = vminq_f32(va, max_val);\n\n        // Convert the clamped float values to int32_t\n        int32x4_t vi = vcvtq_s32_f32(va);\n\n        // Store the result into B\n        vst1q_s32(&B[i], vi);\n    }\n\n    // Handle remaining elements (if any)\n    for (; i < size; ++i) {\n        float val = A[i];\n        if (val > (float)INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (val < (float)INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_51_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    float32x4_t scale_vec = vmovq_n_f32((float)scale);\n    size_t i = 0;\n\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 int32_t values from A\n        int32x4_t int_vec = vld1q_s32(&A[i]);\n\n        // Convert int32_t to float32\n        float32x4_t float_vec = vcvtq_f32_s32(int_vec);\n\n        // Scale the float values\n        float_vec = vmulq_f32(float_vec, scale_vec);\n\n        // Store the result into B\n        vst1q_f32(&B[i], float_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    float32x4_t scale_vec = vmovq_n_f32((float)scale);\n    size_t i = 0;\n\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 int32_t values from A\n        int32x4_t int_vec = vld1q_s32(&A[i]);\n\n        // Convert int32_t to float32\n        float32x4_t float_vec = vcvtq_f32_s32(int_vec);\n\n        // Scale the float values\n        float_vec = vmulq_f32(float_vec, scale_vec);\n\n        // Store the result into B\n        vst1q_f32(&B[i], float_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    float32x4_t scale_vec = vmovq_n_f32((float)scale);\n    size_t i = 0;\n\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 int32_t values from A\n        int32x4_t int_vec = vld1q_s32(&A[i]);\n\n        // Convert int32_t to float32\n        float32x4_t float_vec = vcvtq_f32_s32(int_vec);\n\n        // Scale the float values\n        float_vec = vmulq_f32(float_vec, scale_vec);\n\n        // Store the result in B\n        vst1q_f32(&B[i], float_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    float32x4_t scale_vec = vmovq_n_f32((float)scale);\n    size_t i = 0;\n\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 int32_t values from A\n        int32x4_t int_vec = vld1q_s32(&A[i]);\n\n        // Convert int32_t to float32\n        float32x4_t float_vec = vcvtq_f32_s32(int_vec);\n\n        // Scale the float values\n        float_vec = vmulq_f32(float_vec, scale_vec);\n\n        // Store the result in B\n        vst1q_f32(&B[i], float_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    float32x4_t scale_vec = vmovq_n_f32((float)scale);\n    size_t i = 0;\n\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 int32_t values from A\n        int32x4_t int_vec = vld1q_s32(&A[i]);\n\n        // Convert int32_t to float32\n        float32x4_t float_vec = vcvtq_f32_s32(int_vec);\n\n        // Scale the float values\n        float_vec = vmulq_f32(float_vec, scale_vec);\n\n        // Store the result into B\n        vst1q_f32(&B[i], float_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_52_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 floats from A and B\n        float32x4_t va = vld1q_f32(&A[i]);\n        float32x4_t vb = vld1q_f32(&B[i]);\n        \n        // Perform element-wise division\n        float32x4_t vdiv = vdivq_f32(va, vb);\n        \n        // Round to nearest integer and convert to 32-bit integers\n        int32x4_t vrounded = vcvtq_s32_f32(vrndnq_f32(vdiv));\n        \n        // Store the result into C\n        vst1q_s32(&C[i], vrounded);\n    }\n    \n    // Handle remaining elements (if any)\n    for (; i < size; ++i) {\n        C[i] = static_cast<int32_t>(std::nearbyint(A[i] / B[i]));\n    }\n}\n```"}
{"task_id": "SimdBench_52_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 3 < size; i += 4) {\n        // Load 4 floats from A and B\n        float32x4_t va = vld1q_f32(&A[i]);\n        float32x4_t vb = vld1q_f32(&B[i]);\n        \n        // Perform element-wise division\n        float32x4_t vdiv = vdivq_f32(va, vb);\n        \n        // Round the result to nearest integer\n        int32x4_t vrounded = vcvtaq_s32_f32(vdiv);\n        \n        // Store the result into C\n        vst1q_s32(&C[i], vrounded);\n    }\n    \n    // Handle remaining elements (if any)\n    for (; i < size; ++i) {\n        C[i] = (int32_t) nearbyintf(A[i] / B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_52_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 floats from A and B\n        float32x4_t va = vld1q_f32(&A[i]);\n        float32x4_t vb = vld1q_f32(&B[i]);\n        \n        // Perform element-wise division\n        float32x4_t vdiv = vdivq_f32(va, vb);\n        \n        // Round the result to nearest integer\n        int32x4_t vrounded = vcvtaq_s32_f32(vdiv);\n        \n        // Store the result into the destination array C\n        vst1q_s32(&C[i], vrounded);\n    }\n    \n    // Handle remaining elements (if any)\n    for (; i < size; ++i) {\n        C[i] = (int32_t) nearbyintf(A[i] / B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_52_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 3 < size; i += 4) {\n        // Load 4 floats from A and B\n        float32x4_t va = vld1q_f32(&A[i]);\n        float32x4_t vb = vld1q_f32(&B[i]);\n        \n        // Perform element-wise division\n        float32x4_t vdiv = vdivq_f32(va, vb);\n        \n        // Round the result to nearest integer\n        int32x4_t vrounded = vcvtaq_s32_f32(vdiv);\n        \n        // Store the result into the destination array C\n        vst1q_s32(&C[i], vrounded);\n    }\n    \n    // Handle remaining elements (if any) with scalar code\n    for (; i < size; ++i) {\n        C[i] = (int32_t)roundf(A[i] / B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_52_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 floats from A and B\n        float32x4_t va = vld1q_f32(&A[i]);\n        float32x4_t vb = vld1q_f32(&B[i]);\n        \n        // Perform element-wise division\n        float32x4_t vdiv = vdivq_f32(va, vb);\n        \n        // Round to nearest integer and convert to 32-bit integers\n        int32x4_t vrounded = vcvtq_s32_f32(vrndnq_f32(vdiv));\n        \n        // Store the result into C\n        vst1q_s32(&C[i], vrounded);\n    }\n    \n    // Handle remaining elements (if any)\n    for (; i < size; ++i) {\n        C[i] = (int32_t) nearbyintf(A[i] / B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_53_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    const float32x4_t vflt_max = vdupq_n_f32(FLT_MAX);\n    const float32x4_t vflt_min = vdupq_n_f32(-FLT_MAX);\n\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 double values from A\n        float64x2_t vA0 = vld1q_f64(A + i);\n        float64x2_t vA1 = vld1q_f64(A + i + 2);\n\n        // Convert double to float\n        float32x4_t vB = vcvtq_f32_f64(vA0);\n        float32x4_t vB_next = vcvtq_f32_f64(vA1);\n\n        // Saturate values greater than FLT_MAX to FLT_MAX\n        vB = vminq_f32(vB, vflt_max);\n        vB_next = vminq_f32(vB_next, vflt_max);\n\n        // Saturate values less than -FLT_MAX to -FLT_MAX\n        vB = vmaxq_f32(vB, vflt_min);\n        vB_next = vmaxq_f32(vB_next, vflt_min);\n\n        // Store the results into B\n        vst1q_f32(B + i, vB);\n        vst1q_f32(B + i + 2, vB_next);\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    const float32x4_t vflt_max = vdupq_n_f32(FLT_MAX);\n    const float32x4_t vflt_min = vdupq_n_f32(-FLT_MAX);\n\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 double values from A\n        float64x2_t vA0 = vld1q_f64(A + i);\n        float64x2_t vA1 = vld1q_f64(A + i + 2);\n\n        // Convert double to float\n        float32x4_t vB = vcvtq_f32_f64(vA0);\n        float32x4_t vB_next = vcvtq_f32_f64(vA1);\n\n        // Saturate values greater than FLT_MAX to FLT_MAX\n        vB = vminq_f32(vB, vflt_max);\n        vB_next = vminq_f32(vB_next, vflt_max);\n\n        // Saturate values less than -FLT_MAX to -FLT_MAX\n        vB = vmaxq_f32(vB, vflt_min);\n        vB_next = vmaxq_f32(vB_next, vflt_min);\n\n        // Store the results into B\n        vst1q_f32(B + i, vB);\n        vst1q_f32(B + i + 2, vB_next);\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    const float32x4_t vflt_max = vdupq_n_f32(FLT_MAX);\n    const float32x4_t vflt_min = vdupq_n_f32(-FLT_MAX);\n\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 double values from A\n        float64x2_t vA0 = vld1q_f64(A + i);\n        float64x2_t vA1 = vld1q_f64(A + i + 2);\n\n        // Convert double to float\n        float32x4_t vB0 = vcvtq_f32_f64(vA0);\n        float32x4_t vB1 = vcvtq_f32_f64(vA1);\n\n        // Saturate values greater than FLT_MAX to FLT_MAX\n        vB0 = vminq_f32(vB0, vflt_max);\n        vB1 = vminq_f32(vB1, vflt_max);\n\n        // Saturate values less than -FLT_MAX to -FLT_MAX\n        vB0 = vmaxq_f32(vB0, vflt_min);\n        vB1 = vmaxq_f32(vB1, vflt_min);\n\n        // Store the results into B\n        vst1q_f32(B + i, vB0);\n        vst1q_f32(B + i + 2, vB1);\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        float val = (float)A[i];\n        if (val > FLT_MAX) {\n            val = FLT_MAX;\n        } else if (val < -FLT_MAX) {\n            val = -FLT_MAX;\n        }\n        B[i] = val;\n    }\n}\n```"}
{"task_id": "SimdBench_53_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    const float32x4_t vflt_max = vdupq_n_f32(FLT_MAX);\n    const float32x4_t vflt_min = vdupq_n_f32(-FLT_MAX);\n\n    size_t i = 0;\n\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 double values from A\n        float64x2_t vA0 = vld1q_f64(A + i);\n        float64x2_t vA1 = vld1q_f64(A + i + 2);\n\n        // Convert double to float\n        float32x4_t vB0 = vcvtq_f32_f64(vA0);\n        float32x4_t vB1 = vcvtq_f32_f64(vA1);\n\n        // Saturate values greater than FLT_MAX to FLT_MAX\n        vB0 = vminq_f32(vB0, vflt_max);\n        vB1 = vminq_f32(vB1, vflt_max);\n\n        // Saturate values less than -FLT_MAX to -FLT_MAX\n        vB0 = vmaxq_f32(vB0, vflt_min);\n        vB1 = vmaxq_f32(vB1, vflt_min);\n\n        // Store the results into B\n        vst1q_f32(B + i, vB0);\n        vst1q_f32(B + i + 2, vB1);\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        double val = A[i];\n        if (val > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (val < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    const float32x4_t vmax = vdupq_n_f32(FLT_MAX);\n    const float32x4_t vmin = vdupq_n_f32(-FLT_MAX);\n\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 double values from A\n        float64x2_t a0 = vld1q_f64(A + i);\n        float64x2_t a1 = vld1q_f64(A + i + 2);\n\n        // Convert double to float\n        float32x4_t b0 = vcvtq_f32_f64(a0);\n        float32x4_t b1 = vcvtq_f32_f64(a1);\n\n        // Saturate the values between -FLT_MAX and FLT_MAX\n        b0 = vmaxq_f32(vminq_f32(b0, vmax), vmin);\n        b1 = vmaxq_f32(vminq_f32(b1, vmax), vmin);\n\n        // Store the results into B\n        vst1q_f32(B + i, b0);\n        vst1q_f32(B + i + 2, b1);\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_54_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n\n    // Process 8 elements at a time using NEON intrinsics\n    for (; i + 8 <= size; i += 8) {\n        // Load 8 int16_t values from A\n        int16x8_t vecA = vld1q_s16(&A[i]);\n\n        // Convert the 8 int16_t values to 8 int32_t values\n        int32x4_t vecB_low = vmovl_s16(vget_low_s16(vecA));\n        int32x4_t vecB_high = vmovl_s16(vget_high_s16(vecA));\n\n        // Store the 8 int32_t values into B\n        vst1q_s32(&B[i], vecB_low);\n        vst1q_s32(&B[i + 4], vecB_high);\n    }\n\n    // Handle remaining elements (if any)\n    for (; i < size; ++i) {\n        B[i] = static_cast<int32_t>(A[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_54_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n\n    // Process 8 elements at a time using NEON intrinsics\n    for (; i + 8 <= size; i += 8) {\n        // Load 8 int16_t values from A\n        int16x8_t vecA = vld1q_s16(&A[i]);\n\n        // Convert the first four int16_t to int32_t\n        int32x4_t vecB_low = vmovl_s16(vget_low_s16(vecA));\n\n        // Convert the next four int16_t to int32_t\n        int32x4_t vecB_high = vmovl_high_s16(vecA);\n\n        // Store the 8 int32_t values into B\n        vst1q_s32(&B[i], vecB_low);\n        vst1q_s32(&B[i + 4], vecB_high);\n    }\n\n    // Handle remaining elements (if any)\n    for (; i < size; ++i) {\n        B[i] = static_cast<int32_t>(A[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_54_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n\n    // Process 8 elements at a time using NEON intrinsics\n    for (; i + 8 <= size; i += 8) {\n        // Load 8 int16_t values from A\n        int16x8_t vecA = vld1q_s16(&A[i]);\n\n        // Convert the first four int16_t to int32_t\n        int32x4_t vecB_low = vmovl_s16(vget_low_s16(vecA));\n\n        // Convert the next four int16_t to int32_t\n        int32x4_t vecB_high = vmovl_high_s16(vecA);\n\n        // Store the resulting int32_t values into B\n        vst1q_s32(&B[i], vecB_low);\n        vst1q_s32(&B[i + 4], vecB_high);\n    }\n\n    // Handle any remaining elements\n    for (; i < size; ++i) {\n        B[i] = static_cast<int32_t>(A[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_54_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n\n    // Process 8 elements at a time using Neon intrinsics\n    for (; i + 8 <= size; i += 8) {\n        // Load 8 int16_t values from A\n        int16x8_t input = vld1q_s16(A + i);\n\n        // Convert the first four int16_t to int32_t\n        int32x4_t low = vmovl_s16(vget_low_s16(input));\n\n        // Convert the next four int16_t to int32_t\n        int32x4_t high = vmovl_high_s16(input);\n\n        // Store the results into B\n        vst1q_s32(B + i, low);\n        vst1q_s32(B + i + 4, high);\n    }\n\n    // Handle remaining elements (if any)\n    for (; i < size; ++i) {\n        B[i] = static_cast<int32_t>(A[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_54_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n\n    // Process 8 elements at a time using NEON intrinsics\n    for (; i + 8 <= size; i += 8) {\n        // Load 8 int16_t values from A\n        int16x8_t vecA = vld1q_s16(&A[i]);\n\n        // Convert the 8 int16_t values to 8 int32_t values\n        int32x4_t vecB_low = vmovl_s16(vget_low_s16(vecA));\n        int32x4_t vecB_high = vmovl_s16(vget_high_s16(vecA));\n\n        // Store the 8 int32_t values into B\n        vst1q_s32(&B[i], vecB_low);\n        vst1q_s32(&B[i + 4], vecB_high);\n    }\n\n    // Handle remaining elements (if any)\n    for (; i < size; ++i) {\n        B[i] = static_cast<int32_t>(A[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_55_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float32x4_t vmin = vdupq_n_f32(min_val);\n    float32x4_t vmax = vdupq_n_f32(max_val);\n    float32x4_t vrange = vsubq_f32(vmax, vmin);\n    float32x4_t vzero = vdupq_n_f32(0.0f);\n    float32x4_t vone = vdupq_n_f32(1.0f);\n\n    for (size_t i = 0; i + 4 <= size; i += 4) {\n        // Load 4 elements from A, control, and compute conditions\n        float32x4_t va = vld1q_f32(&A[i]);\n        int32x4_t vcontrol = vld1q_s32(&control[i]);\n\n        // Normalize only if control > 0\n        uint32x4_t mask_gt_zero = vcgtq_s32(vcontrol, vdupq_n_s32(0));\n\n        // Compute normalized value: (A[i] - min_val) / (max_val - min_val)\n        float32x4_t vnormalized = vsubq_f32(va, vmin);\n        vnormalized = vdivq_f32(vnormalized, vrange);\n\n        // Clamp the normalized value between 0 and 1\n        vnormalized = vmaxq_f32(vnormalized, vzero);\n        vnormalized = vminq_f32(vnormalized, vone);\n\n        // Select between normalized value and original value based on control\n        float32x4_t vresult = vbslq_f32(mask_gt_zero, vnormalized, va);\n\n        // Store the result into B\n        vst1q_f32(&B[i], vresult);\n    }\n\n    // Handle remaining elements\n    for (size_t i = (size / 4) * 4; i < size; ++i) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            val = val < 0.0f ? 0.0f : (val > 1.0f ? 1.0f : val);\n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float32x4_t vmin = vdupq_n_f32(min_val);\n    float32x4_t vmax = vdupq_n_f32(max_val);\n    float32x4_t vrange = vsubq_f32(vmax, vmin);\n    float32x4_t vzero = vdupq_n_f32(0.0f);\n    float32x4_t vone = vdupq_n_f32(1.0f);\n\n    for (size_t i = 0; i + 4 <= size; i += 4) {\n        // Load 4 elements from A, control, and compute conditions\n        float32x4_t va = vld1q_f32(&A[i]);\n        int32x4_t vcontrol = vld1q_s32(&control[i]);\n\n        // Check if control > 0\n        uint32x4_t vcontrol_mask = vcgtq_s32(vcontrol, vdupq_n_s32(0));\n\n        // Normalize: (A[i] - min_val) / (max_val - min_val)\n        float32x4_t vnormalized = vsubq_f32(va, vmin);\n        vnormalized = vdivq_f32(vnormalized, vrange);\n\n        // Clamp values to [0, 1]\n        vnormalized = vmaxq_f32(vnormalized, vzero);\n        vnormalized = vminq_f32(vnormalized, vone);\n\n        // Select between normalized value and original value based on control\n        float32x4_t vresult = vbslq_f32(vcontrol_mask, vnormalized, va);\n\n        // Store the result into B\n        vst1q_f32(&B[i], vresult);\n    }\n\n    // Handle remaining elements\n    for (size_t i = (size / 4) * 4; i < size; ++i) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            val = val < 0.0f ? 0.0f : (val > 1.0f ? 1.0f : val);\n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float32x4_t vmin = vdupq_n_f32(min_val);\n    float32x4_t vmax = vdupq_n_f32(max_val);\n    float32x4_t vrange = vsubq_f32(vmax, vmin);\n    float32x4_t vzero = vdupq_n_f32(0.0f);\n    float32x4_t vone = vdupq_n_f32(1.0f);\n\n    for (size_t i = 0; i + 4 <= size; i += 4) {\n        // Load 4 elements from A, control, and compute conditions\n        float32x4_t va = vld1q_f32(&A[i]);\n        int32x4_t vcontrol = vld1q_s32(&control[i]);\n\n        // Check if control > 0\n        uint32x4_t vcontrol_gt_zero = vcgtq_s32(vcontrol, vdupq_n_s32(0));\n\n        // Normalize: (A[i] - min_val) / (max_val - min_val)\n        float32x4_t vnormalized = vsubq_f32(va, vmin);\n        vnormalized = vdivq_f32(vnormalized, vrange);\n\n        // Clamp values to [0, 1]\n        vnormalized = vmaxq_f32(vnormalized, vzero);\n        vnormalized = vminq_f32(vnormalized, vone);\n\n        // Select between normalized value and original value based on control\n        float32x4_t vresult = vbslq_f32(vcontrol_gt_zero, vnormalized, va);\n\n        // Store the result into B\n        vst1q_f32(&B[i], vresult);\n    }\n\n    // Handle remaining elements\n    for (size_t i = (size / 4) * 4; i < size; ++i) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            val = val < 0.0f ? 0.0f : (val > 1.0f ? 1.0f : val);\n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float32x4_t vmin = vdupq_n_f32(min_val);\n    float32x4_t vmax = vdupq_n_f32(max_val);\n    float32x4_t vrange = vsubq_f32(vmax, vmin);\n    float32x4_t vzero = vdupq_n_f32(0.0f);\n    float32x4_t vone = vdupq_n_f32(1.0f);\n\n    for (size_t i = 0; i + 4 <= size; i += 4) {\n        // Load 4 elements from A, control, and compute conditions\n        float32x4_t va = vld1q_f32(&A[i]);\n        int32x4_t vcontrol = vld1q_s32(&control[i]);\n\n        // Normalize only if control > 0\n        uint32x4_t mask = vcgtq_s32(vcontrol, vdupq_n_s32(0));\n        float32x4_t normalized = vsubq_f32(va, vmin);\n        normalized = vdivq_f32(normalized, vrange);\n\n        // Clamp values between 0 and 1\n        normalized = vmaxq_f32(normalized, vzero);\n        normalized = vminq_f32(normalized, vone);\n\n        // Select between normalized and original based on control\n        float32x4_t result = vbslq_f32(mask, normalized, va);\n\n        // Store the result into B\n        vst1q_f32(&B[i], result);\n    }\n\n    // Handle remaining elements\n    for (size_t i = (size / 4) * 4; i < size; ++i) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            val = val < 0.0f ? 0.0f : (val > 1.0f ? 1.0f : val);\n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float32x4_t vmin = vdupq_n_f32(min_val);\n    float32x4_t vmax = vdupq_n_f32(max_val);\n    float32x4_t vrange = vsubq_f32(vmax, vmin);\n    float32x4_t vzero = vdupq_n_f32(0.0f);\n    float32x4_t vone = vdupq_n_f32(1.0f);\n\n    for (size_t i = 0; i + 4 <= size; i += 4) {\n        // Load 4 elements from A, control, and compute conditions\n        float32x4_t va = vld1q_f32(&A[i]);\n        int32x4_t vcontrol = vld1q_s32(&control[i]);\n\n        // Check if control > 0\n        uint32x4_t vcontrol_gt_zero = vcgtq_s32(vcontrol, vdupq_n_s32(0));\n\n        // Normalize: (A[i] - min_val) / (max_val - min_val)\n        float32x4_t vnormalized = vsubq_f32(va, vmin);\n        vnormalized = vdivq_f32(vnormalized, vrange);\n\n        // Clamp values to [0, 1]\n        vnormalized = vmaxq_f32(vnormalized, vzero);\n        vnormalized = vminq_f32(vnormalized, vone);\n\n        // Select between normalized value and original value based on control\n        float32x4_t vresult = vbslq_f32(vcontrol_gt_zero, vnormalized, va);\n\n        // Store the result into B\n        vst1q_f32(&B[i], vresult);\n    }\n\n    // Handle remaining elements\n    for (size_t i = (size / 4) * 4; i < size; ++i) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            val = val < 0.0f ? 0.0f : (val > 1.0f ? 1.0f : val);\n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_56_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 uint32_t values from A\n        uint32x4_t va = vld1q_u32(&A[i]);\n\n        // Shift right by 16 bits to extract the high 16 bits of each uint32_t\n        uint32x4_t shifted = vshrq_n_u32(va, 16);\n\n        // Convert the shifted uint32_t values to float32\n        float32x4_t vf = vcvtq_f32_u32(shifted);\n\n        // Compute the square root of the float32 values\n        float32x4_t vsqrt = vsqrtq_f32(vf);\n\n        // Store the results into B\n        vst1q_f32(&B[i], vsqrt);\n    }\n\n    // Handle remaining elements (if any) with scalar operations\n    for (; i < size; ++i) {\n        uint32_t val = A[i];\n        float result = sqrtf((float)(val >> 16));\n        B[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_56_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 uint32_t values from A\n        uint32x4_t vecA = vld1q_u32(&A[i]);\n\n        // Shift right by 16 bits to extract the high 16 bits of each uint32_t\n        uint32x4_t shiftedA = vshrq_n_u32(vecA, 16);\n\n        // Convert the shifted uint32_t values to float32\n        float32x4_t floatA = vcvtq_f32_u32(shiftedA);\n\n        // Compute the square root of the float32 values\n        float32x4_t sqrtA = vsqrtq_f32(floatA);\n\n        // Store the result into B\n        vst1q_f32(&B[i], sqrtA);\n    }\n\n    // Process remaining elements (if any) using scalar operations\n    for (; i < size; ++i) {\n        uint32_t value = A[i];\n        float converted = static_cast<float>(value >> 16);\n        B[i] = sqrtf(converted);\n    }\n}\n```"}
{"task_id": "SimdBench_56_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 uint32_t values from A\n        uint32x4_t va = vld1q_u32(&A[i]);\n\n        // Shift right by 16 to extract the high 16 bits of each uint32_t\n        uint32x4_t shifted = vshrq_n_u32(va, 16);\n\n        // Convert the shifted uint32_t values to float32\n        float32x4_t vf = vcvtq_f32_u32(shifted);\n\n        // Compute the square root of the float32 values\n        float32x4_t vsqrt = vsqrtq_f32(vf);\n\n        // Store the result into B\n        vst1q_f32(&B[i], vsqrt);\n    }\n\n    // Handle remaining elements (if any) with scalar operations\n    for (; i < size; ++i) {\n        uint32_t value = A[i];\n        float converted = static_cast<float>(value >> 16);\n        B[i] = sqrtf(converted);\n    }\n}\n```"}
{"task_id": "SimdBench_56_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 uint32_t values from A\n        uint32x4_t input = vld1q_u32(&A[i]);\n        \n        // Shift right by 16 bits to extract the high 16 bits of each uint32_t\n        uint32x4_t shifted = vshrq_n_u32(input, 16);\n        \n        // Convert the high 16 bits to float32\n        float32x4_t converted = vcvtq_f32_u32(shifted);\n        \n        // Compute the square root of the float values\n        float32x4_t sqrt_result = vsqrtq_f32(converted);\n        \n        // Store the result into B\n        vst1q_f32(&B[i], sqrt_result);\n    }\n    \n    // Handle remaining elements (if any)\n    for (; i < size; ++i) {\n        uint32_t high_bits = A[i] >> 16;\n        float converted = static_cast<float>(high_bits);\n        B[i] = sqrtf(converted);\n    }\n}\n```"}
{"task_id": "SimdBench_56_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 3 < size; i += 4) {\n        // Load 4 uint32_t values from A\n        uint32x4_t va = vld1q_u32(&A[i]);\n\n        // Shift right by 16 bits to extract the high 16 bits of each uint32_t\n        uint32x4_t shifted = vshrq_n_u32(va, 16);\n\n        // Convert the shifted uint32_t values to float32\n        float32x4_t vf = vcvtq_f32_u32(shifted);\n\n        // Compute the square root of the float32 values\n        float32x4_t vsqrt = vsqrtq_f32(vf);\n\n        // Store the result into B\n        vst1q_f32(&B[i], vsqrt);\n    }\n\n    // Handle remaining elements (if size is not a multiple of 4)\n    for (; i < size; ++i) {\n        uint32_t value = A[i];\n        float converted = static_cast<float>(value >> 16);\n        B[i] = sqrtf(converted);\n    }\n}\n```"}
{"task_id": "SimdBench_57_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 uint32_t values from the source array\n        uint32x4_t int_vec = vld1q_u32(&A[i]);\n\n        // Reinterpret the uint32x4_t vector as float32x4_t without conversion\n        float32x4_t float_vec = vreinterpretq_f32_u32(int_vec);\n\n        // Store the resulting float32x4_t vector into the destination array\n        vst1q_f32(&B[i], float_vec);\n    }\n\n    // Handle any remaining elements that are not a multiple of 4\n    for (; i < size; ++i) {\n        B[i] = *(float*)&A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_57_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 uint32_t values from the source array\n        uint32x4_t v_int = vld1q_u32(&A[i]);\n        \n        // Reinterpret the bits of the uint32_t vector as float32x4_t\n        float32x4_t v_float = vreinterpretq_f32_u32(v_int);\n        \n        // Store the resulting float values into the destination array\n        vst1q_f32(&B[i], v_float);\n    }\n    \n    // Handle any remaining elements that didn't fit into the SIMD processing\n    for (; i < size; ++i) {\n        B[i] = *(float*)&A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_57_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 uint32_t values from the source array\n        uint32x4_t int_vec = vld1q_u32(&A[i]);\n        \n        // Reinterpret the bit pattern of the integers as floats\n        float32x4_t float_vec = vreinterpretq_f32_u32(int_vec);\n        \n        // Store the resulting floats into the destination array\n        vst1q_f32(&B[i], float_vec);\n    }\n    \n    // Handle any remaining elements that didn't fit into the SIMD processing\n    for (; i < size; ++i) {\n        B[i] = *(float*)&A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_57_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon intrinsics\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 uint32_t values from A\n        uint32x4_t v_int = vld1q_u32(&A[i]);\n        \n        // Reinterpret the bits as float32x4_t\n        float32x4_t v_float = vreinterpretq_f32_u32(v_int);\n        \n        // Store the resulting floats into B\n        vst1q_f32(&B[i], v_float);\n    }\n    \n    // Handle any remaining elements\n    for (; i < size; ++i) {\n        B[i] = *(float*)&A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_57_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 uint32_t values from A\n        uint32x4_t int_vec = vld1q_u32(&A[i]);\n        \n        // Reinterpret the uint32x4_t vector as float32x4_t without conversion\n        float32x4_t float_vec = vreinterpretq_f32_u32(int_vec);\n        \n        // Store the resulting float32x4_t vector into B\n        vst1q_f32(&B[i], float_vec);\n    }\n    \n    // Handle any remaining elements (less than 4)\n    for (; i < size; ++i) {\n        B[i] = *(float*)&A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_58_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    // Set the first element of diff to 0.0f\n    diff[0] = 0.0f;\n\n    // Process elements in chunks of 4 using NEON intrinsics\n    size_t i = 1;\n    for (; i + 3 < size; i += 4) {\n        // Load 4 consecutive elements from A starting at index i\n        int32x4_t a_curr = vld1q_s32(&A[i]);\n        int32x4_t a_prev = vld1q_s32(&A[i - 1]);\n\n        // Compute differences: A[i] - A[i-1]\n        int32x4_t diffs = vsubq_s32(a_curr, a_prev);\n\n        // Load 4 boolean conditions starting at index i\n        uint32x4_t cond_mask = vld1q_u32((const uint32_t*)&cond[i]);\n\n        // Convert differences to float\n        float32x4_t diffs_float = vcvtq_f32_s32(diffs);\n\n        // Create a zero vector\n        float32x4_t zeros = vdupq_n_f32(0.0f);\n\n        // Use condition mask to select between diffs_float and zeros\n        float32x4_t result = vbslq_f32(cond_mask, diffs_float, zeros);\n\n        // Store the result into diff array\n        vst1q_f32(&diff[i], result);\n    }\n\n    // Handle remaining elements (if any) with scalar code\n    for (; i < size; ++i) {\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i - 1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    // Set the first element of diff to 0.0f\n    diff[0] = 0.0f;\n\n    // Process elements in chunks of 4 using NEON intrinsics\n    size_t i = 1;\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 consecutive elements from A starting at index i\n        int32x4_t a_curr = vld1q_s32(&A[i]);\n        int32x4_t a_prev = vld1q_s32(&A[i - 1]);\n\n        // Compute differences: A[i] - A[i-1]\n        int32x4_t diffs = vsubq_s32(a_curr, a_prev);\n\n        // Load 4 boolean conditions starting at index i\n        uint32x4_t cond_mask = vld1q_u32((const uint32_t*)&cond[i]);\n\n        // Convert differences to float\n        float32x4_t diffs_float = vcvtq_f32_s32(diffs);\n\n        // Create a vector of zeros\n        float32x4_t zeros = vmovq_n_f32(0.0f);\n\n        // Use condition mask to select between diffs_float and zeros\n        float32x4_t result = vbslq_f32(cond_mask, diffs_float, zeros);\n\n        // Store the result into diff array\n        vst1q_f32(&diff[i], result);\n    }\n\n    // Handle remaining elements (if any) with scalar code\n    for (; i < size; ++i) {\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i - 1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    // Set the first element of diff to 0.0f as there's no previous element\n    diff[0] = 0.0f;\n\n    // Process elements in chunks of 4 using NEON intrinsics\n    size_t i = 1;\n    for (; i + 3 < size; i += 4) {\n        // Load 4 consecutive elements from A starting at index i\n        int32x4_t a_curr = vld1q_s32(&A[i]);\n        int32x4_t a_prev = vld1q_s32(&A[i - 1]);\n\n        // Compute differences: A[i] - A[i-1]\n        int32x4_t diffs = vsubq_s32(a_curr, a_prev);\n\n        // Load 4 boolean conditions starting at index i\n        uint32x4_t cond_vec = vld1q_u32((const uint32_t*)&cond[i]);\n\n        // Convert differences to float\n        float32x4_t diffs_float = vcvtq_f32_s32(diffs);\n\n        // Create a mask for the condition (true -> 0xFFFFFFFF, false -> 0x0)\n        float32x4_t mask = vreinterpretq_f32_u32(cond_vec);\n\n        // Apply the mask: set diff[i] to 0.0f where cond[i] is false\n        float32x4_t result = vmulq_f32(diffs_float, mask);\n\n        // Store the result into the diff array\n        vst1q_f32(&diff[i], result);\n    }\n\n    // Handle remaining elements (if any) with scalar code\n    for (; i < size; ++i) {\n        if (cond[i]) {\n            diff[i] = static_cast<float>(A[i] - A[i - 1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    // Set the first element of diff to 0.0f\n    diff[0] = 0.0f;\n\n    // Process elements in chunks of 4 using NEON intrinsics\n    size_t i = 1;\n    for (; i + 3 < size; i += 4) {\n        // Load 4 consecutive elements from A starting from A[i-1]\n        int32x4_t a_prev = vld1q_s32(&A[i - 1]);\n        int32x4_t a_curr = vld1q_s32(&A[i]);\n\n        // Compute differences: A[i] - A[i-1]\n        int32x4_t diffs = vsubq_s32(a_curr, a_prev);\n\n        // Load 4 boolean conditions\n        uint32x4_t cond_mask = vld1q_u32((const uint32_t*)&cond[i]);\n\n        // Convert differences to float\n        float32x4_t diffs_float = vcvtq_f32_s32(diffs);\n\n        // Create a zero vector\n        float32x4_t zeros = vdupq_n_f32(0.0f);\n\n        // Use condition mask to select between diffs_float and zeros\n        float32x4_t result = vbslq_f32(cond_mask, diffs_float, zeros);\n\n        // Store the result into diff array\n        vst1q_f32(&diff[i], result);\n    }\n\n    // Handle remaining elements (if any) with scalar code\n    for (; i < size; ++i) {\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i - 1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    // Set the first element of diff to 0.0f\n    diff[0] = 0.0f;\n\n    // Process elements in chunks of 4 using Neon intrinsics\n    size_t i = 1;\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 consecutive elements from A starting at index i\n        int32x4_t a_curr = vld1q_s32(&A[i]);\n        int32x4_t a_prev = vld1q_s32(&A[i - 1]);\n\n        // Compute differences between consecutive elements\n        int32x4_t diffs = vsubq_s32(a_curr, a_prev);\n\n        // Load 4 boolean conditions starting at index i\n        uint32x4_t cond_mask = vld1q_u32((const uint32_t*)&cond[i]);\n\n        // Convert differences to float\n        float32x4_t diffs_float = vcvtq_f32_s32(diffs);\n\n        // Create a zero vector for masking\n        float32x4_t zeros = vmovq_n_f32(0.0f);\n\n        // Use condition mask to select between diffs_float and zeros\n        float32x4_t result = vbslq_f32(cond_mask, diffs_float, zeros);\n\n        // Store the result into the diff array\n        vst1q_f32(&diff[i], result);\n    }\n\n    // Handle remaining elements (if any) with scalar code\n    for (; i < size; ++i) {\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i - 1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_59_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 uint32_t elements from the source array\n        uint32x4_t src_vec = vld1q_u32(&src[i]);\n\n        // Zero extend to 64-bit (convert uint32_t to uint64_t)\n        uint64x2_t low = vmovl_u32(vget_low_u32(src_vec));\n        uint64x2_t high = vmovl_high_u32(src_vec);\n\n        // Set the high 32 bits of each 64-bit element to 1\n        uint64x2_t mask_low = vdupq_n_u64(0xFFFFFFFF00000000);\n        uint64x2_t mask_high = vdupq_n_u64(0xFFFFFFFF00000000);\n\n        low = vorrq_u64(low, mask_low);\n        high = vorrq_u64(high, mask_high);\n\n        // Store the results into the destination array\n        vst1q_u64(&dst[i], low);\n        vst1q_u64(&dst[i + 2], high);\n    }\n\n    // Handle remaining elements (if any)\n    for (; i < length; ++i) {\n        dst[i] = ((uint64_t)src[i]) | 0xFFFFFFFF00000000;\n    }\n}\n```"}
{"task_id": "SimdBench_59_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 uint32_t elements from the source array\n        uint32x4_t src_vec = vld1q_u32(src + i);\n\n        // Zero extend to 64-bit (convert uint32_t to uint64_t)\n        uint64x2_t low = vmovl_u32(vget_low_u32(src_vec));\n        uint64x2_t high = vmovl_high_u32(src_vec);\n\n        // Set the high 32 bits of each 64-bit value to 1\n        uint64x2_t mask_low = vdupq_n_u64(0xFFFFFFFF00000000);\n        uint64x2_t mask_high = vdupq_n_u64(0xFFFFFFFF00000000);\n\n        low = vorrq_u64(low, mask_low);\n        high = vorrq_u64(high, mask_high);\n\n        // Store the results into the destination array\n        vst1q_u64(dst + i, low);\n        vst1q_u64(dst + i + 2, high);\n    }\n\n    // Process remaining elements (if any) with scalar code\n    for (; i < length; ++i) {\n        dst[i] = ((uint64_t)src[i]) | 0xFFFFFFFF00000000;\n    }\n}\n```"}
{"task_id": "SimdBench_59_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 uint32_t elements from the source array\n        uint32x4_t src_vec = vld1q_u32(&src[i]);\n\n        // Zero extend to 64-bit (convert uint32_t to uint64_t)\n        uint64x2_t low = vmovl_u32(vget_low_u32(src_vec));\n        uint64x2_t high = vmovl_high_u32(src_vec);\n\n        // Set the high 32 bits of each 64-bit value to 1\n        uint64x2_t mask_low = vdupq_n_u64(0xFFFFFFFF00000000);\n        uint64x2_t mask_high = vdupq_n_u64(0xFFFFFFFF00000000);\n\n        low = vorrq_u64(low, mask_low);\n        high = vorrq_u64(high, mask_high);\n\n        // Store the results into the destination array\n        vst1q_u64(&dst[i], low);\n        vst1q_u64(&dst[i + 2], high);\n    }\n\n    // Handle remaining elements (if any)\n    for (; i < length; ++i) {\n        dst[i] = ((uint64_t)src[i]) | 0xFFFFFFFF00000000;\n    }\n}\n```"}
{"task_id": "SimdBench_59_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 uint32_t elements from the source array\n        uint32x4_t src_vec = vld1q_u32(src + i);\n\n        // Zero extend to 64-bit (convert uint32_t to uint64_t)\n        uint64x2_t low = vmovl_u32(vget_low_u32(src_vec));\n        uint64x2_t high = vmovl_high_u32(src_vec);\n\n        // Set the high 32 bits of each 64-bit element to 1\n        uint64x2_t mask_low = vdupq_n_u64(0xFFFFFFFF00000000);\n        uint64x2_t mask_high = vdupq_n_u64(0xFFFFFFFF00000000);\n\n        low = vorrq_u64(low, mask_low);\n        high = vorrq_u64(high, mask_high);\n\n        // Store the results into the destination array\n        vst1q_u64(dst + i, low);\n        vst1q_u64(dst + i + 2, high);\n    }\n\n    // Handle any remaining elements\n    for (; i < length; ++i) {\n        dst[i] = ((uint64_t)src[i]) | 0xFFFFFFFF00000000;\n    }\n}\n```"}
{"task_id": "SimdBench_59_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 uint32_t elements from the source array\n        uint32x4_t src_vec = vld1q_u32(&src[i]);\n\n        // Zero extend to 64-bit (convert to uint64x2_t)\n        uint64x2_t low = vmovl_u32(vget_low_u32(src_vec));\n        uint64x2_t high = vmovl_high_u32(src_vec);\n\n        // Set the high 32 bits of each 64-bit element to 1\n        uint64x2_t mask = vdupq_n_u64(0xFFFFFFFF00000000);\n        low = vorrq_u64(low, mask);\n        high = vorrq_u64(high, mask);\n\n        // Store the results into the destination array\n        vst1q_u64(&dst[i], low);\n        vst1q_u64(&dst[i + 2], high);\n    }\n\n    // Handle any remaining elements\n    for (; i < length; ++i) {\n        dst[i] = ((uint64_t)src[i]) | 0xFFFFFFFF00000000;\n    }\n}\n```"}
{"task_id": "SimdBench_60_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    size_t i = 0;\n\n    // Process 8 indices at a time using NEON intrinsics\n    for (; i + 8 <= length; i += 8) {\n        // Load 8 int16_t indices\n        int16x8_t idx_v = vld1q_s16(&index[i]);\n\n        // Convert int16_t indices to uint32_t for gather loading\n        uint32x4_t idx_low = vmovl_u16(vget_low_u16(vreinterpretq_u16_s16(idx_v)));\n        uint32x4_t idx_high = vmovl_u16(vget_high_u16(vreinterpretq_u16_s16(idx_v)));\n\n        // Gather-load 8 doubles from vec using the indices\n        float64x2_t val0 = {vec[vgetq_lane_u32(idx_low, 0)], vec[vgetq_lane_u32(idx_low, 1)]};\n        float64x2_t val1 = {vec[vgetq_lane_u32(idx_low, 2)], vec[vgetq_lane_u32(idx_low, 3)]};\n        float64x2_t val2 = {vec[vgetq_lane_u32(idx_high, 0)], vec[vgetq_lane_u32(idx_high, 1)]};\n        float64x2_t val3 = {vec[vgetq_lane_u32(idx_high, 2)], vec[vgetq_lane_u32(idx_high, 3)]};\n\n        // Sum the loaded values horizontally\n        float64x2_t sum0 = vpaddq_f64(val0, val1);\n        float64x2_t sum1 = vpaddq_f64(val2, val3);\n        float64x2_t total = vpaddq_f64(sum0, sum1);\n\n        // Add the result to the scalar sum\n        sum += vgetq_lane_f64(total, 0) + vgetq_lane_f64(total, 1);\n    }\n\n    // Handle remaining elements\n    for (; i < length; ++i) {\n        sum += vec[index[i]];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    size_t i = 0;\n\n    // Process 8 indices at a time using Neon intrinsics\n    for (; i + 8 <= length; i += 8) {\n        // Load 8 int16_t indices\n        int16x8_t idx_v = vld1q_s16(&index[i]);\n\n        // Convert int16_t indices to uint32_t for gather operations\n        uint32x4_t idx_low = vmovl_u16(vget_low_u16(vreinterpretq_u16_s16(idx_v)));\n        uint32x4_t idx_high = vmovl_u16(vget_high_u16(vreinterpretq_u16_s16(idx_v)));\n\n        // Gather 8 double values from vec using the indices\n        float64x2_t val0 = {vec[vgetq_lane_u32(idx_low, 0)], vec[vgetq_lane_u32(idx_low, 1)]};\n        float64x2_t val1 = {vec[vgetq_lane_u32(idx_low, 2)], vec[vgetq_lane_u32(idx_low, 3)]};\n        float64x2_t val2 = {vec[vgetq_lane_u32(idx_high, 0)], vec[vgetq_lane_u32(idx_high, 1)]};\n        float64x2_t val3 = {vec[vgetq_lane_u32(idx_high, 2)], vec[vgetq_lane_u32(idx_high, 3)]};\n\n        // Sum the gathered values horizontally\n        float64x2_t sum0 = vpaddq_f64(val0, val1);\n        float64x2_t sum1 = vpaddq_f64(val2, val3);\n        float64x2_t total = vpaddq_f64(sum0, sum1);\n\n        // Accumulate the result into the scalar sum\n        sum += vgetq_lane_f64(total, 0) + vgetq_lane_f64(total, 1);\n    }\n\n    // Handle remaining elements\n    for (; i < length; ++i) {\n        sum += vec[index[i]];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    size_t i = 0;\n\n    // Process 8 indices at a time using Neon intrinsics\n    for (; i + 8 <= length; i += 8) {\n        // Load 8 int16_t indices\n        int16x8_t idx_v = vld1q_s16(index + i);\n\n        // Convert int16_t indices to uint32_t for gather load\n        uint32x4_t idx_low = vmovl_u16(vget_low_u16(vreinterpretq_u16_s16(idx_v)));\n        uint32x4_t idx_high = vmovl_u16(vget_high_u16(vreinterpretq_u16_s16(idx_v)));\n\n        // Gather-load 8 double values from vec using the indices\n        float64x2_t val0 = vld1q_f64(vec + vgetq_lane_u32(idx_low, 0));\n        float64x2_t val1 = vld1q_f64(vec + vgetq_lane_u32(idx_low, 1));\n        float64x2_t val2 = vld1q_f64(vec + vgetq_lane_u32(idx_low, 2));\n        float64x2_t val3 = vld1q_f64(vec + vgetq_lane_u32(idx_low, 3));\n        float64x2_t val4 = vld1q_f64(vec + vgetq_lane_u32(idx_high, 0));\n        float64x2_t val5 = vld1q_f64(vec + vgetq_lane_u32(idx_high, 1));\n        float64x2_t val6 = vld1q_f64(vec + vgetq_lane_u32(idx_high, 2));\n        float64x2_t val7 = vld1q_f64(vec + vgetq_lane_u32(idx_high, 3));\n\n        // Sum the loaded values horizontally\n        float64x2_t sum_vec0 = vaddq_f64(val0, val1);\n        float64x2_t sum_vec1 = vaddq_f64(val2, val3);\n        float64x2_t sum_vec2 = vaddq_f64(val4, val5);\n        float64x2_t sum_vec3 = vaddq_f64(val6, val7);\n\n        sum_vec0 = vaddq_f64(sum_vec0, sum_vec1);\n        sum_vec2 = vaddq_f64(sum_vec2, sum_vec3);\n        sum_vec0 = vaddq_f64(sum_vec0, sum_vec2);\n\n        // Extract the final sum from the vector\n        sum += vgetq_lane_f64(sum_vec0, 0) + vgetq_lane_f64(sum_vec0, 1);\n    }\n\n    // Process remaining elements\n    for (; i < length; ++i) {\n        sum += vec[index[i]];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    size_t i = 0;\n\n    // Process 8 indices at a time using NEON intrinsics\n    for (; i + 8 <= length; i += 8) {\n        // Load 8 int16_t indices\n        int16x8_t idx_v = vld1q_s16(index + i);\n\n        // Convert int16_t indices to uint32_t for gathering\n        uint32x4_t idx_low = vmovl_u16(vget_low_u16(vreinterpretq_u16_s16(idx_v)));\n        uint32x4_t idx_high = vmovl_u16(vget_high_u16(vreinterpretq_u16_s16(idx_v)));\n\n        // Gather 8 double values from vec using the indices\n        float64x2_t val0 = {vec[vgetq_lane_u32(idx_low, 0)], vec[vgetq_lane_u32(idx_low, 1)]};\n        float64x2_t val1 = {vec[vgetq_lane_u32(idx_low, 2)], vec[vgetq_lane_u32(idx_low, 3)]};\n        float64x2_t val2 = {vec[vgetq_lane_u32(idx_high, 0)], vec[vgetq_lane_u32(idx_high, 1)]};\n        float64x2_t val3 = {vec[vgetq_lane_u32(idx_high, 2)], vec[vgetq_lane_u32(idx_high, 3)]};\n\n        // Sum the gathered values horizontally\n        float64x2_t sum0 = vaddq_f64(val0, val1);\n        float64x2_t sum1 = vaddq_f64(val2, val3);\n        float64x2_t total = vaddq_f64(sum0, sum1);\n\n        // Reduce the two remaining values in total to a scalar\n        sum += vgetq_lane_f64(total, 0) + vgetq_lane_f64(total, 1);\n    }\n\n    // Handle any remaining elements\n    for (; i < length; ++i) {\n        sum += vec[index[i]];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    size_t i = 0;\n\n    // Process 8 indices at a time using Neon intrinsics\n    for (; i + 8 <= length; i += 8) {\n        // Load 8 int16_t indices\n        int16x8_t idx_v = vld1q_s16(index + i);\n\n        // Convert int16_t indices to uint32_t for gather load\n        uint32x4_t idx_low = vmovl_u16(vget_low_u16(vreinterpretq_u16_s16(idx_v)));\n        uint32x4_t idx_high = vmovl_u16(vget_high_u16(vreinterpretq_u16_s16(idx_v)));\n\n        // Gather-load 8 doubles from vec using the indices\n        float64x2_t val0 = {vec[vgetq_lane_u32(idx_low, 0)], vec[vgetq_lane_u32(idx_low, 1)]};\n        float64x2_t val1 = {vec[vgetq_lane_u32(idx_low, 2)], vec[vgetq_lane_u32(idx_low, 3)]};\n        float64x2_t val2 = {vec[vgetq_lane_u32(idx_high, 0)], vec[vgetq_lane_u32(idx_high, 1)]};\n        float64x2_t val3 = {vec[vgetq_lane_u32(idx_high, 2)], vec[vgetq_lane_u32(idx_high, 3)]};\n\n        // Sum the loaded values horizontally\n        float64x2_t sum0 = vpaddq_f64(val0, val1);\n        float64x2_t sum1 = vpaddq_f64(val2, val3);\n        float64x2_t total = vpaddq_f64(sum0, sum1);\n\n        // Add the result to the scalar sum\n        sum += vgetq_lane_f64(total, 0) + vgetq_lane_f64(total, 1);\n    }\n\n    // Process remaining elements\n    for (; i < length; ++i) {\n        sum += vec[index[i]];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_61_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    float64x2_t kernel_vec[kernel_size * kernel_size / 2 + 1];\n    \n    // Load kernel into NEON registers\n    for (size_t i = 0; i < kernel_size * kernel_size; i += 2) {\n        kernel_vec[i / 2] = vld1q_f64(&kernel[i]);\n    }\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            float64x2_t acc = vmovq_n_f64(0.0);\n\n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; kj += 2) {\n                    size_t input_idx = (i + ki) * input_size + (j + kj);\n                    float64x2_t input_vec = vld1q_f64(&input[input_idx]);\n                    float64x2_t kernel_vec_part = kernel_vec[(ki * kernel_size + kj) / 2];\n                    acc = vfmaq_f64(acc, input_vec, kernel_vec_part);\n                }\n            }\n\n            // Horizontal add to accumulate results\n            double sum = vaddvq_f64(acc);\n\n            // Apply ReLU activation\n            if (sum < 0.0) {\n                sum = 0.0;\n            }\n\n            output[i * output_size + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    float64x2_t kernel_vec[kernel_size * kernel_size / 2 + 1];\n    \n    // Load kernel into NEON registers\n    for (size_t i = 0; i < kernel_size * kernel_size; i += 2) {\n        kernel_vec[i / 2] = vld1q_f64(&kernel[i]);\n    }\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            float64x2_t acc = vdupq_n_f64(0.0);\n\n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; kj += 2) {\n                    size_t input_idx = (i + ki) * input_size + (j + kj);\n                    float64x2_t input_vec = vld1q_f64(&input[input_idx]);\n                    float64x2_t kernel_vec_part = kernel_vec[(ki * kernel_size + kj) / 2];\n                    acc = vfmaq_f64(acc, input_vec, kernel_vec_part);\n                }\n            }\n\n            // Horizontal add to accumulate results\n            double temp[2];\n            vst1q_f64(temp, acc);\n            double result = temp[0] + temp[1];\n\n            // Apply ReLU activation\n            if (result < 0.0) {\n                result = 0.0;\n            }\n\n            output[i * output_size + j] = result;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    float64x2_t kernel_vec[kernel_size * kernel_size / 2 + 1];\n    \n    // Load kernel into NEON registers\n    for (size_t i = 0; i < kernel_size * kernel_size / 2; ++i) {\n        kernel_vec[i] = vld1q_f64(kernel + i * 2);\n    }\n    \n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            float64x2_t acc = vdupq_n_f64(0.0);\n            \n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; kj += 2) {\n                    size_t input_idx = (i + ki) * input_size + (j + kj);\n                    float64x2_t input_vec = vld1q_f64(input + input_idx);\n                    size_t kernel_idx = ki * kernel_size + kj;\n                    float64x2_t kernel_reg = vld1q_f64(kernel + kernel_idx);\n                    acc = vfmaq_f64(acc, input_vec, kernel_reg);\n                }\n            }\n            \n            // Horizontal add to accumulate the result\n            double sum = vaddvq_f64(acc);\n            output[i * output_size + j] = sum > 0.0 ? sum : 0.0; // ReLU activation\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    float64x2_t kernel_vec[kernel_size * kernel_size / 2 + 1];\n    \n    // Load kernel into NEON registers\n    for (size_t i = 0; i < kernel_size * kernel_size; i += 2) {\n        kernel_vec[i / 2] = vld1q_f64(kernel + i);\n    }\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            float64x2_t acc = vdupq_n_f64(0.0);\n\n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; kj += 2) {\n                    size_t input_idx = (i + ki) * input_size + (j + kj);\n                    float64x2_t input_vec = vld1q_f64(input + input_idx);\n                    float64x2_t kernel_vec_part = vld1q_f64(kernel + (ki * kernel_size + kj));\n                    acc = vfmaq_f64(acc, input_vec, kernel_vec_part);\n                }\n            }\n\n            // Horizontal add to accumulate results\n            double sum = vaddvq_f64(acc);\n\n            // Apply ReLU activation\n            if (sum < 0.0) {\n                sum = 0.0;\n            }\n\n            output[i * output_size + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    float64x2_t kernel_vec[kernel_size * kernel_size / 2 + 1];\n    \n    // Load kernel into NEON registers\n    for (size_t i = 0; i < kernel_size * kernel_size; i += 2) {\n        kernel_vec[i / 2] = vld1q_f64(&kernel[i]);\n    }\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            float64x2_t acc = vdupq_n_f64(0.0);\n\n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; kj += 2) {\n                    size_t input_idx = (i + ki) * input_size + (j + kj);\n                    float64x2_t input_vec = vld1q_f64(&input[input_idx]);\n                    float64x2_t kernel_vec_part = kernel_vec[(ki * kernel_size + kj) / 2];\n                    acc = vfmaq_f64(acc, input_vec, kernel_vec_part);\n                }\n            }\n\n            // Horizontal sum of the accumulator\n            double result[2];\n            vst1q_f64(result, acc);\n            double sum = result[0] + result[1];\n\n            // Apply ReLU activation\n            if (sum < 0.0) {\n                sum = 0.0;\n            }\n\n            output[i * output_size + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_62_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool has_close_elements_simd(const std::vector<double> &numbers, double threshold) {\n    int size = numbers.size();\n    float64x2_t v_threshold = vmovq_n_f64(threshold);\n\n    for (int i = 0; i < size; ++i) {\n        float64x2_t v_num1 = vmovq_n_f64(numbers[i]);\n\n        for (int j = i + 1; j <= size - 2; j += 2) {\n            float64x2_t v_num2 = vld1q_f64(&numbers[j]);\n            float64x2_t v_diff = vabdq_f64(v_num1, v_num2);\n\n            uint64x2_t v_cmp = vcltq_f64(v_diff, v_threshold);\n            if (vgetq_lane_u64(v_cmp, 0) || vgetq_lane_u64(v_cmp, 1)) {\n                return true;\n            }\n        }\n\n        // Handle remaining elements (if any)\n        for (int j = size - (size % 2); j < size; ++j) {\n            if (fabs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    int size = numbers.size();\n    float64x2_t v_threshold = vmovq_n_f64(threshold);\n\n    for (int i = 0; i < size; ++i) {\n        float64x2_t v_num_i = vmovq_n_f64(numbers[i]);\n\n        for (int j = i + 1; j < size; j += 2) {\n            float64x2_t v_nums_j = vld1q_f64(&numbers[j]);\n\n            float64x2_t v_diff = vabdq_f64(v_num_i, v_nums_j);\n            uint64x2_t v_cmp = vcltq_f64(v_diff, v_threshold);\n\n            if (vgetq_lane_u64(v_cmp, 0) || vgetq_lane_u64(v_cmp, 1)) {\n                return true;\n            }\n        }\n\n        if ((size - (i + 1)) % 2 != 0) {\n            float64x2_t v_num_j = vmovq_n_f64(numbers[size - 1]);\n            float64x2_t v_diff = vabdq_f64(v_num_i, v_num_j);\n            uint64x2_t v_cmp = vcltq_f64(v_diff, v_threshold);\n\n            if (vgetq_lane_u64(v_cmp, 0)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool has_close_elements_simd(const std::vector<double> &numbers, double threshold) {\n    int size = numbers.size();\n    if (size < 2) return false;\n\n    float64x2_t v_threshold = vmovq_n_f64(threshold);\n\n    for (int i = 0; i < size; ++i) {\n        float64x2_t v_num1 = vmovq_n_f64(numbers[i]);\n\n        for (int j = i + 1; j < size; j += 2) {\n            float64x2_t v_num2 = vld1q_f64(&numbers[j]);\n\n            float64x2_t v_diff = vsubq_f64(v_num1, v_num2);\n            v_diff = vabsq_f64(v_diff);\n\n            uint64x2_t v_cmp = vcltq_f64(v_diff, v_threshold);\n\n            if (vgetq_lane_u64(v_cmp, 0) || vgetq_lane_u64(v_cmp, 1)) {\n                return true;\n            }\n        }\n\n        if ((size - (i + 1)) % 2 != 0) {\n            float64x2_t v_num2 = vmovq_n_f64(numbers[size - 1]);\n            float64x2_t v_diff = vsubq_f64(v_num1, v_num2);\n            v_diff = vabsq_f64(v_diff);\n\n            uint64x2_t v_cmp = vcltq_f64(v_diff, v_threshold);\n\n            if (vgetq_lane_u64(v_cmp, 0)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool has_close_elements_simd(const std::vector<double> &numbers, double threshold) {\n    int size = numbers.size();\n    float64x2_t v_threshold = vmovq_n_f64(threshold);\n\n    for (int i = 0; i < size; ++i) {\n        float64x2_t v_a = vmovq_n_f64(numbers[i]);\n\n        for (int j = i + 1; j < size; j += 2) {\n            float64x2_t v_b = vld1q_f64(&numbers[j]);\n\n            float64x2_t v_diff = vabdq_f64(v_a, v_b);\n            uint64x2_t v_cmp = vcltq_f64(v_diff, v_threshold);\n\n            if (vgetq_lane_u64(v_cmp, 0) || vgetq_lane_u64(v_cmp, 1)) {\n                return true;\n            }\n        }\n\n        if (size % 2 != 0 && i != size - 1) {\n            float64x2_t v_b = vmovq_n_f64(numbers[size - 1]);\n            float64x2_t v_diff = vabdq_f64(v_a, v_b);\n            uint64x2_t v_cmp = vcltq_f64(v_diff, v_threshold);\n\n            if (vgetq_lane_u64(v_cmp, 0)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool has_close_elements_simd(const std::vector<double> &numbers, double threshold) {\n    int size = numbers.size();\n    float64x2_t v_threshold = vmovq_n_f64(threshold);\n\n    for (int i = 0; i < size; ++i) {\n        float64x2_t v_a = vmovq_n_f64(numbers[i]);\n\n        for (int j = i + 1; j + 1 < size; j += 2) {\n            float64x2_t v_b = vld1q_f64(&numbers[j]);\n            float64x2_t v_diff = vabdq_f64(v_a, v_b);\n            uint64x2_t v_cmp = vcltq_f64(v_diff, v_threshold);\n\n            if (vgetq_lane_u64(v_cmp, 0) || vgetq_lane_u64(v_cmp, 1)) {\n                return true;\n            }\n        }\n\n        // Handle remaining elements if the size is odd\n        if (size % 2 != 0 && i + 1 < size) {\n            float64x2_t v_b = vmovq_n_f64(numbers[size - 1]);\n            float64x2_t v_diff = vabdq_f64(v_a, v_b);\n            uint64x2_t v_cmp = vcltq_f64(v_diff, v_threshold);\n\n            if (vgetq_lane_u64(v_cmp, 0)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int balance = 0;\n    int n = operations.size();\n    int i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= n - 4; i += 4) {\n        // Load 4 integers into a NEON register\n        int32x4_t ops = vld1q_s32(&operations[i]);\n\n        // Create a vector with the current balance replicated across all lanes\n        int32x4_t balance_vec = vdupq_n_s32(balance);\n\n        // Add the operations to the balance vector\n        balance_vec = vaddq_s32(balance_vec, ops);\n\n        // Check if any lane has a value less than zero\n        uint32x4_t negative_mask = vcltq_s32(balance_vec, vdupq_n_s32(0));\n        if (vmaxvq_u32(negative_mask) != 0) {\n            return true;\n        }\n\n        // Update the scalar balance with the last lane of the vector\n        balance = vgetq_lane_s32(balance_vec, 3);\n    }\n\n    // Process remaining elements\n    for (; i < n; ++i) {\n        balance += operations[i];\n        if (balance < 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int balance = 0;\n    int n = operations.size();\n    int i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= n - 4; i += 4) {\n        // Load 4 integers into a NEON register\n        int32x4_t ops = vld1q_s32(&operations[i]);\n\n        // Horizontal add to calculate the sum of these 4 elements\n        int32x2_t sum_partial = vpadd_s32(vget_low_s32(ops), vget_high_s32(ops));\n        int32x2_t sum_total = vpadd_s32(sum_partial, sum_partial);\n        int sum = vget_lane_s32(sum_total, 0);\n\n        // Check if adding this sum causes the balance to go below zero\n        if (balance + sum < 0) {\n            return true;\n        }\n\n        // Update balance\n        balance += sum;\n    }\n\n    // Process remaining elements\n    for (; i < n; ++i) {\n        balance += operations[i];\n        if (balance < 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int balance = 0;\n    int n = operations.size();\n    int i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= n - 4; i += 4) {\n        // Load 4 integers into a NEON register\n        int32x4_t ops = vld1q_s32(&operations[i]);\n\n        // Horizontal add to calculate the sum of the 4 elements\n        int32x2_t sum_partial = vpadd_s32(vget_low_s32(ops), vget_high_s32(ops));\n        int32x2_t sum_final = vpadd_s32(sum_partial, sum_partial);\n        int sum = vget_lane_s32(sum_final, 0);\n\n        // Check if adding this sum causes balance to go below zero\n        if (balance + sum < 0) {\n            return true;\n        }\n\n        // Update balance\n        balance += sum;\n    }\n\n    // Process remaining elements\n    for (; i < n; ++i) {\n        balance += operations[i];\n        if (balance < 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int balance = 0;\n    int i = 0;\n    int size = operations.size();\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= size - 4; i += 4) {\n        // Load 4 integers from the vector into a NEON register\n        int32x4_t v = vld1q_s32(&operations[i]);\n\n        // Create a vector with the current balance broadcasted to all lanes\n        int32x4_t balance_vec = vdupq_n_s32(balance);\n\n        // Add the operations to the balance vector\n        balance_vec = vaddq_s32(balance_vec, v);\n\n        // Check if any lane has a value less than zero\n        uint32x4_t negative_mask = vcltq_s32(balance_vec, vdupq_n_s32(0));\n\n        // If any lane is negative, return true\n        if (vmaxvq_u32(negative_mask) != 0) {\n            return true;\n        }\n\n        // Update the scalar balance with the sum of the vector elements\n        balance += vgetq_lane_s32(v, 0) + vgetq_lane_s32(v, 1) +\n                   vgetq_lane_s32(v, 2) + vgetq_lane_s32(v, 3);\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        balance += operations[i];\n        if (balance < 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int balance = 0;\n    int i = 0;\n    int n = operations.size();\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= n - 4; i += 4) {\n        // Load 4 integers into a NEON register\n        int32x4_t ops = vld1q_s32(&operations[i]);\n\n        // Create a vector with the current balance repeated 4 times\n        int32x4_t balance_vec = vdupq_n_s32(balance);\n\n        // Add the operations to the balance vector\n        balance_vec = vaddq_s32(balance_vec, ops);\n\n        // Check if any of the balances are less than zero\n        uint32x4_t negative_mask = vcltq_s32(balance_vec, vdupq_n_s32(0));\n\n        // If any element is negative, return true\n        if (vmaxvq_u32(negative_mask) != 0) {\n            return true;\n        }\n\n        // Update the scalar balance with the last value in the vector\n        balance = vgetq_lane_s32(balance_vec, 3);\n    }\n\n    // Process remaining elements\n    for (; i < n; ++i) {\n        balance += operations[i];\n        if (balance < 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_64_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    int n = numbers.size();\n    if (n == 0) return 0.0;\n\n    // Calculate mean\n    double sum = 0.0;\n    for (double num : numbers) {\n        sum += num;\n    }\n    double mean = sum / n;\n\n    // Load mean into SIMD register\n    float64x2_t mean_vec = vdupq_n_f64(mean);\n\n    // Initialize SIMD sum of absolute differences\n    float64x2_t mad_sum_vec = vdupq_n_f64(0.0);\n\n    // Process two elements at a time using SIMD\n    int i = 0;\n    for (; i <= n - 2; i += 2) {\n        float64x2_t nums = vld1q_f64(&numbers[i]);\n        float64x2_t diff = vsubq_f64(nums, mean_vec);\n        float64x2_t abs_diff = vabsq_f64(diff);\n        mad_sum_vec = vaddq_f64(mad_sum_vec, abs_diff);\n    }\n\n    // Horizontal add the results from SIMD registers\n    double mad_sum = vaddvq_f64(mad_sum_vec);\n\n    // Process remaining elements\n    for (; i < n; ++i) {\n        mad_sum += std::abs(numbers[i] - mean);\n    }\n\n    return mad_sum / n;\n}\n```"}
{"task_id": "SimdBench_64_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    int n = numbers.size();\n    if (n == 0) return 0.0;\n\n    // Compute the mean using scalar operations\n    double sum = 0.0;\n    for (double num : numbers) {\n        sum += num;\n    }\n    double mean = sum / n;\n\n    // Load the mean into a SIMD register\n    float64x2_t mean_vec = vdupq_n_f64(mean);\n\n    // Initialize SIMD registers for summing absolute differences\n    float64x2_t mad_sum_vec = vdupq_n_f64(0.0);\n\n    // Process two elements at a time using Neon intrinsics\n    int i = 0;\n    for (; i <= n - 2; i += 2) {\n        // Load two elements from the vector\n        float64x2_t data_vec = vld1q_f64(&numbers[i]);\n\n        // Compute the difference from the mean\n        float64x2_t diff_vec = vsubq_f64(data_vec, mean_vec);\n\n        // Compute the absolute value of the difference\n        float64x2_t abs_diff_vec = vabsq_f64(diff_vec);\n\n        // Accumulate the absolute differences\n        mad_sum_vec = vaddq_f64(mad_sum_vec, abs_diff_vec);\n    }\n\n    // Sum up the results from the SIMD register\n    double mad_sum = vgetq_lane_f64(mad_sum_vec, 0) + vgetq_lane_f64(mad_sum_vec, 1);\n\n    // Handle any remaining elements\n    for (; i < n; ++i) {\n        mad_sum += std::abs(numbers[i] - mean);\n    }\n\n    // Compute the final Mean Absolute Deviation\n    return mad_sum / n;\n}\n```"}
{"task_id": "SimdBench_64_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    int n = numbers.size();\n    if (n == 0) return 0.0;\n\n    // Compute the mean using scalar operations\n    double sum = 0.0;\n    for (double num : numbers) {\n        sum += num;\n    }\n    double mean = sum / n;\n\n    // Load the mean into a SIMD register\n    float64x2_t mean_vec = vdupq_n_f64(mean);\n\n    // Initialize accumulators for absolute differences\n    float64x2_t acc = vdupq_n_f64(0.0);\n\n    // Process two elements at a time using SIMD\n    int i = 0;\n    for (; i <= n - 2; i += 2) {\n        // Load two elements from the vector\n        float64x2_t nums = vld1q_f64(&numbers[i]);\n\n        // Compute the difference from the mean\n        float64x2_t diff = vsubq_f64(nums, mean_vec);\n\n        // Compute the absolute value of the difference\n        float64x2_t abs_diff = vabsq_f64(diff);\n\n        // Accumulate the absolute differences\n        acc = vaddq_f64(acc, abs_diff);\n    }\n\n    // Sum up the accumulated results\n    double total_abs_diff = vgetq_lane_f64(acc, 0) + vgetq_lane_f64(acc, 1);\n\n    // Handle any remaining elements using scalar operations\n    for (; i < n; ++i) {\n        total_abs_diff += std::fabs(numbers[i] - mean);\n    }\n\n    // Compute the mean absolute deviation\n    return total_abs_diff / n;\n}\n```"}
{"task_id": "SimdBench_64_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    int n = numbers.size();\n    if (n == 0) return 0.0;\n\n    // Calculate mean\n    double sum = 0.0;\n    for (double num : numbers) {\n        sum += num;\n    }\n    double mean = sum / n;\n\n    // Load mean into SIMD registers\n    float64x2_t mean_vec = vdupq_n_f64(mean);\n\n    // Process in chunks of 2 using NEON\n    double mad_sum = 0.0;\n    int i = 0;\n    for (; i <= n - 2; i += 2) {\n        // Load two elements\n        float64x2_t nums = vld1q_f64(&numbers[i]);\n\n        // Compute absolute differences\n        float64x2_t diff = vsubq_f64(nums, mean_vec);\n        float64x2_t abs_diff = vabsq_f64(diff);\n\n        // Sum the results horizontally\n        mad_sum += vaddvq_f64(abs_diff);\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        mad_sum += std::abs(numbers[i] - mean);\n    }\n\n    // Return the mean absolute deviation\n    return mad_sum / n;\n}\n```"}
{"task_id": "SimdBench_64_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    int n = numbers.size();\n    if (n == 0) return 0.0;\n\n    // Calculate the mean\n    double sum = 0.0;\n    for (double num : numbers) {\n        sum += num;\n    }\n    double mean = sum / n;\n\n    // Load mean into SIMD registers\n    float64x2_t mean_vec = vdupq_n_f64(mean);\n\n    // Process in chunks of 2 using NEON intrinsics\n    double mad_sum = 0.0;\n    int i = 0;\n    for (; i <= n - 2; i += 2) {\n        // Load two elements at a time\n        float64x2_t nums = vld1q_f64(&numbers[i]);\n\n        // Compute absolute differences\n        float64x2_t diff = vsubq_f64(nums, mean_vec);\n        float64x2_t abs_diff = vabsq_f64(diff);\n\n        // Accumulate the results\n        mad_sum += vgetq_lane_f64(abs_diff, 0) + vgetq_lane_f64(abs_diff, 1);\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        mad_sum += std::abs(numbers[i] - mean);\n    }\n\n    // Compute the final MAD\n    return mad_sum / n;\n}\n```"}
{"task_id": "SimdBench_65_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    std::vector<int> result;\n    int n = numbers.size();\n    \n    if (n == 0) return result;\n\n    result.reserve(2 * n - 1);\n\n    // Process elements in chunks of 4 using NEON intrinsics\n    int i = 0;\n    for (; i <= n - 4; i += 4) {\n        // Load 4 elements from the input vector\n        int32x4_t vec = vld1q_s32(&numbers[i]);\n\n        // Create a vector with the delimiter repeated 4 times\n        int32x4_t delim_vec = vdupq_n_s32(delimeter);\n\n        // Interleave the elements and delimiters\n        int32x4x2_t interleaved = vzipq_s32(vec, delim_vec);\n\n        // Store the interleaved result into the output vector\n        int temp[8];\n        vst1q_s32(temp, interleaved.val[0]);\n        vst1q_s32(temp + 4, interleaved.val[1]);\n\n        for (int j = 0; j < 7; ++j) {\n            result.push_back(temp[j]);\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        result.push_back(numbers[i]);\n        if (i != n - 1) {\n            result.push_back(delimeter);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    std::vector<int> result;\n    int n = numbers.size();\n    \n    if (n == 0) return result;\n\n    result.reserve(2 * n - 1);\n\n    for (int i = 0; i < n - 4; i += 4) {\n        // Load 4 elements from the input vector\n        int32x4_t vec = vld1q_s32(&numbers[i]);\n\n        // Create a vector with the delimiter repeated 4 times\n        int32x4_t delim_vec = vdupq_n_s32(delimeter);\n\n        // Store the first element of the current vector\n        result.push_back(numbers[i]);\n\n        // Interleave the delimiter and store the next three elements\n        for (int j = 1; j < 4; ++j) {\n            result.push_back(delimeter);\n            result.push_back(numbers[i + j]);\n        }\n    }\n\n    // Process remaining elements\n    for (int i = n - (n % 4); i < n; ++i) {\n        result.push_back(numbers[i]);\n        if (i != n - 1) {\n            result.push_back(delimeter);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    std::vector<int> result;\n    int n = numbers.size();\n    \n    if (n == 0) return result;\n\n    result.reserve(2 * n - 1);\n\n    for (int i = 0; i < n - 3; i += 4) {\n        // Load 4 elements from the input vector\n        int32x4_t vec = vld1q_s32(&numbers[i]);\n\n        // Create a vector with the delimiter repeated 4 times\n        int32x4_t delim_vec = vdupq_n_s32(delimeter);\n\n        // Interleave the elements and delimiters\n        int32x4x2_t interleaved = vzipq_s32(vec, delim_vec);\n\n        // Store the interleaved results into the output vector\n        result.insert(result.end(), reinterpret_cast<int*>(&interleaved), reinterpret_cast<int*>(&interleaved) + 8);\n    }\n\n    // Handle remaining elements\n    for (int i = n - (n % 4); i < n; ++i) {\n        result.push_back(numbers[i]);\n        if (i != n - 1) {\n            result.push_back(delimeter);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    std::vector<int> result;\n    int n = numbers.size();\n    \n    if (n == 0) return result;\n\n    result.reserve(2 * n - 1);\n\n    // Add the first element\n    result.push_back(numbers[0]);\n\n    int i = 1;\n    for (; i + 4 <= n; i += 4) {\n        // Load 4 elements from numbers\n        int32x4_t nums = vld1q_s32(&numbers[i]);\n\n        // Create a vector with the delimiter repeated 4 times\n        int32x4_t delim_vec = vdupq_n_s32(delimeter);\n\n        // Interleave delimiters and numbers\n        int32x4x2_t interleaved = vzipq_s32(delim_vec, nums);\n\n        // Store interleaved results into the result vector\n        for (int j = 0; j < 4; ++j) {\n            result.push_back(vgetq_lane_s32(interleaved.val[0], j));\n            result.push_back(vgetq_lane_s32(interleaved.val[1], j));\n        }\n    }\n\n    // Process remaining elements\n    for (; i < n; ++i) {\n        result.push_back(delimeter);\n        result.push_back(numbers[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    std::vector<int> result;\n    int n = numbers.size();\n    \n    if (n == 0) return result;\n\n    result.reserve(n * 2 - 1);\n\n    for (int i = 0; i < n - 4; i += 4) {\n        // Load 4 elements from the input vector\n        int32x4_t vec = vld1q_s32(&numbers[i]);\n\n        // Create a vector with the delimiter repeated 4 times\n        int32x4_t delim_vec = vdupq_n_s32(delimeter);\n\n        // Store the first element of the current vector\n        result.push_back(numbers[i]);\n\n        // Interleave the delimiter and store the next three elements\n        result.push_back(delimeter);\n        result.push_back(numbers[i + 1]);\n        result.push_back(delimeter);\n        result.push_back(numbers[i + 2]);\n        result.push_back(delimeter);\n        result.push_back(numbers[i + 3]);\n    }\n\n    // Process remaining elements\n    for (int i = n - (n % 4); i < n; ++i) {\n        result.push_back(numbers[i]);\n        if (i != n - 1) {\n            result.push_back(delimeter);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_66_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cstdint>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    int i = 0;\n    int size = numbers.size();\n\n    if (size == 0) {\n        return {sum, product};\n    }\n\n    // Process 8 elements at a time using NEON intrinsics\n    for (; i <= size - 8; i += 8) {\n        // Load 8 integers into a NEON register\n        int16x8_t vec = vld1q_s16(&numbers[i]);\n\n        // Horizontal sum of the 8 integers\n        int32x4_t sum_low = vpaddlq_s16(vec);\n        int32x2_t sum_high = vpadd_s32(vget_low_s32(sum_low), vget_high_s32(sum_low));\n        sum += vget_lane_s32(sum_high, 0) + vget_lane_s32(sum_high, 1);\n\n        // Horizontal product of the 8 integers\n        int16x4_t prod_low = vmul_s16(vget_low_s16(vec), vget_high_s16(vec));\n        int16x4_t prod_high = vmul_s16(prod_low, vrev64_s16(prod_low));\n        int16x4_t prod_final = vmul_s16(prod_high, vdup_n_s16(1));\n        product *= vget_lane_s16(prod_final, 0);\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    int i = 0;\n    int size = numbers.size();\n\n    if (size == 0) {\n        return {sum, product};\n    }\n\n    // Process 8 elements at a time using NEON intrinsics\n    for (; i <= size - 8; i += 8) {\n        // Load 8 integers into a NEON register\n        int16x8_t vec = vld1q_s16(&numbers[i]);\n\n        // Horizontal sum of the 8 integers\n        int32x4_t sum_low = vpaddlq_s16(vec);\n        int32x2_t sum_high = vpadd_s32(vget_low_s32(sum_low), vget_high_s32(sum_low));\n        sum += vget_lane_s32(sum_high, 0) + vget_lane_s32(sum_high, 1);\n\n        // Horizontal product of the 8 integers\n        int16x4_t prod_low = vmul_s16(vget_low_s16(vec), vget_high_s16(vec));\n        int16x4_t prod_high = vmul_s16(prod_low, vrev64_s16(prod_low));\n        product *= vget_lane_s16(prod_high, 0);\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cstdint>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    if (numbers.empty()) {\n        return {sum, product};\n    }\n\n    int16x8_t v_sum = vdupq_n_s16(0);\n    int16x8_t v_product = vdupq_n_s16(1);\n\n    size_t i = 0;\n    size_t size = numbers.size();\n\n    for (; i + 8 <= size; i += 8) {\n        int16x8_t v = vld1q_s16(&numbers[i]);\n        v_sum = vaddq_s16(v_sum, v);\n\n        // Compute product iteratively for each lane\n        for (int j = 0; j < 8; ++j) {\n            int16_t val = vgetq_lane_s16(v, j);\n            product *= val;\n        }\n    }\n\n    // Horizontal sum of the vector\n    int32x4_t sum_low = vpaddlq_s16(v_sum);\n    int32x2_t sum_high = vpadd_s32(vget_low_s32(sum_low), vget_high_s32(sum_low));\n    sum = vget_lane_s32(sum_high, 0);\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    int i = 0;\n    int size = numbers.size();\n\n    if (size == 0) {\n        return {sum, product};\n    }\n\n    // Process 8 elements at a time using NEON intrinsics\n    for (; i <= size - 8; i += 8) {\n        // Load 8 integers into a NEON register\n        int16x8_t vec = vld1q_s16(&numbers[i]);\n\n        // Horizontal sum of the 8 integers\n        int32x4_t sum_low = vpaddlq_s16(vec);\n        int32x2_t sum_high = vpadd_s32(vget_low_s32(sum_low), vget_high_s32(sum_low));\n        sum += vget_lane_s32(sum_high, 0) + vget_lane_s32(sum_high, 1);\n\n        // Horizontal product of the 8 integers\n        int16x4_t low = vget_low_s16(vec);\n        int16x4_t high = vget_high_s16(vec);\n        int16x4_t prod_low = vmul_s16(low, high);\n        int16x4_t prod_high = vmul_s16(vext_s16(low, high, 2), vext_s16(low, high, 3));\n        int16x4_t prod_final = vmul_s16(prod_low, prod_high);\n        product *= vget_lane_s16(prod_final, 0) * vget_lane_s16(prod_final, 1) * vget_lane_s16(prod_final, 2) * vget_lane_s16(prod_final, 3);\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cstdint>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    int i = 0;\n    int size = numbers.size();\n\n    if (size == 0) {\n        return {sum, product};\n    }\n\n    // Process 8 elements at a time using NEON intrinsics\n    for (; i <= size - 8; i += 8) {\n        // Load 8 integers into a NEON register\n        int16x8_t vec = vld1q_s16(&numbers[i]);\n\n        // Horizontal sum of the 8 integers\n        int32x4_t sum_part1 = vpaddlq_s16(vec);\n        int32x2_t sum_part2 = vpadd_s32(vget_low_s32(sum_part1), vget_high_s32(sum_part1));\n        sum += vget_lane_s32(sum_part2, 0) + vget_lane_s32(sum_part2, 1);\n\n        // Horizontal product of the 8 integers\n        int16x4_t prod_low = vmul_s16(vget_low_s16(vec), vget_high_s16(vec));\n        int16x4_t prod_high = vmul_s16(vext_s16(vget_low_s16(vec), vget_high_s16(vec), 2), vext_s16(vget_low_s16(vec), vget_high_s16(vec), 3));\n        int16x4_t prod_combined = vmul_s16(prod_low, prod_high);\n        int16x4_t prod_final = vmul_s16(prod_combined, vext_s16(prod_combined, prod_combined, 1));\n        product *= vget_lane_s16(prod_final, 0);\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_67_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    std::vector<int> result(numbers.size());\n    int n = numbers.size();\n    \n    if (n == 0) return result;\n\n    // Initialize the first element\n    result[0] = numbers[0];\n    \n    for (int i = 1; i < n; i += 4) {\n        // Load 4 elements from numbers starting at index i\n        int32x4_t current = vld1q_s32(&numbers[i]);\n        \n        // Load previous maximums, initialize if necessary\n        int32x4_t prev_max;\n        if (i == 1) {\n            // Special case for the first batch\n            int32_t init_vals[4] = {result[i-1], result[i-1], result[i-1], result[i-1]};\n            prev_max = vld1q_s32(init_vals);\n        } else {\n            prev_max = vld1q_s32(&result[i-1]);\n        }\n        \n        // Compute the rolling maximum using pairwise maximum intrinsic\n        int32x4_t rolling_max = vmaxq_s32(prev_max, current);\n        \n        // Store the results back to the result vector\n        vst1q_s32(&result[i], rolling_max);\n    }\n\n    // Ensure correctness for the last few elements if n is not a multiple of 4\n    for (int i = 1; i < n; ++i) {\n        if (result[i] < result[i-1]) {\n            result[i] = result[i-1];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    std::vector<int> result(numbers.size());\n    int n = numbers.size();\n    \n    if (n == 0) return result;\n\n    int32x4_t vmax = vdupq_n_s32(numbers[0]);\n    result[0] = numbers[0];\n\n    for (int i = 1; i < n; i += 4) {\n        int32x4_t vcurrent = vld1q_s32(&numbers[i]);\n\n        // Compute rolling maximum in chunks of 4\n        vmax = vmaxq_s32(vmax, vcurrent);\n\n        // Store the results back to the result vector\n        vst1q_s32(&result[i], vmax);\n    }\n\n    // Handle any remaining elements that didn't fit into a full SIMD register\n    int processed = (n / 4) * 4;\n    int current_max = result[processed - 1];\n    for (int i = processed; i < n; ++i) {\n        current_max = std::max(current_max, numbers[i]);\n        result[i] = current_max;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    std::vector<int> result(numbers.size());\n    int n = numbers.size();\n    \n    if (n == 0) return result;\n\n    // Initialize the first element\n    result[0] = numbers[0];\n\n    // Process in chunks of 4 using NEON intrinsics\n    int i = 1;\n    for (; i + 3 < n; i += 4) {\n        // Load 4 elements from numbers and result\n        int32x4_t current = vld1q_s32(&numbers[i]);\n        int32x4_t prev_max = vld1q_s32(&result[i - 1]);\n\n        // Compute rolling max for each lane\n        int32x4_t rolling_max = vmaxq_s32(prev_max, current);\n\n        // Store the result back to memory\n        vst1q_s32(&result[i], rolling_max);\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        result[i] = std::max(result[i - 1], numbers[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    std::vector<int> result(numbers.size());\n    int n = numbers.size();\n    \n    if (n == 0) return result;\n\n    int32x4_t vmax = vdupq_n_s32(numbers[0]);\n    result[0] = numbers[0];\n\n    for (int i = 1; i < n; ++i) {\n        int32x4_t vcurrent = vdupq_n_s32(numbers[i]);\n        vmax = vmaxq_s32(vmax, vcurrent);\n        result[i] = vmaxgetq_lane_s32(vmax, 0);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    std::vector<int> result(numbers.size());\n    int n = numbers.size();\n    \n    if (n == 0) return result;\n\n    // Initialize the first element\n    result[0] = numbers[0];\n    \n    for (int i = 1; i < n; i += 4) {\n        // Load the current chunk of 4 elements from the input vector\n        int32x4_t current = vld1q_s32(&numbers[i]);\n        \n        // Load the previous rolling maximum values\n        int32x4_t prev_max;\n        if (i == 1) {\n            // Special case for the first iteration\n            int32_t init_vals[4] = {result[i-1], result[i-1], result[i-1], result[i-1]};\n            prev_max = vld1q_s32(init_vals);\n        } else {\n            prev_max = vld1q_s32(&result[i-1]);\n        }\n\n        // Compute the rolling maximum using pairwise maximum intrinsic\n        int32x4_t rolling_max = vmaxq_s32(prev_max, current);\n\n        // Store the result back into the result vector\n        vst1q_s32(&result[i], rolling_max);\n    }\n\n    // Post-process to ensure correctness in case of overlap or incomplete chunks\n    for (int i = 1; i < n; ++i) {\n        if (result[i] < result[i-1]) {\n            result[i] = result[i-1];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <algorithm>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    int len_a = a.length();\n    int len_b = b.length();\n    int max_len = std::max(len_a, len_b);\n\n    // Pad the shorter string with leading zeros\n    a.insert(a.begin(), max_len - len_a, '0');\n    b.insert(b.begin(), max_len - len_b, '0');\n\n    std::string result(max_len, '0');\n    int i = 0;\n\n    // Process 16 characters at a time using NEON intrinsics\n    for (; i <= max_len - 16; i += 16) {\n        // Load 16 characters from each string\n        uint8x16_t va = vld1q_u8(reinterpret_cast<const uint8_t*>(&a[i]));\n        uint8x16_t vb = vld1q_u8(reinterpret_cast<const uint8_t*>(&b[i]));\n\n        // Convert '0'/'1' characters to 0/1 integers by subtracting '0'\n        uint8x16_t va_bits = vsubq_u8(va, vdupq_n_u8('0'));\n        uint8x16_t vb_bits = vsubq_u8(vb, vdupq_n_u8('0'));\n\n        // Perform XOR operation\n        uint8x16_t vxor = veorq_u8(va_bits, vb_bits);\n\n        // Convert back to '0'/'1' characters by adding '0'\n        uint8x16_t vresult = vaddq_u8(vxor, vdupq_n_u8('0'));\n\n        // Store the result back into the output string\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), vresult);\n    }\n\n    // Process remaining characters (if any) using scalar code\n    for (; i < max_len; ++i) {\n        result[i] = ((a[i] - '0') ^ (b[i] - '0')) + '0';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <algorithm>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    int len_a = a.length();\n    int len_b = b.length();\n    int max_len = std::max(len_a, len_b);\n\n    // Pad the shorter string with leading zeros\n    a.insert(a.begin(), max_len - len_a, '0');\n    b.insert(b.begin(), max_len - len_b, '0');\n\n    std::string result(max_len, '0');\n    int i = 0;\n\n    // Process 16 characters at a time using NEON intrinsics\n    for (; i <= max_len - 16; i += 16) {\n        // Load 16 characters from each string\n        uint8x16_t va = vld1q_u8(reinterpret_cast<const uint8_t*>(&a[i]));\n        uint8x16_t vb = vld1q_u8(reinterpret_cast<const uint8_t*>(&b[i]));\n\n        // Convert '0'/'1' characters to 0/1 integers by subtracting '0'\n        uint8x16_t va_int = vsubq_u8(va, vdupq_n_u8('0'));\n        uint8x16_t vb_int = vsubq_u8(vb, vdupq_n_u8('0'));\n\n        // Perform XOR operation\n        uint8x16_t vxor = veorq_u8(va_int, vb_int);\n\n        // Convert back to '0'/'1' characters by adding '0'\n        uint8x16_t vresult = vaddq_u8(vxor, vdupq_n_u8('0'));\n\n        // Store the result back into the output string\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), vresult);\n    }\n\n    // Process remaining characters (if any) using scalar code\n    for (; i < max_len; ++i) {\n        result[i] = ((a[i] - '0') ^ (b[i] - '0')) + '0';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <algorithm>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    int len_a = a.length();\n    int len_b = b.length();\n    int max_len = std::max(len_a, len_b);\n\n    // Pad the shorter string with leading zeros\n    a.insert(a.begin(), max_len - len_a, '0');\n    b.insert(b.begin(), max_len - len_b, '0');\n\n    std::string result(max_len, '0');\n    int i = 0;\n\n    // Process 16 characters at a time using NEON intrinsics\n    for (; i <= max_len - 16; i += 16) {\n        // Load 16 characters from each string\n        uint8x16_t va = vld1q_u8(reinterpret_cast<const uint8_t*>(&a[i]));\n        uint8x16_t vb = vld1q_u8(reinterpret_cast<const uint8_t*>(&b[i]));\n\n        // Convert '0'/'1' characters to 0/1 integers by subtracting '0'\n        uint8x16_t va_int = vsubq_u8(va, vdupq_n_u8('0'));\n        uint8x16_t vb_int = vsubq_u8(vb, vdupq_n_u8('0'));\n\n        // Perform XOR operation\n        uint8x16_t vxor = veorq_u8(va_int, vb_int);\n\n        // Convert back to '0'/'1' characters by adding '0'\n        uint8x16_t vresult = vaddq_u8(vxor, vdupq_n_u8('0'));\n\n        // Store the result back into the output string\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), vresult);\n    }\n\n    // Process remaining characters (if any) using scalar code\n    for (; i < max_len; ++i) {\n        result[i] = ((a[i] - '0') ^ (b[i] - '0')) + '0';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <algorithm>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    int len_a = a.length();\n    int len_b = b.length();\n    int max_len = std::max(len_a, len_b);\n\n    // Pad the shorter string with leading zeros\n    a.insert(a.begin(), max_len - len_a, '0');\n    b.insert(b.begin(), max_len - len_b, '0');\n\n    std::string result(max_len, '0');\n    int i = 0;\n\n    // Process 16 characters at a time using NEON intrinsics\n    for (; i <= max_len - 16; i += 16) {\n        // Load 16 characters from each string\n        uint8x16_t va = vld1q_u8(reinterpret_cast<const uint8_t*>(&a[i]));\n        uint8x16_t vb = vld1q_u8(reinterpret_cast<const uint8_t*>(&b[i]));\n\n        // Convert '0'/'1' characters to 0/1 integers by subtracting '0'\n        uint8x16_t va_num = vsubq_u8(va, vdupq_n_u8('0'));\n        uint8x16_t vb_num = vsubq_u8(vb, vdupq_n_u8('0'));\n\n        // Perform XOR operation\n        uint8x16_t vxor = veorq_u8(va_num, vb_num);\n\n        // Convert back to '0'/'1' characters by adding '0'\n        uint8x16_t vresult = vaddq_u8(vxor, vdupq_n_u8('0'));\n\n        // Store the result back into the output string\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), vresult);\n    }\n\n    // Process remaining characters (if any) using scalar code\n    for (; i < max_len; ++i) {\n        result[i] = ((a[i] - '0') ^ (b[i] - '0')) + '0';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <algorithm>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    int len_a = a.length();\n    int len_b = b.length();\n    int max_len = std::max(len_a, len_b);\n\n    // Pad the shorter string with leading zeros\n    a.insert(a.begin(), max_len - len_a, '0');\n    b.insert(b.begin(), max_len - len_b, '0');\n\n    std::string result(max_len, '0');\n    int i = 0;\n\n    // Process 16 characters at a time using NEON intrinsics\n    for (; i <= max_len - 16; i += 16) {\n        // Load 16 characters from each string\n        uint8x16_t va = vld1q_u8(reinterpret_cast<const uint8_t*>(&a[i]));\n        uint8x16_t vb = vld1q_u8(reinterpret_cast<const uint8_t*>(&b[i]));\n\n        // Convert '0'/'1' characters to 0/1 integers by subtracting '0'\n        uint8x16_t va_int = vsubq_u8(va, vdupq_n_u8('0'));\n        uint8x16_t vb_int = vsubq_u8(vb, vdupq_n_u8('0'));\n\n        // Perform XOR operation\n        uint8x16_t vxor = veorq_u8(va_int, vb_int);\n\n        // Convert back to '0'/'1' characters by adding '0'\n        uint8x16_t vresult = vaddq_u8(vxor, vdupq_n_u8('0'));\n\n        // Store the result back into the output string\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), vresult);\n    }\n\n    // Process remaining characters (if any) using scalar code\n    for (; i < max_len; ++i) {\n        result[i] = ((a[i] - '0') ^ (b[i] - '0')) + '0';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_69_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <vector>\n\nstd::string longest_simd(const std::vector<std::string> &strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    std::string longest_str = strings[0];\n    int longest_len = longest_str.length();\n\n    for (size_t i = 1; i < strings.size(); i += 4) {\n        int32x4_t lengths = {0, 0, 0, 0};\n        int valid_mask = 0xF;\n\n        if (i + 0 < strings.size()) lengths = vsetq_lane_s32(strings[i + 0].length(), lengths, 0);\n        if (i + 1 < strings.size()) lengths = vsetq_lane_s32(strings[i + 1].length(), lengths, 1);\n        if (i + 2 < strings.size()) lengths = vsetq_lane_s32(strings[i + 2].length(), lengths, 2);\n        if (i + 3 < strings.size()) lengths = vsetq_lane_s32(strings[i + 3].length(), lengths, 3);\n\n        if (i + 0 >= strings.size()) valid_mask &= ~(1 << 0);\n        if (i + 1 >= strings.size()) valid_mask &= ~(1 << 1);\n        if (i + 2 >= strings.size()) valid_mask &= ~(1 << 2);\n        if (i + 3 >= strings.size()) valid_mask &= ~(1 << 3);\n\n        int32x4_t max_len_vec = vmovq_n_s32(longest_len);\n        uint32x4_t cmp = vcgtq_s32(lengths, max_len_vec);\n\n        uint64x2_t cmp_packed = vreinterpretq_u64_u32(cmp);\n        uint64_t mask = vgetq_lane_u64(cmp_packed, 0) | (vgetq_lane_u64(cmp_packed, 1) << 4);\n\n        mask &= valid_mask;\n\n        if (mask & (1 << 0)) {\n            longest_str = strings[i + 0];\n            longest_len = strings[i + 0].length();\n        }\n        if (mask & (1 << 1)) {\n            longest_str = strings[i + 1];\n            longest_len = strings[i + 1].length();\n        }\n        if (mask & (1 << 2)) {\n            longest_str = strings[i + 2];\n            longest_len = strings[i + 2].length();\n        }\n        if (mask & (1 << 3)) {\n            longest_str = strings[i + 3];\n            longest_len = strings[i + 3].length();\n        }\n    }\n\n    return longest_str;\n}\n```"}
{"task_id": "SimdBench_69_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::string longest_simd(const std::vector<std::string> &strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    std::string longest_str = strings[0];\n    int longest_len = longest_str.length();\n\n    for (size_t i = 1; i < strings.size(); i += 4) {\n        int32x4_t lengths = vdupq_n_s32(0);\n\n        // Load lengths of up to 4 strings into a SIMD register\n        for (size_t j = 0; j < 4 && (i + j) < strings.size(); ++j) {\n            lengths = vld1q_lane_s32(&static_cast<int>(strings[i + j].length()), lengths, j);\n        }\n\n        // Compare lengths with the current longest length\n        int32x4_t cmp = vcgtq_s32(lengths, vdupq_n_s32(longest_len));\n\n        // Extract results from SIMD register\n        int32_t results[4];\n        vst1q_s32(results, cmp);\n\n        for (size_t j = 0; j < 4 && (i + j) < strings.size(); ++j) {\n            if (results[j]) {\n                longest_str = strings[i + j];\n                longest_len = strings[i + j].length();\n            }\n        }\n    }\n\n    return longest_str;\n}\n```"}
{"task_id": "SimdBench_69_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <vector>\n\nstd::string longest_simd(const std::vector<std::string> &strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    std::string longest_str = strings[0];\n    int longest_len = longest_str.length();\n\n    for (size_t i = 1; i < strings.size(); i += 4) {\n        int32x4_t lengths = {0, 0, 0, 0};\n        int valid_mask = 0xF;\n\n        if (i + 0 < strings.size()) lengths = vsetq_lane_s32(strings[i + 0].length(), lengths, 0);\n        if (i + 1 < strings.size()) lengths = vsetq_lane_s32(strings[i + 1].length(), lengths, 1);\n        if (i + 2 < strings.size()) lengths = vsetq_lane_s32(strings[i + 2].length(), lengths, 2);\n        if (i + 3 < strings.size()) lengths = vsetq_lane_s32(strings[i + 3].length(), lengths, 3);\n\n        if (i + 0 >= strings.size()) valid_mask &= ~(1 << 0);\n        if (i + 1 >= strings.size()) valid_mask &= ~(1 << 1);\n        if (i + 2 >= strings.size()) valid_mask &= ~(1 << 2);\n        if (i + 3 >= strings.size()) valid_mask &= ~(1 << 3);\n\n        int32x4_t cmp = vcgtq_s32(lengths, vdupq_n_s32(longest_len));\n        uint32x4_t mask = vandq_u32(vreinterpretq_u32_s32(cmp), vdupq_n_u32(valid_mask));\n\n        if (vgetq_lane_u32(mask, 0)) {\n            longest_str = strings[i + 0];\n            longest_len = strings[i + 0].length();\n        }\n        if (vgetq_lane_u32(mask, 1)) {\n            longest_str = strings[i + 1];\n            longest_len = strings[i + 1].length();\n        }\n        if (vgetq_lane_u32(mask, 2)) {\n            longest_str = strings[i + 2];\n            longest_len = strings[i + 2].length();\n        }\n        if (vgetq_lane_u32(mask, 3)) {\n            longest_str = strings[i + 3];\n            longest_len = strings[i + 3].length();\n        }\n    }\n\n    return longest_str;\n}\n```"}
{"task_id": "SimdBench_69_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <vector>\n\nstd::string longest_simd(const std::vector<std::string> &strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    std::string longest = strings[0];\n    int max_length = longest.length();\n\n    for (size_t i = 1; i < strings.size(); i += 4) {\n        int32x4_t lengths = {0, 0, 0, 0};\n        int32x4_t indices = {0, 0, 0, 0};\n\n        for (int j = 0; j < 4 && (i + j) < strings.size(); ++j) {\n            lengths[j] = strings[i + j].length();\n            indices[j] = i + j;\n        }\n\n        int32x4_t max_len_vec = vdupq_n_s32(max_length);\n        uint32x4_t cmp = vcgtq_s32(lengths, max_len_vec);\n\n        if (vmaxvq_u32(cmp)) {\n            for (int j = 0; j < 4 && (i + j) < strings.size(); ++j) {\n                if (lengths[j] > max_length) {\n                    max_length = lengths[j];\n                    longest = strings[indices[j]];\n                }\n            }\n        }\n    }\n\n    return longest;\n}\n```"}
{"task_id": "SimdBench_69_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::string longest_simd(const std::vector<std::string> &strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    std::string longest = strings[0];\n    int max_length = longest.length();\n\n    for (size_t i = 1; i < strings.size(); i += 4) {\n        int32x4_t lengths = {0, 0, 0, 0};\n        int valid_mask = 0xF;\n\n        if (i + 0 < strings.size()) lengths = vsetq_lane_s32(strings[i + 0].length(), lengths, 0);\n        if (i + 1 < strings.size()) lengths = vsetq_lane_s32(strings[i + 1].length(), lengths, 1);\n        if (i + 2 < strings.size()) lengths = vsetq_lane_s32(strings[i + 2].length(), lengths, 2);\n        if (i + 3 < strings.size()) lengths = vsetq_lane_s32(strings[i + 3].length(), lengths, 3);\n\n        if (i + 0 >= strings.size()) valid_mask &= ~(1 << 0);\n        if (i + 1 >= strings.size()) valid_mask &= ~(1 << 1);\n        if (i + 2 >= strings.size()) valid_mask &= ~(1 << 2);\n        if (i + 3 >= strings.size()) valid_mask &= ~(1 << 3);\n\n        int32x4_t max_len_vec = vdupq_n_s32(max_length);\n        uint32x4_t cmp = vcgtq_s32(lengths, max_len_vec);\n\n        uint64x2_t cmp_packed = vreinterpretq_u64_u32(cmp);\n        uint64_t mask = vgetq_lane_u64(cmp_packed, 0) | (vgetq_lane_u64(cmp_packed, 1) << 4);\n        mask &= valid_mask;\n\n        if (mask & (1 << 0)) {\n            max_length = strings[i + 0].length();\n            longest = strings[i + 0];\n        }\n        if (mask & (1 << 1)) {\n            max_length = strings[i + 1].length();\n            longest = strings[i + 1];\n        }\n        if (mask & (1 << 2)) {\n            max_length = strings[i + 2].length();\n            longest = strings[i + 2];\n        }\n        if (mask & (1 << 3)) {\n            max_length = strings[i + 3].length();\n            longest = strings[i + 3];\n        }\n    }\n\n    return longest;\n}\n```"}
{"task_id": "SimdBench_70_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    uint64x2_t va = vdupq_n_u64(a);\n    uint64x2_t vb = vdupq_n_u64(b);\n\n    while (vgetq_lane_u64(vb, 0) != 0 || vgetq_lane_u64(vb, 1) != 0) {\n        uint64x2_t vr = vcopyq_lane_u64(va, 0, vb, 0);\n        va = vb;\n        vb = vr;\n        uint64x2_t vrem = vqrdcq_u64(va, vb);\n        vb = vrem;\n    }\n\n    return vgetq_lane_u64(va, 0);\n}\n```"}
{"task_id": "SimdBench_70_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    uint64x2_t va = vdupq_n_u64(a);\n    uint64x2_t vb = vdupq_n_u64(b);\n    \n    while (1) {\n        uint64x2_t vrem = vreinterpretq_u64_u32(vcltq_u64(va, vb));\n        uint64x2_t vtemp = vbslq_u64(vrem, va, vb);\n        vb = vbslq_u64(vrem, vb, va);\n        va = vtemp;\n\n        uint64_t a_scalar = vgetq_lane_u64(va, 0);\n        uint64_t b_scalar = vgetq_lane_u64(vb, 0);\n\n        if (b_scalar == 0) {\n            return a_scalar;\n        }\n\n        uint64_t rem = a_scalar % b_scalar;\n        va = vdupq_n_u64(rem);\n        vb = vdupq_n_u64(b_scalar);\n    }\n}\n```"}
{"task_id": "SimdBench_70_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    uint64x2_t va = vdupq_n_u64(a);\n    uint64x2_t vb = vdupq_n_u64(b);\n    \n    while (1) {\n        uint64x2_t vrem = vreinterpretq_u64_u32(vcltq_u64(va, vb));\n        uint64x2_t vtemp = vbslq_u64(vrem, va, vb);\n        vb = vbslq_u64(vrem, vb, va);\n        va = vtemp;\n\n        uint64x2_t vzero = vdupq_n_u64(0);\n        uint64x2_t vcmp = vceqq_u64(vb, vzero);\n\n        if (vgetq_lane_u64(vcmp, 0) && vgetq_lane_u64(vcmp, 1)) {\n            break;\n        }\n\n        uint64x2_t vmod = vqrdmlahq_u64(vdupq_n_u64(0), va, vb);\n        vb = vmod;\n    }\n\n    return vgetq_lane_u64(va, 0);\n}\n```"}
{"task_id": "SimdBench_70_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    uint64x2_t va = vdupq_n_u64(a);\n    uint64x2_t vb = vdupq_n_u64(b);\n    \n    while (1) {\n        uint64x2_t vrem = vreinterpretq_u64_u32(vcltq_u64(va, vb));\n        uint64x2_t vtemp = vbslq_u64(vrem, va, vb);\n        vb = vbslq_u64(vrem, vb, va);\n        va = vtemp;\n\n        uint64_t rem[2];\n        vst1q_u64(rem, va);\n\n        if (rem[0] == 0 && rem[1] == 0) {\n            break;\n        }\n\n        uint64x2_t vdiv = vdivq_u64(vb, va);\n        uint64x2_t vmul = vmulq_u64(vdiv, va);\n        vb = vsubq_u64(vb, vmul);\n    }\n\n    uint64_t result[2];\n    vst1q_u64(result, vb);\n    return result[0];\n}\n```"}
{"task_id": "SimdBench_70_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    uint64x2_t va = vdupq_n_u64(a);\n    uint64x2_t vb = vdupq_n_u64(b);\n    \n    while (1) {\n        uint64x2_t vrem = vreinterpretq_u64_u32(vcltq_u64(va, vb));\n        uint64x2_t vtemp = vbslq_u64(vrem, va, vb);\n        vb = vbslq_u64(vrem, vb, va);\n        va = vtemp;\n\n        uint64x2_t vzero = vdupq_n_u64(0);\n        uint64x2_t vcmp = vceqq_u64(vb, vzero);\n        if (vgetq_lane_u64(vcmp, 0) && vgetq_lane_u64(vcmp, 1)) {\n            break;\n        }\n\n        uint64x2_t vmod = vdupq_n_u64(0);\n        vmod = vsetq_lane_u64(vgetq_lane_u64(va, 0) % vgetq_lane_u64(vb, 0), vmod, 0);\n        vmod = vsetq_lane_u64(vgetq_lane_u64(va, 1) % vgetq_lane_u64(vb, 1), vmod, 1);\n        va = vmod;\n    }\n\n    return vgetq_lane_u64(va, 0);\n}\n```"}
{"task_id": "SimdBench_71_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    int n = numbers.size();\n    float closest_pair[2] = {0.0f, 0.0f};\n    float min_diff = std::numeric_limits<float>::max();\n\n    for (int i = 0; i <= n - 4; i += 4) {\n        // Load four elements into a SIMD register\n        float32x4_t vec1 = vld1q_f32(&numbers[i]);\n\n        for (int j = i + 1; j < n; ++j) {\n            // Broadcast the j-th element to all lanes of a SIMD register\n            float32x4_t vec2 = vdupq_n_f32(numbers[j]);\n\n            // Compute absolute differences between vec1 and vec2\n            float32x4_t diff = vabdq_f32(vec1, vec2);\n\n            // Find the minimum difference in the SIMD register\n            float32x2_t diff_low = vget_low_f32(diff);\n            float32x2_t diff_high = vget_high_f32(diff);\n            float32x2_t min_diff_vec = vpmin_f32(diff_low, diff_high);\n            min_diff_vec = vpmin_f32(min_diff_vec, min_diff_vec);\n\n            // Extract the minimum difference from the SIMD register\n            float current_min_diff = vget_lane_f32(min_diff_vec, 0);\n\n            // Check if this is the smallest difference found so far\n            if (current_min_diff < min_diff) {\n                min_diff = current_min_diff;\n\n                // Identify which pair produced this minimum difference\n                for (int k = 0; k < 4; ++k) {\n                    if (std::abs(numbers[i + k] - numbers[j]) == min_diff) {\n                        closest_pair[0] = std::min(numbers[i + k], numbers[j]);\n                        closest_pair[1] = std::max(numbers[i + k], numbers[j]);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    // Handle any remaining elements that didn't fit into the SIMD loop\n    for (int i = n - (n % 4); i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                closest_pair[0] = std::min(numbers[i], numbers[j]);\n                closest_pair[1] = std::max(numbers[i], numbers[j]);\n            }\n        }\n    }\n\n    return std::vector<float>(closest_pair, closest_pair + 2);\n}\n```"}
{"task_id": "SimdBench_71_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    int n = numbers.size();\n    float closest_pair[2];\n    float min_diff = std::numeric_limits<float>::max();\n\n    for (int i = 0; i <= n - 4; i += 4) {\n        float32x4_t vi = vld1q_f32(&numbers[i]);\n\n        for (int j = i + 1; j < n; j++) {\n            float32x4_t vj = vdupq_n_f32(numbers[j]);\n            float32x4_t diff = vabsq_f32(vsubq_f32(vi, vj));\n\n            float diffs[4];\n            vst1q_f32(diffs, diff);\n\n            for (int k = 0; k < 4; k++) {\n                if (diffs[k] < min_diff && i + k != j) {\n                    min_diff = diffs[k];\n                    closest_pair[0] = std::min(numbers[i + k], numbers[j]);\n                    closest_pair[1] = std::max(numbers[i + k], numbers[j]);\n                }\n            }\n        }\n    }\n\n    // Handle remaining elements\n    for (int i = n - (n % 4); i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                closest_pair[0] = std::min(numbers[i], numbers[j]);\n                closest_pair[1] = std::max(numbers[i], numbers[j]);\n            }\n        }\n    }\n\n    return std::vector<float>(closest_pair, closest_pair + 2);\n}\n```"}
{"task_id": "SimdBench_71_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    int n = numbers.size();\n    float closest_pair[2];\n    float min_diff = INFINITY;\n\n    for (int i = 0; i <= n - 4; i += 4) {\n        float32x4_t vi = vld1q_f32(&numbers[i]);\n\n        for (int j = i + 1; j < n; j++) {\n            float32x4_t vj = vdupq_n_f32(numbers[j]);\n            float32x4_t diff = vsubq_f32(vi, vj);\n            float32x4_t abs_diff = vabsq_f32(diff);\n\n            float diffs[4];\n            vst1q_f32(diffs, abs_diff);\n\n            for (int k = 0; k < 4; k++) {\n                if (diffs[k] < min_diff && i + k < j) {\n                    min_diff = diffs[k];\n                    closest_pair[0] = std::min(numbers[i + k], numbers[j]);\n                    closest_pair[1] = std::max(numbers[i + k], numbers[j]);\n                }\n            }\n        }\n    }\n\n    // Handle remaining elements\n    for (int i = n - (n % 4); i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                closest_pair[0] = std::min(numbers[i], numbers[j]);\n                closest_pair[1] = std::max(numbers[i], numbers[j]);\n            }\n        }\n    }\n\n    return std::vector<float>(closest_pair, closest_pair + 2);\n}\n```"}
{"task_id": "SimdBench_71_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    int n = numbers.size();\n    float closest_pair[2] = {0.0f, 0.0f};\n    float min_diff = std::numeric_limits<float>::max();\n\n    for (int i = 0; i <= n - 4; i += 4) {\n        // Load four elements into a SIMD register\n        float32x4_t vec1 = vld1q_f32(&numbers[i]);\n\n        for (int j = i + 1; j < n; ++j) {\n            // Broadcast the j-th element to all lanes of a SIMD register\n            float32x4_t vec2 = vmovq_n_f32(numbers[j]);\n\n            // Compute absolute differences between vec1 and vec2\n            float32x4_t diff = vabdq_f32(vec1, vec2);\n\n            // Find the minimum difference in the SIMD register\n            float32x2_t min_diff_low = vpmin_f32(vget_low_f32(diff), vget_high_f32(diff));\n            float32x2_t min_diff_final = vpmin_f32(min_diff_low, min_diff_low);\n            float current_min_diff = vget_lane_f32(min_diff_final, 0);\n\n            // Check if this is the smallest difference found so far\n            if (current_min_diff < min_diff) {\n                min_diff = current_min_diff;\n\n                // Identify which pair produced this minimum difference\n                for (int k = 0; k < 4; ++k) {\n                    float diff_k = std::abs(numbers[i + k] - numbers[j]);\n                    if (diff_k == min_diff) {\n                        closest_pair[0] = std::min(numbers[i + k], numbers[j]);\n                        closest_pair[1] = std::max(numbers[i + k], numbers[j]);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    // Handle any remaining elements that didn't fit into the SIMD loop\n    for (int i = n - (n % 4); i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                closest_pair[0] = std::min(numbers[i], numbers[j]);\n                closest_pair[1] = std::max(numbers[i], numbers[j]);\n            }\n        }\n    }\n\n    return std::vector<float>(closest_pair, closest_pair + 2);\n}\n```"}
{"task_id": "SimdBench_71_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    int n = numbers.size();\n    float closest_pair[2];\n    float min_diff = std::numeric_limits<float>::max();\n\n    for (int i = 0; i <= n - 4; i += 4) {\n        // Load four elements into a SIMD register\n        float32x4_t vec1 = vld1q_f32(&numbers[i]);\n\n        for (int j = i + 1; j < n; ++j) {\n            // Broadcast the j-th element to all lanes of a SIMD register\n            float32x4_t vec2 = vmovq_n_f32(numbers[j]);\n\n            // Compute absolute differences between vec1 and vec2\n            float32x4_t diff = vabdq_f32(vec1, vec2);\n\n            // Find the minimum difference in the SIMD register\n            float32x2_t min_diff_low = vpmin_f32(vget_low_f32(diff), vget_high_f32(diff));\n            float32x2_t min_diff_final = vpmin_f32(min_diff_low, min_diff_low);\n            float current_min_diff = vget_lane_f32(min_diff_final, 0);\n\n            // Check if this is the smallest difference found so far\n            if (current_min_diff < min_diff) {\n                min_diff = current_min_diff;\n\n                // Identify which pair produced this minimum difference\n                for (int k = 0; k < 4; ++k) {\n                    float temp_diff = std::abs(numbers[i + k] - numbers[j]);\n                    if (temp_diff == min_diff) {\n                        closest_pair[0] = std::min(numbers[i + k], numbers[j]);\n                        closest_pair[1] = std::max(numbers[i + k], numbers[j]);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    // Handle any remaining elements that didn't fit into the SIMD loop\n    for (int i = n - (n % 4); i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                closest_pair[0] = std::min(numbers[i], numbers[j]);\n                closest_pair[1] = std::max(numbers[i], numbers[j]);\n            }\n        }\n    }\n\n    return {closest_pair[0], closest_pair[1]};\n}\n```"}
{"task_id": "SimdBench_72_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    int n = numbers.size();\n    std::vector<float> result(n);\n\n    // Find min and max using SIMD\n    float32x4_t vmin = vld1q_f32(&numbers[0]);\n    float32x4_t vmax = vmin;\n\n    int i = 0;\n    for (; i <= n - 4; i += 4) {\n        float32x4_t v = vld1q_f32(&numbers[i]);\n        vmin = vminq_f32(vmin, v);\n        vmax = vmaxq_f32(vmax, v);\n    }\n\n    // Horizontal min and max reduction\n    float min_val = vmin[0];\n    float max_val = vmax[0];\n    for (int j = 1; j < 4; ++j) {\n        min_val = std::min(min_val, vmin[j]);\n        max_val = std::max(max_val, vmax[j]);\n    }\n\n    // Process remaining elements\n    for (; i < n; ++i) {\n        min_val = std::min(min_val, numbers[i]);\n        max_val = std::max(max_val, numbers[i]);\n    }\n\n    float range = max_val - min_val;\n\n    // Rescale using SIMD\n    i = 0;\n    float32x4_t vrange = vdupq_n_f32(range);\n    float32x4_t vmin_vec = vdupq_n_f32(min_val);\n\n    for (; i <= n - 4; i += 4) {\n        float32x4_t v = vld1q_f32(&numbers[i]);\n        float32x4_t vrescaled = vsubq_f32(v, vmin_vec);\n        vrescaled = vdivq_f32(vrescaled, vrange);\n        vst1q_f32(&result[i], vrescaled);\n    }\n\n    // Process remaining elements\n    for (; i < n; ++i) {\n        result[i] = (numbers[i] - min_val) / range;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    int n = numbers.size();\n    std::vector<float> result(n);\n\n    // Find min and max using SIMD\n    float32x4_t vmin = vld1q_f32(&numbers[0]);\n    float32x4_t vmax = vmin;\n\n    int i = 0;\n    for (; i <= n - 4; i += 4) {\n        float32x4_t v = vld1q_f32(&numbers[i]);\n        vmin = vminq_f32(vmin, v);\n        vmax = vmaxq_f32(vmax, v);\n    }\n\n    // Horizontal min/max reduction\n    float min_val = vmin[0];\n    float max_val = vmax[0];\n    for (int j = 1; j < 4; ++j) {\n        min_val = std::min(min_val, vmin[j]);\n        max_val = std::max(max_val, vmax[j]);\n    }\n\n    // Process remaining elements\n    for (; i < n; ++i) {\n        min_val = std::min(min_val, numbers[i]);\n        max_val = std::max(max_val, numbers[i]);\n    }\n\n    float range = max_val - min_val;\n\n    // Rescale using SIMD\n    i = 0;\n    for (; i <= n - 4; i += 4) {\n        float32x4_t v = vld1q_f32(&numbers[i]);\n        float32x4_t vrescaled = vmulq_n_f32(vsubq_f32(v, vdupq_n_f32(min_val)), 1.0f / range);\n        vst1q_f32(&result[i], vrescaled);\n    }\n\n    // Process remaining elements\n    for (; i < n; ++i) {\n        result[i] = (numbers[i] - min_val) / range;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    int n = numbers.size();\n    std::vector<float> result(n);\n\n    // Find min and max using SIMD\n    float32x4_t vmin = vld1q_f32(&numbers[0]);\n    float32x4_t vmax = vmin;\n\n    int i = 0;\n    for (; i <= n - 4; i += 4) {\n        float32x4_t v = vld1q_f32(&numbers[i]);\n        vmin = vminq_f32(vmin, v);\n        vmax = vmaxq_f32(vmax, v);\n    }\n\n    // Horizontal min and max reduction\n    float min_val = vmin[0];\n    float max_val = vmax[0];\n    for (int j = 1; j < 4; ++j) {\n        min_val = std::min(min_val, vmin[j]);\n        max_val = std::max(max_val, vmax[j]);\n    }\n\n    // Process remaining elements\n    for (; i < n; ++i) {\n        min_val = std::min(min_val, numbers[i]);\n        max_val = std::max(max_val, numbers[i]);\n    }\n\n    float range = max_val - min_val;\n\n    // Rescale using SIMD\n    i = 0;\n    for (; i <= n - 4; i += 4) {\n        float32x4_t v = vld1q_f32(&numbers[i]);\n        float32x4_t vrescaled = vmulq_n_f32(vsubq_f32(v, vdupq_n_f32(min_val)), 1.0f / range);\n        vst1q_f32(&result[i], vrescaled);\n    }\n\n    // Process remaining elements\n    for (; i < n; ++i) {\n        result[i] = (numbers[i] - min_val) / range;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    int n = numbers.size();\n    std::vector<float> result(n);\n\n    // Find min and max using SIMD\n    float32x4_t vmin = vld1q_f32(&numbers[0]);\n    float32x4_t vmax = vmin;\n\n    int i = 0;\n    for (; i <= n - 4; i += 4) {\n        float32x4_t v = vld1q_f32(&numbers[i]);\n        vmin = vminq_f32(vmin, v);\n        vmax = vmaxq_f32(vmax, v);\n    }\n\n    // Horizontal min and max reduction\n    float min_val = vmin[0];\n    float max_val = vmax[0];\n    for (int j = 1; j < 4; ++j) {\n        min_val = std::min(min_val, vmin[j]);\n        max_val = std::max(max_val, vmax[j]);\n    }\n\n    // Process remaining elements\n    for (; i < n; ++i) {\n        min_val = std::min(min_val, numbers[i]);\n        max_val = std::max(max_val, numbers[i]);\n    }\n\n    float range = max_val - min_val;\n\n    // Rescale using SIMD\n    i = 0;\n    for (; i <= n - 4; i += 4) {\n        float32x4_t v = vld1q_f32(&numbers[i]);\n        float32x4_t vrescaled = vmulq_n_f32(vsubq_f32(v, vmin), 1.0f / range);\n        vst1q_f32(&result[i], vrescaled);\n    }\n\n    // Process remaining elements\n    for (; i < n; ++i) {\n        result[i] = (numbers[i] - min_val) / range;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    int n = numbers.size();\n    std::vector<float> result(n);\n\n    // Find min and max using SIMD\n    float32x4_t vmin = vld1q_f32(&numbers[0]);\n    float32x4_t vmax = vmin;\n\n    int i = 0;\n    for (; i <= n - 4; i += 4) {\n        float32x4_t v = vld1q_f32(&numbers[i]);\n        vmin = vminq_f32(vmin, v);\n        vmax = vmaxq_f32(vmax, v);\n    }\n\n    // Horizontal min and max reduction\n    float min_val = vmin[0];\n    float max_val = vmax[0];\n    for (int j = 1; j < 4; ++j) {\n        min_val = std::min(min_val, vmin[j]);\n        max_val = std::max(max_val, vmax[j]);\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        min_val = std::min(min_val, numbers[i]);\n        max_val = std::max(max_val, numbers[i]);\n    }\n\n    float range = max_val - min_val;\n\n    // Rescale using SIMD\n    i = 0;\n    for (; i <= n - 4; i += 4) {\n        float32x4_t v = vld1q_f32(&numbers[i]);\n        float32x4_t vrescaled = vmulq_n_f32(vsubq_f32(v, vmin), 1.0f / range);\n        vst1q_f32(&result[i], vrescaled);\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        result[i] = (numbers[i] - min_val) / range;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_73_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    uint64_t result = 1;\n    uint64x2_t vn = vdupq_n_u64(n);\n    uint64x2_t vresult = vdupq_n_u64(1);\n    uint64x2_t vdivisor = vdupq_n_u64(2);\n    uint64x2_t vstep = vdupq_n_u64(2);\n\n    for (uint64_t i = 2; i <= n / 2; i += 2) {\n        uint64x2_t vremainder = vmodq_u64(vn, vdivisor);\n        uint64x2_t vmask = vceqq_u64(vremainder, vdupq_n_u64(0));\n\n        uint64x2_t vupdate = vandq_u64(vmask, vdivisor);\n        vresult = vmaxq_u64(vresult, vupdate);\n\n        vdivisor = vaddq_u64(vdivisor, vstep);\n    }\n\n    uint64_t temp[2];\n    vst1q_u64(temp, vresult);\n    result = temp[0] > temp[1] ? temp[0] : temp[1];\n\n    if (n % (result + 1) == 0) {\n        result = n / (result + 1);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_73_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    uint64_t result = 1;\n    uint64x2_t vn = vdupq_n_u64(n);\n    uint64x2_t vresult = vdupq_n_u64(1);\n    uint64x2_t vdivisor = vdupq_n_u64(2);\n    uint64x2_t vstep = vdupq_n_u64(2);\n\n    for (uint64_t i = 2; i * i <= n; i += 2) {\n        uint64x2_t vi = vdupq_n_u64(i);\n        uint64x2_t vremainder = vqrdcq_u64(vn, vi);\n        uint64_t remainder[2];\n        vst1q_u64(remainder, vremainder);\n\n        if (remainder[0] == 0) {\n            result = i;\n        }\n\n        if (remainder[1] == 0 && i + 1 <= n / (i + 1)) {\n            result = i + 1;\n        }\n    }\n\n    if (result == 1) {\n        return n;\n    }\n\n    return n / result;\n}\n```"}
{"task_id": "SimdBench_73_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    uint64_t result = 1;\n    uint64x2_t vn = vdupq_n_u64(n);\n    uint64x2_t vresult = vdupq_n_u64(1);\n    uint64x2_t vdivisor = vdupq_n_u64(2);\n    uint64x2_t vstep = vdupq_n_u64(2);\n\n    for (uint64_t i = 2; i <= n / 2; i += 2) {\n        uint64x2_t vremainder;\n        vremainder = vqrdcq_u64(vn, vdivisor);\n\n        uint64x2_t vmask = vceqq_u64(vmulq_u64(vremainder, vdivisor), vn);\n        vresult = vbslq_u64(vmask, vdivisor, vresult);\n\n        vdivisor = vaddq_u64(vdivisor, vstep);\n    }\n\n    uint64_t results[2];\n    vst1q_u64(results, vresult);\n    result = results[0] > results[1] ? results[0] : results[1];\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_73_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    uint64_t result = 1;\n    uint64x2_t vn = vdupq_n_u64(n);\n    uint64x2_t vresult = vdupq_n_u64(1);\n    uint64x2_t vdivisor = vdupq_n_u64(2);\n    uint64x2_t vstep = vdupq_n_u64(2);\n\n    for (uint64_t i = 2; i * i <= n; i += 2) {\n        uint64x2_t vremainder;\n        vremainder = vqrdcq_u64(vn, vdivisor);\n\n        uint64x2_t vmul = vmulq_u64(vremainder, vdivisor);\n        uint64x2_t vequal = vceqq_u64(vmul, vn);\n\n        if (vgetq_lane_u64(vequal, 0)) {\n            vresult = vdivisor;\n        }\n\n        vdivisor = vaddq_u64(vdivisor, vstep);\n    }\n\n    uint64_t max_divisor = vgetq_lane_u64(vresult, 0);\n    if (max_divisor == 1) {\n        return n - 1;\n    }\n    return max_divisor;\n}\n```"}
{"task_id": "SimdBench_73_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    uint64_t result = 1;\n    uint64x2_t vn = vdupq_n_u64(n);\n    uint64x2_t vresult = vdupq_n_u64(1);\n    uint64x2_t vdivisor = vdupq_n_u64(2);\n    uint64x2_t vstep = vdupq_n_u64(2);\n\n    for (uint64_t i = 2; i * i <= n; i += 2) {\n        uint64x2_t vremainder;\n        vremainder = vqrdcq_u64(vn, vdivisor);\n\n        uint64x2_t vmul = vmulq_u64(vremainder, vdivisor);\n        uint64x2_t vequal = vceqq_u64(vmul, vn);\n\n        if (vgetq_lane_u64(vequal, 0)) {\n            vresult = vdivisor;\n        }\n\n        if (vgetq_lane_u64(vequal, 1)) {\n            vresult = vdivisor;\n        }\n\n        vdivisor = vaddq_u64(vdivisor, vstep);\n    }\n\n    uint64_t max_divisor = vgetq_lane_u64(vresult, 0);\n    if (max_divisor == 1) {\n        return n - 1;\n    }\n    return max_divisor;\n}\n```"}
{"task_id": "SimdBench_74_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    int32x4_t vn = vdupq_n_s32(n);\n    int32x4_t vfactor = vdupq_n_s32(2);\n\n    while (vgetq_lane_s32(vn, 0) > 1) {\n        uint32x4_t mask = vceqq_s32(vn, vdupq_n_s32(1));\n        if (vgetq_lane_u32(mask, 0)) break;\n\n        int32x4_t vremainder = vdupq_n_s32(vgetq_lane_s32(vn, 0) % vgetq_lane_s32(vfactor, 0));\n        uint32x4_t divisible = vceqq_s32(vremainder, vdupq_n_s32(0));\n\n        if (vgetq_lane_u32(divisible, 0)) {\n            vn = vdivq_s32(vn, vfactor);\n            factors.push_back(vgetq_lane_s32(vfactor, 0));\n        } else {\n            vfactor = vaddq_s32(vfactor, vdupq_n_s32(1));\n        }\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    int32x4_t vn = vdupq_n_s32(n);\n    int32x4_t vdivisor = vdupq_n_s32(2);\n\n    while (vgetq_lane_s32(vn, 0) > 1) {\n        uint32x4_t mask = vcltq_s32(vdupq_n_s32(1), vn);\n        int32x4_t vremainder = vdupq_n_s32(0);\n\n        for (int i = 0; i < 4; ++i) {\n            if (vgetq_lane_s32(vn, i) > 1) {\n                int divisor = vgetq_lane_s32(vdivisor, i);\n                while (vgetq_lane_s32(vn, i) % divisor == 0) {\n                    factors.push_back(divisor);\n                    vn = vsetq_lane_s32(vgetq_lane_s32(vn, i) / divisor, vn, i);\n                }\n            }\n        }\n\n        vdivisor = vaddq_s32(vdivisor, vdupq_n_s32(1));\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    int32x4_t vn = vdupq_n_s32(n);\n    int32x4_t vdivisor = vdupq_n_s32(2);\n\n    while (vgetq_lane_s32(vn, 0) > 1) {\n        uint32x4_t mask = vceqq_s32(vremq_s32(vn, vdivisor), vdupq_n_s32(0));\n        if (vaddvq_u32(mask) > 0) {\n            vn = vdivq_s32(vn, vdivisor);\n            factors.push_back(vgetq_lane_s32(vdivisor, 0));\n        } else {\n            vdivisor = vaddq_s32(vdivisor, vdupq_n_s32(1));\n        }\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    int32x4_t vn = vdupq_n_s32(n);\n    int32x4_t vdivisor = vdupq_n_s32(2);\n\n    while (vgetq_lane_s32(vn, 0) > 1) {\n        uint32x4_t mask = vceqq_s32(vremq_s32(vn, vdivisor), vdupq_n_s32(0));\n        if (vaddvq_u32(mask) > 0) {\n            vn = vdivq_s32(vn, vdivisor);\n            factors.push_back(vgetq_lane_s32(vdivisor, 0));\n        } else {\n            vdivisor = vaddq_s32(vdivisor, vdupq_n_s32(1));\n        }\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    int32x4_t vn = vdupq_n_s32(n);\n    int32x4_t vfactor = vdupq_n_s32(2);\n\n    while (vgetq_lane_s32(vn, 0) > 1) {\n        uint32x4_t mask = vceqq_s32(vremq_s32(vn, vfactor), vdupq_n_s32(0));\n        if (vaddvq_u32(mask) > 0) {\n            vn = vdivq_s32(vn, vfactor);\n            factors.push_back(vgetq_lane_s32(vfactor, 0));\n        } else {\n            vfactor = vaddq_s32(vfactor, vdupq_n_s32(1));\n        }\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_75_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    int size = l.size();\n    int i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= size - 4; i += 4) {\n        // Load 4 floats into a NEON register\n        float32x4_t vec = vld1q_f32(&l[i]);\n\n        // Compare each element with 0 to create a mask of positive values\n        uint32x4_t mask = vcgtq_f32(vec, vdupq_n_f32(0.0f));\n\n        // Use the mask to zero out negative or zero values\n        float32x4_t positives = vbslq_f32(mask, vec, vdupq_n_f32(0.0f));\n\n        // Store the results temporarily\n        float temp[4];\n        vst1q_f32(temp, positives);\n\n        // Add non-zero values to the result vector\n        for (int j = 0; j < 4; ++j) {\n            if (temp[j] > 0.0f) {\n                result.push_back(temp[j]);\n            }\n        }\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        if (l[i] > 0.0f) {\n            result.push_back(l[i]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    int size = l.size();\n    int i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= size - 4; i += 4) {\n        // Load 4 floats into a NEON register\n        float32x4_t vec = vld1q_f32(&l[i]);\n\n        // Compare each element with 0 to create a mask of positive values\n        uint32x4_t mask = vcgtq_f32(vec, vdupq_n_f32(0.0f));\n\n        // Use the mask to zero out negative or zero values\n        float32x4_t positives = vbslq_f32(mask, vec, vdupq_n_f32(0.0f));\n\n        // Store the results temporarily\n        float temp[4];\n        vst1q_f32(temp, positives);\n\n        // Add only positive values to the result vector\n        for (int j = 0; j < 4; ++j) {\n            if (temp[j] > 0.0f) {\n                result.push_back(temp[j]);\n            }\n        }\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        if (l[i] > 0.0f) {\n            result.push_back(l[i]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    int size = l.size();\n    int i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= size - 4; i += 4) {\n        // Load 4 floats into a NEON register\n        float32x4_t vec = vld1q_f32(&l[i]);\n\n        // Compare each element with 0 to create a mask of positive values\n        uint32x4_t mask = vcgtq_f32(vec, vdupq_n_f32(0.0f));\n\n        // Use the mask to zero out negative or zero values\n        float32x4_t positives = vbslq_f32(mask, vec, vdupq_n_f32(0.0f));\n\n        // Store the results temporarily\n        float temp[4];\n        vst1q_f32(temp, positives);\n\n        // Add non-zero values to the result vector\n        for (int j = 0; j < 4; ++j) {\n            if (temp[j] > 0.0f) {\n                result.push_back(temp[j]);\n            }\n        }\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        if (l[i] > 0.0f) {\n            result.push_back(l[i]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    int size = l.size();\n    int i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= size - 4; i += 4) {\n        // Load 4 floats into a NEON register\n        float32x4_t vec = vld1q_f32(&l[i]);\n\n        // Create a mask for positive values (vec > 0.0)\n        uint32x4_t mask = vcgtq_f32(vec, vdupq_n_f32(0.0f));\n\n        // Use the mask to zero out negative or zero values\n        float32x4_t positives = vbslq_f32(mask, vec, vdupq_n_f32(0.0f));\n\n        // Store the results temporarily\n        float temp[4];\n        vst1q_f32(temp, positives);\n\n        // Add positive values to the result vector\n        for (int j = 0; j < 4; ++j) {\n            if (temp[j] > 0.0f) {\n                result.push_back(temp[j]);\n            }\n        }\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        if (l[i] > 0.0f) {\n            result.push_back(l[i]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    int size = l.size();\n    int i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= size - 4; i += 4) {\n        // Load 4 floats into a NEON register\n        float32x4_t vec = vld1q_f32(&l[i]);\n\n        // Compare each element with 0 to create a mask of positive values\n        uint32x4_t mask = vcgtq_f32(vec, vdupq_n_f32(0.0f));\n\n        // Use the mask to zero out negative or zero values\n        float32x4_t positives = vbslq_f32(mask, vec, vdupq_n_f32(0.0f));\n\n        // Store the results temporarily\n        float temp[4];\n        vst1q_f32(temp, positives);\n\n        // Add non-zero values to the result vector\n        for (int j = 0; j < 4; ++j) {\n            if (temp[j] > 0.0f) {\n                result.push_back(temp[j]);\n            }\n        }\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        if (l[i] > 0.0f) {\n            result.push_back(l[i]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_76_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64x2_t vec_n = vdupq_n_s64(n);\n    int64x2_t vec_zero = vdupq_n_s64(0);\n    int64x2_t vec_mod;\n\n    int64_t limit = sqrt(n);\n    for (int64_t i = 5; i <= limit; i += 6) {\n        int64x2_t vec_i = vld1q_s64((int64_t[]){i, i + 2});\n        vec_mod = vmodq_s64(vec_n, vec_i);\n\n        uint64x2_t cmp = vceqq_s64(vec_mod, vec_zero);\n        if (vgetq_lane_u64(cmp, 0) || vgetq_lane_u64(cmp, 1)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t limit = sqrt(n);\n    int64x2_t vec_n = vdupq_n_s64(n);\n    int64x2_t vec_zero = vdupq_n_s64(0);\n\n    for (int64_t i = 5; i <= limit; i += 12) {\n        int64x2_t vec_i = vld1q_s64((int64_t[]){i, i + 6});\n        int64x2_t vec_mod = vqrdcq_s64(vec_n, vec_i);\n\n        if (vgetq_lane_s64(vec_mod, 0) == 0 || vgetq_lane_s64(vec_mod, 1) == 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64x2_t vec_n = vdupq_n_s64(n);\n    int64x2_t vec_zero = vdupq_n_s64(0);\n    int64x2_t vec_mod;\n\n    int64_t limit = sqrt(n);\n    for (int64_t i = 5; i <= limit; i += 12) {\n        int64x2_t vec_i = vld1q_s64((int64_t[]){i, i + 6});\n        vec_mod = vqrdcq_s64(vec_n, vec_i);\n        if (vgetq_lane_s64(vec_mod, 0) == 0 || vgetq_lane_s64(vec_mod, 1) == 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t limit = sqrt(n);\n    int64x2_t vec_n = vdupq_n_s64(n);\n    int64x2_t vec_zero = vdupq_n_s64(0);\n\n    for (int64_t i = 5; i <= limit; i += 12) {\n        int64x2_t vec_i = vld1q_s64((int64_t[]){i, i + 6});\n        int64x2_t vec_mod = vqrdcq_s64(vec_n, vec_i);\n\n        uint64x2_t cmp = vceqq_s64(vec_mod, vec_zero);\n        if (vgetq_lane_u64(cmp, 0) || vgetq_lane_u64(cmp, 1)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64x2_t vec_n = vdupq_n_s64(n);\n    int64x2_t vec_zero = vdupq_n_s64(0);\n    int64x2_t vec_mod;\n\n    int64_t limit = sqrt(n);\n    for (int64_t i = 5; i <= limit; i += 12) {\n        int64x2_t vec_i = {i, i + 6};\n        vec_mod = vqrdcq_s64(vec_n, vec_i);\n        vec_mod = vmulq_s64(vec_mod, vec_i);\n        vec_mod = vceqq_s64(vec_mod, vec_n);\n\n        if (vgetq_lane_s64(vec_mod, 0) || vgetq_lane_s64(vec_mod, 1)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_77_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s) {\n    int n = s.size();\n    std::string result = s;\n    bool hasLetters = false;\n\n    // Check if the string contains any letters\n    for (char c : s) {\n        if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {\n            hasLetters = true;\n            break;\n        }\n    }\n\n    if (!hasLetters) {\n        // Reverse the string if no letters are found\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n\n    int i = 0;\n    for (; i <= n - 16; i += 16) {\n        // Load 16 characters into a SIMD register\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n\n        // Create masks for lowercase and uppercase letters\n        uint8x16_t lower_mask = vcltq_u8(input, vdupq_n_u8('a'));\n        uint8x16_t upper_mask = vcgtq_u8(input, vdupq_n_u8('z'));\n        uint8x16_t letter_mask = vbicq_u8(lower_mask, upper_mask);\n\n        // Toggle case using XOR with space (' ')\n        uint8x16_t toggle = veorq_u8(input, vdupq_n_u8(' '));\n\n        // Select between original and toggled based on letter_mask\n        uint8x16_t output = vbslq_u8(letter_mask, toggle, input);\n\n        // Store the result back to memory\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), output);\n    }\n\n    // Process remaining characters\n    for (; i < n; ++i) {\n        char c = s[i];\n        if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {\n            result[i] ^= ' ';\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s) {\n    int n = s.size();\n    std::string result = s;\n    bool has_letter = false;\n\n    // Check if the string contains any letters\n    for (char c : s) {\n        if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {\n            has_letter = true;\n            break;\n        }\n    }\n\n    if (!has_letter) {\n        // Reverse the string if no letters are found\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n\n    int i = 0;\n    for (; i <= n - 16; i += 16) {\n        // Load 16 characters into a SIMD register\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n\n        // Create masks for lowercase and uppercase letters\n        uint8x16_t lower_mask = vcltq_u8(input, vdupq_n_u8('a'));\n        uint8x16_t upper_mask = vcgtq_u8(input, vdupq_n_u8('z'));\n        uint8x16_t letter_mask = vbicq_u8(lower_mask, upper_mask);\n\n        // Toggle case using XOR with space (0x20)\n        uint8x16_t toggled = veorq_u8(input, vdupq_n_u8(0x20));\n\n        // Blend original and toggled based on letter_mask\n        uint8x16_t output = vbslq_u8(letter_mask, toggled, input);\n\n        // Store the result back to memory\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), output);\n    }\n\n    // Process remaining characters\n    for (; i < n; ++i) {\n        char c = s[i];\n        if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {\n            result[i] ^= 0x20;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s) {\n    int n = s.size();\n    std::string result = s;\n    bool hasLetter = false;\n\n    // Check if the string contains any letters\n    for (char c : s) {\n        if (isalpha(c)) {\n            hasLetter = true;\n            break;\n        }\n    }\n\n    if (hasLetter) {\n        int i = 0;\n        // Process 16 characters at a time using NEON intrinsics\n        for (; i <= n - 16; i += 16) {\n            uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n\n            // Create masks for lowercase and uppercase letters\n            uint8x16_t lower_mask = vcltq_u8(input, vdupq_n_u8('a'));\n            uint8x16_t upper_mask = vcgtq_u8(input, vdupq_n_u8('z'));\n            uint8x16_t alpha_mask = vbicq_u8(lower_mask, upper_mask);\n\n            // Toggle case for alphabetic characters\n            uint8x16_t toggle = vandq_u8(alpha_mask, vdupq_n_u8(32));\n            uint8x16_t output = veorq_u8(input, toggle);\n\n            // Store the result back to the output string\n            vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), output);\n        }\n\n        // Process remaining characters\n        for (; i < n; ++i) {\n            if (isalpha(s[i])) {\n                result[i] ^= 32;\n            }\n        }\n    } else {\n        // Reverse the string if no letters are present\n        std::reverse(result.begin(), result.end());\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s) {\n    int n = s.size();\n    std::string result = s;\n    bool has_letter = false;\n\n    // Check if the string contains any letters\n    for (int i = 0; i < n; ++i) {\n        if ((s[i] >= 'a' && s[i] <= 'z') || (s[i] >= 'A' && s[i] <= 'Z')) {\n            has_letter = true;\n            break;\n        }\n    }\n\n    if (!has_letter) {\n        // Reverse the string if no letters are found\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n\n    int i = 0;\n    // Process 16 characters at a time using NEON intrinsics\n    for (; i <= n - 16; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n\n        // Create masks for lowercase and uppercase letters\n        uint8x16_t lower_mask = vcltq_u8(input, vdupq_n_u8('a'));\n        uint8x16_t upper_mask = vcgtq_u8(input, vdupq_n_u8('z'));\n        uint8x16_t letter_mask = vbicq_u8(lower_mask, upper_mask);\n\n        // Toggle case for letters\n        uint8x16_t toggle_case = vandq_u8(letter_mask, vdupq_n_u8(32));\n        uint8x16_t toggled = veorq_u8(input, toggle_case);\n\n        // Store the result back\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), toggled);\n    }\n\n    // Process remaining characters\n    for (; i < n; ++i) {\n        if ((s[i] >= 'a' && s[i] <= 'z') || (s[i] >= 'A' && s[i] <= 'Z')) {\n            result[i] ^= 32;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s) {\n    int len = s.size();\n    std::string result = s;\n    bool hasLetter = false;\n\n    // Check if the string contains any letters\n    for (int i = 0; i < len; ++i) {\n        if ((s[i] >= 'a' && s[i] <= 'z') || (s[i] >= 'A' && s[i] <= 'Z')) {\n            hasLetter = true;\n            break;\n        }\n    }\n\n    if (!hasLetter) {\n        // Reverse the string if no letters are found\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n\n    int i = 0;\n    // Process 16 characters at a time using NEON intrinsics\n    for (; i <= len - 16; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n\n        // Create masks for lowercase and uppercase letters\n        uint8x16_t lower_mask = vandq_u8(vcgeq_u8(input, vdupq_n_u8('a')), vcleq_u8(input, vdupq_n_u8('z')));\n        uint8x16_t upper_mask = vandq_u8(vcgeq_u8(input, vdupq_n_u8('A')), vcleq_u8(input, vdupq_n_u8('Z')));\n\n        // Toggle case for letters\n        uint8x16_t toggle = vbslq_u8(vorrq_u8(lower_mask, upper_mask), veorq_u8(input, vdupq_n_u8(32)), input);\n\n        // Store the result back to the output string\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), toggle);\n    }\n\n    // Process remaining characters\n    for (; i < len; ++i) {\n        if (s[i] >= 'a' && s[i] <= 'z') {\n            result[i] = s[i] - 32;\n        } else if (s[i] >= 'A' && s[i] <= 'Z') {\n            result[i] = s[i] + 32;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    int n = l.size();\n    std::vector<int> result = l;\n\n    // Extract elements at indices divisible by 3\n    std::vector<int> third_elements;\n    for (int i = 0; i < n; i += 3) {\n        third_elements.push_back(l[i]);\n    }\n\n    // Sort the extracted elements\n    std::sort(third_elements.begin(), third_elements.end());\n\n    // Replace the original indices divisible by 3 with sorted values\n    int k = 0;\n    for (int i = 0; i < n; i += 3) {\n        result[i] = third_elements[k++];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    int n = l.size();\n    std::vector<int> result = l;\n\n    // Extract elements at indices divisible by 3\n    std::vector<int> divisible_by_three;\n    for (int i = 0; i < n; i += 3) {\n        divisible_by_three.push_back(l[i]);\n    }\n\n    // Sort the extracted elements\n    std::sort(divisible_by_three.begin(), divisible_by_three.end());\n\n    // Replace the original indices divisible by 3 with sorted values\n    int idx = 0;\n    for (int i = 0; i < n; i += 3) {\n        result[i] = divisible_by_three[idx++];\n    }\n\n    // Use NEON intrinsics to process the vector in parallel\n    for (int i = 0; i <= n - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&l[i]);\n        int32x4_t res = vld1q_s32(&result[i]);\n\n        // Mask to identify indices divisible by 3\n        uint32x4_t mask = {i % 3 == 0, (i + 1) % 3 == 0, (i + 2) % 3 == 0, (i + 3) % 3 == 0};\n        uint32x4_t mask_neon = vmovq_n_u32(0xFFFFFFFF);\n        mask_neon = vandq_u32(mask_neon, mask);\n\n        // Blend original and sorted values based on the mask\n        res = vbslq_s32(mask_neon, res, vec);\n\n        // Store the result back\n        vst1q_s32(&result[i], res);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    int n = l.size();\n    std::vector<int> result = l;\n\n    // Extract elements at indices divisible by 3\n    std::vector<int> divisible_by_three;\n    for (int i = 0; i < n; i += 3) {\n        divisible_by_three.push_back(l[i]);\n    }\n\n    // Sort the extracted elements\n    std::sort(divisible_by_three.begin(), divisible_by_three.end());\n\n    // Replace the original indices divisible by 3 with sorted values\n    int j = 0;\n    for (int i = 0; i < n; i += 3) {\n        result[i] = divisible_by_three[j++];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    int n = l.size();\n    std::vector<int> result = l;\n\n    // Extract elements at indices divisible by 3\n    std::vector<int> third_elements;\n    for (int i = 0; i < n; i += 3) {\n        third_elements.push_back(l[i]);\n    }\n\n    // Sort the extracted elements\n    std::sort(third_elements.begin(), third_elements.end());\n\n    // Replace the original indices divisible by 3 with sorted values\n    int j = 0;\n    for (int i = 0; i < n; i += 3) {\n        result[i] = third_elements[j++];\n    }\n\n    // Use Neon intrinsics to process the vector in parallel\n    for (int i = 0; i <= n - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&l[i]);\n        int32x4_t res = vld1q_s32(&result[i]);\n\n        // Mask to identify indices divisible by 3\n        uint32x4_t mask = vmovq_n_u32(0xFFFFFFFF);\n        mask = vbicq_u32(mask, vdupq_n_u32(3)); // Clear bits not divisible by 3\n\n        // Blend original and sorted values based on mask\n        res = vbslq_s32(vreinterpretq_s32_u32(mask), res, vec);\n\n        // Store the result back\n        vst1q_s32(&result[i], res);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    int n = l.size();\n    std::vector<int> result = l;\n\n    // Extract elements at indices divisible by 3\n    std::vector<int> divisible_by_three;\n    for (int i = 0; i < n; i += 3) {\n        divisible_by_three.push_back(l[i]);\n    }\n\n    // Sort the extracted elements\n    std::sort(divisible_by_three.begin(), divisible_by_three.end());\n\n    // Replace the original indices divisible by 3 with sorted values\n    int j = 0;\n    for (int i = 0; i < n; i += 3) {\n        result[i] = divisible_by_three[j++];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_79_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nfloat max_element_simd(std::vector<float> l) {\n    int size = l.size();\n    float max_val = l[0];\n    int i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= size - 4; i += 4) {\n        // Load 4 floats into a NEON register\n        float32x4_t vec = vld1q_f32(&l[i]);\n\n        // Compute the maximum of the 4 floats in the register\n        float32x2_t max_pair = vmax_f32(vget_low_f32(vec), vget_high_f32(vec));\n        float32x2_t max_single = vpmax_f32(max_pair, max_pair);\n\n        // Extract the maximum value from the NEON register\n        max_val = std::max(max_val, vget_lane_f32(max_single, 0));\n    }\n\n    // Process any remaining elements\n    for (; i < size; ++i) {\n        max_val = std::max(max_val, l[i]);\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nfloat max_element_simd(std::vector<float> l) {\n    int size = l.size();\n    float max_val = l[0];\n    int i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= size - 4; i += 4) {\n        // Load 4 floats into a NEON register\n        float32x4_t vec = vld1q_f32(&l[i]);\n\n        // Compute the maximum of the 4 floats in the register\n        float32x2_t max_pair = vmax_f32(vget_low_f32(vec), vget_high_f32(vec));\n        float32x2_t max_single = vpmax_f32(max_pair, max_pair);\n\n        // Extract the maximum value from the NEON register\n        max_val = std::max(max_val, vget_lane_f32(max_single, 0));\n    }\n\n    // Process any remaining elements\n    for (; i < size; ++i) {\n        max_val = std::max(max_val, l[i]);\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <algorithm>\n\nfloat max_element_simd(std::vector<float> l) {\n    int size = l.size();\n    float max_val = l[0];\n    int i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= size - 4; i += 4) {\n        // Load 4 floats into a NEON register\n        float32x4_t vec = vld1q_f32(&l[i]);\n\n        // Compute the maximum of the 4 elements in the vector\n        float32x2_t max_pairs = vmax_f32(vget_low_f32(vec), vget_high_f32(vec));\n        float32x2_t max_single = vpmax_f32(max_pairs, max_pairs);\n\n        // Extract the maximum value from the NEON register\n        max_val = std::max(max_val, vget_lane_f32(max_single, 0));\n    }\n\n    // Process any remaining elements\n    for (; i < size; ++i) {\n        max_val = std::max(max_val, l[i]);\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nfloat max_element_simd(std::vector<float> l) {\n    int n = l.size();\n    float max_val = l[0];\n    int i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= n - 4; i += 4) {\n        // Load 4 floats into a NEON register\n        float32x4_t vec = vld1q_f32(&l[i]);\n\n        // Compute the maximum of the 4 elements in the register\n        float32x2_t max_pair = vmax_f32(vget_low_f32(vec), vget_high_f32(vec));\n        float32x2_t max_single = vpmax_f32(max_pair, max_pair);\n\n        // Extract the maximum value from the NEON register\n        max_val = std::max(max_val, vget_lane_f32(max_single, 0));\n    }\n\n    // Process any remaining elements\n    for (; i < n; ++i) {\n        max_val = std::max(max_val, l[i]);\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nfloat max_element_simd(std::vector<float> l) {\n    int n = l.size();\n    float max_val = l[0];\n    int i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= n - 4; i += 4) {\n        // Load 4 floats into a NEON register\n        float32x4_t vec = vld1q_f32(&l[i]);\n\n        // Compute the maximum of the 4 elements in the register\n        float32x2_t max_paired = vmax_f32(vget_low_f32(vec), vget_high_f32(vec));\n        float32x2_t max_single = vpmax_f32(max_paired, max_paired);\n\n        // Extract the maximum value from the NEON register\n        max_val = std::max(max_val, vget_lane_f32(max_single, 0));\n    }\n\n    // Process any remaining elements\n    for (; i < n; ++i) {\n        max_val = std::max(max_val, l[i]);\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_80_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    int i = 0;\n\n    // Process 8 integers at a time using NEON intrinsics\n    for (; i <= n - 8; i += 8) {\n        // Load 8 integers into a vector\n        int32x4_t vec1 = vld1q_s32(&i);\n        int32x4_t vec2 = vld1q_s32(&i + 4);\n\n        // Increment the second vector by 4 to handle consecutive values\n        vec2 = vaddq_s32(vec2, vdupq_n_s32(4));\n\n        // Check divisibility by 11\n        uint32x4_t div11_1 = vceqq_s32(vreinterpretq_s32_u32(vmodq_s32(vec1, vdupq_n_s32(11))), vdupq_n_s32(0));\n        uint32x4_t div11_2 = vceqq_s32(vreinterpretq_s32_u32(vmodq_s32(vec2, vdupq_n_s32(11))), vdupq_n_s32(0));\n\n        // Check divisibility by 13\n        uint32x4_t div13_1 = vceqq_s32(vreinterpretq_s32_u32(vmodq_s32(vec1, vdupq_n_s32(13))), vdupq_n_s32(0));\n        uint32x4_t div13_2 = vceqq_s32(vreinterpretq_s32_u32(vmodq_s32(vec2, vdupq_n_s32(13))), vdupq_n_s32(0));\n\n        // Combine divisibility checks (OR condition)\n        uint32x4_t divisible_1 = vorrq_u32(div11_1, div13_1);\n        uint32x4_t divisible_2 = vorrq_u32(div11_2, div13_2);\n\n        // Convert numbers to strings and count '7's\n        for (int j = 0; j < 4; ++j) {\n            if (divisible_1[j]) {\n                int num = i + j;\n                while (num > 0) {\n                    if (num % 10 == 7) count++;\n                    num /= 10;\n                }\n            }\n        }\n\n        for (int j = 0; j < 4; ++j) {\n            if (divisible_2[j]) {\n                int num = i + 4 + j;\n                while (num > 0) {\n                    if (num % 10 == 7) count++;\n                    num /= 10;\n                }\n            }\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int num = i;\n            while (num > 0) {\n                if (num % 10 == 7) count++;\n                num /= 10;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    int i = 0;\n\n    // Process in chunks of 16 integers using NEON\n    for (; i <= n - 16; i += 16) {\n        // Load 16 integers into a vector\n        int32x4_t vec0 = vld1q_s32(&i);\n        int32x4_t vec1 = vld1q_s32(&i + 4);\n        int32x4_t vec2 = vld1q_s32(&i + 8);\n        int32x4_t vec3 = vld1q_s32(&i + 12);\n\n        // Increment vectors to represent [i, i+15]\n        vec0 = vaddq_s32(vec0, vdupq_n_s32(0));\n        vec1 = vaddq_s32(vec1, vdupq_n_s32(4));\n        vec2 = vaddq_s32(vec2, vdupq_n_s32(8));\n        vec3 = vaddq_s32(vec3, vdupq_n_s32(12));\n\n        // Check divisibility by 11\n        uint32x4_t div11_0 = vceqq_s32(vreinterpretq_s32_u32(vmodq_s32(vec0, vdupq_n_s32(11))), vdupq_n_s32(0));\n        uint32x4_t div11_1 = vceqq_s32(vreinterpretq_s32_u32(vmodq_s32(vec1, vdupq_n_s32(11))), vdupq_n_s32(0));\n        uint32x4_t div11_2 = vceqq_s32(vreinterpretq_s32_u32(vmodq_s32(vec2, vdupq_n_s32(11))), vdupq_n_s32(0));\n        uint32x4_t div11_3 = vceqq_s32(vreinterpretq_s32_u32(vmodq_s32(vec3, vdupq_n_s32(11))), vdupq_n_s32(0));\n\n        // Check divisibility by 13\n        uint32x4_t div13_0 = vceqq_s32(vreinterpretq_s32_u32(vmodq_s32(vec0, vdupq_n_s32(13))), vdupq_n_s32(0));\n        uint32x4_t div13_1 = vceqq_s32(vreinterpretq_s32_u32(vmodq_s32(vec1, vdupq_n_s32(13))), vdupq_n_s32(0));\n        uint32x4_t div13_2 = vceqq_s32(vreinterpretq_s32_u32(vmodq_s32(vec2, vdupq_n_s32(13))), vdupq_n_s32(0));\n        uint32x4_t div13_3 = vceqq_s32(vreinterpretq_s32_u32(vmodq_s32(vec3, vdupq_n_s32(13))), vdupq_n_s32(0));\n\n        // Combine conditions (divisible by 11 or 13)\n        uint32x4_t cond0 = vorrq_u32(div11_0, div13_0);\n        uint32x4_t cond1 = vorrq_u32(div11_1, div13_1);\n        uint32x4_t cond2 = vorrq_u32(div11_2, div13_2);\n        uint32x4_t cond3 = vorrq_u32(div11_3, div13_3);\n\n        // Extract digits and check for '7'\n        for (int j = 0; j < 4; ++j) {\n            if (cond0[j]) {\n                int num = vec0[j];\n                while (num > 0) {\n                    if (num % 10 == 7) {\n                        count++;\n                    }\n                    num /= 10;\n                }\n            }\n        }\n        for (int j = 0; j < 4; ++j) {\n            if (cond1[j]) {\n                int num = vec1[j];\n                while (num > 0) {\n                    if (num % 10 == 7) {\n                        count++;\n                    }\n                    num /= 10;\n                }\n            }\n        }\n        for (int j = 0; j < 4; ++j) {\n            if (cond2[j]) {\n                int num = vec2[j];\n                while (num > 0) {\n                    if (num % 10 == 7) {\n                        count++;\n                    }\n                    num /= 10;\n                }\n            }\n        }\n        for (int j = 0; j < 4; ++j) {\n            if (cond3[j]) {\n                int num = vec3[j];\n                while (num > 0) {\n                    if (num % 10 == 7) {\n                        count++;\n                    }\n                    num /= 10;\n                }\n            }\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int num = i;\n            while (num > 0) {\n                if (num % 10 == 7) {\n                    count++;\n                }\n                num /= 10;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    int i = 0;\n\n    // Process 8 integers at a time using NEON intrinsics\n    for (; i <= n - 8; i += 8) {\n        // Load 8 integers into a vector\n        int32x4_t vec_low = vld1q_s32(&i);\n        int32x4_t vec_high = vld1q_s32(&i + 4);\n\n        // Increment the vector to represent [i, i+1, ..., i+7]\n        int32x4_t inc_low = vaddq_s32(vec_low, vdupq_n_s32(0));\n        int32x4_t inc_high = vaddq_s32(vec_high, vdupq_n_s32(4));\n\n        // Check divisibility by 11\n        uint32x4_t div11_low = vceqq_s32(vmodq_s32(inc_low, vdupq_n_s32(11)), vdupq_n_s32(0));\n        uint32x4_t div11_high = vceqq_s32(vmodq_s32(inc_high, vdupq_n_s32(11)), vdupq_n_s32(0));\n\n        // Check divisibility by 13\n        uint32x4_t div13_low = vceqq_s32(vmodq_s32(inc_low, vdupq_n_s32(13)), vdupq_n_s32(0));\n        uint32x4_t div13_high = vceqq_s32(vmodq_s32(inc_high, vdupq_n_s32(13)), vdupq_n_s32(0));\n\n        // Combine divisibility checks (OR operation)\n        uint32x4_t div_low = vorrq_u32(div11_low, div13_low);\n        uint32x4_t div_high = vorrq_u32(div11_high, div13_high);\n\n        // Convert integers to strings and count '7's\n        for (int j = 0; j < 4; ++j) {\n            if (div_low[j]) {\n                int num = i + j;\n                while (num > 0) {\n                    if (num % 10 == 7) {\n                        count++;\n                    }\n                    num /= 10;\n                }\n            }\n            if (div_high[j]) {\n                int num = i + j + 4;\n                while (num > 0) {\n                    if (num % 10 == 7) {\n                        count++;\n                    }\n                    num /= 10;\n                }\n            }\n        }\n    }\n\n    // Process remaining integers\n    for (; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int num = i;\n            while (num > 0) {\n                if (num % 10 == 7) {\n                    count++;\n                }\n                num /= 10;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    int i = 0;\n\n    // Process in chunks of 4 integers using NEON intrinsics\n    for (; i <= n - 4; i += 4) {\n        // Load 4 integers into a vector\n        int32x4_t vec = vld1q_s32(&i);\n\n        // Create mask for divisibility by 11 and 13\n        uint32x4_t div_by_11 = vceqq_s32(vreinterpretq_s32_u32(vmodq_s32(vec, vdupq_n_s32(11))), vdupq_n_s32(0));\n        uint32x4_t div_by_13 = vceqq_s32(vreinterpretq_s32_u32(vmodq_s32(vec, vdupq_n_s32(13))), vdupq_n_s32(0));\n\n        // Combine masks (OR operation)\n        uint32x4_t mask = vorrq_u32(div_by_11, div_by_13);\n\n        // Extract individual elements from the mask\n        uint32_t mask_array[4];\n        vst1q_u32(mask_array, mask);\n\n        // Check each element in the mask\n        for (int j = 0; j < 4; ++j) {\n            if (mask_array[j]) {\n                int num = i + j;\n                if (num < n) {\n                    // Count occurrences of digit '7' in the number\n                    int temp = num;\n                    while (temp > 0) {\n                        if (temp % 10 == 7) {\n                            count++;\n                        }\n                        temp /= 10;\n                    }\n                }\n            }\n        }\n    }\n\n    // Process remaining elements\n    for (; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int temp = i;\n            while (temp > 0) {\n                if (temp % 10 == 7) {\n                    count++;\n                }\n                temp /= 10;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    int i = 0;\n\n    // Process in chunks of 16 integers using NEON\n    for (; i <= n - 16; i += 16) {\n        // Load 16 integers into a vector\n        int32x4_t vec0 = vld1q_s32(&i);\n        int32x4_t vec1 = vld1q_s32(&i + 4);\n        int32x4_t vec2 = vld1q_s32(&i + 8);\n        int32x4_t vec3 = vld1q_s32(&i + 12);\n\n        // Increment vectors to represent [i, i+15]\n        vec0 = vaddq_s32(vec0, vdupq_n_s32(0));\n        vec1 = vaddq_s32(vec1, vdupq_n_s32(4));\n        vec2 = vaddq_s32(vec2, vdupq_n_s32(8));\n        vec3 = vaddq_s32(vec3, vdupq_n_s32(12));\n\n        // Check divisibility by 11 and 13\n        uint32x4_t div11_0 = vceqq_s32(vreinterpretq_s32_u32(vmodq_s32(vec0, vdupq_n_s32(11))), vdupq_n_s32(0));\n        uint32x4_t div11_1 = vceqq_s32(vreinterpretq_s32_u32(vmodq_s32(vec1, vdupq_n_s32(11))), vdupq_n_s32(0));\n        uint32x4_t div11_2 = vceqq_s32(vreinterpretq_s32_u32(vmodq_s32(vec2, vdupq_n_s32(11))), vdupq_n_s32(0));\n        uint32x4_t div11_3 = vceqq_s32(vreinterpretq_s32_u32(vmodq_s32(vec3, vdupq_n_s32(11))), vdupq_n_s32(0));\n\n        uint32x4_t div13_0 = vceqq_s32(vreinterpretq_s32_u32(vmodq_s32(vec0, vdupq_n_s32(13))), vdupq_n_s32(0));\n        uint32x4_t div13_1 = vceqq_s32(vreinterpretq_s32_u32(vmodq_s32(vec1, vdupq_n_s32(13))), vdupq_n_s32(0));\n        uint32x4_t div13_2 = vceqq_s32(vreinterpretq_s32_u32(vmodq_s32(vec2, vdupq_n_s32(13))), vdupq_n_s32(0));\n        uint32x4_t div13_3 = vceqq_s32(vreinterpretq_s32_u32(vmodq_s32(vec3, vdupq_n_s32(13))), vdupq_n_s32(0));\n\n        // Combine divisibility conditions\n        uint32x4_t div_cond_0 = vorrq_u32(div11_0, div13_0);\n        uint32x4_t div_cond_1 = vorrq_u32(div11_1, div13_1);\n        uint32x4_t div_cond_2 = vorrq_u32(div11_2, div13_2);\n        uint32x4_t div_cond_3 = vorrq_u32(div11_3, div13_3);\n\n        // Convert numbers to strings and count '7's (scalar fallback for simplicity)\n        for (int j = 0; j < 16; ++j) {\n            if (i + j < n && (div_cond_0[j] || div_cond_1[j] || div_cond_2[j] || div_cond_3[j])) {\n                int num = i + j;\n                while (num > 0) {\n                    if (num % 10 == 7) {\n                        ++count;\n                    }\n                    num /= 10;\n                }\n            }\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int num = i;\n            while (num > 0) {\n                if (num % 10 == 7) {\n                    ++count;\n                }\n                num /= 10;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_81_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    int n = l.size();\n    std::vector<float> even_elements;\n    \n    // Extract even-indexed elements\n    for (int i = 0; i < n; i += 2) {\n        even_elements.push_back(l[i]);\n    }\n    \n    // Sort the even-indexed elements\n    std::sort(even_elements.begin(), even_elements.end());\n    \n    // Use NEON intrinsics to merge sorted even elements back into the original vector\n    int even_idx = 0;\n    for (int i = 0; i < n; i += 4) {\n        float32x4_t vec = vld1q_f32(&l[i]);\n        \n        if (i + 0 < n && (i + 0) % 2 == 0) {\n            vec = vsetq_lane_f32(even_elements[even_idx++], vec, 0);\n        }\n        if (i + 2 < n && (i + 2) % 2 == 0) {\n            vec = vsetq_lane_f32(even_elements[even_idx++], vec, 2);\n        }\n        \n        vst1q_f32(&l[i], vec);\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_81_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    int n = l.size();\n    std::vector<float> even_values;\n    \n    // Extract even index values\n    for (int i = 0; i < n; i += 2) {\n        even_values.push_back(l[i]);\n    }\n    \n    // Sort the even index values\n    std::sort(even_values.begin(), even_values.end());\n    \n    // Use NEON to interleave sorted even values and odd values\n    int even_idx = 0;\n    for (int i = 0; i < n; i += 4) {\n        float32x4_t even_vec, odd_vec, result_vec;\n        \n        // Load even values (sorted)\n        if (even_idx + 2 <= even_values.size()) {\n            even_vec = vld1q_f32(&even_values[even_idx]);\n            even_idx += 2;\n        } else {\n            even_vec = vdupq_n_f32(0.0f); // Pad with zeros if insufficient values\n        }\n        \n        // Load odd values (unchanged)\n        if (i + 1 < n && i + 3 < n) {\n            odd_vec = vld1q_f32(&l[i + 1]);\n        } else {\n            odd_vec = vdupq_n_f32(0.0f); // Pad with zeros if insufficient values\n        }\n        \n        // Interleave even and odd values\n        float32x4x2_t interleaved = vzipq_f32(even_vec, odd_vec);\n        result_vec = interleaved.val[0]; // Combine into a single vector\n        \n        // Store the result back into the vector\n        if (i + 4 <= n) {\n            vst1q_f32(&l[i], result_vec);\n        } else {\n            for (int j = 0; j < n - i; ++j) {\n                l[i + j] = ((float*)&result_vec)[j];\n            }\n        }\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_81_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    int n = l.size();\n    std::vector<float> even_values;\n    \n    // Extract even index values\n    for (int i = 0; i < n; i += 2) {\n        even_values.push_back(l[i]);\n    }\n    \n    // Sort the even index values\n    std::sort(even_values.begin(), even_values.end());\n    \n    // Use NEON to interleave sorted even values and odd values\n    int even_idx = 0;\n    for (int i = 0; i < n; i += 4) {\n        float32x4_t even_vec, odd_vec, result;\n        \n        // Load even values (sorted)\n        if (even_idx + 2 <= even_values.size()) {\n            even_vec = vld1q_f32(&even_values[even_idx]);\n            even_idx += 2;\n        } else {\n            even_vec = vdupq_n_f32(0.0f); // Pad with zeros if insufficient values\n        }\n        \n        // Load odd values (unchanged)\n        if (i + 1 < n && i + 3 < n) {\n            odd_vec = vld1q_f32(&l[i + 1]);\n        } else {\n            odd_vec = vdupq_n_f32(0.0f); // Pad with zeros if insufficient values\n        }\n        \n        // Interleave even and odd values\n        float32x4x2_t interleaved = vzipq_f32(even_vec, odd_vec);\n        result = interleaved.val[0]; // Combine into a single vector\n        \n        // Store the result back into the vector\n        if (i + 3 < n) {\n            vst1q_f32(&l[i], result);\n        }\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_81_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    int n = l.size();\n    std::vector<float> even_elements;\n\n    // Extract even-indexed elements\n    for (int i = 0; i < n; i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    // Sort the even-indexed elements\n    std::sort(even_elements.begin(), even_elements.end());\n\n    // Replace the even-indexed positions in the original vector with sorted values\n    int even_idx = 0;\n    for (int i = 0; i < n; i += 2) {\n        l[i] = even_elements[even_idx++];\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_81_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    int n = l.size();\n    std::vector<float> even_values;\n    \n    // Extract even index values\n    for (int i = 0; i < n; i += 2) {\n        even_values.push_back(l[i]);\n    }\n    \n    // Sort the even index values\n    std::sort(even_values.begin(), even_values.end());\n    \n    // Use NEON to interleave sorted even values and odd values\n    int even_idx = 0;\n    for (int i = 0; i < n; i += 4) {\n        float32x4_t even_vec, odd_vec, result;\n        \n        // Load even values (sorted)\n        if (even_idx + 2 <= even_values.size()) {\n            even_vec = vld1q_f32(&even_values[even_idx]);\n            even_idx += 2;\n        } else {\n            even_vec = vdupq_n_f32(0.0f); // Padding with zeros if necessary\n        }\n        \n        // Load odd values (unchanged)\n        if (i + 1 < n && i + 3 < n) {\n            odd_vec = vld1q_f32(&l[i + 1]);\n        } else {\n            odd_vec = vdupq_n_f32(0.0f); // Padding with zeros if necessary\n        }\n        \n        // Interleave even and odd values\n        float32x4x2_t interleaved = vzipq_f32(even_vec, odd_vec);\n        result = interleaved.val[0]; // Combine into a single vector\n        \n        // Store the result back into the vector\n        if (i + 3 < n) {\n            vst1q_f32(&l[i], result);\n        }\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_82_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    for (int i = 0; i < n - 2; ++i) {\n        for (int j = i + 1; j < n - 1; ++j) {\n            int16x8_t vi = vdupq_n_s16(l[i]);\n            int16x8_t vj = vdupq_n_s16(l[j]);\n\n            for (int k = j + 1; k < n; k += 8) {\n                int16x8_t vk = vld1q_s16(&l[k]);\n\n                int16x8_t sum = vaddq_s16(vi, vj);\n                sum = vaddq_s16(sum, vk);\n\n                uint16x8_t mask = vceqq_s16(sum, vdupq_n_s16(0));\n                if (vmaxvq_u16(mask)) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    for (int i = 0; i < n - 2; ++i) {\n        for (int j = i + 1; j < n - 1; ++j) {\n            int16x8_t vi = vdupq_n_s16(l[i]);\n            int16x8_t vj = vdupq_n_s16(l[j]);\n\n            for (int k = j + 1; k < n; k += 8) {\n                int16x8_t vk = vld1q_s16(&l[k]);\n\n                int16x8_t sum = vaddq_s16(vi, vj);\n                sum = vaddq_s16(sum, vk);\n\n                uint16x8_t mask = vceqq_s16(sum, vdupq_n_s16(0));\n                if (vmaxvq_u16(mask)) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    for (int i = 0; i < n - 2; ++i) {\n        for (int j = i + 1; j < n - 1; ++j) {\n            int target = -(l[i] + l[j]);\n            int k = j + 1;\n\n            // Process 4 elements at a time using NEON intrinsics\n            for (; k <= n - 4; k += 4) {\n                // Load 4 elements from the vector into a NEON register\n                int32x4_t vec = vld1q_s32(&l[k]);\n\n                // Create a vector with all elements set to the target value\n                int32x4_t target_vec = vdupq_n_s32(target);\n\n                // Compare each element in vec with target_vec\n                uint32x4_t cmp_result = vceqq_s32(vec, target_vec);\n\n                // Check if any of the comparisons resulted in true\n                if (vmaxvq_u32(cmp_result)) {\n                    return true;\n                }\n            }\n\n            // Process remaining elements\n            for (; k < n; ++k) {\n                if (l[k] == target) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    for (int i = 0; i < n - 2; ++i) {\n        for (int j = i + 1; j < n - 1; ++j) {\n            int16x8_t vi = vdupq_n_s16(l[i]);\n            int16x8_t vj = vdupq_n_s16(l[j]);\n\n            for (int k = j + 1; k < n; k += 8) {\n                int16x8_t vk = vld1q_s16(&l[k]);\n\n                int16x8_t sum = vaddq_s16(vi, vj);\n                sum = vaddq_s16(sum, vk);\n\n                uint16x8_t mask = vceqq_s16(sum, vdupq_n_s16(0));\n                if (vmaxvq_u16(mask) != 0) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    for (int i = 0; i < n - 2; ++i) {\n        for (int j = i + 1; j < n - 1; ++j) {\n            int target = -(l[i] + l[j]);\n            int k = j + 1;\n\n            // Process 4 elements at a time using NEON\n            for (; k <= n - 4; k += 4) {\n                int32x4_t vec = vld1q_s32(&l[k]);\n                int32x4_t target_vec = vdupq_n_s32(target);\n                uint32x4_t cmp = vceqq_s32(vec, target_vec);\n\n                if (vmaxvq_u32(cmp)) {\n                    return true;\n                }\n            }\n\n            // Process remaining elements\n            for (; k < n; ++k) {\n                if (l[k] == target) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_83_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    int n = l.size();\n    std::vector<int> result(n);\n    \n    int i = 0;\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= n - 4; i += 4) {\n        // Load 4 integers into a NEON register\n        int32x4_t vec = vld1q_s32(&l[i]);\n        \n        // Increment the vector by 1\n        int32x4_t inc = vdupq_n_s32(1);\n        vec = vaddq_s32(vec, inc);\n        \n        // Store the result back to memory\n        vst1q_s32(&result[i], vec);\n    }\n    \n    // Process remaining elements (if any)\n    for (; i < n; ++i) {\n        result[i] = l[i] + 1;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_83_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    int n = l.size();\n    std::vector<int> result(n);\n    int i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= n - 4; i += 4) {\n        // Load 4 integers into a NEON register\n        int32x4_t vec = vld1q_s32(&l[i]);\n\n        // Add 1 to each element in the vector\n        int32x4_t incr_vec = vaddq_s32(vec, vdupq_n_s32(1));\n\n        // Store the result back to memory\n        vst1q_s32(&result[i], incr_vec);\n    }\n\n    // Process remaining elements (if any)\n    for (; i < n; ++i) {\n        result[i] = l[i] + 1;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    int n = l.size();\n    std::vector<int> result(n);\n    \n    int i = 0;\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= n - 4; i += 4) {\n        // Load 4 integers into a NEON register\n        int32x4_t vec = vld1q_s32(&l[i]);\n        // Add 1 to each element in the vector\n        vec = vaddq_s32(vec, vdupq_n_s32(1));\n        // Store the result back to memory\n        vst1q_s32(&result[i], vec);\n    }\n    \n    // Process remaining elements (if any)\n    for (; i < n; ++i) {\n        result[i] = l[i] + 1;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_83_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    int n = l.size();\n    std::vector<int> result(n);\n    \n    int i = 0;\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= n - 4; i += 4) {\n        // Load 4 integers into a NEON register\n        int32x4_t vec = vld1q_s32(&l[i]);\n        \n        // Add 1 to each element in the vector\n        int32x4_t incr_vec = vaddq_s32(vec, vdupq_n_s32(1));\n        \n        // Store the result back to memory\n        vst1q_s32(&result[i], incr_vec);\n    }\n    \n    // Handle remaining elements that are less than 4\n    for (; i < n; ++i) {\n        result[i] = l[i] + 1;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_83_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    int n = l.size();\n    std::vector<int> result(n);\n    \n    int i = 0;\n    for (; i <= n - 4; i += 4) {\n        // Load 4 integers from the input vector into a Neon register\n        int32x4_t vec = vld1q_s32(&l[i]);\n        \n        // Create a vector with all elements set to 1\n        int32x4_t ones = vdupq_n_s32(1);\n        \n        // Add 1 to each element in the vector\n        int32x4_t incremented = vaddq_s32(vec, ones);\n        \n        // Store the result back to the output vector\n        vst1q_s32(&result[i], incremented);\n    }\n    \n    // Handle remaining elements that are not a multiple of 4\n    for (; i < n; ++i) {\n        result[i] = l[i] + 1;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_84_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 2) return false;\n\n    // Ensure the vector size is a multiple of 4 for SIMD processing\n    int simd_size = (n / 4) * 4;\n    float32x4_t zero_vec = vdupq_n_f32(0.0f);\n\n    for (int i = 0; i < simd_size; i += 4) {\n        float32x4_t vi = vcvtq_f32_s32(vld1q_s32(&l[i]));\n\n        for (int j = i + 4; j < simd_size; j += 4) {\n            float32x4_t vj = vcvtq_f32_s32(vld1q_s32(&l[j]));\n            float32x4_t sum1 = vaddq_f32(vi, vj);\n            uint32x4_t mask1 = vceqq_f32(sum1, zero_vec);\n\n            if (vmaxvq_u32(mask1)) {\n                return true;\n            }\n        }\n\n        // Handle remaining elements in the inner loop\n        for (int j = simd_size; j < n; ++j) {\n            int32x4_t vj = vdupq_n_s32(l[j]);\n            int32x4_t sum = vaddq_s32(vld1q_s32(&l[i]), vj);\n            uint32x4_t mask = vceqq_s32(sum, vdupq_n_s32(0));\n\n            if (vmaxvq_u32(mask)) {\n                return true;\n            }\n        }\n    }\n\n    // Handle remaining elements in the outer loop\n    for (int i = simd_size; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (l[i] + l[j] == 0) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 2) return false;\n\n    // Ensure the vector size is a multiple of 4 for SIMD processing\n    int simd_size = (n / 4) * 4;\n    float32x4_t zero_vec = vdupq_n_f32(0.0f);\n\n    for (int i = 0; i < simd_size; i += 4) {\n        float32x4_t vi = vcvtq_f32_s32(vld1q_s32(&l[i]));\n\n        for (int j = i + 4; j < simd_size; j += 4) {\n            float32x4_t vj = vcvtq_f32_s32(vld1q_s32(&l[j]));\n            float32x4_t sum1 = vaddq_f32(vi, vj);\n            uint32x4_t mask1 = vceqq_f32(sum1, zero_vec);\n\n            if (vmaxvq_u32(mask1)) {\n                return true;\n            }\n        }\n\n        // Handle remaining elements in the inner loop that are not a multiple of 4\n        for (int j = simd_size; j < n; ++j) {\n            float32_t sum = ((float)l[i]) + ((float)l[j]);\n            if (sum == 0.0f) {\n                return true;\n            }\n        }\n    }\n\n    // Handle remaining elements in the outer loop that are not a multiple of 4\n    for (int i = simd_size; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (l[i] + l[j] == 0) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 2) return false;\n\n    // Ensure the vector size is a multiple of 4 for SIMD processing\n    int simd_size = (n / 4) * 4;\n    int32x4_t zero_vec = vdupq_n_s32(0);\n\n    for (int i = 0; i < simd_size; i += 4) {\n        int32x4_t vec1 = vld1q_s32(&l[i]);\n\n        for (int j = 0; j < n; ++j) {\n            if (i <= j && j < i + 4) continue; // Avoid comparing within the same SIMD block\n\n            int32x4_t vec2 = vdupq_n_s32(l[j]);\n            int32x4_t sum = vaddq_s32(vec1, vec2);\n            uint32x4_t cmp = vceqq_s32(sum, zero_vec);\n\n            if (vmaxvq_u32(cmp)) {\n                return true;\n            }\n        }\n    }\n\n    // Handle remaining elements that don't fit into SIMD blocks\n    for (int i = simd_size; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (l[i] + l[j] == 0) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 2) return false;\n\n    // Ensure the vector size is a multiple of 4 for SIMD processing\n    int simd_size = (n / 4) * 4;\n    float32x4_t zero_vec = vdupq_n_f32(0.0f);\n\n    for (int i = 0; i < simd_size; i += 4) {\n        float32x4_t vec1 = vcvtq_f32_s32(vld1q_s32(&l[i]));\n\n        for (int j = i + 4; j < simd_size; j += 4) {\n            float32x4_t vec2 = vcvtq_f32_s32(vld1q_s32(&l[j]));\n            float32x4_t sum = vaddq_f32(vec1, vec2);\n            uint32x4_t mask = vceqq_f32(sum, zero_vec);\n            if (vmaxvq_u32(mask)) {\n                return true;\n            }\n        }\n    }\n\n    // Handle remaining elements that don't fit into SIMD registers\n    for (int i = simd_size; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (l[i] + l[j] == 0) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 2) return false;\n\n    // Ensure the vector size is a multiple of 4 for SIMD processing\n    int simd_size = (n / 4) * 4;\n    int32x4_t zero_vec = vdupq_n_s32(0);\n\n    for (int i = 0; i < simd_size; i += 4) {\n        int32x4_t vec1 = vld1q_s32(&l[i]);\n\n        for (int j = 0; j < n; ++j) {\n            if (i <= j && j < i + 4) continue; // Avoid self-comparison within the same SIMD block\n\n            int32x4_t vec2 = vdupq_n_s32(l[j]);\n            int32x4_t sum = vaddq_s32(vec1, vec2);\n            uint32x4_t cmp = vceqq_s32(sum, zero_vec);\n\n            if (vmaxvq_u32(cmp)) {\n                return true;\n            }\n        }\n    }\n\n    // Handle remaining elements that don't fit into SIMD blocks\n    for (int i = simd_size; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (l[i] + l[j] == 0) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_85_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <algorithm>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    if (base < 2 || base >= 10) return \"\";\n\n    char buffer[64];\n    int32_t index = 63;\n    buffer[index] = '\\0';\n\n    // Load constants into SIMD registers\n    int8x8_t zero = vdup_n_s8(0);\n    int8x8_t base_vec = vdup_n_s8(base);\n\n    while (x > 0) {\n        // Extract 8 digits in parallel using SIMD\n        int8x8_t remainders;\n        int64x1_t x_vec = vdup_n_s64(x);\n        for (int i = 0; i < 8 && x > 0; ++i) {\n            int64_t remainder = x % base;\n            x /= base;\n            remainders[i] = static_cast<int8_t>(remainder);\n        }\n\n        // Convert remainders to characters\n        uint8x8_t ascii_offset = vdup_n_u8('0');\n        uint8x8_t chars = vadd_u8(vreinterpret_u8_s8(remainders), ascii_offset);\n\n        // Store the characters to the buffer\n        uint8_t temp_buffer[8];\n        vst1_u8(temp_buffer, chars);\n        for (int i = 0; i < 8 && index > 0; ++i) {\n            buffer[--index] = static_cast<char>(temp_buffer[i]);\n        }\n    }\n\n    return std::string(buffer + index);\n}\n```"}
{"task_id": "SimdBench_85_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <algorithm>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    char buffer[65]; // Maximum length for base 2 of a 64-bit number + null terminator\n    int32_t idx = 64;\n    buffer[idx] = '\\0';\n\n    // Load constants into SIMD registers\n    int8x16_t zero = vdupq_n_s8('0');\n    int8x16_t base_vec = vdupq_n_s8(base);\n\n    while (x > 0) {\n        // Compute 16 remainders in parallel using SIMD\n        int64x2_t x_vec = vdupq_n_s64(x);\n        int64x2_t base_vec_64 = vdupq_n_s64(base);\n        int64x2_t remainder_vec = vqdmulhq_s64(x_vec, base_vec_64); // Approximation of division\n\n        // Extract remainders and convert to characters\n        int8x16_t rem_char_vec = vaddq_s8(vreinterpretq_s8_s64(remainder_vec), zero);\n\n        // Store results into buffer\n        vst1q_s8(reinterpret_cast<int8_t*>(&buffer[idx - 16]), rem_char_vec);\n\n        // Update x for next iteration\n        x /= base;\n\n        // Adjust index\n        idx -= 16;\n    }\n\n    // Handle remaining digits if any\n    while (x > 0) {\n        buffer[--idx] = '0' + (x % base);\n        x /= base;\n    }\n\n    // Convert buffer to string\n    return std::string(buffer + idx);\n}\n```"}
{"task_id": "SimdBench_85_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <algorithm>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    if (base < 2 || base >= 10) return \"\";\n\n    char buffer[64];\n    int32_t index = 63;\n    buffer[index] = '\\0';\n\n    // Load constants into SIMD registers\n    const int8x8_t zero_vec = vdup_n_s8('0');\n    const int8x8_t base_vec = vdup_n_s8(base);\n\n    // Process in chunks of 8 digits using SIMD\n    while (x > 0) {\n        uint8x8_t digits;\n        uint64x2_t x_vec = vdupq_n_u64(x);\n        uint64x2_t base_vec_64 = vdupq_n_u64(base);\n\n        // Compute remainders for 8 parallel divisions\n        uint64x2_t quotient = vdivq_u64(x_vec, base_vec_64);\n        uint64x2_t remainder = vsubq_u64(x_vec, vmulq_u64(quotient, base_vec_64));\n\n        // Convert remainders to characters\n        digits = vadd_u8(vreinterpret_u8_u64(remainder), zero_vec);\n\n        // Store results in reverse order\n        for (int i = 0; i < 8 && x > 0; ++i) {\n            buffer[--index] = vget_lane_u8(digits, i);\n            x /= base;\n        }\n    }\n\n    return std::string(buffer + index);\n}\n```"}
{"task_id": "SimdBench_85_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <algorithm>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    char buffer[64];\n    int32_t index = 63;\n    buffer[index] = '\\0';\n\n    // Load constants into SIMD registers\n    int8x8_t zero = vdup_n_s8('0');\n    int8x8_t base_vec = vdup_n_s8(base);\n\n    while (x > 0) {\n        // Compute eight remainders in parallel\n        int8x8_t remainders;\n        int64_t temp = x;\n        for (int i = 0; i < 8; ++i) {\n            remainders[i] = temp % base;\n            temp /= base;\n        }\n\n        // Convert remainders to characters\n        int8x8_t chars = vadd_s8(remainders, zero);\n\n        // Store results into the buffer\n        int32_t store_index = index - 8;\n        if (store_index < 0) store_index = 0; // Ensure no underflow\n        vst1_s8(reinterpret_cast<int8_t*>(buffer + store_index), chars);\n\n        // Update index and remaining value of x\n        index -= 8;\n        x = temp;\n    }\n\n    // Handle leftover characters if any\n    while (x > 0) {\n        buffer[--index] = '0' + (x % base);\n        x /= base;\n    }\n\n    return std::string(buffer + index);\n}\n```"}
{"task_id": "SimdBench_85_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <algorithm>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    char buffer[64];\n    int idx = 63;\n    buffer[idx] = '\\0';\n\n    // Load constants into SIMD registers\n    int8x16_t zero = vdupq_n_s8('0');\n    int8x16_t base_vec = vdupq_n_s8(base);\n\n    while (x > 0) {\n        // Compute 16 remainders in parallel using SIMD\n        int64x2_t x_vec = vdupq_n_s64(x);\n        int64x2_t base_vec_64 = vdupq_n_s64(base);\n        int64x2_t remainder_vec = vqdmulhq_s64(x_vec, base_vec_64);\n\n        // Extract the first remainder (valid result)\n        int64_t remainder = vgetq_lane_s64(remainder_vec, 0);\n        buffer[--idx] = '0' + remainder;\n\n        // Update x for next iteration\n        x /= base;\n    }\n\n    return std::string(buffer + idx);\n}\n```"}
{"task_id": "SimdBench_86_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    int n = text.length();\n    if (n <= 1) return true;\n\n    const char* data = text.data();\n    int mid = n / 2;\n    int i = 0;\n\n    // Process 16 characters at a time using NEON intrinsics\n    for (; i <= mid - 16; i += 16) {\n        uint8x16_t front = vld1q_u8(reinterpret_cast<const uint8_t*>(data + i));\n        uint8x16_t back = vld1q_u8(reinterpret_cast<const uint8_t*>(data + n - i - 16));\n\n        // Reverse the 'back' vector\n        back = vrev64q_u8(back);\n        uint8x16_t back_shuffled = vcombine_u8(vget_high_u8(back), vget_low_u8(back));\n\n        // Compare front and reversed back\n        uint8x16_t cmp = vceqq_u8(front, back_shuffled);\n        if (vmaxvq_u8(cmp) != 0xFF) {\n            return false;\n        }\n    }\n\n    // Process remaining characters\n    for (; i < mid; ++i) {\n        if (data[i] != data[n - i - 1]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    int len = text.length();\n    if (len <= 1) return true;\n\n    int mid = len / 2;\n    int vec_size = 16; // NEON processes 16 bytes at a time\n\n    // Align the string to process in chunks of 16 bytes\n    int i = 0;\n    for (; i <= mid - vec_size; i += vec_size) {\n        uint8x16_t front = vld1q_u8(reinterpret_cast<const uint8_t*>(&text[i]));\n        uint8x16_t back = vld1q_u8(reinterpret_cast<const uint8_t*>(&text[len - i - vec_size]));\n\n        // Reverse the 'back' vector\n        uint8x16_t reversed_back = vrev64q_u8(back);\n        reversed_back = vextq_u8(reversed_back, reversed_back, 8);\n\n        // Compare front and reversed_back\n        uint8x16_t cmp = vceqq_u8(front, reversed_back);\n        if (vminvq_u8(cmp) == 0) {\n            return false; // Mismatch found\n        }\n    }\n\n    // Process remaining characters (if any)\n    for (; i < mid; ++i) {\n        if (text[i] != text[len - i - 1]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    int len = text.length();\n    if (len <= 1) return true;\n\n    const char* data = text.c_str();\n    int mid = len / 2;\n    int i = 0;\n\n    // Process 16 characters at a time using NEON intrinsics\n    for (; i <= mid - 16; i += 16) {\n        uint8x16_t front = vld1q_u8(reinterpret_cast<const uint8_t*>(data + i));\n        uint8x16_t back = vld1q_u8(reinterpret_cast<const uint8_t*>(data + len - i - 16));\n\n        // Reverse the 'back' vector\n        back = vrev64q_u8(back);\n        uint8x16_t back_shuffled = vcombine_u8(vget_high_u8(back), vget_low_u8(back));\n        back = vrev64q_u8(back_shuffled);\n\n        // Compare front and reversed back\n        uint8x16_t cmp = vceqq_u8(front, back);\n        if (vmaxvq_u8(cmp) != 0xFF) {\n            return false;\n        }\n    }\n\n    // Process remaining characters\n    for (; i < mid; ++i) {\n        if (data[i] != data[len - i - 1]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    int len = text.length();\n    if (len <= 1) return true;\n\n    int mid = len / 2;\n    int vec_size = 16; // NEON processes 16 bytes at a time\n    int vec_mid = mid / vec_size;\n\n    const uint8_t* data = reinterpret_cast<const uint8_t*>(text.data());\n\n    for (int i = 0; i < vec_mid; ++i) {\n        uint8x16_t front = vld1q_u8(data + i * vec_size);\n        uint8x16_t back = vld1q_u8(data + len - (i + 1) * vec_size);\n\n        uint8x16_t reversed_back = vrev64q_u8(back);\n        reversed_back = vcombine_u8(vget_high_u8(reversed_back), vget_low_u8(reversed_back));\n\n        uint8x16_t cmp = vceqq_u8(front, reversed_back);\n        if (vmaxvq_u8(cmp) != 0xFF) {\n            return false;\n        }\n    }\n\n    int remaining = mid % vec_size;\n    for (int i = 0; i < remaining; ++i) {\n        if (text[i] != text[len - i - 1]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    int len = text.length();\n    if (len <= 1) return true;\n\n    const char* data = text.c_str();\n    int mid = len / 2;\n    int vec_size = 16; // NEON processes 16 bytes at a time\n\n    // Process in chunks of 16 bytes using NEON intrinsics\n    for (int i = 0; i < mid; i += vec_size) {\n        int chunk_size = std::min(vec_size, mid - i);\n\n        // Load vectors from the start and end of the string\n        uint8x16_t front_vec = vld1q_u8(reinterpret_cast<const uint8_t*>(data + i));\n        uint8x16_t back_vec = vld1q_u8(reinterpret_cast<const uint8_t*>(data + len - i - vec_size));\n\n        // Reverse the back vector\n        uint8x16_t reversed_back_vec = vrev64q_u8(back_vec);\n        uint8x16_t temp = vextq_u8(reversed_back_vec, reversed_back_vec, 8);\n        reversed_back_vec = vextq_u8(temp, reversed_back_vec, 8);\n\n        // Compare the two vectors\n        uint8x16_t cmp_result = vceqq_u8(front_vec, reversed_back_vec);\n\n        // Check if all elements in the comparison result are true\n        uint8x16_t mask = vmovq_n_u8(0xFF);\n        uint8x16_t masked_cmp = vandq_u8(cmp_result, mask);\n        uint64x2_t reduced = vpaddlq_u32(vpaddlq_u16(vpaddlq_u8(masked_cmp)));\n\n        uint64_t result = vgetq_lane_u64(reduced, 0) + vgetq_lane_u64(reduced, 1);\n        if (result != (chunk_size * 0xFF)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_87_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), 0);\n    int len = s.length();\n    int i = 0;\n\n    // Process 16 characters at a time using NEON intrinsics\n    for (; i + 15 < len; i += 16) {\n        // Load 16 characters into a NEON register\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n\n        // Subtract 'a' to normalize to 0-25 range\n        uint8x16_t base = vdupq_n_u8('a');\n        uint8x16_t normalized = vsubq_u8(input, base);\n\n        // Subtract 5 to reverse the shift\n        uint8x16_t shift = vdupq_n_u8(5);\n        uint8x16_t shifted = vsubq_u8(normalized, shift);\n\n        // Add 26 to ensure positive values before modulo\n        uint8x16_t mod_base = vdupq_n_u8(26);\n        uint8x16_t positive = vaddq_u8(shifted, mod_base);\n\n        // Modulo 26 using bitwise AND (equivalent to % 26 for 0-25 range)\n        uint8x16_t mask = vdupq_n_u8(25); // 26 - 1\n        uint8x16_t mod_result = vandq_u8(positive, mask);\n\n        // Add 'a' back to get the final character\n        uint8x16_t result = vaddq_u8(mod_result, base);\n\n        // Store the result back into the output string\n        vst1q_u8(reinterpret_cast<uint8_t*>(&out[i]), result);\n    }\n\n    // Process remaining characters (if any) using scalar code\n    for (; i < len; ++i) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out[i] = (char)w;\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), 0);\n    int i = 0;\n\n    // Process 16 characters at a time using NEON intrinsics\n    for (; i + 15 < s.length(); i += 16) {\n        // Load 16 characters into a NEON register\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n\n        // Subtract 5 from each character\n        uint8x16_t decoded = vsubq_u8(input, vdupq_n_u8(5));\n\n        // Wrap around if the result is below 'a'\n        uint8x16_t wrap_mask = vcltq_u8(decoded, vdupq_n_u8('a'));\n        decoded = vbslq_u8(wrap_mask, vaddq_u8(decoded, vdupq_n_u8(26)), decoded);\n\n        // Store the result back to the output string\n        vst1q_u8(reinterpret_cast<uint8_t*>(&out[i]), decoded);\n    }\n\n    // Process remaining characters (if any) using scalar code\n    for (; i < s.length(); ++i) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out[i] = (char)w;\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), 0);\n    int len = s.length();\n    int i = 0;\n\n    // Process 16 characters at a time using NEON intrinsics\n    for (; i <= len - 16; i += 16) {\n        // Load 16 characters from the input string\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n\n        // Subtract 'a' to normalize to 0-25 range\n        uint8x16_t base = vdupq_n_u8('a');\n        uint8x16_t normalized = vsubq_u8(input, base);\n\n        // Subtract 5 to reverse the shift\n        uint8x16_t shifted = vsubq_u8(normalized, vdupq_n_u8(5));\n\n        // Add 26 to ensure positive values before modulo\n        uint8x16_t adjusted = vaddq_u8(shifted, vdupq_n_u8(26));\n\n        // Modulo 26 using bitwise AND (valid because 26 is a power of 2 minus 1)\n        uint8x16_t mod_result = vandq_u8(adjusted, vdupq_n_u8(25));\n\n        // Add 'a' back to get the final character\n        uint8x16_t result = vaddq_u8(mod_result, base);\n\n        // Store the result into the output string\n        vst1q_u8(reinterpret_cast<uint8_t*>(&out[i]), result);\n    }\n\n    // Process remaining characters (if any) using scalar code\n    for (; i < len; ++i) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out[i] = (char)w;\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), 0);\n    int i = 0;\n\n    // Process 16 characters at a time using NEON intrinsics\n    for (; i + 15 < s.length(); i += 16) {\n        // Load 16 characters into a NEON register\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n\n        // Subtract 5 from each character\n        uint8x16_t decoded = vsubq_u8(input, vdupq_n_u8(5));\n\n        // Wrap around if the result is below 'a'\n        uint8x16_t wrap_mask = vcltq_u8(decoded, vdupq_n_u8('a'));\n        decoded = vbslq_u8(wrap_mask, vaddq_u8(decoded, vdupq_n_u8(26)), decoded);\n\n        // Store the result back to the output string\n        vst1q_u8(reinterpret_cast<uint8_t*>(&out[i]), decoded);\n    }\n\n    // Process remaining characters (if any) using scalar code\n    for (; i < s.length(); ++i) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out[i] = (char)w;\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), 0);\n    int i = 0;\n\n    // Process 16 characters at a time using NEON intrinsics\n    for (; i + 15 < s.length(); i += 16) {\n        // Load 16 characters into a NEON register\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n\n        // Subtract 'a' to normalize to 0-25 range\n        uint8x16_t base = vdupq_n_u8('a');\n        uint8x16_t normalized = vsubq_u8(input, base);\n\n        // Subtract 5 to reverse the shift\n        uint8x16_t shift = vdupq_n_u8(5);\n        uint8x16_t shifted = vsubq_u8(normalized, shift);\n\n        // Add 26 to ensure positive values before modulo\n        uint8x16_t mod_base = vdupq_n_u8(26);\n        uint8x16_t positive = vaddq_u8(shifted, mod_base);\n\n        // Perform modulo 26\n        uint8x16_t result_mod = vandq_u8(positive, vdupq_n_u8(25));\n\n        // Add 'a' back to get the final decoded characters\n        uint8x16_t decoded = vaddq_u8(result_mod, base);\n\n        // Store the result back into the output string\n        vst1q_u8(reinterpret_cast<uint8_t*>(&out[i]), decoded);\n    }\n\n    // Process remaining characters (if any) using scalar code\n    for (; i < s.length(); ++i) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out[i] = (char)w;\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_88_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    int n = l.size();\n    int i = 0;\n    bool result = true;\n\n    // Load the threshold into a vector register\n    int32x4_t threshold = vdupq_n_s32(t);\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= n - 4; i += 4) {\n        // Load 4 elements from the vector into a NEON register\n        int32x4_t vec = vld1q_s32(&l[i]);\n\n        // Compare each element with the threshold\n        uint32x4_t cmp = vcltq_s32(vec, threshold);\n\n        // Check if all comparisons are true (all elements < threshold)\n        if (vminvq_u32(cmp) == 0) {\n            result = false;\n            break;\n        }\n    }\n\n    // Process remaining elements (if any) using scalar code\n    for (; i < n; ++i) {\n        if (l[i] >= t) {\n            result = false;\n            break;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_88_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    int n = l.size();\n    int16x8_t threshold_vec = vdupq_n_s16(t);\n    int i = 0;\n\n    // Process 8 elements at a time using NEON intrinsics\n    for (; i <= n - 8; i += 8) {\n        int16x8_t data_vec = vld1q_s16(reinterpret_cast<const int16_t*>(&l[i]));\n        uint16x8_t cmp_result = vcgtq_s16(data_vec, threshold_vec);\n        if (vmaxvq_u16(cmp_result) != 0) {\n            return false;\n        }\n    }\n\n    // Process remaining elements\n    for (; i < n; ++i) {\n        if (l[i] >= t) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_88_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    int n = l.size();\n    int i = 0;\n    \n    // Broadcast the threshold value to all lanes of a vector\n    int32x4_t vt = vdupq_n_s32(t);\n    bool all_below = true;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= n - 4; i += 4) {\n        // Load 4 integers from the vector into a NEON register\n        int32x4_t vl = vld1q_s32(&l[i]);\n\n        // Compare each element with the threshold\n        uint32x4_t vc = vcltq_s32(vl, vt);\n\n        // Check if all comparisons are true (all elements < threshold)\n        if (vminvq_u32(vc) == 0) {\n            all_below = false;\n            break;\n        }\n    }\n\n    // Process any remaining elements that didn't fit into a full vector\n    for (; i < n; ++i) {\n        if (l[i] >= t) {\n            all_below = false;\n            break;\n        }\n    }\n\n    return all_below;\n}\n```"}
{"task_id": "SimdBench_88_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    int n = l.size();\n    int threshold_vec[4] = {t, t, t, t};\n    int32x4_t vt = vld1q_s32(threshold_vec);\n    bool result = true;\n\n    for (int i = 0; i < n; i += 4) {\n        int32x4_t vl = vld1q_s32(&l[i]);\n        uint32x4_t vc = vcltq_s32(vl, vt);\n        if (vgetq_lane_u32(vc, 0) == 0 || vgetq_lane_u32(vc, 1) == 0 ||\n            vgetq_lane_u32(vc, 2) == 0 || vgetq_lane_u32(vc, 3) == 0) {\n            result = false;\n            break;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_88_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    int n = l.size();\n    int i = 0;\n    \n    // Broadcast the threshold value to all lanes of a SIMD register\n    int32x4_t vt = vdupq_n_s32(t);\n    \n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= n - 4; i += 4) {\n        // Load 4 elements from the vector into a SIMD register\n        int32x4_t vl = vld1q_s32(&l[i]);\n        \n        // Compare each element with the threshold\n        uint32x4_t vc = vcltq_s32(vl, vt);\n        \n        // Check if all comparisons are true (all elements < threshold)\n        if (vminvq_u32(vc) == 0) {\n            return false;\n        }\n    }\n    \n    // Process any remaining elements\n    for (; i < n; ++i) {\n        if (l[i] >= t) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_89_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int length = brackets.length();\n    int balance = 0;\n    int i = 0;\n\n    // Process the string in chunks of 16 characters using NEON\n    for (; i <= length - 16; i += 16) {\n        // Load 16 characters into a NEON register\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&brackets[i]));\n\n        // Create a mask for '<' (ASCII 60)\n        uint8x16_t less_than_mask = vdupq_n_u8('<');\n        uint8x16_t is_less_than = vceqq_u8(input, less_than_mask);\n\n        // Create a mask for '>' (ASCII 62)\n        uint8x16_t greater_than_mask = vdupq_n_u8('>');\n        uint8x16_t is_greater_than = vceqq_u8(input, greater_than_mask);\n\n        // Count the number of '<' and '>' in the current chunk\n        uint16x8_t less_than_count_lo = vpaddlq_u8(vget_low_u8(is_less_than));\n        uint16x8_t less_than_count_hi = vpaddlq_u8(vget_high_u8(is_less_than));\n        uint32x4_t less_than_count = vpaddlq_u16(vcombine_u16(less_than_count_lo, less_than_count_hi));\n\n        uint16x8_t greater_than_count_lo = vpaddlq_u8(vget_low_u8(is_greater_than));\n        uint16x8_t greater_than_count_hi = vpaddlq_u8(vget_high_u8(is_greater_than));\n        uint32x4_t greater_than_count = vpaddlq_u16(vcombine_u16(greater_than_count_lo, greater_than_count_hi));\n\n        // Sum up the counts\n        int less_than_sum = vaddvq_u32(less_than_count);\n        int greater_than_sum = vaddvq_u32(greater_than_count);\n\n        // Update the balance\n        balance += less_than_sum - greater_than_sum;\n\n        // Early exit if balance goes negative\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    // Process remaining characters\n    for (; i < length; ++i) {\n        if (brackets[i] == '<') {\n            balance++;\n        } else if (brackets[i] == '>') {\n            balance--;\n        }\n\n        // Early exit if balance goes negative\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    // Final check for balanced brackets\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int length = brackets.length();\n    int balance = 0;\n    int i = 0;\n\n    // Process the string in chunks of 16 characters using NEON\n    for (; i <= length - 16; i += 16) {\n        // Load 16 characters into a NEON register\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&brackets[i]));\n\n        // Create a mask for '<' (ASCII 60)\n        uint8x16_t less_than_mask = vmovq_n_u8('<');\n        uint8x16_t is_less_than = vceqq_u8(input, less_than_mask);\n\n        // Create a mask for '>' (ASCII 62)\n        uint8x16_t greater_than_mask = vmovq_n_u8('>');\n        uint8x16_t is_greater_than = vceqq_u8(input, greater_than_mask);\n\n        // Count the number of '<' and '>' in the current chunk\n        uint16x8_t less_than_count_low = vpaddlq_u8(vandq_u8(is_less_than, vmovq_n_u8(1)));\n        uint16x8_t greater_than_count_low = vpaddlq_u8(vandq_u8(is_greater_than, vmovq_n_u8(1)));\n\n        uint32x4_t less_than_count_high = vpaddlq_u16(less_than_count_low);\n        uint32x4_t greater_than_count_high = vpaddlq_u16(greater_than_count_low);\n\n        uint64x2_t less_than_sum = vpaddlq_u32(less_than_count_high);\n        uint64x2_t greater_than_sum = vpaddlq_u32(greater_than_count_high);\n\n        // Extract the total counts for '<' and '>' from the NEON registers\n        uint64_t less_than_total = vgetq_lane_u64(less_than_sum, 0) + vgetq_lane_u64(less_than_sum, 1);\n        uint64_t greater_than_total = vgetq_lane_u64(greater_than_sum, 0) + vgetq_lane_u64(greater_than_sum, 1);\n\n        // Update the balance\n        balance += static_cast<int>(less_than_total) - static_cast<int>(greater_than_total);\n\n        // Early exit if balance goes negative\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    // Process the remaining characters (if any) using scalar code\n    for (; i < length; ++i) {\n        if (brackets[i] == '<') {\n            ++balance;\n        } else if (brackets[i] == '>') {\n            --balance;\n        }\n\n        // Early exit if balance goes negative\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    // Final check: balance must be zero for correct bracketing\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int length = brackets.length();\n    if (length % 2 != 0) return false;\n\n    int balance = 0;\n    int i = 0;\n\n    // Process 16 characters at a time using NEON intrinsics\n    for (; i <= length - 16; i += 16) {\n        // Load 16 characters into a NEON register\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&brackets[i]));\n\n        // Create a mask for '<' (ASCII 60)\n        uint8x16_t less_than_mask = vdupq_n_u8('<');\n        uint8x16_t is_less_than = vceqq_u8(input, less_than_mask);\n\n        // Create a mask for '>' (ASCII 62)\n        uint8x16_t greater_than_mask = vdupq_n_u8('>');\n        uint8x16_t is_greater_than = vceqq_u8(input, greater_than_mask);\n\n        // Count the number of '<' and '>' in the current block\n        uint16x8_t sum_less_than_high = vpaddlq_u8(is_less_than);\n        uint16x8_t sum_greater_than_high = vpaddlq_u8(is_greater_than);\n\n        uint32x4_t sum_less_than_low = vpaddlq_u16(sum_less_than_high);\n        uint32x4_t sum_greater_than_low = vpaddlq_u16(sum_greater_than_high);\n\n        uint64x2_t sum_less_than_final = vpaddlq_u32(sum_less_than_low);\n        uint64x2_t sum_greater_than_final = vpaddlq_u32(sum_greater_than_low);\n\n        uint64_t total_less_than = vgetq_lane_u64(sum_less_than_final, 0) + vgetq_lane_u64(sum_less_than_final, 1);\n        uint64_t total_greater_than = vgetq_lane_u64(sum_greater_than_final, 0) + vgetq_lane_u64(sum_greater_than_final, 1);\n\n        // Update balance\n        balance += (int)(total_less_than - total_greater_than);\n\n        // Early exit if balance goes negative\n        if (balance < 0) return false;\n    }\n\n    // Process remaining characters\n    for (; i < length; ++i) {\n        if (brackets[i] == '<') {\n            balance++;\n        } else if (brackets[i] == '>') {\n            balance--;\n        }\n        if (balance < 0) return false;\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int length = brackets.length();\n    int balance = 0;\n    int i = 0;\n\n    // Process the string in chunks of 16 characters using NEON\n    for (; i <= length - 16; i += 16) {\n        // Load 16 characters into a NEON register\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&brackets[i]));\n\n        // Create a mask for '<' (ASCII 60)\n        uint8x16_t less_than_mask = vdupq_n_u8('<');\n        uint8x16_t is_less_than = vceqq_u8(input, less_than_mask);\n\n        // Create a mask for '>' (ASCII 62)\n        uint8x16_t greater_than_mask = vdupq_n_u8('>');\n        uint8x16_t is_greater_than = vceqq_u8(input, greater_than_mask);\n\n        // Count the number of '<' and '>' in the current chunk\n        uint16x8_t less_than_count_low = vpaddlq_u8(vandq_u8(is_less_than, vdupq_n_u8(1)));\n        uint16x8_t greater_than_count_low = vpaddlq_u8(vandq_u8(is_greater_than, vdupq_n_u8(1)));\n\n        uint32x4_t less_than_count_high = vpaddlq_u16(less_than_count_low);\n        uint32x4_t greater_than_count_high = vpaddlq_u16(greater_than_count_low);\n\n        uint64x2_t less_than_sum = vpaddlq_u32(less_than_count_high);\n        uint64x2_t greater_than_sum = vpaddlq_u32(greater_than_count_high);\n\n        // Extract the total counts for '<' and '>' from the NEON registers\n        uint64_t less_than_total = vgetq_lane_u64(less_than_sum, 0) + vgetq_lane_u64(less_than_sum, 1);\n        uint64_t greater_than_total = vgetq_lane_u64(greater_than_sum, 0) + vgetq_lane_u64(greater_than_sum, 1);\n\n        // Update the balance\n        balance += static_cast<int>(less_than_total) - static_cast<int>(greater_than_total);\n\n        // Early exit if balance goes negative\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    // Process the remaining characters\n    for (; i < length; ++i) {\n        if (brackets[i] == '<') {\n            balance++;\n        } else if (brackets[i] == '>') {\n            balance--;\n        }\n\n        // Early exit if balance goes negative\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    // Final check: balance must be zero\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int length = brackets.length();\n    if (length % 2 != 0) return false;\n\n    int balance = 0;\n    int i = 0;\n\n    // Process 16 characters at a time using NEON intrinsics\n    for (; i <= length - 16; i += 16) {\n        // Load 16 characters into a NEON register\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&brackets[i]));\n\n        // Create a mask for '<' (ASCII 60)\n        uint8x16_t less_than_mask = vdupq_n_u8('<');\n        uint8x16_t is_less_than = vceqq_u8(input, less_than_mask);\n\n        // Create a mask for '>' (ASCII 62)\n        uint8x16_t greater_than_mask = vdupq_n_u8('>');\n        uint8x16_t is_greater_than = vceqq_u8(input, greater_than_mask);\n\n        // Count the number of '<' and '>' in the current block\n        uint16x8_t count_less_than_high = vpaddlq_u8(vreinterpretq_u8_u64(vshrq_n_u64(vreinterpretq_u64_u8(is_less_than), 32)));\n        uint16x8_t count_greater_than_high = vpaddlq_u8(vreinterpretq_u8_u64(vshrq_n_u64(vreinterpretq_u64_u8(is_greater_than), 32)));\n\n        uint32x4_t count_less_than_low = vpaddlq_u16(count_less_than_high);\n        uint32x4_t count_greater_than_low = vpaddlq_u16(count_greater_than_high);\n\n        uint64x2_t count_less_than_final = vpaddlq_u32(count_less_than_low);\n        uint64x2_t count_greater_than_final = vpaddlq_u32(count_greater_than_low);\n\n        uint64_t total_less_than = vgetq_lane_u64(count_less_than_final, 0) + vgetq_lane_u64(count_less_than_final, 1);\n        uint64_t total_greater_than = vgetq_lane_u64(count_greater_than_final, 0) + vgetq_lane_u64(count_greater_than_final, 1);\n\n        // Update balance\n        balance += static_cast<int>(total_less_than) - static_cast<int>(total_greater_than);\n\n        // Early exit if balance goes negative\n        if (balance < 0) return false;\n    }\n\n    // Process remaining characters\n    for (; i < length; ++i) {\n        if (brackets[i] == '<') {\n            balance++;\n        } else if (brackets[i] == '>') {\n            balance--;\n        }\n        if (balance < 0) return false;\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int length = brackets.length();\n    int balance = 0;\n    int i = 0;\n\n    // Process 16 characters at a time using NEON intrinsics\n    for (; i <= length - 16; i += 16) {\n        // Load 16 characters into a NEON register\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&brackets[i]));\n\n        // Create a mask for '(' and ')'\n        uint8x16_t open_mask = vceqq_u8(input, vdupq_n_u8('('));\n        uint8x16_t close_mask = vceqq_u8(input, vdupq_n_u8(')'));\n\n        // Count the number of '(' and ')' using the masks\n        uint16x8_t open_sum_1 = vpaddlq_u8(open_mask);\n        uint16x8_t close_sum_1 = vpaddlq_u8(close_mask);\n\n        uint32x4_t open_sum_2 = vpaddlq_u16(open_sum_1);\n        uint32x4_t close_sum_2 = vpaddlq_u16(close_sum_1);\n\n        uint64x2_t open_sum_3 = vpaddlq_u32(open_sum_2);\n        uint64x2_t close_sum_3 = vpaddlq_u32(close_sum_2);\n\n        // Extract the total counts of '(' and ')' from the NEON registers\n        uint64_t open_count = vgetq_lane_u64(open_sum_3, 0) + vgetq_lane_u64(open_sum_3, 1);\n        uint64_t close_count = vgetq_lane_u64(close_sum_3, 0) + vgetq_lane_u64(close_sum_3, 1);\n\n        // Update the balance\n        balance += (int)(open_count - close_count);\n\n        // Early exit if balance goes negative\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    // Process remaining characters\n    for (; i < length; ++i) {\n        if (brackets[i] == '(') {\n            balance++;\n        } else if (brackets[i] == ')') {\n            balance--;\n        }\n\n        // Early exit if balance goes negative\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    // Final check: balance must be zero\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int length = brackets.length();\n    int balance = 0;\n    int i = 0;\n\n    // Process 16 characters at a time using NEON intrinsics\n    for (; i <= length - 16; i += 16) {\n        // Load 16 characters into a NEON register\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&brackets[i]));\n\n        // Create a mask for '(' and ')'\n        uint8x16_t open_mask = vmovq_n_u8('(');\n        uint8x16_t close_mask = vmovq_n_u8(')');\n\n        // Compare for '(' and ')'\n        uint8x16_t is_open = vceqq_u8(input, open_mask);\n        uint8x16_t is_close = vceqq_u8(input, close_mask);\n\n        // Count the number of '(' and ')' in the current block\n        uint16x8_t open_count_lo = vpaddlq_u8(vandq_u8(is_open, vdupq_n_u8(1)));\n        uint16x8_t open_count_hi = vpaddlq_u8(vandq_u8(vextq_u8(is_open, is_open, 8), vdupq_n_u8(1)));\n        uint16x8_t close_count_lo = vpaddlq_u8(vandq_u8(is_close, vdupq_n_u8(1)));\n        uint16x8_t close_count_hi = vpaddlq_u8(vandq_u8(vextq_u8(is_close, is_close, 8), vdupq_n_u8(1)));\n\n        // Sum the counts\n        uint32x4_t open_sum = vpaddlq_u16(vcombine_u16(vget_low_u16(open_count_lo), vget_low_u16(open_count_hi)));\n        uint32x4_t close_sum = vpaddlq_u16(vcombine_u16(vget_low_u16(close_count_lo), vget_low_u16(close_count_hi)));\n\n        // Extract the total counts\n        int open_total = vaddvq_u32(open_sum);\n        int close_total = vaddvq_u32(close_sum);\n\n        // Update balance\n        balance += open_total - close_total;\n\n        // Early exit if balance goes negative\n        if (balance < 0) return false;\n    }\n\n    // Process remaining characters\n    for (; i < length; ++i) {\n        if (brackets[i] == '(') {\n            balance++;\n        } else if (brackets[i] == ')') {\n            balance--;\n        }\n        if (balance < 0) return false;\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int length = brackets.length();\n    int balance = 0;\n    int i = 0;\n\n    // Process the string in chunks of 16 characters using NEON\n    for (; i <= length - 16; i += 16) {\n        // Load 16 characters into a NEON register\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&brackets[i]));\n\n        // Create a mask for '(' and ')'\n        uint8x16_t open_bracket = vmovq_n_u8('(');\n        uint8x16_t close_bracket = vmovq_n_u8(')');\n\n        // Compare for '(' and ')'\n        uint8x16_t is_open = vceqq_u8(input, open_bracket);\n        uint8x16_t is_close = vceqq_u8(input, close_bracket);\n\n        // Count the number of '(' and ')' in the current chunk\n        uint16x8_t open_sum1 = vpaddlq_u8(vreinterpretq_u8_u64(vreinterpretq_u64_u8(is_open)));\n        uint16x8_t close_sum1 = vpaddlq_u8(vreinterpretq_u8_u64(vreinterpretq_u64_u8(is_close)));\n\n        uint32x4_t open_sum2 = vpaddlq_u16(open_sum1);\n        uint32x4_t close_sum2 = vpaddlq_u16(close_sum1);\n\n        uint64x2_t open_sum3 = vpaddlq_u32(open_sum2);\n        uint64x2_t close_sum3 = vpaddlq_u32(close_sum2);\n\n        uint64_t open_count = vgetq_lane_u64(open_sum3, 0) + vgetq_lane_u64(open_sum3, 1);\n        uint64_t close_count = vgetq_lane_u64(close_sum3, 0) + vgetq_lane_u64(close_sum3, 1);\n\n        // Update balance\n        balance += (int)(open_count - close_count);\n\n        // Early exit if balance goes negative\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    // Process remaining characters\n    for (; i < length; ++i) {\n        if (brackets[i] == '(') {\n            balance++;\n        } else if (brackets[i] == ')') {\n            balance--;\n        }\n\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int length = brackets.length();\n    int balance = 0;\n    int i = 0;\n\n    // Process the string in chunks of 16 characters using NEON\n    for (; i <= length - 16; i += 16) {\n        // Load 16 characters into a NEON register\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&brackets[i]));\n\n        // Create a mask for '(' and ')'\n        uint8x16_t open_bracket = vmovq_n_u8('(');\n        uint8x16_t close_bracket = vmovq_n_u8(')');\n\n        // Compare for '(' and ')'\n        uint8x16_t is_open = vceqq_u8(input, open_bracket);\n        uint8x16_t is_close = vceqq_u8(input, close_bracket);\n\n        // Count the number of '(' and ')' in the current chunk\n        uint16x8_t open_sum_low = vpaddlq_u8(vandq_u8(is_open, vdupq_n_u8(1)));\n        uint16x8_t close_sum_low = vpaddlq_u8(vandq_u8(is_close, vdupq_n_u8(1)));\n\n        uint32x4_t open_sum_high = vpaddlq_u16(open_sum_low);\n        uint32x4_t close_sum_high = vpaddlq_u16(close_sum_low);\n\n        uint64x2_t open_sum_final = vpaddlq_u32(open_sum_high);\n        uint64x2_t close_sum_final = vpaddlq_u32(close_sum_high);\n\n        // Extract the total counts for '(' and ')' from the NEON registers\n        uint64_t open_count = vgetq_lane_u64(open_sum_final, 0) + vgetq_lane_u64(open_sum_final, 1);\n        uint64_t close_count = vgetq_lane_u64(close_sum_final, 0) + vgetq_lane_u64(close_sum_final, 1);\n\n        // Update the balance\n        balance += (int)(open_count - close_count);\n\n        // Early exit if balance goes negative\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    // Process remaining characters\n    for (; i < length; ++i) {\n        if (brackets[i] == '(') {\n            balance++;\n        } else if (brackets[i] == ')') {\n            balance--;\n        }\n\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    // Final check for balance\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int length = brackets.length();\n    int balance = 0;\n    int i = 0;\n\n    // Process the string in chunks of 16 characters using NEON\n    for (; i <= length - 16; i += 16) {\n        // Load 16 characters into a NEON register\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&brackets[i]));\n\n        // Create a mask for '(' and ')'\n        uint8x16_t open_bracket = vmovq_n_u8('(');\n        uint8x16_t close_bracket = vmovq_n_u8(')');\n\n        // Compare for '(' and ')'\n        uint8x16_t is_open = vceqq_u8(input, open_bracket);\n        uint8x16_t is_close = vceqq_u8(input, close_bracket);\n\n        // Count the number of '(' and ')'\n        uint16x8_t open_sum_1 = vpaddlq_u8(vreinterpretq_u8_u64(vshrq_n_u64(vreinterpretq_u64_u8(is_open), 7)));\n        uint16x8_t close_sum_1 = vpaddlq_u8(vreinterpretq_u8_u64(vshrq_n_u64(vreinterpretq_u64_u8(is_close), 7)));\n\n        uint32x4_t open_sum_2 = vpaddlq_u16(open_sum_1);\n        uint32x4_t close_sum_2 = vpaddlq_u16(close_sum_1);\n\n        uint64x2_t open_sum_3 = vpaddlq_u32(open_sum_2);\n        uint64x2_t close_sum_3 = vpaddlq_u32(close_sum_2);\n\n        uint64x2_t total_sum = vaddq_u64(open_sum_3, close_sum_3);\n\n        // Extract the counts\n        uint64_t open_count = vgetq_lane_u64(total_sum, 0);\n        uint64_t close_count = vgetq_lane_u64(total_sum, 1);\n\n        // Update balance\n        balance += (int)(open_count - close_count);\n        \n        // Early exit if balance goes negative\n        if (balance < 0) return false;\n    }\n\n    // Process remaining characters\n    for (; i < length; ++i) {\n        if (brackets[i] == '(') {\n            balance++;\n        } else if (brackets[i] == ')') {\n            balance--;\n        }\n        if (balance < 0) return false;\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_91_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    int n = xs.size();\n    std::vector<float> result(n > 1 ? n - 1 : 0, 0.0f);\n\n    if (n <= 1) return result;\n\n    int i = 1;\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 3 < n; i += 4) {\n        // Load 4 coefficients into a vector\n        float32x4_t coeffs = vld1q_f32(&xs[i]);\n\n        // Create a vector of indices {i, i+1, i+2, i+3}\n        float32x4_t indices = vld1q_f32((float[4]){i, i + 1, i + 2, i + 3});\n\n        // Multiply coefficients by their respective indices\n        float32x4_t deriv = vmulq_f32(coeffs, indices);\n\n        // Store the result back to memory\n        vst1q_f32(&result[i - 1], deriv);\n    }\n\n    // Process remaining elements\n    for (; i < n; ++i) {\n        result[i - 1] = xs[i] * static_cast<float>(i);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    int n = xs.size();\n    std::vector<float> result(n - 1, 0.0f);\n\n    int i = 1;\n    for (; i + 3 < n; i += 4) {\n        // Load 4 coefficients into a SIMD register\n        float32x4_t coeffs = vld1q_f32(&xs[i]);\n\n        // Create a vector of indices {i, i+1, i+2, i+3}\n        float32x4_t indices = vld1q_f32((float[4]){i, i + 1, i + 2, i + 3});\n\n        // Multiply coefficients by their respective indices\n        float32x4_t deriv = vmulq_f32(coeffs, indices);\n\n        // Store the result back to memory\n        vst1q_f32(&result[i - 1], deriv);\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        result[i - 1] = xs[i] * static_cast<float>(i);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    int n = xs.size();\n    std::vector<float> result(n - 1);\n\n    int i = 0;\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= n - 5; i += 4) {\n        // Load 4 coefficients into a vector\n        float32x4_t coeffs = vld1q_f32(&xs[i + 1]);\n\n        // Create a vector of indices {1, 2, 3, 4} for multiplication\n        float32x4_t indices = vld1q_f32((float[]){1.0f, 2.0f, 3.0f, 4.0f});\n\n        // Multiply coefficients by their respective indices\n        float32x4_t deriv = vmulq_f32(coeffs, indices);\n\n        // Store the result back to memory\n        vst1q_f32(&result[i], deriv);\n    }\n\n    // Handle remaining elements (if any) using scalar operations\n    for (; i < n - 1; ++i) {\n        result[i] = xs[i + 1] * static_cast<float>(i + 1);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    int n = xs.size();\n    std::vector<float> result(n > 1 ? n - 1 : 0, 0.0f);\n\n    if (n <= 1) return result;\n\n    int i = 1;\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 3 < n; i += 4) {\n        // Load 4 coefficients into a SIMD register\n        float32x4_t coeffs = vld1q_f32(&xs[i]);\n\n        // Create a vector of indices {i, i+1, i+2, i+3}\n        float32x4_t indices = vld1q_f32((float[4]){i, i + 1, i + 2, i + 3});\n\n        // Multiply coefficients by their respective indices\n        float32x4_t deriv = vmulq_f32(coeffs, indices);\n\n        // Store the result back to memory\n        vst1q_f32(&result[i - 1], deriv);\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        result[i - 1] = xs[i] * static_cast<float>(i);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    int n = xs.size();\n    std::vector<float> result(n - 1);\n\n    int i = 1;\n    for (; i + 3 < n; i += 4) {\n        // Load 4 coefficients into a SIMD register\n        float32x4_t coeffs = vld1q_f32(&xs[i]);\n\n        // Create a vector of indices {i, i+1, i+2, i+3}\n        float32x4_t indices = vld1q_f32((float[]){(float)i, (float)(i+1), (float)(i+2), (float)(i+3)});\n\n        // Multiply coefficients by their respective indices\n        float32x4_t deriv = vmulq_f32(coeffs, indices);\n\n        // Store the result back to memory\n        vst1q_f32(&result[i-1], deriv);\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        result[i-1] = xs[i] * i;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_92_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    int len = s.length();\n    int count = 0;\n\n    // Define vowels and 'y' for comparison\n    uint8x16_t vowels = vld1q_u8((const uint8_t *)\"aeiouAEIOU\");\n    uint8x16_t y_char = vdupq_n_u8('y');\n    uint8x16_t Y_char = vdupq_n_u8('Y');\n\n    // Process the string in chunks of 16 characters using NEON intrinsics\n    int i = 0;\n    for (; i <= len - 16; i += 16) {\n        uint8x16_t input = vld1q_u8((const uint8_t *)(s.c_str() + i));\n\n        // Compare with vowels\n        uint8x16_t is_a = vceqq_u8(input, vdupq_n_u8('a'));\n        uint8x16_t is_e = vceqq_u8(input, vdupq_n_u8('e'));\n        uint8x16_t is_i = vceqq_u8(input, vdupq_n_u8('i'));\n        uint8x16_t is_o = vceqq_u8(input, vdupq_n_u8('o'));\n        uint8x16_t is_u = vceqq_u8(input, vdupq_n_u8('u'));\n        uint8x16_t is_A = vceqq_u8(input, vdupq_n_u8('A'));\n        uint8x16_t is_E = vceqq_u8(input, vdupq_n_u8('E'));\n        uint8x16_t is_I = vceqq_u8(input, vdupq_n_u8('I'));\n        uint8x16_t is_O = vceqq_u8(input, vdupq_n_u8('O'));\n        uint8x16_t is_U = vceqq_u8(input, vdupq_n_u8('U'));\n\n        // Combine all comparisons\n        uint8x16_t is_vowel = vorrq_u8(vorrq_u8(vorrq_u8(vorrq_u8(is_a, is_e), vorrq_u8(is_i, is_o)), vorrq_u8(is_u, is_A)), vorrq_u8(vorrq_u8(is_E, is_I), vorrq_u8(is_O, is_U)));\n\n        // Count matches\n        uint8x16_t mask = vmovl_u8(vget_low_u8(is_vowel));\n        count += vaddvq_u8(mask);\n    }\n\n    // Handle remaining characters (less than 16)\n    for (; i < len; ++i) {\n        char c = s[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n            c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n\n    // Check if the last character is 'y' or 'Y'\n    if (len > 0 && (s[len - 1] == 'y' || s[len - 1] == 'Y')) {\n        count++;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    int count = 0;\n    int len = s.length();\n    const char *data = s.c_str();\n\n    // Vowels to check: a, e, i, o, u (case-insensitive)\n    uint8x16_t vowels = vld1q_u8((const uint8_t *)\"aeiouAEIOU\");\n    uint8x16_t mask_low = vdupq_n_u8(0x20); // Mask to convert uppercase to lowercase\n\n    for (int i = 0; i <= len - 16; i += 16) {\n        uint8x16_t input = vld1q_u8((const uint8_t *)(data + i));\n        \n        // Convert uppercase letters to lowercase\n        uint8x16_t lower_input = vorrq_u8(vandq_u8(input, vdupq_n_u8(0xDF)), mask_low);\n\n        // Compare with vowels\n        uint8x16_t cmp_a = vceqq_u8(lower_input, vdupq_n_u8('a'));\n        uint8x16_t cmp_e = vceqq_u8(lower_input, vdupq_n_u8('e'));\n        uint8x16_t cmp_i = vceqq_u8(lower_input, vdupq_n_u8('i'));\n        uint8x16_t cmp_o = vceqq_u8(lower_input, vdupq_n_u8('o'));\n        uint8x16_t cmp_u = vceqq_u8(lower_input, vdupq_n_u8('u'));\n\n        // Combine comparisons\n        uint8x16_t result = vorrq_u8(vorrq_u8(vorrq_u8(cmp_a, cmp_e), vorrq_u8(cmp_i, cmp_o)), cmp_u);\n\n        // Count matches\n        uint8x16_t mask = vshrq_n_u8(result, 7);\n        uint8x8_t sum = vpadd_u8(vget_low_u8(mask), vget_high_u8(mask));\n        sum = vpadd_u8(sum, sum);\n        sum = vpadd_u8(sum, sum);\n        count += vget_lane_u8(sum, 0);\n    }\n\n    // Handle remaining characters\n    for (int i = len - (len % 16); i < len; ++i) {\n        char c = s[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n            c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n\n    // Check if the last character is 'y' or 'Y'\n    if (len > 0 && (s[len - 1] == 'y' || s[len - 1] == 'Y')) {\n        count++;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    int count = 0;\n    int len = s.length();\n    const char *data = s.c_str();\n\n    // Vowel lookup table: 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'\n    uint8x16_t vowel_table = vld1q_u8((const uint8_t *)\"aeiouAEIOU\");\n\n    // Process 16 characters at a time\n    int i = 0;\n    for (; i <= len - 16; i += 16) {\n        uint8x16_t input = vld1q_u8((const uint8_t *)(data + i));\n        uint8x16_t mask0 = vceqq_u8(input, vdupq_laneq_u8(vowel_table, 0));\n        uint8x16_t mask1 = vceqq_u8(input, vdupq_laneq_u8(vowel_table, 1));\n        uint8x16_t mask2 = vceqq_u8(input, vdupq_laneq_u8(vowel_table, 2));\n        uint8x16_t mask3 = vceqq_u8(input, vdupq_laneq_u8(vowel_table, 3));\n        uint8x16_t mask4 = vceqq_u8(input, vdupq_laneq_u8(vowel_table, 4));\n        uint8x16_t mask5 = vceqq_u8(input, vdupq_laneq_u8(vowel_table, 5));\n        uint8x16_t mask6 = vceqq_u8(input, vdupq_laneq_u8(vowel_table, 6));\n        uint8x16_t mask7 = vceqq_u8(input, vdupq_laneq_u8(vowel_table, 7));\n        uint8x16_t mask8 = vceqq_u8(input, vdupq_laneq_u8(vowel_table, 8));\n        uint8x16_t mask9 = vceqq_u8(input, vdupq_laneq_u8(vowel_table, 9));\n\n        uint8x16_t combined_mask = vorrq_u8(vorrq_u8(vorrq_u8(vorrq_u8(mask0, mask1), vorrq_u8(mask2, mask3)),\n                                                     vorrq_u8(vorrq_u8(mask4, mask5), vorrq_u8(mask6, mask7))),\n                                            vorrq_u8(mask8, mask9));\n\n        uint8x16_t result = vpaddq_u8(combined_mask, combined_mask);\n        result = vpaddq_u8(result, result);\n        result = vpaddq_u8(result, result);\n\n        count += vaddvq_u8(result);\n    }\n\n    // Handle remaining characters\n    for (; i < len; ++i) {\n        char c = data[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n            c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n\n    // Check if the last character is 'y' or 'Y'\n    if (len > 0 && (data[len - 1] == 'y' || data[len - 1] == 'Y')) {\n        count++;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    int count = 0;\n    int len = s.length();\n    const char *data = s.c_str();\n\n    // Vowel lookup table: 'a', 'e', 'i', 'o', 'u', 'y' (case-insensitive)\n    uint8x16_t vowel_mask_low = vdupq_n_u8(0);\n    vowel_mask_low = vsetq_lane_u8(1, vowel_mask_low, 'a');\n    vowel_mask_low = vsetq_lane_u8(1, vowel_mask_low, 'e');\n    vowel_mask_low = vsetq_lane_u8(1, vowel_mask_low, 'i');\n    vowel_mask_low = vsetq_lane_u8(1, vowel_mask_low, 'o');\n    vowel_mask_low = vsetq_lane_u8(1, vowel_mask_low, 'u');\n    vowel_mask_low = vsetq_lane_u8(1, vowel_mask_low, 'y');\n\n    uint8x16_t vowel_mask_up = vdupq_n_u8(0);\n    vowel_mask_up = vsetq_lane_u8(1, vowel_mask_up, 'A');\n    vowel_mask_up = vsetq_lane_u8(1, vowel_mask_up, 'E');\n    vowel_mask_up = vsetq_lane_u8(1, vowel_mask_up, 'I');\n    vowel_mask_up = vsetq_lane_u8(1, vowel_mask_up, 'O');\n    vowel_mask_up = vsetq_lane_u8(1, vowel_mask_up, 'U');\n    vowel_mask_up = vsetq_lane_u8(1, vowel_mask_up, 'Y');\n\n    int i = 0;\n\n    // Process 16 characters at a time using SIMD\n    for (; i <= len - 16; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(data + i));\n\n        // Compare with lowercase vowels\n        uint8x16_t cmp_low = vceqq_u8(input, vowel_mask_low);\n\n        // Compare with uppercase vowels\n        uint8x16_t cmp_up = vceqq_u8(input, vowel_mask_up);\n\n        // Combine results\n        uint8x16_t result = vorrq_u8(cmp_low, cmp_up);\n\n        // Count matches\n        uint8x16_t mask = vdupq_n_u8(1);\n        uint8x16_t masked_result = vandq_u8(result, mask);\n        uint32x4_t sum_vec = vpaddlq_u16(vpaddlq_u8(masked_result));\n        uint32x2_t sum_vec_reduced = vpadd_u32(vget_low_u32(sum_vec), vget_high_u32(sum_vec));\n        count += vget_lane_u32(sum_vec_reduced, 0);\n    }\n\n    // Handle remaining characters\n    for (; i < len; ++i) {\n        char c = data[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n            c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n\n    // Check if the last character is 'y' or 'Y'\n    if (len > 0 && (data[len - 1] == 'y' || data[len - 1] == 'Y')) {\n        count++;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    int len = s.length();\n    int count = 0;\n\n    // Define vowels and prepare for SIMD comparison\n    uint8x16_t vowels = vld1q_u8((const uint8_t *)\"aeiouAEIOU\");\n    uint8x16_t y_char = vdupq_n_u8('y');\n    uint8x16_t Y_char = vdupq_n_u8('Y');\n\n    // Process the string in chunks of 16 bytes\n    int i = 0;\n    for (; i <= len - 16; i += 16) {\n        uint8x16_t input = vld1q_u8((const uint8_t *)(s.c_str() + i));\n\n        // Compare with vowels\n        uint8x16_t cmp_a = vceqq_u8(input, vld1q_lane_u8(vowels, 0));\n        uint8x16_t cmp_e = vceqq_u8(input, vld1q_lane_u8(vowels, 1));\n        uint8x16_t cmp_i = vceqq_u8(input, vld1q_lane_u8(vowels, 2));\n        uint8x16_t cmp_o = vceqq_u8(input, vld1q_lane_u8(vowels, 3));\n        uint8x16_t cmp_u = vceqq_u8(input, vld1q_lane_u8(vowels, 4));\n        uint8x16_t cmp_A = vceqq_u8(input, vld1q_lane_u8(vowels, 5));\n        uint8x16_t cmp_E = vceqq_u8(input, vld1q_lane_u8(vowels, 6));\n        uint8x16_t cmp_I = vceqq_u8(input, vld1q_lane_u8(vowels, 7));\n        uint8x16_t cmp_O = vceqq_u8(input, vld1q_lane_u8(vowels, 8));\n        uint8x16_t cmp_U = vceqq_u8(input, vld1q_lane_u8(vowels, 9));\n\n        // Combine all comparisons\n        uint8x16_t cmp_result = vorrq_u8(vorrq_u8(vorrq_u8(vorrq_u8(cmp_a, cmp_e), vorrq_u8(cmp_i, cmp_o)), vorrq_u8(cmp_u, cmp_A)), vorrq_u8(vorrq_u8(cmp_E, cmp_I), vorrq_u8(cmp_O, cmp_U)));\n\n        // Count matches\n        uint8x16_t mask = vshrq_n_u8(cmp_result, 7);\n        uint8x8_t sum = vpadd_u8(vget_low_u8(mask), vget_high_u8(mask));\n        sum = vpadd_u8(sum, sum);\n        sum = vpadd_u8(sum, sum);\n        count += vget_lane_u8(sum, 0);\n    }\n\n    // Handle remaining characters\n    for (; i < len; ++i) {\n        char c = s[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n            c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n\n    // Check if the last character is 'y' or 'Y'\n    if (len > 0 && (s[len - 1] == 'y' || s[len - 1] == 'Y')) {\n        count++;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_93_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    int len = s.length();\n    int i = 0;\n\n    // Process 16 characters at a time using NEON intrinsics\n    for (; i <= len - 16; i += 16) {\n        // Load 16 characters into a NEON register\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n\n        // Create a mask for uppercase letters ('A' to 'Z')\n        uint8x16_t lower_bound = vdupq_n_u8('A');\n        uint8x16_t upper_bound = vdupq_n_u8('Z');\n\n        // Compare if chars are >= 'A' and <= 'Z'\n        uint8x16_t is_ge_A = vcgeq_u8(chars, lower_bound);\n        uint8x16_t is_le_Z = vcleq_u8(chars, upper_bound);\n        uint8x16_t is_upper = vandq_u8(is_ge_A, is_le_Z);\n\n        // Zero out non-uppercase characters\n        uint8x16_t masked_chars = vandq_u8(vreinterpretq_u8_u32(vmovl_u8(vget_low_u8(is_upper))), chars);\n\n        // Extract the ASCII values of the uppercase characters\n        uint16x8_t high_half = vmovl_u8(vget_high_u8(masked_chars));\n        uint16x8_t low_half = vmovl_u8(vget_low_u8(masked_chars));\n\n        // Sum the high and low halves\n        uint32x4_t sum_high = vpaddlq_u16(high_half);\n        uint32x4_t sum_low = vpaddlq_u16(low_half);\n\n        // Add the results together\n        uint32x2_t total_sum = vadd_u32(vadd_u32(vget_low_u32(sum_high), vget_high_u32(sum_high)),\n                                         vadd_u32(vget_low_u32(sum_low), vget_high_u32(sum_low)));\n\n        // Accumulate the sum\n        sum += vget_lane_u32(total_sum, 0) + vget_lane_u32(total_sum, 1);\n    }\n\n    // Process remaining characters\n    for (; i < len; ++i) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            sum += s[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    int len = s.length();\n    int i = 0;\n\n    // Process 16 characters at a time using NEON intrinsics\n    for (; i <= len - 16; i += 16) {\n        // Load 16 characters into a NEON register\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n\n        // Create a mask for uppercase letters ('A' to 'Z')\n        uint8x16_t lower_bound = vdupq_n_u8('A');\n        uint8x16_t upper_bound = vdupq_n_u8('Z');\n\n        // Compare if characters are >= 'A' and <= 'Z'\n        uint8x16_t ge_mask = vcgeq_u8(chars, lower_bound);\n        uint8x16_t le_mask = vcleq_u8(chars, upper_bound);\n        uint8x16_t is_upper = vandq_u8(ge_mask, le_mask);\n\n        // Zero out non-uppercase characters\n        uint8x16_t masked_chars = vandq_u8(chars, is_upper);\n\n        // Extract the ASCII values of uppercase characters\n        uint16x8_t sum_high = vpaddlq_u8(masked_chars);\n        uint32x4_t sum_mid = vpaddlq_u16(sum_high);\n        uint64x2_t sum_low = vpaddlq_u32(sum_mid);\n\n        // Accumulate the results into the scalar sum\n        sum += vgetq_lane_u64(sum_low, 0) + vgetq_lane_u64(sum_low, 1);\n    }\n\n    // Process remaining characters (if any)\n    for (; i < len; ++i) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            sum += s[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    int len = s.length();\n    int i = 0;\n\n    // Process 16 characters at a time using NEON intrinsics\n    for (; i <= len - 16; i += 16) {\n        // Load 16 characters into a NEON register\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n\n        // Create a mask for uppercase letters ('A' to 'Z')\n        uint8x16_t lower_bound = vdupq_n_u8('A');\n        uint8x16_t upper_bound = vdupq_n_u8('Z');\n\n        // Compare if characters are >= 'A' and <= 'Z'\n        uint8x16_t ge_mask = vcgeq_u8(chars, lower_bound);\n        uint8x16_t le_mask = vcleq_u8(chars, upper_bound);\n        uint8x16_t is_upper = vandq_u8(ge_mask, le_mask);\n\n        // Zero out non-uppercase characters\n        uint8x16_t masked_chars = vandq_u8(chars, is_upper);\n\n        // Extract the ASCII values of uppercase characters\n        uint16x8_t sum1 = vpaddlq_u8(masked_chars);\n        uint32x4_t sum2 = vpaddlq_u16(sum1);\n        uint64x2_t sum3 = vpaddlq_u32(sum2);\n\n        // Add the results to the total sum\n        sum += vgetq_lane_u64(sum3, 0) + vgetq_lane_u64(sum3, 1);\n    }\n\n    // Process remaining characters (less than 16)\n    for (; i < len; ++i) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            sum += s[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    int len = s.length();\n    int i = 0;\n\n    // Process 16 characters at a time using NEON intrinsics\n    for (; i <= len - 16; i += 16) {\n        // Load 16 characters into a NEON register\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n\n        // Create a mask for uppercase letters ('A' to 'Z')\n        uint8x16_t lower_bound = vmovq_n_u8('A');\n        uint8x16_t upper_bound = vmovq_n_u8('Z');\n\n        // Compare if characters are >= 'A' and <= 'Z'\n        uint8x16_t is_ge_A = vcgeq_u8(chars, lower_bound);\n        uint8x16_t is_le_Z = vcleq_u8(chars, upper_bound);\n        uint8x16_t is_upper = vandq_u8(is_ge_A, is_le_Z);\n\n        // Zero out non-uppercase characters\n        uint8x16_t masked_chars = vandq_u8(vreinterpretq_u8_u32(vmovl_u8(vget_low_u8(is_upper))), chars);\n\n        // Extract the ASCII values of uppercase characters\n        uint16x8_t sum_high = vpaddlq_u8(masked_chars);\n        uint32x4_t sum_mid = vpaddlq_u16(sum_high);\n        uint64x2_t sum_low = vpaddlq_u32(sum_mid);\n\n        // Accumulate the results into the scalar sum\n        sum += vgetq_lane_u64(sum_low, 0) + vgetq_lane_u64(sum_low, 1);\n    }\n\n    // Process remaining characters (if any)\n    for (; i < len; ++i) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            sum += s[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    int len = s.length();\n    int i = 0;\n\n    // Process 16 characters at a time using NEON intrinsics\n    for (; i <= len - 16; i += 16) {\n        // Load 16 characters into a NEON register\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n\n        // Create a mask for uppercase letters ('A' to 'Z')\n        uint8x16_t lower_bound = vdupq_n_u8('A');\n        uint8x16_t upper_bound = vdupq_n_u8('Z');\n\n        // Check if characters are in the range 'A' to 'Z'\n        uint8x16_t is_upper = vandq_u8(vcgeq_u8(chars, lower_bound), vcleq_u8(chars, upper_bound));\n\n        // Zero out non-uppercase characters\n        uint8x16_t masked_chars = vandq_u8(chars, is_upper);\n\n        // Extract the ASCII values of uppercase characters and add them to the sum\n        uint16x8_t sum_high = vpaddlq_u8(masked_chars);\n        uint32x4_t sum_mid = vpaddlq_u16(sum_high);\n        uint64x2_t sum_low = vpaddlq_u32(sum_mid);\n\n        // Accumulate the results into the scalar sum\n        sum += vgetq_lane_u64(sum_low, 0) + vgetq_lane_u64(sum_low, 1);\n    }\n\n    // Process remaining characters (if any)\n    for (; i < len; ++i) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            sum += s[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_94_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n\n    int min_val = std::numeric_limits<int>::max();\n    int min_idx = -1;\n    int n = arr.size();\n\n    // Process 4 elements at a time using NEON intrinsics\n    int i = 0;\n    for (; i <= n - 4; i += 4) {\n        // Load 4 integers into a NEON register\n        int32x4_t vec = vld1q_s32(&arr[i]);\n\n        // Create a mask to identify even numbers\n        uint32x4_t even_mask = vandq_u32(vreinterpretq_u32_s32(vec), vdupq_n_u32(1));\n        even_mask = vmvnq_u32(even_mask); // Invert the mask to get true for even numbers\n\n        // Replace odd numbers with a large value to ignore them in the comparison\n        int32x4_t large_val = vdupq_n_s32(std::numeric_limits<int>::max());\n        int32x4_t masked_vec = vbslq_s32(even_mask, vec, large_val);\n\n        // Find the minimum value in the vector\n        int32x2_t min_pair = vmin_s32(vget_low_s32(masked_vec), vget_high_s32(masked_vec));\n        int32x2_t min_val_s2 = vpmin_s32(min_pair, min_pair);\n        int min_val_current = vget_lane_s32(min_val_s2, 0);\n\n        // If the current minimum is smaller than the global minimum, update\n        if (min_val_current < min_val) {\n            // Find the index of the smallest even value in the current vector\n            for (int j = 0; j < 4; ++j) {\n                if (arr[i + j] == min_val_current) {\n                    min_val = min_val_current;\n                    min_idx = i + j;\n                    break;\n                }\n            }\n        }\n    }\n\n    // Process remaining elements (if any)\n    for (; i < n; ++i) {\n        if (arr[i] % 2 == 0 && arr[i] < min_val) {\n            min_val = arr[i];\n            min_idx = i;\n        }\n    }\n\n    // If no even value was found, return an empty vector\n    if (min_idx == -1) return {};\n\n    return {min_val, min_idx};\n}\n```"}
{"task_id": "SimdBench_94_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n\n    int min_val = std::numeric_limits<int>::max();\n    int min_idx = -1;\n    int n = arr.size();\n\n    // Process 4 elements at a time using NEON intrinsics\n    int i = 0;\n    for (; i <= n - 4; i += 4) {\n        // Load 4 integers into a NEON register\n        int32x4_t vec = vld1q_s32(&arr[i]);\n\n        // Create a mask for even numbers (value & 1 == 0)\n        uint32x4_t even_mask = vandq_u32(vreinterpretq_u32_s32(vec), vdupq_n_u32(1));\n        even_mask = vmvnq_u32(even_mask); // Invert the mask to get true for even numbers\n\n        // Extract even values, set odd values to max int\n        int32x4_t even_vals = vbslq_s32(even_mask, vec, vdupq_n_s32(std::numeric_limits<int>::max()));\n\n        // Find the minimum value among the 4 elements\n        int32x2_t min_pair = vpmin_s32(vget_low_s32(even_vals), vget_high_s32(even_vals));\n        min_pair = vpmin_s32(min_pair, min_pair);\n        int current_min = vget_lane_s32(min_pair, 0);\n\n        // If a new minimum is found, update min_val and min_idx\n        if (current_min < min_val) {\n            for (int j = 0; j < 4; ++j) {\n                if (arr[i + j] == current_min && arr[i + j] % 2 == 0) {\n                    min_val = current_min;\n                    min_idx = i + j;\n                    break;\n                }\n            }\n        }\n    }\n\n    // Process remaining elements (if any)\n    for (; i < n; ++i) {\n        if (arr[i] % 2 == 0 && arr[i] < min_val) {\n            min_val = arr[i];\n            min_idx = i;\n        }\n    }\n\n    // If no even value was found, return an empty vector\n    if (min_idx == -1) return {};\n\n    return {min_val, min_idx};\n}\n```"}
{"task_id": "SimdBench_94_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int min_even = std::numeric_limits<int>::max();\n    int min_index = -1;\n    int n = arr.size();\n\n    // Process 4 elements at a time using NEON intrinsics\n    int i = 0;\n    for (; i <= n - 4; i += 4) {\n        // Load 4 integers into a NEON register\n        int32x4_t vec = vld1q_s32(&arr[i]);\n\n        // Create a mask to identify even numbers\n        uint32x4_t even_mask = vandq_u32(vreinterpretq_u32_s32(vec), vdupq_n_u32(1));\n        even_mask = vmvnq_u32(even_mask); // Invert the mask to get true for even numbers\n\n        // Extract the even values, replacing odd values with a large number\n        int32x4_t even_values = vbslq_s32(even_mask, vec, vdupq_n_s32(std::numeric_limits<int>::max()));\n\n        // Find the minimum value among the 4 elements\n        int32x2_t min_val_low = vpmin_s32(vget_low_s32(even_values), vget_high_s32(even_values));\n        int32x2_t min_val = vpmin_s32(min_val_low, min_val_low);\n        int current_min = vget_lane_s32(min_val, 0);\n\n        // If the current minimum is smaller than the global minimum, update\n        if (current_min < min_even) {\n            // Find the index of the smallest even value in the current vector\n            for (int j = 0; j < 4; ++j) {\n                if (arr[i + j] == current_min && arr[i + j] % 2 == 0) {\n                    min_even = current_min;\n                    min_index = i + j;\n                    break;\n                }\n            }\n        }\n    }\n\n    // Process remaining elements (if any)\n    for (; i < n; ++i) {\n        if (arr[i] % 2 == 0 && arr[i] < min_even) {\n            min_even = arr[i];\n            min_index = i;\n        }\n    }\n\n    // If no even value was found, return an empty vector\n    if (min_index == -1) {\n        return {};\n    }\n\n    return {min_even, min_index};\n}\n```"}
{"task_id": "SimdBench_94_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int min_even = std::numeric_limits<int>::max();\n    int min_index = -1;\n    int n = arr.size();\n\n    // Process 4 elements at a time using NEON intrinsics\n    int i = 0;\n    for (; i <= n - 4; i += 4) {\n        // Load 4 integers into a NEON register\n        int32x4_t vec = vld1q_s32(&arr[i]);\n\n        // Create a mask to identify even numbers\n        uint32x4_t even_mask = vandq_u32(vreinterpretq_u32_s32(vec), vdupq_n_u32(1));\n        even_mask = vmvnq_u32(even_mask); // Invert the mask to get true for even numbers\n\n        // Extract even numbers, set odd numbers to max value\n        int32x4_t even_values = vbslq_s32(even_mask, vec, vdupq_n_s32(std::numeric_limits<int>::max()));\n\n        // Find the minimum value among the 4 elements\n        int32x2_t min_pair = vpmin_s32(vget_low_s32(even_values), vget_high_s32(even_values));\n        int32x2_t min_single = vpmin_s32(min_pair, min_pair);\n        int current_min = vget_lane_s32(min_single, 0);\n\n        // If a new minimum is found, update min_even and min_index\n        if (current_min < min_even) {\n            for (int j = 0; j < 4; ++j) {\n                if (arr[i + j] == current_min && arr[i + j] % 2 == 0) {\n                    min_even = current_min;\n                    min_index = i + j;\n                    break;\n                }\n            }\n        }\n    }\n\n    // Process remaining elements (if any)\n    for (; i < n; ++i) {\n        if (arr[i] % 2 == 0 && arr[i] < min_even) {\n            min_even = arr[i];\n            min_index = i;\n        }\n    }\n\n    // If no even number was found, return an empty vector\n    if (min_index == -1) {\n        return {};\n    }\n\n    return {min_even, min_index};\n}\n```"}
{"task_id": "SimdBench_94_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n\n    int min_even = std::numeric_limits<int>::max();\n    int min_index = -1;\n    int n = arr.size();\n\n    // Process 4 elements at a time using NEON intrinsics\n    int i = 0;\n    for (; i <= n - 4; i += 4) {\n        // Load 4 integers into a NEON register\n        int32x4_t vec = vld1q_s32(&arr[i]);\n\n        // Create a mask for even numbers (value & 1 == 0)\n        uint32x4_t even_mask = vandq_u32(vreinterpretq_u32_s32(vec), vdupq_n_u32(1));\n        even_mask = vmvnq_u32(even_mask); // Invert the mask to get true for even numbers\n\n        // Extract even values using the mask\n        int32x4_t even_values = vbslq_s32(even_mask, vec, vdupq_n_s32(std::numeric_limits<int>::max()));\n\n        // Find the minimum value among the even numbers in this vector\n        int32x2_t min_val_low = vpmin_s32(vget_low_s32(even_values), vget_high_s32(even_values));\n        int32x2_t min_val = vpmin_s32(min_val_low, min_val_low);\n        int current_min = vget_lane_s32(min_val, 0);\n\n        // If the current minimum is smaller than the global minimum, update\n        if (current_min < min_even) {\n            // Find the index of the smallest even value in this vector\n            for (int j = 0; j < 4; ++j) {\n                if (arr[i + j] == current_min && arr[i + j] % 2 == 0) {\n                    min_even = current_min;\n                    min_index = i + j;\n                    break;\n                }\n            }\n        }\n    }\n\n    // Process remaining elements (if any)\n    for (; i < n; ++i) {\n        if (arr[i] % 2 == 0 && arr[i] < min_even) {\n            min_even = arr[i];\n            min_index = i;\n        }\n    }\n\n    // If no even number was found, return an empty vector\n    if (min_index == -1) return {};\n\n    return {min_even, min_index};\n}\n```"}
{"task_id": "SimdBench_95_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    int max_val = *std::max_element(lst.begin(), lst.end());\n    std::vector<int> freq(max_val + 1, 0);\n\n    // Process the input list in chunks of 4 using NEON intrinsics\n    int i = 0;\n    int size = lst.size();\n    for (; i <= size - 4; i += 4) {\n        // Load 4 integers from the list into a NEON register\n        int32x4_t vec = vld1q_s32(&lst[i]);\n\n        // Extract each lane and update frequency count\n        freq[vgetq_lane_s32(vec, 0)]++;\n        freq[vgetq_lane_s32(vec, 1)]++;\n        freq[vgetq_lane_s32(vec, 2)]++;\n        freq[vgetq_lane_s32(vec, 3)]++;\n    }\n\n    // Process remaining elements that don't fit into a full NEON register\n    for (; i < size; ++i) {\n        freq[lst[i]]++;\n    }\n\n    // Find the largest integer with frequency >= value\n    int result = -1;\n    for (int val = 1; val <= max_val; ++val) {\n        if (freq[val] >= val) {\n            result = std::max(result, val);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_95_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    int max_val = *std::max_element(lst.begin(), lst.end());\n    std::vector<int> freq(max_val + 1, 0);\n\n    // Count frequency of each element using NEON intrinsics\n    int i = 0;\n    int size = lst.size();\n    for (; i <= size - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        int32x4_t indices = vec;\n\n        for (int j = 0; j < 4; ++j) {\n            int val = vgetq_lane_s32(indices, j);\n            if (val > 0 && val <= max_val) {\n                freq[val]++;\n            }\n        }\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        int val = lst[i];\n        if (val > 0 && val <= max_val) {\n            freq[val]++;\n        }\n    }\n\n    // Find the greatest integer with frequency >= value\n    int result = -1;\n    for (int val = max_val; val > 0; --val) {\n        if (freq[val] >= val) {\n            result = val;\n            break;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_95_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    int max_val = *std::max_element(lst.begin(), lst.end());\n    std::vector<int> freq(max_val + 1, 0);\n\n    // Count frequency using NEON intrinsics\n    int i = 0;\n    int size = lst.size();\n    for (; i <= size - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        int32x4_t indices = {0, 1, 2, 3};\n        for (int j = 0; j < 4; ++j) {\n            int val = vgetq_lane_s32(vec, j);\n            freq[val]++;\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        freq[lst[i]]++;\n    }\n\n    // Find the greatest integer with frequency >= value\n    int result = -1;\n    for (int val = 1; val <= max_val; ++val) {\n        if (freq[val] >= val) {\n            result = std::max(result, val);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_95_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    int max_val = *std::max_element(lst.begin(), lst.end());\n    std::vector<int> freq(max_val + 1, 0);\n\n    // Process the input list in chunks of 4 using NEON intrinsics\n    int i = 0;\n    int size = lst.size();\n    for (; i <= size - 4; i += 4) {\n        // Load 4 integers from the list into a NEON register\n        int32x4_t vec = vld1q_s32(&lst[i]);\n\n        // Extract each lane and update frequency count\n        freq[vgetq_lane_s32(vec, 0)]++;\n        freq[vgetq_lane_s32(vec, 1)]++;\n        freq[vgetq_lane_s32(vec, 2)]++;\n        freq[vgetq_lane_s32(vec, 3)]++;\n    }\n\n    // Process remaining elements (if any)\n    for (; i < size; ++i) {\n        freq[lst[i]]++;\n    }\n\n    // Find the largest integer with frequency >= value\n    int result = -1;\n    for (int val = 1; val <= max_val; ++val) {\n        if (freq[val] >= val) {\n            result = std::max(result, val);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_95_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    int max_val = *std::max_element(lst.begin(), lst.end());\n    std::vector<int> freq(max_val + 1, 0);\n\n    // Count frequency of each element\n    for (size_t i = 0; i < lst.size(); i++) {\n        freq[lst[i]]++;\n    }\n\n    int result = -1;\n\n    // Process in chunks of 4 using NEON intrinsics\n    int vec_size = max_val + 1;\n    int simd_width = 4;\n    int limit = vec_size - (vec_size % simd_width);\n\n    for (int i = 1; i < limit; i += simd_width) {\n        // Load 4 integers from the frequency array\n        int32x4_t freq_vec = vld1q_s32(&freq[i]);\n\n        // Create a vector with values [i, i+1, i+2, i+3]\n        int32x4_t index_vec = vaddq_s32(vdupq_n_s32(i), vld1q_s32((int32_t[]){0, 1, 2, 3}));\n\n        // Compare frequency >= index\n        uint32x4_t cmp_vec = vcgeq_s32(freq_vec, index_vec);\n\n        // Extract results from comparison mask\n        uint32_t mask = vmovemaskq_u32(cmp_vec);\n        if (mask != 0) {\n            for (int j = 0; j < simd_width; ++j) {\n                if (mask & (1 << j)) {\n                    result = std::max(result, i + j);\n                }\n            }\n        }\n    }\n\n    // Handle remaining elements\n    for (int i = limit; i <= max_val; ++i) {\n        if (freq[i] >= i) {\n            result = std::max(result, i);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_96_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    int sum = 0;\n    bool is_palindromic = true;\n\n    // Process 4 elements at a time using NEON intrinsics\n    int i = 0;\n    for (; i <= n - 4; i += 4) {\n        // Load 4 elements from the vector\n        int32x4_t vec = vld1q_s32(&q[i]);\n\n        // Add the elements to the sum\n        int32x4_t sum_vec = vmovq_n_s32(0);\n        sum_vec = vaddq_s32(sum_vec, vec);\n        sum += vaddvq_s32(sum_vec);\n\n        // Check palindromic property\n        int32x4_t reverse_vec = vld1q_s32(&q[n - i - 4]);\n        reverse_vec = vrev64q_s32(reverse_vec);\n        uint32x4_t cmp = vceqq_s32(vec, reverse_vec);\n        if (vminvq_u32(cmp) == 0) {\n            is_palindromic = false;\n            break;\n        }\n    }\n\n    // Process remaining elements\n    for (; i < n; ++i) {\n        sum += q[i];\n        if (q[i] != q[n - i - 1]) {\n            is_palindromic = false;\n            break;\n        }\n    }\n\n    // Check conditions\n    return is_palindromic && (sum <= w);\n}\n```"}
{"task_id": "SimdBench_96_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    int sum = 0;\n    bool balanced = true;\n\n    // Process 4 elements at a time using NEON intrinsics\n    int i = 0;\n    for (; i <= n - 4; i += 4) {\n        // Load 4 elements from the vector\n        int32x4_t vec = vld1q_s32(&q[i]);\n\n        // Add the elements to the sum\n        int32x4_t sum_vec = vmovq_n_s32(0);\n        sum_vec = vaddq_s32(sum_vec, vec);\n        sum += vaddvq_s32(sum_vec);\n\n        // Compare the elements for balance\n        int32x4_t reverse_vec = vld1q_s32(&q[n - i - 4]);\n        uint32x4_t cmp = vceqq_s32(vec, vrev64q_s32(reverse_vec));\n        if (vaddvq_u32(cmp) != 4) {\n            balanced = false;\n        }\n    }\n\n    // Process remaining elements\n    for (; i < n; ++i) {\n        sum += q[i];\n        if (q[i] != q[n - i - 1]) {\n            balanced = false;\n        }\n    }\n\n    // Check conditions\n    return balanced && (sum <= w);\n}\n```"}
{"task_id": "SimdBench_96_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    int sum = 0;\n    bool is_palindromic = true;\n\n    // Process 4 elements at a time using NEON intrinsics\n    int i = 0;\n    for (; i <= n - 4; i += 4) {\n        // Load 4 elements from the vector\n        int32x4_t vec = vld1q_s32(&q[i]);\n\n        // Add the elements to the sum\n        int32x4_t sum_vec = vmovq_n_s32(0);\n        sum_vec = vaddq_s32(sum_vec, vec);\n        sum += vaddvq_s32(sum_vec);\n\n        // Check palindromic property\n        int32x4_t reverse_vec = vld1q_s32(&q[n - i - 4]);\n        reverse_vec = vrev64q_s32(reverse_vec);\n        uint32x4_t cmp = vceqq_s32(vec, reverse_vec);\n        if (vgetq_lane_u32(cmp, 0) == 0 || vgetq_lane_u32(cmp, 1) == 0 ||\n            vgetq_lane_u32(cmp, 2) == 0 || vgetq_lane_u32(cmp, 3) == 0) {\n            is_palindromic = false;\n            break;\n        }\n    }\n\n    // Process remaining elements\n    for (; i < n; ++i) {\n        sum += q[i];\n        if (q[i] != q[n - i - 1]) {\n            is_palindromic = false;\n            break;\n        }\n    }\n\n    return is_palindromic && (sum <= w);\n}\n```"}
{"task_id": "SimdBench_96_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    int sum = 0;\n    bool is_palindromic = true;\n\n    // Process 4 elements at a time using NEON intrinsics\n    int i = 0;\n    for (; i <= n - 4; i += 4) {\n        // Load 4 elements from the vector\n        int32x4_t vec = vld1q_s32(&q[i]);\n\n        // Add the elements to calculate the sum\n        int32x4_t sum_vec = vmovq_n_s32(0);\n        sum_vec = vaddq_s32(sum_vec, vec);\n        sum += vaddvq_s32(sum_vec);\n\n        // Check if the elements are palindromic\n        int32x4_t reverse_vec = vrev64q_s32(vec);\n        uint32x4_t cmp = vceqq_s32(vec, reverse_vec);\n        if (vgetq_lane_u32(cmp, 0) == 0 || vgetq_lane_u32(cmp, 1) == 0 ||\n            vgetq_lane_u32(cmp, 2) == 0 || vgetq_lane_u32(cmp, 3) == 0) {\n            is_palindromic = false;\n            break;\n        }\n    }\n\n    // Process remaining elements\n    for (; i < n; ++i) {\n        sum += q[i];\n        if (q[i] != q[n - i - 1]) {\n            is_palindromic = false;\n            break;\n        }\n    }\n\n    // Check conditions\n    return is_palindromic && (sum <= w);\n}\n```"}
{"task_id": "SimdBench_96_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    int sum = 0;\n    bool is_palindromic = true;\n\n    // Process 4 elements at a time using NEON intrinsics\n    int i = 0;\n    for (; i <= n - 4; i += 4) {\n        // Load 4 elements from the vector\n        int32x4_t vec = vld1q_s32(&q[i]);\n\n        // Add the elements to the sum\n        int32x4_t sum_vec = vmovq_n_s32(0);\n        sum_vec = vaddq_s32(sum_vec, vec);\n        sum += vaddvq_s32(sum_vec);\n\n        // Check palindromic property\n        int32x4_t reverse_vec = vld1q_s32(&q[n - i - 4]);\n        reverse_vec = vrev64q_s32(reverse_vec);\n        uint32x4_t cmp = vceqq_s32(vec, reverse_vec);\n        if (vminvq_u32(cmp) == 0) {\n            is_palindromic = false;\n            break;\n        }\n    }\n\n    // Process remaining elements\n    for (; i < n; ++i) {\n        sum += q[i];\n        if (q[i] != q[n - i - 1]) {\n            is_palindromic = false;\n            break;\n        }\n    }\n\n    // Check conditions\n    return is_palindromic && (sum <= w);\n}\n```"}
{"task_id": "SimdBench_97_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    int i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= n - 8; i += 8) {\n        // Load 8 elements from the start and end of the current window\n        int32x4_t vec_start1 = vld1q_s32(&arr[i]);\n        int32x4_t vec_end1 = vld1q_s32(&arr[n - i - 4]);\n\n        int32x4_t vec_start2 = vld1q_s32(&arr[i + 4]);\n        int32x4_t vec_end2 = vld1q_s32(&arr[n - i - 8]);\n\n        // Reverse the order of elements in vec_end1 and vec_end2\n        vec_end1 = vrev64q_s32(vec_end1);\n        vec_end2 = vrev64q_s32(vec_end2);\n\n        // Compare vec_start1 with vec_end1 and vec_start2 with vec_end2\n        uint32x4_t cmp1 = vceqq_s32(vec_start1, vec_end1);\n        uint32x4_t cmp2 = vceqq_s32(vec_start2, vec_end2);\n\n        // Count mismatches\n        uint8x16_t cmp_result = vcombine_u8(vmovn_u16(vreinterpretq_u16_u32(cmp1)),\n                                            vmovn_u16(vreinterpretq_u16_u32(cmp2)));\n        uint8x16_t ones = vdupq_n_u8(1);\n        uint8x16_t mismatches = veorq_u8(cmp_result, ones);\n\n        // Sum mismatches\n        uint32x4_t sum_mismatches = vpaddlq_u16(vpaddlq_u8(mismatches));\n        uint64x2_t sum_total = vpaddlq_u32(sum_mismatches);\n        changes += vgetq_lane_u64(sum_total, 0) + vgetq_lane_u64(sum_total, 1);\n    }\n\n    // Process remaining elements\n    for (; i < n / 2; ++i) {\n        if (arr[i] != arr[n - i - 1]) {\n            ++changes;\n        }\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    int i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= n - 8; i += 8) {\n        // Load 8 elements from the start and end of the array\n        int32x4_t vec_start1 = vld1q_s32(&arr[i]);\n        int32x4_t vec_end1 = vld1q_s32(&arr[n - i - 4]);\n        int32x4_t vec_start2 = vld1q_s32(&arr[i + 4]);\n        int32x4_t vec_end2 = vld1q_s32(&arr[n - i - 8]);\n\n        // Reverse the order of the end vectors\n        vec_end1 = vrev64q_s32(vec_end1);\n        vec_end2 = vrev64q_s32(vec_end2);\n\n        // Compare the start and reversed end vectors\n        uint32x4_t cmp1 = vceqq_s32(vec_start1, vec_end1);\n        uint32x4_t cmp2 = vceqq_s32(vec_start2, vec_end2);\n\n        // Count the number of mismatches\n        uint32x4_t mask1 = vmvnq_u32(cmp1);\n        uint32x4_t mask2 = vmvnq_u32(cmp2);\n\n        // Sum the mismatches\n        uint32x4_t sum_mask = vaddq_u32(mask1, mask2);\n        uint32x2_t sum_low = vpadd_u32(vget_low_u32(sum_mask), vget_high_u32(sum_mask));\n        uint32x2_t sum_final = vpadd_u32(sum_low, sum_low);\n\n        // Add the total mismatches to the changes counter\n        changes += vget_lane_u32(sum_final, 0);\n    }\n\n    // Process remaining elements (if any)\n    for (; i < n / 2; ++i) {\n        if (arr[i] != arr[n - i - 1]) {\n            ++changes;\n        }\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    int i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= n - 8; i += 8) {\n        // Load 8 elements from the start and end of the current window\n        int32x4_t vec_start1 = vld1q_s32(&arr[i]);\n        int32x4_t vec_end1 = vld1q_s32(&arr[n - i - 4]);\n\n        int32x4_t vec_start2 = vld1q_s32(&arr[i + 4]);\n        int32x4_t vec_end2 = vld1q_s32(&arr[n - i - 8]);\n\n        // Reverse the order of elements in vec_end1 and vec_end2\n        int32x4_t vec_end1_rev = vrev64q_s32(vec_end1);\n        int32x4_t vec_end2_rev = vrev64q_s32(vec_end2);\n\n        // Compare vec_start1 with vec_end1_rev and vec_start2 with vec_end2_rev\n        uint32x4_t cmp1 = vceqq_s32(vec_start1, vec_end1_rev);\n        uint32x4_t cmp2 = vceqq_s32(vec_start2, vec_end2_rev);\n\n        // Count mismatches\n        uint32x4_t mask1 = vmvnq_u32(cmp1);\n        uint32x4_t mask2 = vmvnq_u32(cmp2);\n\n        // Sum mismatches\n        uint32_t mismatch_count1 = vaddvq_u32(mask1);\n        uint32_t mismatch_count2 = vaddvq_u32(mask2);\n\n        changes += __builtin_popcount(mismatch_count1) + __builtin_popcount(mismatch_count2);\n    }\n\n    // Process remaining elements (if any)\n    for (; i < n / 2; ++i) {\n        if (arr[i] != arr[n - i - 1]) {\n            changes++;\n        }\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    int i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= n - 8; i += 8) {\n        // Load 8 elements from the start and end of the array\n        int32x4_t vec1 = vld1q_s32(&arr[i]);\n        int32x4_t vec2 = vld1q_s32(&arr[n - i - 4]);\n\n        // Reverse the second vector (vec2)\n        int32x4_t reversed_vec2 = vrev64q_s32(vec2);\n\n        // Compare the two vectors for equality\n        uint32x4_t cmp1 = vceqq_s32(vec1, reversed_vec2);\n\n        // Load the next 4 elements for comparison\n        int32x4_t vec3 = vld1q_s32(&arr[i + 4]);\n        int32x4_t vec4 = vld1q_s32(&arr[n - i - 8]);\n\n        // Reverse the second vector (vec4)\n        int32x4_t reversed_vec4 = vrev64q_s32(vec4);\n\n        // Compare the two vectors for equality\n        uint32x4_t cmp2 = vceqq_s32(vec3, reversed_vec4);\n\n        // Combine the comparison results\n        uint32x4_t combined_cmp = vandq_u32(cmp1, cmp2);\n\n        // Count the number of non-matching elements\n        uint32_t mask1 = ~vgetq_lane_u32(combined_cmp, 0);\n        uint32_t mask2 = ~vgetq_lane_u32(combined_cmp, 1);\n        uint32_t mask3 = ~vgetq_lane_u32(combined_cmp, 2);\n        uint32_t mask4 = ~vgetq_lane_u32(combined_cmp, 3);\n\n        changes += __builtin_popcount(mask1) + __builtin_popcount(mask2) +\n                   __builtin_popcount(mask3) + __builtin_popcount(mask4);\n    }\n\n    // Process remaining elements\n    for (; i < n / 2; ++i) {\n        if (arr[i] != arr[n - i - 1]) {\n            ++changes;\n        }\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    int i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= n - 8; i += 8) {\n        // Load 8 elements from the start and end of the current window\n        int32x4_t vec1 = vld1q_s32(&arr[i]);\n        int32x4_t vec2 = vld1q_s32(&arr[n - i - 4]);\n\n        // Reverse the second vector (vec2)\n        int32x4_t reversed_vec2 = vrev64q_s32(vec2);\n        reversed_vec2 = vcombine_s32(vget_high_s32(reversed_vec2), vget_low_s32(reversed_vec2));\n\n        // Compare the two vectors for equality\n        uint32x4_t cmp1 = vceqq_s32(vec1, reversed_vec2);\n\n        // Load the next 4 elements\n        int32x4_t vec3 = vld1q_s32(&arr[i + 4]);\n        int32x4_t vec4 = vld1q_s32(&arr[n - i - 8]);\n\n        // Reverse the second vector (vec4)\n        int32x4_t reversed_vec4 = vrev64q_s32(vec4);\n        reversed_vec4 = vcombine_s32(vget_high_s32(reversed_vec4), vget_low_s32(reversed_vec4));\n\n        // Compare the two vectors for equality\n        uint32x4_t cmp2 = vceqq_s32(vec3, reversed_vec4);\n\n        // Combine the comparison results\n        uint64x2_t combined_cmp = vreinterpretq_u64_u32(vcombine_u32(vget_low_u32(cmp1), vget_low_u32(cmp2)));\n\n        // Count the number of mismatches\n        uint8x16_t mask = vreinterpretq_u8_u64(combined_cmp);\n        int mismatch_count = 16 - vaddvq_u8(vcntq_u8(mask));\n        changes += mismatch_count;\n    }\n\n    // Process remaining elements (if any)\n    for (; i < n / 2; ++i) {\n        if (arr[i] != arr[n - i - 1]) {\n            ++changes;\n        }\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_98_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    uint32_t total1 = 0, total2 = 0;\n\n    // Process lst1\n    for (const auto& str : lst1) {\n        size_t len = str.size();\n        uint32x4_t v_total = vmovq_n_u32(0);\n\n        for (size_t i = 0; i < len; i += 16) {\n            uint8x16_t v_chars = vld1q_u8(reinterpret_cast<const uint8_t*>(str.data() + i));\n            uint8x16_t v_mask = vceqq_u8(v_chars, vdupq_n_u8(0)); // Compare with null terminator\n            uint8x16_t v_not_mask = vmvnq_u8(v_mask);             // Invert mask\n            uint32x4_t v_sum = vpaddlq_u16(vpaddlq_u8(v_not_mask));\n            v_total = vaddq_u32(v_total, v_sum);\n        }\n\n        uint32_t temp[4];\n        vst1q_u32(temp, v_total);\n        total1 += temp[0] + temp[1] + temp[2] + temp[3];\n    }\n\n    // Process lst2\n    for (const auto& str : lst2) {\n        size_t len = str.size();\n        uint32x4_t v_total = vmovq_n_u32(0);\n\n        for (size_t i = 0; i < len; i += 16) {\n            uint8x16_t v_chars = vld1q_u8(reinterpret_cast<const uint8_t*>(str.data() + i));\n            uint8x16_t v_mask = vceqq_u8(v_chars, vdupq_n_u8(0)); // Compare with null terminator\n            uint8x16_t v_not_mask = vmvnq_u8(v_mask);             // Invert mask\n            uint32x4_t v_sum = vpaddlq_u16(vpaddlq_u8(v_not_mask));\n            v_total = vaddq_u32(v_total, v_sum);\n        }\n\n        uint32_t temp[4];\n        vst1q_u32(temp, v_total);\n        total2 += temp[0] + temp[1] + temp[2] + temp[3];\n    }\n\n    return (total1 <= total2) ? lst1 : lst2;\n}\n```"}
{"task_id": "SimdBench_98_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    int total1 = 0, total2 = 0;\n\n    // Process lst1\n    for (const auto& str : lst1) {\n        int len = str.length();\n        int i = 0;\n        for (; i + 16 <= len; i += 16) {\n            uint8x16_t v = vld1q_u8(reinterpret_cast<const uint8_t*>(str.data() + i));\n            uint8x16_t v_zero = vmovq_n_u8(0);\n            total1 += 16 - vaddvq_u8(vceqq_u8(v, v_zero));\n        }\n        total1 += len - i;\n    }\n\n    // Process lst2\n    for (const auto& str : lst2) {\n        int len = str.length();\n        int i = 0;\n        for (; i + 16 <= len; i += 16) {\n            uint8x16_t v = vld1q_u8(reinterpret_cast<const uint8_t*>(str.data() + i));\n            uint8x16_t v_zero = vmovq_n_u8(0);\n            total2 += 16 - vaddvq_u8(vceqq_u8(v, v_zero));\n        }\n        total2 += len - i;\n    }\n\n    return (total1 <= total2) ? lst1 : lst2;\n}\n```"}
{"task_id": "SimdBench_98_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    uint32_t total1 = 0, total2 = 0;\n\n    // Process lst1\n    for (const auto& str : lst1) {\n        size_t len = str.size();\n        uint32x4_t v_total = vmovq_n_u32(0);\n\n        for (size_t i = 0; i < len; i += 16) {\n            uint8x16_t v_chars = vld1q_u8(reinterpret_cast<const uint8_t*>(str.data() + i));\n            uint8x16_t v_mask = vceqq_u8(v_chars, vdupq_n_u8(0)); // Compare with null terminator\n            uint8x16_t v_not_mask = vmvnq_u8(v_mask);             // Invert mask\n            uint32x4_t v_sum = vpaddlq_u16(vpaddlq_u8(v_not_mask));\n            v_total = vaddq_u32(v_total, v_sum);\n        }\n\n        uint32_t temp[4];\n        vst1q_u32(temp, v_total);\n        total1 += temp[0] + temp[1] + temp[2] + temp[3];\n    }\n\n    // Process lst2\n    for (const auto& str : lst2) {\n        size_t len = str.size();\n        uint32x4_t v_total = vmovq_n_u32(0);\n\n        for (size_t i = 0; i < len; i += 16) {\n            uint8x16_t v_chars = vld1q_u8(reinterpret_cast<const uint8_t*>(str.data() + i));\n            uint8x16_t v_mask = vceqq_u8(v_chars, vdupq_n_u8(0)); // Compare with null terminator\n            uint8x16_t v_not_mask = vmvnq_u8(v_mask);             // Invert mask\n            uint32x4_t v_sum = vpaddlq_u16(vpaddlq_u8(v_not_mask));\n            v_total = vaddq_u32(v_total, v_sum);\n        }\n\n        uint32_t temp[4];\n        vst1q_u32(temp, v_total);\n        total2 += temp[0] + temp[1] + temp[2] + temp[3];\n    }\n\n    return (total1 <= total2) ? lst1 : lst2;\n}\n```"}
{"task_id": "SimdBench_98_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    int total1 = 0, total2 = 0;\n\n    // Process lst1\n    for (const auto& str : lst1) {\n        int len = str.size();\n        int i = 0;\n        // Process in chunks of 16 characters using NEON\n        for (; i <= len - 16; i += 16) {\n            uint8x16_t v = vld1q_u8(reinterpret_cast<const uint8_t*>(str.data() + i));\n            uint8x16_t mask = vceqq_u8(v, v); // All ones\n            total1 += 16;\n        }\n        // Process remaining characters\n        total1 += len - i;\n    }\n\n    // Process lst2\n    for (const auto& str : lst2) {\n        int len = str.size();\n        int i = 0;\n        // Process in chunks of 16 characters using NEON\n        for (; i <= len - 16; i += 16) {\n            uint8x16_t v = vld1q_u8(reinterpret_cast<const uint8_t*>(str.data() + i));\n            uint8x16_t mask = vceqq_u8(v, v); // All ones\n            total2 += 16;\n        }\n        // Process remaining characters\n        total2 += len - i;\n    }\n\n    // Compare totals and return the appropriate vector\n    if (total1 <= total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    uint32_t total1 = 0, total2 = 0;\n\n    // Process lst1\n    for (const auto& str : lst1) {\n        size_t len = str.size();\n        size_t i = 0;\n        // Process in chunks of 16 bytes using NEON\n        for (; i + 16 <= len; i += 16) {\n            uint8x16_t v = vld1q_u8(reinterpret_cast<const uint8_t*>(str.data() + i));\n            uint8x16_t mask = vceqq_u8(v, v); // All lanes are valid characters\n            total1 += 16 - vaddvq_u8(vcntq_u8(mask)); // Count non-zero lanes\n        }\n        // Process remaining characters\n        total1 += len - i;\n    }\n\n    // Process lst2\n    for (const auto& str : lst2) {\n        size_t len = str.size();\n        size_t i = 0;\n        // Process in chunks of 16 bytes using NEON\n        for (; i + 16 <= len; i += 16) {\n            uint8x16_t v = vld1q_u8(reinterpret_cast<const uint8_t*>(str.data() + i));\n            uint8x16_t mask = vceqq_u8(v, v); // All lanes are valid characters\n            total2 += 16 - vaddvq_u8(vcntq_u8(mask)); // Count non-zero lanes\n        }\n        // Process remaining characters\n        total2 += len - i;\n    }\n\n    // Compare totals and return the appropriate vector\n    if (total1 <= total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_99_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n <= 1) {\n        return x == 1;\n    }\n\n    uint64x2_t vx = vdupq_n_u64(x);\n    uint64x2_t vn = vdupq_n_u64(n);\n    uint64x2_t vresult = vdupq_n_u64(1);\n    uint64x2_t vtemp;\n\n    for (int i = 0; i < 64; ++i) {\n        vtemp = vmulq_u64(vresult, vn);\n        if (vgetq_lane_u64(vtemp, 0) == x || vgetq_lane_u64(vtemp, 1) == x) {\n            return true;\n        }\n        if (vgetq_lane_u64(vtemp, 0) > x && vgetq_lane_u64(vtemp, 1) > x) {\n            break;\n        }\n        vresult = vtemp;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n <= 1) {\n        return x == 1;\n    }\n\n    uint64x2_t vx = vdupq_n_u64(x);\n    uint64x2_t vn = vdupq_n_u64(n);\n    uint64x2_t vresult = vdupq_n_u64(1);\n    uint64x2_t vpower = vdupq_n_u64(1);\n\n    for (int i = 0; i < 64; ++i) {\n        vpower = vmulq_u64(vpower, vn);\n        uint64x2_t cmp = vceqq_u64(vpower, vx);\n        if (vgetq_lane_u64(cmp, 0) || vgetq_lane_u64(cmp, 1)) {\n            return true;\n        }\n        uint64x2_t overflow_check = vcgtq_u64(vpower, vx);\n        if (vgetq_lane_u64(overflow_check, 0) || vgetq_lane_u64(overflow_check, 1)) {\n            break;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n <= 1) {\n        return x == 1;\n    }\n\n    uint64x2_t vx = vdupq_n_u64(x);\n    uint64x2_t vn = vdupq_n_u64(n);\n    uint64x2_t vpow = vdupq_n_u64(1);\n    uint64x2_t vresult = vdupq_n_u64(0);\n\n    for (int i = 0; i < 64; ++i) {\n        vresult = vorrq_u64(vresult, vceqq_u64(vpow, vx));\n        vpow = vmulq_u64(vpow, vn);\n    }\n\n    uint64_t result_array[2];\n    vst1q_u64(result_array, vresult);\n\n    return result_array[0] || result_array[1];\n}\n```"}
{"task_id": "SimdBench_99_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n <= 1) {\n        return x == 1;\n    }\n\n    uint64x2_t vx = vdupq_n_u64(x);\n    uint64x2_t vn = vdupq_n_u64(n);\n    uint64x2_t vpow = vdupq_n_u64(1);\n    uint64x2_t vresult = vdupq_n_u64(0);\n\n    for (int i = 0; i < 64; ++i) {\n        vresult = vorrq_u64(vresult, vceqq_u64(vpow, vx));\n        vpow = vmulq_u64(vpow, vn);\n    }\n\n    uint64_t result = vgetq_lane_u64(vresult, 0) | vgetq_lane_u64(vresult, 1);\n    return result != 0;\n}\n```"}
{"task_id": "SimdBench_99_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n <= 1) {\n        return x == 1;\n    }\n\n    uint64x2_t vx = vdupq_n_u64(x);\n    uint64x2_t vn = vdupq_n_u64(n);\n    uint64x2_t vpow = vdupq_n_u64(1);\n    uint64x2_t vresult = vdupq_n_u64(0);\n\n    for (int i = 0; i < 64; ++i) {\n        vresult = vorrq_u64(vresult, vceqq_u64(vpow, vx));\n        vpow = vmulq_u64(vpow, vn);\n    }\n\n    uint64_t result[2];\n    vst1q_u64(result, vresult);\n\n    return result[0] || result[1];\n}\n```"}
{"task_id": "SimdBench_100_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    int prime_count = 0;\n    int len = num.length();\n    const char* data = num.c_str();\n\n    // Prime digits: '2', '3', '5', '7', 'B', 'D'\n    uint8x16_t prime_mask = vld1q_u8((const uint8_t*)\"2357BD2357BD2357\");\n\n    for (int i = 0; i + 16 <= len; i += 16) {\n        uint8x16_t input = vld1q_u8((const uint8_t*)(data + i));\n        uint8x16_t cmp1 = vceqq_u8(input, vget_low_u8(prime_mask));\n        uint8x16_t cmp2 = vceqq_u8(input, vget_high_u8(prime_mask));\n        uint8x16_t cmp = vorrq_u8(cmp1, cmp2);\n        uint8x16_t sum = vpaddq_u8(cmp, cmp);\n        sum = vpaddq_u8(sum, sum);\n        sum = vpaddq_u8(sum, sum);\n        prime_count += vaddvq_u8(sum);\n    }\n\n    for (int i = len - (len % 16); i < len; ++i) {\n        char c = data[i];\n        if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n            ++prime_count;\n        }\n    }\n\n    return prime_count;\n}\n```"}
{"task_id": "SimdBench_100_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    int prime_count = 0;\n    int len = num.length();\n    const char* data = num.c_str();\n\n    // Prime digits in hexadecimal: '2', '3', '5', '7', 'B', 'D'\n    uint8x16_t prime_mask = vld1q_u8((const uint8_t*)\"2357BD2357BD2357\");\n\n    for (int i = 0; i + 16 <= len; i += 16) {\n        uint8x16_t input = vld1q_u8((const uint8_t*)(data + i));\n        uint8x16_t cmp_result_0 = vceqq_u8(input, vget_low_u8(prime_mask));\n        uint8x16_t cmp_result_1 = vceqq_u8(input, vget_high_u8(prime_mask));\n        uint8x16_t cmp_result = vorrq_u8(cmp_result_0, cmp_result_1);\n\n        uint8x16_t mask = vdupq_n_u8(0x01);\n        uint8x16_t masked_result = vandq_u8(cmp_result, mask);\n\n        uint8x8_t sum_low = vpadd_u8(vget_low_u8(masked_result), vget_high_u8(masked_result));\n        uint8x8_t sum_high = vpadd_u8(sum_low, sum_low);\n        uint8x8_t sum_final = vpadd_u8(sum_high, sum_high);\n\n        prime_count += vget_lane_u8(sum_final, 0);\n    }\n\n    // Handle remaining characters\n    for (int i = len - (len % 16); i < len; ++i) {\n        char c = data[i];\n        if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n            prime_count++;\n        }\n    }\n\n    return prime_count;\n}\n```"}
{"task_id": "SimdBench_100_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    int prime_count = 0;\n    int len = num.length();\n    const char* data = num.c_str();\n\n    // Prime digits: '2', '3', '5', '7', 'B', 'D'\n    uint8x16_t prime_mask = vld1q_u8((const uint8_t*)\"2357BD\");\n    uint8x16_t prime_check = vmovq_n_u8(0);\n\n    for (int i = 0; i < len; i += 16) {\n        int chunk_size = std::min(16, len - i);\n        uint8x16_t input = vld1q_u8((const uint8_t*)(data + i));\n\n        // Compare each byte in the input with the prime mask\n        for (int j = 0; j < chunk_size; ++j) {\n            uint8x16_t broadcast = vmovq_n_u8(input[j]);\n            uint8x16_t cmp = vceqq_u8(broadcast, prime_mask);\n            prime_check = vorrq_u8(prime_check, cmp);\n        }\n    }\n\n    // Count the number of matches\n    uint8_t result[16];\n    vst1q_u8(result, prime_check);\n\n    for (int i = 0; i < 16; ++i) {\n        if (result[i]) {\n            prime_count++;\n        }\n    }\n\n    return prime_count;\n}\n```"}
{"task_id": "SimdBench_100_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    int prime_count = 0;\n    int len = num.length();\n    const char* data = num.c_str();\n\n    // Prime digits in hexadecimal: '2', '3', '5', '7', 'B', 'D'\n    uint8x16_t prime_mask = vld1q_u8((const uint8_t*)\"2357BD2357BD2357\");\n\n    for (int i = 0; i + 16 <= len; i += 16) {\n        uint8x16_t input = vld1q_u8((const uint8_t*)(data + i));\n        uint8x16_t cmp1 = vceqq_u8(input, vget_low_u8(prime_mask));\n        uint8x16_t cmp2 = vceqq_u8(input, vget_high_u8(prime_mask));\n        uint8x16_t cmp = vorrq_u8(cmp1, cmp2);\n        uint8x16_t sum = vpaddq_u8(cmp, cmp);\n        sum = vpaddq_u8(sum, sum);\n        sum = vpaddq_u8(sum, sum);\n        prime_count += vaddvq_u8(sum);\n    }\n\n    for (int i = len - (len % 16); i < len; ++i) {\n        char c = data[i];\n        if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n            prime_count++;\n        }\n    }\n\n    return prime_count;\n}\n```"}
{"task_id": "SimdBench_100_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    int prime_count = 0;\n    int len = num.length();\n    const char* data = num.c_str();\n\n    // Prime digits in hexadecimal: '2', '3', '5', '7', 'B', 'D'\n    uint8x16_t prime_mask = vld1q_u8((const uint8_t*)\"2357BD2357BD2357\");\n\n    for (int i = 0; i + 16 <= len; i += 16) {\n        uint8x16_t input = vld1q_u8((const uint8_t*)(data + i));\n        uint8x16_t cmp1 = vceqq_u8(input, vget_low_u8(prime_mask));\n        uint8x16_t cmp2 = vceqq_u8(input, vget_high_u8(prime_mask));\n        uint8x16_t cmp = vorrq_u8(cmp1, cmp2);\n        uint8x16_t sum = vpaddq_u8(cmp, cmp);\n        sum = vpaddq_u8(sum, sum);\n        sum = vpaddq_u8(sum, sum);\n        prime_count += vaddvq_u8(sum);\n    }\n\n    for (int i = len - (len % 16); i < len; ++i) {\n        char c = data[i];\n        if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n            prime_count++;\n        }\n    }\n\n    return prime_count;\n}\n```"}
{"task_id": "SimdBench_101_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool is_happy_simd(const std::string & s) {\n    int len = s.length();\n    if (len < 3) return false;\n\n    const uint8_t *data = reinterpret_cast<const uint8_t *>(s.data());\n    int i = 0;\n\n    // Process 16 characters at a time using NEON intrinsics\n    for (; i <= len - 16; i += 16) {\n        uint8x16_t input = vld1q_u8(data + i);\n\n        // Extract consecutive triplets and compare\n        uint8x16_t first = input;\n        uint8x16_t second = vextq_u8(input, input, 1);\n        uint8x16_t third = vextq_u8(input, input, 2);\n\n        // Check if any of the three consecutive characters are equal\n        uint8x16_t cmp1 = vceqq_u8(first, second);\n        uint8x16_t cmp2 = vceqq_u8(second, third);\n        uint8x16_t cmp3 = vceqq_u8(first, third);\n\n        uint8x16_t result = vorrq_u8(cmp1, cmp2);\n        result = vorrq_u8(result, cmp3);\n\n        // If any lane has non-zero, it means there are duplicates\n        uint8x8_t result_low = vget_low_u8(result);\n        uint8x8_t result_high = vget_high_u8(result);\n\n        uint8x8_t or_result = vorr_u8(result_low, result_high);\n        uint8x8_t reduced = vpmax_u8(or_result, or_result);\n        reduced = vpmax_u8(reduced, reduced);\n        reduced = vpmax_u8(reduced, reduced);\n\n        if (vget_lane_u8(reduced, 0) != 0) {\n            return false;\n        }\n    }\n\n    // Handle remaining characters (less than 16)\n    for (; i <= len - 3; ++i) {\n        if (s[i] == s[i + 1] || s[i + 1] == s[i + 2] || s[i] == s[i + 2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s) {\n    int len = s.length();\n    if (len < 3) return false;\n\n    const uint8_t *data = reinterpret_cast<const uint8_t *>(s.data());\n    int i = 0;\n\n    // Process 16 characters at a time using NEON intrinsics\n    for (; i <= len - 16; i += 16) {\n        // Load 16 characters into a NEON register\n        uint8x16_t v = vld1q_u8(data + i);\n\n        // Compare each character with the next one and the one after that\n        uint8x16_t vnext = vextq_u8(v, v, 1); // Shift left by 1\n        uint8x16_t vnext2 = vextq_u8(v, v, 2); // Shift left by 2\n\n        // Check if any of the three consecutive characters are equal\n        uint8x16_t cmp1 = vceqq_u8(v, vnext);\n        uint8x16_t cmp2 = vceqq_u8(v, vnext2);\n        uint8x16_t cmp3 = vceqq_u8(vnext, vnext2);\n\n        // Combine the comparison results\n        uint8x16_t result = vorrq_u8(cmp1, cmp2);\n        result = vorrq_u8(result, cmp3);\n\n        // If any of the comparisons are true, the string is not happy\n        uint64x2_t res64 = vreinterpretq_u64_u8(result);\n        if (vgetq_lane_u64(res64, 0) != 0 || vgetq_lane_u64(res64, 1) != 0) {\n            return false;\n        }\n    }\n\n    // Process remaining characters (less than 16)\n    for (; i <= len - 3; ++i) {\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s) {\n    int len = s.length();\n    if (len < 3) return false;\n\n    const uint8_t* data = reinterpret_cast<const uint8_t*>(s.data());\n    int i = 0;\n\n    // Process 16 characters at a time using NEON intrinsics\n    for (; i <= len - 16; i += 16) {\n        // Load 16 characters into a NEON register\n        uint8x16_t v = vld1q_u8(data + i);\n\n        // Compare each character with the next one and the one after that\n        uint8x16_t vnext = vextq_u8(v, v, 1); // Shift left by 1\n        uint8x16_t vnext2 = vextq_u8(v, v, 2); // Shift left by 2\n\n        // Check for equality between consecutive characters\n        uint8x16_t cmp1 = vceqq_u8(v, vnext);\n        uint8x16_t cmp2 = vceqq_u8(v, vnext2);\n        uint8x16_t cmp3 = vceqq_u8(vnext, vnext2);\n\n        // Combine the results\n        uint8x16_t result = vorrq_u8(cmp1, cmp2);\n        result = vorrq_u8(result, cmp3);\n\n        // If any of the comparisons are true, the string is not happy\n        uint8x16_t zero = vmovq_n_u8(0);\n        if (!vmaxvq_u8(vceqq_u8(result, zero))) {\n            return false;\n        }\n    }\n\n    // Process remaining characters (less than 16)\n    for (; i <= len - 3; ++i) {\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s) {\n    int len = s.length();\n    if (len < 3) return false;\n\n    const uint8_t *data = reinterpret_cast<const uint8_t *>(s.data());\n    int i = 0;\n\n    // Process 16 bytes at a time using NEON intrinsics\n    for (; i <= len - 16; i += 16) {\n        // Load 16 characters into a NEON register\n        uint8x16_t current = vld1q_u8(data + i);\n\n        // Shift left and right to compare consecutive triplets\n        uint8x16_t next = vextq_u8(current, current, 1);\n        uint8x16_t next_next = vextq_u8(current, current, 2);\n\n        // Compare for equality: current == next || current == next_next || next == next_next\n        uint8x16_t cmp1 = vceqq_u8(current, next);\n        uint8x16_t cmp2 = vceqq_u8(current, next_next);\n        uint8x16_t cmp3 = vceqq_u8(next, next_next);\n\n        // Combine comparisons with OR operation\n        uint8x16_t result = vorrq_u8(cmp1, cmp2);\n        result = vorrq_u8(result, cmp3);\n\n        // Check if any of the lanes have non-zero values (indicating duplicates)\n        uint8x16_t zero = vmovq_n_u8(0);\n        uint8x16_t mask = vceqq_u8(result, zero);\n\n        if (vmaxvq_u8(mask) != 0xFF) {\n            return false;\n        }\n    }\n\n    // Handle remaining characters (less than 16)\n    for (; i <= len - 3; ++i) {\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool is_happy_simd(const std::string & s) {\n    int len = s.length();\n    if (len < 3) return false;\n\n    const uint8_t *data = reinterpret_cast<const uint8_t *>(s.data());\n    int i = 0;\n\n    // Process 16 characters at a time using NEON intrinsics\n    for (; i <= len - 16; i += 16) {\n        // Load 16 characters into a NEON register\n        uint8x16_t current = vld1q_u8(data + i);\n\n        // Shift left and right to compare consecutive triplets\n        uint8x16_t next = vextq_u8(current, current, 1);\n        uint8x16_t next2 = vextq_u8(current, current, 2);\n\n        // Compare for equality: current == next, current == next2, next == next2\n        uint8x16_t cmp1 = vceqq_u8(current, next);\n        uint8x16_t cmp2 = vceqq_u8(current, next2);\n        uint8x16_t cmp3 = vceqq_u8(next, next2);\n\n        // Combine comparisons with OR to check if any are equal\n        uint8x16_t or_result = vorrq_u8(cmp1, cmp2);\n        or_result = vorrq_u8(or_result, cmp3);\n\n        // Check if any lane has non-zero (i.e., some comparison was true)\n        uint64x2_t result64 = vreinterpretq_u64_u8(or_result);\n        if (vgetq_lane_u64(result64, 0) != 0 || vgetq_lane_u64(result64, 1) != 0) {\n            return false;\n        }\n    }\n\n    // Process remaining characters (less than 16)\n    for (; i <= len - 3; ++i) {\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n#include <string>\n\nbool prime_length_simd(const std::string & str) {\n    int length = str.length();\n    if (length < 2) return false;\n\n    int sqrt_len = static_cast<int>(std::sqrt(length));\n    uint32x4_t vec_len = vmovq_n_u32(length);\n    uint32x4_t vec_zero = vmovq_n_u32(0);\n\n    for (int i = 2; i <= sqrt_len; i += 4) {\n        uint32x4_t vec_i = vld1q_u32((uint32_t[]){i, i + 1, i + 2, i + 3});\n        uint32x4_t mod_results = vmodq_u32(vec_len, vec_i);\n        uint32x4_t is_divisible = vceqq_u32(mod_results, vec_zero);\n\n        if (vmaxvq_u32(is_divisible)) {\n            return false;\n        }\n    }\n\n    for (int i = (sqrt_len / 4) * 4 + 1; i <= sqrt_len; ++i) {\n        if (length % i == 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n#include <string>\n\nbool prime_length_simd(const std::string & str) {\n    int length = str.length();\n    if (length < 2) return false;\n\n    int sqrt_len = static_cast<int>(std::sqrt(length));\n    uint32x4_t vec_len = vmovq_n_u32(length);\n    uint32x4_t vec_mod;\n    uint32x4_t vec_zero = vmovq_n_u32(0);\n\n    for (int i = 2; i <= sqrt_len; i += 4) {\n        uint32x4_t vec_i = vld1q_u32((uint32_t[]){i, i + 1, i + 2, i + 3});\n        vec_mod = vmodq_u32(vec_len, vec_i);\n        uint32x4_t cmp = vceqq_u32(vec_mod, vec_zero);\n        if (vmaxvq_u32(cmp)) {\n            return false;\n        }\n    }\n\n    for (int i = (sqrt_len / 4) * 4 + 2; i <= sqrt_len; ++i) {\n        if (length % i == 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n\nbool prime_length_simd(const std::string & str) {\n    int length = str.length();\n    if (length < 2) return false;\n\n    int sqrt_len = static_cast<int>(std::sqrt(length));\n    uint32x4_t vec_len = vmovq_n_u32(length);\n    uint32x4_t vec_zero = vmovq_n_u32(0);\n\n    for (int i = 2; i <= sqrt_len; i += 4) {\n        uint32x4_t vec_i = vld1q_u32((uint32_t[]){i, i + 1, i + 2, i + 3});\n        uint32x4_t mod_results = vmodq_u32(vec_len, vec_i);\n        uint32x4_t is_zero = vceqq_u32(mod_results, vec_zero);\n\n        if (vmaxvq_u32(is_zero)) {\n            return false;\n        }\n    }\n\n    for (int i = (sqrt_len / 4) * 4 + 1; i <= sqrt_len; ++i) {\n        if (length % i == 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n#include <string>\n\nbool prime_length_simd(const std::string & str) {\n    int length = str.length();\n    if (length < 2) return false;\n\n    int sqrt_len = static_cast<int>(std::sqrt(length));\n    uint32x4_t vec_len = vmovq_n_u32(length);\n    uint32x4_t vec_zero = vmovq_n_u32(0);\n\n    for (int i = 2; i <= sqrt_len; i += 4) {\n        uint32x4_t vec_i = vld1q_u32((uint32_t[]){i, i + 1, i + 2, i + 3});\n        uint32x4_t mod_results = vmodq_u32(vec_len, vec_i);\n        uint32x4_t is_divisible = vceqq_u32(mod_results, vec_zero);\n\n        if (vmaxvq_u32(is_divisible)) {\n            return false;\n        }\n    }\n\n    for (int i = (sqrt_len / 4) * 4 + 1; i <= sqrt_len; ++i) {\n        if (length % i == 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n#include <string>\n\nbool prime_length_simd(const std::string & str) {\n    int length = str.length();\n    if (length < 2) return false;\n\n    int sqrt_len = static_cast<int>(std::sqrt(length));\n    uint32x4_t vec_len = vmovq_n_u32(length);\n    uint32x4_t vec_zero = vmovq_n_u32(0);\n\n    for (int i = 2; i <= sqrt_len; i += 4) {\n        uint32x4_t vec_i = {static_cast<uint32_t>(i), \n                            static_cast<uint32_t>(i + 1), \n                            static_cast<uint32_t>(i + 2), \n                            static_cast<uint32_t>(i + 3)};\n        uint32x4_t mod_results = vmodq_u32(vec_len, vec_i);\n        uint32x4_t is_divisible = vceqq_u32(mod_results, vec_zero);\n\n        if (vmaxvq_u32(is_divisible)) {\n            return false;\n        }\n    }\n\n    for (int i = (sqrt_len / 4) * 4 + 1; i <= sqrt_len; ++i) {\n        if (length % i == 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_103_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <bitset>\n\nstd::string solve_simd(uint64_t N) {\n    uint8x16_t digit_mask = vdupq_n_u8(0xF); // Mask to extract 4 bits at a time\n    uint8x16_t sum_vec = vdupq_n_u8(0);      // Accumulator for sums\n\n    // Load the number into a vector, split into 4-bit chunks\n    uint8x16_t num_vec = vreinterpretq_u8_u64(vdupq_n_u64(N));\n\n    // Process 16 digits (4-bit chunks) in parallel\n    for (int i = 0; i < 16; ++i) {\n        uint8x16_t digits = vandq_u8(num_vec, digit_mask); // Extract lower 4 bits\n        sum_vec = vaddq_u8(sum_vec, digits);              // Add to accumulator\n        num_vec = vshrq_n_u8(num_vec, 4);                 // Shift right by 4 bits\n    }\n\n    // Horizontally sum the elements of the vector\n    uint32x4_t sum_32 = vpaddlq_u16(vpaddlq_u8(sum_vec)); // Pairwise add to reduce\n    uint32x2_t sum_32_low = vget_low_u32(sum_32);\n    uint32x2_t sum_32_high = vget_high_u32(sum_32);\n    uint32x2_t total_sum = vpadd_u32(sum_32_low, sum_32_high);\n\n    // Extract the final sum from the vector\n    uint32_t result = vget_lane_u32(total_sum, 0);\n\n    // Convert the sum to binary string\n    std::string binary = std::bitset<32>(result).to_string();\n    // Remove leading zeros\n    size_t first_one = binary.find('1');\n    return first_one != std::string::npos ? binary.substr(first_one) : \"0\";\n}\n```"}
{"task_id": "SimdBench_103_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <bitset>\n\nstd::string solve_simd(uint64_t N) {\n    uint8x16_t digit_mask = vdupq_n_u8(0xF); // Mask to extract 4 bits at a time\n    uint8x16_t sum_vector = vdupq_n_u8(0);   // Accumulator for sums\n\n    // Load the number into a vector as bytes (split into chunks of 8 bits)\n    uint8_t num_array[16];\n    for (int i = 0; i < 16; ++i) {\n        num_array[i] = (N >> (i * 4)) & 0xF;\n    }\n    uint8x16_t num_vec = vld1q_u8(num_array);\n\n    // Process each chunk in parallel\n    sum_vector = vaddq_u8(sum_vector, vandq_u8(num_vec, digit_mask));\n\n    // Horizontal sum of the vector elements\n    uint32_t total_sum = 0;\n    for (int i = 0; i < 16; ++i) {\n        total_sum += ((uint8_t*)&sum_vector)[i];\n    }\n\n    // Convert the sum to binary string\n    std::string binary = std::bitset<32>(total_sum).to_string();\n    // Remove leading zeros\n    size_t first_one = binary.find('1');\n    return first_one != std::string::npos ? binary.substr(first_one) : \"0\";\n}\n```"}
{"task_id": "SimdBench_103_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <bitset>\n\nstd::string solve_simd(uint64_t N) {\n    uint8x16_t digit_mask = vdupq_n_u8(0xF); // Mask to extract 4 bits at a time\n    uint8x16_t sum_vec = vdupq_n_u8(0);     // Accumulator for sums\n\n    // Process the number in chunks of 16 digits using NEON\n    while (N > 0) {\n        uint8x16_t digits;\n        for (int i = 0; i < 16; ++i) {\n            uint8_t digit = N % 10;\n            N /= 10;\n            digits[i] = digit;\n        }\n\n        // Add the extracted digits to the accumulator\n        sum_vec = vaddq_u8(sum_vec, digits);\n    }\n\n    // Horizontally sum the elements of the vector\n    uint32x4_t sum_partial = vpaddlq_u16(vpaddlq_u8(sum_vec));\n    uint32x2_t sum_final = vpadd_u32(vget_low_u32(sum_partial), vget_high_u32(sum_partial));\n    uint32_t total_sum = vget_lane_u32(sum_final, 0);\n\n    // Convert the total sum to binary string\n    std::string binary_result = std::bitset<32>(total_sum).to_string();\n    // Remove leading zeros\n    size_t first_one = binary_result.find('1');\n    return first_one != std::string::npos ? binary_result.substr(first_one) : \"0\";\n}\n```"}
{"task_id": "SimdBench_103_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <bitset>\n\nstd::string solve_simd(uint64_t N) {\n    uint8x16_t digit_mask = vdupq_n_u8(0xF); // Mask to extract 4 bits at a time\n    uint8x16_t sum_vec = vdupq_n_u8(0);      // Accumulator for sums\n\n    // Load the number into a vector, split into 4-bit chunks\n    uint8x16_t num_vec = vreinterpretq_u8_u64(vdupq_n_u64(N));\n\n    // Process 16 digits (4-bit chunks) in parallel\n    for (int i = 0; i < 16; ++i) {\n        uint8x16_t chunk = vandq_u8(num_vec, digit_mask); // Extract 4 bits\n        sum_vec = vaddq_u8(sum_vec, chunk);              // Add to accumulator\n        num_vec = vshrq_n_u8(num_vec, 4);                // Shift right by 4 bits\n    }\n\n    // Horizontally sum the elements of the vector\n    uint32x4_t sum_partial = vpaddlq_u16(vpaddlq_u8(sum_vec));\n    uint32x2_t sum_final = vpadd_u32(vget_low_u32(sum_partial), vget_high_u32(sum_partial));\n    uint32_t total_sum = vget_lane_u32(sum_final, 0);\n\n    // Convert the sum to binary string\n    std::string binary = std::bitset<32>(total_sum).to_string();\n    // Remove leading zeros\n    size_t first_one = binary.find('1');\n    return first_one != std::string::npos ? binary.substr(first_one) : \"0\";\n}\n```"}
{"task_id": "SimdBench_103_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <bitset>\n\nstd::string solve_simd(uint64_t N) {\n    uint8x16_t digit_mask = vdupq_n_u8(0xF); // Mask to extract 4 bits at a time\n    uint8x16_t sum_vec = vdupq_n_u8(0);      // Accumulator for sums\n\n    // Process 16 digits at a time using SIMD\n    while (N > 0) {\n        uint8x16_t digits = vdupq_n_u8(0);\n        for (int i = 0; i < 16 && N > 0; ++i) {\n            uint8_t digit = N % 10;\n            N /= 10;\n            digits = vsetq_lane_u8(digit, digits, i);\n        }\n\n        // Add the extracted digits to the accumulator\n        sum_vec = vaddq_u8(sum_vec, digits);\n    }\n\n    // Horizontally sum the elements in the vector\n    uint32x4_t sum_partial = vpaddlq_u16(vpaddlq_u8(sum_vec));\n    uint32x2_t sum_final = vpadd_u32(vget_low_u32(sum_partial), vget_high_u32(sum_partial));\n    uint32_t total_sum = vget_lane_u32(sum_final, 0) + vget_lane_u32(sum_final, 1);\n\n    // Convert the total sum to binary string\n    std::string binary = std::bitset<32>(total_sum).to_string();\n    // Remove leading zeros\n    size_t first_one = binary.find('1');\n    return first_one != std::string::npos ? binary.substr(first_one) : \"0\";\n}\n```"}
{"task_id": "SimdBench_104_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint add_simd(std::vector<int> lst) {\n    int result = 0;\n    int size = lst.size();\n    int i = 1;\n\n    // Process elements in chunks of 4 using NEON intrinsics\n    for (; i + 3 < size; i += 4) {\n        // Load 4 integers from the vector starting at index i\n        int32x4_t vec = vld1q_s32(&lst[i]);\n\n        // Create a mask to identify odd indices (i.e., 1, 3, 5, ...)\n        int32x4_t index_mask = {i % 2, (i + 1) % 2, (i + 2) % 2, (i + 3) % 2};\n        uint32x4_t odd_index_mask = vmovq_n_u32(0);\n        odd_index_mask = vorrq_u32(odd_index_mask, vceqq_s32(index_mask, vmovq_n_s32(1)));\n\n        // Mask out elements that are not at odd indices\n        vec = vandq_s32(vec, vreinterpretq_s32_u32(odd_index_mask));\n\n        // Check which elements are even\n        uint32x4_t even_mask = vceqq_s32(vandq_s32(vec, vmovq_n_s32(1)), vmovq_n_s32(0));\n\n        // Combine masks: only consider even elements at odd indices\n        uint32x4_t combined_mask = vandq_u32(odd_index_mask, even_mask);\n\n        // Use the combined mask to zero out unwanted elements\n        vec = vandq_s32(vec, vreinterpretq_s32_u32(combined_mask));\n\n        // Horizontally add the valid elements in the vector\n        int32x2_t sum_vec = vpadd_s32(vget_low_s32(vec), vget_high_s32(vec));\n        sum_vec = vpadd_s32(sum_vec, sum_vec);\n        result += vget_lane_s32(sum_vec, 0);\n    }\n\n    // Process remaining elements (if any) using scalar code\n    for (; i < size; ++i) {\n        if (i % 2 == 1 && lst[i] % 2 == 0) {\n            result += lst[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_104_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint add_simd(std::vector<int> lst) {\n    int result = 0;\n    int n = lst.size();\n    int i = 1;\n\n    // Process elements in chunks of 4 using NEON intrinsics\n    for (; i + 3 < n; i += 4) {\n        // Load 4 integers from the vector starting at index i\n        int32x4_t vec = vld1q_s32(&lst[i]);\n\n        // Create a mask to identify odd indices (i.e., 1, 3, 5, ...)\n        int32x4_t index_mask = {i, i + 1, i + 2, i + 3};\n        uint32x4_t odd_index_mask = vmovq_n_u32(1);\n        odd_index_mask = vandq_u32(vreinterpretq_u32_s32(index_mask), odd_index_mask);\n\n        // Select elements at odd indices using the mask\n        int32x4_t odd_index_elements = vbslq_s32(vreinterpretq_s32_u32(odd_index_mask), vec, vmovq_n_s32(0));\n\n        // Create a mask to identify even elements\n        uint32x4_t even_element_mask = vceqq_s32(vandq_s32(odd_index_elements, vmovq_n_s32(1)), vmovq_n_s32(0));\n\n        // Select even elements using the mask\n        int32x4_t even_elements = vbslq_s32(vreinterpretq_s32_u32(even_element_mask), odd_index_elements, vmovq_n_s32(0));\n\n        // Horizontally add the selected even elements\n        int32x2_t sum_vec = vpadd_s32(vget_low_s32(even_elements), vget_high_s32(even_elements));\n        sum_vec = vpadd_s32(sum_vec, sum_vec);\n        result += vget_lane_s32(sum_vec, 0);\n    }\n\n    // Process remaining elements that didn't fit into the SIMD loop\n    for (; i < n; ++i) {\n        if (i % 2 == 1 && lst[i] % 2 == 0) {\n            result += lst[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_104_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint add_simd(std::vector<int> lst) {\n    int result = 0;\n    int n = lst.size();\n    int i = 1;\n\n    // Process elements in chunks of 4 using NEON intrinsics\n    for (; i + 3 < n; i += 4) {\n        // Load 4 integers from the vector starting at index i\n        int32x4_t vec = vld1q_s32(&lst[i]);\n\n        // Create a mask to identify odd indices (1, 3, 5, etc.)\n        uint32x4_t index_mask = {1, 0, 1, 0};\n\n        // Select elements at odd indices using the mask\n        int32x4_t odd_index_elements = vbslq_s32(index_mask, vec, vdupq_n_s32(0));\n\n        // Check which elements are even\n        uint32x4_t even_mask = vceqq_s32(vandq_s32(odd_index_elements, vdupq_n_s32(1)), vdupq_n_s32(0));\n\n        // Zero out odd elements using the even mask\n        int32x4_t even_elements = vbslq_s32(even_mask, odd_index_elements, vdupq_n_s32(0));\n\n        // Horizontally add the even elements in the vector\n        int32x2_t sum_vec = vpadd_s32(vget_low_s32(even_elements), vget_high_s32(even_elements));\n        sum_vec = vpadd_s32(sum_vec, sum_vec);\n\n        // Add the result to the scalar accumulator\n        result += vget_lane_s32(sum_vec, 0);\n    }\n\n    // Process remaining elements that didn't fit into a full NEON register\n    for (; i < n; i += 2) {\n        if (i % 2 == 1 && lst[i] % 2 == 0) {\n            result += lst[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_104_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int result = 0;\n    int n = lst.size();\n    int i = 1;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 3 < n; i += 4) {\n        // Load 4 integers from the vector into a NEON register\n        int32x4_t vec = vld1q_s32(&lst[i]);\n\n        // Create a mask to select odd indices (i.e., 1st, 3rd elements in the vector)\n        uint32x4_t mask = {0, -1, 0, -1}; // Equivalent to {0, 1, 0, 1} as a bitmask\n\n        // Use the mask to extract elements at odd indices\n        int32x4_t odd_index_vals = vandq_s32(vec, vreinterpretq_s32_u32(mask));\n\n        // Check which of these values are even\n        uint32x4_t is_even_mask = vceqq_s32(vandq_s32(odd_index_vals, vdupq_n_s32(1)), vdupq_n_s32(0));\n\n        // Zero out the non-even values\n        int32x4_t even_vals = vandq_s32(odd_index_vals, vreinterpretq_s32_u32(is_even_mask));\n\n        // Horizontally add the even values in the NEON register\n        int32x2_t sum_vec = vpadd_s32(vget_low_s32(even_vals), vget_high_s32(even_vals));\n        sum_vec = vpadd_s32(sum_vec, sum_vec);\n\n        // Add the result to the accumulator\n        result += vget_lane_s32(sum_vec, 0);\n    }\n\n    // Handle remaining elements that couldn't be processed in groups of 4\n    for (; i < n; i += 2) {\n        if (lst[i] % 2 == 0) {\n            result += lst[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_104_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint add_simd(std::vector<int> lst) {\n    int result = 0;\n    int n = lst.size();\n    int i = 1;\n\n    // Process elements in chunks of 4 using NEON intrinsics\n    for (; i + 3 < n; i += 4) {\n        // Load 4 integers from the vector starting at index i\n        int32x4_t vec = vld1q_s32(&lst[i]);\n\n        // Create a mask to identify odd indices (i.e., 1, 3, etc.)\n        uint32x4_t index_mask = {0, 1, 0, 1};\n\n        // Select elements at odd indices using the mask\n        int32x4_t odd_index_elements = vbslq_s32(index_mask, vec, vdupq_n_s32(0));\n\n        // Check which elements are even\n        uint32x4_t even_mask = vceqq_s32(vandq_s32(odd_index_elements, vdupq_n_s32(1)), vdupq_n_s32(0));\n\n        // Zero out elements that are not even\n        int32x4_t even_elements = vbslq_s32(even_mask, odd_index_elements, vdupq_n_s32(0));\n\n        // Horizontally add the even elements\n        int32x2_t sum_vec = vpadd_s32(vget_low_s32(even_elements), vget_high_s32(even_elements));\n        sum_vec = vpadd_s32(sum_vec, sum_vec);\n\n        // Add the result to the accumulator\n        result += vget_lane_s32(sum_vec, 0);\n    }\n\n    // Process remaining elements\n    for (; i < n; i += 2) {\n        if (lst[i] % 2 == 0) {\n            result += lst[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    std::string result(s.size(), '\\0');\n    int len = s.size();\n\n    // Process 16 characters at a time using NEON intrinsics\n    int i = 0;\n    for (; i <= len - 16; i += 16) {\n        // Load 16 characters from the input string\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n\n        // Create a vector with the shift value (2 * 2 = 4)\n        uint8x16_t shift = vdupq_n_u8(4);\n\n        // Add the shift to the input vector\n        uint8x16_t shifted = vaddq_u8(input, shift);\n\n        // Wrap around if the character exceeds 'z'\n        uint8x16_t wrap = vdupq_n_u8('z' + 1);\n        uint8x16_t mask = vcgtq_u8(shifted, wrap);\n        uint8x16_t wrapped = vsubq_u8(shifted, vandq_u8(mask, vdupq_n_u8(26)));\n\n        // Store the result back into the output string\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), wrapped);\n    }\n\n    // Process remaining characters (if any) using scalar code\n    for (; i < len; ++i) {\n        char c = s[i];\n        if (c >= 'a' && c <= 'z') {\n            c = c + 4;\n            if (c > 'z') {\n                c -= 26;\n            }\n        }\n        result[i] = c;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    std::string result(s.size(), 0);\n    int len = s.size();\n    int i = 0;\n\n    // Process 16 characters at a time using NEON intrinsics\n    for (; i <= len - 16; i += 16) {\n        // Load 16 characters from the input string\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n\n        // Create a vector with the value 4 (2 * 2)\n        uint8x16_t shift = vmovq_n_u8(4);\n\n        // Add the shift value to the input vector\n        uint8x16_t encrypted = vaddq_u8(input, shift);\n\n        // Store the result back into the output string\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), encrypted);\n    }\n\n    // Process remaining characters (if any) using scalar code\n    for (; i < len; ++i) {\n        result[i] = s[i] + 4;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    std::string result(s.size(), '\\0');\n    int len = s.size();\n    int i = 0;\n\n    // Process 16 characters at a time using NEON intrinsics\n    for (; i <= len - 16; i += 16) {\n        // Load 16 characters from the input string\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n\n        // Create a vector with the shift value (2 * 2 = 4)\n        uint8x16_t shift = vmovq_n_u8(4);\n\n        // Add the shift to the input vector\n        uint8x16_t shifted = vaddq_u8(input, shift);\n\n        // Wrap around if the character exceeds 'z'\n        uint8x16_t wrap = vcltq_u8(shifted, vmovq_n_u8('a'));\n        uint8x16_t wrapped = vbslq_u8(wrap, vaddq_u8(shifted, vmovq_n_u8(26)), shifted);\n\n        // Store the result back into the output string\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), wrapped);\n    }\n\n    // Process remaining characters (if any) using scalar code\n    for (; i < len; ++i) {\n        char c = s[i];\n        if (c >= 'a' && c <= 'z') {\n            c += 4;\n            if (c > 'z') {\n                c -= 26;\n            }\n        }\n        result[i] = c;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    std::string result(s.size(), ' ');\n    int len = s.size();\n    int i = 0;\n\n    // Process 16 characters at a time using NEON intrinsics\n    for (; i <= len - 16; i += 16) {\n        // Load 16 characters into a NEON register\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n\n        // Create a vector with the shift value (2 * 2 = 4)\n        uint8x16_t shift = vdupq_n_u8(4);\n\n        // Add the shift to the input characters\n        uint8x16_t encrypted = vaddq_u8(input, shift);\n\n        // Wrap around if the character exceeds 'z'\n        uint8x16_t wrap = vdupq_n_u8('z' + 1);\n        uint8x16_t mask = vcgtq_u8(encrypted, wrap);\n        encrypted = vbslq_u8(mask, vsubq_u8(encrypted, vdupq_n_u8(26)), encrypted);\n\n        // Store the result back to memory\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), encrypted);\n    }\n\n    // Process remaining characters (if any) using scalar code\n    for (; i < len; ++i) {\n        char c = s[i];\n        if (c >= 'a' && c <= 'z') {\n            c += 4;\n            if (c > 'z') {\n                c -= 26;\n            }\n        }\n        result[i] = c;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    std::string result(s.size(), ' ');\n    int len = s.size();\n\n    // Process 16 characters at a time using NEON intrinsics\n    int i = 0;\n    for (; i <= len - 16; i += 16) {\n        // Load 16 characters into a NEON register\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n\n        // Create a vector with the shift value (2 * 2 = 4)\n        uint8x16_t shift = vmovq_n_u8(4);\n\n        // Add the shift to the input vector\n        uint8x16_t encrypted = vaddq_u8(input, shift);\n\n        // Wrap around for characters beyond 'z'\n        uint8x16_t wrap = vmovq_n_u8('z' + 1);\n        uint8x16_t mask = vcgtq_u8(encrypted, wrap);\n        encrypted = vbslq_u8(mask, vsubq_u8(encrypted, wrap), encrypted);\n\n        // Store the result back to memory\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), encrypted);\n    }\n\n    // Process remaining characters (if any) using scalar code\n    for (; i < len; ++i) {\n        char c = s[i];\n        c += 4; // Shift by 4 positions\n        if (c > 'z') {\n            c -= ('z' - 'a' + 1); // Wrap around if necessary\n        }\n        result[i] = c;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encode_simd(const std::string &message) {\n    std::string result(message.size(), 0);\n    int i = 0;\n\n    // Process 16 characters at a time using NEON intrinsics\n    for (; i <= static_cast<int>(message.size()) - 16; i += 16) {\n        // Load 16 characters into a NEON register\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&message[i]));\n\n        // Create masks for case swapping and vowels\n        uint8x16_t lowercase_mask = vcltq_u8(input, vdupq_n_u8('a'));\n        uint8x16_t uppercase_mask = vcgeq_u8(input, vdupq_n_u8('A'));\n\n        // Swap case: toggle the 5th bit (32)\n        uint8x16_t case_swapped = veorq_u8(input, vdupq_n_u8(32));\n\n        // Identify vowels (a, e, i, o, u and A, E, I, O, U)\n        uint8x16_t vowel_a = vceqq_u8(case_swapped, vdupq_n_u8('a'));\n        uint8x16_t vowel_e = vceqq_u8(case_swapped, vdupq_n_u8('e'));\n        uint8x16_t vowel_i = vceqq_u8(case_swapped, vdupq_n_u8('i'));\n        uint8x16_t vowel_o = vceqq_u8(case_swapped, vdupq_n_u8('o'));\n        uint8x16_t vowel_u = vceqq_u8(case_swapped, vdupq_n_u8('u'));\n\n        // Combine all vowel masks\n        uint8x16_t is_vowel = vorrq_u8(vowel_a, vowel_e);\n        is_vowel = vorrq_u8(is_vowel, vowel_i);\n        is_vowel = vorrq_u8(is_vowel, vowel_o);\n        is_vowel = vorrq_u8(is_vowel, vowel_u);\n\n        // Replace vowels with letters 2 places ahead\n        uint8x16_t vowel_replaced = vaddq_u8(case_swapped, vdupq_n_u8(2));\n\n        // Select between case-swapped and vowel-replaced based on vowel mask\n        uint8x16_t final_output = vbslq_u8(is_vowel, vowel_replaced, case_swapped);\n\n        // Store the result back to memory\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), final_output);\n    }\n\n    // Process remaining characters (if any) using scalar code\n    for (; i < static_cast<int>(message.size()); ++i) {\n        char c = message[i];\n        if (c >= 'a' && c <= 'z') {\n            c ^= 32; // Convert to uppercase\n        } else if (c >= 'A' && c <= 'Z') {\n            c ^= 32; // Convert to lowercase\n        }\n\n        // Check if the character is a vowel\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ||\n            c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            c += 2; // Replace vowel with the letter 2 places ahead\n        }\n\n        result[i] = c;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encode_simd(const std::string &message) {\n    std::string result(message.size(), 0);\n    int len = message.size();\n    int i = 0;\n\n    // Constants for SIMD operations\n    const uint8x16_t mask_lower_to_upper = vdupq_n_u8(0x20); // Mask to flip case\n    const uint8x16_t vowels_lower = vld1q_u8((const uint8_t *)\"aeiou\");\n    const uint8x16_t vowels_upper = vld1q_u8((const uint8_t *)\"AEIOU\");\n    const uint8x16_t replace_lower = vld1q_u8((const uint8_t *)\"cgikmo\");\n    const uint8x16_t replace_upper = vld1q_u8((const uint8_t *)\"CGIKMO\");\n\n    for (; i <= len - 16; i += 16) {\n        // Load 16 characters\n        uint8x16_t input = vld1q_u8((const uint8_t *)(message.data() + i));\n\n        // Swap case\n        uint8x16_t is_lower = vcltq_u8(input, vdupq_n_u8('a'));\n        uint8x16_t swapped_case = veorq_u8(input, mask_lower_to_upper);\n\n        // Replace vowels\n        uint8x16_t is_vowel_lower = vceqq_u8(input, vowels_lower);\n        uint8x16_t is_vowel_upper = vceqq_u8(input, vowels_upper);\n\n        uint8x16_t replaced_lower = vbslq_u8(is_vowel_lower, replace_lower, input);\n        uint8x16_t replaced_upper = vbslq_u8(is_vowel_upper, replace_upper, replaced_lower);\n\n        uint8x16_t final_output = vbslq_u8(is_lower, swapped_case, replaced_upper);\n\n        // Store the result\n        vst1q_u8((uint8_t *)(result.data() + i), final_output);\n    }\n\n    // Handle remaining characters\n    for (; i < len; ++i) {\n        char c = message[i];\n        if (c >= 'a' && c <= 'z') {\n            c ^= 0x20; // Convert to uppercase\n            switch (c) {\n                case 'A': c = 'C'; break;\n                case 'E': c = 'G'; break;\n                case 'I': c = 'K'; break;\n                case 'O': c = 'Q'; break;\n                case 'U': c = 'W'; break;\n            }\n        } else if (c >= 'A' && c <= 'Z') {\n            c ^= 0x20; // Convert to lowercase\n            switch (c) {\n                case 'a': c = 'c'; break;\n                case 'e': c = 'g'; break;\n                case 'i': c = 'k'; break;\n                case 'o': c = 'q'; break;\n                case 'u': c = 'w'; break;\n            }\n        }\n        result[i] = c;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encode_simd(const std::string &message) {\n    std::string result = message;\n    int len = message.length();\n    int i = 0;\n\n    // Constants for SIMD operations\n    const uint8x16_t mask_case = vdupq_n_u8(32); // Mask to flip case (5th bit)\n    const uint8x16_t vowels_lower = vld1q_u8((const uint8_t *)\"aeiou\");\n    const uint8x16_t vowels_upper = vld1q_u8((const uint8_t *)\"AEIOU\");\n    const uint8x16_t replace_lower = vld1q_u8((const uint8_t *)\"cgikmo\");\n    const uint8x16_t replace_upper = vld1q_u8((const uint8_t *)\"CGIKMO\");\n\n    for (; i <= len - 16; i += 16) {\n        uint8x16_t data = vld1q_u8((const uint8_t *)(message.data() + i));\n\n        // Swap case by flipping the 5th bit\n        uint8x16_t swapped_case = veorq_u8(data, mask_case);\n\n        // Replace vowels with corresponding letters\n        uint8x16_t is_vowel_lower = vceqq_u8(data, vowels_lower);\n        uint8x16_t is_vowel_upper = vceqq_u8(data, vowels_upper);\n\n        uint8x16_t replaced = vbslq_u8(is_vowel_lower, replace_lower, data);\n        replaced = vbslq_u8(is_vowel_upper, replace_upper, replaced);\n\n        // Combine swapped case and replaced vowels\n        uint8x16_t final_data = vbslq_u8(vorrq_u8(is_vowel_lower, is_vowel_upper), replaced, swapped_case);\n\n        vst1q_u8((uint8_t *)(result.data() + i), final_data);\n    }\n\n    // Handle remaining characters\n    for (; i < len; ++i) {\n        char c = message[i];\n        if (c >= 'a' && c <= 'z') {\n            c ^= 32; // Swap case\n            if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n                c += 2; // Replace vowel\n            }\n        } else if (c >= 'A' && c <= 'Z') {\n            c ^= 32; // Swap case\n            if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n                c += 2; // Replace vowel\n            }\n        }\n        result[i] = c;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encode_simd(const std::string &message) {\n    std::string result(message.size(), '\\0');\n    int len = message.size();\n    int i = 0;\n\n    // Constants for SIMD operations\n    const uint8x16_t mask_case_swap = vdupq_n_u8(32); // Mask to swap case (bit 5)\n    const uint8x16_t vowels_lower = vld1q_u8((const uint8_t *)\"aeiou\");\n    const uint8x16_t vowels_upper = vld1q_u8((const uint8_t *)\"AEIOU\");\n    const uint8x16_t replace_lower = vld1q_u8((const uint8_t *)\"cgikmo\");\n    const uint8x16_t replace_upper = vld1q_u8((const uint8_t *)\"CGIKMO\");\n\n    for (; i <= len - 16; i += 16) {\n        // Load 16 characters from the input\n        uint8x16_t input = vld1q_u8((const uint8_t *)(message.data() + i));\n\n        // Swap case by flipping the 5th bit\n        uint8x16_t swapped = veorq_u8(input, mask_case_swap);\n\n        // Replace vowels with corresponding letters\n        uint8x16_t is_vowel_lower = vceqq_u8(input, vowels_lower);\n        uint8x16_t is_vowel_upper = vceqq_u8(input, vowels_upper);\n\n        uint8x16_t replaced_lower = vbslq_u8(is_vowel_lower, replace_lower, swapped);\n        uint8x16_t replaced_upper = vbslq_u8(is_vowel_upper, replace_upper, replaced_lower);\n\n        // Store the result back\n        vst1q_u8((uint8_t *)(result.data() + i), replaced_upper);\n    }\n\n    // Handle remaining characters\n    for (; i < len; ++i) {\n        char c = message[i];\n        if (c >= 'a' && c <= 'z') {\n            c ^= 32; // Swap case\n            if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n                c += 2; // Replace vowel\n            }\n        } else if (c >= 'A' && c <= 'Z') {\n            c ^= 32; // Swap case\n            if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n                c += 2; // Replace vowel\n            }\n        }\n        result[i] = c;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encode_simd(const std::string &message) {\n    std::string result(message.size(), '\\0');\n    int i = 0;\n\n    // Constants for SIMD operations\n    const uint8x16_t lower_case_mask = vdupq_n_u8(0x20);\n    const uint8x16_t upper_case_mask = vdupq_n_u8(~0x20);\n    const uint8x16_t vowel_a = vdupq_n_u8('a');\n    const uint8x16_t vowel_e = vdupq_n_u8('e');\n    const uint8x16_t vowel_i = vdupq_n_u8('i');\n    const uint8x16_t vowel_o = vdupq_n_u8('o');\n    const uint8x16_t vowel_u = vdupq_n_u8('u');\n    const uint8x16_t vowel_A = vdupq_n_u8('A');\n    const uint8x16_t vowel_E = vdupq_n_u8('E');\n    const uint8x16_t vowel_I = vdupq_n_u8('I');\n    const uint8x16_t vowel_O = vdupq_n_u8('O');\n    const uint8x16_t vowel_U = vdupq_n_u8('U');\n\n    for (; i <= static_cast<int>(message.size()) - 16; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&message[i]));\n\n        // Swap case\n        uint8x16_t is_lower = vandq_u8(input, lower_case_mask);\n        uint8x16_t swapped_case = veorq_u8(input, is_lower);\n\n        // Replace vowels with letters two places ahead\n        uint8x16_t replace_a = vorrq_u8(vceqq_u8(input, vowel_a), vceqq_u8(input, vowel_A));\n        uint8x16_t replace_e = vorrq_u8(vceqq_u8(input, vowel_e), vceqq_u8(input, vowel_E));\n        uint8x16_t replace_i = vorrq_u8(vceqq_u8(input, vowel_i), vceqq_u8(input, vowel_I));\n        uint8x16_t replace_o = vorrq_u8(vceqq_u8(input, vowel_o), vceqq_u8(input, vowel_O));\n        uint8x16_t replace_u = vorrq_u8(vceqq_u8(input, vowel_u), vceqq_u8(input, vowel_U));\n\n        uint8x16_t replacement = vdupq_n_u8(0);\n        replacement = vbslq_u8(replace_a, vaddq_u8(input, vdupq_n_u8(2)), replacement);\n        replacement = vbslq_u8(replace_e, vaddq_u8(input, vdupq_n_u8(2)), replacement);\n        replacement = vbslq_u8(replace_i, vaddq_u8(input, vdupq_n_u8(2)), replacement);\n        replacement = vbslq_u8(replace_o, vaddq_u8(input, vdupq_n_u8(2)), replacement);\n        replacement = vbslq_u8(replace_u, vaddq_u8(input, vdupq_n_u8(2)), replacement);\n\n        uint8x16_t mask = vorrq_u8(replace_a, vorrq_u8(replace_e, vorrq_u8(replace_i, vorrq_u8(replace_o, replace_u))));\n        uint8x16_t final_output = vbslq_u8(mask, replacement, swapped_case);\n\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), final_output);\n    }\n\n    // Handle remaining characters\n    for (; i < static_cast<int>(message.size()); ++i) {\n        char c = message[i];\n        if (c >= 'a' && c <= 'z') {\n            c ^= 0x20; // Convert to uppercase\n        } else if (c >= 'A' && c <= 'Z') {\n            c ^= 0x20; // Convert to lowercase\n        }\n\n        if (c == 'a' || c == 'A') c += 2;\n        else if (c == 'e' || c == 'E') c += 2;\n        else if (c == 'i' || c == 'I') c += 2;\n        else if (c == 'o' || c == 'O') c += 2;\n        else if (c == 'u' || c == 'U') c += 2;\n\n        result[i] = c;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_107_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        int len = key.length();\n\n        // Process 16 characters at a time using NEON intrinsics\n        int i = 0;\n        for (; i + 16 <= len; i += 16) {\n            uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(&key[i]));\n\n            // Check for lowercase characters\n            uint8x16_t lower_check = vandq_u8(vcleq_u8(chars, vdupq_n_u8('z')), vcgeq_u8(chars, vdupq_n_u8('a')));\n            uint8x16_t not_lower = vmvnq_u8(lower_check);\n\n            // Check for uppercase characters\n            uint8x16_t upper_check = vandq_u8(vcleq_u8(chars, vdupq_n_u8('Z')), vcgeq_u8(chars, vdupq_n_u8('A')));\n            uint8x16_t not_upper = vmvnq_u8(upper_check);\n\n            // Update flags\n            all_lower &= (vmaxvq_u8(not_lower) == 0);\n            all_upper &= (vmaxvq_u8(not_upper) == 0);\n        }\n\n        // Process remaining characters\n        for (; i < len; ++i) {\n            char c = key[i];\n            all_lower &= (c >= 'a' && c <= 'z');\n            all_upper &= (c >= 'A' && c <= 'Z');\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        int len = key.length();\n\n        // Process 16 characters at a time using NEON intrinsics\n        int i = 0;\n        for (; i <= len - 16; i += 16) {\n            uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&key[i]));\n\n            // Check for lowercase letters\n            uint8x16_t lower_check = vandq_u8(vcleq_u8(input, vdupq_n_u8('z')), vcgeq_u8(input, vdupq_n_u8('a')));\n            uint8x16_t not_lower = vmvnq_u8(lower_check);\n\n            // Check for uppercase letters\n            uint8x16_t upper_check = vandq_u8(vcleq_u8(input, vdupq_n_u8('Z')), vcgeq_u8(input, vdupq_n_u8('A')));\n            uint8x16_t not_upper = vmvnq_u8(upper_check);\n\n            // Combine results\n            uint8x16_t mixed_case = vorrq_u8(not_lower, not_upper);\n            uint64x2_t result = vreinterpretq_u64_u8(mixed_case);\n\n            if ((vgetq_lane_u64(result, 0) != 0) || (vgetq_lane_u64(result, 1) != 0)) {\n                return false;\n            }\n        }\n\n        // Process remaining characters\n        for (; i < len; ++i) {\n            char c = key[i];\n            if (c >= 'a' && c <= 'z') {\n                all_upper = false;\n            } else if (c >= 'A' && c <= 'Z') {\n                all_lower = false;\n            } else {\n                return false;\n            }\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    bool hasLower = false, hasUpper = false;\n    uint8x16_t lowerMask = vdupq_n_u8(0x20); // Mask for checking lowercase\n    uint8x16_t upperMask = vdupq_n_u8(0x00); // Mask for checking uppercase\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        int len = key.length();\n\n        if (len == 0) continue;\n\n        const uint8_t* data = reinterpret_cast<const uint8_t*>(key.data());\n        int i = 0;\n\n        // Process 16 characters at a time using NEON\n        for (; i <= len - 16; i += 16) {\n            uint8x16_t input = vld1q_u8(data + i);\n            uint8x16_t lowerCheck = vandq_u8(input, lowerMask);\n            uint8x16_t upperCheck = vceqq_u8(input, upperMask);\n\n            uint8x16_t isLower = vceqq_u8(lowerCheck, lowerMask);\n            uint8x16_t isUpper = vceqq_u8(upperCheck, upperMask);\n\n            if (vmaxvq_u8(isLower)) hasLower = true;\n            if (vmaxvq_u8(isUpper)) hasUpper = true;\n\n            if (hasLower && hasUpper) return false;\n        }\n\n        // Process remaining characters\n        for (; i < len; ++i) {\n            char c = key[i];\n            if (c >= 'a' && c <= 'z') {\n                hasLower = true;\n            } else if (c >= 'A' && c <= 'Z') {\n                hasUpper = true;\n            }\n            if (hasLower && hasUpper) return false;\n        }\n    }\n\n    return !(hasLower && hasUpper);\n}\n```"}
{"task_id": "SimdBench_107_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    bool hasLower = false, hasUpper = false;\n    uint8x16_t lowerMask = vdupq_n_u8(0x20); // Mask for checking lowercase\n    uint8x16_t upperMask = vdupq_n_u8(0x00); // Mask for checking uppercase\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        int len = key.length();\n\n        if (len == 0) continue;\n\n        const char* data = key.c_str();\n        int i = 0;\n\n        // Process 16 characters at a time using NEON intrinsics\n        for (; i <= len - 16; i += 16) {\n            uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(data + i));\n            uint8x16_t lowerCheck = vandq_u8(input, lowerMask);\n            uint8x16_t upperCheck = vceqq_u8(input, upperMask);\n\n            uint8x16_t isLower = vceqq_u8(lowerCheck, lowerMask);\n            uint8x16_t isUpper = vceqq_u8(upperCheck, upperMask);\n\n            uint16x8_t lowerResult = vorrq_u8(vget_low_u8(isLower), vget_high_u8(isLower));\n            uint16x8_t upperResult = vorrq_u8(vget_low_u8(isUpper), vget_high_u8(isUpper));\n\n            if (vmaxvq_u8(lowerResult) != 0) hasLower = true;\n            if (vmaxvq_u8(upperResult) != 0) hasUpper = true;\n\n            if (hasLower && hasUpper) return false;\n        }\n\n        // Process remaining characters\n        for (; i < len; ++i) {\n            char c = data[i];\n            if (c >= 'a' && c <= 'z') {\n                hasLower = true;\n            } else if (c >= 'A' && c <= 'Z') {\n                hasUpper = true;\n            } else {\n                return false; // Non-alphabetic character found\n            }\n            if (hasLower && hasUpper) return false;\n        }\n    }\n\n    return !(hasLower && hasUpper);\n}\n```"}
{"task_id": "SimdBench_107_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        int len = key.length();\n\n        // Process 16 characters at a time using NEON intrinsics\n        int i = 0;\n        for (; i + 16 <= len; i += 16) {\n            uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&key[i]));\n\n            // Check for lowercase letters\n            uint8x16_t lower_check = vcgeq_u8(input, vdupq_n_u8('a'));\n            lower_check = vandq_u8(lower_check, vcleq_u8(input, vdupq_n_u8('z')));\n\n            // Check for uppercase letters\n            uint8x16_t upper_check = vcgeq_u8(input, vdupq_n_u8('A'));\n            upper_check = vandq_u8(upper_check, vcleq_u8(input, vdupq_n_u8('Z')));\n\n            // Combine results\n            uint8x16_t not_lower = vmvnq_u8(lower_check);\n            uint8x16_t not_upper = vmvnq_u8(upper_check);\n\n            all_lower &= !vmaxvq_u8(not_lower);\n            all_upper &= !vmaxvq_u8(not_upper);\n        }\n\n        // Process remaining characters\n        for (; i < len; ++i) {\n            char c = key[i];\n            all_lower &= (c >= 'a' && c <= 'z');\n            all_upper &= (c >= 'A' && c <= 'Z');\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_108_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n\n    // Helper function to check if a number is prime\n    auto is_prime = [](int x) -> bool {\n        if (x < 2) return false;\n        for (int i = 2; i * i <= x; ++i) {\n            if (x % i == 0) return false;\n        }\n        return true;\n    };\n\n    // Process numbers in chunks of 4 using NEON intrinsics\n    int limit = n;\n    int vec_size = 4;\n    int num_chunks = (limit + vec_size - 1) / vec_size;\n\n    for (int chunk = 0; chunk < num_chunks; ++chunk) {\n        int32x4_t nums = vdupq_n_s32(0); // Initialize vector with zeros\n        int32x4_t results = vdupq_n_s32(0); // Results vector\n\n        // Fill the vector with numbers for this chunk\n        for (int i = 0; i < vec_size; ++i) {\n            int val = chunk * vec_size + i + 2; // Start from 2\n            nums = vsetq_lane_s32(val, nums, i);\n        }\n\n        // Check primality for each number in the vector\n        for (int i = 0; i < vec_size; ++i) {\n            int val = vgetq_lane_s32(nums, i);\n            if (val >= n) break; // Stop if we exceed the limit\n            results = vsetq_lane_s32(is_prime(val) ? 1 : 0, results, i);\n        }\n\n        // Collect primes based on results\n        for (int i = 0; i < vec_size; ++i) {\n            if (vgetq_lane_s32(results, i) == 1) {\n                int val = vgetq_lane_s32(nums, i);\n                if (val < n) primes.push_back(val);\n            }\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n\n    // Helper function to check if a number is prime\n    auto is_prime = [](int x) -> bool {\n        if (x < 2) return false;\n        for (int i = 2; i * i <= x; ++i) {\n            if (x % i == 0) return false;\n        }\n        return true;\n    };\n\n    // Process numbers in chunks of 4 using NEON intrinsics\n    int limit = n;\n    int num_chunks = (limit + 3) / 4;\n    for (int chunk = 0; chunk < num_chunks; ++chunk) {\n        // Load 4 integers into a NEON register\n        int32x4_t vec = vld1q_s32(&chunk * 4 + 2); // Start from 2\n        uint32x4_t mask = vmovq_n_u32(1); // Initialize mask for primality\n\n        // Check primality for each element in the vector\n        for (int i = 2; i * i < limit; ++i) {\n            int32x4_t div = vmovq_n_s32(i);\n            uint32x4_t divisible = vceqq_s32(vmodq_s32(vec, div), vmovq_n_s32(0));\n            mask = vbicq_u32(mask, divisible); // Update mask\n        }\n\n        // Extract results from the mask\n        uint32_t result_mask = vgetq_lane_u32(mask, 0) |\n                               (vgetq_lane_u32(mask, 1) << 1) |\n                               (vgetq_lane_u32(mask, 2) << 2) |\n                               (vgetq_lane_u32(mask, 3) << 3);\n\n        // Add primes to the result vector\n        for (int i = 0; i < 4; ++i) {\n            if (result_mask & (1 << i)) {\n                int candidate = chunk * 4 + 2 + i;\n                if (candidate < n && is_prime(candidate)) {\n                    primes.push_back(candidate);\n                }\n            }\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n\n    // Helper function to check if a number is prime\n    auto is_prime = [](int x) -> bool {\n        if (x < 2) return false;\n        for (int i = 2; i * i <= x; ++i) {\n            if (x % i == 0) return false;\n        }\n        return true;\n    };\n\n    // Process in chunks of 4 using NEON intrinsics\n    int limit = n;\n    int num_chunks = (limit + 3) / 4;\n    for (int chunk = 0; chunk < num_chunks; ++chunk) {\n        int32x4_t vec = vdupq_n_s32(0); // Initialize vector\n        int base = chunk * 4 + 2; // Start from 2, as 0 and 1 are not prime\n\n        // Load 4 consecutive integers into the vector\n        for (int i = 0; i < 4; ++i) {\n            int val = base + i;\n            vec = vsetq_lane_s32(val, vec, i);\n        }\n\n        // Mask to filter values >= n\n        uint32x4_t mask = vcltq_s32(vec, vdupq_n_s32(n));\n\n        // Check primality for each element in the vector\n        uint32x4_t prime_mask = vmovq_n_u32(0);\n        for (int i = 0; i < 4; ++i) {\n            int val = vgetq_lane_s32(vec, i);\n            if (val < n && is_prime(val)) {\n                prime_mask = vorrq_u32(prime_mask, vsetq_lane_u32(1, vmovq_n_u32(0), i));\n            }\n        }\n\n        // Combine masks to filter valid primes\n        uint32x4_t combined_mask = vandq_u32(mask, prime_mask);\n\n        // Extract primes based on the combined mask\n        for (int i = 0; i < 4; ++i) {\n            if (vgetq_lane_u32(combined_mask, i)) {\n                primes.push_back(vgetq_lane_s32(vec, i));\n            }\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n\n    // Helper function to check if a number is prime\n    auto is_prime = [](int x) -> bool {\n        if (x < 2) return false;\n        for (int i = 2; i * i <= x; ++i) {\n            if (x % i == 0) return false;\n        }\n        return true;\n    };\n\n    // Process numbers in chunks of 4 using Neon intrinsics\n    int32x4_t vec, cmp;\n    int mask;\n    for (int i = 2; i < n; i += 4) {\n        // Load 4 integers into a Neon vector\n        vec = vld1q_s32(&i);\n\n        // Compare each element with n to ensure we don't exceed the limit\n        cmp = vcltq_s32(vec, vdupq_n_s32(n));\n\n        // Extract the comparison mask\n        mask = vget_lane_u32(vreinterpret_u32_s32(cmp), 0);\n\n        // Check each element in the vector\n        for (int j = 0; j < 4 && (i + j) < n; ++j) {\n            if (mask & (1 << j)) {\n                int num = i + j;\n                if (is_prime(num)) {\n                    primes.push_back(num);\n                }\n            }\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n\n    // Helper function to check if a number is prime\n    auto is_prime = [](int x) -> bool {\n        if (x < 2) return false;\n        for (int i = 2; i * i <= x; ++i) {\n            if (x % i == 0) return false;\n        }\n        return true;\n    };\n\n    // Process numbers in chunks of 4 using NEON intrinsics\n    int32x4_t vec, cmp;\n    int limit = (n + 3) / 4 * 4; // Round up to the nearest multiple of 4\n    for (int i = 2; i < limit; i += 4) {\n        // Load 4 integers into a NEON vector\n        vec = vld1q_s32(&i);\n\n        // Create a mask for numbers less than n\n        int32x4_t mask = vdupq_n_s32(n);\n        uint32x4_t valid_mask = vcltq_s32(vec, mask);\n\n        // Check primality for each element in the vector\n        uint32x4_t prime_mask = vmovq_n_u32(0);\n        for (int j = 0; j < 4; ++j) {\n            int val = vgetq_lane_s32(vec, j);\n            if (val < n && is_prime(val)) {\n                prime_mask = vorrq_u32(prime_mask, vsetq_lane_u32(1, prime_mask, j));\n            }\n        }\n\n        // Combine masks to filter valid primes\n        uint32x4_t combined_mask = vandq_u32(valid_mask, prime_mask);\n\n        // Extract results and add primes to the vector\n        for (int j = 0; j < 4; ++j) {\n            if (vgetq_lane_u32(combined_mask, j)) {\n                primes.push_back(vgetq_lane_s32(vec, j));\n            }\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_109_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint count_upper_simd(const std::string & s) {\n    int count = 0;\n    int length = s.length();\n    const char* data = s.c_str();\n\n    // Process 16 characters at a time\n    int i = 0;\n    for (; i + 15 < length; i += 16) {\n        // Load 16 characters into a vector\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(data + i));\n\n        // Create masks for uppercase vowels ('A', 'E', 'I', 'O', 'U')\n        uint8x16_t maskA = vceqq_u8(chars, vdupq_n_u8('A'));\n        uint8x16_t maskE = vceqq_u8(chars, vdupq_n_u8('E'));\n        uint8x16_t maskI = vceqq_u8(chars, vdupq_n_u8('I'));\n        uint8x16_t maskO = vceqq_u8(chars, vdupq_n_u8('O'));\n        uint8x16_t maskU = vceqq_u8(chars, vdupq_n_u8('U'));\n\n        // Combine all vowel masks\n        uint8x16_t vowelMask = vorrq_u8(maskA, maskE);\n        vowelMask = vorrq_u8(vowelMask, maskI);\n        vowelMask = vorrq_u8(vowelMask, maskO);\n        vowelMask = vorrq_u8(vowelMask, maskU);\n\n        // Create a mask for even indices (0, 2, 4, ..., 14)\n        uint8x16_t evenIndexMask = vsetq_lane_u8(0xFF, vdupq_n_u8(0), 0);\n        evenIndexMask = vsetq_lane_u8(0xFF, evenIndexMask, 2);\n        evenIndexMask = vsetq_lane_u8(0xFF, evenIndexMask, 4);\n        evenIndexMask = vsetq_lane_u8(0xFF, evenIndexMask, 6);\n        evenIndexMask = vsetq_lane_u8(0xFF, evenIndexMask, 8);\n        evenIndexMask = vsetq_lane_u8(0xFF, evenIndexMask, 10);\n        evenIndexMask = vsetq_lane_u8(0xFF, evenIndexMask, 12);\n        evenIndexMask = vsetq_lane_u8(0xFF, evenIndexMask, 14);\n\n        // Apply the even index mask\n        uint8x16_t combinedMask = vandq_u8(vowelMask, evenIndexMask);\n\n        // Count the number of matches\n        uint8x16_t sumVector = vpaddlq_u8(combinedMask);\n        sumVector = vpaddlq_u16(sumVector);\n        sumVector = vpaddlq_u32(sumVector);\n        count += vgetq_lane_u64(sumVector, 0);\n    }\n\n    // Process remaining characters\n    for (; i < length; ++i) {\n        if (i % 2 == 0 && (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            ++count;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint count_upper_simd(const std::string & s) {\n    int count = 0;\n    int length = s.length();\n    const char* data = s.data();\n\n    // Process 16 characters at a time\n    int i = 0;\n    for (; i + 15 < length; i += 16) {\n        // Load 16 characters into a vector\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(data + i));\n\n        // Create a mask for even indices (0, 2, 4, ..., 14)\n        uint8x16_t even_mask = {0, 255, 0, 255, 0, 255, 0, 255, 0, 255, 0, 255, 0, 255, 0, 255};\n        uint8x16_t even_chars = vandq_u8(input, even_mask);\n\n        // Check for uppercase vowels ('A', 'E', 'I', 'O', 'U')\n        uint8x16_t vowel_A = vdupq_n_u8('A');\n        uint8x16_t vowel_E = vdupq_n_u8('E');\n        uint8x16_t vowel_I = vdupq_n_u8('I');\n        uint8x16_t vowel_O = vdupq_n_u8('O');\n        uint8x16_t vowel_U = vdupq_n_u8('U');\n\n        uint8x16_t is_A = vceqq_u8(even_chars, vowel_A);\n        uint8x16_t is_E = vceqq_u8(even_chars, vowel_E);\n        uint8x16_t is_I = vceqq_u8(even_chars, vowel_I);\n        uint8x16_t is_O = vceqq_u8(even_chars, vowel_O);\n        uint8x16_t is_U = vceqq_u8(even_chars, vowel_U);\n\n        uint8x16_t is_vowel = vorrq_u8(vorrq_u8(vorrq_u8(is_A, is_E), vorrq_u8(is_I, is_O)), is_U);\n\n        // Count the number of matches\n        uint8x16_t match_count = vshrq_n_u8(is_vowel, 7); // Extract the most significant bit\n        uint16x8_t sum_low = vpaddlq_u8(match_count);\n        uint32x4_t sum_high = vpaddlq_u16(sum_low);\n        uint64x2_t sum_total = vpaddlq_u32(sum_high);\n\n        count += vgetq_lane_u64(sum_total, 0) + vgetq_lane_u64(sum_total, 1);\n    }\n\n    // Process remaining characters\n    for (; i < length; i += 2) {\n        if (i % 2 == 0 && (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint count_upper_simd(const std::string & s) {\n    int count = 0;\n    int length = s.length();\n    const char* data = s.data();\n\n    // Process 16 characters at a time\n    int i = 0;\n    for (; i + 15 < length; i += 16) {\n        // Load 16 characters into a vector\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(data + i));\n\n        // Create a mask for even indices (0, 2, 4, ..., 14)\n        uint8x16_t even_mask = {1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0};\n        uint8x16_t even_chars = vandq_u8(chars, even_mask);\n\n        // Check for uppercase vowels ('A', 'E', 'I', 'O', 'U')\n        uint8x16_t vowel_A = vdupq_n_u8('A');\n        uint8x16_t vowel_E = vdupq_n_u8('E');\n        uint8x16_t vowel_I = vdupq_n_u8('I');\n        uint8x16_t vowel_O = vdupq_n_u8('O');\n        uint8x16_t vowel_U = vdupq_n_u8('U');\n\n        uint8x16_t is_A = vceqq_u8(even_chars, vowel_A);\n        uint8x16_t is_E = vceqq_u8(even_chars, vowel_E);\n        uint8x16_t is_I = vceqq_u8(even_chars, vowel_I);\n        uint8x16_t is_O = vceqq_u8(even_chars, vowel_O);\n        uint8x16_t is_U = vceqq_u8(even_chars, vowel_U);\n\n        uint8x16_t is_vowel = vorrq_u8(vorrq_u8(vorrq_u8(is_A, is_E), vorrq_u8(is_I, is_O)), is_U);\n\n        // Count the number of matches\n        uint8x16_t mask = {1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0};\n        uint8x16_t masked_vowels = vandq_u8(is_vowel, mask);\n\n        uint8x8_t sum_low = vpadd_u8(vget_low_u8(masked_vowels), vget_high_u8(masked_vowels));\n        uint8x8_t sum_high = vpadd_u8(sum_low, sum_low);\n        uint8x8_t total_sum = vpadd_u8(sum_high, sum_high);\n\n        count += vget_lane_u8(total_sum, 0);\n    }\n\n    // Process remaining characters\n    for (; i < length; i += 2) {\n        if (i % 2 == 0 && (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint count_upper_simd(const std::string & s) {\n    int count = 0;\n    int len = s.length();\n    const char* data = s.c_str();\n\n    // Process 16 characters at a time\n    int i = 0;\n    for (; i <= len - 16; i += 16) {\n        // Load 16 characters\n        uint8x16_t chars = vld1q_u8((const uint8_t*)(data + i));\n\n        // Create mask for uppercase vowels ('A', 'E', 'I', 'O', 'U')\n        uint8x16_t vowel_mask_A = vceqq_u8(chars, vdupq_n_u8('A'));\n        uint8x16_t vowel_mask_E = vceqq_u8(chars, vdupq_n_u8('E'));\n        uint8x16_t vowel_mask_I = vceqq_u8(chars, vdupq_n_u8('I'));\n        uint8x16_t vowel_mask_O = vceqq_u8(chars, vdupq_n_u8('O'));\n        uint8x16_t vowel_mask_U = vceqq_u8(chars, vdupq_n_u8('U'));\n\n        // Combine all vowel masks\n        uint8x16_t vowel_mask = vorrq_u8(vowel_mask_A, vowel_mask_E);\n        vowel_mask = vorrq_u8(vowel_mask, vowel_mask_I);\n        vowel_mask = vorrq_u8(vowel_mask, vowel_mask_O);\n        vowel_mask = vorrq_u8(vowel_mask, vowel_mask_U);\n\n        // Create mask for even indices (0, 2, 4, ..., 14)\n        uint8x16_t even_index_mask = vsetq_lane_u8(0xFF, vdupq_n_u8(0), 0);\n        even_index_mask = vsetq_lane_u8(0xFF, even_index_mask, 2);\n        even_index_mask = vsetq_lane_u8(0xFF, even_index_mask, 4);\n        even_index_mask = vsetq_lane_u8(0xFF, even_index_mask, 6);\n        even_index_mask = vsetq_lane_u8(0xFF, even_index_mask, 8);\n        even_index_mask = vsetq_lane_u8(0xFF, even_index_mask, 10);\n        even_index_mask = vsetq_lane_u8(0xFF, even_index_mask, 12);\n        even_index_mask = vsetq_lane_u8(0xFF, even_index_mask, 14);\n\n        // Combine with even index mask\n        uint8x16_t combined_mask = vandq_u8(vowel_mask, even_index_mask);\n\n        // Count the number of matches\n        uint8x16_t result = vpaddq_u8(combined_mask, combined_mask);\n        result = vpaddq_u8(result, result);\n        result = vpaddq_u8(result, result);\n        count += vgetq_lane_u8(result, 0);\n    }\n\n    // Process remaining characters\n    for (; i < len; ++i) {\n        if (i % 2 == 0 && (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            ++count;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint count_upper_simd(const std::string & s) {\n    int count = 0;\n    int length = s.length();\n    const char* data = s.data();\n\n    // Process 16 characters at a time\n    int i = 0;\n    for (; i + 15 < length; i += 16) {\n        // Load 16 characters into a SIMD register\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(data + i));\n\n        // Create masks for uppercase vowels ('A', 'E', 'I', 'O', 'U')\n        uint8x16_t mask_A = vceqq_u8(input, vdupq_n_u8('A'));\n        uint8x16_t mask_E = vceqq_u8(input, vdupq_n_u8('E'));\n        uint8x16_t mask_I = vceqq_u8(input, vdupq_n_u8('I'));\n        uint8x16_t mask_O = vceqq_u8(input, vdupq_n_u8('O'));\n        uint8x16_t mask_U = vceqq_u8(input, vdupq_n_u8('U'));\n\n        // Combine all vowel masks\n        uint8x16_t vowel_mask = vorrq_u8(mask_A, mask_E);\n        vowel_mask = vorrq_u8(vowel_mask, mask_I);\n        vowel_mask = vorrq_u8(vowel_mask, mask_O);\n        vowel_mask = vorrq_u8(vowel_mask, mask_U);\n\n        // Create a mask for even indices (0, 2, 4, ..., 14)\n        uint8x16_t even_index_mask = vsetq_lane_u8(0xFF, vdupq_n_u8(0), 0);\n        even_index_mask = vsetq_lane_u8(0xFF, even_index_mask, 2);\n        even_index_mask = vsetq_lane_u8(0xFF, even_index_mask, 4);\n        even_index_mask = vsetq_lane_u8(0xFF, even_index_mask, 6);\n        even_index_mask = vsetq_lane_u8(0xFF, even_index_mask, 8);\n        even_index_mask = vsetq_lane_u8(0xFF, even_index_mask, 10);\n        even_index_mask = vsetq_lane_u8(0xFF, even_index_mask, 12);\n        even_index_mask = vsetq_lane_u8(0xFF, even_index_mask, 14);\n\n        // Apply the even index mask to filter only even positions\n        uint8x16_t filtered_mask = vandq_u8(vowel_mask, even_index_mask);\n\n        // Count the number of matches\n        uint8_t temp[16];\n        vst1q_u8(temp, filtered_mask);\n        for (int j = 0; j < 16; j += 2) {\n            count += (temp[j] != 0);\n        }\n    }\n\n    // Process remaining characters\n    for (; i < length; i += 2) {\n        if (i % 2 == 0 && (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_110_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    int32x4_t increment = vdupq_n_s32(2); // Increment by 2 for odd/even continuation\n    int32x4_t level = vdupq_n_s32(n);    // Start with n stones\n\n    int i = 0;\n    for (; i + 4 <= n; i += 4) {\n        vst1q_s32(&result[i], level);    // Store current levels into result\n        level = vaddq_s32(level, increment); // Add increment to compute next levels\n    }\n\n    // Handle remaining elements\n    if (i < n) {\n        int32x4_t temp_result = level;\n        for (; i < n; ++i) {\n            result[i] = vgetq_lane_s32(temp_result, 0);\n            temp_result = vextq_s32(temp_result, temp_result, 1); // Shift vector left\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    int32x4_t increment = vdupq_n_s32(2); // Increment by 2 for odd/even sequence\n    int32x4_t level = vdupq_n_s32(n);     // Start with n stones\n\n    int i = 0;\n    for (; i + 4 <= n; i += 4) {\n        // Store current levels into the result vector\n        vst1q_s32(&result[i], level);\n        // Update levels for the next iteration\n        level = vaddq_s32(level, increment);\n    }\n\n    // Handle remaining elements (if n is not a multiple of 4)\n    for (; i < n; ++i) {\n        result[i] = n + 2 * i;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    int32x4_t increment = vdupq_n_s32(2); // Increment by 2 for odd/even sequence\n    int32x4_t level = vdupq_n_s32(n);    // Start with n stones\n\n    int i = 0;\n    for (; i + 4 <= n; i += 4) {\n        // Store current levels into result\n        vst1q_s32(&result[i], level);\n        // Update levels for next iteration\n        level = vaddq_s32(level, increment);\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        result[i] = n + 2 * i;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    int32x4_t increment = vdupq_n_s32(2); // Increment by 2 for odd/even sequence\n    int32x4_t level = vdupq_n_s32(n);    // Start with n stones\n\n    int i = 0;\n    for (; i + 4 <= n; i += 4) {\n        // Store the current levels into the result\n        vst1q_s32(&result[i], level);\n        // Update the levels for the next iteration\n        level = vaddq_s32(level, increment);\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        result[i] = n + 2 * i;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    int32x4_t v_n = vmovq_n_s32(n);\n    int32x4_t v_step = vmovq_n_s32(2);\n    int32x4_t v_index = vmovq_n_s32(0);\n    int32x4_t v_increment = vmovq_n_s32(1);\n\n    for (int i = 0; i < n; i += 4) {\n        int32x4_t v_current = vaddq_s32(v_n, vmulq_s32(v_index, v_step));\n        vst1q_s32(&result[i], v_current);\n        v_index = vaddq_s32(v_index, v_increment);\n    }\n\n    // Handle remaining elements if n is not a multiple of 4\n    for (int i = (n / 4) * 4; i < n; ++i) {\n        result[i] = n + i * 2;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_111_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <bitset>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n\n    int64x2_t vn = vdupq_n_s64(n);\n    int64x2_t vm = vdupq_n_s64(m);\n\n    // Compute sum of integers from n to m using the formula: sum = (m - n + 1) * (n + m) / 2\n    int64x2_t count = vaddq_s64(vsubq_s64(vm, vn), vdupq_n_s64(1));\n    int64x2_t sum = vmulq_s64(vaddq_s64(vn, vm), count);\n    sum = vshrq_n_s64(sum, 1); // Divide by 2\n\n    // Compute average by dividing sum by count\n    int64x2_t avg = vdivq_s64(sum, count);\n\n    // Extract the result and convert to binary\n    int64_t result = vgetq_lane_s64(avg, 0);\n    std::string binary = std::bitset<64>(result).to_string();\n\n    // Remove leading zeros\n    size_t first_one = binary.find('1');\n    return first_one != std::string::npos ? binary.substr(first_one) : \"0\";\n}\n```"}
{"task_id": "SimdBench_111_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n\n    int64x2_t vn = vdupq_n_s64(n);\n    int64x2_t vm = vdupq_n_s64(m);\n\n    // Compute sum of integers from n to m using the formula: sum = (m - n + 1) * (n + m) / 2\n    int64x2_t count = vaddq_s64(vsubq_s64(vm, vn), vdupq_n_s64(1));\n    int64x2_t sum = vmulq_s64(vaddq_s64(vn, vm), count);\n    sum = vshrq_n_s64(sum, 1); // Divide by 2\n\n    // Compute average\n    int64x2_t avg = vdivq_s64(sum, count);\n\n    // Extract the result and convert to binary\n    int64_t result = vgetq_lane_s64(avg, 0);\n    if (result < 0) return \"-1\";\n\n    std::string binary = \"\";\n    while (result > 0) {\n        binary = char('0' + (result & 1)) + binary;\n        result >>= 1;\n    }\n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_111_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <bitset>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n\n    int64x2_t vn = vdupq_n_s64(n);\n    int64x2_t vm = vdupq_n_s64(m);\n\n    // Compute sum of integers from n to m using the formula: sum = (m - n + 1) * (n + m) / 2\n    int64x2_t count = vaddq_s64(vsubq_s64(vm, vn), vdupq_n_s64(1));\n    int64x2_t sum = vmulq_s64(vaddq_s64(vn, vm), count);\n    sum = vshrq_n_s64(sum, 1); // Divide by 2\n\n    // Compute average\n    int64x2_t avg = vdivq_s64(sum, count);\n\n    // Extract the result and convert to binary\n    int64_t result = vgetq_lane_s64(avg, 0);\n    std::string binary = std::bitset<64>(result).to_string();\n\n    // Remove leading zeros\n    size_t first_one = binary.find('1');\n    return first_one != std::string::npos ? binary.substr(first_one) : \"0\";\n}\n```"}
{"task_id": "SimdBench_111_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n\n    int64x2_t vn = vdupq_n_s64(n);\n    int64x2_t vm = vdupq_n_s64(m);\n\n    // Compute the sum of integers from n to m using the formula for arithmetic series\n    int64x2_t sum_vec = vaddq_s64(vn, vm);\n    sum_vec = vmlaq_n_s64(vdupq_n_s64(0), sum_vec, (m - n + 1) / 2);\n\n    // Handle the case where (m - n + 1) is odd\n    int64_t remainder = (m - n + 1) % 2;\n    if (remainder) {\n        sum_vec = vaddq_s64(sum_vec, vdupq_n_s64((n + m) / 2));\n    }\n\n    // Compute the average by dividing the sum by (m - n + 1)\n    int64x2_t count_vec = vdupq_n_s64(m - n + 1);\n    int64x2_t avg_vec = vdivq_s64(sum_vec, count_vec);\n\n    // Extract the result and convert to binary\n    int64_t avg = vgetq_lane_s64(avg_vec, 0);\n    std::string binary = \"\";\n    if (avg == 0) {\n        binary = \"0\";\n    } else {\n        while (avg > 0) {\n            binary = char('0' + (avg & 1)) + binary;\n            avg >>= 1;\n        }\n    }\n\n    return binary;\n}\n```"}
{"task_id": "SimdBench_111_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <bitset>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n\n    int64x2_t vn = vdupq_n_s64(n);\n    int64x2_t vm = vdupq_n_s64(m);\n\n    // Compute sum of integers from n to m using the formula: sum = (m - n + 1) * (n + m) / 2\n    int64x2_t count = vaddq_s64(vsubq_s64(vm, vn), vdupq_n_s64(1));\n    int64x2_t sum = vmulq_s64(vaddq_s64(vn, vm), count);\n    sum = vshrq_n_s64(sum, 1); // Divide by 2\n\n    // Compute average\n    int64x2_t avg = vdivq_s64(sum, count);\n\n    // Extract the result and convert to binary\n    int64_t result = vgetq_lane_s64(avg, 0);\n    std::string binary = std::bitset<64>(result).to_string();\n\n    // Remove leading zeros\n    size_t first_one = binary.find('1');\n    return first_one != std::string::npos ? binary.substr(first_one) : \"0\";\n}\n```"}
{"task_id": "SimdBench_112_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    int16x8_t v_mod = vdupq_n_s16(10000);\n    int16x8_t v_even_factorial = vdupq_n_s16(1);\n    int16x8_t v_odd_sum = vdupq_n_s16(0);\n    int16x8_t v_index = vdupq_n_s16(1);\n\n    for (int i = 0; i < n; i += 8) {\n        int16x8_t v_mask = vtstq_s16(vandq_s16(v_index, vdupq_n_s16(1)), vdupq_n_s16(1));\n        int16x8_t v_factorial_mod = vmodq_s16(v_even_factorial, v_mod);\n        int16x8_t v_sum = vmlaq_s16(vdupq_n_s16(0), v_index, vdupq_n_s16(1));\n\n        int16x8_t v_result = vbslq_s16(v_mask, v_sum, v_factorial_mod);\n\n        vst1q_s16(result.data() + i, v_result);\n\n        v_even_factorial = vmulq_s16(v_even_factorial, v_index);\n        v_odd_sum = vaddq_s16(v_odd_sum, v_index);\n        v_index = vaddq_s16(v_index, vdupq_n_s16(1));\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    int16x8_t v_mod = vdupq_n_s16(10000);\n    int16x8_t v_even_factorial = vdupq_n_s16(1);\n    int16x8_t v_odd_sum = vdupq_n_s16(0);\n    int16x8_t v_index = vdupq_n_s16(1);\n\n    for (int i = 0; i < n; i += 8) {\n        int16x8_t v_mask = vtstq_s16(vandq_s16(v_index, vdupq_n_s16(1)), vdupq_n_s16(1));\n        \n        // Compute factorial for even indices\n        int16x8_t v_factorial = vdupq_n_s16(1);\n        for (int j = 2; j <= n; ++j) {\n            int16x8_t v_j = vdupq_n_s16(j);\n            v_factorial = vmulq_s16(v_factorial, v_j);\n            v_factorial = vqdmulhq_s16(v_factorial, v_mod);\n        }\n        v_even_factorial = v_factorial;\n\n        // Compute sum for odd indices\n        v_odd_sum = vaddq_s16(v_odd_sum, v_index);\n\n        // Blend results based on mask\n        int16x8_t v_result = vbslq_s16(v_mask, v_odd_sum, v_even_factorial);\n\n        // Store results into the output vector\n        vst1q_s16(result.data() + i, v_result);\n\n        // Increment index vector\n        v_index = vaddq_s16(v_index, vdupq_n_s16(8));\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    int16x8_t v_mod = vdupq_n_s16(10000);\n    int16x8_t v_even_factorial = vdupq_n_s16(1);\n    int16x8_t v_odd_sum = vdupq_n_s16(0);\n    int16x8_t v_index = vdupq_n_s16(1);\n\n    for (int i = 0; i < n; i += 8) {\n        int16x8_t v_mask = vtstq_s16(vandq_s16(v_index, vdupq_n_s16(1)), vdupq_n_s16(1));\n        \n        // Compute factorial for even indices\n        int16x8_t v_factorial = v_even_factorial;\n        for (int j = 2; j <= 8; ++j) {\n            v_factorial = vmulq_s16(v_factorial, vdupq_n_s16(j));\n            v_factorial = vqdmulhq_s16(v_factorial, v_mod); // Modulo operation\n        }\n\n        // Compute sum for odd indices\n        int16x8_t v_sum = vaddq_s16(v_odd_sum, v_index);\n\n        // Blend results based on even/odd mask\n        int16x8_t v_result = vbslq_s16(v_mask, v_sum, v_factorial);\n\n        // Store results into the output vector\n        vst1q_s16(result.data() + i, v_result);\n\n        // Update indices and accumulators\n        v_index = vaddq_s16(v_index, vdupq_n_s16(8));\n        v_even_factorial = v_factorial;\n        v_odd_sum = v_sum;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    int16x8_t v_mod = vdupq_n_s16(10000);\n    int16x8_t v_ones = vdupq_n_s16(1);\n    int16x8_t v_even_fact = vdupq_n_s16(1);\n    int16x8_t v_odd_sum = vdupq_n_s16(0);\n    int16x8_t v_index = vdupq_n_s16(1);\n\n    for (int i = 0; i < n; i += 8) {\n        int16x8_t v_mask = vtstq_s16(vandq_s16(v_index, v_ones), v_ones); // Check if even\n\n        // Compute factorial for even indices\n        int16x8_t v_temp_fact = v_even_fact;\n        for (int j = 2; j <= 8; ++j) {\n            v_temp_fact = vmulq_s16(v_temp_fact, v_index);\n            v_index = vaddq_s16(v_index, v_ones);\n        }\n        v_temp_fact = vqdmulhq_s16(v_temp_fact, v_mod); // Modulo 10000\n        v_even_fact = vbslq_s16(v_mask, v_even_fact, v_temp_fact);\n\n        // Compute sum for odd indices\n        int16x8_t v_temp_sum = vaddq_s16(v_odd_sum, v_index);\n        v_odd_sum = vbslq_s16(v_mask, v_temp_sum, v_odd_sum);\n\n        // Combine results\n        int16x8_t v_result = vbslq_s16(v_mask, v_odd_sum, v_even_fact);\n\n        // Store results\n        vst1q_s16(result.data() + i, v_result);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    int16x8_t veven = vmovq_n_s16(1); // Factorial base case for even indices\n    int16x8_t vodd = vmovq_n_s16(0);  // Sum base case for odd indices\n    int16x8_t vidx = vmovq_n_s16(1);  // Index vector\n\n    for (int i = 0; i < n; i += 8) {\n        int16x8_t mask_even = vtstq_s16(vandq_s16(vidx, vmovq_n_s16(1)), vmovq_n_s16(0));\n        int16x8_t mask_odd = vmvnq_s16(mask_even);\n\n        // Update factorial for even indices\n        int16x8_t vfact = veven;\n        for (int j = 2; j <= n; ++j) {\n            int16x8_t vmul = vmovq_n_s16(j);\n            vfact = vmulq_s16(vfact, vmul);\n            veven = vbslq_s16(mask_even, vfact, veven);\n        }\n        veven = vmodq_s16(veven, vmovq_n_s16(10000)); // Modulo 10000\n\n        // Update sum for odd indices\n        int16x8_t vsum = vaddq_s16(vodd, vidx);\n        vodd = vbslq_s16(mask_odd, vsum, vodd);\n\n        // Combine results\n        int16x8_t vresult = vbslq_s16(mask_even, veven, vodd);\n        vst1q_s16(&result[i], vresult);\n\n        // Increment index vector\n        vidx = vaddq_s16(vidx, vmovq_n_s16(8));\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_113_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0, odd_count = 0;\n    int16x8_t v_even = vmovq_n_s16(0);\n    int16x8_t v_odd = vmovq_n_s16(0);\n\n    for (int i = 1; i <= n; i += 8) {\n        int16x8_t v_i = vld1q_s16((int16_t*)&i);\n        uint16x8_t v_palindrome = vmovq_n_u16(0);\n\n        // Check if numbers are palindromes\n        for (int j = 0; j < 8; ++j) {\n            int num = i + j;\n            if (num > n) break;\n\n            int original = num, reversed = 0;\n            while (num > 0) {\n                reversed = reversed * 10 + (num % 10);\n                num /= 10;\n            }\n            if (original == reversed) {\n                v_palindrome = vsetq_lane_u16(1, v_palindrome, j);\n            }\n        }\n\n        // Separate even and odd palindromes\n        uint16x8_t v_is_even = vandq_u16(v_palindrome, vmovq_n_u16(1));\n        uint16x8_t v_is_odd = vbicq_u16(v_palindrome, vmovq_n_u16(1));\n\n        // Accumulate counts\n        v_even = vaddq_s16(v_even, vreinterpretq_s16_u16(v_is_even));\n        v_odd = vaddq_s16(v_odd, vreinterpretq_s16_u16(v_is_odd));\n    }\n\n    // Sum up the results from the SIMD registers\n    int16_t temp_even[8], temp_odd[8];\n    vst1q_s16(temp_even, v_even);\n    vst1q_s16(temp_odd, v_odd);\n\n    for (int j = 0; j < 8; ++j) {\n        even_count += temp_even[j];\n        odd_count += temp_odd[j];\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0, odd_count = 0;\n    int16x8_t v_even_count = vmovq_n_s16(0);\n    int16x8_t v_odd_count = vmovq_n_s16(0);\n\n    for (int i = 1; i <= n; i += 8) {\n        int16x8_t v_i = vld1q_s16((int16_t*)&i);\n        uint16x8_t v_palindrome = vmovq_n_u16(0);\n\n        // Check if numbers are palindromes\n        for (int j = 0; j < 8; ++j) {\n            int num = i + j;\n            if (num > n) break;\n\n            int original = num, reversed = 0;\n            while (original > 0) {\n                reversed = reversed * 10 + (original % 10);\n                original /= 10;\n            }\n            if (reversed == num) {\n                v_palindrome = vsetq_lane_u16(1, v_palindrome, j);\n            }\n        }\n\n        // Separate even and odd palindromes\n        uint16x8_t v_is_even = vandq_u16(v_palindrome, vmovq_n_u16(1));\n        uint16x8_t v_is_odd = vbicq_u16(v_palindrome, vmovq_n_u16(1));\n\n        // Accumulate counts\n        v_even_count = vaddq_s16(v_even_count, vmovl_s16(vget_low_s16(vreinterpretq_s16_u16(v_is_even))));\n        v_odd_count = vaddq_s16(v_odd_count, vmovl_s16(vget_low_s16(vreinterpretq_s16_u16(v_is_odd))));\n    }\n\n    // Sum up the results from the vector registers\n    for (int j = 0; j < 8; ++j) {\n        even_count += vgetq_lane_s16(v_even_count, j);\n        odd_count += vgetq_lane_s16(v_odd_count, j);\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0, odd_count = 0;\n    int16x8_t v_even = vmovq_n_s16(0);\n    int16x8_t v_odd = vmovq_n_s16(0);\n\n    for (int i = 1; i <= n; i += 8) {\n        int16x8_t v_i = vld1q_s16((int16_t*)&i);\n        uint16x8_t v_palindrome = vmovq_n_u16(0);\n\n        // Check if numbers are palindromes\n        for (int j = 0; j < 8; ++j) {\n            int num = i + j;\n            if (num > n) break;\n\n            int original = num, reversed = 0;\n            while (num > 0) {\n                reversed = reversed * 10 + (num % 10);\n                num /= 10;\n            }\n            if (original == reversed) {\n                v_palindrome[j] = 1;\n            }\n        }\n\n        // Separate even and odd palindromes\n        uint16x8_t v_is_even = vandq_u16(v_palindrome, vmovq_n_u16(1));\n        uint16x8_t v_is_odd = vbicq_u16(v_palindrome, v_is_even);\n\n        // Accumulate counts\n        v_even = vaddq_s16(v_even, vreinterpretq_s16_u16(v_is_even));\n        v_odd = vaddq_s16(v_odd, vreinterpretq_s16_u16(v_is_odd));\n    }\n\n    // Sum up the results from the SIMD registers\n    int16_t temp_even[8], temp_odd[8];\n    vst1q_s16(temp_even, v_even);\n    vst1q_s16(temp_odd, v_odd);\n\n    for (int j = 0; j < 8; ++j) {\n        even_count += temp_even[j];\n        odd_count += temp_odd[j];\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0, odd_count = 0;\n    int16x8_t v_even_count = vmovq_n_s16(0);\n    int16x8_t v_odd_count = vmovq_n_s16(0);\n\n    for (int i = 1; i <= n; i += 8) {\n        int16x8_t v_i = vld1q_s16((int16_t*)&i);\n        uint16x8_t v_palindrome = vmovq_n_u16(0);\n\n        // Check if numbers are palindromes\n        for (int j = 0; j < 8; ++j) {\n            int num = i + j;\n            if (num > n) break;\n\n            int original = num, reversed = 0;\n            while (num > 0) {\n                reversed = reversed * 10 + (num % 10);\n                num /= 10;\n            }\n            if (original == reversed) {\n                v_palindrome = vsetq_lane_u16(1, v_palindrome, j);\n            }\n        }\n\n        // Separate even and odd palindromes\n        uint16x8_t v_is_even = vandq_u16(v_palindrome, vmovq_n_u16(1));\n        uint16x8_t v_is_odd = vbicq_u16(v_palindrome, v_is_even);\n\n        // Update counts\n        v_even_count = vaddq_s16(v_even_count, vreinterpretq_s16_u16(v_is_even));\n        v_odd_count = vaddq_s16(v_odd_count, vreinterpretq_s16_u16(v_is_odd));\n    }\n\n    // Sum up the results from the SIMD registers\n    for (int j = 0; j < 8; ++j) {\n        even_count += vgetq_lane_s16(v_even_count, j);\n        odd_count += vgetq_lane_s16(v_odd_count, j);\n    }\n\n    return std::vector<int>{even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0, odd_count = 0;\n    int16x8_t v_even = vmovq_n_s16(0);\n    int16x8_t v_odd = vmovq_n_s16(0);\n\n    for (int i = 1; i <= n; i += 8) {\n        int16x8_t v_i = vld1q_s16((int16_t*)&i);\n        uint16x8_t v_palindrome = vmovq_n_u16(0);\n\n        // Check if numbers are palindromes\n        for (int j = 0; j < 8; ++j) {\n            int num = i + j;\n            if (num > n) break;\n\n            int original = num, reversed = 0;\n            while (num > 0) {\n                reversed = reversed * 10 + (num % 10);\n                num /= 10;\n            }\n            if (reversed == original) {\n                v_palindrome = vsetq_lane_u16(1, v_palindrome, j);\n            }\n        }\n\n        // Separate even and odd palindromes\n        uint16x8_t v_is_even = vandq_u16(v_palindrome, vmovq_n_u16(1));\n        uint16x8_t v_is_odd = vbicq_u16(v_palindrome, vmovq_n_u16(1));\n\n        // Accumulate counts\n        v_even = vaddq_s16(v_even, vreinterpretq_s16_u16(v_is_even));\n        v_odd = vaddq_s16(v_odd, vreinterpretq_s16_u16(v_is_odd));\n    }\n\n    // Sum up the results from the SIMD registers\n    int16_t temp_even[8], temp_odd[8];\n    vst1q_s16(temp_even, v_even);\n    vst1q_s16(temp_odd, v_odd);\n\n    for (int j = 0; j < 8; ++j) {\n        even_count += temp_even[j];\n        odd_count += temp_odd[j];\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_114_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    int size = n.size();\n    int i = 0;\n\n    // Process 4 integers at a time using NEON intrinsics\n    for (; i <= size - 4; i += 4) {\n        // Load 4 integers into a NEON register\n        int32x4_t vec = vld1q_s32(&n[i]);\n\n        // Mask to identify negative numbers\n        uint32x4_t is_negative = vcgtq_s32(vdupq_n_s32(0), vec);\n\n        // Absolute values of the integers\n        int32x4_t abs_vals = vabsq_s32(vec);\n\n        // Extract digits and compute their sum\n        int32x4_t sum_digits = vdupq_n_s32(0);\n        int32x4_t temp = abs_vals;\n\n        while (vmaxvq_s32(temp) > 0) {\n            // Extract the last digit\n            int32x4_t digit = vmodq_s32(temp, vdupq_n_s32(10));\n\n            // Add the digit to the sum\n            sum_digits = vaddq_s32(sum_digits, digit);\n\n            // Remove the last digit\n            temp = vdivq_s32(temp, vdupq_n_s32(10));\n        }\n\n        // Adjust the first digit for negative numbers\n        int32x4_t first_digit = vnegq_s32(vshrq_n_s32(abs_vals, 31));\n        sum_digits = vaddq_s32(sum_digits, vandq_s32(first_digit, vreinterpretq_s32_u32(is_negative)));\n\n        // Check if the sum of digits is greater than 0\n        uint32x4_t is_sum_positive = vcgtq_s32(sum_digits, vdupq_n_s32(0));\n\n        // Count the number of elements with sum of digits > 0\n        count += vaddvq_u32(is_sum_positive);\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        int num = n[i];\n        int sum = 0;\n        int sign = (num < 0) ? -1 : 1;\n        num = abs(num);\n\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n\n        if (sign == -1) {\n            sum = -sum;\n        }\n\n        if (sum > 0) {\n            ++count;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    int size = n.size();\n    int i = 0;\n\n    // Process 4 integers at a time using NEON intrinsics\n    for (; i <= size - 4; i += 4) {\n        // Load 4 integers into a NEON register\n        int32x4_t vec = vld1q_s32(&n[i]);\n\n        // Mask to extract signs of the numbers\n        uint32x4_t sign_mask = vcltq_s32(vec, vdupq_n_s32(0));\n\n        // Absolute values of the numbers\n        int32x4_t abs_vals = vabsq_s32(vec);\n\n        // Initialize digit sum vectors\n        int32x4_t digit_sum = vdupq_n_s32(0);\n\n        // Compute sum of digits for each number in the vector\n        for (int j = 0; j < 10; ++j) { // Assuming max 10 digits per number\n            // Extract the last digit\n            int32x4_t last_digit = vandq_s32(abs_vals, vdupq_n_s32(0xF));\n\n            // Add the last digit to the digit sum\n            digit_sum = vaddq_s32(digit_sum, last_digit);\n\n            // Remove the last digit\n            abs_vals = vshrq_n_s32(abs_vals, 4);\n        }\n\n        // Adjust the first digit for negative numbers\n        int32x4_t first_digit = vshrq_n_s32(vec, 28); // Extract the highest digit\n        first_digit = vnegq_s32(vandq_s32(first_digit, sign_mask)); // Negate if negative\n        digit_sum = vaddq_s32(digit_sum, first_digit);\n\n        // Check which sums are greater than 0\n        uint32x4_t cmp = vcgtq_s32(digit_sum, vdupq_n_s32(0));\n\n        // Count the number of true values in the comparison result\n        uint8x16_t cmp_u8 = vreinterpretq_u8_u32(cmp);\n        uint32_t mask = vget_lane_u32(vreinterpret_u32_u8(vpmax_u8(vpmax_u8(cmp_u8, cmp_u8), vpmax_u8(cmp_u8, cmp_u8))), 0);\n        count += __builtin_popcount(mask);\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        int num = n[i];\n        int sum = 0;\n        int temp = std::abs(num);\n        while (temp > 0) {\n            sum += temp % 10;\n            temp /= 10;\n        }\n        if (num < 0) {\n            sum -= 2 * (num % 10);\n        }\n        if (sum > 0) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    int size = n.size();\n    int i = 0;\n\n    // Process 4 integers at a time using NEON intrinsics\n    for (; i <= size - 4; i += 4) {\n        // Load 4 integers into a NEON register\n        int32x4_t vec = vld1q_s32(&n[i]);\n\n        // Mask to identify negative numbers\n        uint32x4_t is_negative = vcgtq_s32(vdupq_n_s32(0), vec);\n\n        // Absolute value of the integers\n        int32x4_t abs_vals = vabsq_s32(vec);\n\n        // Extract digits and compute their sum\n        int32x4_t digit_sum = vdupq_n_s32(0);\n        int32x4_t temp = abs_vals;\n\n        while (vmaxvq_s32(temp) > 0) {\n            // Add the last digit to the sum\n            digit_sum = vaddq_s32(digit_sum, vandq_s32(temp, vdupq_n_s32(0xF)));\n\n            // Remove the last digit\n            temp = vshrq_n_s32(temp, 4);\n        }\n\n        // Adjust the first digit for negative numbers\n        int32x4_t first_digit = vdupq_n_s32(0);\n        temp = abs_vals;\n        uint32x4_t mask = vcgtq_s32(temp, vdupq_n_s32(0));\n\n        while (vmaxvq_u32(mask) > 0) {\n            first_digit = vbslq_s32(mask, temp, first_digit);\n            temp = vshrq_n_s32(temp, 4);\n            mask = vcgtq_s32(temp, vdupq_n_s32(0));\n        }\n\n        int32x4_t neg_first_digit = vnegq_s32(first_digit);\n        digit_sum = vbslq_s32(is_negative, vaddq_s32(digit_sum, neg_first_digit), digit_sum);\n\n        // Check if digit sum > 0\n        uint32x4_t cmp = vcgtq_s32(digit_sum, vdupq_n_s32(0));\n\n        // Count the number of true values in the comparison result\n        count += vaddvq_u32(cmp);\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        int num = n[i];\n        int sum = 0;\n        int abs_num = std::abs(num);\n        bool is_negative = num < 0;\n\n        while (abs_num > 0) {\n            sum += abs_num % 10;\n            abs_num /= 10;\n        }\n\n        if (is_negative) {\n            sum -= 2 * (num % 10);\n        }\n\n        if (sum > 0) {\n            ++count;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    int size = n.size();\n    int i = 0;\n\n    // Process 4 integers at a time using NEON intrinsics\n    for (; i <= size - 4; i += 4) {\n        // Load 4 integers into a NEON register\n        int32x4_t vec = vld1q_s32(&n[i]);\n\n        // Initialize a mask to track which numbers have positive digit sums\n        uint32x4_t positive_mask = vmovq_n_u32(0);\n\n        // Extract each integer from the vector and compute its digit sum\n        for (int j = 0; j < 4; ++j) {\n            int num = vgetq_lane_s32(vec, j);\n            int digit_sum = 0;\n            int abs_num = num < 0 ? -num : num;\n\n            // Compute the sum of digits\n            while (abs_num > 0) {\n                digit_sum += abs_num % 10;\n                abs_num /= 10;\n            }\n\n            // Adjust for negative numbers\n            if (num < 0 && digit_sum > 0) {\n                digit_sum = -digit_sum + 2 * (num % 10);\n            }\n\n            // Update the mask if the digit sum is positive\n            if (digit_sum > 0) {\n                positive_mask = vsetq_lane_u32(1, positive_mask, j);\n            }\n        }\n\n        // Count how many elements in the mask are set\n        uint64x2_t pair_sum = vpaddlq_u32(positive_mask);\n        count += vgetq_lane_u64(pair_sum, 0) + vgetq_lane_u64(pair_sum, 1);\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        int num = n[i];\n        int digit_sum = 0;\n        int abs_num = num < 0 ? -num : num;\n\n        // Compute the sum of digits\n        while (abs_num > 0) {\n            digit_sum += abs_num % 10;\n            abs_num /= 10;\n        }\n\n        // Adjust for negative numbers\n        if (num < 0 && digit_sum > 0) {\n            digit_sum = -digit_sum + 2 * (num % 10);\n        }\n\n        // Increment count if the digit sum is positive\n        if (digit_sum > 0) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    int size = n.size();\n    int i = 0;\n\n    // Process 4 integers at a time using NEON intrinsics\n    for (; i <= size - 4; i += 4) {\n        // Load 4 integers into a NEON register\n        int32x4_t vec = vld1q_s32(&n[i]);\n\n        // Initialize a mask to track which numbers have positive digit sums\n        uint32x4_t mask = vmovq_n_u32(0);\n\n        // Extract each integer from the vector and compute its digit sum\n        for (int j = 0; j < 4; ++j) {\n            int num = vgetq_lane_s32(vec, j);\n            int digit_sum = 0;\n            int abs_num = num < 0 ? -num : num;\n\n            if (abs_num == 0) {\n                digit_sum = 0;\n            } else {\n                if (num < 0) {\n                    digit_sum -= abs_num % 10;\n                    abs_num /= 10;\n                }\n                while (abs_num > 0) {\n                    digit_sum += abs_num % 10;\n                    abs_num /= 10;\n                }\n            }\n\n            // Update the mask if the digit sum is positive\n            if (digit_sum > 0) {\n                mask = vsetq_lane_u32(1, mask, j);\n            }\n        }\n\n        // Count how many elements in the mask are set to 1\n        uint32x2_t sum_pairs = vpadd_u32(vget_low_u32(mask), vget_high_u32(mask));\n        uint32x2_t total = vpadd_u32(sum_pairs, sum_pairs);\n        count += vget_lane_u32(total, 0);\n    }\n\n    // Process remaining elements that didn't fit into the SIMD loop\n    for (; i < size; ++i) {\n        int num = n[i];\n        int digit_sum = 0;\n        int abs_num = num < 0 ? -num : num;\n\n        if (abs_num == 0) {\n            digit_sum = 0;\n        } else {\n            if (num < 0) {\n                digit_sum -= abs_num % 10;\n                abs_num /= 10;\n            }\n            while (abs_num > 0) {\n                digit_sum += abs_num % 10;\n                abs_num /= 10;\n            }\n        }\n\n        if (digit_sum > 0) {\n            ++count;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_115_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    int N = arr.size();\n    if (N == 0) return true;\n\n    int drop_count = 0;\n    int32x4_t v1, v2;\n    int tail = N - (N % 4);\n\n    for (int i = 0; i < tail; i += 4) {\n        v1 = vld1q_s32(&arr[i]);\n        v2 = vld1q_s32(&arr[i + 1]);\n\n        uint32x4_t cmp = vcgtq_s32(v1, v2);\n        uint64x2_t pair_sum = vpaddlq_u32(cmp);\n        uint64x1_t sum = vpadd_u64(vget_low_u64(pair_sum), vget_high_u64(pair_sum));\n\n        drop_count += vget_lane_u64(sum, 0);\n    }\n\n    for (int i = tail; i < N - 1; ++i) {\n        if (arr[i] > arr[i + 1]) {\n            drop_count++;\n        }\n    }\n\n    if (arr[N - 1] > arr[0]) {\n        drop_count++;\n    }\n\n    return drop_count <= 1;\n}\n```"}
{"task_id": "SimdBench_115_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    int N = arr.size();\n    if (N == 0) return true;\n\n    int drop_count = 0;\n    int32x4_t v1, v2;\n    int tail = N - (N % 4);\n\n    for (int i = 0; i < tail; i += 4) {\n        v1 = vld1q_s32(&arr[i]);\n        v2 = vld1q_s32(&arr[i + 1]);\n\n        uint32x4_t cmp = vcgtq_s32(v1, v2);\n        uint64x2_t pair_sum = vpaddlq_u32(cmp);\n        uint64x1_t sum = vadd_u64(vget_low_u64(pair_sum), vget_high_u64(pair_sum));\n        drop_count += vget_lane_u64(sum, 0);\n    }\n\n    for (int i = tail; i < N - 1; ++i) {\n        if (arr[i] > arr[i + 1]) {\n            drop_count++;\n        }\n    }\n\n    if (arr[N - 1] > arr[0]) {\n        drop_count++;\n    }\n\n    return drop_count <= 1;\n}\n```"}
{"task_id": "SimdBench_115_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    int N = arr.size();\n    if (N == 0) return true;\n\n    int count_drops = 0;\n    int32x4_t v_prev = vdupq_n_s32(arr[0]);\n    int i = 1;\n\n    for (; i + 4 <= N; i += 4) {\n        int32x4_t v_curr = vld1q_s32(&arr[i]);\n        uint32x4_t v_cmp = vcgtq_s32(v_prev, v_curr);\n        uint64x2_t v_sum_pairs = vpaddlq_u32(v_cmp);\n        uint64x1_t v_sum_final = vpadal_u64(vdup_n_u64(0), v_sum_pairs);\n        count_drops += vget_lane_u64(v_sum_final, 0);\n        v_prev = v_curr;\n    }\n\n    for (; i < N; ++i) {\n        if (arr[i - 1] > arr[i]) {\n            count_drops++;\n        }\n    }\n\n    if (arr[N - 1] > arr[0]) {\n        count_drops++;\n    }\n\n    return count_drops <= 1;\n}\n```"}
{"task_id": "SimdBench_115_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    int N = arr.size();\n    if (N == 0) return true;\n\n    int drop_count = 0;\n    int32x4_t v_prev = vdupq_n_s32(arr[0]);\n    int i = 1;\n\n    for (; i + 4 <= N; i += 4) {\n        int32x4_t v_curr = vld1q_s32(&arr[i]);\n        uint32x4_t v_cmp = vcgtq_s32(v_prev, v_curr);\n        uint64x2_t v_sum_pairs = vpaddlq_u32(v_cmp);\n        uint64x1_t v_sum_final = vadd_u64(vget_low_u64(v_sum_pairs), vget_high_u64(v_sum_pairs));\n        drop_count += vget_lane_u64(v_sum_final, 0);\n\n        if (drop_count > 1) return false;\n        v_prev = v_curr;\n    }\n\n    for (; i < N; ++i) {\n        if (arr[i - 1] > arr[i]) {\n            ++drop_count;\n            if (drop_count > 1) return false;\n        }\n    }\n\n    if (arr[N - 1] > arr[0]) ++drop_count;\n    return drop_count <= 1;\n}\n```"}
{"task_id": "SimdBench_115_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    int N = arr.size();\n    if (N == 0) return true;\n\n    int drop_count = 0;\n    int32x4_t v1, v2;\n    int tail = N - (N % 4);\n\n    for (int i = 0; i < tail; i += 4) {\n        v1 = vld1q_s32(&arr[i]);\n        v2 = vld1q_s32(&arr[i + 1]);\n\n        uint32x4_t cmp = vcgtq_s32(v1, v2);\n        uint64x2_t pair = vreinterpretq_u64_u32(cmp);\n        drop_count += vaddvq_u8(vcntq_u8(vreinterpretq_u8_u64(pair)));\n    }\n\n    for (int i = tail; i < N - 1; ++i) {\n        if (arr[i] > arr[i + 1]) {\n            drop_count++;\n        }\n    }\n\n    if (arr[N - 1] > arr[0]) {\n        drop_count++;\n    }\n\n    return drop_count <= 1;\n}\n```"}
{"task_id": "SimdBench_116_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <vector>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int n1 = lst1.size();\n    int n2 = lst2.size();\n    int i = 0;\n    int odd_count_lst1 = 0;\n\n    // Process lst1 in chunks of 4 using NEON intrinsics\n    for (; i <= n1 - 4; i += 4) {\n        int32x4_t v1 = vld1q_s32(&lst1[i]);\n        uint32x4_t mask = vandq_u32(vreinterpretq_u32_s32(v1), vdupq_n_u32(1));\n        uint32x4_t odd_mask = vceqq_u32(mask, vdupq_n_u32(1));\n        odd_count_lst1 += vaddvq_u32(odd_mask);\n    }\n\n    // Process remaining elements of lst1\n    for (; i < n1; ++i) {\n        if (lst1[i] & 1) {\n            ++odd_count_lst1;\n        }\n    }\n\n    int even_count_lst2 = 0;\n    i = 0;\n\n    // Process lst2 in chunks of 4 using NEON intrinsics\n    for (; i <= n2 - 4; i += 4) {\n        int32x4_t v2 = vld1q_s32(&lst2[i]);\n        uint32x4_t mask = vandq_u32(vreinterpretq_u32_s32(v2), vdupq_n_u32(1));\n        uint32x4_t even_mask = vceqq_u32(mask, vdupq_n_u32(0));\n        even_count_lst2 += vaddvq_u32(even_mask);\n    }\n\n    // Process remaining elements of lst2\n    for (; i < n2; ++i) {\n        if ((lst2[i] & 1) == 0) {\n            ++even_count_lst2;\n        }\n    }\n\n    return (even_count_lst2 >= odd_count_lst1) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <vector>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int n1 = lst1.size();\n    int n2 = lst2.size();\n    int i = 0;\n    int odd_count_lst1 = 0;\n\n    // Process lst1 in chunks of 4 using NEON intrinsics\n    for (; i <= n1 - 4; i += 4) {\n        int32x4_t v1 = vld1q_s32(&lst1[i]);\n        uint32x4_t mask = vandq_u32(vreinterpretq_u32_s32(v1), vdupq_n_u32(1));\n        uint32x4_t odd_mask = vceqq_u32(mask, vdupq_n_u32(1));\n        odd_count_lst1 += vaddvq_u32(odd_mask);\n    }\n\n    // Process remaining elements in lst1\n    for (; i < n1; ++i) {\n        if (lst1[i] & 1) {\n            ++odd_count_lst1;\n        }\n    }\n\n    int even_count_lst2 = 0;\n    i = 0;\n\n    // Process lst2 in chunks of 4 using NEON intrinsics\n    for (; i <= n2 - 4; i += 4) {\n        int32x4_t v2 = vld1q_s32(&lst2[i]);\n        uint32x4_t mask = vandq_u32(vreinterpretq_u32_s32(v2), vdupq_n_u32(1));\n        uint32x4_t even_mask = vceqq_u32(mask, vdupq_n_u32(0));\n        even_count_lst2 += vaddvq_u32(even_mask);\n    }\n\n    // Process remaining elements in lst2\n    for (; i < n2; ++i) {\n        if ((lst2[i] & 1) == 0) {\n            ++even_count_lst2;\n        }\n    }\n\n    return (even_count_lst2 >= odd_count_lst1) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <vector>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int n1 = lst1.size();\n    int n2 = lst2.size();\n    int i = 0;\n    int odd_count_lst1 = 0;\n\n    // Process lst1 in chunks of 4 using NEON intrinsics\n    for (i = 0; i + 4 <= n1; i += 4) {\n        int32x4_t v1 = vld1q_s32(&lst1[i]); // Load 4 integers from lst1\n        uint32x4_t mask = vandq_u32(vreinterpretq_u32_s32(v1), vdupq_n_u32(1)); // Check if each element is odd\n        uint32x4_t odd_check = vceqq_u32(mask, vdupq_n_u32(1)); // Compare with 1 to identify odd numbers\n        odd_count_lst1 += vaddvq_u32(odd_check); // Sum up the odd flags\n    }\n\n    // Process remaining elements in lst1\n    for (; i < n1; ++i) {\n        if (lst1[i] & 1) {\n            ++odd_count_lst1;\n        }\n    }\n\n    int even_count_lst2 = 0;\n    i = 0;\n\n    // Process lst2 in chunks of 4 using NEON intrinsics\n    for (i = 0; i + 4 <= n2; i += 4) {\n        int32x4_t v2 = vld1q_s32(&lst2[i]); // Load 4 integers from lst2\n        uint32x4_t mask = vandq_u32(vreinterpretq_u32_s32(v2), vdupq_n_u32(1)); // Check if each element is odd\n        uint32x4_t even_check = vceqq_u32(mask, vdupq_n_u32(0)); // Compare with 0 to identify even numbers\n        even_count_lst2 += vaddvq_u32(even_check); // Sum up the even flags\n    }\n\n    // Process remaining elements in lst2\n    for (; i < n2; ++i) {\n        if ((lst2[i] & 1) == 0) {\n            ++even_count_lst2;\n        }\n    }\n\n    // If lst2 has enough even numbers to replace all odd numbers in lst1\n    return (even_count_lst2 >= odd_count_lst1) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <vector>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int n1 = lst1.size();\n    int n2 = lst2.size();\n    int i = 0;\n    int odd_count_lst1 = 0;\n\n    // Process lst1 in chunks of 4 using NEON intrinsics\n    for (; i <= n1 - 4; i += 4) {\n        int32x4_t v1 = vld1q_s32(&lst1[i]);\n        uint32x4_t mask = vandq_u32(vreinterpretq_u32_s32(v1), vdupq_n_u32(1));\n        uint32x4_t cmp = vceqq_u32(mask, vdupq_n_u32(1));\n        odd_count_lst1 += vaddvq_u32(cmp);\n    }\n\n    // Process remaining elements of lst1\n    for (; i < n1; ++i) {\n        if (lst1[i] & 1) {\n            ++odd_count_lst1;\n        }\n    }\n\n    int even_count_lst2 = 0;\n    i = 0;\n\n    // Process lst2 in chunks of 4 using NEON intrinsics\n    for (; i <= n2 - 4; i += 4) {\n        int32x4_t v2 = vld1q_s32(&lst2[i]);\n        uint32x4_t mask = vandq_u32(vreinterpretq_u32_s32(v2), vdupq_n_u32(1));\n        uint32x4_t cmp = vceqq_u32(mask, vdupq_n_u32(0));\n        even_count_lst2 += vaddvq_u32(cmp);\n    }\n\n    // Process remaining elements of lst2\n    for (; i < n2; ++i) {\n        if ((lst2[i] & 1) == 0) {\n            ++even_count_lst2;\n        }\n    }\n\n    return (even_count_lst2 >= odd_count_lst1) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <vector>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int n1 = lst1.size();\n    int n2 = lst2.size();\n    int i = 0;\n    int odd_count_lst1 = 0;\n\n    // Process lst1 in chunks of 4 using NEON intrinsics\n    for (i = 0; i <= n1 - 4; i += 4) {\n        int32x4_t v1 = vld1q_s32(&lst1[i]); // Load 4 integers from lst1\n        uint32x4_t mask = vandq_u32(vreinterpretq_u32_s32(v1), vdupq_n_u32(1)); // Check if each element is odd\n        uint32x4_t odd_bits = vceqq_u32(mask, vdupq_n_u32(1)); // Compare with 1 to identify odd numbers\n        odd_count_lst1 += vaddvq_u32(odd_bits); // Sum up the odd bits\n    }\n\n    // Process remaining elements in lst1\n    for (; i < n1; ++i) {\n        if (lst1[i] & 1) {\n            ++odd_count_lst1;\n        }\n    }\n\n    int even_count_lst2 = 0;\n    i = 0;\n\n    // Process lst2 in chunks of 4 using NEON intrinsics\n    for (i = 0; i <= n2 - 4; i += 4) {\n        int32x4_t v2 = vld1q_s32(&lst2[i]); // Load 4 integers from lst2\n        uint32x4_t mask = vandq_u32(vreinterpretq_u32_s32(v2), vdupq_n_u32(1)); // Check if each element is odd\n        uint32x4_t even_bits = vceqq_u32(mask, vdupq_n_u32(0)); // Compare with 0 to identify even numbers\n        even_count_lst2 += vaddvq_u32(even_bits); // Sum up the even bits\n    }\n\n    // Process remaining elements in lst2\n    for (; i < n2; ++i) {\n        if ((lst2[i] & 1) == 0) {\n            ++even_count_lst2;\n        }\n    }\n\n    // If lst2 has enough even numbers to replace all odd numbers in lst1, return \"YES\"\n    return (even_count_lst2 >= odd_count_lst1) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_117_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    const uint8x16_t odd_mask = vdupq_n_u8(0x01); // Mask to check odd digits (1, 3, 5, 7, 9)\n    const uint8x16_t digit_mask = vdupq_n_u8(0x0F); // Mask to isolate lower 4 bits of ASCII digits\n\n    for (const auto& str : lst) {\n        int count = 0;\n        size_t len = str.length();\n        size_t i = 0;\n\n        // Process 16 characters at a time using NEON\n        for (; i + 16 <= len; i += 16) {\n            uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(&str[i])); // Load 16 characters\n            uint8x16_t digits = vandq_u8(chars, digit_mask); // Isolate lower 4 bits\n            uint8x16_t is_odd = vandq_u8(digits, odd_mask); // Check if odd\n            uint8x16_t odd_check = vceqq_u8(is_odd, odd_mask); // Compare with odd mask\n            count += vaddvq_u8(odd_check); // Sum up the odd counts\n        }\n\n        // Process remaining characters\n        for (; i < len; ++i) {\n            char c = str[i];\n            if ((c - '0') % 2 != 0) {\n                ++count;\n            }\n        }\n\n        // Replace 'i' in the template string with the count\n        std::string output = \"the number of odd elements \" + std::to_string(count) +\n                             \"n the str\" + std::to_string(count) + \"ng \" +\n                             std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\";\n        result.push_back(output);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    const uint8x16_t odd_mask = vdupq_n_u8(0x01); // Mask to check odd digits (binary 00000001)\n    const char *template_str = \"the number of odd elements in the string X of the input.\";\n    \n    for (const auto &str : lst) {\n        int count = 0;\n        size_t len = str.size();\n        size_t i = 0;\n\n        // Process 16 characters at a time using NEON intrinsics\n        for (; i + 16 <= len; i += 16) {\n            uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(&str[i]));\n            uint8x16_t digits = vsubq_u8(chars, vdupq_n_u8('0')); // Convert characters to digit values\n            uint8x16_t is_odd = vandq_u8(digits, odd_mask); // Check if the last bit is set (odd)\n            uint8x16_t odd_check = vceqq_u8(is_odd, odd_mask); // Compare with mask to confirm oddness\n            \n            // Count the number of odd digits in this block\n            uint8x16_t odd_bits = vshrq_n_u8(odd_check, 7); // Extract the comparison result as bits\n            uint32x4_t sums = vpaddlq_u16(vpaddlq_u8(odd_bits)); // Sum across lanes\n            count += vaddvq_u32(sums); // Add up all the sums\n        }\n\n        // Process remaining characters\n        for (; i < len; ++i) {\n            if ((str[i] - '0') % 2 != 0) {\n                ++count;\n            }\n        }\n\n        // Replace 'X' in the template string with the count\n        std::string output = template_str;\n        output.replace(output.find('X'), 1, std::to_string(count));\n        result.push_back(output);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    const uint8x16_t odd_mask = vdupq_n_u8(0x01); // Mask to check if digit is odd\n    const char base_template[] = \"the number of odd elements in the string X of the input.\";\n    \n    for (const auto& str : lst) {\n        int count = 0;\n        size_t len = str.size();\n        size_t i = 0;\n\n        // Process 16 characters at a time using NEON\n        for (; i + 16 <= len; i += 16) {\n            uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(&str[i]));\n            uint8x16_t digits = vsubq_u8(chars, vdupq_n_u8('0')); // Convert char to digit\n            uint8x16_t is_odd = vandq_u8(digits, odd_mask); // Check if odd\n            uint8x16_t odd_check = vceqq_u8(is_odd, odd_mask); // Compare with mask\n            count += vaddvq_u8(odd_check); // Sum up odd counts\n        }\n\n        // Process remaining characters\n        for (; i < len; ++i) {\n            if ((str[i] - '0') & 1) {\n                ++count;\n            }\n        }\n\n        // Replace 'X' in the template with the count\n        std::string output(base_template);\n        output.replace(output.find('X'), 1, std::to_string(count));\n        result.push_back(output);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    const uint8x16_t odd_mask = vdupq_n_u8(0x01); // Mask to check odd digits (1, 3, 5, 7, 9)\n    const uint8x16_t digit_mask = vdupq_n_u8(0x0F); // Mask to isolate lower 4 bits of ASCII digits\n\n    for (const auto& str : lst) {\n        int count = 0;\n        size_t len = str.length();\n        size_t i = 0;\n\n        // Process 16 characters at a time using NEON intrinsics\n        for (; i + 16 <= len; i += 16) {\n            uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(&str[i])); // Load 16 characters\n            uint8x16_t digits = vandq_u8(chars, digit_mask); // Isolate the digit part\n            uint8x16_t is_odd = vandq_u8(digits, odd_mask); // Check if the digit is odd\n            uint8x16_t odd_bits = vceqq_u8(is_odd, odd_mask); // Compare with odd mask\n            count += vaddvq_u8(odd_bits); // Sum up the odd counts\n        }\n\n        // Process remaining characters\n        for (; i < len; ++i) {\n            char c = str[i];\n            if ((c - '0') % 2 != 0) {\n                ++count;\n            }\n        }\n\n        // Replace 'i' in the template string with the count\n        std::string output = \"the number of odd elements \" + std::to_string(count) +\n                             \"n the str\" + std::to_string(count) + \"ng \" +\n                             std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\";\n        result.push_back(output);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    const uint8x16_t odd_mask = vdupq_n_u8(0x01); // Mask to check odd digits (1, 3, 5, 7, 9)\n    const uint8x16_t digit_mask = vdupq_n_u8(0x0F); // Mask to isolate lower nibble (digit)\n\n    for (const auto& str : lst) {\n        int count = 0;\n        size_t len = str.size();\n        size_t i = 0;\n\n        // Process 16 characters at a time using NEON\n        for (; i + 16 <= len; i += 16) {\n            uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&str[i]));\n            uint8x16_t digits = vandq_u8(input, digit_mask); // Isolate the digit part\n            uint8x16_t is_odd = vandq_u8(digits, odd_mask); // Check if odd\n            uint8x16_t odd_counts = vceqq_u8(is_odd, odd_mask); // Compare with odd mask\n            count += vaddvq_u8(odd_counts); // Sum up the odd counts\n        }\n\n        // Process remaining characters\n        for (; i < len; ++i) {\n            char c = str[i];\n            if ((c - '0') % 2 != 0) {\n                ++count;\n            }\n        }\n\n        // Replace 'i' with the count in the output string\n        std::string output = \"the number of odd elements in the string X of the input.\";\n        size_t pos = output.find('X');\n        if (pos != std::string::npos) {\n            output.replace(pos, 1, std::to_string(count));\n        }\n        result.push_back(output);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_118_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <limits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int64_t min_sum = std::numeric_limits<int64_t>::max();\n    int64_t current_min = 0;\n    int64_t global_min = std::numeric_limits<int64_t>::max();\n\n    size_t i = 0;\n    size_t n = nums.size();\n\n    // Process 2 elements at a time using NEON intrinsics\n    for (; i + 1 < n; i += 2) {\n        // Load two consecutive elements into a vector\n        int64x2_t vec = vld1q_s64(&nums[i]);\n\n        // Compute horizontal sum of the vector\n        int64_t sum = vaddvq_s64(vec);\n\n        // Update current minimum sum\n        current_min += sum;\n\n        // Check if we need to reset current_min\n        if (current_min > 0) {\n            current_min = 0;\n        }\n\n        // Update global minimum\n        if (current_min < global_min) {\n            global_min = current_min;\n        }\n    }\n\n    // Process remaining elements (if any)\n    for (; i < n; ++i) {\n        current_min += nums[i];\n        if (current_min > 0) {\n            current_min = 0;\n        }\n        if (current_min < global_min) {\n            global_min = current_min;\n        }\n    }\n\n    // Find the actual minimum sum by iterating again\n    int64_t actual_min = std::numeric_limits<int64_t>::max();\n    current_min = 0;\n    for (size_t j = 0; j < n; ++j) {\n        current_min += nums[j];\n        if (current_min < actual_min) {\n            actual_min = current_min;\n        }\n        if (current_min > 0) {\n            current_min = 0;\n        }\n    }\n\n    return actual_min;\n}\n```"}
{"task_id": "SimdBench_118_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int n = nums.size();\n    if (n == 0) return 0;\n\n    int64_t min_sum = nums[0];\n    int64_t current_min = nums[0];\n\n    // Process the array in chunks of 2 using NEON intrinsics\n    int i = 1;\n    for (; i <= n - 2; i += 2) {\n        // Load two elements at a time\n        int64x2_t vec = vld1q_s64(&nums[i]);\n\n        // Extract individual elements from the vector\n        int64_t val1 = vgetq_lane_s64(vec, 0);\n        int64_t val2 = vgetq_lane_s64(vec, 1);\n\n        // Compute current minimum for the first element\n        current_min = std::min(val1, current_min + val1);\n        min_sum = std::min(min_sum, current_min);\n\n        // Compute current minimum for the second element\n        current_min = std::min(val2, current_min + val2);\n        min_sum = std::min(min_sum, current_min);\n    }\n\n    // Process any remaining elements\n    for (; i < n; ++i) {\n        current_min = std::min((int64_t)nums[i], current_min + (int64_t)nums[i]);\n        min_sum = std::min(min_sum, current_min);\n    }\n\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <limits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int64_t min_sum = std::numeric_limits<int64_t>::max();\n    int64_t current_min = 0;\n    int64_t global_min = std::numeric_limits<int64_t>::max();\n\n    size_t i = 0;\n    size_t n = nums.size();\n\n    // Process 2 elements at a time using NEON intrinsics\n    for (; i + 1 < n; i += 2) {\n        // Load two consecutive elements into a NEON register\n        int64x2_t vec = vld1q_s64(&nums[i]);\n\n        // Compute horizontal sum of the two elements\n        int64_t sum = vaddvq_s64(vec);\n\n        // Update current minimum sum\n        current_min += sum;\n\n        // Update global minimum\n        global_min = std::min(global_min, current_min);\n\n        // Reset current_min if it becomes positive\n        if (current_min > 0) {\n            current_min = 0;\n        }\n    }\n\n    // Process remaining elements (if any)\n    for (; i < n; ++i) {\n        current_min += nums[i];\n        global_min = std::min(global_min, current_min);\n        if (current_min > 0) {\n            current_min = 0;\n        }\n    }\n\n    return global_min;\n}\n```"}
{"task_id": "SimdBench_118_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int64_t min_sum = nums[0];\n    int64_t current_min = nums[0];\n\n    // Ensure the size is a multiple of 2 for SIMD processing\n    size_t simd_size = nums.size() / 2 * 2;\n\n    // Process two elements at a time using NEON intrinsics\n    for (size_t i = 0; i < simd_size; i += 2) {\n        // Load two consecutive elements into a NEON register\n        int64x2_t vec = vld1q_s64(&nums[i]);\n\n        // Extract individual elements from the vector\n        int64_t val1 = vgetq_lane_s64(vec, 0);\n        int64_t val2 = vgetq_lane_s64(vec, 1);\n\n        // Update current_min and min_sum for the first element\n        current_min = std::min(val1, current_min + val1);\n        min_sum = std::min(min_sum, current_min);\n\n        // Update current_min and min_sum for the second element\n        current_min = std::min(val2, current_min + val2);\n        min_sum = std::min(min_sum, current_min);\n    }\n\n    // Handle any remaining elements that didn't fit into the SIMD loop\n    for (size_t i = simd_size; i < nums.size(); ++i) {\n        current_min = std::min(nums[i], current_min + nums[i]);\n        min_sum = std::min(min_sum, current_min);\n    }\n\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <limits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int64_t min_sum = std::numeric_limits<int64_t>::max();\n    int64_t current_min = 0;\n    int64_t temp_min = 0;\n\n    int64_t sum1, sum2, sum3, sum4;\n    int64x2_t vec_current_min = vdupq_n_s64(0);\n    int64x2_t vec_min_sum = vdupq_n_s64(std::numeric_limits<int64_t>::max());\n\n    size_t i = 0;\n    size_t size = nums.size();\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 3 < size; i += 4) {\n        int64x2_t vec1 = vld1q_s64(&nums[i]);\n        int64x2_t vec2 = vld1q_s64(&nums[i + 2]);\n\n        // Compute cumulative sums for each lane\n        vec_current_min = vaddq_s64(vec_current_min, vec1);\n        vec_current_min = vminq_s64(vec_current_min, vec1);\n\n        vec_current_min = vaddq_s64(vec_current_min, vec2);\n        vec_current_min = vminq_s64(vec_current_min, vec2);\n\n        // Update the minimum sum across lanes\n        vec_min_sum = vminq_s64(vec_min_sum, vec_current_min);\n    }\n\n    // Extract the minimum value from the NEON registers\n    int64_t min_vals[2];\n    vst1q_s64(min_vals, vec_min_sum);\n    min_sum = std::min(min_vals[0], min_vals[1]);\n\n    // Process remaining elements (if any)\n    for (; i < size; ++i) {\n        current_min = std::min(nums[i], current_min + nums[i]);\n        min_sum = std::min(min_sum, current_min);\n    }\n\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_119_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint max_fill_simd(const std::vector<std::vector<int>> &grid, int capacity) {\n    int totalDrops = 0;\n\n    for (const auto &row : grid) {\n        int rowSize = row.size();\n        int i = 0;\n\n        // Process 16 elements at a time using NEON intrinsics\n        for (; i <= rowSize - 16; i += 16) {\n            // Load 16 integers from the row into a NEON register\n            uint8x16_t v = vld1q_u8(reinterpret_cast<const uint8_t*>(&row[i]));\n\n            // Compare each element to 1 and create a mask\n            uint8x16_t mask = vceqq_u8(v, vdupq_n_u8(1));\n\n            // Count the number of 1s in the mask\n            uint8x16_t sumVec = vpaddlq_u8(mask);\n            sumVec = vpaddlq_u8(sumVec);\n            sumVec = vpaddlq_u8(sumVec);\n\n            // Extract the total count of 1s from the NEON register\n            uint64_t totalCount = vaddvq_u8(sumVec);\n            totalDrops += totalCount;\n        }\n\n        // Process remaining elements in the row\n        for (; i < rowSize; ++i) {\n            totalDrops += row[i];\n        }\n    }\n\n    // Calculate the total number of bucket drops needed\n    return (totalDrops + capacity - 1) / capacity;\n}\n```"}
{"task_id": "SimdBench_119_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint max_fill_simd(const std::vector<std::vector<int>> &grid, int capacity) {\n    int totalDrops = 0;\n\n    for (const auto &row : grid) {\n        int rowSize = row.size();\n        int i = 0;\n\n        // Process 16 elements at a time using NEON intrinsics\n        for (; i <= rowSize - 16; i += 16) {\n            // Load 16 integers into a NEON register\n            uint8x16_t v = vld1q_u8(reinterpret_cast<const uint8_t*>(&row[i]));\n\n            // Compare each element to 1 and create a mask\n            uint8x16_t mask = vceqq_u8(v, vdupq_n_u8(1));\n\n            // Count the number of 1s in the mask\n            uint8x16_t popcount = vcntq_u8(mask);\n\n            // Sum the counts across all lanes\n            uint16x8_t sum1 = vpaddlq_u8(popcount);\n            uint32x4_t sum2 = vpaddlq_u16(sum1);\n            uint64x2_t sum3 = vpaddlq_u32(sum2);\n\n            // Extract the total count of 1s from the NEON register\n            uint64_t totalCount = vgetq_lane_u64(sum3, 0) + vgetq_lane_u64(sum3, 1);\n            totalDrops += (totalCount + capacity - 1) / capacity;\n        }\n\n        // Process remaining elements\n        for (; i < rowSize; ++i) {\n            if (row[i] == 1) {\n                totalDrops += (1 + capacity - 1) / capacity;\n            }\n        }\n    }\n\n    return totalDrops;\n}\n```"}
{"task_id": "SimdBench_119_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint max_fill_simd(const std::vector<std::vector<int>> &grid, int capacity) {\n    int totalDrops = 0;\n\n    for (const auto &row : grid) {\n        int rowSize = row.size();\n        int i = 0;\n\n        // Process 16 elements at a time using Neon intrinsics\n        for (; i <= rowSize - 16; i += 16) {\n            // Load 16 integers from the row into a Neon register\n            uint8x16_t v = vld1q_u8(reinterpret_cast<const uint8_t*>(&row[i]));\n\n            // Compare each element to 1 and create a mask\n            uint8x16_t mask = vceqq_u8(v, vdupq_n_u8(1));\n\n            // Count the number of 1s in the mask\n            uint8x16_t onesCount = vpaddlq_u8(mask);\n            onesCount = vpaddlq_u8(onesCount);\n            onesCount = vpaddlq_u8(onesCount);\n\n            // Extract the sum of 1s from the Neon register\n            int sum = vaddvq_u8(onesCount);\n            totalDrops += (sum + capacity - 1) / capacity;\n        }\n\n        // Process remaining elements in the row\n        for (; i < rowSize; ++i) {\n            if (row[i] == 1) {\n                totalDrops += (1 + capacity - 1) / capacity;\n            }\n        }\n    }\n\n    return totalDrops;\n}\n```"}
{"task_id": "SimdBench_119_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint max_fill_simd(const std::vector<std::vector<int>> &grid, int capacity) {\n    int totalDrops = 0;\n\n    for (const auto &row : grid) {\n        int rowSize = row.size();\n        int i = 0;\n\n        // Process 16 elements at a time using NEON intrinsics\n        for (; i <= rowSize - 16; i += 16) {\n            // Load 16 integers from the row into a NEON register\n            uint8x16_t v = vld1q_u8(reinterpret_cast<const uint8_t*>(&row[i]));\n\n            // Compare each element to 1 and create a mask\n            uint8x16_t mask = vceqq_u8(v, vdupq_n_u8(1));\n\n            // Count the number of 1s in the mask\n            uint8x16_t popcount = vcntq_u8(mask);\n\n            // Sum the counts across the NEON lanes\n            uint16x8_t sum1 = vpaddlq_u8(popcount);\n            uint32x4_t sum2 = vpaddlq_u16(sum1);\n            uint64x2_t sum3 = vpaddlq_u32(sum2);\n\n            // Extract the total count of 1s from the NEON register\n            uint64_t totalCount = vgetq_lane_u64(sum3, 0) + vgetq_lane_u64(sum3, 1);\n            totalDrops += totalCount;\n        }\n\n        // Process remaining elements in the row\n        for (; i < rowSize; ++i) {\n            totalDrops += row[i];\n        }\n    }\n\n    // Calculate the total number of bucket drops needed\n    return (totalDrops + capacity - 1) / capacity;\n}\n```"}
{"task_id": "SimdBench_119_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint max_fill_simd(const std::vector<std::vector<int>> &grid, int capacity) {\n    int total_buckets = 0;\n\n    for (const auto &row : grid) {\n        int row_size = row.size();\n        int i = 0;\n\n        // Process 16 elements at a time using Neon intrinsics\n        for (; i <= row_size - 16; i += 16) {\n            uint8x16_t v = vld1q_u8(reinterpret_cast<const uint8_t*>(&row[i]));\n            uint8x16_t mask = vdupq_n_u8(1);\n            uint8x16_t water = vandq_u8(v, mask);\n\n            // Count the number of 1s in the vector\n            uint16x8_t sum1 = vpaddlq_u8(water);\n            uint32x4_t sum2 = vpaddlq_u16(sum1);\n            uint64x2_t sum3 = vpaddlq_u32(sum2);\n\n            uint64_t total = vgetq_lane_u64(sum3, 0) + vgetq_lane_u64(sum3, 1);\n            total_buckets += (total + capacity - 1) / capacity;\n        }\n\n        // Process remaining elements\n        for (; i < row_size; ++i) {\n            if (row[i]) {\n                total_buckets += (1 + capacity - 1) / capacity;\n            }\n        }\n    }\n\n    return total_buckets;\n}\n```"}
{"task_id": "SimdBench_120_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cstdint>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t result = 0;\n    int i = 0;\n    int size = lst.size();\n\n    // Process 8 elements at a time using NEON intrinsics\n    for (; i <= size - 8; i += 8) {\n        // Load 8 elements into a NEON register\n        int16x8_t vec = vld1q_s16(&lst[i]);\n\n        // Create a mask for even positions (0, 2, 4, 6)\n        uint16x8_t even_mask = {0xFFFF, 0, 0xFFFF, 0, 0xFFFF, 0, 0xFFFF, 0};\n        int16x8_t even_elements = vandq_s16(vec, vreinterpretq_s16_u16(even_mask));\n\n        // Check for odd numbers\n        uint16x8_t odd_mask = vandq_u16(vreinterpretq_u16_s16(even_elements), vdupq_n_u16(1));\n        int16x8_t odd_elements = vbslq_s16(vreinterpretq_u16_s16(odd_mask), even_elements, vdupq_n_s16(0));\n\n        // Horizontally sum the valid odd elements in even positions\n        int32x4_t sum1 = vpaddlq_s16(odd_elements);\n        int32x2_t sum2 = vpadd_s32(vget_low_s32(sum1), vget_high_s32(sum1));\n        result += vget_lane_s32(sum2, 0) + vget_lane_s32(sum2, 1);\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        if ((i % 2 == 0) && (lst[i] % 2 != 0)) {\n            result += lst[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_120_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cstdint>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    int n = lst.size();\n    int i = 0;\n\n    // Process 8 elements at a time using NEON intrinsics\n    for (; i <= n - 8; i += 8) {\n        // Load 8 elements into a NEON register\n        int16x8_t vec = vld1q_s16(&lst[i]);\n\n        // Create a mask to select even positions (0, 2, 4, 6)\n        uint16x8_t even_mask = {1, 0, 1, 0, 1, 0, 1, 0};\n        uint16x8_t even_positions = vandq_u16(vreinterpretq_u16_s16(vec), even_mask);\n\n        // Extract only the odd values from the even positions\n        int16x8_t odd_mask = vandq_s16(vec, vdupq_n_s16(1)); // Check if odd\n        int16x8_t filtered = vbslq_s16(vreinterpretq_u16_s16(odd_mask), vec, vdupq_n_s16(0));\n\n        // Add the filtered values to the sum\n        int32x4_t sum_low = vpaddlq_s16(vget_low_s16(filtered));\n        int32x4_t sum_high = vpaddlq_s16(vget_high_s16(filtered));\n        int64x2_t total = vpaddlq_s32(vcombine_s32(sum_low, sum_high));\n        sum += vgetq_lane_s64(total, 0) + vgetq_lane_s64(total, 1);\n    }\n\n    // Process remaining elements\n    for (; i < n; ++i) {\n        if ((i % 2 == 0) && (lst[i] % 2 != 0)) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cstdint>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    int n = lst.size();\n    int i = 0;\n\n    // Process 8 elements at a time using NEON intrinsics\n    for (; i <= n - 8; i += 8) {\n        // Load 8 elements into a NEON register\n        int16x8_t vec = vld1q_s16(&lst[i]);\n\n        // Create a mask for even positions (0, 2, 4, 6)\n        uint16x8_t even_mask = {1, 0, 1, 0, 1, 0, 1, 0};\n        uint16x8_t even_pos = vmovq_n_u16(0);\n        even_pos = vorrq_u16(even_pos, even_mask);\n\n        // Select elements at even positions\n        int16x8_t even_elements = vbslq_s16(even_pos, vec, vdupq_n_s16(0));\n\n        // Check for odd numbers\n        int16x8_t odd_mask = vandq_s16(even_elements, vdupq_n_s16(1));\n        uint16x8_t is_odd = vceqq_s16(odd_mask, vdupq_n_s16(1));\n\n        // Mask out non-odd numbers\n        int16x8_t odd_numbers = vbslq_s16(is_odd, even_elements, vdupq_n_s16(0));\n\n        // Horizontally add the results\n        int32x4_t sum_low = vpaddlq_s16(odd_numbers);\n        int32x2_t sum_high = vpadd_s32(vget_low_s32(sum_low), vget_high_s32(sum_low));\n        sum += vget_lane_s32(sum_high, 0) + vget_lane_s32(sum_high, 1);\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        if ((i % 2 == 0) && (lst[i] % 2 != 0)) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cstdint>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    int n = lst.size();\n    int i = 0;\n\n    // Process 8 elements at a time using NEON intrinsics\n    for (; i <= n - 8; i += 8) {\n        // Load 8 elements into a NEON register\n        int16x8_t vec = vld1q_s16(&lst[i]);\n\n        // Create a mask to select even positions (0, 2, 4, 6)\n        uint16x8_t even_mask = {0xFFFF, 0, 0xFFFF, 0, 0xFFFF, 0, 0xFFFF, 0};\n        int16x8_t even_elements = vandq_s16(vec, vreinterpretq_s16_u16(even_mask));\n\n        // Check for odd numbers\n        uint16x8_t odd_mask = vandq_u16(vreinterpretq_u16_s16(even_elements), vdupq_n_u16(1));\n        int16x8_t odd_elements = vbslq_s16(vreinterpretq_u16_s16(odd_mask), even_elements, vdupq_n_s16(0));\n\n        // Horizontally add the results\n        int32x4_t sum_partial = vpaddlq_s16(odd_elements);\n        sum_partial = vpaddq_s32(sum_partial, sum_partial);\n        sum += vgetq_lane_s32(sum_partial, 0) + vgetq_lane_s32(sum_partial, 2);\n    }\n\n    // Process remaining elements\n    for (; i < n; ++i) {\n        if ((i % 2 == 0) && (lst[i] % 2 != 0)) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cstdint>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    int i = 0;\n    int size = lst.size();\n\n    // Process 8 elements at a time using NEON intrinsics\n    for (; i <= size - 8; i += 8) {\n        // Load 8 elements into a NEON register\n        int16x8_t vec = vld1q_s16(&lst[i]);\n\n        // Create a mask for even positions (0, 2, 4, 6)\n        uint16x8_t even_mask = {0xFFFF, 0, 0xFFFF, 0, 0xFFFF, 0, 0xFFFF, 0};\n        int16x8_t even_elements = vandq_s16(vec, vreinterpretq_s16_u16(even_mask));\n\n        // Check for odd values\n        uint16x8_t odd_mask = vandq_u16(vreinterpretq_u16_s16(even_elements), vdupq_n_u16(1));\n        int16x8_t odd_values = vbslq_s16(vreinterpretq_u16_u32(odd_mask), even_elements, vdupq_n_s16(0));\n\n        // Horizontally add the results\n        int32x4_t sum_partial = vpaddlq_s16(odd_values);\n        sum += vgetq_lane_s32(sum_partial, 0);\n        sum += vgetq_lane_s32(sum_partial, 1);\n        sum += vgetq_lane_s32(sum_partial, 2);\n        sum += vgetq_lane_s32(sum_partial, 3);\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= k - 4; i += 4) {\n        // Load 4 integers into a NEON register\n        int32x4_t vec = vld1q_s32(&arr[i]);\n\n        // Create a mask for elements with absolute value less than 100 (two digits)\n        uint32x4_t mask = vcltq_s32(vabsq_s32(vec), vdupq_n_s32(100));\n\n        // Use the mask to zero out elements that don't meet the condition\n        int32x4_t masked_values = vandq_s32(vec, vreinterpretq_s32_u32(mask));\n\n        // Horizontally add the valid elements in the vector\n        sum += vaddvq_s32(masked_values);\n    }\n\n    // Process remaining elements (if any) using scalar code\n    for (; i < k; ++i) {\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= k - 4; i += 4) {\n        // Load 4 integers from the array into a NEON register\n        int32x4_t vec = vld1q_s32(&arr[i]);\n\n        // Create a mask to identify elements with absolute values less than 100\n        uint32x4_t mask = vcltq_s32(vabsq_s32(vec), vdupq_n_s32(100));\n\n        // Use the mask to zero out elements that do not meet the condition\n        int32x4_t masked_values = vandq_s32(vec, vreinterpretq_s32_u32(mask));\n\n        // Horizontally add the valid elements in the vector\n        int32x2_t sum_vec = vpadd_s32(vget_low_s32(masked_values), vget_high_s32(masked_values));\n        sum_vec = vpadd_s32(sum_vec, sum_vec);\n\n        // Add the result to the total sum\n        sum += vget_lane_s32(sum_vec, 0);\n    }\n\n    // Process any remaining elements\n    for (; i < k; ++i) {\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= k - 4; i += 4) {\n        // Load 4 integers into a NEON register\n        int32x4_t vec = vld1q_s32(&arr[i]);\n\n        // Create a mask to identify elements with at most two digits (-99 to 99)\n        int32x4_t lower_bound = vdupq_n_s32(-99);\n        int32x4_t upper_bound = vdupq_n_s32(99);\n        uint32x4_t mask = vandq_u32(vcgeq_s32(vec, lower_bound), vcleq_s32(vec, upper_bound));\n\n        // Use the mask to zero out elements that don't meet the condition\n        int32x4_t masked_values = vbslq_s32(mask, vec, vdupq_n_s32(0));\n\n        // Horizontally add the valid elements in the vector\n        int32x2_t sum_vec = vpadd_s32(vget_low_s32(masked_values), vget_high_s32(masked_values));\n        sum_vec = vpadd_s32(sum_vec, sum_vec);\n\n        // Add the result to the total sum\n        sum += vget_lane_s32(sum_vec, 0);\n    }\n\n    // Process any remaining elements\n    for (; i < k; ++i) {\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= k - 4; i += 4) {\n        // Load 4 integers into a NEON register\n        int32x4_t vec = vld1q_s32(&arr[i]);\n\n        // Create a mask to check if the absolute values are less than 100 (two-digit numbers)\n        uint32x4_t mask = vcltq_s32(vabsq_s32(vec), vdupq_n_s32(100));\n\n        // Use the mask to zero out elements that don't meet the condition\n        int32x4_t masked_values = vandq_s32(vec, vreinterpretq_s32_u32(mask));\n\n        // Horizontally add the valid elements in the vector\n        int32x2_t sum_vec = vpadd_s32(vget_low_s32(masked_values), vget_high_s32(masked_values));\n        sum_vec = vpadd_s32(sum_vec, sum_vec);\n\n        // Add the result to the scalar sum\n        sum += vget_lane_s32(sum_vec, 0);\n    }\n\n    // Process any remaining elements\n    for (; i < k; ++i) {\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= k - 4; i += 4) {\n        // Load 4 integers into a NEON register\n        int32x4_t vec = vld1q_s32(&arr[i]);\n\n        // Create a mask for elements with absolute value less than 100 (two digits or less)\n        uint32x4_t mask = vcltq_s32(vabsq_s32(vec), vdupq_n_s32(100));\n\n        // Use the mask to zero out elements that don't meet the condition\n        int32x4_t masked_values = vandq_s32(vec, vreinterpretq_s32_u32(mask));\n\n        // Horizontally add the valid elements in the vector\n        sum += vaddvq_s32(masked_values);\n    }\n\n    // Process any remaining elements\n    for (; i < k; ++i) {\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_122_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    int n = lst.size();\n    if (n <= 1) return true;\n\n    int i = 0;\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= n - 4; i += 4) {\n        // Load 4 integers into a NEON register\n        int32x4_t current = vld1q_s32(&lst[i]);\n        int32x4_t next = vld1q_s32(&lst[i + 1]);\n\n        // Check if current <= next for all pairs\n        uint32x4_t cmp = vcleq_s32(current, next);\n\n        // Check for duplicates by comparing adjacent elements\n        int32x4_t diff = vsubq_s32(next, current);\n        uint32x4_t duplicate_check = vceqq_s32(diff, vdupq_n_s32(0));\n\n        // Combine results: cmp must be all true and duplicate_check must not have more than one true\n        uint32x4_t combined = vandq_u32(cmp, vmvnq_u32(duplicate_check));\n        if (vminvq_u32(combined) == 0) {\n            return false;\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < n - 1; ++i) {\n        if (lst[i] > lst[i + 1]) return false;\n        if (lst[i] == lst[i + 1]) {\n            // Check for more than one duplicate\n            if (i > 0 && lst[i - 1] == lst[i]) return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    int n = lst.size();\n    if (n <= 1) return true;\n\n    int i = 0;\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= n - 4; i += 4) {\n        // Load 4 elements into a NEON register\n        int32x4_t current = vld1q_s32(&lst[i]);\n        int32x4_t next = vld1q_s32(&lst[i + 1]);\n\n        // Check if current <= next for all 4 elements\n        uint32x4_t cmp_sorted = vcleq_s32(current, next);\n\n        // Check for duplicates by comparing current == next\n        uint32x4_t cmp_duplicates = vceqq_s32(current, next);\n\n        // Shift left by 1 to compare with the next element\n        int32x4_t shifted = vextq_s32(current, next, 1);\n        uint32x4_t cmp_sorted_shifted = vcleq_s32(current, shifted);\n\n        // Combine results\n        uint32x4_t result = vandq_u32(cmp_sorted, cmp_sorted_shifted);\n        result = vandq_u32(result, vmvnq_u32(cmp_duplicates));\n\n        // If any lane fails, return false\n        if (vminvq_u32(result) == 0) {\n            return false;\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < n - 1; ++i) {\n        if (lst[i] > lst[i + 1]) return false;\n        if (lst[i] == lst[i + 1] && (i + 2 < n && lst[i + 1] == lst[i + 2])) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> &lst) {\n    int n = lst.size();\n    if (n <= 1) return true;\n\n    int i = 0;\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= n - 4; i += 4) {\n        // Load 4 elements into a NEON register\n        int32x4_t current = vld1q_s32(&lst[i]);\n        int32x4_t next = vld1q_s32(&lst[i + 1]);\n\n        // Check if current <= next for all pairs\n        uint32x4_t cmp = vcleq_s32(current, next);\n        if (vaddvq_u32(cmp) != 4) {\n            return false;\n        }\n\n        // Check for duplicates by comparing adjacent elements\n        int32x4_t diff = vsubq_s32(next, current);\n        uint32x4_t duplicate_check = vceqq_s32(diff, vdupq_n_s32(0));\n        if (vaddvq_u32(duplicate_check) > 1) {\n            return false;\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < n - 1; ++i) {\n        if (lst[i] > lst[i + 1]) {\n            return false;\n        }\n        if (lst[i] == lst[i + 1]) {\n            // Check for more than one duplicate\n            int count = 1;\n            while (i < n - 1 && lst[i] == lst[i + 1]) {\n                ++count;\n                ++i;\n            }\n            if (count > 2) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    int n = lst.size();\n    if (n <= 1) return true;\n\n    int i = 0;\n    bool result = true;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= n - 4; i += 4) {\n        // Load 4 elements into a NEON register\n        int32x4_t current = vld1q_s32(&lst[i]);\n        int32x4_t next = vld1q_s32(&lst[i + 1]);\n\n        // Check if current <= next for all 4 elements\n        uint32x4_t cmp_sorted = vcleq_s32(current, next);\n\n        // Check for duplicates by comparing adjacent elements\n        int32x4_t diff = vsubq_s32(next, current);\n        uint32x4_t cmp_duplicates = vceqq_s32(diff, vdupq_n_s32(0));\n\n        // Combine results: sorted and no more than 1 duplicate\n        uint32x4_t combined = vandq_u32(cmp_sorted, vnotq_u32(cmp_duplicates));\n\n        // Reduce the result to a single boolean value\n        uint64x2_t reduced = vreinterpretq_u64_u32(combined);\n        uint64x1_t reduced_low = vget_low_u64(reduced);\n        uint64x1_t reduced_high = vget_high_u64(reduced);\n\n        if ((vget_lane_u64(reduced_low, 0) != 0xFFFFFFFFFFFFFFFF) ||\n            (vget_lane_u64(reduced_high, 0) != 0xFFFFFFFFFFFFFFFF)) {\n            return false;\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < n - 1; ++i) {\n        if (lst[i] > lst[i + 1]) return false;\n        if (lst[i] == lst[i + 1] && (i > 0 && lst[i] == lst[i - 1])) return false;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_122_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> &lst) {\n    int n = lst.size();\n    if (n <= 1) return true;\n\n    int i = 0;\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= n - 8; i += 4) {\n        // Load 4 elements starting from index i and i+1\n        int32x4_t vec1 = vld1q_s32(&lst[i]);\n        int32x4_t vec2 = vld1q_s32(&lst[i + 1]);\n\n        // Compare vec1 <= vec2 for ascending order check\n        uint32x4_t cmp_asc = vcleq_s32(vec1, vec2);\n\n        // Check for duplicates by comparing equality\n        uint32x4_t cmp_eq = vceqq_s32(vec1, vec2);\n\n        // Combine results: ascending order must be true AND duplicates must be false\n        uint32x4_t result = vandq_u32(cmp_asc, vmvnq_u32(cmp_eq));\n\n        // If any lane fails the condition, return false\n        if (vminvq_u32(result) == 0) {\n            return false;\n        }\n    }\n\n    // Handle remaining elements (less than 4)\n    for (; i < n - 1; ++i) {\n        if (lst[i] > lst[i + 1]) return false;\n        if (lst[i] == lst[i + 1]) {\n            // Check for more than one duplicate\n            int j = i;\n            while (j < n - 1 && lst[j] == lst[j + 1]) ++j;\n            if (j - i >= 2) return false;\n            i = j - 1; // Skip duplicates\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_123_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    int32_t total_sum = 0;\n    int32_t sign_product = 1;\n    size_t i = 0;\n    size_t size = arr.size();\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 integers into a NEON register\n        int32x4_t vec = vld1q_s32(&arr[i]);\n\n        // Compute the absolute values of the 4 integers\n        int32x4_t abs_vec = vabsq_s32(vec);\n\n        // Extract the signs of the 4 integers (-1, 0, or 1)\n        int32x4_t sign_vec = vshrq_n_s32(vec, 31); // Get -1 for negative, 0 for positive\n        int32x4_t is_nonzero = vtstq_s32(vec, vec); // Mask for non-zero values\n        sign_vec = veorq_s32(sign_vec, vandq_s32(is_nonzero, vdupq_n_s32(1))); // Convert to -1, 0, or 1\n\n        // Accumulate the sum of absolute values\n        total_sum += vaddvq_s32(abs_vec);\n\n        // Update the product of signs\n        int32_t signs[4];\n        vst1q_s32(signs, sign_vec);\n        for (int j = 0; j < 4; ++j) {\n            if (signs[j] == 0) {\n                sign_product = 0;\n                break;\n            }\n            sign_product *= signs[j];\n        }\n        if (sign_product == 0) break; // Early exit if product becomes zero\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        int val = arr[i];\n        total_sum += std::abs(val);\n        if (val == 0) {\n            sign_product = 0;\n            break;\n        }\n        sign_product *= (val > 0) ? 1 : -1;\n    }\n\n    return total_sum * sign_product;\n}\n```"}
{"task_id": "SimdBench_123_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    int32_t sum_magnitude = 0;\n    int32_t product_sign = 1;\n\n    int i = 0;\n    int size = arr.size();\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= size - 4; i += 4) {\n        // Load 4 integers into a NEON register\n        int32x4_t vec = vld1q_s32(&arr[i]);\n\n        // Extract signs of the 4 integers\n        int32x4_t sign_mask = vshrq_n_s32(vec, 31); // Arithmetic shift right to get 0 or -1\n        int32x4_t ones = vdupq_n_s32(1);            // Vector of all ones\n        int32x4_t signs = vorrq_s32(sign_mask, vandq_s32(vceqq_s32(vec, vdupq_n_s32(0)), ones));\n\n        // Compute product of signs\n        int32x2_t signs_low = vget_low_s32(signs);\n        int32x2_t signs_high = vget_high_s32(signs);\n        int32x2_t prod_low = vmul_s32(signs_low, vext_s32(signs_low, signs_low, 1));\n        int32x2_t prod_high = vmul_s32(signs_high, vext_s32(signs_high, signs_high, 1));\n        int32x2_t prod = vmul_s32(prod_low, prod_high);\n        product_sign *= vget_lane_s32(prod, 0);\n\n        // Compute magnitudes and add to sum\n        int32x4_t magnitude = vabsq_s32(vec);\n        sum_magnitude += vaddvq_s32(magnitude);\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        if (arr[i] == 0) {\n            product_sign = 0;\n        } else {\n            product_sign *= (arr[i] > 0) ? 1 : -1;\n        }\n        sum_magnitude += abs(arr[i]);\n    }\n\n    return product_sign * sum_magnitude;\n}\n```"}
{"task_id": "SimdBench_123_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    int32_t total_sum = 0;\n    int32_t sign_product = 1;\n    size_t i = 0;\n    size_t size = arr.size();\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 integers into a NEON register\n        int32x4_t vec = vld1q_s32(&arr[i]);\n\n        // Compute the absolute values of the 4 integers\n        int32x4_t abs_vec = vabsq_s32(vec);\n\n        // Extract the signs of the 4 integers (-1, 0, or 1)\n        int32x4_t sign_vec = vshrq_n_s32(vec, 31); // Get -1 for negative, 0 otherwise\n        int32x4_t inv_sign_vec = vshrq_n_s32(vnegq_s32(vec), 31); // Get 1 for positive, 0 otherwise\n        sign_vec = vorrq_s32(sign_vec, inv_sign_vec); // Combine to get -1, 0, or 1\n\n        // Update the sign product\n        int32x2_t sign_low = vget_low_s32(sign_vec);\n        int32x2_t sign_high = vget_high_s32(sign_vec);\n        int32x2_t prod_low = vmul_s32(sign_low, vext_s32(sign_low, sign_low, 1));\n        int32x2_t prod_high = vmul_s32(sign_high, vext_s32(sign_high, sign_high, 1));\n        int32x2_t final_prod = vmul_s32(prod_low, prod_high);\n        sign_product *= vget_lane_s32(final_prod, 0);\n\n        // Accumulate the sum of absolute values\n        int32x2_t sum_low = vpadd_s32(vget_low_s32(abs_vec), vget_high_s32(abs_vec));\n        int32x2_t sum_final = vpadd_s32(sum_low, sum_low);\n        total_sum += vget_lane_s32(sum_final, 0);\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        int val = arr[i];\n        total_sum += std::abs(val);\n        if (val > 0) sign_product *= 1;\n        else if (val < 0) sign_product *= -1;\n        else sign_product *= 0;\n    }\n\n    return total_sum * sign_product;\n}\n```"}
{"task_id": "SimdBench_123_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    int32_t total_sum = 0;\n    int32_t sign_product = 1;\n    size_t i = 0;\n    size_t size = arr.size();\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 integers into a NEON register\n        int32x4_t vec = vld1q_s32(&arr[i]);\n\n        // Extract signs of the 4 integers\n        int32x4_t signs = vshrq_n_s32(vec, 31); // Arithmetic shift right to get -1 for negative, 0 for positive\n        int32x4_t is_zero = vceqq_s32(vec, vdupq_n_s32(0)); // Compare each element with 0\n        int32x4_t non_zero_signs = vorrq_s32(signs, vandq_s32(is_zero, vdupq_n_s32(1))); // Combine signs and zeros\n\n        // Calculate magnitudes\n        int32x4_t abs_values = vabsq_s32(vec);\n\n        // Sum magnitudes horizontally\n        int32x2_t sum_partial = vpadd_s32(vget_low_s32(abs_values), vget_high_s32(abs_values));\n        total_sum += vget_lane_s32(vpadd_s32(sum_partial, sum_partial), 0);\n\n        // Update sign product\n        int32x2_t sign_low = vget_low_s32(non_zero_signs);\n        int32x2_t sign_high = vget_high_s32(non_zero_signs);\n        int32x2_t combined_signs = vmul_s32(sign_low, sign_high);\n        int32_t combined_sign_scalar = vget_lane_s32(combined_signs, 0) * vget_lane_s32(combined_signs, 1);\n        sign_product *= combined_sign_scalar;\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        int val = arr[i];\n        if (val == 0) {\n            sign_product = 0;\n        } else {\n            sign_product *= (val > 0) ? 1 : -1;\n        }\n        total_sum += abs(val);\n    }\n\n    return sign_product == 0 ? 0 : total_sum * sign_product;\n}\n```"}
{"task_id": "SimdBench_123_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    int32_t sum_magnitude = 0;\n    int32_t product_sign = 1;\n\n    int i = 0;\n    int size = arr.size();\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= size - 4; i += 4) {\n        // Load 4 integers into a NEON register\n        int32x4_t vec = vld1q_s32(&arr[i]);\n\n        // Compute the magnitude of each element\n        int32x4_t magnitude = vabsq_s32(vec);\n\n        // Extract the sign of each element (-1, 0, or 1)\n        int32x4_t sign = vshrq_n_s32(vec, 31); // Shift to get -1 for negative, 0 for positive\n        int32x4_t is_nonzero = vceqq_s32(vec, vmovq_n_s32(0)); // Check for zero\n        sign = vbslq_s32(is_nonzero, vmovq_n_s32(0), vaddq_s32(sign, vmovq_n_s32(1)));\n\n        // Accumulate magnitudes horizontally\n        int32x2_t sum_partial = vpadd_s32(vget_low_s32(magnitude), vget_high_s32(magnitude));\n        sum_magnitude += vget_lane_s32(vpadd_s32(sum_partial, sum_partial), 0);\n\n        // Accumulate signs horizontally\n        int32x2_t sign_partial = vpadd_s32(vget_low_s32(sign), vget_high_s32(sign));\n        int32_t sign_product = vget_lane_s32(vpadd_s32(sign_partial, sign_partial), 0);\n        product_sign *= sign_product;\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        int val = arr[i];\n        sum_magnitude += abs(val);\n        if (val > 0) product_sign *= 1;\n        else if (val < 0) product_sign *= -1;\n        else product_sign *= 0;\n    }\n\n    return sum_magnitude * product_sign;\n}\n```"}
{"task_id": "SimdBench_124_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>> &grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k, 0);\n    std::vector<std::vector<int>> dp(N, std::vector<int>(N, 0));\n    std::vector<std::vector<int>> next_dp(N, std::vector<int>(N, 0));\n\n    // Initialize dp with the grid values\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            dp[i][j] = grid[i][j];\n        }\n    }\n\n    for (int step = 1; step < k; ++step) {\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j <= N - 4; j += 4) {\n                // Load 4 values from dp using Neon intrinsics\n                int32x4_t dp_vals = vld1q_s32(&dp[i][j]);\n\n                // Initialize minimum values for each of the 4 cells\n                int32x4_t min_vals = dp_vals;\n\n                // Check top neighbor\n                if (i > 0) {\n                    int32x4_t top_vals = vld1q_s32(&dp[i - 1][j]);\n                    min_vals = vminq_s32(min_vals, top_vals);\n                }\n\n                // Check bottom neighbor\n                if (i < N - 1) {\n                    int32x4_t bottom_vals = vld1q_s32(&dp[i + 1][j]);\n                    min_vals = vminq_s32(min_vals, bottom_vals);\n                }\n\n                // Check left neighbor\n                if (j > 0) {\n                    int32x4_t left_vals = vld1q_s32(&dp[i][j - 1]);\n                    min_vals = vminq_s32(min_vals, left_vals);\n                }\n\n                // Check right neighbor\n                if (j < N - 4) {\n                    int32x4_t right_vals = vld1q_s32(&dp[i][j + 1]);\n                    min_vals = vminq_s32(min_vals, right_vals);\n                }\n\n                // Add current grid values to the minimum path values\n                int32x4_t grid_vals = vld1q_s32(&grid[i][j]);\n                min_vals = vaddq_s32(min_vals, grid_vals);\n\n                // Store the results back into next_dp\n                vst1q_s32(&next_dp[i][j], min_vals);\n            }\n\n            // Handle remaining columns (if N is not a multiple of 4)\n            for (int j = N - (N % 4); j < N; ++j) {\n                int min_val = dp[i][j];\n                if (i > 0) min_val = std::min(min_val, dp[i - 1][j]);\n                if (i < N - 1) min_val = std::min(min_val, dp[i + 1][j]);\n                if (j > 0) min_val = std::min(min_val, dp[i][j - 1]);\n                if (j < N - 1) min_val = std::min(min_val, dp[i][j + 1]);\n                next_dp[i][j] = min_val + grid[i][j];\n            }\n        }\n\n        // Swap dp and next_dp for the next iteration\n        dp.swap(next_dp);\n    }\n\n    // Find the minimum path value and reconstruct the path\n    int min_val = INT32_MAX;\n    int start_i = 0, start_j = 0;\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if (dp[i][j] < min_val) {\n                min_val = dp[i][j];\n                start_i = i;\n                start_j = j;\n            }\n        }\n    }\n\n    result[k - 1] = grid[start_i][start_j];\n    for (int step = k - 2; step >= 0; --step) {\n        int min_val = INT32_MAX;\n        int next_i = start_i, next_j = start_j;\n        if (start_i > 0 && dp[start_i - 1][start_j] < min_val) {\n            min_val = dp[start_i - 1][start_j];\n            next_i = start_i - 1;\n            next_j = start_j;\n        }\n        if (start_i < N - 1 && dp[start_i + 1][start_j] < min_val) {\n            min_val = dp[start_i + 1][start_j];\n            next_i = start_i + 1;\n            next_j = start_j;\n        }\n        if (start_j > 0 && dp[start_i][start_j - 1] < min_val) {\n            min_val = dp[start_i][start_j - 1];\n            next_i = start_i;\n            next_j = start_j - 1;\n        }\n        if (start_j < N - 1 && dp[start_i][start_j + 1] < min_val) {\n            min_val = dp[start_i][start_j + 1];\n            next_i = start_i;\n            next_j = start_j + 1;\n        }\n        result[step] = grid[next_i][next_j];\n        start_i = next_i;\n        start_j = next_j;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_124_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>> &grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k, 0);\n    std::vector<int> current_path(k, 0);\n    std::vector<int> best_path(k, 0);\n\n    // Initialize best_path with maximum possible values\n    for (int i = 0; i < k; ++i) {\n        best_path[i] = INT32_MAX;\n    }\n\n    // Directions: up, down, left, right\n    const int dx[4] = {-1, 1, 0, 0};\n    const int dy[4] = {0, 0, -1, 1};\n\n    // Process each starting point in the grid\n    for (int start_x = 0; start_x < N; ++start_x) {\n        for (int start_y = 0; start_y < N; ++start_y) {\n            // Initialize the first element of the path\n            current_path[0] = grid[start_x][start_y];\n\n            // Use a stack to simulate DFS\n            struct State {\n                int x, y, step;\n            };\n            std::vector<State> stack;\n            stack.push_back(State{start_x, start_y, 0});\n\n            while (!stack.empty()) {\n                State current = stack.back();\n                stack.pop_back();\n\n                if (current.step == k - 1) {\n                    // Compare current_path with best_path using SIMD\n                    bool is_better = false;\n                    int i = 0;\n\n                    for (; i <= k - 4; i += 4) {\n                        int32x4_t v_current = vld1q_s32(&current_path[i]);\n                        int32x4_t v_best = vld1q_s32(&best_path[i]);\n                        uint32x4_t v_cmp = vcltq_s32(v_current, v_best);\n\n                        if (vgetq_lane_u32(v_cmp, 0) || vgetq_lane_u32(v_cmp, 1) ||\n                            vgetq_lane_u32(v_cmp, 2) || vgetq_lane_u32(v_cmp, 3)) {\n                            is_better = true;\n                            break;\n                        } else {\n                            uint32x4_t v_eq = vceqq_s32(v_current, v_best);\n                            if (!(vgetq_lane_u32(v_eq, 0) && vgetq_lane_u32(v_eq, 1) &&\n                                  vgetq_lane_u32(v_eq, 2) && vgetq_lane_u32(v_eq, 3))) {\n                                break;\n                            }\n                        }\n                    }\n\n                    for (; i < k; ++i) {\n                        if (current_path[i] < best_path[i]) {\n                            is_better = true;\n                            break;\n                        } else if (current_path[i] > best_path[i]) {\n                            break;\n                        }\n                    }\n\n                    if (is_better) {\n                        best_path = current_path;\n                    }\n                } else {\n                    // Explore neighbors\n                    for (int dir = 0; dir < 4; ++dir) {\n                        int nx = current.x + dx[dir];\n                        int ny = current.y + dy[dir];\n\n                        if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n                            current_path[current.step + 1] = grid[nx][ny];\n                            stack.push_back(State{nx, ny, current.step + 1});\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return best_path;\n}\n```"}
{"task_id": "SimdBench_124_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>> &grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k, 0);\n    std::vector<int> current_path(k, 0);\n    std::vector<int> best_path(k, 0);\n\n    // Initialize best_path with maximum possible values\n    for (int i = 0; i < k; ++i) {\n        best_path[i] = N * N + 1;\n    }\n\n    // Directions: up, down, left, right\n    const int dx[4] = {-1, 1, 0, 0};\n    const int dy[4] = {0, 0, -1, 1};\n\n    for (int start_x = 0; start_x < N; ++start_x) {\n        for (int start_y = 0; start_y < N; ++start_y) {\n            // Initialize the first element of the path\n            current_path[0] = grid[start_x][start_y];\n\n            // Use NEON to parallelize path exploration\n            int32x4_t v_current_path = vld1q_dup_s32(&current_path[0]);\n            int32x4_t v_best_path = vld1q_dup_s32(&best_path[0]);\n\n            for (int step = 1; step < k; ++step) {\n                int min_val = N * N + 1;\n                int next_x = start_x, next_y = start_y;\n\n                for (int dir = 0; dir < 4; ++dir) {\n                    int nx = start_x + dx[dir];\n                    int ny = start_y + dy[dir];\n\n                    if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n                        int val = grid[nx][ny];\n                        if (val < min_val) {\n                            min_val = val;\n                            next_x = nx;\n                            next_y = ny;\n                        }\n                    }\n                }\n\n                current_path[step] = min_val;\n                start_x = next_x;\n                start_y = next_y;\n\n                // Load current path into NEON register\n                v_current_path = vld1q_dup_s32(&current_path[step]);\n\n                // Compare current path with best path using NEON\n                uint32x4_t v_cmp = vcltq_s32(v_current_path, v_best_path);\n                if (vaddvq_u32(v_cmp) > 0) {\n                    v_best_path = v_current_path;\n                }\n            }\n\n            // Store the best path found so far\n            vst1q_s32(&best_path[0], v_best_path);\n        }\n    }\n\n    // Copy the best path to the result\n    for (int i = 0; i < k; ++i) {\n        result[i] = best_path[i];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_124_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>> &grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k, 0);\n    std::vector<std::vector<int>> dp(N, std::vector<int>(N, 0));\n    std::vector<std::vector<int>> next_dp(N, std::vector<int>(N, 0));\n\n    // Initialize dp with grid values\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            dp[i][j] = grid[i][j];\n        }\n    }\n\n    for (int step = 1; step < k; ++step) {\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j <= N - 4; j += 4) {\n                int32x4_t current = vld1q_s32(&dp[i][j]);\n                int32x4_t min_val = current;\n\n                // Check top neighbor\n                if (i > 0) {\n                    int32x4_t top = vld1q_s32(&dp[i - 1][j]);\n                    min_val = vminq_s32(min_val, top);\n                }\n\n                // Check bottom neighbor\n                if (i < N - 1) {\n                    int32x4_t bottom = vld1q_s32(&dp[i + 1][j]);\n                    min_val = vminq_s32(min_val, bottom);\n                }\n\n                // Check left neighbor\n                if (j > 0) {\n                    int32x4_t left = vld1q_s32(&dp[i][j - 1]);\n                    min_val = vminq_s32(min_val, left);\n                }\n\n                // Check right neighbor\n                if (j < N - 4) {\n                    int32x4_t right = vld1q_s32(&dp[i][j + 1]);\n                    min_val = vminq_s32(min_val, right);\n                }\n\n                // Store the minimum value in next_dp\n                vst1q_s32(&next_dp[i][j], min_val);\n            }\n\n            // Handle remaining columns (if N % 4 != 0)\n            for (int j = N - (N % 4); j < N; ++j) {\n                int min_val = dp[i][j];\n                if (i > 0) min_val = std::min(min_val, dp[i - 1][j]);\n                if (i < N - 1) min_val = std::min(min_val, dp[i + 1][j]);\n                if (j > 0) min_val = std::min(min_val, dp[i][j - 1]);\n                if (j < N - 1) min_val = std::min(min_val, dp[i][j + 1]);\n                next_dp[i][j] = min_val;\n            }\n        }\n\n        // Swap dp and next_dp for the next iteration\n        dp.swap(next_dp);\n    }\n\n    // Find the minimum path\n    int min_value = INT32_MAX;\n    int start_row = 0, start_col = 0;\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if (dp[i][j] < min_value) {\n                min_value = dp[i][j];\n                start_row = i;\n                start_col = j;\n            }\n        }\n    }\n\n    result[0] = grid[start_row][start_col];\n    int current_row = start_row, current_col = start_col;\n\n    for (int step = 1; step < k; ++step) {\n        int min_val = INT32_MAX;\n        int next_row = current_row, next_col = current_col;\n\n        if (current_row > 0 && dp[current_row - 1][current_col] < min_val) {\n            min_val = dp[current_row - 1][current_col];\n            next_row = current_row - 1;\n            next_col = current_col;\n        }\n        if (current_row < N - 1 && dp[current_row + 1][current_col] < min_val) {\n            min_val = dp[current_row + 1][current_col];\n            next_row = current_row + 1;\n            next_col = current_col;\n        }\n        if (current_col > 0 && dp[current_row][current_col - 1] < min_val) {\n            min_val = dp[current_row][current_col - 1];\n            next_row = current_row;\n            next_col = current_col - 1;\n        }\n        if (current_col < N - 1 && dp[current_row][current_col + 1] < min_val) {\n            min_val = dp[current_row][current_col + 1];\n            next_row = current_row;\n            next_col = current_col + 1;\n        }\n\n        result[step] = grid[next_row][next_col];\n        current_row = next_row;\n        current_col = next_col;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_124_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>> &grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k, 0);\n    std::vector<int> current_path(k, 0);\n    std::vector<int> best_path(k, 0);\n\n    // Initialize best_path with maximum possible values\n    for (int i = 0; i < k; ++i) {\n        best_path[i] = N * N + 1;\n    }\n\n    // Directions: up, down, left, right\n    const int dx[4] = {-1, 1, 0, 0};\n    const int dy[4] = {0, 0, -1, 1};\n\n    for (int start_x = 0; start_x < N; ++start_x) {\n        for (int start_y = 0; start_y < N; ++start_y) {\n            // Initialize the first element of the path\n            current_path[0] = grid[start_x][start_y];\n\n            // Use NEON to parallelize the comparison of paths\n            int32x4_t v_best = vld1q_s32(&best_path[0]);\n            int32x4_t v_current = vld1q_s32(&current_path[0]);\n\n            if (k == 1) {\n                if (vgetq_lane_s32(v_current, 0) < vgetq_lane_s32(v_best, 0)) {\n                    best_path[0] = current_path[0];\n                }\n                continue;\n            }\n\n            // Explore all possible paths of length k\n            std::vector<std::pair<int, int>> queue = {{start_x, start_y}};\n            while (!queue.empty()) {\n                auto [x, y] = queue.back();\n                queue.pop_back();\n\n                for (int dir = 0; dir < 4; ++dir) {\n                    int nx = x + dx[dir];\n                    int ny = y + dy[dir];\n\n                    if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n                        // Update the current path\n                        current_path.push_back(grid[nx][ny]);\n\n                        // Compare using NEON intrinsics\n                        int32x4_t v_best = vld1q_s32(&best_path[0]);\n                        int32x4_t v_current = vld1q_s32(&current_path[0]);\n\n                        uint32x4_t v_cmp = vcltq_s32(v_current, v_best);\n                        if (vaddvq_u32(v_cmp) > 0) {\n                            best_path = current_path;\n                        }\n\n                        // Backtrack\n                        current_path.pop_back();\n                    }\n                }\n            }\n        }\n    }\n\n    return best_path;\n}\n```"}
{"task_id": "SimdBench_125_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t digits_simd(uint64_t n) {\n    uint8x16_t odd_mask = vdupq_n_u8(0x1); // Mask to check if a digit is odd\n    uint8x16_t zero = vdupq_n_u8(0);       // Vector of zeros\n    uint8x16_t product = vdupq_n_u8(1);    // Initialize product vector to 1\n\n    while (n > 0) {\n        uint8x16_t digits;\n        for (int i = 0; i < 16 && n > 0; ++i) {\n            uint8_t digit = n % 10;\n            n /= 10;\n            digits = vsetq_lane_u8(digit, digits, i);\n        }\n\n        uint8x16_t is_odd = vandq_u8(digits, odd_mask); // Check odd digits\n        uint8x16_t mask = vcgtq_u8(is_odd, zero);       // Create mask for odd digits\n        uint8x16_t valid_digits = vbslq_u8(mask, digits, one);\n\n        product = vmulq_u8(product, valid_digits); // Multiply valid digits\n    }\n\n    // Horizontal reduction to compute the final product\n    uint64_t result = 1;\n    for (int i = 0; i < 16; ++i) {\n        uint8_t value = vgetq_lane_u8(product, i);\n        if (value != 1) {\n            result *= value;\n        }\n    }\n\n    return result == 1 ? 0 : result;\n}\n```"}
{"task_id": "SimdBench_125_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t digits_simd(uint64_t n) {\n    uint8x16_t odd_mask = vdupq_n_u8(0x1); // Mask to check odd digits (1, 3, 5, 7, 9)\n    uint8x16_t digit_mask = vdupq_n_u8(0xF); // Mask to extract individual digits\n    uint8x16_t zero = vdupq_n_u8(0); // Zero vector for comparison\n    uint8x16_t product_vec = vdupq_n_u8(1); // Vector to hold the product of odd digits\n\n    while (n > 0) {\n        uint64_t chunk = n & 0xFFFFFFFFFFFFFFFF; // Extract 64 bits at a time\n        n >>= 64;\n\n        uint8x16_t digits = vreinterpretq_u8_u64(vdupq_n_u64(chunk)); // Load chunk into NEON register\n        digits = vandq_u8(digits, digit_mask); // Extract lower 4 bits of each byte (digit)\n\n        uint8x16_t is_odd = vandq_u8(digits, odd_mask); // Check if each digit is odd\n        uint8x16_t is_nonzero = vcgtq_u8(digits, zero); // Check if each digit is non-zero\n        uint8x16_t valid = vandq_u8(is_odd, is_nonzero); // Combine conditions: odd and non-zero\n\n        // Replace invalid entries with 1 to avoid affecting the product\n        uint8x16_t ones = vdupq_n_u8(1);\n        digits = vbslq_u8(valid, digits, ones);\n\n        // Compute horizontal product of valid digits in the vector\n        for (int i = 0; i < 16; i += 2) {\n            uint8x8_t prod_pair = vmul_u8(vget_low_u8(digits), vget_high_u8(digits));\n            digits = vsetq_lane_u8(prod_pair[0], digits, i / 2);\n        }\n\n        product_vec = vmulq_u8(product_vec, digits); // Accumulate product into result vector\n    }\n\n    // Compute final horizontal product of the accumulated results\n    uint64_t result = 1;\n    uint8_t* ptr = (uint8_t*)&product_vec;\n    for (int i = 0; i < 16; ++i) {\n        result *= ptr[i];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_125_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t digits_simd(uint64_t n) {\n    uint8x16_t odd_mask = vdupq_n_u8(0x1); // Mask to check odd digits (1, 3, 5, 7, 9)\n    uint8x16_t digit_mask = vdupq_n_u8(0xF); // Mask to extract lower 4 bits (digit extraction)\n    uint8x16_t zero = vdupq_n_u8(0); // Vector of zeros\n    uint8x16_t product = vdupq_n_u8(1); // Initialize product vector to 1\n\n    while (n > 0) {\n        uint64_t chunk = n & 0xFFFFFFFFFFFFFFFF; // Extract 64 bits (16 digits max)\n        n >>= 64;\n\n        uint8x16_t digits = vreinterpretq_u8_u64(vdupq_n_u64(chunk)); // Load digits into vector\n        digits = vandq_u8(digits, digit_mask); // Mask to isolate each digit\n\n        uint8x16_t is_odd = vandq_u8(digits, odd_mask); // Check if each digit is odd\n        uint8x16_t valid_digits = vbslq_u8(vceqq_u8(is_odd, odd_mask), digits, zero); // Select odd digits\n\n        // Compute product horizontally within the vector\n        for (int i = 0; i < 16; i++) {\n            uint8_t digit = valid_digits[i];\n            if (digit != 0) {\n                product = vmulq_lane_u8(product, vdupq_n_u8(digit), 0);\n            }\n        }\n    }\n\n    // Reduce the product vector to a single scalar value\n    uint64_t result = 1;\n    for (int i = 0; i < 16; i++) {\n        result *= product[i];\n    }\n\n    return result == 1 ? 0 : result; // Return 0 if all digits were even\n}\n```"}
{"task_id": "SimdBench_125_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t digits_simd(uint64_t n) {\n    uint8x16_t odd_mask = vdupq_n_u8(0x1); // Mask to check odd digits (1, 3, 5, 7, 9)\n    uint8x16_t digit_mask = vdupq_n_u8(0xF); // Mask to extract individual digits\n    uint8x16_t zero = vdupq_n_u8(0); // Vector of zeros\n    uint8x16_t product = vdupq_n_u8(1); // Initialize product vector to 1\n\n    while (n > 0) {\n        uint64_t chunk = n % 10000000000; // Extract 10 digits at a time\n        n /= 10000000000;\n\n        uint8x16_t digits = vdupq_n_u8(0);\n        for (int i = 0; i < 10; ++i) {\n            uint8_t d = chunk % 10;\n            chunk /= 10;\n            digits = vsetq_lane_u8(d, digits, i);\n        }\n\n        uint8x16_t is_odd = vandq_u8(digits, odd_mask); // Check if each digit is odd\n        uint8x16_t valid_digits = vbslq_u8(vceqq_u8(is_odd, odd_mask), digits, zero); // Select odd digits\n\n        // Compute product of valid digits using pairwise multiplication\n        uint8x8_t low = vget_low_u8(valid_digits);\n        uint8x8_t high = vget_high_u8(valid_digits);\n        uint8x8_t prod_low = vmul_u8(low, vshr_n_u8(low, 4));\n        uint8x8_t prod_high = vmul_u8(high, vshr_n_u8(high, 4));\n        uint8x16_t prod = vcombine_u8(prod_low, prod_high);\n\n        product = vmulq_u8(product, prod);\n    }\n\n    // Horizontal reduction to compute the final product\n    uint8x8_t low = vget_low_u8(product);\n    uint8x8_t high = vget_high_u8(product);\n    uint8x8_t reduced = vpadd_u8(low, high);\n    reduced = vpadd_u8(reduced, reduced);\n    reduced = vpadd_u8(reduced, reduced);\n\n    return vget_lane_u8(reduced, 0);\n}\n```"}
{"task_id": "SimdBench_125_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t digits_simd(uint64_t n) {\n    uint8x16_t odd_mask = vdupq_n_u8(0x1); // Mask to check if a digit is odd\n    uint8x16_t zero = vdupq_n_u8(0);       // Vector of zeros\n    uint8x16_t digits = vdupq_n_u8(0);     // Vector to hold digits\n    uint8x16_t product = vdupq_n_u8(1);    // Vector to hold the product of odd digits\n\n    int digit_count = 0;\n    while (n > 0 && digit_count < 16) {\n        uint8_t digit = n % 10;\n        n /= 10;\n        digits = vsetq_lane_u8(digit, digits, digit_count);\n        digit_count++;\n    }\n\n    // Process the digits in parallel\n    for (int i = 0; i < digit_count; i++) {\n        uint8x16_t current_digit = vdupq_n_u8(vgetq_lane_u8(digits, i));\n        uint8x16_t is_odd = vandq_u8(current_digit, odd_mask);\n        uint8x16_t mask = vcgtq_u8(is_odd, zero); // Mask for odd digits\n        product = vmulq_u8(product, vorrq_u8(current_digit, mask));\n    }\n\n    // Horizontal reduction to compute the final product\n    uint64_t result = 1;\n    for (int i = 0; i < digit_count; i++) {\n        uint8_t digit = vgetq_lane_u8(product, i);\n        if (digit != 0) {\n            result *= digit;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_126_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t result = 0;\n    int i = 0;\n    int size = lst.size();\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= size - 4; i += 4) {\n        // Load 4 floats into a NEON register\n        float32x4_t vec = vld1q_f32(&lst[i]);\n\n        // Compute ceiling for each element\n        float32x4_t ceil_vec = vrndpq_f32(vec);\n\n        // Square each element\n        float32x4_t square_vec = vmulq_f32(ceil_vec, ceil_vec);\n\n        // Sum the squared values horizontally\n        float32x2_t sum_partial = vpadd_f32(vget_low_f32(square_vec), vget_high_f32(square_vec));\n        sum_partial = vpadd_f32(sum_partial, sum_partial);\n\n        // Add the result to the total sum\n        result += vget_lane_f32(sum_partial, 0);\n    }\n\n    // Process remaining elements (if any)\n    for (; i < size; ++i) {\n        float val = std::ceil(lst[i]);\n        result += val * val;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_126_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nuint64_t sum_squares_simd(const std::vector<float> &lst) {\n    uint64_t total_sum = 0;\n    int i = 0;\n    int size = lst.size();\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= size - 4; i += 4) {\n        // Load 4 floats into a NEON register\n        float32x4_t vec = vld1q_f32(&lst[i]);\n\n        // Compute ceiling for each element\n        float32x4_t ceil_vec = vrndpq_f32(vec);\n\n        // Square each element\n        float32x4_t squared_vec = vmulq_f32(ceil_vec, ceil_vec);\n\n        // Convert squared values to 32-bit integers\n        int32x4_t int_squared_vec = vcvtq_s32_f32(squared_vec);\n\n        // Horizontally add the 4 integer values\n        int32x2_t sum_pairs = vpadd_s32(vget_low_s32(int_squared_vec), vget_high_s32(int_squared_vec));\n        int32x2_t sum_final = vpadd_s32(sum_pairs, sum_pairs);\n\n        // Add the result to the total sum\n        total_sum += vget_lane_s32(sum_final, 0);\n    }\n\n    // Process remaining elements (if any)\n    for (; i < size; ++i) {\n        float val = std::ceil(lst[i]);\n        total_sum += static_cast<uint64_t>(val * val);\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_126_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t result = 0;\n    int i = 0;\n    int size = lst.size();\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= size - 4; i += 4) {\n        // Load 4 floats into a NEON register\n        float32x4_t vec = vld1q_f32(&lst[i]);\n\n        // Compute the ceiling of each element\n        float32x4_t ceil_vec = vrndpq_f32(vec);\n\n        // Square each element\n        float32x4_t squared_vec = vmulq_f32(ceil_vec, ceil_vec);\n\n        // Convert the squared values to 32-bit integers\n        int32x4_t int_squared_vec = vcvtq_s32_f32(squared_vec);\n\n        // Horizontally add the 4 integer values\n        int32x2_t sum_pairs = vpadd_s32(vget_low_s32(int_squared_vec), vget_high_s32(int_squared_vec));\n        int32x2_t sum_final = vpadd_s32(sum_pairs, sum_pairs);\n\n        // Add the result to the total sum\n        result += vget_lane_s32(sum_final, 0);\n    }\n\n    // Process any remaining elements\n    for (; i < size; ++i) {\n        int ceiled_val = static_cast<int>(std::ceil(lst[i]));\n        result += ceiled_val * ceiled_val;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_126_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t result = 0;\n    int i = 0;\n    int size = lst.size();\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= size - 4; i += 4) {\n        // Load 4 floats from the vector\n        float32x4_t vec = vld1q_f32(&lst[i]);\n\n        // Compute ceiling for each element\n        float32x4_t ceil_vec = vrndpq_f32(vec);\n\n        // Square each element\n        float32x4_t squared_vec = vmulq_f32(ceil_vec, ceil_vec);\n\n        // Convert squared values to uint32_t and horizontally add them\n        uint32x4_t int_vec = vcvtq_u32_f32(squared_vec);\n        uint32x2_t sum_pairs = vpadd_u32(vget_low_u32(int_vec), vget_high_u32(int_vec));\n        uint32x2_t sum_final = vpadd_u32(sum_pairs, sum_pairs);\n\n        // Add the result to the total sum\n        result += vget_lane_u32(sum_final, 0);\n    }\n\n    // Process remaining elements (if any)\n    for (; i < size; ++i) {\n        float val = std::ceil(lst[i]);\n        result += static_cast<uint64_t>(val * val);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_126_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t total_sum = 0;\n    int i = 0;\n    int size = lst.size();\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= size - 4; i += 4) {\n        // Load 4 floats into a NEON register\n        float32x4_t vec = vld1q_f32(&lst[i]);\n\n        // Compute the ceiling of each element\n        float32x4_t ceil_vec = vrndpq_f32(vec);\n\n        // Square each element\n        float32x4_t squared_vec = vmulq_f32(ceil_vec, ceil_vec);\n\n        // Convert squared values to 32-bit integers\n        int32x4_t int_squared_vec = vcvtq_s32_f32(squared_vec);\n\n        // Horizontally add the 4 integer values\n        int32x2_t sum_pairs = vpadd_s32(vget_low_s32(int_squared_vec), vget_high_s32(int_squared_vec));\n        int32x2_t sum_final = vpadd_s32(sum_pairs, sum_pairs);\n\n        // Add the result to the total sum\n        total_sum += vget_lane_s32(sum_final, 0);\n    }\n\n    // Process remaining elements (if any)\n    for (; i < size; ++i) {\n        int ceiled_val = static_cast<int>(std::ceil(lst[i]));\n        total_sum += ceiled_val * ceiled_val;\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_127_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n < 2) return -1;\n\n    int result = -1;\n    int i = 1;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 3 < n; i += 4) {\n        // Load 4 elements starting from index i and i-1\n        int32x4_t current = vld1q_s32(&arr[i]);\n        int32x4_t prev = vld1q_s32(&arr[i - 1]);\n\n        // Compare if current >= prev\n        uint32x4_t mask = vcgeq_s32(current, prev);\n\n        // Convert the mask to a bitmask\n        uint64_t bitmask = vget_lane_u64(vreinterpret_u64_u32(vshrn_n_u64(vreinterpretq_u64_u32(mask), 32)), 0);\n\n        // If any element is less than the previous one, find the first such index\n        if (bitmask != 0xFFFFFFFF) {\n            for (int j = 0; j < 4; ++j) {\n                if (!(bitmask & (1 << j))) {\n                    result = i + j;\n                    break;\n                }\n            }\n            break;\n        }\n    }\n\n    // Check remaining elements\n    for (; i < n; ++i) {\n        if (arr[i] < arr[i - 1]) {\n            result = i;\n            break;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n <= 1) return -1;\n\n    int result = -1;\n    int i = 1;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 3 < n; i += 4) {\n        // Load 4 elements starting from index i and i-1\n        int32x4_t current = vld1q_s32(&arr[i]);\n        int32x4_t previous = vld1q_s32(&arr[i - 1]);\n\n        // Compare if current >= previous\n        uint32x4_t mask = vcgeq_s32(current, previous);\n\n        // Convert the mask to a bitmask\n        uint64_t bitmask = vgetq_lane_u64(vreinterpretq_u64_u32(mask), 0);\n\n        // If any element is less than its predecessor, find the first such index\n        if (bitmask != 0xFFFFFFFFFFFFFFFF) {\n            for (int j = 0; j < 4; ++j) {\n                if (!(bitmask & (1ULL << (j * 16)))) {\n                    result = i + j;\n                    break;\n                }\n            }\n            break;\n        }\n    }\n\n    // Check remaining elements sequentially\n    for (; i < n; ++i) {\n        if (arr[i] < arr[i - 1]) {\n            result = i;\n            break;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n <= 1) return -1;\n\n    int result = -1;\n    int i = 1;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 3 < n; i += 4) {\n        // Load 4 elements starting from index i and i-1\n        int32x4_t current = vld1q_s32(&arr[i]);\n        int32x4_t prev = vld1q_s32(&arr[i - 1]);\n\n        // Compare if current >= prev\n        uint32x4_t mask = vcgeq_s32(current, prev);\n\n        // Convert the mask to a bitmask\n        uint64_t bitmask = vget_lane_u64(vreinterpret_u64_u32(vshrn_n_u64(vreinterpretq_u64_u32(mask), 32)), 0);\n\n        // If any element is less than its predecessor, find the first such index\n        if (bitmask != 0xFFFFFFFF) {\n            for (int j = 0; j < 4; ++j) {\n                if (!(bitmask & (1 << j))) {\n                    result = i + j;\n                    break;\n                }\n            }\n            break;\n        }\n    }\n\n    // Process remaining elements sequentially\n    for (; i < n; ++i) {\n        if (arr[i] < arr[i - 1]) {\n            result = i;\n            break;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n <= 1) return -1;\n\n    int result = -1;\n    int i = 1;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i + 3 < n; i += 4) {\n        // Load 4 elements starting from index i and i-1\n        int32x4_t current = vld1q_s32(&arr[i]);\n        int32x4_t prev = vld1q_s32(&arr[i - 1]);\n\n        // Compare if current >= prev\n        uint32x4_t mask = vcgeq_s32(current, prev);\n\n        // Convert the mask to a bitmask\n        uint64_t bitmask = vget_lane_u64(vreinterpret_u64_u32(vmovn_u32(mask)), 0);\n\n        // If any element in the mask is zero, find the first occurrence\n        if (bitmask != 0xFFFF) {\n            for (int j = 0; j < 4; ++j) {\n                if (!(bitmask & (1 << j))) {\n                    result = i + j;\n                    break;\n                }\n            }\n            break;\n        }\n    }\n\n    // Process remaining elements sequentially\n    for (; i < n; ++i) {\n        if (arr[i] < arr[i - 1]) {\n            result = i;\n            break;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n <= 1) return -1;\n\n    int result = -1;\n    int i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= n - 4; i += 4) {\n        // Load 4 elements from the array into a NEON register\n        int32x4_t current = vld1q_s32(&arr[i]);\n        int32x4_t previous = vld1q_s32(&arr[i - 1]);\n\n        // Compare current >= previous\n        uint32x4_t mask = vcgeq_s32(current, previous);\n\n        // Convert the mask to a bitmask\n        uint32_t bitmask = vget_lane_u32(vreinterpret_u32_u64(vshrn_n_u64(vreinterpretq_u64_u32(mask), 32)), 0);\n\n        // If any element fails the condition, find the specific index\n        if (bitmask != 0xF) {\n            for (int j = 0; j < 4; ++j) {\n                if (!(bitmask & (1 << j))) {\n                    result = i + j;\n                    break;\n                }\n            }\n            break;\n        }\n    }\n\n    // Process remaining elements\n    for (; i < n; ++i) {\n        if (arr[i] < arr[i - 1]) {\n            result = i;\n            break;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_128_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    int size = lst.size();\n    int i = 0;\n\n    // Process 4 integers at a time using NEON intrinsics\n    for (; i <= size - 4; i += 4) {\n        // Load 4 integers into a NEON register\n        int32x4_t vec = vld1q_s32(&lst[i]);\n\n        // Create masks for negative and positive values\n        uint32x4_t negative_mask = vcltq_s32(vec, vdupq_n_s32(0));\n        uint32x4_t positive_mask = vcgtq_s32(vec, vdupq_n_s32(0));\n\n        // Extract negative and positive values, others set to minimum/maximum\n        int32x4_t negatives = vbslq_s32(negative_mask, vec, vdupq_n_s32(std::numeric_limits<int>::min()));\n        int32x4_t positives = vbslq_s32(positive_mask, vec, vdupq_n_s32(std::numeric_limits<int>::max()));\n\n        // Find the largest negative and smallest positive in this vector\n        int32x2_t max_negatives = vmax_s32(vget_low_s32(negatives), vget_high_s32(negatives));\n        int32x2_t min_positives = vmin_s32(vget_low_s32(positives), vget_high_s32(positives));\n\n        int max_neg = vmaxv_s32(max_negatives);\n        int min_pos = vminv_s32(min_positives);\n\n        // Update largest_negative and smallest_positive\n        if (max_neg > largest_negative) {\n            largest_negative = max_neg;\n        }\n        if (min_pos < smallest_positive || smallest_positive == 0) {\n            smallest_positive = min_pos;\n        }\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        if (lst[i] < 0 && lst[i] > largest_negative) {\n            largest_negative = lst[i];\n        }\n        if (lst[i] > 0 && (lst[i] < smallest_positive || smallest_positive == 0)) {\n            smallest_positive = lst[i];\n        }\n    }\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_128_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    int size = lst.size();\n    int i = 0;\n\n    // Process 4 integers at a time using NEON intrinsics\n    for (; i <= size - 4; i += 4) {\n        // Load 4 integers into a NEON register\n        int32x4_t vec = vld1q_s32(&lst[i]);\n\n        // Create masks for negative and positive values\n        uint32x4_t negative_mask = vcltq_s32(vec, vdupq_n_s32(0));\n        uint32x4_t positive_mask = vcgtq_s32(vec, vdupq_n_s32(0));\n\n        // Extract negative and positive values, others set to 0\n        int32x4_t negatives = vandq_s32(vec, vreinterpretq_s32_u32(negative_mask));\n        int32x4_t positives = vandq_s32(vec, vreinterpretq_s32_u32(positive_mask));\n\n        // Find the largest negative in this vector\n        int32x2_t negatives_lo = vget_low_s32(negatives);\n        int32x2_t negatives_hi = vget_high_s32(negatives);\n        int32x2_t max_neg = vpmax_s32(negatives_lo, negatives_hi);\n        max_neg = vpmax_s32(max_neg, max_neg);\n\n        // Update largest_negative if necessary\n        int current_max_neg = vget_lane_s32(max_neg, 0);\n        if (current_max_neg < largest_negative) {\n            largest_negative = current_max_neg;\n        }\n\n        // Find the smallest positive in this vector\n        int32x2_t positives_lo = vget_low_s32(positives);\n        int32x2_t positives_hi = vget_high_s32(positives);\n        int32x2_t min_pos = vpmin_s32(positives_lo, positives_hi);\n        min_pos = vpmin_s32(min_pos, min_pos);\n\n        // Update smallest_positive if necessary\n        int current_min_pos = vget_lane_s32(min_pos, 0);\n        if (current_min_pos > 0 && (smallest_positive == 0 || current_min_pos < smallest_positive)) {\n            smallest_positive = current_min_pos;\n        }\n    }\n\n    // Process remaining elements (less than 4)\n    for (; i < size; ++i) {\n        int val = lst[i];\n        if (val < 0 && val > largest_negative) {\n            largest_negative = val;\n        } else if (val > 0 && (smallest_positive == 0 || val < smallest_positive)) {\n            smallest_positive = val;\n        }\n    }\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_128_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    int size = lst.size();\n    int simd_size = size / 4 * 4; // Process in chunks of 4 for SIMD\n\n    int32x4_t v_largest_negative = vdupq_n_s32(0);\n    int32x4_t v_smallest_positive = vdupq_n_s32(0);\n\n    for (int i = 0; i < simd_size; i += 4) {\n        int32x4_t v = vld1q_s32(&lst[i]);\n\n        // Mask for negative numbers\n        uint32x4_t v_neg_mask = vcltq_s32(v, vdupq_n_s32(0));\n        // Mask for positive numbers\n        uint32x4_t v_pos_mask = vcgtq_s32(v, vdupq_n_s32(0));\n\n        // Update largest negative\n        int32x4_t v_negatives = vbslq_s32(v_neg_mask, v, vdupq_n_s32(std::numeric_limits<int>::min()));\n        v_largest_negative = vmaxq_s32(v_largest_negative, v_negatives);\n\n        // Update smallest positive\n        int32x4_t v_positives = vbslq_s32(v_pos_mask, v, vdupq_n_s32(std::numeric_limits<int>::max()));\n        v_smallest_positive = vminq_s32(v_smallest_positive, v_positives);\n    }\n\n    // Extract results from SIMD registers\n    int32_t temp[4];\n    vst1q_s32(temp, v_largest_negative);\n    for (int i = 0; i < 4; ++i) {\n        if (temp[i] < 0 && temp[i] > largest_negative) {\n            largest_negative = temp[i];\n        }\n    }\n\n    vst1q_s32(temp, v_smallest_positive);\n    for (int i = 0; i < 4; ++i) {\n        if (temp[i] > 0 && temp[i] < smallest_positive) {\n            smallest_positive = temp[i];\n        }\n    }\n\n    // Handle remaining elements\n    for (int i = simd_size; i < size; ++i) {\n        if (lst[i] < 0 && lst[i] > largest_negative) {\n            largest_negative = lst[i];\n        }\n        if (lst[i] > 0 && lst[i] < smallest_positive) {\n            smallest_positive = lst[i];\n        }\n    }\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_128_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    int size = lst.size();\n    int i = 0;\n\n    // Process 4 integers at a time using NEON intrinsics\n    for (; i <= size - 4; i += 4) {\n        // Load 4 integers into a NEON register\n        int32x4_t vec = vld1q_s32(&lst[i]);\n\n        // Create masks for negative and positive values\n        uint32x4_t negative_mask = vcltq_s32(vec, vdupq_n_s32(0));\n        uint32x4_t positive_mask = vcgtq_s32(vec, vdupq_n_s32(0));\n\n        // Extract negatives and positives using masks\n        int32x4_t negatives = vandq_s32(vec, vreinterpretq_s32_u32(negative_mask));\n        int32x4_t positives = vandq_s32(vec, vreinterpretq_s32_u32(positive_mask));\n\n        // Find the largest negative in the current vector\n        int32x2_t negatives_lo = vget_low_s32(negatives);\n        int32x2_t negatives_hi = vget_high_s32(negatives);\n        int32x2_t max_negatives = vpmax_s32(negatives_lo, negatives_hi);\n        int32x2_t max_negatives_final = vpmax_s32(max_negatives, max_negatives);\n        int current_max_negative = vget_lane_s32(max_negatives_final, 0);\n\n        // Find the smallest positive in the current vector\n        int32x2_t positives_lo = vget_low_s32(positives);\n        int32x2_t positives_hi = vget_high_s32(positives);\n        int32x2_t min_positives = vpmin_s32(positives_lo, positives_hi);\n        int32x2_t min_positives_final = vpmin_s32(min_positives, min_positives);\n        int current_min_positive = vget_lane_s32(min_positives_final, 0);\n\n        // Update largest_negative if a larger negative is found\n        if (current_max_negative < 0 && current_max_negative > largest_negative) {\n            largest_negative = current_max_negative;\n        }\n\n        // Update smallest_positive if a smaller positive is found\n        if (current_min_positive > 0 && (smallest_positive == 0 || current_min_positive < smallest_positive)) {\n            smallest_positive = current_min_positive;\n        }\n    }\n\n    // Process remaining elements that didn't fit into the SIMD loop\n    for (; i < size; ++i) {\n        if (lst[i] < 0 && lst[i] > largest_negative) {\n            largest_negative = lst[i];\n        } else if (lst[i] > 0 && (smallest_positive == 0 || lst[i] < smallest_positive)) {\n            smallest_positive = lst[i];\n        }\n    }\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_128_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    int size = lst.size();\n    int i = 0;\n\n    // Process 4 integers at a time using NEON intrinsics\n    for (; i <= size - 4; i += 4) {\n        // Load 4 integers into a NEON register\n        int32x4_t vec = vld1q_s32(&lst[i]);\n\n        // Create masks for negative and positive values\n        uint32x4_t negative_mask = vcltq_s32(vec, vdupq_n_s32(0));\n        uint32x4_t positive_mask = vcgtq_s32(vec, vdupq_n_s32(0));\n\n        // Extract negative and positive values, others set to minimum/maximum\n        int32x4_t negatives = vbslq_s32(negative_mask, vec, vdupq_n_s32(std::numeric_limits<int>::min()));\n        int32x4_t positives = vbslq_s32(positive_mask, vec, vdupq_n_s32(std::numeric_limits<int>::max()));\n\n        // Find the maximum of negatives and minimum of positives in the current vector\n        int32x2_t max_negatives = vmax_s32(vget_low_s32(negatives), vget_high_s32(negatives));\n        int32x2_t min_positives = vmin_s32(vget_low_s32(positives), vget_high_s32(positives));\n\n        int32x2_t max_neg_reduced = vpmax_s32(max_negatives, max_negatives);\n        int32x2_t min_pos_reduced = vpmin_s32(min_positives, min_positives);\n\n        int max_neg_scalar = vget_lane_s32(max_neg_reduced, 0);\n        int min_pos_scalar = vget_lane_s32(min_pos_reduced, 0);\n\n        // Update largest_negative and smallest_positive\n        if (max_neg_scalar > largest_negative) {\n            largest_negative = max_neg_scalar;\n        }\n        if (min_pos_scalar < smallest_positive || smallest_positive == 0) {\n            smallest_positive = min_pos_scalar;\n        }\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        if (lst[i] < 0 && lst[i] > largest_negative) {\n            largest_negative = lst[i];\n        }\n        if (lst[i] > 0 && (lst[i] < smallest_positive || smallest_positive == 0)) {\n            smallest_positive = lst[i];\n        }\n    }\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_129_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    uint64_t result = 1;\n    uint64x2_t vec_result = vmovq_n_u64(1);\n\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t factorial = 1;\n        uint64x2_t vec_factorial = vmovq_n_u64(1);\n\n        for (uint64_t j = 1; j <= i; ++j) {\n            uint64x2_t vec_j = vmovq_n_u64(j);\n            vec_factorial = vmulq_u64(vec_factorial, vec_j);\n        }\n\n        // Horizontal multiplication of the vector elements\n        uint64_t temp_factorial = vgetq_lane_u64(vec_factorial, 0) * vgetq_lane_u64(vec_factorial, 1);\n        factorial = temp_factorial;\n\n        uint64x2_t vec_temp = vmovq_n_u64(factorial);\n        vec_result = vmulq_u64(vec_result, vec_temp);\n    }\n\n    // Horizontal multiplication of the final vector elements\n    uint64_t final_result = vgetq_lane_u64(vec_result, 0) * vgetq_lane_u64(vec_result, 1);\n    result = final_result;\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    uint64_t result = 1;\n    uint64x2_t vec_result = vmovq_n_u64(1);\n\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t fact = 1;\n        for (uint64_t j = 1; j <= i; ++j) {\n            fact *= j;\n        }\n        uint64x2_t vec_fact = vmovq_n_u64(fact);\n        vec_result = vmulq_u64(vec_result, vec_fact);\n    }\n\n    result = vgetq_lane_u64(vec_result, 0) * vgetq_lane_u64(vec_result, 1);\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    uint64_t result = 1;\n    uint64x2_t vec_result = vmovq_n_u64(1);\n\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t factorial = 1;\n        for (uint64_t j = 1; j <= i; ++j) {\n            factorial *= j;\n        }\n\n        uint64x2_t vec_factorial = vmovq_n_u64(factorial);\n        vec_result = vmulq_u64(vec_result, vec_factorial);\n    }\n\n    result = vgetq_lane_u64(vec_result, 0) * vgetq_lane_u64(vec_result, 1);\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    uint64_t result = 1;\n    uint64x2_t vec_result = vmovq_n_u64(1);\n\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t factorial = 1;\n        for (uint64_t j = 1; j <= i; ++j) {\n            factorial *= j;\n        }\n\n        uint64x2_t vec_factorial = vmovq_n_u64(factorial);\n        vec_result = vmulq_u64(vec_result, vec_factorial);\n    }\n\n    // Combine the two 64-bit elements of vec_result into a single scalar result\n    result = vgetq_lane_u64(vec_result, 0) * vgetq_lane_u64(vec_result, 1);\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    uint64_t result = 1;\n    uint64x2_t vec_result = vmovq_n_u64(1);\n\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t factorial = 1;\n        for (uint64_t j = 1; j <= i; ++j) {\n            factorial *= j;\n        }\n        uint64x2_t vec_factorial = vmovq_n_u64(factorial);\n        vec_result = vmulq_u64(vec_result, vec_factorial);\n    }\n\n    // Combine the two 64-bit elements of vec_result into a single 64-bit result\n    result = vgetq_lane_u64(vec_result, 0) * vgetq_lane_u64(vec_result, 1);\n    return result;\n}\n```"}
{"task_id": "SimdBench_130_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> &lst) {\n    int sum = 0;\n    int n = lst.size();\n    int i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= n - 4; i += 4) {\n        // Load 4 integers from the vector into a NEON register\n        int32x4_t vec = vld1q_s32(&lst[i]);\n\n        // Create masks for indices that are multiples of 3 and 4\n        int32x4_t idx = {i, i + 1, i + 2, i + 3};\n        uint32x4_t mask3 = vceqq_s32(vmodq_s32(idx, vdupq_n_s32(3)), vdupq_n_s32(0));\n        uint32x4_t mask4 = vandq_u32(vceqq_s32(vmodq_s32(idx, vdupq_n_s32(4)), vdupq_n_s32(0)),\n                                     vmvnq_u32(mask3));\n\n        // Square elements where index is a multiple of 3\n        int32x4_t squared = vmulq_s32(vec, vec);\n        vec = vbslq_s32(mask3, squared, vec);\n\n        // Cube elements where index is a multiple of 4 and not a multiple of 3\n        int32x4_t cubed = vmulq_s32(vec, vmulq_s32(vec, vec));\n        vec = vbslq_s32(mask4, cubed, vec);\n\n        // Accumulate the results\n        sum += vaddvq_s32(vec);\n    }\n\n    // Process remaining elements\n    for (; i < n; ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    int sum = 0;\n    int n = lst.size();\n    int i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= n - 4; i += 4) {\n        // Load 4 integers from the vector into a NEON register\n        int32x4_t vec = vld1q_s32(&lst[i]);\n\n        // Create masks for indices that are multiples of 3 and 4\n        uint32x4_t mask_mul3 = vmovq_n_u32(0);\n        uint32x4_t mask_mul4 = vmovq_n_u32(0);\n\n        // Set masks based on index conditions\n        mask_mul3 = vorrq_u32(mask_mul3, vmovq_n_u32((i + 0) % 3 == 0 ? ~0 : 0));\n        mask_mul3 = vorrq_u32(mask_mul3, vmovq_n_u32((i + 1) % 3 == 0 ? ~0 : 0));\n        mask_mul3 = vorrq_u32(mask_mul3, vmovq_n_u32((i + 2) % 3 == 0 ? ~0 : 0));\n        mask_mul3 = vorrq_u32(mask_mul3, vmovq_n_u32((i + 3) % 3 == 0 ? ~0 : 0));\n\n        mask_mul4 = vorrq_u32(mask_mul4, vmovq_n_u32((i + 0) % 4 == 0 && (i + 0) % 3 != 0 ? ~0 : 0));\n        mask_mul4 = vorrq_u32(mask_mul4, vmovq_n_u32((i + 1) % 4 == 0 && (i + 1) % 3 != 0 ? ~0 : 0));\n        mask_mul4 = vorrq_u32(mask_mul4, vmovq_n_u32((i + 2) % 4 == 0 && (i + 2) % 3 != 0 ? ~0 : 0));\n        mask_mul4 = vorrq_u32(mask_mul4, vmovq_n_u32((i + 3) % 4 == 0 && (i + 3) % 3 != 0 ? ~0 : 0));\n\n        // Square elements where index is a multiple of 3\n        int32x4_t squared = vmulq_s32(vec, vec);\n        vec = vbslq_s32(mask_mul3, squared, vec);\n\n        // Cube elements where index is a multiple of 4 and not a multiple of 3\n        int32x4_t cubed = vmulq_s32(vec, vmulq_s32(vec, vec));\n        vec = vbslq_s32(mask_mul4, cubed, vec);\n\n        // Accumulate the results horizontally\n        int32x2_t sum_vec = vpadd_s32(vget_low_s32(vec), vget_high_s32(vec));\n        sum_vec = vpadd_s32(sum_vec, sum_vec);\n        sum += vget_lane_s32(sum_vec, 0);\n    }\n\n    // Process remaining elements\n    for (; i < n; ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> &lst) {\n    int sum = 0;\n    int n = lst.size();\n    int i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= n - 4; i += 4) {\n        // Load 4 integers from the vector into a NEON register\n        int32x4_t vec = vld1q_s32(&lst[i]);\n\n        // Create masks for indices that are multiples of 3 and 4\n        int32x4_t idx = {i, i + 1, i + 2, i + 3};\n        uint32x4_t mask_mult_3 = vceqq_u32(vandq_u32(idx, vdupq_n_u32(3)), vdupq_n_u32(0));\n        uint32x4_t mask_mult_4 = vceqq_u32(vandq_u32(idx, vdupq_n_u32(4)), vdupq_n_u32(0));\n\n        // Square elements where index is a multiple of 3\n        int32x4_t squared = vmulq_s32(vec, vec);\n        vec = vbslq_s32(mask_mult_3, squared, vec);\n\n        // Cube elements where index is a multiple of 4 but not 3\n        uint32x4_t mask_mult_4_not_3 = vbicq_u32(mask_mult_4, mask_mult_3);\n        int32x4_t cubed = vmulq_s32(vec, vmulq_s32(vec, vec));\n        vec = vbslq_s32(mask_mult_4_not_3, cubed, vec);\n\n        // Accumulate the results horizontally\n        int32x2_t sum_partial = vpadd_s32(vget_low_s32(vec), vget_high_s32(vec));\n        sum += vget_lane_s32(sum_partial, 0) + vget_lane_s32(sum_partial, 1);\n    }\n\n    // Process remaining elements\n    for (; i < n; ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> &lst) {\n    int sum = 0;\n    int n = lst.size();\n    int i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= n - 4; i += 4) {\n        // Load 4 integers from the vector into a NEON register\n        int32x4_t vec = vld1q_s32(&lst[i]);\n\n        // Create masks for indices that are multiples of 3 and 4\n        int32x4_t idx = {i, i + 1, i + 2, i + 3};\n        uint32x4_t mask_mult3 = vceqq_u32(vmodq_u32(idx, vmovq_n_u32(3)), vmovq_n_u32(0));\n        uint32x4_t mask_mult4 = vandq_u32(vceqq_u32(vmodq_u32(idx, vmovq_n_u32(4)), vmovq_n_u32(0)),\n                                          vmvnq_u32(mask_mult3));\n\n        // Compute squares for indices that are multiples of 3\n        int32x4_t squares = vmulq_s32(vec, vec);\n        vec = vbslq_s32(mask_mult3, squares, vec);\n\n        // Compute cubes for indices that are multiples of 4 but not 3\n        int32x4_t cubes = vmulq_s32(vec, vmulq_s32(vec, vec));\n        vec = vbslq_s32(mask_mult4, cubes, vec);\n\n        // Accumulate the results into the sum\n        sum += vaddvq_s32(vec);\n    }\n\n    // Process remaining elements (if any) using scalar code\n    for (; i < n; ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> &lst) {\n    int sum = 0;\n    int n = lst.size();\n    int i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= n - 4; i += 4) {\n        // Load 4 integers into a NEON register\n        int32x4_t vec = vld1q_s32(&lst[i]);\n\n        // Create masks for indices that are multiples of 3 and 4\n        int32x4_t idx = {i, i + 1, i + 2, i + 3};\n        uint32x4_t mask3 = vceqq_s32(vmodq_s32(idx, vdupq_n_s32(3)), vdupq_n_s32(0));\n        uint32x4_t mask4 = vandq_u32(vceqq_s32(vmodq_s32(idx, vdupq_n_s32(4)), vdupq_n_s32(0)),\n                                     vmvnq_u32(vceqq_s32(vmodq_s32(idx, vdupq_n_s32(3)), vdupq_n_s32(0))));\n\n        // Compute squares for indices that are multiples of 3\n        int32x4_t squares = vmulq_s32(vec, vec);\n        vec = vbslq_s32(mask3, squares, vec);\n\n        // Compute cubes for indices that are multiples of 4 but not 3\n        int32x4_t cubes = vmulq_s32(vec, vmulq_s32(vec, vec));\n        vec = vbslq_s32(mask4, cubes, vec);\n\n        // Accumulate the results into the sum\n        sum += vaddvq_s32(vec);\n    }\n\n    // Process remaining elements\n    for (; i < n; ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_131_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> &nums) {\n    int count = 0;\n    int n = nums.size();\n    int i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= n - 4; i += 4) {\n        // Load 4 integers into a NEON register\n        int32x4_t vec = vld1q_s32(&nums[i]);\n\n        // Compare each element with 10 to check if it's greater than 10\n        uint32x4_t greater_than_10 = vcgtq_s32(vec, vdupq_n_s32(10));\n\n        // Extract absolute values for digit checks\n        int32x4_t abs_vec = vabsq_s32(vec);\n\n        // Extract the last digit of each number (abs_val % 10)\n        int32x4_t last_digit = vqmovn_s64(vreinterpretq_s64_s32(abs_vec)) % 10;\n\n        // Extract the first digit of each number\n        int32x4_t first_digit = abs_vec;\n        for (int j = 0; j < 4; ++j) {\n            int num = vgetq_lane_s32(first_digit, j);\n            while (num >= 10) {\n                num /= 10;\n            }\n            first_digit = vsetq_lane_s32(num, first_digit, j);\n        }\n\n        // Check if both first and last digits are odd\n        uint32x4_t first_digit_odd = vandq_u32(vcgtq_s32(vandq_s32(first_digit, vdupq_n_s32(1)), vdupq_n_s32(0)), greater_than_10);\n        uint32x4_t last_digit_odd = vandq_u32(vcgtq_s32(vandq_s32(last_digit, vdupq_n_s32(1)), vdupq_n_s32(0)), greater_than_10);\n\n        // Combine conditions: both first and last digits must be odd\n        uint32x4_t valid = vandq_u32(first_digit_odd, last_digit_odd);\n\n        // Count the number of valid elements in this batch\n        count += vaddvq_u32(valid);\n    }\n\n    // Process remaining elements (if any) using scalar code\n    for (; i < n; ++i) {\n        int num = nums[i];\n        if (num > 10) {\n            int abs_num = std::abs(num);\n            int last_digit = abs_num % 10;\n            int first_digit = abs_num;\n            while (first_digit >= 10) {\n                first_digit /= 10;\n            }\n            if ((first_digit % 2 == 1) && (last_digit % 2 == 1)) {\n                ++count;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> &nums) {\n    int count = 0;\n    int n = nums.size();\n    int i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= n - 4; i += 4) {\n        // Load 4 integers into a NEON register\n        int32x4_t vec = vld1q_s32(&nums[i]);\n\n        // Compare each element with 10 to check if it's greater than 10\n        uint32x4_t greater_than_10 = vcgtq_s32(vec, vdupq_n_s32(10));\n\n        // Extract absolute values to handle negative numbers\n        int32x4_t abs_vec = vabsq_s32(vec);\n\n        // Compute the last digit of each number (abs_val % 10)\n        int32x4_t last_digit = vqmovn_s32(vreinterpretq_s64_s32(abs_vec)) % 10;\n\n        // Compute the first digit of each number\n        int32x4_t first_digit = abs_vec;\n        for (int j = 0; j < 4; ++j) {\n            first_digit = vdivq_s32(first_digit, vdupq_n_s32(10));\n        }\n\n        // Check if both first and last digits are odd\n        uint32x4_t first_digit_odd = vandq_u32(vcgtq_s32(vandq_s32(first_digit, vdupq_n_s32(1)), vdupq_n_s32(0)));\n        uint32x4_t last_digit_odd = vandq_u32(vcgtq_s32(vandq_s32(last_digit, vdupq_n_s32(1)), vdupq_n_s32(0)));\n\n        // Combine conditions: greater than 10 AND first digit odd AND last digit odd\n        uint32x4_t valid = vandq_u32(greater_than_10, vandq_u32(first_digit_odd, last_digit_odd));\n\n        // Count the number of valid elements in this iteration\n        count += vaddvq_u32(valid);\n    }\n\n    // Process remaining elements (if any) using scalar code\n    for (; i < n; ++i) {\n        int num = nums[i];\n        if (num > 10) {\n            int abs_num = std::abs(num);\n            int last_digit = abs_num % 10;\n            int first_digit = abs_num;\n            while (first_digit >= 10) {\n                first_digit /= 10;\n            }\n            if ((first_digit % 2 != 0) && (last_digit % 2 != 0)) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> &nums) {\n    int count = 0;\n    int n = nums.size();\n    int i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= n - 4; i += 4) {\n        // Load 4 integers into a NEON register\n        int32x4_t vec = vld1q_s32(&nums[i]);\n\n        // Compare each element with 10 to check if it's greater than 10\n        uint32x4_t greater_than_10 = vcgtq_s32(vec, vdupq_n_s32(10));\n\n        // Extract absolute values to handle negative numbers\n        int32x4_t abs_vec = vabsq_s32(vec);\n\n        // Extract the last digit of each number\n        int32x4_t last_digit = vandq_s32(abs_vec, vdupq_n_s32(0xF));\n\n        // Compute the first digit of each number\n        int32x4_t first_digit = abs_vec;\n        for (int j = 0; j < 9; ++j) { // Iteratively divide by 10 to get the first digit\n            first_digit = vdivq_s32(first_digit, vdupq_n_s32(10));\n        }\n\n        // Check if both first and last digits are odd\n        uint32x4_t first_digit_odd = vandq_u32(vreinterpretq_u32_s32(first_digit), vdupq_n_u32(1));\n        uint32x4_t last_digit_odd = vandq_u32(vreinterpretq_u32_s32(last_digit), vdupq_n_u32(1));\n        uint32x4_t both_odd = vandq_u32(first_digit_odd, last_digit_odd);\n\n        // Combine conditions: greater than 10 AND both digits odd\n        uint32x4_t valid = vandq_u32(greater_than_10, both_odd);\n\n        // Count the number of valid elements in this batch\n        uint64x2_t pair_sum = vpaddlq_u32(valid);\n        uint32x2_t sum = vpadd_u32(vget_low_u32(pair_sum), vget_high_u32(pair_sum));\n        count += vget_lane_u32(sum, 0);\n    }\n\n    // Process remaining elements\n    for (; i < n; ++i) {\n        int num = nums[i];\n        if (num > 10) {\n            int abs_num = std::abs(num);\n            int last_digit = abs_num % 10;\n            while (abs_num >= 10) {\n                abs_num /= 10;\n            }\n            int first_digit = abs_num;\n            if ((first_digit % 2 == 1) && (last_digit % 2 == 1)) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> &nums) {\n    int count = 0;\n    int n = nums.size();\n    int i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= n - 4; i += 4) {\n        // Load 4 integers into a NEON register\n        int32x4_t vec = vld1q_s32(&nums[i]);\n\n        // Compare each element with 10 to check if it's greater than 10\n        uint32x4_t greater_than_10 = vcgtq_s32(vec, vdupq_n_s32(10));\n\n        // Extract absolute values for first and last digit calculations\n        int32x4_t abs_vec = vabsq_s32(vec);\n\n        // Compute the last digit of each number (abs_val % 10)\n        int32x4_t last_digit = vremq_s32(abs_vec, vdupq_n_s32(10));\n\n        // Compute the first digit of each number\n        int32x4_t first_digit = abs_vec;\n        for (int j = 0; j < 4; ++j) {\n            int val = vgetq_lane_s32(first_digit, j);\n            while (val >= 10) {\n                val /= 10;\n            }\n            first_digit = vsetq_lane_s32(val, first_digit, j);\n        }\n\n        // Check if the first and last digits are odd\n        uint32x4_t first_digit_odd = vandq_u32(vreinterpretq_u32_s32(first_digit), vdupq_n_u32(1));\n        uint32x4_t last_digit_odd = vandq_u32(vreinterpretq_u32_s32(last_digit), vdupq_n_u32(1));\n\n        // Combine conditions: greater than 10, first digit odd, last digit odd\n        uint32x4_t mask = vandq_u32(greater_than_10, vandq_u32(first_digit_odd, last_digit_odd));\n\n        // Count the number of true values in the mask\n        count += vaddvq_u32(mask);\n    }\n\n    // Process remaining elements\n    for (; i < n; ++i) {\n        int num = nums[i];\n        if (num > 10) {\n            int abs_num = std::abs(num);\n            int last_digit = abs_num % 10;\n            int first_digit = abs_num;\n            while (first_digit >= 10) {\n                first_digit /= 10;\n            }\n            if ((first_digit % 2 == 1) && (last_digit % 2 == 1)) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> &nums) {\n    int count = 0;\n    int n = nums.size();\n    int i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= n - 4; i += 4) {\n        // Load 4 integers into a NEON register\n        int32x4_t vec = vld1q_s32(&nums[i]);\n\n        // Compare each element with 10 to check if it's greater than 10\n        uint32x4_t greater_than_10 = vcgtq_s32(vec, vdupq_n_s32(10));\n\n        // Extract absolute values for digit checks\n        int32x4_t abs_vec = vabsq_s32(vec);\n\n        // Extract the first digit of each number\n        int32x4_t first_digit = abs_vec;\n        while (true) {\n            int32x4_t div_by_10 = vdivq_s32(first_digit, vdupq_n_s32(10));\n            uint32x4_t is_zero = vceqq_s32(div_by_10, vdupq_n_s32(0));\n            if (vaddvq_u32(is_zero) == 4) break; // All elements are single-digit\n            first_digit = div_by_10;\n        }\n\n        // Extract the last digit of each number\n        int32x4_t last_digit = vmodq_s32(abs_vec, vdupq_n_s32(10));\n\n        // Check if first and last digits are odd\n        uint32x4_t first_digit_odd = vandq_u32(vceqq_s32(vandq_s32(first_digit, vdupq_n_s32(1)), vdupq_n_s32(1)), vdupq_n_u32(1));\n        uint32x4_t last_digit_odd = vandq_u32(vceqq_s32(vandq_s32(last_digit, vdupq_n_s32(1)), vdupq_n_s32(1)), vdupq_n_u32(1));\n\n        // Combine conditions: greater than 10, first digit odd, last digit odd\n        uint32x4_t valid = vandq_u32(greater_than_10, vandq_u32(first_digit_odd, last_digit_odd));\n\n        // Count the number of valid elements in this iteration\n        count += vaddvq_u32(valid);\n    }\n\n    // Process remaining elements\n    for (; i < n; ++i) {\n        int num = nums[i];\n        if (num > 10) {\n            int abs_num = std::abs(num);\n            int first_digit = abs_num;\n            while (first_digit >= 10) {\n                first_digit /= 10;\n            }\n            int last_digit = abs_num % 10;\n            if (first_digit % 2 == 1 && last_digit % 2 == 1) {\n                ++count;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    uint64_t count = 0;\n    uint64_t simd_width = 4; // Process 4 elements at a time using NEON\n\n    // Allocate space for the array 'a'\n    uint32_t *a = (uint32_t *)malloc(n * sizeof(uint32_t));\n    if (!a) return 0;\n\n    // Compute values of a[i] = i * i - i + 1\n    for (uint64_t i = 0; i < n; ++i) {\n        a[i] = i * i - i + 1;\n    }\n\n    // Precompute modulo 3 values for all elements in 'a'\n    uint32_t *mod3 = (uint32_t *)malloc(n * sizeof(uint32_t));\n    if (!mod3) {\n        free(a);\n        return 0;\n    }\n    for (uint64_t i = 0; i < n; ++i) {\n        mod3[i] = a[i] % 3;\n    }\n\n    // Count triples using NEON intrinsics\n    for (uint64_t i = 0; i < n; ++i) {\n        uint64_t j = i + 1;\n        while (j + simd_width <= n) {\n            // Load 4 elements of mod3 starting from index j\n            uint32x4_t v_mod3_j = vld1q_u32(&mod3[j]);\n\n            // Broadcast mod3[i] to all lanes of a vector\n            uint32x4_t v_mod3_i = vmovq_n_u32(mod3[i]);\n\n            // Add mod3[i] to each element of v_mod3_j\n            uint32x4_t v_sum_ij = vaddq_u32(v_mod3_i, v_mod3_j);\n\n            // Iterate over k in chunks of 4\n            for (uint64_t k = j + 1; k + simd_width <= n; k += simd_width) {\n                // Load 4 elements of mod3 starting from index k\n                uint32x4_t v_mod3_k = vld1q_u32(&mod3[k]);\n\n                // Add v_sum_ij to each element of v_mod3_k\n                uint32x4_t v_sum_ijk = vaddq_u32(v_sum_ij, v_mod3_k);\n\n                // Check which sums are divisible by 3\n                uint32x4_t v_divisible = vceqq_u32(vandq_u32(v_sum_ijk, vmovq_n_u32(3)), vmovq_n_u32(0));\n\n                // Count the number of true values in v_divisible\n                uint64_t mask = vget_lane_u64(vreinterpret_u64_u32(v_divisible), 0);\n                count += __builtin_popcountll(mask);\n            }\n\n            j += simd_width;\n        }\n\n        // Handle remaining elements for j and k (not aligned to simd_width)\n        for (uint64_t j_remain = j; j_remain < n; ++j_remain) {\n            for (uint64_t k_remain = j_remain + 1; k_remain < n; ++k_remain) {\n                if ((mod3[i] + mod3[j_remain] + mod3[k_remain]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    free(a);\n    free(mod3);\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    uint64_t count = 0;\n    uint64_t simd_width = 4; // Process 4 elements at a time using NEON\n\n    // Allocate space for the array 'a' and compute its values\n    uint32_t *a = (uint32_t *)malloc(n * sizeof(uint32_t));\n    for (uint64_t i = 0; i < n; ++i) {\n        a[i] = i * i - i + 1;\n    }\n\n    // Precompute modulo 3 values for all elements in 'a'\n    uint32_t *mod3 = (uint32_t *)malloc(n * sizeof(uint32_t));\n    for (uint64_t i = 0; i < n; ++i) {\n        mod3[i] = a[i] % 3;\n    }\n\n    // Count occurrences of each modulo class (0, 1, 2)\n    uint64_t count_mod[3] = {0, 0, 0};\n    for (uint64_t i = 0; i < n; ++i) {\n        count_mod[mod3[i]]++;\n    }\n\n    // Use NEON to process triples in parallel\n    for (uint64_t i = 0; i + simd_width <= n; i += simd_width) {\n        uint32x4_t mod_vec = vld1q_u32(&mod3[i]);\n\n        // Compare each element with modulo classes 0, 1, and 2\n        uint32x4_t cmp0 = vceqq_u32(mod_vec, vmovq_n_u32(0));\n        uint32x4_t cmp1 = vceqq_u32(mod_vec, vmovq_n_u32(1));\n        uint32x4_t cmp2 = vceqq_u32(mod_vec, vmovq_n_u32(2));\n\n        // Count matches for each modulo class\n        uint64_t sum0 = vaddvq_u32(cmp0);\n        uint64_t sum1 = vaddvq_u32(cmp1);\n        uint64_t sum2 = vaddvq_u32(cmp2);\n\n        count_mod[0] += sum0;\n        count_mod[1] += sum1;\n        count_mod[2] += sum2;\n    }\n\n    // Handle remaining elements that don't fit into SIMD width\n    for (uint64_t i = n - (n % simd_width); i < n; ++i) {\n        count_mod[mod3[i]]++;\n    }\n\n    // Compute the number of valid triples\n    uint64_t triples = 0;\n\n    // Case 1: All three elements have the same modulo class\n    triples += (count_mod[0] * (count_mod[0] - 1) * (count_mod[0] - 2)) / 6;\n    triples += (count_mod[1] * (count_mod[1] - 1) * (count_mod[1] - 2)) / 6;\n    triples += (count_mod[2] * (count_mod[2] - 1) * (count_mod[2] - 2)) / 6;\n\n    // Case 2: Each element has a different modulo class\n    triples += count_mod[0] * count_mod[1] * count_mod[2];\n\n    free(a);\n    free(mod3);\n\n    return triples;\n}\n```"}
{"task_id": "SimdBench_132_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    uint64_t count = 0;\n    uint64_t simd_size = 4; // Process 4 elements at a time using NEON\n\n    // Allocate space for the array 'a' and compute its values\n    uint32_t *a = (uint32_t *)malloc(n * sizeof(uint32_t));\n    for (uint64_t i = 0; i < n; ++i) {\n        a[i] = i * i - i + 1;\n    }\n\n    // Precompute modulo 3 values for all elements in 'a'\n    uint32_t *mod3 = (uint32_t *)malloc(n * sizeof(uint32_t));\n    for (uint64_t i = 0; i < n; ++i) {\n        mod3[i] = a[i] % 3;\n    }\n\n    // Count occurrences of each modulo class (0, 1, 2)\n    uint64_t count_mod[3] = {0, 0, 0};\n    for (uint64_t i = 0; i < n; ++i) {\n        count_mod[mod3[i]]++;\n    }\n\n    // Use SIMD to process triples in parallel\n    for (uint64_t i = 0; i + simd_size <= n; i += simd_size) {\n        uint32x4_t mod_vec = vld1q_u32(&mod3[i]);\n\n        // Extract individual lanes\n        uint32_t m0 = vgetq_lane_u32(mod_vec, 0);\n        uint32_t m1 = vgetq_lane_u32(mod_vec, 1);\n        uint32_t m2 = vgetq_lane_u32(mod_vec, 2);\n        uint32_t m3 = vgetq_lane_u32(mod_vec, 3);\n\n        // Check combinations of triples within this vector\n        if ((m0 + m1 + m2) % 3 == 0) count++;\n        if ((m0 + m1 + m3) % 3 == 0) count++;\n        if ((m0 + m2 + m3) % 3 == 0) count++;\n        if ((m1 + m2 + m3) % 3 == 0) count++;\n    }\n\n    // Handle remaining elements that don't fit into SIMD blocks\n    for (uint64_t i = n - (n % simd_size); i < n; ++i) {\n        for (uint64_t j = i + 1; j < n; ++j) {\n            for (uint64_t k = j + 1; k < n; ++k) {\n                if ((mod3[i] + mod3[j] + mod3[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    free(a);\n    free(mod3);\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    uint64_t count = 0;\n    uint64_t simd_size = 4; // Process 4 elements at a time using NEON\n\n    // Allocate space for the array 'a'\n    uint32_t *a = (uint32_t *)malloc(n * sizeof(uint32_t));\n    if (!a) return 0;\n\n    // Compute values of a[i] = i * i - i + 1\n    for (uint64_t i = 0; i < n; ++i) {\n        a[i] = i * i - i + 1;\n    }\n\n    // Precompute modulo 3 values for all elements in 'a'\n    uint32_t *mod3 = (uint32_t *)malloc(n * sizeof(uint32_t));\n    if (!mod3) {\n        free(a);\n        return 0;\n    }\n    for (uint64_t i = 0; i < n; ++i) {\n        mod3[i] = a[i] % 3;\n    }\n\n    // Count occurrences of each modulo class (0, 1, 2)\n    uint64_t count_mod[3] = {0, 0, 0};\n    for (uint64_t i = 0; i < n; ++i) {\n        count_mod[mod3[i]]++;\n    }\n\n    // Use NEON to process triples in parallel\n    for (uint64_t i = 0; i + simd_size <= n; i += simd_size) {\n        uint32x4_t mod3_vec = vld1q_u32(&mod3[i]);\n\n        // Extract individual elements from the vector\n        uint32_t m0 = vgetq_lane_u32(mod3_vec, 0);\n        uint32_t m1 = vgetq_lane_u32(mod3_vec, 1);\n        uint32_t m2 = vgetq_lane_u32(mod3_vec, 2);\n        uint32_t m3 = vgetq_lane_u32(mod3_vec, 3);\n\n        // Check combinations of triples within the vector\n        for (uint32_t j = 0; j < simd_size; ++j) {\n            for (uint32_t k = j + 1; k < simd_size; ++k) {\n                for (uint32_t l = k + 1; l < simd_size; ++l) {\n                    uint32_t sum_mod = (mod3[i + j] + mod3[i + k] + mod3[i + l]) % 3;\n                    if (sum_mod == 0) {\n                        count++;\n                    }\n                }\n            }\n        }\n    }\n\n    // Handle remaining elements that don't fit into SIMD blocks\n    for (uint64_t i = n - (n % simd_size); i < n; ++i) {\n        for (uint64_t j = i + 1; j < n; ++j) {\n            for (uint64_t k = j + 1; k < n; ++k) {\n                uint32_t sum_mod = (mod3[i] + mod3[j] + mod3[k]) % 3;\n                if (sum_mod == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    // Free allocated memory\n    free(a);\n    free(mod3);\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    uint64_t count = 0;\n    uint64_t simd_size = 4; // Process 4 elements at a time using NEON\n    uint64_t aligned_n = (n / simd_size) * simd_size;\n\n    // Allocate space for the array 'a'\n    uint32_t *a = (uint32_t *)malloc(n * sizeof(uint32_t));\n\n    // Compute a[i] = i * i - i + 1 for all i using scalar computation\n    for (uint64_t i = 0; i < n; ++i) {\n        a[i] = i * i - i + 1;\n    }\n\n    // SIMD processing for triples\n    for (uint64_t i = 0; i < n - 2; ++i) {\n        uint64_t j = i + 1;\n        // Process j, k in chunks of 4 using NEON intrinsics\n        for (; j + simd_size <= n; j += simd_size) {\n            uint32x4_t ai = vdupq_n_u32(a[i]); // Broadcast a[i] to all lanes\n            uint32x4_t aj = vld1q_u32(&a[j]); // Load 4 values of a[j] into a vector\n            uint32x4_t ak = vld1q_u32(&a[j + 1]); // Load 4 values of a[k] into a vector\n\n            // Compute sum = a[i] + a[j] + a[k]\n            uint32x4_t sum = vaddq_u32(ai, aj);\n            sum = vaddq_u32(sum, ak);\n\n            // Check if sum is divisible by 3\n            uint32x4_t mod3 = vdupq_n_u32(3);\n            uint32x4_t remainder = vqrdmulhq_u32(sum, mod3); // Approximate division by 3\n            uint32x4_t mask = vceqq_u32(remainder, vdupq_n_u32(0)); // Compare with 0\n\n            // Count the number of valid triples in this chunk\n            uint64_t valid_count = vaddvq_u32(mask); // Horizontal sum of mask\n            count += valid_count;\n        }\n\n        // Handle remaining elements (if any) using scalar computation\n        for (; j < n - 1; ++j) {\n            for (uint64_t k = j + 1; k < n; ++k) {\n                uint64_t sum = a[i] + a[j] + a[k];\n                if (sum % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    free(a);\n    return count;\n}\n```"}
{"task_id": "SimdBench_133_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    // Load n into a SIMD register and broadcast it to all lanes\n    int32x4_t vn = vdupq_n_s32(n);\n\n    // Initialize a vector of integers from 2 to 5 for divisibility checks\n    int32x4_t divisors = {2, 3, 4, 5};\n\n    // Perform modulo operation in parallel\n    uint32x4_t remainder = vreinterpretq_u32_s32(vmodq_s32(vn, divisors));\n\n    // Check if any remainder is zero (indicating divisibility)\n    uint32x4_t zero = vdupq_n_u32(0);\n    uint32x4_t is_divisible = vceqq_u32(remainder, zero);\n\n    // Reduce the result to a single flag indicating if any divisibility was found\n    uint32_t mask = vaddvq_u32(is_divisible);\n\n    // If mask is non-zero, n is not prime; otherwise, n is prime\n    return (mask != 0) ? y : x;\n}\n```"}
{"task_id": "SimdBench_133_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    if (n <= 1) return y;\n\n    int sqrt_n = 0;\n    for (int i = 0; i < 2; ++i) {\n        sqrt_n += (n >> i);\n    }\n    sqrt_n >>= 1;\n\n    int32x4_t vn = vdupq_n_s32(n);\n    int32x4_t vprime = vdupq_n_s32(1);\n\n    for (int i = 2; i <= sqrt_n; ++i) {\n        int32x4_t vi = vdupq_n_s32(i);\n        int32x4_t vmod = vqrdmulhq_n_s32(vn, i);\n        vmod = vmulq_n_s32(vmod, i);\n        uint32x4_t mask = vceqq_s32(vmod, vn);\n        vprime = vandq_u32(vprime, vmvnq_u32(mask));\n    }\n\n    int32x4_t vx = vdupq_n_s32(x);\n    int32x4_t vy = vdupq_n_s32(y);\n    int32x4_t result = vbslq_s32(vprime, vx, vy);\n\n    return vgetq_lane_s32(result, 0);\n}\n```"}
{"task_id": "SimdBench_133_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    if (n <= 1) return y;\n\n    int sqrt_n = 0;\n    for (int i = 0; i < 2; ++i) {\n        sqrt_n += (n >> i);\n    }\n    sqrt_n >>= 1;\n\n    int32x4_t vn = vdupq_n_s32(n);\n    int32x4_t vprime = vdupq_n_s32(1);\n\n    for (int i = 2; i <= sqrt_n; ++i) {\n        int32x4_t vi = vdupq_n_s32(i);\n        int32x4_t vmod = vqrdmulhq_n_s32(vn, i);\n        int32x4_t vcmp = vceqq_s32(vmod, vi);\n\n        vprime = vandq_s32(vprime, vmvnq_s32(vcmp));\n    }\n\n    int32x2_t vprime_low = vget_low_s32(vprime);\n    int32x2_t vprime_high = vget_high_s32(vprime);\n    int32x2_t vcombined = vand_s32(vprime_low, vprime_high);\n\n    int is_prime = vget_lane_s32(vcombined, 0) & vget_lane_s32(vcombined, 1);\n\n    return is_prime ? x : y;\n}\n```"}
{"task_id": "SimdBench_133_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    // Load n into a SIMD register and broadcast it to all lanes\n    int32x4_t vn = vdupq_n_s32(n);\n\n    // Initialize a vector of integers from 2 to 5 for divisibility checks\n    int32x4_t divisors = {2, 3, 4, 5};\n\n    // Perform modulo operation in parallel\n    uint32x4_t results = vmull_s32(vget_low_s32(vn), vget_low_s32(divisors));\n\n    // Check if any of the modulo results are zero\n    uint32x4_t zero = vdupq_n_u32(0);\n    uint32x4_t is_zero = vceqq_u32(results, zero);\n\n    // Reduce the comparison results to a single flag\n    uint32_t mask = vaddvq_u32(is_zero);\n\n    // If mask is non-zero, n is not prime; otherwise, it is prime\n    return (mask != 0) ? y : x;\n}\n```"}
{"task_id": "SimdBench_133_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    if (n <= 1) return y;\n\n    int sqrt_n = 1;\n    while (sqrt_n * sqrt_n <= n) sqrt_n++;\n    sqrt_n--;\n\n    int32x4_t vn = vdupq_n_s32(n);\n    int32x4_t vprime = vdupq_n_s32(1);\n\n    for (int i = 2; i <= sqrt_n; i++) {\n        int32x4_t vi = vdupq_n_s32(i);\n        int32x4_t vmod = vqrdmulhq_n_s32(vn, i);\n        vmod = vmulq_n_s32(vmod, i);\n        uint32x4_t vcmp = vceqq_s32(vmod, vn);\n        vprime = vandq_u32(vprime, vcmp);\n    }\n\n    int32x4_t vx = vdupq_n_s32(x);\n    int32x4_t vy = vdupq_n_s32(y);\n    int32x4_t vresult = vbslq_s32(vprime, vx, vy);\n\n    int result[4];\n    vst1q_s32(result, vresult);\n    return result[0];\n}\n```"}
{"task_id": "SimdBench_134_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    uint64_t result = 0;\n    int i = 0;\n    int size = lst.size();\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= size - 4; i += 4) {\n        // Load 4 floats into a NEON register\n        float32x4_t vec = vld1q_f32(&lst[i]);\n\n        // Create a mask for positive numbers (numbers >= 0)\n        uint32x4_t positive_mask = vcgeq_f32(vec, vdupq_n_f32(0.0f));\n\n        // Create a mask for integer values (numbers == floor(numbers))\n        float32x4_t floor_vec = vrndmq_f32(vec);\n        uint32x4_t integer_mask = vceqq_f32(vec, floor_vec);\n\n        // Combine masks: positive and integer\n        uint32x4_t valid_mask = vandq_u32(positive_mask, integer_mask);\n\n        // Convert valid floats to integers\n        int32x4_t int_vec = vcvtq_s32_f32(vec);\n\n        // Create a mask for odd integers\n        int32x4_t odd_mask = vandq_s32(int_vec, vdupq_n_s32(1));\n        uint32x4_t odd_valid_mask = vandq_u32(valid_mask, vmvnq_u32(vceqq_s32(odd_mask, vdupq_n_s32(0))));\n\n        // Square the valid odd integers\n        int32x4_t squared = vmulq_s32(int_vec, int_vec);\n\n        // Blend squared values with zero based on the odd_valid_mask\n        int32x4_t masked_squared = vbslq_s32(odd_valid_mask, squared, vdupq_n_s32(0));\n\n        // Horizontally add the squared values\n        int32x2_t sum_pairs = vpadd_s32(vget_low_s32(masked_squared), vget_high_s32(masked_squared));\n        int32x2_t sum_final = vpadd_s32(sum_pairs, sum_pairs);\n\n        // Add the result to the accumulator\n        result += vget_lane_s32(sum_final, 0);\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        float val = lst[i];\n        if (val >= 0 && val == static_cast<int>(val)) {\n            int intval = static_cast<int>(val);\n            if (intval % 2 != 0) {\n                result += static_cast<uint64_t>(intval * intval);\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_134_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    uint64_t result = 0;\n    int i = 0;\n    int size = lst.size();\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= size - 4; i += 4) {\n        // Load 4 floats into a NEON register\n        float32x4_t vec = vld1q_f32(&lst[i]);\n\n        // Create a mask for positive values\n        uint32x4_t positive_mask = vcgtq_f32(vec, vdupq_n_f32(0.0f));\n\n        // Create a mask for integer values (values equal to their truncated version)\n        int32x4_t truncated = vcvtq_s32_f32(vec);\n        float32x4_t truncated_back = vcvtq_f32_s32(truncated);\n        uint32x4_t integer_mask = vceqq_f32(vec, truncated_back);\n\n        // Combine masks: positive and integer\n        uint32x4_t valid_mask = vandq_u32(positive_mask, integer_mask);\n\n        // Convert valid floats to integers\n        int32x4_t int_vec = vcvtq_s32_f32(vec);\n\n        // Create a mask for odd integers\n        int32x4_t odd_mask = vandq_s32(int_vec, vdupq_n_s32(1));\n        uint32x4_t odd_valid_mask = vandq_u32(valid_mask, vreinterpretq_u32_s32(odd_mask));\n\n        // Square the integers\n        int32x4_t squared = vmulq_s32(int_vec, int_vec);\n\n        // Blend squared values with zero based on the odd_valid_mask\n        int32x4_t masked_squared = vbslq_s32(odd_valid_mask, squared, vdupq_n_s32(0));\n\n        // Horizontally add the squared values\n        int32x2_t sum_pairs = vpadd_s32(vget_low_s32(masked_squared), vget_high_s32(masked_squared));\n        int32x2_t sum_final = vpadd_s32(sum_pairs, sum_pairs);\n\n        // Accumulate the result\n        result += vget_lane_s32(sum_final, 0);\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        float val = lst[i];\n        if (val > 0 && val == static_cast<int>(val)) {\n            int int_val = static_cast<int>(val);\n            if (int_val % 2 != 0) {\n                result += static_cast<uint64_t>(int_val * int_val);\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_134_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    uint64_t result = 0;\n    int i = 0;\n    int size = lst.size();\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= size - 4; i += 4) {\n        // Load 4 floats into a NEON register\n        float32x4_t vec = vld1q_f32(&lst[i]);\n\n        // Create a mask for positive numbers (vec > 0)\n        uint32x4_t positive_mask = vcgtq_f32(vec, vdupq_n_f32(0.0f));\n\n        // Create a mask for integer numbers (fract(vec) == 0)\n        float32x4_t trunc_vec = vrndq_f32(vec);\n        uint32x4_t integer_mask = vceqq_f32(vec, trunc_vec);\n\n        // Combine masks: positive and integer\n        uint32x4_t valid_mask = vandq_u32(positive_mask, integer_mask);\n\n        // Convert to integers for odd check\n        int32x4_t int_vec = vcvtq_s32_f32(vec);\n        uint32x4_t odd_mask = vmovq_n_u32(1); // Odd check mask\n        odd_mask = vandq_u32(vreinterpretq_u32_s32(int_vec), odd_mask);\n\n        // Combine with odd mask\n        valid_mask = vandq_u32(valid_mask, odd_mask);\n\n        // Square the valid elements\n        float32x4_t squared = vmulq_f32(vec, vec);\n\n        // Mask out invalid elements\n        float32x4_t masked_squared = vbslq_f32(valid_mask, squared, vdupq_n_f32(0.0f));\n\n        // Sum the squared values horizontally\n        float32x2_t sum_partial = vpadd_f32(vget_low_f32(masked_squared), vget_high_f32(masked_squared));\n        float32x2_t sum_final = vpadd_f32(sum_partial, sum_partial);\n\n        // Add the result to the total sum\n        result += vget_lane_f32(sum_final, 0);\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        float val = lst[i];\n        if (val > 0 && std::floor(val) == val && static_cast<int>(val) % 2 != 0) {\n            result += val * val;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_134_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    uint64_t result = 0;\n    int i = 0;\n    int size = lst.size();\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= size - 4; i += 4) {\n        // Load 4 floats into a NEON register\n        float32x4_t vec = vld1q_f32(&lst[i]);\n\n        // Create a mask for positive numbers (vec > 0.0f)\n        uint32x4_t positive_mask = vcgtq_f32(vec, vdupq_n_f32(0.0f));\n\n        // Create a mask for integer values (truncated value == original value)\n        int32x4_t truncated = vcvtq_s32_f32(vec);\n        float32x4_t truncated_back = vcvtq_f32_s32(truncated);\n        uint32x4_t integer_mask = vceqq_f32(vec, truncated_back);\n\n        // Combine masks: positive and integer\n        uint32x4_t valid_mask = vandq_u32(positive_mask, integer_mask);\n\n        // Check for odd integers (integer % 2 != 0)\n        int32x4_t mod2 = vandq_s32(truncated, vdupq_n_s32(1));\n        uint32x4_t odd_mask = vcgtq_s32(mod2, vdupq_n_s32(0));\n\n        // Final mask: positive, integer, and odd\n        uint32x4_t final_mask = vandq_u32(valid_mask, odd_mask);\n\n        // Square the values\n        float32x4_t squared = vmulq_f32(vec, vec);\n\n        // Blend squared values with zero based on the final mask\n        float32x4_t masked_squared = vbslq_f32(final_mask, squared, vdupq_n_f32(0.0f));\n\n        // Horizontally add the squared values in the NEON register\n        float32x2_t sum_partial = vpadd_f32(vget_low_f32(masked_squared), vget_high_f32(masked_squared));\n        float32x2_t sum_final = vpadd_f32(sum_partial, sum_partial);\n\n        // Add the result to the accumulator\n        result += vget_lane_f32(sum_final, 0);\n    }\n\n    // Process remaining elements (if any)\n    for (; i < size; ++i) {\n        float val = lst[i];\n        int intval = static_cast<int>(val);\n        if (val > 0.0f && val == static_cast<float>(intval) && intval % 2 != 0) {\n            result += intval * intval;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_134_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    uint64_t result = 0;\n    int i = 0;\n    int size = lst.size();\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= size - 4; i += 4) {\n        // Load 4 floats into a NEON register\n        float32x4_t vec = vld1q_f32(&lst[i]);\n\n        // Create a mask for positive numbers (vec > 0.0f)\n        uint32x4_t positive_mask = vcgtq_f32(vec, vdupq_n_f32(0.0f));\n\n        // Create a mask for integers (fract(vec) == 0.0f)\n        float32x4_t trunc_vec = vrndq_f32(vec);\n        uint32x4_t integer_mask = vceqq_f32(vec, trunc_vec);\n\n        // Combine masks: positive and integer\n        uint32x4_t valid_mask = vandq_u32(positive_mask, integer_mask);\n\n        // Convert to integers\n        int32x4_t int_vec = vcvtq_s32_f32(vec);\n\n        // Create a mask for odd numbers (int_vec % 2 != 0)\n        int32x4_t mod_vec = vandq_s32(int_vec, vdupq_n_s32(1));\n        uint32x4_t odd_mask = vmvnq_u32(vceqq_s32(mod_vec, vdupq_n_s32(0)));\n\n        // Combine masks: valid and odd\n        uint32x4_t final_mask = vandq_u32(valid_mask, odd_mask);\n\n        // Square the integers\n        int32x4_t squared = vmulq_s32(int_vec, int_vec);\n\n        // Blend squared values with zero based on the final mask\n        int32x4_t masked_squared = vbslq_s32(final_mask, squared, vdupq_n_s32(0));\n\n        // Horizontally add the squared values\n        int32x2_t sum_vec = vpadd_s32(vget_low_s32(masked_squared), vget_high_s32(masked_squared));\n        sum_vec = vpadd_s32(sum_vec, sum_vec);\n\n        // Add the result to the total sum\n        result += vget_lane_s32(sum_vec, 0);\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        float val = lst[i];\n        if (val > 0.0f && std::floor(val) == val) {\n            int ival = static_cast<int>(val);\n            if (ival % 2 != 0) {\n                result += static_cast<uint64_t>(ival * ival);\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result(game.size());\n    int size = game.size();\n    int i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= size - 4; i += 4) {\n        // Load 4 elements from game and guess vectors\n        int32x4_t game_vec = vld1q_s32(&game[i]);\n        int32x4_t guess_vec = vld1q_s32(&guess[i]);\n\n        // Compute the difference between game and guess\n        int32x4_t diff = vsubq_s32(game_vec, guess_vec);\n\n        // Compute the absolute value of the difference\n        int32x4_t abs_diff = vabsq_s32(diff);\n\n        // Store the result back to the result vector\n        vst1q_s32(&result[i], abs_diff);\n    }\n\n    // Process remaining elements (if any)\n    for (; i < size; ++i) {\n        result[i] = std::abs(game[i] - guess[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result(game.size());\n    int size = game.size();\n    int i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= size - 4; i += 4) {\n        // Load 4 scores and 4 guesses into NEON registers\n        int32x4_t game_vec = vld1q_s32(&game[i]);\n        int32x4_t guess_vec = vld1q_s32(&guess[i]);\n\n        // Compute the difference between scores and guesses\n        int32x4_t diff_vec = vsubq_s32(game_vec, guess_vec);\n\n        // Compute the absolute value of the differences\n        int32x4_t abs_diff_vec = vabsq_s32(diff_vec);\n\n        // Store the results back to the result vector\n        vst1q_s32(&result[i], abs_diff_vec);\n    }\n\n    // Process remaining elements (if any) using scalar operations\n    for (; i < size; ++i) {\n        result[i] = std::abs(game[i] - guess[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result(game.size());\n    int size = game.size();\n    int i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= size - 4; i += 4) {\n        // Load 4 scores and 4 guesses into NEON registers\n        int32x4_t game_vec = vld1q_s32(&game[i]);\n        int32x4_t guess_vec = vld1q_s32(&guess[i]);\n\n        // Compute the difference between scores and guesses\n        int32x4_t diff_vec = vsubq_s32(game_vec, guess_vec);\n\n        // Compute the absolute value of the differences\n        int32x4_t abs_diff_vec = vabsq_s32(diff_vec);\n\n        // Store the results back to the result vector\n        vst1q_s32(&result[i], abs_diff_vec);\n    }\n\n    // Process remaining elements (if any)\n    for (; i < size; ++i) {\n        result[i] = std::abs(game[i] - guess[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result(game.size());\n    int size = game.size();\n    int i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= size - 4; i += 4) {\n        // Load 4 scores and 4 guesses into NEON registers\n        int32x4_t game_vec = vld1q_s32(&game[i]);\n        int32x4_t guess_vec = vld1q_s32(&guess[i]);\n\n        // Compute the difference between scores and guesses\n        int32x4_t diff_vec = vsubq_s32(game_vec, guess_vec);\n\n        // Compute the absolute value of the differences\n        int32x4_t abs_diff_vec = vabsq_s32(diff_vec);\n\n        // Store the results back to the result vector\n        vst1q_s32(&result[i], abs_diff_vec);\n    }\n\n    // Process remaining elements (if any)\n    for (; i < size; ++i) {\n        result[i] = std::abs(game[i] - guess[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result(game.size());\n    int size = game.size();\n    int i = 0;\n\n    // Process 4 elements at a time using NEON intrinsics\n    for (; i <= size - 4; i += 4) {\n        // Load 4 scores and 4 guesses into NEON registers\n        int32x4_t game_vec = vld1q_s32(&game[i]);\n        int32x4_t guess_vec = vld1q_s32(&guess[i]);\n\n        // Compute the difference between scores and guesses\n        int32x4_t diff = vsubq_s32(game_vec, guess_vec);\n\n        // Compute the absolute value of the differences\n        int32x4_t abs_diff = vabsq_s32(diff);\n\n        // Store the results back to the result vector\n        vst1q_s32(&result[i], abs_diff);\n    }\n\n    // Process remaining elements (if any) using scalar operations\n    for (; i < size; ++i) {\n        result[i] = std::abs(game[i] - guess[i]);\n    }\n\n    return result;\n}\n```"}

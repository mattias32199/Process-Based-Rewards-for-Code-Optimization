{"task_id": "SimdBench_0_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e64m1(length - i);\n\n        vbool64_t mask_v = vle8_v_b64_m(vl, mask + i);\n        vint64m1_t src_v = vle64_v_i64m1(src + i, vl);\n        vint64m1_t dst_v = vle64_v_i64m1(dst + i, vl);\n\n        dst_v = vmerge_vxm_i64m1(dst_v, src_v, mask_v, vl);\n\n        vse64_v_i64m1(dst + i, dst_v, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_0_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e64m8(length - i);\n\n        vbool8_t vmask = vle8_v_b8(mask + i, vl);\n        vint64m8_t vsrc = vle64_v_i64m8(src + i, vl);\n        vint64m8_t vdst = vlxei64_v_i64m8(dst + i, vl);\n\n        vint64m8_t result = vmerge_vxm_i64m8(vdst, vsrc, vmask, vl);\n\n        vse64_v_i64m8(dst + i, result, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_0_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e64m8(length - i);\n\n        vbool8_t vmask = vle8_v_b8(mask + i, vl);\n        vint64m8_t vsrc = vle64_v_i64m8(src + i, vl);\n        vint64m8_t vdst = vlxei64_v_i64m8(dst + i, vl);\n\n        vint64m8_t result = vmerge_vxm_i64m8(vdst, vsrc, vmask, vl);\n\n        vse64_v_i64m8(dst + i, result, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_0_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e64m8(length - i);\n\n        vbool8_t vmask = vle8_v_b8(mask + i, vl);\n        vint64m8_t vsrc = vle64_v_i64m8(src + i, vl);\n        vint64m8_t vdst = vlxei64_v_i64m8(dst + i, vl);\n\n        vint64m8_t result = vmerge_vxm_i64m8(vdst, vsrc, vmask, vl);\n\n        vse64_v_i64m8(dst + i, result, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_0_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e64m1(length - i);\n\n        vbool64_t vmask = vle8_v_b64(mask + i, vl);\n        vint64m1_t vsrc = vle64_v_i64m1(src + i, vl);\n        vint64m1_t vdst = vlxei64_v_i64m1(dst + i, vl);\n\n        vint64m1_t result = vmerge_vxm_i64m1(vdst, vsrc, vmask, vl);\n\n        vse64_v_i64m1(dst + i, result, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_1_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e32m8(length - i);\n\n        vint32m8_t v_src = vle32_v_i32m8(&src[i], vl);\n        vint32m8_t v_scaled = vmul_vx_i32m8(v_src, scale, vl);\n\n        vint32m8_t v_tmp1 = vsra_vx_i32m8(v_scaled, 3, vl);\n        vint32m8_t v_tmp2 = vsll_vx_i32m8(v_scaled, 3, vl);\n\n        vint32m8_t v_mul = vmul_vv_i32m8(v_tmp1, v_tmp2, vl);\n        vint32m8_t v_add = vadd_vv_i32m8(v_scaled, v_mul, vl);\n\n        vint32m8_t v_result = vdiv_vx_i32m8(v_add, 7, vl);\n\n        vse32_v_i32m8(&dst[i], v_result, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_1_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e32m8(length - i);\n\n        vint32m8_t v_src = vle32_v_i32m8(&src[i], vl);\n        vint32m8_t v_scaled = vmul_vx_i32m8(v_src, scale, vl);\n\n        vint32m8_t v_tmp1 = vsra_vx_i32m8(v_scaled, 3, vl);\n        vint32m8_t v_tmp2 = vsll_vx_i32m8(v_scaled, 3, vl);\n\n        vint32m8_t v_mul = vmul_vv_i32m8(v_tmp1, v_tmp2, vl);\n        vint32m8_t v_add = vadd_vv_i32m8(v_scaled, v_mul, vl);\n\n        vint32m8_t v_result = vdiv_vx_i32m8(v_add, 7, vl);\n\n        vse32_v_i32m8(&dst[i], v_result, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_1_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e32m8(length - i);\n\n        vint32m8_t v_src = vle32_v_i32m8(&src[i], vl);\n        vint32m8_t v_scaled = vmul_vx_i32m8(v_src, scale, vl);\n\n        vint32m8_t v_tmp1 = vsra_vx_i32m8(v_scaled, 3, vl);\n        vint32m8_t v_tmp2 = vsll_vx_i32m8(v_scaled, 3, vl);\n\n        vint32m8_t v_mul = vmul_vv_i32m8(v_tmp1, v_tmp2, vl);\n        vint32m8_t v_add = vadd_vv_i32m8(v_scaled, v_mul, vl);\n\n        vint32m8_t v_result = vdiv_vx_i32m8(v_add, 7, vl);\n\n        vse32_v_i32m8(&dst[i], v_result, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_1_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e32m8(length - i);\n\n        vint32m8_t v_src = vle32_v_i32m8(&src[i], vl);\n        vint32m8_t v_scaled = vmul_vx_i32m8(v_src, scale, vl);\n\n        vint32m8_t v_tmp1 = vsra_vx_i32m8(v_scaled, 3, vl);\n        vint32m8_t v_tmp2 = vsll_vx_i32m8(v_scaled, 3, vl);\n\n        vint32m8_t v_mul = vmul_vv_i32m8(v_tmp1, v_tmp2, vl);\n        vint32m8_t v_add = vadd_vv_i32m8(v_scaled, v_mul, vl);\n\n        vint32m8_t v_result = vdiv_vx_i32m8(v_add, 7, vl);\n\n        vse32_v_i32m8(&dst[i], v_result, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_1_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e32m8(length - i);\n\n        vint32m8_t v_src = vle32_v_i32m8(&src[i], vl);\n        vint32m8_t v_scaled = vmul_vx_i32m8(v_src, scale, vl);\n\n        vint32m8_t v_tmp1 = vsra_vx_i32m8(v_scaled, 3, vl);\n        vint32m8_t v_tmp2 = vsll_vx_i32m8(v_scaled, 3, vl);\n\n        vint32m8_t v_mul = vmul_vv_i32m8(v_tmp1, v_tmp2, vl);\n        vint32m8_t v_add = vadd_vv_i32m8(v_scaled, v_mul, vl);\n\n        vint32m8_t v_result = vdiv_vx_i32m8(v_add, 7, vl);\n\n        vse32_v_i32m8(&dst[i], v_result, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_2_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t vl;\n    vuint64m8_t indices;\n    vfloat64m8_t values;\n\n    for (size_t r = 0; r < rows; r += vl) {\n        vl = vsetvl_e64m8(rows - r);\n        indices = vid_v_u64m8(vl); // Generate indices [0, 1, ..., vl-1]\n        indices = vadd_vx_u64m8(indices, r, vl); // Add current row offset to indices\n        indices = vmul_vx_u64m8(indices, cols, vl); // Multiply by cols to get row start positions\n        indices = vadd_vx_u64m8(indices, stride, vl); // Add stride to get the desired column index\n\n        values = vrgather_vv_f64m8(vle64_v_f64m8(src, vl), indices, vl); // Gather elements from src\n        vse64_v_f64m8(dst + r, values, vl); // Store gathered elements into dst\n    }\n}\n```"}
{"task_id": "SimdBench_2_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t vlmax = vsetvlmax_e64m1();\n    for (size_t r = 0; r < rows; r += vlmax) {\n        size_t vl = vsetvl_e64m1(rows - r);\n        vuint64m1_t indices = vid_v_u64m1(vl);\n        indices = vadd_vx_u64m1(indices, r, vl);\n        indices = vmul_vx_u64m1(indices, cols, vl);\n        indices = vadd_vx_u64m1(indices, stride, vl);\n        vfloat64m1_t values = vrgather_vv_f64m1(vle64_v_f64m1(src, vl), indices, vl);\n        vse64_v_f64m1(dst + r, values, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_2_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t vlmax = vsetvlmax_e64m1();\n    for (size_t r = 0; r < rows; r += vlmax) {\n        size_t vl = vsetvl_e64m1(rows - r);\n        vuint64m1_t indices = vid_v_u64m1(vl);\n        indices = vadd_vx_u64m1(indices, r, vl);\n        indices = vmul_vx_u64m1(indices, cols, vl);\n        indices = vadd_vx_u64m1(indices, stride, vl);\n        vfloat64m1_t values = vle64_v_f64m1(src + vget_v_u64m1(indices, 0), vl);\n        vse64_v_f64m1(dst + r, values, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_2_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t vl;\n    vuint64m8_t indices;\n    vfloat64m8_t loaded_values;\n\n    for (size_t r = 0; r < rows; r += vl) {\n        vl = vsetvl_e64m8(rows - r);\n        indices = vid_v_u64m8(vl);                      // Generate indices [0, 1, ..., vl-1]\n        indices = vadd_vx_u64m8(indices, r, vl);         // Offset indices by current row index r\n        indices = vmul_vx_u64m8(indices, cols, vl);      // Multiply indices by cols to get row offsets\n        indices = vadd_vx_u64m8(indices, stride, vl);    // Add stride to each index\n\n        loaded_values = vrgather_vv_f64m8(vle64_v_f64m8(src, vl), indices, vl); // Gather values from src\n        vse64_v_f64m8(dst + r, loaded_values, vl);       // Store gathered values into dst\n    }\n}\n```"}
{"task_id": "SimdBench_2_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t vlmax = vsetvlmax_e64m1();\n    for (size_t r = 0; r < rows; r += vlmax) {\n        size_t vl = vsetvl_e64m1(rows - r);\n        vuint64m1_t indices = vid_v_u64m1(vl);\n        indices = vadd_vx_u64m1(indices, r, vl);\n        indices = vmul_vx_u64m1(indices, cols, vl);\n        indices = vadd_vx_u64m1(indices, stride, vl);\n        vfloat64m1_t values = vrgather_vv_f64m1(vle64_v_f64m1(src, vl), indices, vl);\n        vse64_v_f64m1(dst + r, values, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_3_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    // Gather operation\n    while (i < length) {\n        vl = vsetvl_e32m8(length - i);\n        vint32m8_t idx_vec = vle32_v_i32m8(indices + i, vl);\n        vfloat32m8_t src_gathered = vrgather_vf_f32m8(vle32_v_f32m8(src, vl), idx_vec, vl);\n        vse32_v_f32m8(dst + i, src_gathered, vl);\n        i += vl;\n    }\n\n    // Scatter operation\n    i = 0;\n    while (i < length) {\n        vl = vsetvl_e32m8(length - i);\n        vint32m8_t idx_vec = vle32_v_i32m8(indices + i, vl);\n        vfloat32m8_t src_scatter = vle32_v_f32m8(src + i, vl);\n        vse32_v_f32m8(dst, vrgather_vf_f32m8(src_scatter, idx_vec, vl), vl);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_3_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    // Gather operation\n    while (i < length) {\n        vl = vsetvl_e32m8(length - i);\n        vint32m8_t idx_v = vle32_v_i32m8(indices + i, vl);\n        vfloat32m8_t src_v = vrgather_vf_f32m8(vle32_v_f32m8(src, vl), idx_v, vl);\n        vse32_v_f32m8(dst + i, src_v, vl);\n        i += vl;\n    }\n\n    // Scatter operation\n    i = 0;\n    while (i < length) {\n        vl = vsetvl_e32m8(length - i);\n        vint32m8_t idx_v = vle32_v_i32m8(indices + i, vl);\n        vfloat32m8_t src_v = vle32_v_f32m8(src + i, vl);\n        vse32_v_f32m8(dst, vcompress_vm_m8(vmseq_vx_i32m8(idx_v, i, vl), src_v, vl), vl);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_3_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    // Gather operation\n    while (i < length) {\n        vl = vsetvl_e32m8(length - i);\n        vint32m8_t idx_vec = vle32_v_i32m8(indices + i, vl);\n        vfloat32m8_t src_gathered = vrgather_vf_f32m8(vle32_v_f32m8(src, vl), idx_vec, vl);\n        vse32_v_f32m8(dst + i, src_gathered, vl);\n        i += vl;\n    }\n\n    // Scatter operation\n    i = 0;\n    while (i < length) {\n        vl = vsetvl_e32m8(length - i);\n        vint32m8_t idx_vec = vle32_v_i32m8(indices + i, vl);\n        vfloat32m8_t src_scatter = vle32_v_f32m8(src + i, vl);\n        vse32_v_f32m8(dst, vrgather_vf_f32m8(src_scatter, idx_vec, vl), vl);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_3_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    // Gather operation\n    while (i < length) {\n        vl = vsetvl_e32m8(length - i);\n        vint32m8_t idx_v = vle32_v_i32m8(indices + i, vl);\n        vfloat32m8_t src_v = vrgather_vf_f32m8(vle32_v_f32m8(src, vl), idx_v, vl);\n        vse32_v_f32m8(dst + i, src_v, vl);\n        i += vl;\n    }\n\n    // Scatter operation\n    i = 0;\n    while (i < length) {\n        vl = vsetvl_e32m8(length - i);\n        vint32m8_t idx_v = vle32_v_i32m8(indices + i, vl);\n        vfloat32m8_t src_v = vle32_v_f32m8(src + i, vl);\n        vse32_v_f32m8(dst, src_v, vl);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_3_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    // Gather operation\n    for (; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        vint32m8_t idx_v = vle32_v_i32m8(indices + i, vl);\n        vfloat32m8_t src_v = vrgather_vf_f32m8(vle32_v_f32m8(src, vl), idx_v, vl);\n        vse32_v_f32m8(dst + i, src_v, vl);\n    }\n\n    // Scatter operation\n    i = 0;\n    for (; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        vint32m8_t idx_v = vle32_v_i32m8(indices + i, vl);\n        vfloat32m8_t src_v = vle32_v_f32m8(src + i, vl);\n        vse32_v_f32m8(dst, src_v, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_4_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    size_t vl;\n    size_t vector_len = end - start + 1;\n    size_t mid = (start + end) / 2;\n\n    for (size_t i = 0; i < (mid - start + 1); i += vl) {\n        vl = vsetvl_e16m8(vector_len - i);\n\n        // Load elements from the start of the range\n        vint16m8_t vec_start = vle16_v_i16m8(arr + start + i, vl);\n\n        // Load elements from the end of the range\n        vint16m8_t vec_end = vle16_v_i16m8(arr + end - i - (vl - 1), vl);\n\n        // Reverse and store back to the array\n        vse16_v_i16m8(arr + start + i, vec_end, vl);\n        vse16_v_i16m8(arr + end - i - (vl - 1), vec_start, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_4_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    size_t vl;\n    size_t i = 0;\n    size_t n = (end - start + 1) / 2; // Number of pairs to swap\n\n    while (i < n) {\n        vl = vsetvl_e16m8(n - i); // Set vector length for int16_t\n\n        // Load elements from the start and end regions\n        vint16m8_t vec_start = vle16_v_i16m8(arr + start + i, vl);\n        vint16m8_t vec_end = vle16_v_i16m8(arr + end - i - vl + 1, vl);\n\n        // Reverse the loaded elements\n        vint16m8_t vec_reversed_start = vrev_v_i16m8(vec_end, vl);\n        vint16m8_t vec_reversed_end = vrev_v_i16m8(vec_start, vl);\n\n        // Store the reversed elements back to their respective positions\n        vse16_v_i16m8(arr + start + i, vec_reversed_start, vl);\n        vse16_v_i16m8(arr + end - i - vl + 1, vec_reversed_end, vl);\n\n        i += vl; // Increment by the number of elements processed\n    }\n}\n```"}
{"task_id": "SimdBench_4_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    size_t vl;\n    size_t i = 0;\n    size_t n = end - start + 1;\n\n    while (i < n / 2) {\n        vl = vsetvl_e16m8(n / 2 - i);\n\n        // Load elements from the start of the range\n        vint16m8_t vec_start = vle16_v_i16m8(arr + start + i, vl);\n\n        // Load elements from the end of the range\n        vint16m8_t vec_end = vle16_v_i16m8(arr + end - i - (vl - 1), vl);\n\n        // Reverse the loaded elements by swapping\n        vse16_v_i16m8(arr + start + i, vec_end, vl);\n        vse16_v_i16m8(arr + end - i - (vl - 1), vec_start, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_4_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    size_t vl;\n    size_t i = 0;\n    size_t len = end - start + 1;\n\n    while (i < len / 2) {\n        vl = vsetvl_e16m8(len / 2 - i);\n\n        vint16m8_t vec_front = vle16_v_i16m8(arr + start + i, vl);\n        vint16m8_t vec_back = vle16_v_i16m8(arr + end - i - (vl - 1), vl);\n\n        // Reverse the elements by swapping front and back\n        vse16_v_i16m8(arr + start + i, vec_back, vl);\n        vse16_v_i16m8(arr + end - i - (vl - 1), vec_front, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_4_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    size_t vl;\n    size_t i = 0;\n    uint64_t len = end - start + 1;\n    uint64_t mid = len / 2;\n\n    while (i < mid) {\n        vl = vsetvl_e16m8(len - i);\n        vint16m8_t vec_front = vle16_v_i16m8(arr + start + i, vl);\n        vint16m8_t vec_back = vle16_v_i16m8(arr + end - i - (vl - 1), vl);\n\n        // Reverse the elements by swapping\n        vse16_v_i16m8(arr + start + i, vec_back, vl);\n        vse16_v_i16m8(arr + end - i - (vl - 1), vec_front, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_5_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_offset = slice_idx * dim1 * dim2;\n    size_t total_elements = dim1 * dim2;\n\n    size_t i = 0;\n    while (i < total_elements) {\n        size_t vl = vsetvl_e8m8(total_elements - i);\n\n        vuint8m8_t vec = vle8_v_u8m8(&tensor[slice_offset + i], vl);\n        vse8_v_u8m8(&slice[i], vec, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_5_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_offset = slice_idx * dim1 * dim2;\n    size_t total_elements = dim1 * dim2;\n\n    size_t i = 0;\n    for (; i + vsetvlmax_e8m8() <= total_elements; i += vsetvlmax_e8m8()) {\n        size_t vl = vsetvl_e8m8(total_elements - i);\n        vuint8m8_t vec = vle8_v_u8m8(&tensor[slice_offset + i], vl);\n        vse8_v_u8m8(&slice[i], vec, vl);\n    }\n\n    // Handle remaining elements\n    for (; i < total_elements; ++i) {\n        slice[i] = tensor[slice_offset + i];\n    }\n}\n```"}
{"task_id": "SimdBench_5_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_offset = slice_idx * dim1 * dim2;\n    size_t total_elements = dim1 * dim2;\n\n    size_t i = 0;\n    for (; i + vsetvlmax_e8m1() <= total_elements; i += vsetvlmax_e8m1()) {\n        size_t vl = vsetvl_e8m1(total_elements - i);\n        vuint8m1_t vec = vle8_v_u8m1(&tensor[slice_offset + i], vl);\n        vse8_v_u8m1(&slice[i], vec, vl);\n    }\n\n    // Handle remaining elements\n    for (; i < total_elements; ++i) {\n        slice[i] = tensor[slice_offset + i];\n    }\n}\n```"}
{"task_id": "SimdBench_5_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_offset = slice_idx * dim1 * dim2;\n    size_t total_elements = dim1 * dim2;\n\n    size_t i = 0;\n    size_t vl;\n\n    for (; i < total_elements; i += vl) {\n        vl = vsetvl_e8m1(total_elements - i);\n        vuint8m1_t vec = vle8_v_u8m1(&tensor[slice_offset + i], vl);\n        vse8_v_u8m1(&slice[i], vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_5_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_offset = slice_idx * dim1 * dim2;\n    size_t total_elements = dim1 * dim2;\n\n    size_t vl;\n    size_t i = 0;\n\n    while (i < total_elements) {\n        vl = vsetvl_e8m8(total_elements - i);\n        vuint8m8_t vec = vle8_v_u8m8(&tensor[slice_offset + i], vl);\n        vse8_v_u8m8(&slice[i], vec, vl);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_6_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    size_t vlmax = vsetvlmax_e16m1();\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t block_rows = rows - i > block_size ? block_size : rows - i;\n            size_t block_cols = cols - j > block_size ? block_size : cols - j;\n\n            for (size_t bi = 0; bi < block_rows; ++bi) {\n                for (size_t bj = 0; bj < block_cols; bj += vlmax) {\n                    size_t vl = vsetvl_e16m1(block_cols - bj);\n                    size_t src_idx = (i + bi) * cols + (j + bj);\n                    size_t dst_idx = (j + bj) * rows + (i + bi);\n\n                    vint16m1_t vec = vle16_v_i16m1(&src[src_idx], vl);\n                    vse16_v_i16m1(&dst[dst_idx], vec, vl);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    size_t vlmax = vsetvlmax_e16m1();\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t row_limit = i + block_size <= rows ? block_size : rows - i;\n            size_t col_limit = j + block_size <= cols ? block_size : cols - j;\n\n            for (size_t bi = 0; bi < row_limit; ++bi) {\n                for (size_t bj = 0; bj < col_limit; bj += vlmax) {\n                    size_t vl = vsetvl_e16m1(col_limit - bj);\n                    vint16m1_t vec = vle16_v_i16m1(&src[(i + bi) * cols + j + bj], vl);\n                    vse16_v_i16m1(&dst[(j + bj) * rows + i + bi], vec, vl);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    size_t vlmax = vsetvlmax_e16m1();\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t block_rows = rows - i < block_size ? rows - i : block_size;\n            size_t block_cols = cols - j < block_size ? cols - j : block_size;\n\n            for (size_t bi = 0; bi < block_rows; ++bi) {\n                for (size_t bj = 0; bj < block_cols; bj += vlmax) {\n                    size_t vl = vsetvl_e16m1(block_cols - bj);\n                    vint16m1_t vec_src = vle16_v_i16m1(&src[(i + bi) * cols + j + bj], vl);\n                    vse16_v_i16m1(&dst[(j + bj) * rows + i + bi], vec_src, vl);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    size_t vlmax = vsetvlmax_e16m1();\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t row_end = i + block_size < rows ? i + block_size : rows;\n            size_t col_end = j + block_size < cols ? j + block_size : cols;\n\n            for (size_t ii = i; ii < row_end; ++ii) {\n                for (size_t jj = j; jj < col_end; jj += vlmax) {\n                    size_t vl = vsetvl_e16m1(col_end - jj);\n                    vint16m1_t vec_src = vle16_v_i16m1(&src[ii * cols + jj], vl);\n                    vse16_v_i16m1(&dst[jj * rows + ii], vec_src, vl);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    size_t vl;\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t row_limit = i + block_size <= rows ? block_size : rows - i;\n            size_t col_limit = j + block_size <= cols ? block_size : cols - j;\n\n            for (size_t bi = 0; bi < row_limit; ++bi) {\n                for (size_t bj = 0; bj < col_limit; bj += vl) {\n                    vl = vsetvl_e16m1(col_limit - bj);\n                    vint16m1_t vec_src = vle16_v_i16m1(&src[(i + bi) * cols + j + bj], vl);\n                    vse16_v_i16m1(&dst[(j + bj) * rows + i + bi], vec_src, vl);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_7_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    size_t vlmax = vsetvlmax_e32m1();\n    float sum = 0.0f;\n    vfloat32m1_t vsum = vfmv_v_f_f32m1(0.0f, vlmax);\n\n    for (size_t i = 0; i < dim; i++) {\n        size_t index = i * dim * dim + i * dim + i;\n        vfloat32m1_t vval = vle32_v_f32m1(&array[index], vlmax);\n        vsum = vfadd_vv_f32m1(vsum, vval, vlmax);\n    }\n\n    sum = vfmv_f_s_f32m1_f32(vsum);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    size_t vlmax = vsetvl_e32m1(dim);\n    float sum = 0.0f;\n    vfloat32m1_t vsum = vfmv_v_f_f32m1(0.0f, vlmax);\n\n    for (size_t i = 0; i < dim; i++) {\n        size_t index = i * dim * dim + i * dim + i;\n        vfloat32m1_t vval = vle32_v_f32m1(&array[index], vlmax);\n        vsum = vfadd_vv_f32m1(vsum, vval, vlmax);\n    }\n\n    sum = vfmv_f_s_f32m1_f32(vsum);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    size_t vlmax = vsetvlmax_e32m1();\n    float sum = 0.0f;\n    vfloat32m1_t vsum = vfmv_v_f_f32m1(0.0f, vlmax);\n\n    for (size_t i = 0; i < dim; i++) {\n        size_t index = i * dim * dim + i * dim + i;\n        vfloat32m1_t vval = vle32_v_f32m1(&array[index], vlmax);\n        vsum = vfadd_vv_f32m1(vsum, vval, vlmax);\n    }\n\n    sum = vfmv_f_s_f32m1_f32(vsum);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    size_t vlmax = vsetvlmax_e32m1();\n    float sum = 0.0f;\n    vfloat32m1_t vsum = vfmv_v_f_f32m1(0.0f, vlmax);\n\n    for (size_t i = 0; i < dim; i++) {\n        size_t index = i * dim * dim + i * dim + i;\n        vfloat32m1_t vval = vle32_v_f32m1(&array[index], vlmax);\n        vsum = vfadd_vv_f32m1(vsum, vval, vlmax);\n    }\n\n    sum = vfmv_f_s_f32m1_f32(vsum);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    size_t vlmax = vsetvlmax_e32m1();\n    float sum = 0.0f;\n    vfloat32m1_t vsum = vfmv_v_f_f32m1(0.0f, vlmax);\n\n    for (size_t i = 0; i < dim; i++) {\n        size_t index = i * dim * dim + i * dim + i;\n        vfloat32m1_t vval = vle32_v_f32m1(&array[index], vlmax);\n        vsum = vfadd_vv_f32m1(vsum, vval, vlmax);\n    }\n\n    sum = vfmv_f_s_f32m1_f32(vsum);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_8_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e64m8(total_elements - i);\n\n        vfloat64m8_t v_src = vle64_v_f64m8(&src[i], vl);\n        vbool64_t mask = vmfgt_vf_f64m8_b64(v_src, threshold, vl);\n        vfloat64m8_t v_scaled = vfmul_vf_f64m8(v_src, scale, vl);\n        vfloat64m8_t v_result = vmerge_vvm_f64m8(mask, v_scaled, v_src, vl);\n\n        vse64_v_f64m8(&dst[i], v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_8_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e64m8(total_elements - i);\n\n        vfloat64m8_t src_vec = vle64_v_f64m8(&src[i], vl);\n        vbool64_t mask = vmfgt_vf_f64m8_b64(src_vec, threshold, vl);\n        vfloat64m8_t scaled_vec = vfmul_vf_f64m8(src_vec, scale, vl);\n        vfloat64m8_t result_vec = vmerge_vvm_f64m8(mask, scaled_vec, src_vec, vl);\n\n        vse64_v_f64m8(&dst[i], result_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_8_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e64m8(total_elements - i);\n\n        vfloat64m8_t v_src = vle64_v_f64m8(&src[i], vl);\n        vbool8_t mask = vmfgt_vf_f64m8_b8(v_src, threshold, vl);\n        vfloat64m8_t v_scaled = vfmul_vf_f64m8(v_src, scale, vl);\n        vfloat64m8_t v_result = vmerge_vvm_f64m8(mask, v_scaled, v_src, vl);\n\n        vse64_v_f64m8(&dst[i], v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_8_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e64m8(total_elements - i);\n\n        vfloat64m8_t src_vec = vle64_v_f64m8(&src[i], vl);\n        vbool8_t mask = vmfgt_vf_f64m8_b8(src_vec, threshold, vl);\n        vfloat64m8_t scaled_vec = vfmul_vf_f64m8(src_vec, scale, vl);\n        vfloat64m8_t result_vec = vmerge_vvm_f64m8(mask, scaled_vec, src_vec, vl);\n\n        vse64_v_f64m8(&dst[i], result_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_8_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e64m8(total_elements - i);\n\n        vfloat64m8_t src_vec = vle64_v_f64m8(&src[i], vl);\n        vbool8_t mask = vmfgt_vf_f64m8_b8(src_vec, threshold, vl);\n        vfloat64m8_t scaled_vec = vfmul_vf_f64m8(src_vec, scale, vl);\n        vfloat64m8_t result_vec = vmerge_vvm_f64m8(mask, scaled_vec, src_vec, vl);\n\n        vse64_v_f64m8(&dst[i], result_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_9_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t vlmax = vsetvlmax_e64m8();\n    for (size_t i = 0; i < rows; ++i) {\n        size_t src_row_idx = indices[i] * cols;\n        size_t dst_row_idx = i * cols;\n\n        size_t j = 0;\n        for (; j + vlmax <= cols; j += vlmax) {\n            vfloat64m8_t vec_src = vle64_v_f64m8(&src[src_row_idx + j], vlmax);\n            vse64_v_f64m8(&dst[dst_row_idx + j], vec_src, vlmax);\n        }\n\n        if (j < cols) {\n            size_t remaining = cols - j;\n            size_t vl = vsetvl_e64m8(remaining);\n            vfloat64m8_t vec_src = vle64_v_f64m8(&src[src_row_idx + j], vl);\n            vse64_v_f64m8(&dst[dst_row_idx + j], vec_src, vl);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t vlmax = vsetvlmax_e64m8();\n    for (size_t i = 0; i < rows; ++i) {\n        size_t idx = indices[i];\n        const double *src_row = src + idx * cols;\n        double *dst_row = dst + i * cols;\n\n        size_t j = 0;\n        for (; j + vlmax <= cols; j += vlmax) {\n            vfloat64m8_t vec_src = vle64_v_f64m8(src_row + j, vlmax);\n            vse64_v_f64m8(dst_row + j, vec_src, vlmax);\n        }\n        if (j < cols) {\n            size_t vl = vsetvl_e64m8(cols - j);\n            vfloat64m8_t vec_src = vle64_v_f64m8(src_row + j, vl);\n            vse64_v_f64m8(dst_row + j, vec_src, vl);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t vlmax = vsetvlmax_e64m8();\n    for (size_t i = 0; i < rows; ++i) {\n        size_t src_row_idx = indices[i] * cols;\n        size_t dst_row_idx = i * cols;\n        size_t j = 0;\n\n        for (; j + vlmax <= cols; j += vlmax) {\n            vfloat64m8_t vec_src = vle64_v_f64m8(&src[src_row_idx + j], vlmax);\n            vse64_v_f64m8(&dst[dst_row_idx + j], vec_src, vlmax);\n        }\n\n        if (j < cols) {\n            size_t remaining = cols - j;\n            size_t vl = vsetvl_e64m8(remaining);\n            vfloat64m8_t vec_src = vle64_v_f64m8(&src[src_row_idx + j], vl);\n            vse64_v_f64m8(&dst[dst_row_idx + j], vec_src, vl);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t vlmax = vsetvlmax_e64m8();\n    for (size_t i = 0; i < rows; ++i) {\n        size_t row_idx = indices[i];\n        const double *src_row = src + row_idx * cols;\n        double *dst_row = dst + i * cols;\n\n        size_t j = 0;\n        for (; j + vlmax <= cols; j += vlmax) {\n            vfloat64m8_t vec_src = vle64_v_f64m8(src_row + j, vlmax);\n            vse64_v_f64m8(dst_row + j, vec_src, vlmax);\n        }\n        if (j < cols) {\n            size_t vl = vsetvl_e64m8(cols - j);\n            vfloat64m8_t vec_src = vle64_v_f64m8(src_row + j, vl);\n            vse64_v_f64m8(dst_row + j, vec_src, vl);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t vlmax = vsetvlmax_e64m8();\n    for (size_t i = 0; i < rows; ++i) {\n        size_t src_row_idx = indices[i] * cols;\n        size_t dst_row_idx = i * cols;\n\n        size_t j = 0;\n        for (; j + vlmax <= cols; j += vlmax) {\n            vfloat64m8_t vec_src = vle64_v_f64m8(&src[src_row_idx + j], vlmax);\n            vse64_v_f64m8(&dst[dst_row_idx + j], vec_src, vlmax);\n        }\n\n        if (j < cols) {\n            size_t vl = vsetvl_e64m8(cols - j);\n            vfloat64m8_t vec_src = vle64_v_f64m8(&src[src_row_idx + j], vl);\n            vse64_v_f64m8(&dst[dst_row_idx + j], vec_src, vl);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_10_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e64m8(length - i);\n\n        vint64m8_t vec_src1 = vle64_v_i64m8(&src1[i], vl);\n        vint64m8_t vec_src2 = vle64_v_i64m8(&src2[i], vl);\n\n        vint64m8_t vec_sum = vadd_vv_i64m8(vec_src1, vec_src2, vl);\n        vint64m8_t vec_scalar_add = vadd_vx_i64m8(vec_sum, scalar, vl);\n        vint64m8_t vec_div = vdiv_vx_i64m8(vec_scalar_add, 2, vl);\n\n        vse64_v_i64m8(&dst[i], vec_div, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_10_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e64m8(length - i);\n\n        vint64m8_t vec_src1 = vle64_v_i64m8(&src1[i], vl);\n        vint64m8_t vec_src2 = vle64_v_i64m8(&src2[i], vl);\n\n        vint64m8_t vec_sum = vadd_vv_i64m8(vec_src1, vec_src2, vl);\n        vint64m8_t vec_scalar_added = vadd_vx_i64m8(vec_sum, scalar, vl);\n        vint64m8_t vec_divided = vdiv_vx_i64m8(vec_scalar_added, 2, vl);\n\n        vse64_v_i64m8(&dst[i], vec_divided, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_10_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e64m1(length - i);\n\n        vint64m1_t vec_src1 = vle64_v_i64m1(&src1[i], vl);\n        vint64m1_t vec_src2 = vle64_v_i64m1(&src2[i], vl);\n\n        vint64m1_t vec_sum = vadd_vv_i64m1(vec_src1, vec_src2, vl);\n        vint64m1_t vec_scalar_add = vadd_vx_i64m1(vec_sum, scalar, vl);\n        vint64m1_t vec_div = vdiv_vx_i64m1(vec_scalar_add, 2, vl);\n\n        vse64_v_i64m1(&dst[i], vec_div, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_10_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e64m8(length - i);\n\n        vint64m8_t vec_src1 = vle64_v_i64m8(&src1[i], vl);\n        vint64m8_t vec_src2 = vle64_v_i64m8(&src2[i], vl);\n\n        vint64m8_t vec_sum = vadd_vv_i64m8(vec_src1, vec_src2, vl);\n        vint64m8_t vec_scalar_add = vadd_vx_i64m8(vec_sum, scalar, vl);\n        vint64m8_t vec_div = vdiv_vx_i64m8(vec_scalar_add, 2, vl);\n\n        vse64_v_i64m8(&dst[i], vec_div, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_10_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e64m1(length - i);\n\n        vint64m1_t vec_src1 = vle64_v_i64m1(&src1[i], vl);\n        vint64m1_t vec_src2 = vle64_v_i64m1(&src2[i], vl);\n\n        vint64m1_t vec_sum = vadd_vv_i64m1(vec_src1, vec_src2, vl);\n        vint64m1_t vec_scalar_add = vadd_vx_i64m1(vec_sum, scalar, vl);\n        vint64m1_t vec_div = vdiv_vx_i64m1(vec_scalar_add, 2, vl);\n\n        vse64_v_i64m1(&dst[i], vec_div, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_11_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    int min_val = INT32_MAX;\n    size_t vl;\n    vint32m1_t v_min = vmv_s_x_i32m1(min_val, 1); // Initialize vector with max value\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n        vint32m1_t v_src = vle32_v_i32m1(src + i, vl);\n\n        // Create a mask for even indices\n        vbool32_t mask_even = vmseq.vx_i32m1_b32(viota(), 0, vl);\n\n        // Apply mask to select even elements\n        vint32m1_t v_even = vmerge_vxm_i32m1(mask_even, v_src, INT32_MAX, vl);\n\n        // Compute the minimum of the selected even elements\n        v_min = vmin_vv_i32m1(v_min, v_even, vl);\n    }\n\n    // Reduce the vector to find the minimum scalar value\n    int reduced_min = vmv_x_s_i32m1_i32(v_min);\n    return reduced_min;\n}\n```"}
{"task_id": "SimdBench_11_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    int min_val = INT32_MAX;\n    size_t i = 0;\n\n    size_t vlmax = vsetvlmax_e32m1();\n    vint32m1_t v_min = vmv_s_x_i32m1(min_val, vlmax);\n\n    for (; i + vlmax <= length; i += vlmax) {\n        vint32m1_t v_src = vle32_v_i32m1(&src[i], vlmax);\n        vbool32_t mask = vmseq.vx_i32m1_b32(v_src, 0x0, vlmax); // Mask even numbers\n        vint32m1_t v_even = vcompress_vm_i32m1(mask, v_src, vlmax);\n        v_min = vmin_vv_i32m1(v_min, v_even, vlmax);\n    }\n\n    // Tail handling\n    if (i < length) {\n        size_t vl = vsetvl_e32m1(length - i);\n        vint32m1_t v_src = vle32_v_i32m1(&src[i], vl);\n        vbool32_t mask = vmseq.vx_i32m1_b32(v_src, 0x0, vl); // Mask even numbers\n        vint32m1_t v_even = vcompress_vm_i32m1(mask, v_src, vl);\n        v_min = vmin_vv_i32m1(v_min, v_even, vl);\n    }\n\n    // Reduction to find the minimum scalar value\n    int temp_min[vlmax];\n    vse32_v_i32m1(temp_min, v_min, vlmax);\n    for (size_t j = 0; j < vlmax; ++j) {\n        if (temp_min[j] < min_val && temp_min[j] % 2 == 0) {\n            min_val = temp_min[j];\n        }\n    }\n\n    return (min_val == INT32_MAX) ? -1 : min_val;\n}\n```"}
{"task_id": "SimdBench_11_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    int min_val = INT32_MAX;\n    size_t vl;\n    vint32m1_t v_min = vmv_s_x_i32m1(min_val, 1); // Initialize vector with max value\n    size_t i = 0;\n\n    for (; i + vsetvlmax_e32m1() <= length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n        vint32m1_t v_src = vle32_v_i32m1(&src[i], vl);\n\n        // Create a mask to select even indices\n        vbool32_t mask = vmseq.vx_i32m1_b32(viota_m1_b32(vl), 0, vl);\n\n        // Apply mask and compute minimum\n        vint32m1_t v_even = vmerge_vxm_i32m1(mask, v_src, INT32_MAX, vl);\n        v_min = vmin_vv_i32m1(v_min, v_even, vl);\n    }\n\n    // Reduce the vector to find the minimum value\n    int reduced_min = vmv_x_s_i32m1_i32(v_min);\n    for (size_t j = 0; j < vl; ++j) {\n        int val = src[i + j];\n        if ((i + j) % 2 == 0 && val < reduced_min) {\n            reduced_min = val;\n        }\n    }\n\n    return reduced_min == INT32_MAX ? -1 : reduced_min;\n}\n```"}
{"task_id": "SimdBench_11_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    int min_val = 0x7FFFFFFF; // Initialize to maximum 32-bit integer value\n    size_t vl;\n    vint32m1_t v_min = vmv_s_x_i32m1(min_val, 1); // Broadcast max value to vector\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n        vint32m1_t v_src = vle32_v_i32m1(src + i, vl);\n\n        // Create a mask for even indices\n        vbool32_t mask_even = vmseq.vx_i32m1_b32(viota_v_u32m1(vl), 0, vl);\n\n        // Apply mask to select even-indexed elements\n        vint32m1_t v_even = vmerge_vxm_i32m1(mask_even, v_src, 0x7FFFFFFF, vl);\n\n        // Compute the minimum of the selected even-indexed elements\n        v_min = vmin_vv_i32m1(v_min, v_even, vl);\n    }\n\n    // Reduce the vector to find the minimum value\n    int reduced_min = vmv_x_s_i32m1_i32(v_min);\n    return reduced_min;\n}\n```"}
{"task_id": "SimdBench_11_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    int min_val = 0x7FFFFFFF; // Initialize to maximum possible integer value\n    size_t vlmax = vsetvlmax_e32m1(); // Get maximum vector length for 32-bit integers\n\n    for (size_t i = 0; i < length; i += vlmax) {\n        size_t vl = vsetvl_e32m1(length - i); // Set vector length dynamically\n        vint32m1_t vec = vle32_v_i32m1(src + i, vl); // Load vector from memory\n\n        // Create a mask for even indices\n        vbool32_t mask = vmseq_vx_i32m1(vec, 0, vl); // Mask for even indices\n        vint32m1_t even_vec = vmerge_vxm_i32m1(mask, vec, 0x7FFFFFFF, vl);\n\n        // Compute the minimum of the even-indexed elements\n        vint32m1_t min_vec = vredmin_vs_i32m1_i32m1(even_vec, even_vec, vl);\n        int temp_min = vmv_x_s_i32m1_i32(min_vec);\n\n        // Update the scalar minimum value\n        if (temp_min < min_val) {\n            min_val = temp_min;\n        }\n    }\n\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_12_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e32m8(length - i);\n\n        vint32m8_t v_src = vle32_v_i32m8(&src[i], vl);\n\n        // Arithmetic right shift\n        vint32m8_t v_arith_shifted = vsra_vx_i32m8(v_src, shift, vl);\n\n        // Logical right shift (convert to unsigned, shift, then convert back to signed)\n        vuint32m8_t v_unsigned_src = vreinterpret_u32m8_i32m8(v_src);\n        vuint32m8_t v_logic_shifted_unsigned = vsrl_vx_u32m8(v_unsigned_src, shift, vl);\n        vint32m8_t v_logic_shifted = vreinterpret_i32m8_u32m8(v_logic_shifted_unsigned);\n\n        // Add the results of arithmetic and logical shifts\n        vint32m8_t v_result = vadd_vv_i32m8(v_arith_shifted, v_logic_shifted, vl);\n\n        // Store the result into the destination array\n        vse32_v_i32m8(&dst[i], v_result, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_12_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e32m8(length - i);\n\n        // Load vector of 32-bit integers from src\n        vint32m8_t v_src = vle32_v_i32m8(&src[i], vl);\n\n        // Perform arithmetic right shift\n        vint32m8_t v_arith_shifted = vsra_vx_i32m8(v_src, shift, vl);\n\n        // Convert to unsigned for logical right shift\n        vuint32m8_t v_unsigned_src = vreinterpret_u32m8_i32m8(v_src);\n        vuint32m8_t v_logic_shifted_unsigned = vsrl_vx_u32m8(v_unsigned_src, shift, vl);\n\n        // Convert back to signed after logical shift\n        vint32m8_t v_logic_shifted = vreinterpret_i32m8_u32m8(v_logic_shifted_unsigned);\n\n        // Add the results of arithmetic and logical shifts\n        vint32m8_t v_result = vadd_vv_i32m8(v_arith_shifted, v_logic_shifted, vl);\n\n        // Store the result into dst\n        vse32_v_i32m8(&dst[i], v_result, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_12_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e32m8(length - i);\n\n        // Load vector of 32-bit integers from src\n        vint32m8_t v_src = vle32_v_i32m8(&src[i], vl);\n\n        // Perform arithmetic right shift\n        vint32m8_t v_arith_shifted = vsra_vx_i32m8(v_src, shift, vl);\n\n        // Convert to unsigned for logical right shift, then cast back to signed\n        vuint32m8_t v_unsigned_src = vreinterpret_u32m8_i32m8(v_src);\n        vuint32m8_t v_logic_shifted_unsigned = vsrl_vx_u32m8(v_unsigned_src, shift, vl);\n        vint32m8_t v_logic_shifted = vreinterpret_i32m8_u32m8(v_logic_shifted_unsigned);\n\n        // Add the results of arithmetic and logical shifts\n        vint32m8_t v_result = vadd_vv_i32m8(v_arith_shifted, v_logic_shifted, vl);\n\n        // Store the result into dst\n        vse32_v_i32m8(&dst[i], v_result, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_12_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e32m8(length - i);\n\n        vint32m8_t v_src = vle32_v_i32m8(&src[i], vl);\n\n        // Arithmetic right shift\n        vint32m8_t v_arith_shifted = vsra_vx_i32m8(v_src, shift, vl);\n\n        // Logical right shift (convert to unsigned, shift, then convert back to signed)\n        vuint32m8_t v_unsigned_src = vreinterpret_u32m8_i32m8(v_src);\n        vuint32m8_t v_logic_shifted_unsigned = vsrl_vx_u32m8(v_unsigned_src, shift, vl);\n        vint32m8_t v_logic_shifted = vreinterpret_i32m8_u32m8(v_logic_shifted_unsigned);\n\n        // Add the results of arithmetic and logical shifts\n        vint32m8_t v_result = vadd_vv_i32m8(v_arith_shifted, v_logic_shifted, vl);\n\n        // Store the result into the destination array\n        vse32_v_i32m8(&dst[i], v_result, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_12_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e32m8(length - i);\n\n        // Load vector of 32-bit integers from source array\n        vint32m8_t v_src = vle32_v_i32m8(&src[i], vl);\n\n        // Perform arithmetic right shift\n        vint32m8_t v_arith_shifted = vsra_vx_i32m8(v_src, shift, vl);\n\n        // Convert to unsigned for logical right shift, then cast back to signed\n        vuint32m8_t v_unsigned_src = vreinterpret_u32m8_i32m8(v_src);\n        vuint32m8_t v_logic_shifted_unsigned = vsrl_vx_u32m8(v_unsigned_src, shift, vl);\n        vint32m8_t v_logic_shifted = vreinterpret_i32m8_u32m8(v_logic_shifted_unsigned);\n\n        // Add the results of arithmetic and logical shifts\n        vint32m8_t v_result = vadd_vv_i32m8(v_arith_shifted, v_logic_shifted, vl);\n\n        // Store the result into the destination array\n        vse32_v_i32m8(&dst[i], v_result, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_13_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    const int *data_ptr = matrix;\n    int64_t sum = 0;\n\n    size_t vl;\n    vint32m8_t vsum_vec = vmv_v_x_i32m8(0, vl); // Initialize vector accumulator to zero\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n        vint32m8_t vec = vle32_v_i32m8(data_ptr, vl); // Load elements into vector\n        vsum_vec = vwredsum_vs_i32m8_i64m1(vsum_vec, vec, vsum_vec, vl); // Vectorized reduction sum\n        data_ptr += vl;\n    }\n\n    // Reduce the vector sum to a scalar value\n    sum = vgetlane_i64m1(vwredsum_vs_i32m8_i64m1(vsum_vec, vsum_vec, vl), 0);\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    const int *data_ptr = matrix;\n\n    int64_t sum = 0;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n        vint32m8_t vec = vle32_v_i32m8(data_ptr, vl);\n        data_ptr += vl;\n\n        vint32m1_t sum_vec = vmv_s_x_i32m1(0, vl);\n        sum_vec = vwredsum_vs_i32m8_i32m1(vec, sum_vec, vl);\n\n        sum += vmv_x_s_i32m1_i32(sum_vec);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n    int64_t sum = 0;\n\n    while (i < total_elements) {\n        size_t vl = vsetvl_e32m8(total_elements - i);\n        vint32m8_t vec = vle32_v_i32m8(&matrix[i], vl);\n        vint32m1_t sum_vec = vmv_v_x_i32m1(0, vl);\n\n        sum_vec = vwredsum_vs_i32m8_i32m1(sum_vec, vec, vl);\n        sum += vmv_x_s_i32m1_i32(sum_vec);\n\n        i += vl;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    const int *data_ptr = matrix;\n    int64_t sum = 0;\n\n    size_t vl;\n    vint32m8_t vsum_vec = vmv_v_x_i32m8(0, vl); // Initialize vector accumulator to zero\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n        vint32m8_t vec = vle32_v_i32m8(data_ptr, vl); // Load elements into vector\n        vsum_vec = vwredsum_vs_i32m8_i64m1(vsum_vec, vec, vsum_vec, vl); // Vectorized reduction sum\n        data_ptr += vl;\n    }\n\n    // Reduce the vector sum to a scalar value\n    sum = vgetlane_i64m1(vwredsum_vs_i32m8_i64m1(vsum_vec, vsum_vec, vl), 0);\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    const int *data_ptr = matrix;\n    int64_t sum = 0;\n\n    size_t vl;\n    vint32m8_t vsum_vec = vmv_v_x_i32m8(0, vl); // Initialize vector accumulator to zero\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i); // Set vector length\n        vint32m8_t vec = vle32_v_i32m8(data_ptr, vl); // Load elements into vector\n        vsum_vec = vwredsum_vs_i32m8_i64m1(vsum_vec, vec, vsum_vec, vl); // Vectorized reduction sum\n        data_ptr += vl;\n    }\n\n    // Accumulate the partial sums from the vector into a scalar\n    sum = vmv_x_s_i64m1_i64(vsum_vec);\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_14_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t vlmax = vsetvlmax_e8m1();\n    size_t index = 0;\n    int8_t max_val = src[0];\n\n    for (size_t i = 0; i < length; i += vlmax) {\n        size_t vl = vsetvl_e8m1(length - i);\n        vint8m1_t vec = vle8_v_i8m1(src + i, vl);\n\n        // Find the maximum value in the vector\n        vbool8_t mask = vmseq_vx_i8m1_b8(vec, max_val, vl);\n        vint8m1_t max_vec = vmerge_vxm_i8m1(mask, vec, max_val, vl);\n        int8_t temp_max = vmax_v_i8m1(max_vec, vl);\n\n        // If a new max is found, update max_val and index\n        if (temp_max > max_val) {\n            max_val = temp_max;\n            index = i + vfirst_m_b8(vmseq_vx_i8m1_b8(vec, max_val, vl), vl);\n        }\n    }\n\n    return index;\n}\n```"}
{"task_id": "SimdBench_14_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t vlmax = vsetvlmax_e8m1();\n    size_t index = 0;\n    int8_t max_val = src[0];\n\n    for (size_t i = 0; i < length; i += vlmax) {\n        size_t vl = vsetvl_e8m1(length - i);\n        vint8m1_t vec = vle8_v_i8m1(src + i, vl);\n\n        // Find the maximum value in the vector\n        vbool8_t mask = vmseq_vx_i8m1(vec, max_val, vl);\n        vint8m1_t max_vec = vmerge_vxm_i8m1(mask, vec, max_val, vl);\n        int8_t temp_max = vmax_vx_i8m1(max_vec, max_val, vl);\n\n        // If a new max is found, update the max value and index\n        if (temp_max > max_val) {\n            vbool8_t new_mask = vmseq_vx_i8m1(vec, temp_max, vl);\n            unsigned long first_set_bit;\n            asm volatile(\"vfirst.m %0, %1\" : \"=r\"(first_set_bit) : \"vr\"(new_mask));\n            if (first_set_bit < vl) {\n                max_val = temp_max;\n                index = i + first_set_bit;\n            }\n        }\n    }\n\n    return index;\n}\n```"}
{"task_id": "SimdBench_14_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t vlmax = vsetvlmax_e8m1();\n    size_t index = 0;\n    int8_t max_val = src[0];\n\n    for (size_t i = 0; i < length; i += vlmax) {\n        size_t vl = vsetvl_e8m1(length - i);\n        vint8m1_t vec = vle8_v_i8m1(src + i, vl);\n\n        // Find the maximum value in the vector\n        vbool8_t mask = vmseq_vx_i8m1_b8(vec, max_val, vl);\n        vint8m1_t max_vec = vmerge_vxm_i8m1(mask, vec, max_val, vl);\n        int8_t temp_max = vmax_v_i8m1(max_vec, vl);\n\n        // Update max_val and index if a new maximum is found\n        if (temp_max > max_val) {\n            max_val = temp_max;\n            index = i + vfirst_m_b8(vmseq_vx_i8m1_b8(vec, max_val, vl), vl);\n        }\n    }\n\n    return index;\n}\n```"}
{"task_id": "SimdBench_14_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t vlmax = vsetvlmax_e8m1();\n    size_t index = 0;\n    int8_t max_val = src[0];\n\n    for (size_t i = 0; i < length; i += vlmax) {\n        size_t vl = vsetvl_e8m1(length - i);\n        vint8m1_t vec = vle8_v_i8m1(src + i, vl);\n\n        // Find the maximum value in the vector\n        vbool8_t mask = vmseq_vx_i8m1_b8(vec, max_val, vl);\n        vint8m1_t max_vec = vmerge_vxm_i8m1(mask, vec, max_val, vl);\n        int8_t temp_max = vmax_v_i8m1(max_vec, vl);\n\n        // If a new max is found, update max_val and index\n        if (temp_max > max_val) {\n            max_val = temp_max;\n            index = i + vfirst_m_b8(vmseq_vx_i8m1_b8(vec, max_val, vl), vl);\n        }\n    }\n\n    return index;\n}\n```"}
{"task_id": "SimdBench_14_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t vlmax = vsetvlmax_e8m1();\n    size_t index = 0;\n    int8_t max_val = src[0];\n\n    for (size_t i = 0; i < length; i += vlmax) {\n        size_t vl = vsetvl_e8m1(length - i);\n        vint8m1_t vec = vle8_v_i8m1(src + i, vl);\n\n        // Find the maximum value in the vector\n        vbool8_t mask = vmseq_vx_i8m1_b8(vec, max_val, vl);\n        vint8m1_t max_vec = vmerge_vxm_i8m1(mask, vec, max_val, vl);\n        int8_t temp_max = vmax_v_i8m1(max_vec, vl);\n\n        // Update max_val and index if a new maximum is found\n        if (temp_max > max_val) {\n            max_val = temp_max;\n            index = i + vfirst_m_b8(vmseq_vx_i8m1_b8(vec, max_val, vl), vl);\n        }\n    }\n\n    return index;\n}\n```"}
{"task_id": "SimdBench_15_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e16m8(length - i);\n\n        vuint16m8_t v_src1 = vle16_v_u16m8(&src1[i], vl);\n        vuint16m8_t v_src2 = vle16_v_u16m8(&src2[i], vl);\n\n        vid_v_u16m8(vl);\n        vbool16_t v_mask = vmseq_vx_u16m8(vid_v_u16m8(vl) & mask, 0, vl);\n\n        vuint16m8_t v_dst = vmerge_vvm_u16m8(v_mask, v_src1, v_src2, vl);\n\n        vse16_v_u16m8(&dst[i], v_dst, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_15_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e16m8(length - i);\n\n        vuint16m8_t src1_vec = vle16_v_u16m8(&src1[i], vl);\n        vuint16m8_t src2_vec = vle16_v_u16m8(&src2[i], vl);\n\n        vbool16_t cond_vec = vmseq_vx_u16m8(vand_vx_u16m8(vid_v_u16m8(vl), mask, vl), 0, vl);\n\n        vuint16m8_t result_vec = vmerge_vvm_u16m8(cond_vec, src2_vec, src1_vec, vl);\n\n        vse16_v_u16m8(&dst[i], result_vec, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_15_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e16m8(length - i);\n\n        vuint16m8_t v_src1 = vle16_v_u16m8(&src1[i], vl);\n        vuint16m8_t v_src2 = vle16_v_u16m8(&src2[i], vl);\n\n        vid_v_u16m8(vl);\n        vbool16_t v_mask = vmseq_vx_u16m8(vid_v_u16m8(vl) & mask, 0, vl);\n\n        vuint16m8_t v_dst = vmerge_vvm_u16m8(v_mask, v_src1, v_src2, vl);\n\n        vse16_v_u16m8(&dst[i], v_dst, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_15_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e16m8(length - i);\n\n        vuint16m8_t src1_vec = vle16_v_u16m8(&src1[i], vl);\n        vuint16m8_t src2_vec = vle16_v_u16m8(&src2[i], vl);\n\n        vid_v_u16m8(vl);\n        vbool16_t cond = vmseq_vx_u16m8(vid_v_u16m8(vl) & mask, 0, vl);\n\n        vuint16m8_t result = vmerge_vvm_u16m8(cond, src1_vec, src2_vec, vl);\n\n        vse16_v_u16m8(&dst[i], result, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_15_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e16m8(length - i);\n\n        vuint16m8_t v_src1 = vle16_v_u16m8(&src1[i], vl);\n        vuint16m8_t v_src2 = vle16_v_u16m8(&src2[i], vl);\n\n        vbool16_t v_mask = vmseq_vx_u16m8_b16(vand_vx_u16m8(vid_v_u16m8(vl), mask, vl), 0, vl);\n\n        vuint16m8_t v_dst = vmerge_vvm_u16m8(v_mask, v_src1, v_src2, vl);\n\n        vse16_v_u16m8(&dst[i], v_dst, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_16_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e32m8(length - i);\n\n        vuint32m8_t vec_src = vle32_v_u32m8(&src[i], vl);\n        vuint32m8_t vec_popcount = vpopc_v_u32m8(vec_src, vl);\n\n        vse32_v_u32m8(&dst[i], vec_popcount, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_16_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e32m8(length - i);\n\n        vuint32m8_t vec_src = vle32_v_u32m8(&src[i], vl);\n        vuint32m8_t vec_popcount = vpopc_v_u32m8(vec_src, vl);\n\n        vse32_v_u32m8(&dst[i], vec_popcount, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_16_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e32m8(length - i);\n\n        vuint32m8_t vec_src = vle32_v_u32m8(&src[i], vl);\n        vuint32m8_t vec_popcnt = vpopc_v_u32m8(vec_src, vl);\n\n        vse32_v_u32m8(&dst[i], vec_popcnt, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_16_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e32m8(length - i);\n\n        vuint32m8_t vec_src = vle32_v_u32m8(&src[i], vl);\n        vuint32m8_t vec_popcount = vpopc_v_u32m8(vec_src, vl);\n\n        vse32_v_u32m8(&dst[i], vec_popcount, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_16_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e32m8(length - i);\n\n        vuint32m8_t vec_src = vle32_v_u32m8(&src[i], vl);\n        vuint32m8_t vec_popcount = vpopc_v_u32m8(vec_src, vl);\n\n        vse32_v_u32m8(&dst[i], vec_popcount, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_17_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e16m8(length - i);\n\n        vuint16m8_t vec_src1 = vle16_v_u16m8(&src1[i], vl);\n        vuint16m8_t vec_src2 = vle16_v_u16m8(&src2[i], vl);\n        vuint16m8_t vec_dst = vsaddu_vv_u16m8(vec_src1, vec_src2, vl);\n\n        vse16_v_u16m8(&dst[i], vec_dst, vl);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_17_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t vl;\n    vuint16m1_t vec_src1, vec_src2, vec_dst;\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16m1(length - i);\n        vec_src1 = vle16_v_u16m1(&src1[i], vl);\n        vec_src2 = vle16_v_u16m1(&src2[i], vl);\n        vec_dst = vsaddu_vv_u16m1(vec_src1, vec_src2, vl);\n        vse16_v_u16m1(&dst[i], vec_dst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_17_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t vl;\n    vuint16m1_t vec_src1, vec_src2, vec_dst;\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16m1(length - i);\n        vec_src1 = vle16_v_u16m1(&src1[i], vl);\n        vec_src2 = vle16_v_u16m1(&src2[i], vl);\n        vec_dst = vsaddu_vv_u16m1(vec_src1, vec_src2, vl);\n        vse16_v_u16m1(&dst[i], vec_dst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_17_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t vl;\n    vuint16m1_t vec_src1, vec_src2, vec_dst;\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16m1(length - i);\n        vec_src1 = vle16_v_u16m1(&src1[i], vl);\n        vec_src2 = vle16_v_u16m1(&src2[i], vl);\n        vec_dst = vsaddu_vv_u16m1(vec_src1, vec_src2, vl);\n        vse16_v_u16m1(&dst[i], vec_dst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_17_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t vl;\n    vuint16m1_t vec_src1, vec_src2, vec_dst;\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16m1(length - i);\n        vec_src1 = vle16_v_u16m1(&src1[i], vl);\n        vec_src2 = vle16_v_u16m1(&src2[i], vl);\n        vec_dst = vsaddu_vv_u16m1(vec_src1, vec_src2, vl);\n        vse16_v_u16m1(&dst[i], vec_dst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_18_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    size_t vlmax = vsetvlmax_e64m1();\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t k = 0; k < p; ++k) {\n            double sum = 0.0;\n            size_t j = 0;\n            vfloat64m1_t vsum = vfmv_v_f_f64m1(0.0, vlmax);\n\n            for (; j + vlmax <= n; j += vlmax) {\n                vfloat64m1_t va = vle64_v_f64m1(&A[i * n + j], vlmax);\n                vfloat64m1_t vb = vle64_v_f64m1(&B[j * p + k], vlmax);\n\n                vbool64_t mask_a = vmfge_vf_f64m1_b64(va, -100.0, vlmax);\n                vbool64_t mask_b = vmfle_vf_f64m1_b64(va, 100.0, vlmax);\n                vbool64_t mask = vmand_mm_b64(mask_a, mask_b);\n\n                mask_a = vmfge_vf_f64m1_b64(vb, -100.0, vlmax);\n                mask_b = vmfle_vf_f64m1_b64(vb, 100.0, vlmax);\n                mask = vmand_mm_b64(mask, vmand_mm_b64(mask_a, mask_b));\n\n                vfloat64m1_t vmul = vfmul_vv_f64m1(va, vb, vlmax);\n                vsum = vfadd_vv_f64m1_m(mask, vsum, vmul, vlmax);\n            }\n\n            sum = vfmv_f_s_f64m1_f64(vfredsum_vs_f64m1_f64m1(vsum, vsum, vlmax));\n\n            for (; j < n; ++j) {\n                double a_elem = A[i * n + j];\n                double b_elem = B[j * p + k];\n                if (a_elem >= -100.0 && a_elem <= 100.0 &&\n                    b_elem >= -100.0 && b_elem <= 100.0) {\n                    sum += a_elem * b_elem;\n                }\n            }\n\n            C[i * p + k] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    size_t vlmax = vsetvlmax_e64m1();\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t k = 0; k < p; ++k) {\n            double sum = 0.0;\n            size_t j = 0;\n            vfloat64m1_t vsum = vfmv_v_f_f64m1(0.0, vlmax);\n\n            for (; j + vlmax <= n; j += vlmax) {\n                size_t vl = vsetvl_e64m1(vlmax);\n                vfloat64m1_t va = vle64_v_f64m1(&A[i * n + j], vl);\n                vfloat64m1_t vb = vle64_v_f64m1(&B[j * p + k], vl);\n\n                vbool64_t mask_a = vmfge_vf_f64m1_b64(va, -100.0, vl);\n                vbool64_t mask_b = vmfle_vf_f64m1_b64(va, 100.0, vl);\n                vbool64_t mask = vmand_mm(mask_a, mask_b);\n\n                mask_a = vmfge_vf_f64m1_b64(vb, -100.0, vl);\n                mask_b = vmfle_vf_f64m1_b64(vb, 100.0, vl);\n                mask = vmand_mm(mask, vmand_mm(mask_a, mask_b));\n\n                vfloat64m1_t vmul = vfmul_vv_f64m1_m(mask, va, vb, vl);\n                vsum = vfadd_vv_f64m1(vsum, vmul, vl);\n            }\n\n            // Reduction of vector sum to scalar\n            double temp_sum[vlmax];\n            vse64_v_f64m1(temp_sum, vsum, vlmax);\n            for (size_t l = 0; l < vlmax; ++l) {\n                sum += temp_sum[l];\n            }\n\n            // Handle remaining elements\n            for (; j < n; ++j) {\n                double a_elem = A[i * n + j];\n                double b_elem = B[j * p + k];\n                if (a_elem >= -100.0 && a_elem <= 100.0 &&\n                    b_elem >= -100.0 && b_elem <= 100.0) {\n                    sum += a_elem * b_elem;\n                }\n            }\n\n            C[i * p + k] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    size_t vlmax = vsetvlmax_e64m1();\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t k = 0; k < p; ++k) {\n            double sum = 0.0;\n            size_t j = 0;\n            vfloat64m1_t vsum = vfmv_v_f_f64m1(0.0, vlmax);\n\n            for (; j + vlmax <= n; j += vlmax) {\n                vfloat64m1_t va = vle64_v_f64m1(&A[i * n + j], vlmax);\n                vfloat64m1_t vb = vle64_v_f64m1(&B[j * p + k], vlmax);\n\n                vbool64_t mask_a = vmfge_vf_f64m1_b64(va, -100.0, vlmax);\n                vbool64_t mask_b = vmfle_vf_f64m1_b64(va, 100.0, vlmax);\n                vbool64_t mask = vmand_mm(mask_a, mask_b);\n\n                mask_a = vmfge_vf_f64m1_b64(vb, -100.0, vlmax);\n                mask_b = vmfle_vf_f64m1_b64(vb, 100.0, vlmax);\n                mask = vmand_mm(mask, vmand_mm(mask_a, mask_b));\n\n                vfloat64m1_t vmul = vfmul_vv_f64m1(va, vb, vlmax);\n                vsum = vfadd_vv_f64m1_m(mask, vsum, vmul, vlmax);\n            }\n\n            // Reduction of vector sum to scalar\n            double temp[vlmax];\n            vse64_v_f64m1(temp, vsum, vlmax);\n            for (size_t l = 0; l < vlmax; ++l) {\n                sum += temp[l];\n            }\n\n            // Handle remaining elements\n            for (; j < n; ++j) {\n                double a_elem = A[i * n + j];\n                double b_elem = B[j * p + k];\n                if (a_elem >= -100.0 && a_elem <= 100.0 &&\n                    b_elem >= -100.0 && b_elem <= 100.0) {\n                    sum += a_elem * b_elem;\n                }\n            }\n\n            C[i * p + k] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    size_t vl;\n    vfloat64m1_t v_res, v_a, v_b;\n    vbool64_t mask_a, mask_b;\n\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n\n            size_t k = 0;\n            v_res = vfmv_v_f_f64m1(0.0, vl);\n\n            while (k < n) {\n                vl = vsetvl_e64m1(n - k);\n\n                // Load vectors from A and B\n                v_a = vle64_v_f64m1(&A[i * n + k], vl);\n                v_b = vle64_v_f64m1(&B[k * p + j], vl);\n\n                // Create masks for the range [-100, 100]\n                mask_a = vmfge_vf_f64m1_b64(v_a, -100.0, vl);\n                mask_b = vmfle_vf_f64m1_b64(v_a, 100.0, vl);\n                mask_a = vmfge_vf_f64m1_b64_m(mask_a, v_b, -100.0, vl);\n                mask_b = vmfle_vf_f64m1_b64_m(mask_b, v_b, 100.0, vl);\n\n                // Combine masks\n                vbool64_t mask = vmand_mm_b64(mask_a, mask_b);\n\n                // Perform multiplication with mask\n                v_res = vfmacc_vv_f64m1_m(mask, v_res, v_a, v_b, vl);\n\n                k += vl;\n            }\n\n            // Reduce the vector result to a scalar\n            sum = vfmv_f_s_f64m1_f64(v_res);\n\n            // Store the result in C\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    size_t vl;\n    vfloat64m1_t v_res, v_a, v_b;\n    vbool64_t mask;\n\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t k = 0; k < p; ++k) {\n            double sum = 0.0;\n            size_t j = 0;\n\n            // Initialize vector result to zero\n            v_res = vfmv_v_f_f64m1(0.0, vsetvlmax_e64m1());\n\n            // Process elements in chunks defined by the vector length\n            for (; j + vsetvlmax_e64m1() <= n; j += vl) {\n                vl = vsetvl_e64m1(n - j);\n\n                // Load vectors from A and B\n                v_a = vle64_v_f64m1(&A[i * n + j], vl);\n                v_b = vle64_v_f64m1(&B[j * p + k], vl);\n\n                // Create a mask for values within the range [-100, 100]\n                mask = vmfge_vf_f64m1_b64(v_a, -100.0, vl);\n                mask = vmfle_vf_f64m1_b64_m(mask, v_a, 100.0, vl);\n                mask = vmfge_vf_f64m1_b64_m(mask, v_b, -100.0, vl);\n                mask = vmfle_vf_f64m1_b64_m(mask, v_b, 100.0, vl);\n\n                // Multiply and accumulate only valid elements\n                v_res = vfmacc_vv_f64m1_m(mask, v_res, v_a, v_b, vl);\n            }\n\n            // Reduce the vector result into a scalar\n            for (size_t l = 0; l < vl; ++l) {\n                sum += v_res[l];\n            }\n\n            // Handle remaining elements (if any)\n            for (; j < n; ++j) {\n                double a_val = A[i * n + j];\n                double b_val = B[j * p + k];\n                if (a_val >= -100.0 && a_val <= 100.0 &&\n                    b_val >= -100.0 && b_val <= 100.0) {\n                    sum += a_val * b_val;\n                }\n            }\n\n            // Store the result in matrix C\n            C[i * p + k] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e64m8(total_elements - i);\n\n        vint64m8_t va = vle64_v_i64m8(&A[i], vl);\n        vint64m8_t vb = vle64_v_i64m8(&B[i], vl);\n        vint64m8_t vc = vadd_vv_i64m8(va, vb, vl);\n\n        vse64_v_i64m8(&C[i], vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_19_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e64m8(total_elements - i);\n        vint64m8_t va = vle64_v_i64m8(&A[i], vl);\n        vint64m8_t vb = vle64_v_i64m8(&B[i], vl);\n        vint64m8_t vc = vadd_vv_i64m8(va, vb, vl);\n        vse64_v_i64m8(&C[i], vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_19_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e64m8(total_elements - i);\n\n        vint64m8_t va = vle64_v_i64m8(&A[i], vl);\n        vint64m8_t vb = vle64_v_i64m8(&B[i], vl);\n        vint64m8_t vc = vadd_vv_i64m8(va, vb, vl);\n\n        vse64_v_i64m8(&C[i], vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_19_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e64m8(total_elements - i);\n\n        vint64m8_t va = vle64_v_i64m8(&A[i], vl);\n        vint64m8_t vb = vle64_v_i64m8(&B[i], vl);\n        vint64m8_t vc = vadd_vv_i64m8(va, vb, vl);\n\n        vse64_v_i64m8(&C[i], vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_19_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e64m8(total_elements - i);\n\n        vint64m8_t va = vle64_v_i64m8(&A[i], vl);\n        vint64m8_t vb = vle64_v_i64m8(&B[i], vl);\n        vint64m8_t vc = vadd_vv_i64m8(va, vb, vl);\n\n        vse64_v_i64m8(&C[i], vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_20_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl;\n    vfloat32m1_t v_src1, v_src2, v_res;\n    vint32m1_t v_int_res;\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n\n        v_src1 = vle32_v_f32m1(&src1[i], vl);\n        v_src2 = vle32_v_f32m1(&src2[i], vl);\n\n        v_res = vfadd_vv_f32m1(v_src1, v_src2, vl);\n        v_int_res = vfcvt_x_f_v_i32m1(v_res, vl);\n        vse32_v_f32m1(&dst[i], vfcvt_f_x_v_f32m1(v_int_res, vl), vl);\n    }\n}\n```"}
{"task_id": "SimdBench_20_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl;\n    vfloat32m1_t v_src1, v_src2, v_res;\n    vint32m1_t v_int_res;\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n\n        v_src1 = vle32_v_f32m1(&src1[i], vl);\n        v_src2 = vle32_v_f32m1(&src2[i], vl);\n\n        v_res = vfadd_vv_f32m1(v_src1, v_src2, vl);\n        v_int_res = vfcvt_x_f_v_i32m1(v_res, vl);\n\n        vse32_v_i32m1(&dst[i], v_int_res, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_20_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl;\n    vfloat32m1_t v_src1, v_src2, v_res;\n    vint32m1_t v_int_res;\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n\n        v_src1 = vle32_v_f32m1(&src1[i], vl);\n        v_src2 = vle32_v_f32m1(&src2[i], vl);\n\n        v_res = vfadd_vv_f32m1(v_src1, v_src2, vl);\n        v_int_res = vfcvt_x_f_v_i32m1(v_res, vl);\n\n        vse32_v_i32m1(&dst[i], v_int_res, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_20_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl;\n    vfloat32m1_t v_src1, v_src2, v_res;\n    vint32m1_t v_int_res;\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n\n        v_src1 = vle32_v_f32m1(&src1[i], vl);\n        v_src2 = vle32_v_f32m1(&src2[i], vl);\n\n        v_res = vfadd_vv_f32m1(v_src1, v_src2, vl);\n        v_int_res = vfcvt_x_f_v_i32m1(v_res, vl);\n        vse32_v_f32m1(&dst[i], vfcvt_f_x_v_f32m1(v_int_res, vl), vl);\n    }\n}\n```"}
{"task_id": "SimdBench_20_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e32m8(length - i);\n\n        vfloat32m8_t vec_src1 = vle32_v_f32m8(&src1[i], vl);\n        vfloat32m8_t vec_src2 = vle32_v_f32m8(&src2[i], vl);\n\n        vfloat32m8_t vec_sum = vfadd_vv_f32m8(vec_src1, vec_src2, vl);\n        vfloat32m8_t vec_rounded = vfcvt_x_f_v_f32m8(vec_sum, vl);\n        vfloat32m8_t vec_result = vfcvt_f_x_v_f32m8(vec_rounded, vl);\n\n        vse32_v_f32m8(&dst[i], vec_result, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_21_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl;\n    vfloat32m1_t v_src1, v_src2, v_dst;\n    vbool32_t mask1, mask2, combined_mask;\n    vfloat32m1_t v_neg_one = vfmv_v_f_f32m1(-1.0f, vl);\n    vfloat32m1_t v_five_zero = vfmv_v_f_f32m1(50.0f, vl);\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n\n        // Load vectors from src1 and src2\n        v_src1 = vle32_v_f32m1(src1 + i, vl);\n        v_src2 = vle32_v_f32m1(src2 + i, vl);\n\n        // Compute absolute difference\n        vfloat32m1_t v_diff = vfsub_vv_f32m1(v_src1, v_src2, vl);\n        vfloat32m1_t v_abs_diff = vfsgnjx_vv_f32m1(v_diff, v_diff, vl);\n\n        // Condition 1: Absolute difference is within 50\n        mask1 = vmflt_vv_f32m1_b32(v_abs_diff, v_five_zero, vl);\n\n        // Condition 2: Index is a multiple of 2\n        vbool32_t index_mask = vmseq_vx_i32m1_b32(vid_v_i32m1(vl), 0, vl);\n        mask2 = vmnot_m_b32(index_mask, vl);\n\n        // Combine masks\n        combined_mask = vmand_mm_b32(mask1, mask2, vl);\n\n        // Element-wise multiplication\n        v_dst = vfmul_vv_f32m1(v_src1, v_src2, vl);\n\n        // Round up towards positive infinity\n        v_dst = vfcvt_x_f_v_f32m1(v_dst, vl);\n        v_dst = vfcvt_f_x_v_f32m1(v_dst, vl);\n\n        // Apply combined mask\n        v_dst = vmerge_vvm_f32m1(combined_mask, v_dst, v_neg_one, vl);\n\n        // Store result to dst\n        vse32_v_f32m1(dst + i, v_dst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_21_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl;\n    vfloat32m1_t v_src1, v_src2, v_dst;\n    vbool32_t mask1, mask2, combined_mask;\n    vfloat32m1_t v_neg_one = vfmv_v_f_f32m1(-1.0f, vl);\n    vfloat32m1_t v_five_zero = vfmv_v_f_f32m1(50.0f, vl);\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n\n        // Load vectors from src1 and src2\n        v_src1 = vle32_v_f32m1(src1 + i, vl);\n        v_src2 = vle32_v_f32m1(src2 + i, vl);\n\n        // Compute absolute difference\n        vfloat32m1_t v_diff = vfsub_vv_f32m1(v_src1, v_src2, vl);\n        vfloat32m1_t v_abs_diff = vfsgnjx_vv_f32m1(v_diff, v_diff, vl);\n\n        // Condition 1: Absolute difference is within 50\n        mask1 = vmflt_vv_f32m1_b32(v_abs_diff, v_five_zero, vl);\n\n        // Condition 2: Index is a multiple of 2\n        vbool32_t index_mask = vmseq_vx_i32m1_b32(vid_v_i32m1(), 0, vl);\n        mask2 = vmnot_m_b32(index_mask, vl);\n\n        // Combine masks\n        combined_mask = vmand_mm_b32(mask1, mask2, vl);\n\n        // Perform element-wise multiplication\n        v_dst = vfmul_vv_f32m1(v_src1, v_src2, vl);\n\n        // Round up towards positive infinity\n        v_dst = vfcvt_x_f_v_f32m1(v_dst, vl);\n        v_dst = vfcvt_f_x_v_f32m1(v_dst, vl);\n\n        // Apply combined mask to set results to -1 where conditions are not met\n        v_dst = vmerge_vvm_f32m1(combined_mask, v_dst, v_neg_one, vl);\n\n        // Store the result in dst\n        vse32_v_f32m1(dst + i, v_dst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_21_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl;\n    vfloat32m1_t v_src1, v_src2, v_dst;\n    vbool32_t mask1, mask2, combined_mask;\n    vfloat32m1_t v_neg_one = vfmv_v_f_f32m1(-1.0f, vl);\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n\n        // Load vectors from src1 and src2\n        v_src1 = vle32_v_f32m1(src1 + i, vl);\n        v_src2 = vle32_v_f32m1(src2 + i, vl);\n\n        // Condition 1: Absolute value of the difference is within 50\n        vfloat32m1_t v_diff = vfsub_vv_f32m1(v_src1, v_src2, vl);\n        vfloat32m1_t v_abs_diff = vfsgnjx_vv_f32m1(v_diff, v_diff, vl); // Absolute value\n        mask1 = vmflt_vf_f32m1(v_abs_diff, 50.0f, vl);\n\n        // Condition 2: Index is a multiple of 2\n        vbool32_t index_mask = vmseq_vx_i32m1(vid_v_i32m1(vl), 0, vl); // Generate index mask\n        mask2 = vmfne_vv_f32m1(index_mask, vneg_v_i32m1(index_mask, vl), vl);\n\n        // Combine masks\n        combined_mask = vmand_mm_b32(mask1, mask2, vl);\n\n        // Perform element-wise multiplication for elements that meet both conditions\n        vfloat32m1_t v_mul = vfmul_vv_f32m1(v_src1, v_src2, vl);\n\n        // Round up towards positive infinity\n        vfloat32m1_t v_rounded = vfcvt_x_f_v_f32m1(vfceil_v_f32m1(v_mul, vl), vl);\n\n        // Blend results: use -1 for elements that do not meet the conditions\n        v_dst = vmerge_vvm_f32m1(combined_mask, v_rounded, v_neg_one, vl);\n\n        // Store the result into dst\n        vse32_v_f32m1(dst + i, v_dst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_21_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl;\n    vfloat32m1_t v_src1, v_src2, v_dst;\n    vbool32_t mask1, mask2, combined_mask;\n    vfloat32m1_t v_neg_one = vfmv_v_f_f32m1(-1.0f, vl);\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n\n        // Load vectors from src1 and src2\n        v_src1 = vle32_v_f32m1(src1 + i, vl);\n        v_src2 = vle32_v_f32m1(src2 + i, vl);\n\n        // Compute absolute difference\n        vfloat32m1_t v_diff = vfsub_vv_f32m1(v_src1, v_src2, vl);\n        vfloat32m1_t v_abs_diff = vfsgnjx_vv_f32m1(v_diff, v_diff, vl);\n\n        // Condition 1: Absolute difference within 50\n        mask1 = vmflt_vf_f32m1(v_abs_diff, 50.0f, vl);\n\n        // Condition 2: Index is a multiple of 2\n        vbool32_t index_mask = vmseq_vx_i32m1(vid_v_i32m1(vl), 0, vl);\n        mask2 = vmnot_m_b32(index_mask, vl);\n\n        // Combine masks\n        combined_mask = vmand_mm_b32(mask1, mask2, vl);\n\n        // Perform element-wise multiplication\n        vfloat32m1_t v_mul = vfmul_vv_f32m1(v_src1, v_src2, vl);\n\n        // Round up towards positive infinity\n        vfloat32m1_t v_ceil = vfceil_v_f32m1(v_mul, vl);\n\n        // Apply mask to select results or -1\n        v_dst = vmerge_vvm_f32m1(combined_mask, v_ceil, v_neg_one, vl);\n\n        // Store result into dst\n        vse32_v_f32m1(dst + i, v_dst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_21_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    vfloat32m1_t v_src1, v_src2, v_dst;\n    vbool32_t mask1, mask2, combined_mask;\n    vfloat32m1_t v_neg_one = vfmv_v_f_f32m1(-1.0f, vl);\n\n    for (; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n\n        // Load vectors from src1 and src2\n        v_src1 = vle32_v_f32m1(&src1[i], vl);\n        v_src2 = vle32_v_f32m1(&src2[i], vl);\n\n        // Compute absolute difference\n        vfloat32m1_t v_diff = vfsub_vv_f32m1(v_src1, v_src2, vl);\n        vfloat32m1_t v_abs_diff = vfsgnjx_vv_f32m1(v_diff, v_diff, vl);\n\n        // Create mask for condition 1: abs(diff) <= 50\n        mask1 = vmfle_vf_f32m1(v_abs_diff, 50.0f, vl);\n\n        // Create mask for condition 2: index is a multiple of 2\n        vbool32_t index_mask = vmseq_vx_i32m1(vid_v_i32m1(vl), 0, vl);\n        mask2 = vmnot_m_b32(index_mask, vl);\n\n        // Combine masks\n        combined_mask = vmand_mm_b32(mask1, mask2, vl);\n\n        // Perform element-wise multiplication\n        vfloat32m1_t v_mul = vfmul_vv_f32m1(v_src1, v_src2, vl);\n\n        // Round up towards positive infinity\n        v_dst = vfcvt_x_f_v_f32m1(v_mul, vl);\n        v_dst = vfcvt_f_x_v_f32m1(v_dst, vl);\n\n        // Apply combined mask to set results to -1 where conditions are not met\n        v_dst = vmerge_vvm_f32m1(combined_mask, v_dst, v_neg_one, vl);\n\n        // Store the result in dst\n        vse32_v_f32m1(&dst[i], v_dst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_22_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e64m8(total_elements - i);\n        vfloat64m8_t vec_mat = vle64_v_f64m8(&mat[i], vl);\n        vfloat64m8_t vec_result = vfmul_vf_f64m8(vec_mat, scalar, vl);\n        vse64_v_f64m8(&dst[i], vec_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_22_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e64m8(total_elements - i);\n        vfloat64m8_t vec_mat = vle64_v_f64m8(&mat[i], vl);\n        vfloat64m8_t vec_result = vfmul_vf_f64m8(vec_mat, scalar, vl);\n        vse64_v_f64m8(&dst[i], vec_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_22_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e64m8(total_elements - i);\n        vfloat64m8_t vec_mat = vle64_v_f64m8(&mat[i], vl);\n        vfloat64m8_t vec_result = vfmul_vf_f64m8(vec_mat, scalar, vl);\n        vse64_v_f64m8(&dst[i], vec_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_22_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e64m8(total_elements - i);\n        vfloat64m8_t vec_mat = vle64_v_f64m8(&mat[i], vl);\n        vfloat64m8_t vec_result = vfmul_vf_f64m8(vec_mat, scalar, vl);\n        vse64_v_f64m8(&dst[i], vec_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_22_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e64m8(total_elements - i);\n        vfloat64m8_t vec_mat = vle64_v_f64m8(&mat[i], vl);\n        vfloat64m8_t vec_result = vfmul_vf_f64m8(vec_mat, scalar, vl);\n        vse64_v_f64m8(&dst[i], vec_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_23_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    size_t vlmax = vsetvlmax_e32m8();\n    for (size_t i = 0; i < m; ++i) {\n        float* row = mat + i * n;\n        size_t j = 0;\n\n        // Compute the L2 norm of the row\n        float sum_squares = 0.0f;\n        for (; j + vlmax <= n; j += vlmax) {\n            vfloat32m8_t vec = vle32_v_f32m8(row + j, vlmax);\n            vfloat32m8_t squared = vfmul_vv_f32m8(vec, vec, vlmax);\n            sum_squares += vfredsum_vs_f32m8_f32m1(squared, vfmv_s_f_f32m1(0.0f), vlmax);\n        }\n        if (j < n) {\n            size_t vl = vsetvl_e32m8(n - j);\n            vfloat32m8_t vec = vle32_v_f32m8(row + j, vl);\n            vfloat32m8_t squared = vfmul_vv_f32m8(vec, vec, vl);\n            sum_squares += vfredsum_vs_f32m8_f32m1(squared, vfmv_s_f_f32m1(0.0f), vl);\n        }\n\n        float norm = sqrtf(sum_squares);\n\n        // Normalize the row by dividing each element by the norm\n        j = 0;\n        for (; j + vlmax <= n; j += vlmax) {\n            vfloat32m8_t vec = vle32_v_f32m8(row + j, vlmax);\n            vfloat32m8_t normalized = vfdiv_vf_f32m8(vec, norm, vlmax);\n            vse32_v_f32m8(row + j, normalized, vlmax);\n        }\n        if (j < n) {\n            size_t vl = vsetvl_e32m8(n - j);\n            vfloat32m8_t vec = vle32_v_f32m8(row + j, vl);\n            vfloat32m8_t normalized = vfdiv_vf_f32m8(vec, norm, vl);\n            vse32_v_f32m8(row + j, normalized, vl);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    size_t row, col;\n    for (row = 0; row < m; ++row) {\n        float* row_start = mat + row * n;\n        float sum_squares = 0.0f;\n\n        // Compute the sum of squares using RVV intrinsics\n        size_t vl;\n        vfloat32m1_t v_sum_squares = vfmv_v_f_f32m1(0.0f, vsetvlmax_e32m1());\n        for (col = 0; col < n; col += vl) {\n            vl = vsetvl_e32m1(n - col);\n            vfloat32m1_t v_row = vle32_v_f32m1(row_start + col, vl);\n            v_sum_squares = vfredusum_vs_f32m1_f32m1(v_sum_squares, vfmul_vv_f32m1(v_row, v_row, vl), v_sum_squares, vl);\n        }\n        sum_squares = vfmv_f_s_f32m1_f32(v_sum_squares);\n\n        // Compute L2 norm\n        float l2_norm = sqrtf(sum_squares);\n\n        // Normalize the row using RVV intrinsics\n        for (col = 0; col < n; col += vl) {\n            vl = vsetvl_e32m1(n - col);\n            vfloat32m1_t v_row = vle32_v_f32m1(row_start + col, vl);\n            v_row = vfdiv_vf_f32m1(v_row, l2_norm, vl);\n            vse32_v_f32m1(row_start + col, v_row, vl);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    size_t vlmax = vsetvlmax_e32m8();\n    for (size_t i = 0; i < m; ++i) {\n        float* row = mat + i * n;\n        size_t j = 0;\n\n        // Compute the sum of squares of the row elements\n        vfloat32m8_t vsum = vfmv_v_f_f32m8(0.0f, vlmax);\n        for (; j + vlmax <= n; j += vlmax) {\n            vfloat32m8_t vrow = vle32_v_f32m8(row + j, vlmax);\n            vsum = vfredusum_vs_f32m8_f32m1(vsum, vfmul_vv_f32m8(vrow, vrow, vlmax), vsum, vlmax);\n        }\n        float sum_of_squares = vfmv_f_s_f32m1_f32(vsum);\n\n        // Handle remaining elements\n        for (; j < n; ++j) {\n            sum_of_squares += row[j] * row[j];\n        }\n\n        // Compute L2 norm\n        float norm = sqrtf(sum_of_squares);\n\n        // Normalize the row by dividing each element by the norm\n        j = 0;\n        vfloat32m8_t vnorm = vfmv_v_f_f32m8(norm, vlmax);\n        for (; j + vlmax <= n; j += vlmax) {\n            vfloat32m8_t vrow = vle32_v_f32m8(row + j, vlmax);\n            vrow = vfdiv_vf_f32m8(vrow, norm, vlmax);\n            vse32_v_f32m8(row + j, vrow, vlmax);\n        }\n\n        // Handle remaining elements\n        for (; j < n; ++j) {\n            row[j] /= norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    size_t vlmax = vsetvlmax_e32m8();\n    for (size_t i = 0; i < m; ++i) {\n        float* row = mat + i * n;\n        float sum_squares = 0.0f;\n\n        // Compute the sum of squares of the row elements using RVV\n        size_t j = 0;\n        vfloat32m8_t vsum = vfmv_v_f_f32m8(0.0f, vlmax);\n        for (; j + vlmax <= n; j += vlmax) {\n            vfloat32m8_t vrow = vle32_v_f32m8(row + j, vlmax);\n            vsum = vfredusum_vs_f32m8_f32m1(vsum, vfmul_vv_f32m8(vrow, vrow, vlmax), vsum, vlmax);\n        }\n        sum_squares = vfmv_f_s_f32m1_f32(vsum);\n\n        // Handle the tail elements\n        for (; j < n; ++j) {\n            sum_squares += row[j] * row[j];\n        }\n\n        // Compute the L2 norm\n        float norm = sqrtf(sum_squares);\n\n        // Normalize the row by dividing each element by the L2 norm\n        j = 0;\n        for (; j + vlmax <= n; j += vlmax) {\n            vfloat32m8_t vrow = vle32_v_f32m8(row + j, vlmax);\n            vfloat32m8_t vnorm = vfdiv_vf_f32m8(vrow, norm, vlmax);\n            vse32_v_f32m8(row + j, vnorm, vlmax);\n        }\n\n        // Handle the tail elements\n        for (; j < n; ++j) {\n            row[j] /= norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    size_t vlmax = vsetvlmax_e32m8();\n    for (size_t i = 0; i < m; ++i) {\n        float* row = mat + i * n;\n        float norm_sq = 0.0f;\n\n        // Compute the sum of squares of the row elements\n        size_t j = 0;\n        vfloat32m8_t v_sum_sq = vfmv_v_f_f32m8(0.0f, vlmax);\n        for (; j + vlmax <= n; j += vlmax) {\n            vfloat32m8_t v_row = vle32_v_f32m8(row + j, vlmax);\n            v_sum_sq = vfmacc_vv_f32m8(v_sum_sq, v_row, v_row, vlmax);\n        }\n        // Reduction to get the final sum of squares\n        float sum_sq_temp = 0.0f;\n        vse32_v_f32m8(&sum_sq_temp, v_sum_sq, vlmax);\n        for (size_t k = 0; k < vlmax; ++k) {\n            norm_sq += sum_sq_temp;\n        }\n        // Handle remaining elements\n        for (; j < n; ++j) {\n            norm_sq += row[j] * row[j];\n        }\n\n        // Compute the L2 norm\n        float norm = sqrtf(norm_sq);\n\n        // Normalize the row by dividing each element by the norm\n        j = 0;\n        for (; j + vlmax <= n; j += vlmax) {\n            vfloat32m8_t v_row = vle32_v_f32m8(row + j, vlmax);\n            vfloat32m8_t v_norm = vfmv_v_f_f32m8(norm, vlmax);\n            v_row = vfdiv_vv_f32m8(v_row, v_norm, vlmax);\n            vse32_v_f32m8(row + j, v_row, vlmax);\n        }\n        // Handle remaining elements\n        for (; j < n; ++j) {\n            row[j] /= norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    size_t vl;\n    vfloat64m1_t v_res, v_mat1, v_mat2;\n    vfloat64m1_t v_zero = vmv_v_f_f64m1(0.0, vsetvlmax_e64m1());\n\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n\n            size_t k = 0;\n            v_res = v_zero;\n\n            for (; k + vsetvlmax_e64m1() <= n; k += vl) {\n                vl = vsetvl_e64m1(n - k);\n\n                v_mat1 = vle64_v_f64m1(&mat1[i * n + k], vl);\n                v_mat2 = vle64_v_f64m1(&mat2[k * p + j], vl);\n\n                v_res = vfmacc_vv_f64m1(v_res, v_mat1, v_mat2, vl);\n            }\n\n            // Reduction of vector elements to scalar\n            for (size_t l = 0; l < vl; ++l) {\n                sum += *((double*)&v_res + l);\n            }\n\n            // Process remaining elements\n            for (; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n\n            // Round the result to the nearest integer and store in dst\n            dst[i * p + j] = nearbyint(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    size_t vl;\n    vfloat64m1_t v_res, v_mat1, v_mat2;\n    vfloat64m1_t v_zero = vfmv_v_f_f64m1(0.0, vl);\n\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            size_t k = 0;\n\n            vl = vsetvl_e64m1(n);\n            v_res = v_zero;\n\n            while (k < n) {\n                vl = vsetvl_e64m1(n - k);\n                v_mat1 = vle64_v_f64m1(&mat1[i * n + k], vl);\n                v_mat2 = vle64_v_f64m1(&mat2[k * p + j], vl);\n                v_res = vfmacc_vv_f64m1(v_res, v_mat1, v_mat2, vl);\n                k += vl;\n            }\n\n            // Reduction to scalar\n            sum = vfmv_f_s_f64m1_f64(v_res);\n\n            // Round the result to the nearest integer and store in dst\n            dst[i * p + j] = nearbyint(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    size_t vl;\n    vfloat64m1_t v_res, v_mat1, v_mat2;\n    vfloat64m1_t v_zero = vmv_v_f_f64m1(0.0, vl);\n\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n\n            size_t k = 0;\n            v_res = vmv_v_f_f64m1(0.0, vl);\n            for (; k + vsetvl_e64m1(k) <= n; k += vl) {\n                vl = vsetvl_e64m1(n - k);\n                v_mat1 = vle64_v_f64m1(&mat1[i * n + k], vl);\n                v_mat2 = vle64_v_f64m1(&mat2[k * p + j], vl);\n                v_res = vfmacc_vv_f64m1(v_res, v_mat1, v_mat2, vl);\n            }\n\n            // Reduction of vector result to scalar\n            for (size_t l = 0; l < vl; ++l) {\n                sum += v_res[l];\n            }\n\n            // Handle remaining elements\n            for (; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n\n            // Round the result to the nearest integer and store in dst\n            dst[i * p + j] = nearbyint(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    size_t vl;\n    vfloat64m1_t v_res, v_mat1, v_mat2;\n    vfloat64m1_t v_zero = vmv_v_f_f64m1(0.0, vl);\n\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            size_t k = 0;\n\n            vl = vsetvl_e64m1(n);\n            v_res = vmv_v_f_f64m1(0.0, vl);\n\n            while (k < n) {\n                vl = vsetvl_e64m1(n - k);\n                v_mat1 = vle64_v_f64m1(&mat1[i * n + k], vl);\n                v_mat2 = vle64_v_f64m1(&mat2[k * p + j], vl);\n                v_res = vfmacc_vv_f64m1(v_res, v_mat1, v_mat2, vl);\n                k += vl;\n            }\n\n            // Reduction of vector to scalar\n            for (size_t l = 0; l < vl; ++l) {\n                sum += v_res[l];\n            }\n\n            // Round the result to the nearest integer and store in dst\n            dst[i * p + j] = nearbyint(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    size_t vl;\n    vfloat64m1_t v_res, v_mat1, v_mat2;\n    vfloat64m1_t v_zero = vfmv_v_f_f64m1(0.0, vl);\n\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n\n            size_t k = 0;\n            v_res = v_zero;\n\n            for (; k + vsetvlmax_e64m1() <= n; k += vl) {\n                vl = vsetvl_e64m1(n - k);\n                v_mat1 = vle64_v_f64m1(&mat1[i * n + k], vl);\n                v_mat2 = vle64_v_f64m1(&mat2[k * p + j], vl);\n                v_res = vfmacc_vv_f64m1(v_res, v_mat1, v_mat2, vl);\n            }\n\n            sum = vfmv_f_s_f64m1_f64(vfredsum_vs_f64m1_f64m1(v_res, v_res, v_zero, vl));\n\n            for (; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n\n            dst[i * p + j] = nearbyint(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t vlmax = vsetvlmax_e32m1();\n    for (size_t i = 0; i < rows; i += vlmax) {\n        size_t vl = vsetvl_e32m1(rows - i);\n        for (size_t j = 0; j < cols; ++j) {\n            // Load the row elements from src\n            vfloat32m1_t vec_src = vle32_v_f32m1(&src[i * cols + j], vl);\n\n            // Round to nearest quarter (multiply by 4, round, divide by 4)\n            vfloat32m1_t vec_rounded = vfdiv_vf_f32m1(vfrint_x_f32m1(vfmul_vf_f32m1(vec_src, 4.0f, vl), vl), 4.0f, vl);\n\n            // Store transposed into dst\n            for (size_t k = 0; k < vl; ++k) {\n                dst[(j * rows) + i + k] = vfmv_f_s_f32m1_f32(vec_rounded);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t vl;\n    vfloat32m1_t v_src, v_dst;\n    vfloat32m1_t v_rounded;\n    vbool32_t mask;\n\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j += vl) {\n            vl = vsetvl_e32m1(cols - j);\n\n            // Load a vector of elements from the source matrix\n            v_src = vle32_v_f32m1(&src[i * cols + j], vl);\n\n            // Round each element to the nearest quarter (0.25)\n            v_dst = vfdiv_vf_f32m1(v_src, 0.25f, vl);\n            v_dst = vfadd_vf_f32m1(v_dst, 0.5f, vl); // Add 0.5 for rounding\n            v_rounded = vfcvt_x_f_v_f32m1(v_dst, vl);\n            v_rounded = vfmul_vf_f32m1(vfcvt_f_x_v_f32m1(v_rounded, vl), 0.25f, vl);\n\n            // Store the transposed and rounded result into the destination matrix\n            for (size_t k = 0; k < vl; k++) {\n                dst[(j + k) * rows + i] = v_rounded[k];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t vlmax = vsetvlmax_e32m1();\n    float quarter = 0.25f;\n\n    for (size_t col = 0; col < cols; col += vlmax) {\n        size_t vl = vsetvl_e32m1(cols - col);\n        for (size_t row = 0; row < rows; ++row) {\n            // Load a vector of elements from the source matrix\n            vfloat32m1_t vec_src = vle32_v_f32m1(&src[row * cols + col], vl);\n\n            // Round each element to the nearest quarter\n            vfloat32m1_t rounded = vfadd_vf_f32m1(vfmul_vf_f32m1(vec_src, 4.0f, vl), 0.5f, vl);\n            rounded = vfcvt_f_x_f32m1(vfcvt_x_f_f32m1(rounded, vl), vl);\n            rounded = vfmul_vf_f32m1(rounded, quarter, vl);\n\n            // Store the transposed result into the destination matrix\n            for (size_t i = 0; i < vl; ++i) {\n                dst[(col + i) * rows + row] = vfmv_f_s_f32m1_f32(rounded, i);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t vl;\n    vfloat32m1_t v_src, v_dst;\n    vfloat32m1_t v_round_factor = vfmv_v_f_f32m1(0.125f, vl); // 0.125 for rounding to nearest quarter\n\n    for (size_t i = 0; i < rows; i += vl) {\n        vl = vsetvl_e32m1(rows - i);\n        for (size_t j = 0; j < cols; j++) {\n            v_src = vle32_v_f32m1(&src[i * cols + j], vl);\n            v_src = vfadd_vv_f32m1(v_src, v_round_factor, vl);\n            v_dst = vfncvt_x_f_w_f32m1(v_src, vl);\n            v_dst = vfcvt_f_x_v_f32m1(v_dst, vl);\n            v_dst = vfmul_vf_f32m1(v_dst, 0.25f, vl);\n            for (size_t k = 0; k < vl; k++) {\n                dst[(i + k) * cols + j] = v_dst[k];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t vlmax = vsetvlmax_e32m1();\n    float quarter = 0.25f;\n\n    for (size_t col = 0; col < cols; col += vlmax) {\n        size_t vl = vsetvl_e32m1(cols - col);\n        for (size_t row = 0; row < rows; ++row) {\n            // Load a vector of elements from the source matrix\n            vfloat32m1_t v_src = vle32_v_f32m1(&src[row * cols + col], vl);\n\n            // Round each element to the nearest quarter\n            vfloat32m1_t v_rounded = vfadd_vf_f32m1(vfmul_vf_f32m1(v_src, 4.0f, vl), 0.5f, vl);\n            v_rounded = vfmul_vf_f32m1(vfcvt_x_f_v_f32m1(v_rounded, vl), quarter, vl);\n\n            // Store the transposed result into the destination matrix\n            for (size_t i = 0; i < vl; ++i) {\n                dst[(col + i) * rows + row] = vfmv_f_s_f32m1_f32(v_rounded);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n\n        vfloat32m8_t vec1 = vle32_v_f32m8(&tensor1[i], vl);\n        vfloat32m8_t vec2 = vle32_v_f32m8(&tensor2[i], vl);\n\n        vfloat32m8_t result = vfsub_vv_f32m8(vec1, vec2, vl);\n        vint32m8_t rounded = vfcvt_rtz_x_f_v_i32m8(result, vl);\n        vfloat32m8_t final_result = vfcvt_f_x_v_f32m8(rounded, vl);\n\n        vse32_v_f32m8(&dst[i], final_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_26_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n\n        vfloat32m8_t vec1 = vle32_v_f32m8(&tensor1[i], vl);\n        vfloat32m8_t vec2 = vle32_v_f32m8(&tensor2[i], vl);\n\n        vfloat32m8_t result = vfsub_vv_f32m8(vec1, vec2, vl);\n        vint32m8_t rounded = vfcvt_rtz_x_f_v_i32m8(result, vl);\n        vfloat32m8_t final_result = vfcvt_f_x_v_f32m8(rounded, vl);\n\n        vse32_v_f32m8(&dst[i], final_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_26_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    while (i < total_elements) {\n        size_t vl = vsetvl_e32m8(total_elements - i);\n\n        vfloat32m8_t vec1 = vle32_v_f32m8(&tensor1[i], vl);\n        vfloat32m8_t vec2 = vle32_v_f32m8(&tensor2[i], vl);\n\n        vfloat32m8_t result = vfsub_vv_f32m8(vec1, vec2, vl);\n        vint32m8_t rounded = vfcvt_rtz_x_f_v_i32m8(result, vl);\n        vfloat32m8_t final_result = vfcvt_f_x_v_f32m8(rounded, vl);\n\n        vse32_v_f32m8(&dst[i], final_result, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_26_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n\n        vfloat32m8_t vec1 = vle32_v_f32m8(tensor1 + i, vl);\n        vfloat32m8_t vec2 = vle32_v_f32m8(tensor2 + i, vl);\n\n        vfloat32m8_t result = vfsub_vv_f32m8(vec1, vec2, vl);\n        vint32m8_t rounded = vfcvt_rtz_x_f_v_i32m8(result, vl);\n        vfloat32m8_t final_result = vfncvt_f_xu_f_v_f32m8(rounded, vl);\n\n        vse32_v_f32m8(dst + i, final_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_26_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n\n        vfloat32m8_t vec1 = vle32_v_f32m8(&tensor1[i], vl);\n        vfloat32m8_t vec2 = vle32_v_f32m8(&tensor2[i], vl);\n\n        vfloat32m8_t result = vfsub_vv_f32m8(vec1, vec2, vl);\n        vint32m8_t rounded = vfcvt_rtz_x_f_v_i32m8(result, vl);\n        vfloat32m8_t final_result = vfcvt_f_x_v_f32m8(rounded, vl);\n\n        vse32_v_f32m8(&dst[i], final_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_27_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t idx = 0;\n    size_t vl;\n\n    for (size_t i = 0; i < m; ++i) {\n        idx = i * n;\n        size_t j = 0;\n\n        while (j < n) {\n            vl = vsetvl_e64m8(n - j);\n            vfloat64m8_t vec1 = vle64_v_f64m8(&mat1[idx + j], vl);\n            vfloat64m8_t vec2 = vle64_v_f64m8(&mat2[idx + j], vl);\n            vfloat64m8_t result = vfmul_vv_f64m8(vec1, vec2, vl);\n            vse64_v_f64m8(&dst[idx + j], result, vl);\n            j += vl;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_27_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t idx = 0;\n    size_t vl;\n\n    for (size_t i = 0; i < m; ++i) {\n        idx = i * n;\n        size_t j = 0;\n\n        while (j < n) {\n            vl = vsetvl_e64m8(n - j);\n            vfloat64m8_t vec1 = vle64_v_f64m8(&mat1[idx + j], vl);\n            vfloat64m8_t vec2 = vle64_v_f64m8(&mat2[idx + j], vl);\n            vfloat64m8_t result = vfmul_vv_f64m8(vec1, vec2, vl);\n            vse64_v_f64m8(&dst[idx + j], result, vl);\n            j += vl;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_27_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t idx = 0;\n    size_t vl;\n\n    for (size_t i = 0; i < m; ++i) {\n        idx = i * n;\n        size_t j = 0;\n\n        while (j < n) {\n            vl = vsetvl_e64m8(n - j);\n            vfloat64m8_t vec1 = vle64_v_f64m8(&mat1[idx + j], vl);\n            vfloat64m8_t vec2 = vle64_v_f64m8(&mat2[idx + j], vl);\n            vfloat64m8_t result = vfmul_vv_f64m8(vec1, vec2, vl);\n            vse64_v_f64m8(&dst[idx + j], result, vl);\n            j += vl;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_27_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t idx = 0;\n    size_t vl;\n\n    for (size_t i = 0; i < m; ++i) {\n        idx = i * n;\n        size_t j = 0;\n\n        while (j < n) {\n            vl = vsetvl_e64m8(n - j);\n            vfloat64m8_t vec1 = vle64_v_f64m8(&mat1[idx + j], vl);\n            vfloat64m8_t vec2 = vle64_v_f64m8(&mat2[idx + j], vl);\n            vfloat64m8_t result = vfmul_vv_f64m8(vec1, vec2, vl);\n            vse64_v_f64m8(&dst[idx + j], result, vl);\n            j += vl;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_27_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t idx = 0;\n    size_t vl;\n\n    for (size_t i = 0; i < m; ++i) {\n        idx = i * n;\n        size_t j = 0;\n\n        while (j < n) {\n            vl = vsetvl_e64m8(n - j);\n            vfloat64m8_t vec1 = vle64_v_f64m8(&mat1[idx + j], vl);\n            vfloat64m8_t vec2 = vle64_v_f64m8(&mat2[idx + j], vl);\n            vfloat64m8_t result = vfmul_vv_f64m8(vec1, vec2, vl);\n            vse64_v_f64m8(&dst[idx + j], result, vl);\n            j += vl;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_28_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    size_t vl;\n    vfloat32m1_t v_res, v_mat_row, v_vec;\n\n    for (size_t i = 0; i < m; ++i) {\n        v_res = vfmv_v_f_f32m1(0.0f, vsetvl_e32m1(n)); // Initialize result vector to 0\n\n        for (size_t j = 0; j < n; j += vl) {\n            vl = vsetvl_e32m1(n - j); // Set vector length\n\n            v_vec = vle32_v_f32m1(vec + j, vl); // Load vector elements\n            v_mat_row = vle32_v_f32m1(mat + i * n + j, vl); // Load matrix row elements\n\n            v_res = vfmacc_vv_f32m1(v_res, v_mat_row, v_vec, vl); // Multiply and accumulate\n        }\n\n        // Reduce the vector to a scalar value\n        dst[i] = vfmv_f_s_f32m1_f32(v_res); // Store the result in dst\n    }\n}\n```"}
{"task_id": "SimdBench_28_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    size_t vl;\n    vfloat32m1_t v_res, v_mat_row, v_vec;\n\n    for (size_t i = 0; i < m; ++i) {\n        v_res = vfmv_v_f_f32m1(0.0f, vsetvlmax_e32m1());\n        size_t j = 0;\n\n        for (; j + vsetvlmax_e32m1() <= n; j += vl) {\n            vl = vsetvl_e32m1(n - j);\n            v_vec = vle32_v_f32m1(vec + j, vl);\n            v_mat_row = vle32_v_f32m1(mat + i * n + j, vl);\n            v_res = vfmacc_vv_f32m1(v_res, v_mat_row, v_vec, vl);\n        }\n\n        if (j < n) {\n            vl = vsetvl_e32m1(n - j);\n            v_vec = vle32_v_f32m1(vec + j, vl);\n            v_mat_row = vle32_v_f32m1(mat + i * n + j, vl);\n            v_res = vfmacc_vv_f32m1(v_res, v_mat_row, v_vec, vl);\n        }\n\n        dst[i] = vfmv_f_s_f32m1_f32(v_res);\n    }\n}\n```"}
{"task_id": "SimdBench_28_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    size_t vl;\n    vfloat32m1_t v_res, v_mat_row, v_vec;\n\n    for (size_t i = 0; i < m; ++i) {\n        v_res = vfmv_v_f_f32m1(0.0f, vsetvlmax_e32m1());\n        size_t j = 0;\n\n        while (j < n) {\n            vl = vsetvl_e32m1(n - j);\n\n            v_vec = vle32_v_f32m1(vec + j, vl);\n            v_mat_row = vle32_v_f32m1(mat + i * n + j, vl);\n\n            v_res = vfmacc_vv_f32m1(v_res, v_mat_row, v_vec, vl);\n\n            j += vl;\n        }\n\n        dst[i] = vfmv_f_s_f32m1_f32(v_res);\n    }\n}\n```"}
{"task_id": "SimdBench_28_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    size_t vl;\n    vfloat32m1_t v_res, v_mat_row, v_vec;\n\n    for (size_t i = 0; i < m; ++i) {\n        v_res = vfmv_v_f_f32m1(0.0f, vsetvlmax_e32m1());\n        size_t j = 0;\n\n        for (; j + vsetvlmax_e32m1() <= n; j += vl) {\n            vl = vsetvl_e32m1(n - j);\n            v_vec = vle32_v_f32m1(vec + j, vl);\n            v_mat_row = vle32_v_f32m1(mat + i * n + j, vl);\n            v_res = vfmacc_vv_f32m1(v_res, v_mat_row, v_vec, vl);\n        }\n\n        if (j < n) {\n            vl = vsetvl_e32m1(n - j);\n            v_vec = vle32_v_f32m1(vec + j, vl);\n            v_mat_row = vle32_v_f32m1(mat + i * n + j, vl);\n            v_res = vfmacc_vv_f32m1(v_res, v_mat_row, v_vec, vl);\n        }\n\n        dst[i] = vfmv_f_s_f32m1_f32(v_res);\n    }\n}\n```"}
{"task_id": "SimdBench_28_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    size_t vl;\n    vfloat32m1_t v_res, v_mat_row, v_vec;\n\n    for (size_t i = 0; i < m; ++i) {\n        v_res = vfmv_v_f_f32m1(0.0f, vsetvlmax_e32m1());\n        size_t j = 0;\n\n        for (; j + vsetvlmax_e32m1() <= n; j += vl) {\n            vl = vsetvl_e32m1(n - j);\n            v_vec = vle32_v_f32m1(vec + j, vl);\n            v_mat_row = vle32_v_f32m1(mat + i * n + j, vl);\n            v_res = vfmacc_vv_f32m1(v_res, v_mat_row, v_vec, vl);\n        }\n\n        if (j < n) {\n            vl = vsetvl_e32m1(n - j);\n            v_vec = vle32_v_f32m1(vec + j, vl);\n            v_mat_row = vle32_v_f32m1(mat + i * n + j, vl);\n            v_res = vfmacc_vv_f32m1(v_res, v_mat_row, v_vec, vl);\n        }\n\n        dst[i] = vfmv_f_s_f32m1_f32(v_res);\n    }\n}\n```"}
{"task_id": "SimdBench_29_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t index = 0;\n    double sum = 0.0;\n\n    while (index < total_elements) {\n        size_t vl = vsetvl_e64m8(total_elements - index);\n        vfloat64m8_t vec = vle64_v_f64m8(&mat[index], vl);\n        sum += vfmv_f_s_f64m8_f64(vfredsum_vs_f64m8_f64m1(vec, vfsub_vv_f64m8(vec, vec, vl), vl));\n        index += vl;\n    }\n\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t index = 0;\n    double sum = 0.0;\n\n    while (index < total_elements) {\n        size_t vl = vsetvl_e64m8(total_elements - index);\n        vfloat64m8_t vec = vle64_v_f64m8(&mat[index], vl);\n        sum += vfmv_f_s_f64m8_f64(vfredsum_vs_f64m8_f64m1(vec, vfsub_vv_f64m8(vec, vec, vl), vl));\n        index += vl;\n    }\n\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t index = 0;\n    double sum = 0.0;\n\n    while (index < total_elements) {\n        size_t vl = vsetvl_e64m8(total_elements - index);\n        vfloat64m8_t vec = vle64_v_f64m8(&mat[index], vl);\n        sum += vfmv_f64_v_f64m8(vfredsum_vs_f64m8_f64m1(vec, vfsub_vv_f64m8(vec, vec, vl), vl));\n        index += vl;\n    }\n\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t index = 0;\n    double sum = 0.0;\n\n    while (index < total_elements) {\n        size_t vl = vsetvl_e64m8(total_elements - index);\n\n        vfloat64m8_t vec = vle64_v_f64m8(&mat[index], vl);\n        vfloat64m1_t vec_sum = vfmv_s_f_f64m1(vundefined_f64m1(), 0.0, vl);\n\n        vec_sum = vfredsum_vs_f64m8_f64m1(vec_sum, vec, vec_sum, vl);\n\n        sum += vfmv_f_s_f64m1_f64(vec_sum);\n\n        index += vl;\n    }\n\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t index = 0;\n    double sum = 0.0;\n\n    while (index < total_elements) {\n        size_t vl = vsetvl_e64m8(total_elements - index);\n        vfloat64m8_t vec = vle64_v_f64m8(&mat[index], vl);\n        sum += vfmv_f_s_f64m8_f64(vfredsum_vs_f64m8_f64m1(vec, vfsub_vv_f64m8(vec, vec, vl), vl));\n        index += vl;\n    }\n\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_30_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    size_t vlmax = vsetvlmax_e32m8();\n    bool all_sorted = true;\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        bool ascending = directions[i];\n        size_t j = 0;\n\n        while (j < cols - 1) {\n            size_t vl = vsetvl_e32m8(cols - j);\n            vint32m8_t vec_curr = vle32_v_i32m8(row + j, vl);\n            vint32m8_t vec_next = vle32_v_i32m8(row + j + 1, vl);\n\n            vbool4_t mask;\n            if (ascending) {\n                mask = vmseq_vv_i32m8_b4(vec_curr, vec_next);\n                mask = vmor_vv_i32m8_b4(mask, vmslt_vv_i32m8_b4(vec_curr, vec_next));\n            } else {\n                mask = vmseq_vv_i32m8_b4(vec_curr, vec_next);\n                mask = vmor_vv_i32m8_b4(mask, vmslt_vv_i32m8_b4(vec_next, vec_curr));\n            }\n\n            if (!vmall(mask)) {\n                all_sorted = false;\n                break;\n            }\n\n            j += vl;\n        }\n\n        if (!all_sorted) {\n            break;\n        }\n    }\n\n    return all_sorted;\n}\n```"}
{"task_id": "SimdBench_30_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    size_t vlmax = vsetvlmax_e32m8();\n    bool all_sorted = true;\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        bool ascending = directions[i];\n        size_t j = 0;\n\n        while (j < cols - 1) {\n            size_t vl = vsetvl_e32m8(cols - j);\n            vint32m8_t vec_curr = vle32_v_i32m8(row + j, vl);\n            vint32m8_t vec_next = vle32_v_i32m8(row + j + 1, vl);\n\n            vbool4_t mask;\n            if (ascending) {\n                mask = vmseq_vv_i32m8_b4(vec_curr, vec_next, vl);\n                mask = vmor_mm_b4(mask, vmsle_vv_i32m8_b4(vec_curr, vec_next, vl), vl);\n            } else {\n                mask = vmseq_vv_i32m8_b4(vec_curr, vec_next, vl);\n                mask = vmor_mm_b4(mask, vmsge_vv_i32m8_b4(vec_curr, vec_next, vl), vl);\n            }\n\n            if (!vmall_b4(mask, vl)) {\n                all_sorted = false;\n                break;\n            }\n\n            j += vl;\n        }\n\n        if (!all_sorted) {\n            break;\n        }\n    }\n\n    return all_sorted;\n}\n```"}
{"task_id": "SimdBench_30_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    size_t vlmax = vsetvlmax_e32m8();\n    bool all_sorted = true;\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        bool ascending = directions[i];\n        size_t j = 0;\n\n        while (j < cols - 1) {\n            size_t vl = vsetvl_e32m8(cols - j);\n            vint32m8_t curr = vle32_v_i32m8(row + j, vl);\n            vint32m8_t next = vle32_v_i32m8(row + j + 1, vl);\n\n            vbool4_t mask;\n            if (ascending) {\n                mask = vmflt_vv_i32m8_b4(curr, next, vl);\n            } else {\n                mask = vmfgt_vv_i32m8_b4(curr, next, vl);\n            }\n\n            if (!vmall(mask, vl)) {\n                all_sorted = false;\n                break;\n            }\n\n            j += vl;\n        }\n\n        if (!all_sorted) {\n            break;\n        }\n    }\n\n    return all_sorted;\n}\n```"}
{"task_id": "SimdBench_30_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    size_t vlmax = vsetvlmax_e32m8();\n    bool all_sorted = true;\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        bool ascending = directions[i];\n        size_t j = 0;\n\n        while (j < cols - 1) {\n            size_t vl = vsetvl_e32m8(cols - j);\n            vint32m8_t vec_current = vle32_v_i32m8(row + j, vl);\n            vint32m8_t vec_next = vle32_v_i32m8(row + j + 1, vl);\n\n            vbool4_t mask;\n            if (ascending) {\n                mask = vmseq_vv_i32m8_b4(vec_current, vec_next);\n                mask = vmor_vv_i32m8_b4(mask, vmsle_vv_i32m8_b4(vec_current, vec_next));\n            } else {\n                mask = vmseq_vv_i32m8_b4(vec_current, vec_next);\n                mask = vmor_vv_i32m8_b4(mask, vmsge_vv_i32m8_b4(vec_current, vec_next));\n            }\n\n            if (!vmall(mask)) {\n                all_sorted = false;\n                break;\n            }\n\n            j += vl;\n        }\n\n        if (!all_sorted) {\n            break;\n        }\n    }\n\n    return all_sorted;\n}\n```"}
{"task_id": "SimdBench_30_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    size_t vlmax = vsetvlmax_e32m8();\n    bool all_sorted = true;\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        bool ascending = directions[i];\n        size_t j = 0;\n\n        while (j < cols - 1) {\n            size_t vl = vsetvl_e32m8(cols - j);\n            vint32m8_t curr = vle32_v_i32m8(row + j, vl);\n            vint32m8_t next = vle32_v_i32m8(row + j + 1, vl);\n\n            vbool4_t mask;\n            if (ascending) {\n                mask = vmseq_vv_i32m8_b4(vmslt_vv_i32m8(curr, next, vl), 1, vl);\n            } else {\n                mask = vmseq_vv_i32m8_b4(vmslt_vv_i32m8(next, curr, vl), 1, vl);\n            }\n\n            if (!vmall(mask, vl)) {\n                all_sorted = false;\n                break;\n            }\n\n            j += vl;\n        }\n\n        if (!all_sorted) {\n            break;\n        }\n    }\n\n    return all_sorted;\n}\n```"}
{"task_id": "SimdBench_31_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t vl;\n    vint16m1_t vsrc, vbase, vmult, vremainder, vresult;\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16m1(length - i);\n\n        // Load source vector\n        vsrc = vle16_v_i16m1(src + i, vl);\n\n        // Broadcast base as a vector\n        vbase = vmv_v_x_i16m1(base, vl);\n\n        // Compute the quotient (integer division)\n        vmult = vdiv_vx_i16m1(vsrc, base, vl);\n\n        // Multiply back to get the largest multiple of base <= src\n        vresult = vmul_vx_i16m1(vmult, base, vl);\n\n        // Store the result into the destination array\n        vse16_v_i16m1(dst + i, vresult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_31_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    vint16m1_t v_base = vmv_s_x_i16m1(vundefined_i16m1(), (int16_t)base, 1);\n    while (i < length) {\n        vl = vsetvl_e16m1(length - i);\n        vint16m1_t v_src = vle16_v_i16m1(&src[i], vl);\n        vint16m1_t v_div = vdiv_vx_i16m1(v_src, v_base, vl);\n        vint16m1_t v_mul = vmul_vx_i16m1(v_div, v_base, vl);\n        vse16_v_i16m1(&dst[i], v_mul, vl);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_31_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t vl;\n    vint16m1_t vsrc, vbase, vmultiple, vremainder, vresult;\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16m1(length - i);\n\n        // Load source vector\n        vsrc = vle16_v_i16m1(src + i, vl);\n\n        // Broadcast base as a vector\n        vbase = vmv_v_x_i16m1(base, vl);\n\n        // Compute the quotient: src / base\n        vmultiple = vdiv_vx_i16m1(vsrc, base, vl);\n\n        // Compute the multiple of base: (src / base) * base\n        vmultiple = vmul_vx_i16m1(vmultiple, base, vl);\n\n        // Store the result into the destination array\n        vse16_v_i16m1(dst + i, vmultiple, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_31_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t vl;\n    vint16m1_t vsrc, vdst;\n    vint16m1_t vbase = vmv_v_x_i16m1(base, 1); // Broadcast base to a vector\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16m1(length - i);\n        vsrc = vle16_v_i16m1(src + i, vl); // Load source vector\n        vdst = vdiv_vx_i16m1(vsrc, base, vl); // Divide each element by base\n        vdst = vmul_vx_i16m1(vdst, base, vl); // Multiply back by base to get the nearest multiple\n        vse16_v_i16m1(dst + i, vdst, vl); // Store result into destination\n    }\n}\n```"}
{"task_id": "SimdBench_31_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t vl;\n    vint16m1_t v_src, v_dst;\n    vint16m1_t v_base = vmv_v_x_i16m1(base, 1); // Broadcast base to vector\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16m1(length - i);\n        v_src = vle16_v_i16m1(src + i, vl); // Load src elements into vector\n        v_dst = vdiv_vx_i16m1(v_src, base, vl); // Divide each element by base\n        v_dst = vmul_vx_i16m1(v_dst, base, vl); // Multiply back by base to get the nearest multiple\n        vse16_v_i16m1(dst + i, v_dst, vl); // Store results into dst\n    }\n}\n```"}
{"task_id": "SimdBench_32_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    size_t vlmax = vsetvlmax_e64m1();\n    bool found = false;\n\n    for (size_t i = 0; i < rows && !found; ++i) {\n        const double* row = matrix + i * cols;\n        size_t j = 0;\n        vbool64_t match_all = vmbool_m8(true); // Initialize to all true\n\n        for (; j + vlmax <= cols; j += vlmax) {\n            vfloat64m1_t vec_v = vle64_v_f64m1(vector + j, vlmax);\n            vfloat64m1_t row_v = vle64_v_f64m1(row + j, vlmax);\n            vbool64_t match = vmfeq_vv_f64m1_b64(vec_v, row_v, vlmax);\n            match_all = vmand_vv_i64m1_b64(match_all, match, vlmax);\n        }\n\n        // Handle remaining elements\n        if (j < cols) {\n            size_t vl = vsetvl_e64m1(cols - j);\n            vfloat64m1_t vec_v = vle64_v_f64m1(vector + j, vl);\n            vfloat64m1_t row_v = vle64_v_f64m1(row + j, vl);\n            vbool64_t match = vmfeq_vv_f64m1_b64(vec_v, row_v, vl);\n            match_all = vmand_vv_i64m1_b64(match_all, match, vl);\n        }\n\n        // Reduce match_all to scalar\n        int mask = vmv_x_s_i64m1_i64(match_all);\n        found = (mask == -1); // All bits set means all elements matched\n    }\n\n    return found;\n}\n```"}
{"task_id": "SimdBench_32_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    size_t vlmax = vsetvlmax_e64m1();\n    bool found_match = false;\n\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row = matrix + i * cols;\n        size_t j = 0;\n        bool match = true;\n\n        while (j < cols) {\n            size_t vl = vsetvl_e64m1(cols - j);\n            vfloat64m1_t vec_row = vle64_v_f64m1(row + j, vl);\n            vfloat64m1_t vec_vector = vle64_v_f64m1(vector + j, vl);\n            vbool64_t comparison = vmfne_vv_f64m1_b64(vec_row, vec_vector, vl);\n\n            if (vmfirst_m_b64(comparison, vl) != -1) {\n                match = false;\n                break;\n            }\n\n            j += vl;\n        }\n\n        if (match) {\n            found_match = true;\n            break;\n        }\n    }\n\n    return found_match;\n}\n```"}
{"task_id": "SimdBench_32_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    size_t vlmax = vsetvlmax_e64m1();\n    bool found_match = false;\n\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row = matrix + i * cols;\n        size_t j = 0;\n        bool match = true;\n\n        while (j < cols) {\n            size_t vl = vsetvl_e64m1(cols - j);\n            vfloat64m1_t vec_row = vle64_v_f64m1(row + j, vl);\n            vfloat64m1_t vec_vec = vle64_v_f64m1(vector + j, vl);\n            vbool64_t comparison = vmfne_vv_f64m1_b64(vec_row, vec_vec, vl);\n\n            if (vmfirst_m_b64(comparison, vl) != -1) {\n                match = false;\n                break;\n            }\n\n            j += vl;\n        }\n\n        if (match) {\n            found_match = true;\n            break;\n        }\n    }\n\n    return found_match;\n}\n```"}
{"task_id": "SimdBench_32_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    size_t vlmax = vsetvlmax_e64m8();\n    bool found_match = false;\n\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row = matrix + i * cols;\n        size_t j = 0;\n        bool match = true;\n\n        for (; j + vlmax <= cols; j += vlmax) {\n            vfloat64m8_t vec_matrix = vle64_v_f64m8(row + j, vlmax);\n            vfloat64m8_t vec_vector = vle64_v_f64m8(vector + j, vlmax);\n            vbool8_t comparison = vmfne_vv_f64m8_b8(vec_matrix, vec_vector, vlmax);\n\n            if (vmfirst_m_b8(comparison, vlmax) != -1) {\n                match = false;\n                break;\n            }\n        }\n\n        if (match && j < cols) {\n            for (; j < cols; ++j) {\n                if (row[j] != vector[j]) {\n                    match = false;\n                    break;\n                }\n            }\n        }\n\n        if (match) {\n            found_match = true;\n            break;\n        }\n    }\n\n    return found_match;\n}\n```"}
{"task_id": "SimdBench_32_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    size_t vlmax = vsetvlmax_e64m8();\n    bool found = false;\n\n    for (size_t i = 0; i < rows && !found; ++i) {\n        const double* row = matrix + i * cols;\n        size_t j = 0;\n        vbool64_t match_all = vmbool_m8(true);\n\n        for (; j + vlmax <= cols; j += vlmax) {\n            vfloat64m8_t vec_row = vle64_v_f64m8(row + j, vlmax);\n            vfloat64m8_t vec_vec = vle64_v_f64m8(vector + j, vlmax);\n            vbool64_t match = vmfeq_vv_f64m8(vec_row, vec_vec, vlmax);\n            match_all = vmand_mm_b64(match_all, match, vlmax);\n        }\n\n        if (vmseq_m_b64(vmfirst_m_b64(match_all, vlmax), true)) {\n            found = true;\n        } else {\n            for (; j < cols; ++j) {\n                if (row[j] != vector[j]) {\n                    break;\n                }\n            }\n            if (j == cols) {\n                found = true;\n            }\n        }\n    }\n\n    return found;\n}\n```"}
{"task_id": "SimdBench_33_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e8m8(total_elements - i);\n        vuint8m8_t vecA = vle8_v_u8m8(&A[i], vl);\n        vuint8m8_t vecB = vle8_v_u8m8(&B[i], vl);\n        vbool8_t mask = vmseq_vv_u8m8_b8(vecA, vecB, vl);\n        count += vcpop_m_b8(mask, vl);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e8m8(total_elements - i);\n        vuint8m8_t vecA = vle8_v_u8m8(&A[i], vl);\n        vuint8m8_t vecB = vle8_v_u8m8(&B[i], vl);\n        vbool8_t mask = vmseq_vv_u8m8_b8(vecA, vecB, vl);\n        count += vcpop_m_b8(mask, vl);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e8m8(total_elements - i);\n        vuint8m8_t vecA = vle8_v_u8m8(&A[i], vl);\n        vuint8m8_t vecB = vle8_v_u8m8(&B[i], vl);\n        vbool8_t mask = vmseq_vv_u8m8(vecA, vecB, vl);\n        count += vcpop_m_b8(mask, vl);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e8m8(total_elements - i);\n        vuint8m8_t vec_a = vle8_v_u8m8(&A[i], vl);\n        vuint8m8_t vec_b = vle8_v_u8m8(&B[i], vl);\n        vbool8_t mask = vmseq_vv_u8m8(vec_a, vec_b, vl);\n        count += vcpop_m_b8(mask, vl);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e8m8(total_elements - i);\n        vuint8m8_t vec_a = vle8_v_u8m8(&A[i], vl);\n        vuint8m8_t vec_b = vle8_v_u8m8(&B[i], vl);\n        vbool8_t mask = vmseq_vv_u8m8(vec_a, vec_b, vl);\n        count += vcpop_m_b8(mask, vl);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_34_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t vl;\n    vint64m8_t vx, vy, vres;\n    vint64m8_t va = vmv_v_x_i64m8(a, vl); // Broadcast scalar 'a' to vector\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m8(length - i);\n        vx = vle64_v_i64m8(x + i, vl);         // Load vector x\n        vy = vle64_v_i64m8(y + i, vl);         // Load vector y\n\n        vres = vsub_vv_i64m8(va, vx, vl);      // Scalar-vector multiplication: a * x\n        vres = vmslt_vx_i64m8_b(vres, 0, vl);  // Absolute value of vector y\n        vres = vsub_vv_i64m8(vres, vy, vl);    // Element-wise subtraction\n\n        vse64_v_i64m8(y + i, vres, vl);        // Store the result back to y\n    }\n}\n```"}
{"task_id": "SimdBench_34_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t vl;\n    vint64m8_t vx, vy, vres;\n    vint64m1_t va;\n\n    va = vmv_s_x_i64m1(va, a);\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m8(length - i);\n        vx = vle64_v_i64m8(x + i, vl);\n        vy = vle64_v_i64m8(y + i, vl);\n\n        vres = vsub_vv_i64m8(vmul_vx_i64m8(vx, va, vl), vabs_v_i64m8(vy, vl), vl);\n        vse64_v_i64m8(y + i, vres, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_34_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t vl;\n    vint64m8_t vx, vy, vres;\n    vint64m8_t va = vmv_v_x_i64m8(a, vl); // Broadcast scalar 'a' to vector\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m8(length - i);\n\n        vx = vle64_v_i64m8(x + i, vl);         // Load vector x\n        vy = vle64_v_i64m8(y + i, vl);         // Load vector y\n\n        vres = vsub_vv_i64m8(va, vx, vl);      // Scalar-vector multiplication: a * x\n        vres = vmsub_vx_i64m8(vres, vy, vl);   // Element-wise subtraction: (a * x) - y\n        vres = vabs_v_i64m8(vres, vl);         // Absolute value of the result\n\n        vse64_v_i64m8(y + i, vres, vl);        // Store the result back to y\n    }\n}\n```"}
{"task_id": "SimdBench_34_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t vl;\n    vint64m8_t vx, vy, vres;\n    vint64m1_t va;\n\n    va = vmv_v_x_i64m1(a, 1); // Broadcast scalar 'a' to a vector\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m8(length - i);\n\n        vx = vle64_v_i64m8(x + i, vl);       // Load vector x\n        vy = vle64_v_i64m8(y + i, vl);       // Load vector y\n\n        vres = vmul_vx_i64m8(vx, a, vl);     // Scalar-vector multiplication: a * x\n        vy = vsub_vv_i64m8(vy, vres, vl);    // Element-wise subtraction: y - (a * x)\n        vy = vabs_v_i64m8(vy, vl);           // Absolute value of the result\n\n        vse64_v_i64m8(y + i, vy, vl);        // Store the result back to y\n    }\n}\n```"}
{"task_id": "SimdBench_34_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t vl;\n    vint64m8_t vx, vy, vres;\n    vint64m8_t va = vmv_v_x_i64m8(a, vl);\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m8(length - i);\n        vx = vle64_v_i64m8(x + i, vl);\n        vy = vle64_v_i64m8(y + i, vl);\n\n        vres = vsub_vv_i64m8(va, vx, vl);\n        vres = vabs_v_i64m8(vres, vl);\n\n        vse64_v_i64m8(y + i, vres, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_35_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    size_t vl;\n    size_t i = 0;\n\n    vint16m1_t v_min = vmv_s_x_i16m1(0x7FFF, 1); // Initialize to INT16_MAX\n    vint16m1_t v_max = vmv_s_x_i16m1(0x8000, 1); // Initialize to INT16_MIN\n\n    for (; i + vsetvlmax_e16m1() <= length; i += vl) {\n        vl = vsetvl_e16m1(length - i);\n        vint16m1_t v_vec = vle16_v_i16m1(vec + i, vl);\n        v_min = vmin_vv_i16m1(v_min, v_vec, vl);\n        v_max = vmax_vv_i16m1(v_max, v_vec, vl);\n    }\n\n    int16_t temp_min = vmv_x_s_i16m1_i16(v_min);\n    int16_t temp_max = vmv_x_s_i16m1_i16(v_max);\n\n    result.min_num = temp_min;\n    result.max_num = temp_max;\n\n    for (; i < length; ++i) {\n        if (vec[i] < result.min_num) {\n            result.min_num = vec[i];\n        }\n        if (vec[i] > result.max_num) {\n            result.max_num = vec[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    size_t vl;\n    size_t i = 0;\n\n    // Initialize vector registers for min and max\n    vint16m1_t v_min = vmv_s_x_i16m1(0x7FFF, 1); // INT16_MAX\n    vint16m1_t v_max = vmv_s_x_i16m1(0x8000, 1); // INT16_MIN\n\n    // Process the input vector in chunks using RVV intrinsics\n    for (; i < length; i += vl) {\n        vl = vsetvl_e16m1(length - i);\n        vint16m1_t v_vec = vle16_v_i16m1(vec + i, vl);\n\n        // Update min and max values\n        v_min = vmin_vv_i16m1(v_min, v_vec, vl);\n        v_max = vmax_vv_i16m1(v_max, v_vec, vl);\n    }\n\n    // Reduce the vector results to scalar values\n    int16_t min_val = vmv_x_s_i16m1_i16(v_min);\n    int16_t max_val = vmv_x_s_i16m1_i16(v_max);\n\n    // Perform a final reduction across lanes if necessary\n    for (size_t j = 1; j < vl; ++j) {\n        min_val = (min_val < vec[i - vl + j]) ? min_val : vec[i - vl + j];\n        max_val = (max_val > vec[i - vl + j]) ? max_val : vec[i - vl + j];\n    }\n\n    result.min_num = min_val;\n    result.max_num = max_val;\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    size_t vl;\n    size_t i = 0;\n\n    // Initialize vector registers for min and max\n    vint16m1_t v_min = vmv_v_x_i16m1(0x7FFF, 1); // INT16_MAX\n    vint16m1_t v_max = vmv_v_x_i16m1(0x8000, 1); // INT16_MIN\n\n    // Process the input vector in chunks using RVV intrinsics\n    for (; i < length; i += vl) {\n        vl = vsetvl_e16m1(length - i);\n        vint16m1_t v_vec = vle16_v_i16m1(vec + i, vl);\n\n        // Update min and max values\n        v_min = vmin_vv_i16m1(v_min, v_vec, vl);\n        v_max = vmax_vv_i16m1(v_max, v_vec, vl);\n    }\n\n    // Reduce the vector min and max to scalar values\n    int16_t min_val = vmv_x_s_i16m1_i16(v_min);\n    int16_t max_val = vmv_x_s_i16m1_i16(v_max);\n\n    // Perform horizontal reduction for remaining elements in the vector\n    for (size_t j = 1; j < vl; ++j) {\n        min_val = (min_val < vec[i - vl + j]) ? min_val : vec[i - vl + j];\n        max_val = (max_val > vec[i - vl + j]) ? max_val : vec[i - vl + j];\n    }\n\n    result.min_num = min_val;\n    result.max_num = max_val;\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    size_t vl;\n    size_t i = 0;\n\n    // Initialize vector registers for min and max\n    vint16m1_t v_min = vmv_v_x_i16m1(0x7FFF, 1); // INT16_MAX\n    vint16m1_t v_max = vmv_v_x_i16m1(0x8000, 1); // INT16_MIN\n\n    // Process the input vector in chunks using RVV intrinsics\n    for (; i < length; i += vl) {\n        vl = vsetvl_e16m1(length - i);\n        vint16m1_t v_vec = vle16_v_i16m1(vec + i, vl);\n\n        // Update min and max values\n        v_min = vmin_vv_i16m1(v_min, v_vec, vl);\n        v_max = vmax_vv_i16m1(v_max, v_vec, vl);\n    }\n\n    // Reduce the vector results to scalar values\n    vint16m1_t v_res_min = vmv_v_x_i16m1(0x7FFF, 1); // INT16_MAX\n    vint16m1_t v_res_max = vmv_v_x_i16m1(0x8000, 1); // INT16_MIN\n\n    vl = vsetvl_e16m1(1); // Set VL to 1 for reduction\n    v_res_min = vmin_vv_i16m1(v_res_min, v_min, vl);\n    v_res_max = vmax_vv_i16m1(v_res_max, v_max, vl);\n\n    // Extract scalar results from vector registers\n    result.min_num = vget_v_i16m1_i16(v_res_min, 0);\n    result.max_num = vget_v_i16m1_i16(v_res_max, 0);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    size_t vl;\n    size_t i = 0;\n\n    vint16m1_t vmax = vmv_s_x_i16m1(vmax, INT16_MIN, 1);\n    vint16m1_t vmin = vmv_s_x_i16m1(vmin, INT16_MAX, 1);\n\n    for (; i < length; i += vl) {\n        vl = vsetvl_e16m1(length - i);\n        vint16m1_t v = vle16_v_i16m1(vec + i, vl);\n        vmax = vmax_vv_i16m1(vmax, v, vl);\n        vmin = vmin_vv_i16m1(vmin, v, vl);\n    }\n\n    // Reduction to find the final max and min\n    int16_t max_val = vmax[0];\n    int16_t min_val = vmin[0];\n\n    for (size_t j = 1; j < vl; ++j) {\n        if (vmax[j] > max_val) max_val = vmax[j];\n        if (vmin[j] < min_val) min_val = vmin[j];\n    }\n\n    result.max_num = max_val;\n    result.min_num = min_val;\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_36_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    size_t vlmax = vsetvlmax_e32m8();\n    bool all_increasing = true;\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        size_t j = 0;\n\n        while (j < cols - 1) {\n            size_t vl = vsetvl_e32m8(cols - j);\n            vint32m8_t vec_curr = vle32_v_i32m8(row + j, vl);\n            vint32m8_t vec_next = vle32_v_i32m8(row + j + 1, vl);\n\n            vbool4_t mask = vmseq_vv_i32m8_b4(vec_curr, vec_next);\n            if (vmfirst_m_b4(mask, vl) != -1) {\n                all_increasing = false;\n                break;\n            }\n\n            vbool4_t mask_gt = vmsgt_vv_i32m8_b4(vec_curr, vec_next);\n            if (vmfirst_m_b4(mask_gt, vl) != -1) {\n                all_increasing = false;\n                break;\n            }\n\n            j += vl;\n        }\n\n        if (!all_increasing) {\n            break;\n        }\n    }\n\n    return all_increasing;\n}\n```"}
{"task_id": "SimdBench_36_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    size_t vlmax = vsetvlmax_e32m8();\n    bool all_increasing = true;\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        size_t j = 0;\n\n        while (j < cols - 1) {\n            size_t vl = vsetvl_e32m8(cols - j);\n            vint32m8_t vec_curr = vle32_v_i32m8(row + j, vl);\n            vint32m8_t vec_next = vle32_v_i32m8(row + j + 1, vl);\n\n            vbool4_t mask = vmseq_vv_i32m8_b4(vec_curr, vec_next);\n            if (vmfirst_m_b4(mask, vl)) {\n                all_increasing = false;\n                break;\n            }\n\n            mask = vmslt_vv_i32m8_b4(vec_curr, vec_next);\n            if (!vmfirst_m_b4(mask, vl)) {\n                all_increasing = false;\n                break;\n            }\n\n            j += vl;\n        }\n\n        if (!all_increasing) {\n            break;\n        }\n    }\n\n    return all_increasing;\n}\n```"}
{"task_id": "SimdBench_36_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    size_t vlmax = vsetvlmax_e32m8();\n    bool all_increasing = true;\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        size_t j = 0;\n        bool row_increasing = true;\n\n        while (j < cols - 1) {\n            size_t vl = vsetvl_e32m8(cols - j);\n            vint32m8_t vec_curr = vle32_v_i32m8(row + j, vl);\n            vint32m8_t vec_next = vle32_v_i32m8(row + j + 1, vl);\n\n            vbool4_t mask = vmseq_vv_i32m8_b4(vec_curr, vec_next);\n            if (vmfirst_m_b4(mask)) {\n                row_increasing = false;\n                break;\n            }\n\n            mask = vmslt_vv_i32m8_b4(vec_curr, vec_next);\n            if (!vmfirst_m_b4(mask)) {\n                row_increasing = false;\n                break;\n            }\n\n            j += vl;\n        }\n\n        if (!row_increasing) {\n            all_increasing = false;\n            break;\n        }\n    }\n\n    return all_increasing;\n}\n```"}
{"task_id": "SimdBench_36_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    size_t vlmax = vsetvlmax_e32m8();\n    bool all_increasing = true;\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        size_t j = 0;\n        bool row_increasing = true;\n\n        while (j < cols - 1) {\n            size_t vl = vsetvl_e32m8(cols - 1 - j);\n            vint32m8_t vec_curr = vle32_v_i32m8(row + j, vl);\n            vint32m8_t vec_next = vle32_v_i32m8(row + j + 1, vl);\n\n            vbool4_t mask = vmseq_vv_i32m8_b4(vec_curr, vec_next, vl);\n            if (vmfirst_m_b4(mask, vl) != -1) {\n                row_increasing = false;\n                break;\n            }\n\n            mask = vmslt_vv_i32m8_b4(vec_curr, vec_next, vl);\n            if (vmfirst_m_b4(mask, vl) == -1) {\n                row_increasing = false;\n                break;\n            }\n\n            j += vl;\n        }\n\n        if (!row_increasing) {\n            all_increasing = false;\n            break;\n        }\n    }\n\n    return all_increasing;\n}\n```"}
{"task_id": "SimdBench_36_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    size_t vlmax = vsetvlmax_e32m8();\n    bool all_increasing = true;\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        size_t j = 0;\n\n        while (j < cols - 1) {\n            size_t vl = vsetvl_e32m8(cols - j);\n            vint32m8_t curr = vle32_v_i32m8(row + j, vl);\n            vint32m8_t next = vle32_v_i32m8(row + j + 1, vl);\n\n            vbool4_t cmp = vmseq_vv_i32m8_b4(curr, next);\n            if (vmfirst_m_b4(cmp, vl) != -1) {\n                all_increasing = false;\n                break;\n            }\n\n            j += vl;\n        }\n\n        if (!all_increasing) {\n            break;\n        }\n    }\n\n    return all_increasing;\n}\n```"}
{"task_id": "SimdBench_37_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    // Check if block_size is valid\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n    size_t block_elements = block_size * block_size;\n\n    // Load the first block into a vector register for comparison\n    const int* first_block = matrix;\n    size_t vlmax = vsetvl_e32m8(block_elements); // Set vector length for block elements\n    vint32m8_t first_block_vec = vle32_v_i32m8(first_block, vlmax);\n\n    // Iterate over all blocks\n    for (size_t i = 0; i < num_blocks_row; ++i) {\n        for (size_t j = 0; j < num_blocks_col; ++j) {\n            if (i == 0 && j == 0) continue; // Skip the first block\n\n            // Compute the starting address of the current block\n            const int* current_block = matrix + (i * block_size * cols) + (j * block_size);\n            size_t vl = vsetvl_e32m8(block_elements); // Reset vector length\n\n            // Load the current block into a vector register\n            vint32m8_t current_block_vec = vle32_v_i32m8(current_block, vl);\n\n            // Compare the current block with the first block\n            vbool4_t comparison_result = vmseq_vv_i32m8_b4(first_block_vec, current_block_vec, vl);\n\n            // Reduce the comparison result to check if all elements are equal\n            bool all_equal = vmv_x_s_b4(vmand_vv_b4(comparison_result, vl));\n            if (!all_equal) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    // Check if block_size is valid\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n\n    // Get the first block as reference\n    const int* first_block = matrix;\n\n    // Initialize vector length based on LMUL and SEW\n    size_t vlmax = vsetvl_e32m1(block_size * block_size);\n\n    // Load the first block into a vector register\n    vint32m1_t ref_vec;\n    for (size_t i = 0; i < block_size; ++i) {\n        ref_vec = vle32_v_i32m1(first_block + i * cols, vlmax);\n    }\n\n    // Compare all other blocks with the first block\n    for (size_t br = 0; br < num_blocks_row; ++br) {\n        for (size_t bc = 0; bc < num_blocks_col; ++bc) {\n            if (br == 0 && bc == 0) continue; // Skip the first block\n\n            const int* current_block = matrix + br * block_size * cols + bc * block_size;\n\n            bool mismatch_found = false;\n            for (size_t i = 0; i < block_size; ++i) {\n                vint32m1_t curr_vec = vle32_v_i32m1(current_block + i * cols, vlmax);\n                vbool32_t cmp_result = vmseq_vv_i32m1_b32(ref_vec, curr_vec, vlmax);\n\n                // Check if all elements in the comparison result are true\n                if (!vmall_b32(cmp_result)) {\n                    mismatch_found = true;\n                    break;\n                }\n            }\n\n            if (mismatch_found) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n    size_t block_elements = block_size * block_size;\n\n    // Load the first block into a vector register for comparison\n    vint32m1_t first_block_v;\n    const int* first_block_ptr = matrix;\n    size_t vl = vsetvl_e32m1(block_elements);\n\n    first_block_v = vle32_v_i32m1(first_block_ptr, vl);\n\n    // Iterate over all other blocks\n    for (size_t i = 0; i < num_blocks_row; ++i) {\n        for (size_t j = 0; j < num_blocks_col; ++j) {\n            if (i == 0 && j == 0) continue; // Skip the first block\n\n            const int* current_block_ptr = matrix + (i * block_size * cols) + (j * block_size);\n            vint32m1_t current_block_v = vle32_v_i32m1(current_block_ptr, vl);\n\n            // Compare the current block with the first block\n            vbool32_t cmp_result = vmseq_vv_i32m1_b32(first_block_v, current_block_v, vl);\n\n            // Check if all elements in the comparison result are true\n            if (!vmall_b32(cmp_result, vl)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n\n    // Load the first block into a vector register for comparison\n    size_t block_elements = block_size * block_size;\n    size_t vlmax = __riscv_vsetvl_e32m8(block_elements);\n\n    int32_t first_block[block_elements];\n    for (size_t i = 0; i < block_elements; ++i) {\n        first_block[i] = matrix[i];\n    }\n\n    vint32m8_t first_block_vec = __riscv_vle32_v_i32m8(first_block, vlmax);\n\n    // Iterate over all other blocks\n    for (size_t br = 0; br < num_blocks_row; ++br) {\n        for (size_t bc = 0; bc < num_blocks_col; ++bc) {\n            if (br == 0 && bc == 0) continue; // Skip the first block\n\n            size_t block_start = (br * block_size * cols) + (bc * block_size);\n            bool mismatch_found = false;\n\n            for (size_t i = 0; i < block_size; ++i) {\n                size_t row_start = block_start + (i * cols);\n                int32_t current_block[block_elements];\n\n                for (size_t j = 0; j < block_size; ++j) {\n                    current_block[i * block_size + j] = matrix[row_start + j];\n                }\n\n                vint32m8_t current_block_vec = __riscv_vle32_v_i32m8(current_block, vlmax);\n                vbool4_t comparison_result = __riscv_vmseq_vv_i32m8_b4(first_block_vec, current_block_vec, vlmax);\n\n                // Check if all elements in the comparison result are true\n                if (__riscv_vfirst_m_b4(comparison_result, vlmax) != -1) {\n                    mismatch_found = true;\n                    break;\n                }\n            }\n\n            if (mismatch_found) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    // Check if block_size is valid\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_block_rows = rows / block_size;\n    size_t num_block_cols = cols / block_size;\n\n    // Load the first block into a reference vector\n    size_t block_elements = block_size * block_size;\n    size_t vlmax = vsetvl_e32m8(block_elements); // Set vector length for 32-bit integers\n\n    vint32m8_t ref_block = vmv_v_x_i32m8(0, vlmax); // Initialize reference block vector\n    for (size_t i = 0; i < block_elements; i += vlmax) {\n        size_t vl = vsetvl_e32m8(block_elements - i);\n        ref_block = vle32_v_i32m8(matrix + i, vl);\n    }\n\n    // Compare all other blocks with the reference block\n    for (size_t br = 0; br < num_block_rows; ++br) {\n        for (size_t bc = 0; bc < num_block_cols; ++bc) {\n            if (br == 0 && bc == 0) continue; // Skip the first block\n\n            size_t block_start = (br * block_size * cols) + (bc * block_size);\n            bool block_equal = true;\n\n            for (size_t i = 0; i < block_elements; i += vlmax) {\n                size_t vl = vsetvl_e32m8(block_elements - i);\n                const int* block_ptr = matrix + block_start + i;\n                vint32m8_t current_block = vle32_v_i32m8(block_ptr, vl);\n\n                vbool4_t comparison = vmseq_vv_i32m8(current_block, ref_block, vl);\n                if (!vmv_x_s_b4_i32(vmreduce_all_b4(comparison))) {\n                    block_equal = false;\n                    break;\n                }\n            }\n\n            if (!block_equal) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (block_size == 0 || length < block_size || length % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    size_t vlmax = vsetvlmax_e64m8();\n    bool result = true;\n\n    for (size_t b = 1; b < num_blocks && result; ++b) {\n        size_t i = 0;\n        while (i < block_size) {\n            size_t vl = vsetvl_e64m8(block_size - i);\n            vfloat64m8_t v_first = vle64_v_f64m8(vec + i, vl);\n            vfloat64m8_t v_current = vle64_v_f64m8(vec + b * block_size + i, vl);\n            vbool64_t mask = vmfge_vv_f64m8_b64(vfabs_vf_f64m8(vfsub_vv_f64m8(v_current, v_first, vl), vl), tolerance, vl);\n\n            if (!vmall(mask, vl)) {\n                result = false;\n                break;\n            }\n            i += vl;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_38_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (block_size == 0 || length < block_size || block_size > length) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 2) {\n        return false;\n    }\n\n    size_t vlmax = vsetvlmax_e64m8();\n    bool result = true;\n\n    for (size_t b = 1; b < num_blocks && result; ++b) {\n        size_t i = 0;\n        while (i < block_size) {\n            size_t vl = vsetvl_e64m8(block_size - i);\n            vfloat64m8_t v_first = vle64_v_f64m8(vec + i, vl);\n            vfloat64m8_t v_current = vle64_v_f64m8(vec + b * block_size + i, vl);\n            vbool8_t mask = vmfge_vv_f64m8_b8(vfabs_vf_f64m8(vfsub_vv_f64m8(v_current, v_first, vl), vl), tolerance, vl);\n\n            if (!vmall(mask, vl)) {\n                result = false;\n                break;\n            }\n            i += vl;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_38_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (block_size == 0 || length < block_size || tolerance < 0) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 2) {\n        return false;\n    }\n\n    size_t vlmax = vsetvlmax_e64m1();\n    bool result = true;\n\n    for (size_t b = 1; b < num_blocks && result; ++b) {\n        size_t i = 0;\n        while (i < block_size) {\n            size_t vl = vsetvl_e64m1(block_size - i);\n            vfloat64m1_t v_first = vle64_v_f64m1(vec + i, vl);\n            vfloat64m1_t v_current = vle64_v_f64m1(vec + b * block_size + i, vl);\n\n            vbool64_t mask = vmfge_vv_f64m1_b64(vfabs_vf_f64m1(vfsub_vv_f64m1(v_current, v_first, vl), vl), tolerance, vl);\n            if (!vmall(mask)) {\n                result = false;\n                break;\n            }\n            i += vl;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_38_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (block_size == 0 || length < block_size || tolerance < 0) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 2) {\n        return false;\n    }\n\n    size_t vlmax = vsetvlmax_e64m8();\n    bool result = true;\n\n    for (size_t i = 1; i < num_blocks && result; ++i) {\n        size_t vl = vlmax;\n        size_t j = 0;\n\n        while (j < block_size) {\n            vl = vsetvl_e64m8(block_size - j);\n            vfloat64m8_t v_first = vle64_v_f64m8(vec + j, vl);\n            vfloat64m8_t v_current = vle64_v_f64m8(vec + i * block_size + j, vl);\n            vbool8_t mask = vmfge_vv_f64m8_b8(vfabs_vf_f64m8(vfsub_vv_f64m8(v_current, v_first, vl), vl), tolerance, vl);\n\n            if (!vmall(mask, vl)) {\n                result = false;\n                break;\n            }\n\n            j += vl;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_38_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (block_size == 0 || length < block_size || tolerance < 0) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 2) {\n        return false;\n    }\n\n    size_t vlmax = vsetvlmax_e64m8();\n    bool result = true;\n\n    for (size_t b = 1; b < num_blocks && result; ++b) {\n        size_t i = 0;\n        while (i < block_size) {\n            size_t vl = vsetvl_e64m8(block_size - i);\n            vfloat64m8_t v_first = vle64_v_f64m8(vec + i, vl);\n            vfloat64m8_t v_current = vle64_v_f64m8(vec + b * block_size + i, vl);\n\n            vbool64_t mask = vmfge_vv_f64m8_b64(vfabs_vf_f64m8(vfsub_vv_f64m8(v_current, v_first, vl), vl), tolerance, vl);\n            if (!vmall(mask)) {\n                result = false;\n                break;\n            }\n            i += vl;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_39_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    size_t vlmax = vsetvlmax_e64m1();\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row = matrix + i * cols;\n        double norm_sq = 0.0;\n        size_t j = 0;\n\n        // Compute the squared norm of the row using RVV intrinsics\n        for (; j + vlmax <= cols; j += vlmax) {\n            vfloat64m1_t vrow = vle64_v_f64m1(row + j, vlmax);\n            vfloat64m1_t vsq = vfmul_vv_f64m1(vrow, vrow, vlmax);\n            vfloat64m1_t vacc = vfredsum_vs_f64m1_f64m1(vsq, vsq, vlmax);\n            norm_sq += vfmv_f_s_f64m1_f64(vacc);\n        }\n\n        // Handle remaining elements\n        for (; j < cols; ++j) {\n            norm_sq += row[j] * row[j];\n        }\n\n        // Compare the Euclidean norm with the threshold\n        double norm = sqrt(norm_sq);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    size_t vlmax = vsetvlmax_e64m8();\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row = matrix + i * cols;\n        double norm_sq = 0.0;\n        size_t j = 0;\n\n        // Compute the squared norm of the row using RVV intrinsics\n        vfloat64m8_t v_sum = vfmv_v_f_f64m8(0.0, vlmax);\n        for (; j + vlmax <= cols; j += vlmax) {\n            vfloat64m8_t v_row = vle64_v_f64m8(row + j, vlmax);\n            v_sum = vfredusum_vs_f64m8_f64m1(v_sum, vfmul_vv_f64m8(v_row, v_row, vlmax), v_sum, vlmax);\n        }\n        norm_sq = vfmv_f_s_f64m1_f64(v_sum);\n\n        // Handle remaining elements\n        for (; j < cols; ++j) {\n            norm_sq += row[j] * row[j];\n        }\n\n        // Compare the Euclidean norm with the threshold\n        double norm = sqrt(norm_sq);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    size_t vlmax = vsetvlmax_e64m8();\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row = matrix + i * cols;\n        double norm_sq = 0.0;\n        size_t j = 0;\n\n        // Compute the squared norm of the row using RVV intrinsics\n        for (; j + vlmax <= cols; j += vlmax) {\n            vfloat64m8_t vrow = vle64_v_f64m8(row + j, vlmax);\n            vfloat64m8_t vsq = vfmul_vv_f64m8(vrow, vrow, vlmax);\n            vfloat64m1_t vsum = vfredusum_vs_f64m8_f64m1(vundef_f64m1(), vsq, vlmax);\n            norm_sq += vfmv_f_s_f64m1_f64(vsum);\n        }\n\n        // Handle remaining elements\n        if (j < cols) {\n            size_t vl = vsetvl_e64m8(cols - j);\n            vfloat64m8_t vrow = vle64_v_f64m8(row + j, vl);\n            vfloat64m8_t vsq = vfmul_vv_f64m8(vrow, vrow, vl);\n            vfloat64m1_t vsum = vfredusum_vs_f64m8_f64m1(vundef_f64m1(), vsq, vl);\n            norm_sq += vfmv_f_s_f64m1_f64(vsum);\n        }\n\n        // Compare the Euclidean norm with the threshold\n        double norm = sqrt(norm_sq);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    size_t vlmax = vsetvlmax_e64m8();\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row = matrix + i * cols;\n        double norm_sq = 0.0;\n        size_t j = 0;\n\n        // Compute the squared norm of the row using RVV intrinsics\n        for (; j + vlmax <= cols; j += vlmax) {\n            vfloat64m8_t vrow = vle64_v_f64m8(row + j, vlmax);\n            vfloat64m8_t vsq = vfmul_vv_f64m8(vrow, vrow, vlmax);\n            vfloat64m1_t vsum = vfmv_s_f_f64m1(0.0, vlmax);\n            vsum = vfredusum_vs_f64m8_f64m1(vsum, vsq, vsum, vlmax);\n            norm_sq += vfmv_f_s_f64m1_f64(vsum);\n        }\n\n        // Handle remaining elements\n        for (; j < cols; ++j) {\n            norm_sq += row[j] * row[j];\n        }\n\n        // Compare the Euclidean norm with the threshold\n        double norm = sqrt(norm_sq);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    size_t vlmax = vsetvlmax_e64m1();\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row = matrix + i * cols;\n        double norm_sq = 0.0;\n        size_t j = 0;\n\n        // Compute the squared norm of the row using RVV intrinsics\n        for (; j + vlmax <= cols; j += vlmax) {\n            vfloat64m1_t vrow = vle64_v_f64m1(row + j, vlmax);\n            vfloat64m1_t vsq = vfmul_vv_f64m1(vrow, vrow, vlmax);\n            vfloat64m1_t vacc = vfredusum_vs_f64m1_f64m1(vsq, vfmv_s_f_f64m1(0.0, vlmax), vlmax);\n            norm_sq += vfmv_f_s_f64m1_f64(vacc);\n        }\n\n        // Handle remaining elements\n        for (; j < cols; ++j) {\n            norm_sq += row[j] * row[j];\n        }\n\n        // Compare the Euclidean norm with the threshold\n        double norm = sqrt(norm_sq);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_40_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e32m8(length - i);\n        vuint32m8_t vecA = vle32_v_u32m8(&A[i], vl);\n        vuint32m8_t vecB = vle32_v_u32m8(&B[i], vl);\n        vuint32m8_t vecC = vor_vv_u32m8(vecA, vecB, vl);\n        vse32_v_u32m8(&C[i], vecC, vl);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_40_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e32m8(length - i);\n        vuint32m8_t vecA = vle32_v_u32m8(&A[i], vl);\n        vuint32m8_t vecB = vle32_v_u32m8(&B[i], vl);\n        vuint32m8_t vecC = vor_vv_u32m8(vecA, vecB, vl);\n        vse32_v_u32m8(&C[i], vecC, vl);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_40_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e32m8(length - i);\n        vuint32m8_t vecA = vle32_v_u32m8(&A[i], vl);\n        vuint32m8_t vecB = vle32_v_u32m8(&B[i], vl);\n        vuint32m8_t vecC = vor_vv_u32m8(vecA, vecB, vl);\n        vse32_v_u32m8(&C[i], vecC, vl);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_40_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e32m8(length - i);\n        vuint32m8_t vecA = vle32_v_u32m8(&A[i], vl);\n        vuint32m8_t vecB = vle32_v_u32m8(&B[i], vl);\n        vuint32m8_t vecC = vor_vv_u32m8(vecA, vecB, vl);\n        vse32_v_u32m8(&C[i], vecC, vl);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_40_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e32m8(length - i);\n        vuint32m8_t vecA = vle32_v_u32m8(&A[i], vl);\n        vuint32m8_t vecB = vle32_v_u32m8(&B[i], vl);\n        vuint32m8_t vecC = vor_vv_u32m8(vecA, vecB, vl);\n        vse32_v_u32m8(&C[i], vecC, vl);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_41_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    size_t vl;\n    size_t i = 0;\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n\n    while (i < length) {\n        vl = vsetvl_e8m1(length - i);\n\n        vint8m1_t vec_a = vle8_v_i8m1(&A[i], vl);\n        vint8m1_t vec_b = vle8_v_i8m1(&B[i], vl);\n\n        // Compute squares of A and B\n        vint16m2_t vec_a_sq = vwmul_vv_i16m2(vec_a, vec_a, vl);\n        vint16m2_t vec_b_sq = vwmul_vv_i16m2(vec_b, vec_b, vl);\n\n        // Sum of squares\n        vint32m4_t vec_sum_sq = vwadd_vv_i32m4(vec_a_sq, vec_b_sq, vl);\n        sum_squares += vwredsum_vs_i32m4_i64m1(vundefined_i64m1(), vec_sum_sq, vundefined_i64m1(), vl);\n\n        // Compute products of A and B\n        vint16m2_t vec_prod = vwmul_vv_i16m2(vec_a, vec_b, vl);\n\n        // Sum of products\n        vint32m4_t vec_sum_prod = vwadd_vv_i32m4(vec_prod, vec_prod, vl);\n        sum_products += vwredsum_vs_i32m4_i64m1(vundefined_i64m1(), vec_sum_prod, vundefined_i64m1(), vl);\n\n        i += vl;\n    }\n\n    return sum_squares - sum_products;\n}\n```"}
{"task_id": "SimdBench_41_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    size_t vl;\n    vint8m1_t va, vb;\n    vint16m2_t vaa, vbb, vab;\n    vint32m4_t vacc_a_sq, vacc_b_sq, vacc_ab;\n    vint64m8_t vacc_a_sq_64, vacc_b_sq_64, vacc_ab_64;\n\n    int64_t sum_a_sq = 0, sum_b_sq = 0, sum_ab = 0;\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e8m1(length - i);\n\n        // Load vectors\n        va = vle8_v_i8m1(&A[i], vl);\n        vb = vle8_v_i8m1(&B[i], vl);\n\n        // Compute squares and products\n        vaa = vwmul_vv_i16m2(va, va, vl);\n        vbb = vwmul_vv_i16m2(vb, vb, vl);\n        vab = vwmul_vv_i16m2(va, vb, vl);\n\n        // Widen to 32-bit for accumulation\n        vacc_a_sq = vwadd_vv_i32m4(vaa, vaa, vl);\n        vacc_b_sq = vwadd_vv_i32m4(vbb, vbb, vl);\n        vacc_ab = vwadd_vv_i32m4(vab, vab, vl);\n\n        // Widen to 64-bit for final accumulation\n        vacc_a_sq_64 = vwadd_vv_i64m8(vacc_a_sq, vacc_a_sq, vl);\n        vacc_b_sq_64 = vwadd_vv_i64m8(vacc_b_sq, vacc_b_sq, vl);\n        vacc_ab_64 = vwadd_vv_i64m8(vacc_ab, vacc_ab, vl);\n\n        // Reduce sums\n        sum_a_sq += vmv_x_s_i64m8_i64(vacc_a_sq_64);\n        sum_b_sq += vmv_x_s_i64m8_i64(vacc_b_sq_64);\n        sum_ab += vmv_x_s_i64m8_i64(vacc_ab_64);\n    }\n\n    return (sum_a_sq + sum_b_sq) - sum_ab;\n}\n```"}
{"task_id": "SimdBench_41_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    size_t vl;\n    vint8m1_t va, vb;\n    vint16m2_t vaa, vbb, vab;\n    vint32m4_t vacc_sq, vacc_prod;\n    vint64m8_t vacc_sq_sum, vacc_prod_sum;\n\n    int64_t sum_sq = 0, sum_prod = 0;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e8m1(length - i);\n\n        // Load vectors\n        va = vle8_v_i8m1(&A[i], vl);\n        vb = vle8_v_i8m1(&B[i], vl);\n\n        // Compute squares and products\n        vaa = vwmul_vv_i16m2(va, va, vl);\n        vbb = vwmul_vv_i16m2(vb, vb, vl);\n        vab = vwmul_vv_i16m2(va, vb, vl);\n\n        // Add squares and products\n        vacc_sq = vwadd_vv_i32m4(vaa, vbb, vl);\n        vacc_prod = vwcvt_x_x_v_i32m4(vab, vl);\n\n        // Accumulate into 64-bit sums\n        vacc_sq_sum = vwcvt_x_x_v_i64m8(vacc_sq, vl);\n        vacc_prod_sum = vwcvt_x_x_v_i64m8(vacc_prod, vl);\n\n        // Reduce sums\n        sum_sq += vmv_x_s_i64m8_i64(vfredsum_vs_i64m8_i64m8(vacc_sq_sum, vacc_sq_sum, vl));\n        sum_prod += vmv_x_s_i64m8_i64(vfredsum_vs_i64m8_i64m8(vacc_prod_sum, vacc_prod_sum, vl));\n\n        i += vl;\n    }\n\n    return sum_sq - sum_prod;\n}\n```"}
{"task_id": "SimdBench_41_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    size_t vl;\n    vint8m1_t va, vb;\n    vint16m2_t vaa, vbb, vab;\n    vint32m4_t vsum_squares = vmv_v_x_i32m4(0, 1);\n    vint32m4_t vsum_products = vmv_v_x_i32m4(0, 1);\n    int64_t sum_squares = 0, sum_products = 0;\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e8m1(length - i);\n\n        va = vle8_v_i8m1(&A[i], vl);\n        vb = vle8_v_i8m1(&B[i], vl);\n\n        vaa = vwmul_vv_i16m2(va, va, vl);\n        vbb = vwmul_vv_i16m2(vb, vb, vl);\n        vab = vwmul_vv_i16m2(va, vb, vl);\n\n        vsum_squares = vwredsum_vs_i16m2_i32m4(vsum_squares, vaa, vsum_squares, vl);\n        vsum_squares = vwredsum_vs_i16m2_i32m4(vsum_squares, vbb, vsum_squares, vl);\n        vsum_products = vwredsum_vs_i16m2_i32m4(vsum_products, vab, vsum_products, vl);\n    }\n\n    sum_squares = vgetlane_x_i32m4(vsum_squares, 0) + vgetlane_x_i32m4(vsum_squares, 1);\n    sum_products = vgetlane_x_i32m4(vsum_products, 0) + vgetlane_x_i32m4(vsum_products, 1);\n\n    return (int64_t)(sum_squares - 2 * sum_products);\n}\n```"}
{"task_id": "SimdBench_41_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    size_t vl;\n    vint8m1_t va, vb;\n    vint16m2_t vaa, vbb, vab;\n    vint32m4_t vacc_a_sq = vmv_v_x_i32m4(0, 1);\n    vint32m4_t vacc_b_sq = vmv_v_x_i32m4(0, 1);\n    vint32m4_t vacc_ab = vmv_v_x_i32m4(0, 1);\n\n    size_t i = 0;\n    while (i < length) {\n        vl = vsetvl_e8m1(length - i);\n\n        va = vle8_v_i8m1(&A[i], vl);\n        vb = vle8_v_i8m1(&B[i], vl);\n\n        vaa = vwmul_vv_i16m2(va, va, vl);\n        vbb = vwmul_vv_i16m2(vb, vb, vl);\n        vab = vwmul_vv_i16m2(va, vb, vl);\n\n        vacc_a_sq = vwredsum_vs_i16m2_i32m4(vacc_a_sq, vaa, vacc_a_sq, vl);\n        vacc_b_sq = vwredsum_vs_i16m2_i32m4(vacc_b_sq, vbb, vacc_b_sq, vl);\n        vacc_ab = vwredsum_vs_i16m2_i32m4(vacc_ab, vab, vacc_ab, vl);\n\n        i += vl;\n    }\n\n    int32_t sum_a_sq = vmv_x_s_i32m4_i32(vacc_a_sq);\n    int32_t sum_b_sq = vmv_x_s_i32m4_i32(vacc_b_sq);\n    int32_t sum_ab = vmv_x_s_i32m4_i32(vacc_ab);\n\n    return ((int64_t)sum_a_sq + (int64_t)sum_b_sq) - 2 * (int64_t)sum_ab;\n}\n```"}
{"task_id": "SimdBench_42_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e64m1(length - i);\n\n        vuint64m1_t va = vle64_v_u64m1(&A[i], vl);\n        vuint64m1_t vb = vle64_v_u64m1(&B[i], vl);\n        vuint64m1_t vc = vand_vv_u64m1(va, vnot_v_u64m1(vb, vl), vl);\n\n        vse64_v_u64m1(&C[i], vc, vl);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_42_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e64m1(length - i);\n\n        vuint64m1_t va = vle64_v_u64m1(&A[i], vl);\n        vuint64m1_t vb = vle64_v_u64m1(&B[i], vl);\n\n        vuint64m1_t vn_b = vnot_v_u64m1(vb, vl);\n        vuint64m1_t vc = vand_vv_u64m1(va, vn_b, vl);\n\n        vse64_v_u64m1(&C[i], vc, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_42_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e64m1(length - i);\n\n        vuint64m1_t va = vle64_v_u64m1(&A[i], vl);\n        vuint64m1_t vb = vle64_v_u64m1(&B[i], vl);\n\n        vuint64m1_t vn_b = vnot_v_u64m1(vb, vl);\n        vuint64m1_t vc = vand_vv_u64m1(va, vn_b, vl);\n\n        vse64_v_u64m1(&C[i], vc, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_42_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e64m1(length - i);\n\n        vuint64m1_t va = vle64_v_u64m1(&A[i], vl);\n        vuint64m1_t vb = vle64_v_u64m1(&B[i], vl);\n\n        vuint64m1_t vnand_b = vnot_v_u64m1(vb, vl);\n        vuint64m1_t vc = vand_vv_u64m1(va, vnand_b, vl);\n\n        vse64_v_u64m1(&C[i], vc, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_42_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e64m8(length - i);\n\n        vuint64m8_t va = vle64_v_u64m8(&A[i], vl);\n        vuint64m8_t vb = vle64_v_u64m8(&B[i], vl);\n\n        vuint64m8_t vn_b = vnot_v_u64m8(vb, vl);\n        vuint64m8_t vc = vand_vv_u64m8(va, vn_b, vl);\n\n        vse64_v_u64m8(&C[i], vc, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_43_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e8m1(length - i);\n\n        vint8m1_t va = vle8_v_i8m1(&A[i], vl);\n        vint8m1_t vb = vle8_v_i8m1(&B[i], vl);\n\n        vbool8_t mask_pos = vmslt_vx_i8m1_b8(va, 0, vl);\n        vbool8_t mask_neg = vmslt_vx_i8m1_b8(vb, 0, vl);\n\n        vbool8_t both_pos = vmseq_vv_i8m1_b8(mask_pos, mask_neg, vl);\n        vbool8_t both_neg = vmseq_vv_i8m1_b8(mask_pos, mask_neg, vl);\n\n        vint8m1_t result = vreinterpret_v_i8m1(vmseq_vv_i8m1_b8(both_pos, both_neg, vl), vl);\n\n        vse8_v_i8m1(&C[i], result, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_43_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e8m1(length - i);\n\n        vint8m1_t va = vle8_v_i8m1(&A[i], vl);\n        vint8m1_t vb = vle8_v_i8m1(&B[i], vl);\n\n        vbool8_t mask_pos = vmslt_vx_i8m1_b8(va, 0, vl);\n        vbool8_t mask_neg = vmslt_vx_i8m1_b8(vb, 0, vl);\n\n        vbool8_t both_pos = vmseq_vv_i8m1_b8(mask_pos, mask_neg, vl);\n        vbool8_t both_neg = vmseq_vv_i8m1_b8(mask_pos, mask_neg, vl);\n\n        vint8m1_t result = vadd_vx_i8m1(both_pos, -1, vl);\n        result = vadd_vx_i8m1(result, 1, vl);\n\n        vse8_v_i8m1(&C[i], result, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_43_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e8m1(length - i);\n\n        vint8m1_t va = vle8_v_i8m1(&A[i], vl);\n        vint8m1_t vb = vle8_v_i8m1(&B[i], vl);\n\n        vbool8_t mask_pos = vmslt_vx_i8m1_b8(va, 0, vl);\n        vbool8_t mask_neg = vmslt_vx_i8m1_b8(vb, 0, vl);\n\n        vbool8_t both_pos = vmseq_vv_i8m1_b8(mask_pos, mask_neg, vl);\n        vbool8_t both_neg = vmseq_vv_i8m1_b8(mask_pos, mask_neg, vl);\n\n        vint8m1_t result = vadd_vx_i8m1(both_pos, -1, vl);\n        result = vsub_vx_i8m1(result, both_neg, vl);\n\n        vse8_v_i8m1(&C[i], result, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_43_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e8m1(length - i);\n\n        vint8m1_t va = vle8_v_i8m1(&A[i], vl);\n        vint8m1_t vb = vle8_v_i8m1(&B[i], vl);\n\n        vbool8_t mask_pos = vmslt_vx_i8m1_b8(va, 0, vl);\n        vbool8_t mask_neg = vmslt_vx_i8m1_b8(vb, 0, vl);\n\n        vbool8_t both_pos = vmseq_vv_i8m1_b8(mask_pos, mask_neg, vl);\n        vbool8_t both_neg = vmseq_vv_i8m1_b8(mask_pos, mask_neg, vl);\n\n        vint8m1_t result = vmv_v_x_i8m1(0, vl);\n        result = vmerge_vxm_i8m1(result, 1, both_pos, vl);\n        result = vmerge_vxm_i8m1(result, -1, both_neg, vl);\n\n        vse8_v_i8m1(&C[i], result, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_43_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e8m1(length - i);\n\n        vint8m1_t va = vle8_v_i8m1(A + i, vl);\n        vint8m1_t vb = vle8_v_i8m1(B + i, vl);\n\n        vbool8_t mask_pos = vmslt_vx_i8m1_b8(va, 0, vl);\n        vbool8_t mask_neg = vmslt_vx_i8m1_b8(vb, 0, vl);\n\n        vbool8_t both_pos = vmnot_mm_b8(mask_pos, vl);\n        vbool8_t both_neg = vmnot_mm_b8(mask_neg, vl);\n\n        vbool8_t pos_and = vmand_mm_b8(both_pos, vmnot_mm_b8(mask_neg, vl), vl);\n        vbool8_t neg_and = vmand_mm_b8(both_neg, vmnot_mm_b8(mask_pos, vl), vl);\n\n        vint8m1_t result_pos = vmv_v_x_i8m1(1, vl);\n        vint8m1_t result_neg = vmv_v_x_i8m1(-1, vl);\n        vint8m1_t result_zero = vmv_v_x_i8m1(0, vl);\n\n        vint8m1_t result = vmerge_vvm_i8m1(pos_and, result_pos, result_zero, vl);\n        result = vmerge_vvm_i8m1(neg_and, result_neg, result, vl);\n\n        vse8_v_i8m1(C + i, result, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_44_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t vlmax = vsetvlmax_e16m1();\n    size_t midpoint = length / 2;\n\n    size_t i = 0;\n    // Process elements before the midpoint (XOR operation)\n    for (; i < midpoint; i += vlmax) {\n        size_t vl = vsetvl_e16m1(length - i);\n        vuint16m1_t va = vle16_v_u16m1(&A[i], vl);\n        vuint16m1_t vb = vle16_v_u16m1(&B[i], vl);\n        vuint16m1_t vc = vxor_vv_u16m1(va, vb, vl);\n        vse16_v_u16m1(&C[i], vc, vl);\n    }\n\n    // Handle the midpoint element (copy from A)\n    if (length % 2 == 1 || length > 1) {\n        C[midpoint] = A[midpoint];\n    }\n\n    // Process elements after the midpoint (AND operation)\n    i = midpoint + 1;\n    for (; i < length; i += vlmax) {\n        size_t vl = vsetvl_e16m1(length - i);\n        vuint16m1_t va = vle16_v_u16m1(&A[i], vl);\n        vuint16m1_t vb = vle16_v_u16m1(&B[i], vl);\n        vuint16m1_t vc = vand_vv_u16m1(va, vb, vl);\n        vse16_v_u16m1(&C[i], vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_44_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t vlmax = vsetvlmax_e16m1();\n    size_t midpoint = length / 2;\n\n    size_t i = 0;\n    // Process elements before the midpoint (XOR operation)\n    for (; i < midpoint; i += vlmax) {\n        size_t vl = vsetvl_e16m1(length - i);\n        vuint16m1_t va = vle16_v_u16m1(&A[i], vl);\n        vuint16m1_t vb = vle16_v_u16m1(&B[i], vl);\n        vuint16m1_t vc = vxor_vv_u16m1(va, vb, vl);\n        vse16_v_u16m1(&C[i], vc, vl);\n    }\n\n    // Handle the midpoint element (copy from A)\n    if (length % 2 == 1 || length > 1) {\n        C[midpoint] = A[midpoint];\n    }\n\n    // Process elements after the midpoint (AND operation)\n    i = midpoint + 1;\n    for (; i < length; i += vlmax) {\n        size_t vl = vsetvl_e16m1(length - i);\n        vuint16m1_t va = vle16_v_u16m1(&A[i], vl);\n        vuint16m1_t vb = vle16_v_u16m1(&B[i], vl);\n        vuint16m1_t vc = vand_vv_u16m1(va, vb, vl);\n        vse16_v_u16m1(&C[i], vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_44_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t vlmax = vsetvlmax_e16m1();\n    size_t midpoint = length / 2;\n\n    size_t i = 0;\n    for (; i + vlmax <= midpoint; i += vlmax) {\n        vuint16m1_t va = vle16_v_u16m1(&A[i], vlmax);\n        vuint16m1_t vb = vle16_v_u16m1(&B[i], vlmax);\n        vuint16m1_t vc = vxor_vv_u16m1(va, vb, vlmax);\n        vse16_v_u16m1(&C[i], vc, vlmax);\n    }\n\n    if (i < midpoint) {\n        size_t vl = vsetvl_e16m1(midpoint - i);\n        vuint16m1_t va = vle16_v_u16m1(&A[i], vl);\n        vuint16m1_t vb = vle16_v_u16m1(&B[i], vl);\n        vuint16m1_t vc = vxor_vv_u16m1(va, vb, vl);\n        vse16_v_u16m1(&C[i], vc, vl);\n        i = midpoint;\n    }\n\n    if (i == midpoint) {\n        C[i] = A[i];\n        i++;\n    }\n\n    for (; i + vlmax <= length; i += vlmax) {\n        vuint16m1_t va = vle16_v_u16m1(&A[i], vlmax);\n        vuint16m1_t vb = vle16_v_u16m1(&B[i], vlmax);\n        vuint16m1_t vc = vand_vv_u16m1(va, vb, vlmax);\n        vse16_v_u16m1(&C[i], vc, vlmax);\n    }\n\n    if (i < length) {\n        size_t vl = vsetvl_e16m1(length - i);\n        vuint16m1_t va = vle16_v_u16m1(&A[i], vl);\n        vuint16m1_t vb = vle16_v_u16m1(&B[i], vl);\n        vuint16m1_t vc = vand_vv_u16m1(va, vb, vl);\n        vse16_v_u16m1(&C[i], vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_44_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t vlmax = vsetvlmax_e16m1();\n    size_t midpoint = length / 2;\n\n    size_t i = 0;\n    // Process elements before the midpoint (XOR operation)\n    for (; i < midpoint; i += vlmax) {\n        size_t vl = vsetvl_e16m1(length - i);\n        vuint16m1_t va = vle16_v_u16m1(&A[i], vl);\n        vuint16m1_t vb = vle16_v_u16m1(&B[i], vl);\n        vuint16m1_t vc = vxor_vv_u16m1(va, vb, vl);\n        vse16_v_u16m1(&C[i], vc, vl);\n    }\n\n    // Handle the midpoint element (copy from A)\n    if (length % 2 == 1 || length > 1) { // Ensure midpoint is valid\n        C[midpoint] = A[midpoint];\n    }\n\n    // Process elements after the midpoint (AND operation)\n    i = midpoint + 1;\n    for (; i < length; i += vlmax) {\n        size_t vl = vsetvl_e16m1(length - i);\n        vuint16m1_t va = vle16_v_u16m1(&A[i], vl);\n        vuint16m1_t vb = vle16_v_u16m1(&B[i], vl);\n        vuint16m1_t vc = vand_vv_u16m1(va, vb, vl);\n        vse16_v_u16m1(&C[i], vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_44_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t vlmax = vsetvlmax_e16m1();\n    size_t midpoint = length / 2;\n\n    size_t i = 0;\n    for (; i + vlmax <= midpoint; i += vlmax) {\n        vuint16m1_t va = vle16_v_u16m1(&A[i], vlmax);\n        vuint16m1_t vb = vle16_v_u16m1(&B[i], vlmax);\n        vuint16m1_t vc = vxor_vv_u16m1(va, vb, vlmax);\n        vse16_v_u16m1(&C[i], vc, vlmax);\n    }\n\n    if (i < midpoint) {\n        size_t vl = vsetvl_e16m1(midpoint - i);\n        vuint16m1_t va = vle16_v_u16m1(&A[i], vl);\n        vuint16m1_t vb = vle16_v_u16m1(&B[i], vl);\n        vuint16m1_t vc = vxor_vv_u16m1(va, vb, vl);\n        vse16_v_u16m1(&C[i], vc, vl);\n        i = midpoint;\n    }\n\n    if (i == midpoint) {\n        C[i] = A[i];\n        i++;\n    }\n\n    for (; i + vlmax <= length; i += vlmax) {\n        vuint16m1_t va = vle16_v_u16m1(&A[i], vlmax);\n        vuint16m1_t vb = vle16_v_u16m1(&B[i], vlmax);\n        vuint16m1_t vc = vand_vv_u16m1(va, vb, vlmax);\n        vse16_v_u16m1(&C[i], vc, vlmax);\n    }\n\n    if (i < length) {\n        size_t vl = vsetvl_e16m1(length - i);\n        vuint16m1_t va = vle16_v_u16m1(&A[i], vl);\n        vuint16m1_t vb = vle16_v_u16m1(&B[i], vl);\n        vuint16m1_t vc = vand_vv_u16m1(va, vb, vl);\n        vse16_v_u16m1(&C[i], vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_45_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n\n    size_t i = 0;\n    while (i < total_elements) {\n        size_t vl = vsetvl_e32m8(total_elements - i);\n\n        // Load vectors for A, B, C, D\n        vfloat32m8_t va = vle32_v_f32m8(&A[i], vl);\n        vfloat32m8_t vb = vle32_v_f32m8(&B[i], vl);\n        vfloat32m8_t vc = vle32_v_f32m8(&C[i], vl);\n        vfloat32m8_t vd = vle32_v_f32m8(&D[i], vl);\n\n        // Load boolean conditions\n        vbool32_t vcond1 = vmseq_v_i8mf8_b32(vle8_v_i8mf8((const int8_t*)&cond1[i], vl), 1, vl);\n        vbool32_t vcond2 = vmseq_v_i8mf8_b32(vle8_v_i8mf8((const int8_t*)&cond2[i], vl), 1, vl);\n\n        // Compute combined conditions\n        vbool32_t cond1_and_cond2 = vmand_mm_b32(vcond1, vcond2, vl);\n        vbool32_t cond1_and_not_cond2 = vmandn_mm_b32(vcond1, vcond2, vl);\n        vbool32_t not_cond1_and_cond2 = vmandn_mm_b32(vcond2, vcond1, vl);\n        vbool32_t not_cond1_and_not_cond2 = vmnand_mm_b32(vcond1, vcond2, vl);\n\n        // Perform element-wise selection based on conditions\n        vfloat32m8_t result = vmerge_vvm_f32m8(\n            cond1_and_cond2,\n            va,\n            vmerge_vvm_f32m8(\n                cond1_and_not_cond2,\n                vb,\n                vmerge_vvm_f32m8(\n                    not_cond1_and_cond2,\n                    vc,\n                    vd,\n                    vl\n                ),\n                vl\n            ),\n            vl\n        );\n\n        // Store the result back to memory\n        vse32_v_f32m8(&out[i], result, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_45_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n\n    size_t i = 0;\n    while (i < total_elements) {\n        size_t vl = vsetvl_e32m8(total_elements - i);\n\n        // Load vectors for A, B, C, D\n        vfloat32m8_t va = vle32_v_f32m8(&A[i], vl);\n        vfloat32m8_t vb = vle32_v_f32m8(&B[i], vl);\n        vfloat32m8_t vc = vle32_v_f32m8(&C[i], vl);\n        vfloat32m8_t vd = vle32_v_f32m8(&D[i], vl);\n\n        // Load boolean conditions and convert them to masks\n        vbool32_t vmask_cond1 = vmseq_v_i8mf8_b32(vle8_v_i8mf8((const int8_t*)&cond1[i], vl), 1, vl);\n        vbool32_t vmask_cond2 = vmseq_v_i8mf8_b32(vle8_v_i8mf8((const int8_t*)&cond2[i], vl), 1, vl);\n\n        // Compute combined masks\n        vbool32_t mask_cond1_and_cond2 = vmand_mm_b32(vmask_cond1, vmask_cond2, vl);\n        vbool32_t mask_cond1_and_not_cond2 = vmandnot_mm_b32(vmask_cond1, vmask_cond2, vl);\n        vbool32_t mask_not_cond1_and_cond2 = vmandnot_mm_b32(vmask_cond2, vmask_cond1, vl);\n        vbool32_t mask_not_cond1_and_not_cond2 = vmnand_mm_b32(vmask_cond1, vmask_cond2, vl);\n\n        // Perform element-wise selection based on masks\n        vfloat32m8_t result = vmerge_vvm_f32m8(mask_cond1_and_cond2, va, vd, vl);\n        result = vmerge_vvm_f32m8(mask_cond1_and_not_cond2, vb, result, vl);\n        result = vmerge_vvm_f32m8(mask_not_cond1_and_cond2, vc, result, vl);\n\n        // Store the result back to memory\n        vse32_v_f32m8(&out[i], result, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_45_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n\n    size_t i = 0;\n    while (i < total_elements) {\n        size_t vl = vsetvl_e32m8(total_elements - i);\n\n        // Load vectors for A, B, C, D\n        vfloat32m8_t va = vle32_v_f32m8(&A[i], vl);\n        vfloat32m8_t vb = vle32_v_f32m8(&B[i], vl);\n        vfloat32m8_t vc = vle32_v_f32m8(&C[i], vl);\n        vfloat32m8_t vd = vle32_v_f32m8(&D[i], vl);\n\n        // Load boolean conditions and convert to mask registers\n        vbool32_t vmask_cond1 = vmseq_v_i8mf8_b32(vle8_v_i8mf8((const int8_t*)&cond1[i], vl), 1, vl);\n        vbool32_t vmask_cond2 = vmseq_v_i8mf8_b32(vle8_v_i8mf8((const int8_t*)&cond2[i], vl), 1, vl);\n\n        // Compute masks for the four cases\n        vbool32_t mask_case1 = vmand_vv_b32(vmask_cond1, vmask_cond2, vl); // cond1 && cond2\n        vbool32_t mask_case2 = vmandn_vv_b32(vmask_cond1, vmask_cond2, vl); // cond1 && !cond2\n        vbool32_t mask_case3 = vmandn_vv_b32(vmask_cond2, vmask_cond1, vl); // !cond1 && cond2\n        vbool32_t mask_case4 = vmnand_vv_b32(vmask_cond1, vmask_cond2, vl); // !cond1 && !cond2\n\n        // Select values based on masks\n        vfloat32m8_t result = vmerge_vvm_f32m8(mask_case1, va, vd, vl); // Case 1: A if cond1 && cond2, else D\n        result = vmerge_vvm_f32m8(mask_case2, vb, result, vl);          // Case 2: B if cond1 && !cond2, else previous result\n        result = vmerge_vvm_f32m8(mask_case3, vc, result, vl);          // Case 3: C if !cond1 && cond2, else previous result\n        result = vmerge_vvm_f32m8(mask_case4, vd, result, vl);          // Case 4: D if !cond1 && !cond2, else previous result\n\n        // Store the result back to memory\n        vse32_v_f32m8(&out[i], result, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_45_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n\n    size_t i = 0;\n    while (i < total_elements) {\n        size_t vl = vsetvl_e32m8(total_elements - i);\n\n        // Load vectors for A, B, C, D\n        vfloat32m8_t va = vle32_v_f32m8(&A[i], vl);\n        vfloat32m8_t vb = vle32_v_f32m8(&B[i], vl);\n        vfloat32m8_t vc = vle32_v_f32m8(&C[i], vl);\n        vfloat32m8_t vd = vle32_v_f32m8(&D[i], vl);\n\n        // Load boolean conditions\n        vbool32_t vcond1 = vmseq_v_i8mf8_b32(vle8_v_i8mf8((const int8_t*)&cond1[i], vl), 1, vl);\n        vbool32_t vcond2 = vmseq_v_i8mf8_b32(vle8_v_i8mf8((const int8_t*)&cond2[i], vl), 1, vl);\n\n        // Compute combined conditions\n        vbool32_t cond1_and_cond2 = vmand_mm(vcond1, vcond2, vl);\n        vbool32_t cond1_and_not_cond2 = vmandn_mm(vcond1, vcond2, vl);\n        vbool32_t not_cond1_and_cond2 = vmandn_mm(vcond2, vcond1, vl);\n        vbool32_t not_cond1_and_not_cond2 = vmnand_mm(vcond1, vcond2, vl);\n\n        // Select values based on conditions\n        vfloat32m8_t result = vmerge_vvm_f32m8(\n            cond1_and_cond2,\n            va,\n            vmerge_vvm_f32m8(\n                cond1_and_not_cond2,\n                vb,\n                vmerge_vvm_f32m8(\n                    not_cond1_and_cond2,\n                    vc,\n                    vd,\n                    vl\n                ),\n                vl\n            ),\n            vl\n        );\n\n        // Store the result\n        vse32_v_f32m8(&out[i], result, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_45_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n\n    size_t vl;\n    size_t i = 0;\n\n    for (; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n\n        // Load vectors from input tensors\n        vfloat32m8_t vec_A = vle32_v_f32m8(&A[i], vl);\n        vfloat32m8_t vec_B = vle32_v_f32m8(&B[i], vl);\n        vfloat32m8_t vec_C = vle32_v_f32m8(&C[i], vl);\n        vfloat32m8_t vec_D = vle32_v_f32m8(&D[i], vl);\n\n        // Load boolean conditions and convert to mask registers\n        vbool32_t mask_cond1 = vmseq_v_i8mf8_b32(vle8_v_i8mf8((const int8_t*)&cond1[i], vl), 1, vl);\n        vbool32_t mask_cond2 = vmseq_v_i8mf8_b32(vle8_v_i8mf8((const int8_t*)&cond2[i], vl), 1, vl);\n\n        // Compute combined masks\n        vbool32_t mask_cond1_and_cond2 = vmand_mm_b32(mask_cond1, mask_cond2, vl);\n        vbool32_t mask_cond1_and_not_cond2 = vmandn_mm_b32(mask_cond1, mask_cond2, vl);\n        vbool32_t mask_not_cond1_and_cond2 = vmandn_mm_b32(mask_cond2, mask_cond1, vl);\n        vbool32_t mask_not_cond1_and_not_cond2 = vmnand_mm_b32(mask_cond1, mask_cond2, vl);\n\n        // Perform element-wise selection based on masks\n        vfloat32m8_t result = vmerge_vvm_f32m8(\n            mask_cond1_and_cond2,\n            vec_A,\n            vmerge_vvm_f32m8(\n                mask_cond1_and_not_cond2,\n                vec_B,\n                vmerge_vvm_f32m8(\n                    mask_not_cond1_and_cond2,\n                    vec_C,\n                    vec_D,\n                    vl\n                ),\n                vl\n            ),\n            vl\n        );\n\n        // Store the result back to the output tensor\n        vse32_v_f32m8(&out[i], result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_46_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        // Set vector length for uint32_t elements\n        vl = vsetvl_e32m8(total_elements - i);\n\n        // Load vector of uint32_t elements from A\n        vuint32m8_t vec_A = vle32_v_u32m8(&A[i], vl);\n\n        // Compute the popcount (number of bits set to 1) for each element in vec_A\n        vuint8m1_t vec_popcount = vpopc_m_b32(vundefined_u8m1(), vmseq_vx_u32m8_b32(vec_A, 0, vl), vl);\n\n        // Store the result into the output array as uint8_t\n        vse8_v_u8m1(&out[i], vec_popcount, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_46_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        // Set the vector length for uint32_t elements\n        vl = vsetvl_e32m8(total_elements - i);\n\n        // Load vector of uint32_t elements from A\n        vuint32m8_t vec_A = vle32_v_u32m8(&A[i], vl);\n\n        // Compute the popcount for each element in the vector\n        vuint8m1_t vec_popcount = vpopc_v_u32m8(vec_A, vl);\n\n        // Store the result into the output array as uint8_t\n        vse8_v_u8m1(&out[i], vec_popcount, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_46_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n\n        // Load vector of uint32_t elements from A\n        vuint32m8_t vec_A = vle32_v_u32m8(&A[i], vl);\n\n        // Compute the popcount (number of bits set to 1) for each element in vec_A\n        vuint8m1_t vec_popcount = vpopc_m_b32(vundefined_u8m1(), vmseq_vx_u32m8_b32(vec_A, 0, vl), vl);\n\n        // Store the result into the output array\n        vse8_v_u8m1(&out[i], vec_popcount, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_46_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n\n        vuint32m8_t vec_A = vle32_v_u32m8(&A[i], vl);\n\n        // Count the number of bits set to 1 in each element\n        vuint8m1_t vec_popcount = vmv_v_x_u8m1(0, vl);\n        vec_popcount = vcpop_u32(vec_A, vl);\n\n        // Store the result into the output tensor\n        vse8_v_u8m1(&out[i], vec_popcount, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_46_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n\n        // Load vector of 32-bit unsigned integers from A\n        vuint32m8_t vec_A = vle32_v_u32m8(&A[i], vl);\n\n        // Count the number of bits set to 1 in each element\n        vuint8m1_t vec_popcount = vpopc_v_u32m8(vec_A, vl);\n\n        // Store the result into the output array\n        vse8_v_u8m1(&out[i], vec_popcount, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_47_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n\n        // Load vector of elements from A\n        vint32m8_t vec_A = vle32_v_i32m8(&A[i], vl);\n\n        // Compute absolute values of A\n        vint32m8_t vec_abs_A = vmslt_vx_i32m8_b32(vec_A, 0, vl);\n        vec_abs_A = vneg_v_i32m8_m(vec_abs_A, vec_A, vl);\n\n        // Check if elements are divisible by 3\n        vbool32_t vec_div_by_3 = vmseq_vx_i32m8(vec_A % 3, 0, vl);\n\n        // Select between original A and abs(A) based on the condition\n        vint32m8_t vec_B = vmerge_vvm_i32m8(vec_div_by_3, vec_abs_A, vec_A, vl);\n\n        // Store the result into B\n        vse32_v_i32m8(&B[i], vec_B, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_47_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n\n        vint32m8_t vec_A = vle32_v_i32m8(&A[i], vl);\n        vbool4_t mask_div_by_3 = vmseq_vx_i32m8(vrem_vx_i32m8(vec_A, 3, vl), 0, vl);\n        vint32m8_t vec_abs_A = vabs_v_i32m8(vec_A, vl);\n\n        vint32m8_t result = vmerge_vvm_i32m8(mask_div_by_3, vec_abs_A, vec_A, vl);\n        vse32_v_i32m8(&B[i], result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_47_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n\n        vint32m8_t vec_A = vle32_v_i32m8(&A[i], vl);\n        vbool4_t mask = vmseq_vx_i32m8_b4(vec_A, 0, vl); // Mask where elements are divisible by 3\n        vint32m8_t vec_abs_A = vmslt_vx_i32m8(vec_A, 0, vl) ? vneg_v_i32m8(vec_A, vl) : vec_A;\n        vint32m8_t result = vmerge_vvm_i32m8(mask, vec_abs_A, vec_A, vl);\n\n        vse32_v_i32m8(&B[i], result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_47_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n\n        // Load vector of elements from A\n        vint32m8_t vec_A = vle32_v_i32m8(&A[i], vl);\n\n        // Compute absolute value of elements in A\n        vint32m8_t vec_abs_A = vmslt_vx_i32m8_b32(vec_A, 0, vl);\n        vec_abs_A = vneg_v_i32m8_m(vec_abs_A, vec_A, vl);\n\n        // Check if elements are divisible by 3\n        vbool32_t vec_div_by_3 = vmseq_vx_i32m8(vrem_vx_i32m8(vec_A, 3, vl), 0, vl);\n\n        // Select between original and absolute values based on divisibility condition\n        vint32m8_t vec_B = vmerge_vvm_i32m8(vec_div_by_3, vec_abs_A, vec_A, vl);\n\n        // Store the result into B\n        vse32_v_i32m8(&B[i], vec_B, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_47_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n\n        vint32m8_t vec_A = vle32_v_i32m8(&A[i], vl);\n        vbool4_t mask_div_by_3 = vmseq_vx_i32m8(vrem_vx_i32m8(vec_A, 3, vl), 0, vl);\n        vint32m8_t vec_abs_A = vabs_v_i32m8(vec_A, vl);\n\n        vint32m8_t result = vmerge_vvm_i32m8(mask_div_by_3, vec_abs_A, vec_A, vl);\n        vse32_v_i32m8(&B[i], result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_48_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t vl;\n    vuint32m8_t v_src, v_dst, v_rotated, v_negated;\n    vbool4_t v_mask;\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n\n        // Load source vector\n        v_src = vle32_v_u32m8(&src[i], vl);\n\n        // Create mask: true if low 4 bits are all 1\n        v_mask = vmseq_vx_u32m8_b4(vand_vx_u32m8(v_src, 0xF, vl), 0xF, vl);\n\n        // Rotate right by rotate_bits\n        v_rotated = vor_vv_u32m8(\n            vsrl_vx_u32m8(v_src, rotate_bits, vl),\n            vsll_vx_u32m8(v_src, 32 - rotate_bits, vl),\n            vl\n        );\n\n        // Bitwise negation\n        v_negated = vnot_v_u32m8(v_src, vl);\n\n        // Conditional select: rotated if mask is true, negated otherwise\n        v_dst = vmerge_vvm_u32m8(v_mask, v_rotated, v_negated, vl);\n\n        // Store result to destination vector\n        vse32_v_u32m8(&dst[i], v_dst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_48_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t vl;\n    vuint32m8_t vsrc, vdst, vrotated, vnotted;\n    vbool4_t mask;\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n\n        // Load source vector\n        vsrc = vle32_v_u32m8(&src[i], vl);\n\n        // Create mask: true if low 4 bits are all 1\n        mask = vmseq_vx_u32m8_b4(vand_vx_u32m8(vsrc, 0xF, vl), 0xF, vl);\n\n        // Compute rotated values\n        vrotated = vor_vv_u32m8(vsrl_vx_u32m8(vsrc, rotate_bits, vl),\n                                 vsll_vx_u32m8(vsrc, 32 - rotate_bits, vl), vl);\n\n        // Compute bitwise negation\n        vnotted = vnot_v_u32m8(vsrc, vl);\n\n        // Select based on mask: rotated if mask is true, otherwise negated\n        vdst = vmerge_vvm_u32m8(mask, vrotated, vnotted, vl);\n\n        // Store result to destination vector\n        vse32_v_u32m8(&dst[i], vdst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_48_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t vl;\n    vuint32m8_t v_src, v_dst, v_rotated, v_negated;\n    vbool4_t v_condition;\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n\n        // Load source vector\n        v_src = vle32_v_u32m8(&src[i], vl);\n\n        // Check if the low 4 bits are all 1\n        v_condition = vmseq_vx_u32m8(vand_vx_u32m8(v_src, 0xF, vl), 0xF, vl);\n\n        // Perform bitwise rotation\n        v_rotated = vor_vv_u32m8(vsrl_vx_u32m8(v_src, rotate_bits, vl),\n                                 vsll_vx_u32m8(v_src, 32 - rotate_bits, vl), vl);\n\n        // Perform bitwise negation\n        v_negated = vnot_v_u32m8(v_src, vl);\n\n        // Select result based on condition\n        v_dst = vmerge_vvm_u32m8(v_condition, v_rotated, v_negated, vl);\n\n        // Store result to destination vector\n        vse32_v_u32m8(&dst[i], v_dst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_48_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t vl;\n    vuint32m8_t v_src, v_dst, v_rotated, v_negated;\n    vbool4_t v_condition;\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n\n        // Load source vector\n        v_src = vle32_v_u32m8(&src[i], vl);\n\n        // Condition: Check if the low 4 bits are all 1\n        v_condition = vmseq_vx_u32m8_b4(vand_vx_u32m8(v_src, 0xF, vl), 0xF, vl);\n\n        // Rotate right by rotate_bits\n        v_rotated = vor_vv_u32m8(\n            vsrl_vx_u32m8(v_src, rotate_bits, vl),\n            vsll_vx_u32m8(v_src, 32 - rotate_bits, vl),\n            vl\n        );\n\n        // Bitwise negation\n        v_negated = vnot_v_u32m8(v_src, vl);\n\n        // Select based on condition\n        v_dst = vmerge_vvm_u32m8(v_condition, v_rotated, v_negated, vl);\n\n        // Store result to destination vector\n        vse32_v_u32m8(&dst[i], v_dst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_48_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t vl;\n    vuint32m8_t v_src, v_dst, v_rotated, v_negated;\n    vbool4_t v_condition;\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n\n        // Load source vector\n        v_src = vle32_v_u32m8(&src[i], vl);\n\n        // Create condition: low 4 bits are all 1 (0xF)\n        v_condition = vmseq_vx_u32m8_b4(vand_vx_u32m8(v_src, 0xF, vl), 0xF, vl);\n\n        // Rotate right by rotate_bits\n        v_rotated = vor_vv_u32m8(\n            vsrl_vx_u32m8(v_src, rotate_bits, vl),\n            vsll_vx_u32m8(v_src, 32 - rotate_bits, vl),\n            vl\n        );\n\n        // Bitwise negation\n        v_negated = vnot_v_u32m8(v_src, vl);\n\n        // Select based on condition\n        v_dst = vmerge_vvm_u32m8(v_condition, v_rotated, v_negated, vl);\n\n        // Store result to destination vector\n        vse32_v_u32m8(&dst[i], v_dst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_49_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t vl;\n    vfloat32m1_t va, vb, vdiff, vepsilon_pos, vepsilon_neg;\n    vmask_t mask_gt, mask_lt;\n    vint8m1_t vout;\n\n    // Broadcast epsilon and -epsilon to vector registers\n    vepsilon_pos = vfadd_vf_f32m1(vfmv_v_f_f32m1(0.0f, vl), epsilon, vl);\n    vepsilon_neg = vfsub_vf_f32m1(vfmv_v_f_f32m1(0.0f, vl), epsilon, vl);\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n\n        // Load vectors from A and B\n        va = vle32_v_f32m1(&A[i], vl);\n        vb = vle32_v_f32m1(&B[i], vl);\n\n        // Compute difference: A[i] - B[i]\n        vdiff = vfsub_vv_f32m1(va, vb, vl);\n\n        // Compare A[i] - B[i] > epsilon\n        mask_gt = vmfgt_vf_f32m1_b32(vdiff, epsilon, vl);\n\n        // Compare A[i] - B[i] < -epsilon\n        mask_lt = vmflt_vf_f32m1_b32(vdiff, -epsilon, vl);\n\n        // Initialize output vector with zeros\n        vout = vmv_v_x_i8m1(0, vl);\n\n        // Set output to 1 where A[i] - B[i] > epsilon\n        vout = vmerge_vxm_i8m1(vout, 1, mask_gt, vl);\n\n        // Set output to -1 where A[i] - B[i] < -epsilon\n        vout = vmerge_vxm_i8m1(vout, -1, mask_lt, vl);\n\n        // Store results to the output array\n        vse8_v_i8m1(&out[i], vout, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_49_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t vl;\n    vfloat32m1_t va, vb, vdiff, vabs_diff, vepsilon;\n    vmask_t mask_gt, mask_lt;\n    vint8m1_t vout;\n\n    // Broadcast epsilon to a vector register\n    vepsilon = vfadd_vf_f32m1(vepsilon, epsilon, vl);\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n\n        // Load vectors from A and B\n        va = vle32_v_f32m1(&A[i], vl);\n        vb = vle32_v_f32m1(&B[i], vl);\n\n        // Compute difference: A[i] - B[i]\n        vdiff = vfsub_vv_f32m1(va, vb, vl);\n\n        // Compute absolute difference: abs(A[i] - B[i])\n        vabs_diff = vfsgnjx_vv_f32m1(vdiff, vdiff, vl);\n\n        // Compare |A[i] - B[i]| > epsilon\n        mask_gt = vmfgt_vf_f32m1(vabs_diff, epsilon, vl);\n\n        // Compare |A[i] - B[i]| < -epsilon\n        mask_lt = vmflt_vf_f32m1(vabs_diff, -epsilon, vl);\n\n        // Initialize output vector with zeros\n        vout = vmv_v_x_i8m1(0, vl);\n\n        // Set output to 1 where |A[i] - B[i]| > epsilon\n        vout = vmerge_vxm_i8m1(vout, 1, mask_gt, vl);\n\n        // Set output to -1 where |A[i] - B[i]| < -epsilon\n        vout = vmerge_vxm_i8m1(vout, -1, mask_lt, vl);\n\n        // Store results to the output array\n        vse8_v_i8m1(&out[i], vout, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_49_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t vl;\n    vfloat32m1_t va, vb, vdiff, vepsilon_pos, vepsilon_neg;\n    vmask_t mask_gt, mask_lt;\n    vint8m1_t vout;\n\n    // Broadcast epsilon and -epsilon to vector registers\n    vepsilon_pos = vfadd_vf_f32m1(vfmv_v_f_f32m1(0.0f, vl), epsilon, vl);\n    vepsilon_neg = vfsub_vf_f32m1(vfmv_v_f_f32m1(0.0f, vl), epsilon, vl);\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n\n        // Load vectors from A and B\n        va = vle32_v_f32m1(&A[i], vl);\n        vb = vle32_v_f32m1(&B[i], vl);\n\n        // Compute difference: A[i] - B[i]\n        vdiff = vfsub_vv_f32m1(va, vb, vl);\n\n        // Compare A[i] - B[i] > epsilon\n        mask_gt = vmfgt_vf_f32m1_b32(vdiff, epsilon, vl);\n\n        // Compare A[i] - B[i] < -epsilon\n        mask_lt = vmflt_vf_f32m1_b32(vdiff, -epsilon, vl);\n\n        // Initialize output vector with zeros\n        vout = vmv_v_x_i8m1(0, vl);\n\n        // Set output to 1 where A[i] - B[i] > epsilon\n        vout = vmerge_vxm_i8m1(vout, 1, mask_gt, vl);\n\n        // Set output to -1 where A[i] - B[i] < -epsilon\n        vout = vmerge_vxm_i8m1(vout, -1, mask_lt, vl);\n\n        // Store results to the output array\n        vse8_v_i8m1(&out[i], vout, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_49_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t vl;\n    vfloat32m1_t va, vb, vdiff, vepsilon;\n    vmask_t mask_gt, mask_lt;\n    vint8m1_t vout;\n\n    // Broadcast epsilon to a vector register\n    vepsilon = vfsub_vv_f32m1(vfmv_v_f_f32m1(0.0f, vl), vfmv_v_f_f32m1(epsilon, vl), vl);\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n\n        // Load vectors from A and B\n        va = vle32_v_f32m1(&A[i], vl);\n        vb = vle32_v_f32m1(&B[i], vl);\n\n        // Compute difference: A[i] - B[i]\n        vdiff = vfsub_vv_f32m1(va, vb, vl);\n\n        // Compare |A[i] - B[i]| > epsilon\n        mask_gt = vmfgt_vf_f32m1(vdiff, epsilon, vl);\n        mask_lt = vmflt_vf_f32m1(vdiff, -epsilon, vl);\n\n        // Initialize output vector with zeros\n        vout = vmv_v_x_i8m1(0, vl);\n\n        // Set output to 1 where A[i] - B[i] > epsilon\n        vout = vmerge_vxm_i8m1(vout, 1, mask_gt, vl);\n\n        // Set output to -1 where A[i] - B[i] < -epsilon\n        vout = vmerge_vxm_i8m1(vout, -1, mask_lt, vl);\n\n        // Store results to the output array\n        vse8_v_i8m1(&out[i], vout, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_49_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t vl;\n    vfloat32m1_t va, vb, vdiff, vepsilon_pos, vepsilon_neg;\n    vmask_t mask_gt, mask_lt;\n    vint8m1_t vout;\n\n    // Broadcast epsilon and -epsilon to vector registers\n    vepsilon_pos = vfadd_vf_f32m1(vfmv_v_f_f32m1(0.0f, vl), epsilon, vl);\n    vepsilon_neg = vfsub_vf_f32m1(vfmv_v_f_f32m1(0.0f, vl), epsilon, vl);\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n\n        // Load vectors from A and B\n        va = vle32_v_f32m1(&A[i], vl);\n        vb = vle32_v_f32m1(&B[i], vl);\n\n        // Compute difference: A[i] - B[i]\n        vdiff = vfsub_vv_f32m1(va, vb, vl);\n\n        // Compare A[i] - B[i] > epsilon\n        mask_gt = vmfgt_vf_f32m1_b32(vdiff, epsilon, vl);\n\n        // Compare A[i] - B[i] < -epsilon\n        mask_lt = vmflt_vf_f32m1_b32(vdiff, -epsilon, vl);\n\n        // Initialize output vector with zeros\n        vout = vmv_v_x_i8m1(0, vl);\n\n        // Set output to 1 where A[i] - B[i] > epsilon\n        vout = vmerge_vxm_i8m1(vout, 1, mask_gt, vl);\n\n        // Set output to -1 where A[i] - B[i] < -epsilon\n        vout = vmerge_vxm_i8m1(vout, -1, mask_lt, vl);\n\n        // Store results to the output array\n        vse8_v_i8m1(&out[i], vout, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_50_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <limits.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t vl;\n    vfloat32m1_t vf;\n    vint32m1_t vi;\n    vbool32_t mask_gt, mask_lt;\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n\n        // Load float values from A\n        vf = vle32_v_f32m1(&A[i], vl);\n\n        // Create masks for saturation conditions\n        mask_gt = vmfgt_vf_f32m1_b32(vf, INT32_MAX, vl);\n        mask_lt = vmflt_vf_f32m1_b32(vf, INT32_MIN, vl);\n\n        // Convert float to int with saturation\n        vi = vfcvt_x_f_v_i32m1(vf, vl);\n\n        // Apply saturation logic\n        vi = vmerge_vx_i32m1(mask_gt, vi, INT32_MAX, vl);\n        vi = vmerge_vx_i32m1(mask_lt, vi, INT32_MIN, vl);\n\n        // Store the result into B\n        vse32_v_i32m1(&B[i], vi, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_50_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <limits.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t vl;\n    vfloat32m1_t vf;\n    vint32m1_t vi;\n    vbool32_t mask_gt, mask_lt;\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n\n        // Load float values from A\n        vf = vle32_v_f32m1(&A[i], vl);\n\n        // Convert float to int with saturation\n        vi = vfcvt_x_f_v_i32m1(vf, vl);\n\n        // Create masks for values greater than INT32_MAX and less than INT32_MIN\n        mask_gt = vmfgt_vf_f32m1_b32(vf, (float)INT32_MAX, vl);\n        mask_lt = vmflt_vf_f32m1_b32(vf, (float)INT32_MIN, vl);\n\n        // Saturate values greater than INT32_MAX to INT32_MAX\n        vi = vmerge_vxm_i32m1(vi, INT32_MAX, mask_gt, vl);\n\n        // Saturate values less than INT32_MIN to INT32_MIN\n        vi = vmerge_vxm_i32m1(vi, INT32_MIN, mask_lt, vl);\n\n        // Store the result into B\n        vse32_v_i32m1(&B[i], vi, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_50_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <limits.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t vl;\n    vfloat32m1_t vf;\n    vint32m1_t vi;\n    vbool32_t mask_gt, mask_lt;\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n\n        // Load float values from A\n        vf = vle32_v_f32m1(&A[i], vl);\n\n        // Create masks for values greater than INT32_MAX and less than INT32_MIN\n        mask_gt = vmfgt_vf_f32m1_b32(vf, (float)INT32_MAX, vl);\n        mask_lt = vmflt_vf_f32m1_b32(vf, (float)INT32_MIN, vl);\n\n        // Convert float to int with saturation\n        vi = vfcvt_x_f_v_i32m1(vf, vl);\n\n        // Saturate values greater than INT32_MAX\n        vi = vmerge_vx_i32m1(vi, INT32_MAX, mask_gt, vl);\n\n        // Saturate values less than INT32_MIN\n        vi = vmerge_vx_i32m1(vi, INT32_MIN, mask_lt, vl);\n\n        // Store the result into B\n        vse32_v_i32m1(&B[i], vi, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_50_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <limits.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t vl;\n    vfloat32m1_t vf;\n    vint32m1_t vi;\n    vbool32_t mask_gt, mask_lt;\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n\n        // Load vector of floats from A\n        vf = vle32_v_f32m1(&A[i], vl);\n\n        // Compare if values are greater than INT32_MAX\n        mask_gt = vmfgt_vf_f32m1_b32(vf, (float)INT32_MAX, vl);\n\n        // Compare if values are less than INT32_MIN\n        mask_lt = vmflt_vf_f32m1_b32(vf, (float)INT32_MIN, vl);\n\n        // Convert float to int with saturation\n        vi = vfcvt_x_f_v_i32m1(vf, vl);\n\n        // Apply masks to clamp values\n        vi = vmerge_vxm_i32m1(vi, INT32_MAX, mask_gt, vl);\n        vi = vmerge_vxm_i32m1(vi, INT32_MIN, mask_lt, vl);\n\n        // Store the result into B\n        vse32_v_i32m1(&B[i], vi, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_50_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <limits.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t vl;\n    size_t i = 0;\n\n    vfloat32m1_t vf;\n    vint32m1_t vi;\n    vbool32_t mask_gt, mask_lt;\n\n    const float int32_max_f = (float)INT32_MAX;\n    const float int32_min_f = (float)INT32_MIN;\n\n    for (; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n\n        vf = vle32_v_f32m1(&A[i], vl);\n\n        mask_gt = vmfgt_vf_f32m1_b32(vf, int32_max_f, vl);\n        mask_lt = vmflt_vf_f32m1_b32(vf, int32_min_f, vl);\n\n        vi = vfcvt_x_f_v_i32m1(vf, vl);\n\n        vi = vmerge_vx_i32m1(mask_gt, INT32_MAX, vi, vl);\n        vi = vmerge_vx_i32m1(mask_lt, INT32_MIN, vi, vl);\n\n        vse32_v_i32m1(&B[i], vi, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_51_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t vl;\n    vfloat32m1_t vf32;\n    vint32m1_t vi32;\n    vfloat32m1_t vscale = vfmv_v_f_f32m1((float)scale, vl);\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n        vi32 = vle32_v_i32m1(&A[i], vl);\n        vf32 = vfcvt_f_x_v_f32m1(vi32, vl);\n        vf32 = vfmul_vv_f32m1(vf32, vscale, vl);\n        vse32_v_f32m1(&B[i], vf32, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_51_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t vl;\n    vfloat32m1_t vf32;\n    vint32m1_t vi32;\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n        vi32 = vle32_v_i32m1(&A[i], vl);\n        vf32 = vfcvt_f_x_v_f32m1(vi32, vl);\n        vf32 = vfmul_vf_f32m1(vf32, (float)scale, vl);\n        vse32_v_f32m1(&B[i], vf32, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_51_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t vl;\n    vfloat32m1_t vf32;\n    vint32m1_t vi32;\n    vfloat32m1_t vscale = vfmv_v_f_f32m1((float)scale, vl); // Broadcast scale to vector\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n        vi32 = vle32_v_i32m1(&A[i], vl);           // Load int32 values from A\n        vf32 = vfcvt_f_x_v_f32m1(vi32, vl);        // Convert int32 to float32\n        vf32 = vfmul_vv_f32m1(vf32, vscale, vl);   // Scale the float values\n        vse32_v_f32m1(&B[i], vf32, vl);            // Store results into B\n    }\n}\n```"}
{"task_id": "SimdBench_51_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t vl;\n    vfloat32m1_t vf32;\n    vint32m1_t vi32;\n    vfloat32m1_t vscale = vfmv_v_f_f32m1((float)scale, vl);\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n        vi32 = vle32_v_i32m1(&A[i], vl);\n        vf32 = vfcvt_f_x_v_f32m1(vi32, vl);\n        vf32 = vfmul_vv_f32m1(vf32, vscale, vl);\n        vse32_v_f32m1(&B[i], vf32, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_51_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t vl;\n    vfloat32m1_t vf32;\n    vint32m1_t vi32;\n    const int32_t* pa = A;\n    float* pb = B;\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n        vi32 = vle32_v_i32m1(pa, vl);\n        vf32 = vfcvt_f_x_v_f32m1(vi32, vl);\n        vf32 = vfmul_vf_f32m1(vf32, (float)scale, vl);\n        vse32_v_f32m1(pb, vf32, vl);\n        pa += vl;\n        pb += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_52_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t vl;\n    vfloat32m1_t va, vb, vdiv;\n    vint32m1_t vresult;\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n\n        va = vle32_v_f32m1(&A[i], vl);\n        vb = vle32_v_f32m1(&B[i], vl);\n\n        vdiv = vfdiv_vv_f32m1(va, vb, vl);\n        vresult = vfcvt_x_f_v_i32m1(vdiv, vl);\n\n        vse32_v_i32m1(&C[i], vresult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_52_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < size) {\n        vl = vsetvl_e32m8(size - i);\n\n        vfloat32m8_t va = vle32_v_f32m8(&A[i], vl);\n        vfloat32m8_t vb = vle32_v_f32m8(&B[i], vl);\n\n        vfloat32m8_t vdiv = vfdiv_vv_f32m8(va, vb, vl);\n        vint32m8_t vrounded = vfcvt_x_f_v_i32m8(vdiv, vl);\n\n        vse32_v_i32m8(&C[i], vrounded, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_52_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < size) {\n        vl = vsetvl_e32m8(size - i);\n\n        vfloat32m8_t va = vle32_v_f32m8(&A[i], vl);\n        vfloat32m8_t vb = vle32_v_f32m8(&B[i], vl);\n\n        vfloat32m8_t vdiv = vfdiv_vv_f32m8(va, vb, vl);\n\n        vint32m8_t vrounded = vfcvt_x_f_v_i32m8(vdiv, vl);\n\n        vse32_v_i32m8(&C[i], vrounded, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_52_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t vl;\n    vfloat32m1_t va, vb, vdiv;\n    vint32m1_t vresult;\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n\n        va = vle32_v_f32m1(&A[i], vl);\n        vb = vle32_v_f32m1(&B[i], vl);\n\n        vdiv = vfdiv_vv_f32m1(va, vb, vl);\n        vresult = vfcvt_x_f_v_i32m1(vdiv, vl);\n\n        vse32_v_i32m1(&C[i], vresult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_52_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < size) {\n        vl = vsetvl_e32m8(size - i);\n\n        vfloat32m8_t va = vle32_v_f32m8(&A[i], vl);\n        vfloat32m8_t vb = vle32_v_f32m8(&B[i], vl);\n\n        vfloat32m8_t vdiv = vfdiv_vv_f32m8(va, vb, vl);\n        vint32m8_t vrounded = vfcvt_x_f_v_i32m8(vdiv, vl);\n\n        vse32_v_i32m8(&C[i], vrounded, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_53_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t vl;\n    vfloat64m1_t vmax = vfmv_v_f_f64m1(DBL_MAX, 1);\n    vfloat64m1_t vmin = vfmv_v_f_f64m1(-DBL_MAX, 1);\n    vfloat32m1_t vflt_max = vfmv_v_f_f32m1(FLT_MAX, 1);\n    vfloat32m1_t vflt_min = vfmv_v_f_f32m1(-FLT_MAX, 1);\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e64m1(size - i);\n        vfloat64m1_t vsrc = vle64_v_f64m1(&A[i], vl);\n        vbool64_t mask_gt = vmfgt_vf_f64m1_b64(vsrc, FLT_MAX, vl);\n        vbool64_t mask_lt = vmflt_vf_f64m1_b64(vsrc, -FLT_MAX, vl);\n\n        vfloat64m1_t vsaturated = vmerge_vvm_f64m1(mask_gt, vmax, vsrc, vl);\n        vsaturated = vmerge_vvm_f64m1(mask_lt, vmin, vsaturated, vl);\n\n        vfloat32m1_t vconverted = vfncvt_f_f_w_f32m1(vsaturated, vl);\n        vse32_v_f32m1(&B[i], vconverted, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_53_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t vl;\n    vfloat64m1_t vmax = vfmv_v_f_f64m1(DBL_MAX, 1);\n    vfloat64m1_t vmin = vfmv_v_f_f64m1(-DBL_MAX, 1);\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e64m1(size - i);\n        vfloat64m1_t va = vle64_v_f64m1(&A[i], vl);\n        vbool64_t mask_gt = vmfgt_vf_f64m1_b64(va, FLT_MAX, vl);\n        vbool64_t mask_lt = vmflt_vf_f64m1_b64(va, -FLT_MAX, vl);\n        vfloat64m1_t vsaturated = vfmerge_vfm_f64m1(mask_gt, FLT_MAX, va, vl);\n        vsaturated = vfmerge_vfm_f64m1(mask_lt, -FLT_MAX, vsaturated, vl);\n        vfloat32m2_t vcvt = vfncvt_f_f_w_f32m2(vsaturated, vl);\n        vse32_v_f32m2(&B[i], vcvt, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_53_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t vl;\n    vfloat64m1_t vmax = vfmv_v_f_f64m1(DBL_MAX, 1);\n    vfloat64m1_t vmin = vfmv_v_f_f64m1(-DBL_MAX, 1);\n    vfloat32m1_t vflt_max = vfmv_v_f_f32m1(FLT_MAX, 1);\n    vfloat32m1_t vflt_min = vfmv_v_f_f32m1(-FLT_MAX, 1);\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e64m1(size - i);\n        vfloat64m1_t vsrc = vle64_v_f64m1(&A[i], vl);\n        vbool64_t mask_gt = vmfgt_vf_f64m1_b64(vsrc, vmax, vl);\n        vbool64_t mask_lt = vmflt_vf_f64m1_b64(vsrc, vmin, vl);\n        vfloat64m1_t vsaturated = vfmerge_vfm_f64m1(mask_gt, vmax, vsrc, vl);\n        vsaturated = vfmerge_vfm_f64m1(mask_lt, vmin, vsaturated, vl);\n        vfloat32m1_t vconverted = vfncvt_f_f_w_f32m1(vsaturated, vl);\n        vse32_v_f32m1(&B[i], vconverted, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_53_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t vl;\n    size_t i = 0;\n\n    vfloat64m1_t vmax_double = vfmv_v_f_f64m1(DBL_MAX, 1);\n    vfloat64m1_t vmin_double = vfmv_v_f_f64m1(-DBL_MAX, 1);\n    vfloat32m1_t vmax_float = vfmv_v_f_f32m1(FLT_MAX, 1);\n    vfloat32m1_t vmin_float = vfmv_v_f_f32m1(-FLT_MAX, 1);\n\n    for (; i < size; i += vl) {\n        vl = vsetvl_e64m1(size - i);\n\n        vfloat64m1_t v_double = vle64_v_f64m1(&A[i], vl);\n\n        vbool64_t mask_gt = vmfgt_vf_f64m1_b64(v_double, FLT_MAX, vl);\n        vbool64_t mask_lt = vmflt_vf_f64m1_b64(v_double, -FLT_MAX, vl);\n\n        v_double = vfmin_vf_f64m1(v_double, FLT_MAX, vl);\n        v_double = vfmax_vf_f64m1(v_double, -FLT_MAX, vl);\n\n        vfloat32m1_t v_float = vfncvt_f_f_w_f32m1(v_double, vl);\n\n        vse32_v_f32m1(&B[i], v_float, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_53_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t vl;\n    vfloat64m1_t vmax_double = vfmv_v_f_f64m1(DBL_MAX, 1);\n    vfloat64m1_t vmin_double = vfmv_v_f_f64m1(-DBL_MAX, 1);\n    vfloat32m1_t vmax_float = vfmv_v_f_f32m1(FLT_MAX, 1);\n    vfloat32m1_t vmin_float = vfmv_v_f_f32m1(-FLT_MAX, 1);\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e64m1(size - i);\n        vfloat64m1_t v_double = vle64_v_f64m1(&A[i], vl);\n\n        // Clamp values to the range [-FLT_MAX, FLT_MAX]\n        vbool64_t mask_gt = vmfgt_vf_f64m1_b64(v_double, vmax_double, vl);\n        vbool64_t mask_lt = vmflt_vf_f64m1_b64(v_double, vmin_double, vl);\n        v_double = vfmerge_vfm_f64m1(mask_gt, vmax_double, v_double, vl);\n        v_double = vfmerge_vfm_f64m1(mask_lt, vmin_double, v_double, vl);\n\n        // Convert double to float\n        vfloat32m1_t v_float = vfncvt_f_f_w_f32m1(v_double, vl);\n\n        // Store results into destination array\n        vse32_v_f32m1(&B[i], v_float, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_54_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < size) {\n        vl = vsetvl_e16m8(size - i);\n        vint16m8_t vec_A = vle16_v_i16m8(&A[i], vl);\n        vint32m8_t vec_B = vwadd_vx_i32m8(vec_A, 0, vl);\n        vse32_v_i32m8(&B[i], vec_B, vl);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_54_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < size) {\n        vl = vsetvl_e16m8(size - i);\n        vint16m8_t vec_A = vle16_v_i16m8(&A[i], vl);\n        vint32m8_t vec_B = vwadd_vx_i32m8(vec_A, 0, vl);\n        vse32_v_i32m8(&B[i], vec_B, vl);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_54_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < size) {\n        vl = vsetvl_e16m8(size - i);\n        vint16m8_t vec_in = vle16_v_i16m8(&A[i], vl);\n        vint32m8_t vec_out = vwadd_vx_i32m8(vec_in, 0, vl);\n        vse32_v_i32m8(&B[i], vec_out, vl);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_54_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < size) {\n        vl = vsetvl_e16m8(size - i);\n        vint16m8_t vec_A = vle16_v_i16m8(&A[i], vl);\n        vint32m8_t vec_B = vwadd_vx_i32m8(vec_A, 0, vl);\n        vse32_v_i32m8(&B[i], vec_B, vl);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_54_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < size) {\n        vl = vsetvl_e16m8(size - i);\n        vint16m8_t vec_in = vle16_v_i16m8(&A[i], vl);\n        vint32m8_t vec_out = vwadd_vx_i32m8(vec_in, 0, vl);\n        vse32_v_i32m8(&B[i], vec_out, vl);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_55_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    size_t vl;\n    vfloat32m1_t va, vb, vmin, vmax, vnormalized;\n    vint32m1_t vcontrol;\n    vbool32_t mask_gt_zero, mask_normalized;\n\n    float range = max_val - min_val;\n    vmin = vfmv_v_f_f32m1(min_val, vl);\n    vmax = vfmv_v_f_f32m1(max_val, vl);\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n\n        // Load vectors\n        va = vle32_v_f32m1(&A[i], vl);\n        vcontrol = vle32_v_i32m1(&control[i], vl);\n\n        // Create mask for control > 0\n        mask_gt_zero = vmfgt_vx_i32m1_b32(vcontrol, 0, vl);\n\n        // Normalize where control > 0\n        vnormalized = vfsub_vv_f32m1(va, vmin, vl);\n        vnormalized = vfdiv_vf_f32m1(vnormalized, range, vl);\n\n        // Clamp normalized values to [0.0, 1.0]\n        mask_normalized = vmflt_vf_f32m1_b32(vnormalized, 0.0f, vl);\n        vnormalized = vmerge_vvm_f32m1(mask_normalized, vfadd_vv_f32m1(vnormalized, vnormalized, vl), 0.0f, vl);\n\n        mask_normalized = vmfgt_vf_f32m1_b32(vnormalized, 1.0f, vl);\n        vnormalized = vmerge_vvm_f32m1(mask_normalized, vfadd_vv_f32m1(vnormalized, vnormalized, vl), 1.0f, vl);\n\n        // Select between normalized and original values based on control\n        vb = vmerge_vvm_f32m1(mask_gt_zero, vnormalized, va, vl);\n\n        // Store results\n        vse32_v_f32m1(&B[i], vb, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_55_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    size_t vl;\n    vfloat32m1_t v_min_val = vfmv_v_f_f32m1(min_val, 1);\n    vfloat32m1_t v_max_val = vfmv_v_f_f32m1(max_val, 1);\n    vfloat32m1_t v_zero = vfmv_v_f_f32m1(0.0f, 1);\n    vfloat32m1_t v_one = vfmv_v_f_f32m1(1.0f, 1);\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n\n        vfloat32m1_t v_a = vle32_v_f32m1(&A[i], vl);\n        vint32m1_t v_control = vle32_v_i32m1(&control[i], vl);\n\n        vbool32_t mask = vmfgt_vx_i32m1_b32(v_control, 0, vl);\n\n        vfloat32m1_t v_normalized = vfsub_vv_f32m1(v_a, v_min_val, vl);\n        vfloat32m1_t v_denominator = vfsub_vv_f32m1(v_max_val, v_min_val, vl);\n        v_normalized = vfdiv_vv_f32m1(v_normalized, v_denominator, vl);\n\n        v_normalized = vfmax_vv_f32m1(v_normalized, v_zero, vl);\n        v_normalized = vfmin_vv_f32m1(v_normalized, v_one, vl);\n\n        vfloat32m1_t v_result = vmerge_vvm_f32m1(mask, v_normalized, v_a, vl);\n\n        vse32_v_f32m1(&B[i], v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_55_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    size_t vl;\n    vfloat32m1_t va, vb, vmin, vmax, vnormalized, vzero, vone;\n    vint32m1_t vcontrol;\n    vbool32_t mask;\n\n    float range = max_val - min_val;\n    vmin = vfmv_v_f_f32m1(min_val, vl);\n    vmax = vfmv_v_f_f32m1(max_val, vl);\n    vzero = vfmv_v_f_f32m1(0.0f, vl);\n    vone = vfmv_v_f_f32m1(1.0f, vl);\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n\n        va = vle32_v_f32m1(&A[i], vl);\n        vcontrol = vle32_v_i32m1(&control[i], vl);\n\n        // Compute normalized value: (A[i] - min_val) / (max_val - min_val)\n        vnormalized = vfsub_vv_f32m1(va, vmin, vl);\n        vnormalized = vfdiv_vf_f32m1(vnormalized, range, vl);\n\n        // Clamp values to [0, 1]\n        vnormalized = vfmax_vv_f32m1(vnormalized, vzero, vl);\n        vnormalized = vfmin_vv_f32m1(vnormalized, vone, vl);\n\n        // Create mask for control > 0\n        mask = vmfgt_vx_i32m1_b32(vcontrol, 0, vl);\n\n        // Select between normalized value and original value based on mask\n        vb = vmerge_vvm_f32m1(mask, vnormalized, va, vl);\n\n        // Store result to B\n        vse32_v_f32m1(&B[i], vb, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_55_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    size_t vl;\n    vfloat32m1_t va, vb, vmin, vmax, vnormalized;\n    vint32m1_t vcontrol;\n    vbool32_t mask_gt_zero, mask_normalized;\n\n    float range = max_val - min_val;\n    vmin = vfmv_v_f_f32m1(min_val, vl);\n    vmax = vfmv_v_f_f32m1(max_val, vl);\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n\n        // Load vectors\n        va = vle32_v_f32m1(&A[i], vl);\n        vcontrol = vle32_v_i32m1(&control[i], vl);\n\n        // Create mask for control > 0\n        mask_gt_zero = vmfgt_vx_i32m1_b32(vcontrol, 0, vl);\n\n        // Normalize where control > 0\n        vnormalized = vfsub_vv_f32m1(va, vmin, vl);\n        vnormalized = vfdiv_vf_f32m1(vnormalized, range, vl);\n\n        // Clamp normalized values to [0.0, 1.0]\n        vnormalized = vfmax_vf_f32m1(vnormalized, 0.0f, vl);\n        vnormalized = vfmin_vf_f32m1(vnormalized, 1.0f, vl);\n\n        // Select between normalized and original values based on control\n        vb = vmerge_vvm_f32m1(mask_gt_zero, vnormalized, va, vl);\n\n        // Store results\n        vse32_v_f32m1(&B[i], vb, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_55_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    size_t vl;\n    vfloat32m1_t va, vb, vmin, vmax, vnormalized;\n    vint32m1_t vcontrol;\n    vbool32_t mask_gt_zero, mask_normalized_lt_zero, mask_normalized_gt_one;\n\n    float range = max_val - min_val;\n    vmin = vfmv_v_f_f32m1(min_val, 1);\n    vmax = vfmv_v_f_f32m1(range, 1);\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n\n        // Load vectors\n        va = vle32_v_f32m1(&A[i], vl);\n        vcontrol = vle32_v_i32m1(&control[i], vl);\n\n        // Create mask for control > 0\n        mask_gt_zero = vmfgt_vx_i32m1_b32(vcontrol, 0, vl);\n\n        // Normalize where control > 0\n        vnormalized = vfsub_vv_f32m1(va, vmin, vl);\n        vnormalized = vfdiv_vv_f32m1(vnormalized, vmax, vl);\n\n        // Clamp normalized values to [0, 1]\n        mask_normalized_lt_zero = vmflt_vf_f32m1_b32(vnormalized, 0.0f, vl);\n        mask_normalized_gt_one = vmfgt_vf_f32m1_b32(vnormalized, 1.0f, vl);\n        vnormalized = vmerge_vvm_f32m1(mask_normalized_lt_zero, vfadd_vv_f32m1(vnormalized, vnormalized, vl), 0.0f, vl);\n        vnormalized = vmerge_vvm_f32m1(mask_normalized_gt_one, vfadd_vv_f32m1(vnormalized, vnormalized, vl), 1.0f, vl);\n\n        // Select between normalized and original values based on control\n        vb = vmerge_vvm_f32m1(mask_gt_zero, vnormalized, va, vl);\n\n        // Store results\n        vse32_v_f32m1(&B[i], vb, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_56_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl;\n    vuint32m8_t vec_A;\n    vfloat32m8_t vec_B;\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n\n        // Load vector of uint32_t from A\n        vec_A = vle32_v_u32m8(&A[i], vl);\n\n        // Shift right by 16 bits to extract the high 16 bits\n        vec_A = vsrl_vx_u32m8(vec_A, 16, vl);\n\n        // Convert uint32_t to float32\n        vec_B = vfcvt_f_x_v_f32m8(vec_A, vl);\n\n        // Compute square root of the float values\n        vec_B = vfsqrt_v_f32m8(vec_B, vl);\n\n        // Store the result into B\n        vse32_v_f32m8(&B[i], vec_B, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_56_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl;\n    vuint32m8_t vec_A;\n    vfloat32m8_t vec_B;\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n\n        // Load vector of uint32_t from A\n        vec_A = vle32_v_u32m8(&A[i], vl);\n\n        // Shift right by 16 bits to extract the high 16 bits\n        vec_A = vsrl_vx_u32m8(vec_A, 16, vl);\n\n        // Convert uint32_t to float32\n        vec_B = vfcvt_f_x_v_f32m8(vec_A, vl);\n\n        // Compute square root of the float values\n        vec_B = vfsqrt_v_f32m8(vec_B, vl);\n\n        // Store the result into B\n        vse32_v_f32m8(&B[i], vec_B, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_56_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl;\n    vuint32m8_t vec_A;\n    vfloat32m8_t vec_B;\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n\n        // Load vector of uint32_t from A\n        vec_A = vle32_v_u32m8(&A[i], vl);\n\n        // Shift right by 16 bits to extract the high 16 bits\n        vec_A = vsrl_vx_u32m8(vec_A, 16, vl);\n\n        // Convert uint32_t to float32\n        vec_B = vfcvt_f_x_v_f32m8(vec_A, vl);\n\n        // Compute square root of the float values\n        vec_B = vfsqrt_v_f32m8(vec_B, vl);\n\n        // Store the result into B\n        vse32_v_f32m8(&B[i], vec_B, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_56_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl;\n    vuint32m8_t vec_A;\n    vfloat32m8_t vec_B;\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n\n        // Load vector of uint32_t from A\n        vec_A = vle32_v_u32m8(&A[i], vl);\n\n        // Shift right by 16 bits to extract the high 16 bits\n        vec_A = vsrl_vx_u32m8(vec_A, 16, vl);\n\n        // Convert uint32_t to float32\n        vec_B = vfcvt_f_x_v_f32m8(vec_A, vl);\n\n        // Compute square root of the float values\n        vec_B = vfsqrt_v_f32m8(vec_B, vl);\n\n        // Store the result into B\n        vse32_v_f32m8(&B[i], vec_B, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_56_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl;\n    vuint32m8_t vec_A;\n    vfloat32m8_t vec_B;\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n\n        // Load vector of uint32_t from A\n        vec_A = vle32_v_u32m8(&A[i], vl);\n\n        // Shift right by 16 bits to extract the high 16 bits\n        vec_A = vsrl_vx_u32m8(vec_A, 16, vl);\n\n        // Convert uint32_t to float32\n        vec_B = vfcvt_f_x_v_f32m8(vec_A, vl);\n\n        // Compute square root of the float values\n        vec_B = vfsqrt_v_f32m8(vec_B, vl);\n\n        // Store the result into B\n        vse32_v_f32m8(&B[i], vec_B, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_57_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < size) {\n        vl = vsetvl_e32m8(size - i);\n\n        vuint32m8_t vec_uint = vle32_v_u32m8(&A[i], vl);\n        vfloat32m8_t vec_float = vreinterpret_v_u32m8_f32m8(vec_uint);\n        vse32_v_f32m8(&B[i], vec_float, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_57_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < size) {\n        vl = vsetvl_e32m8(size - i);\n        vuint32m8_t v_uint = vle32_v_u32m8(&A[i], vl);\n        vfloat32m8_t v_float = vreinterpret_v_u32m8_f32m8(v_uint);\n        vse32_v_f32m8(&B[i], v_float, vl);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_57_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < size) {\n        vl = vsetvl_e32m8(size - i);\n        vuint32m8_t v_uint = vle32_v_u32m8(&A[i], vl);\n        vfloat32m8_t v_float = vreinterpret_v_u32m8_f32m8(v_uint);\n        vse32_v_f32m8(&B[i], v_float, vl);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_57_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl;\n    vuint32m8_t v_uint;\n    vfloat32m8_t v_float;\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n        v_uint = vle32_v_u32m8(&A[i], vl);\n        v_float = vreinterpret_v_u32m8_f32m8(v_uint);\n        vse32_v_f32m8(&B[i], v_float, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_57_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < size) {\n        vl = vsetvl_e32m8(size - i);\n\n        vuint32m8_t vec_uint = vle32_v_u32m8(&A[i], vl);\n        vfloat32m8_t vec_float = vreinterpret_v_u32m8_f32m8(vec_uint);\n\n        vse32_v_f32m8(&B[i], vec_float, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_58_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    size_t vl;\n    size_t i = 0;\n\n    // Set the first element of diff to 0.0f\n    diff[0] = 0.0f;\n    i = 1;\n\n    while (i < size) {\n        // Set vector length for current stripmining loop\n        vl = vsetvl_e32m8(size - i);\n\n        // Load vectors from A, cond, and compute differences\n        vint32m8_t vec_A = vle32_v_i32m8(&A[i], vl);\n        vint32m8_t vec_A_prev = vle32_v_i32m8(&A[i - 1], vl);\n        vbool4_t vec_cond = vmseq_vx_i8mf8(vle8_v_i8mf8((const int8_t*)&cond[i], vl), 1, vl);\n\n        // Compute difference between consecutive elements\n        vint32m8_t vec_diff_int = vsub_vv_i32m8(vec_A, vec_A_prev, vl);\n\n        // Convert integer differences to float\n        vfloat32m8_t vec_diff_float = vcvt_f_x_v_f32m8(vec_diff_int, vl);\n\n        // Create a zero vector for masking\n        vfloat32m8_t vec_zero = vfmv_v_f_f32m8(0.0f, vl);\n\n        // Apply mask: set diff[i] to 0.0f where cond[i] is false\n        vfloat32m8_t vec_result = vmerge_vvm_f32m8(vec_cond, vec_diff_float, vec_zero, vl);\n\n        // Store the result back to diff array\n        vse32_v_f32m8(&diff[i], vec_result, vl);\n\n        // Increment index by vector length\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_58_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    size_t vl;\n    size_t i = 0;\n\n    // Set the first element of diff to 0.0f\n    diff[0] = 0.0f;\n    i = 1;\n\n    while (i < size) {\n        // Set vector length for the current stripmined loop\n        vl = vsetvl_e32m8(size - i);\n\n        // Load vectors of A[i] and A[i-1]\n        vint32m8_t vec_Ai = vle32_v_i32m8(&A[i], vl);\n        vint32m8_t vec_Ai_prev = vle32_v_i32m8(&A[i - 1], vl);\n\n        // Compute differences: A[i] - A[i-1]\n        vint32m8_t vec_diff_int = vsub_vv_i32m8(vec_Ai, vec_Ai_prev, vl);\n\n        // Load condition array as a mask\n        vbool32_t vec_cond = vmseq_vx_i32m8(vle8_v_i8m1((const int8_t*)&cond[i], vl), 1, vl);\n\n        // Convert differences to float\n        vfloat32m8_t vec_diff_float = vcvt_f_x_v_f32m8(vec_diff_int, vl);\n\n        // Create a zero vector for false conditions\n        vfloat32m8_t vec_zero = vfmv_v_f_f32m8(0.0f, vl);\n\n        // Select between computed difference and zero based on condition\n        vfloat32m8_t vec_result = vmerge_vvm_f32m8(vec_cond, vec_diff_float, vec_zero, vl);\n\n        // Store the result into diff array\n        vse32_v_f32m8(&diff[i], vec_result, vl);\n\n        // Increment index by vector length\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_58_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    size_t vl;\n    size_t i = 0;\n\n    // Set the first element of diff to 0.0f\n    diff[0] = 0.0f;\n\n    // Process the rest of the array in vectorized manner\n    for (i = 1; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n\n        // Load vectors\n        vint32m8_t vec_A = vle32_v_i32m8(&A[i], vl);\n        vint32m8_t vec_A_prev = vle32_v_i32m8(&A[i - 1], vl);\n        vbool32_t vec_cond = vmseq_vx_i32m8_b32(vle32_v_i32m8((const int32_t*)&cond[i], vl), 1, vl);\n\n        // Compute differences\n        vint32m8_t vec_diff_int = vsub_vv_i32m8(vec_A, vec_A_prev, vl);\n\n        // Convert differences to float\n        vfloat32m8_t vec_diff_float = vcvt_f_x_v_f32m8(vec_diff_int, vl);\n\n        // Create a zero vector\n        vfloat32m8_t vec_zero = vfmv_v_f_f32m8(0.0f, vl);\n\n        // Select based on condition: if cond[i] is true, use diff, else use 0.0f\n        vfloat32m8_t vec_result = vmerge_vvm_f32m8(vec_cond, vec_diff_float, vec_zero, vl);\n\n        // Store results back to memory\n        vse32_v_f32m8(&diff[i], vec_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_58_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    size_t vl;\n    size_t i = 0;\n\n    // Set the first element of diff to 0.0f\n    diff[0] = 0.0f;\n    i = 1;\n\n    while (i < size) {\n        // Set vector length for the current stripmined loop iteration\n        vl = vsetvl_e32m8(size - i);\n\n        // Load vectors of A[i] and A[i-1]\n        vint32m8_t vec_A_i = vle32_v_i32m8(&A[i], vl);\n        vint32m8_t vec_A_im1 = vle32_v_i32m8(&A[i - 1], vl);\n\n        // Compute differences between consecutive elements\n        vint32m8_t vec_diff_int = vsub_vv_i32m8(vec_A_i, vec_A_im1, vl);\n\n        // Load condition array as a mask\n        vbool32_t vec_cond = vmseq_vx_i32m8_b32(vle32_v_i32m8((const int32_t*)&cond[i], vl), 1, vl);\n\n        // Convert integer differences to float\n        vfloat32m8_t vec_diff_float = vcvt_f_x_v_f32m8(vec_diff_int, vl);\n\n        // Create a zero vector for false conditions\n        vfloat32m8_t vec_zero = vfmv_v_f_f32m8(0.0f, vl);\n\n        // Select between computed difference and zero based on the condition\n        vfloat32m8_t vec_result = vmerge_vvm_f32m8(vec_cond, vec_diff_float, vec_zero, vl);\n\n        // Store the result into the diff array\n        vse32_v_f32m8(&diff[i], vec_result, vl);\n\n        // Increment loop counter\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_58_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    size_t vl;\n    size_t i = 0;\n\n    // Set the first element of diff to 0.0f\n    diff[0] = 0.0f;\n\n    // Process the rest of the elements in vectorized manner\n    for (i = 1; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n\n        // Load vectors\n        vint32m8_t vec_A = vle32_v_i32m8(&A[i], vl);\n        vint32m8_t vec_A_prev = vle32_v_i32m8(&A[i - 1], vl);\n        vbool8_t vec_cond = vmseq_vx_i8mf8(vle8_v_i8mf8((const int8_t*)&cond[i], vl), 1, vl);\n\n        // Compute differences\n        vint32m8_t vec_diff_int = vsub_vv_i32m8(vec_A, vec_A_prev, vl);\n\n        // Convert differences to float\n        vfloat32m8_t vec_diff_float = vcvt_f_x_v_f32m8(vec_diff_int, vl);\n\n        // Create a zero vector\n        vfloat32m8_t vec_zero = vfmv_v_f_f32m8(0.0f, vl);\n\n        // Select based on condition\n        vfloat32m8_t vec_result = vmerge_vvm_f32m8(vec_cond, vec_diff_float, vec_zero, vl);\n\n        // Store results\n        vse32_v_f32m8(&diff[i], vec_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_59_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e32m8(length - i);\n        vuint32m8_t v_src = vle32_v_u32m8(&src[i], vl);\n        vuint64m8_t v_widened = vwaddu_vx_u64m8(v_src, 0, vl);\n        vuint64m8_t v_result = vor_vx_u64m8(v_widened, 0xFFFFFFFF00000000ULL, vl);\n        vse64_v_u64m8(&dst[i], v_result, vl);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_59_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e32m8(length - i);\n\n        vuint32m8_t src_vec = vle32_v_u32m8(&src[i], vl);\n        vuint64m8_t dst_vec = vwaddu_vx_u64m8(src_vec, 0, vl);\n        dst_vec = vor_vx_u64m8(dst_vec, 0xFFFFFFFF00000000ULL, vl);\n\n        vse64_v_u64m8(&dst[i], dst_vec, vl);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_59_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e32m8(length - i);\n        vuint32m8_t v_src = vle32_v_u32m8(&src[i], vl);\n        vuint64m8_t v_widened = vwaddu_vx_u64m8(v_src, 0, vl);\n        vuint64m8_t v_result = vor_vx_u64m8(v_widened, 0xFFFFFFFF00000000ULL, vl);\n        vse64_v_u64m8(&dst[i], v_result, vl);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_59_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e32m8(length - i);\n\n        vuint32m8_t src_vec = vle32_v_u32m8(&src[i], vl);\n        vuint64m8_t dst_vec = vwaddu_vx_u64m8(src_vec, 0, vl);\n        dst_vec = vor_vx_u64m8(dst_vec, 0xFFFFFFFF00000000ULL, vl);\n\n        vse64_v_u64m8(&dst[i], dst_vec, vl);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_59_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t vl;\n    size_t i = 0;\n\n    while (i < length) {\n        vl = vsetvl_e32m8(length - i);\n\n        vuint32m8_t src_vec = vle32_v_u32m8(&src[i], vl);\n        vuint64m8_t dst_vec = vwaddu_vx_u64m8(src_vec, 0, vl);\n        dst_vec = vor_vx_u64m8(dst_vec, 0xFFFFFFFF00000000ULL, vl);\n\n        vse64_v_u64m8(&dst[i], dst_vec, vl);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_60_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    size_t vl;\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16m2(length - i);\n\n        // Load indices as int16\n        vint16m2_t v_index = vle16_v_i16m2(&index[i], vl);\n\n        // Widen indices to int32 for addressing\n        vint32m4_t v_index_wide = vwadd_vx_i32m4(v_index, 0, vl);\n\n        // Gather elements from vec using the widened indices\n        vfloat64m8_t v_gathered = vrgather_vv_f64m8(vle64_v_f64m8(vec, vl), v_index_wide, vl);\n\n        // Reduce the gathered elements into a scalar sum\n        sum += vfmv_f_s_f64m8_f64(vfredsum_vs_f64m8_f64m1(v_gathered, vfredusum_vs_f64m8_f64m1(v_gathered, vl)));\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    size_t i = 0;\n\n    // Initialize vector registers\n    vfloat64m1_t v_sum = vfmv_v_f_f64m1(0.0, vsetvlmax_e64m1());\n    vint16mf2_t v_index;\n    vfloat64m1_t v_vec_values;\n\n    while (i < length) {\n        size_t vl = vsetvl_e16mf2(length - i);\n\n        // Load indices\n        v_index = vle16_v_i16mf2(index + i, vl);\n\n        // Gather values from vec using indices\n        v_vec_values = vrgather_vv_f64m1(vle64_v_f64m1(vec, vl), v_index, vl);\n\n        // Accumulate the gathered values into the sum vector\n        v_sum = vfadd_vv_f64m1(v_sum, v_vec_values, vl);\n\n        i += vl;\n    }\n\n    // Reduce the vector sum to a scalar\n    sum = vfmv_f_s_f64m1_f64(vfredsum_vs_f64m1_f64m1(v_sum, v_sum, vfmv_v_f_f64m1(0.0, vsetvlmax_e64m1()), vsetvlmax_e64m1()));\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    size_t vl;\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16m2(length - i);\n\n        // Load indices\n        vint16m2_t v_index = vle16_v_i16m2(index + i, vl);\n\n        // Convert indices to unsigned for gather load\n        vuint16m2_t v_uindex = vreinterpret_u16m2(v_index);\n\n        // Gather-load the values from vec using the indices\n        vfloat64m4_t v_vec_vals = vloxei16_v_f64m4(vec, v_uindex, vl);\n\n        // Reduce the vector elements into a scalar sum\n        vfloat64m1_t v_sum = vfmv_v_f_f64m1(0.0, vl);\n        v_sum = vfredsum_vs_f64m4_f64m1(v_sum, v_vec_vals, v_sum, vl);\n\n        // Extract the reduced sum and add it to the total sum\n        sum += vfmv_f_s_f64m1_f64(v_sum);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    size_t i = 0;\n\n    // RVV setup\n    vfloat64m1_t vsum = vfmv_v_f_f64m1(0.0, vl); // Initialize vector accumulator to 0.0\n    vint16mf2_t vindex;                          // Vector for loading indices\n    vfloat64m1_t vvec;                           // Vector for gathering values from vec\n\n    // Determine the vector register length\n    size_t vlmax = vsetvlmax_e64m1();            // Maximum vector length for float64\n\n    // Main SIMD loop\n    for (; i + vlmax <= length; i += vlmax) {\n        // Load indices\n        vindex = vle16_v_i16mf2(index + i, vlmax);\n\n        // Gather values from vec using indices\n        vvec = vrgather_vv_f64m1(vec, vindex, vlmax);\n\n        // Accumulate into vector sum\n        vsum = vfadd_vv_f64m1(vsum, vvec, vlmax);\n    }\n\n    // Reduce vector sum to scalar\n    sum = vfmv_f_s_f64m1_f64(vfredsum_vs_f64m1_f64m1(vsum, vsum, vlmax));\n\n    // Handle remaining elements (tail processing)\n    for (; i < length; i++) {\n        sum += vec[index[i]];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    size_t vl;\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16m2(length - i);\n\n        vint16m2_t v_index = vle16_v_i16m2(index + i, vl);\n        vbool8_t mask = vmflt_vx_i16m2_b8(v_index, length, vl);\n\n        vint16m2_t masked_index = vmerge_vxm_i16m2(v_index, 0, mask, vl);\n        vfloat64m4_t v_vec_vals = vfwcvt_f_x_v_f64m4(masked_index, vl);\n\n        vfloat64m4_t v_gathered = vrgather_vv_f64m4(v_vec_vals, masked_index, vl);\n        vfloat64m1_t v_reduced = vfredsum_vs_f64m4_f64m1(v_gathered, vfadd_vv_f64m4, vl);\n\n        double temp_sum;\n        vse64_v_f64m1(&temp_sum, v_reduced, 1);\n        sum += temp_sum;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_61_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    size_t vl;\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n\n            // Vectorized convolution operation\n            for (size_t ki = 0; ki < kernel_size; ki += vl) {\n                vl = vsetvl_e64m8(kernel_size - ki);\n\n                vfloat64m8_t v_kernel = vle64_v_f64m8(&kernel[ki * kernel_size], vl);\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    vfloat64m8_t v_input = vle64_v_f64m8(&input[(i + ki) * input_size + j + kj], vl);\n                    vfloat64m8_t v_mul = vfmul_vv_f64m8(v_input, v_kernel, vl);\n                    sum += vfredsum_vs_f64m8_f64m1(v_mul, vfmv_s_f_f64m1(0.0), vl);\n                }\n            }\n\n            // Apply ReLU activation\n            output[i * output_size + j] = (sum > 0.0) ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    size_t vl;\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n\n            // Vectorized convolution computation\n            for (size_t ki = 0; ki < kernel_size; ki += vl) {\n                vl = vsetvl_e64m8(kernel_size - ki);\n\n                vfloat64m8_t v_kernel, v_input, v_sum_vec;\n                v_sum_vec = vfmv_v_f_f64m8(0.0, vl);\n\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    // Load kernel values\n                    v_kernel = vle64_v_f64m8(&kernel[(ki * kernel_size) + kj], vl);\n                    \n                    // Load corresponding input values\n                    v_input = vle64_v_f64m8(&input[((i + ki) * input_size) + (j + kj)], vl);\n\n                    // Multiply and accumulate\n                    v_sum_vec = vfmacc_vv_f64m8(v_sum_vec, v_kernel, v_input, vl);\n                }\n\n                // Reduce the vector sum to a scalar\n                sum += vfredsum_vs_f64m8_f64m1(v_sum_vec, v_sum_vec, vfmv_s_f_f64m1(0.0), vl);\n            }\n\n            // Apply ReLU activation\n            output[i * output_size + j] = (sum > 0.0) ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    size_t vl;\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n\n            // Vectorized convolution computation\n            for (size_t ki = 0; ki < kernel_size; ki += vl) {\n                vl = vsetvl_e64m1(kernel_size - ki);\n\n                vfloat64m1_t v_kernel = vle64_v_f64m1(&kernel[ki * kernel_size], vl);\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    vfloat64m1_t v_input = vle64_v_f64m1(&input[(i + ki) * input_size + j + kj], vl);\n                    vfloat64m1_t v_mul = vfmul_vv_f64m1(v_input, v_kernel, vl);\n                    sum += vfredsum_vs_f64m1_f64m1(v_mul, v_mul, vl);\n                }\n            }\n\n            // Apply ReLU activation\n            output[i * output_size + j] = (sum > 0.0) ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    size_t vl;\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n\n            // Vectorized convolution computation\n            for (size_t ki = 0; ki < kernel_size; ki += vl) {\n                vl = vsetvl_e64m8(kernel_size - ki);\n\n                vfloat64m8_t v_kernel = vle64_v_f64m8(&kernel[ki * kernel_size], vl);\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    size_t idx = (i + ki) * input_size + (j + kj);\n                    vfloat64m8_t v_input = vle64_v_f64m8(&input[idx], vl);\n                    vfloat64m8_t v_mul = vfmul_vv_f64m8(v_input, v_kernel, vl);\n                    sum += vfredsum_vs_f64m8_f64m1(v_mul, vfmv_s_f_f64m1(0.0), vl);\n                }\n            }\n\n            // Apply ReLU activation\n            output[i * output_size + j] = (sum > 0.0) ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    size_t kernel_elements = kernel_size * kernel_size;\n\n    // Load kernel into vector registers once (assuming kernel fits in vector registers)\n    vfloat64m1_t vk[kernel_size * kernel_size];\n    for (size_t i = 0; i < kernel_elements; ++i) {\n        vk[i] = vfmv_v_f_f64m1(kernel[i], vsetvl_e64m1(1));\n    }\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            vfloat64m1_t vacc = vfmv_v_f_f64m1(0.0, vsetvl_e64m1(1)); // Initialize accumulator to 0\n\n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    size_t input_idx = (i + ki) * input_size + (j + kj);\n                    vfloat64m1_t vx = vle64_v_f64m1(&input[input_idx], vsetvl_e64m1(1));\n                    vacc = vfmacc_vv_f64m1(vacc, vx, vk[ki * kernel_size + kj], vsetvl_e64m1(1));\n                }\n            }\n\n            // Reduce the vector accumulator to a scalar\n            double result = vfmv_f_s_f64m1_f64(vacc);\n\n            // Apply ReLU activation\n            if (result < 0.0) {\n                result = 0.0;\n            }\n\n            // Store the result in the output array\n            output[i * output_size + j] = result;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_62_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t vlmax = vsetvlmax_e64m8();\n    size_t n = numbers.size();\n    bool result = false;\n\n    for (size_t i = 0; i < n; i++) {\n        const double *base = &numbers[i];\n        size_t remaining = n - i - 1;\n        size_t vl;\n\n        while (remaining > 0) {\n            vl = vsetvl_e64m8(remaining);\n            vfloat64m8_t vec1 = vle64_v_f64m8(base, vl);\n            vfloat64m8_t vec2 = vle64_v_f64m8(&numbers[i + 1], vl);\n\n            vfloat64m8_t diff = vfsub_vv_f64m8(vec1, vec2, vl);\n            vfloat64m8_t abs_diff = vfsgnjx_vv_f64m8(diff, diff, vl);\n            vmask_t mask = vmflt_vf_f64m8_b(abs_diff, threshold, vl);\n\n            if (vcpop_m(mask, vl) > 0) {\n                return true;\n            }\n\n            base += vl;\n            remaining -= vl;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_62_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t vlmax = vsetvlmax_e64m8();\n    size_t n = numbers.size();\n    bool result = false;\n\n    for (size_t i = 0; i < n; ++i) {\n        const double *base = &numbers[i];\n        size_t j = i + 1;\n        while (j < n) {\n            size_t vl = vsetvl_e64m8(n - j);\n            vfloat64m8_t vec1 = vle64_v_f64m8(&numbers[j], vl);\n            vfloat64m8_t vec2 = vfsub_vf_f64m8(vec1, base[0], vl);\n            vfloat64m8_t vec_abs = vfsgnjx_vv_f64m8(vec2, vec2, vl);\n            vbool8_t mask = vmflt_vf_f64m8_b8(vec_abs, threshold, vl);\n\n            if (vfirst_m_b8(mask, vl) != -1) {\n                return true;\n            }\n            j += vl;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_62_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n < 2) return false;\n\n    bool result = false;\n    size_t i = 0;\n\n    // Load the threshold value into a vector register for comparison\n    vfloat64m1_t v_threshold = vfmv_v_f_f64m1(threshold, vsetvlmax_e64m1());\n\n    while (i < n) {\n        size_t vl = vsetvl_e64m1(n - i);\n\n        // Load the current chunk of numbers into a vector\n        vfloat64m1_t v_a = vle64_v_f64m1(&numbers[i], vl);\n\n        for (size_t j = i + 1; j < n; j += vl) {\n            size_t vl_inner = vsetvl_e64m1(n - j);\n            vfloat64m1_t v_b = vle64_v_f64m1(&numbers[j], vl_inner);\n\n            // Compute absolute differences between elements of v_a and v_b\n            vfloat64m1_t v_diff = vfsub_vv_f64m1(v_a, v_b, vl_inner);\n            vfloat64m1_t v_abs_diff = vfsgnjx_vv_f64m1(v_diff, v_diff, vl_inner);\n\n            // Compare absolute differences with the threshold\n            vbool64_t v_cmp = vmflt_vf_f64m1_b64(v_abs_diff, v_threshold, vl_inner);\n\n            // Check if any element in the comparison is true\n            if (vmseq_vx_i64m1_b64(v_cmp, 1, vl_inner)) {\n                result = true;\n                break;\n            }\n        }\n\n        if (result) break;\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_62_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t vlmax = vsetvlmax_e64m8();\n    size_t n = numbers.size();\n    bool result = false;\n\n    for (size_t i = 0; i < n; i++) {\n        const double *base = &numbers[i];\n        size_t j = i + 1;\n        while (j < n) {\n            size_t vl = vsetvl_e64m8(n - j);\n            vfloat64m8_t vec1 = vle64_v_f64m8(&numbers[j], vl);\n            vfloat64m8_t vec2 = vfmv_v_f_f64m8(base[0], vl);\n            vfloat64m8_t diff = vfsub_vv_f64m8(vec1, vec2, vl);\n            vbool8_t mask = vmflt_vf_f64m8(diff, threshold, vl);\n\n            if (vmseq_vx_i8mf8_b8(mask, 1)) {\n                return true;\n            }\n            j += vl;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_62_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t vlmax = vsetvlmax_e64m8();\n    size_t n = numbers.size();\n    bool result = false;\n\n    for (size_t i = 0; i < n; i++) {\n        const double *base = &numbers[i];\n        size_t remaining = n - i - 1;\n        size_t vl;\n\n        while (remaining > 0) {\n            vl = vsetvl_e64m8(remaining);\n            vfloat64m8_t vec1 = vle64_v_f64m8(base, vl);\n            vfloat64m8_t vec2 = vle64_v_f64m8(&numbers[i + 1], vl);\n\n            vfloat64m8_t diff = vfsub_vv_f64m8(vec1, vec2, vl);\n            vfloat64m8_t abs_diff = vfsgnjx_vv_f64m8(diff, diff, vl); // Absolute value\n            vbool8_t mask = vmflt_vf_f64m8_b8(abs_diff, threshold, vl);\n\n            if (vmseq_vx_i8mf8_b8(mask, 1, vl)) {\n                return true;\n            }\n\n            base += vl;\n            remaining -= vl;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_63_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool below_zero_simd(std::vector<int> operations) {\n    size_t vlmax = vsetvlmax_e32m8();\n    size_t n = operations.size();\n    int balance = 0;\n    size_t i = 0;\n\n    while (i < n) {\n        size_t vl = vsetvl_e32m8(n - i);\n        vint32m8_t vec_ops = vle32_v_i32m8(operations.data() + i, vl);\n\n        // Accumulate the sum of operations in parallel\n        vint32m8_t vec_balance = vmv_v_x_i32m8(balance, vl);\n        vec_balance = vadd_vv_i32m8(vec_balance, vec_ops, vl);\n\n        // Check if any balance goes below zero\n        vbool4_t vec_below_zero = vmslt_vx_i32m8_b4(vec_balance, 0, vl);\n        if (vmseq_vx_i1(vfirst_m_b4(vec_below_zero), 1)) {\n            return true;\n        }\n\n        // Update the scalar balance with the last element of vectorized balance\n        balance = vget_v_i32m8_i32(vec_balance, vl - 1);\n\n        i += vl;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool below_zero_simd(std::vector<int> operations) {\n    size_t vlmax = vsetvlmax_e32m8();\n    size_t n = operations.size();\n    int balance = 0;\n    size_t i = 0;\n\n    while (i < n) {\n        size_t vl = vsetvl_e32m8(n - i);\n        vint32m8_t vec_ops = vle32_v_i32m8(&operations[i], vl);\n\n        // Accumulate the operations into a vector of balances\n        vint32m8_t vec_balance = vmul_vx_i32m8(vec_ops, 0, vl); // Initialize with zeros\n        vec_balance = vadd_vx_i32m8(vec_balance, balance, vl);\n\n        // Perform a cumulative sum within the vector\n        for (size_t j = 1; j < vl; ++j) {\n            vec_balance = vfadd_vv_i32m8(vec_balance, vec_ops, vl);\n        }\n\n        // Check if any balance is below zero\n        vbool4_t below_zero_mask = vmflt_vx_i32m8_b4(vec_balance, 0, vl);\n        if (vmseq_vx_i1(vfirst_m_b4(below_zero_mask), 1)) {\n            return true;\n        }\n\n        // Update the scalar balance with the last element of the vector\n        balance = vget_v_i32m8_i32(vec_balance, vl - 1);\n\n        i += vl;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool below_zero_simd(std::vector<int> operations) {\n    size_t vlmax = vsetvlmax_e32m1();\n    size_t n = operations.size();\n    int balance = 0;\n    size_t i = 0;\n\n    while (i < n) {\n        size_t vl = vsetvl_e32m1(n - i);\n        vint32m1_t vec_ops = vle32_v_i32m1(operations.data() + i, vl);\n\n        // Accumulate the operations into a vector of balances\n        vint32m1_t vec_balance = vmv_v_x_i32m1(balance, vl);\n        vec_balance = vadd_vx_i32m1(vec_balance, vec_ops, vl);\n\n        // Check if any balance is below zero\n        vbool32_t vec_below_zero = vmslt_vx_i32m1_b32(vec_balance, 0, vl);\n        if (vmfirst_m_b32(vec_below_zero, vl) != -1) {\n            return true;\n        }\n\n        // Update the scalar balance with the last element of the vector balance\n        balance = vget_v_i32m1_i32(vec_balance, vl - 1);\n\n        i += vl;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool below_zero_simd(std::vector<int> operations) {\n    size_t vlmax = vsetvlmax_e32m8();\n    size_t n = operations.size();\n    int balance = 0;\n    size_t i = 0;\n\n    while (i < n) {\n        size_t vl = vsetvl_e32m8(n - i);\n        vint32m8_t vec_ops = vle32_v_i32m8(&operations[i], vl);\n\n        // Accumulate the sum of the current vector elements\n        vint32m1_t vec_sum = vmv_s_x_i32m1(0, vl);\n        vec_sum = vwredsum_vs_i32m8_i32m1(vec_sum, vec_ops, vec_sum, vl);\n\n        // Extract the sum from the vector register\n        int sum;\n        vse32_v_i32m1(&sum, vec_sum, 1);\n\n        // Update the balance\n        balance += sum;\n\n        // Check if balance falls below zero\n        if (balance < 0) {\n            return true;\n        }\n\n        i += vl;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool below_zero_simd(std::vector<int> operations) {\n    size_t vlmax = vsetvlmax_e32m1();\n    size_t n = operations.size();\n    int balance = 0;\n    bool below_zero = false;\n\n    for (size_t i = 0; i < n; i += vlmax) {\n        size_t vl = vsetvl_e32m1(n - i);\n\n        // Load the vector of operations\n        vint32m1_t vec_ops = vle32_v_i32m1(operations.data() + i, vl);\n\n        // Create a vector with the current balance broadcasted\n        vint32m1_t vec_balance = vmv_v_x_i32m1(balance, vl);\n\n        // Add the operations to the balance vector\n        vec_balance = vadd_vv_i32m1(vec_balance, vec_ops, vl);\n\n        // Check if any element in the balance vector is less than zero\n        vbool32_t vec_below_zero = vmslt_vx_i32m1_b32(vec_balance, 0, vl);\n\n        // Reduce the comparison results to a scalar boolean\n        below_zero = below_zero || vmreduce_any_true_b32(vec_below_zero, vl);\n\n        // Update the scalar balance with the last element of the vector balance\n        balance = vget_v_i32m1_i32(vec_balance, vl - 1);\n    }\n\n    return below_zero;\n}\n```"}
{"task_id": "SimdBench_64_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n#include <vector>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t n = numbers.size();\n    double mean = 0.0;\n    double mad = 0.0;\n\n    // Compute the mean using scalar operations\n    for (size_t i = 0; i < n; ++i) {\n        mean += numbers[i];\n    }\n    mean /= n;\n\n    // Initialize vector registers\n    size_t vlmax = vsetvlmax_e64m8();\n    size_t vl;\n    vfloat64m8_t v_mean = vfmv_v_f_f64m8(mean, vlmax);\n    vfloat64m8_t v_sum = vmv_v_x_f64m8(0.0, vlmax);\n\n    // Process the data in chunks using RVV intrinsics\n    size_t i = 0;\n    for (; i + vlmax <= n; i += vlmax) {\n        vl = vsetvl_e64m8(vlmax);\n        vfloat64m8_t v_data = vle64_v_f64m8(&numbers[i], vl);\n        vfloat64m8_t v_diff = vfsub_vv_f64m8(v_data, v_mean, vl);\n        vfloat64m8_t v_abs_diff = vfsgnjx_vv_f64m8(v_diff, v_diff, vl); // Absolute value\n        v_sum = vfadd_vv_f64m8(v_sum, v_abs_diff, vl);\n    }\n\n    // Reduce the vector sum to a scalar\n    double temp_sum = 0.0;\n    vse64_v_f64m8(&temp_sum, v_sum, vlmax);\n    mad += temp_sum;\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        mad += std::abs(numbers[i] - mean);\n    }\n\n    // Compute the final MAD\n    mad /= n;\n    return mad;\n}\n```"}
{"task_id": "SimdBench_64_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t n = numbers.size();\n    double mean = 0.0;\n    double mad = 0.0;\n\n    // Compute the mean of the dataset\n    for (size_t i = 0; i < n; ++i) {\n        mean += numbers[i];\n    }\n    mean /= n;\n\n    // Initialize vector registers\n    size_t vlmax = vsetvlmax_e64m8();\n    double sum_diff = 0.0;\n\n    // Process the data in chunks using RVV intrinsics\n    size_t i = 0;\n    for (; i + vlmax <= n; i += vlmax) {\n        vfloat64m8_t vnums = vle64_v_f64m8(&numbers[i], vlmax);\n        vfloat64m8_t vmean = vfadd_vf_f64m8(vnums, -mean, vlmax);\n        vfloat64m8_t vabs = vfsgnjx_vv_f64m8(vmean, vmean, vlmax); // Absolute value\n        sum_diff += vfredsum_vs_f64m8_f64m1(vabs, vfmv_s_f_f64m1(0.0), vlmax);\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        sum_diff += std::fabs(numbers[i] - mean);\n    }\n\n    // Compute the final MAD\n    mad = sum_diff / n;\n    return mad;\n}\n```"}
{"task_id": "SimdBench_64_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n#include <vector>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t n = numbers.size();\n    double mean = 0.0;\n    double mad = 0.0;\n\n    // Compute the mean of the dataset\n    for (size_t i = 0; i < n; ++i) {\n        mean += numbers[i];\n    }\n    mean /= n;\n\n    // Initialize vector registers\n    size_t vl;\n    vfloat64m1_t v_mean = vfmv_v_f_f64m1(mean, vl);\n    vfloat64m1_t v_sum = vfmv_v_f_f64m1(0.0, vl);\n\n    // Process the data in chunks using RVV intrinsics\n    size_t i = 0;\n    for (; i + vsetvlmax_e64m1() <= n; i += vl) {\n        vl = vsetvl_e64m1(n - i);\n        vfloat64m1_t v_data = vle64_v_f64m1(&numbers[i], vl);\n        vfloat64m1_t v_diff = vfsub_vv_f64m1(v_data, v_mean, vl);\n        vfloat64m1_t v_abs_diff = vfsgnjx_vv_f64m1(v_diff, v_diff, vl); // Absolute value\n        v_sum = vfadd_vv_f64m1(v_sum, v_abs_diff, vl);\n    }\n\n    // Reduce the vector sum to a scalar\n    double sum = 0.0;\n    vl = vsetvl_e64m1(n - i);\n    vfloat64m1_t v_temp = vfmv_v_f_f64m1(0.0, vl);\n    v_temp = vfadd_vv_f64m1(v_temp, v_sum, vl);\n    sum = vfmv_f_s_f64m1_f64(v_temp);\n\n    // Handle any remaining elements\n    for (; i < n; ++i) {\n        sum += std::abs(numbers[i] - mean);\n    }\n\n    // Compute the final MAD\n    mad = sum / n;\n    return mad;\n}\n```"}
{"task_id": "SimdBench_64_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    double sum = 0.0;\n    size_t i = 0;\n\n    // Compute the sum of all elements using RVV\n    vfloat64m1_t v_sum = vfmv_s_f_f64m1(v_sum, 0.0, vsetvlmax_e64m1());\n    for (; i + vsetvlmax_e64m1() <= n; i += vsetvlmax_e64m1()) {\n        vfloat64m1_t v = vle64_v_f64m1(&numbers[i], vsetvlmax_e64m1());\n        v_sum = vfadd_vv_f64m1(v_sum, v, vsetvlmax_e64m1());\n    }\n    sum = vfmv_f_s_f64m1_f64(v_sum);\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        sum += numbers[i];\n    }\n\n    // Compute the mean\n    double mean = sum / n;\n\n    // Compute the absolute deviations from the mean using RVV\n    double mad_sum = 0.0;\n    i = 0;\n    vfloat64m1_t v_mean = vfmv_s_f_f64m1(v_mean, mean, vsetvlmax_e64m1());\n    vfloat64m1_t v_mad_sum = vfmv_s_f_f64m1(v_mad_sum, 0.0, vsetvlmax_e64m1());\n    for (; i + vsetvlmax_e64m1() <= n; i += vsetvlmax_e64m1()) {\n        vfloat64m1_t v = vle64_v_f64m1(&numbers[i], vsetvlmax_e64m1());\n        vfloat64m1_t v_diff = vfsub_vv_f64m1(v, v_mean, vsetvlmax_e64m1());\n        vfloat64m1_t v_abs_diff = vfsgnjx_vv_f64m1(v_diff, v_diff, vsetvlmax_e64m1());\n        v_mad_sum = vfadd_vv_f64m1(v_mad_sum, v_abs_diff, vsetvlmax_e64m1());\n    }\n    mad_sum = vfmv_f_s_f64m1_f64(v_mad_sum);\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        mad_sum += std::abs(numbers[i] - mean);\n    }\n\n    // Compute the Mean Absolute Deviation\n    return mad_sum / n;\n}\n```"}
{"task_id": "SimdBench_64_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t n = numbers.size();\n    double mean = 0.0;\n    double mad = 0.0;\n\n    // Compute the mean using scalar operations\n    for (size_t i = 0; i < n; ++i) {\n        mean += numbers[i];\n    }\n    mean /= n;\n\n    // Initialize vector registers\n    size_t vl;\n    vfloat64m1_t v_mean = vfmv_v_f_f64m1(mean, vsetvlmax_e64m1());\n    vfloat64m1_t v_sum = vfmv_v_f_f64m1(0.0, vsetvlmax_e64m1());\n\n    // Process the data in chunks using RVV intrinsics\n    size_t i = 0;\n    for (; i + vsetvlmax_e64m1() <= n; i += vl) {\n        vl = vsetvl_e64m1(n - i);\n        vfloat64m1_t v_data = vle64_v_f64m1(&numbers[i], vl);\n        vfloat64m1_t v_diff = vfsub_vv_f64m1(v_data, v_mean, vl);\n        vfloat64m1_t v_abs = vfsgnjx_vv_f64m1(v_diff, v_diff, vl); // Absolute value\n        v_sum = vfadd_vv_f64m1(v_sum, v_abs, vl);\n    }\n\n    // Reduce the vector sum to a scalar\n    mad = vfmv_f_s_f64m1_f64(vfredsum_vs_f64m1_f64m1(v_sum, v_sum, vsetvlmax_e64m1()));\n\n    // Handle any remaining elements with scalar operations\n    for (; i < n; ++i) {\n        mad += std::abs(numbers[i] - mean);\n    }\n\n    // Compute the final MAD by dividing the sum of absolute differences by n\n    return mad / n;\n}\n```"}
{"task_id": "SimdBench_65_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    size_t n = numbers.size();\n    std::vector<int> result;\n    if (n == 0) return result;\n\n    result.reserve(2 * n - 1);\n\n    size_t vlmax = vsetvlmax_e32m8();\n    size_t i = 0;\n\n    for (; i + vlmax <= n; i += vlmax) {\n        vint32m8_t vec_numbers = vle32_v_i32m8(&numbers[i], vlmax);\n        vse32_v_i32m8(&result[i * 2], vec_numbers, vlmax);\n\n        // Insert delimiter\n        size_t j;\n        for (j = 0; j < vlmax - 1; ++j) {\n            result[i * 2 + j * 2 + 1] = delimeter;\n        }\n    }\n\n    // Handle remaining elements\n    if (i < n) {\n        size_t vl = vsetvl_e32m8(n - i);\n        vint32m8_t vec_numbers = vle32_v_i32m8(&numbers[i], vl);\n        vse32_v_i32m8(&result[i * 2], vec_numbers, vl);\n\n        for (size_t j = 0; j < vl - 1; ++j) {\n            result[i * 2 + j * 2 + 1] = delimeter;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    size_t n = numbers.size();\n    std::vector<int> result;\n    if (n == 0) return result;\n\n    // Reserve space for the result vector\n    result.reserve(2 * n - 1);\n\n    // Initialize RISC-V vector intrinsics\n    size_t vlmax = vsetvlmax_e32m8(); // Maximum vector length for int32_t\n\n    // Process the input vector in chunks using RVV\n    size_t i = 0;\n    while (i < n) {\n        size_t vl = vsetvl_e32m8(n - i); // Vector length for this iteration\n\n        // Load a vector of elements from the input\n        vint32m8_t vec_numbers = vle32_v_i32m8(&numbers[i], vl);\n\n        // Create a vector filled with the delimiter value\n        vint32m8_t vec_delim = vmv_v_x_i32m8(delimeter, vl);\n\n        // Store the first element of the current vector into the result\n        if (i == 0) {\n            result.push_back(numbers[0]);\n        } else {\n            // Interleave the delimiter and the current number\n            for (size_t j = 0; j < vl; ++j) {\n                result.push_back(delimeter);\n                result.push_back(numbers[i + j]);\n            }\n        }\n\n        // Move to the next chunk\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    size_t n = numbers.size();\n    std::vector<int> result;\n    if (n == 0) return result;\n\n    size_t result_size = n + (n > 1 ? n - 1 : 0);\n    result.resize(result_size);\n\n    size_t vlmax = vsetvlmax_e32m8();\n    size_t i = 0;\n\n    // Process elements in chunks defined by vector length\n    for (; i + vlmax <= n; i += vlmax) {\n        vint32m8_t vec = vle32_v_i32m8(&numbers[i], vlmax);\n\n        // Store the original elements into the result\n        vse32_v_i32m8(&result[2 * i], vec, vlmax);\n\n        // Fill the delimiter positions\n        size_t j;\n        for (j = 0; j < vlmax - 1; ++j) {\n            result[2 * i + 2 * j + 1] = delimeter;\n        }\n    }\n\n    // Handle remaining elements (tail case)\n    if (i < n) {\n        size_t vl = vsetvl_e32m8(n - i);\n        vint32m8_t vec = vle32_v_i32m8(&numbers[i], vl);\n\n        // Store the original elements into the result\n        vse32_v_i32m8(&result[2 * i], vec, vl);\n\n        // Fill the delimiter positions\n        for (size_t j = 0; j < vl - 1; ++j) {\n            result[2 * i + 2 * j + 1] = delimeter;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    size_t n = numbers.size();\n    std::vector<int> result;\n    if (n == 0) return result;\n\n    size_t result_size = n + (n > 1 ? n - 1 : 0);\n    result.resize(result_size);\n\n    size_t vlmax = vsetvlmax_e32m8();\n    size_t i = 0;\n\n    for (; i + vlmax <= n; i += vlmax) {\n        vint32m8_t vec = vle32_v_i32m8(&numbers[i], vlmax);\n        vse32_v_i32m8(&result[2 * i], vec, vlmax);\n\n        vint32m8_t delim_vec = vmv_v_x_i32m8(delimeter, vlmax);\n        vse32_v_i32m8(&result[2 * i + 1], delim_vec, vlmax);\n    }\n\n    if (i < n) {\n        size_t vl = vsetvl_e32m8(n - i);\n        vint32m8_t vec = vle32_v_i32m8(&numbers[i], vl);\n        vse32_v_i32m8(&result[2 * i], vec, vl);\n\n        if (i < n - 1) {\n            vint32m8_t delim_vec = vmv_v_x_i32m8(delimeter, vl);\n            vse32_v_i32m8(&result[2 * i + 1], delim_vec, vl);\n        }\n    }\n\n    // Remove the trailing delimiter if it exists\n    if (n > 1 && result.size() > 1 && result[result.size() - 1] == delimeter) {\n        result.pop_back();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    size_t n = numbers.size();\n    std::vector<int> result;\n    if (n == 0) return result;\n\n    size_t result_size = n + (n > 1 ? n - 1 : 0);\n    result.resize(result_size);\n\n    size_t vlmax = vsetvlmax_e32m8();\n    size_t i = 0;\n\n    for (; i + vlmax <= n; i += vlmax) {\n        vint32m8_t vec_numbers = vle32_v_i32m8(&numbers[i], vlmax);\n        vse32_v_i32m8(&result[2 * i], vec_numbers, vlmax);\n\n        vint32m8_t vec_delim = vmv_v_x_i32m8(delimeter, vlmax);\n        vse32_v_i32m8(&result[2 * i + 1], vec_delim, vlmax);\n    }\n\n    if (i < n) {\n        size_t vl = vsetvl_e32m8(n - i);\n        vint32m8_t vec_numbers = vle32_v_i32m8(&numbers[i], vl);\n        vse32_v_i32m8(&result[2 * i], vec_numbers, vl);\n\n        vint32m8_t vec_delim = vmv_v_x_i32m8(delimeter, vl);\n        vse32_v_i32m8(&result[2 * i + 1], vec_delim, vl);\n    }\n\n    // Remove the extra delimiter at the end if it exists\n    if (n > 1) {\n        result.pop_back();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_66_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    size_t vlmax = vsetvlmax_e16m8();\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    if (numbers.empty()) {\n        return {sum, product};\n    }\n\n    size_t n = numbers.size();\n    size_t i = 0;\n\n    vint16m8_t v_sum_vec = vmv_v_x_i16m8(0, vlmax);\n    vint16m8_t v_product_vec = vmv_v_x_i16m8(1, vlmax);\n\n    for (; i + vlmax <= n; i += vlmax) {\n        vint16m8_t v_numbers = vle16_v_i16m8(&numbers[i], vlmax);\n        v_sum_vec = vwadd_vv_i32m8(v_sum_vec, v_numbers, vlmax);\n        v_product_vec = vwmul_vv_i32m8(v_product_vec, v_numbers, vlmax);\n    }\n\n    // Reduction for sum\n    vint32m8_t v_sum_widened = vwadd_vv_i32m8(v_sum_vec, v_sum_vec, vlmax);\n    while (vlmax > 1) {\n        vlmax /= 2;\n        v_sum_widened = vwadd_vv_i32m8(v_sum_widened, v_sum_widened, vlmax);\n    }\n    sum = vmv_x_s_i32m1_i32(v_sum_widened);\n\n    // Reduction for product\n    vint32m8_t v_product_widened = vwmul_vv_i32m8(v_product_vec, v_product_vec, vlmax);\n    while (vlmax > 1) {\n        vlmax /= 2;\n        v_product_widened = vwmul_vv_i32m8(v_product_widened, v_product_widened, vlmax);\n    }\n    product = vmv_x_s_i32m1_i32(v_product_widened);\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    size_t vlmax = vsetvlmax_e16m1();\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    if (numbers.empty()) {\n        return {sum, product};\n    }\n\n    vint16m1_t v_sum = vmv_v_x_i16m1(0, vlmax);\n    vint16m1_t v_product = vmv_v_x_i16m1(1, vlmax);\n\n    size_t i = 0;\n    size_t n = numbers.size();\n\n    for (; i + vlmax <= n; i += vlmax) {\n        vint16m1_t v_in = vle16_v_i16m1(&numbers[i], vlmax);\n        v_sum = vadd_vv_i16m1(v_sum, v_in, vlmax);\n        v_product = vmul_vv_i16m1(v_product, v_in, vlmax);\n    }\n\n    // Tail handling\n    if (i < n) {\n        size_t remaining = n - i;\n        vint16m1_t v_in = vle16_v_i16m1(&numbers[i], remaining);\n        v_sum = vadd_vv_i16m1(v_sum, v_in, remaining);\n        v_product = vmul_vv_i16m1(v_product, v_in, remaining);\n    }\n\n    // Reduction for sum\n    while (vlmax > 1) {\n        v_sum = vredsum_vs_i16m1_i16m1(v_sum, v_sum, vmv_v_x_i16m1(0, vlmax), vlmax);\n        vlmax /= 2;\n    }\n    sum = vmv_x_s_i16m1_i16(v_sum);\n\n    // Reset vlmax for product reduction\n    vlmax = vsetvlmax_e16m1();\n\n    // Reduction for product\n    while (vlmax > 1) {\n        v_product = vredprod_vs_i16m1_i16m1(v_product, v_product, vmv_v_x_i16m1(1, vlmax), vlmax);\n        vlmax /= 2;\n    }\n    product = vmv_x_s_i16m1_i16(v_product);\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    size_t vlmax = vsetvlmax_e16m1();\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    if (numbers.empty()) {\n        return {sum, product};\n    }\n\n    vint16m1_t v_sum = vmv_s_x_i16m1(0, vlmax);\n    vint16m1_t v_product = vmv_s_x_i16m1(1, vlmax);\n\n    size_t i = 0;\n    size_t n = numbers.size();\n\n    for (; i + vlmax <= n; i += vlmax) {\n        vint16m1_t v_in = vle16_v_i16m1(&numbers[i], vlmax);\n        v_sum = vwredsum_vs_i16m1_i32m1(v_sum, v_in, v_sum, vlmax);\n        v_product = vmul_vv_i16m1(v_product, v_in, vlmax);\n    }\n\n    // Reduction for sum\n    int32_t temp_sum = 0;\n    vint32m1_t v_temp_sum = vmv_s_x_i32m1(0, vlmax);\n    v_temp_sum = vwredsum_vs_i16m1_i32m1(v_temp_sum, v_sum, v_temp_sum, vlmax);\n    temp_sum += vmv_x_s_i32m1_i32(v_temp_sum);\n\n    // Reduction for product\n    int16_t temp_product = 1;\n    vint16m1_t v_temp_product = vmv_s_x_i16m1(1, vlmax);\n    v_temp_product = vmul_vv_i16m1(v_temp_product, v_product, vlmax);\n    temp_product *= vmv_x_s_i16m1_i16(v_temp_product);\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    sum += temp_sum;\n    product *= temp_product;\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    size_t vlmax = vsetvlmax_e16m1();\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    if (numbers.empty()) {\n        return {sum, product};\n    }\n\n    vint16m1_t v_sum = vmv_s_x_i16m1(0, vlmax);\n    vint16m1_t v_product = vmv_s_x_i16m1(1, vlmax);\n\n    size_t i = 0;\n    size_t n = numbers.size();\n\n    for (; i + vlmax <= n; i += vlmax) {\n        vint16m1_t v_in = vle16_v_i16m1(&numbers[i], vlmax);\n        v_sum = vwredsum_vs_i16m1_i32m1(v_sum, v_in, v_sum, vlmax);\n        v_product = vwmul_vv_i16m1(v_product, v_in, vlmax);\n    }\n\n    // Reduce the partial sums and products\n    int16_t temp_sum[vlmax];\n    int16_t temp_product[vlmax];\n    vse16_v_i16m1(temp_sum, v_sum, vlmax);\n    vse16_v_i16m1(temp_product, v_product, vlmax);\n\n    for (size_t j = 0; j < vlmax; ++j) {\n        sum += temp_sum[j];\n        product *= temp_product[j];\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    size_t vlmax = vsetvlmax_e16m8();\n    int64_t sum = 0;\n    int64_t product = 1;\n    size_t i = 0;\n\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    vint16m8_t vec_sum = vmv_v_x_i16m8(0, vlmax);\n    vint16m8_t vec_product = vmv_v_x_i16m8(1, vlmax);\n\n    for (; i + vlmax <= numbers.size(); i += vlmax) {\n        vint16m8_t vec = vle16_v_i16m8(&numbers[i], vlmax);\n        vec_sum = vwadd_vv_i32m8(vec_sum, vec, vlmax);\n        vec_product = vwmul_vv_i32m8(vec_product, vec, vlmax);\n    }\n\n    // Reduction for sum\n    vint32m8_t sum_reduced = vwredsum_vs_i16m8_i32m8(vmv_v_x_i32m8(0, vlmax), vec_sum, vlmax);\n    sum = vmv_x_s_i32m8_i32(sum_reduced);\n\n    // Reduction for product\n    vint32m8_t product_reduced = vwredprod_vs_i16m8_i32m8(vmv_v_x_i32m8(1, vlmax), vec_product, vlmax);\n    product = vmv_x_s_i32m8_i32(product_reduced);\n\n    // Handle remaining elements\n    for (; i < numbers.size(); ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_67_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    size_t n = numbers.size();\n    std::vector<int> result(n);\n    \n    size_t vlmax = vsetvlmax_e32m8();\n    int current_max = numbers[0];\n    \n    for (size_t i = 0; i < n; i += vlmax) {\n        size_t vl = vsetvl_e32m8(n - i);\n        \n        vint32m8_t vec = vle32_v_i32m8(&numbers[i], vl);\n        vbool4_t mask = vmseq_vx_i32m8_b4(vec, current_max, vl);\n        \n        vint32m8_t max_vec = vmv_v_x_i32m8(current_max, vl);\n        max_vec = vmax_vv_i32m8(max_vec, vec, vl);\n        \n        current_max = vmax_vv_i32m8_m(mask, max_vec, vec, vl);\n        current_max = vmax_vx_i32m8(current_max, current_max, vl);\n        \n        vse32_v_i32m8(&result[i], max_vec, vl);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_67_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    size_t n = numbers.size();\n    std::vector<int> result(n);\n    \n    size_t vl;\n    int current_max = numbers[0];\n    result[0] = current_max;\n\n    for (size_t i = 1; i < n; ) {\n        vl = vsetvl_e32m8(n - i);\n        vint32m8_t vec = vle32_v_i32m8(&numbers[i], vl);\n\n        // Broadcast the current max value into a vector\n        vint32m8_t max_vec = vmv_v_x_i32m8(current_max, vl);\n\n        // Compute the maximum between the current max and the loaded vector\n        vint32m8_t res_vec = vmax_vv_i32m8(max_vec, vec, vl);\n\n        // Store the result back to the result array\n        vse32_v_i32m8(&result[i], res_vec, vl);\n\n        // Update the scalar current_max by reducing the vector to find the new max\n        for (size_t j = 0; j < vl; ++j) {\n            current_max = std::max(current_max, numbers[i + j]);\n        }\n\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    size_t n = numbers.size();\n    std::vector<int> result(n);\n    size_t vlmax = vsetvlmax_e32m8();\n\n    if (n == 0) return result;\n\n    int current_max = numbers[0];\n    result[0] = current_max;\n\n    for (size_t i = 1; i < n; i += vlmax) {\n        size_t vl = vsetvl_e32m8(n - i);\n\n        vint32m8_t vec = vle32_v_i32m8(&numbers[i], vl);\n        vbool4_t mask = vmseq_vx_i32m8_b4(vec, vec, vl);\n\n        vint32m8_t max_vec = vredmax_vs_i32m8_i32m1(vec, vmv_s_x_i32m1(current_max), mask, vl);\n        int temp_max = vmv_x_s_i32m1_i32(max_vec);\n\n        current_max = std::max(current_max, temp_max);\n\n        vint32m8_t res_vec = vmerge_vx_i32m8(vec, current_max, mask, vl);\n        vse32_v_i32m8(&result[i], res_vec, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    size_t n = numbers.size();\n    std::vector<int> result(n);\n    \n    if (n == 0) return result;\n\n    size_t vlmax = vsetvlmax_e32m8();\n    int current_max = numbers[0];\n    result[0] = current_max;\n\n    for (size_t i = 0; i < n; i += vlmax) {\n        size_t vl = vsetvl_e32m8(n - i);\n\n        vint32m8_t vec = vle32_v_i32m8(&numbers[i], vl);\n        vbool4_t mask = vmseq_vx_i32m8_b4(vec, current_max, vl);\n        vint32m8_t max_vec = vmerge_vxm_i32m8(mask, vec, current_max, vl);\n\n        current_max = vmaxv_v_i32m8(max_vec, vl);\n        vse32_v_i32m8(&result[i], max_vec, vl);\n    }\n\n    // Post-process to ensure rolling max property\n    for (size_t i = 1; i < n; ++i) {\n        if (result[i] < result[i - 1]) {\n            result[i] = result[i - 1];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    size_t n = numbers.size();\n    std::vector<int> result(n);\n    \n    if (n == 0) return result;\n\n    size_t vl;\n    size_t i = 0;\n    int current_max = numbers[0];\n\n    while (i < n) {\n        vl = vsetvl_e32m8(n - i);\n        vint32m8_t vec = vle32_v_i32m8(&numbers[i], vl);\n\n        // Initialize the first element of the result vector with the current max\n        if (i == 0) {\n            result[0] = current_max;\n            i++;\n            continue;\n        }\n\n        // Create a vector containing the current maximum value repeated\n        vint32m8_t max_vec = vmv_v_x_i32m8(current_max, vl);\n\n        // Compute the rolling max by comparing the current vector with the max vector\n        vbool4_t mask = vmseq_vx_i32m8(vec, max_vec, vl);\n        vint32m8_t rolling_max = vmax_vv_i32m8(vec, max_vec, vl);\n\n        // Store the results back to the result array\n        vse32_v_i32m8(&result[i], rolling_max, vl);\n\n        // Update the current_max for the next iteration\n        for (size_t j = 0; j < vl; ++j) {\n            if (numbers[i + j] > current_max) {\n                current_max = numbers[i + j];\n            }\n        }\n\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.length();\n    std::string result(len, '0');\n    \n    size_t vl;\n    size_t i = 0;\n    for (; i + vsetvlmax_e8m1() <= len; i += vl) {\n        vl = vsetvl_e8m1(len - i);\n        \n        vuint8m1_t va = vle8_v_u8m1((uint8_t*)a.data() + i, vl);\n        vuint8m1_t vb = vle8_v_u8m1((uint8_t*)b.data() + i, vl);\n        \n        vuint8m1_t vxor = vxor_vv_u8m1(va, vb, vl);\n        \n        vse8_v_u8m1((uint8_t*)result.data() + i, vxor, vl);\n    }\n    \n    for (; i < len; ++i) {\n        result[i] = ((a[i] == '1') ^ (b[i] == '1')) ? '1' : '0';\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_68_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.length();\n    std::string result(len, '0');\n    \n    size_t vl;\n    size_t i = 0;\n\n    while (i < len) {\n        // Load vector mask and calculate the maximum vector length\n        vl = vsetvl_e8m1(len - i);\n\n        // Load vectors from input strings\n        vuint8m1_t va = vle8_v_u8m1((const uint8_t*)(&a[i]), vl);\n        vuint8m1_t vb = vle8_v_u8m1((const uint8_t*)(&b[i]), vl);\n\n        // Perform XOR operation on packed bytes ('0' ^ '0' = '0', '1' ^ '1' = '0', '1' ^ '0' = '1')\n        vuint8m1_t vxor = vxor_vv_u8m1(va, vb, vl);\n\n        // Store the result back into the output string\n        vse8_v_u8m1((uint8_t*)(&result[i]), vxor, vl);\n\n        // Increment index by the number of elements processed in this iteration\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.length();\n    std::string result(len, '0');\n    size_t vl;\n\n    for (size_t i = 0; i < len; i += vl) {\n        vl = vsetvl_e8m1(len - i);\n\n        vuint8m1_t vec_a = vle8_v_u8m1((uint8_t*)a.data() + i, vl);\n        vuint8m1_t vec_b = vle8_v_u8m1((uint8_t*)b.data() + i, vl);\n\n        vuint8m1_t vec_xor = vxor_vv_u8m1(vec_a, vec_b, vl);\n\n        vse8_v_u8m1((uint8_t*)result.data() + i, vec_xor, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.length();\n    std::string result(len, '0');\n    \n    size_t vl;\n    size_t i = 0;\n\n    while (i < len) {\n        // Load vector mask and calculate the maximum vector length\n        vl = vsetvl_e8m1(len - i);\n\n        // Load vectors from input strings\n        vuint8m1_t va = vle8_v_u8m1((uint8_t*)(&a[i]), vl);\n        vuint8m1_t vb = vle8_v_u8m1((uint8_t*)(&b[i]), vl);\n\n        // Perform XOR operation on vectors\n        vuint8m1_t vxor = vxor_vv_u8m1(va, vb, vl);\n\n        // Store the result back into the output string\n        vse8_v_u8m1((uint8_t*)(&result[i]), vxor, vl);\n\n        // Increment index by the number of elements processed\n        i += vl;\n    }\n\n    // Convert ASCII values back to '0'/'1' characters\n    for (size_t j = 0; j < len; ++j) {\n        result[j] = (result[j] == '\\x00') ? '0' : '1';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.length();\n    std::string result(len, '0');\n    \n    size_t vl;\n    size_t i = 0;\n\n    while (i < len) {\n        // Load the vector length for the current iteration\n        vl = vsetvl_e8m1(len - i);\n\n        // Load vectors from input strings\n        vuint8m1_t vec_a = vle8_v_u8m1((const uint8_t*)(a.data() + i), vl);\n        vuint8m1_t vec_b = vle8_v_u8m1((const uint8_t*)(b.data() + i), vl);\n\n        // Convert characters '0'/'1' to integers 0/1\n        vuint8m1_t mask_a = vmseq_vx_u8m1(vec_a, '0', vl);\n        vuint8m1_t mask_b = vmseq_vx_u8m1(vec_b, '0', vl);\n\n        // Perform XOR operation\n        vbool8_t xor_result = vmsne_vv_u8m1_b8(mask_a, mask_b, vl);\n\n        // Convert the boolean result back to '0'/'1'\n        vuint8m1_t res_vec = vmerge_vxm_u8m1(mask_a, '1', xor_result, vl);\n        res_vec = vmerge_vxm_u8m1(res_vec, '0', !xor_result, vl);\n\n        // Store the result back into the output string\n        vse8_v_u8m1((uint8_t*)(result.data() + i), res_vec, vl);\n\n        // Increment the index by the vector length\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_69_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <vector>\n\nstd::string longest_simd(const std::vector<std::string> &strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    size_t max_len = 0;\n    size_t max_idx = 0;\n\n    size_t vlmax = vsetvlmax_e32m1();\n    size_t n = strings.size();\n\n    for (size_t i = 0; i < n; i += vlmax) {\n        size_t vl = vsetvl_e32m1(n - i);\n\n        // Load lengths of strings into a vector register\n        vuint32m1_t v_lengths = vmv_v_x_u32m1(0, vl);\n        for (size_t j = 0; j < vl; ++j) {\n            v_lengths = vslide1up_vx_u32m1(v_lengths, strings[i + j].size(), vl);\n        }\n\n        // Find the maximum length in the vector\n        vbool32_t mask = vmseq_vx_u32m1_b32(v_lengths, 0, vl);\n        vuint32m1_t v_max_len = vredmaxu_vs_u32m1_u32m1(v_lengths, vmv_v_x_u32m1(0, vl), mask, vl);\n\n        // Extract the maximum length from the vector\n        unsigned int temp_max_len;\n        vse32_v_u32m1(&temp_max_len, v_max_len, vl);\n\n        if (temp_max_len > max_len) {\n            // Find the index of the first occurrence of the maximum length\n            for (size_t j = 0; j < vl; ++j) {\n                if (strings[i + j].size() == temp_max_len) {\n                    max_len = temp_max_len;\n                    max_idx = i + j;\n                    break;\n                }\n            }\n        }\n    }\n\n    return strings[max_idx];\n}\n```"}
{"task_id": "SimdBench_69_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <vector>\n\nstd::string longest_simd(const std::vector<std::string> &strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    size_t max_len = 0;\n    size_t max_idx = 0;\n\n    size_t vlmax = vsetvlmax_e32m1();\n    size_t n = strings.size();\n\n    for (size_t i = 0; i < n; i += vlmax) {\n        size_t vl = vsetvl_e32m1(n - i);\n\n        vuint32m1_t v_lengths = vmv_v_x_u32m1(0, vl);\n        for (size_t j = 0; j < vl; ++j) {\n            v_lengths = vslide1up_vx_u32m1(v_lengths, strings[i + j].size(), vl);\n        }\n\n        vbool32_t mask = vmseq_vx_u32m1_b32(v_lengths, max_len, vl);\n        if (vmfirst_m_b32(mask, vl) != -1) {\n            max_idx = i + vmfirst_m_b32(mask, vl);\n            max_len = strings[max_idx].size();\n        }\n\n        vbool32_t gt_mask = vmsgt_vx_u32m1_b32(v_lengths, max_len, vl);\n        int first_gt = vmfirst_m_b32(gt_mask, vl);\n        if (first_gt != -1) {\n            max_idx = i + first_gt;\n            max_len = strings[max_idx].size();\n        }\n    }\n\n    return strings[max_idx];\n}\n```"}
{"task_id": "SimdBench_69_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <vector>\n\nstd::string longest_simd(const std::vector<std::string> &strings) {\n    if (strings.empty()) return \"\";\n\n    size_t max_len = 0;\n    size_t max_idx = 0;\n\n    size_t vlmax = __riscv_vsetvlmax_e32m1();\n    size_t n = strings.size();\n\n    for (size_t i = 0; i < n; i += vlmax) {\n        size_t vl = __riscv_vsetvl_e32m1(n - i);\n\n        // Load lengths of current vector segment into a vector register\n        vuint32m1_t v_lengths = __riscv_vundefined_u32m1();\n        for (size_t j = 0; j < vl; ++j) {\n            v_lengths = __riscv_vlse32_v_u32m1(v_lengths, &strings[i + j].size(), j);\n        }\n\n        // Find the maximum length in the current vector segment\n        vbool32_t mask = __riscv_vmseq_vx_u32m1_b32(v_lengths, 0, vl);\n        size_t idx = __riscv_vfirst_m_b32(mask, vl);\n        if (idx < vl) {\n            size_t len = __riscv_vmv_x_s_u32m1_u32(v_lengths);\n            if (len > max_len) {\n                max_len = len;\n                max_idx = i + idx;\n            }\n        }\n    }\n\n    return strings[max_idx];\n}\n```"}
{"task_id": "SimdBench_69_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <vector>\n\nstd::string longest_simd(const std::vector<std::string> &strings) {\n    if (strings.empty()) return \"\";\n\n    size_t max_len = 0;\n    size_t max_idx = 0;\n\n    size_t vlmax = __riscv_vsetvlmax_e32m1();\n    size_t n = strings.size();\n\n    for (size_t i = 0; i < n; i += vlmax) {\n        size_t vl = __riscv_vsetvl_e32m1(n - i);\n\n        // Load lengths of strings into a vector register\n        unsigned int lengths[vlmax];\n        for (size_t j = 0; j < vl; ++j) {\n            lengths[j] = strings[i + j].length();\n        }\n\n        // Vectorized load of lengths\n        vuint32m1_t v_lengths = __riscv_vle32_v_u32m1(lengths, vl);\n\n        // Find the maximum length in the current vector\n        vbool32_t mask = __riscv_vmseq_vx_u32m1_b32(v_lengths, __riscv_vredmaxu_vs_u32m1_u32m1(v_lengths, v_lengths, vl), vl);\n        unsigned int max_in_chunk = __riscv_vmv_x_s_u32m1_u32(__riscv_vredmaxu_vs_u32m1_u32m1(v_lengths, v_lengths, vl));\n\n        // Check if this chunk's max is greater than global max\n        if (max_in_chunk > max_len) {\n            max_len = max_in_chunk;\n\n            // Find the index of the first occurrence of max_in_chunk\n            for (size_t j = 0; j < vl; ++j) {\n                if (lengths[j] == max_in_chunk) {\n                    max_idx = i + j;\n                    break;\n                }\n            }\n        }\n    }\n\n    return strings[max_idx];\n}\n```"}
{"task_id": "SimdBench_69_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <vector>\n\nstd::string longest_simd(const std::vector<std::string> &strings) {\n    if (strings.empty()) return \"\";\n\n    size_t max_len = 0;\n    size_t max_idx = 0;\n\n    size_t vlmax = vsetvlmax_e32m1();\n    size_t n = strings.size();\n\n    for (size_t i = 0; i < n; i += vlmax) {\n        size_t vl = vsetvl_e32m1(n - i);\n\n        vuint32m1_t v_lengths = vmv_v_x_u32m1(0, vl);\n        for (size_t j = 0; j < vl; ++j) {\n            v_lengths = vslide1up_vx_u32m1(v_lengths, strings[i + j].size(), vl);\n        }\n\n        vbool32_t mask = vmseq_vx_u32m1(v_lengths, max_len, vl);\n        if (vmfirst_m_b32(mask, vl) != -1) {\n            for (size_t j = 0; j < vl; ++j) {\n                size_t len = strings[i + j].size();\n                if (len > max_len) {\n                    max_len = len;\n                    max_idx = i + j;\n                }\n            }\n        }\n    }\n\n    return strings[max_idx];\n}\n```"}
{"task_id": "SimdBench_70_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    size_t vl;\n    vuint64m1_t va, vb, vrem;\n\n    // Initialize vector length\n    vl = vsetvl_e64m1(1);\n\n    // Load scalars into vector registers\n    va = vmv_v_x_u64m1(a, vl);\n    vb = vmv_v_x_u64m1(b, vl);\n\n    while (1) {\n        // Compute remainder: vrem = va % vb\n        vrem = vremu_vv_u64m1(va, vb, vl);\n\n        // Check if all remainders are zero\n        vbool64_t cmp = vmseq_vx_u64m1_b64(vrem, 0, vl);\n        if (vmfirst_m_b64(cmp, vl) == 0) {\n            break;\n        }\n\n        // Update va and vb for next iteration\n        va = vb;\n        vb = vrem;\n    }\n\n    // Extract result from vector register\n    return vmv_x_s_u64m1_u64(vb);\n}\n```"}
{"task_id": "SimdBench_70_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    size_t vl;\n    vuint64m1_t va, vb, vrem;\n\n    // Initialize vector length\n    vl = __riscv_vsetvl_e64m1(1);\n\n    // Load scalars into vector registers\n    va = __riscv_vmv_v_x_u64m1(a, vl);\n    vb = __riscv_vmv_v_x_u64m1(b, vl);\n\n    while (1) {\n        // Compute remainder: vrem = va % vb\n        vrem = __riscv_vremu_vv_u64m1(va, vb, vl);\n\n        // Check if all remainders are zero\n        vbool64_t cmp = __riscv_vmseq_vx_u64m1_b64(vrem, 0, vl);\n        if (__riscv_vfirst_m_b64(cmp, vl) != -1) {\n            break; // Exit loop if remainder is zero\n        }\n\n        // Update va and vb for next iteration\n        va = vb;\n        vb = vrem;\n    }\n\n    // Extract the result from the vector register\n    return __riscv_vmv_x_s_u64m1_u64(vb);\n}\n```"}
{"task_id": "SimdBench_70_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    size_t vl;\n    vuint64m1_t va, vb, vrem;\n\n    // Initialize vector length\n    vl = __riscv_vsetvl_e64m1(1);\n\n    // Load scalars into vector registers\n    va = __riscv_vmv_v_x_u64m1(a, vl);\n    vb = __riscv_vmv_v_x_u64m1(b, vl);\n\n    while (1) {\n        // Compute remainder: vrem = va % vb\n        vrem = __riscv_vremu_vv_u64m1(va, vb, vl);\n\n        // Check if all remainders are zero\n        if (__riscv_vfirst_m_b64m1(__riscv_vmseq_vx_u64m1_b64m1(vrem, 0, vl), vl) != -1) {\n            break;\n        }\n\n        // Update va and vb for next iteration\n        va = vb;\n        vb = vrem;\n    }\n\n    // Extract the result from the vector register\n    return __riscv_vmv_x_s_u64m1_u64(vb);\n}\n```"}
{"task_id": "SimdBench_70_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    size_t vl;\n    vuint64m1_t va, vb, vrem;\n\n    // Initialize vector length\n    vl = vsetvl_e64m1(1);\n\n    // Load scalars into vector registers\n    va = vmv_v_x_u64m1(a, vl);\n    vb = vmv_v_x_u64m1(b, vl);\n\n    while (1) {\n        // Compute remainder: vrem = va % vb\n        vrem = vremu_vv_u64m1(va, vb, vl);\n\n        // Check if all remainders are zero\n        if (vmseq_vx_u64m1_b1(vrem, 0, vl)) {\n            break;\n        }\n\n        // Update va and vb for next iteration\n        va = vb;\n        vb = vrem;\n    }\n\n    // Extract result from vector register\n    return vmv_x_s_u64m1_u64(vb);\n}\n```"}
{"task_id": "SimdBench_70_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    size_t vl;\n    vuint64m1_t va, vb, vrem;\n\n    // Initialize vector length\n    vl = __riscv_vsetvl_e64m1(1);\n\n    // Load scalars into vector registers\n    va = __riscv_vmv_v_x_u64m1(a, vl);\n    vb = __riscv_vmv_v_x_u64m1(b, vl);\n\n    while (1) {\n        // Compute remainder: vrem = va % vb\n        vrem = __riscv_vremu_vv_u64m1(va, vb, vl);\n\n        // Check if all remainders are zero\n        if (__riscv_vfirst_m_b64m1(__riscv_vmseq_vx_u64m1_b64m1(vrem, 0, vl), vl) != -1) {\n            break;\n        }\n\n        // Update va and vb for next iteration\n        va = vb;\n        vb = vrem;\n    }\n\n    // Extract result from vector register\n    return __riscv_vmv_x_s_u64m1_u64(vb);\n}\n```"}
{"task_id": "SimdBench_71_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_a = 0.0f, closest_b = 0.0f;\n\n    size_t vl;\n    vfloat32m1_t vec_a, vec_b;\n    vbool32_t mask;\n\n    for (size_t i = 0; i < n; i++) {\n        float current = numbers[i];\n        vec_a = vfmv_v_f_f32m1(current, vl);\n\n        for (size_t j = i + 1; j < n; j += vl) {\n            vl = vsetvl_e32m1(n - j);\n            vec_b = vle32_v_f32m1(numbers.data() + j, vl);\n\n            vfloat32m1_t diff = vfsub_vv_f32m1(vec_b, vec_a, vl);\n            diff = vfsgnjx_vv_f32m1(diff, diff, vl); // Absolute value\n\n            vfloat32m1_t min_diff_vec = vfmv_v_f_f32m1(min_diff, vl);\n            mask = vmflt_vv_f32m1(diff, min_diff_vec, vl);\n\n            if (vcpop_m_b32(mask, vl)) {\n                float new_min_diff = vfmv_f_s_f32m1_f32(vfredmin_vs_f32m1_f32m1(diff, diff, vl));\n                if (new_min_diff < min_diff) {\n                    min_diff = new_min_diff;\n                    closest_a = current;\n                    closest_b = numbers[j + vfirst_m_b32(mask, vl)];\n                }\n            }\n        }\n    }\n\n    return {closest_a, closest_b};\n}\n```"}
{"task_id": "SimdBench_71_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float closest_pair[2] = {0.0f, 0.0f};\n    float min_diff = std::numeric_limits<float>::max();\n\n    size_t vl;\n    vfloat32m1_t v_min_diff = vfmv_v_f_f32m1(min_diff, vl);\n    vfloat32m1_t v_closest_a = vfmv_v_f_f32m1(0.0f, vl);\n    vfloat32m1_t v_closest_b = vfmv_v_f_f32m1(0.0f, vl);\n\n    for (size_t i = 0; i < n; i++) {\n        vfloat32m1_t vi = vle32_v_f32m1(&numbers[i], vl);\n        for (size_t j = i + 1; j < n; j++) {\n            vfloat32m1_t vj = vle32_v_f32m1(&numbers[j], vl);\n            vfloat32m1_t diff = vfsub_vv_f32m1(vi, vj, vl);\n            diff = vfabs_v_f32m1(diff, vl);\n\n            vbool32_t mask = vmflt_vv_f32m1_b32(diff, v_min_diff, vl);\n            v_min_diff = vmerge_vvm_f32m1(mask, diff, v_min_diff, vl);\n            v_closest_a = vmerge_vvm_f32m1(mask, vi, v_closest_a, vl);\n            v_closest_b = vmerge_vvm_f32m1(mask, vj, v_closest_b, vl);\n        }\n    }\n\n    float result_min_diff = vfmv_f_s_f32m1_f32(v_min_diff);\n    float result_a = vfmv_f_s_f32m1_f32(v_closest_a);\n    float result_b = vfmv_f_s_f32m1_f32(v_closest_b);\n\n    if (result_a > result_b) {\n        std::swap(result_a, result_b);\n    }\n\n    return {result_a, result_b};\n}\n```"}
{"task_id": "SimdBench_71_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_a = 0.0f, closest_b = 0.0f;\n\n    size_t vl;\n    vfloat32m1_t vec_a, vec_b;\n    vbool32_t mask;\n    vfloat32m1_t diff_vec, min_diff_vec;\n\n    for (size_t i = 0; i < n; i++) {\n        float current = numbers[i];\n        vec_a = vfmv_v_f_f32m1(current, vsetvl_e32m1(n));\n\n        for (size_t j = 0; j < n; j += vl) {\n            vl = vsetvl_e32m1(n - j);\n            vec_b = vle32_v_f32m1(&numbers[j], vl);\n\n            diff_vec = vfsub_vv_f32m1(vec_b, vec_a, vl);\n            diff_vec = vfsgnjx_vv_f32m1(diff_vec, diff_vec, vl); // Absolute value\n\n            min_diff_vec = vfmv_v_f_f32m1(min_diff, vl);\n            mask = vmflt_vv_f32m1(diff_vec, min_diff_vec, vl);\n\n            if (vmseq_vx_i32m1_b32(mask, true, vl)) {\n                float temp_min_diff = vfmv_f_s_f32m1_f32(vfredmin_vs_f32m1_f32m1(diff_vec, diff_vec, vl));\n                if (temp_min_diff < min_diff) {\n                    min_diff = temp_min_diff;\n                    closest_a = current;\n                    closest_b = numbers[j + vfirst_m_b32(mask, vl)];\n                }\n            }\n        }\n    }\n\n    return {closest_a, closest_b};\n}\n```"}
{"task_id": "SimdBench_71_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_a = 0.0f, closest_b = 0.0f;\n\n    size_t vl;\n    vfloat32m1_t vec_a, vec_b;\n    vbool32_t mask;\n    vfloat32m1_t diff_vec, min_diff_vec;\n\n    for (size_t i = 0; i < n; i++) {\n        float current = numbers[i];\n        vec_a = vfsub_vf_f32m1(vec_a, current, vl);\n\n        for (size_t j = i + 1; j < n; j += vl) {\n            vl = vsetvl_e32m1(n - j);\n            vec_b = vle32_v_f32m1(numbers.data() + j, vl);\n            diff_vec = vfsub_vv_f32m1(vec_b, vec_a, vl);\n            diff_vec = vfsgnjx_vv_f32m1(diff_vec, diff_vec, vl); // Absolute value\n\n            // Find the minimum difference in this vector\n            min_diff_vec = vfredmin_vs_f32m1_f32m1(diff_vec, min_diff_vec, vl);\n            float local_min_diff = vfmv_f_s_f32m1_f32(min_diff_vec);\n\n            if (local_min_diff < min_diff) {\n                min_diff = local_min_diff;\n                closest_a = current;\n                closest_b = numbers[j + vfirst_m_b32(vfseq_vf_f32m1(diff_vec, min_diff, vl))];\n            }\n        }\n    }\n\n    return {closest_a, closest_b};\n}\n```"}
{"task_id": "SimdBench_71_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_a = 0.0f, closest_b = 0.0f;\n\n    size_t vl;\n    vfloat32m1_t vec_a, vec_b;\n    vbool32_t mask;\n\n    for (size_t i = 0; i < n; i++) {\n        float current = numbers[i];\n        size_t j = 0;\n\n        while (j < n) {\n            vl = vsetvl_e32m1(n - j);\n            vec_a = vfsub_vf_f32m1(vle32_v_f32m1(numbers.data() + j, vl), current, vl);\n            vec_a = vfabs_v_f32m1(vec_a, vl);\n\n            // Create a mask to ignore the element itself\n            mask = vmseq_vx_i32m1(viota_v_u32m1(vl), j + i, vl);\n            vec_a = vmerge_vxm_f32m1(vec_a, std::numeric_limits<float>::max(), mask, vl);\n\n            // Find the minimum difference in this vector\n            float local_min_diff = vfmv_f_s_f32m1_f32(vfredmin_vs_f32m1_f32m1(vec_a, vec_a, vl));\n            if (local_min_diff < min_diff) {\n                min_diff = local_min_diff;\n                closest_a = current;\n                closest_b = numbers[j + vfirst_m_b32(vfcmpeq_vf_f32m1(vec_a, local_min_diff, vl))];\n            }\n\n            j += vl;\n        }\n    }\n\n    if (closest_a > closest_b) {\n        std::swap(closest_a, closest_b);\n    }\n\n    return {closest_a, closest_b};\n}\n```"}
{"task_id": "SimdBench_72_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    std::vector<float> result(n);\n\n    float min_val = numbers[0];\n    float max_val = numbers[0];\n\n    // Find min and max values in the input vector\n    for (size_t i = 1; i < n; ++i) {\n        if (numbers[i] < min_val) min_val = numbers[i];\n        if (numbers[i] > max_val) max_val = numbers[i];\n    }\n\n    float range = max_val - min_val;\n    if (range == 0) range = 1.0f; // Avoid division by zero\n\n    size_t vl;\n    size_t i = 0;\n\n    // Process the vector using RVV intrinsics\n    for (; i + vsetvl_e32m8(i) <= n; i += vl) {\n        vl = vsetvl_e32m8(n - i);\n        vfloat32m8_t vec = vle32_v_f32m8(&numbers[i], vl);\n        vec = vfsub_vf_f32m8(vec, min_val, vl);\n        vec = vfdiv_vf_f32m8(vec, range, vl);\n        vse32_v_f32m8(&result[i], vec, vl);\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        result[i] = (numbers[i] - min_val) / range;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    std::vector<float> result(n);\n\n    float min_val = numbers[0];\n    float max_val = numbers[0];\n\n    // Find min and max values in the vector\n    for (size_t i = 1; i < n; ++i) {\n        if (numbers[i] < min_val) min_val = numbers[i];\n        if (numbers[i] > max_val) max_val = numbers[i];\n    }\n\n    float range = max_val - min_val;\n    if (range == 0) range = 1.0f; // Avoid division by zero\n\n    size_t vl;\n    size_t i = 0;\n\n    // Process the vector using RVV intrinsics\n    for (; i + vsetvlmax_e32m1() <= n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        vfloat32m1_t v_numbers = vle32_v_f32m1(&numbers[i], vl);\n        vfloat32m1_t v_min = vfsub_vf_f32m1(v_numbers, min_val, vl);\n        vfloat32m1_t v_scaled = vfdiv_vf_f32m1(v_min, range, vl);\n        vse32_v_f32m1(&result[i], v_scaled, vl);\n    }\n\n    // Process remaining elements\n    for (; i < n; ++i) {\n        result[i] = (numbers[i] - min_val) / range;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    std::vector<float> result(n);\n\n    float min_val = numbers[0];\n    float max_val = numbers[0];\n\n    // Find min and max values in the input vector\n    for (size_t i = 1; i < n; ++i) {\n        if (numbers[i] < min_val) min_val = numbers[i];\n        if (numbers[i] > max_val) max_val = numbers[i];\n    }\n\n    float range = max_val - min_val;\n    if (range == 0) range = 1.0f; // Avoid division by zero\n\n    size_t vl;\n    size_t i = 0;\n\n    // Process the vector using RVV intrinsics\n    for (; i + vsetvlmax_e32m1() <= n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        vfloat32m1_t vec = vle32_v_f32m1(&numbers[i], vl);\n        vec = vfsub_vf_f32m1(vec, min_val, vl);\n        vec = vfdiv_vf_f32m1(vec, range, vl);\n        vse32_v_f32m1(&result[i], vec, vl);\n    }\n\n    // Handle any remaining elements\n    for (; i < n; ++i) {\n        result[i] = (numbers[i] - min_val) / range;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    std::vector<float> result(n);\n\n    float min_val = numbers[0];\n    float max_val = numbers[0];\n\n    // Find min and max values in the vector\n    for (size_t i = 1; i < n; ++i) {\n        if (numbers[i] < min_val) min_val = numbers[i];\n        if (numbers[i] > max_val) max_val = numbers[i];\n    }\n\n    float range = max_val - min_val;\n    if (range == 0) range = 1.0f; // Avoid division by zero\n\n    size_t vl;\n    size_t i = 0;\n\n    // Process the vector using RVV intrinsics\n    for (; i + vsetvlmax_e32m1() <= n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        vfloat32m1_t vnums = vle32_v_f32m1(&numbers[i], vl);\n        vfloat32m1_t vmins = vfsub_vf_f32m1(vnums, min_val, vl);\n        vfloat32m1_t vscaled = vfdiv_vf_f32m1(vmins, range, vl);\n        vse32_v_f32m1(&result[i], vscaled, vl);\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        result[i] = (numbers[i] - min_val) / range;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    std::vector<float> result(n);\n\n    float min_val = numbers[0];\n    float max_val = numbers[0];\n\n    // Find min and max values in the input vector\n    for (size_t i = 1; i < n; ++i) {\n        if (numbers[i] < min_val) min_val = numbers[i];\n        if (numbers[i] > max_val) max_val = numbers[i];\n    }\n\n    float range = max_val - min_val;\n    if (range == 0) range = 1.0f; // Avoid division by zero\n\n    size_t vl;\n    size_t i = 0;\n\n    // Process the vector using RVV intrinsics\n    for (; i < n; i += vl) {\n        vl = vsetvl_e32m8(n - i);\n        vfloat32m8_t vec = vle32_v_f32m8(&numbers[i], vl);\n        vec = vfsub_vf_f32m8(vec, min_val, vl);\n        vec = vfdiv_vf_f32m8(vec, range, vl);\n        vse32_v_f32m8(&result[i], vec, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_73_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    size_t vlmax = __riscv_vsetvlmax_e64m1();\n    uint64_t result = 1;\n    uint64_t i = n / 2;\n\n    while (i > 1) {\n        size_t vl = __riscv_vsetvl_e64m1(i);\n        vuint64m1_t vec_i = __riscv_vid_v_u64m1(vl);\n        vec_i = __riscv_vadd_vx_u64m1(vec_i, i - vl + 1, vl);\n\n        vbool64_t mask = __riscv_vmseq_vx_u64m1_b64(__riscv_vremu_vx_u64m1(vec_i, n, vl), 0, vl);\n        if (__riscv_vfirst_m_b64(mask, vl) != -1) {\n            result = i;\n            break;\n        }\n        i -= vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_73_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    size_t vl;\n    uint64_t divisor = 1;\n    uint64_t i = n / 2;\n\n    vuint64m8_t vn = vmv_v_x_u64m8(n, vl);\n    vuint64m8_t vi, vrem, vzero;\n    vbool64_t mask;\n\n    for (; i >= 1; i -= vl) {\n        vl = vsetvl_e64m8(i);\n\n        vi = vid_v_u64m8(vi, vl);\n        vi = vsub_vx_u64m8(vi, i - vl + 1, vl);\n\n        vrem = vremu_vx_u64m8(vn, vi, vl);\n        vzero = vmv_v_x_u64m8(0, vl);\n\n        mask = vmseq_vv_u64m8_b64(vrem, vzero, vl);\n\n        if (vmfirst_m_b64(mask, vl) != -1) {\n            divisor = i - vmfirst_m_b64(mask, vl);\n            break;\n        }\n    }\n\n    return divisor;\n}\n```"}
{"task_id": "SimdBench_73_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    size_t vl;\n    uint64_t divisor = 1;\n    uint64_t i = n / 2;\n\n    vuint64m8_t vn = vmv_v_x_u64m8(n, vl);\n    vbool64_t mask;\n\n    for (; i > 1; i -= vl) {\n        vl = vsetvl_e64m8(i);\n        vuint64m8_t vi = vid_v_u64m8(vl);\n        vi = vsub_vx_u64m8(vi, i - vl, vl);\n\n        vuint64m8_t vrem = vrem_vv_u64m8(vn, vi, vl);\n        mask = vmseq_vx_u64m8(vrem, 0, vl);\n\n        if (vmfirst_m(mask, vl) != -1) {\n            divisor = i - vmfirst_m(mask, vl);\n            break;\n        }\n    }\n\n    return divisor;\n}\n```"}
{"task_id": "SimdBench_73_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    size_t vl;\n    uint64_t divisor = 1;\n    uint64_t max_divisor = 1;\n\n    // Start from n/2 and go downwards to find the largest divisor\n    uint64_t start = n / 2;\n\n    // Vector loop to process multiple potential divisors in parallel\n    for (uint64_t i = start; i > 1; i -= vl) {\n        vl = vsetvl_e64m1(i);  // Set vector length based on remaining elements\n\n        vuint64m1_t vec_i = vid_v_u64m1(vl);  // Create a vector of indices [0, 1, ..., vl-1]\n        vec_i = vadd_vx_u64m1(vec_i, i - vl, vl);  // Offset indices to represent actual values [i-vl+1, ..., i]\n\n        vbool64_t mask = vmseq_vx_u64m1(vec_i, 0, vl);  // Mask out-of-bound elements\n        vuint64m1_t vec_n = vmul_vx_u64m1(vec_i, 0, vl);  // Broadcast n into a vector\n        vbool64_t div_mask = vmsne_vv_u64m1(vrem_vv_u64m1(vec_n, vec_i, vl), 0, vl);  // Check if n % vec_i == 0\n\n        // Compress the valid divisors\n        vuint64m1_t valid_divisors = vcompress_vm_u64m1(div_mask, vec_i, vl);\n\n        // Find the maximum valid divisor in the vector\n        uint64_t max_in_vec = vmaxu_v_u64m1(valid_divisors, vl);\n        if (max_in_vec > max_divisor) {\n            max_divisor = max_in_vec;\n        }\n    }\n\n    return max_divisor;\n}\n```"}
{"task_id": "SimdBench_73_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    size_t vlmax = __riscv_vsetvlmax_e64m1();\n    uint64_t result = 1;\n    uint64_t i = n / 2;\n\n    while (i > 1) {\n        size_t vl = __riscv_vsetvl_e64m1(i);\n        vuint64m1_t vec_i = __riscv_vid_v_u64m1(vl);\n        vec_i = __riscv_vadd_vx_u64m1(vec_i, i - vl + 1, vl);\n\n        vbool64_t mask = __riscv_vmseq_vx_u64m1(__riscv_vremu_vx_u64m1(vec_i, n, vl), 0, vl);\n\n        if (__riscv_vfirst_m_b64(mask, vl) != -1) {\n            result = i;\n            break;\n        }\n\n        i -= vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_74_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    size_t vl;\n\n    // Handle factor 2 separately\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    // Start with factor 3 and increment by 2 for odd numbers\n    int factor = 3;\n    while (factor * factor <= n) {\n        // Load the factor into a vector register\n        vint32m1_t vec_factor = vmv_v_x_i32m1(factor, vl);\n\n        // Check divisibility in parallel\n        while (n % factor == 0) {\n            factors.push_back(factor);\n            n /= factor;\n        }\n        factor += 2;\n    }\n\n    // If remaining n is a prime number greater than 2\n    if (n > 1) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    size_t vlmax = __riscv_vsetvlmax_e32m8();\n    int divisor = 2;\n\n    while (n > 1) {\n        if (n % divisor == 0) {\n            int temp_n = n;\n            int count = 0;\n\n            // Vectorized loop to divide by divisor as long as possible\n            for (size_t vl; (vl = __riscv_vsetvl_e32m8(temp_n)) > 0;) {\n                vint32m8_t v_divisor = __riscv_vmv_v_x_i32m8(divisor, vl);\n                vint32m8_t v_temp_n = __riscv_vle32_v_i32m8(&temp_n, vl);\n                vbool4_t mask = __riscv_vmseq_vx_i32m8_b4(v_temp_n, 0, vl);\n\n                // Check divisibility and update temp_n\n                v_temp_n = __riscv_vdiv_vx_i32m8_m(mask, v_temp_n, divisor, vl);\n                __riscv_vse32_v_i32m8(&temp_n, v_temp_n, vl);\n\n                // Count how many times division occurred\n                count += __riscv_vcpop_m_b4(mask, vl);\n            }\n\n            // Append divisor 'count' times to factors\n            for (int i = 0; i < count; ++i) {\n                factors.push_back(divisor);\n            }\n            n /= divisor;\n        } else {\n            divisor++;\n        }\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    size_t vlmax = __riscv_vsetvlmax_e32m8();\n    int divisor = 2;\n\n    while (n > 1) {\n        if (n % divisor == 0) {\n            int temp_n = n;\n            int count = 0;\n\n            // Vectorized loop to divide by divisor as long as possible\n            while (temp_n % divisor == 0) {\n                size_t vl = __riscv_vsetvl_e32m8(1); // Single element for simplicity\n                vint32m8_t vec_n = __riscv_vmv_v_x_i32m8(temp_n, vl);\n                vint32m8_t vec_divisor = __riscv_vmv_v_x_i32m8(divisor, vl);\n                vbool4_t mask = __riscv_vmseq_vv_i32m8_b4(vec_n, vec_divisor, vl);\n\n                // Perform division and update temp_n\n                vint32m8_t result = __riscv_vdiv_vv_i32m8(vec_n, vec_divisor, vl);\n                temp_n = __riscv_vmv_x_s_i32m8_i32(result);\n\n                // Append divisor to factors\n                factors.push_back(divisor);\n                count++;\n            }\n            n /= static_cast<int>(std::pow(divisor, count));\n        }\n        divisor++;\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    size_t vlmax = __riscv_vsetvlmax_e32m1();\n    int divisor = 2;\n\n    while (n > 1) {\n        if (n % divisor == 0) {\n            int temp_n = n;\n            int count = 0;\n\n            // Vectorized loop to divide by divisor as long as possible\n            while (temp_n % divisor == 0) {\n                size_t vl = __riscv_vsetvl_e32m1(1); // Set vector length to 1 for scalar-like behavior\n                vint32m1_t vdivisor = __riscv_vmv_v_x_i32m1(divisor, vl);\n                vint32m1_t vtemp_n = __riscv_vmv_v_x_i32m1(temp_n, vl);\n\n                // Check divisibility using RVV\n                vbool32_t mask = __riscv_vmseq_vx_i32m1_b32(vtemp_n, 0, vl);\n                if (__riscv_vfirst_m_b32(mask, vl) >= 0) {\n                    break; // Exit if no more divisible\n                }\n\n                // Perform division and store result\n                vtemp_n = __riscv_vdiv_vx_i32m1(vtemp_n, divisor, vl);\n                temp_n = __riscv_vmv_x_s_i32m1_i32(vtemp_n);\n\n                // Append divisor to factors\n                factors.push_back(divisor);\n                count++;\n            }\n            n = temp_n;\n        }\n        divisor++;\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    size_t vlmax = __riscv_vsetvlmax_e32m8();\n    int divisor = 2;\n\n    while (n > 1) {\n        if (n % divisor == 0) {\n            int temp_n = n;\n            int count = 0;\n\n            // Vectorized loop to divide by divisor as long as possible\n            while (temp_n % divisor == 0) {\n                size_t vl = __riscv_vsetvl_e32m8(temp_n);\n                vint32m8_t vec_divisor = __riscv_vmv_v_x_i32m8(divisor, vl);\n                vbool4_t mask = __riscv_vmseq_vx_i32m8_b4(__riscv_vmv_v_x_i32m8(temp_n, vl), 0, vl);\n\n                temp_n /= divisor;\n                count++;\n            }\n\n            // Append divisor 'count' times to the result vector\n            for (int i = 0; i < count; ++i) {\n                factors.push_back(divisor);\n            }\n        }\n        divisor++;\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_75_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    size_t vlmax = vsetvlmax_e32m8();\n    size_t n = l.size();\n    size_t i = 0;\n\n    while (i < n) {\n        size_t vl = vsetvl_e32m8(n - i);\n        vfloat32m8_t vec = vle32_v_f32m8(&l[i], vl);\n        vbool4_t mask = vmfgt_vf_f32m8_b4(vec, 0.0f, vl);\n\n        // Count the number of positive elements\n        size_t count = vcpop_m_b4(mask, vl);\n        result.resize(result.size() + count);\n\n        // Compress and store positive elements\n        vfloat32m8_t compressed = vcompress_vm_f32m8(mask, vec, vl);\n        vse32_v_f32m8(&result[result.size() - count], compressed, count);\n        \n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    size_t vlmax = vsetvlmax_e32m8();\n    size_t n = l.size();\n    size_t i = 0;\n\n    while (i < n) {\n        size_t vl = vsetvl_e32m8(n - i);\n        vfloat32m8_t vec = vle32_v_f32m8(&l[i], vl);\n        vbool4_t mask = vmflt_vf_f32m8_b4(vec, 0.0f, vl);\n        vfloat32m8_t positive_vals = vcompress_vm_f32m8(mask, vec, vl);\n\n        // Store the compressed positive values into a temporary buffer\n        float temp[vlmax];\n        vse32_v_f32m8(temp, positive_vals, vl);\n\n        // Append the valid elements to the result vector\n        for (size_t j = 0; j < vl; ++j) {\n            if (temp[j] > 0) {\n                result.push_back(temp[j]);\n            }\n        }\n\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    size_t vlmax = vsetvlmax_e32m8();\n    size_t n = l.size();\n    size_t i = 0;\n\n    while (i < n) {\n        size_t vl = vsetvl_e32m8(n - i);\n        vfloat32m8_t vec = vle32_v_f32m8(&l[i], vl);\n        vbool4_t mask = vmfgt_vf_f32m8_b4(vec, 0.0f, vl);\n        vfloat32m8_t positive_vals = vcompress_vm_f32m8(mask, vec, vl);\n\n        // Store the compressed positive values into a temporary buffer\n        float temp[vlmax];\n        vse32_v_f32m8(temp, positive_vals, vl);\n\n        // Append the valid positive values to the result vector\n        for (size_t j = 0; j < vl; ++j) {\n            if (mask.b[j]) {\n                result.push_back(temp[j]);\n            }\n        }\n\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    size_t vlmax = vsetvlmax_e32m8();\n    size_t n = l.size();\n    size_t i = 0;\n\n    while (i < n) {\n        size_t vl = vsetvl_e32m8(n - i);\n        vfloat32m8_t vec = vle32_v_f32m8(&l[i], vl);\n        vbool4_t mask = vmflt_vf_f32m8_b4(vec, 0.0f, vl);\n        vfloat32m8_t positive_vals = vcompress_vm_f32m8(mask, vec, vl);\n\n        // Store the compressed positive values into a temporary buffer\n        float temp[vlmax];\n        vse32_v_f32m8(temp, positive_vals, vl);\n\n        // Append the positive values to the result vector\n        for (size_t j = 0; j < vl; ++j) {\n            if (temp[j] > 0) {\n                result.push_back(temp[j]);\n            }\n        }\n\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    size_t vlmax = vsetvlmax_e32m8();\n    size_t n = l.size();\n    size_t i = 0;\n\n    while (i < n) {\n        size_t vl = vsetvl_e32m8(n - i);\n        vfloat32m8_t vec = vle32_v_f32m8(&l[i], vl);\n        vbool4_t mask = vmflt_vf_f32m8_b4(vec, 0.0f, vl);\n        vfloat32m8_t positive_vals = vcompress_vm_f32m8(mask, vec, vl);\n\n        // Store the positive values into a temporary buffer\n        float temp[vlmax];\n        vse32_v_f32m8(temp, positive_vals, vl);\n\n        // Append the positive values to the result vector\n        for (size_t j = 0; j < vl; ++j) {\n            if (temp[j] > 0) {\n                result.push_back(temp[j]);\n            }\n        }\n\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_76_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    size_t vlmax = __riscv_vsetvlmax_e64m1();\n    int64_t limit = n / 2;\n    int64_t i = 5;\n\n    while (i <= limit) {\n        size_t vl = __riscv_vsetvl_e64m1(limit - i + 1);\n        vint64m1_t vec_i = __riscv_vid_v_i64m1(vl);\n        vec_i = __riscv_vadd_vx_i64m1(vec_i, i, vl);\n\n        vbool64_t mask = __riscv_vmseq_vx_i64m1_b64(vec_i, 0, vl);\n        vbool64_t div_mask = __riscv_vmsne_vx_i64m1_b64(__riscv_vrem_vx_i64m1(vec_i, n, vl), 0, vl);\n        mask = __riscv_vmand_mm_b64(mask, div_mask, vl);\n\n        if (__riscv_vfirst_m_b64(mask, vl) != -1) {\n            return false;\n        }\n\n        i += vl * 6;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    size_t vlmax = vsetvlmax_e64m1();\n    int64_t limit = n / 2;\n    int64_t i = 5;\n\n    while (i <= limit) {\n        bool is_divisible = false;\n        size_t vl = vsetvl_e64m1(vlmax);\n\n        vint64m1_t vec_i = vmul_vx_i64m1(vadd_vx_i64m1(vundefined_i64m1(), vl), 6, vl);\n        vec_i = vadd_vx_i64m1(vec_i, i, vl);\n\n        vbool64_t vec_mod1 = vmseq_vx_i64m1(vrem_vx_i64m1(vec_i, n, vl), 0, vl);\n        vbool64_t vec_mod2 = vmseq_vx_i64m1(vrem_vx_i64m1(vadd_vx_i64m1(vec_i, 2, vl), n, vl), 0, vl);\n\n        is_divisible = vmreduce_or(vmor_vv_i64m1(vec_mod1, vec_mod2, vl), vl);\n\n        if (is_divisible) {\n            return false;\n        }\n\n        i += 6 * vl;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    size_t vlmax = vsetvlmax_e64m1();\n    int64_t limit = sqrt(n);\n    int64_t i = 5;\n\n    while (i <= limit) {\n        bool divisible = false;\n        size_t vl = vsetvl_e64m1(vlmax);\n\n        vint64m1_t vec_i = vmul_vx_i64m1(vadd_vx_i64m1(vundefined_i64m1(), i), vl);\n        vbool64_t vec_divisible = vmseq_vx_i64m1(vmod_vx_i64m1(vec_i, n, vl), 0, vl);\n\n        if (vmfirst_m_b64(vec_divisible, vl) != -1) {\n            return false;\n        }\n\n        i += 6;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    size_t vlmax = vsetvlmax_e64m1();\n    int64_t limit = sqrt(n);\n    int64_t i = 5;\n\n    while (i <= limit) {\n        size_t vl = vsetvl_e64m1(vlmax);\n\n        vint64m1_t vec_i = vmul(vsetvl_e64m1(vl), i, vl);\n        vbool64_t vec_mod = vmseq_vv_i64m1(vec_i, n % vec_i, vl);\n\n        if (vmfirst_m_b64(vmnot_m_b64(vec_mod, vl)) != -1) {\n            return false;\n        }\n\n        i += 6;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    size_t vlmax = vsetvlmax_e64m1();\n    int64_t limit = sqrt(n);\n    int64_t i = 5;\n\n    while (i <= limit) {\n        // Load vector of potential divisors starting from i\n        vint64m1_t vec_i = vle64_v_i64m1(&i, vlmax);\n\n        // Broadcast n into a vector\n        vint64m1_t vec_n = vmv_v_x_i64m1(n, vlmax);\n\n        // Compute modulus for all elements in parallel\n        vint64m1_t vec_mod = vrem_vv_i64m1(vec_n, vec_i, vlmax);\n\n        // Check if any modulus result is zero\n        vbool64_t vec_is_zero = vmseq_vx_i64m1_b64(vec_mod, 0, vlmax);\n\n        // Reduce to check if any element was zero\n        if (vmreduce_any_true_b64(vec_is_zero, vlmax)) {\n            return false;\n        }\n\n        // Increment i by 6 for the next iteration\n        i += 6;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_77_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s) {\n    size_t len = s.size();\n    std::string result = s;\n    bool has_letter = false;\n\n    size_t vl;\n    vbool8_t mask;\n    vuint8m1_t vec, vec_alpha, vec_upper, vec_lower, vec_result;\n    uint8_t alpha_mask = 0x20;\n\n    for (size_t i = 0; i < len; i += vl) {\n        vl = vsetvl_e8m1(len - i);\n        vec = vle8_v_u8m1(reinterpret_cast<const uint8_t*>(&s[i]), vl);\n\n        // Check if character is a letter\n        vec_alpha = vmseq_vx_u8m1(vec, 'A', vl);\n        vec_alpha = vor_vv_u8m1(vec_alpha, vmseq_vx_u8m1(vec, 'a', vl), vl);\n        vec_alpha = vor_vv_u8m1(vec_alpha, vmseq_vx_u8m1(vec, 'Z', vl), vl);\n        vec_alpha = vor_vv_u8m1(vec_alpha, vmseq_vx_u8m1(vec, 'z', vl), vl);\n\n        // Toggle case if it's a letter\n        vec_upper = vand_vx_u8m1(vec_alpha, vec, vl);\n        vec_lower = vxor_vx_u8m1(vec_upper, alpha_mask, vl);\n        vec_result = vmerge_vvm_u8m1(vec_alpha, vec_lower, vec, vl);\n\n        // Store the result back\n        vse8_v_u8m1(reinterpret_cast<uint8_t*>(&result[i]), vec_result, vl);\n\n        // Check if there are any letters in this vector\n        mask = vmseq_vx_u8m1(vec_alpha, 0, vl);\n        if (!vmall(mask, vl)) {\n            has_letter = true;\n        }\n    }\n\n    // If no letters were found, reverse the string\n    if (!has_letter) {\n        std::reverse(result.begin(), result.end());\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s) {\n    size_t len = s.size();\n    std::string result = s;\n    bool has_letter = false;\n\n    size_t vlmax = vsetvlmax_e8m1();\n    for (size_t i = 0; i < len; i += vlmax) {\n        size_t vl = vsetvl_e8m1(len - i);\n\n        // Load vector of characters\n        vuint8m1_t vec = vle8_v_u8m1((const uint8_t*)(s.data() + i), vl);\n\n        // Create masks for lowercase and uppercase letters\n        vbool8_t is_lowercase = vmseq_vx_u8m1(vec, 'a', vl) | vmseq_vx_u8m1(vec, 'z', vl);\n        vbool8_t is_uppercase = vmseq_vx_u8m1(vec, 'A', vl) | vmseq_vx_u8m1(vec, 'Z', vl);\n\n        // Check if any letter exists\n        has_letter |= vmreduce_any_true_b8(is_lowercase, vl) || vmreduce_any_true_b8(is_uppercase, vl);\n\n        // Toggle case: Add or subtract 32 based on case\n        vuint8m1_t toggled = vadd_vx_u8m1(vec, 32, vl);\n        toggled = vsub_vx_u8m1(toggled, 64, vl);\n\n        // Selectively apply toggle only to letters\n        vbool8_t is_letter = vor_vv_b8(is_lowercase, is_uppercase, vl);\n        vec = vmerge_vvm_u8m1(is_letter, toggled, vec, vl);\n\n        // Store the result back\n        vse8_v_u8m1((uint8_t*)(result.data() + i), vec, vl);\n    }\n\n    // If no letters were found, reverse the string\n    if (!has_letter) {\n        std::reverse(result.begin(), result.end());\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s) {\n    size_t len = s.size();\n    std::string result = s;\n    bool has_letter = false;\n\n    size_t vl;\n    vbool8_t mask;\n    vuint8m1_t vec, vec_alpha, vec_upper, vec_lower, vec_res;\n    uint8_t alpha_mask = 0x20;\n\n    for (size_t i = 0; i < len; i += vl) {\n        vl = vsetvl_e8m1(len - i);\n        vec = vle8_v_u8m1((const uint8_t*)(s.data() + i), vl);\n\n        // Check if character is a letter\n        vec_alpha = vmseq_vx_u8m1(vec & 0xC0, 0x40, vl); // Mask to check if in 'A-Za-z' range\n        has_letter |= vmseq_vx_u8m1(vec_alpha, 1, vl) != 0;\n\n        // Toggle case for letters\n        vec_res = vec ^ (vec_alpha & alpha_mask);\n\n        // Store the result back\n        vse8_v_u8m1((uint8_t*)(result.data() + i), vec_res, vl);\n    }\n\n    // If no letters found, reverse the string\n    if (!has_letter) {\n        std::reverse(result.begin(), result.end());\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s) {\n    size_t len = s.size();\n    std::string result = s;\n    bool has_letter = false;\n\n    size_t vl;\n    vbool8_t mask;\n    vuint8m1_t vec, vec_result;\n    vuint8m1_t vec_upper, vec_lower, vec_alpha_mask, vec_reverse_mask;\n\n    // Constants for case conversion and alpha detection\n    uint8_t upper_case_diff = 'a' - 'A';\n    uint8_t lower_bound_a = 'a';\n    uint8_t upper_bound_z = 'z';\n    uint8_t lower_bound_A = 'A';\n    uint8_t upper_bound_Z = 'Z';\n\n    for (size_t i = 0; i < len; i += vl) {\n        vl = vsetvl_e8m1(len - i);\n\n        // Load vector of characters\n        vec = vle8_v_u8m1((const uint8_t*)(s.data() + i), vl);\n\n        // Create masks for lowercase and uppercase letters\n        vec_alpha_mask = vmfgtu_vx_u8m1(vec, lower_bound_A - 1, vl);\n        vec_alpha_mask = vmfgeu_vx_u8m1(vec_alpha_mask, vec, upper_bound_z + 1, vl);\n\n        // Detect if there are any letters in the string\n        has_letter |= vmseq_vx_u8m1_b8(vec_alpha_mask, 1, vl);\n\n        // Reverse case: Add or subtract 'a' - 'A'\n        vec_reverse_mask = vmfgtu_vx_u8m1(vec, lower_bound_a - 1, vl);\n        vec_reverse_mask = vmfgeu_vx_u8m1(vec_reverse_mask, vec, upper_bound_z + 1, vl);\n\n        vec_result = vsub_vx_u8m1_m(vec_reverse_mask, vec, upper_case_diff, vl);\n        vec_result = vadd_vx_u8m1_m(vnot_m_b8(vec_reverse_mask), vec, upper_case_diff, vl);\n\n        // Merge results back into the output\n        vec_result = vmerge_vvm_u8m1(vec_alpha_mask, vec_result, vec, vl);\n        vsse8_v_u8m1((uint8_t*)(result.data() + i), vec_result, vl);\n    }\n\n    // If no letters were found, reverse the entire string\n    if (!has_letter) {\n        std::reverse(result.begin(), result.end());\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s) {\n    size_t len = s.size();\n    std::string result = s;\n    bool has_letter = false;\n\n    size_t vl;\n    vbool8_t mask;\n    vuint8m1_t vec, vec_alpha, vec_upper, vec_lower, vec_res;\n\n    for (size_t i = 0; i < len; i += vl) {\n        vl = vsetvl_e8m1(len - i);\n        vec = vle8_v_u8m1((const uint8_t*)(s.data() + i), vl);\n\n        // Check if character is a letter\n        vec_alpha = vmfgt_vx_u8m1(vec, 'A' - 1, vl);\n        vec_alpha = vmfand_vv_u8m1(vec_alpha, vmflt_vx_u8m1(vec, 'z' + 1, vl), vl);\n        mask = vmfne_vx_u8m1(vec_alpha, 0, vl);\n\n        // Check if there are any letters in the string\n        if (!has_letter) {\n            has_letter = vmfirst_m_b8(mask, vl) != -1;\n        }\n\n        // Convert lowercase to uppercase and vice versa\n        vec_upper = vsub_vx_u8m1(vec, 'a' - 'A', vl);\n        vec_lower = vadd_vx_u8m1(vec, 'a' - 'A', vl);\n\n        vec_res = vmerge_vvm_u8m1(mask, vmfge_vx_u8m1(vec, 'a', vl), vec_upper, vec_lower, vl);\n        vec_res = vmerge_vvm_u8m1(mask, vmflt_vx_u8m1(vec, 'A', vl), vec_res, vec, vl);\n\n        // Store the result back\n        vse8_v_u8m1((uint8_t*)(result.data() + i), vec_res, vl);\n    }\n\n    // If no letters were found, reverse the string\n    if (!has_letter) {\n        std::reverse(result.begin(), result.end());\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t vlmax = __riscv_vsetvlmax_e32m8();\n    size_t n = l.size();\n    std::vector<int> result = l;\n\n    // Extract elements at indices divisible by 3\n    std::vector<int> third_elements;\n    for (size_t i = 0; i < n; i += 3) {\n        third_elements.push_back(l[i]);\n    }\n\n    // Sort the extracted elements\n    std::sort(third_elements.begin(), third_elements.end());\n\n    // Replace the original indices divisible by 3 with sorted values using RVV\n    size_t num_thirds = third_elements.size();\n    size_t idx = 0;\n\n    for (size_t i = 0; i < n; i += vlmax) {\n        size_t vl = __riscv_vsetvl_e32m8(n - i);\n\n        // Load the current segment of the result vector\n        vint32m8_t vec = __riscv_vle32_v_i32m8(&result[i], vl);\n\n        // Create a mask for indices divisible by 3\n        vbool4_t mask = __riscv_vmseq_vx_i32m8_b4(__riscv_vid_v_i32m8(vl), 0, vl);\n\n        // Load sorted values into a vector\n        vint32m8_t sorted_vals = __riscv_vle32_v_i32m8(&third_elements[idx], vl);\n\n        // Replace values in the result vector using the mask\n        vec = __riscv_vmerge_vvm_i32m8(vec, sorted_vals, mask, vl);\n\n        // Store the updated vector back to memory\n        __riscv_vse32_v_i32m8(&result[i], vec, vl);\n\n        idx += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <algorithm>\n#include <vector>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t vlmax = __riscv_vsetvlmax_e32m8();\n    size_t n = l.size();\n    std::vector<int> result = l;\n\n    // Extract elements at indices divisible by 3\n    std::vector<int> divisible_by_three;\n    for (size_t i = 0; i < n; i += 3) {\n        divisible_by_three.push_back(l[i]);\n    }\n\n    // Sort the extracted elements\n    std::sort(divisible_by_three.begin(), divisible_by_three.end());\n\n    // Replace the original indices divisible by 3 with sorted values\n    size_t j = 0;\n    for (size_t i = 0; i < n; i += 3) {\n        result[i] = divisible_by_three[j++];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <algorithm>\n#include <vector>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t vlmax = __riscv_vsetvlmax_e32m8();\n    size_t n = l.size();\n    std::vector<int> result = l;\n\n    // Extract elements at indices divisible by 3\n    std::vector<int> divisible_by_three;\n    for (size_t i = 0; i < n; i += 3) {\n        divisible_by_three.push_back(l[i]);\n    }\n\n    // Sort the extracted elements\n    std::sort(divisible_by_three.begin(), divisible_by_three.end());\n\n    // Replace the original indices divisible by 3 with sorted values\n    size_t sorted_idx = 0;\n    for (size_t i = 0; i < n; i += 3) {\n        result[i] = divisible_by_three[sorted_idx++];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <algorithm>\n#include <vector>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t vlmax = __riscv_vsetvlmax_e32m8();\n    size_t n = l.size();\n    std::vector<int> result = l;\n\n    // Extract elements at indices divisible by 3\n    std::vector<int> divisible_by_three;\n    for (size_t i = 0; i < n; i += 3) {\n        divisible_by_three.push_back(l[i]);\n    }\n\n    // Sort the extracted elements\n    std::sort(divisible_by_three.begin(), divisible_by_three.end());\n\n    // Replace the original indices divisible by 3 with sorted values using RVV\n    size_t k = 0;\n    for (size_t i = 0; i < n; i += 3) {\n        size_t vl = __riscv_vsetvl_e32m8(n - i);\n        int32_t value = divisible_by_three[k++];\n        result[i] = value;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <algorithm>\n#include <vector>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t vlmax = __riscv_vsetvlmax_e32m8();\n    size_t n = l.size();\n    std::vector<int> result = l;\n\n    // Extract elements at indices divisible by 3\n    std::vector<int> divisible_by_three;\n    for (size_t i = 0; i < n; i += 3) {\n        divisible_by_three.push_back(l[i]);\n    }\n\n    // Sort the extracted elements\n    std::sort(divisible_by_three.begin(), divisible_by_three.end());\n\n    // Replace the original indices divisible by 3 with sorted values\n    size_t j = 0;\n    for (size_t i = 0; i < n; i += 3) {\n        result[i] = divisible_by_three[j++];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_79_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nfloat max_element_simd(std::vector<float> l) {\n    size_t vlmax = vsetvlmax_e32m1();\n    float max_val = l[0];\n    size_t i = 0;\n\n    for (; i + vlmax <= l.size(); i += vlmax) {\n        vfloat32m1_t vec = vle32_v_f32m1(&l[i], vlmax);\n        vfloat32m1_t max_vec = vfmax_vv_f32m1(vec, vec, vlmax);\n\n        // Horizontal reduction to find the maximum in the vector\n        for (size_t j = vlmax / 2; j > 0; j /= 2) {\n            max_vec = vfmax_vv_f32m1(max_vec, vslide1down_vx_f32m1(max_vec, max_vec, vlmax), vlmax);\n        }\n\n        // Extract the maximum value from the vector\n        float temp_max;\n        vse32_v_f32m1(&temp_max, max_vec, 1);\n        if (temp_max > max_val) {\n            max_val = temp_max;\n        }\n    }\n\n    // Process remaining elements\n    for (; i < l.size(); ++i) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nfloat max_element_simd(std::vector<float> l) {\n    size_t vlmax = vsetvlmax_e32m1();\n    float max_val = l[0];\n    size_t i = 0;\n\n    for (; i + vlmax <= l.size(); i += vlmax) {\n        vfloat32m1_t vec = vle32_v_f32m1(&l[i], vlmax);\n        vfloat32m1_t max_vec = vfmax_vv_f32m1(vec, vec, vlmax);\n        float temp_max = vmax(xs)(f32, m1)(max_vec, vlmax);\n        if (temp_max > max_val) {\n            max_val = temp_max;\n        }\n    }\n\n    for (; i < l.size(); ++i) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nfloat max_element_simd(std::vector<float> l) {\n    size_t vlmax = vsetvlmax_e32m1();\n    float max_val = l[0];\n    size_t i = 0;\n\n    for (; i + vlmax <= l.size(); i += vlmax) {\n        vfloat32m1_t vec = vle32_v_f32m1(&l[i], vlmax);\n        vfloat32m1_t max_vec = vfmax_vv_f32m1(vec, vec, vlmax);\n        float temp_max = vmax(xs)(f32, m1)(max_vec, vlmax);\n        if (temp_max > max_val) {\n            max_val = temp_max;\n        }\n    }\n\n    for (; i < l.size(); ++i) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nfloat max_element_simd(std::vector<float> l) {\n    size_t vlmax = vsetvlmax_e32m1();\n    float max_val = l[0];\n    size_t i = 0;\n\n    for (; i + vlmax <= l.size(); i += vlmax) {\n        vfloat32m1_t vec = vle32_v_f32m1(&l[i], vlmax);\n        vfloat32m1_t max_vec = vfmax_vv_f32m1(vec, vec, vlmax);\n\n        // Reduce within the vector to find the maximum value\n        for (size_t j = vlmax / 2; j > 0; j /= 2) {\n            max_vec = vfmax_vv_f32m1(max_vec, vslide1down_vx_f32m1(max_vec, max_vec, vlmax), vlmax);\n        }\n\n        // Extract the maximum value from the vector\n        float temp_max;\n        vse32_v_f32m1(&temp_max, max_vec, 1);\n        if (temp_max > max_val) {\n            max_val = temp_max;\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < l.size(); ++i) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nfloat max_element_simd(std::vector<float> l) {\n    size_t vlmax = vsetvlmax_e32m1();\n    float max_val = l[0];\n    size_t i = 0;\n\n    for (; i + vlmax <= l.size(); i += vlmax) {\n        vfloat32m1_t vec = vle32_v_f32m1(&l[i], vlmax);\n        vfloat32m1_t max_vec = vfmax_vv_f32m1(vec, vec, vlmax);\n\n        for (size_t j = 0; j < vlmax; ++j) {\n            float val = ((float*)&max_vec)[j];\n            if (val > max_val) {\n                max_val = val;\n            }\n        }\n    }\n\n    for (; i < l.size(); ++i) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_80_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint fizz_buzz_simd(int n) {\n    int result = 0;\n    size_t vl;\n\n    for (int i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m8(n - i);\n\n        vuint32m8_t vec = vid_v_u32m8(vl);\n        vec = vadd_vx_u32m8(vec, i, vl);\n\n        vbool4_t mask11 = vmseq_vx_u32m8(vmod_vx_u32m8(vec, 11, vl), 0, vl);\n        vbool4_t mask13 = vmseq_vx_u32m8(vmod_vx_u32m8(vec, 13, vl), 0, vl);\n        vbool4_t mask = vor_vv_i32m8(mask11, mask13, vl);\n\n        vuint32m8_t masked_values = vcompress_vm_i32m8(mask, vec, vl);\n\n        int count = vcpop_m_b32(vmclr_m(), mask, vl);\n        for (int j = 0; j < count; ++j) {\n            int value = ((uint32_t*)&masked_values)[j];\n            while (value > 0) {\n                if (value % 10 == 7) {\n                    result++;\n                }\n                value /= 10;\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_80_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint fizz_buzz_simd(int n) {\n    int result = 0;\n    size_t vl;\n\n    for (int i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m8(n - i);\n\n        vuint32m8_t vec = vid_v_u32m8(vl);\n        vuint32m8_t offset = vmul_vx_u32m8(vec, i, vl);\n        vec = vadd_vv_u32m8(vec, offset, vl);\n\n        vbool4_t mask11 = vmseq_vx_u32m8(vmod_vx_u32m8(vec, 11, vl), 0, vl);\n        vbool4_t mask13 = vmseq_vx_u32m8(vmod_vx_u32m8(vec, 13, vl), 0, vl);\n        vbool4_t mask = vor_mm_b4(mask11, mask13, vl);\n\n        vuint32m8_t filtered = vcompress_vm_b4_u32m8(mask, vec, vl);\n\n        int count = vcpop_m_b4(mask, vl);\n        for (int j = 0; j < count; ++j) {\n            int num = ((uint32_t*)&filtered)[j];\n            while (num > 0) {\n                if (num % 10 == 7) {\n                    result++;\n                }\n                num /= 10;\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_80_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint fizz_buzz_simd(int n) {\n    int result = 0;\n    size_t vl;\n\n    for (int i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m8(n - i);\n\n        vuint32m8_t vec_indices = vid_v_u32m8(vl);\n        vec_indices = vadd_vx_u32m8(vec_indices, i, vl);\n\n        vbool4_t vec_div_11 = vmseq_vx_u32m8(vmod_vx_u32m8(vec_indices, 11, vl), 0, vl);\n        vbool4_t vec_div_13 = vmseq_vx_u32m8(vmod_vx_u32m8(vec_indices, 13, vl), 0, vl);\n        vbool4_t vec_divisible = vor_vv_i32m8(vec_div_11, vec_div_13, vl);\n\n        vuint32m8_t vec_numbers = vand_vx_u32m8(vec_indices, vec_divisible, vl);\n\n        // Convert numbers to string-like representation and count '7'\n        vuint32m8_t vec_seven_count = vmv_v_x_u32m8(0, vl);\n        for (int digit = 0; digit < 10; ++digit) {\n            vuint32m8_t vec_digit = vmv_v_x_u32m8(digit, vl);\n            vbool4_t vec_has_digit = vmseq_vv_u32m8(vec_numbers, vec_digit, vl);\n            vec_seven_count = vadd_vx_u32m8(vec_seven_count, vmv_v_x_u32m8(digit == 7 ? 1 : 0, vl), vl);\n        }\n\n        // Reduce the vector sum to scalar\n        result += vsum_vs_u32m8_u32(vec_seven_count, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_80_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint fizz_buzz_simd(int n) {\n    int result = 0;\n    size_t vl;\n\n    for (int i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m8(n - i);\n\n        vuint32m8_t vec_indices = vid_v_u32m8(vl);\n        vec_indices = vadd_vx_u32m8(vec_indices, i, vl);\n\n        vbool4_t vec_div_11 = vmseq_vx_u32m8(vmod_vx_u32m8(vec_indices, 11, vl), 0, vl);\n        vbool4_t vec_div_13 = vmseq_vx_u32m8(vmod_vx_u32m8(vec_indices, 13, vl), 0, vl);\n        vbool4_t vec_divisible = vor_vv_i32m8(vec_div_11, vec_div_13, vl);\n\n        vuint32m8_t vec_numbers = vand_vx_u32m8(vec_indices, vec_divisible, vl);\n\n        // Convert numbers to string-like representation and count '7's\n        vuint32m8_t vec_seven_count = vmv_v_x_u32m8(0, vl);\n        for (int digit_pos = 0; digit_pos < 10; ++digit_pos) {\n            vuint32m8_t vec_digit = vdiv_vx_u32m8(vec_numbers, 10, vl);\n            vuint32m8_t vec_remainder = vmod_vx_u32m8(vec_numbers, 10, vl);\n            vec_seven_count = vadd_vx_u32m8(vec_seven_count, vmseq_vx_u32m8(vec_remainder, 7, vl), vl);\n            vec_numbers = vec_digit;\n        }\n\n        // Reduce the vector counts into a scalar sum\n        uint32_t temp_sum[vl];\n        vse32_v_u32m8(temp_sum, vec_seven_count, vl);\n        for (size_t j = 0; j < vl; ++j) {\n            result += temp_sum[j];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_80_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint fizz_buzz_simd(int n) {\n    int result = 0;\n    size_t vl;\n\n    for (int i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m8(n - i);\n\n        vuint32m8_t vec = vid_v_u32m8(vl);\n        vec = vadd_vx_u32m8(vec, i, vl);\n\n        vbool4_t mask_11 = vmseq_vx_u32m8(vmod_vx_u32m8(vec, 11, vl), 0, vl);\n        vbool4_t mask_13 = vmseq_vx_u32m8(vmod_vx_u32m8(vec, 13, vl), 0, vl);\n        vbool4_t mask = vor_vv_i32m8(mask_11, mask_13, vl);\n\n        vuint32m8_t masked_values = vcompress_vm_i32m8(mask, vec, vl);\n\n        int count = vcpop_m_b32(mask, vl);\n        for (int j = 0; j < count; ++j) {\n            int value = ((uint32_t*)&masked_values)[j];\n            while (value > 0) {\n                if (value % 10 == 7) {\n                    result++;\n                }\n                value /= 10;\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t vlmax = __riscv_vsetvlmax_e32m1();\n    size_t n = l.size();\n    std::vector<float> even_elements;\n    std::vector<float> result = l;\n\n    // Extract even-indexed elements\n    for (size_t i = 0; i < n; i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    // Sort the even-indexed elements\n    std::sort(even_elements.begin(), even_elements.end());\n\n    // Replace the even-indexed positions in the result with sorted values\n    size_t even_idx = 0;\n    for (size_t i = 0; i < n; i += 2) {\n        result[i] = even_elements[even_idx++];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <algorithm>\n#include <vector>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t vlmax = __riscv_vsetvlmax_e32m1();\n    size_t n = l.size();\n    std::vector<float> even_values;\n    even_values.reserve((n + 1) / 2);\n\n    // Extract even-indexed elements\n    for (size_t i = 0; i < n; i += 2) {\n        even_values.push_back(l[i]);\n    }\n\n    // Sort the even-indexed elements\n    std::sort(even_values.begin(), even_values.end());\n\n    // Reinsert sorted even-indexed elements using RVV intrinsics\n    size_t even_idx = 0;\n    size_t i = 0;\n\n    while (i < n) {\n        size_t vl = __riscv_vsetvl_e32m1(n - i);\n\n        // Load vector from memory\n        vfloat32m1_t vec = __riscv_vle32_v_f32m1(&l[i], vl);\n\n        // Create a mask for even indices\n        vbool32_t mask = __riscv_vmseq_vx_i32m1(__riscv_vid_v_i32m1(vl), 0, vl);\n\n        // Load sorted even values into a vector\n        vfloat32m1_t even_vec = __riscv_vle32_v_f32m1(&even_values[even_idx], vl);\n\n        // Merge sorted even values into the original vector using the mask\n        vec = __riscv_vmerge_vvm_f32m1(mask, even_vec, vec, vl);\n\n        // Store the result back to memory\n        __riscv_vse32_v_f32m1(&l[i], vec, vl);\n\n        // Update indices\n        i += vl;\n        even_idx += __riscv_vcpop_m_b32(mask, vl);\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_81_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t vlmax = __riscv_vsetvlmax_e32m1();\n    size_t n = l.size();\n    std::vector<float> even_elements;\n    \n    // Extract even-indexed elements\n    for (size_t i = 0; i < n; i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    // Sort the even-indexed elements\n    std::sort(even_elements.begin(), even_elements.end());\n\n    // Reintegrate sorted even-indexed elements using RVV intrinsics\n    size_t even_idx = 0;\n    for (size_t i = 0; i < n; i += vlmax) {\n        size_t vl = __riscv_vsetvl_e32m1(n - i);\n\n        // Load the original vector segment\n        vfloat32m1_t vec = __riscv_vle32_v_f32m1(&l[i], vl);\n\n        // Create a mask for even indices\n        vbool32_t mask = __riscv_vmseq.vx_i32m1_b32(i % 2 == 0 ? 0 : 1, vl);\n\n        // Load sorted even elements into a vector\n        vfloat32m1_t sorted_even_vec = __riscv_vle32_v_f32m1(&even_elements[even_idx], vl);\n        even_idx += vl;\n\n        // Merge sorted even elements into the original vector using the mask\n        vec = __riscv_vmerge_vxm_f32m1(vec, sorted_even_vec, mask, vl);\n\n        // Store the result back to memory\n        __riscv_vse32_v_f32m1(&l[i], vec, vl);\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_81_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t vlmax = __riscv_vsetvlmax_e32m1();\n    size_t n = l.size();\n    std::vector<float> even_elements;\n    even_elements.reserve((n + 1) / 2);\n\n    // Extract even-indexed elements\n    for (size_t i = 0; i < n; i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    // Sort the even-indexed elements\n    std::sort(even_elements.begin(), even_elements.end());\n\n    // Reintegrate sorted even-indexed elements back into the original vector using RVV\n    size_t even_idx = 0;\n    size_t i = 0;\n\n    while (i < n) {\n        size_t vl = __riscv_vsetvl_e32m1(n - i);\n\n        // Load elements from the vector\n        vfloat32m1_t vec = __riscv_vle32_v_f32m1(&l[i], vl);\n\n        // Create a mask for even indices\n        vbool32_t mask = __riscv_vmseq.vx_i32m1_b32(i % 2 == 0 ? 0 : 1, vl);\n\n        // Replace even-indexed elements with sorted values\n        for (size_t j = 0; j < vl; ++j) {\n            if (i + j < n && (i + j) % 2 == 0) {\n                vec = __riscv_vfmerge_vf_f32m1(vec, even_elements[even_idx++], mask, vl);\n            }\n        }\n\n        // Store the modified vector back to memory\n        __riscv_vse32_v_f32m1(&l[i], vec, vl);\n\n        i += vl;\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_81_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <algorithm>\n#include <vector>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t vlmax = __riscv_vsetvlmax_e32m1();\n    size_t n = l.size();\n    std::vector<float> even_elements;\n    \n    // Extract even-indexed elements\n    for (size_t i = 0; i < n; i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    // Sort the even-indexed elements\n    std::sort(even_elements.begin(), even_elements.end());\n\n    // Reintegrate sorted even-indexed elements using RVV intrinsics\n    size_t even_idx = 0;\n    size_t i = 0;\n\n    while (i < n) {\n        size_t vl = __riscv_vsetvl_e32m1(n - i);\n\n        // Load elements from the original vector\n        vfloat32m1_t vec = __riscv_vle32_v_f32m1(&l[i], vl);\n\n        // Create a mask for even indices\n        vbool32_t mask = __riscv_vmseq.vx_i32m1_b32(i % 2 == 0, vl);\n\n        // Replace even-indexed elements with sorted values\n        for (size_t j = 0; j < vl; ++j) {\n            if (mask & (1 << j)) {\n                vec[j] = even_elements[even_idx++];\n            }\n        }\n\n        // Store the modified vector back to memory\n        __riscv_vse32_v_f32m1(&l[i], vec, vl);\n\n        i += vl;\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_82_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 3) return false;\n\n    bool found = false;\n    size_t vlmax = vsetvlmax_e32m8();\n\n    for (size_t i = 0; i < n - 2 && !found; ++i) {\n        for (size_t j = i + 1; j < n - 1 && !found; ++j) {\n            int target = -(l[i] + l[j]);\n            size_t k = j + 1;\n\n            while (k < n) {\n                size_t vl = vsetvl_e32m8(n - k);\n                vint32m8_t vec_k = vle32_v_i32m8(&l[k], vl);\n                vbool4_t cmp = vmseq_vx_i32m8_b4(vec_k, target, vl);\n                if (vmfirst_m_b4(cmp, vl) != -1) {\n                    found = true;\n                    break;\n                }\n                k += vl;\n            }\n        }\n    }\n\n    return found;\n}\n```"}
{"task_id": "SimdBench_82_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 3) return false;\n\n    bool found = false;\n    size_t vlmax = __riscv_vsetvlmax_e32m1();\n\n    for (size_t i = 0; i < n - 2 && !found; ++i) {\n        for (size_t j = i + 1; j < n - 1 && !found; ++j) {\n            int target = -(l[i] + l[j]);\n\n            size_t k = j + 1;\n            while (k < n) {\n                size_t vl = __riscv_vsetvl_e32m1(n - k);\n                vint32m1_t vec = __riscv_vle32_v_i32m1(&l[k], vl);\n\n                vbool32_t cmp = __riscv_vmseq_vx_i32m1_b32(vec, target, vl);\n                if (__riscv_vfirst_m_b32(cmp, vl) != -1) {\n                    found = true;\n                    break;\n                }\n\n                k += vl;\n            }\n        }\n    }\n\n    return found;\n}\n```"}
{"task_id": "SimdBench_82_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 3) return false;\n\n    size_t vlmax = __riscv_vsetvlmax_e32m8();\n    int *data = l.data();\n\n    for (size_t i = 0; i < n - 2; ++i) {\n        for (size_t j = i + 1; j < n - 1; ++j) {\n            int target = -(data[i] + data[j]);\n\n            size_t k = j + 1;\n            while (k < n) {\n                size_t vl = __riscv_vsetvl_e32m8(n - k);\n                vint32m8_t vec = __riscv_vle32_v_i32m8(&data[k], vl);\n\n                vbool4_t cmp = __riscv_vmseq_vx_i32m8_b4(vec, target, vl);\n                if (__riscv_vfirst_m_b4(cmp, vl) != -1) {\n                    return true;\n                }\n\n                k += vl;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 3) return false;\n\n    bool found = false;\n    size_t vlmax = __riscv_vsetvlmax_e32m1();\n\n    for (size_t i = 0; i < n - 2 && !found; ++i) {\n        for (size_t j = i + 1; j < n - 1 && !found; ++j) {\n            int target = -(l[i] + l[j]);\n\n            size_t k = j + 1;\n            while (k < n) {\n                size_t vl = __riscv_vsetvl_e32m1(n - k);\n                vint32m1_t vec = __riscv_vle32_v_i32m1(&l[k], vl);\n\n                vbool32_t cmp = __riscv_vmseq_vx_i32m1_b32(vec, target, vl);\n                if (__riscv_vfirst_m_b32(cmp, vl) != -1) {\n                    found = true;\n                    break;\n                }\n\n                k += vl;\n            }\n        }\n    }\n\n    return found;\n}\n```"}
{"task_id": "SimdBench_82_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 3) return false;\n\n    bool found = false;\n    size_t vlmax = vsetvlmax_e32m1();\n\n    for (size_t i = 0; i < n - 2 && !found; ++i) {\n        for (size_t j = i + 1; j < n - 1 && !found; ++j) {\n            int target = -(l[i] + l[j]);\n            size_t k = j + 1;\n\n            while (k < n) {\n                size_t vl = vsetvl_e32m1(n - k);\n                vint32m1_t vec = vle32_v_i32m1(&l[k], vl);\n\n                vbool32_t cmp = vmseq_vx_i32m1(vec, target, vl);\n                if (vmfirst_m_b32(cmp, vl) != -1) {\n                    found = true;\n                    break;\n                }\n\n                k += vl;\n            }\n        }\n    }\n\n    return found;\n}\n```"}
{"task_id": "SimdBench_83_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t vlmax = __riscv_vsetvlmax_e32m1();\n    size_t n = l.size();\n    std::vector<int> result(n);\n\n    for (size_t i = 0; i < n; i += vlmax) {\n        size_t vl = __riscv_vsetvl_e32m1(n - i);\n        vint32m1_t vec = __riscv_vle32_v_i32m1(&l[i], vl);\n        vec = __riscv_vadd_vx_i32m1(vec, 1, vl);\n        __riscv_vse32_v_i32m1(&result[i], vec, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t vlmax = __riscv_vsetvlmax_e32m1();\n    std::vector<int> result(l.size());\n\n    for (size_t i = 0; i < l.size(); i += vlmax) {\n        size_t vl = __riscv_vsetvl_e32m1(l.size() - i);\n        vint32m1_t vec = __riscv_vle32_v_i32m1(&l[i], vl);\n        vec = __riscv_vadd_vx_i32m1(vec, 1, vl);\n        __riscv_vse32_v_i32m1(&result[i], vec, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t vlmax = __riscv_vsetvlmax_e32m1();\n    size_t n = l.size();\n    std::vector<int> result(n);\n\n    for (size_t i = 0; i < n; i += vlmax) {\n        size_t vl = __riscv_vsetvl_e32m1(n - i);\n        vint32m1_t vec = __riscv_vle32_v_i32m1(&l[i], vl);\n        vec = __riscv_vadd_vx_i32m1(vec, 1, vl);\n        __riscv_vse32_v_i32m1(&result[i], vec, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t vlmax = __riscv_vsetvlmax_e32m1();\n    size_t n = l.size();\n    std::vector<int> result(n);\n\n    for (size_t i = 0; i < n; i += vlmax) {\n        size_t vl = __riscv_vsetvl_e32m1(n - i);\n        vint32m1_t vec = __riscv_vle32_v_i32m1(l.data() + i, vl);\n        vec = __riscv_vadd_vx_i32m1(vec, 1, vl);\n        __riscv_vse32_v_i32m1(result.data() + i, vec, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t vlmax = __riscv_vsetvlmax_e32m1();\n    size_t n = l.size();\n    std::vector<int> result(n);\n\n    for (size_t i = 0; i < n; i += vlmax) {\n        size_t vl = __riscv_vsetvl_e32m1(n - i);\n        vint32m1_t vec = __riscv_vle32_v_i32m1(&l[i], vl);\n        vint32m1_t vec_incr = __riscv_vadd_vx_i32m1(vec, 1, vl);\n        __riscv_vse32_v_i32m1(&result[i], vec_incr, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_84_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    size_t vlmax = __riscv_vsetvlmax_e32m1();\n    size_t n = l.size();\n    bool found = false;\n\n    for (size_t i = 0; i < n; i++) {\n        int x = l[i];\n        size_t j = 0;\n\n        while (j < n) {\n            size_t vl = __riscv_vsetvl_e32m1(n - j);\n            vint32m1_t vec = __riscv_vle32_v_i32m1(&l[j], vl);\n\n            // Check if any element in the vector equals -x\n            vbool32_t mask = __riscv_vmseq_vx_i32m1_b32(vec, -x, vl);\n            if (__riscv_vfirst_m_b32(mask, vl) != -1) {\n                found = true;\n                break;\n            }\n\n            j += vl;\n        }\n\n        if (found) {\n            break;\n        }\n    }\n\n    return found;\n}\n```"}
{"task_id": "SimdBench_84_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <stdbool.h>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    size_t vlmax = __riscv_vsetvlmax_e32m1();\n    size_t n = l.size();\n    int *data = l.data();\n\n    for (size_t i = 0; i < n; i++) {\n        size_t j = i + 1;\n        while (j < n) {\n            size_t vl = __riscv_vsetvl_e32m1(n - j);\n            vint32m1_t vec_i = __riscv_vmv_v_x_i32m1(data[i], vl);\n            vint32m1_t vec_j = __riscv_vle32_v_i32m1(&data[j], vl);\n\n            vbool32_t mask = __riscv_vmseq_vx_i32m1(__riscv_vadd_vv_i32m1(vec_i, vec_j, vl), 0, vl);\n            if (__riscv_vfirst_m_b32(mask, vl) != -1) {\n                return true;\n            }\n            j += vl;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <stdbool.h>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    size_t vlmax = __riscv_vsetvlmax_e32m8();\n    size_t n = l.size();\n    int* data = l.data();\n\n    for (size_t i = 0; i < n; i++) {\n        size_t j = i + 1;\n        while (j < n) {\n            size_t vl = __riscv_vsetvl_e32m8(n - j);\n            vint32m8_t vi = __riscv_vle32_v_i32m8(&data[j], vl);\n            vint32m8_t vx = __riscv_vmv_v_x_i32m8(data[i], vl);\n            vbool4_t cmp = __riscv_vmseq_vv_i32m8_b4(__riscv_vadd_vv_i32m8(vx, vi, vl), __riscv_vmv_v_x_i32m8(0, vl), vl);\n\n            if (__riscv_vfirst_m_b4(cmp, vl) != -1) {\n                return true;\n            }\n            j += vl;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    size_t vlmax = __riscv_vsetvlmax_e32m1();\n    size_t n = l.size();\n    int *data = l.data();\n\n    for (size_t i = 0; i < n; i++) {\n        size_t j = i + 1;\n        while (j < n) {\n            size_t vl = __riscv_vsetvl_e32m1(n - j);\n            vint32m1_t vi = __riscv_vle32_v_i32m1(&data[j], vl);\n            vint32m1_t vx = __riscv_vadd_vx_i32m1(vi, data[i], vl);\n            vbool32_t cmp = __riscv_vmseq_vx_i32m1_b32(vx, 0, vl);\n            if (__riscv_vfirst_m_b32(cmp, vl) != -1) {\n                return true;\n            }\n            j += vl;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    size_t vlmax = __riscv_vsetvlmax_e32m1();\n    size_t n = l.size();\n    bool found = false;\n\n    for (size_t i = 0; i < n; ++i) {\n        int x = l[i];\n        size_t j = 0;\n\n        while (j < n) {\n            size_t vl = __riscv_vsetvl_e32m1(n - j);\n            vint32m1_t vec = __riscv_vle32_v_i32m1(&l[j], vl);\n\n            vint32m1_t neg_x_vec = __riscv_vmv_v_x_i32m1(-x, vl);\n            vbool32_t cmp = __riscv_vmseq_vv_i32m1_b32(vec, neg_x_vec, vl);\n\n            if (__riscv_vfirst_m_b32(cmp, vl) != -1) {\n                found = true;\n                break;\n            }\n\n            j += vl;\n        }\n\n        if (found) {\n            break;\n        }\n    }\n\n    return found;\n}\n```"}
{"task_id": "SimdBench_85_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    std::string result;\n    size_t vlmax = __riscv_vsetvlmax_e8m1();\n    uint8_t buffer[64]; // Temporary buffer for SIMD processing\n    uint8_t *ptr = buffer;\n\n    // Initialize vector registers\n    vuint8m1_t vbase = __riscv_vmv_v_x_u8m1(base, vlmax);\n    vint64m1_t vx = __riscv_vmv_v_x_i64m1(x, vlmax);\n\n    while (x > 0) {\n        // Compute x % base using SIMD\n        vint64m1_t vremainder = __riscv_vrem_vx_i64m1(vx, vbase, vlmax);\n        int64_t remainder = __riscv_vmv_x_s_i64m1_i64(vremainder);\n\n        // Store the remainder as a character\n        *ptr++ = '0' + remainder;\n\n        // Update x = x / base using SIMD\n        vx = __riscv_vdiv_vx_i64m1(vx, vbase, vlmax);\n        x = __riscv_vmv_x_s_i64m1_i64(vx);\n    }\n\n    // Reverse the buffer to form the result string\n    while (ptr != buffer) {\n        result.push_back(*--ptr);\n    }\n\n    return result.empty() ? \"0\" : result;\n}\n```"}
{"task_id": "SimdBench_85_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    char buffer[65]; // Maximum size for base 2 representation of 64-bit number + null terminator\n    int index = 64;\n    buffer[index] = '\\0';\n\n    size_t vlmax = __riscv_vsetvlmax_e64m1();\n    vint64m1_t vx = __riscv_vmv_v_x_i64m1(x, vlmax);\n    vint64m1_t vbase = __riscv_vmv_v_x_i64m1(base, vlmax);\n    vbool64_t mask;\n\n    while (true) {\n        vint64m1_t vremainder = __riscv_vdiv_vv_i64m1(vx, vbase, vlmax);\n        vint64m1_t vquotient = __riscv_vrem_vv_i64m1(vx, vbase, vlmax);\n\n        // Extract scalar remainder and quotient\n        int64_t remainder = __riscv_vmv_x_s_i64m1_i64(vremainder);\n        int64_t quotient = __riscv_vmv_x_s_i64m1_i64(vquotient);\n\n        buffer[--index] = '0' + remainder;\n\n        if (quotient == 0) {\n            break;\n        }\n\n        vx = __riscv_vmv_v_x_i64m1(quotient, vlmax);\n    }\n\n    return std::string(buffer + index);\n}\n```"}
{"task_id": "SimdBench_85_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    std::string result;\n    size_t vlmax = __riscv_vsetvlmax_e8m1();\n    int8_t digits[64]; // Maximum possible digits for base 2\n    int8_t *pdigits = digits;\n    int64_t temp = x;\n\n    while (temp > 0) {\n        size_t vl = __riscv_vsetvl_e8m1(vlmax);\n        vint8m1_t vbase = __riscv_vmv_v_x_i8m1(base, vl);\n        vint64m8_t vx = __riscv_vmv_v_x_i64m8(temp, vl);\n        vint64m8_t vremainder = __riscv_vrem_vx_i64m8(vx, base, vl);\n\n        // Store remainders as digits\n        __riscv_vse8_v_i8m1(pdigits, __riscv_vreinterpret_v_i64m8_i8m1(vremainder), vl);\n        pdigits += vl;\n\n        // Update temp for next iteration\n        temp /= base;\n    }\n\n    // Convert digits to characters and reverse\n    for (int i = pdigits - digits - 1; i >= 0; --i) {\n        result += (digits[i] + '0');\n    }\n\n    return result.empty() ? \"0\" : result;\n}\n```"}
{"task_id": "SimdBench_85_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    std::string result;\n    size_t vlmax = __riscv_vsetvlmax_e8m1();\n    uint8_t digits[64]; // Temporary storage for digits\n    size_t digit_count = 0;\n\n    while (x > 0) {\n        // Compute multiple remainders in parallel using RVV\n        size_t vl = __riscv_vsetvl_e64m1(1); // Set vector length to 1 for scalar remainder computation\n        vint64m1_t vx = __riscv_vmv_s_x_i64m1(x, vl);\n        vint64m1_t vbase = __riscv_vmv_s_x_i64m1(base, vl);\n        vint64m1_t vremainder = __riscv_vrem_vv_i64m1(vx, vbase, vl);\n\n        // Extract the remainder and store it\n        int64_t remainder = __riscv_vmv_x_s_i64m1_i64(vremainder);\n        digits[digit_count++] = remainder + '0';\n        x /= base;\n    }\n\n    // Reverse the digits to form the final string\n    for (size_t i = digit_count; i > 0; --i) {\n        result += digits[i - 1];\n    }\n\n    return result.empty() ? \"0\" : result;\n}\n```"}
{"task_id": "SimdBench_85_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    char buffer[65]; // Maximum size for base 2 representation of 64-bit number + null terminator\n    int index = 64;\n    buffer[index] = '\\0';\n\n    size_t vlmax = __riscv_vsetvlmax_e64m1();\n    int64_t vx = x;\n    int8_t vbase = base;\n\n    while (vx > 0) {\n        int64_t remainder;\n        int64_t quotient;\n\n        // Use RVV to calculate quotient and remainder in parallel\n        __riscv_vint64m1_t vec_x = __riscv_vmv_v_x_i64m1(vx, vlmax);\n        __riscv_vint64m1_t vec_base = __riscv_vmv_v_x_i64m1(vbase, vlmax);\n\n        // Compute quotient\n        __riscv_vint64m1_t vec_quotient = __riscv_vdiv_vv_i64m1(vec_x, vec_base, vlmax);\n        quotient = __riscv_vmv_x_s_i64m1_i64(vec_quotient);\n\n        // Compute remainder\n        __riscv_vint64m1_t vec_remainder = __riscv_vrem_vv_i64m1(vec_x, vec_base, vlmax);\n        remainder = __riscv_vmv_x_s_i64m1_i64(vec_remainder);\n\n        // Store the remainder as part of the result\n        buffer[--index] = '0' + remainder;\n\n        // Update vx for next iteration\n        vx = quotient;\n    }\n\n    return std::string(buffer + index);\n}\n```"}
{"task_id": "SimdBench_86_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool is_palindrome_simd(std::string text) {\n    size_t n = text.length();\n    if (n == 0) return true;\n\n    const char* data = text.data();\n    size_t vlmax = vsetvlmax_e8m1();\n    size_t vl;\n    bool mismatch = false;\n\n    for (size_t i = 0; i < n / 2; i += vl) {\n        vl = vsetvl_e8m1(n / 2 - i);\n\n        vuint8m1_t vec_left = vle8_v_u8m1(&data[i], vl);\n        vuint8m1_t vec_right = vle8_v_u8m1(&data[n - i - vl], vl);\n        vec_right = vrev_v_u8m1(vec_right, vl);\n\n        vbool8_t comparison = vmseq_vv_u8m1_b8(vec_left, vec_right, vl);\n        mismatch |= vmseq_vx_u8m1_b8(comparison, 0, vl);\n    }\n\n    return !mismatch;\n}\n```"}
{"task_id": "SimdBench_86_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool is_palindrome_simd(std::string text) {\n    size_t n = text.length();\n    if (n == 0) return true;\n\n    const char* data = text.data();\n    size_t vlmax = vsetvlmax_e8m1();\n    bool is_palindrome = true;\n\n    for (size_t i = 0; i < n / 2; i += vlmax) {\n        size_t vl = vsetvl_e8m1(n / 2 - i);\n\n        vuint8m1_t left = vle8_v_u8m1((const uint8_t*)(data + i), vl);\n        vuint8m1_t right = vle8_v_u8m1((const uint8_t*)(data + n - i - vl), vl);\n        right = vrev8_v_u8m1(right, vl);\n\n        vbool8_t cmp = vmseq_vv_u8m1_b8(left, right, vl);\n        is_palindrome &= vmall_v_b8(cmp, vl);\n    }\n\n    return is_palindrome;\n}\n```"}
{"task_id": "SimdBench_86_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool is_palindrome_simd(std::string text) {\n    size_t n = text.length();\n    if (n == 0) return true;\n\n    const char* data = text.data();\n    size_t vlmax = vsetvlmax_e8m8();\n    size_t vl;\n    bool mismatch = false;\n\n    for (size_t i = 0; i < n / 2; i += vl) {\n        vl = vsetvl_e8m8(n / 2 - i);\n\n        vuint8m8_t vec_left = vle8_v_u8m8((const uint8_t*)(data + i), vl);\n        vuint8m8_t vec_right = vle8_v_u8m8((const uint8_t*)(data + n - i - vl), vl);\n        vec_right = vrev8_v_u8m8(vec_right, vl);\n\n        vbool8_t vec_cmp = vmseq_vv_u8m8_b8(vec_left, vec_right, vl);\n        mismatch |= vmfirst_m_b8(vec_cmp, vl) != -1;\n    }\n\n    return !mismatch;\n}\n```"}
{"task_id": "SimdBench_86_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool is_palindrome_simd(std::string text) {\n    size_t n = text.length();\n    if (n == 0) return true;\n\n    const char* data = text.data();\n    size_t vlmax = vsetvlmax_e8m1();\n    bool is_palindrome = true;\n\n    for (size_t i = 0; i < n / 2; i += vlmax) {\n        size_t vl = vsetvl_e8m1(n / 2 - i);\n\n        vuint8m1_t left = vle8_v_u8m1((const uint8_t*)(data + i), vl);\n        vuint8m1_t right = vle8_v_u8m1((const uint8_t*)(data + n - i - vl), vl);\n        right = vrev8_v_u8m1(right, vl);\n\n        vbool8_t cmp = vmseq_vv_u8m1_b8(left, right, vl);\n        is_palindrome &= vmall_v_b8(cmp, vl);\n    }\n\n    return is_palindrome;\n}\n```"}
{"task_id": "SimdBench_86_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool is_palindrome_simd(std::string text) {\n    size_t n = text.length();\n    if (n == 0) return true;\n\n    const char* data = text.data();\n    size_t vlmax = vsetvlmax_e8m1();\n    size_t vl;\n    bool mismatch = false;\n\n    for (size_t i = 0; i < n / 2; i += vl) {\n        vl = vsetvl_e8m1(n / 2 - i);\n\n        vuint8m1_t vec_left = vle8_v_u8m1(data + i, vl);\n        vuint8m1_t vec_right = vle8_v_u8m1(data + n - i - vl, vl);\n        vec_right = vrev8_v_u8m1(vec_right, vl);\n\n        vbool8_t comparison = vmseq_vv_u8m1_b8(vec_left, vec_right, vl);\n        mismatch |= vmfne_vv_u8m1_b8(comparison, vmclr_m_b8(), vl);\n    }\n\n    return !mismatch;\n}\n```"}
{"task_id": "SimdBench_87_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    size_t len = s.length();\n    std::string out(len, 0);\n    size_t vl;\n\n    for (size_t i = 0; i < len; i += vl) {\n        vl = vsetvl_e8m1(len - i);\n\n        vuint8m1_t vec_in = vle8_v_u8m1((const uint8_t*)(&s[i]), vl);\n        vuint8m1_t vec_base = vmv_v_x_u8m1('a', vl);\n        vuint8m1_t vec_shifted = vsub_vx_u8m1(vec_in, 5, vl);\n        vuint8m1_t vec_mod = vsub_vv_u8m1(vec_shifted, vec_base, vl);\n        vec_mod = vand_vx_u8m1(vec_mod, 25, vl);\n        vuint8m1_t vec_out = vadd_vv_u8m1(vec_mod, vec_base, vl);\n\n        vse8_v_u8m1((uint8_t*)(&out[i]), vec_out, vl);\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    size_t len = s.length();\n    std::string out(len, 0);\n    size_t vl;\n\n    for (size_t i = 0; i < len; i += vl) {\n        vl = vsetvl_e8m1(len - i);\n\n        vuint8m1_t vec_in = vle8_v_u8m1((uint8_t*)&s[i], vl);\n        vuint8m1_t vec_base = vmv_v_x_u8m1('a', vl);\n        vuint8m1_t vec_shifted = vsub_vx_u8m1(vec_in, 5, vl);\n        vuint8m1_t vec_mod = vsub_vv_u8m1(vec_shifted, vec_base, vl);\n        vec_mod = vand_vx_u8m1(vec_mod, 25, vl);\n        vuint8m1_t vec_out = vadd_vv_u8m1(vec_mod, vec_base, vl);\n\n        vse8_v_u8m1((uint8_t*)&out[i], vec_out, vl);\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    size_t len = s.length();\n    std::string out(len, 0);\n    size_t vl;\n\n    for (size_t i = 0; i < len; i += vl) {\n        vl = vsetvl_e8m1(len - i);\n\n        vuint8m1_t vec_in = vle8_v_u8m1((const uint8_t*)(&s[i]), vl);\n        vuint8m1_t vec_base = vmv_v_x_u8m1('a', vl);\n        vuint8m1_t vec_shifted = vsub_vx_u8m1(vec_in, 5, vl);\n        vuint8m1_t vec_mod = vsub_vv_u8m1(vec_shifted, vec_base, vl);\n        vec_mod = vand_vx_u8m1(vec_mod, 25, vl);\n        vuint8m1_t vec_out = vadd_vv_u8m1(vec_mod, vec_base, vl);\n\n        vse8_v_u8m1((uint8_t*)(&out[i]), vec_out, vl);\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    size_t len = s.length();\n    std::string out(len, 0);\n    size_t vl;\n\n    for (size_t i = 0; i < len; i += vl) {\n        vl = vsetvl_e8m1(len - i);\n\n        vuint8m1_t vec = vle8_v_u8m1((const uint8_t*)(&s[i]), vl);\n        vuint8m1_t decoded = vsub_vx_u8m1(vec, 5, vl);\n        vse8_v_u8m1((uint8_t*)(&out[i]), decoded, vl);\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    size_t len = s.length();\n    std::string out(len, 0);\n    size_t vl;\n\n    for (size_t i = 0; i < len; i += vl) {\n        vl = vsetvl_e8m1(len - i);\n\n        vuint8m1_t vec_in = vle8_v_u8m1((const uint8_t*)(&s[i]), vl);\n        vuint8m1_t vec_base = vmv_v_x_u8m1('a', vl);\n        vuint8m1_t vec_shifted = vsub_vx_u8m1(vec_in, 5, vl);\n        vuint8m1_t vec_mod = vsub_vv_u8m1(vec_shifted, vec_base, vl);\n        vec_mod = vand_vx_u8m1(vec_mod, 25, vl);\n        vuint8m1_t vec_out = vadd_vv_u8m1(vec_mod, vec_base, vl);\n\n        vse8_v_u8m1((uint8_t*)(&out[i]), vec_out, vl);\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_88_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    size_t vlmax = __riscv_vsetvlmax_e32m8();\n    size_t n = l.size();\n    bool all_below = true;\n\n    for (size_t i = 0; i < n; i += vlmax) {\n        size_t vl = __riscv_vsetvl_e32m8(n - i);\n        vint32m8_t vec = __riscv_vle32_v_i32m8(&l[i], vl);\n        vbool4_t mask = __riscv_vmflt_vx_i32m8_b4(vec, t, vl);\n        if (!__riscv_vmandn_b4(mask, vl)) {\n            all_below = false;\n            break;\n        }\n    }\n\n    return all_below;\n}\n```"}
{"task_id": "SimdBench_88_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    size_t vlmax = vsetvlmax_e32m8();\n    size_t len = l.size();\n    bool result = true;\n\n    for (size_t i = 0; i < len; i += vlmax) {\n        size_t vl = vsetvl_e32m8(len - i);\n        vint32m8_t vec = vle32_v_i32m8(&l[i], vl);\n        vbool4_t mask = vmflt_vx_i32m8_b4(vec, t, vl);\n        if (!vmreduce_all_b4(mask, vl)) {\n            result = false;\n            break;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_88_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    size_t vlmax = vsetvlmax_e32m8();\n    size_t n = l.size();\n    bool result = true;\n\n    for (size_t i = 0; i < n; i += vlmax) {\n        size_t vl = vsetvl_e32m8(n - i);\n        vint32m8_t vec = vle32_v_i32m8(l.data() + i, vl);\n        vbool4_t mask = vmflt_vx_i32m8_b4(vec, t, vl);\n        if (!vmreduce_all_b4(mask, vl)) {\n            result = false;\n            break;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_88_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    size_t vlmax = vsetvlmax_e32m8();\n    size_t len = l.size();\n    bool result = true;\n\n    for (size_t i = 0; i < len; i += vlmax) {\n        size_t vl = vsetvl_e32m8(len - i);\n        vint32m8_t vec = vle32_v_i32m8(&l[i], vl);\n        vbool4_t mask = vmflt_vx_i32m8_b4(vec, t, vl);\n        if (!vmall(mask, vl)) {\n            result = false;\n            break;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_88_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    size_t vlmax = vsetvlmax_e32m8();\n    size_t len = l.size();\n    bool all_below = true;\n\n    for (size_t i = 0; i < len; i += vlmax) {\n        size_t vl = vsetvl_e32m8(len - i);\n        vint32m8_t vec = vle32_v_i32m8(&l[i], vl);\n        vbool4_t mask = vmflt_vx_i32m8_b4(vec, t, vl);\n        if (!vmreduce_all_b4(mask, vl)) {\n            all_below = false;\n            break;\n        }\n    }\n\n    return all_below;\n}\n```"}
{"task_id": "SimdBench_89_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t len = brackets.length();\n    if (len == 0) return true;\n    if (len % 2 != 0) return false;\n\n    int balance = 0;\n    size_t vlmax = __riscv_vsetvlmax_e8m1();\n    vint8m1_t vec_balance = __riscv_vmv_v_x_i8m1(0, vlmax);\n\n    for (size_t i = 0; i < len; i += vlmax) {\n        size_t vl = __riscv_vsetvl_e8m1(len - i);\n        vint8m1_t vec_chars = __riscv_vle8_v_i8m1((const int8_t*)(brackets.data() + i), vl);\n\n        vbool8_t mask_open = __riscv_vmseq_vx_i8m1_b8(vec_chars, '<', vl);\n        vbool8_t mask_close = __riscv_vmseq_vx_i8m1_b8(vec_chars, '>', vl);\n\n        vint8m1_t vec_add = __riscv_vadd_vx_i8m1_m(mask_open, vec_balance, vec_balance, 1, vl);\n        vint8m1_t vec_sub = __riscv_vsub_vx_i8m1_m(mask_close, vec_balance, vec_balance, 1, vl);\n\n        vec_balance = __riscv_vmerge_vvm_i8m1(mask_open, vec_add, vec_sub, vl);\n\n        // Check for negative balance during computation\n        vbool8_t neg_mask = __riscv_vmslt_vx_i8m1_b8(vec_balance, 0, vl);\n        if (__riscv_vfirst_m_b8(neg_mask, vl) != -1) {\n            return false;\n        }\n    }\n\n    // Reduce the vector to a scalar balance value\n    int8_t sum = 0;\n    for (size_t i = 0; i < vlmax; ++i) {\n        sum += __riscv_vlse8_v_i8m1(&((int8_t*)&vec_balance)[i], vlmax);\n    }\n\n    return sum == 0;\n}\n```"}
{"task_id": "SimdBench_89_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t len = brackets.size();\n    if (len == 0) return true;\n    if (len % 2 != 0) return false;\n\n    int balance = 0;\n    size_t vlmax = __riscv_vsetvlmax_e8m1();\n    vint8m1_t vec_balance = __riscv_vmv_v_x_i8m1(0, vlmax);\n\n    for (size_t i = 0; i < len; i += vlmax) {\n        size_t vl = __riscv_vsetvl_e8m1(len - i);\n        vint8m1_t vec_chars = __riscv_vle8_v_i8m1((const int8_t*)(brackets.data() + i), vl);\n\n        vbool8_t mask_open = __riscv_vmseq_vx_i8m1_b8(vec_chars, '<', vl);\n        vbool8_t mask_close = __riscv_vmseq_vx_i8m1_b8(vec_chars, '>', vl);\n\n        vint8m1_t vec_add = __riscv_vadd_vx_i8m1_m(mask_open, vec_balance, vec_balance, 1, vl);\n        vint8m1_t vec_sub = __riscv_vsub_vx_i8m1_m(mask_close, vec_balance, vec_balance, 1, vl);\n\n        vec_balance = __riscv_vmerge_vvm_i8m1(mask_open, vec_add, vec_sub, vl);\n\n        // Check for negative balance\n        vbool8_t neg_mask = __riscv_vmslt_vx_i8m1(vec_balance, 0, vl);\n        if (__riscv_vfirst_m_b8(neg_mask, vl) != -1) {\n            return false;\n        }\n    }\n\n    // Reduce the vector to a scalar balance\n    int final_balance = 0;\n    for (size_t i = 0; i < len; i += vlmax) {\n        size_t vl = __riscv_vsetvl_e8m1(len - i);\n        final_balance += __riscv_vredsum_vs_i8m1_i8m1(vec_balance, __riscv_vmv_v_x_i8m1(0, vl), vl);\n    }\n\n    return final_balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t len = brackets.size();\n    if (len == 0) return true;\n    if (len % 2 != 0) return false;\n\n    int balance = 0;\n    size_t vlmax = __riscv_vsetvlmax_e8m1();\n    size_t vl;\n\n    for (size_t i = 0; i < len; i += vl) {\n        vl = __riscv_vsetvl_e8m1(len - i);\n\n        // Load a vector of characters from the string\n        vint8m1_t vec = __riscv_vle8_v_i8m1((const int8_t*)(brackets.data() + i), vl);\n\n        // Create a mask for '<' and '>'\n        vbool8_t is_less_than = __riscv_vmseq_vx_i8m1_b8(vec, '<', vl);\n        vbool8_t is_greater_than = __riscv_vmseq_vx_i8m1_b8(vec, '>', vl);\n\n        // Count the number of '<' and '>' in the current vector\n        int count_less_than = __riscv_vpopc_m_b8(is_less_than, vl);\n        int count_greater_than = __riscv_vpopc_m_b8(is_greater_than, vl);\n\n        // Update the balance\n        balance += count_less_than - count_greater_than;\n\n        // Early exit if balance goes negative\n        if (balance < 0) return false;\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t len = brackets.size();\n    if (len == 0) return true;\n    if (len % 2 != 0) return false;\n\n    int balance = 0;\n    size_t vlmax = vsetvlmax_e8m1();\n    vint8m1_t vec_balance = vmv_v_x_i8m1(0, vlmax);\n\n    for (size_t i = 0; i < len; i += vlmax) {\n        size_t vl = vsetvl_e8m1(len - i);\n        vint8m1_t vec_chars = vle8_v_i8m1((const int8_t*)(brackets.data() + i), vl);\n\n        vbool8_t is_less = vmseq_vx_i8m1_b8(vec_chars, '<', vl);\n        vbool8_t is_greater = vmseq_vx_i8m1_b8(vec_chars, '>', vl);\n\n        vint8m1_t vec_add = vadd_vx_i8m1(vec_balance, 1, vl);\n        vint8m1_t vec_sub = vsub_vx_i8m1(vec_balance, 1, vl);\n\n        vec_balance = vmerge_vvm_i8m1(is_less, vec_add, vec_balance, vl);\n        vec_balance = vmerge_vvm_i8m1(is_greater, vec_sub, vec_balance, vl);\n\n        // Check for negative balance during the process\n        vbool8_t is_negative = vmslt_vx_i8m1_b8(vec_balance, 0, vl);\n        if (vfirst_m_b8(is_negative, vl) != -1) {\n            return false;\n        }\n    }\n\n    // Reduce the vector to a scalar balance\n    int sum_balance = 0;\n    for (size_t i = 0; i < vlmax; ++i) {\n        sum_balance += ((int8_t*)&vec_balance)[i];\n    }\n\n    return sum_balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t len = brackets.size();\n    if (len == 0) return true;\n    if (len % 2 != 0) return false;\n\n    int balance = 0;\n    size_t vlmax = __riscv_vsetvlmax_e8m1();\n    size_t vl;\n\n    for (size_t i = 0; i < len; i += vl) {\n        vl = __riscv_vsetvl_e8m1(len - i);\n\n        // Load a vector of characters from the string\n        vint8m1_t vec = __riscv_vle8_v_i8m1((const uint8_t*)(brackets.data() + i), vl);\n\n        // Create a mask for '<' and '>'\n        vbool8_t is_less = __riscv_vmseq_vx_i8m1_b8(vec, '<', vl);\n        vbool8_t is_greater = __riscv_vmseq_vx_i8m1_b8(vec, '>', vl);\n\n        // Count the number of '<' and '>' in the current vector\n        int less_count = __riscv_vpopc_m_b8(is_less, vl);\n        int greater_count = __riscv_vpopc_m_b8(is_greater, vl);\n\n        // Update the balance\n        balance += less_count - greater_count;\n\n        // Early exit if balance goes negative\n        if (balance < 0) return false;\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t len = brackets.size();\n    if (len == 0) return true;\n\n    // Ensure the length is even; otherwise, it cannot be balanced.\n    if (len % 2 != 0) return false;\n\n    // Initialize a counter for balance tracking.\n    int balance = 0;\n\n    // Vectorized loop to process brackets in chunks.\n    size_t vlmax = vsetvlmax_e8m1(); // Maximum vector length for 8-bit elements.\n    size_t i = 0;\n\n    // Process the string in chunks using RVV intrinsics.\n    for (; i + vlmax <= len; i += vlmax) {\n        // Load a vector of characters from the string.\n        vint8m1_t vec = vle8_v_i8m1((const int8_t*)(brackets.data() + i), vlmax);\n\n        // Create masks for '(' and ')'.\n        vbool8_t mask_open = vmseq_vx_i8m1(vec, '(', vlmax);\n        vbool8_t mask_close = vmseq_vx_i8m1(vec, ')', vlmax);\n\n        // Count the number of '(' and ')' in the current vector.\n        int open_count = vcpop_m_b8(vmnot_m_b8(mask_open, vlmax), vlmax);\n        int close_count = vcpop_m_b8(vmnot_m_b8(mask_close, vlmax), vlmax);\n\n        // Update the balance counter.\n        balance += open_count - close_count;\n\n        // Early exit if balance goes negative.\n        if (balance < 0) return false;\n    }\n\n    // Process any remaining characters that didn't fit into a full vector.\n    for (; i < len; ++i) {\n        if (brackets[i] == '(') {\n            balance++;\n        } else if (brackets[i] == ')') {\n            balance--;\n        }\n\n        // Early exit if balance goes negative.\n        if (balance < 0) return false;\n    }\n\n    // Final check: balance must be zero for correct bracketing.\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t len = brackets.size();\n    if (len == 0) return true;\n\n    // Ensure the length is even; otherwise, it cannot be balanced.\n    if (len % 2 != 0) return false;\n\n    // Variables to track balance using SIMD operations.\n    int balance = 0;\n    size_t vlmax = vsetvlmax_e8m1(); // Maximum vector length for 8-bit elements.\n\n    for (size_t i = 0; i < len; i += vlmax) {\n        size_t vl = vsetvl_e8m1(len - i); // Set vector length dynamically.\n\n        // Load a vector of characters from the string.\n        vint8m1_t vec = vle8_v_i8m1((const int8_t*)(brackets.data() + i), vl);\n\n        // Create masks for '(' and ')'.\n        vbool8_t is_open = vmseq_vx_i8m1_b8(vec, '(', vl);\n        vbool8_t is_close = vmseq_vx_i8m1_b8(vec, ')', vl);\n\n        // Count the number of '(' and ')' in the current vector.\n        int open_count = vcpop_m_b8(vmandnot_mm(is_close, is_open, vl), vl);\n        int close_count = vcpop_m_b8(is_close, vl);\n\n        // Update the balance.\n        balance += open_count - close_count;\n\n        // Early exit if balance goes negative.\n        if (balance < 0) return false;\n    }\n\n    // Final check: balance must be zero for correct bracketing.\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t len = brackets.size();\n    if (len == 0) return true;\n\n    // Ensure the length is even; otherwise, it cannot be balanced.\n    if (len % 2 != 0) return false;\n\n    // Initialize a counter for open brackets.\n    int balance = 0;\n\n    // Define vector types and constants.\n    size_t vlmax = vsetvlmax_e8m1(); // Maximum vector length for 8-bit elements.\n    vint8m1_t vec_open = vmv_v_x_i8m1('(', vlmax);  // Vector of '(' characters.\n    vint8m1_t vec_close = vmv_v_x_i8m1(')', vlmax); // Vector of ')' characters.\n\n    // Process the string in chunks using RVV intrinsics.\n    size_t i = 0;\n    while (i < len) {\n        size_t vl = vsetvl_e8m1(len - i); // Set vector length dynamically.\n\n        // Load a vector of characters from the string.\n        vint8m1_t vec_chars = vle8_v_i8m1((const int8_t*)(brackets.data() + i), vl);\n\n        // Compare with '(' and ')'.\n        vbool8_t mask_open = vmseq_vv_i8m1_b8(vec_chars, vec_open, vl);\n        vbool8_t mask_close = vmseq_vv_i8m1_b8(vec_chars, vec_close, vl);\n\n        // Count the number of '(' and ')' in the current vector.\n        int open_count = vcpop_m_b8(mask_open, vl);\n        int close_count = vcpop_m_b8(mask_close, vl);\n\n        // Update the balance counter.\n        balance += open_count - close_count;\n\n        // If balance goes negative, the string is unbalanced.\n        if (balance < 0) return false;\n\n        // Move to the next chunk.\n        i += vl;\n    }\n\n    // Final check: balance must be zero for the string to be valid.\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t len = brackets.size();\n    if (len == 0) return true;\n    if (len % 2 != 0) return false;\n\n    int balance = 0;\n    size_t vlmax = __riscv_vsetvlmax_e8m1();\n    vint8m1_t vec_open = __riscv_vmv_v_x_i8m1('(', vlmax);\n    vint8m1_t vec_close = __riscv_vmv_v_x_i8m1(')', vlmax);\n\n    for (size_t i = 0; i < len; i += vlmax) {\n        size_t vl = __riscv_vsetvl_e8m1(len - i);\n        vint8m1_t vec_brackets = __riscv_vle8_v_i8m1((const int8_t*)(brackets.data() + i), vl);\n\n        vbool8_t is_open = __riscv_vmseq_vv_i8m1_b8(vec_brackets, vec_open, vl);\n        vbool8_t is_close = __riscv_vmseq_vv_i8m1_b8(vec_brackets, vec_close, vl);\n\n        vint8m1_t ones = __riscv_vmv_v_x_i8m1(1, vl);\n        vint8m1_t neg_ones = __riscv_vmv_v_x_i8m1(-1, vl);\n\n        vint8m1_t add_vec = __riscv_vmerge_vxm_i8m1(is_open, ones, 0, vl);\n        vint8m1_t sub_vec = __riscv_vmerge_vxm_i8m1(is_close, neg_ones, 0, vl);\n\n        vint8m1_t combined = __riscv_vadd_vv_i8m1(add_vec, sub_vec, vl);\n        balance += __riscv_vmv_x_s_i8m1_i8(__riscv_vredsum_vs_i8m1_i8m1(combined, __riscv_vmv_v_x_i8m1(0, vl), vl));\n\n        if (balance < 0) return false;\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t len = brackets.size();\n    if (len == 0) return true;\n\n    // Ensure the length is even; otherwise, it cannot be balanced.\n    if (len % 2 != 0) return false;\n\n    // Initialize a counter for open brackets.\n    int balance = 0;\n\n    // Define vector type and mask type.\n    size_t vl;\n    vint32m1_t v_balance = vmv_s_x_i32m1(v_balance, 0, vl);\n    vbool32_t mask;\n\n    // Process the string in chunks using RVV intrinsics.\n    for (size_t i = 0; i < len; i += vl) {\n        vl = vsetvl_e8m1(len - i);\n\n        // Load a vector of characters from the string.\n        vuint8m1_t v_chars = vle8_v_u8m1((uint8_t*)&brackets[i], vl);\n\n        // Create masks for '(' and ')'.\n        vbool8_t is_open = vmseq_vx_u8m1(v_chars, '(', vl);\n        vbool8_t is_close = vmseq_vx_u8m1(v_chars, ')', vl);\n\n        // Count the number of '(' and ')' in the current vector.\n        vint32m1_t v_open_count = vwredsum_vs_i8m1_i32m1(is_open, v_balance, vl);\n        vint32m1_t v_close_count = vwredsum_vs_i8m1_i32m1(is_close, v_balance, vl);\n\n        // Update the scalar balance counter.\n        balance += vmv_x_s_i32m1_i32(v_open_count) - vmv_x_s_i32m1_i32(v_close_count);\n\n        // Early exit if balance goes negative.\n        if (balance < 0) return false;\n    }\n\n    // Final check: balance must be zero for correct bracketing.\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_91_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    size_t n = xs.size();\n    std::vector<float> result(n > 1 ? n - 1 : 0);\n\n    if (n <= 1) return result;\n\n    size_t vl;\n    vfloat32m1_t vx, vy;\n    vfloat32m1_t vres;\n\n    size_t i = 0;\n    for (; i + vsetvlmax_e32m1() <= n - 1; i += vl) {\n        vl = vsetvl_e32m1(n - 1 - i);\n        vx = vle32_v_f32m1(xs.data() + i + 1, vl);\n        vy = vfmul_vf_f32m1(vx, static_cast<float>(i + 1), vl);\n        vse32_v_f32m1(result.data() + i, vy, vl);\n    }\n\n    for (; i < n - 1; ++i) {\n        result[i] = xs[i + 1] * static_cast<float>(i + 1);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    size_t n = xs.size();\n    std::vector<float> result(n > 0 ? n - 1 : 0);\n\n    if (n <= 1) return result;\n\n    size_t vl;\n    size_t i = 0;\n\n    for (; i + vsetvlmax_e32m1() <= n - 1; i += vl) {\n        vl = vsetvl_e32m1(n - 1 - i);\n        vfloat32m1_t vx = vle32_v_f32m1(xs.data() + i + 1, vl);\n        vfloat32m1_t vi = vfmul_vf_f32m1(vx, i + 1 + vgetindex(), vl);\n        vse32_v_f32m1(result.data() + i, vi, vl);\n    }\n\n    for (; i < n - 1; ++i) {\n        result[i] = xs[i + 1] * (i + 1);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    size_t n = xs.size();\n    std::vector<float> result(n > 1 ? n - 1 : 0, 0.0f);\n\n    if (n <= 1) return result;\n\n    size_t vl;\n    vfloat32m1_t vx, vy;\n    vfloat32m1_t vres;\n\n    size_t i = 0;\n    for (; i + vsetvlmax_e32m1() <= n - 1; i += vl) {\n        vl = vsetvl_e32m1(n - 1 - i);\n        vx = vle32_v_f32m1(xs.data() + i + 1, vl);\n        vy = vfmul_vf_f32m1(vx, static_cast<float>(i + 1), vl);\n        vse32_v_f32m1(result.data() + i, vy, vl);\n    }\n\n    for (; i < n - 1; ++i) {\n        result[i] = xs[i + 1] * static_cast<float>(i + 1);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    size_t n = xs.size();\n    std::vector<float> result(n > 1 ? n - 1 : 0);\n\n    if (n <= 1) return result;\n\n    size_t vl;\n    size_t i = 0;\n    vfloat32m1_t v_coeff, v_index;\n    vfloat32m1_t v_result;\n\n    for (; i + vsetvl_e32m1(i) <= n - 1; i += vl) {\n        vl = vsetvl_e32m1(n - 1 - i);\n        v_coeff = vle32_v_f32m1(&xs[i + 1], vl); // Load coefficients starting from xs[1]\n        v_index = vfmul_vf_f32m1(vadd_vx_i32m1(vundefined_i32m1(), i + 1, vl), 1.0f, vl); // Generate indices [i+1, i+2, ...]\n        v_result = vfmul_vv_f32m1(v_coeff, v_index, vl); // Multiply coefficients by their indices\n        vse32_v_f32m1(&result[i], v_result, vl); // Store the result\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    size_t n = xs.size();\n    std::vector<float> result(n > 0 ? n - 1 : 0);\n\n    if (n <= 1) {\n        return result; // Derivative of constant is zero.\n    }\n\n    size_t vl;\n    size_t i = 0;\n\n    for (; i + vsetvlmax_e32m1() <= n - 1; i += vl) {\n        vl = vsetvl_e32m1(n - 1 - i);\n        vfloat32m1_t vx = vle32_v_f32m1(&xs[i + 1], vl);\n        vfloat32m1_t vy = vfmul_vf_f32m1(vx, static_cast<float>(i + 1), vl);\n        vse32_v_f32m1(&result[i], vy, vl);\n    }\n\n    for (; i < n - 1; ++i) {\n        result[i] = xs[i + 1] * static_cast<float>(i + 1);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_92_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint vowels_count_simd(std::string s) {\n    size_t len = s.length();\n    int result = 0;\n    size_t vl;\n\n    // Create a vector of vowels for comparison\n    vuint8m1_t vec_a = vmv_v_x_u8m1('a', vl);\n    vuint8m1_t vec_e = vmv_v_x_u8m1('e', vl);\n    vuint8m1_t vec_i = vmv_v_x_u8m1('i', vl);\n    vuint8m1_t vec_o = vmv_v_x_u8m1('o', vl);\n    vuint8m1_t vec_u = vmv_v_x_u8m1('u', vl);\n    vuint8m1_t vec_y = vmv_v_x_u8m1('y', vl);\n\n    // Convert string to lowercase and load into vector\n    std::string lower_s = s;\n    std::transform(lower_s.begin(), lower_s.end(), lower_s.begin(), ::tolower);\n    const uint8_t* data = reinterpret_cast<const uint8_t*>(lower_s.c_str());\n\n    for (size_t i = 0; i < len; i += vl) {\n        vl = vsetvl_e8m1(len - i);\n        vuint8m1_t vec_data = vle8_v_u8m1(&data[i], vl);\n\n        // Compare with each vowel\n        vbool8_t mask_a = vmseq_vv_u8m1(vec_data, vec_a, vl);\n        vbool8_t mask_e = vmseq_vv_u8m1(vec_data, vec_e, vl);\n        vbool8_t mask_i = vmseq_vv_u8m1(vec_data, vec_i, vl);\n        vbool8_t mask_o = vmseq_vv_u8m1(vec_data, vec_o, vl);\n        vbool8_t mask_u = vmseq_vv_u8m1(vec_data, vec_u, vl);\n\n        // Combine masks for all vowels except 'y'\n        vbool8_t mask_vowels = vmor_mm(mask_a, vmor_mm(mask_e, vmor_mm(mask_i, vmor_mm(mask_o, mask_u, vl), vl), vl), vl);\n\n        // Handle 'y' only if it's at the end of the word\n        if (i + vl == len && s[len - 1] == 'y') {\n            mask_vowels = vmor_mm(mask_vowels, vmseq_vx_u8m1(vec_data, 'y', vl), vl);\n        }\n\n        // Count the number of true values in the mask\n        result += vcpop_m_b8(mask_vowels, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_92_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint vowels_count_simd(std::string s) {\n    size_t len = s.length();\n    int result = 0;\n\n    // Define vowels and their properties\n    const char vowels[] = {'a', 'e', 'i', 'o', 'u', 'y'};\n    const int num_vowels = 6;\n\n    // Ensure the string is null-terminated for safety\n    if (len == 0) return 0;\n\n    // Convert the string to lowercase for case-insensitive comparison\n    std::string lower_s = s;\n    for (char &c : lower_s) c = tolower(c);\n\n    // Process the string in chunks using RVV intrinsics\n    size_t vlmax = vsetvlmax_e8m1(); // Set vector length for byte-sized elements\n    size_t i = 0;\n\n    for (; i + vlmax <= len; i += vlmax) {\n        // Load a vector of characters from the string\n        vuint8m1_t vec_str = vle8_v_u8m1((const uint8_t*)(lower_s.c_str() + i), vlmax);\n\n        // Initialize a mask for vowels\n        vbool8_t mask = vmfalse_b8();\n\n        // Compare each character with the vowel set\n        for (int j = 0; j < num_vowels; ++j) {\n            vuint8m1_t vec_vowel = vmv_v_x_u8m1(vowels[j], vlmax);\n            mask = vmor_mm_b8(mask, vmseq_vv_u8m1(vec_str, vec_vowel, vlmax));\n        }\n\n        // Count the number of matches (vowels)\n        result += vcpop_m_b8(mask, vlmax);\n    }\n\n    // Handle the remaining characters (if any)\n    if (i < len) {\n        size_t remaining = len - i;\n        size_t vl = vsetvl_e8m1(remaining);\n\n        // Load the remaining characters\n        vuint8m1_t vec_str = vle8_v_u8m1((const uint8_t*)(lower_s.c_str() + i), vl);\n\n        // Initialize a mask for vowels\n        vbool8_t mask = vmfalse_b8();\n\n        // Compare each character with the vowel set\n        for (int j = 0; j < num_vowels; ++j) {\n            vuint8m1_t vec_vowel = vmv_v_x_u8m1(vowels[j], vl);\n            mask = vmor_mm_b8(mask, vmseq_vv_u8m1(vec_str, vec_vowel, vl));\n        }\n\n        // Count the number of matches (vowels)\n        result += vcpop_m_b8(mask, vl);\n    }\n\n    // Special case: Check if 'y' is at the end of the word\n    if (len > 0 && lower_s[len - 1] == 'y') {\n        result++;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_92_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    size_t len = s.length();\n    int result = 0;\n\n    // Define vowels and their properties\n    const char vowels[] = {'a', 'e', 'i', 'o', 'u', 'y'};\n    const int num_vowels = 6;\n\n    // Ensure the string is null-terminated for safety in vectorized operations\n    s.push_back('\\0');\n\n    // Process the main part of the string using RVV intrinsics\n    size_t vl;\n    size_t i = 0;\n    for (; i + vsetvlmax_e8() <= len; i += vl) {\n        vl = vsetvl_e8m1(len - i);\n\n        // Load a vector of characters from the string\n        vuint8m1_t vec_chars = vle8_v_u8m1((const uint8_t*)(s.data() + i), vl);\n\n        // Initialize a mask for vowels\n        vbool8_t vowel_mask = vmfalse_b8();\n\n        // Compare against each vowel\n        for (int v = 0; v < num_vowels - 1; ++v) { // Exclude 'y' for now\n            vuint8m1_t vec_vowel = vmv_v_x_u8m1(vowels[v], vl);\n            vowel_mask = vmor_mm_b8(vowel_mask, vmseq_vv_u8m1(vec_chars, vec_vowel, vl));\n        }\n\n        // Count matches for standard vowels\n        result += vcpop_m_b8(vowel_mask, vl);\n    }\n\n    // Handle the last character separately to check if it's 'y'\n    if (len > 0 && (s[len - 1] == 'y' || s[len - 1] == 'Y')) {\n        result += 1;\n    }\n\n    // Handle any remaining characters (not processed in the vectorized loop)\n    for (; i < len; ++i) {\n        char c = s[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n            c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            result++;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_92_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cctype>\n\nint vowels_count_simd(std::string s) {\n    size_t len = s.length();\n    int result = 0;\n    size_t vl;\n\n    // Create a vector of vowels for comparison\n    unsigned char vowels[6] = {'a', 'e', 'i', 'o', 'u', 'y'};\n    vuint8m1_t vec_vowels = vle8_v_u8m1(vowels, 6);\n\n    // Convert the string to lowercase\n    for (size_t i = 0; i < len; ++i) {\n        s[i] = std::tolower(s[i]);\n    }\n\n    // Process the string in chunks using RVV intrinsics\n    size_t i = 0;\n    while (i < len) {\n        vl = vsetvl_e8m1(len - i);\n        vuint8m1_t vec_str = vle8_v_u8m1((unsigned char*)&s[i], vl);\n\n        // Compare each character with the vowel list\n        vbool8_t mask_a = vmseq_vx_u8m1(vec_str, 'a', vl);\n        vbool8_t mask_e = vmseq_vx_u8m1(vec_str, 'e', vl);\n        vbool8_t mask_i = vmseq_vx_u8m1(vec_str, 'i', vl);\n        vbool8_t mask_o = vmseq_vx_u8m1(vec_str, 'o', vl);\n        vbool8_t mask_u = vmseq_vx_u8m1(vec_str, 'u', vl);\n\n        // Combine masks for all vowels except 'y'\n        vbool8_t mask_vowels = vmor_mm_b8(vmor_mm_b8(vmor_mm_b8(mask_a, mask_e), vmor_mm_b8(mask_i, mask_o)), mask_u);\n\n        // Count the number of matches\n        result += vcpop_m_b8(mask_vowels, vl);\n\n        i += vl;\n    }\n\n    // Check if the last character is 'y'\n    if (len > 0 && s[len - 1] == 'y') {\n        result += 1;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_92_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cctype>\n\nint vowels_count_simd(std::string s) {\n    size_t len = s.length();\n    int result = 0;\n\n    // Check if the last character is 'y' or 'Y'\n    if (len > 0 && (s[len - 1] == 'y' || s[len - 1] == 'Y')) {\n        result++;\n        len--; // Exclude the last character from further checks\n    }\n\n    size_t vl;\n    size_t i = 0;\n\n    // Process the string in chunks using RVV intrinsics\n    for (; i + vsetvlmax_e8m1() <= len; i += vl) {\n        vl = vsetvl_e8m1(len - i);\n        vuint8m1_t vec_chars = vle8_v_u8m1((const uint8_t*)(s.data() + i), vl);\n\n        // Convert characters to lowercase\n        vuint8m1_t vec_lower = vmul_vx_u8m1(vec_chars, 1, vl);\n        vec_lower = vmsltu_vx_u8m1(vec_lower, 'A', vl) ? vec_lower : vec_lower + ('a' - 'A');\n\n        // Create a mask for vowels\n        vbool8_t mask_a = vmseq_vx_u8m1(vec_lower, 'a', vl);\n        vbool8_t mask_e = vmseq_vx_u8m1(vec_lower, 'e', vl);\n        vbool8_t mask_i = vmseq_vx_u8m1(vec_lower, 'i', vl);\n        vbool8_t mask_o = vmseq_vx_u8m1(vec_lower, 'o', vl);\n        vbool8_t mask_u = vmseq_vx_u8m1(vec_lower, 'u', vl);\n\n        // Combine masks\n        vbool8_t mask_vowels = vmor_mm(mask_a, mask_e, vl);\n        mask_vowels = vmor_mm(mask_vowels, mask_i, vl);\n        mask_vowels = vmor_mm(mask_vowels, mask_o, vl);\n        mask_vowels = vmor_mm(mask_vowels, mask_u, vl);\n\n        // Count the number of vowels in this chunk\n        result += vcpop_m_b8(mask_vowels, vl);\n    }\n\n    // Process remaining characters\n    for (; i < len; ++i) {\n        char c = std::tolower(s[i]);\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            result++;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_93_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint digitSum_simd(std::string s) {\n    size_t len = s.length();\n    int sum = 0;\n\n    size_t vl;\n    size_t i = 0;\n\n    while (i < len) {\n        vl = vsetvl_e8m1(len - i);\n\n        // Load a vector of characters from the string\n        vuint8m1_t vec_chars = vle8_v_u8m1((const uint8_t*)(s.data() + i), vl);\n\n        // Create a mask for uppercase letters ('A' to 'Z')\n        vbool8_t mask_upper = vmsgeu_vx_u8m1_b8(vec_chars, 'A', vl) & vm sleu_vx_u8m1_b8(vec_chars, 'Z', vl);\n\n        // Apply the mask to filter only uppercase letters\n        vuint8m1_t upper_chars = vcompress_vm(mask_upper, vec_chars, vl);\n\n        // Convert the filtered uppercase characters to their ASCII integer values\n        vint16m2_t upper_ints = vwaddu_vx_u16m2(upper_chars, 0, vl);\n\n        // Sum up the ASCII values of the uppercase characters\n        sum += vsum_vs_i16m2_i16m1(upper_ints, vl);\n\n        i += vl;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint digitSum_simd(std::string s) {\n    size_t len = s.length();\n    int sum = 0;\n\n    size_t vl;\n    size_t i = 0;\n    for (; i + vsetvlmax_e8m1() <= len; i += vl) {\n        vl = vsetvl_e8m1(len - i);\n        vuint8m1_t vec = vle8_v_u8m1((const uint8_t*)(s.data() + i), vl);\n        vbool8_t mask = vmseq_vx_u8m1(vec, 'A', vl);\n        mask = vmor_mm_b8(mask, vmseq_vx_u8m1(vec, 'B', vl));\n        mask = vmor_mm_b8(mask, vmseq_vx_u8m1(vec, 'C', vl));\n        mask = vmor_mm_b8(mask, vmseq_vx_u8m1(vec, 'D', vl));\n        mask = vmor_mm_b8(mask, vmseq_vx_u8m1(vec, 'E', vl));\n        mask = vmor_mm_b8(mask, vmseq_vx_u8m1(vec, 'F', vl));\n        mask = vmor_mm_b8(mask, vmseq_vx_u8m1(vec, 'G', vl));\n        mask = vmor_mm_b8(mask, vmseq_vx_u8m1(vec, 'H', vl));\n        mask = vmor_mm_b8(mask, vmseq_vx_u8m1(vec, 'I', vl));\n        mask = vmor_mm_b8(mask, vmseq_vx_u8m1(vec, 'J', vl));\n        mask = vmor_mm_b8(mask, vmseq_vx_u8m1(vec, 'K', vl));\n        mask = vmor_mm_b8(mask, vmseq_vx_u8m1(vec, 'L', vl));\n        mask = vmor_mm_b8(mask, vmseq_vx_u8m1(vec, 'M', vl));\n        mask = vmor_mm_b8(mask, vmseq_vx_u8m1(vec, 'N', vl));\n        mask = vmor_mm_b8(mask, vmseq_vx_u8m1(vec, 'O', vl));\n        mask = vmor_mm_b8(mask, vmseq_vx_u8m1(vec, 'P', vl));\n        mask = vmor_mm_b8(mask, vmseq_vx_u8m1(vec, 'Q', vl));\n        mask = vmor_mm_b8(mask, vmseq_vx_u8m1(vec, 'R', vl));\n        mask = vmor_mm_b8(mask, vmseq_vx_u8m1(vec, 'S', vl));\n        mask = vmor_mm_b8(mask, vmseq_vx_u8m1(vec, 'T', vl));\n        mask = vmor_mm_b8(mask, vmseq_vx_u8m1(vec, 'U', vl));\n        mask = vmor_mm_b8(mask, vmseq_vx_u8m1(vec, 'V', vl));\n        mask = vmor_mm_b8(mask, vmseq_vx_u8m1(vec, 'W', vl));\n        mask = vmor_mm_b8(mask, vmseq_vx_u8m1(vec, 'X', vl));\n        mask = vmor_mm_b8(mask, vmseq_vx_u8m1(vec, 'Y', vl));\n        mask = vmor_mm_b8(mask, vmseq_vx_u8m1(vec, 'Z', vl));\n\n        vuint8m1_t masked_vec = vmerge_vxm_u8m1(vec, 0, mask, vl);\n        sum += vmv_x_s_u8m1_i8(vredsum_vs_u8m1_u8m1(masked_vec, vmv_v_x_u8m1(0), vl));\n    }\n\n    for (; i < len; ++i) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            sum += s[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint digitSum_simd(std::string s) {\n    size_t len = s.length();\n    int sum = 0;\n\n    size_t vl;\n    vuint8m1_t vec_upper_mask = vmv_v_x_u8m1(0, vsetvlmax_e8m1());\n    vuint8m1_t vec_char;\n    vbool8_t vec_is_upper;\n\n    for (size_t i = 0; i < len; i += vl) {\n        vl = vsetvl_e8m1(len - i);\n\n        // Load characters into vector register\n        vec_char = vle8_v_u8m1((const uint8_t*)(s.data() + i), vl);\n\n        // Create a mask for uppercase letters ('A' to 'Z')\n        vec_is_upper = vmsltu_vx_u8m1_b8(vec_char, 'Z' + 1, vl);\n        vec_is_upper = vmul_vv_u8m1_b8(vec_is_upper, vmsgtu_vx_u8m1_b8(vec_char, 'A' - 1, vl), vl);\n\n        // Mask and add the ASCII values of uppercase letters\n        vuint8m1_t vec_upper_chars = vmerge_vxm_u8m1(vec_upper_mask, vec_char, vec_is_upper, vl);\n        sum += vmv_x_s_u8m1_i8(vredsum_vs_u8m1_u8m1(vec_upper_chars, vec_upper_mask, vl));\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint digitSum_simd(std::string s) {\n    size_t len = s.length();\n    int sum = 0;\n\n    size_t vl;\n    size_t i = 0;\n\n    while (i < len) {\n        vl = vsetvl_e8m1(len - i);\n\n        // Load a vector of characters from the string\n        vuint8m1_t vec_chars = vle8_v_u8m1((const uint8_t*)(s.c_str() + i), vl);\n\n        // Create a mask for uppercase letters ('A' to 'Z')\n        vbool8_t mask_upper = vmsgeu_vx_u8m1_b8(vec_chars, 'A', vl) & vm sleu_vx_u8m1_b8(vec_chars, 'Z', vl);\n\n        // Apply the mask to filter only uppercase letters\n        vuint8m1_t vec_upper = vcompress_vm(mask_upper, vec_chars, vl);\n\n        // Convert the filtered vector to integers and calculate their sum\n        vint16m2_t vec_int = vwaddu_vx_u16m2(vec_upper, 0, vl);\n        sum += vsum_vs_i16m2_i16m1(vec_int, vl);\n\n        i += vl;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint digitSum_simd(std::string s) {\n    size_t len = s.length();\n    int sum = 0;\n\n    size_t vl;\n    vuint8m1_t vec_upper_mask = vmv_v_x_u8m1(0, vsetvlmax_e8m1());\n    vuint8m1_t vec_char;\n    vbool8_t vec_is_upper;\n\n    for (size_t i = 0; i < len; i += vl) {\n        vl = vsetvl_e8m1(len - i);\n\n        // Load characters into vector register\n        vec_char = vle8_v_u8m1((const uint8_t*)(s.data() + i), vl);\n\n        // Create a mask for uppercase letters ('A' to 'Z')\n        vec_is_upper = vmsltu_vx_u8m1_b8(vec_char, 'Z' + 1, vl);\n        vec_is_upper = vmul_vv_u8m1_b8(vec_is_upper, vmsgtu_vx_u8m1_b8(vec_char, 'A' - 1, vl), vl);\n\n        // Mask and add only the uppercase characters\n        vuint8m1_t vec_upper_chars = vmerge_vxm_u8m1(vec_upper_mask, vec_char, vec_is_upper, vl);\n        sum += vmv_x_s_u8m1_i8(vredsum_vs_u8m1_u8m1(vec_upper_chars, vec_upper_mask, vl));\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_94_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    size_t n = arr.size();\n    if (n == 0) return {};\n\n    int smallest_even = -1;\n    int smallest_index = -1;\n\n    size_t vl;\n    size_t i = 0;\n    vint32m8_t vec, even_mask, indices;\n    vbool4_t bool_mask;\n\n    for (; i + vsetvlmax_e32m8() <= n; i += vl) {\n        vl = vsetvl_e32m8(n - i);\n\n        // Load vector of elements\n        vec = vle32_v_i32m8(arr.data() + i, vl);\n\n        // Create a mask for even numbers\n        even_mask = vand_vx_i32m8(vec, 1, vl);\n        bool_mask = vmseq_vx_i32m8(even_mask, 0, vl);\n\n        // Create a vector of indices\n        indices = vid_v_i32m8(vl);\n        indices = vadd_vx_i32m8(indices, i, vl);\n\n        // Compress the vector to keep only even numbers and their indices\n        vint32m8_t even_values = vcompress_vm_i32m8(bool_mask, vec, vl);\n        vint32m8_t even_indices = vcompress_vm_i32m8(bool_mask, indices, vl);\n\n        // Find the minimum even value and its index\n        int min_val = vredmin_vs_i32m8_i32m1(even_values, vl);\n        int min_idx = vredmin_vs_i32m8_i32m1(even_indices, vl);\n\n        if (smallest_even == -1 || min_val < smallest_even ||\n            (min_val == smallest_even && min_idx < smallest_index)) {\n            smallest_even = min_val;\n            smallest_index = min_idx;\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        if (arr[i] % 2 == 0) {\n            if (smallest_even == -1 || arr[i] < smallest_even ||\n                (arr[i] == smallest_even && i < smallest_index)) {\n                smallest_even = arr[i];\n                smallest_index = i;\n            }\n        }\n    }\n\n    if (smallest_even == -1) return {};\n    return {smallest_even, smallest_index};\n}\n```"}
{"task_id": "SimdBench_94_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n\n    size_t n = arr.size();\n    int smallest_even = -1;\n    int smallest_index = -1;\n\n    size_t vl;\n    size_t i = 0;\n\n    while (i < n) {\n        vl = vsetvl_e32m8(n - i);\n\n        vint32m8_t vec = vle32_v_i32m8(&arr[i], vl);\n        vbool4_t mask_even = vmseq_vx_i32m8_b4(vec, 0, vl);\n\n        vint32m8_t even_values = vmerge_vxm_i32m8(vec, INT32_MAX, mask_even, vl);\n        vint32m8_t indices = vid_v_i32m8(vl);\n        indices = vadd_vx_i32m8(indices, i, vl);\n\n        vbool4_t mask_smallest = vmseq_vv_i32m8_b4(even_values, smallest_even, vl);\n        vbool4_t mask_update = vmflt_vv_i32m8_b4(even_values, smallest_even, vl);\n\n        smallest_even = vmv_x_s_i32m8_i32(vfmin_vv_i32m8(even_values, smallest_even, vl));\n        smallest_index = vmv_x_s_i32m8_i32(vfmin_vv_i32m8(indices, smallest_index, vl));\n\n        i += vl;\n    }\n\n    if (smallest_even == -1) return {};\n    return {smallest_even, smallest_index};\n}\n```"}
{"task_id": "SimdBench_94_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    size_t n = arr.size();\n    if (n == 0) return {};\n\n    int smallest_even = std::numeric_limits<int>::max();\n    int smallest_index = -1;\n\n    size_t vl;\n    size_t i = 0;\n\n    while (i < n) {\n        vl = vsetvl_e32m8(n - i);\n\n        vint32m8_t vec = vle32_v_i32m8(&arr[i], vl);\n        vbool4_t mask_even = vmseq_vx_i32m8_b4(vec, 0, vl);\n\n        vint32m8_t even_values = vmerge_vxm_i32m8(vec, std::numeric_limits<int>::max(), mask_even, vl);\n        vint32m1_t min_value = vmv_v_x_i32m1(std::numeric_limits<int>::max());\n        min_value = vredmin_vs_i32m8_i32m1(even_values, min_value, vl);\n\n        int local_min;\n        vse32_v_i32m1(&local_min, min_value, 1);\n\n        if (local_min < smallest_even) {\n            vbool4_t mask_min = vmseq_vx_i32m8_b4(even_values, local_min, vl);\n            vid_v_u32m8(vl);\n            vint32m8_t indices = vid_v_u32m8(vl);\n            vint32m1_t min_index = vmv_v_x_i32m1(std::numeric_limits<int>::max());\n            min_index = vredmin_vs_i32m8_i32m1(indices, min_index, mask_min, vl);\n\n            int local_index;\n            vse32_v_i32m1(&local_index, min_index, 1);\n\n            if (local_min < smallest_even || (local_min == smallest_even && local_index < smallest_index)) {\n                smallest_even = local_min;\n                smallest_index = local_index + i;\n            }\n        }\n\n        i += vl;\n    }\n\n    if (smallest_index == -1) return {};\n    return {smallest_even, smallest_index};\n}\n```"}
{"task_id": "SimdBench_94_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n\n    size_t n = arr.size();\n    int smallest_even = std::numeric_limits<int>::max();\n    int smallest_index = -1;\n\n    size_t vl;\n    vint32m8_t vec_vals, vec_indices, vec_mask;\n    vbool4_t mask;\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m8(n - i);\n\n        // Load values into vector register\n        vec_vals = vle32_v_i32m8(arr.data() + i, vl);\n\n        // Create a vector of indices\n        vec_indices = vid_v_i32m8(vl);\n        vec_indices = vadd_vx_i32m8(vec_indices, i, vl);\n\n        // Mask for even numbers\n        vec_mask = vmseq_vx_i32m8(vec_vals, 0, vl); // Initialize mask\n        vec_mask = vmfeq_vx_i32m8(vec_vals, 0, vl); // Check even numbers\n\n        // Apply mask to filter even numbers\n        vint32m8_t vec_even_vals = vcompress_vm_i32m8(vec_vals, vec_mask, vl);\n        vint32m8_t vec_even_indices = vcompress_vm_i32m8(vec_indices, vec_mask, vl);\n\n        // Find the minimum even value and its index\n        int min_val = vmv_x_s_i32m8_i32(vredmin_vs_i32m8_i32m1(vec_even_vals, vl));\n        int min_idx = vmv_x_s_i32m8_i32(vredmin_vs_i32m8_i32m1(vec_even_indices, vl));\n\n        // Update smallest_even and smallest_index if needed\n        if (min_val < smallest_even) {\n            smallest_even = min_val;\n            smallest_index = min_idx;\n        }\n    }\n\n    if (smallest_index == -1) return {};\n    return {smallest_even, smallest_index};\n}\n```"}
{"task_id": "SimdBench_94_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n\n    size_t n = arr.size();\n    int smallest_even = -1;\n    int smallest_index = -1;\n\n    size_t vlmax = vsetvlmax_e32m8();\n    vbool32_t mask_even;\n    vint32m8_t vec_vals, vec_indices, vec_smallest_val, vec_smallest_idx;\n    vint32m8_t vec_init_val = vmv_v_x_i32m8(0x7FFFFFFF, vlmax); // Max int value\n    vint32m8_t vec_init_idx = vmv_v_x_i32m8(-1, vlmax);        // Invalid index\n\n    vec_smallest_val = vec_init_val;\n    vec_smallest_idx = vec_init_idx;\n\n    for (size_t i = 0; i < n; i += vlmax) {\n        size_t vl = vsetvl_e32m8(n - i);\n        vec_vals = vle32_v_i32m8(arr.data() + i, vl);\n\n        // Create a mask for even numbers\n        mask_even = vmsne_vx_i32m8_b32(vec_vals, vec_vals & 1, vl);\n\n        // Prepare indices vector\n        vint32m8_t vec_current_indices = vid_v_i32m8(vl);\n        vec_current_indices = vadd_vx_i32m8(vec_current_indices, i, vl);\n\n        // Update smallest even value and index\n        vbool32_t update_mask = vmflt_vv_i32m8_b32(vec_vals, vec_smallest_val, vl);\n        update_mask = vmand_mm(update_mask, mask_even, vl);\n\n        vec_smallest_val = vmerge_vvm_i32m8(update_mask, vec_vals, vec_smallest_val, vl);\n        vec_smallest_idx = vmerge_vvm_i32m8(update_mask, vec_current_indices, vec_smallest_idx, vl);\n    }\n\n    // Reduce across lanes to find the global smallest even value and its index\n    int smallest_val_scalar = vmv_x_s_i32m8_i32(vec_smallest_val);\n    int smallest_idx_scalar = vmv_x_s_i32m8_i32(vec_smallest_idx);\n\n    for (size_t i = 1; i < vlmax; ++i) {\n        int val = vget_vi32m8_i32(vec_smallest_val, i);\n        int idx = vget_vi32m8_i32(vec_smallest_idx, i);\n        if (val < smallest_val_scalar && val % 2 == 0) {\n            smallest_val_scalar = val;\n            smallest_idx_scalar = idx;\n        }\n    }\n\n    if (smallest_val_scalar == 0x7FFFFFFF) {\n        return {};\n    }\n\n    return {smallest_val_scalar, smallest_idx_scalar};\n}\n```"}
{"task_id": "SimdBench_95_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    size_t n = lst.size();\n    int max_val = *std::max_element(lst.begin(), lst.end());\n    std::vector<int> freq(max_val + 1, 0);\n\n    size_t vl;\n    vint32m8_t vec_val, vec_one;\n    vbool4_t mask;\n\n    // Count frequencies using RVV\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m8(n - i);\n        vec_val = vle32_v_i32m8(&lst[i], vl);\n        for (size_t j = 0; j < vl; ++j) {\n            freq[vget_i32m8(vec_val, j)]++;\n        }\n    }\n\n    // Find the greatest integer with frequency >= value\n    int result = -1;\n    for (int i = 1; i <= max_val; ++i) {\n        if (freq[i] >= i) {\n            result = std::max(result, i);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_95_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    size_t n = lst.size();\n    int max_val = *std::max_element(lst.begin(), lst.end());\n    std::vector<int> freq(max_val + 1, 0);\n\n    size_t vl;\n    vint32m8_t vec_val, vec_one;\n    vbool4_t mask;\n\n    // Count frequencies using RVV\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m8(n - i);\n        vec_val = vle32_v_i32m8(&lst[i], vl);\n        for (size_t j = 0; j < vl; ++j) {\n            freq[vget_i32m8(vec_val, j)]++;\n        }\n    }\n\n    // Find the greatest integer with frequency >= value\n    int result = -1;\n    for (int val = 1; val <= max_val; ++val) {\n        if (freq[val] >= val) {\n            result = std::max(result, val);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_95_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    size_t n = lst.size();\n    int max_val = *std::max_element(lst.begin(), lst.end());\n    std::vector<int> freq(max_val + 1, 0);\n\n    size_t vl;\n    vint32m8_t vec_val, vec_one;\n    vbool4_t mask;\n\n    // Count frequencies using RVV\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m8(n - i);\n        vec_val = vle32_v_i32m8(&lst[i], vl);\n        for (size_t j = 0; j < vl; ++j) {\n            freq[vget_i32m8(vec_val, j)]++;\n        }\n    }\n\n    // Find the greatest integer with frequency >= value\n    int result = -1;\n    for (int val = 1; val <= max_val; ++val) {\n        if (freq[val] >= val) {\n            result = std::max(result, val);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_95_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    size_t n = lst.size();\n    int max_val = *std::max_element(lst.begin(), lst.end());\n    std::vector<int> freq(max_val + 1, 0);\n\n    size_t vl;\n    vint32m8_t vec_val, vec_one;\n    vbool4_t mask;\n\n    // Count frequency using RVV\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m8(n - i);\n        vec_val = vle32_v_i32m8(&lst[i], vl);\n        for (size_t j = 0; j < vl; ++j) {\n            freq[vget_i32m8(vec_val, j)]++;\n        }\n    }\n\n    // Find the greatest integer with frequency >= value\n    int result = -1;\n    for (int val = 1; val <= max_val; ++val) {\n        if (freq[val] >= val) {\n            result = std::max(result, val);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_95_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    size_t n = lst.size();\n    int max_val = *std::max_element(lst.begin(), lst.end());\n    std::vector<int> freq(max_val + 1, 0);\n\n    size_t vl;\n    vint32m8_t vec_val, vec_one;\n    int32_t idx[n];\n\n    // Initialize index array for scatter\n    for (size_t i = 0; i < n; ++i) {\n        idx[i] = lst[i];\n    }\n\n    // Compute frequencies using RVV intrinsics\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m8(n - i);\n        vec_val = vle32_v_i32m8(&idx[i], vl);\n        vec_one = vmv_v_x_i32m8(1, vl);\n        vse32_v_i32m8(&freq[0], vfadd_vv_i32m8(vec_val, vec_one, vl), vl);\n    }\n\n    // Find the greatest integer with frequency >= value\n    int result = -1;\n    for (int i = max_val; i > 0; --i) {\n        if (freq[i] >= i) {\n            result = i;\n            break;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_96_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    size_t n = q.size();\n    int sum = 0;\n    bool is_palindromic = true;\n\n    size_t vlmax = vsetvlmax_e32m8();\n    size_t vl = vlmax;\n\n    // Compute the sum of elements using RVV intrinsics\n    vint32m8_t vec_sum = vmv_v_x_i32m8(0, vl);\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m8(n - i);\n        vint32m8_t vec = vle32_v_i32m8(&q[i], vl);\n        vec_sum = vadd_vv_i32m8(vec_sum, vec, vl);\n    }\n    sum = vsum_vs_i32m8_i32(vec_sum, vl);\n\n    // Check if the vector is palindromic using RVV intrinsics\n    size_t mid = n / 2;\n    for (size_t i = 0; i < mid; i += vl) {\n        vl = vsetvl_e32m8(mid - i);\n        vint32m8_t vec_left = vle32_v_i32m8(&q[i], vl);\n        vint32m8_t vec_right = vlse32_v_i32m8(&q[n - i - 1], -sizeof(int), vl);\n        vbool32_t cmp = vmseq_vv_i32m8_b32(vec_left, vec_right, vl);\n        if (!vmall_b32(cmp, vl)) {\n            is_palindromic = false;\n            break;\n        }\n    }\n\n    return is_palindromic && (sum <= w);\n}\n```"}
{"task_id": "SimdBench_96_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    size_t n = q.size();\n    int sum = 0;\n    bool is_palindromic = true;\n\n    size_t vlmax = vsetvlmax_e32m8();\n    size_t vl = vlmax;\n\n    // Compute the sum of elements using RVV\n    vint32m8_t vec_sum = vmv_v_x_i32m8(0, vl);\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m8(n - i);\n        vint32m8_t vec = vle32_v_i32m8(&q[i], vl);\n        vec_sum = vwredsum_vs_i32m8_i32m1(vec, vec_sum, vl);\n    }\n    sum = vmv_x_s_i32m1_i32(vfredsum_vs_i32m1_i32m1(vec_sum, vec_sum, vl));\n\n    // Check if the vector is palindromic using RVV\n    for (size_t i = 0; i < n / 2; i += vl) {\n        vl = vsetvl_e32m8(n / 2 - i);\n        vint32m8_t vec_left = vle32_v_i32m8(&q[i], vl);\n        vint32m8_t vec_right = vlse32_v_i32m8(&q[n - i - vl], vl);\n        vbool32_t cmp = vmseq_vv_i32m8(vec_left, vec_right, vl);\n        if (!vmv_x_s_b32(vmreduce_all_b32(cmp))) {\n            is_palindromic = false;\n            break;\n        }\n    }\n\n    return is_palindromic && (sum <= w);\n}\n```"}
{"task_id": "SimdBench_96_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    size_t n = q.size();\n    int sum = 0;\n    bool is_palindromic = true;\n\n    size_t vlmax = vsetvlmax_e32m8();\n    size_t vl;\n    int32_t *q_data = q.data();\n\n    // Compute the sum of elements using RVV\n    vint32m8_t vsum_vec = vmv_v_x_i32m8(0, vlmax);\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m8(n - i);\n        vint32m8_t vec = vle32_v_i32m8(q_data + i, vl);\n        vsum_vec = vadd_vv_i32m8(vsum_vec, vec, vl);\n    }\n    sum = vmv_x_s_i32m8_i32(vsum_vec);\n\n    // Check if the vector is palindromic using RVV\n    size_t mid = n / 2;\n    for (size_t i = 0; i < mid; i += vl) {\n        vl = vsetvl_e32m8(mid - i);\n        vint32m8_t vec1 = vle32_v_i32m8(q_data + i, vl);\n        vint32m8_t vec2 = vlse32_v_i32m8(q_data + (n - i - vl), -sizeof(int), vl);\n        vbool4_t cmp = vmseq_vv_i32m8_b4(vec1, vec2, vl);\n        if (!vmv_x_s_b4_i8(vmreduction_vm_b4(cmp, vl))) {\n            is_palindromic = false;\n            break;\n        }\n    }\n\n    return is_palindromic && (sum <= w);\n}\n```"}
{"task_id": "SimdBench_96_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    size_t n = q.size();\n    int sum = 0;\n    bool is_palindromic = true;\n\n    size_t vlmax = vsetvlmax_e32m1();\n    size_t vl = vlmax;\n\n    // Compute sum using RVV\n    vint32m1_t v_sum = vmv_v_x_i32m1(0, vl);\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        vint32m1_t v = vle32_v_i32m1(&q[i], vl);\n        v_sum = vadd_vv_i32m1(v_sum, v, vl);\n    }\n    sum = vmv_x_s_i32m1_i32(v_sum);\n\n    // Check palindromic property using RVV\n    size_t mid = n / 2;\n    for (size_t i = 0; i < mid; i += vl) {\n        vl = vsetvl_e32m1(mid - i);\n        vint32m1_t v_front = vle32_v_i32m1(&q[i], vl);\n        vint32m1_t v_back = vle32_v_i32m1(&q[n - i - vl], vl);\n        vbool32_t cmp = vmseq_vv_i32m1_b32(v_front, v_back, vl);\n        if (!vmv_x_s_b32(vmreduction_and_b32(cmp))) {\n            is_palindromic = false;\n            break;\n        }\n    }\n\n    return is_palindromic && (sum <= w);\n}\n```"}
{"task_id": "SimdBench_96_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    size_t n = q.size();\n    int sum = 0;\n    bool is_palindromic = true;\n\n    size_t vlmax = vsetvlmax_e32m8();\n    size_t vl = vlmax;\n\n    // Compute the sum of elements using RVV\n    vint32m8_t vec_sum = vmv_v_x_i32m8(0, vl);\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m8(n - i);\n        vint32m8_t vec = vle32_v_i32m8(&q[i], vl);\n        vec_sum = vadd_vv_i32m8(vec_sum, vec, vl);\n    }\n    sum = vmv_x_s_i32m8_i32(vec_sum);\n\n    // Check if the vector is palindromic using RVV\n    size_t mid = n / 2;\n    for (size_t i = 0; i < mid; i += vl) {\n        vl = vsetvl_e32m8(mid - i);\n        vint32m8_t vec_left = vle32_v_i32m8(&q[i], vl);\n        vint32m8_t vec_right = vlse32_v_i32m8(&q[n - i - vl], vl);\n        vbool32_t cmp = vmseq_vv_i32m8(vec_left, vec_right, vl);\n        if (!vmv_x_s_b32(vmreduction_and_b32(cmp))) {\n            is_palindromic = false;\n            break;\n        }\n    }\n\n    return is_palindromic && (sum <= w);\n}\n```"}
{"task_id": "SimdBench_97_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint smallest_change_simd(std::vector<int> arr) {\n    size_t n = arr.size();\n    int result = 0;\n    size_t vlmax = vsetvlmax_e32m8();\n\n    for (size_t i = 0; i < n / 2; i += vlmax) {\n        size_t vl = vsetvl_e32m8(n / 2 - i);\n\n        // Load the first half of the array\n        vint32m8_t vec1 = vle32_v_i32m8(&arr[i], vl);\n\n        // Load the second half of the array in reverse order\n        vint32m8_t vec2 = vle32_v_i32m8(&arr[n - i - vl], vl);\n        vec2 = vrev_v_i32m8(vec2, vl);\n\n        // Compare the two vectors\n        vbool4_t mask = vmseq_vv_i32m8_b4(vec1, vec2, vl);\n\n        // Count the number of mismatches\n        result += vcpop_m_b4(mask, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_97_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint smallest_change_simd(std::vector<int> arr) {\n    size_t n = arr.size();\n    int result = 0;\n\n    size_t vlmax = vsetvlmax_e32m1();\n    for (size_t i = 0; i < n / 2; i += vlmax) {\n        size_t vl = vsetvl_e32m1(n / 2 - i);\n\n        // Load elements from the start and end of the array\n        vint32m1_t vec_start = vle32_v_i32m1(&arr[i], vl);\n        vint32m1_t vec_end = vle32_v_i32m1(&arr[n - i - vl], vl);\n\n        // Reverse the order of vec_end to match corresponding positions\n        vec_end = vrev_v_i32m1(vec_end, vl);\n\n        // Compare the two vectors element-wise\n        vbool32_t mask = vmseq_vv_i32m1_b32(vec_start, vec_end, vl);\n\n        // Count mismatches\n        result += vcpop_m_b32(vmnot_m_b32(mask, vl), vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_97_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint smallest_change_simd(std::vector<int> arr) {\n    size_t n = arr.size();\n    int result = 0;\n\n    size_t vlmax = vsetvlmax_e32m8();\n    for (size_t i = 0; i < n / 2; i += vlmax) {\n        size_t vl = vsetvl_e32m8(n / 2 - i);\n\n        // Load the first half of the array\n        vint32m8_t vec1 = vle32_v_i32m8(&arr[i], vl);\n\n        // Load the second half of the array in reverse order\n        vint32m8_t vec2 = vle32_v_i32m8(&arr[n - i - vl], vl);\n        vec2 = vrev_v_i32m8(vec2, vl);\n\n        // Compare the two vectors for inequality\n        vbool4_t mask = vmseq_vv_i32m8_b4(vec1, vec2, vl);\n\n        // Count the number of mismatches\n        result += vcpop_m_b4(mask, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_97_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint smallest_change_simd(std::vector<int> arr) {\n    size_t n = arr.size();\n    int result = 0;\n\n    size_t vlmax = vsetvlmax_e32m8();\n    for (size_t i = 0; i < n / 2; i += vlmax) {\n        size_t vl = vsetvl_e32m8(n / 2 - i);\n\n        // Load the first half of the array\n        vint32m8_t vec1 = vle32_v_i32m8(&arr[i], vl);\n        // Load the second half of the array in reverse order\n        vint32m8_t vec2 = vle32_v_i32m8(&arr[n - i - vl], vl);\n        vec2 = vrev_v_i32m8(vec2, vl);\n\n        // Compare the two vectors for inequality\n        vbool4_t mask = vmseq_vv_i32m8_b4(vec1, vec2, vl);\n\n        // Count the number of mismatches\n        result += vcpop_m_b4(mask, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_97_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint smallest_change_simd(std::vector<int> arr) {\n    size_t n = arr.size();\n    int result = 0;\n\n    size_t vlmax = vsetvlmax_e32m8(); // Set vector length for int32_t\n\n    for (size_t i = 0; i < n / 2; i += vlmax) {\n        size_t vl = vsetvl_e32m8(n / 2 - i); // Set vector length dynamically\n\n        // Load elements from the start and end of the array\n        vint32m8_t vec_start = vle32_v_i32m8(&arr[i], vl);\n        vint32m8_t vec_end = vle32_v_i32m8(&arr[n - i - vl], vl);\n\n        // Reverse the order of vec_end to match corresponding positions\n        vec_end = vrev_v_i32m8(vec_end, vl);\n\n        // Compare elements from start and end\n        vbool4_t mask = vmseq_vv_i32m8_b4(vec_start, vec_end, vl);\n\n        // Count mismatches\n        result += vcpop_m_b4(mask, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_98_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    size_t total_chars1 = 0, total_chars2 = 0;\n    size_t i = 0, j = 0;\n\n    // Process lst1 using RVV intrinsics\n    while (i < lst1.size()) {\n        size_t vl = __riscv_vsetvl_e8m1(lst1.size() - i);\n        size_t sum = 0;\n        for (size_t k = 0; k < vl; ++k) {\n            sum += lst1[i + k].size();\n        }\n        total_chars1 += sum;\n        i += vl;\n    }\n\n    // Process lst2 using RVV intrinsics\n    while (j < lst2.size()) {\n        size_t vl = __riscv_vsetvl_e8m1(lst2.size() - j);\n        size_t sum = 0;\n        for (size_t k = 0; k < vl; ++k) {\n            sum += lst2[j + k].size();\n        }\n        total_chars2 += sum;\n        j += vl;\n    }\n\n    // Compare total characters and return the appropriate vector\n    if (total_chars1 <= total_chars2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    size_t total_chars1 = 0, total_chars2 = 0;\n    size_t i = 0, j = 0;\n\n    // Process lst1 using RVV intrinsics\n    while (i < lst1.size()) {\n        size_t vl = __riscv_vsetvl_e8m1(lst1.size() - i);\n        size_t chars_sum = 0;\n        for (size_t k = 0; k < vl; ++k) {\n            chars_sum += lst1[i + k].size();\n        }\n        total_chars1 += chars_sum;\n        i += vl;\n    }\n\n    // Process lst2 using RVV intrinsics\n    while (j < lst2.size()) {\n        size_t vl = __riscv_vsetvl_e8m1(lst2.size() - j);\n        size_t chars_sum = 0;\n        for (size_t k = 0; k < vl; ++k) {\n            chars_sum += lst2[j + k].size();\n        }\n        total_chars2 += chars_sum;\n        j += vl;\n    }\n\n    // Compare total characters and return the appropriate vector\n    if (total_chars1 <= total_chars2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    size_t total_chars1 = 0, total_chars2 = 0;\n    size_t i = 0;\n\n    // Process lst1\n    while (i < lst1.size()) {\n        size_t vl;\n        size_t sum = 0;\n        for (vl = vsetvl_e8m1(lst1.size() - i); vl > 0; vl = vsetvl_e8m1(lst1.size() - i)) {\n            vuint8m1_t lengths = vmv_v_x_u8m1(0, vl);\n            for (size_t j = 0; j < vl; ++j) {\n                lengths = vset(lengths, j, lst1[i + j].size());\n            }\n            vuint8m1_t ones = vmv_v_x_u8m1(1, vl);\n            vuint8m1_t partial_sums = vwmul_vv_u16m2(lengths, ones, vl);\n            sum += vsum_vs_u16m2_u32m1(partial_sums, vl);\n            i += vl;\n        }\n        total_chars1 += sum;\n    }\n\n    i = 0;\n    // Process lst2\n    while (i < lst2.size()) {\n        size_t vl;\n        size_t sum = 0;\n        for (vl = vsetvl_e8m1(lst2.size() - i); vl > 0; vl = vsetvl_e8m1(lst2.size() - i)) {\n            vuint8m1_t lengths = vmv_v_x_u8m1(0, vl);\n            for (size_t j = 0; j < vl; ++j) {\n                lengths = vset(lengths, j, lst2[i + j].size());\n            }\n            vuint8m1_t ones = vmv_v_x_u8m1(1, vl);\n            vuint8m1_t partial_sums = vwmul_vv_u16m2(lengths, ones, vl);\n            sum += vsum_vs_u16m2_u32m1(partial_sums, vl);\n            i += vl;\n        }\n        total_chars2 += sum;\n    }\n\n    return total_chars1 <= total_chars2 ? lst1 : lst2;\n}\n```"}
{"task_id": "SimdBench_98_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    size_t total_chars1 = 0, total_chars2 = 0;\n    size_t i = 0, j = 0;\n\n    // Process lst1 using RVV intrinsics\n    while (i < lst1.size()) {\n        size_t vl;\n        vuint8m1_t vec_str_len;\n        size_t sum = 0;\n\n        for (; i < lst1.size(); i += vl) {\n            vl = vsetvl_e8m1(lst1.size() - i);\n            vec_str_len = vmv_v_x_u8m1(0, vl);\n\n            for (size_t k = 0; k < vl && (i + k) < lst1.size(); ++k) {\n                vec_str_len = vset_v_u8m1(vec_str_len, k, lst1[i + k].size());\n            }\n\n            vuint8m1_t vec_ones = vmv_v_x_u8m1(1, vl);\n            vuint8m1_t vec_sum = vwredsum_vs_u8m1_u8m1(vec_str_len, vec_ones, vl);\n            sum += vmv_x_s_u8m1_u8(vec_sum);\n        }\n\n        total_chars1 += sum;\n    }\n\n    // Process lst2 using RVV intrinsics\n    while (j < lst2.size()) {\n        size_t vl;\n        vuint8m1_t vec_str_len;\n        size_t sum = 0;\n\n        for (; j < lst2.size(); j += vl) {\n            vl = vsetvl_e8m1(lst2.size() - j);\n            vec_str_len = vmv_v_x_u8m1(0, vl);\n\n            for (size_t k = 0; k < vl && (j + k) < lst2.size(); ++k) {\n                vec_str_len = vset_v_u8m1(vec_str_len, k, lst2[j + k].size());\n            }\n\n            vuint8m1_t vec_ones = vmv_v_x_u8m1(1, vl);\n            vuint8m1_t vec_sum = vwredsum_vs_u8m1_u8m1(vec_str_len, vec_ones, vl);\n            sum += vmv_x_s_u8m1_u8(vec_sum);\n        }\n\n        total_chars2 += sum;\n    }\n\n    return (total_chars1 <= total_chars2) ? lst1 : lst2;\n}\n```"}
{"task_id": "SimdBench_98_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    size_t total_chars_lst1 = 0;\n    size_t total_chars_lst2 = 0;\n\n    // Calculate total characters in lst1 using RVV\n    size_t i = 0;\n    size_t vl;\n    while (i < lst1.size()) {\n        vl = vsetvl_e8m1(lst1.size() - i);\n        vuint8m1_t vec_len = vmv_v_x_u8m1(0, vl);\n        for (size_t j = 0; j < vl; ++j) {\n            vec_len = vset_v_u8m1(vec_len, j, lst1[i + j].size(), vl);\n        }\n        vuint32m4_t vec_sum = vwredsum_vs_u8m1_u32m4(vmv_v_x_u32m4(0, vl), vec_len, vwredsum_vs_u8m1_u32m4(vmv_v_x_u32m4(0, vl), vec_len, vl), vl);\n        total_chars_lst1 += vmv_x_s_u32m4_u32(vec_sum);\n        i += vl;\n    }\n\n    // Calculate total characters in lst2 using RVV\n    i = 0;\n    while (i < lst2.size()) {\n        vl = vsetvl_e8m1(lst2.size() - i);\n        vuint8m1_t vec_len = vmv_v_x_u8m1(0, vl);\n        for (size_t j = 0; j < vl; ++j) {\n            vec_len = vset_v_u8m1(vec_len, j, lst2[i + j].size(), vl);\n        }\n        vuint32m4_t vec_sum = vwredsum_vs_u8m1_u32m4(vmv_v_x_u32m4(0, vl), vec_len, vwredsum_vs_u8m1_u32m4(vmv_v_x_u32m4(0, vl), vec_len, vl), vl);\n        total_chars_lst2 += vmv_x_s_u32m4_u32(vec_sum);\n        i += vl;\n    }\n\n    // Compare and return the appropriate vector\n    if (total_chars_lst1 <= total_chars_lst2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_99_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n == 0 || (n == 1 && x != 1)) {\n        return false;\n    }\n\n    size_t vlmax = vsetvlmax_e64m1();\n    vuint64m1_t vx = vmv_v_x_u64m1(x, vlmax);\n    vuint64m1_t vn = vmv_v_x_u64m1(n, vlmax);\n    vuint64m1_t vresult = vmv_v_x_u64m1(1, vlmax);\n    vbool64_t mask;\n\n    while (1) {\n        vresult = vwmul_vv_u64m1(vresult, vn, vlmax);\n        mask = vmseq_vx_u64m1(vresult, vx, vlmax);\n\n        if (vcpop_m_b64(vmfirst_m_b64(mask, vlmax), vlmax)) {\n            return true;\n        }\n\n        vbool64_t over_mask = vmsgtu_vx_u64m1(vresult, x, vlmax);\n        if (vcpop_m_b64(vmfirst_m_b64(over_mask, vlmax), vlmax)) {\n            break;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n <= 1) {\n        return x == 1;\n    }\n\n    size_t vlmax = vsetvlmax_e64m1();\n    vuint64m1_t vx = vmv_v_x_u64m1(x, vlmax);\n    vuint64m1_t vn = vmv_v_x_u64m1(n, vlmax);\n    vbool64_t result = vmclr_m_b64(vlmax);\n\n    vuint64m1_t power = vmv_v_x_u64m1(1, vlmax);\n    vbool64_t mask = vmseq_vx_u64m1_b64(power, vx, vlmax);\n\n    while (!vmreduce_b64(mask, vlmax)) {\n        power = vwmul_vv_u64m1(power, vn, vlmax);\n        mask = vmseq_vv_u64m1_b64(power, vx, vlmax);\n        result = vor_vv_b64(result, mask, vlmax);\n\n        vbool64_t overflow = vmgeu_vx_u64m1_b64(power, x, vlmax);\n        if (vmreduce_b64(overflow, vlmax)) {\n            break;\n        }\n    }\n\n    return vmreduce_b64(result, vlmax);\n}\n```"}
{"task_id": "SimdBench_99_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n <= 1) {\n        return x == 1;\n    }\n\n    size_t vlmax = __riscv_vsetvlmax_e64m1();\n    uint64_t result = 0;\n\n    // Broadcast x and n into vector registers\n    vuint64m1_t vx = __riscv_vmv_v_x_u64m1(x, vlmax);\n    vuint64m1_t vn = __riscv_vmv_v_x_u64m1(n, vlmax);\n\n    // Initialize power vector to 1 (n^0)\n    vuint64m1_t vpower = __riscv_vmv_v_x_u64m1(1, vlmax);\n\n    // Loop to calculate powers of n in parallel\n    for (size_t i = 0; i < vlmax; ++i) {\n        // Multiply power by n to get next power\n        vpower = __riscv_vmul_vv_u64m1(vpower, vn, vlmax);\n\n        // Compare power with x\n        vbool64_t cmp = __riscv_vmseq_vv_u64m1_b64(vpower, vx, vlmax);\n\n        // Reduce comparison results to scalar\n        result |= __riscv_vcpop_m_b64(__riscv_vfirst_m_b64(cmp, vlmax), vlmax);\n\n        // Early exit if x is found as a power of n\n        if (result) {\n            break;\n        }\n\n        // Exit loop if power exceeds x\n        vbool64_t overflow = __riscv_vmsgtu_vx_u64m1_b64(vpower, x, vlmax);\n        if (__riscv_vcpop_m_b64(__riscv_vfirst_m_b64(overflow, vlmax), vlmax)) {\n            break;\n        }\n    }\n\n    return result > 0;\n}\n```"}
{"task_id": "SimdBench_99_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n <= 1) return x == 1;\n\n    size_t vlmax = __riscv_vsetvlmax_e64m1();\n    uint64_t result = 0;\n    uint64_t power = 1;\n\n    while (power < x) {\n        power *= n;\n        if (power == x) {\n            result = 1;\n            break;\n        }\n    }\n\n    // Broadcast the scalar result to a vector register\n    vuint64m1_t vec_result = __riscv_vmv_v_x_u64m1(result, vlmax);\n\n    // Reduce the vector to a scalar boolean\n    uint64_t reduced_result = __riscv_vmv_x_s_u64m1_u64(vec_result);\n\n    return reduced_result != 0;\n}\n```"}
{"task_id": "SimdBench_99_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n <= 1) {\n        return x == 1;\n    }\n\n    size_t vlmax = __riscv_vsetvlmax_e64m1();\n    uint64_t result = 0;\n\n    // Broadcast x and n into vector registers\n    vuint64m1_t vx = __riscv_vmv_v_x_u64m1(x, vlmax);\n    vuint64m1_t vn = __riscv_vmv_v_x_u64m1(n, vlmax);\n\n    // Initialize power accumulator vector to 1\n    vuint64m1_t vpower = __riscv_vmv_v_x_u64m1(1, vlmax);\n\n    // Loop to calculate powers of n in parallel\n    for (int i = 0; i < 64; ++i) {\n        // Check if any lane matches x\n        vbool64_t match = __riscv_vmseq_vv_u64m1_b64(vpower, vx, vlmax);\n        if (__riscv_vfirst_m_b64(match, vlmax) != -1) {\n            result = 1;\n            break;\n        }\n\n        // Multiply power by n for next iteration\n        vpower = __riscv_vmul_vv_u64m1(vpower, vn, vlmax);\n\n        // Exit early if power exceeds x in all lanes\n        vbool64_t overflow = __riscv_vmsgtu_vx_u64m1_b64(vpower, x, vlmax);\n        if (__riscv_vfirst_m_b64(overflow, vlmax) == 0) {\n            break;\n        }\n    }\n\n    return result != 0;\n}\n```"}
{"task_id": "SimdBench_100_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint hex_key_simd(const std::string & num) {\n    size_t len = num.length();\n    int result = 0;\n\n    // Prime mask for hexadecimal digits: 0x2A8B (binary: 0010101010001011)\n    // Represents primes at positions: 2, 3, 5, 7, 11 (B), 13 (D)\n    const uint16_t prime_mask = 0x2A8B;\n\n    size_t vlmax = vsetvlmax_e8m1();\n    size_t i = 0;\n\n    while (i < len) {\n        size_t vl = vsetvl_e8m1(len - i);\n\n        // Load characters into a vector\n        vuint8m1_t vec = vle8_v_u8m1((const uint8_t*)(num.c_str() + i), vl);\n\n        // Convert characters to numeric values\n        vuint8m1_t is_digit = vmseq_vx_u8m1(vec, '0', vl);\n        vuint8m1_t is_alpha = vmseq_vx_u8m1(vec, 'A', vl);\n        vbool8_t mask = vmor_mm_b8(is_digit, is_alpha, vl);\n\n        vuint8m1_t numeric_values = vsub_vx_u8m1(vec, '0', vl);\n        numeric_values = vadd_vx_u8m1(numeric_values, vmul_vx_u8m1(vsub_vx_u8m1(vec, 'A', vl), 10, vl), vl);\n\n        // Check if numeric values are primes using the mask\n        vuint16m2_t extended_values = vwaddu_vx_u16m2(numeric_values, 0, vl);\n        vbool16_t prime_check = vmseq_vx_u16m2(vand_vx_u16m2(extended_values, prime_mask, vl), 0, vl);\n\n        // Count the number of primes in this vector\n        result += vcpop_m_b16(prime_check, vl);\n\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_100_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint hex_key_simd(const std::string & num) {\n    size_t len = num.length();\n    int result = 0;\n\n    // Prime mask for hexadecimal digits: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F\n    // Index corresponds to the digit value (e.g., 'A' -> 10, 'B' -> 11, etc.)\n    const uint8_t prime_mask[16] = {0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0};\n\n    size_t vlmax = vsetvlmax_e8m1(); // Maximum vector length for 8-bit elements\n\n    for (size_t i = 0; i < len; i += vlmax) {\n        size_t vl = vsetvl_e8m1(len - i); // Set vector length for the remaining elements\n\n        // Load a vector of characters from the string\n        vuint8m1_t vec = vle8_v_u8m1((const uint8_t *)(num.c_str() + i), vl);\n\n        // Convert characters to their numeric values\n        vuint8m1_t is_digit = vmseq_vx_u8m1(vec, '0', vl); // Check if character is '0'-'9'\n        vuint8m1_t is_alpha = vmsge_vx_u8m1(vec, 'A', vl); // Check if character is 'A'-'F'\n\n        vuint8m1_t digit_val = vsub_vx_u8m1(vec, '0', vl); // Subtract '0' for '0'-'9'\n        vuint8m1_t alpha_val = vsub_vx_u8m1(vec, 'A' - 10, vl); // Subtract 'A' - 10 for 'A'-'F'\n\n        vuint8m1_t val = vor_vv_u8m1(vand_vv_u8m1(digit_val, is_digit, vl),\n                                      vand_vv_u8m1(alpha_val, is_alpha, vl), vl);\n\n        // Create a mask for prime values using the precomputed prime_mask\n        vbool8_t prime_flag = vmfalse_b8(); // Initialize as false\n        for (int j = 0; j < 16; ++j) {\n            if (prime_mask[j]) {\n                prime_flag = vmor_vx_b8(prime_flag, vmseq_vx_u8m1(val, j, vl), vl);\n            }\n        }\n\n        // Count the number of true values in the prime_flag mask\n        result += vcpop_m_b8(prime_flag, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_100_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint hex_key_simd(const std::string & num) {\n    size_t len = num.length();\n    int result = 0;\n\n    // Prime mask for hexadecimal digits: 0-15\n    // Index corresponds to hex value, 1 means prime, 0 means not prime\n    const uint8_t prime_mask[16] = {0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0};\n\n    size_t vl;\n    vuint8m1_t v_prime_mask = vle8_v_u8m1(prime_mask, 16); // Load prime mask into vector register\n\n    for (size_t i = 0; i < len; i += vl) {\n        vl = vsetvl_e8m1(len - i); // Set vector length\n\n        // Load characters from the string into a vector register\n        vuint8m1_t v_chars = vle8_v_u8m1((const uint8_t *)(num.c_str() + i), vl);\n\n        // Convert characters '0'-'9' and 'A'-'F' to their numeric values\n        vuint8m1_t v_values = vmul(vsub(v_chars, vsetvl_elem_u8m1('0', vl)), \n                                   vmerge(vsetvl_elem_u8m1(1, vl), vsetvl_elem_u8m1(10, vl), \n                                          vmsltu(v_chars, vsetvl_elem_u8m1('A', vl))));\n\n        // Lookup prime status using the prime mask\n        vbool8_t v_is_prime = vmsne(vlox(v_values, v_prime_mask), vsetvl_elem_u8m1(0, vl));\n\n        // Count the number of primes in this vector\n        result += vcpop_m_b8(v_is_prime, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_100_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint hex_key_simd(const std::string & num) {\n    size_t len = num.length();\n    int result = 0;\n\n    // Prime mask for hexadecimal digits: 0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F\n    // Binary representation: index corresponds to digit value (0-15)\n    // 1 means prime, 0 means not prime\n    const uint16_t prime_mask = 0b0000101000110100; // Primes: 2, 3, 5, 7, 11 (B), 13 (D)\n\n    size_t vlmax = vsetvlmax_e8m1(); // Get maximum vector length for 8-bit elements\n\n    for (size_t i = 0; i < len; i += vlmax) {\n        size_t vl = vsetvl_e8m1(len - i); // Set vector length for the remaining elements\n\n        // Load characters into a vector\n        vuint8m1_t vec_chars = vle8_v_u8m1((const uint8_t *)(num.c_str() + i), vl);\n\n        // Convert characters to numeric values\n        vuint8m1_t vec_values = vmv_v_x_u8m1(0, vl); // Initialize vector with zeros\n        vec_values = vadd_vx_u8m1(vec_values, vec_chars, vl); // Add character values\n        vec_values = vsub_vx_u8m1(vec_values, '0', vl); // Subtract '0' for digits\n        vbool8_t is_alpha = vmseq_vx_u8m1_b8(vec_chars, 'A', vl); // Check if >= 'A'\n        vec_values = vadd_vx_u8m1_m(is_alpha, vec_values, 10, vl); // Add 10 for A-F\n\n        // Create a mask for prime values\n        vuint8m1_t vec_prime_mask = vmv_v_x_u8m1(prime_mask, vl); // Broadcast prime mask\n        vbool8_t is_prime = vmsne_vx_u8m1_b8(vand_vv_u8m1(vec_prime_mask, vec_values, vl), 0, vl);\n\n        // Count the number of primes in this vector\n        result += vcpop_m_b8(is_prime, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_100_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint hex_key_simd(const std::string & num) {\n    size_t len = num.length();\n    int result = 0;\n\n    // Prime mask for hexadecimal digits: 0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F\n    // Binary representation where 1 indicates the digit is prime: 2, 3, 5, 7, B(11), D(13)\n    const uint8_t prime_mask[16] = {0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0};\n\n    size_t vlmax = vsetvlmax_e8m1(); // Get maximum vector length for 8-bit elements\n\n    for (size_t i = 0; i < len; i += vlmax) {\n        size_t vl = vsetvl_e8m1(len - i); // Set vector length based on remaining elements\n\n        // Load characters from the string into a vector register\n        vuint8m1_t vec_chars = vle8_v_u8m1((const uint8_t*)(num.c_str() + i), vl);\n\n        // Convert characters to numerical values (0-15)\n        vuint8m1_t vec_values = vmv_v_x_u8m1(0, vl);\n        vec_values = vadd_vx_u8m1(vec_values, vec_chars, vl);\n        vec_values = vsub_vx_u8m1(vec_values, '0', vl);\n        vbool8_t cond = vmseq_vx_u8m1(vec_chars, 'A', vl);\n        vec_values = vmerge_vxm_u8m1(vec_values, 10, cond, vl);\n        cond = vmseq_vx_u8m1(vec_chars, 'B', vl);\n        vec_values = vmerge_vxm_u8m1(vec_values, 11, cond, vl);\n        cond = vmseq_vx_u8m1(vec_chars, 'C', vl);\n        vec_values = vmerge_vxm_u8m1(vec_values, 12, cond, vl);\n        cond = vmseq_vx_u8m1(vec_chars, 'D', vl);\n        vec_values = vmerge_vxm_u8m1(vec_values, 13, cond, vl);\n        cond = vmseq_vx_u8m1(vec_chars, 'E', vl);\n        vec_values = vmerge_vxm_u8m1(vec_values, 14, cond, vl);\n        cond = vmseq_vx_u8m1(vec_chars, 'F', vl);\n        vec_values = vmerge_vxm_u8m1(vec_values, 15, cond, vl);\n\n        // Create a mask for prime digits using the precomputed prime_mask\n        vuint8m1_t vec_prime_mask = vundefined_u8m1();\n        for (int j = 0; j < 16; ++j) {\n            vbool8_t cmp = vmseq_vx_u8m1(vec_values, j, vl);\n            vec_prime_mask = vmerge_vxm_u8m1(vec_prime_mask, prime_mask[j], cmp, vl);\n        }\n\n        // Count the number of primes in this vector\n        vbool8_t prime_flags = vmseq_vx_u8m1(vec_prime_mask, 1, vl);\n        result += vcpop_m_b8(vl, prime_flags);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_101_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool is_happy_simd(const std::string & s) {\n    size_t len = s.length();\n    if (len < 3) return false;\n\n    size_t vlmax = vsetvlmax_e8m1();\n    bool happy = true;\n\n    for (size_t i = 0; i + 3 <= len; i += vlmax) {\n        size_t vl = vsetvl_e8m1(len - i);\n\n        vuint8m1_t vec = vle8_v_u8m1((const uint8_t*)(s.data() + i), vl);\n        vuint8m1_t vec_next = vle8_v_u8m1((const uint8_t*)(s.data() + i + 1), vl - 1);\n        vuint8m1_t vec_next_next = vle8_v_u8m1((const uint8_t*)(s.data() + i + 2), vl - 2);\n\n        vbool8_t cmp1 = vmseq_vv_u8m1_b8(vec, vec_next, vl);\n        vbool8_t cmp2 = vmseq_vv_u8m1_b8(vec, vec_next_next, vl);\n        vbool8_t cmp3 = vmseq_vv_u8m1_b8(vec_next, vec_next_next, vl);\n\n        vbool8_t result = vmfor_any_b8(cmp1, cmp2, cmp3, vl);\n\n        if (vmv_x_s_b8(result)) {\n            happy = false;\n            break;\n        }\n    }\n\n    return happy;\n}\n```"}
{"task_id": "SimdBench_101_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool is_happy_simd(const std::string & s) {\n    size_t len = s.length();\n    if (len < 3) return false;\n\n    size_t vlmax = vsetvlmax_e8m1();\n    bool happy = true;\n\n    for (size_t i = 0; i < len - 2 && happy; i += vlmax) {\n        size_t vl = vsetvl_e8m1(len - i);\n        vuint8m1_t vec = vle8_v_u8m1((const uint8_t*)(s.data() + i), vl);\n\n        vbool8_t mask1 = vmseq_vv_u8m1_b8(vec, vsll_vx_u8m1(vec, 1, vl), vl);\n        vbool8_t mask2 = vmseq_vv_u8m1_b8(vec, vsll_vx_u8m1(vec, 2, vl), vl);\n        vbool8_t mask3 = vmseq_vv_u8m1_b8(vsll_vx_u8m1(vec, 1, vl), vsll_vx_u8m1(vec, 2, vl), vl);\n\n        vbool8_t combined_mask = vmor_mm_b8(mask1, vmor_mm_b8(mask2, mask3, vl), vl);\n        happy = !vmreduce_any_true_b8(combined_mask, vl);\n    }\n\n    return happy;\n}\n```"}
{"task_id": "SimdBench_101_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool is_happy_simd(const std::string & s) {\n    size_t len = s.length();\n    if (len < 3) return false;\n\n    size_t vlmax = vsetvlmax_e8m1();\n    size_t vl;\n    bool happy = true;\n\n    for (size_t i = 0; i < len - 2 && happy; i += vl) {\n        vl = vsetvl_e8m1(len - i);\n\n        vuint8m1_t vec = vle8_v_u8m1((const uint8_t*)(s.data() + i), vl);\n        vuint8m1_t vec_next = vle8_v_u8m1((const uint8_t*)(s.data() + i + 1), vl - 1);\n        vuint8m1_t vec_next_next = vle8_v_u8m1((const uint8_t*)(s.data() + i + 2), vl - 2);\n\n        vbool8_t cmp1 = vmseq_vv_u8m1_b8(vec, vec_next);\n        vbool8_t cmp2 = vmseq_vv_u8m1_b8(vec, vec_next_next);\n        vbool8_t cmp3 = vmseq_vv_u8m1_b8(vec_next, vec_next_next);\n\n        vbool8_t result = vmor_mm_b8(cmp1, vmor_mm_b8(cmp2, cmp3));\n        happy = !vmreduce_any_true_b8(result, vl);\n    }\n\n    return happy;\n}\n```"}
{"task_id": "SimdBench_101_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool is_happy_simd(const std::string & s) {\n    size_t len = s.length();\n    if (len < 3) return false;\n\n    size_t vlmax = vsetvlmax_e8m1();\n    size_t vl;\n    bool happy = true;\n\n    for (size_t i = 0; i < len - 2 && happy; i += vl) {\n        vl = vsetvl_e8m1(len - i);\n        vuint8m1_t vec = vle8_v_u8m1((const uint8_t*)(s.data() + i), vl);\n\n        vbool8_t mask1 = vmseq_vv_u8m1_b8(vec, vsll_vx_u8m1(vec, 1, vl), vl);\n        vbool8_t mask2 = vmseq_vv_u8m1_b8(vec, vsll_vx_u8m1(vec, 2, vl), vl);\n        vbool8_t mask3 = vmseq_vv_u8m1_b8(vsll_vx_u8m1(vec, 1, vl), vsll_vx_u8m1(vec, 2, vl), vl);\n\n        vbool8_t combined_mask = vmor_mm_b8(mask1, vmor_mm_b8(mask2, mask3, vl), vl);\n        happy = !vmseq_vx_u8m1_b8(combined_mask, 1, vl);\n    }\n\n    return happy;\n}\n```"}
{"task_id": "SimdBench_101_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool is_happy_simd(const std::string & s) {\n    size_t len = s.length();\n    if (len < 3) return false;\n\n    size_t vlmax = vsetvlmax_e8m1();\n    bool happy = true;\n\n    for (size_t i = 0; i < len - 2 && happy; i += vlmax) {\n        size_t vl = vsetvl_e8m1(len - i);\n        vuint8m1_t vec = vle8_v_u8m1((const uint8_t*)(s.data() + i), vl);\n\n        vbool8_t mask1 = vmseq_vv_u8m1_b8(vec, vsll_vx_u8m1(vec, 1, vl), vl);\n        vbool8_t mask2 = vmseq_vv_u8m1_b8(vec, vsll_vx_u8m1(vec, 2, vl), vl);\n        vbool8_t mask3 = vmseq_vv_u8m1_b8(vsll_vx_u8m1(vec, 1, vl), vsll_vx_u8m1(vec, 2, vl), vl);\n\n        vbool8_t combined_mask = vmor_mm_b8(mask1, vmor_mm_b8(mask2, mask3, vl), vl);\n        happy = !vmreduce_any_true_b8(combined_mask, vl);\n    }\n\n    return happy;\n}\n```"}
{"task_id": "SimdBench_102_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool prime_length_simd(const std::string & str) {\n    size_t len = str.length();\n    if (len < 2) return false;\n\n    size_t sqrt_len = 1;\n    while ((sqrt_len + 1) * (sqrt_len + 1) <= len) sqrt_len++;\n\n    size_t vlmax = __riscv_vsetvlmax_e32m1();\n    bool is_prime = true;\n\n    for (size_t i = 2; i <= sqrt_len; i += vlmax) {\n        size_t vl = __riscv_vsetvl_e32m1(len - i);\n        vbool32_t mask = __riscv_vmseq_vx_i32m1(__riscv_vid_v_i32m1(vl), 0, vl);\n        vuint32m1_t vec_i = __riscv_vadd_vx_u32m1(__riscv_vid_v_u32m1(vl), i, vl);\n        vbool32_t div_mask = __riscv_vmseq_vx_u32m1(__riscv_vremu_vx_u32m1(vec_i, len, vl), 0, vl);\n\n        if (__riscv_vfirst_m_b32(div_mask, vl) != -1) {\n            is_prime = false;\n            break;\n        }\n    }\n\n    return is_prime;\n}\n```"}
{"task_id": "SimdBench_102_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool prime_length_simd(const std::string & str) {\n    size_t len = str.length();\n    if (len < 2) return false;\n\n    size_t vlmax = __riscv_vsetvlmax_e32m1();\n    size_t sqrt_len = 1;\n    while ((sqrt_len + 1) * (sqrt_len + 1) <= len) sqrt_len++;\n\n    bool is_prime = true;\n    size_t i = 2;\n\n    while (i <= sqrt_len) {\n        size_t j = i;\n        size_t stride = vlmax;\n\n        // Load vector of integers to check divisibility\n        vbool32_t mask = __riscv_vmseq_vx_i32m1(__riscv_vid_v_i32m1(vlmax), 0, vlmax);\n        vuint32m1_t vec = __riscv_vadd_vx_u32m1(__riscv_vid_v_u32m1(vlmax), i, vlmax);\n\n        // Check divisibility in parallel\n        while (j < i + vlmax && j <= sqrt_len) {\n            if (len % j == 0) {\n                is_prime = false;\n                break;\n            }\n            j++;\n        }\n\n        if (!is_prime) break;\n        i += vlmax;\n    }\n\n    return is_prime;\n}\n```"}
{"task_id": "SimdBench_102_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool prime_length_simd(const std::string & str) {\n    size_t len = str.length();\n    if (len < 2) return false;\n\n    size_t sqrt_len = 1;\n    while ((sqrt_len + 1) * (sqrt_len + 1) <= len) sqrt_len++;\n\n    size_t vlmax = __riscv_vsetvlmax_e8m1();\n    bool is_prime = true;\n\n    for (size_t i = 2; i <= sqrt_len && is_prime; i += vlmax) {\n        size_t vl = __riscv_vsetvl_e8m1(len - i);\n        vbool8_t mask = __riscv_vmseq_vx_i8m1(__riscv_vid_v_i8m1(vl), 0, vl);\n        vuint8m1_t vec = __riscv_vle8_v_u8m1(&str[i], vl);\n\n        vbool8_t div_mask = __riscv_vmseq_vx_u8m1(vec, 0, vl);\n        is_prime = !__riscv_vmsbf_m(mask, div_mask, vl);\n    }\n\n    return is_prime;\n}\n```"}
{"task_id": "SimdBench_102_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n\nbool prime_length_simd(const std::string & str) {\n    size_t len = str.length();\n    if (len < 2) return false;\n\n    size_t sqrt_len = static_cast<size_t>(std::sqrt(len));\n    bool is_prime = true;\n\n    size_t vlmax = __riscv_vsetvlmax_e8m1();\n    size_t vl;\n\n    for (size_t i = 2; i <= sqrt_len; i += vl) {\n        vl = __riscv_vsetvl_e8m1(sqrt_len - i + 1);\n\n        vbool8_t mask = __riscv_vmseq_vx_i8m1_b8(__riscv_vid_v_i8m1(vl), 0, vl);\n        vint8m1_t vec_i = __riscv_vadd_vx_i8m1(__riscv_vmv_v_x_i8m1(0, vl), i, vl);\n\n        vbool8_t div_mask = __riscv_vmseq_vx_i8m1_b8(__riscv_vmod_vx_i8m1(vec_i, len, vl), 0, vl);\n        is_prime = is_prime && !__riscv_vmask_b8(mask, div_mask, vl);\n\n        if (!is_prime) break;\n    }\n\n    return is_prime;\n}\n```"}
{"task_id": "SimdBench_102_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool prime_length_simd(const std::string & str) {\n    size_t len = str.length();\n    if (len < 2) return false;\n\n    size_t vlmax = __riscv_vsetvlmax_e32m1();\n    size_t sqrt_len = 1;\n    while ((sqrt_len + 1) * (sqrt_len + 1) <= len) sqrt_len++;\n\n    bool is_prime = true;\n    size_t i = 2;\n\n    while (i <= sqrt_len) {\n        size_t j = i;\n        size_t stride = vlmax;\n\n        // Process in chunks of vector length\n        while (j < i + vlmax && j <= sqrt_len) {\n            if (len % j == 0) {\n                is_prime = false;\n                break;\n            }\n            j++;\n        }\n\n        if (!is_prime) break;\n        i += vlmax;\n    }\n\n    return is_prime;\n}\n```"}
{"task_id": "SimdBench_103_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string solve_simd(uint64_t N) {\n    size_t vl;\n    uint64_t sum = 0;\n    uint64_t temp = N;\n\n    // Process digits in parallel using RVV intrinsics\n    while (temp > 0) {\n        vl = __riscv_vsetvl_e64m1(1); // Set vector length for 64-bit elements\n        vuint64m1_t vec_temp = __riscv_vle64_v_u64m1(&temp, vl); // Load value into vector register\n        vuint64m1_t vec_mod = __riscv_vand_vx_u64m1(vec_temp, 0xF, vl); // Extract last 4 bits (digit)\n        sum += __riscv_vmv_x_s_u64m1_u64(vec_mod); // Accumulate sum of digits\n        temp /= 10; // Remove the last digit\n    }\n\n    // Convert the sum to binary representation\n    std::string binary = \"\";\n    if (sum == 0) {\n        binary = \"0\";\n    } else {\n        while (sum > 0) {\n            binary = (sum % 2 == 0 ? \"0\" : \"1\") + binary;\n            sum /= 2;\n        }\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string solve_simd(uint64_t N) {\n    size_t vl;\n    uint64_t sum = 0;\n\n    // Convert the number to a string to process each digit\n    std::string num_str = std::to_string(N);\n    size_t len = num_str.length();\n\n    // Process digits in chunks using RVV intrinsics\n    for (size_t i = 0; i < len; i += vl) {\n        vl = vsetvl_e8m1(len - i);\n\n        // Load a vector of characters from the string\n        vuint8m1_t v_chars = vle8_v_u8m1((const uint8_t*)(num_str.c_str() + i), vl);\n\n        // Convert characters to integers by subtracting '0'\n        vuint8m1_t v_digits = vsub_vx_u8m1(v_chars, '0', vl);\n\n        // Sum the digits in the vector\n        sum += vmv_x_s_u8m1_u8(vredsum_vs_u8m1_u8m1(v_digits, v_digits, vl));\n    }\n\n    // Convert the sum to binary representation\n    std::string binary_sum;\n    do {\n        binary_sum.insert(0, 1, (sum % 2) + '0');\n        sum /= 2;\n    } while (sum > 0);\n\n    return binary_sum;\n}\n```"}
{"task_id": "SimdBench_103_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string solve_simd(uint64_t N) {\n    size_t vlmax = __riscv_vsetvlmax_e8m1();\n    uint8_t digits[20]; // Maximum 20 digits for a 64-bit integer\n    int digit_count = 0;\n    uint64_t temp = N;\n\n    // Extract digits into an array\n    while (temp > 0) {\n        digits[digit_count++] = temp % 10;\n        temp /= 10;\n    }\n\n    // Initialize vector registers\n    vuint8m1_t v_digits = __riscv_vle8_v_u8m1(digits, vlmax);\n    vuint8m1_t v_zero = __riscv_vmvsx_v_x_u8m1(0, vlmax);\n    vuint8m1_t v_sum_vec = __riscv_vmvsx_v_x_u8m1(0, vlmax);\n\n    // Compute sum of digits using RVV intrinsics\n    for (int i = 0; i < digit_count; i += vlmax) {\n        size_t vl = __riscv_vsetvl_e8m1(digit_count - i);\n        v_digits = __riscv_vle8_v_u8m1(digits + i, vl);\n        v_sum_vec = __riscv_vadd_vv_u8m1(v_sum_vec, v_digits, vl);\n    }\n\n    // Reduce the vector sum to a scalar\n    uint8_t sum_array[20] = {0};\n    __riscv_vse8_v_u8m1(sum_array, v_sum_vec, vlmax);\n    uint8_t total_sum = 0;\n    for (int i = 0; i < vlmax; ++i) {\n        total_sum += sum_array[i];\n    }\n\n    // Convert the sum to binary string\n    std::string binary_result;\n    while (total_sum > 0) {\n        binary_result = char('0' + (total_sum % 2)) + binary_result;\n        total_sum /= 2;\n    }\n    return binary_result.empty() ? \"0\" : binary_result;\n}\n```"}
{"task_id": "SimdBench_103_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string solve_simd(uint64_t N) {\n    uint64_t sum = 0;\n    size_t vl;\n\n    // Process the digits of N using RVV intrinsics\n    while (N > 0) {\n        // Load a vector of digits from N\n        vuint64m1_t vdigits = vmv_v_x_u64m1(0, vl); // Initialize vector with zeros\n        vl = vsetvl_e64m1(1); // Set vector length to 1 for scalar processing\n\n        // Extract digits and compute their sum in parallel\n        uint64_t temp = N;\n        while (temp > 0) {\n            uint64_t digit = temp % 10;\n            vdigits = vadd_vx_u64m1(vdigits, digit, vl);\n            temp /= 10;\n        }\n\n        // Reduce the vector sum to a scalar\n        sum += vmv_x_s_u64m1_u64(vdigits);\n\n        // Update N for the next iteration (if any)\n        N = temp;\n    }\n\n    // Convert the sum to binary representation\n    std::string binary = \"\";\n    if (sum == 0) {\n        binary = \"0\";\n    } else {\n        while (sum > 0) {\n            binary = char('0' + (sum % 2)) + binary;\n            sum /= 2;\n        }\n    }\n\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string solve_simd(uint64_t N) {\n    size_t vl;\n    uint64_t sum = 0;\n    uint64_t temp = N;\n\n    // Process digits in chunks using RVV intrinsics\n    while (temp > 0) {\n        vl = __riscv_vsetvl_e64m1(8); // Set vector length to 8 elements\n        vuint64m1_t vdigits = __riscv_vmv_v_x_u64m1(0, vl); // Initialize vector to zero\n\n        // Load up to 8 digits into the vector\n        for (size_t i = 0; i < vl && temp > 0; ++i) {\n            uint64_t digit = temp % 10;\n            temp /= 10;\n            vdigits = __riscv_vfadd_vf_u64m1(vdigits, digit, vl);\n        }\n\n        // Reduce the vector sum into a scalar\n        while (vl > 1) {\n            vl = __riscv_vsetvl_e64m1(vl / 2);\n            vuint64m1_t vsum = __riscv_vredsum_vs_u64m1_u64m1(vdigits, __riscv_vmv_v_x_u64m1(0, vl), vl);\n            vdigits = vsum;\n        }\n\n        // Add the reduced sum to the total sum\n        sum += __riscv_vmv_x_s_u64m1_u64(vdigits);\n    }\n\n    // Convert the sum to binary string\n    std::string binary = \"\";\n    if (sum == 0) {\n        binary = \"0\";\n    } else {\n        while (sum > 0) {\n            binary = (sum % 2 ? \"1\" : \"0\") + binary;\n            sum /= 2;\n        }\n    }\n\n    return binary;\n}\n```"}
{"task_id": "SimdBench_104_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint add_simd(std::vector<int> lst) {\n    int result = 0;\n    size_t vlmax = vsetvlmax_e32m8();\n    size_t len = lst.size();\n\n    for (size_t i = 1; i < len; i += 2) {\n        size_t vl = vsetvl_e32m8(len - i);\n        vint32m8_t vec = vle32_v_i32m8(&lst[i], vl);\n\n        // Create a mask for even numbers\n        vbool4_t mask = vmseq_vx_i32m8_b4(vec, 0, vl);\n\n        // Masked compress to get only even numbers\n        vint32m8_t even_vec = vcompress_vm_i32m8(mask, vec, vl);\n\n        // Horizontal sum of the even elements\n        while (vl > 1) {\n            vl = vsetvl_e32m8(vl / 2);\n            even_vec = vredsum_vs_i32m8_i32m8(even_vec, even_vec, vl);\n        }\n\n        // Extract the final sum from the vector\n        if (vl == 1) {\n            result += vmv_x_s_i32m8_i32(even_vec);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_104_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint add_simd(std::vector<int> lst) {\n    int result = 0;\n    size_t vlmax = vsetvlmax_e32m1();\n    size_t len = lst.size();\n    int *data = lst.data();\n\n    for (size_t i = 0; i < len; i += vlmax) {\n        size_t vl = vsetvl_e32m1(len - i);\n\n        // Load vector of elements from memory\n        vint32m1_t vec = vle32_v_i32m1(data + i, vl);\n\n        // Create a mask for odd indices\n        vbool32_t odd_index_mask = vmseq_vx_i32m1_b32(viota_v_u32m1(vl), i % 2 ? 0 : 1, vl);\n\n        // Apply the mask to filter elements at odd indices\n        vint32m1_t odd_index_vals = vmerge_vxm_i32m1(vec, 0, odd_index_mask, vl);\n\n        // Create a mask for even values\n        vbool32_t even_val_mask = vmseq_vx_i32m1_b32(vand_vx_i32m1(odd_index_vals, 1, vl), 0, vl);\n\n        // Apply the mask to filter even values\n        vint32m1_t even_vals_at_odd_indices = vmerge_vxm_i32m1(odd_index_vals, 0, even_val_mask, vl);\n\n        // Reduce the vector to get the sum of valid elements\n        result += vmv_x_s_i32m1_i32(vredsum_vs_i32m1_i32m1(even_vals_at_odd_indices, vundefined_i32m1(), vl));\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_104_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint add_simd(std::vector<int> lst) {\n    int result = 0;\n    size_t vlmax = vsetvlmax_e32m1();\n    size_t len = lst.size();\n\n    for (size_t i = 1; i < len; i += 2) {\n        size_t vl = vsetvl_e32m1(len - i);\n        vint32m1_t vec = vle32_v_i32m1(&lst[i], vl);\n\n        // Create a mask for even numbers\n        vbool32_t mask = vmseq_vx_i32m1(vec & 1, 0, vl);\n\n        // Masked compress to get only even numbers\n        vint32m1_t even_elements = vcompress_vm_i32m1(mask, vec, vl);\n\n        // Horizontal sum of the even elements\n        int sum = 0;\n        for (size_t j = 0; j < vl; ++j) {\n            sum += ((int*)&even_elements)[j];\n        }\n        result += sum;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_104_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint add_simd(std::vector<int> lst) {\n    int result = 0;\n    size_t vlmax = vsetvlmax_e32m8();\n    size_t len = lst.size();\n\n    for (size_t i = 1; i < len; i += 2) {\n        size_t vl = vsetvl_e32m8(len - i);\n        vint32m8_t vec = vle32_v_i32m8(&lst[i], vl);\n\n        // Create a mask for even numbers\n        vbool4_t mask = vmseq_vx_i32m8_b4(vec, 0, vl);\n\n        // Masked compress to select only even numbers\n        vint32m8_t even_elements = vcompress_vm_i32m8(mask, vec, vl);\n\n        // Horizontal sum of the selected elements\n        while (vl > 1) {\n            vl = vsetvl_e32m8(vl / 2);\n            even_elements = vredsum_vs_i32m8_i32m8(even_elements, even_elements, vl);\n        }\n\n        // Extract the final sum from the vector\n        if (vl > 0) {\n            result += vmv_x_s_i32m8_i32(even_elements);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_104_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint add_simd(std::vector<int> lst) {\n    int result = 0;\n    size_t vlmax = vsetvlmax_e32m8();\n    size_t n = lst.size();\n\n    for (size_t i = 1; i < n; i += vlmax * 2) {\n        size_t vl = vsetvl_e32m8(n - i);\n        vint32m8_t vec = vle32_v_i32m8(&lst[i], vl);\n\n        // Create a mask for odd indices\n        vbool4_t mask_odd_indices = vmfgt_vx_i32m8_b4(vec, 0, vl);\n\n        // Extract even elements using modulo operation\n        vbool4_t mask_even_elements = vmseq_vx_i32m8_b4(vrem_vx_i32m8(vec, 2, vl), 0, vl);\n\n        // Combine masks: select even elements at odd indices\n        vbool4_t combined_mask = vmand_mm_b4(mask_odd_indices, mask_even_elements, vl);\n\n        // Compress the vector to keep only selected elements\n        vint32m8_t selected_elements = vcompress_vm_i32m8(combined_mask, vec, vl);\n\n        // Reduce the selected elements to get their sum\n        while (vl > 1) {\n            vl = vsetvl_e32m8(vl / 2);\n            selected_elements = vredsum_vs_i32m8_i32m8(selected_elements, selected_elements, vl);\n        }\n\n        // Add the final reduced value to the result\n        if (vl == 1) {\n            result += vmv_x_s_i32m8_i32(selected_elements);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    size_t len = s.size();\n    std::string result(len, '\\0');\n    size_t vl;\n\n    for (size_t i = 0; i < len; i += vl) {\n        vl = vsetvl_e8m8(len - i);\n\n        vuint8m8_t vec = vle8_v_u8m8((const uint8_t*)(&s[i]), vl);\n        vbool8_t mask = vmseq_vx_u8m8(vec, 0, vl); // Mask for non-alphabetic characters\n\n        // Process lowercase letters\n        vbool8_t is_lower = vmslt_vx_u8m8(vec, 'a', vl);\n        vuint8m8_t lower_shifted = vadd_vx_u8m8(vec, 4, vl);\n        lower_shifted = vand_vx_u8m8(lower_shifted, ~is_lower, vl);\n\n        // Wrap around for lowercase letters beyond 'z'\n        vbool8_t wrap_lower = vmsge_vx_u8m8(lower_shifted, 'z' + 1, vl);\n        lower_shifted = vsub_vx_u8m8(lower_shifted, 26, vl);\n        lower_shifted = vor_vx_u8m8(lower_shifted, wrap_lower, vl);\n\n        // Process uppercase letters\n        vbool8_t is_upper = vmslt_vx_u8m8(vec, 'A', vl);\n        vuint8m8_t upper_shifted = vadd_vx_u8m8(vec, 4, vl);\n        upper_shifted = vand_vx_u8m8(upper_shifted, ~is_upper, vl);\n\n        // Wrap around for uppercase letters beyond 'Z'\n        vbool8_t wrap_upper = vmsge_vx_u8m8(upper_shifted, 'Z' + 1, vl);\n        upper_shifted = vsub_vx_u8m8(upper_shifted, 26, vl);\n        upper_shifted = vor_vx_u8m8(upper_shifted, wrap_upper, vl);\n\n        // Combine results\n        vuint8m8_t final_vec = vor_vv_u8m8(lower_shifted, upper_shifted, vl);\n        final_vec = vmerge_vvm_u8m8(mask, vec, final_vec, vl);\n\n        vse8_v_u8m8((uint8_t*)(&result[i]), final_vec, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    size_t len = s.size();\n    std::string result(len, '\\0');\n    size_t vl;\n\n    for (size_t i = 0; i < len; i += vl) {\n        vl = vsetvl_e8m1(len - i);\n\n        // Load characters into a vector register\n        vuint8m1_t vec_chars = vle8_v_u8m1((const uint8_t*)(&s[i]), vl);\n\n        // Convert characters to their alphabetical index (0-25 for 'a'-'z')\n        vuint8m1_t vec_alpha_idx = vsub_vx_u8m1(vec_chars, 'a', vl);\n\n        // Shift the alphabet index by 4 positions (2 * 2)\n        vuint8m1_t vec_shifted_idx = vadd_vx_u8m1(vec_alpha_idx, 4, vl);\n\n        // Wrap around using modulo 26\n        vec_shifted_idx = vmod_vx_u8m1(vec_shifted_idx, 26, vl);\n\n        // Convert back to character range ('a'-'z')\n        vuint8m1_t vec_encrypted_chars = vadd_vx_u8m1(vec_shifted_idx, 'a', vl);\n\n        // Store the encrypted characters back to the result string\n        vse8_v_u8m1((uint8_t*)(&result[i]), vec_encrypted_chars, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    size_t len = s.size();\n    std::string result(len, '\\0');\n    size_t vl;\n\n    for (size_t i = 0; i < len; i += vl) {\n        vl = vsetvl_e8m1(len - i);\n\n        // Load characters into a vector register\n        vuint8m1_t vec = vle8_v_u8m1((const uint8_t*)(s.data() + i), vl);\n\n        // Convert characters to their alphabetical index (0-25)\n        vuint8m1_t offset = vmv_v_x_u8m1('a', vl);\n        vuint8m1_t alpha_idx = vsub_vv_u8m1(vec, offset, vl);\n\n        // Apply the rotation: shift by 2 * 2 = 4 places\n        vuint8m1_t rotated_idx = vadd_vx_u8m1(alpha_idx, 4, vl);\n\n        // Wrap around using modulo 26\n        vuint8m1_t mod_base = vmv_v_x_u8m1(26, vl);\n        rotated_idx = vremu_vv_u8m1(rotated_idx, mod_base, vl);\n\n        // Convert back to ASCII characters\n        vuint8m1_t encrypted_char = vadd_vv_u8m1(rotated_idx, offset, vl);\n\n        // Store the result back into the output string\n        vse8_v_u8m1((uint8_t*)(result.data() + i), encrypted_char, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    size_t len = s.size();\n    std::string result(len, '\\0');\n    size_t vlmax = vsetvlmax_e8m1();\n\n    for (size_t i = 0; i < len; i += vlmax) {\n        size_t vl = vsetvl_e8m1(len - i);\n\n        // Load characters into vector register\n        vuint8m1_t vec_chars = vle8_v_u8m1((const uint8_t*)(&s[i]), vl);\n\n        // Convert to lowercase and check if it's an alphabet character\n        vbool8_t mask = vmseq_vx_u8m1(vec_chars, 0, vl); // Initialize mask\n        vuint8m1_t vec_lower = vadd_vx_u8m1(vec_chars, 32, vl);\n        mask = vmslt_vx_u8m1(vec_chars, 'A', vl);\n        mask = vmor_mm_b8(mask, vmslt_vx_u8m1(vec_chars, 'a', vl), vl);\n        vec_chars = vmerge_vvm_u8m1(mask, vec_chars, vec_lower, vl);\n\n        // Apply rotation: shift by 4 positions (2 * 2)\n        vuint8m1_t vec_rotated = vadd_vx_u8m1(vec_chars, 4, vl);\n\n        // Wrap around for letters beyond 'z' or 'Z'\n        vuint8m1_t vec_wrapped = vsub_vx_u8m1(vec_rotated, 26, vl);\n        mask = vmsge_vx_u8m1(vec_rotated, 'z', vl);\n        mask = vmor_mm_b8(mask, vmsge_vx_u8m1(vec_rotated, 'Z', vl), vl);\n        vec_rotated = vmerge_vvm_u8m1(mask, vec_wrapped, vec_rotated, vl);\n\n        // Store the result back to memory\n        vse8_v_u8m1((uint8_t*)(&result[i]), vec_rotated, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    size_t len = s.size();\n    std::string result(len, '\\0');\n    size_t vl;\n\n    for (size_t i = 0; i < len; i += vl) {\n        vl = vsetvl_e8m1(len - i);\n\n        // Load characters into a vector register\n        vuint8m1_t vec = vle8_v_u8m1((const uint8_t*)(&s[i]), vl);\n\n        // Convert characters to lowercase and check if they are alphabetic\n        vbool8_t mask = vmseq_vx_u8m1(vec, 0, vl); // Initialize mask\n        vuint8m1_t offset = vadd_vx_u8m1(vec, 4, vl); // Shift by 4 positions\n\n        // Wrap around for letters exceeding 'z'\n        vbool8_t wrap_mask = vmslt_vx_u8m1(offset, 'a', vl);\n        offset = vadd_vx_u8m1(offset, 26, vl); // Add 26 to wrap around\n        offset = vmerge_vxm_u8m1(offset, vec, wrap_mask, vl);\n\n        // Store the encrypted characters back to the result string\n        vse8_v_u8m1((uint8_t*)(&result[i]), offset, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string encode_simd(const std::string &message) {\n    size_t len = message.size();\n    std::string result(len, '\\0');\n    size_t vl;\n\n    // Define vowels and their replacements\n    const char vowels[] = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n    const char replacements[] = {'c', 'g', 'k', 'q', 'w', 'C', 'G', 'K', 'Q', 'W'};\n\n    for (size_t i = 0; i < len; i += vl) {\n        vl = vsetvl_e8m1(len - i);\n\n        // Load vector of characters\n        vuint8m1_t vec = vle8_v_u8m1((const uint8_t*)(message.data() + i), vl);\n\n        // Swap case using SIMD\n        vbool8_t is_lower = vmseq_vx_u8m1(vec, vec, vl);\n        vuint8m1_t swapped_case = vsub_vx_u8m1(vec, 32, vl);\n        swapped_case = vmerge_vvm_u8m1(is_lower, swapped_case, vec, vl);\n\n        // Replace vowels with their replacements\n        for (int j = 0; j < 10; ++j) {\n            vbool8_t is_vowel = vmseq_vx_u8m1(swapped_case, vowels[j], vl);\n            swapped_case = vmerge_vvm_u8m1(is_vowel, replacements[j], swapped_case, vl);\n        }\n\n        // Store the result back to memory\n        vse8_v_u8m1((uint8_t*)(result.data() + i), swapped_case, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string encode_simd(const std::string &message) {\n    size_t len = message.size();\n    std::string result(len, '\\0');\n\n    size_t vl;\n    size_t i = 0;\n\n    while (i < len) {\n        vl = vsetvl_e8m1(len - i);\n\n        // Load vector of characters\n        vuint8m1_t vec = vle8_v_u8m1((const uint8_t*)(message.data() + i), vl);\n\n        // Create masks for vowels and case swapping\n        vbool8_t is_lower = vmseq_vx_u8m1(vec, 'a', vl) |\n                            vmseq_vx_u8m1(vec, 'e', vl) |\n                            vmseq_vx_u8m1(vec, 'i', vl) |\n                            vmseq_vx_u8m1(vec, 'o', vl) |\n                            vmseq_vx_u8m1(vec, 'u', vl);\n\n        vbool8_t is_upper = vmseq_vx_u8m1(vec, 'A', vl) |\n                            vmseq_vx_u8m1(vec, 'E', vl) |\n                            vmseq_vx_u8m1(vec, 'I', vl) |\n                            vmseq_vx_u8m1(vec, 'O', vl) |\n                            vmseq_vx_u8m1(vec, 'U', vl);\n\n        // Replace vowels with letters two places ahead\n        vuint8m1_t replaced = vadd_vx_u8m1(vec, 2, vl);\n        vec = vmerge_vvm_u8m1(is_lower | is_upper, replaced, vec, vl);\n\n        // Swap case\n        vbool8_t is_alpha = vmslt_vx_u8m1(vec, 'a', vl) & vmslt_vx_u8m1(vec, 'z', vl) |\n                            vmslt_vx_u8m1(vec, 'A', vl) & vmslt_vx_u8m1(vec, 'Z', vl);\n\n        vuint8m1_t swapped = vsub_vx_u8m1(vec, 'a' - 'A', vl);\n        vec = vmerge_vvm_u8m1(is_alpha, swapped, vec, vl);\n\n        // Store the result back to memory\n        vse8_v_u8m1((uint8_t*)(result.data() + i), vec, vl);\n\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string encode_simd(const std::string &message) {\n    size_t len = message.size();\n    std::string result(len, '\\0');\n    size_t vl;\n\n    // Define vowels and their replacements\n    const char vowels[] = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n    const char replacements[] = {'c', 'g', 'k', 'q', 's', 'C', 'G', 'K', 'Q', 'S'};\n\n    for (size_t i = 0; i < len; i += vl) {\n        vl = vsetvl_e8m1(len - i);\n\n        // Load vector of characters from the input message\n        vuint8m1_t vec = vle8_v_u8m1((const uint8_t*)(message.data() + i), vl);\n\n        // Create a mask for letters\n        vbool8_t is_alpha_mask = vmseq_vx_u8m1(vec, 0, vl); // Placeholder for alpha check\n\n        // Swap case: Check if lowercase or uppercase and toggle case\n        vuint8m1_t lower_mask = vmseq_vx_u8m1(vec, 0, vl); // Placeholder for lowercase check\n        vuint8m1_t upper_mask = vmseq_vx_u8m1(vec, 0, vl); // Placeholder for uppercase check\n        vuint8m1_t swapped_case = vadd_vx_u8m1(vec, 0, vl); // Placeholder for case swap logic\n\n        // Replace vowels with their replacements\n        for (int j = 0; j < 10; ++j) {\n            vbool8_t is_vowel_mask = vmseq_vx_u8m1(vec, vowels[j], vl);\n            swapped_case = vmerge_vvm_u8m1(is_vowel_mask, replacements[j], swapped_case, vl);\n        }\n\n        // Store the result back into the output string\n        vse8_v_u8m1((uint8_t*)(result.data() + i), swapped_case, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string encode_simd(const std::string &message) {\n    size_t len = message.size();\n    std::string result(len, '\\0');\n    size_t vl;\n\n    // Define vowels and their replacements\n    const char vowels[] = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n    const char replacements[] = {'c', 'g', 'k', 'q', 's', 'C', 'G', 'K', 'Q', 'S'};\n\n    for (size_t i = 0; i < len; i += vl) {\n        vl = vsetvl_e8m1(len - i);\n\n        // Load vector of characters\n        vuint8m1_t vec = vle8_v_u8m1((const uint8_t*)(message.data() + i), vl);\n\n        // Create mask for case swapping\n        vbool8_t is_lower = vmseq_vx_u8m1(vec, 0, vl); // Placeholder for actual logic\n        vbool8_t is_upper = vmseq_vx_u8m1(vec, 0, vl); // Placeholder for actual logic\n\n        // Swap case\n        vuint8m1_t swapped_case = vadd_vx_u8m1(vec, is_lower ? -32 : 32, vl);\n\n        // Replace vowels\n        for (int j = 0; j < 10; ++j) {\n            vbool8_t is_vowel = vmseq_vx_u8m1(vec, vowels[j], vl);\n            swapped_case = vmerge_vvm_u8m1(is_vowel, replacements[j], swapped_case, vl);\n        }\n\n        // Store result back to memory\n        vse8_v_u8m1((uint8_t*)(result.data() + i), swapped_case, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string encode_simd(const std::string &message) {\n    size_t len = message.size();\n    std::string result(len, '\\0');\n\n    size_t vl;\n    size_t i = 0;\n\n    while (i < len) {\n        vl = vsetvl_e8m1(len - i);\n\n        // Load vector of characters\n        vuint8m1_t vec = vle8_v_u8m1((const uint8_t*)(message.data() + i), vl);\n\n        // Create masks for vowels and case swapping\n        vbool8_t is_lower = vmseq_vx_u8m1(vec, 'a', vl) |\n                            vmseq_vx_u8m1(vec, 'e', vl) |\n                            vmseq_vx_u8m1(vec, 'i', vl) |\n                            vmseq_vx_u8m1(vec, 'o', vl) |\n                            vmseq_vx_u8m1(vec, 'u', vl);\n\n        vbool8_t is_upper = vmseq_vx_u8m1(vec, 'A', vl) |\n                            vmseq_vx_u8m1(vec, 'E', vl) |\n                            vmseq_vx_u8m1(vec, 'I', vl) |\n                            vmseq_vx_u8m1(vec, 'O', vl) |\n                            vmseq_vx_u8m1(vec, 'U', vl);\n\n        // Replace vowels with letters 2 places ahead\n        vuint8m1_t replaced = vadd_vx_u8m1(vec, 2, vl);\n        vec = vmerge_vvm_u8m1(is_lower | is_upper, replaced, vec, vl);\n\n        // Swap case\n        vbool8_t is_alpha = vmslt_vx_u8m1(vec, 'a', vl) & vmslt_vx_u8m1(vec, 'z', vl) |\n                            vmslt_vx_u8m1(vec, 'A', vl) & vmslt_vx_u8m1(vec, 'Z', vl);\n\n        vuint8m1_t swapped = vsub_vx_u8m1(vec, 'a' - 'A', vl);\n        swapped = vadd_vx_u8m1(swapped, 'A' - 'a', vl);\n        vec = vmerge_vvm_u8m1(is_alpha, swapped, vec, vl);\n\n        // Store the result back\n        vse8_v_u8m1((uint8_t*)(result.data() + i), vec, vl);\n\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_107_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    size_t total_keys = dict.size();\n    size_t vlmax = __riscv_vsetvlmax_e8m1();\n    bool all_lower = true, all_upper = true;\n\n    // Extract keys from the map\n    std::vector<std::string> keys;\n    for (const auto& pair : dict) {\n        keys.push_back(pair.first);\n    }\n\n    // Process keys in chunks using RVV intrinsics\n    for (size_t i = 0; i < total_keys; i += vlmax) {\n        size_t vl = __riscv_vsetvl_e8m1(total_keys - i);\n\n        // Load characters from keys into vector registers\n        unsigned char key_chars[vlmax];\n        for (size_t j = 0; j < vl; ++j) {\n            key_chars[j] = keys[i + j][0]; // Assuming first character determines case\n        }\n\n        // Vectorized islower and isupper checks\n        vuint8m1_t vec_chars = __riscv_vle8_v_u8m1(key_chars, vl);\n        vbool8_t vec_islower = __riscv_vmseq_vx_u8m1_b8(vec_chars, std::tolower(vec_chars), vl);\n        vbool8_t vec_isupper = __riscv_vmseq_vx_u8m1_b8(vec_chars, std::toupper(vec_chars), vl);\n\n        // Reduce results to scalar booleans\n        all_lower &= __riscv_vmandn_mm_b8(__riscv_vmnot_m_b8(vec_islower, vl), vl);\n        all_upper &= __riscv_vmandn_mm_b8(__riscv_vmnot_m_b8(vec_isupper, vl), vl);\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    size_t total_keys = dict.size();\n    size_t vlmax = __riscv_vsetvlmax_e8m1();\n    bool all_lower = true, all_upper = true;\n\n    // Temporary buffer to hold key characters for SIMD processing\n    unsigned char key_buffer[vlmax];\n    size_t buffer_size = 0;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n\n        for (char c : key) {\n            key_buffer[buffer_size++] = static_cast<unsigned char>(c);\n\n            if (buffer_size == vlmax || (&c == &key.back() && &pair == &(*dict.rbegin()))) {\n                size_t vl = __riscv_vsetvl_e8m1(buffer_size);\n\n                // Load characters into a vector register\n                vuint8m1_t vec_chars = __riscv_vle8_v_u8m1(key_buffer, vl);\n\n                // Check for lowercase characters\n                vbool8_t is_lower = __riscv_vmseq_vx_u8m1_b8(vec_chars, 0, vl);\n                all_lower &= __riscv_vmandn_mm(is_lower, is_lower, vl);\n\n                // Check for uppercase characters\n                vbool8_t is_upper = __riscv_vmseq_vx_u8m1_b8(vec_chars, 0, vl);\n                all_upper &= __riscv_vmandn_mm(is_upper, is_upper, vl);\n\n                buffer_size = 0; // Reset buffer for next batch\n            }\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    size_t total_keys = dict.size();\n    size_t vlmax = vsetvlmax_e8m1();\n    size_t vl = 0;\n\n    // Allocate buffers for SIMD processing\n    unsigned char *keys_buffer = new unsigned char[total_keys * 256];\n    bool *is_lower_buffer = new bool[total_keys];\n    bool *is_upper_buffer = new bool[total_keys];\n\n    size_t idx = 0;\n    for (const auto &pair : dict) {\n        const std::string &key = pair.first;\n        if (key.empty()) {\n            delete[] keys_buffer;\n            delete[] is_lower_buffer;\n            delete[] is_upper_buffer;\n            return false;\n        }\n        keys_buffer[idx++] = key[0];\n    }\n\n    bool all_lower = true, all_upper = true;\n    for (size_t i = 0; i < total_keys; i += vl) {\n        vl = vsetvl_e8m1(total_keys - i);\n\n        // Load the first character of each key into a vector register\n        vuint8m1_t keys = vle8_v_u8m1(&keys_buffer[i], vl);\n\n        // Check if characters are lowercase\n        vbool8_t is_lower = vmseq_vx_u8m1(keys, tolower(keys), vl);\n        vbool8_t all_lower_vec = vmv_s_x_b8(vl, true);\n        all_lower_vec = vmand_vv_b8(all_lower_vec, is_lower, vl);\n\n        // Check if characters are uppercase\n        vbool8_t is_upper = vmseq_vx_u8m1(keys, toupper(keys), vl);\n        vbool8_t all_upper_vec = vmv_s_x_b8(vl, true);\n        all_upper_vec = vmand_vv_b8(all_upper_vec, is_upper, vl);\n\n        // Reduce results\n        all_lower &= vcpop_m_b8(all_lower_vec, vl) == vl;\n        all_upper &= vcpop_m_b8(all_upper_vec, vl) == vl;\n    }\n\n    delete[] keys_buffer;\n    delete[] is_lower_buffer;\n    delete[] is_upper_buffer;\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    size_t total_keys = dict.size();\n    size_t vlmax = __riscv_vsetvlmax_e8m1();\n    size_t vl = __riscv_vsetvl_e8m1(total_keys);\n\n    unsigned char *keys_buffer = new unsigned char[total_keys];\n    size_t idx = 0;\n\n    for (const auto &pair : dict) {\n        keys_buffer[idx++] = pair.first[0];\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (size_t i = 0; i < total_keys; i += vl) {\n        vl = __riscv_vsetvl_e8m1(total_keys - i);\n        vuint8m1_t vec = __riscv_vle8_v_u8m1(&keys_buffer[i], vl);\n\n        vbool8_t is_lower = __riscv_vmseq_vx_u8m1_b8(vec, 'a', vl);\n        vbool8_t is_upper = __riscv_vmseq_vx_u8m1_b8(vec, 'A', vl);\n\n        all_lower &= __riscv_vmandn_mm(is_lower, is_lower, vl);\n        all_upper &= __riscv_vmandn_mm(is_upper, is_upper, vl);\n    }\n\n    delete[] keys_buffer;\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    size_t total_keys = dict.size();\n    size_t vlmax = __riscv_vsetvlmax_e8m1();\n    bool all_lower = true, all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        size_t len = key.length();\n\n        for (size_t i = 0; i < len; i += vlmax) {\n            size_t vl = __riscv_vsetvl_e8m1(len - i);\n\n            // Load characters into vector register\n            vuint8m1_t vec_chars = __riscv_vle8_v_u8m1(reinterpret_cast<const uint8_t*>(&key[i]), vl);\n\n            // Check if characters are lowercase\n            vbool8_t is_lower = __riscv_vmseq_vx_u8m1_b8(vec_chars, 0, vl);\n            all_lower &= __riscv_vmandn_mm_b8(is_lower, is_lower, vl);\n\n            // Check if characters are uppercase\n            vbool8_t is_upper = __riscv_vmseq_vx_u8m1_b8(vec_chars, 0, vl);\n            all_upper &= __riscv_vmandn_mm_b8(is_upper, is_upper, vl);\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_108_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n\n    size_t vlmax = __riscv_vsetvlmax_e32m1();\n    int *is_prime = (int *)malloc(n * sizeof(int));\n    int *indices = (int *)malloc(n * sizeof(int));\n\n    // Initialize is_prime array to 1 (true)\n    for (int i = 0; i < n; ++i) {\n        is_prime[i] = 1;\n    }\n    is_prime[0] = is_prime[1] = 0;\n\n    // Sieve of Eratosthenes using RVV\n    for (int p = 2; p * p < n; ++p) {\n        if (is_prime[p]) {\n            size_t vl;\n            for (int multiple = p * p; multiple < n; multiple += p) {\n                vl = __riscv_vsetvl_e32m1(n - multiple);\n                vbool32_t mask = __riscv_vmseq_vx_i32m1(__riscv_vle32_v_i32m1(&is_prime[multiple], vl), 1, vl);\n                __riscv_vse32_v_i32m1(&is_prime[multiple], __riscv_vmerge_vxm_i32m1(mask, 0, __riscv_vle32_v_i32m1(&is_prime[multiple], vl), vl), vl);\n            }\n        }\n    }\n\n    // Collect prime numbers\n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    free(is_prime);\n    free(indices);\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n\n    size_t vlmax = __riscv_vsetvlmax_e32m1();\n    int *is_prime = new int[n];\n    for (int i = 0; i < n; ++i) is_prime[i] = 1;\n    is_prime[0] = is_prime[1] = 0;\n\n    for (int p = 2; p * p < n; ++p) {\n        if (is_prime[p]) {\n            for (int multiple = p * p; multiple < n; multiple += p) {\n                size_t vl = __riscv_vsetvl_e32m1(n - multiple);\n                vbool32_t mask = __riscv_vmseq_vx_i32m1(__riscv_vle32_v_i32m1(&is_prime[multiple], vl), 1, vl);\n                __riscv_vse32_v_i32m1(&is_prime[multiple], __riscv_vmv_v_x_i32m1(0, vl), vl);\n            }\n        }\n    }\n\n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) primes.push_back(i);\n    }\n\n    delete[] is_prime;\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n\n    size_t vlmax = __riscv_vsetvlmax_e32m1();\n    int *is_prime = new int[n];\n    for (int i = 0; i < n; ++i) is_prime[i] = 1;\n    is_prime[0] = is_prime[1] = 0;\n\n    for (int p = 2; p * p < n; ++p) {\n        if (is_prime[p]) {\n            for (int multiple = p * p; multiple < n; multiple += p) {\n                is_prime[multiple] = 0;\n            }\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        if (is_prime[i]) primes.push_back(i);\n    }\n\n    delete[] is_prime;\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n\n    size_t vlmax = vsetvlmax_e32m1();\n    int *is_prime = new int[n];\n    for (int i = 0; i < n; ++i) is_prime[i] = 1;\n    is_prime[0] = is_prime[1] = 0;\n\n    for (int p = 2; p * p < n; ++p) {\n        if (is_prime[p]) {\n            for (int multiple = p * p; multiple < n; multiple += p) {\n                is_prime[multiple] = 0;\n            }\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        if (is_prime[i]) primes.push_back(i);\n    }\n\n    delete[] is_prime;\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n\n    size_t vlmax = __riscv_vsetvlmax_e32m1();\n    int *is_prime = new int[n];\n    for (int i = 0; i < n; ++i) is_prime[i] = 1;\n    is_prime[0] = is_prime[1] = 0;\n\n    for (int p = 2; p * p < n; ++p) {\n        if (is_prime[p]) {\n            for (int multiple = p * p; multiple < n; multiple += p) {\n                is_prime[multiple] = 0;\n            }\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        if (is_prime[i]) primes.push_back(i);\n    }\n\n    delete[] is_prime;\n    return primes;\n}\n```"}
{"task_id": "SimdBench_109_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint count_upper_simd(const std::string & s) {\n    size_t len = s.size();\n    int result = 0;\n    size_t i = 0;\n\n    // Process the string in chunks using RVV intrinsics\n    while (i + vsetvlmax_e8m1() <= len) {\n        size_t vl = vsetvl_e8m1(len - i);\n\n        // Load a vector of characters from the string\n        vuint8m1_t vec_chars = vle8_v_u8m1((const uint8_t*)(s.data() + i), vl);\n\n        // Create a mask for even indices\n        vbool8_t even_mask = vmseq.vx_i8mf8(viota_m8(), 0, vl);\n\n        // Apply the even index mask to filter characters at even positions\n        vuint8m1_t even_chars = vmerge_vvm_u8m1(even_mask, vec_chars, vmv_v_x_u8m1(0, vl), vl);\n\n        // Create a mask for uppercase vowels ('A', 'E', 'I', 'O', 'U')\n        vbool8_t vowel_mask_A = vmseq.vx_u8m1(even_chars, 'A', vl);\n        vbool8_t vowel_mask_E = vmseq.vx_u8m1(even_chars, 'E', vl);\n        vbool8_t vowel_mask_I = vmseq.vx_u8m1(even_chars, 'I', vl);\n        vbool8_t vowel_mask_O = vmseq.vx_u8m1(even_chars, 'O', vl);\n        vbool8_t vowel_mask_U = vmseq.vx_u8m1(even_chars, 'U', vl);\n\n        // Combine all vowel masks\n        vbool8_t combined_vowel_mask = vmor_mm(vowel_mask_A, vowel_mask_E, vl);\n        combined_vowel_mask = vmor_mm(combined_vowel_mask, vowel_mask_I, vl);\n        combined_vowel_mask = vmor_mm(combined_vowel_mask, vowel_mask_O, vl);\n        combined_vowel_mask = vmor_mm(combined_vowel_mask, vowel_mask_U, vl);\n\n        // Count the number of true values in the combined vowel mask\n        result += vcpop_m8(combined_vowel_mask, vl);\n\n        // Move to the next chunk\n        i += vl;\n    }\n\n    // Handle remaining elements (if any)\n    for (; i < len; i += 2) {\n        char c = s[i];\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            result++;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_109_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint count_upper_simd(const std::string & s) {\n    size_t len = s.size();\n    int result = 0;\n    size_t i = 0;\n\n    // Process the string in chunks using RVV intrinsics\n    for (; i + vsetvlmax_e8m1() <= len; i += vsetvlmax_e8m1()) {\n        size_t vl = vsetvl_e8m1(len - i);\n\n        // Load a vector of characters from the string\n        vuint8m1_t vec = vle8_v_u8m1((const uint8_t*)(s.data() + i), vl);\n\n        // Create a mask for even indices\n        vbool8_t even_mask = vmseq_vx_i8m1(viota_v_u8m1(vl), 0, vl);\n\n        // Apply the even index mask\n        vuint8m1_t even_chars = vcompress_vm_u8m1(even_mask, vec, vl);\n\n        // Create a mask for uppercase vowels (A, E, I, O, U)\n        vbool8_t vowel_mask = vmfne_vx_u8m1(vec, 'A', vl);\n        vowel_mask = vmfne_vx_u8m1(vec, 'E', vl);\n        vowel_mask = vmfne_vx_u8m1(vec, 'I', vl);\n        vowel_mask = vmfne_vx_u8m1(vec, 'O', vl);\n        vowel_mask = vmfne_vx_u8m1(vec, 'U', vl);\n\n        // Combine masks for even indices and uppercase vowels\n        vbool8_t combined_mask = vmand_mm_b8(even_mask, vowel_mask);\n\n        // Count the number of true values in the combined mask\n        result += vcpop_m_b8(combined_mask, vl);\n    }\n\n    // Process any remaining characters that didn't fit in a full vector\n    for (; i < len; ++i) {\n        if (i % 2 == 0 && (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            ++result;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_109_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint count_upper_simd(const std::string & s) {\n    size_t len = s.size();\n    int result = 0;\n    size_t i = 0;\n\n    // Process the string in chunks using RVV intrinsics\n    for (; i + vsetvlmax_e8m1() <= len; i += vsetvlmax_e8m1()) {\n        size_t vl = vsetvl_e8m1(len - i);\n\n        // Load a vector of characters from the string\n        vuint8m1_t vec = vle8_v_u8m1((const uint8_t*)(s.data() + i), vl);\n\n        // Create a mask for even indices\n        vbool8_t even_mask = vmseq.vx_i8mf8(viota_v_u8mf8(vl, vl), 0, vl);\n\n        // Apply the even index mask\n        vuint8m1_t even_chars = vcompress_vm_u8m1(even_mask, vec, vl);\n\n        // Create a mask for uppercase vowels (A, E, I, O, U)\n        vbool8_t vowel_mask = vmfne_vx_u8m1(even_chars, 'A', vl);\n        vowel_mask = vmfne_vx_u8m1(even_chars, 'E', vl);\n        vowel_mask = vmfne_vx_u8m1(even_chars, 'I', vl);\n        vowel_mask = vmfne_vx_u8m1(even_chars, 'O', vl);\n        vowel_mask = vmfne_vx_u8m1(even_chars, 'U', vl);\n\n        // Count the number of true values in the vowel mask\n        result += vcpop_m_b8(vl, vowel_mask);\n    }\n\n    // Process any remaining characters\n    for (; i < len; ++i) {\n        if (i % 2 == 0 && (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            ++result;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_109_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint count_upper_simd(const std::string & s) {\n    size_t len = s.size();\n    int result = 0;\n    size_t i = 0;\n\n    // Process the string in chunks using RVV intrinsics\n    for (; i + vsetvlmax_e8m1() <= len; i += vsetvlmax_e8m1()) {\n        size_t vl = vsetvl_e8m1(len - i);\n\n        // Load a vector of characters from the string\n        vuint8m1_t vec = vle8_v_u8m1((const uint8_t*)(s.data() + i), vl);\n\n        // Create a mask for uppercase vowels ('A', 'E', 'I', 'O', 'U')\n        vbool8_t is_A = vmseq_vx_u8m1_b8(vec, 'A', vl);\n        vbool8_t is_E = vmseq_vx_u8m1_b8(vec, 'E', vl);\n        vbool8_t is_I = vmseq_vx_u8m1_b8(vec, 'I', vl);\n        vbool8_t is_O = vmseq_vx_u8m1_b8(vec, 'O', vl);\n        vbool8_t is_U = vmseq_vx_u8m1_b8(vec, 'U', vl);\n        vbool8_t is_vowel = vor_vv_u8m1_b8(is_A, is_E, vl);\n        is_vowel = vor_vv_u8m1_b8(is_vowel, is_I, vl);\n        is_vowel = vor_vv_u8m1_b8(is_vowel, is_O, vl);\n        is_vowel = vor_vv_u8m1_b8(is_vowel, is_U, vl);\n\n        // Create a mask for even indices\n        vbool8_t is_even = vmseq_vx_u8m1_b8(vid_v_u8m1(vl), 0, vl); // Placeholder for even index logic\n\n        // Combine masks: character must be an uppercase vowel AND at an even index\n        vbool8_t mask = vand_vv_u8m1_b8(is_vowel, is_even, vl);\n\n        // Count the number of true values in the mask\n        result += vcpop_m_b8(mask, vl);\n    }\n\n    // Process any remaining characters (not aligned to vector length)\n    for (; i < len; ++i) {\n        if (i % 2 == 0 && (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            ++result;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_109_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint count_upper_simd(const std::string & s) {\n    size_t len = s.size();\n    int result = 0;\n    size_t vlmax = vsetvlmax_e8m1();\n\n    for (size_t i = 0; i < len; i += vlmax) {\n        size_t vl = vsetvl_e8m1(len - i);\n\n        // Load characters from the string into a vector register\n        vuint8m1_t vec_chars = vle8_v_u8m1((const uint8_t*)(s.data() + i), vl);\n\n        // Create a mask for even indices\n        vbool8_t even_indices_mask = vmseq_vx_i8m1(viota_v_u8m1(vl), 0, vl);\n\n        // Apply the even indices mask to filter out odd indices\n        vec_chars = vcompress_vm_m(vec_chars, even_indices_mask, vl);\n\n        // Check if characters are uppercase vowels ('A', 'E', 'I', 'O', 'U')\n        vbool8_t is_A = vmseq_vx_u8m1(vec_chars, 'A', vl);\n        vbool8_t is_E = vmseq_vx_u8m1(vec_chars, 'E', vl);\n        vbool8_t is_I = vmseq_vx_u8m1(vec_chars, 'I', vl);\n        vbool8_t is_O = vmseq_vx_u8m1(vec_chars, 'O', vl);\n        vbool8_t is_U = vmseq_vx_u8m1(vec_chars, 'U', vl);\n\n        // Combine all conditions\n        vbool8_t is_upper_vowel = vor_vv_i8m1(\n            vor_vv_i8m1(\n                vor_vv_i8m1(is_A, is_E, vl),\n                vor_vv_i8m1(is_I, is_O, vl), vl),\n            is_U, vl);\n\n        // Count the number of true values in the mask\n        result += vcpop_m_b8(vlm_v_b8(is_upper_vowel, vl), vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    int vlmax = __riscv_vsetvlmax_e32m1();\n    size_t vl;\n\n    // Initialize the first level\n    int current = n;\n    result[0] = current;\n\n    // Process the rest of the levels using RVV intrinsics\n    for (int i = 1; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m1(n - i);\n\n        // Load the previous level values into a vector\n        vint32m1_t prev_level = __riscv_vle32_v_i32m1(result.data() + i - 1, vl);\n\n        // Compute the next level values\n        vbool32_t is_odd = __riscv_vmseq_vx_i32m1_b32(prev_level, 1, vl);\n        vint32m1_t increment = __riscv_vadd_vx_i32m1(__riscv_vand_vx_i32m1(is_odd, 1, vl), 1, vl);\n        vint32m1_t next_level = __riscv_vadd_vv_i32m1(prev_level, increment, vl);\n\n        // Store the computed values back to the result vector\n        __riscv_vse32_v_i32m1(result.data() + i, next_level, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    int vlmax = __riscv_vsetvlmax_e32m1();\n    size_t vl;\n\n    // Initialize the first level\n    int current_stones = n;\n    result[0] = current_stones;\n\n    // Process the rest of the levels using RVV intrinsics\n    for (int i = 1; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m1(n - i);\n\n        // Load the previous level's stones into a vector\n        vint32m1_t prev_stones = __riscv_vle32_v_i32m1(&result[i - 1], vl);\n\n        // Compute the next number of stones\n        vbool32_t is_odd = __riscv_vmseq_vx_i32m1_b32(prev_stones, 1, vl); // Check oddness\n        vint32m1_t increment = __riscv_vadd_vx_i32m1(__riscv_vand_vx_i32m1(is_odd, 1, vl), 1, vl);\n        vint32m1_t next_stones = __riscv_vadd_vv_i32m1(prev_stones, increment, vl);\n\n        // Store the result back to memory\n        __riscv_vse32_v_i32m1(&result[i], next_stones, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    int vlmax = __riscv_vsetvlmax_e32m1();\n    size_t vl;\n\n    // Initialize the first level\n    int current = n;\n    result[0] = current;\n\n    // Process the rest of the levels using RVV intrinsics\n    for (int i = 1; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m1(n - i);\n\n        // Load the previous level values into a vector\n        vint32m1_t prev_level = __riscv_vle32_v_i32m1(&result[i - 1], vl);\n\n        // Compute the next level values\n        vbool32_t is_odd = __riscv_vmseq_vx_i32m1_b32(prev_level, 1, vl);\n        vint32m1_t increment = __riscv_vadd_vx_i32m1(prev_level, 1, vl);\n        vint32m1_t next_level = __riscv_vadd_vx_i32m1(increment, 1, vl);\n\n        // Store the computed values back to the result vector\n        __riscv_vse32_v_i32m1(&result[i], next_level, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    int vlmax = __riscv_vsetvlmax_e32m1();\n    size_t vl;\n\n    // Initialize the first level\n    int current_stones = n;\n    result[0] = current_stones;\n\n    // Process the rest of the levels using RVV intrinsics\n    for (int i = 1; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m1(n - i);\n\n        // Load the previous level's stones into a vector\n        vint32m1_t prev_stones = __riscv_vle32_v_i32m1(result.data() + i - 1, vl);\n\n        // Compute the next number of stones based on odd/even condition\n        vbool32_t is_odd = __riscv_vmseq_vx_i32m1_b32(prev_stones, 1, vl);\n        vint32m1_t increment = __riscv_vadd_vx_i32m1(__riscv_vand_vx_i32m1(is_odd, 1, vl), 1, vl);\n        vint32m1_t next_stones = __riscv_vadd_vv_i32m1(prev_stones, increment, vl);\n\n        // Store the result back to the vector\n        __riscv_vse32_v_i32m1(result.data() + i, next_stones, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    int vlmax = __riscv_vsetvlmax_e32m1();\n    size_t vl;\n\n    // Initialize the first level\n    int current = n;\n    result[0] = current;\n\n    // Process the rest of the levels using RVV intrinsics\n    for (int i = 1; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m1(n - i);\n\n        // Load the previous level values into a vector\n        vint32m1_t prev_level = __riscv_vle32_v_i32m1(result.data() + i - 1, vl);\n\n        // Compute the next level values\n        vbool32_t is_odd = __riscv_vmseq_vx_i32m1_b32(prev_level, 1, vl);\n        vint32m1_t increment = __riscv_vadd_vx_i32m1(__riscv_vand_vx_i32m1(is_odd, 1, vl), 2, vl);\n        vint32m1_t next_level = __riscv_vadd_vv_i32m1(prev_level, increment, vl);\n\n        // Store the computed values back to the result vector\n        __riscv_vse32_v_i32m1(result.data() + i, next_level, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_111_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n\n    size_t vlmax = __riscv_vsetvlmax_e64m1();\n    int64_t sum = 0;\n    int64_t count = 0;\n\n    for (int64_t i = n; i <= m;) {\n        size_t vl = __riscv_vsetvl_e64m1(m - i + 1);\n        vint64m1_t vec = __riscv_vid_v_i64m1(vl);\n        vec = __riscv_vadd_vx_i64m1(vec, i, vl);\n\n        vint64m1_t ones = __riscv_vmv_v_x_i64m1(1, vl);\n        sum += __riscv_vredsum_vs_i64m1_i64m1(vec, sum, ones, vl);\n        count += vl;\n\n        i += vl;\n    }\n\n    int64_t avg = sum / count;\n    if (avg < 0) {\n        return \"-1\";\n    }\n\n    std::string binary = \"\";\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_111_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n\n    size_t vlmax = vsetvlmax_e64m8();\n    int64_t sum = 0;\n    int64_t count = 0;\n\n    for (int64_t i = n; i <= m; i += vlmax) {\n        size_t vl = vsetvl_e64m8(m - i + 1);\n        vint64m8_t vec = vid_v_i64m8(vl);\n        vint64m8_t offset = vmv_v_x_i64m8(i, vl);\n        vec = vadd_vv_i64m8(vec, offset, vl);\n\n        // Horizontal sum of the vector elements\n        vint64m1_t sum_vec = vmv_v_x_i64m1(0, vl);\n        sum_vec = vfredsum_vs_i64m8_i64m1(sum_vec, vec, sum_vec, vl);\n        sum += vmv_x_s_i64m1_i64(sum_vec);\n\n        count += vl;\n    }\n\n    int64_t avg = sum / count;\n    if (avg < 0) {\n        return \"-1\";\n    }\n\n    std::string binary = \"\";\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_111_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n\n    size_t vlmax = vsetvlmax_e64m8();\n    int64_t sum = 0;\n    int64_t count = 0;\n\n    for (int64_t i = n; i <= m; i += vlmax) {\n        size_t vl = vsetvl_e64m8(m - i + 1);\n        vint64m8_t vec = vid_v_i64m8(vl);\n        vec = vadd_vx_i64m8(vec, i, vl);\n        vint64m8_t ones = vmv_v_x_i64m8(1, vl);\n        sum += vredsum_vs_i64m8_i64m1(vec, vmv_v_x_i64m1(0), vl);\n        count += vredsum_vs_i64m8_i64m1(ones, vmv_v_x_i64m1(0), vl);\n    }\n\n    int64_t avg = sum / count;\n    if (avg < 0) return \"-1\";\n\n    std::string binary = \"\";\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_111_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n\n    size_t vlmax = vsetvlmax_e64m1();\n    int64_t sum = 0;\n    int64_t count = 0;\n\n    for (int64_t i = n; i <= m;) {\n        size_t vl = vsetvl_e64m1(m - i + 1);\n        vint64m1_t vec = vid_v_i64m1(vl);\n        vint64m1_t offset = vmv_v_x_i64m1(i, vl);\n        vec = vadd_vv_i64m1(vec, offset, vl);\n\n        // Horizontal sum of vector elements\n        int64_t temp_sum = 0;\n        for (size_t j = 0; j < vl; ++j) {\n            temp_sum += ((int64_t*)&vec)[j];\n        }\n        sum += temp_sum;\n        count += vl;\n        i += vl;\n    }\n\n    int64_t avg = sum / count;\n    if (sum % count * 2 >= count) {\n        avg++;\n    }\n\n    std::string binary = \"\";\n    if (avg == 0) {\n        binary = \"0\";\n    } else {\n        while (avg > 0) {\n            binary = (avg % 2 == 0 ? \"0\" : \"1\") + binary;\n            avg /= 2;\n        }\n    }\n\n    return binary;\n}\n```"}
{"task_id": "SimdBench_111_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n\n    size_t vlmax = vsetvlmax_e64m1();\n    int64_t sum = 0;\n    int64_t count = 0;\n\n    for (int64_t i = n; i <= m;) {\n        size_t vl = vsetvl_e64m1(m - i + 1);\n        vint64m1_t vec = vid_v_i64m1(vl);\n        vint64m1_t offset = vmul_vx_i64m1(vec, 1, vl);\n        vint64m1_t values = vadd_vx_i64m1(offset, i, vl);\n\n        // Horizontal sum of the vector\n        int64_t temp_sum = 0;\n        for (size_t j = 0; j < vl; ++j) {\n            temp_sum += values[j];\n        }\n        sum += temp_sum;\n        count += vl;\n        i += vl;\n    }\n\n    int64_t avg = sum / count;\n    if (sum % count * 2 >= count) avg++;\n\n    std::string binary = \"\";\n    if (avg == 0) return \"0\";\n    while (avg > 0) {\n        binary = ((avg % 2) ? \"1\" : \"0\") + binary;\n        avg /= 2;\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_112_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    size_t vlmax = vsetvlmax_e32m1();\n    int i = 0;\n\n    while (i < n) {\n        size_t vl = vsetvl_e32m1(n - i);\n\n        // Initialize vectors for indices and results\n        vint32m1_t indices = vid_v_i32m1(vl);\n        vint32m1_t results;\n\n        // Compute factorial modulo 10,000 for even indices\n        vbool32_t mask_even = vmseq_vx_i32m1_b32(indices, 0, vl);\n        vint32m1_t factorials = vmv_v_x_i32m1(1, vl);\n        for (int j = 2; j <= n; j += 2) {\n            factorials = vwmul_vv_i32m1(factorials, indices, vl);\n            factorials = vmod_vx_i32m1(factorials, 10000, vl);\n        }\n        results = vmerge_vvm_i32m1(mask_even, factorials, results, vl);\n\n        // Compute sum for odd indices\n        vbool32_t mask_odd = vmsne_vx_i32m1_b32(indices, 0, vl);\n        vint32m1_t sums = vadd_vx_i32m1(indices, 1, vl);\n        sums = vmul_vx_i32m1(sums, indices, vl);\n        sums = vsra_vx_i32m1(sums, 1, vl);\n        results = vmerge_vvm_i32m1(mask_odd, sums, results, vl);\n\n        // Store results back to the vector\n        vse32_v_i32m1(&result[i], results, vl);\n\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    size_t vlmax = vsetvlmax_e32m1();\n    int i = 0;\n\n    while (i < n) {\n        size_t vl = vsetvl_e32m1(n - i);\n\n        // Initialize vectors for even and odd indices\n        vint32m1_t veven = vmv_v_x_i32m1(1, vl); // Factorial starts with 1\n        vint32m1_t vodd = vmv_v_x_i32m1(0, vl);  // Sum starts with 0\n\n        // Create index vector\n        vint32m1_t indices = vid_v_i32m1(vl);\n        indices = vadd_vx_i32m1(indices, i + 1, vl); // Adjust indices to start from 1\n\n        // Mask for even and odd indices\n        vbool32_t mask_even = vmsne_vx_i32m1_b32(indices, 1, vl); // Even mask\n        vbool32_t mask_odd = vmseq_vx_i32m1_b32(indices, 1, vl);  // Odd mask\n\n        // Compute factorial for even indices\n        for (int j = 2; j <= n; ++j) {\n            if (j % 2 == 0) {\n                veven = vmul_vx_i32m1_m(mask_even, veven, j, vl);\n                veven = vmod_vx_i32m1(veven, 10000, vl);\n            }\n        }\n\n        // Compute sum for odd indices\n        for (int j = 1; j <= n; ++j) {\n            if (j % 2 != 0) {\n                vodd = vadd_vx_i32m1_m(mask_odd, vodd, j, vl);\n            }\n        }\n\n        // Merge results based on even/odd masks\n        vint32m1_t vresult = vmerge_vvm_i32m1(mask_even, veven, vodd, vl);\n\n        // Store results back to the result vector\n        vse32_v_i32m1(&result[i], vresult, vl);\n\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    size_t vl;\n    int i = 0;\n\n    while (i < n) {\n        vl = vsetvl_e32m8(n - i);\n\n        vint32m8_t vi = vid_v_i32m8(vl);\n        vi = vadd_vx_i32m8(vi, i + 1, vl); // vi now contains indices [i+1, i+2, ..., i+vl]\n\n        vbool32_t is_even = vmseq_vx_i32m8(vi & 1, 0, vl); // Check if even\n\n        // Compute factorial modulo 10000 for even indices\n        vint32m8_t fact_mod = vmv_v_x_i32m8(1, vl);\n        for (int j = 2; j <= n; ++j) {\n            fact_mod = vmul_vx_i32m8_m(is_even, fact_mod, j, vl);\n            fact_mod = vmod_vx_i32m8(fact_mod, 10000, vl);\n        }\n\n        // Compute sum for odd indices\n        vint32m8_t sum = vadd_vx_i32m8(vi, -1, vl);\n        sum = vmul_vx_i32m8(sum, vi, vl);\n        sum = vsra_vx_i32m8(sum, 1, vl);\n\n        // Merge results based on even/odd condition\n        vint32m8_t res = vmerge_vvm_i32m8(is_even, fact_mod, sum, vl);\n\n        // Store results back to memory\n        vse32_v_i32m8(&result[i], res, vl);\n\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    size_t vlmax = vsetvlmax_e32m1();\n    int i = 0;\n\n    while (i < n) {\n        size_t vl = vsetvl_e32m1(n - i);\n\n        // Initialize vectors for even and odd indices\n        vint32m1_t veven = vmv_v_x_i32m1(1, vl); // Factorial starts with 1\n        vint32m1_t vodd = vmv_v_x_i32m1(0, vl);  // Sum starts with 0\n\n        // Create index vector\n        vint32m1_t indices = vid_v_i32m1(vl);\n        indices = vadd_vx_i32m1(indices, i + 1, vl); // Adjust indices to start from 1\n\n        // Mask for even and odd indices\n        vbool32_t mask_even = vmseq_vx_i32m1(indices, 0, vl); // Placeholder for even mask\n        vbool32_t mask_odd = vmsne_vx_i32m1(indices, 0, vl);  // Placeholder for odd mask\n\n        // Compute factorial for even indices\n        for (int j = 1; j <= n; ++j) {\n            if (j % 2 == 0) {\n                veven = vmul_vx_i32m1_m(mask_even, veven, j, vl);\n                veven = vmod_vx_i32m1(veven, 10000, vl);\n            }\n        }\n\n        // Compute sum for odd indices\n        for (int j = 1; j <= n; ++j) {\n            if (j % 2 != 0) {\n                vodd = vadd_vx_i32m1_m(mask_odd, vodd, j, vl);\n            }\n        }\n\n        // Combine results\n        vint32m1_t vresult = vmerge_vvm_i32m1(mask_even, veven, vodd, vl);\n\n        // Store results back to memory\n        vse32_v_i32m1(&result[i], vresult, vl);\n\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    size_t vlmax = vsetvlmax_e32m1();\n    int i = 0;\n\n    while (i < n) {\n        size_t vl = vsetvl_e32m1(n - i);\n\n        // Initialize vectors for indices and results\n        vint32m1_t indices = vid_v_i32m1(vl);\n        vint32m1_t even_mask = vmseq_vx_i32m1(indices, 0, vl); // Even mask (i % 2 == 0)\n        vint32m1_t odd_mask = vmnot_m_b32(vmbool_t, even_mask, vl); // Odd mask (i % 2 != 0)\n\n        // Compute factorial modulo 10000 for even indices\n        vint32m1_t factorial = vmv_v_x_i32m1(1, vl);\n        for (int j = 1; j <= i + vl; ++j) {\n            factorial = vwmul_vv_i32m1(factorial, indices, vl);\n            factorial = vrem_vx_i32m1(factorial, 10000, vl);\n        }\n        factorial = vand_vv_i32m1(factorial, even_mask, vl);\n\n        // Compute sum for odd indices\n        vint32m1_t sum = vadd_vx_i32m1(indices, 1, vl);\n        sum = vand_vv_i32m1(sum, odd_mask, vl);\n\n        // Combine results\n        vint32m1_t combined = vor_vv_i32m1(factorial, sum, vl);\n\n        // Store results to the output vector\n        vse32_v_i32m1(&result[i], combined, vl);\n\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_113_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0, odd_count = 0;\n    size_t vl;\n\n    // Determine the maximum vector length for integers\n    vl = vsetvlmax_e32m1();\n\n    // Create a vector of indices starting from 1 to n\n    vint32m1_t vec_indices = vmv_v_x_i32m1(0, vl);\n    for (int i = 1; i <= n; i += vl) {\n        vl = vsetvl_e32m1(n - i + 1);\n        vec_indices = vid_v_i32m1(vec_indices, vl);\n\n        // Check if the number is a palindrome\n        vbool32_t is_palindrome = vmseq_vv_i32m1(vec_indices, reverse_digits_vector(vec_indices, vl), vl);\n\n        // Separate even and odd palindromes\n        vbool32_t is_even = vmseq_vx_i32m1(vrem_vx_i32m1(vec_indices, 2, vl), 0, vl);\n        vbool32_t is_odd = vmseq_vx_i32m1(vrem_vx_i32m1(vec_indices, 2, vl), 1, vl);\n\n        // Count even and odd palindromes\n        even_count += vpopc_m_b32(vmand_vv_b32m1(is_palindrome, is_even, vl), vl);\n        odd_count += vpopc_m_b32(vmand_vv_b32m1(is_palindrome, is_odd, vl), vl);\n    }\n\n    return std::vector<int>{even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0, odd_count = 0;\n    size_t vl;\n\n    // Determine the maximum vector length for integers\n    vl = vsetvl_e32m1(n);\n\n    // Create vectors to hold numbers and boolean results\n    vint32m1_t vec_numbers = vmv_v_x_i32m1(0, vl);\n    vbool32_t vec_is_palindrome = vmv_v_x_b32(0, vl);\n    vbool32_t vec_is_even = vmv_v_x_b32(0, vl);\n\n    // Initialize the vector with numbers from 1 to n\n    for (int i = 1; i <= n; i += vl) {\n        vl = vsetvl_e32m1(n - i + 1);\n        vec_numbers = vid_v_i32m1(vec_numbers, vl);\n        vec_numbers = vadd_vx_i32m1(vec_numbers, i - 1, vl);\n\n        // Check if each number is a palindrome\n        vint32m1_t vec_reversed = vmv_v_x_i32m1(0, vl);\n        vint32m1_t vec_temp = vec_numbers;\n        vbool32_t vec_mask = vmv_v_x_b32(1, vl);\n\n        while (vmseq_vx_i32m1_b32(vec_temp, 0, vl), vl) {\n            vec_reversed = vadd_vx_i32m1(vmul_vx_i32m1(vec_reversed, 10, vl), vrem_vx_i32m1(vec_temp, 10, vl), vl);\n            vec_temp = vdiv_vx_i32m1(vec_temp, 10, vl);\n        }\n\n        vec_is_palindrome = vmseq_vv_i32m1_b32(vec_numbers, vec_reversed, vl);\n\n        // Check if each palindrome is even or odd\n        vec_is_even = vmandnot_mm_b32(vec_is_palindrome, vmsne_vx_i32m1_b32(vrem_vx_i32m1(vec_numbers, 2, vl), 0, vl));\n\n        // Count even and odd palindromes\n        even_count += vcpop_m_b32(vmseq_vx_i32m1_b32(vec_is_even, 1, vl), vl);\n        odd_count += vcpop_m_b32(vmseq_vx_i32m1_b32(vmandnot_mm_b32(vec_is_palindrome, vec_is_even), 1, vl), vl);\n    }\n\n    return std::vector<int>{even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0, odd_count = 0;\n    size_t vl;\n\n    // Determine the maximum vector length for integer operations\n    vl = vsetvl_e32m1(n);\n\n    // Create vectors to hold values and masks\n    vint32m1_t vec = vmv_v_x_i32m1(0, vl);\n    vbool32_t mask_even, mask_odd, mask_palindrome;\n\n    // Initialize loop counter\n    int i = 1;\n\n    while (i <= n) {\n        // Load values into the vector\n        vl = vsetvl_e32m1(n - i + 1);\n        vec = vid_v_i32m1(vec, vl);\n        vint32m1_t reversed = vmv_v_x_i32m1(0, vl);\n\n        // Reverse digits of each number in the vector\n        vint32m1_t temp = vec;\n        vbool32_t mask_nonzero = vmseq_vx_i32m1(temp, 0, vl);\n        while (vmseq_vx_i32m1_b32(mask_nonzero, 0, vl)) {\n            vint32m1_t digit = vrem_vx_i32m1(temp, 10, vl);\n            reversed = vadd_vx_i32m1(vmul_vx_i32m1(reversed, 10, vl), digit, vl);\n            temp = vdiv_vx_i32m1(temp, 10, vl);\n            mask_nonzero = vmseq_vx_i32m1(temp, 0, vl);\n        }\n\n        // Check if the number is a palindrome\n        mask_palindrome = vmseq_vv_i32m1(vec, reversed, vl);\n\n        // Count even and odd palindromes\n        mask_even = vmsne_vx_i32m1(vand_vx_i32m1(vec, 1, vl), 0, vl);\n        mask_odd = vmseq_vx_i32m1(vand_vx_i32m1(vec, 1, vl), 1, vl);\n\n        even_count += vcpop_m_b32(vmseq_vx_i32m1_b32(mask_even, 1, vl), vl);\n        odd_count += vcpop_m_b32(vmseq_vx_i32m1_b32(mask_odd, 1, vl), vl);\n\n        // Update loop counter\n        i += vl;\n    }\n\n    return std::vector<int>{even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0, odd_count = 0;\n    size_t vl;\n\n    for (int i = 1; i <= n; i += vl) {\n        vl = vsetvl_e32m8(n - i + 1);\n\n        vint32m8_t vec = vid_v_i32m8(vl);\n        vec = vadd_vx_i32m8(vec, i - 1, vl);\n\n        vbool4_t is_palindrome_mask = vmbool_m_b4(vmseq_vv_i32m8(\n            vec, vrev_v_i32m8(vec, vl), vl));\n\n        vint32m8_t palindrome_numbers = vcompress_vm_i32m8(is_palindrome_mask, vec, vl);\n\n        vbool4_t is_even_mask = vmeq_vx_i32m8(palindrome_numbers, 0, vl);\n        vbool4_t is_odd_mask = vmnot_m_b4(is_even_mask, vl);\n\n        even_count += vcpop_m_b4(is_even_mask, vl);\n        odd_count += vcpop_m_b4(is_odd_mask, vl);\n    }\n\n    return std::vector<int>{even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0, odd_count = 0;\n    size_t vl;\n\n    // Determine the maximum vector length for integers\n    vl = vsetvlmax_e32m1();\n\n    // Create a vector of indices starting from 1 to n\n    vint32m1_t vec_indices = vmv_v_x_i32m1(0, vl);\n    for (int i = 1; i <= n; i += vl) {\n        vl = vsetvl_e32m1(n - i + 1);\n        vec_indices = vid_v_i32m1(vec_indices, vl);\n\n        // Convert vector indices to scalar values and check palindrome property\n        int temp[vl];\n        vse32_v_i32m1(temp, vec_indices, vl);\n\n        for (size_t j = 0; j < vl; ++j) {\n            int num = temp[j];\n            int original_num = num;\n            int reversed_num = 0;\n\n            while (num > 0) {\n                reversed_num = reversed_num * 10 + (num % 10);\n                num /= 10;\n            }\n\n            if (original_num == reversed_num) {\n                if (original_num % 2 == 0) {\n                    even_count++;\n                } else {\n                    odd_count++;\n                }\n            }\n        }\n    }\n\n    return std::vector<int>{even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_114_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint count_nums_simd(std::vector<int> n) {\n    size_t vlmax = vsetvlmax_e32m8();\n    size_t len = n.size();\n    int result = 0;\n\n    for (size_t i = 0; i < len; i += vlmax) {\n        size_t vl = vsetvl_e32m8(len - i);\n\n        // Load the vector of integers\n        vint32m8_t vec = vle32_v_i32m8(n.data() + i, vl);\n\n        // Initialize a mask for positive digits sum\n        vbool4_t mask = vmbool4_m(vl, false);\n\n        // Process each number in the vector\n        vint32m8_t num = vec;\n        vbool4_t sign_mask = vmflt_vx_i32m8(num, 0, vl);\n        vint32m8_t abs_num = vneg_v_i32m8(num, vl);\n        abs_num = vmerge_vxm_i32m8(abs_num, num, sign_mask, vl);\n\n        // Compute the sum of digits for each number\n        vint32m8_t digit_sum = vmv_v_x_i32m8(0, vl);\n        vint32m8_t temp = abs_num;\n\n        while (vmseq_vx_i32m8(temp, 0, vl)) {\n            vint32m8_t mod = vremu_vx_i32m8(temp, 10, vl);\n            digit_sum = vadd_vv_i32m8(digit_sum, mod, vl);\n            temp = vdivu_vx_i32m8(temp, 10, vl);\n        }\n\n        // Adjust the first digit if the number was negative\n        vint32m8_t first_digit = vremu_vx_i32m8(abs_num, 10, vl);\n        vint32m8_t neg_first_digit = vneg_v_i32m8(first_digit, vl);\n        digit_sum = vmerge_vvm_i32m8(digit_sum, vsub_vv_i32m8(digit_sum, vadd_vv_i32m8(first_digit, neg_first_digit, vl), vl), sign_mask, vl);\n\n        // Create a mask where digit_sum > 0\n        mask = vmfgt_vx_i32m8(digit_sum, 0, vl);\n\n        // Count the number of true values in the mask\n        result += vcpop_m_b4(mask, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_114_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint count_nums_simd(std::vector<int> n) {\n    size_t vlmax = vsetvlmax_e32m8();\n    size_t len = n.size();\n    int result = 0;\n\n    for (size_t i = 0; i < len; i += vlmax) {\n        size_t vl = vsetvl_e32m8(len - i);\n\n        // Load the vector of integers\n        vint32m8_t vec = vle32_v_i32m8(n.data() + i, vl);\n\n        // Initialize a mask for positive digits\n        vbool4_t mask_positive = vmfgt_vx_i32m8_b4(vec, 0, vl);\n\n        // Initialize a mask for negative numbers\n        vbool4_t mask_negative = vmflt_vx_i32m8_b4(vec, 0, vl);\n\n        // Compute absolute values for negative numbers\n        vint32m8_t abs_vec = vmsub_vx_i32m8(vec, 0, mask_negative, vl);\n\n        // Extract digits and compute their sums\n        vint32m8_t digit_sum = vmv_v_x_i32m8(0, vl);\n        vint32m8_t temp = abs_vec;\n\n        while (1) {\n            // Extract the last digit\n            vint32m8_t last_digit = vrem_vx_i32m8(temp, 10, vl);\n\n            // Add the last digit to the sum\n            digit_sum = vadd_vv_i32m8(digit_sum, last_digit, vl);\n\n            // Remove the last digit\n            temp = vdiv_vx_i32m8(temp, 10, vl);\n\n            // Check if all elements are zero\n            vbool4_t mask_nonzero = vmfne_vx_i32m8_b4(temp, 0, vl);\n            if (!vmreduce_any_b4(mask_nonzero, vl)) {\n                break;\n            }\n        }\n\n        // Adjust digit sum for negative numbers\n        vint32m8_t first_digit = vrem_vx_i32m8(abs_vec, 10, vl);\n        vint32m8_t adjusted_sum = vsub_vv_i32m8(digit_sum, vadd_vv_i32m8(first_digit, first_digit, vl), mask_negative, vl);\n\n        // Count numbers with digit sum > 0\n        vbool4_t mask_sum_positive = vmfgt_vx_i32m8_b4(adjusted_sum, 0, vl);\n        result += vmreduce_sum_b4(mask_sum_positive, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_114_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint count_nums_simd(std::vector<int> n) {\n    size_t vlmax = vsetvlmax_e32m8();\n    size_t len = n.size();\n    int result = 0;\n\n    for (size_t i = 0; i < len; i += vlmax) {\n        size_t vl = vsetvl_e32m8(len - i);\n\n        // Load the vector of integers\n        vint32m8_t vec = vle32_v_i32m8(n.data() + i, vl);\n\n        // Initialize a mask for positive numbers\n        vbool4_t mask_positive = vmflt_vx_i32m8_b4(vec, 0, vl);\n\n        // Negate the negative numbers to work with their absolute values\n        vint32m8_t abs_values = vmsub_vx_i32m8(vec, 0, vec, vl);\n\n        // Compute the sum of digits for each number in parallel\n        vint32m8_t digit_sum = vmv_v_x_i32m8(0, vl);\n        vint32m8_t temp = abs_values;\n\n        while (1) {\n            // Extract the last digit\n            vint32m8_t last_digit = vremu_vx_i32m8(temp, 10, vl);\n\n            // Add the last digit to the digit sum\n            digit_sum = vadd_vv_i32m8(digit_sum, last_digit, vl);\n\n            // Remove the last digit\n            temp = vdivu_vx_i32m8(temp, 10, vl);\n\n            // Check if all numbers have been reduced to zero\n            vbool4_t mask_nonzero = vmfgt_vx_i32m8_b4(temp, 0, vl);\n            if (!vmfirst_m_b4(mask_nonzero, vl)) {\n                break;\n            }\n        }\n\n        // Create a mask for numbers where the sum of digits > 0\n        vbool4_t mask_digit_sum_positive = vmfgt_vx_i32m8_b4(digit_sum, 0, vl);\n\n        // Combine masks: number is positive or has digit sum > 0\n        vbool4_t mask_final = vmor_mm_b4(mask_positive, mask_digit_sum_positive, vl);\n\n        // Count the number of true values in the mask\n        result += vcpop_m_b4(mask_final, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_114_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint count_nums_simd(std::vector<int> n) {\n    size_t vlmax = vsetvlmax_e32m8();\n    size_t len = n.size();\n    int result = 0;\n\n    for (size_t i = 0; i < len; i += vlmax) {\n        size_t vl = vsetvl_e32m8(len - i);\n        vint32m8_t vec = vle32_v_i32m8(&n[i], vl);\n\n        // Compute absolute values\n        vbool4_t mask_negative = vmflt_vx_i32m8_b4(vec, 0, vl);\n        vint32m8_t abs_values = vneg_v_i32m8_m(mask_negative, vec, vl);\n\n        // Initialize digit sum vector\n        vint32m8_t digit_sum = vmv_v_x_i32m8(0, vl);\n\n        // Extract and sum digits\n        vint32m8_t temp = abs_values;\n        while (1) {\n            vint32m8_t digit = vremu_vx_i32m8(temp, 10, vl);\n            digit_sum = vadd_vv_i32m8(digit_sum, digit, vl);\n            temp = vdivu_vx_i32m8(temp, 10, vl);\n\n            vbool4_t mask_nonzero = vmfgt_vx_i32m8_b4(temp, 0, vl);\n            if (!vmfirst_m_b4(mask_nonzero)) break;\n        }\n\n        // Adjust for negative numbers\n        vint32m8_t first_digit = vremu_vx_i32m8(abs_values, 10, vl);\n        vint32m8_t adjusted_sum = vsub_vv_i32m8_m(mask_negative, digit_sum, first_digit, vl);\n        adjusted_sum = vadd_vv_i32m8_m(mask_negative, adjusted_sum, vmul_vx_i32m8(first_digit, -2, vl), vl);\n\n        // Count elements with sum of digits > 0\n        vbool4_t mask_positive_sum = vmfgt_vx_i32m8_b4(adjusted_sum, 0, vl);\n        result += vcpop_m_b4(mask_positive_sum, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_114_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint count_nums_simd(std::vector<int> n) {\n    size_t vlmax = vsetvlmax_e32m8();\n    size_t len = n.size();\n    int result = 0;\n\n    for (size_t i = 0; i < len; i += vlmax) {\n        size_t vl = vsetvl_e32m8(len - i);\n        vint32m8_t vec = vle32_v_i32m8(n.data() + i, vl);\n\n        // Compute absolute values\n        vbool4_t mask_neg = vmflt_vx_i32m8_b4(vec, 0, vl);\n        vint32m8_t abs_vals = vneg_v_i32m8_m(mask_neg, vec, vl);\n\n        // Extract and sum digits\n        vint32m8_t digit_sum = vmv_v_x_i32m8(0, vl);\n        vint32m8_t temp = abs_vals;\n\n        while (1) {\n            vint32m8_t digit = vremu_vx_i32m8(temp, 10, vl);\n            digit_sum = vadd_vv_i32m8(digit_sum, digit, vl);\n            temp = vdivu_vx_i32m8(temp, 10, vl);\n\n            vbool4_t mask_nonzero = vmfgt_vx_i32m8_b4(temp, 0, vl);\n            if (!vmfirst_m_b4(mask_nonzero, vl)) break;\n        }\n\n        // Adjust for negative numbers\n        vint32m8_t first_digit = vneg_v_i32m8_m(mask_neg, vremu_vx_i32m8(abs_vals, 10, vl), vl);\n        digit_sum = vadd_vv_i32m8(digit_sum, first_digit, vl);\n\n        // Count where digit_sum > 0\n        vbool4_t mask_positive = vmfgt_vx_i32m8_b4(digit_sum, 0, vl);\n        result += vcpop_m_b4(mask_positive, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_115_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    size_t N = arr.size();\n    if (N == 0) return true;\n\n    // Allocate space for the vectorized operations\n    std::vector<int> arr_extended(arr.begin(), arr.end());\n    arr_extended.insert(arr_extended.end(), arr.begin(), arr.end());\n\n    size_t vlmax = vsetvlmax_e32m1(); // Set maximum vector length for int32\n    bool result = true;\n\n    for (size_t i = 0; i < N && result; ++i) {\n        size_t vl = vsetvl_e32m1(N); // Vector length for current iteration\n        vint32m1_t prev = vle32_v_i32m1(&arr_extended[i], vl); // Load first segment\n        vint32m1_t curr = vle32_v_i32m1(&arr_extended[i + 1], vl); // Load next segment\n\n        // Compare adjacent elements for non-decreasing order\n        vbool32_t mask = vmseq_vv_i32m1_b32(prev, curr);\n        bool is_sorted = vmall(mask, vl);\n\n        if (!is_sorted) {\n            result = false;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_115_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    size_t N = arr.size();\n    if (N == 0) return true;\n\n    // Allocate space for the vectorized operations\n    std::vector<int> arr_extended(arr.begin(), arr.end());\n    arr_extended.insert(arr_extended.end(), arr.begin(), arr.end());\n\n    bool result = false;\n    size_t vlmax = vsetvlmax_e32m1(); // Set maximum vector length for int32\n\n    for (size_t start = 0; start < N; ++start) {\n        bool is_sorted = true;\n\n        size_t i = 0;\n        for (; i + vlmax <= N - 1; i += vlmax) {\n            vint32m1_t curr = vle32_v_i32m1(&arr_extended[start + i], vlmax);\n            vint32m1_t next = vle32_v_i32m1(&arr_extended[start + i + 1], vlmax);\n\n            vbool32_t mask = vmseq_vv_i32m1_b32(curr, next, vlmax);\n            if (vmfirst_m_b32(mask, vlmax) != -1) {\n                is_sorted = false;\n                break;\n            }\n        }\n\n        // Handle remaining elements\n        for (; i < N - 1; ++i) {\n            if (arr_extended[start + i] > arr_extended[start + i + 1]) {\n                is_sorted = false;\n                break;\n            }\n        }\n\n        if (is_sorted) {\n            result = true;\n            break;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_115_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    size_t N = arr.size();\n    if (N == 0) return true;\n\n    // Copy the array to a new array twice its size for wrap-around comparison\n    std::vector<int> doubled_arr(arr.begin(), arr.end());\n    doubled_arr.insert(doubled_arr.end(), arr.begin(), arr.end());\n\n    size_t vlmax = __riscv_vsetvlmax_e32m1();\n    bool result = false;\n\n    for (size_t i = 0; i < N; ++i) {\n        bool is_sorted = true;\n        size_t j = 0;\n\n        while (j < N - vlmax) {\n            vint32m1_t vec1 = __riscv_vle32_v_i32m1(&doubled_arr[i + j], vlmax);\n            vint32m1_t vec2 = __riscv_vle32_v_i32m1(&doubled_arr[i + j + 1], vlmax);\n            vbool32_t mask = __riscv_vmseq_vv_i32m1_b32(vec1, vec2);\n            if (__riscv_vfirst_m_b32(mask, vlmax) != -1) {\n                is_sorted = false;\n                break;\n            }\n            j += vlmax;\n        }\n\n        if (is_sorted) {\n            for (; j < N - 1; ++j) {\n                if (doubled_arr[i + j] > doubled_arr[i + j + 1]) {\n                    is_sorted = false;\n                    break;\n                }\n            }\n        }\n\n        if (is_sorted) {\n            result = true;\n            break;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_115_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    size_t N = arr.size();\n    if (N == 0) return true;\n\n    // Allocate space for the vectorized operations\n    std::vector<int> arr_extended(arr.begin(), arr.end());\n    arr_extended.insert(arr_extended.end(), arr.begin(), arr.end());\n\n    size_t vlmax = vsetvlmax_e32m1(); // Get maximum vector length for int32\n    bool result = true;\n\n    for (size_t i = 0; i < N && result; ++i) {\n        size_t vl = vsetvl_e32m1(N); // Set vector length for current iteration\n        vint32m1_t prev = vle32_v_i32m1(&arr_extended[i], vl); // Load first vector\n        vint32m1_t curr = vle32_v_i32m1(&arr_extended[i + 1], vl); // Load second vector\n\n        vbool32_t mask = vmseq_vv_i32m1_b32(prev, curr); // Compare elements\n        bool is_sorted = vmreduce_all_b32(mask); // Check if all elements are sorted\n\n        if (!is_sorted) {\n            result = false;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_115_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    size_t N = arr.size();\n    if (N == 0) return true;\n\n    // Allocate space for the vectorized operations\n    std::vector<int> arr_extended(arr.begin(), arr.end());\n    arr_extended.insert(arr_extended.end(), arr.begin(), arr.end());\n\n    bool result = false;\n    size_t vlmax = vsetvlmax_e32m1(); // Set maximum vector length for int32\n\n    for (size_t i = 0; i < N; ++i) {\n        bool is_sorted = true;\n        size_t j = 0;\n\n        // Vectorized comparison loop\n        for (; j + vlmax <= N - 1; j += vlmax) {\n            vint32m1_t vec_current = vle32_v_i32m1(&arr_extended[i + j], vlmax);\n            vint32m1_t vec_next = vle32_v_i32m1(&arr_extended[i + j + 1], vlmax);\n            vbool32_t mask = vmseq_vv_i32m1_b32(vec_current, vec_next);\n            if (vmfirst_m_b32(mask) != -1) {\n                is_sorted = false;\n                break;\n            }\n        }\n\n        // Handle remaining elements\n        for (; j < N - 1; ++j) {\n            if (arr_extended[i + j] > arr_extended[i + j + 1]) {\n                is_sorted = false;\n                break;\n            }\n        }\n\n        if (is_sorted) {\n            result = true;\n            break;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_116_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t n = lst1.size();\n    size_t m = lst2.size();\n    size_t max_size = (n > m) ? n : m;\n\n    // Temporary arrays to hold the data for RVV processing\n    int temp_lst1[max_size];\n    int temp_lst2[max_size];\n\n    // Copy lst1 and lst2 into temporary arrays, padding with zeros if necessary\n    for (size_t i = 0; i < max_size; ++i) {\n        temp_lst1[i] = (i < n) ? lst1[i] : 0;\n        temp_lst2[i] = (i < m) ? lst2[i] : 0;\n    }\n\n    size_t vl;\n    bool has_odd_in_lst1 = false;\n    bool has_even_in_lst2 = false;\n\n    // Process vectors using RVV intrinsics\n    for (size_t i = 0; i < max_size; i += vl) {\n        vl = vsetvl_e32m8(max_size - i);\n\n        // Load vectors from memory\n        vint32m8_t vec_lst1 = vle32_v_i32m8(&temp_lst1[i], vl);\n        vint32m8_t vec_lst2 = vle32_v_i32m8(&temp_lst2[i], vl);\n\n        // Check for odd numbers in lst1\n        vbool4_t mask_odd_lst1 = vmseq_vx_i32m8_b4(vec_lst1 & 1, 1, vl);\n        has_odd_in_lst1 |= vmreduce_any_true_b4(mask_odd_lst1, vl);\n\n        // Check for even numbers in lst2\n        vbool4_t mask_even_lst2 = vmseq_vx_i32m8_b4(vec_lst2 & 1, 0, vl);\n        has_even_in_lst2 |= vmreduce_any_true_b4(mask_even_lst2, vl);\n    }\n\n    return (has_odd_in_lst1 && has_even_in_lst2) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t n = lst1.size();\n    size_t m = lst2.size();\n    size_t max_size = std::max(n, m);\n\n    // Allocate memory for aligned data\n    int* aligned_lst1 = (int*)aligned_alloc(sizeof(int) * max_size, sizeof(int) * max_size);\n    int* aligned_lst2 = (int*)aligned_alloc(sizeof(int) * max_size, sizeof(int) * max_size);\n\n    // Copy data to aligned memory\n    for (size_t i = 0; i < n; ++i) aligned_lst1[i] = lst1[i];\n    for (size_t i = 0; i < m; ++i) aligned_lst2[i] = lst2[i];\n\n    // Initialize RVV variables\n    size_t vl;\n    size_t vlmax = vsetvlmax_e32m8(); // Set maximum vector length for int32\n    bool has_odd_in_lst1 = false;\n\n    // Check if lst1 contains any odd numbers\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m8(n - i); // Set vector length for remaining elements\n        vint32m8_t vec_lst1 = vle32_v_i32m8(&aligned_lst1[i], vl); // Load vector from lst1\n        vbool4_t mask_odd = vmseq_vx_i32m8_b4(vec_lst1, 1); // Mask for odd numbers\n        if (vmfirst_m_b4(mask_odd)) { // Check if any odd number exists\n            has_odd_in_lst1 = true;\n            break;\n        }\n    }\n\n    // If no odd numbers in lst1, return \"YES\"\n    if (!has_odd_in_lst1) {\n        free(aligned_lst1);\n        free(aligned_lst2);\n        return \"YES\";\n    }\n\n    // Check if lst2 contains at least one even number\n    bool has_even_in_lst2 = false;\n    for (size_t i = 0; i < m; i += vl) {\n        vl = vsetvl_e32m8(m - i); // Set vector length for remaining elements\n        vint32m8_t vec_lst2 = vle32_v_i32m8(&aligned_lst2[i], vl); // Load vector from lst2\n        vbool4_t mask_even = vmseq_vx_i32m8_b4(vec_lst2, 0); // Mask for even numbers\n        if (vmfirst_m_b4(mask_even)) { // Check if any even number exists\n            has_even_in_lst2 = true;\n            break;\n        }\n    }\n\n    // Free allocated memory\n    free(aligned_lst1);\n    free(aligned_lst2);\n\n    // Return result based on conditions\n    return (has_even_in_lst2) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t n = lst1.size();\n    size_t m = lst2.size();\n    size_t max_size = std::max(n, m);\n\n    // Allocate temporary arrays for RVV processing\n    int* temp_lst1 = new int[max_size];\n    int* temp_lst2 = new int[max_size];\n\n    // Copy data to temporary arrays\n    for (size_t i = 0; i < n; ++i) temp_lst1[i] = lst1[i];\n    for (size_t i = 0; i < m; ++i) temp_lst2[i] = lst2[i];\n\n    // Initialize RVV variables\n    size_t vl;\n    vbool32_t mask_odd;\n    vint32m1_t vec_lst1, vec_lst2;\n\n    // Count odd numbers in lst1 and even numbers in lst2\n    int odd_count_lst1 = 0;\n    int even_count_lst2 = 0;\n\n    for (size_t i = 0; i < max_size; i += vl) {\n        vl = vsetvl_e32m1(max_size - i);\n\n        // Load vectors from lst1 and lst2\n        vec_lst1 = vle32_v_i32m1(temp_lst1 + i, vl);\n        vec_lst2 = vle32_v_i32m1(temp_lst2 + i, vl);\n\n        // Check odd numbers in lst1\n        mask_odd = vmseq_vx_i32m1_b32(vec_lst1, 1); // Mask for odd numbers\n        odd_count_lst1 += vcpop_m_b32(mask_odd, vl);\n\n        // Check even numbers in lst2\n        mask_odd = vmseq_vx_i32m1_b32(vec_lst2, 0); // Mask for even numbers\n        even_count_lst2 += vcpop_m_b32(mask_odd, vl);\n    }\n\n    // Cleanup temporary arrays\n    delete[] temp_lst1;\n    delete[] temp_lst2;\n\n    // Determine if exchange is possible\n    return (odd_count_lst1 <= even_count_lst2) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t n = lst1.size();\n    size_t m = lst2.size();\n    size_t max_size = std::max(n, m);\n\n    // Allocate temporary storage for RVV operations\n    int *temp1 = (int *)malloc(max_size * sizeof(int));\n    int *temp2 = (int *)malloc(max_size * sizeof(int));\n\n    // Copy data to temporary arrays\n    for (size_t i = 0; i < n; ++i) temp1[i] = lst1[i];\n    for (size_t i = 0; i < m; ++i) temp2[i] = lst2[i];\n\n    // Initialize vector registers\n    size_t vl;\n    vbool32_t mask;\n    vint32m1_t vec1, vec2;\n\n    // Count odd numbers in lst1\n    int odd_count_lst1 = 0;\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        vec1 = vle32_v_i32m1(&temp1[i], vl);\n        mask = vmseq_vx_i32m1_b32(vec1, 1); // Mask for odd numbers\n        odd_count_lst1 += vcpop_m_b32(mask, vl);\n    }\n\n    // Count even numbers in lst2\n    int even_count_lst2 = 0;\n    for (size_t i = 0; i < m; i += vl) {\n        vl = vsetvl_e32m1(m - i);\n        vec2 = vle32_v_i32m1(&temp2[i], vl);\n        mask = vmseq_vx_i32m1_b32(vec2, 0); // Mask for even numbers\n        even_count_lst2 += vcpop_m_b32(mask, vl);\n    }\n\n    // Free temporary storage\n    free(temp1);\n    free(temp2);\n\n    // Determine if exchange is possible\n    return (odd_count_lst1 <= even_count_lst2) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t n = lst1.size();\n    size_t m = lst2.size();\n    size_t max_size = std::max(n, m);\n\n    // Allocate temporary arrays for RVV processing\n    int *temp_lst1 = (int *)malloc(max_size * sizeof(int));\n    int *temp_lst2 = (int *)malloc(max_size * sizeof(int));\n\n    // Copy data to temporary arrays and pad with zeros if necessary\n    for (size_t i = 0; i < max_size; ++i) {\n        temp_lst1[i] = (i < n) ? lst1[i] : 0;\n        temp_lst2[i] = (i < m) ? lst2[i] : 0;\n    }\n\n    size_t vl;\n    bool has_odd_in_lst1 = false;\n    bool has_even_in_lst2 = false;\n\n    // Process using RVV intrinsics\n    for (size_t i = 0; i < max_size; i += vl) {\n        vl = vsetvl_e32m8(max_size - i);\n\n        // Load vectors from lst1 and lst2\n        vint32m8_t vec_lst1 = vle32_v_i32m8(&temp_lst1[i], vl);\n        vint32m8_t vec_lst2 = vle32_v_i32m8(&temp_lst2[i], vl);\n\n        // Check for odd numbers in lst1\n        vbool4_t mask_odd_lst1 = vmseq_vx_i32m8_b4(vec_lst1 & 1, 1, vl);\n        has_odd_in_lst1 |= vmreduce_any(mask_odd_lst1, vl);\n\n        // Check for even numbers in lst2\n        vbool4_t mask_even_lst2 = vmseq_vx_i32m8_b4(vec_lst2 & 1, 0, vl);\n        has_even_in_lst2 |= vmreduce_any(mask_even_lst2, vl);\n    }\n\n    // Free allocated memory\n    free(temp_lst1);\n    free(temp_lst2);\n\n    // Determine result based on flags\n    return (has_odd_in_lst1 && !has_even_in_lst2) ? \"NO\" : \"YES\";\n}\n```"}
{"task_id": "SimdBench_117_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    size_t max_len = 0;\n\n    // Find the maximum string length in the input vector\n    for (const auto &s : lst) {\n        if (s.length() > max_len) {\n            max_len = s.length();\n        }\n    }\n\n    // Allocate a buffer to hold all strings padded to the max length\n    std::vector<char> buffer(lst.size() * max_len, '0');\n    for (size_t i = 0; i < lst.size(); ++i) {\n        memcpy(&buffer[i * max_len], lst[i].c_str(), lst[i].size());\n    }\n\n    // Process the buffer using RVV intrinsics\n    size_t vlmax = vsetvlmax_e8m1();\n    for (size_t i = 0; i < lst.size(); ++i) {\n        size_t count = 0;\n        size_t j = 0;\n\n        // Load and process the string in chunks using RVV\n        for (; j + vlmax <= max_len; j += vlmax) {\n            vuint8m1_t vec = vle8_v_u8m1(&buffer[i * max_len + j], vlmax);\n            vbool8_t mask = vmseq_vx_u8m1(vec, '1', vlmax) |\n                            vmseq_vx_u8m1(vec, '3', vlmax) |\n                            vmseq_vx_u8m1(vec, '5', vlmax) |\n                            vmseq_vx_u8m1(vec, '7', vlmax) |\n                            vmseq_vx_u8m1(vec, '9', vlmax);\n            count += vpopc_m_b8(vmnot_m_b8(mask, vlmax), vlmax);\n        }\n\n        // Handle remaining elements\n        if (j < max_len) {\n            size_t vl = vsetvl_e8m1(max_len - j);\n            vuint8m1_t vec = vle8_v_u8m1(&buffer[i * max_len + j], vl);\n            vbool8_t mask = vmseq_vx_u8m1(vec, '1', vl) |\n                            vmseq_vx_u8m1(vec, '3', vl) |\n                            vmseq_vx_u8m1(vec, '5', vl) |\n                            vmseq_vx_u8m1(vec, '7', vl) |\n                            vmseq_vx_u8m1(vec, '9', vl);\n            count += vpopc_m_b8(vmnot_m_b8(mask, vl), vl);\n        }\n\n        // Generate the output string\n        std::string output = \"the number of odd elements \";\n        output += std::to_string(count);\n        output += \"n the str\";\n        output += std::to_string(count);\n        output += \"ng \";\n        output += std::to_string(count);\n        output += \" of the \";\n        output += std::to_string(count);\n        output += \"nput.\";\n        result.push_back(output);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    size_t max_len = 0;\n\n    // Find the maximum string length in the input vector\n    for (const auto &s : lst) {\n        if (s.length() > max_len) {\n            max_len = s.length();\n        }\n    }\n\n    // Allocate a buffer to hold all strings padded to the max length\n    std::vector<char> buffer(lst.size() * max_len, '0');\n    for (size_t i = 0; i < lst.size(); ++i) {\n        memcpy(&buffer[i * max_len], lst[i].c_str(), lst[i].size());\n    }\n\n    // Process the buffer using RVV intrinsics\n    size_t vlmax = vsetvlmax_e8m1();\n    for (size_t i = 0; i < lst.size(); ++i) {\n        size_t vl = vsetvl_e8m1(max_len);\n        unsigned int odd_count = 0;\n\n        for (size_t j = 0; j < max_len; j += vl) {\n            vl = vsetvl_e8m1(max_len - j);\n\n            // Load characters from the buffer\n            vuint8m1_t vec = vle8_v_u8m1(&buffer[i * max_len + j], vl);\n\n            // Create a mask for odd digits ('1', '3', '5', '7', '9')\n            vbool8_t mask = vmseq_vx_u8m1(vec, '1', vl) |\n                            vmseq_vx_u8m1(vec, '3', vl) |\n                            vmseq_vx_u8m1(vec, '5', vl) |\n                            vmseq_vx_u8m1(vec, '7', vl) |\n                            vmseq_vx_u8m1(vec, '9', vl);\n\n            // Count the number of true values in the mask\n            odd_count += vcpop_m_b8(mask, vl);\n        }\n\n        // Construct the output string\n        std::string output = \"the number of odd elements \";\n        output += std::to_string(odd_count);\n        output += \"n the str\";\n        output += std::to_string(odd_count);\n        output += \"ng \";\n        output += std::to_string(odd_count);\n        output += \" of the \";\n        output += std::to_string(odd_count);\n        output += \"nput.\";\n        result.push_back(output);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    size_t max_len = 0;\n\n    // Find the maximum string length in the input vector\n    for (const auto &s : lst) {\n        if (s.length() > max_len) {\n            max_len = s.length();\n        }\n    }\n\n    // Allocate a buffer to hold all strings padded to the max length\n    std::vector<char> buffer(lst.size() * max_len, '0');\n    for (size_t i = 0; i < lst.size(); ++i) {\n        memcpy(&buffer[i * max_len], lst[i].c_str(), lst[i].size());\n    }\n\n    // Process the strings using RVV intrinsics\n    size_t vlmax = vsetvlmax_e8m1();\n    for (size_t i = 0; i < lst.size(); ++i) {\n        size_t vl = vsetvl_e8m1(max_len);\n        unsigned int odd_count = 0;\n\n        for (size_t j = 0; j < max_len; j += vl) {\n            vl = vsetvl_e8m1(max_len - j);\n\n            // Load characters from the buffer\n            vuint8m1_t vec = vle8_v_u8m1(&buffer[i * max_len + j], vl);\n\n            // Create a mask for odd digits ('1', '3', '5', '7', '9')\n            vbool8_t mask_odd = vmseq_vx_u8m1(vec, '1', vl);\n            mask_odd = vmor_mm(mask_odd, vmseq_vx_u8m1(vec, '3', vl), vl);\n            mask_odd = vmor_mm(mask_odd, vmseq_vx_u8m1(vec, '5', vl), vl);\n            mask_odd = vmor_mm(mask_odd, vmseq_vx_u8m1(vec, '7', vl), vl);\n            mask_odd = vmor_mm(mask_odd, vmseq_vx_u8m1(vec, '9', vl), vl);\n\n            // Count the number of odd digits\n            odd_count += vmpopc_m_b8(mask_odd, vl);\n        }\n\n        // Construct the output string with the odd count\n        std::string output = \"the number of odd elements \";\n        output += std::to_string(odd_count);\n        output += \"n the str\";\n        output += std::to_string(odd_count);\n        output += \"ng \";\n        output += std::to_string(odd_count);\n        output += \" of the \";\n        output += std::to_string(odd_count);\n        output += \"nput.\";\n        result.push_back(output);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    size_t max_len = 0;\n\n    // Find the maximum string length in the input list\n    for (const auto &s : lst) {\n        if (s.length() > max_len) {\n            max_len = s.length();\n        }\n    }\n\n    // Allocate a buffer to hold all strings padded to the same length\n    std::vector<char> buffer(lst.size() * max_len, '0');\n    for (size_t i = 0; i < lst.size(); ++i) {\n        memcpy(&buffer[i * max_len], lst[i].c_str(), lst[i].size());\n    }\n\n    // Process the buffer using RVV intrinsics\n    size_t vlmax = vsetvlmax_e8m1();\n    for (size_t i = 0; i < lst.size(); ++i) {\n        size_t vl = vsetvl_e8m1(max_len);\n        unsigned int odd_count = 0;\n\n        for (size_t j = 0; j < max_len; j += vl) {\n            vl = vsetvl_e8m1(max_len - j);\n\n            // Load a vector of characters from the buffer\n            vuint8m1_t vec = vle8_v_u8m1(&buffer[i * max_len + j], vl);\n\n            // Create a mask for odd digits ('1', '3', '5', '7', '9')\n            vbool8_t mask = vmseq_vx_u8m1(vec, '1', vl);\n            mask = vmfor_vv_b8(mask, vmseq_vx_u8m1(vec, '3', vl), vl);\n            mask = vmfor_vv_b8(mask, vmseq_vx_u8m1(vec, '5', vl), vl);\n            mask = vmfor_vv_b8(mask, vmseq_vx_u8m1(vec, '7', vl), vl);\n            mask = vmfor_vv_b8(mask, vmseq_vx_u8m1(vec, '9', vl), vl);\n\n            // Count the number of true values in the mask\n            odd_count += vcpop_m_b8(mask, vl);\n        }\n\n        // Construct the output string with the count replaced\n        std::string output = \"the number of odd elements Xn the strXng X of the Xnput.\";\n        for (char &c : output) {\n            if (c == 'X') {\n                c = '0' + odd_count;\n            }\n        }\n        result.push_back(output);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    size_t max_len = 0;\n\n    // Find the maximum string length in the input vector\n    for (const auto &s : lst) {\n        if (s.length() > max_len) {\n            max_len = s.length();\n        }\n    }\n\n    // Allocate a buffer to hold all strings padded to the max length\n    std::vector<char> buffer(lst.size() * max_len, '0');\n    for (size_t i = 0; i < lst.size(); ++i) {\n        memcpy(&buffer[i * max_len], lst[i].c_str(), lst[i].size());\n    }\n\n    // Process the buffer using RVV intrinsics\n    size_t vlmax = vsetvlmax_e8m1();\n    for (size_t i = 0; i < lst.size(); ++i) {\n        size_t vl = vsetvl_e8m1(max_len);\n        unsigned int odd_count = 0;\n\n        for (size_t j = 0; j < max_len; j += vl) {\n            vl = vsetvl_e8m1(max_len - j);\n\n            // Load a vector of characters from the buffer\n            vuint8m1_t vec = vle8_v_u8m1(&buffer[i * max_len + j], vl);\n\n            // Create a mask for odd digits ('1', '3', '5', '7', '9')\n            vbool8_t mask = vmseq_vx_u8m1(vec, '1', vl);\n            mask = vmor_mm_b8(mask, vmseq_vx_u8m1(vec, '3', vl), vl);\n            mask = vmor_mm_b8(mask, vmseq_vx_u8m1(vec, '5', vl), vl);\n            mask = vmor_mm_b8(mask, vmseq_vx_u8m1(vec, '7', vl), vl);\n            mask = vmor_mm_b8(mask, vmseq_vx_u8m1(vec, '9', vl), vl);\n\n            // Count the number of odd digits in this vector\n            odd_count += vcpop_m_b8(mask, vl);\n        }\n\n        // Construct the output string with the count replaced\n        std::string output = \"the number of odd elements Xn the strXng X of the Xnput.\";\n        for (char &c : output) {\n            if (c == 'X') {\n                c = '0' + odd_count;\n            }\n        }\n        result.push_back(output);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_118_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    size_t vlmax = vsetvlmax_e64m1();\n    size_t n = nums.size();\n    int64_t global_min = nums[0];\n    int64_t current_min = nums[0];\n\n    for (size_t i = 1; i < n; i += vlmax) {\n        size_t vl = vsetvl_e64m1(n - i);\n\n        vint64m1_t vec = vle64_v_i64m1(nums.data() + i, vl);\n        vint64m1_t current_min_vec = vmv_v_x_i64m1(current_min, vl);\n        vint64m1_t global_min_vec = vmv_v_x_i64m1(global_min, vl);\n\n        // Compute prefix sums and track minimum\n        vint64m1_t prefix_sum = vmv_v_x_i64m1(0, vl);\n        vint64m1_t temp_min = vmv_v_x_i64m1(current_min, vl);\n\n        for (size_t j = 0; j < vl; ++j) {\n            prefix_sum = vadd_vv_i64m1(prefix_sum, vec, vl);\n            temp_min = vmin_vv_i64m1(temp_min, prefix_sum, vl);\n        }\n\n        // Update global_min and current_min\n        current_min = vmin_vv_i64m1(current_min_vec, temp_min, vl);\n        global_min = vmin_vv_i64m1(global_min_vec, current_min, vl);\n    }\n\n    return global_min;\n}\n```"}
{"task_id": "SimdBench_118_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    size_t len = nums.size();\n    int64_t global_min = nums[0];\n    int64_t current_min = nums[0];\n\n    size_t vlmax = vsetvlmax_e64m1();\n    vint64m1_t v_global_min = vmv_s_x_i64m1(vundefined_i64m1(), global_min, vlmax);\n    vint64m1_t v_current_min = vmv_s_x_i64m1(vundefined_i64m1(), current_min, vlmax);\n\n    for (size_t i = 1; i < len; i += vlmax) {\n        size_t vl = vsetvl_e64m1(len - i);\n        vint64m1_t v_nums = vle64_v_i64m1(&nums[i], vl);\n\n        // Update current_min = min(nums[i], current_min + nums[i])\n        vint64m1_t v_current_plus_num = vwadd_vv_i64m1(v_current_min, v_nums, vl);\n        v_current_min = vmin_vv_i64m1(v_nums, v_current_plus_num, vl);\n\n        // Update global_min = min(global_min, current_min)\n        v_global_min = vmin_vv_i64m1(v_global_min, v_current_min, vl);\n    }\n\n    // Reduce the vector to a scalar minimum\n    int64_t result = global_min;\n    int64_t temp;\n    for (size_t i = 0; i < vlmax; ++i) {\n        temp = vget_v_i64m1_i64(v_global_min, i);\n        if (temp < result) {\n            result = temp;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_118_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    size_t vlmax = vsetvlmax_e64m1();\n    size_t n = nums.size();\n    int64_t global_min = nums[0];\n    int64_t current_min = nums[0];\n\n    for (size_t i = 1; i < n; i += vlmax) {\n        size_t vl = vsetvl_e64m1(n - i);\n\n        // Load the vector of elements\n        vint64m1_t vec = vle64_v_i64m1(nums.data() + i, vl);\n\n        // Compute prefix sums\n        vint64m1_t prefix_sum = vec;\n        vint64m1_t temp_sum = vec;\n        for (size_t j = 1; j < vl; ++j) {\n            temp_sum = vadd_vx_i64m1(temp_sum, nums[i + j], vl);\n            prefix_sum = vmin_vv_i64m1(prefix_sum, temp_sum, vl);\n        }\n\n        // Find the minimum value in the prefix sum\n        int64_t local_min = vmv_x_s_i64m1_i64(prefix_sum);\n        for (size_t j = 1; j < vl; ++j) {\n            local_min = std::min(local_min, nums[i + j]);\n        }\n\n        // Update current_min and global_min\n        current_min = std::min(current_min + nums[i], local_min);\n        global_min = std::min(global_min, current_min);\n    }\n\n    return global_min;\n}\n```"}
{"task_id": "SimdBench_118_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    size_t len = nums.size();\n    int64_t global_min = nums[0];\n    int64_t current_min = nums[0];\n\n    size_t vlmax = vsetvlmax_e64m1();\n    vint64m1_t v_global_min = vmv_s_x_i64m1(vundefined_i64m1(), global_min, vlmax);\n    vint64m1_t v_current_min = vmv_s_x_i64m1(vundefined_i64m1(), current_min, vlmax);\n\n    for (size_t i = 1; i < len; i += vlmax) {\n        size_t vl = vsetvl_e64m1(len - i);\n        vint64m1_t v_nums = vle64_v_i64m1(&nums[i], vl);\n\n        // Update current_min = min(nums[i], current_min + nums[i])\n        vint64m1_t v_current_plus_num = vadd_vv_i64m1(v_current_min, v_nums, vl);\n        v_current_min = vmin_vv_i64m1(v_nums, v_current_plus_num, vl);\n\n        // Update global_min = min(global_min, current_min)\n        v_global_min = vmin_vv_i64m1(v_global_min, v_current_min, vl);\n    }\n\n    // Reduce the vector to find the minimum value\n    int64_t result = global_min;\n    int64_t temp[vlmax];\n    vse64_v_i64m1(temp, v_global_min, vlmax);\n    for (size_t j = 0; j < vlmax && j < len; ++j) {\n        if (temp[j] < result) {\n            result = temp[j];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_118_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    size_t vlmax = vsetvlmax_e64m1();\n    int64_t global_min = nums[0];\n    int64_t current_min = nums[0];\n\n    for (size_t i = 0; i < nums.size(); i += vlmax) {\n        size_t vl = vsetvl_e64m1(nums.size() - i);\n\n        // Load vector of elements from nums\n        vint64m1_t vec = vle64_v_i64m1(&nums[i], vl);\n\n        // Initialize vectors for cumulative sum and minimum tracking\n        vint64m1_t cum_sum = vec;\n        vint64m1_t min_sum = vec;\n\n        // Iterate through the vector to compute min subarray sum using Kadane's algorithm\n        for (size_t j = 1; j < vl; ++j) {\n            vint64m1_t prev_sum = vslidedown_vx_i64m1(cum_sum, 1, vl);\n            cum_sum = vfadd_vv_i64m1(prev_sum, vec, vl);\n            min_sum = vfmin_vv_i64m1(min_sum, cum_sum, vl);\n        }\n\n        // Reduce the vector to find the minimum value in this segment\n        int64_t local_min = vmv_x_s_i64m1_i64(min_sum);\n        for (size_t j = 1; j < vl; ++j) {\n            min_sum = vfmin_vv_i64m1(min_sum, vslidedown_vx_i64m1(min_sum, j, vl), vl);\n        }\n        local_min = vmv_x_s_i64m1_i64(min_sum);\n\n        // Update global minimum\n        if (local_min < global_min) {\n            global_min = local_min;\n        }\n    }\n\n    return global_min;\n}\n```"}
{"task_id": "SimdBench_119_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint max_fill_simd(const std::vector<std::vector<int>> &grid, int capacity) {\n    size_t total_water = 0;\n    size_t row_size = grid[0].size();\n\n    for (const auto &row : grid) {\n        size_t i = 0;\n        size_t water_in_row = 0;\n\n        // Process the row using RVV intrinsics\n        while (i < row_size) {\n            size_t vl = __riscv_vsetvl_e8m1(row_size - i);\n            vuint8m1_t vec = __riscv_vle8_v_u8m1(&row[i], vl);\n\n            // Count the number of 1s in the vector\n            vbool8_t mask = __riscv_vmseq_vx_u8m1_b8(vec, 1, vl);\n            water_in_row += __riscv_vpopc_m_b8(mask, vl);\n\n            i += vl;\n        }\n\n        total_water += water_in_row;\n    }\n\n    // Calculate the number of bucket operations\n    return (total_water + capacity - 1) / capacity;\n}\n```"}
{"task_id": "SimdBench_119_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint max_fill_simd(const std::vector<std::vector<int>> &grid, int capacity) {\n    size_t total_water = 0;\n    size_t row_size = grid[0].size();\n\n    for (const auto &row : grid) {\n        size_t i = 0;\n        size_t water_in_row = 0;\n\n        // Process the row using RVV intrinsics\n        while (i < row_size) {\n            size_t vl = vsetvl_e8m1(row_size - i);\n            vuint8m1_t vec = vle8_v_u8m1(reinterpret_cast<const uint8_t*>(&row[i]), vl);\n\n            // Create a mask for values equal to 1\n            vbool8_t mask = vmseq_vx_u8m1_b8(vec, 1, vl);\n\n            // Count the number of 1s in the vector\n            water_in_row += vcpop_m_b8(mask, vl);\n\n            i += vl;\n        }\n\n        // Add the total water in this row to the overall total\n        total_water += water_in_row;\n    }\n\n    // Calculate the number of bucket operations needed\n    return (total_water + capacity - 1) / capacity;\n}\n```"}
{"task_id": "SimdBench_119_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint max_fill_simd(const std::vector<std::vector<int>> &grid, int capacity) {\n    size_t total_drops = 0;\n\n    for (const auto &row : grid) {\n        size_t row_size = row.size();\n        size_t i = 0;\n\n        while (i < row_size) {\n            size_t vl = __riscv_vsetvl_e32m8(row_size - i);\n            vuint32m8_t vec = __riscv_vle32_v_u32m8(&row[i], vl);\n\n            // Count the number of ones in the vector\n            vbool4_t mask = __riscv_vmseq_vx_u32m8_b4(vec, 1, vl);\n            size_t count = __riscv_vpopc_m_b4(mask, vl);\n\n            total_drops += count;\n            i += vl;\n        }\n    }\n\n    // Calculate the number of bucket operations\n    return (total_drops + capacity - 1) / capacity;\n}\n```"}
{"task_id": "SimdBench_119_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint max_fill_simd(const std::vector<std::vector<int>> &grid, int capacity) {\n    size_t total_water = 0;\n    size_t row_length = grid[0].size();\n\n    for (const auto &row : grid) {\n        size_t i = 0;\n        while (i < row_length) {\n            size_t vl = __riscv_vsetvl_e8m1(row_length - i);\n            vuint8m1_t vec = __riscv_vle8_v_u8m1(&row[i], vl);\n\n            // Count the number of 1s in the vector\n            vbool8_t mask = __riscv_vmseq_vx_u8m1_b8(vec, 1, vl);\n            total_water += __riscv_vpopc_m_b8(mask, vl);\n\n            i += vl;\n        }\n    }\n\n    // Calculate the number of bucket operations\n    return (total_water + capacity - 1) / capacity;\n}\n```"}
{"task_id": "SimdBench_119_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint max_fill_simd(const std::vector<std::vector<int>> &grid, int capacity) {\n    size_t total_water = 0;\n    size_t row_length = grid[0].size();\n\n    for (const auto &row : grid) {\n        size_t i = 0;\n        size_t row_sum = 0;\n\n        // Process the row using RVV intrinsics\n        while (i + vsetvlmax_e8m1() <= row_length) {\n            size_t vl = vsetvl_e8m1(row_length - i);\n            vuint8m1_t vec = vle8_v_u8m1(&row[i], vl);\n            vbool8_t mask = vmseq_vx_u8m1_b8(vec, 1, vl);\n            row_sum += vcpop_m_b8(mask, vl);\n            i += vl;\n        }\n\n        // Handle any remaining elements\n        while (i < row_length) {\n            row_sum += row[i];\n            i++;\n        }\n\n        total_water += row_sum;\n    }\n\n    return (total_water + capacity - 1) / capacity;\n}\n```"}
{"task_id": "SimdBench_120_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    size_t vlmax = vsetvlmax_e16m1();\n    int64_t sum = 0;\n    size_t n = lst.size();\n\n    for (size_t i = 0; i < n; i += vlmax) {\n        size_t vl = vsetvl_e16m1(n - i);\n\n        // Load vector of elements from memory\n        vint16m1_t vec = vle16_v_i16m1(lst.data() + i, vl);\n\n        // Create a mask for even positions (0-based index)\n        vbool16_t even_pos_mask = vmseq_vx_i16m1_b16(viota_v_u16m1(vl), 0, vl);\n\n        // Apply the mask to select elements at even positions\n        vint16m1_t even_pos_vals = vmerge_vvm_i16m1(even_pos_mask, vec, 0, vl);\n\n        // Check which elements are odd\n        vbool16_t odd_val_mask = vmnot_vx_i16m1_b16(veq_vx_i16m1(even_pos_vals, 0, vl), vl);\n\n        // Combine masks: only consider odd values in even positions\n        vbool16_t combined_mask = vmand_mm_b16(even_pos_mask, odd_val_mask, vl);\n\n        // Compress the vector to keep only the relevant elements\n        vint16m1_t filtered_vals = vcompress_vm_i16m1(combined_mask, even_pos_vals, vl);\n\n        // Widen and accumulate the results into a 64-bit sum\n        vint32m2_t widened_vals = vwadd_vx_i32m2(filtered_vals, 0, vl);\n        sum += vsum_vs_i32m2_i64m1(widened_vals, vl);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    size_t vlmax = vsetvlmax_e16m1();\n    int64_t sum = 0;\n    size_t n = lst.size();\n\n    for (size_t i = 0; i < n; i += vlmax) {\n        size_t vl = vsetvl_e16m1(n - i);\n\n        // Load vector of 16-bit integers\n        vint16m1_t vec = vle16_v_i16m1(lst.data() + i, vl);\n\n        // Create a mask for even positions (0-based index)\n        vbool16_t even_pos_mask = vmseq_vx_i16m1_b16(viota_v_u16m1(vl), 0, vl);\n\n        // Extract elements at even positions\n        vint16m1_t even_pos_vals = vcompress_vm_i16m1(even_pos_mask, vec, vl);\n\n        // Create a mask for odd values\n        vbool16_t odd_val_mask = vmnot_vx_i16m1_b16(veq_vx_i16m1(even_pos_vals, 0, vl));\n\n        // Compress to keep only odd values from even positions\n        vint16m1_t odd_in_even_vals = vcompress_vm_i16m1(odd_val_mask, even_pos_vals, vl);\n\n        // Widen and accumulate the results into a 64-bit integer\n        vint32m2_t widened_vals = vwadd_vx_i32m2(odd_in_even_vals, 0, vl);\n        sum += vsume_v_i32m2_i64(widened_vals, vl);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    size_t vlmax = vsetvlmax_e16m1();\n    int64_t sum = 0;\n    size_t i = 0;\n\n    for (; i + vlmax <= lst.size(); i += vlmax) {\n        vint16m1_t vec = vle16_v_i16m1(lst.data() + i, vlmax);\n        vbool16_t mask_even_pos = vmseq_vx_i16m1_b16(viota_v_u16m1(vundefined_u16m1(), vlmax), 0, vlmax);\n        vbool16_t mask_odd_val = vmnot_m_b16(vmseq_vx_i16m1_b16(vand_vx_i16m1(vec, 1, vlmax), 0, vlmax), vlmax);\n        vbool16_t mask_combined = vmand_mm_b16(mask_even_pos, mask_odd_val, vlmax);\n\n        vint16m1_t masked_vals = vcompress_vm_b16_i16m1(mask_combined, vec, vlmax);\n        sum += (int64_t)vredsum_vs_i16m1_i16m1(vundefined_i16m1(), masked_vals, 0, vlmax);\n    }\n\n    for (; i < lst.size(); ++i) {\n        if ((i % 2 == 0) && (lst[i] % 2 != 0)) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    size_t vlmax = vsetvlmax_e16m1();\n    int64_t sum = 0;\n    size_t i = 0;\n\n    for (; i + vlmax <= lst.size(); i += vlmax) {\n        vint16m1_t vec = vle16_v_i16m1(&lst[i], vlmax);\n        vbool16_t mask_even_pos = vmseq_vx_i16m1_b16(viota_v_u16m1(vundefined_u16m1(), vlmax), 0, vlmax);\n        vbool16_t mask_odd_val = vmsodd_v_i16m1_b16(vec, vlmax);\n        vbool16_t combined_mask = vmand_mm_b16(mask_even_pos, mask_odd_val, vlmax);\n        vint16m1_t masked_vals = vmerge_vxm_i16m1(vec, 0, combined_mask, vlmax);\n        sum += vwredsum_vs_i16m1_i64m1(vundefined_i64m1(), masked_vals, vlmax);\n    }\n\n    for (; i < lst.size(); ++i) {\n        if ((i % 2 == 0) && (lst[i] % 2 != 0)) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    size_t vlmax = __riscv_vsetvlmax_e16m1();\n    int64_t sum = 0;\n    size_t n = lst.size();\n\n    for (size_t i = 0; i < n; i += vlmax) {\n        size_t vl = __riscv_vsetvl_e16m1(n - i);\n\n        // Load vector of elements from memory\n        vint16m1_t vec = __riscv_vle16_v_i16m1(lst.data() + i, vl);\n\n        // Create a mask for even positions (0-based index)\n        vbool16_t even_pos_mask = __riscv_vmseq_vx_i16m1_b16(__riscv_vid_v_i16m1(vl), 0, vl);\n\n        // Apply the even position mask to select elements at even indices\n        vint16m1_t even_pos_elements = __riscv_vcompress_vm_i16m1(vec, even_pos_mask, vl);\n\n        // Check which elements are odd\n        vbool16_t odd_mask = __riscv_vmnot_vx_i16m1_b16(__riscv_vmand_vx_i16m1(even_pos_elements, 1, vl), vl);\n\n        // Compress the odd elements from even positions\n        vint16m1_t odd_elements = __riscv_vcompress_vm_i16m1(even_pos_elements, odd_mask, vl);\n\n        // Perform a reduction sum on the odd elements\n        vint32m2_t widened_odd_elements = __riscv_vwadd_vx_i32m2(odd_elements, 0, vl);\n        vint32m1_t reduced_sum = __riscv_vredsum_vs_i32m2_i32m1(widened_odd_elements, __riscv_vmv_v_x_i32m1(0, vl), vl);\n\n        // Accumulate the result into the scalar sum\n        sum += __riscv_vmv_x_s_i32m1_i32(reduced_sum);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    size_t vlmax = vsetvlmax_e32m8();\n    size_t vl;\n\n    for (size_t i = 0; i < k; i += vl) {\n        vl = vsetvl_e32m8(k - i);\n\n        vint32m8_t vec = vle32_v_i32m8(&arr[i], vl);\n        vbool4_t mask = vmflt_vx_i32m8_b4(vec, 100, vl);\n        mask = vmfge_vx_i32m8_b4(vec, -100, vl) & mask;\n\n        vint32m8_t masked_values = vcompress_vm_i32m8(mask, vec, vl);\n        sum += vsum_vs_i32m8_i32(masked_values, vl);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    size_t vlmax = vsetvlmax_e32m8();\n    size_t vl;\n\n    for (size_t i = 0; i < k; i += vl) {\n        vl = vsetvl_e32m8(k - i);\n\n        vint32m8_t vec = vle32_v_i32m8(&arr[i], vl);\n        vbool4_t mask = vmflt_vx_i32m8_b4(vec, 100, vl);\n        mask = vmfge_vx_i32m8_b4_m(mask, vec, -100, vl);\n\n        vint32m8_t masked_values = vmerge_vxm_i32m8(vec, 0, mask, vl);\n        sum += vredsum_vs_i32m8_i32m1(vsetvl_e32m1(1), masked_values, 0, vl);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    size_t vlmax = vsetvlmax_e32m8();\n    size_t vl;\n\n    for (size_t i = 0; i < k; i += vl) {\n        vl = vsetvl_e32m8(k - i);\n\n        vint32m8_t vec = vle32_v_i32m8(&arr[i], vl);\n        vbool4_t mask = vmflt_vx_i32m8_b4(vec, 100, vl);\n        mask = vmfge_vx_i32m8_b4_m(mask, vec, -100, vl);\n\n        vint32m8_t masked_values = vmerge_vxm_i32m8(vec, 0, mask, vl);\n        sum += vredsum_vs_i32m8_i32m1(vsetvl_e32m1(1), masked_values, 0, vl);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    size_t vlmax = vsetvlmax_e32m8();\n    size_t vl;\n\n    for (size_t i = 0; i < k; i += vl) {\n        vl = vsetvl_e32m8(k - i);\n\n        vint32m8_t vec = vle32_v_i32m8(&arr[i], vl);\n        vbool4_t mask = vmflt_vx_i32m8_b4(vec, 100, vl);\n        mask = vmfge_vx_i32m8_b4_m(mask, vec, -100, vl);\n\n        vint32m8_t masked_vec = vcompress_vm_i32m8(mask, vec, vl);\n        sum += vsum_vs_i32m8_i32m1(masked_vec, vl);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    size_t vlmax = vsetvlmax_e32m8();\n    size_t vl;\n\n    for (size_t i = 0; i < k; i += vl) {\n        vl = vsetvl_e32m8(k - i);\n\n        vint32m8_t vec = vle32_v_i32m8(&arr[i], vl);\n        vbool4_t mask = vmflt_vx_i32m8_b4(vec, 100, vl);\n        mask = vmfle_vx_i32m8_b4(vec, -100, vl) & mask;\n\n        vint32m8_t masked_vec = vcompress_vm_i32m8(mask, vec, vl);\n        sum += vsum_vs_i32m8_i32(masked_vec, vl);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_122_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    size_t vlmax = vsetvlmax_e32m8();\n    size_t n = lst.size();\n    if (n <= 1) return true;\n\n    const int *data = lst.data();\n    bool sorted = true;\n    bool duplicate = false;\n\n    for (size_t i = 0; i < n - 1; i += vlmax) {\n        size_t vl = vsetvl_e32m8(n - i - 1);\n\n        vint32m8_t vec_curr = vle32_v_i32m8(&data[i], vl);\n        vint32m8_t vec_next = vle32_v_i32m8(&data[i + 1], vl);\n\n        // Check if current > next (not sorted)\n        vbool4_t cmp_sorted = vmseq_vv_i32m8_b4(vec_curr, vec_next);\n        sorted &= !vmreduce_any_true_b4(cmp_sorted, vl);\n\n        // Check for duplicates\n        vbool4_t cmp_duplicate = vmseq_vv_i32m8_b4(vec_curr, vec_next);\n        duplicate |= vmreduce_any_true_b4(cmp_duplicate, vl);\n    }\n\n    return sorted && !duplicate;\n}\n```"}
{"task_id": "SimdBench_122_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    size_t len = lst.size();\n    if (len <= 1) return true;\n\n    size_t vl;\n    size_t i = 0;\n    bool sorted = true;\n    bool duplicate = false;\n\n    for (; i + vsetvlmax_e32m8() <= len; i += vl) {\n        vl = vsetvl_e32m8(len - i);\n\n        vint32m8_t vec = vle32_v_i32m8(&lst[i], vl);\n        vint32m8_t vec_next = vle32_v_i32m8(&lst[i + 1], vl - 1);\n\n        vbool4_t cmp_sorted = vmseq_vv_i32m8_b4(vec, vec_next);\n        vbool4_t cmp_duplicate = vmseq_vv_i32m8_b4(vec, vslidedown_vx_i32m8(vec, 1));\n\n        sorted &= !vmreduce_any_true_b4(cmp_sorted, vl);\n        duplicate |= vmreduce_any_true_b4(cmp_duplicate, vl);\n    }\n\n    for (; i < len - 1; ++i) {\n        if (lst[i] > lst[i + 1]) {\n            sorted = false;\n        }\n        if (lst[i] == lst[i + 1]) {\n            duplicate = true;\n        }\n    }\n\n    return sorted && !duplicate;\n}\n```"}
{"task_id": "SimdBench_122_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    size_t vlmax = vsetvlmax_e32m8();\n    size_t n = lst.size();\n    if (n <= 1) return true;\n\n    const int *data = lst.data();\n    bool sorted = true;\n    bool duplicate = false;\n\n    for (size_t i = 0; i < n - 1; i += vlmax) {\n        size_t vl = vsetvl_e32m8(n - i - 1);\n\n        vint32m8_t vec_current = vle32_v_i32m8(&data[i], vl);\n        vint32m8_t vec_next = vle32_v_i32m8(&data[i + 1], vl);\n\n        // Check if current > next (not sorted)\n        vbool4_t cmp_sorted = vmseq_vv_i32m8_b4(vec_current, vec_next, vl);\n        sorted &= !vmreduce_any_true_b4(cmp_sorted, vl);\n\n        // Check for duplicates\n        vbool4_t cmp_duplicate = vmseq_vv_i32m8_b4(vec_current, vec_next, vl);\n        duplicate |= vmreduce_any_true_b4(cmp_duplicate, vl);\n    }\n\n    return sorted && !duplicate;\n}\n```"}
{"task_id": "SimdBench_122_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    size_t vlmax = vsetvlmax_e32m8();\n    size_t n = lst.size();\n    if (n <= 1) return true;\n\n    const int *data = lst.data();\n    bool sorted = true;\n    bool duplicate = false;\n\n    for (size_t i = 0; i < n - 1; i += vlmax) {\n        size_t vl = vsetvl_e32m8(n - i - 1);\n\n        vint32m8_t vec_current = vle32_v_i32m8(&data[i], vl);\n        vint32m8_t vec_next = vle32_v_i32m8(&data[i + 1], vl);\n\n        // Check if current > next (not sorted)\n        vbool4_t cmp_sorted = vmseq_vv_i32m8_b4(vec_current, vec_next);\n        sorted &= !vmreduce_any_true_b4(cmp_sorted, vl);\n\n        // Check for duplicates\n        vbool4_t cmp_duplicate = vmseq_vv_i32m8_b4(vec_current, vec_next);\n        duplicate |= vmreduce_any_true_b4(cmp_duplicate, vl);\n    }\n\n    return sorted && !duplicate;\n}\n```"}
{"task_id": "SimdBench_122_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    size_t vlmax = vsetvlmax_e32m8();\n    size_t n = lst.size();\n    if (n <= 1) return true;\n\n    const int *data = lst.data();\n    bool sorted = true;\n    bool duplicate = false;\n\n    for (size_t i = 0; i < n - 1; i += vlmax) {\n        size_t vl = vsetvl_e32m8(n - i - 1);\n\n        vint32m8_t vec_current = vle32_v_i32m8(&data[i], vl);\n        vint32m8_t vec_next = vle32_v_i32m8(&data[i + 1], vl);\n\n        // Check if current > next (not sorted)\n        vbool4_t cmp_sorted = vmseq_vv_i32m8_b4(vec_current, vec_next);\n        sorted &= !vmreduce_any_true_b4(cmp_sorted, vl);\n\n        // Check for duplicates\n        vbool4_t cmp_duplicate = vmseq_vv_i32m8_b4(vec_current, vec_next);\n        duplicate |= vmreduce_any_true_b4(cmp_duplicate, vl);\n    }\n\n    return sorted && !duplicate;\n}\n```"}
{"task_id": "SimdBench_123_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    size_t vlmax = vsetvlmax_e32m8();\n    size_t len = arr.size();\n    const int *data = arr.data();\n\n    int sum_magnitude = 0;\n    int product_sign = 1;\n\n    size_t i = 0;\n    while (i < len) {\n        size_t vl = vsetvl_e32m8(len - i);\n\n        vint32m8_t vec = vle32_v_i32m8(data + i, vl);\n\n        // Compute magnitudes\n        vbool4_t mask_positive = vmflt_vx_i32m8_b4(vec, 0, vl);\n        vbool4_t mask_negative = vmflt_vx_i32m8_b4(vneg_v_i32m8(vec, vl), 0, vl);\n        vint32m8_t magnitude = vabs_v_i32m8(vec, vl);\n\n        // Sum magnitudes horizontally\n        vint32m1_t sum_vec = vmv_v_x_i32m1(0, vlmax);\n        sum_vec = vwredsum_vs_i32m8_i32m1(sum_vec, magnitude, vl);\n\n        // Extract the reduced sum\n        int temp_sum = vmv_x_s_i32m1_i32(sum_vec);\n        sum_magnitude += temp_sum;\n\n        // Compute product of signs\n        vint32m8_t sign = vsub_vx_i32m8(vec, 0, vl);\n        vbool4_t zero_mask = vmseq_vx_i32m8_b4(vec, 0, vl);\n        if (vmfirst_m_b4(zero_mask, vl)) {\n            product_sign = 0;\n            break;\n        }\n\n        vint32m8_t neg_mask = vmflt_vx_i32m8(vec, 0, vl);\n        int neg_count = vcpop_m_b4(neg_mask, vl);\n        if (neg_count % 2 != 0) {\n            product_sign *= -1;\n        }\n\n        i += vl;\n    }\n\n    return product_sign * sum_magnitude;\n}\n```"}
{"task_id": "SimdBench_123_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    size_t len = arr.size();\n    int sum_magnitude = 0;\n    int product_sign = 1;\n\n    size_t vl;\n    vint32m8_t vec, signs, magnitudes;\n    vbool4_t mask;\n\n    for (size_t i = 0; i < len; i += vl) {\n        vl = vsetvl_e32m8(len - i);\n\n        // Load vector of integers\n        vec = vle32_v_i32m8(arr.data() + i, vl);\n\n        // Compute sign of each element (-1, 0, or 1)\n        signs = vmslt_vx_i32m8(vec, 0, vl);          // -1 for negative numbers\n        signs = vadd_vx_i32m8(signs, 1, vl);         // 0 for negative numbers, 1 otherwise\n        signs = vmerge_vxm_i32m8(signs, 0, vmseq_vx_i32m8(vec, 0, vl), vl); // 0 for zero elements\n\n        // Compute magnitude of each element\n        magnitudes = vabs_v_i32m8(vec, vl);\n\n        // Reduce sum of magnitudes\n        sum_magnitude += vsum_vs_i32m8_i32m1(magnitudes, vl);\n\n        // Update product of signs\n        for (size_t j = 0; j < vl; ++j) {\n            int sign_val = ((int32_t*)&signs)[j];\n            if (sign_val == 0) {\n                product_sign = 0;\n                break;\n            }\n            product_sign *= sign_val;\n        }\n        if (product_sign == 0) break;\n    }\n\n    return sum_magnitude * product_sign;\n}\n```"}
{"task_id": "SimdBench_123_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    size_t vlmax = vsetvlmax_e32m8();\n    size_t len = arr.size();\n    int sum_magnitude = 0;\n    int product_sign = 1;\n\n    for (size_t i = 0; i < len; i += vlmax) {\n        size_t vl = vsetvl_e32m8(len - i);\n\n        // Load vector of integers\n        vint32m8_t vec = vle32_v_i32m8(&arr[i], vl);\n\n        // Compute magnitudes\n        vbool4_t mask_positive = vmflt_vx_i32m8_b4(vec, 0, vl);\n        vbool4_t mask_negative = vmflt_vx_i32m8_b4(vneg_v_i32m8(vec, vl), 0, vl);\n        vint32m8_t magnitude = vabs_v_i32m8(vec, vl);\n\n        // Sum magnitudes horizontally\n        vint32m1_t sum_vec = vmv_v_x_i32m1(0, vl);\n        sum_vec = vwredsum_vs_i32m8_i32m1(sum_vec, magnitude, vl);\n        sum_magnitude += vmv_x_s_i32m1_i32(sum_vec);\n\n        // Determine sign contributions\n        vint32m8_t signs = vsub_vx_i32m8(vec, 0, vl);\n        vbool4_t zero_mask = vmseq_vx_i32m8_b4(vec, 0, vl);\n        product_sign *= (vmfirst_true_b4(zero_mask, vl)) ? 0 : 1;\n        product_sign *= (vmfirst_true_b4(mask_negative, vl)) ? -1 : 1;\n    }\n\n    return sum_magnitude * product_sign;\n}\n```"}
{"task_id": "SimdBench_123_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    size_t vlmax = vsetvlmax_e32m8();\n    size_t len = arr.size();\n    const int *data = arr.data();\n\n    int sum_magnitude = 0;\n    int product_sign = 1;\n\n    size_t i = 0;\n    while (i < len) {\n        size_t vl = vsetvl_e32m8(len - i);\n\n        vint32m8_t vec = vle32_v_i32m8(data + i, vl);\n\n        // Compute magnitudes\n        vbool4_t mask_positive = vmflt_vx_i32m8_b4(vec, 0, vl);\n        vbool4_t mask_negative = vmflt_vx_i32m8_b4(vneg_v_i32m8(vec, vl), 0, vl);\n        vint32m8_t magnitude = vabs_v_i32m8(vec, vl);\n\n        // Sum magnitudes horizontally\n        vint32m1_t sum_vec = vmv_v_x_i32m1(0, vlmax);\n        sum_vec = vwredsum_vs_i32m8_i32m1(sum_vec, magnitude, vl);\n\n        // Extract the reduced sum\n        int temp_sum = vmv_x_s_i32m1_i32(sum_vec);\n        sum_magnitude += temp_sum;\n\n        // Compute product of signs\n        vint32m8_t sign = vsub_vx_i32m8(vec, 0, vl);\n        vbool4_t zero_mask = vmseq_vx_i32m8_b4(vec, 0, vl);\n        if (vmfirst_m_b4(zero_mask, vl)) {\n            product_sign = 0;\n            break;\n        }\n\n        vint32m8_t neg_mask = vmflt_vx_i32m8(vec, 0, vl);\n        int neg_count = vcpop_m_b4(neg_mask, vl);\n        if (neg_count % 2 != 0) {\n            product_sign *= -1;\n        }\n\n        i += vl;\n    }\n\n    return product_sign * sum_magnitude;\n}\n```"}
{"task_id": "SimdBench_123_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    size_t len = arr.size();\n    int sum_magnitude = 0;\n    int product_sign = 1;\n\n    size_t vl;\n    vint32m8_t vec, signs, magnitudes;\n    vbool4_t mask;\n\n    for (size_t i = 0; i < len; i += vl) {\n        vl = vsetvl_e32m8(len - i);\n\n        // Load vector of integers\n        vec = vle32_v_i32m8(arr.data() + i, vl);\n\n        // Compute sign of each element (-1, 0, or 1)\n        signs = vmslt_vx_i32m8(vec, 0, vl);          // -1 for negative numbers\n        signs = vadd_vx_i32m8(signs, 1, vl);         // 0 for negative numbers, 1 otherwise\n        signs = vmerge_vxm_i32m8(signs, 0, vmseq_vx_i32m8(vec, 0, vl), vl); // 0 for zero elements\n\n        // Compute magnitude of each element\n        magnitudes = vabs_v_i32m8(vec, vl);\n\n        // Reduce sum of magnitudes\n        sum_magnitude += vsum_vs_i32m8_i32m1(magnitudes, vl);\n\n        // Update product of signs\n        for (size_t j = 0; j < vl; ++j) {\n            int sign_val = ((int32_t*)&signs)[j];\n            if (sign_val == 0) {\n                product_sign = 0;\n                break;\n            }\n            product_sign *= sign_val;\n        }\n        if (product_sign == 0) break;\n    }\n\n    return sum_magnitude * product_sign;\n}\n```"}
{"task_id": "SimdBench_124_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>> &grid, int k) {\n    size_t N = grid.size();\n    std::vector<int> result(k, 0);\n    std::vector<int> current_path(k, 0);\n    std::vector<int> best_path(k, 0);\n\n    // Initialize best_path with maximum possible values\n    for (int i = 0; i < k; ++i) {\n        best_path[i] = N * N + 1;\n    }\n\n    // Lambda function to update the best path using RVV intrinsics\n    auto update_best_path = [&](const std::vector<int>& current_path) {\n        size_t vl;\n        bool is_less = false;\n\n        for (size_t i = 0; i < k; i += vl) {\n            vl = __riscv_vsetvl_e32m8(k - i);\n\n            vint32m8_t v_current = __riscv_vle32_v_i32m8(&current_path[i], vl);\n            vint32m8_t v_best = __riscv_vle32_v_i32m8(&best_path[i], vl);\n\n            vbool4_t v_cmp = __riscv_vmseq_vv_i32m8_b4(v_current, v_best, vl);\n\n            // Check if current_path is lexicographically less than best_path\n            if (!__riscv_vmandn_b4(v_cmp, vl)) {\n                is_less = true;\n                break;\n            }\n        }\n\n        if (is_less) {\n            best_path = current_path;\n        }\n    };\n\n    // Recursive DFS-like function to explore all paths of length k\n    std::function<void(int, int, int)> dfs = [&](int x, int y, int step) {\n        if (step == k) {\n            update_best_path(current_path);\n            return;\n        }\n\n        static const int dx[4] = {0, 1, 0, -1};\n        static const int dy[4] = {1, 0, -1, 0};\n\n        for (int dir = 0; dir < 4; ++dir) {\n            int nx = x + dx[dir];\n            int ny = y + dy[dir];\n\n            if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n                current_path[step] = grid[nx][ny];\n                dfs(nx, ny, step + 1);\n            }\n        }\n    };\n\n    // Start DFS from every cell in the grid\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            current_path[0] = grid[i][j];\n            dfs(i, j, 1);\n        }\n    }\n\n    return best_path;\n}\n```"}
{"task_id": "SimdBench_124_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>> &grid, int k) {\n    size_t N = grid.size();\n    std::vector<int> result(k, 0);\n    std::vector<std::vector<int>> paths;\n    std::vector<int> temp_path;\n\n    // Helper function to generate all paths of length k\n    auto dfs = [&](auto &&dfs, int x, int y, int steps) -> void {\n        if (steps == k) {\n            paths.push_back(temp_path);\n            return;\n        }\n        static const int dir[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        for (int d = 0; d < 4; ++d) {\n            int nx = x + dir[d][0], ny = y + dir[d][1];\n            if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n                temp_path.push_back(grid[nx][ny]);\n                dfs(dfs, nx, ny, steps + 1);\n                temp_path.pop_back();\n            }\n        }\n    };\n\n    // Generate all possible paths starting from each cell\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            temp_path = {grid[i][j]};\n            dfs(dfs, i, j, 1);\n        }\n    }\n\n    // Use RVV to perform parallel lexicographical comparison\n    size_t num_paths = paths.size();\n    size_t path_len = k;\n    size_t vlmax = vsetvlmax_e32m8(); // Set vector length for int32\n    bool found_min = false;\n\n    for (size_t i = 0; i < num_paths; i += vlmax) {\n        size_t vl = vsetvl_e32m8(std::min(vlmax, num_paths - i));\n        vint32m8_t min_vec = vmv_v_x_i32m8(0, vl); // Initialize min vector\n\n        for (size_t j = 0; j < path_len; ++j) {\n            vint32m8_t current_min = vmv_v_x_i32m8(INT32_MAX, vl);\n            for (size_t p = 0; p < vl; ++p) {\n                size_t idx = i + p;\n                if (idx < num_paths) {\n                    vint32m8_t path_val = vle32_v_i32m8(&paths[idx][j], vl);\n                    current_min = vmin_vv_i32m8(current_min, path_val, vl);\n                }\n            }\n            min_vec = current_min;\n        }\n\n        // Find the index of the minimum path in this vector group\n        for (size_t p = 0; p < vl; ++p) {\n            size_t idx = i + p;\n            if (idx < num_paths && !found_min) {\n                bool is_min = true;\n                for (size_t j = 0; j < path_len; ++j) {\n                    if (paths[idx][j] != result[j]) {\n                        is_min = false;\n                        break;\n                    }\n                }\n                if (is_min) {\n                    result = paths[idx];\n                    found_min = true;\n                }\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_124_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>> &grid, int k) {\n    size_t N = grid.size();\n    std::vector<int> result(k, 0);\n    std::vector<std::vector<int>> dp_prev(N, std::vector<int>(N, 0));\n    std::vector<std::vector<int>> dp_curr(N, std::vector<int>(N, 0));\n\n    // Initialize DP for the first step\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            dp_prev[i][j] = grid[i][j];\n        }\n    }\n\n    for (int step = 1; step < k; ++step) {\n        for (size_t i = 0; i < N; ++i) {\n            for (size_t j = 0; j < N; ++j) {\n                int min_val = dp_prev[i][j];\n                if (i > 0) min_val = std::min(min_val, dp_prev[i - 1][j]);\n                if (i < N - 1) min_val = std::min(min_val, dp_prev[i + 1][j]);\n                if (j > 0) min_val = std::min(min_val, dp_prev[i][j - 1]);\n                if (j < N - 1) min_val = std::min(min_val, dp_prev[i][j + 1]);\n                dp_curr[i][j] = min_val + grid[i][j];\n            }\n        }\n        dp_prev.swap(dp_curr);\n    }\n\n    // Find the minimum path\n    int min_val = dp_prev[0][0];\n    size_t min_i = 0, min_j = 0;\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            if (dp_prev[i][j] < min_val) {\n                min_val = dp_prev[i][j];\n                min_i = i;\n                min_j = j;\n            }\n        }\n    }\n\n    // Reconstruct the path\n    size_t i = min_i, j = min_j;\n    for (int step = k - 1; step >= 0; --step) {\n        result[step] = grid[i][j];\n        int next_min = grid[i][j];\n        size_t next_i = i, next_j = j;\n\n        if (i > 0 && dp_prev[i - 1][j] + grid[i][j] == dp_prev[i][j]) {\n            next_i = i - 1;\n        } else if (i < N - 1 && dp_prev[i + 1][j] + grid[i][j] == dp_prev[i][j]) {\n            next_i = i + 1;\n        } else if (j > 0 && dp_prev[i][j - 1] + grid[i][j] == dp_prev[i][j]) {\n            next_j = j - 1;\n        } else if (j < N - 1 && dp_prev[i][j + 1] + grid[i][j] == dp_prev[i][j]) {\n            next_j = j + 1;\n        }\n\n        i = next_i;\n        j = next_j;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_124_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>> &grid, int k) {\n    size_t N = grid.size();\n    std::vector<int> result(k, 0);\n    std::vector<std::vector<int>> paths;\n    std::vector<int> temp_path;\n\n    // Helper function to generate all paths of length k\n    auto dfs = [&](auto &&dfs, int x, int y, int steps) -> void {\n        if (steps == k) {\n            paths.push_back(temp_path);\n            return;\n        }\n        static const int dx[] = {0, 1, 0, -1};\n        static const int dy[] = {1, 0, -1, 0};\n        for (int dir = 0; dir < 4; ++dir) {\n            int nx = x + dx[dir], ny = y + dy[dir];\n            if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n                temp_path.push_back(grid[nx][ny]);\n                dfs(dfs, nx, ny, steps + 1);\n                temp_path.pop_back();\n            }\n        }\n    };\n\n    // Generate all possible paths starting from each cell\n    for (size_t i = 0; i < N; ++i) {\n        for (size_t j = 0; j < N; ++j) {\n            temp_path = {grid[i][j]};\n            dfs(dfs, i, j, 1);\n        }\n    }\n\n    // Use RVV to find the lexicographically smallest path\n    size_t num_paths = paths.size();\n    size_t path_len = paths[0].size();\n    size_t vlmax = vsetvlmax_e32m8(); // Set vector length for 32-bit integers\n\n    // Initialize result with the first path\n    for (size_t i = 0; i < path_len; ++i) {\n        result[i] = paths[0][i];\n    }\n\n    // Compare all paths in parallel using RVV\n    for (size_t p = 1; p < num_paths; ++p) {\n        bool is_smaller = false;\n        size_t i = 0;\n\n        while (i < path_len) {\n            size_t vl = vsetvl_e32m8(path_len - i); // Set vector length dynamically\n            vint32m8_t v_result = vle32_v_i32m8(&result[i], vl); // Load current result\n            vint32m8_t v_candidate = vle32_v_i32m8(&paths[p][i], vl); // Load candidate path\n\n            // Compare vectors element-wise\n            vbool4_t v_cmp = vmseq_vv_i32m8_b4(v_result, v_candidate, vl); // Equality comparison\n            vbool4_t v_lt = vmslt_vv_i32m8_b4(v_result, v_candidate, vl); // Less-than comparison\n\n            // Check if any element is smaller or not equal\n            if (vfirst_m_b4(v_cmp, vl) == -1 || vfirst_m_b4(v_lt, vl) != -1) {\n                is_smaller = true;\n                break;\n            }\n\n            i += vl;\n        }\n\n        // Update result if the current path is lexicographically smaller\n        if (is_smaller) {\n            for (size_t j = 0; j < path_len; ++j) {\n                result[j] = paths[p][j];\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_124_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>> &grid, int k) {\n    size_t N = grid.size();\n    std::vector<int> result(k, 0);\n    std::vector<int> current_path(k, 0);\n    std::vector<int> best_path(k, 0);\n\n    // Initialize best_path with maximum possible values\n    for (int i = 0; i < k; ++i) {\n        best_path[i] = N * N + 1;\n    }\n\n    // Lambda to update the best path using RVV intrinsics\n    auto update_best_path = [&](const std::vector<int>& current_path) {\n        size_t vl;\n        bool is_less = false;\n        size_t i = 0;\n\n        // Compare paths using RVV intrinsics\n        for (i = 0; i < k; i += vl) {\n            vl = __riscv_vsetvl_e32m8(k - i);\n            vint32m8_t v_current = __riscv_vle32_v_i32m8(&current_path[i], vl);\n            vint32m8_t v_best = __riscv_vle32_v_i32m8(&best_path[i], vl);\n            vbool4_t v_cmp = __riscv_vmseq_vv_i32m8_b4(v_current, v_best, vl);\n\n            // Check if current path is lexicographically smaller\n            if (__riscv_vfirst_m_b4(v_cmp, vl) != -1) {\n                is_less = true;\n                break;\n            }\n        }\n\n        // If current path is better, copy it to best_path\n        if (is_less) {\n            for (i = 0; i < k; i += vl) {\n                vl = __riscv_vsetvl_e32m8(k - i);\n                vint32m8_t v_current = __riscv_vle32_v_i32m8(&current_path[i], vl);\n                __riscv_vse32_v_i32m8(&best_path[i], v_current, vl);\n            }\n        }\n    };\n\n    // Explore all possible paths of length k\n    for (size_t start_row = 0; start_row < N; ++start_row) {\n        for (size_t start_col = 0; start_col < N; ++start_col) {\n            // Initialize the first element of the path\n            current_path[0] = grid[start_row][start_col];\n\n            // Use a recursive or iterative approach to explore paths\n            // For simplicity, assume a depth-first search (DFS) here\n            // Implement DFS with stack or recursion to generate paths\n            // Update current_path during DFS traversal\n\n            // After generating a valid path of length k, update the best path\n            update_best_path(current_path);\n        }\n    }\n\n    return best_path;\n}\n```"}
{"task_id": "SimdBench_125_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nuint64_t digits_simd(uint64_t n) {\n    uint64_t result = 1;\n    bool has_odd = false;\n\n    size_t vlmax = vsetvlmax_e8m1();\n    vuint8m1_t v_zero = vmv_v_x_u8m1(0, vlmax);\n    vuint8m1_t v_one = vmv_v_x_u8m1(1, vlmax);\n    vuint8m1_t v_ten = vmv_v_x_u8m1(10, vlmax);\n\n    while (n > 0) {\n        size_t vl = vsetvl_e8m1(vlmax);\n        vuint8m1_t v_digits = vmv_v_x_u8m1(0, vl);\n\n        // Load digits into vector\n        uint64_t temp = n;\n        for (size_t i = 0; i < vl; ++i) {\n            if (temp == 0) break;\n            uint8_t digit = temp % 10;\n            vse8_v_u8m1(&v_digits, i, digit);\n            temp /= 10;\n        }\n\n        // Check for odd digits and compute product\n        vbool8_t v_is_odd = vmsne_vx_u8m1_b8(v_digits, v_digits & v_one, vl);\n        vuint8m1_t v_odd_digits = vcompress_vm_u8m1(v_is_odd, v_digits, vl);\n        vuint8m1_t v_product = vmul_vv_u8m1(v_odd_digits, v_odd_digits, vl);\n\n        // Reduce product to scalar\n        uint64_t product = 1;\n        for (size_t i = 0; i < vl; ++i) {\n            uint8_t digit = vle8_v_u8m1(&v_product, i);\n            if (digit != 0) {\n                product *= digit;\n                has_odd = true;\n            }\n        }\n\n        result *= product;\n        n /= pow(10, vl);\n    }\n\n    return has_odd ? result : 0;\n}\n```"}
{"task_id": "SimdBench_125_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nuint64_t digits_simd(uint64_t n) {\n    uint64_t result = 1;\n    bool has_odd = false;\n\n    size_t vlmax = vsetvlmax_e8m1();\n    vuint8m1_t v_zero = vmv_v_x_u8m1(0, vlmax);\n    vuint8m1_t v_one = vmv_v_x_u8m1(1, vlmax);\n    vuint8m1_t v_ten = vmv_v_x_u8m1(10, vlmax);\n\n    while (n > 0) {\n        size_t vl = vsetvl_e8m1(n > 0 ? 1 : 0);\n        if (vl == 0) break;\n\n        // Load the current digit\n        uint8_t digit = n % 10;\n        vuint8m1_t v_digit = vmv_v_x_u8m1(digit, vl);\n\n        // Check if the digit is odd\n        vbool8_t v_is_odd = vmsne_vx_u8m1_b8(v_digit, v_digit & v_one, vl);\n\n        // Mask to select only odd digits\n        vuint8m1_t v_odd_digits = vmerge_vxm_u8m1(v_zero, v_digit, v_is_odd, vl);\n\n        // Compute product of odd digits\n        vuint8m1_t v_product = vmul_vx_u8m1(v_odd_digits, 1, vl);\n\n        // Reduce the product\n        uint8_t odd_product = vget_u8m1(v_product, 0);\n        if (odd_product != 0) {\n            result *= odd_product;\n            has_odd = true;\n        }\n\n        n /= 10;\n    }\n\n    return has_odd ? result : 0;\n}\n```"}
{"task_id": "SimdBench_125_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t digits_simd(uint64_t n) {\n    uint64_t product = 1;\n    uint64_t has_odd = 0;\n\n    size_t vlmax = vsetvlmax_e8m1();\n    vuint8m1_t v_zero = vmv_v_x_u8m1(0, vlmax);\n    vuint8m1_t v_product = vmv_v_x_u8m1(1, vlmax);\n\n    while (n > 0) {\n        size_t vl = vsetvl_e8m1(n > 0 ? 1 : 0);\n        if (vl == 0) break;\n\n        // Load the next digit\n        uint8_t digit = n % 10;\n        n /= 10;\n\n        // Broadcast the digit to a vector\n        vuint8m1_t v_digit = vmv_v_x_u8m1(digit, vl);\n\n        // Check if the digit is odd\n        vbool8_t v_is_odd = vmsne_vx_u8m1_b8(v_digit, 0, vl);\n        v_is_odd = vmseq_vx_u8m1_b8(vand_vx_u8m1(v_digit, 1, vl), 1, vl);\n\n        // Update the product for odd digits\n        v_product = vwmul_vv_u8m1(v_product, v_digit, vl);\n\n        // Track if we have encountered any odd digit\n        has_odd |= vmv_x_s_u8m1_b8(v_any_true(v_is_odd, vl));\n    }\n\n    // Reduce the vector product to a scalar\n    product = vmv_x_s_u8m1_u8(v_product);\n\n    return has_odd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_125_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nuint64_t digits_simd(uint64_t n) {\n    size_t vl;\n    uint64_t result = 1;\n    uint64_t all_even = 1;\n\n    // Convert the number to a vector of digits\n    uint8_t digits[20];\n    int num_digits = 0;\n    while (n > 0) {\n        digits[num_digits++] = n % 10;\n        n /= 10;\n    }\n\n    // Initialize vector registers\n    vuint8m1_t v_odd_mask = vmv_v_x_u8m1(1, 1); // Odd mask (1 for odd digits)\n    vuint8m1_t v_zero = vmv_v_x_u8m1(0, 1);    // Zero vector\n    vuint8m1_t v_one = vmv_v_x_u8m1(1, 1);     // One vector\n\n    // Process digits in parallel using RVV intrinsics\n    for (int i = 0; i < num_digits; i += vl) {\n        vl = vsetvl_e8m1(num_digits - i);\n\n        // Load digits into a vector\n        vuint8m1_t v_digits = vle8_v_u8m1(&digits[i], vl);\n\n        // Create a mask for odd digits\n        vbool8_t v_is_odd = vmsne_vx_u8m1_b8(vand_vx_u8m1(v_digits, 1, vl), 0, vl);\n\n        // Extract odd digits using the mask\n        vuint8m1_t v_odd_digits = vmerge_vvm_u8m1(v_is_odd, v_digits, v_one, vl);\n\n        // Compute product of odd digits\n        vuint8m1_t v_product = vmul_vv_u8m1(v_odd_digits, v_odd_digits, vl);\n\n        // Reduce the product to a scalar\n        uint8_t temp_product = vredprod_vs_u8m1_u8m1(v_product, v_one, vl);\n\n        // Update the result\n        if (temp_product != 1) {\n            result *= temp_product;\n            all_even = 0;\n        }\n    }\n\n    return all_even ? 0 : result;\n}\n```"}
{"task_id": "SimdBench_125_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t digits_simd(uint64_t n) {\n    size_t vlmax = vsetvlmax_e8m1();\n    uint64_t product = 1;\n    int has_odd = 0;\n\n    // Convert the number to a digit array\n    uint8_t digits[20];\n    int num_digits = 0;\n    while (n > 0) {\n        digits[num_digits++] = n % 10;\n        n /= 10;\n    }\n\n    // Process the digits using RVV intrinsics\n    for (int i = 0; i < num_digits; i += vlmax) {\n        size_t vl = vsetvl_e8m1(num_digits - i);\n\n        // Load digits into a vector\n        vuint8m1_t v_digits = vle8_v_u8m1(&digits[i], vl);\n\n        // Create a mask for odd digits\n        vbool8_t v_odd_mask = vmseq_vx_u8m1(v_digits & 1, 1, vl);\n\n        // Extract odd digits using the mask\n        vuint8m1_t v_odds = vcompress_vm_u8m1(v_odd_mask, v_digits, vl);\n\n        // Compute the product of odd digits in the vector\n        vuint64m8_t v_product = vmv_v_x_u64m8(1, vl);\n        v_product = vwmul_vv_u64m8(v_product, v_odds, vl);\n\n        // Reduce the vector product to a scalar\n        uint64_t scalar_product = 1;\n        for (size_t j = 0; j < vl; ++j) {\n            scalar_product *= v_odds[j];\n        }\n\n        // Update the overall product\n        if (scalar_product > 1) {\n            product *= scalar_product;\n            has_odd = 1;\n        }\n    }\n\n    return has_odd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_126_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n#include <vector>\n\nuint64_t sum_squares_simd(const std::vector<float> &lst) {\n    size_t len = lst.size();\n    const float *data = lst.data();\n    uint64_t result = 0;\n\n    size_t vl;\n    vfloat32m1_t v_input, v_ceiling;\n    vfloat32m1_t v_zero = vfmv_v_f_f32m1(0.0f, vl);\n    vfloat32m1_t v_one = vfmv_v_f_f32m1(1.0f, vl);\n\n    for (size_t i = 0; i < len; i += vl) {\n        vl = vsetvl_e32m1(len - i);\n\n        // Load vector of floats\n        v_input = vle32_v_f32m1(data + i, vl);\n\n        // Compute ceiling: if value is not integer, add 1 after truncation\n        vbool32_t mask = vmflt_vv_f32m1_b32(v_input, vfadd_vv_f32m1(v_input, v_one, vl), vl);\n        v_ceiling = vfadd_vv_f32m1(vfcvt_x_f_v_f32m1(v_input, vl), vfmv_v_f_f32m1(mask ? 1.0f : 0.0f, vl), vl);\n\n        // Square the ceiling values\n        v_ceiling = vfmul_vv_f32m1(v_ceiling, v_ceiling, vl);\n\n        // Accumulate the squared values into result\n        result += vfwredsum_vs_f32m1_f32m1(v_ceiling, v_zero, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_126_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n#include <cstdint>\n\nuint64_t sum_squares_simd(const std::vector<float> &lst) {\n    size_t len = lst.size();\n    const float *data = lst.data();\n    uint64_t result = 0;\n\n    size_t vl;\n    vfloat32m1_t v_x, v_ceil;\n    vfloat32m1_t v_zero = vfmv_v_f_f32m1(0.0f, vl);\n    vbool32_t mask;\n\n    for (size_t i = 0; i < len; i += vl) {\n        vl = vsetvl_e32m1(len - i);\n\n        // Load vector of floats from memory\n        v_x = vle32_v_f32m1(&data[i], vl);\n\n        // Compute ceiling of each element\n        v_ceil = vfceil_v_f32m1(v_x, vl);\n\n        // Square each element\n        v_ceil = vfmul_vv_f32m1(v_ceil, v_ceil, vl);\n\n        // Convert to int64 and accumulate horizontally\n        vint64m2_t v_int = vfcvt_x_f_v_i64m2(v_ceil, vl);\n        result += vwredsum_vs_i64m2_i64m1(v_int, v_zero, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_126_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n#include <vector>\n\nuint64_t sum_squares_simd(const std::vector<float> &lst) {\n    size_t len = lst.size();\n    const float *data = lst.data();\n    uint64_t result = 0;\n\n    size_t vl;\n    vfloat32m1_t v_x, v_ceil;\n    vfloat32m1_t v_zero = vfmv_v_f_f32m1(0.0f, vl);\n    vbool32_t mask;\n\n    for (size_t i = 0; i < len; i += vl) {\n        vl = vsetvl_e32m1(len - i);\n\n        // Load vector of floats from memory\n        v_x = vle32_v_f32m1(&data[i], vl);\n\n        // Compute ceiling of each element\n        v_ceil = vfceil_v_f32m1(v_x, vl);\n\n        // Square each element\n        v_ceil = vfmul_vv_f32m1(v_ceil, v_ceil, vl);\n\n        // Convert to int64 and accumulate horizontally\n        vint64m2_t v_int = vfcvt_x_f_v_i64m2(v_ceil, vl);\n        result += vmv_x_s_i64m2_i64(vwredsum_vs_i64m2_i64m1(v_int, v_zero, vl));\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_126_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n#include <vector>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    size_t len = lst.size();\n    size_t vl;\n    uint64_t result = 0;\n\n    // Initialize vector registers\n    vfloat32m1_t v_ceil, v_squared;\n    vuint64m1_t v_sum;\n\n    // Set mask for tail handling\n    vbool32_t mask;\n\n    // Process the input vector in chunks defined by the vector length\n    for (size_t i = 0; i < len; i += vl) {\n        // Determine the vector length for this iteration\n        vl = vsetvl_e32m1(len - i);\n\n        // Load a vector of floats from the input array\n        vfloat32m1_t v_input = vle32_v_f32m1(&lst[i], vl);\n\n        // Compute the ceiling of each element\n        v_ceil = vfceil_v_f32m1(v_input, vl);\n\n        // Square each element\n        v_squared = vfmul_vv_f32m1(v_ceil, v_ceil, vl);\n\n        // Convert squared values to 64-bit integers\n        vuint64m1_t v_int_squared = vfcvt_xu_f_v_u64m1(v_squared, vl);\n\n        // Accumulate the results into a single vector register\n        if (i == 0) {\n            v_sum = v_int_squared;\n        } else {\n            v_sum = vwaddu_vv_u64m1(v_sum, v_int_squared, vl);\n        }\n    }\n\n    // Reduce the vector register to a scalar value\n    while (vl > 1) {\n        vl = vsetvl_e64m1(vl / 2);\n        v_sum = vwaddu_vv_u64m1(v_sum, v_sum, vl);\n    }\n\n    // Extract the final scalar result\n    result = vmv_x_s_u64m1_u64(v_sum);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_126_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n#include <vector>\n\nuint64_t sum_squares_simd(const std::vector<float> &lst) {\n    size_t vlmax = vsetvlmax_e32m8();\n    size_t len = lst.size();\n    size_t i = 0;\n    uint64_t result = 0;\n\n    while (i < len) {\n        size_t vl = vsetvl_e32m8(len - i);\n\n        // Load vector of floats from memory\n        vfloat32m8_t vf = vle32_v_f32m8(&lst[i], vl);\n\n        // Compute ceiling for each element\n        vfloat32m8_t vceil = vfceil_vf_f32m8(vf, vl);\n\n        // Convert ceiling values to integers\n        vint32m8_t vi = vfcvt_x_f_v_i32m8(vceil, vl);\n\n        // Square the integer values\n        vint32m8_t vsquared = vmul_vv_i32m8(vi, vi, vl);\n\n        // Accumulate squared values into a single sum\n        vint64m1_t vsum = vmv_v_x_i64m1(0, vl); // Initialize accumulator\n        vsum = vwredsum_vs_i32m8_i64m1(vsum, vsquared, vsum, vl);\n\n        // Extract the accumulated sum\n        int64_t temp_sum;\n        vse64_v_i64m1(&temp_sum, vsum, 1);\n        result += temp_sum;\n\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    size_t n = arr.size();\n    if (n < 2) return -1;\n\n    int result = -1;\n    size_t vlmax = vsetvlmax_e32m8();\n\n    for (size_t i = 0; i < n - 1; i += vlmax) {\n        size_t vl = vsetvl_e32m8(n - 1 - i);\n\n        vint32m8_t vec_curr = vle32_v_i32m8(&arr[i], vl);\n        vint32m8_t vec_next = vle32_v_i32m8(&arr[i + 1], vl);\n\n        vbool4_t mask = vmseq_vv_i32m8_b4(vec_curr, vec_next);\n        vbool4_t mask_gt = vmslt_vv_i32m8_b4(vec_curr, vec_next);\n\n        mask = vmor_mm_b4(mask, mask_gt);\n\n        int32_t index = n - 1;\n        if (vfirst_m_b4(mask, vl) != -1) {\n            index = i + vfirst_m_b4(mask, vl);\n        }\n\n        if (index < n - 1 && arr[index] >= arr[index + 1]) {\n            result = index + 1;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    size_t vlmax = vsetvlmax_e32m8();\n    size_t n = arr.size();\n    int result = -1;\n\n    for (size_t i = 0; i < n; i += vlmax) {\n        size_t vl = vsetvl_e32m8(n - i);\n\n        vint32m8_t vec = vle32_v_i32m8(&arr[i], vl);\n        vint32m8_t vec_prev = vle32_v_i32m8(&arr[i - 1], vl);\n\n        vbool4_t mask = vmflt_vv_i32m8_b4(vec, vec_prev, vl);\n\n        if (vmseq_vx_i32m8_b4(mask, 0, vl)) {\n            continue;\n        }\n\n        int index = i + vfirst_m_b4(mask, vl);\n        if (index > result) {\n            result = index;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    size_t vlmax = vsetvlmax_e32m8();\n    size_t n = arr.size();\n    int result = -1;\n\n    for (size_t i = 0; i < n; i += vlmax) {\n        size_t vl = vsetvl_e32m8(n - i);\n\n        vint32m8_t vec = vle32_v_i32m8(&arr[i], vl);\n        vint32m8_t prev_vec = vle32_v_i32m8(&arr[i - 1], vl);\n\n        vbool4_t mask = vmseq_vv_i32m8_b4(vec, prev_vec, vl);\n        vbool4_t mask_not_ge = vmflt_vv_i32m8_b4(vec, prev_vec, vl);\n\n        if (vmfirst_m_b4(mask_not_ge, vl)) {\n            result = i + vmfirst_m_b4(mask_not_ge, vl);\n            break;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    size_t vlmax = vsetvlmax_e32m8();\n    size_t n = arr.size();\n    int result = -1;\n\n    for (size_t i = 0; i < n; i += vlmax) {\n        size_t vl = vsetvl_e32m8(n - i);\n\n        vint32m8_t vec = vle32_v_i32m8(&arr[i], vl);\n        vint32m8_t prev_vec = vrgather_vv_i32m8(vec, vid_v_u32m8(), vl);\n        vbool4_t mask = vmflt_vv_i32m8_b4(vec, prev_vec, vl);\n\n        if (vfirst_m_b4(mask, vl) != -1) {\n            result = i + vfirst_m_b4(mask, vl);\n            break;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    size_t n = arr.size();\n    if (n < 2) return -1;\n\n    int result = -1;\n    size_t vlmax = vsetvlmax_e32m8();\n\n    for (size_t i = 0; i < n - 1; i += vlmax) {\n        size_t vl = vsetvl_e32m8(n - 1 - i);\n\n        vint32m8_t vec_curr = vle32_v_i32m8(&arr[i], vl);\n        vint32m8_t vec_next = vle32_v_i32m8(&arr[i + 1], vl);\n\n        vbool4_t mask = vmflt_vv_i32m8_b4(vec_next, vec_curr);\n\n        if (vfirst_m_b4(mask, vl) != -1) {\n            result = i + vfirst_m_b4(mask, vl) + 1;\n            break;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_128_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    size_t vlmax = __riscv_vsetvlmax_e32m1();\n    int largest_neg = 0;\n    int smallest_pos = 0;\n\n    size_t n = lst.size();\n    size_t i = 0;\n\n    while (i < n) {\n        size_t vl = __riscv_vsetvl_e32m1(n - i);\n\n        // Load vector from memory\n        vint32m1_t vec = __riscv_vle32_v_i32m1(&lst[i], vl);\n\n        // Mask for negative numbers\n        vbool32_t neg_mask = __riscv_vmflt_vx_i32m1_b32(vec, 0, vl);\n        // Mask for positive numbers\n        vbool32_t pos_mask = __riscv_vmfgt_vx_i32m1_b32(vec, 0, vl);\n\n        // Extract negative numbers and find the largest\n        vint32m1_t neg_vec = __riscv_vmerge_vxm_i32m1(vec, 0, neg_mask, vl);\n        int max_neg = __riscv_vredmax_vs_i32m1_i32m1(__riscv_vmv_v_x_i32m1(0, vl), neg_vec, vl);\n        if (max_neg < 0 && max_neg < largest_neg) {\n            largest_neg = max_neg;\n        }\n\n        // Extract positive numbers and find the smallest\n        vint32m1_t pos_vec = __riscv_vmerge_vxm_i32m1(vec, 0, pos_mask, vl);\n        int min_pos = __riscv_vredmin_vs_i32m1_i32m1(__riscv_vmv_v_x_i32m1(0, vl), pos_vec, vl);\n        if (min_pos > 0 && (smallest_pos == 0 || min_pos < smallest_pos)) {\n            smallest_pos = min_pos;\n        }\n\n        i += vl;\n    }\n\n    return {largest_neg, smallest_pos};\n}\n```"}
{"task_id": "SimdBench_128_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    size_t vlmax = __riscv_vsetvlmax_e32m1();\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    size_t n = lst.size();\n    size_t i = 0;\n\n    while (i < n) {\n        size_t vl = __riscv_vsetvl_e32m1(n - i);\n        vint32m1_t vec = __riscv_vle32_v_i32m1(&lst[i], vl);\n\n        // Mask for negative numbers\n        vbool32_t negative_mask = __riscv_vmflt_vx_i32m1_b32(vec, 0, vl);\n        // Mask for positive numbers\n        vbool32_t positive_mask = __riscv_vmfgt_vx_i32m1_b32(vec, 0, vl);\n\n        // Extract negative numbers and find the largest\n        vint32m1_t negatives = __riscv_vmerge_vxm_i32m1(vec, 0, negative_mask, vl);\n        int max_negative = __riscv_vredmax_vs_i32m1_i32m1(__riscv_vmv_v_x_i32m1(0, vl), negatives, vl);\n        if (max_negative < 0 && max_negative < largest_negative) {\n            largest_negative = max_negative;\n        }\n\n        // Extract positive numbers and find the smallest\n        vint32m1_t positives = __riscv_vmerge_vxm_i32m1(vec, 0, positive_mask, vl);\n        int min_positive = __riscv_vredmin_vs_i32m1_i32m1(__riscv_vmv_v_x_i32m1(0, vl), positives, vl);\n        if (min_positive > 0 && (smallest_positive == 0 || min_positive < smallest_positive)) {\n            smallest_positive = min_positive;\n        }\n\n        i += vl;\n    }\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_128_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    size_t vlmax = vsetvlmax_e32m1();\n    size_t len = lst.size();\n    int largest_neg = 0;\n    int smallest_pos = 0;\n\n    for (size_t i = 0; i < len; i += vlmax) {\n        size_t vl = vsetvl_e32m1(len - i);\n\n        // Load vector from memory\n        vint32m1_t vec = vle32_v_i32m1((const int32_t*)(lst.data() + i), vl);\n\n        // Mask for negative numbers\n        vbool32_t neg_mask = vmflt_vx_i32m1_b32(vec, 0, vl);\n        vint32m1_t neg_vec = vmerge_vxm_i32m1(vec, 0, neg_mask, vl);\n\n        // Find the largest negative number\n        vint32m1_t max_neg_vec = vredmax_vs_i32m1_i32m1(neg_vec, vundefined_i32m1(), vl);\n        int max_neg = vmv_x_s_i32m1_i32(max_neg_vec);\n        if (max_neg < 0 && max_neg < largest_neg) {\n            largest_neg = max_neg;\n        }\n\n        // Mask for positive numbers\n        vbool32_t pos_mask = vmfgt_vx_i32m1_b32(vec, 0, vl);\n        vint32m1_t pos_vec = vmerge_vxm_i32m1(vec, 0, pos_mask, vl);\n\n        // Find the smallest positive number\n        vint32m1_t min_pos_vec = vredmin_vs_i32m1_i32m1(pos_vec, vundefined_i32m1(), vl);\n        int min_pos = vmv_x_s_i32m1_i32(min_pos_vec);\n        if (min_pos > 0 && (smallest_pos == 0 || min_pos < smallest_pos)) {\n            smallest_pos = min_pos;\n        }\n    }\n\n    return {largest_neg, smallest_pos};\n}\n```"}
{"task_id": "SimdBench_128_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    size_t vlmax = __riscv_vsetvlmax_e32m1();\n    int largest_neg = 0;\n    int smallest_pos = 0;\n\n    for (size_t i = 0; i < lst.size(); i += vlmax) {\n        size_t vl = __riscv_vsetvl_e32m1(lst.size() - i);\n\n        vint32m1_t vec = __riscv_vle32_v_i32m1(&lst[i], vl);\n        vbool32_t mask_neg = __riscv_vmflt_vx_i32m1_b32(vec, 0, vl);\n        vbool32_t mask_pos = __riscv_vmfgt_vx_i32m1_b32(vec, 0, vl);\n\n        vint32m1_t neg_vals = __riscv_vmerge_vxm_i32m1(vec, 0, mask_neg, vl);\n        vint32m1_t pos_vals = __riscv_vmerge_vxm_i32m1(vec, 0, mask_pos, vl);\n\n        int max_neg = __riscv_vredmax_vs_i32m1_i32m1(neg_vals, 0, vl);\n        int min_pos = __riscv_vredmin_vs_i32m1_i32m1(pos_vals, 0, vl);\n\n        if (max_neg < 0 && max_neg < largest_neg) {\n            largest_neg = max_neg;\n        }\n        if (min_pos > 0 && (smallest_pos == 0 || min_pos < smallest_pos)) {\n            smallest_pos = min_pos;\n        }\n    }\n\n    return {largest_neg, smallest_pos};\n}\n```"}
{"task_id": "SimdBench_128_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    size_t vlmax = __riscv_vsetvlmax_e32m1();\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    size_t n = lst.size();\n    size_t i = 0;\n\n    while (i < n) {\n        size_t vl = __riscv_vsetvl_e32m1(n - i);\n\n        // Load vector from memory\n        vint32m1_t vec = __riscv_vle32_v_i32m1(&lst[i], vl);\n\n        // Mask for negative numbers\n        vbool32_t neg_mask = __riscv_vmflt_vx_i32m1_b32(vec, 0, vl);\n        vint32m1_t neg_vec = __riscv_vmerge_vxm_i32m1(vec, 0, neg_mask, vl);\n\n        // Find the largest negative number\n        vint32m1_t max_neg_vec = __riscv_vredmax_vs_i32m1_i32m1(neg_vec, __riscv_vmv_v_x_i32m1(0, vl), vl);\n        int max_neg = __riscv_vmv_x_s_i32m1_i32(max_neg_vec);\n        if (max_neg < 0 && max_neg < largest_negative) {\n            largest_negative = max_neg;\n        }\n\n        // Mask for positive numbers\n        vbool32_t pos_mask = __riscv_vmfgt_vx_i32m1_b32(vec, 0, vl);\n        vint32m1_t pos_vec = __riscv_vmerge_vxm_i32m1(vec, 0, pos_mask, vl);\n\n        // Find the smallest positive number\n        vint32m1_t min_pos_vec = __riscv_vredmin_vs_i32m1_i32m1(pos_vec, __riscv_vmv_v_x_i32m1(0, vl), vl);\n        int min_pos = __riscv_vmv_x_s_i32m1_i32(min_pos_vec);\n        if (min_pos > 0 && (smallest_positive == 0 || min_pos < smallest_positive)) {\n            smallest_positive = min_pos;\n        }\n\n        i += vl;\n    }\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_129_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    uint64_t result = 1;\n    size_t vl;\n\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t fact = 1;\n        vl = __riscv_vsetvl_e64m1(i);\n\n        // Compute factorial of `i` using RVV intrinsics\n        for (uint64_t j = 1; j <= i; j += vl) {\n            vl = __riscv_vsetvl_e64m1(i - j + 1);\n            vuint64m1_t vec_j = __riscv_vid_v_u64m1(vl);\n            vec_j = __riscv_vadd_vx_u64m1(vec_j, j, vl);\n            vuint64m1_t vec_fact = __riscv_vmul_vx_u64m1(vec_j, 1, vl);\n\n            // Horizontal reduction to compute the product\n            uint64_t temp_fact = 1;\n            for (size_t k = 0; k < vl; ++k) {\n                temp_fact *= __riscv_vget_v_u64m1(vec_fact, k);\n            }\n            fact *= temp_fact;\n        }\n\n        result *= fact;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    uint64_t result = 1;\n    size_t vl;\n\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t factorial = 1;\n        vl = vsetvl_e64m1(i); // Set vector length based on the current factorial size\n\n        // Compute factorial(i) using RVV intrinsics\n        for (uint64_t j = 1; j <= i; j += vl) {\n            vl = vsetvl_e64m1(i - j + 1);\n            vuint64m1_t vec_j = vid_v_u64m1(vl); // Generate a vector of indices [0, 1, ..., vl-1]\n            vec_j = vadd_vx_u64m1(vec_j, j, vl); // Offset indices to [j, j+1, ..., j+vl-1]\n            vuint64m1_t vec_factorial = vmul_vv_u64m1(vec_j, vec_j, vl); // Multiply elements\n            factorial *= vmv_x_s_u64m1_u64(vec_factorial); // Accumulate the result\n        }\n\n        result *= factorial; // Multiply the result by the computed factorial(i)\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    uint64_t result = 1;\n    size_t vl;\n\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t factorial = 1;\n        vl = __riscv_vsetvl_e64m1(i);\n\n        // Compute factorial of i using RVV intrinsics\n        for (uint64_t j = 1; j <= i; j += vl) {\n            vl = __riscv_vsetvl_e64m1(i - j + 1);\n            vuint64m1_t vec_j = __riscv_vid_v_u64m1(vl);\n            vec_j = __riscv_vadd_vx_u64m1(vec_j, j, vl);\n            vuint64m1_t vec_factorial = __riscv_vmul_vx_u64m1(vec_j, 1, vl);\n\n            // Reduce the vector to a scalar product\n            factorial *= __riscv_vmv_x_s_u64m1_u64(__riscv_vfredus_v_u64m1(vec_factorial, vl));\n        }\n\n        result *= factorial;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    uint64_t result = 1;\n    size_t vl;\n\n    // Compute individual factorials in parallel using RVV\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t fact = 1;\n        vl = vsetvl_e64m1(i); // Set vector length based on current factorial size\n\n        // Vectorized computation of factorial\n        for (uint64_t j = 1; j <= i; j += vl) {\n            vuint64m1_t vec_j = vid_v_u64m1(vl); // Generate a vector of indices\n            vec_j = vadd_vx_u64m1(vec_j, j - 1, vl); // Offset indices to start from 'j'\n            vuint64m1_t vec_fact = vmul_vv_u64m1(vec_j, vec_j, vl); // Multiply elements\n            fact *= vmv_x_s_u64m1_u64(vec_fact); // Accumulate the result\n        }\n\n        result *= fact; // Multiply the current factorial into the result\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    uint64_t result = 1;\n    size_t vl;\n\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t fact = 1;\n        vl = vsetvl_e64m1(i);\n\n        vuint64m1_t vec_fact = vmv_v_x_u64m1(1, vl);\n        vuint64m1_t vec_indices = vid_v_u64m1(vl);\n\n        vec_indices = vfadd_vx_u64m1(vec_indices, 1, vl);\n\n        for (size_t j = 0; j < i; j += vl) {\n            vec_fact = vfmul_vv_u64m1(vec_fact, vec_indices, vl);\n        }\n\n        fact = vfmv_f_s_u64m1_f64(vec_fact);\n        result *= fact;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_130_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint sum_squares_simd(const std::vector<int> &lst) {\n    size_t vlmax = vsetvlmax_e32m1();\n    size_t len = lst.size();\n    int result = 0;\n\n    for (size_t i = 0; i < len; i += vlmax) {\n        size_t vl = vsetvl_e32m1(len - i);\n\n        // Load vector from memory\n        vint32m1_t vec = vle32_v_i32m1(&lst[i], vl);\n\n        // Create index vector\n        vint32m1_t indices = vid_v_i32m1(vl);\n\n        // Compute masks for multiples of 3 and multiples of 4 (not multiple of 3)\n        vbool32_t mask_mult3 = vmseq_vx_i32m1(indices, 0, vl);\n        vbool32_t mask_mult4 = vmseq_vx_i32m1(indices, 0, vl);\n        for (int j = 3; j < vlmax; j += 3) {\n            mask_mult3 = vmor_vv_i32m1_b32(mask_mult3, vmseq_vx_i32m1(indices, j, vl), vl);\n        }\n        for (int j = 4; j < vlmax; j += 4) {\n            vbool32_t temp_mask = vmseq_vx_i32m1(indices, j, vl);\n            mask_mult4 = vmor_vv_i32m1_b32(mask_mult4, temp_mask, vl);\n            mask_mult4 = vmandnot_vv_i32m1_b32(mask_mult4, mask_mult3, vl);\n        }\n\n        // Square elements where index is a multiple of 3\n        vint32m1_t squared = vwmul_vv_i32m1(vec, vec, vl);\n        vec = vmerge_vvm_i32m1(mask_mult3, squared, vec, vl);\n\n        // Cube elements where index is a multiple of 4 (and not multiple of 3)\n        vint32m1_t cubed = vwmul_vv_i32m1(squared, vec, vl);\n        vec = vmerge_vvm_i32m1(mask_mult4, cubed, vec, vl);\n\n        // Reduce the vector to compute partial sum\n        int partial_sum = 0;\n        vint32m1_t sum_vec = vmv_v_x_i32m1(0, vl);\n        sum_vec = vwredsum_vs_i32m1_i32m1(sum_vec, vec, sum_vec, vl);\n        partial_sum = vmv_x_s_i32m1_i32(sum_vec);\n\n        result += partial_sum;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_130_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint sum_squares_simd(const std::vector<int> &lst) {\n    size_t vlmax = vsetvlmax_e32m1();\n    size_t len = lst.size();\n    int result = 0;\n\n    for (size_t i = 0; i < len; i += vlmax) {\n        size_t vl = vsetvl_e32m1(len - i);\n\n        // Load vector from memory\n        vint32m1_t vec = vle32_v_i32m1(&lst[i], vl);\n\n        // Create index vector\n        vint32m1_t indices = vid_v_i32m1(vl);\n\n        // Compute mask for multiples of 3\n        vbool32_t mask_mult_3 = vmseq_vx_i32m1(indices, 0, vl);\n        for (int j = 3; j < vlmax; j += 3) {\n            mask_mult_3 = vmor_mm_b32(mask_mult_3, vmseq_vx_i32m1(indices, j, vl), vl);\n        }\n\n        // Compute mask for multiples of 4 but not multiples of 3\n        vbool32_t mask_mult_4_not_3 = vmseq_vx_i32m1(indices, 0, vl);\n        for (int j = 4; j < vlmax; j += 4) {\n            mask_mult_4_not_3 = vmor_mm_b32(mask_mult_4_not_3, vmseq_vx_i32m1(indices, j, vl), vl);\n        }\n        mask_mult_4_not_3 = vmnand_mm_b32(mask_mult_4_not_3, mask_mult_3, vl);\n\n        // Square elements where index is multiple of 3\n        vint32m1_t squared = vwmul_vv_i32m1(vec, vec, vl);\n        vec = vmerge_vxm_i32m1(vec, squared, mask_mult_3, vl);\n\n        // Cube elements where index is multiple of 4 but not multiple of 3\n        vint32m1_t cubed = vwmul_vv_i32m1(squared, vec, vl);\n        vec = vmerge_vxm_i32m1(vec, cubed, mask_mult_4_not_3, vl);\n\n        // Reduce sum\n        vint32m1_t sum_vec = vmv_v_x_i32m1(0, vl);\n        sum_vec = vwredsum_vs_i32m1_i32m1(sum_vec, vec, sum_vec, vl);\n        result += vmv_x_s_i32m1_i32(sum_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_130_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint sum_squares_simd(const std::vector<int> &lst) {\n    size_t vlmax = vsetvlmax_e32m1();\n    size_t len = lst.size();\n    int result = 0;\n\n    for (size_t i = 0; i < len; i += vlmax) {\n        size_t vl = vsetvl_e32m1(len - i);\n\n        // Load vector from memory\n        vint32m1_t vec = vle32_v_i32m1(&lst[i], vl);\n\n        // Create index vector\n        vint32m1_t indices = vid_v_i32m1(vl);\n\n        // Compute masks for multiples of 3 and multiples of 4\n        vbool32_t mask_mult3 = vmseq_vx_i32m1(vrem_vx_i32m1(indices, 3, vl), 0, vl);\n        vbool32_t mask_mult4 = vmseq_vx_i32m1(vrem_vx_i32m1(indices, 4, vl), 0, vl);\n\n        // Square elements where index is a multiple of 3\n        vint32m1_t squared = vwmul_vv_i32m1(vec, vec, vl);\n        vec = vmerge_vvm_i32m1(mask_mult3, squared, vec, vl);\n\n        // Cube elements where index is a multiple of 4 but not a multiple of 3\n        vbool32_t mask_mult4_not3 = vmandnot_mm(mask_mult4, mask_mult3, vl);\n        vint32m1_t cubed = vwmul_vv_i32m1(squared, vec, vl);\n        vec = vmerge_vvm_i32m1(mask_mult4_not3, cubed, vec, vl);\n\n        // Reduce the vector to compute partial sum\n        int partial_sum = vredsum_vs_i32m1_i32m1(vec, vl);\n        result += partial_sum;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_130_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint sum_squares_simd(const std::vector<int> &lst) {\n    size_t vlmax = vsetvlmax_e32m1();\n    size_t len = lst.size();\n    int result = 0;\n\n    for (size_t i = 0; i < len; i += vlmax) {\n        size_t vl = vsetvl_e32m1(len - i);\n\n        // Load vector from memory\n        vint32m1_t vec = vle32_v_i32m1(&lst[i], vl);\n\n        // Create index vector\n        vint32m1_t indices = vid_v_i32m1(vl);\n\n        // Mask for multiples of 3\n        vbool32_t mask_mult3 = vmseq_vx_i32m1(indices, 0, vl);\n        for (int j = 3; j < vlmax; j += 3) {\n            mask_mult3 = vmor_mm_b32(mask_mult3, vmseq_vx_i32m1(indices, j, vl), vl);\n        }\n\n        // Mask for multiples of 4 but not multiples of 3\n        vbool32_t mask_mult4_not3 = vmseq_vx_i32m1(indices, 0, vl);\n        for (int j = 4; j < vlmax; j += 4) {\n            mask_mult4_not3 = vmor_mm_b32(mask_mult4_not3, vmseq_vx_i32m1(indices, j, vl), vl);\n        }\n        mask_mult4_not3 = vmnand_mm_b32(mask_mult4_not3, mask_mult3, vl);\n\n        // Square elements where index is a multiple of 3\n        vint32m1_t squared = vwmul_vv_i32m1(vec, vec, vl);\n        vec = vmerge_vvm_i32m1(mask_mult3, squared, vec, vl);\n\n        // Cube elements where index is a multiple of 4 but not 3\n        vint32m1_t cubed = vwmul_vv_i32m1(squared, vec, vl);\n        vec = vmerge_vvm_i32m1(mask_mult4_not3, cubed, vec, vl);\n\n        // Reduce sum\n        result += vredsum_vs_i32m1_i32m1(vec, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_130_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint sum_squares_simd(const std::vector<int> &lst) {\n    size_t vlmax = vsetvlmax_e32m1();\n    size_t len = lst.size();\n    int result = 0;\n\n    for (size_t i = 0; i < len; i += vlmax) {\n        size_t vl = vsetvl_e32m1(len - i);\n\n        // Load vector from memory\n        vint32m1_t vec = vle32_v_i32m1(lst.data() + i, vl);\n\n        // Create index vector\n        vint32m1_t indices = vid_v_i32m1(vl);\n\n        // Mask for indices that are multiples of 3\n        vbool32_t mask_mult3 = vmseq_vx_i32m1(indices, 0, vl);\n        for (int j = 3; j < vlmax; j += 3) {\n            mask_mult3 = vmor_mm_b32(mask_mult3, vmseq_vx_i32m1(indices, j, vl), vl);\n        }\n\n        // Mask for indices that are multiples of 4 but not multiples of 3\n        vbool32_t mask_mult4_not3 = vmseq_vx_i32m1(indices, 0, vl);\n        for (int j = 4; j < vlmax; j += 4) {\n            mask_mult4_not3 = vmor_mm_b32(mask_mult4_not3, vmseq_vx_i32m1(indices, j, vl), vl);\n        }\n        mask_mult4_not3 = vmnand_mm_b32(mask_mult4_not3, mask_mult3, vl);\n\n        // Square elements where index is a multiple of 3\n        vint32m1_t squared = vwmul_vv_i32m1(vec, vec, vl);\n        vec = vmerge_vxm_i32m1(vec, squared, mask_mult3, vl);\n\n        // Cube elements where index is a multiple of 4 but not 3\n        vint32m1_t cubed = vwmul_vv_i32m1(squared, vec, vl);\n        vec = vmerge_vxm_i32m1(vec, cubed, mask_mult4_not3, vl);\n\n        // Reduce the vector to compute partial sum\n        result += vredsum_vs_i32m1_i32m1(vec, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_131_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint specialFilter_simd(const std::vector<int> &nums) {\n    size_t vlmax = vsetvlmax_e32m8();\n    int result = 0;\n\n    for (size_t i = 0; i < nums.size(); i += vlmax) {\n        size_t vl = vsetvl_e32m8(nums.size() - i);\n\n        // Load vector of integers from memory\n        vint32m8_t vec = vle32_v_i32m8(&nums[i], vl);\n\n        // Create a mask for numbers greater than 10\n        vbool4_t mask_gt_10 = vmfgt_vx_i32m8_b4(vec, 10, vl);\n\n        // Extract absolute values to handle negatives\n        vint32m8_t abs_vec = vabs_v_i32m8(vec, vl);\n\n        // Compute first digit\n        vint32m8_t first_digit = abs_vec;\n        for (int j = 0; j < 9; ++j) { // Reduce to first digit\n            first_digit = vdiv_vx_i32m8(first_digit, 10, vl);\n        }\n\n        // Compute last digit\n        vint32m8_t last_digit = vrem_vx_i32m8(abs_vec, 10, vl);\n\n        // Check if first and last digits are odd\n        vbool4_t mask_first_odd = vmfne_vx_i32m8_b4(vrem_vx_i32m8(first_digit, 2, vl), 0, vl);\n        vbool4_t mask_last_odd = vmfne_vx_i32m8_b4(vrem_vx_i32m8(last_digit, 2, vl), 0, vl);\n\n        // Combine all conditions: >10, first digit odd, last digit odd\n        vbool4_t combined_mask = vmand_mm(mask_gt_10, vmand_mm(mask_first_odd, mask_last_odd, vl), vl);\n\n        // Count the number of elements satisfying the condition\n        result += vcpop_m_b4(combined_mask, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_131_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint specialFilter_simd(const std::vector<int> &nums) {\n    size_t vlmax = vsetvlmax_e32m1();\n    int result = 0;\n\n    for (size_t i = 0; i < nums.size(); i += vlmax) {\n        size_t vl = vsetvl_e32m1(nums.size() - i);\n\n        // Load vector of integers from memory\n        vint32m1_t vec = vle32_v_i32m1(&nums[i], vl);\n\n        // Check if numbers are greater than 10\n        vbool32_t mask_gt_10 = vmfgt_vx_i32m1_b32(vec, 10, vl);\n\n        // Extract first digit\n        vint32m1_t temp = vec;\n        vbool32_t mask_positive = vmfgt_vx_i32m1_b32(temp, 0, vl);\n        temp = vneg_v_i32m1_m(mask_positive, temp, vl); // Make all numbers positive\n        while (1) {\n            vbool32_t mask_ge_10 = vmfge_vx_i32m1_b32(temp, 10, vl);\n            vint32m1_t div = vdiv_vx_i32m1(temp, 10, vl);\n            temp = vmerge_vvm_i32m1(mask_ge_10, div, temp, vl);\n            if (!vmfirst_m_b32(mask_ge_10)) break;\n        }\n        vint32m1_t first_digit = temp;\n\n        // Extract last digit\n        vint32m1_t last_digit = vrem_vx_i32m1(vec, 10, vl);\n        last_digit = vabs_v_i32m1(last_digit, vl); // Ensure last digit is positive\n\n        // Check if first and last digits are odd\n        vbool32_t mask_first_odd = vmsne_vx_i32m1_b32(vand_vx_i32m1(first_digit, 1, vl), 0, vl);\n        vbool32_t mask_last_odd = vmsne_vx_i32m1_b32(vand_vx_i32m1(last_digit, 1, vl), 0, vl);\n\n        // Combine all conditions\n        vbool32_t mask_final = vmadd_vv_b32(mask_gt_10, mask_first_odd, mask_last_odd, vl);\n\n        // Count the number of elements satisfying the condition\n        result += vcpop_m_b32(mask_final, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_131_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint specialFilter_simd(const std::vector<int> &nums) {\n    size_t vlmax = vsetvlmax_e32m1();\n    int result = 0;\n\n    for (size_t i = 0; i < nums.size(); i += vlmax) {\n        size_t vl = vsetvl_e32m1(nums.size() - i);\n\n        // Load vector of integers from memory\n        vint32m1_t vec = vle32_v_i32m1(&nums[i], vl);\n\n        // Create a mask for numbers greater than 10\n        vbool32_t mask_gt_10 = vmfgt_vx_i32m1_b32(vec, 10, vl);\n\n        // Extract absolute values to handle negative numbers\n        vint32m1_t abs_vec = vabs_v_i32m1(vec, vl);\n\n        // Compute the last digit (abs_val % 10)\n        vint32m1_t last_digit = vremu_vx_i32m1(abs_vec, 10, vl);\n\n        // Compute the first digit\n        vint32m1_t first_digit = abs_vec;\n        for (int div = 10; div <= 1000000000; div *= 10) {\n            vbool32_t mask_ge_div = vmfge_vx_i32m1_b32(first_digit, div, vl);\n            first_digit = vdivu_vx_i32m1_m(mask_ge_div, first_digit, div, first_digit, vl);\n        }\n\n        // Check if both first and last digits are odd\n        vbool32_t mask_first_odd = vmfne_vx_i32m1_b32(vremu_vx_i32m1(first_digit, 2, vl), 0, vl);\n        vbool32_t mask_last_odd = vmfne_vx_i32m1_b32(vremu_vx_i32m1(last_digit, 2, vl), 0, vl);\n        vbool32_t mask_odd_digits = vmand_mm(mask_first_odd, mask_last_odd, vl);\n\n        // Combine masks: greater than 10 AND both digits odd\n        vbool32_t final_mask = vmand_mm(mask_gt_10, mask_odd_digits, vl);\n\n        // Count the number of true elements in the final mask\n        result += vcpop_m_b32(final_mask, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_131_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint specialFilter_simd(const std::vector<int> &nums) {\n    size_t vlmax = vsetvlmax_e32m8();\n    int result = 0;\n\n    for (size_t i = 0; i < nums.size(); i += vlmax) {\n        size_t vl = vsetvl_e32m8(nums.size() - i);\n\n        // Load vector of integers\n        vint32m8_t vec = vle32_v_i32m8(&nums[i], vl);\n\n        // Check if numbers are greater than 10\n        vbool4_t mask_gt_10 = vmfgt_vx_i32m8_b4(vec, 10, vl);\n\n        // Extract first digit\n        vint32m8_t temp = vec;\n        vbool4_t mask_positive = vmfgt_vx_i32m8_b4(temp, 0, vl);\n        temp = vneg_v_i32m8_m(mask_positive, temp, vl); // Make all numbers positive\n        while (1) {\n            vbool4_t mask_ge_10 = vmfge_vx_i32m8_b4(temp, 10, vl);\n            vint32m8_t div = vdiv_vx_i32m8_m(mask_ge_10, temp, 10, vl);\n            temp = vmerge_vxm_i32m8(mask_ge_10, div, temp, vl);\n            if (!vmreduce_any_true_b4(mask_ge_10, vl)) break;\n        }\n        vint32m8_t first_digit = temp;\n\n        // Extract last digit\n        vint32m8_t last_digit = vrem_vx_i32m8(vec, 10, vl);\n        last_digit = vabs_v_i32m8(last_digit, vl); // Ensure last digit is positive\n\n        // Check if first and last digits are odd\n        vbool4_t mask_first_odd = vmsne_vx_i32m8_b4(vand_vx_i32m8(first_digit, 1, vl), 0, vl);\n        vbool4_t mask_last_odd = vmsne_vx_i32m8_b4(vand_vx_i32m8(last_digit, 1, vl), 0, vl);\n\n        // Combine conditions: greater than 10 AND first digit odd AND last digit odd\n        vbool4_t mask_combined = vmand_mm(mask_gt_10, vmand_mm(mask_first_odd, mask_last_odd, vl), vl);\n\n        // Count the number of elements satisfying the condition\n        result += vcpop_m_b4(mask_combined, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_131_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint specialFilter_simd(const std::vector<int> &nums) {\n    size_t vlmax = vsetvlmax_e32m1();\n    int result = 0;\n\n    for (size_t i = 0; i < nums.size(); i += vlmax) {\n        size_t vl = vsetvl_e32m1(nums.size() - i);\n\n        // Load vector of integers from memory\n        vint32m1_t vec = vle32_v_i32m1(&nums[i], vl);\n\n        // Check if numbers are greater than 10\n        vbool32_t mask_gt_10 = vmfgt_vx_i32m1_b32(vec, 10, vl);\n\n        // Extract first digit\n        vint32m1_t temp_first = vec;\n        vbool32_t mask_nonzero = vmfne_vx_i32m1_b32(temp_first, 0, vl);\n        while (vmfne_vx_i32m1_b32(vmsgtu_vx_i32m1_b32(temp_first, 9, vl), 0, vl)) {\n            temp_first = vsra_vx_i32m1(temp_first, 1, vl);\n        }\n        vint32m1_t first_digit = temp_first;\n\n        // Extract last digit\n        vint32m1_t last_digit = vand_vx_i32m1(vec, 0xF, vl);\n\n        // Check if both first and last digits are odd\n        vbool32_t mask_first_odd = vmfne_vx_i32m1_b32(vand_vx_i32m1(first_digit, 1, vl), 0, vl);\n        vbool32_t mask_last_odd = vmfne_vx_i32m1_b32(vand_vx_i32m1(last_digit, 1, vl), 0, vl);\n        vbool32_t mask_odd = vmand_mm(mask_first_odd, mask_last_odd, vl);\n\n        // Combine conditions: greater than 10 and both digits odd\n        vbool32_t mask_final = vmand_mm(mask_gt_10, mask_odd, vl);\n\n        // Count the number of elements satisfying the condition\n        result += vcpop_m_b32(mask_final, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_132_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    uint64_t count = 0;\n    size_t vl;\n\n    // Allocate memory for the array a\n    uint64_t *a = (uint64_t *)malloc(n * sizeof(uint64_t));\n    if (!a) return 0;\n\n    // Compute a[i] = i * i - i + 1 using RVV intrinsics\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e64m1(n - i);\n        vuint64m1_t vi = vid_v_u64m1(vl); // Generate indices [0, vl)\n        vi = vadd_vx_u64m1(vi, i, vl);    // Adjust indices to [i, i + vl)\n        vuint64m1_t vi_sq = vmul_vv_u64m1(vi, vi, vl); // vi^2\n        vuint64m1_t vi_val = vsub_vv_u64m1(vi_sq, vi, vl); // vi^2 - vi\n        vi_val = vadd_vx_u64m1(vi_val, 1, vl); // vi^2 - vi + 1\n        vse64_v_u64m1(a + i, vi_val, vl); // Store results in a\n    }\n\n    // Count triples where (a[i] + a[j] + a[k]) % 3 == 0\n    for (size_t i = 0; i < n; ++i) {\n        for (size_t j = i + 1; j < n; j += vl) {\n            vl = vsetvl_e64m1(n - j);\n            vuint64m1_t vj = vle64_v_u64m1(a + j, vl); // Load a[j] to a[j + vl]\n            for (size_t k = j + 1; k < n; k += vl) {\n                size_t vl_k = vsetvl_e64m1(n - k);\n                vuint64m1_t vk = vle64_v_u64m1(a + k, vl_k); // Load a[k] to a[k + vl_k]\n\n                // Compute sums and check modulo 3\n                vuint64m1_t sum = vadd_vx_u64m1(vj, a[i], vl);\n                sum = vadd_vv_u64m1(sum, vk, vl_k);\n                vbool64_t mask = vmseq_vx_u64m1(vmod_vx_u64m1(sum, 3, vl_k), 0, vl_k);\n\n                // Count valid triples\n                count += vcpop_m_b64(vmseq_vx_u64m1(mask, 1, vl_k));\n            }\n        }\n    }\n\n    free(a);\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    uint64_t count = 0;\n    size_t vlmax = vsetvlmax_e32m8();\n    uint32_t *a = (uint32_t *)malloc(n * sizeof(uint32_t));\n\n    // Compute a[i] = i * i - i + 1 for all i in parallel\n    for (size_t i = 0; i < n; i += vlmax) {\n        size_t vl = vsetvl_e32m8(n - i);\n        vuint32m8_t vi = vid_v_u32m8(vl);\n        vi = vfadd_vx_u32m8(vi, i, vl); // Add offset to indices\n        vuint32m8_t vi_sq = vfmul_vv_u32m8(vi, vi, vl);\n        vuint32m8_t vi_val = vfsub_vv_u32m8(vi_sq, vi, vl);\n        vi_val = vfadd_vx_u32m8(vi_val, 1, vl);\n        vse32_v_u32m8(a + i, vi_val, vl);\n    }\n\n    // Count triples where (a[i] + a[j] + a[k]) % 3 == 0\n    for (size_t i = 0; i < n; ++i) {\n        for (size_t j = i + 1; j < n; j += vlmax) {\n            size_t vl = vsetvl_e32m8(n - j);\n            vuint32m8_t vj = vle32_v_u32m8(a + j, vl);\n            vuint32m8_t vijk_sum = vfadd_vx_u32m8(vj, a[i], vl);\n\n            for (size_t k = j + 1; k < n; k += vlmax) {\n                size_t vl_k = vsetvl_e32m8(n - k);\n                vuint32m8_t vk = vle32_v_u32m8(a + k, vl_k);\n                vuint32m8_t sum_mod = vfadd_vv_u32m8(vijk_sum, vk, vl_k);\n                sum_mod = vremu_vx_u32m8(sum_mod, 3, vl_k);\n\n                vmask_t mask = vmseq_vx_u32m8_b32(sum_mod, 0, vl_k);\n                count += vcpop_m_b32(mask, vl_k);\n            }\n        }\n    }\n\n    free(a);\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    size_t vl;\n    uint64_t count = 0;\n\n    // Allocate memory for the array a\n    uint64_t *a = (uint64_t *)malloc(n * sizeof(uint64_t));\n    if (!a) return 0;\n\n    // Compute a[i] = i * i - i + 1 using scalar code\n    for (uint64_t i = 0; i < n; ++i) {\n        a[i] = i * i - i + 1;\n    }\n\n    // Process triples using RVV intrinsics\n    for (uint64_t i = 0; i < n - 2; ++i) {\n        uint64_t j = i + 1;\n        while (j < n - 1) {\n            vl = vsetvl_e64m8(n - j - 1); // Set vector length for k loop\n\n            // Load a[j] as a broadcasted scalar\n            vuint64m8_t aj_vec = vmv_v_x_u64m8(a[j], vl);\n\n            // Load a[k] values into a vector\n            vuint64m8_t ak_vec = vle64_v_u64m8(&a[j + 1], vl);\n\n            // Compute a[i] + a[j] + a[k]\n            vuint64m8_t sum_vec = vadd_vx_u64m8(aj_vec, a[i], vl);\n            sum_vec = vadd_vv_u64m8(sum_vec, ak_vec, vl);\n\n            // Check if (a[i] + a[j] + a[k]) % 3 == 0\n            vbool8_t mask = vmseq_vx_u64m8(vrem_vx_u64m8(sum_vec, 3, vl), 0, vl);\n\n            // Count the number of valid triples\n            count += vcpop_m_b8(vmseq_vx_u64m8(mask, -1, vl));\n\n            j += vl; // Move to the next chunk\n        }\n    }\n\n    free(a);\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    uint64_t count = 0;\n    size_t vl;\n\n    // Allocate memory for the array a\n    uint64_t *a = (uint64_t *)malloc(n * sizeof(uint64_t));\n    if (!a) return 0;\n\n    // Compute a[i] = i * i - i + 1 using scalar code\n    for (uint64_t i = 0; i < n; ++i) {\n        a[i] = i * i - i + 1;\n    }\n\n    // Precompute modulo 3 values for all elements in a\n    uint8_t *mod3 = (uint8_t *)malloc(n * sizeof(uint8_t));\n    if (!mod3) {\n        free(a);\n        return 0;\n    }\n\n    for (uint64_t i = 0; i < n; ++i) {\n        mod3[i] = a[i] % 3;\n    }\n\n    // Count triples using RVV intrinsics\n    for (uint64_t i = 0; i < n; i++) {\n        uint64_t j = i + 1;\n        while (j < n) {\n            vl = vsetvl_e8m1(n - j); // Set vector length for remaining elements\n            vuint8m1_t mod3_j = vle8_v_u8m1(&mod3[j], vl); // Load mod3[j..j+vl-1]\n            vuint8m1_t target_mod = vmv_v_x_u8m1((3 - ((mod3[i] + mod3[j]) % 3)) % 3, vl); // Target mod value\n\n            // Compare mod3[k] with target_mod\n            vbool8_t mask = vmseq_vv_u8m1_b8(mod3_j, target_mod, vl);\n\n            // Count matches\n            count += vcpop_m_b8(mask, vl);\n\n            j += vl; // Move to next chunk\n        }\n    }\n\n    free(a);\n    free(mod3);\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    uint64_t count = 0;\n    size_t vlmax = vsetvlmax_e32m8();\n    uint32_t *a = (uint32_t *)malloc(n * sizeof(uint32_t));\n\n    // Compute the array a[i] = i * i - i + 1 using RVV\n    for (size_t i = 0; i < n; i += vlmax) {\n        size_t vl = vsetvl_e32m8(n - i);\n        vuint32m8_t vi = vid_v_u32m8(vl); // Generate indices [0, 1, ..., vl-1]\n        vuint32m8_t vi_plus_1 = vadd_vx_u32m8(vi, i + 1, vl); // Adjust to [i+1, i+2, ...]\n        vuint32m8_t vi_squared = vmul_vv_u32m8(vi_plus_1, vi_plus_1, vl); // (i+1)^2\n        vuint32m8_t vi_linear = vsub_vx_u32m8(vi_squared, vi_plus_1, vl); // (i+1)^2 - (i+1)\n        vuint32m8_t vi_final = vadd_vx_u32m8(vi_linear, 1, vl); // (i+1)^2 - (i+1) + 1\n        vse32_v_u32m8(a + i, vi_final, vl); // Store results in array a\n    }\n\n    // Count triples where (a[i] + a[j] + a[k]) % 3 == 0\n    for (size_t i = 0; i < n; ++i) {\n        for (size_t j = i + 1; j < n; ++j) {\n            size_t k_start = j + 1;\n            size_t k_end = n;\n\n            for (size_t k = k_start; k < k_end; k += vlmax) {\n                size_t vl = vsetvl_e32m8(k_end - k);\n                vuint32m8_t vk = vle32_v_u32m8(a + k, vl); // Load a[k], a[k+1], ...\n                vuint32m8_t sum_k = vadd_vx_u32m8(vk, a[i] + a[j], vl); // a[i] + a[j] + a[k]\n                vbool32_t mask = vmseq_vx_u32m8(vrem_vx_u32m8(sum_k, 3, vl), 0, vl); // (sum % 3 == 0)\n                count += vcpop_m_b32(vmseq_vx_u32m8(mask, -1, vl)); // Count true values\n            }\n        }\n    }\n\n    free(a);\n    return count;\n}\n```"}
{"task_id": "SimdBench_133_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    size_t vlmax = __riscv_vsetvlmax_e32m1();\n    int result = y;\n\n    if (n <= 1) return y;\n\n    // Create a vector of integers from 2 to vlmax\n    int elems[vlmax];\n    for (int i = 0; i < vlmax; i++) {\n        elems[i] = i + 2;\n    }\n\n    // Load the vector\n    vint32m1_t vec = __riscv_vle32_v_i32m1(elems, vlmax);\n\n    // Broadcast n to a vector\n    vint32m1_t vec_n = __riscv_vmv_v_x_i32m1(n, vlmax);\n\n    // Compute modulus: vec_mod = vec_n % vec\n    vint32m1_t vec_mod = __riscv_vmod_vv_i32m1(vec_n, vec, vlmax);\n\n    // Check if any element in vec_mod is zero\n    vbool32_t vec_zero_mask = __riscv_vmseq_vx_i32m1_b32(vec_mod, 0, vlmax);\n\n    // If any element is zero, then n is not prime\n    if (__riscv_vfirst_m_b32(vec_zero_mask, vlmax) != -1) {\n        result = y;\n    } else {\n        result = x;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_133_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    size_t vlmax = vsetvlmax_e32m1();\n    int result = y;\n\n    if (n <= 1) return y;\n\n    // Create a vector of integers from 2 to vlmax\n    vint32m1_t vec_indices = vid_v_i32m1(vlmax);\n    vec_indices = vadd_vx_i32m1(vec_indices, 2, vlmax);\n\n    // Create a mask for the vector elements less than n\n    vbool32_t mask = vmseq_vx_i32m1_b32(vec_indices, n, vlmax);\n\n    // Initialize a vector of ones (true) for primality check\n    vbool32_t is_prime = vmset_v_i32m1_b32(mask, vlmax);\n\n    // Loop through potential divisors in parallel\n    for (int i = 2; i * i <= n; ++i) {\n        vbool32_t divisible = vmseq_vx_i32m1_b32(vrem_vx_i32m1(vec_indices, i, vlmax), 0, vlmax);\n        is_prime = vmnand_vv_i32m1_b32(is_prime, divisible, vlmax);\n    }\n\n    // Check if any element in the vector indicates primality\n    if (vmreduce_any_true_b32(is_prime, vlmax)) {\n        result = x;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_133_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    size_t vlmax = vsetvlmax_e32m1();\n    int result;\n\n    // Broadcast n into a vector register\n    vint32m1_t vn = vmv_v_x_i32m1(n, vlmax);\n\n    // Initialize a vector of integers from 2 to vlmax+1\n    vint32m1_t vi = vid_v_i32m1(vlmax);\n    vi = vadd_vx_i32m1(vi, 2, vlmax);\n\n    // Compute n % i for all i in parallel\n    vint32m1_t mod_result = vrem_vv_i32m1(vn, vi, vlmax);\n\n    // Create a mask where mod_result == 0 (i.e., n is divisible by i)\n    vbool32_t div_mask = vmseq_vx_i32m1_b32(mod_result, 0, vlmax);\n\n    // Check if any element in the mask is true (i.e., n is not prime)\n    if (vmfirst_m_b32(div_mask, vlmax) != -1) {\n        result = y; // n is not prime\n    } else {\n        result = x; // n is prime\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_133_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    size_t vlmax = vsetvlmax_e32m1();\n    int result = y;\n\n    if (n <= 1) return y;\n\n    // Create a vector of integers from 2 to VLMAX\n    vint32m1_t vec_indices = vid_v_i32m1(vlmax);\n    vint32m1_t vec_n = vmv_v_x_i32m1(n, vlmax);\n    vbool32_t vec_mask = vmseq_vx_i32m1_b32(vec_indices, 0, vlmax); // Initialize mask\n\n    // Check divisors in parallel\n    for (size_t vl = vsetvl_e32m1(n - 2); vl > 0; vl = vsetvl_e32m1(n - 2)) {\n        vint32m1_t vec_divisors = vadd_vx_i32m1(vec_indices, 2, vl);\n        vbool32_t vec_divisible = vmseq_vx_i32m1_b32(vmod_vv_i32m1(vec_n, vec_divisors, vl), 0, vl);\n        vec_mask = vmor_vv_i32m1_b32(vec_mask, vec_divisible, vl);\n    }\n\n    // Reduce the mask to check if any divisor was found\n    int any_divisor = vmreduce_any_i32m1_b32(vec_mask, vlmax);\n\n    if (!any_divisor) {\n        result = x;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_133_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    size_t vlmax = __riscv_vsetvlmax_e32m1();\n    int result = y;\n\n    if (n <= 1) return y;\n\n    // Create a vector of integers from 2 to vlmax\n    int mask[vlmax];\n    for (int i = 0; i < vlmax; ++i) {\n        mask[i] = i + 2;\n    }\n\n    // Load the mask into a vector register\n    vint32m1_t vec_mask = __riscv_vle32_v_i32m1(mask, vlmax);\n\n    // Broadcast n into a vector\n    vint32m1_t vec_n = __riscv_vmv_v_x_i32m1(n, vlmax);\n\n    // Compute n % mask for all elements in parallel\n    vint32m1_t vec_mod = __riscv_vmod_vv_i32m1(vec_n, vec_mask, vlmax);\n\n    // Check if any element is zero (i.e., n is divisible by some number)\n    vbool32_t vec_zero = __riscv_vmseq_vx_i32m1_b32(vec_mod, 0, vlmax);\n    int is_divisible = __riscv_vmpopc_m_b32(__riscv_vfirst_m_b32(vec_zero, vlmax), vlmax);\n\n    if (!is_divisible) {\n        result = x;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_134_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    size_t vlmax = vsetvlmax_e32m8();\n    uint64_t result = 0;\n\n    for (size_t i = 0; i < lst.size(); i += vlmax) {\n        size_t vl = vsetvl_e32m8(lst.size() - i);\n\n        // Load vector of floats from memory\n        vfloat32m8_t vf = vle32_v_f32m8(&lst[i], vl);\n\n        // Create a mask for positive numbers\n        vbool4_t positive_mask = vmflt_vf_f32m8_b4(vf, 0.0f, vl);\n\n        // Convert floats to integers (truncate towards zero)\n        vint32m8_t vi = vfcvt_x_f_v_i32m8(vf, vl);\n\n        // Create a mask for odd integers\n        vbool4_t odd_mask = vmnot_mm_b4(vmod_vx_i32m8_b4(vi, 2, vl), vl);\n\n        // Combine masks: positive and odd\n        vbool4_t combined_mask = vmand_mm_b4(positive_mask, odd_mask, vl);\n\n        // Square the integers\n        vint32m8_t squared = vwmul_vv_i32m8(vi, vi, vl);\n\n        // Apply the combined mask to select valid squared values\n        vint32m8_t masked_squared = vmerge_vxm_i32m8(squared, 0, combined_mask, vl);\n\n        // Reduce the valid squared values into a scalar sum\n        while (vl > 1) {\n            vl = vsetvl_e32m8(vl / 2);\n            masked_squared = vredsum_vs_i32m8_i32m8(masked_squared, masked_squared, vl);\n        }\n\n        // Extract the final sum for this iteration\n        int32_t partial_sum;\n        vse32_v_i32m8(&partial_sum, masked_squared, 1);\n        result += partial_sum;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_134_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    size_t vlmax = vsetvlmax_e32m8();\n    uint64_t result = 0;\n\n    for (size_t i = 0; i < lst.size(); i += vlmax) {\n        size_t vl = vsetvl_e32m8(std::min(vlmax, lst.size() - i));\n\n        // Load vector of floats from memory\n        vfloat32m8_t vf = vle32_v_f32m8(&lst[i], vl);\n\n        // Create a mask for positive numbers\n        vbool4_t vm_positive = vmfgt_vf_f32m8_b4(vf, 0.0f, vl);\n\n        // Truncate floats to integers\n        vint32m8_t vi = vfncvt_x_f_w_i32m8(vf, vl);\n\n        // Check if the integers are odd\n        vbool4_t vm_odd = vmfne_vx_i32m8_b4(vi, vadd_vx_i32m8(vi, 1, vl), vl);\n\n        // Combine masks: positive and odd\n        vbool4_t vm_combined = vm_and(vm_positive, vm_odd, vl);\n\n        // Square the original float values\n        vfloat32m8_t vf_squared = vfmul_vv_f32m8(vf, vf, vl);\n\n        // Convert squared floats to integers\n        vint64m8_t vi_squared = vfncvt_rtz_x_f_v_i64m8(vf_squared, vl);\n\n        // Compress the results based on the combined mask\n        vint64m8_t vi_compressed = vcompress_vm_i64m8(vm_combined, vi_squared, vl);\n\n        // Reduce the compressed results to scalar\n        for (size_t j = 0; j < vl; ++j) {\n            if (vm_combined[j]) {\n                result += vi_compressed[j];\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_134_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    size_t vlmax = vsetvlmax_e32m8();\n    uint64_t result = 0;\n\n    for (size_t i = 0; i < lst.size(); i += vlmax) {\n        size_t vl = vsetvl_e32m8(lst.size() - i);\n\n        // Load vector of floats from memory\n        vfloat32m8_t vf = vle32_v_f32m8(&lst[i], vl);\n\n        // Create a mask for positive numbers\n        vbool4_t positive_mask = vmfgt_vf_f32m8_b4(vf, 0.0f, vl);\n\n        // Truncate floats to integers\n        vint32m8_t vi = vfcvt_x_f_v_i32m8(vf, vl);\n\n        // Check if integers are odd\n        vbool4_t odd_mask = vmfne_vx_i32m8_b4(vi, vadd_vx_i32m8(vi, 1, vl), vl);\n\n        // Combine masks: positive and odd\n        vbool4_t combined_mask = vmand_mm_b4(positive_mask, odd_mask, vl);\n\n        // Square the original floats\n        vfloat32m8_t squared = vfmul_vv_f32m8(vf, vf, vl);\n\n        // Apply mask to select squared values of positive odd integers\n        vfloat32m8_t masked_squared = vmerge_vxm_f32m8(squared, 0.0f, combined_mask, vl);\n\n        // Reduce the selected squared values to sum\n        while (vl > 1) {\n            vl = vsetvl_e32m8(vl / 2);\n            masked_squared = vfredusum_vs_f32m8_f32m8(masked_squared, masked_squared, 0.0f, vl);\n        }\n\n        // Accumulate the final sum into the scalar result\n        float temp_result;\n        vse32_v_f32m8(&temp_result, masked_squared, 1);\n        result += static_cast<uint64_t>(temp_result);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_134_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    size_t vlmax = vsetvlmax_e32m8();\n    uint64_t result = 0;\n\n    for (size_t i = 0; i < lst.size(); i += vlmax) {\n        size_t vl = vsetvl_e32m8(std::min(vlmax, lst.size() - i));\n\n        // Load vector of floats from memory\n        vfloat32m8_t vf = vle32_v_f32m8(&lst[i], vl);\n\n        // Create a mask for positive numbers\n        vbool4_t vm_positive = vmflt_vf_f32m8_b4(vf, 0.0f, vl);\n\n        // Truncate floats to integers and check if they are odd\n        vint32m8_t vi = vfcvt_x_f_v_i32m8(vf, vl);\n        vbool4_t vm_odd = vmnot_m_b4(vmfeq_vx_i32m8_b4(vi, 0, vl), vl);\n        vm_odd = vmand_mm_b4(vm_odd, vmnot_m_b4(vmfne_vx_i32m8_b4(vi, 1, vl), vl), vl);\n\n        // Combine masks: positive and odd\n        vbool4_t vm_valid = vmand_mm_b4(vm_positive, vm_odd, vl);\n\n        // Square the valid numbers\n        vfloat32m8_t vf_squared = vfmul_vv_f32m8_m(vm_valid, vf, vf, vl);\n\n        // Convert squared floats to integers and accumulate\n        vint32m8_t vi_squared = vfcvt_x_f_v_i32m8_m(vm_valid, vf_squared, vl);\n        result += vwredsum_vs_i32m8_i64m1(vi_squared, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_134_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    size_t vlmax = vsetvlmax_e32m8();\n    uint64_t result = 0;\n\n    for (size_t i = 0; i < lst.size(); i += vlmax) {\n        size_t vl = vsetvl_e32m8(std::min(vlmax, lst.size() - i));\n\n        // Load vector of floats from memory\n        vfloat32m8_t vf = vle32_v_f32m8(&lst[i], vl);\n\n        // Create a mask for positive numbers\n        vbool4_t vm_positive = vmflt_vf_f32m8_b4(vf, 0.0f, vl);\n\n        // Truncate floats to integers\n        vint32m8_t vi = vfcvt_x_f_v_i32m8(vf, vl);\n\n        // Check if integers are odd\n        vbool4_t vm_odd = vmnot_mm_b4(vmod_vx_i32m8_b4(vi, 2, vl), vl);\n\n        // Combine masks: positive and odd\n        vbool4_t vm_valid = vmand_mm_b4(vm_positive, vm_odd, vl);\n\n        // Square the valid integers\n        vint32m8_t vsquared = vwmul_vv_i32m8(vi, vi, vl);\n\n        // Compress the squared values based on the mask\n        vint32m8_t vsquared_compressed = vcompress_vm_i32m8(vsquared, vm_valid, vl);\n\n        // Reduce the compressed values to scalar sum\n        int32_t temp_sum = 0;\n        for (size_t j = 0; j < vl; ++j) {\n            if (vm_valid[j]) {\n                temp_sum += vsquared_compressed[j];\n            }\n        }\n        result += temp_sum;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t len = game.size();\n    std::vector<int> result(len);\n\n    size_t vl;\n    size_t i = 0;\n\n    while (i < len) {\n        vl = vsetvl_e32m8(len - i);\n\n        vint32m8_t v_game = vle32_v_i32m8(&game[i], vl);\n        vint32m8_t v_guess = vle32_v_i32m8(&guess[i], vl);\n\n        vbool4_t mask = vmseq_vv_i32m8_b4(v_game, v_guess);\n        vint32m8_t v_diff = vmsub_vv_i32m8(v_game, v_guess, mask);\n        vint32m8_t v_abs_diff = vabs_v_i32m8(v_diff, vl);\n\n        vse32_v_i32m8(&result[i], v_abs_diff, vl);\n\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t len = game.size();\n    std::vector<int> result(len);\n\n    size_t vl;\n    size_t i = 0;\n\n    while (i < len) {\n        vl = vsetvl_e32m8(len - i);\n\n        vint32m8_t v_game = vle32_v_i32m8(&game[i], vl);\n        vint32m8_t v_guess = vle32_v_i32m8(&guess[i], vl);\n\n        vbool4_t mask = vmseq_vv_i32m8_b4(v_game, v_guess);\n        vint32m8_t diff = vsub_vv_i32m8(v_game, v_guess);\n        vint32m8_t abs_diff = vand_vx_i32m8(diff, -(diff > 0), vl);\n\n        vint32m8_t res = vmerge_vxm_i32m8(mask, 0, abs_diff, vl);\n        vse32_v_i32m8(&result[i], res, vl);\n\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t len = game.size();\n    std::vector<int> result(len);\n\n    size_t vl;\n    size_t i = 0;\n\n    while (i < len) {\n        vl = vsetvl_e32m8(len - i);\n\n        vint32m8_t vg1 = vle32_v_i32m8(&game[i], vl);\n        vint32m8_t vg2 = vle32_v_i32m8(&guess[i], vl);\n\n        vbool4_t mask = vmseq_vv_i32m8_b4(vg1, vg2);\n        vint32m8_t diff = vsub_vv_i32m8(vg1, vg2);\n        diff = vabs_v_i32m8(diff, vl);\n\n        vint32m8_t res = vmerge_vxm_i32m8(mask, 0, diff, vl);\n\n        vse32_v_i32m8(&result[i], res, vl);\n\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t len = game.size();\n    std::vector<int> result(len);\n\n    size_t vl;\n    size_t i = 0;\n\n    while (i < len) {\n        vl = vsetvl_e32m8(len - i);\n\n        vint32m8_t game_vec = vle32_v_i32m8(&game[i], vl);\n        vint32m8_t guess_vec = vle32_v_i32m8(&guess[i], vl);\n\n        vbool4_t mask = vmseq_vv_i32m8_b4(game_vec, guess_vec, vl);\n        vint32m8_t diff_vec = vsub_vv_i32m8(game_vec, guess_vec, vl);\n        diff_vec = vabs_v_i32m8(diff_vec, vl);\n\n        vint32m8_t result_vec = vmerge_vxm_i32m8(mask, 0, diff_vec, vl);\n\n        vse32_v_i32m8(&result[i], result_vec, vl);\n\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t len = game.size();\n    std::vector<int> result(len);\n\n    size_t vl;\n    size_t i = 0;\n    while (i < len) {\n        vl = vsetvl_e32m8(len - i);\n\n        vint32m8_t v_game = vle32_v_i32m8(&game[i], vl);\n        vint32m8_t v_guess = vle32_v_i32m8(&guess[i], vl);\n\n        vbool4_t mask = vmseq_vv_i32m8_b4(v_game, v_guess);\n        vint32m8_t diff = vsub_vv_i32m8(v_game, v_guess);\n        vint32m8_t abs_diff = vand_vx_i32m8(diff, -(diff > 0), vl);\n\n        vint32m8_t result_vec = vmerge_vxm_i32m8(mask, 0, abs_diff, vl);\n\n        vse32_v_i32m8(&result[i], result_vec, vl);\n\n        i += vl;\n    }\n\n    return result;\n}\n```"}

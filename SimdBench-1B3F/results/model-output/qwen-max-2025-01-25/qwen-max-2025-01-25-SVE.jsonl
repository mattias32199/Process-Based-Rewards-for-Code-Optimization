{"task_id": "SimdBench_0_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, length);\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svint64_t src_vec = svld1(pg, &src[i]);\n        svbool_t mask_vec = svld1sb(pg, &mask[i]);\n        svst1_m(pg, &dst[i], src_vec, mask_vec);\n        i += svcntd();\n        pg = svwhilelt_b64(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_0_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, length);\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svint64_t src_vec = svld1(pg, &src[i]);\n        svbool_t mask_vec = svld1sb(pg, &mask[i]);\n        svst1_m(pg, &dst[i], src_vec, mask_vec);\n        i += svcntd();\n        pg = svwhilelt_b64(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_0_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, length);\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svint64_t src_vec = svld1(pg, &src[i]);\n        svbool_t mask_vec = svld1sb(pg, &mask[i]);\n        svst1(pg, &dst[i], svsel(mask_vec, src_vec, svld1(pg, &dst[i])));\n        i += svcntd();\n        pg = svwhilelt_b64(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_0_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, length);\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svint64_t src_vec = svld1(pg, &src[i]);\n        svbool_t mask_vec = svld1sb(pg, &mask[i]);\n        svst1(pg, &dst[i], svsel(mask_vec, src_vec, svld1(pg, &dst[i])));\n        i += svcntd();\n        pg = svwhilelt_b64(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_0_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, length);\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svint64_t src_vec = svld1(pg, &src[i]);\n        svbool_t mask_vec = svld1sb(pg, &mask[i]);\n        svint64_t dst_vec = svld1(pg, &dst[i]);\n\n        dst_vec = svsel(mask_vec, src_vec, dst_vec);\n        svst1(pg, &dst[i], dst_vec);\n\n        i += svcntd();\n        pg = svwhilelt_b64(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t src_vec = svld1_s32(pg, &src[i]);\n        svint32_t scaled = svmul_n_s32_x(pg, src_vec, scale);\n        svint32_t tmp1 = svasr_n_s32_x(pg, scaled, 3);\n        svint32_t tmp2 = svlsl_n_s32_x(pg, scaled, 3);\n        svint32_t product = svmul_x(pg, tmp1, tmp2);\n        svint32_t result = svdiv_n_s32_x(pg, svadd_x(pg, scaled, product), 7);\n        svst1_s32(pg, &dst[i], result);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t i = 0;\n    svint32_t vscale = svdup_n_s32(scale);\n    svint32_t vseven = svdup_n_s32(7);\n\n    while (i < length) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svint32_t vsrc = svld1_s32(pg, &src[i]);\n\n        svint32_t vmul = svmul_s32_x(pg, vsrc, vscale);\n        svint32_t vtmp1 = svasr_n_s32_x(pg, vmul, 3);\n        svint32_t vtmp2 = svasl_n_s32_x(pg, vmul, 3);\n\n        svint32_t vprod = svmul_s32_x(pg, vtmp1, vtmp2);\n        svint32_t vsum = svadd_s32_x(pg, vmul, vprod);\n\n        svint32_t vresult = svdiv_s32_x(pg, vsum, vseven);\n        svst1_s32(pg, &dst[i], vresult);\n\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t src_vec = svld1_s32(pg, &src[i]);\n        svint32_t scaled = svmul_n_s32_x(pg, src_vec, scale);\n        \n        svint32_t tmp1 = svasr_n_s32_x(pg, scaled, 3);\n        svint32_t tmp2 = svlsl_n_s32_x(pg, scaled, 3);\n        \n        svint32_t product = svmul_x(pg, tmp1, tmp2);\n        svint32_t result = svdiv_n_s32_x(pg, svadd_x(pg, scaled, product), 7);\n        \n        svst1_s32(pg, &dst[i], result);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec_src = svld1_s32(pg, &src[i]);\n        svint32_t tmp1 = svasr_n_s32_x(pg, svmul_n_s32_x(pg, vec_src, scale), 3);\n        svint32_t tmp2 = svasl_n_s32_x(pg, svmul_n_s32_x(pg, vec_src, scale), 3);\n        svint32_t result = svdiv_n_s32_x(pg, svadd_s32_x(pg, svmul_n_s32_x(pg, vec_src, scale), svmul_s32_x(pg, tmp1, tmp2)), 7);\n        svst1_s32(pg, &dst[i], result);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t src_vec = svld1_s32(pg, &src[i]);\n        svint32_t scaled = svmul_n_s32_x(pg, src_vec, scale);\n        \n        svint32_t tmp1 = svasr_n_s32_x(pg, scaled, 3);\n        svint32_t tmp2 = svlsl_n_s32_x(pg, scaled, 3);\n        \n        svint32_t tmp1_mul_tmp2 = svmul_x(pg, tmp1, tmp2);\n        svint32_t result = svdiv_n_s32_x(pg, svadd_x(pg, scaled, tmp1_mul_tmp2), 7);\n        \n        svst1_s32(pg, &dst[i], result);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, rows);\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svuint64_t indices = svindex_u64(i * cols + stride, cols);\n        svfloat64_t values = svld1_gather_index_f64(pg, src, indices);\n        svst1_f64(pg, dst + i, values);\n\n        i += svcntd();\n        pg = svwhilelt_b64(i, rows);\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, rows);\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svuint64_t indices = svindex_u64(i * cols + stride, cols);\n        svfloat64_t vec = svld1_gather_index_f64(pg, src, indices);\n        svst1_f64(pg, dst + i, vec);\n        i += svcntd();\n        pg = svwhilelt_b64(i, rows);\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, rows);\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svuint64_t indices = svindex_u64(i * cols + stride, cols);\n        svfloat64_t vec = svld1_gather_index_f64(pg, src, indices);\n        svst1_f64(pg, dst + i, vec);\n        i += svcntd();\n        pg = svwhilelt_b64(i, rows);\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, rows);\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svuint64_t indices = svindex_u64(i * cols + stride, cols);\n        svfloat64_t vec = svld1_gather_index_f64(pg, src, indices);\n        svst1_f64(pg, dst + i, vec);\n        i += svcntd();\n        pg = svwhilelt_b64(i, rows);\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, rows);\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svuint64_t indices = svindex_u64(i * cols + stride, cols);\n        svfloat64_t values = svld1_gather_index_f64(pg, src, indices);\n        svst1_f64(pg, dst + i, values);\n\n        i += svcntd();\n        pg = svwhilelt_b64(i, rows);\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Gather operation: dst[i] = src[indices[i]]\n        svuint32_t idx_vec = svld1uw(pg, indices + i);\n        svfloat32_t gather_vec = svtbl_f32(sveor_f32(svdup_f32(0.0f)), idx_vec);\n        svst1_f32(pg, dst + i, gather_vec);\n\n        // Scatter operation: dst[indices[i]] = src[i]\n        svfloat32_t src_vec = svld1_f32(pg, src + i);\n        svst1_scatter_f32index(pg, dst, idx_vec, src_vec);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Gather operation: dst[i] = src[indices[i]]\n        svuint32_t idx_vec = svld1_gather_index_u32(pg, indices + i);\n        svfloat32_t gather_values = svld1_gather_index_f32(pg, src, idx_vec);\n        svst1_f32(pg, dst + i, gather_values);\n\n        // Scatter operation: dst[indices[i]] = src[i]\n        svfloat32_t src_values = svld1_f32(pg, src + i);\n        svst1_scatter_index_f32(pg, dst, idx_vec, src_values);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Gather operation: dst[i] = src[indices[i]]\n        svuint32_t idx_vec = svld1_gather_index_u32(pg, indices + i);\n        svfloat32_t src_vec = svld1_gather_index_f32(pg, src, idx_vec);\n        svst1_f32(pg, dst + i, src_vec);\n\n        // Scatter operation: dst[indices[i]] = src[i]\n        svfloat32_t src_val = svld1_f32(pg, src + i);\n        svst1_scatter_index_f32(pg, dst, idx_vec, src_val);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Gather operation: Load values from src using indices as lookups\n        svint32_t idx_vec = svld1_s32(pg, &indices[i]);\n        svfloat32_t gathered_values = svtbl_f32(svld1_f32(svptrue_b32(), src), svreinterpret_u32_s32(idx_vec));\n        svst1_f32(pg, &dst[i], gathered_values);\n\n        // Scatter operation: Store values from src into dst using indices as write locations\n        svfloat32_t src_vec = svld1_f32(pg, &src[i]);\n        svst1_scatter_f32index(pg, dst, idx_vec, src_vec);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Gather operation: dst[i] = src[indices[i]]\n        svuint32_t idx_vec = svld1uw(pg, indices + i);\n        svfloat32_t gather_vec = svtbl_f32(svld1_f32(pg, src), svreinterpret_u32(idx_vec));\n        svst1_f32(pg, dst + i, gather_vec);\n\n        // Scatter operation: dst[indices[i]] = src[i]\n        svfloat32_t src_vec = svld1_f32(pg, src + i);\n        svst1_scatter_f32index(pg, dst, idx_vec, src_vec);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t length = end - start + 1;\n    uint64_t vec_len = svcntw() * 2; // Number of 16-bit elements in an SVE vector\n\n    // Align the start and end indices to vector boundaries\n    uint64_t vec_start = (start + vec_len - 1) / vec_len * vec_len;\n    uint64_t vec_end = (end / vec_len) * vec_len;\n\n    // Reverse elements before the first vector boundary\n    for (uint64_t i = 0; i < (vec_start - start) / 2; ++i) {\n        int16_t temp = arr[start + i];\n        arr[start + i] = arr[end - i];\n        arr[end - i] = temp;\n    }\n\n    // Reverse elements using SVE intrinsics\n    if (vec_start < vec_end) {\n        svbool_t pg = svwhilelt_b16(start, end + 1); // Predicate for active lanes\n        uint64_t i = vec_start;\n        uint64_t j = vec_end;\n\n        while (i < j) {\n            svint16_t vec_i = svld1(pg, arr + i);\n            svint16_t vec_j = svld1(pg, arr + j - svcntw() * 2);\n\n            // Reverse the vector elements\n            svint16_t rev_vec_i = svrev(vec_i);\n            svint16_t rev_vec_j = svrev(vec_j);\n\n            // Swap the reversed vectors\n            svst1(pg, arr + i, rev_vec_j);\n            svst1(pg, arr + j - svcntw() * 2, rev_vec_i);\n\n            i += svcntw() * 2;\n            j -= svcntw() * 2;\n        }\n    }\n\n    // Reverse elements after the last vector boundary\n    uint64_t tail_start = vec_end;\n    uint64_t tail_end = end;\n\n    for (uint64_t i = 0; i < (tail_end - tail_start + 1) / 2; ++i) {\n        int16_t temp = arr[tail_start + i];\n        arr[tail_start + i] = arr[tail_end - i];\n        arr[tail_end - i] = temp;\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t length = end - start + 1;\n    uint64_t vec_len = svcntw() * 2; // Number of 16-bit elements in an SVE vector\n\n    // Align the start and end indices to vector boundaries\n    uint64_t vec_start = (start + vec_len - 1) & ~(vec_len - 1);\n    uint64_t vec_end = (end + 1) & ~(vec_len - 1);\n\n    // Reverse elements before the first vector boundary\n    for (uint64_t i = 0; i < (vec_start - start) / 2; ++i) {\n        int16_t temp = arr[start + i];\n        arr[start + i] = arr[end - i];\n        arr[end - i] = temp;\n    }\n\n    // Reverse elements using SVE intrinsics\n    svbool_t pg = svwhilelt_b16(start, end + 1); // Predicate for active lanes\n    while (svptest_any(svptrue_b16(), pg)) {\n        svint16_t vec1 = svld1(pg, arr + start); // Load vector from start\n        svint16_t vec2 = svld1(pg, arr + end - svcntw() + 1); // Load vector from end\n\n        // Reverse the loaded vectors\n        vec1 = svrev(vec1);\n        vec2 = svrev(vec2);\n\n        // Swap the reversed vectors\n        svst1(pg, arr + start, vec2);\n        svst1(pg, arr + end - svcntw() + 1, vec1);\n\n        start += svcntw();\n        end -= svcntw();\n        pg = svwhilelt_b16(start, end + 1);\n    }\n\n    // Reverse elements after the last vector boundary\n    for (uint64_t i = 0; i < (end - vec_end + 1) / 2; ++i) {\n        int16_t temp = arr[vec_end + i];\n        arr[vec_end + i] = arr[end - i];\n        arr[end - i] = temp;\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t length = end - start + 1;\n    uint64_t vec_len = svcntw() * 2; // Number of int16_t elements per SVE vector\n\n    // Align the start and end indices to vector boundaries\n    uint64_t vec_start = (start + vec_len - 1) & ~(vec_len - 1);\n    uint64_t vec_end = (end + 1) & ~(vec_len - 1);\n\n    // Reverse elements outside the vectorized region (head and tail)\n    for (uint64_t i = 0; i < (vec_start - start) / 2; ++i) {\n        int16_t temp = arr[start + i];\n        arr[start + i] = arr[end - i];\n        arr[end - i] = temp;\n    }\n\n    // Vectorized reversal\n    svbool_t pg = svwhilelt_b16(start, end + 1); // Predicate for active lanes\n    for (uint64_t i = vec_start; i < vec_end; i += vec_len) {\n        svint16_t vec = svld1(pg, arr + i); // Load vector\n        vec = svrev(vec);                   // Reverse vector\n        svst1(pg, arr + (end - i), vec);    // Store reversed vector\n    }\n\n    // Reverse elements outside the vectorized region (tail)\n    uint64_t tail_start = vec_end;\n    uint64_t tail_end = end;\n    for (uint64_t i = 0; i < (tail_end - tail_start + 1) / 2; ++i) {\n        int16_t temp = arr[tail_start + i];\n        arr[tail_start + i] = arr[tail_end - i];\n        arr[tail_end - i] = temp;\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t len = end - start + 1;\n    uint64_t vec_len = svcntw() * 2; // Number of 16-bit elements in a vector\n\n    // Align the start and end indices to vector boundaries\n    uint64_t vec_start = (start + vec_len - 1) / vec_len * vec_len;\n    uint64_t vec_end = (end + 1) / vec_len * vec_len;\n\n    // Reverse elements before the first vector boundary\n    for (uint64_t i = start, j = end; i < vec_start && i < j; ++i, --j) {\n        int16_t temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n\n    // Reverse elements using SVE intrinsics\n    if (vec_start < vec_end) {\n        svbool_t pg = svwhilelt_b16((uint64_t)0, len);\n\n        for (uint64_t i = vec_start, j = vec_end - vec_len; i < j; i += vec_len, j -= vec_len) {\n            svint16_t vec1 = svld1(pg, arr + i);\n            svint16_t vec2 = svld1(pg, arr + j);\n\n            vec1 = svrev(vec1);\n            vec2 = svrev(vec2);\n\n            svst1(pg, arr + i, vec2);\n            svst1(pg, arr + j, vec1);\n        }\n    }\n\n    // Reverse elements after the last vector boundary\n    uint64_t tail_start = vec_end > end ? vec_end - vec_len : vec_end;\n    for (uint64_t i = tail_start, j = end; i < j; ++i, --j) {\n        int16_t temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t length = end - start + 1;\n    uint64_t vec_len = svcntw() * 2; // Number of int16_t elements per SVE vector\n\n    uint64_t i = 0;\n    for (; i + vec_len <= length / 2; i += vec_len) {\n        svint16_t vec1 = svld1_s16(svptrue_b16(), arr + start + i);\n        svint16_t vec2 = svld1_s16(svptrue_b16(), arr + end - i - vec_len + 1);\n\n        svst1_s16(svptrue_b16(), arr + start + i, vec2);\n        svst1_s16(svptrue_b16(), arr + end - i - vec_len + 1, vec1);\n    }\n\n    for (; i < length / 2; ++i) {\n        int16_t temp = arr[start + i];\n        arr[start + i] = arr[end - i];\n        arr[end - i] = temp;\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_offset = slice_idx * dim1 * dim2;\n    size_t total_elements = dim1 * dim2;\n\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b8(i, total_elements);\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t vec = svld1(pg, &tensor[slice_offset + i]);\n        svst1(pg, &slice[i], vec);\n        i += svcntb();\n        pg = svwhilelt_b8(i, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_offset = slice_idx * dim1 * dim2;\n    size_t total_elements = dim1 * dim2;\n\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b8(i, total_elements);\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t vec = svld1(pg, &tensor[slice_offset + i]);\n        svst1(pg, &slice[i], vec);\n        i += svcntb();\n        pg = svwhilelt_b8(i, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_offset = slice_idx * dim1 * dim2;\n    size_t total_elements = dim1 * dim2;\n\n    for (size_t i = 0; i < total_elements; i += svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, total_elements);\n        svuint8_t vec = svld1ub(pg, &tensor[slice_offset + i]);\n        svst1ub(pg, &slice[i], vec);\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_offset = slice_idx * dim1 * dim2;\n    size_t total_elements = dim1 * dim2;\n\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b8(i, total_elements);\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t vec = svld1(pg, &tensor[slice_offset + i]);\n        svst1(pg, &slice[i], vec);\n        i += svcntb();\n        pg = svwhilelt_b8(i, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_offset = slice_idx * dim1 * dim2;\n    size_t total_elements = dim1 * dim2;\n\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b8(i, total_elements);\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t vec = svld1(pg, &tensor[slice_offset + i]);\n        svst1(pg, &slice[i], vec);\n        i += svcntb();\n        pg = svwhilelt_b8(i, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t block_rows = (i + block_size > rows) ? (rows - i) : block_size;\n            size_t block_cols = (j + block_size > cols) ? (cols - j) : block_size;\n\n            for (size_t bi = 0; bi < block_rows; ++bi) {\n                for (size_t bj = 0; bj < block_cols; bj += svcntw()) {\n                    svbool_t pg = svwhilelt_b16(bj, block_cols);\n\n                    // Load a vector from the source block\n                    const int16_t *src_ptr = &src[(i + bi) * cols + (j + bj)];\n                    svint16_t vec = svld1(pg, src_ptr);\n\n                    // Store the transposed vector into the destination block\n                    int16_t *dst_ptr = &dst[(j + bj) * rows + (i + bi)];\n                    svst1(pg, dst_ptr, vec);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    size_t i, j, ii, jj;\n    svbool_t pg = svwhilelt_b16(0, block_size);\n\n    for (i = 0; i < rows; i += block_size) {\n        for (j = 0; j < cols; j += block_size) {\n            for (ii = 0; ii < block_size && (i + ii < rows); ++ii) {\n                for (jj = 0; jj < block_size; jj += svcntw()) {\n                    svint16_t vec = svld1(pg, &src[(i + ii) * cols + j + jj]);\n                    svst1(pg, &dst[(j + jj) * rows + i + ii], vec);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    size_t i, j, ii, jj;\n    svbool_t pg = svwhilelt_b16(0, block_size);\n\n    for (i = 0; i < rows; i += block_size) {\n        for (j = 0; j < cols; j += block_size) {\n            for (ii = 0; ii < block_size && (i + ii < rows); ++ii) {\n                for (jj = 0; jj < block_size; jj += svcntw()) {\n                    svint16_t vec = svld1(pg, &src[(i + ii) * cols + j + jj]);\n                    svst1(pg, &dst[(j + jj) * rows + i + ii], vec);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    size_t i_block, j_block, i, j, k;\n    svbool_t pg = svwhilelt_b16(0, block_size);\n\n    for (i_block = 0; i_block < rows; i_block += block_size) {\n        for (j_block = 0; j_block < cols; j_block += block_size) {\n            size_t row_limit = i_block + block_size <= rows ? block_size : rows - i_block;\n            size_t col_limit = j_block + block_size <= cols ? block_size : cols - j_block;\n\n            for (i = 0; i < row_limit; ++i) {\n                for (j = 0; j < col_limit; j += svcntw()) {\n                    svint16_t vec = svld1_s16(pg, &src[(i_block + i) * cols + (j_block + j)]);\n                    svst1_s16(pg, &dst[(j_block + j) * rows + (i_block + i)], vec);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    size_t i, j, ii, jj;\n    svbool_t pg = svwhilelt_b16(0, block_size);\n\n    for (i = 0; i < rows; i += block_size) {\n        for (j = 0; j < cols; j += block_size) {\n            for (ii = 0; ii < block_size && (i + ii < rows); ++ii) {\n                for (jj = 0; jj < block_size; jj += svcntw()) {\n                    svint16_t vec = svld1_s16(pg, &src[(i + ii) * cols + j + jj]);\n                    svst1_s16(pg, &dst[(j + jj) * rows + i + ii], vec);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b32(i, dim);\n    svfloat32_t vec_sum = svdup_f32(0.0f);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vec_vals = svld1_f32(pg, &array[i * dim * dim + i * dim + i]);\n        vec_sum = svadd_f32_z(pg, vec_sum, vec_vals);\n        i += svcntw();\n        pg = svwhilelt_b32(i, dim);\n    }\n\n    // Horizontal reduction of the vector sum\n    float temp[svcntw()];\n    svst1_f32(svptrue_b32(), temp, vec_sum);\n    for (int j = 0; j < svcntw(); ++j) {\n        sum += temp[j];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    svbool_t pg = svwhilelt_b32(0, dim); // Predicate for the vector loop\n\n    for (size_t i = 0; i < dim; i++) {\n        size_t index = i * dim * dim + i * dim + i; // Diagonal element index\n        svfloat32_t vec = svld1_f32(pg, &array[index]); // Load the diagonal element into a vector\n        sum += svaddv_f32(pg, vec); // Accumulate the sum of the vector elements\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    svbool_t pg = svwhilelt_b32(0, dim); // Predicate for the vector length\n\n    for (size_t i = 0; i < dim; i++) {\n        size_t index = i * dim * dim + i * dim + i; // Diagonal element index\n        svfloat32_t vec = svld1_f32(pg, &array[index]); // Load the diagonal element\n        sum += svaddv_f32(pg, vec); // Accumulate the sum\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    svbool_t pg = svwhilelt_b32(0, dim); // Predicate for the active lanes\n\n    for (size_t i = 0; i < dim; i++) {\n        size_t index = i * dim * dim + i * dim + i; // Diagonal element index\n        svfloat32_t vec = svld1_f32(pg, &array[index]); // Load the diagonal element\n        sum += svaddv_f32(pg, vec); // Accumulate the sum of active lanes\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    svbool_t pg = svwhilelt_b32(0, dim); // Predicate for the active lanes\n\n    for (size_t i = 0; i < dim; i++) {\n        size_t index = i * dim * dim + i * dim + i; // Diagonal element index\n        svfloat32_t vec = svld1_f32(pg, &array[index]); // Load the diagonal element\n        sum += svaddv_f32(pg, vec); // Accumulate the sum of active lanes\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t num_elements = rows * cols;\n    size_t i = 0;\n\n    svbool_t all_active = svptrue_b64();\n    svfloat64_t vec_threshold = svdup_f64(threshold);\n    svfloat64_t vec_scale = svdup_f64(scale);\n\n    for (; i + svcntd() <= num_elements; i += svcntd()) {\n        svfloat64_t vec_src = svld1_f64(all_active, &src[i]);\n        svbool_t mask = svcmpgt_f64(all_active, vec_src, vec_threshold);\n        svfloat64_t vec_dst = svmul_f64_x(mask, vec_src, vec_scale);\n        vec_dst = svsel_f64(mask, vec_dst, vec_src);\n        svst1_f64(all_active, &dst[i], vec_dst);\n    }\n\n    for (; i < num_elements; ++i) {\n        if (src[i] > threshold) {\n            dst[i] = src[i] * scale;\n        } else {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b64(i, total_elements);\n    svfloat64_t vec_threshold = svdup_f64(threshold);\n    svfloat64_t vec_scale = svdup_f64(scale);\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svfloat64_t vec_src = svld1_f64(pg, &src[i]);\n        svbool_t mask = svcmpgt_f64(pg, vec_src, vec_threshold);\n        svfloat64_t vec_result = svsel_f64(mask, svmul_f64_z(pg, vec_src, vec_scale), vec_src);\n        svst1_f64(pg, &dst[i], vec_result);\n\n        i += svcntd();\n        pg = svwhilelt_b64(i, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t num_elements = rows * cols;\n    svbool_t pg = svwhilelt_b64(0, num_elements); // Predicate for the active lanes\n\n    const double *src_ptr = src;\n    double *dst_ptr = dst;\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svfloat64_t src_vec = svld1_f64(pg, src_ptr); // Load vector from src\n        svfloat64_t threshold_vec = svdup_f64(threshold); // Broadcast threshold\n        svfloat64_t scale_vec = svdup_f64(scale); // Broadcast scale\n\n        svbool_t mask = svcmpgt_f64(pg, src_vec, threshold_vec); // Compare src > threshold\n        svfloat64_t scaled_vec = svmul_f64_z(pg, src_vec, scale_vec); // Scale values\n        svfloat64_t result_vec = svsel_f64(mask, scaled_vec, src_vec); // Select scaled or original\n\n        svst1_f64(pg, dst_ptr, result_vec); // Store result into dst\n\n        src_ptr += svcntd(); // Move to next chunk\n        dst_ptr += svcntd();\n        pg = svwhilelt_b64((size_t)(src_ptr - src), num_elements); // Update predicate\n    }\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t num_elements = rows * cols;\n    svbool_t pg = svwhilelt_b64(0, num_elements); // Predicate for the active lanes\n\n    const double* src_ptr = src;\n    double* dst_ptr = dst;\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svfloat64_t src_vec = svld1_f64(pg, src_ptr); // Load vector of doubles from src\n        svfloat64_t threshold_vec = svdup_f64(threshold); // Broadcast threshold to a vector\n        svfloat64_t scale_vec = svdup_f64(scale); // Broadcast scale to a vector\n\n        svbool_t cmp_mask = svcmpgt_f64(pg, src_vec, threshold_vec); // Compare src > threshold\n        svfloat64_t scaled_vec = svmul_f64_z(pg, src_vec, scale_vec); // Scale values where condition is true\n\n        svfloat64_t result_vec = svsel_f64(cmp_mask, scaled_vec, src_vec); // Select scaled or original values\n        svst1_f64(pg, dst_ptr, result_vec); // Store the result into dst\n\n        src_ptr += svcntd(); // Move src pointer forward by the number of elements processed\n        dst_ptr += svcntd(); // Move dst pointer forward by the number of elements processed\n        pg = svwhilelt_b64(src_ptr - src, num_elements); // Update predicate for remaining elements\n    }\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t num_elements = rows * cols;\n    svbool_t pg = svwhilelt_b64(0, num_elements); // Predicate for the active lanes\n\n    const double *src_ptr = src;\n    double *dst_ptr = dst;\n\n    do {\n        svfloat64_t src_vec = svld1_f64(pg, src_ptr); // Load vector of doubles from src\n        svfloat64_t threshold_vec = svdup_f64(threshold); // Broadcast threshold to a vector\n        svfloat64_t scale_vec = svdup_f64(scale); // Broadcast scale to a vector\n\n        svbool_t mask = svcmpgt_f64(pg, src_vec, threshold_vec); // Compare src > threshold\n        svfloat64_t scaled_vec = svmul_f64_z(pg, src_vec, scale_vec); // Scale values where mask is true\n        svfloat64_t result_vec = svsel_f64(mask, scaled_vec, src_vec); // Select scaled or original values\n\n        svst1_f64(pg, dst_ptr, result_vec); // Store the result into dst\n\n        src_ptr += svcntd(); // Move to the next chunk of data\n        dst_ptr += svcntd();\n        pg = svwhilelt_b64(src_ptr - src, num_elements); // Update predicate for remaining elements\n    } while (svptest_any(svptrue_b64(), pg)); // Continue until all elements are processed\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t i, j;\n    svbool_t pg = svwhilelt_b64(0, cols); // Predicate for vector operations\n\n    for (i = 0; i < rows; ++i) {\n        size_t src_row_index = indices[i] * cols;\n        size_t dst_row_index = i * cols;\n\n        j = 0;\n        do {\n            svfloat64_t vec = svld1(pg, &src[src_row_index + j]); // Load vector from src\n            svst1(pg, &dst[dst_row_index + j], vec);              // Store vector into dst\n            j += svcntd();                                        // Increment by vector length\n        } while (j < cols);\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t i, j;\n    svbool_t pg = svwhilelt_b64(0, cols); // Predicate for vectorized operations\n\n    for (i = 0; i < rows; ++i) {\n        size_t src_row_index = indices[i] * cols;\n        size_t dst_row_index = i * cols;\n\n        j = 0;\n        do {\n            svfloat64_t vec = svld1(pg, &src[src_row_index + j]); // Load vector from src\n            svst1(pg, &dst[dst_row_index + j], vec);              // Store vector into dst\n            j += svcntd();                                        // Increment by vector length\n        } while (j < cols);\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t i, j;\n    svbool_t pg = svwhilelt_b64(0, cols); // Predicate for vector operations\n\n    for (i = 0; i < rows; ++i) {\n        size_t src_row_idx = indices[i] * cols;\n        size_t dst_row_idx = i * cols;\n\n        j = 0;\n        do {\n            svfloat64_t vec = svld1(pg, &src[src_row_idx + j]); // Load vector from src\n            svst1(pg, &dst[dst_row_idx + j], vec);              // Store vector into dst\n            j += svcntd();                                      // Increment by vector length\n        } while (j < cols);\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t i, j;\n    svbool_t pg = svwhilelt_b64(0, cols); // Predicate for vector operations\n\n    for (i = 0; i < rows; ++i) {\n        size_t src_row_idx = indices[i] * cols;\n        size_t dst_row_idx = i * cols;\n\n        j = 0;\n        do {\n            svfloat64_t vec = svld1(pg, &src[src_row_idx + j]); // Load vector from src\n            svst1(pg, &dst[dst_row_idx + j], vec);              // Store vector into dst\n            j += svcntd();                                      // Increment by vector length\n        } while (j < cols);\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t i, j;\n    svbool_t pg = svwhilelt_b64(0, cols); // Predicate for vectorization up to cols\n\n    for (i = 0; i < rows; ++i) {\n        size_t src_row_idx = indices[i] * cols;\n        size_t dst_row_idx = i * cols;\n\n        j = 0;\n        do {\n            svfloat64_t vec = svld1(pg, &src[src_row_idx + j]); // Load vector from src\n            svst1(pg, &dst[dst_row_idx + j], vec);              // Store vector into dst\n            j += svcntd();                                      // Increment by the vector length\n        } while (j < cols);\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    svint64_t vec_scalar = svdup_n_s64(scalar);\n\n    while (i < length) {\n        svbool_t pg = svwhilelt_b64(i, length);\n        svint64_t vec_src1 = svld1_s64(pg, &src1[i]);\n        svint64_t vec_src2 = svld1_s64(pg, &src2[i]);\n\n        svint64_t vec_result = svadd_s64_x(pg, vec_src1, vec_src2);\n        vec_result = svadd_s64_x(pg, vec_result, vec_scalar);\n        vec_result = svdivr_n_s64_x(pg, vec_result, 2);\n\n        svst1_s64(pg, &dst[i], vec_result);\n        i += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    svint64_t sv_scalar = svdup_n_s64(scalar);\n    svint64_t sv_two = svdup_n_s64(2);\n\n    while (i < length) {\n        svbool_t pg = svwhilelt_b64(i, length);\n\n        svint64_t vec1 = svld1(pg, &src1[i]);\n        svint64_t vec2 = svld1(pg, &src2[i]);\n\n        svint64_t result = svadd_z(pg, vec1, vec2);\n        result = svadd_z(pg, result, sv_scalar);\n        result = svdiv_z(pg, result, sv_two);\n\n        svst1(pg, &dst[i], result);\n\n        i += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    svint64_t vec_scalar = svdup_s64(scalar); // Broadcast scalar to a vector\n    svbool_t pg = svwhilelt_b64(i, length);  // Predicate for the active lanes\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svint64_t vec_src1 = svld1(pg, &src1[i]); // Load elements from src1\n        svint64_t vec_src2 = svld1(pg, &src2[i]); // Load elements from src2\n\n        svint64_t vec_sum = svadd_s64_x(pg, vec_src1, vec_src2); // Add src1 and src2\n        vec_sum = svadd_s64_x(pg, vec_sum, vec_scalar);           // Add scalar\n        vec_sum = svdiv_s64_x(pg, vec_sum, svdup_s64(2));         // Divide by 2 (round-toward-zero)\n\n        svst1(pg, &dst[i], vec_sum); // Store result into dst\n\n        i += svcntd();               // Increment index by vector length\n        pg = svwhilelt_b64(i, length); // Update predicate\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    svint64_t sv_scalar = svdup_s64(scalar);\n    svbool_t pg = svwhilelt_b64(i, length);\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svint64_t vec1 = svld1(pg, &src1[i]);\n        svint64_t vec2 = svld1(pg, &src2[i]);\n\n        svint64_t result = svadd_s64_x(pg, vec1, vec2);\n        result = svadd_s64_x(pg, result, sv_scalar);\n        result = svdiv_n_s64_x(pg, result, 2);\n\n        svst1(pg, &dst[i], result);\n\n        i += svcntd();\n        pg = svwhilelt_b64(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    svint64_t vec_scalar = svdup_s64(scalar);\n    svbool_t pg;\n\n    for (; i <= length - svcntd(); i += svcntd()) {\n        pg = svwhilelt_b64(i, length);\n        svint64_t vec_src1 = svld1_s64(pg, &src1[i]);\n        svint64_t vec_src2 = svld1_s64(pg, &src2[i]);\n        svint64_t vec_result = svadd_s64_x(pg, vec_src1, vec_src2);\n        vec_result = svadd_s64_x(pg, vec_result, vec_scalar);\n        vec_result = svdiv_n_s64_x(pg, vec_result, 2);\n        svst1_s64(pg, &dst[i], vec_result);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    svbool_t pg = svwhilelt_b32(0, length); // Predicate for active lanes\n    svint32_t vec = svld1_s32(pg, src);    // Load the source array into a vector\n    svint32_t even_indices = svindex_s32(0, 2); // Generate even indices (0, 2, 4, ...)\n    svbool_t even_pred = svcmpeq_s32(pg, svand_s32_z(pg, even_indices, 1), 0); // Predicate for even indices\n\n    int min_val = 0x7FFFFFFF; // Initialize to maximum 32-bit integer value\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t even_vals = svcompact_s32(even_pred, vec); // Extract even-indexed elements\n        min_val = sminv_s32(min_val, even_vals);             // Compute minimum across active lanes\n        pg = svwhilelt_b32(0, length);                       // Update predicate for remaining elements\n        vec = svld1_s32(pg, src);                            // Reload next chunk of data\n    }\n\n    return (min_val == 0x7FFFFFFF) ? -1 : min_val; // Return -1 if no valid even element found\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    svbool_t pred_all = svptrue_b32();\n    svbool_t pred_even = svwhilelt_b32(0, length);\n    svint32_t vec_min = svdup_n_s32(INT32_MAX);\n\n    size_t i = 0;\n    while (svptest_any(pred_all, pred_even)) {\n        svint32_t vec = svld1_s32(pred_even, &src[i]);\n        svbool_t pred_even_elements = svbrkb_z(pred_even, pred_even);\n        svint32_t vec_even = svcompact_s32(pred_even_elements, vec);\n        vec_min = svmin_s32_m(vec_min, vec_min, vec_even, pred_even_elements);\n\n        i += svcntw();\n        pred_even = svwhilelt_b32(i, length);\n    }\n\n    int min_val = INT32_MAX;\n    svst1_s32(svptrue_b32(), &min_val, vec_min);\n    return (min_val == INT32_MAX) ? -1 : min_val;\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    svbool_t pred_all = svptrue_b32();\n    svbool_t pred_even = svwhilelt_b32(0, length);\n    svint32_t vec_min = svdup_n_s32(INT32_MAX);\n\n    size_t i = 0;\n    while (svptest_any(pred_all, pred_even)) {\n        svint32_t vec_data = svld1_s32(pred_even, &src[i]);\n        svbool_t pred_even_elements = svbrkb_b_z(pred_even, pred_all);\n        svint32_t vec_even_data = svcompact_s32(pred_even_elements, vec_data);\n        vec_min = svmin_s32_m(vec_min, vec_min, vec_even_data);\n\n        i += svcntw();\n        pred_even = svwhilelt_b32(i, length);\n    }\n\n    int min_val = INT32_MAX;\n    svst1_s32(svptrue_b32(), &min_val, vec_min);\n\n    return (min_val == INT32_MAX) ? -1 : min_val;\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    svbool_t pg = svwhilelt_b32(0, length); // Predicate for the active lanes\n    svint32_t vec = svld1(pg, src);         // Load the source array into a vector\n    svint32_t even_indices = svindex_s32(0, 2); // Generate even indices (0, 2, 4, ...)\n    svbool_t even_pred = svcmpeq(svptrue_b32(), svrem_s32(even_indices, 2), 0); // Predicate for even indices\n\n    // Combine predicates: valid range and even indices\n    svbool_t combined_pred = svand_z(pg, even_pred);\n\n    // Extract even-indexed elements using the combined predicate\n    svint32_t even_values = svcompact(combined_pred, vec);\n\n    // Find the minimum value among the even-indexed elements\n    int min_val = 0x7FFFFFFF; // Initialize to maximum 32-bit integer value\n    while (svptest_any(svptrue_b32(), combined_pred)) {\n        min_val = svminv(svptrue_b32(), even_values);\n        break; // Single iteration is sufficient as we compacted the values\n    }\n\n    return (min_val == 0x7FFFFFFF) ? -1 : min_val;\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    svbool_t pg = svwhilelt_b32(0, length); // Predicate for the active lanes\n    svint32_t vec = svld1_s32(pg, src);    // Load the source array into a vector\n    svint32_t even_indices = svindex_s32(0, 2); // Create a vector of even indices (0, 2, 4, ...)\n    svbool_t even_pred = svcmpeq_s32(pg, svand_s32_z(pg, even_indices, 1), 0); // Predicate for even indices\n\n    int min_val = 0x7FFFFFFF; // Initialize to maximum 32-bit integer value\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t even_vals = svcompact_s32(even_pred, vec); // Extract values at even indices\n        min_val = svasr_n_s32_m(min_val, even_vals, 0);      // Update minimum value\n        pg = svwhilelt_b32(0, length);                       // Update predicate for remaining elements\n        vec = svld1_s32(pg, src);                            // Reload the next chunk of the array\n    }\n\n    return (min_val == 0x7FFFFFFF) ? -1 : min_val; // Return -1 if no valid even element found\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec_src = svld1_s32(pg, &src[i]);\n\n        // Arithmetic right shift\n        svint32_t arith_shifted = svasr_n_s32_x(pg, vec_src, shift);\n\n        // Logical right shift (convert to unsigned, shift, then convert back to signed)\n        svuint32_t vec_src_unsigned = svcvt_u32_s32_x(pg, vec_src);\n        svuint32_t logic_shifted_unsigned = svlsr_n_u32_x(pg, vec_src_unsigned, shift);\n        svint32_t logic_shifted = svcvt_s32_u32_x(pg, logic_shifted_unsigned);\n\n        // Add the results of arithmetic and logical shifts\n        svint32_t result = svadd_s32_x(pg, arith_shifted, logic_shifted);\n\n        // Store the result into the destination array\n        svst1_s32(pg, &dst[i], result);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t src_vec = svld1_s32(pg, &src[i]);\n\n        // Arithmetic right shift\n        svint32_t arith_shifted = svasr_n_s32_x(pg, src_vec, shift);\n\n        // Logical right shift (convert to unsigned, shift, then convert back to signed)\n        svuint32_t src_unsigned = svcvt_u32_s32_x(pg, src_vec);\n        svuint32_t log_shifted_unsigned = svlsr_n_u32_x(pg, src_unsigned, shift);\n        svint32_t log_shifted = svcvt_s32_u32_x(pg, log_shifted_unsigned);\n\n        // Add the results of arithmetic and logical shifts\n        svint32_t result = svadd_s32_x(pg, arith_shifted, log_shifted);\n\n        // Store the result into the destination array\n        svst1_s32(pg, &dst[i], result);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t src_vec = svld1_s32(pg, &src[i]);\n\n        // Arithmetic right shift\n        svint32_t arith_shifted = svasr_n_s32_x(pg, src_vec, shift);\n\n        // Logical right shift (convert to unsigned, shift, then convert back to signed)\n        svuint32_t src_unsigned = svcvt_u32_s32_x(pg, src_vec);\n        svuint32_t log_shifted_unsigned = svlsr_n_u32_x(pg, src_unsigned, shift);\n        svint32_t log_shifted = svcvt_s32_u32_x(pg, log_shifted_unsigned);\n\n        // Add the results of arithmetic and logical shifts\n        svint32_t result = svadd_s32_x(pg, arith_shifted, log_shifted);\n\n        // Store the result into the destination array\n        svst1_s32(pg, &dst[i], result);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t src_vec = svld1_s32(pg, &src[i]);\n\n        // Arithmetic right shift\n        svint32_t arith_shifted = svasr_n_s32_x(pg, src_vec, shift);\n\n        // Logical right shift (convert to unsigned, shift, then convert back to signed)\n        svuint32_t src_unsigned = svcvt_u32_s32_x(pg, src_vec);\n        svuint32_t logic_shifted_unsigned = svlsr_n_u32_x(pg, src_unsigned, shift);\n        svint32_t logic_shifted = svcvt_s32_u32_x(pg, logic_shifted_unsigned);\n\n        // Add the results of arithmetic and logical shifts\n        svint32_t result = svadd_s32_x(pg, arith_shifted, logic_shifted);\n\n        // Store the result into the destination array\n        svst1_s32(pg, &dst[i], result);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t src_vec = svld1_s32(pg, &src[i]);\n\n        // Arithmetic right shift\n        svint32_t arith_shifted = svasr_n_s32_x(pg, src_vec, shift);\n\n        // Logical right shift (convert to unsigned, shift, then convert back to signed)\n        svuint32_t src_unsigned = svcvt_u32_s32_x(pg, src_vec);\n        svuint32_t logical_shifted_unsigned = svlsr_n_u32_x(pg, src_unsigned, shift);\n        svint32_t logical_shifted = svcvt_s32_u32_x(pg, logical_shifted_unsigned);\n\n        // Add the results of arithmetic and logical shifts\n        svint32_t result = svadd_s32_x(pg, arith_shifted, logical_shifted);\n\n        // Store the result into the destination array\n        svst1_s32(pg, &dst[i], result);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64_t total_sum = 0;\n    size_t num_elements = rows * cols;\n\n    size_t i = 0;\n    svint32_t vec_sum = svdup_n_s32(0);\n\n    while (i <= num_elements - svcntw()) {\n        svint32_t vec = svld1_s32(svptrue_b32(), &matrix[i]);\n        vec_sum = svadd_s32_z(svptrue_b32(), vec_sum, vec);\n        i += svcntw();\n    }\n\n    // Reduce the vector sum to a scalar\n    int32_t temp_sum = 0;\n    svst1_s32(svptrue_b32(), &temp_sum, vec_sum);\n    total_sum += temp_sum;\n\n    // Handle any remaining elements\n    for (; i < num_elements; ++i) {\n        total_sum += matrix[i];\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64_t total_sum = 0;\n    size_t num_elements = rows * cols;\n\n    size_t i = 0;\n    svint32_t vec_sum = svdup_n_s32(0);\n\n    while (i <= num_elements - svcntw()) {\n        svint32_t vec = svld1_s32(svptrue_b32(), &matrix[i]);\n        vec_sum = svadd_s32_z(svptrue_b32(), vec_sum, vec);\n        i += svcntw();\n    }\n\n    int32_t temp_sum[svcntw()];\n    svst1_s32(svptrue_b32(), temp_sum, vec_sum);\n\n    for (size_t j = 0; j < svcntw(); ++j) {\n        total_sum += temp_sum[j];\n    }\n\n    while (i < num_elements) {\n        total_sum += matrix[i];\n        ++i;\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64_t total_sum = 0;\n    size_t num_elements = rows * cols;\n\n    size_t i = 0;\n    svint32_t vec_sum = svdup_n_s32(0);\n\n    while (i <= num_elements - svcntw()) {\n        svint32_t vec = svld1_s32(svptrue_b32(), &matrix[i]);\n        vec_sum = svadd_s32_z(svptrue_b32(), vec_sum, vec);\n        i += svcntw();\n    }\n\n    int32_t temp_sum[svcntw()];\n    svst1_s32(svptrue_b32(), temp_sum, vec_sum);\n\n    for (size_t j = 0; j < svcntw(); ++j) {\n        total_sum += temp_sum[j];\n    }\n\n    for (; i < num_elements; ++i) {\n        total_sum += matrix[i];\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64_t total_sum = 0;\n    size_t num_elements = rows * cols;\n\n    size_t i = 0;\n    svint32_t vec_sum = svdup_n_s32(0);\n\n    while (i <= num_elements - svcntw()) {\n        svint32_t vec = svld1_s32(svptrue_b32(), &matrix[i]);\n        vec_sum = svadd_s32_z(svptrue_b32(), vec_sum, vec);\n        i += svcntw();\n    }\n\n    // Reduce the vector sum to a scalar\n    int32_t temp_sum = 0;\n    svst1_s32(svptrue_b32(), &temp_sum, vec_sum);\n    total_sum += temp_sum;\n\n    // Handle remaining elements\n    for (; i < num_elements; ++i) {\n        total_sum += matrix[i];\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64_t total_sum = 0;\n    size_t num_elements = rows * cols;\n    size_t i = 0;\n\n    svint32_t vec_sum = svdup_n_s32(0);\n\n    while (i <= num_elements - svcntw()) {\n        svint32_t vec = svld1_s32(svptrue_b32(), &matrix[i]);\n        vec_sum = svadd_s32_z(svptrue_b32(), vec_sum, vec);\n        i += svcntw();\n    }\n\n    int32_t temp_sum = 0;\n    svst1_s32(svptrue_b32(), &temp_sum, vec_sum);\n    total_sum += temp_sum;\n\n    for (; i < num_elements; ++i) {\n        total_sum += matrix[i];\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b8(i, length);\n    int8_t max_val = INT8_MIN;\n    size_t max_idx = 0;\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svint8_t vec = svld1_s8(pg, src + i);\n        svbool_t cmp = svcmpgt_n_s8(pg, vec, max_val);\n\n        if (svptest_any(svptrue_b8(), cmp)) {\n            max_val = svmaxv_s8(pg, vec);\n            max_idx = i + svindex_u8(0, 1)[svfirst_true(cmp)];\n        }\n\n        i += svcntb();\n        pg = svwhilelt_b8(i, length);\n    }\n\n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\n#include <arm_sve.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b8(i, length);\n    int8_t max_val = INT8_MIN;\n    size_t max_idx = 0;\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svint8_t vec = svld1_s8(pg, src + i);\n        svbool_t cmp = svcmpgt_n_s8(pg, vec, max_val);\n\n        if (svptest_any(svptrue_b8(), cmp)) {\n            max_val = svmaxv_s8(pg, vec);\n            max_idx = i + svindex_u8(0, 1)[svfirst_true(cmp)];\n        }\n\n        i += svcntw();\n        pg = svwhilelt_b8(i, length);\n    }\n\n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b8(i, length);\n    int8_t max_val = INT8_MIN;\n    size_t max_idx = 0;\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svint8_t vec = svld1_s8(pg, src + i);\n        svbool_t cmp = svcmpgt_n_s8(pg, vec, max_val);\n\n        if (svptest_any(svptrue_b8(), cmp)) {\n            max_val = svmaxv_s8(pg, vec);\n            max_idx = i + svlasta_b8(cmp);\n        }\n\n        i += svcntb();\n        pg = svwhilelt_b8(i, length);\n    }\n\n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\n#include <arm_sve.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b8(i, length);\n    int8_t max_val = INT8_MIN;\n    size_t max_idx = 0;\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svint8_t vec = svld1_s8(pg, &src[i]);\n        svbool_t cmp = svcmpgt_n_s8(pg, vec, max_val);\n\n        if (svptest_any(svptrue_b8(), cmp)) {\n            max_val = svmaxv_s8(pg, vec);\n            max_idx = i + svindex_u64(0, 1)[svfirst_true(cmp)];\n        }\n\n        i += svcntw();\n        pg = svwhilelt_b8(i, length);\n    }\n\n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b8(i, length);\n    int8_t max_val = INT8_MIN;\n    size_t max_idx = 0;\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svint8_t vec = svld1_s8(pg, src + i);\n        svbool_t cmp = svcmpgt_n_s8(pg, vec, max_val);\n\n        if (svptest_any(svptrue_b8(), cmp)) {\n            max_val = svmaxv_s8(pg, vec);\n            max_idx = i + svindex_u8(0, 1)[svfirst_true(cmp)];\n        }\n\n        i += svcntw();\n        pg = svwhilelt_b8(i, length);\n    }\n\n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b16(i, length);\n\n    while (svptest_any(svptrue_b16(), pg)) {\n        svuint16_t vec_src1 = svld1(pg, &src1[i]);\n        svuint16_t vec_src2 = svld1(pg, &src2[i]);\n        svuint32_t vec_indices = svindex_u32(i, 1);\n        svbool_t pred = svcmpne_n_u32(pg, svand_vx_u32(pg, vec_indices, mask), 0);\n\n        svuint16_t result = svsel(pred, vec_src1, vec_src2);\n        svst1(pg, &dst[i], result);\n\n        i += svcntw();\n        pg = svwhilelt_b16(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b16(i, length);\n\n    while (svptest_any(svptrue_b16(), pg)) {\n        svuint16_t vec_src1 = svld1(pg, &src1[i]);\n        svuint16_t vec_src2 = svld1(pg, &src2[i]);\n\n        svuint32_t indices = svindex_u32(i, 1);\n        svbool_t blend_mask = svcmpne_n_u32(pg, svandv_u32(pg, indices, mask), 0);\n\n        svuint16_t result = svsel(blend_mask, vec_src1, vec_src2);\n        svst1(pg, &dst[i], result);\n\n        i += svcntw();\n        pg = svwhilelt_b16(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b16(i, length);\n\n    while (svptest_any(svptrue_b16(), pg)) {\n        svuint16_t vec_src1 = svld1(pg, &src1[i]);\n        svuint16_t vec_src2 = svld1(pg, &src2[i]);\n\n        svuint32_t indices = svindex_u32(i, 1);\n        svbool_t blend_mask = svcmpne_n_u32(pg, svandv_n_u32(pg, indices, mask), 0);\n\n        svuint16_t result = svsel(blend_mask, vec_src1, vec_src2);\n        svst1(pg, &dst[i], result);\n\n        i += svcntw();\n        pg = svwhilelt_b16(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b16(i, length);\n\n    while (svptest_any(svptrue_b16(), pg)) {\n        svuint16_t vec_src1 = svld1(pg, &src1[i]);\n        svuint16_t vec_src2 = svld1(pg, &src2[i]);\n\n        svuint32_t indices = svindex_u32(i, 1);\n        svbool_t blend_mask = svcmpne_n_u32(pg, svandv_u32(pg, indices, mask), 0);\n\n        svuint16_t result = svsel(blend_mask, vec_src1, vec_src2);\n        svst1(pg, &dst[i], result);\n\n        i += svcntw();\n        pg = svwhilelt_b16(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b16(i, length);\n\n    while (svptest_any(svptrue_b16(), pg)) {\n        svuint16_t indices = svindex_u16(i, 1);\n        svbool_t condition = svcmpne_n_u16(pg, svandv_u16(pg, indices, mask), 0);\n\n        svuint16_t src1_vec = svld1_u16(pg, src1 + i);\n        svuint16_t src2_vec = svld1_u16(pg, src2 + i);\n\n        svuint16_t result = svsel_u16(condition, src1_vec, src2_vec);\n        svst1_u16(pg, dst + i, result);\n\n        i += svcntw();\n        pg = svwhilelt_b16(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t vec_src = svld1(pg, &src[i]);\n        svuint32_t vec_popcount = svcnt(vec_src);\n        svst1(pg, &dst[i], vec_popcount);\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t vec_src = svld1(pg, &src[i]);\n        svuint32_t vec_popcount = svcnt(vec_src);\n        svst1(pg, &dst[i], vec_popcount);\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t vec_src = svld1(pg, &src[i]);\n        svuint32_t vec_popcount = svcnt(vec_src);\n        svst1(pg, &dst[i], vec_popcount);\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t vec_src = svld1(pg, &src[i]);\n        svuint32_t vec_popcount = svcnt(vec_src);\n        svst1(pg, &dst[i], vec_popcount);\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t vec = svld1(pg, &src[i]);\n        svuint32_t popcount = svcntp_u32(pg, vec);\n        svst1(pg, &dst[i], popcount);\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b16(i, length);\n\n    while (svptest_any(svptrue_b16(), pg)) {\n        svuint16_t vec1 = svld1(pg, &src1[i]);\n        svuint16_t vec2 = svld1(pg, &src2[i]);\n        svuint16_t result = svqadd(vec1, vec2);\n        svst1(pg, &dst[i], result);\n\n        i += svcntw();\n        pg = svwhilelt_b16(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b16(i, length);\n\n    while (svptest_any(svptrue_b16(), pg)) {\n        svuint16_t vec1 = svld1(pg, &src1[i]);\n        svuint16_t vec2 = svld1(pg, &src2[i]);\n        svuint16_t result = svqadd(vec1, vec2);\n        svst1(pg, &dst[i], result);\n\n        i += svcntw();\n        pg = svwhilelt_b16(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b16(i, length);\n\n    while (svptest_any(svptrue_b16(), pg)) {\n        svuint16_t vec1 = svld1(pg, &src1[i]);\n        svuint16_t vec2 = svld1(pg, &src2[i]);\n        svuint16_t result = svqadd(vec1, vec2);\n        svst1(pg, &dst[i], result);\n\n        i += svcntw();\n        pg = svwhilelt_b16(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b16(i, length);\n\n    while (svptest_any(svptrue_b16(), pg)) {\n        svuint16_t vec1 = svld1(pg, &src1[i]);\n        svuint16_t vec2 = svld1(pg, &src2[i]);\n        svuint16_t result = svqadd(vec1, vec2);\n        svst1(pg, &dst[i], result);\n\n        i += svcntw();\n        pg = svwhilelt_b16(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b16(i, length);\n\n    while (svptest_any(svptrue_b16(), pg)) {\n        svuint16_t vec1 = svld1(pg, &src1[i]);\n        svuint16_t vec2 = svld1(pg, &src2[i]);\n        svuint16_t result = svqadd(vec1, vec2);\n        svst1(pg, &dst[i], result);\n        i += svcntw();\n        pg = svwhilelt_b16(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t k = 0; k < p; ++k) {\n            // Initialize the result for C[i][k] to 0\n            svfloat64_t c_vec = svdup_f64(0.0);\n\n            for (size_t j = 0; j < n; j += svcntd()) {\n                // Load vectors from A and B\n                svbool_t pg = svwhilelt_b64(j, n);\n                svfloat64_t a_vec = svld1_f64(pg, &A[i * n + j]);\n                svfloat64_t b_vec = svld1_f64(pg, &B[j * p + k]);\n\n                // Create masks for the range [-100, 100]\n                svbool_t mask_a = svcmpge(pg, a_vec, svdup_f64(-100.0));\n                svbool_t mask_b = svcmple(pg, a_vec, svdup_f64(100.0));\n                svbool_t mask = svand_z(pg, mask_a, mask_b);\n\n                svbool_t mask_b_range = svcmpge(pg, b_vec, svdup_f64(-100.0));\n                mask_b = svcmple(pg, b_vec, svdup_f64(100.0));\n                mask_b = svand_z(pg, mask_b_range, mask_b);\n\n                mask = svand_z(pg, mask, mask_b);\n\n                // Perform multiplication and accumulation only for valid elements\n                svfloat64_t mul_vec = svmul_x(pg, a_vec, b_vec);\n                c_vec = svadd_m(pg, c_vec, mul_vec, mask);\n            }\n\n            // Reduce the vector to a scalar and store in C[i][k]\n            double result = 0.0;\n            svst1_f64(svptrue_b64(), &result, c_vec);\n            C[i * p + k] = result;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    svbool_t pg = svptrue_b64(); // Predicate for active lanes\n\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n\n            size_t k = 0;\n            while (k <= n - svcntd()) {\n                svfloat64_t va = svld1(pg, &A[i * n + k]);\n                svfloat64_t vb = svld1(pg, &B[k * p + j]);\n\n                svbool_t in_range_a = svcmp_ge(pg, va, -100.0);\n                svbool_t in_range_b = svcmp_le(pg, va, 100.0);\n                svbool_t mask_a = svand_z(pg, in_range_a, in_range_b);\n\n                in_range_a = svcmp_ge(pg, vb, -100.0);\n                in_range_b = svcmp_le(pg, vb, 100.0);\n                svbool_t mask_b = svand_z(pg, in_range_a, in_range_b);\n\n                svbool_t combined_mask = svand_z(pg, mask_a, mask_b);\n\n                svfloat64_t product = svmul_x(pg, va, vb);\n                product = svsel(combined_mask, product, 0.0);\n\n                sum += svaddv(pg, product);\n\n                k += svcntd();\n            }\n\n            for (; k < n; ++k) {\n                double a_val = A[i * n + k];\n                double b_val = B[k * p + j];\n\n                if (a_val >= -100.0 && a_val <= 100.0 &&\n                    b_val >= -100.0 && b_val <= 100.0) {\n                    sum += a_val * b_val;\n                }\n            }\n\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    svbool_t pg = svptrue_b64(); // Predicate for active lanes\n\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t k = 0; k < p; ++k) {\n            double sum = 0.0;\n\n            size_t j = 0;\n            while (j <= n - svcntd()) {\n                svfloat64_t va = svld1(pg, &A[i * n + j]);\n                svfloat64_t vb = svld1(pg, &B[j * p + k]);\n\n                svbool_t mask_a = svcmp_ge(pg, va, svdup_n_f64(-100.0));\n                svbool_t mask_b = svcmp_le(pg, va, svdup_n_f64(100.0));\n                svbool_t mask = svand_z(pg, mask_a, mask_b);\n\n                mask_a = svcmp_ge(pg, vb, svdup_n_f64(-100.0));\n                mask_b = svcmp_le(pg, vb, svdup_n_f64(100.0));\n                mask = svand_z(pg, mask, svand_z(pg, mask_a, mask_b));\n\n                svfloat64_t vmul = svmul_x(pg, va, vb);\n                sum += svaddv(mask, vmul);\n\n                j += svcntd();\n            }\n\n            for (; j < n; ++j) {\n                double a_val = A[i * n + j];\n                double b_val = B[j * p + k];\n                if (a_val >= -100.0 && a_val <= 100.0 && b_val >= -100.0 && b_val <= 100.0) {\n                    sum += a_val * b_val;\n                }\n            }\n\n            C[i * p + k] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    svbool_t pg = svptrue_b64(); // Predicate for active lanes\n\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t k = 0; k < p; ++k) {\n            double sum = 0.0;\n\n            size_t j = 0;\n            svfloat64_t sve_sum = svdup_f64(0.0);\n\n            while (j <= n - svcntd()) {\n                svfloat64_t a_vec = svld1(pg, &A[i * n + j]);\n                svfloat64_t b_vec = svld1(pg, &B[j * p + k]);\n\n                svbool_t mask = svcmpeq(pg, svabs(a_vec), 100.0);\n                mask = svand(mask, svcmpeq(pg, svabs(b_vec), 100.0));\n\n                sve_sum = svmla_m(pg, sve_sum, a_vec, b_vec, mask);\n                j += svcntd();\n            }\n\n            // Horizontal reduction of the vector sum\n            double temp_sum = 0.0;\n            svst1(pg, &temp_sum, sve_sum);\n            for (size_t idx = 0; idx < svcntd(); ++idx) {\n                sum += ((double*)&temp_sum)[idx];\n            }\n\n            // Handle remaining elements\n            for (; j < n; ++j) {\n                double a_val = A[i * n + j];\n                double b_val = B[j * p + k];\n                if (-100.0 <= a_val && a_val <= 100.0 && -100.0 <= b_val && b_val <= 100.0) {\n                    sum += a_val * b_val;\n                }\n            }\n\n            C[i * p + k] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    svbool_t pg = svptrue_b64(); // Predicate for active lanes\n\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            svfloat64_t c_sum = svdup_f64(0.0); // Initialize accumulator to 0.0\n\n            for (size_t k = 0; k < n; k += svcntd()) {\n                svfloat64_t a_vec = svld1(pg, &A[i * n + k]); // Load A[i][k] vector\n                svfloat64_t b_vec = svld1(pg, &B[k * p + j]); // Load B[k][j] vector\n\n                // Create masks for range [-100, 100]\n                svbool_t a_in_range = svcmp_ge(pg, a_vec, svdup_f64(-100.0));\n                a_in_range = svcmpeq(pg, svmin(a_in_range, svcmp_le(pg, a_vec, svdup_f64(100.0))), pg);\n\n                svbool_t b_in_range = svcmp_ge(pg, b_vec, svdup_f64(-100.0));\n                b_in_range = svcmpeq(pg, svmin(b_in_range, svcmp_le(pg, b_vec, svdup_f64(100.0))), pg);\n\n                // Combine masks\n                svbool_t in_range = svand_z(pg, a_in_range, b_in_range);\n\n                // Multiply and accumulate only valid elements\n                c_sum = svmla_m(pg, c_sum, a_vec, b_vec, in_range);\n            }\n\n            // Reduce the vector sum into a scalar\n            double result = 0.0;\n            c_sum = svaddv(pg, c_sum); // Horizontal reduction\n            svst1_f64(pg, &result, c_sum);\n\n            C[i * p + j] = result; // Store result in C[i][j]\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b64(i, total_elements);\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svint64_t va = svld1(pg, &A[i]);\n        svint64_t vb = svld1(pg, &B[i]);\n        svint64_t vc = svadd_x(pg, va, vb);\n        svst1(pg, &C[i], vc);\n\n        i += svcntd();\n        pg = svwhilelt_b64(i, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b64(i, total_elements);\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svint64_t va = svld1(pg, &A[i]);\n        svint64_t vb = svld1(pg, &B[i]);\n        svint64_t vc = svadd_x(pg, va, vb);\n        svst1(pg, &C[i], vc);\n\n        i += svcntd();\n        pg = svwhilelt_b64(i, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b64(i, total_elements);\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svint64_t va = svld1(pg, &A[i]);\n        svint64_t vb = svld1(pg, &B[i]);\n        svint64_t vc = svadd_x(pg, va, vb);\n        svst1(pg, &C[i], vc);\n\n        i += svcntd();\n        pg = svwhilelt_b64(i, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b64(i, total_elements);\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svint64_t va = svld1(pg, &A[i]);\n        svint64_t vb = svld1(pg, &B[i]);\n        svint64_t vc = svadd_x(pg, va, vb);\n        svst1(pg, &C[i], vc);\n\n        i += svcntd();\n        pg = svwhilelt_b64(i, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b64(i, total_elements);\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svint64_t va = svld1(pg, &A[i]);\n        svint64_t vb = svld1(pg, &B[i]);\n        svint64_t vc = svadd_x(pg, va, vb);\n        svst1(pg, &C[i], vc);\n\n        i += svcntd();\n        pg = svwhilelt_b64(i, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vec1 = svld1_f32(pg, &src1[i]);\n        svfloat32_t vec2 = svld1_f32(pg, &src2[i]);\n\n        svfloat32_t result = svadd_f32_z(pg, vec1, vec2);\n        svfloat32_t rounded = svrintn_f32_z(pg, result);\n\n        svst1_f32(pg, &dst[i], rounded);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vec1 = svld1_f32(pg, &src1[i]);\n        svfloat32_t vec2 = svld1_f32(pg, &src2[i]);\n\n        svfloat32_t result = svadd_f32_z(pg, vec1, vec2);\n        svfloat32_t rounded = svrintn_f32_z(pg, result);\n\n        svst1_f32(pg, &dst[i], rounded);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vec1 = svld1_f32(pg, &src1[i]);\n        svfloat32_t vec2 = svld1_f32(pg, &src2[i]);\n\n        svfloat32_t result = svadd_f32_z(pg, vec1, vec2);\n        svfloat32_t rounded = svrintn_f32_z(pg, result);\n\n        svst1_f32(pg, &dst[i], rounded);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vec1 = svld1_f32(pg, &src1[i]);\n        svfloat32_t vec2 = svld1_f32(pg, &src2[i]);\n        svfloat32_t result = svadd_f32_z(pg, vec1, vec2);\n        svfloat32_t rounded = svrintn_f32_z(pg, result);\n        svst1_f32(pg, &dst[i], rounded);\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vec1 = svld1_f32(pg, &src1[i]);\n        svfloat32_t vec2 = svld1_f32(pg, &src2[i]);\n\n        svfloat32_t result = svadd_f32_z(pg, vec1, vec2);\n        svfloat32_t rounded = svrintn_f32_z(pg, result);\n\n        svst1_f32(pg, &dst[i], rounded);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    svbool_t pred_all = svptrue_b32();\n    svfloat32_t vec_minus_one = svdup_f32(-1.0f);\n    svfloat32_t vec_50 = svdup_f32(50.0f);\n\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t pred = svwhilelt_b32(i, length);\n        svfloat32_t vec_src1 = svld1_f32(pred, &src1[i]);\n        svfloat32_t vec_src2 = svld1_f32(pred, &src2[i]);\n\n        // Compute absolute difference\n        svfloat32_t vec_diff = svsub_f32(vec_src1, vec_src2);\n        svfloat32_t vec_abs_diff = svabs_f32(vec_diff);\n\n        // Check if absolute difference is within 50\n        svbool_t pred_diff = svcmple_f32(pred, vec_abs_diff, vec_50);\n\n        // Check if index is a multiple of 2\n        svbool_t pred_index = svcmpeq_n_u32(pred, svindex_u32(i, 1), 0);\n\n        // Combine predicates\n        svbool_t pred_combined = svand_z(pred, pred_diff, pred_index);\n\n        // Perform multiplication and round up\n        svfloat32_t vec_mul = svmul_f32(vec_src1, vec_src2);\n        svfloat32_t vec_rounded = svrintp_f32(vec_mul);\n\n        // Select results based on predicate\n        svfloat32_t vec_result = svsel_f32(pred_combined, vec_rounded, vec_minus_one);\n\n        // Store results to destination\n        svst1_f32(pred, &dst[i], vec_result);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    svbool_t pred_all = svptrue_b32();\n    svfloat32_t vec_minus_one = svdup_f32(-1.0f);\n    svfloat32_t vec_50 = svdup_f32(50.0f);\n\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t pred = svwhilelt_b32(i, length);\n        svfloat32_t vec_src1 = svld1_f32(pred, &src1[i]);\n        svfloat32_t vec_src2 = svld1_f32(pred, &src2[i]);\n\n        svfloat32_t vec_diff = svsub_f32(vec_src1, vec_src2);\n        svfloat32_t vec_abs_diff = svabs_f32(vec_diff);\n\n        svbool_t cond1 = svcmple_f32(pred, vec_abs_diff, vec_50);\n        svbool_t cond2 = svcmpeq_n_u32(pred, svindex_u32(i, 1), 0);\n        svbool_t combined_pred = svand_z(pred, cond1, cond2);\n\n        svfloat32_t vec_mul = svmul_f32(vec_src1, vec_src2);\n        svfloat32_t vec_rounded = svrintx_f32(vec_mul);\n\n        svfloat32_t result = svsel_f32(combined_pred, vec_rounded, vec_minus_one);\n        svst1_f32(pred, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    svbool_t pred_all = svptrue_b32();\n    svfloat32_t vec_minus_one = svdup_f32(-1.0f);\n    svfloat32_t vec_50 = svdup_f32(50.0f);\n\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t pred = svwhilelt_b32(i, length);\n        svfloat32_t vec_src1 = svld1_f32(pred, &src1[i]);\n        svfloat32_t vec_src2 = svld1_f32(pred, &src2[i]);\n\n        // Compute absolute difference\n        svfloat32_t vec_diff = svsub_f32(vec_src1, vec_src2);\n        svfloat32_t vec_abs_diff = svabs_f32(vec_diff);\n\n        // Check if absolute difference is within 50\n        svbool_t pred_diff = svcmple_f32(pred, vec_abs_diff, vec_50);\n\n        // Check if index is a multiple of 2\n        svuint32_t vec_indices = svindex_u32(i, 1);\n        svbool_t pred_even = svcmpeq_n_u32(pred, svand_u32_z(pred, vec_indices, 1), 0);\n\n        // Combine predicates\n        svbool_t pred_combined = svand_b_z(pred, pred_diff, pred_even);\n\n        // Perform element-wise multiplication\n        svfloat32_t vec_mul = svmul_f32_x(pred_combined, vec_src1, vec_src2);\n\n        // Round up towards positive infinity\n        svfloat32_t vec_rounded = svrintp_f32_x(pred_combined, vec_mul);\n\n        // Merge results with -1 for elements not meeting conditions\n        svfloat32_t vec_result = svsel_f32(pred_combined, vec_rounded, vec_minus_one);\n\n        // Store the result into dst\n        svst1_f32(pred, &dst[i], vec_result);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    svbool_t pred_all = svptrue_b32();\n    svfloat32_t vec_minus_one = svdup_f32(-1.0f);\n    svfloat32_t vec_50 = svdup_f32(50.0f);\n\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t pred = svwhilelt_b32(i, length);\n        svfloat32_t vec_src1 = svld1_f32(pred, &src1[i]);\n        svfloat32_t vec_src2 = svld1_f32(pred, &src2[i]);\n\n        // Compute absolute difference\n        svfloat32_t vec_diff = svsub_f32(vec_src1, vec_src2);\n        svfloat32_t vec_abs_diff = svabs_f32(vec_diff);\n\n        // Check if absolute difference is within 50\n        svbool_t pred_diff = svcmple_f32(pred, vec_abs_diff, vec_50);\n\n        // Check if index is a multiple of 2\n        svbool_t pred_index = svcmpeq_n_u32(pred, svindex_u32(i, 1), 0);\n\n        // Combine conditions\n        svbool_t pred_combined = svand_b_z(pred, pred_diff, pred_index);\n\n        // Perform multiplication and round up\n        svfloat32_t vec_mul = svmul_f32(vec_src1, vec_src2);\n        svfloat32_t vec_rounded = svrintp_f32(vec_mul);\n\n        // Select results based on combined predicate\n        svfloat32_t vec_result = svsel_f32(pred_combined, vec_rounded, vec_minus_one);\n\n        // Store results to destination\n        svst1_f32(pred, &dst[i], vec_result);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    svbool_t pred_all = svptrue_b32();\n    svfloat32_t vec_minus_one = svdup_f32(-1.0f);\n    svfloat32_t vec_threshold = svdup_f32(50.0f);\n\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t pred = svwhilelt_b32(i, length);\n        svfloat32_t vec_src1 = svld1_f32(pred, &src1[i]);\n        svfloat32_t vec_src2 = svld1_f32(pred, &src2[i]);\n\n        svfloat32_t vec_diff = svsub_f32(vec_src1, vec_src2);\n        svfloat32_t vec_abs_diff = svabs_f32(vec_diff);\n\n        svbool_t pred_condition = svacle_f32(vec_abs_diff, vec_threshold);\n        svbool_t pred_index_even = svbrkb_z(pred_all, pred);\n        pred_condition = svand_b_z(pred, pred_condition, pred_index_even);\n\n        svfloat32_t vec_mul = svmul_f32(vec_src1, vec_src2);\n        svfloat32_t vec_result = svrintp_f32(vec_mul);\n\n        vec_result = svsel_f32(pred_condition, vec_result, vec_minus_one);\n        svst1_f32(pred, &dst[i], vec_result);\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i = 0;\n\n    // Load the scalar into a vector register for multiplication\n    svfloat64_t scalar_vec = svdup_f64(scalar);\n\n    // Determine the vector length\n    size_t vl = svcntd();\n\n    // Process elements in chunks of the vector length\n    for (; i + vl <= total_elements; i += vl) {\n        // Load a vector of elements from the source matrix\n        svfloat64_t mat_vec = svld1_f64(svptrue_b64(), &mat[i]);\n\n        // Perform element-wise multiplication\n        svfloat64_t result_vec = svmul_f64_x(svptrue_b64(), mat_vec, scalar_vec);\n\n        // Store the result into the destination matrix\n        svst1_f64(svptrue_b64(), &dst[i], result_vec);\n    }\n\n    // Handle any remaining elements using a tail predicate\n    if (i < total_elements) {\n        svbool_t pred = svwhilelt_b64(i, total_elements);\n        svfloat64_t mat_vec = svld1_f64(pred, &mat[i]);\n        svfloat64_t result_vec = svmul_f64_x(pred, mat_vec, scalar_vec);\n        svst1_f64(pred, &dst[i], result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b64(i, total_elements);\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svfloat64_t vec_mat = svld1_f64(pg, &mat[i]);\n        svfloat64_t vec_result = svmul_f64_z(pg, vec_mat, scalar);\n        svst1_f64(pg, &dst[i], vec_result);\n\n        i += svcntd();\n        pg = svwhilelt_b64(i, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i = 0;\n\n    // Load the scalar value into a vector register\n    svfloat64_t vec_scalar = svdup_f64(scalar);\n\n    // Process elements in chunks defined by the SVE vector length\n    while (i <= total_elements - svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, total_elements); // Create a predicate for active lanes\n        svfloat64_t vec_mat = svld1_f64(pg, &mat[i]);   // Load a vector of elements from mat\n        svfloat64_t vec_result = svmul_f64_x(pg, vec_mat, vec_scalar); // Multiply by scalar\n        svst1_f64(pg, &dst[i], vec_result);             // Store the result into dst\n        i += svcntd();                                  // Move to the next chunk\n    }\n\n    // Handle any remaining elements that don't fill a full vector\n    if (i < total_elements) {\n        svbool_t pg = svwhilelt_b64(i, total_elements); // Predicate for remaining elements\n        svfloat64_t vec_mat = svld1_f64(pg, &mat[i]);   // Load remaining elements\n        svfloat64_t vec_result = svmul_f64_x(pg, vec_mat, vec_scalar); // Multiply by scalar\n        svst1_f64(pg, &dst[i], vec_result);             // Store the result\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b64(i, total_elements);\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svfloat64_t vec_mat = svld1_f64(pg, &mat[i]);\n        svfloat64_t vec_result = svmul_f64_z(pg, vec_mat, scalar);\n        svst1_f64(pg, &dst[i], vec_result);\n\n        i += svcntd();\n        pg = svwhilelt_b64(i, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t idx = 0;\n    svbool_t pg = svwhilelt_b64(idx, m * n);\n\n    do {\n        svfloat64_t vec_mat = svld1_f64(pg, &mat[idx]);\n        svfloat64_t vec_result = svmul_f64_z(pg, vec_mat, scalar);\n        svst1_f64(pg, &dst[idx], vec_result);\n\n        idx += svcntd();\n        pg = svwhilelt_b64(idx, m * n);\n    } while (svptest_any(svptrue_b64(), pg));\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float* row = mat + i * n;\n        svfloat32_t vec_sum = svdup_f32(0.0f);\n        size_t j = 0;\n\n        // Compute the sum of squares using SVE intrinsics\n        svbool_t pg = svwhilelt_b32(j, n);\n        while (svptest_any(svptrue_b32(), pg)) {\n            svfloat32_t vec = svld1_f32(pg, row + j);\n            vec_sum = svmla_f32(vec_sum, vec, vec);\n            j += svcntw();\n            pg = svwhilelt_b32(j, n);\n        }\n\n        // Reduce the vector sum to a scalar\n        float norm_sq = 0.0f;\n        svbool_t reduce_pg = svptrue_b32();\n        while (svptest_any(svptrue_b32(), reduce_pg)) {\n            norm_sq += svaddv_f32(reduce_pg, vec_sum);\n            reduce_pg = svpnext_b32(reduce_pg, reduce_pg);\n        }\n\n        // Compute the L2 norm\n        float norm = sqrtf(norm_sq);\n\n        // Normalize the row\n        j = 0;\n        pg = svwhilelt_b32(j, n);\n        while (svptest_any(svptrue_b32(), pg)) {\n            svfloat32_t vec = svld1_f32(pg, row + j);\n            vec = svdiv_f32_z(pg, vec, svdup_f32(norm));\n            svst1_f32(pg, row + j, vec);\n            j += svcntw();\n            pg = svwhilelt_b32(j, n);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float* row = mat + i * n;\n        float norm = 0.0f;\n\n        // Compute the L2 norm of the row using SVE intrinsics\n        svbool_t pg = svwhilelt_b32(0, n); // Predicate for active lanes\n        svfloat32_t vec_sum = svdup_f32(0.0f); // Initialize sum vector to zero\n\n        size_t j = 0;\n        while (svptest_any(svptrue_b32(), pg)) {\n            svfloat32_t vec = svld1_f32(pg, row + j); // Load elements from memory\n            vec_sum = svmla_f32(vec_sum, vec, vec);  // Accumulate squares of elements\n            j += svcntw();\n            pg = svwhilelt_b32(j, n); // Update predicate\n        }\n\n        // Reduce the vector sum into a scalar value\n        float sum = 0.0f;\n        svst1_f32(svptrue_b32(), &sum, vec_sum); // Store vector sum into scalar sum\n        norm = sqrtf(sum); // Compute square root for L2 norm\n\n        // Normalize the row by dividing each element by the norm\n        if (norm > 1e-8) { // Avoid division by zero\n            pg = svwhilelt_b32(0, n); // Reset predicate\n            j = 0;\n            while (svptest_any(svptrue_b32(), pg)) {\n                svfloat32_t vec = svld1_f32(pg, row + j); // Load elements\n                vec = svdiv_f32_z(pg, vec, svdup_f32(norm)); // Divide by norm\n                svst1_f32(pg, row + j, vec); // Store normalized elements back\n                j += svcntw();\n                pg = svwhilelt_b32(j, n); // Update predicate\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float* row = mat + i * n;\n        float norm = 0.0f;\n\n        // Compute the L2 norm of the row using SVE intrinsics\n        svbool_t pg = svwhilelt_b32(0, n); // Predicate for vector length\n        svfloat32_t vec_sum = svdup_f32(0.0f); // Initialize sum vector to zero\n\n        size_t j = 0;\n        while (svptest_any(svptrue_b32(), pg)) {\n            svfloat32_t vec = svld1_f32(pg, row + j); // Load vector from memory\n            vec_sum = svmla_f32(vec_sum, vec, vec);  // Accumulate squares\n            j += svcntw(); // Increment by the number of elements processed\n            pg = svwhilelt_b32(j, n); // Update predicate\n        }\n\n        // Reduce the vector sum to a scalar\n        float sum = 0.0f;\n        svst1_f32(svptrue_b32(), &sum, vec_sum); // Store vector sum into scalar\n        for (size_t k = 0; k < svcntw(); ++k) {\n            norm += sum;\n        }\n\n        norm = sqrtf(norm); // Compute square root of the sum\n\n        // Normalize the row using SVE intrinsics\n        if (norm > 1e-8) { // Avoid division by zero\n            pg = svwhilelt_b32(0, n); // Reset predicate\n            j = 0;\n            while (svptest_any(svptrue_b32(), pg)) {\n                svfloat32_t vec = svld1_f32(pg, row + j); // Load vector from memory\n                vec = svdiv_f32_z(pg, vec, svdup_f32(norm)); // Divide by norm\n                svst1_f32(pg, row + j, vec); // Store normalized vector back to memory\n                j += svcntw(); // Increment by the number of elements processed\n                pg = svwhilelt_b32(j, n); // Update predicate\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float* row = mat + i * n;\n        float norm = 0.0f;\n\n        // Compute the L2 norm of the row using SVE intrinsics\n        svbool_t pg = svwhilelt_b32(0, n); // Predicate for vector loop\n        svfloat32_t vec_sum = svdup_f32(0.0f); // Initialize sum vector to zero\n\n        size_t j = 0;\n        while (svptest_any(svptrue_b32(), pg)) {\n            svfloat32_t vec = svld1_f32(pg, row + j); // Load elements into vector\n            vec_sum = svmla_f32(vec_sum, vec, vec); // Accumulate squares\n            j += svcntw(); // Increment by vector length\n            pg = svwhilelt_b32(j, n); // Update predicate\n        }\n\n        // Reduce the vector sum to a scalar\n        float sum = 0.0f;\n        svst1_f32(svptrue_b32(), &sum, vec_sum); // Store vector sum into scalar\n        for (size_t k = 0; k < svcntw(); ++k) {\n            norm += sum;\n        }\n\n        norm = sqrtf(norm); // Compute square root for L2 norm\n\n        // Normalize the row using SVE intrinsics\n        pg = svwhilelt_b32(0, n); // Reset predicate\n        j = 0;\n        while (svptest_any(svptrue_b32(), pg)) {\n            svfloat32_t vec = svld1_f32(pg, row + j); // Load elements into vector\n            vec = svdiv_f32_z(pg, vec, svdup_f32(norm)); // Divide by norm\n            svst1_f32(pg, row + j, vec); // Store normalized elements back\n            j += svcntw(); // Increment by vector length\n            pg = svwhilelt_b32(j, n); // Update predicate\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float* row = mat + i * n;\n        svfloat32_t vec_sum = svdup_f32(0.0f);\n        size_t j = 0;\n\n        // Compute the sum of squares using SVE intrinsics\n        svbool_t pg = svwhilelt_b32(j, n);\n        while (svptest_any(svptrue_b32(), pg)) {\n            svfloat32_t vec = svld1_f32(pg, row + j);\n            vec_sum = svmla_f32(vec_sum, vec, vec);\n            j += svcntw();\n            pg = svwhilelt_b32(j, n);\n        }\n\n        // Reduce the vector sum to a scalar\n        float row_norm_sq = 0.0f;\n        svbool_t all_active = svptrue_b32();\n        row_norm_sq = svaddv_f32(all_active, vec_sum);\n\n        // Compute the L2 norm\n        float row_norm = sqrtf(row_norm_sq);\n\n        // Normalize the row\n        j = 0;\n        pg = svwhilelt_b32(j, n);\n        while (svptest_any(svptrue_b32(), pg)) {\n            svfloat32_t vec = svld1_f32(pg, row + j);\n            vec = svdiv_f32_z(pg, vec, svdup_f32(row_norm));\n            svst1_f32(pg, row + j, vec);\n            j += svcntw();\n            pg = svwhilelt_b32(j, n);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    size_t i, j, k;\n    svbool_t pg = svptrue_b64();\n\n    for (i = 0; i < m; ++i) {\n        for (j = 0; j < p; ++j) {\n            svfloat64_t acc = svdup_f64(0.0);\n\n            for (k = 0; k < n; k += svcntd()) {\n                svbool_t pg_k = svwhilelt_b64(k, n);\n                svfloat64_t vec_a = svld1_f64(pg_k, &mat1[i * n + k]);\n                svfloat64_t vec_b = svld1_f64(pg_k, &mat2[k * p + j]);\n                acc = svmla_f64_x(pg_k, acc, vec_a, vec_b);\n            }\n\n            double result = svaddv_f64(pg, acc);\n            dst[i * p + j] = nearbyint(result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    size_t i, j, k;\n    svbool_t pg = svptrue_b64();\n\n    for (i = 0; i < m; ++i) {\n        for (j = 0; j < p; ++j) {\n            svfloat64_t sum_vec = svdup_f64(0.0);\n\n            for (k = 0; k < n; k += svcntd()) {\n                svfloat64_t mat1_vec = svld1(pg, &mat1[i * n + k]);\n                svfloat64_t mat2_vec = svld1(pg, &mat2[k * p + j]);\n\n                svfloat64_t mul_vec = svmul_f64_x(pg, mat1_vec, mat2_vec);\n                sum_vec = svadd_f64_x(pg, sum_vec, mul_vec);\n            }\n\n            // Horizontal reduction of the vector to get the final sum\n            double sum = 0.0;\n            double temp[simdvlen];\n            svst1(pg, temp, sum_vec);\n            for (int l = 0; l < svcntd(); ++l) {\n                sum += temp[l];\n            }\n\n            // Round to nearest integer and store in dst\n            dst[i * p + j] = nearbyint(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    size_t i, j, k;\n    svbool_t pg = svptrue_b64();\n\n    for (i = 0; i < m; ++i) {\n        for (j = 0; j < p; ++j) {\n            svfloat64_t acc = svdup_f64(0.0);\n\n            for (k = 0; k < n; k += svcntd()) {\n                svbool_t pg_k = svwhilelt_b64(k, n);\n                svfloat64_t vec_mat1 = svld1_f64(pg_k, &mat1[i * n + k]);\n                svfloat64_t vec_mat2 = svld1_f64(pg_k, &mat2[k * p + j]);\n                acc = svmla_f64_x(pg_k, acc, vec_mat1, vec_mat2);\n            }\n\n            double result = svaddv_f64(pg, acc);\n            dst[i * p + j] = nearbyint(result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    size_t i, j, k;\n    svbool_t pg = svptrue_b64();\n\n    for (i = 0; i < m; ++i) {\n        for (j = 0; j < p; ++j) {\n            svfloat64_t acc = svdup_f64(0.0);\n\n            for (k = 0; k < n; k += svcntd()) {\n                svbool_t pg_k = svwhilelt_b64(k, n);\n                svfloat64_t vec_a = svld1_f64(pg_k, &mat1[i * n + k]);\n                svfloat64_t vec_b = svld1_f64(pg_k, &mat2[k * p + j]);\n                acc = svmla_f64_x(pg_k, acc, vec_a, vec_b);\n            }\n\n            double result = svaddv_f64(pg, acc);\n            dst[i * p + j] = nearbyint(result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            svfloat64_t vec_sum = svdup_f64(0.0);\n\n            size_t k = 0;\n            while (k <= n - svcntd()) {\n                svfloat64_t vec_mat1 = svld1_f64(svptrue_b64(), &mat1[i * n + k]);\n                svfloat64_t vec_mat2 = svld1_f64(svptrue_b64(), &mat2[k * p + j]);\n                vec_sum = svmla_f64(vec_sum, vec_mat1, vec_mat2);\n                k += svcntd();\n            }\n\n            double sum = svaddv_f64(svptrue_b64(), vec_sum);\n\n            for (; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n\n            dst[i * p + j] = nearbyint(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    svbool_t pg = svwhilelt_b32(0, cols); // Predicate for columns\n\n    for (size_t i = 0; i < rows; ++i) {\n        size_t j = 0;\n        for (; j + svcntw() <= cols; j += svcntw()) {\n            svfloat32_t vec = svld1(pg, &src[i * cols + j]); // Load row elements\n            vec = svmla_n_f32_z(pg, svdup_n_f32(0.0f), vec, 4.0f); // Multiply by 4\n            vec = svrintn_f32_z(pg, vec); // Round to nearest integer\n            vec = svmul_n_f32_z(pg, vec, 0.25f); // Divide by 4 to get nearest quarter\n            svst1(pg, &dst[j * rows + i], vec); // Store into transposed position\n        }\n        if (j < cols) {\n            pg = svwhilelt_b32(j, cols); // Update predicate for remaining elements\n            svfloat32_t vec = svld1(pg, &src[i * cols + j]); // Load remaining row elements\n            vec = svmla_n_f32_z(pg, svdup_n_f32(0.0f), vec, 4.0f); // Multiply by 4\n            vec = svrintn_f32_z(pg, vec); // Round to nearest integer\n            vec = svmul_n_f32_z(pg, vec, 0.25f); // Divide by 4 to get nearest quarter\n            svst1(pg, &dst[j * rows + i], vec); // Store into transposed position\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    svbool_t pg = svwhilelt_b32(0, cols); // Predicate for columns\n\n    for (size_t i = 0; i < rows; ++i) {\n        size_t j = 0;\n        for (; j + svcntw() <= cols; j += svcntw()) {\n            svfloat32_t vec = svld1(pg, &src[i * cols + j]); // Load row elements\n            vec = svmla_n_f32_z(pg, svdup_n_f32(0.0f), vec, 4.0f); // Multiply by 4.0\n            vec = svrintn_f32_z(pg, vec); // Round to nearest integer\n            vec = svmul_n_f32_z(pg, vec, 0.25f); // Divide by 4.0\n            svst1(pg, &dst[j * rows + i], vec); // Store into transposed position\n        }\n        if (j < cols) {\n            pg = svwhilelt_b32(j, cols); // Update predicate for remaining elements\n            svfloat32_t vec = svld1(pg, &src[i * cols + j]);\n            vec = svmla_n_f32_z(pg, svdup_n_f32(0.0f), vec, 4.0f);\n            vec = svrintn_f32_z(pg, vec);\n            vec = svmul_n_f32_z(pg, vec, 0.25f);\n            svst1(pg, &dst[j * rows + i], vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    svbool_t pg = svwhilelt_b32(0, cols); // Predicate for columns\n    float quarter = 0.25f;\n\n    for (size_t i = 0; i < rows; ++i) {\n        size_t j = 0;\n        for (; j + svcntw() <= cols; j += svcntw()) {\n            svfloat32_t vec = svld1(pg, &src[i * cols + j]); // Load row elements\n            vec = svdiv_x(pg, svrintn_x(pg, svmul_x(pg, vec, 4.0f)), 4.0f); // Round to nearest quarter\n            svst1(pg, &dst[j * rows + i], vec); // Store into transposed position\n        }\n        if (j < cols) {\n            pg = svwhilelt_b32(j, cols); // Update predicate for remaining elements\n            svfloat32_t vec = svld1(pg, &src[i * cols + j]); // Load remaining row elements\n            vec = svdiv_x(pg, svrintn_x(pg, svmul_x(pg, vec, 4.0f)), 4.0f); // Round to nearest quarter\n            svst1(pg, &dst[j * rows + i], vec); // Store into transposed position\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    svbool_t pg = svwhilelt_b32(0, cols); // Predicate for columns\n\n    for (size_t i = 0; i < rows; ++i) {\n        size_t j = 0;\n        for (; j + svcntw() <= cols; j += svcntw()) {\n            svfloat32_t vec = svld1(pg, &src[i * cols + j]); // Load row elements\n            vec = svmla_f32_z(pg, svdup_f32(0.125f), vec, svdup_f32(4.0f)); // Add 0.125 for rounding\n            vec = svdiv_f32_z(pg, vec, svdup_f32(4.0f)); // Divide by 4.0\n            vec = svmul_f32_z(pg, svrintn_f32(pg, vec), svdup_f32(4.0f)); // Round to nearest and scale back\n            svst1(pg, &dst[j * rows + i], vec); // Store transposed and rounded elements\n        }\n\n        if (j < cols) {\n            pg = svwhilelt_b32(j, cols); // Update predicate for remaining elements\n            svfloat32_t vec = svld1(pg, &src[i * cols + j]); // Load remaining row elements\n            vec = svmla_f32_z(pg, svdup_f32(0.125f), vec, svdup_f32(4.0f)); // Add 0.125 for rounding\n            vec = svdiv_f32_z(pg, vec, svdup_f32(4.0f)); // Divide by 4.0\n            vec = svmul_f32_z(pg, svrintn_f32(pg, vec), svdup_f32(4.0f)); // Round to nearest and scale back\n            svst1(pg, &dst[j * rows + i], vec); // Store transposed and rounded elements\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    svbool_t pg = svwhilelt_b32(0, cols); // Predicate for columns\n\n    for (size_t i = 0; i < rows; ++i) {\n        size_t j = 0;\n        for (; j + svcntw() <= cols; j += svcntw()) {\n            svfloat32_t vec = svld1(pg, &src[i * cols + j]); // Load row elements\n            vec = svrintn_f32_z(pg, vec);                    // Round to nearest integer\n            vec = svmul_f32_z(pg, vec, 0.25f);               // Multiply by 0.25 to round to nearest quarter\n            svst1(pg, &dst[j * rows + i], vec);              // Store transposed and rounded elements\n        }\n\n        if (j < cols) {\n            svbool_t pgtail = svwhilelt_b32(j, cols);        // Tail predicate\n            svfloat32_t vec = svld1(pgtail, &src[i * cols + j]); // Load remaining row elements\n            vec = svrintn_f32_z(pgtail, vec);                // Round to nearest integer\n            vec = svmul_f32_z(pgtail, vec, 0.25f);           // Multiply by 0.25 to round to nearest quarter\n            svst1(pgtail, &dst[j * rows + i], vec);          // Store transposed and rounded elements\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b32(i, total_elements);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vec1 = svld1_f32(pg, &tensor1[i]);\n        svfloat32_t vec2 = svld1_f32(pg, &tensor2[i]);\n\n        svfloat32_t result = svsub_f32_z(pg, vec1, vec2);\n        result = svrintz_f32_z(pg, result);\n\n        svst1_f32(pg, &dst[i], result);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b32(i, total_elements);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vec1 = svld1_f32(pg, &tensor1[i]);\n        svfloat32_t vec2 = svld1_f32(pg, &tensor2[i]);\n\n        // Perform element-wise subtraction\n        svfloat32_t result = svsub_f32_z(pg, vec1, vec2);\n\n        // Round towards zero using truncation\n        svint32_t truncated = svbtrunc_s32_f32(pg, result);\n        svfloat32_t rounded = svcvt_f32_s32(pg, truncated);\n\n        // Store the result into the destination tensor\n        svst1_f32(pg, &dst[i], rounded);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b32(i, total_elements);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vec1 = svld1_f32(pg, &tensor1[i]);\n        svfloat32_t vec2 = svld1_f32(pg, &tensor2[i]);\n\n        svfloat32_t result = svsub_f32_z(pg, vec1, vec2);\n        result = svrintz_f32_z(pg, result);\n\n        svst1_f32(pg, &dst[i], result);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b32(i, total_elements);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vec1 = svld1_f32(pg, &tensor1[i]);\n        svfloat32_t vec2 = svld1_f32(pg, &tensor2[i]);\n\n        svfloat32_t result = svsub_f32_z(pg, vec1, vec2);\n        result = svrintz_f32_z(pg, result);\n\n        svst1_f32(pg, &dst[i], result);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n\n    for (size_t i = 0; i < total_elements; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n\n        svfloat32_t vec1 = svld1_f32(pg, &tensor1[i]);\n        svfloat32_t vec2 = svld1_f32(pg, &tensor2[i]);\n\n        svfloat32_t result = svsub_f32_x(pg, vec1, vec2);\n        result = svrintz_f32_x(pg, result);\n\n        svst1_f32(pg, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t num_elements = m * n;\n    size_t i = 0;\n\n    // Determine the vector length for double-precision floating point\n    size_t vl = svcntd();\n\n    // Process elements in chunks of the vector length\n    for (; i + vl <= num_elements; i += vl) {\n        svfloat64_t vec1 = svld1_f64(svptrue_b64(), &mat1[i]);\n        svfloat64_t vec2 = svld1_f64(svptrue_b64(), &mat2[i]);\n        svfloat64_t result = svmul_f64_z(svptrue_b64(), vec1, vec2);\n        svst1_f64(svptrue_b64(), &dst[i], result);\n    }\n\n    // Process any remaining elements using scalar operations\n    for (; i < num_elements; ++i) {\n        dst[i] = mat1[i] * mat2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t vec_size = svcntd(); // Number of elements in an SVE vector\n    svbool_t pg = svwhilelt_b64(0, n); // Predicate for the active lanes\n\n    for (size_t i = 0; i < m; ++i) {\n        size_t j = 0;\n        for (; j + vec_size <= n; j += vec_size) {\n            svfloat64_t vec1 = svld1(pg, &mat1[i * n + j]);\n            svfloat64_t vec2 = svld1(pg, &mat2[i * n + j]);\n            svfloat64_t result = svmul_x(pg, vec1, vec2);\n            svst1(pg, &dst[i * n + j], result);\n        }\n\n        // Handle remaining elements\n        if (j < n) {\n            svbool_t pg_tail = svwhilelt_b64(j, n);\n            svfloat64_t vec1 = svld1(pg_tail, &mat1[i * n + j]);\n            svfloat64_t vec2 = svld1(pg_tail, &mat2[i * n + j]);\n            svfloat64_t result = svmul_x(pg_tail, vec1, vec2);\n            svst1(pg_tail, &dst[i * n + j], result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t num_elements = m * n;\n    size_t i = 0;\n\n    // Determine the vector length for double-precision floating point\n    size_t vl = svcntd();\n\n    // Process elements in chunks of the vector length\n    for (; i + vl <= num_elements; i += vl) {\n        svfloat64_t vec1 = svld1_f64(svptrue_b64(), &mat1[i]);\n        svfloat64_t vec2 = svld1_f64(svptrue_b64(), &mat2[i]);\n        svfloat64_t result = svmul_f64_z(svptrue_b64(), vec1, vec2);\n        svst1_f64(svptrue_b64(), &dst[i], result);\n    }\n\n    // Process any remaining elements using scalar operations\n    for (; i < num_elements; ++i) {\n        dst[i] = mat1[i] * mat2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t vec_size = svcntd(); // Number of double-precision elements per SVE vector\n    svbool_t pg = svwhilelt_b64(0, n); // Predicate for the active lanes\n\n    for (size_t i = 0; i < m; ++i) {\n        size_t j = 0;\n        for (; j + vec_size <= n; j += vec_size) {\n            svfloat64_t vec1 = svld1(pg, &mat1[i * n + j]);\n            svfloat64_t vec2 = svld1(pg, &mat2[i * n + j]);\n            svfloat64_t result = svmul_x(pg, vec1, vec2);\n            svst1(pg, &dst[i * n + j], result);\n        }\n\n        // Handle remaining elements\n        if (j < n) {\n            svbool_t pg_tail = svwhilelt_b64(j, n);\n            svfloat64_t vec1 = svld1(pg_tail, &mat1[i * n + j]);\n            svfloat64_t vec2 = svld1(pg_tail, &mat2[i * n + j]);\n            svfloat64_t result = svmul_x(pg_tail, vec1, vec2);\n            svst1(pg_tail, &dst[i * n + j], result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t vec_size = svcntd(); // Number of elements processed per SVE vector\n    svbool_t pg = svwhilelt_b64(0, n); // Predicate for partial vectors\n\n    for (size_t i = 0; i < m; ++i) {\n        size_t j = 0;\n\n        // Process full vectors\n        for (; j + vec_size <= n; j += vec_size) {\n            svfloat64_t vec1 = svld1(pg, &mat1[i * n + j]);\n            svfloat64_t vec2 = svld1(pg, &mat2[i * n + j]);\n            svfloat64_t result = svmul_x(pg, vec1, vec2);\n            svst1(pg, &dst[i * n + j], result);\n        }\n\n        // Process remaining elements (if any)\n        if (j < n) {\n            pg = svwhilelt_b64(j, n);\n            svfloat64_t vec1 = svld1(pg, &mat1[i * n + j]);\n            svfloat64_t vec2 = svld1(pg, &mat2[i * n + j]);\n            svfloat64_t result = svmul_x(pg, vec1, vec2);\n            svst1(pg, &dst[i * n + j], result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, m); // Predicate for rows\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        size_t j = 0;\n        svfloat32_t result_vec = svdup_f32(0.0f); // Initialize accumulator to 0\n\n        while (j < n) {\n            svbool_t pg_col = svwhilelt_b32(j, n); // Predicate for columns\n            svfloat32_t mat_vec = svld1(pg_col, &mat[i * n + j]); // Load matrix row elements\n            svfloat32_t vec_vec = svld1(pg_col, &vec[j]);         // Load vector elements\n            result_vec = svmla_f32(result_vec, mat_vec, vec_vec); // Multiply and accumulate\n            j += svcntw(); // Increment by the vector length\n        }\n\n        // Reduce the vector to a scalar\n        float result_scalar = svaddv_f32(svptrue_b32(), result_vec);\n        dst[i] = result_scalar; // Store the result in the destination vector\n\n        i += svcntw(); // Increment by the vector length\n        pg = svwhilelt_b32(i, m); // Update predicate for rows\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, m);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load a vector of zeros to initialize the accumulator\n        svfloat32_t acc = svdup_f32(0.0f);\n\n        size_t j = 0;\n        while (j < n) {\n            svbool_t pg_vec = svwhilelt_b32(j, n);\n\n            // Load a slice of the vector\n            svfloat32_t vec_slice = svld1_f32(pg_vec, &vec[j]);\n\n            // Perform multiplication and accumulation for each row in the active predicate\n            size_t k = i;\n            do {\n                // Load a slice of the matrix row\n                svfloat32_t mat_slice = svld1_f32(pg_vec, &mat[k * n + j]);\n\n                // Multiply and accumulate\n                acc = svmla_f32(acc, mat_slice, vec_slice);\n\n                k++;\n            } while (svptest_next(pg, &k));\n\n            j += svcntw();\n        }\n\n        // Store the result for the active rows\n        svst1_f32(pg, &dst[i], acc);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, m);\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, m);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t result_vec = svdup_f32(0.0f);\n\n        size_t j = 0;\n        while (j < n) {\n            svbool_t pg_j = svwhilelt_b32(j, n);\n            svfloat32_t mat_row = svld1_f32(pg_j, &mat[i * n + j]);\n            svfloat32_t vec_elem = svld1rq_f32(pg_j, &vec[j]);\n            result_vec = svmla_f32(result_vec, mat_row, vec_elem);\n            j += svcntw();\n        }\n\n        svst1_f32(pg, &dst[i], result_vec);\n        i += svcntw();\n        pg = svwhilelt_b32(i, m);\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, m);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t result_vec = svdup_f32(0.0f);\n\n        size_t j = 0;\n        while (j < n) {\n            svbool_t pg_j = svwhilelt_b32(j, n);\n            svfloat32_t mat_row = svld1_f32(pg_j, &mat[i * n + j]);\n            svfloat32_t vec_elem = svld1rq_f32(pg_j, &vec[j]);\n            result_vec = svmla_f32(result_vec, mat_row, vec_elem);\n            j += svcntw();\n        }\n\n        svst1_f32(pg, &dst[i], result_vec);\n        i += svcntw();\n        pg = svwhilelt_b32(i, m);\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, m);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load the current row indices for which we are computing dot products\n        svfloat32_t result_vec = svdup_f32(0.0f);\n\n        size_t j = 0;\n        while (j < n) {\n            svbool_t pg_j = svwhilelt_b32(j, n);\n            // Load a slice of the vector 'vec'\n            svfloat32_t vec_slice = svld1(pg_j, &vec[j]);\n\n            // Perform dot product for each active lane in the predicate\n            for (size_t k = i; k < svcntw(); ++k) {\n                if (svptest_any(svptrue_b32(), pg)) {\n                    // Load a slice of the matrix row corresponding to this lane\n                    svfloat32_t mat_slice = svld1(pg_j, &mat[k * n + j]);\n                    // Multiply and accumulate\n                    result_vec = svmla_m(pg_j, result_vec, mat_slice, vec_slice);\n                }\n            }\n\n            // Increment j by the number of elements processed in this iteration\n            j += svcntw();\n        }\n\n        // Store the results back into the destination vector\n        svst1(pg, &dst[i], result_vec);\n\n        // Update i and predicate for next iteration\n        i += svcntw();\n        pg = svwhilelt_b32(i, m);\n    }\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i = 0;\n    svfloat64_t vec_sum = svdup_f64(0.0);\n    double scalar_sum = 0.0;\n\n    while (i <= total_elements - svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        svfloat64_t vec = svld1_f64(pg, &mat[i]);\n        vec_sum = svadd_f64_m(pg, vec_sum, vec);\n        i += svcntd();\n    }\n\n    scalar_sum = svaddv_f64(svptrue_b64(), vec_sum);\n\n    for (; i < total_elements; ++i) {\n        scalar_sum += mat[i];\n    }\n\n    return scalar_sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i = 0;\n    svfloat64_t vec_sum = svdup_f64(0.0);\n    svbool_t pg = svwhilelt_b64(i, total_elements);\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svfloat64_t vec = svld1_f64(pg, &mat[i]);\n        vec_sum = svadd_f64_z(pg, vec_sum, vec);\n        i += svcntd();\n        pg = svwhilelt_b64(i, total_elements);\n    }\n\n    double sum = 0.0;\n    svst1_f64(svptrue_b64(), &sum, vec_sum);\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i = 0;\n    svfloat64_t vec_sum = svdup_f64(0.0);\n    double scalar_sum = 0.0;\n\n    while (i <= total_elements - svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        svfloat64_t vec = svld1_f64(pg, &mat[i]);\n        vec_sum = svadd_f64_m(pg, vec_sum, vec);\n        i += svcntd();\n    }\n\n    scalar_sum = svaddv_f64(svptrue_b64(), vec_sum);\n\n    for (; i < total_elements; ++i) {\n        scalar_sum += mat[i];\n    }\n\n    return scalar_sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i = 0;\n    svfloat64_t vec_sum = svdup_f64(0.0);\n    svbool_t pg = svwhilelt_b64(i, total_elements);\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svfloat64_t vec = svld1_f64(pg, &mat[i]);\n        vec_sum = svadd_f64_m(pg, vec_sum, vec);\n        i += svcntd();\n        pg = svwhilelt_b64(i, total_elements);\n    }\n\n    double sum = 0.0;\n    svst1_f64(svptrue_b64(), &sum, vec_sum);\n\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i = 0;\n    svfloat64_t vec_sum = svdup_f64(0.0);\n    svbool_t pg = svwhilelt_b64(i, total_elements);\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svfloat64_t vec = svld1_f64(pg, &mat[i]);\n        vec_sum = svadd_f64_m(pg, vec_sum, vec);\n        i += svcntd();\n        pg = svwhilelt_b64(i, total_elements);\n    }\n\n    double sum = 0.0;\n    svst1_f64(svptrue_b64(), &sum, vec_sum);\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        bool ascending = directions[i];\n        size_t j = 0;\n\n        // Load the predicate for the vector length\n        svbool_t pg =svptrue_b32();\n\n        // Process full vectors first\n        for (; j <= cols - svcntw(); j += svcntw()) {\n            svint32_t vec = svld1_s32(pg, row + j);\n            svint32_t vec_next = svld1_s32(pg, row + j + 1);\n\n            svbool_t cmp;\n            if (ascending) {\n                cmp = svcmplt_s32(pg, vec, vec_next);\n            } else {\n                cmp = svcmpgt_s32(pg, vec, vec_next);\n            }\n\n            if (!svptest_first(pg, cmp)) {\n                return false;\n            }\n        }\n\n        // Process remaining elements\n        for (; j < cols - 1; ++j) {\n            if ((ascending && row[j] > row[j + 1]) || (!ascending && row[j] < row[j + 1])) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    size_t sve_vector_size = svcntw(); // Number of 32-bit integers in an SVE vector\n    svbool_t all_true = svptrue_b32(); // Predicate for full vector width\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        bool ascending = directions[i];\n        bool row_sorted = true;\n\n        size_t j = 0;\n\n        // Process full SVE vectors\n        for (; j + sve_vector_size <= cols; j += sve_vector_size) {\n            svint32_t vec_curr = svld1_s32(all_true, row + j);\n            svint32_t vec_next = svld1_s32(all_true, row + j + 1);\n\n            svbool_t cmp;\n            if (ascending) {\n                cmp = svcmplt_s32(all_true, vec_curr, vec_next); // Check curr < next\n            } else {\n                cmp = svcmpgt_s32(all_true, vec_curr, vec_next); // Check curr > next\n            }\n\n            if (!svptest_all(all_true, cmp)) {\n                row_sorted = false;\n                break;\n            }\n        }\n\n        // Process remaining elements (if any)\n        if (row_sorted && j < cols - 1) {\n            for (; j < cols - 1; ++j) {\n                if ((ascending && row[j] >= row[j + 1]) || (!ascending && row[j] <= row[j + 1])) {\n                    row_sorted = false;\n                    break;\n                }\n            }\n        }\n\n        if (!row_sorted) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    size_t sve_vector_size = svcntw(); // Number of 32-bit integers in an SVE vector\n    svbool_t all_active = svptrue_b32(); // Predicate for all active lanes\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        bool ascending = directions[i];\n        bool sorted = true;\n\n        size_t j = 0;\n\n        // Process full SVE vectors\n        for (; j + sve_vector_size <= cols; j += sve_vector_size) {\n            svint32_t vec_current = svld1_s32(all_active, row + j);\n            svint32_t vec_next = svld1_s32(all_active, row + j + 1);\n\n            svbool_t cmp_result;\n            if (ascending) {\n                cmp_result = svcmplt_s32(all_active, vec_current, vec_next);\n            } else {\n                cmp_result = svcmpgt_s32(all_active, vec_current, vec_next);\n            }\n\n            if (!svptest_all(all_active, cmp_result)) {\n                sorted = false;\n                break;\n            }\n        }\n\n        // Process remaining elements (if any)\n        for (; j < cols - 1; ++j) {\n            if ((ascending && row[j] > row[j + 1]) || (!ascending && row[j] < row[j + 1])) {\n                sorted = false;\n                break;\n            }\n        }\n\n        if (!sorted) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        bool ascending = directions[i];\n        size_t j = 0;\n\n        // Load the first element of the row as the initial comparison value\n        svint32_t prev = svdup_n_s32(row[0]);\n\n        // Process the row in chunks defined by the SVE vector length\n        for (; j + svcntw() <= cols; j += svcntw()) {\n            svint32_t curr = svld1_s32(svptrue_b32(), row + j);\n\n            // Compare adjacent elements based on direction\n            svbool_t cmp;\n            if (ascending) {\n                cmp = svcmplt_s32(svptrue_b32(), prev, curr);\n            } else {\n                cmp = svcmpgt_s32(svptrue_b32(), prev, curr);\n            }\n\n            // If any comparison fails, return false\n            if (!svptest_first(svptrue_b32(), cmp)) {\n                return false;\n            }\n\n            // Update previous vector to current for next iteration\n            prev = curr;\n        }\n\n        // Handle remaining elements that don't fill a full vector\n        if (j < cols) {\n            svbool_t pg = svwhilelt_b32(j, cols);\n            svint32_t curr = svld1_s32(pg, row + j);\n\n            svbool_t cmp;\n            if (ascending) {\n                cmp = svcmplt_s32(pg, prev, curr);\n            } else {\n                cmp = svcmpgt_s32(pg, prev, curr);\n            }\n\n            if (!svptest_first(pg, cmp)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    size_t sve_vector_length = svcntw(); // Number of 32-bit integers in an SVE vector\n    svbool_t all_active = svptrue_b32(); // All lanes active\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        bool ascending = directions[i];\n        bool row_sorted = true;\n\n        size_t j = 0;\n\n        // Process full SVE vectors\n        for (; j + sve_vector_length <= cols; j += sve_vector_length) {\n            svint32_t vec = svld1_s32(all_active, row + j);\n            svint32_t shifted_vec = svext_s32(vec, vec, 1); // Shift left by one element\n\n            svbool_t cmp;\n            if (ascending) {\n                cmp = svcmplt_s32(all_active, vec, shifted_vec); // Check ascending order\n            } else {\n                cmp = svcmpgt_s32(all_active, vec, shifted_vec); // Check descending order\n            }\n\n            if (svptest_any(all_active, cmp)) { // If any lane fails the condition\n                row_sorted = false;\n                break;\n            }\n        }\n\n        // Process remaining elements (if any)\n        for (; j < cols - 1; ++j) {\n            if ((ascending && row[j] > row[j + 1]) || (!ascending && row[j] < row[j + 1])) {\n                row_sorted = false;\n                break;\n            }\n        }\n\n        if (!row_sorted) {\n            return false; // Early exit if a row is not sorted\n        }\n    }\n\n    return true; // All rows are sorted according to their respective directions\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    svbool_t pg = svwhilelt_b16(0, length);\n    svint16_t vec_base = svdup_s16(base);\n\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svint16_t vec_src = svld1_s16(pg, src + i);\n        svint16_t vec_div = svdiv_s16_z(pg, vec_src, vec_base);\n        svint16_t vec_mul = svmul_s16_z(pg, vec_div, vec_base);\n        svst1_s16(pg, dst + i, vec_mul);\n        pg = svwhilelt_b16(i + svcntw(), length);\n    }\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    svbool_t pg = svwhilelt_b16(0, length);\n    svint16_t vec_base = svdup_s16(base);\n\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svint16_t vec_src = svld1_s16(pg, src + i);\n        svint16_t vec_div = svdiv_s16(vec_src, vec_base);\n        svint16_t vec_mul = svmul_s16(vec_div, vec_base);\n        svst1_s16(pg, dst + i, vec_mul);\n        pg = svwhilelt_b16(i + svcntw(), length);\n    }\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    svbool_t pg = svwhilelt_b16(0, length);\n    svint16_t vec_base = svdup_s16(base);\n\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svint16_t vec_src = svld1_s16(pg, src + i);\n        svint16_t quotient = svdiv_s16(vec_src, vec_base);\n        svint16_t result = svmul_s16(quotient, vec_base);\n        svst1_s16(pg, dst + i, result);\n        pg = svwhilelt_b16(i + svcntw(), length);\n    }\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    svbool_t pg = svwhilelt_b16(0, length);\n    svint16_t vec_base = svdup_s16(base);\n    \n    for (size_t i = 0; i < length; i += svcntw()) {\n        svint16_t vec_src = svld1_s16(pg, src + i);\n        svint16_t quotient = svdiv_s16(vec_src, vec_base);\n        svint16_t multiple = svmul_s16(quotient, vec_base);\n        svst1_s16(pg, dst + i, multiple);\n        pg = svwhilelt_b16(i + svcntw(), length);\n    }\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    svbool_t pg = svwhilelt_b16(0, length);\n    svint16_t vec_base = svdup_s16(base);\n\n    while (svptest_any(svptrue_b16(), pg)) {\n        svint16_t vec_src = svld1_s16(pg, src);\n        svint16_t quotient = svdiv_s16(vec_src, vec_base);\n        svint16_t result = svmul_s16(quotient, vec_base);\n        svst1_s16(pg, dst, result);\n\n        src += svcntw();\n        dst += svcntw();\n        length -= svcntw();\n        pg = svwhilelt_b16(0, length);\n    }\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    size_t vec_size = svcntd(); // Get the number of elements in an SVE vector\n    svbool_t all_active = svptrue_b64(); // Predicate for full vector length\n\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row = matrix + i * cols;\n        bool match = true;\n\n        for (size_t j = 0; j < cols; j += vec_size) {\n            svbool_t pred = svwhilelt_b64(j, cols); // Predicate for remaining elements\n            svfloat64_t vec_row = svld1_f64(pred, row + j); // Load row elements\n            svfloat64_t vec_vec = svld1_f64(pred, vector + j); // Load vector elements\n            svbool_t cmp = svcmpeq_f64(pred, vec_row, vec_vec); // Compare elements\n\n            if (!svptest_all(all_active, cmp)) { // Check if all elements match\n                match = false;\n                break;\n            }\n        }\n\n        if (match) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    size_t vec_size = svcntd(); // Number of elements in an SVE vector\n    svbool_t all_active = svptrue_b64(); // Predicate for full vector length\n\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row = matrix + i * cols;\n        bool match = true;\n\n        size_t j = 0;\n        svbool_t pred = svwhilelt_b64((uint64_t)j, (uint64_t)cols); // Predicate for remaining elements\n\n        while (svptest_any(all_active, pred)) {\n            svfloat64_t vec_row = svld1_f64(pred, row + j); // Load row elements\n            svfloat64_t vec_vector = svld1_f64(pred, vector + j); // Load vector elements\n            svbool_t cmp = svcmpeq_f64(pred, vec_row, vec_vector); // Compare elements\n\n            if (!svptest_all(all_active, cmp)) { // If any element doesn't match\n                match = false;\n                break;\n            }\n\n            j += vec_size;\n            pred = svwhilelt_b64((uint64_t)j, (uint64_t)cols); // Update predicate\n        }\n\n        if (match) {\n            return true; // Found a matching row\n        }\n    }\n\n    return false; // No matching row found\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    size_t i = 0;\n    svbool_t all_true = svptrue_b64();\n\n    for (i = 0; i < rows; ++i) {\n        const double* row = matrix + i * cols;\n        svbool_t match_all = all_true;\n\n        size_t j = 0;\n        while (j < cols) {\n            svbool_t pg = svwhilelt_b64((uint64_t)j, (uint64_t)cols);\n            svfloat64_t vec_row = svld1_f64(pg, row + j);\n            svfloat64_t vec_vector = svld1_f64(pg, vector + j);\n            svbool_t match = svcmpeq_f64(pg, vec_row, vec_vector);\n            match_all = svand_b_z(pg, match_all, match);\n\n            if (svptest_first(all_true, match_all) == 0) {\n                break;\n            }\n\n            j += svcntd();\n        }\n\n        if (svptest_first(all_true, match_all)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    size_t vec_size = svcntd(); // Get the number of elements in an SVE vector\n    svbool_t all_active = svptrue_b64(); // Predicate for full vector length\n\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row = matrix + i * cols;\n        bool match = true;\n\n        for (size_t j = 0; j < cols; j += vec_size) {\n            svbool_t pred = svwhilelt_b64(j, cols); // Predicate for remaining elements\n            svfloat64_t vec_row = svld1_f64(pred, row + j); // Load row elements\n            svfloat64_t vec_vec = svld1_f64(pred, vector + j); // Load vector elements\n            svbool_t comparison = svcmpeq_f64(pred, vec_row, vec_vec); // Compare elements\n\n            if (!svptest_all(all_active, comparison)) { // Check if all elements match\n                match = false;\n                break;\n            }\n        }\n\n        if (match) {\n            return true; // Found a matching row\n        }\n    }\n\n    return false; // No matching row found\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    size_t i = 0;\n    svbool_t all_true = svptrue_b64();\n\n    for (i = 0; i < rows; ++i) {\n        const double* row = matrix + i * cols;\n        svbool_t match_all = all_true;\n\n        size_t j = 0;\n        while (j < cols) {\n            svbool_t pg = svwhilelt_b64(j, cols);\n            svfloat64_t vec1 = svld1(pg, row + j);\n            svfloat64_t vec2 = svld1(pg, vector + j);\n            svbool_t match = svcmpeq(pg, vec1, vec2);\n            match_all = svand_z(pg, match_all, match);\n\n            if (svptest_any(svptrue_b64(), svnot_z(pg, match_all))) {\n                break;\n            }\n\n            j += svcntd();\n        }\n\n        if (svptest_first(all_true, match_all)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b8(i, total_elements);\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t vecA = svld1_u8(pg, &A[i]);\n        svuint8_t vecB = svld1_u8(pg, &B[i]);\n        svbool_t mask = svcmpeq(pg, vecA, vecB);\n        count += svcntp_b8(pg, mask);\n        i += svcntb();\n        pg = svwhilelt_b8(i, total_elements);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```c\n#include <arm_sve.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b8(i, total_elements);\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t vecA = svld1_u8(pg, &A[i]);\n        svuint8_t vecB = svld1_u8(pg, &B[i]);\n        svbool_t mask = svcmpeq(pg, vecA, vecB);\n        count += svcntp_b8(pg, mask);\n        i += svcntb();\n        pg = svwhilelt_b8(i, total_elements);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b8(i, total_elements);\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t vecA = svld1_u8(pg, &A[i]);\n        svuint8_t vecB = svld1_u8(pg, &B[i]);\n        svbool_t mask = svcmpeq(pg, vecA, vecB);\n        count += svcntp_b8(pg, mask);\n        i += svcntb();\n        pg = svwhilelt_b8(i, total_elements);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b8(i, total_elements);\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t vecA = svld1_u8(pg, &A[i]);\n        svuint8_t vecB = svld1_u8(pg, &B[i]);\n        svbool_t mask = svcmpeq(pg, vecA, vecB);\n        count += svcntp_b8(pg, mask);\n        i += svcntb();\n        pg = svwhilelt_b8(i, total_elements);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b8(i, total_elements);\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t vecA = svld1_u8(pg, &A[i]);\n        svuint8_t vecB = svld1_u8(pg, &B[i]);\n        svbool_t mask = svcmpeq(pg, vecA, vecB);\n        count += svcntp_b8(pg, mask);\n        i += svcntb();\n        pg = svwhilelt_b8(i, total_elements);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, length);\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svint64_t vec_x = svld1(pg, &x[i]);\n        svint64_t vec_y = svld1(pg, &y[i]);\n\n        svint64_t scaled_x = svmul_n_s64_x(pg, vec_x, a);\n        svint64_t abs_y = svabs_s64_x(pg, vec_y);\n        svint64_t result = svsub_s64_x(pg, scaled_x, abs_y);\n\n        svst1(pg, &y[i], result);\n\n        i += svcntd();\n        pg = svwhilelt_b64(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    svint64_t vec_a = svdup_s64(a);\n\n    while (i < length) {\n        svbool_t pg = svwhilelt_b64(i, length);\n        svint64_t vec_x = svld1_s64(pg, &x[i]);\n        svint64_t vec_y = svld1_s64(pg, &y[i]);\n\n        svint64_t temp = svmul_s64_x(pg, vec_a, vec_x);\n        svint64_t abs_y = svabs_s64_x(pg, vec_y);\n        svint64_t result = svsub_s64_x(pg, temp, abs_y);\n\n        svst1_s64(pg, &y[i], result);\n        i += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    svint64_t va = svdup_s64(a); // Broadcast scalar 'a' to a vector\n\n    while (i < length) {\n        svbool_t pg = svwhilelt_b64(i, length); // Create a predicate for the remaining elements\n        svint64_t vx = svld1(pg, &x[i]);       // Load elements from 'x'\n        svint64_t vy = svld1(pg, &y[i]);       // Load elements from 'y'\n\n        // Perform scalar-vector multiplication: a * x\n        svint64_t vmul = svmul_x(pg, va, vx);\n\n        // Compute absolute value of 'y'\n        svint64_t vabs = svabs_x(pg, vy);\n\n        // Perform element-wise subtraction: (a * x) - abs(y)\n        svint64_t vsub = svsub_x(pg, vmul, vabs);\n\n        // Store the result back to 'y'\n        svst1(pg, &y[i], vsub);\n\n        i += svcntd(); // Increment by the number of elements processed in this iteration\n    }\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    svint64_t vec_a = svdup_s64(a);\n\n    while (i < length) {\n        svbool_t pg = svwhilelt_b64(i, length);\n        svint64_t vec_x = svld1_s64(pg, &x[i]);\n        svint64_t vec_y = svld1_s64(pg, &y[i]);\n\n        svint64_t temp = svmul_s64_x(pg, vec_a, vec_x);\n        svint64_t abs_y = svabs_s64_x(pg, vec_y);\n        svint64_t result = svsub_s64_x(pg, temp, abs_y);\n\n        svst1_s64(pg, &y[i], result);\n        i += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, length);\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svint64_t vec_x = svld1(pg, &x[i]);\n        svint64_t vec_y = svld1(pg, &y[i]);\n\n        svint64_t scaled_x = svmul_n_s64_x(pg, vec_x, a);\n        svint64_t abs_y = svabs_s64_x(pg, vec_y);\n        svint64_t result = svsub_s64_x(pg, scaled_x, abs_y);\n\n        svst1(pg, &y[i], result);\n\n        i += svcntd();\n        pg = svwhilelt_b64(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\n#include <arm_sve.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    svint16_t vec_min = svdup_n_s16(INT16_MAX);\n    svint16_t vec_max = svdup_n_s16(INT16_MIN);\n    size_t i = 0;\n\n    // Process vector-length chunks using SVE intrinsics\n    while (i <= length - svcntw()) {\n        svint16_t data = svld1_s16(svptrue_b16(), &vec[i]);\n        vec_min = svmin_s16(vec_min, data);\n        vec_max = svmax_s16(vec_max, data);\n        i += svcntw();\n    }\n\n    // Reduce the vector to scalar for min and max\n    int16_t min_val = svminv_s16(svptrue_b16(), vec_min);\n    int16_t max_val = svmaxv_s16(svptrue_b16(), vec_max);\n\n    // Handle any remaining elements\n    for (; i < length; ++i) {\n        if (vec[i] < min_val) min_val = vec[i];\n        if (vec[i] > max_val) max_val = vec[i];\n    }\n\n    result.min_num = min_val;\n    result.max_num = max_val;\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\n#include <arm_sve.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    svint16_t vec_min = svdup_n_s16(INT16_MAX);\n    svint16_t vec_max = svdup_n_s16(INT16_MIN);\n    size_t i = 0;\n\n    // Process vectorized part\n    svbool_t pg = svwhilelt_b16(i, length);\n    while (svptest_any(svptrue_b16(), pg)) {\n        svint16_t vec_data = svld1_s16(pg, &vec[i]);\n        vec_min = svmin_s16_m(pg, vec_min, vec_data);\n        vec_max = svmax_s16_m(pg, vec_max, vec_data);\n        i += svcntw();\n        pg = svwhilelt_b16(i, length);\n    }\n\n    // Reduce to scalar for min and max\n    int16_t min_val = svminv_s16(svptrue_b16(), vec_min);\n    int16_t max_val = svmaxv_s16(svptrue_b16(), vec_max);\n\n    // Handle any remaining elements\n    for (; i < length; ++i) {\n        if (vec[i] < min_val) min_val = vec[i];\n        if (vec[i] > max_val) max_val = vec[i];\n    }\n\n    result.min_num = min_val;\n    result.max_num = max_val;\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\n#include <arm_sve.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    svint16_t vec_min = svdup_n_s16(INT16_MAX);\n    svint16_t vec_max = svdup_n_s16(INT16_MIN);\n    size_t i = 0;\n\n    // Process vector-length chunks using SVE intrinsics\n    while (i <= length - svcntw()) {\n        svint16_t vec_data = svld1_s16(svptrue_b16(), &vec[i]);\n        vec_min = svmin_s16(vec_min, vec_data);\n        vec_max = svmax_s16(vec_max, vec_data);\n        i += svcntw();\n    }\n\n    // Reduce the vector results to scalar values\n    int16_t min_val = svminv_s16(svptrue_b16(), vec_min);\n    int16_t max_val = svmaxv_s16(svptrue_b16(), vec_max);\n\n    // Handle any remaining elements\n    for (; i < length; ++i) {\n        if (vec[i] < min_val) min_val = vec[i];\n        if (vec[i] > max_val) max_val = vec[i];\n    }\n\n    result.min_num = min_val;\n    result.max_num = max_val;\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\n#include <arm_sve.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    svint16_t vec_min = svdup_n_s16(INT16_MAX);\n    svint16_t vec_max = svdup_n_s16(INT16_MIN);\n    size_t i = 0;\n\n    // Process vector-length chunks using SVE intrinsics\n    while (i <= length - svcntw()) {\n        svint16_t data = svld1_s16(svptrue_b16(), &vec[i]);\n        vec_min = svmin_s16(vec_min, data);\n        vec_max = svmax_s16(vec_max, data);\n        i += svcntw();\n    }\n\n    // Reduce the vector results to scalar values\n    int16_t min_val = svminv_s16(svptrue_b16(), vec_min);\n    int16_t max_val = svmaxv_s16(svptrue_b16(), vec_max);\n\n    // Handle any remaining elements\n    for (; i < length; ++i) {\n        if (vec[i] < min_val) min_val = vec[i];\n        if (vec[i] > max_val) max_val = vec[i];\n    }\n\n    result.min_num = min_val;\n    result.max_num = max_val;\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\n#include <arm_sve.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    svint16_t vec_min = svdup_n_s16(INT16_MAX);\n    svint16_t vec_max = svdup_n_s16(INT16_MIN);\n    size_t i = 0;\n\n    // Process vectorized part\n    svbool_t pg = svwhilelt_b16(i, length);\n    while (svptest_any(svptrue_b16(), pg)) {\n        svint16_t vec_data = svld1_s16(pg, &vec[i]);\n        vec_min = svmin_s16_m(pg, vec_min, vec_data);\n        vec_max = svmax_s16_m(pg, vec_max, vec_data);\n        i += svcntw();\n        pg = svwhilelt_b16(i, length);\n    }\n\n    // Reduce to scalar for min and max\n    int16_t min_val = svminv_s16(svptrue_b16(), vec_min);\n    int16_t max_val = svmaxv_s16(svptrue_b16(), vec_max);\n\n    // Handle any remaining elements\n    for (; i < length; ++i) {\n        if (vec[i] < min_val) min_val = vec[i];\n        if (vec[i] > max_val) max_val = vec[i];\n    }\n\n    result.min_num = min_val;\n    result.max_num = max_val;\n    return result;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    size_t vec_size = svcntw(); // Number of 32-bit integers in an SVE vector\n    svbool_t all_true = svptrue_b32(); // Predicate for all elements\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        bool row_increasing = true;\n\n        size_t j = 0;\n        // Process full vectors\n        for (; j + vec_size <= cols; j += vec_size) {\n            svint32_t curr = svld1_s32(all_true, row + j);\n            svint32_t next = svld1_s32(all_true, row + j + 1);\n\n            svbool_t cmp = svcmplt_s32(all_true, curr, next);\n            if (!svptest_all(all_true, cmp)) {\n                return false;\n            }\n        }\n\n        // Process remaining elements\n        for (; j < cols - 1; ++j) {\n            if (row[j] >= row[j + 1]) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    size_t vec_size = svcntw(); // Number of 32-bit integers in an SVE vector\n    svbool_t all_true = svptrue_b32(); // Predicate for full vector length\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        bool row_increasing = true;\n\n        size_t j = 0;\n        // Process elements in chunks of SVE vector size\n        for (; j + vec_size <= cols - 1; j += vec_size) {\n            svint32_t curr = svld1_s32(all_true, row + j);\n            svint32_t next = svld1_s32(all_true, row + j + 1);\n\n            svbool_t cmp = svcmplt_s32(all_true, curr, next);\n            if (!svptest_all(all_true, cmp)) {\n                return false;\n            }\n        }\n\n        // Process remaining elements (if any)\n        for (; j < cols - 1; ++j) {\n            if (row[j] >= row[j + 1]) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    size_t vec_size = svcntw(); // Number of 32-bit integers in an SVE vector\n    svbool_t all_true = svptrue_b32(); // Predicate for all elements\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        bool row_valid = true;\n\n        size_t j = 0;\n        // Process full vectors\n        for (; j + vec_size <= cols; j += vec_size) {\n            svint32_t curr = svld1_s32(all_true, row + j);\n            svint32_t next = svld1_s32(all_true, row + j + 1);\n\n            svbool_t cmp = svcmplt_s32(all_true, curr, next);\n            if (!svptest_all(all_true, cmp)) {\n                row_valid = false;\n                break;\n            }\n        }\n\n        // Process remaining elements\n        if (row_valid && j < cols - 1) {\n            svbool_t pred = svwhilelt_b32(j, cols - 1);\n            svint32_t curr = svld1_s32(pred, row + j);\n            svint32_t next = svld1_s32(pred, row + j + 1);\n\n            svbool_t cmp = svcmplt_s32(pred, curr, next);\n            if (!svptest_all(pred, cmp)) {\n                row_valid = false;\n            }\n        }\n\n        if (!row_valid) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    size_t vec_size = svcntw(); // Number of 32-bit integers in an SVE vector\n    svbool_t all_true = svptrue_b32(); // Predicate for full vector length\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        bool row_increasing = true;\n\n        size_t j = 0;\n        // Process elements in chunks of SVE vector size\n        for (; j + vec_size <= cols; j += vec_size) {\n            svint32_t curr = svld1_s32(all_true, row + j);\n            svint32_t next = svld1_s32(all_true, row + j + 1);\n\n            svbool_t cmp = svcmplt_s32(all_true, curr, next);\n            if (!svptest_all(all_true, cmp)) {\n                row_increasing = false;\n                break;\n            }\n        }\n\n        // Process remaining elements (if any)\n        for (; j < cols - 1; ++j) {\n            if (row[j] >= row[j + 1]) {\n                row_increasing = false;\n                break;\n            }\n        }\n\n        if (!row_increasing) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    size_t vec_size = svcntw(); // Number of 32-bit integers in an SVE vector\n    svbool_t all_true = svptrue_b32(); // Predicate for full vector length\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        bool row_valid = true;\n\n        size_t j = 0;\n        // Process elements in chunks of SVE vector size\n        for (; j + vec_size <= cols; j += vec_size) {\n            svint32_t curr = svld1_s32(all_true, row + j);\n            svint32_t next = svld1_s32(all_true, row + j + 1);\n\n            svbool_t cmp = svcmplt_s32(all_true, curr, next);\n            if (!svptest_all(all_true, cmp)) {\n                return false;\n            }\n        }\n\n        // Process remaining elements (if any)\n        for (; j < cols - 1; ++j) {\n            if (row[j] >= row[j + 1]) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n    size_t block_elements = block_size * block_size;\n\n    // Load the first block into a vector for comparison\n    svint32_t first_block_vec = svld1_s32(svptrue_b32(), matrix);\n\n    for (size_t i = 0; i < num_blocks_row; ++i) {\n        for (size_t j = 0; j < num_blocks_col; ++j) {\n            if (i == 0 && j == 0) continue; // Skip the first block\n\n            const int* current_block = matrix + (i * block_size * cols) + (j * block_size);\n            size_t k = 0;\n\n            svbool_t pg = svwhilelt_b32(k, block_elements);\n            do {\n                svint32_t current_block_vec = svld1_s32(pg, current_block + k);\n                svbool_t cmp_result = svcmpeq_s32(pg, current_block_vec, first_block_vec);\n\n                if (!svptest_first(pg, cmp_result)) {\n                    return false;\n                }\n\n                k += svcntw();\n                pg = svwhilelt_b32(k, block_elements);\n            } while (svptest_any(svptrue_b32(), pg));\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n\n    // Load the first block into a reference buffer\n    svint32_t ref_block[block_size][block_size];\n    for (size_t i = 0; i < block_size; ++i) {\n        for (size_t j = 0; j < block_size; ++j) {\n            ref_block[i][j] = svdup_n_s32(matrix[i * cols + j]);\n        }\n    }\n\n    // Compare all other blocks with the reference block\n    for (size_t bi = 0; bi < num_blocks_row; ++bi) {\n        for (size_t bj = 0; bj < num_blocks_col; ++bj) {\n            if (bi == 0 && bj == 0) continue; // Skip the first block\n\n            bool mismatch_found = false;\n            for (size_t i = 0; i < block_size && !mismatch_found; ++i) {\n                for (size_t j = 0; j < block_size; ++j) {\n                    size_t row = bi * block_size + i;\n                    size_t col = bj * block_size + j;\n                    svint32_t current_val = svdup_n_s32(matrix[row * cols + col]);\n                    svbool_t pg = svcmpeq(svptrue_b32(), current_val, ref_block[i][j]);\n                    if (svptest_any(svptrue_b32(), pg) == 0) {\n                        mismatch_found = true;\n                        break;\n                    }\n                }\n            }\n\n            if (mismatch_found) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n    size_t block_elements = block_size * block_size;\n\n    // Load the first block into a vector for comparison\n    svint32_t first_block_vec = svld1_s32(svptrue_b32(), matrix);\n\n    for (size_t i = 0; i < num_blocks_row; ++i) {\n        for (size_t j = 0; j < num_blocks_col; ++j) {\n            if (i == 0 && j == 0) continue; // Skip the first block\n\n            const int* current_block = matrix + (i * block_size * cols) + (j * block_size);\n            size_t idx = 0;\n\n            svbool_t pg = svwhilelt_b32(idx, block_elements);\n            do {\n                svint32_t current_block_vec = svld1_s32(pg, current_block + idx);\n                svbool_t cmp_result = svcmpeq(pg, current_block_vec, first_block_vec);\n\n                if (!svptest_first(pg, cmp_result)) {\n                    return false;\n                }\n\n                idx += svcntw();\n                pg = svwhilelt_b32(idx, block_elements);\n            } while (svptest_any(svptrue_b32(), pg));\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_block_rows = rows / block_size;\n    size_t num_block_cols = cols / block_size;\n    size_t block_elements = block_size * block_size;\n\n    // Load the first block into a vector for comparison\n    svint32_t first_block_vec = svld1_s32(svptrue_b32(), matrix);\n\n    for (size_t i = 0; i < num_block_rows; ++i) {\n        for (size_t j = 0; j < num_block_cols; ++j) {\n            if (i == 0 && j == 0) continue; // Skip the first block\n\n            const int* current_block = matrix + (i * block_size * cols) + (j * block_size);\n            size_t offset = 0;\n\n            svbool_t pg = svwhilelt_b32(offset, block_elements);\n            do {\n                svint32_t current_block_vec = svld1_s32(pg, current_block + offset);\n                svbool_t cmp_result = svcmpeq(pg, current_block_vec, first_block_vec);\n\n                if (!svptest_first(pg, cmp_result)) {\n                    return false;\n                }\n\n                offset += svcntw();\n                pg = svwhilelt_b32(offset, block_elements);\n            } while (svptest_any(svptrue_b32(), pg));\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n    size_t block_elements = block_size * block_size;\n\n    // Load the first block into a vector for comparison\n    svint32_t first_block_vec = svld1_s32(svptrue_b32(), matrix);\n\n    for (size_t i = 0; i < num_blocks_row; ++i) {\n        for (size_t j = 0; j < num_blocks_col; ++j) {\n            if (i == 0 && j == 0) continue; // Skip the first block\n\n            const int* current_block = matrix + (i * block_size * cols) + (j * block_size);\n            svbool_t pg = svwhilelt_b32(0, block_elements);\n\n            size_t k = 0;\n            bool mismatch_found = false;\n\n            while (svptest_any(svptrue_b32(), pg)) {\n                svint32_t current_block_vec = svld1_s32(pg, current_block + k);\n                svbool_t comparison_result = svcmpeq(pg, current_block_vec, first_block_vec);\n\n                if (!svptest_all(svptrue_b32(), comparison_result)) {\n                    mismatch_found = true;\n                    break;\n                }\n\n                k += svcntw();\n                pg = svwhilelt_b32(k, block_elements);\n            }\n\n            if (mismatch_found) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (block_size == 0 || length < block_size || tolerance < 0.0) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 2) {\n        return false;\n    }\n\n    svbool_t pg = svwhilelt_b64(0, block_size);\n    svfloat64_t tolerance_vec = svdup_f64(tolerance);\n    svfloat64_t first_block = svld1(pg, vec);\n\n    for (size_t i = 1; i < num_blocks; ++i) {\n        const double* current_block_ptr = vec + i * block_size;\n        svfloat64_t current_block = svld1(pg, current_block_ptr);\n\n        svfloat64_t diff = svsub_f64(current_block, first_block);\n        svfloat64_t abs_diff = svabs_f64(diff);\n        svbool_t not_within_tolerance = svcmpgt(pg, abs_diff, tolerance_vec);\n\n        if (svptest_any(svptrue_b64(), not_within_tolerance)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (block_size == 0 || length < block_size || vec == nullptr) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 2) {\n        return false;\n    }\n\n    svbool_t pg = svwhilelt_b64(0, block_size);\n    svfloat64_t tolerance_vec = svdup_f64(tolerance);\n\n    const double* first_block = vec;\n    for (size_t i = 1; i < num_blocks; ++i) {\n        const double* current_block = vec + i * block_size;\n        size_t j = 0;\n\n        do {\n            svfloat64_t first_vals = svld1(pg, first_block + j);\n            svfloat64_t curr_vals = svld1(pg, current_block + j);\n            svfloat64_t diff = svsub_f64(first_vals, curr_vals);\n            svfloat64_t abs_diff = svabs_f64(diff);\n            svbool_t not_within_tolerance = svcmpgt(pg, abs_diff, tolerance_vec);\n\n            if (svptest_any(svptrue_b64(), not_within_tolerance)) {\n                return false;\n            }\n\n            j += svcntd();\n        } while (j < block_size);\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (block_size == 0 || length < block_size || tolerance < 0.0) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 2) {\n        return false;\n    }\n\n    svbool_t pg = svwhilelt_b64(0, block_size);\n    svfloat64_t tolerance_vec = svdup_f64(tolerance);\n\n    // Load the first block as reference\n    svfloat64_t ref_vec = svld1(pg, vec);\n\n    for (size_t i = 1; i < num_blocks; ++i) {\n        const double* current_block = vec + i * block_size;\n        svfloat64_t current_vec = svld1(pg, current_block);\n\n        // Compute absolute difference\n        svfloat64_t diff = svsub_f64(current_vec, ref_vec);\n        svfloat64_t abs_diff = svabs_f64(diff);\n\n        // Check if any element exceeds tolerance\n        svbool_t exceeds_tolerance = svcmpgt(pg, abs_diff, tolerance_vec);\n        if (svptest_any(svptrue_b64(), exceeds_tolerance)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (block_size == 0 || length < block_size || vec == nullptr) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 2) {\n        return false;\n    }\n\n    svbool_t pg = svwhilelt_b64(0, block_size); // Predicate for the block size\n    svfloat64_t tolerance_vec = svdup_f64(tolerance); // Broadcast tolerance to a vector\n    svfloat64_t first_block_ref = svld1(pg, vec); // Load the first block as reference\n\n    for (size_t i = 1; i < num_blocks; ++i) {\n        const double* current_block = vec + i * block_size;\n        svfloat64_t current_block_vec = svld1(pg, current_block); // Load the current block\n        svfloat64_t diff = svsub_f64(current_block_vec, first_block_ref); // Compute element-wise difference\n        svfloat64_t abs_diff = svabs_f64(diff); // Absolute value of differences\n        svbool_t cmp = svacgt(pg, abs_diff, tolerance_vec); // Compare absolute differences with tolerance\n\n        if (svptest_any(svptrue_b64(), cmp)) { // Check if any element exceeds tolerance\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (block_size == 0 || length < block_size || tolerance < 0.0) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 2) {\n        return false;\n    }\n\n    svbool_t pg = svwhilelt_b64(0, block_size); // Predicate for the block size\n    svfloat64_t tolerance_vec = svdup_f64(tolerance); // Broadcast tolerance to a vector\n    svfloat64_t first_block_vec[block_size]; // Store the first block as reference\n\n    // Load the first block into vectors\n    for (size_t i = 0; i < block_size; i++) {\n        first_block_vec[i] = svdup_f64(vec[i]);\n    }\n\n    // Compare each subsequent block with the first block\n    for (size_t b = 1; b < num_blocks; ++b) {\n        size_t offset = b * block_size;\n\n        for (size_t i = 0; i < block_size; i++) {\n            svfloat64_t current_vec = svld1(pg, &vec[offset + i]); // Load current block element\n            svfloat64_t diff = svsub_f64(current_vec, first_block_vec[i]); // Compute difference\n            svfloat64_t abs_diff = svabs_f64(diff); // Absolute value of difference\n            svbool_t cmp = svacgt(pg, abs_diff, tolerance_vec); // Check if abs(diff) > tolerance\n\n            if (svptest_any(svptrue_b64(), cmp)) { // If any element exceeds tolerance\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    size_t vec_size = svcntd(); // Get the number of elements in an SVE vector\n    svbool_t all_active = svptrue_b64(); // Predicate for full vector length\n\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row_ptr = matrix + i * cols;\n        double threshold = thresholds[i];\n        double norm_sq = 0.0;\n\n        size_t j = 0;\n        svfloat64_t vec_sum_sq = svdup_f64(0.0); // Initialize vector accumulator for squared sum\n\n        // Process columns in chunks of SVE vector size\n        for (; j + vec_size <= cols; j += vec_size) {\n            svfloat64_t vec = svld1_f64(all_active, row_ptr + j); // Load a vector of elements\n            vec_sum_sq = svmla_f64(vec_sum_sq, vec, vec); // Accumulate squared values\n        }\n\n        // Reduce the vector sum to a scalar\n        double sum_sq = 0.0;\n        svst1_f64(svptrue_b64(), &sum_sq, vec_sum_sq);\n\n        // Handle remaining elements (if any)\n        for (; j < cols; ++j) {\n            double val = row_ptr[j];\n            norm_sq += val * val;\n        }\n\n        // Combine the partial sums\n        norm_sq += sum_sq;\n\n        // Compare the Euclidean norm with the threshold\n        result[i] = (norm_sq > threshold * threshold);\n    }\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    size_t vec_size = svcntd(); // Get the number of elements in an SVE vector\n    svbool_t pg = svptrue_b64(); // Predicate for full vector operations\n\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row_ptr = matrix + i * cols;\n        double threshold = thresholds[i];\n        double norm_sq = 0.0;\n\n        size_t j = 0;\n        // Process full SVE vectors\n        for (; j + vec_size <= cols; j += vec_size) {\n            svfloat64_t vec = svld1(pg, row_ptr + j); // Load a vector of doubles\n            svfloat64_t squared = svmul_x(pg, vec, vec); // Square each element\n            norm_sq += svaddv(pg, squared); // Sum reduction across the vector\n        }\n\n        // Process remaining elements (if any)\n        for (; j < cols; ++j) {\n            norm_sq += row_ptr[j] * row_ptr[j];\n        }\n\n        // Compare the Euclidean norm with the threshold\n        double norm = sqrt(norm_sq);\n        result[i] = (norm > threshold);\n    }\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    size_t vec_size = svcntd(); // Get the number of elements in an SVE vector\n    svbool_t all_active = svptrue_b64(); // Predicate for full vector operations\n\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row_ptr = matrix + i * cols;\n        double threshold = thresholds[i];\n        double norm_sq = 0.0;\n\n        size_t j = 0;\n        svfloat64_t vec_sum_sq = svdup_f64(0.0); // Initialize vector accumulator for squared sum\n\n        // Process columns in chunks of SVE vector width\n        for (; j + vec_size <= cols; j += vec_size) {\n            svfloat64_t vec = svld1_f64(all_active, row_ptr + j); // Load vector from memory\n            vec_sum_sq = svmla_f64(vec_sum_sq, vec, vec); // Accumulate squared values\n        }\n\n        // Horizontal reduction to compute the sum of squares\n        double sum_sq = 0.0;\n        svbool_t pred = svwhilelt_b64(j, cols); // Predicate for remaining elements\n        svfloat64_t vec = svld1_f64(pred, row_ptr + j); // Load remaining elements\n        vec_sum_sq = svmla_f64(vec_sum_sq, vec, vec); // Accumulate squared values for remaining elements\n\n        // Reduce the vector sum into a scalar\n        for (size_t k = 0; k < vec_size; ++k) {\n            sum_sq += svlasta_f64(vec_sum_sq);\n            vec_sum_sq = svuzp2_f64(vec_sum_sq, vec_sum_sq); // Shift out processed elements\n        }\n\n        // Compare Euclidean norm with threshold\n        double norm = sqrt(sum_sq);\n        result[i] = (norm > threshold);\n    }\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    size_t vec_size = svcntd(); // Number of elements in an SVE vector\n    svbool_t pg = svptrue_b64(); // Predicate for full vector operations\n\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row_ptr = matrix + i * cols;\n        double threshold = thresholds[i];\n        double norm_sq = 0.0;\n\n        size_t j = 0;\n        // Process full SVE vectors\n        for (; j + vec_size <= cols; j += vec_size) {\n            svfloat64_t vec = svld1(pg, row_ptr + j); // Load vector from memory\n            norm_sq += svaddv(pg, svmul_x(pg, vec, vec)); // Accumulate squared values\n        }\n\n        // Process remaining elements (tail)\n        if (j < cols) {\n            svbool_t tail_pg = svwhilelt_b64(j, cols); // Predicate for tail processing\n            svfloat64_t vec = svld1(tail_pg, row_ptr + j); // Load partial vector\n            norm_sq += svaddv(tail_pg, svmul_x(tail_pg, vec, vec)); // Accumulate squared values\n        }\n\n        // Compare Euclidean norm with threshold\n        double norm = sqrt(norm_sq);\n        result[i] = (norm > threshold);\n    }\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    size_t col_stride = svcntd() * sizeof(double); // Vector length in bytes for doubles\n    size_t vec_len = svcntd();                     // Number of elements per vector\n\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row_ptr = matrix + i * cols;\n        svbool_t pg = svwhilelt_b64(0, cols);      // Predicate for active lanes\n        svfloat64_t vec_sum = svdup_f64(0.0);      // Initialize sum vector to zero\n\n        size_t j = 0;\n        for (; j <= cols - vec_len; j += vec_len) {\n            svfloat64_t vec = svld1(pg, row_ptr + j); // Load vector from memory\n            vec_sum = svmla_f64(vec_sum, vec, vec);   // Accumulate squared values\n        }\n\n        // Handle remaining elements\n        if (j < cols) {\n            pg = svwhilelt_b64(j, cols);              // Update predicate for remaining elements\n            svfloat64_t vec = svld1(pg, row_ptr + j); // Load remaining elements\n            vec_sum = svmla_f64(vec_sum, vec, vec);   // Accumulate squared values\n        }\n\n        // Horizontal reduction to compute the sum of squares\n        double norm_sq = 0.0;\n        svfloat64_t sum_vec = vec_sum;\n        while (svcntd() > 1) {\n            sum_vec = svadd_f64(svuzp1(sum_vec, sum_vec), svuzp2(sum_vec, sum_vec));\n        }\n        norm_sq = svlasta_f64(pg, sum_vec);\n\n        // Compare Euclidean norm with threshold\n        double norm = sqrt(norm_sq);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t vecA = svld1(pg, &A[i]);\n        svuint32_t vecB = svld1(pg, &B[i]);\n        svuint32_t vecC = svorr_x(pg, vecA, vecB);\n        svst1(pg, &C[i], vecC);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t va = svld1(pg, &A[i]);\n        svuint32_t vb = svld1(pg, &B[i]);\n        svuint32_t vc = svorr_x(pg, va, vb);\n        svst1(pg, &C[i], vc);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t vecA = svld1(pg, &A[i]);\n        svuint32_t vecB = svld1(pg, &B[i]);\n        svuint32_t vecC = svorr_x(pg, vecA, vecB);\n        svst1(pg, &C[i], vecC);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t va = svld1(pg, &A[i]);\n        svuint32_t vb = svld1(pg, &B[i]);\n        svuint32_t vc = svorr_x(pg, va, vb);\n        svst1(pg, &C[i], vc);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t va = svld1(pg, &A[i]);\n        svuint32_t vb = svld1(pg, &B[i]);\n        svuint32_t vc = svorr_x(pg, va, vb);\n        svst1(pg, &C[i], vc);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_of_squares = 0;\n    int64_t sum_of_products = 0;\n\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b8(i, length);\n\n    svint8_t vec_a, vec_b;\n    svint16_t vec_square_a, vec_square_b, vec_product;\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        vec_a = svld1_s8(pg, &A[i]);\n        vec_b = svld1_s8(pg, &B[i]);\n\n        // Compute squares\n        vec_square_a = svmulh_s16(svunpklo_s8(vec_a), svunpklo_s8(vec_a));\n        vec_square_b = svmulh_s16(svunpklo_s8(vec_b), svunpklo_s8(vec_b));\n\n        // Compute products\n        vec_product = svmulh_s16(svunpklo_s8(vec_a), svunpklo_s8(vec_b));\n\n        // Accumulate horizontally\n        sum_of_squares += svaddv_s16(pg, svadd_s16(vec_square_a, vec_square_b));\n        sum_of_products += svaddv_s16(pg, vec_product);\n\n        i += svcntw();\n        pg = svwhilelt_b8(i, length);\n    }\n\n    return sum_of_squares - sum_of_products;\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    svint8_t va, vb;\n    svint32_t vsum_squares = svdup_s32(0);\n    svint32_t vsum_products = svdup_s32(0);\n    svbool_t pg = svwhilelt_b8(0, length);\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        va = svld1_s8(pg, A);\n        vb = svld1_s8(pg, B);\n\n        svint16_t va_wide = svunpklo_s16(va);\n        svint16_t vb_wide = svunpklo_s16(vb);\n\n        svint32_t va_sq = svmul_s32(svsmul_s32(va_wide, va_wide), svdup_s32(1));\n        svint32_t vb_sq = svmul_s32(svsmul_s32(vb_wide, vb_wide), svdup_s32(1));\n        svint32_t vprod = svmul_s32(svsmul_s32(va_wide, vb_wide), svdup_s32(1));\n\n        vsum_squares = svadd_s32_m(pg, vsum_squares, svadd_s32(va_sq, vb_sq));\n        vsum_products = svadd_s32_m(pg, vsum_products, vprod);\n\n        A += svcntb();\n        B += svcntb();\n        length -= svcntb();\n        pg = svwhilelt_b8(0, length);\n    }\n\n    int32_t sum_squares = svaddv_s32(svptrue_b32(), vsum_squares);\n    int32_t sum_products = svaddv_s32(svptrue_b32(), vsum_products);\n\n    return (int64_t)sum_squares - (int64_t)sum_products;\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    svint8_t va, vb;\n    svint32_t vsum_squares = svdup_s32(0);\n    svint32_t vsum_products = svdup_s32(0);\n    svbool_t pg = svwhilelt_b8(0, length);\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        va = svld1_s8(pg, A);\n        vb = svld1_s8(pg, B);\n\n        svint16_t va_wide = svunpklo_s16(va);\n        svint16_t vb_wide = svunpklo_s16(vb);\n\n        svint32_t va_sq = svmul_s32_x(pg, svmovlb_s32(va_wide), svmovlb_s32(va_wide));\n        svint32_t vb_sq = svmul_s32_x(pg, svmovlb_s32(vb_wide), svmovlb_s32(vb_wide));\n        svint32_t vprod = svmul_s32_x(pg, svmovlb_s32(va_wide), svmovlb_s32(vb_wide));\n\n        vsum_squares = svadd_s32_x(pg, vsum_squares, svadd_s32_x(pg, va_sq, vb_sq));\n        vsum_products = svadd_s32_x(pg, vsum_products, vprod);\n\n        A += svcntw();\n        B += svcntw();\n        length -= svcntw();\n        pg = svwhilelt_b8(0, length);\n    }\n\n    int32_t sum_squares = svaddv_s32(svptrue_b32(), vsum_squares);\n    int32_t sum_products = svaddv_s32(svptrue_b32(), vsum_products);\n\n    return (int64_t)sum_squares - (int64_t)sum_products;\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    svint8_t va, vb;\n    svint32_t vsum_squares = svdup_n_s32(0);\n    svint32_t vsum_products = svdup_n_s32(0);\n    svbool_t pg = svwhilelt_b8(0, length);\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        va = svld1sb_s8(pg, A);\n        vb = svld1sb_s8(pg, B);\n\n        svint16_t va_wide = svmovlb_s16(va);\n        svint16_t vb_wide = svmovlb_s16(vb);\n\n        svint32_t va_sq = svmul_n_s32_x(pg, svmovlb_s32(va_wide), svmovlb_s32(va_wide));\n        svint32_t vb_sq = svmul_n_s32_x(pg, svmovlb_s32(vb_wide), svmovlb_s32(vb_wide));\n        svint32_t vprod = svmul_n_s32_x(pg, svmovlb_s32(va_wide), svmovlb_s32(vb_wide));\n\n        vsum_squares = svadd_s32_x(pg, vsum_squares, svadd_s32_x(pg, va_sq, vb_sq));\n        vsum_products = svadd_s32_x(pg, vsum_products, vprod);\n\n        A += svcntb();\n        B += svcntb();\n        length -= svcntb();\n        pg = svwhilelt_b8(0, length);\n    }\n\n    int32_t sum_squares = 0, sum_products = 0;\n    sum_squares = svaddv_s32(svptrue_b32(), vsum_squares);\n    sum_products = svaddv_s32(svptrue_b32(), vsum_products);\n\n    return (int64_t)sum_squares - (int64_t)sum_products;\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    svint8_t va, vb;\n    svint32_t vsum_squares = svdup_n_s32(0);\n    svint32_t vsum_products = svdup_n_s32(0);\n    svbool_t pg = svwhilelt_b8(0, length);\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        va = svld1sb_s8(pg, A);\n        vb = svld1sb_s8(pg, B);\n\n        svint16_t va_wide = svunpklo_s16(va);\n        svint16_t vb_wide = svunpklo_s16(vb);\n\n        svint32_t va_sq = svmul_s32(svsmul_s32(va_wide, va_wide), svdup_n_s32(1));\n        svint32_t vb_sq = svmul_s32(svsmul_s32(vb_wide, vb_wide), svdup_n_s32(1));\n        svint32_t vprod = svmul_s32(svsmul_s32(va_wide, vb_wide), svdup_n_s32(1));\n\n        vsum_squares = svadd_s32_m(pg, vsum_squares, svadd_s32(va_sq, vb_sq));\n        vsum_products = svadd_s32_m(pg, vsum_products, vprod);\n\n        A += svcntb();\n        B += svcntb();\n        length -= svcntb();\n        pg = svwhilelt_b8(0, length);\n    }\n\n    int32_t sum_squares = svaddv_s32(svptrue_b32(), vsum_squares);\n    int32_t sum_products = svaddv_s32(svptrue_b32(), vsum_products);\n\n    return (int64_t)sum_squares - (int64_t)sum_products;\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, length);\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svuint64_t va = svld1_u64(pg, &A[i]);\n        svuint64_t vb = svld1_u64(pg, &B[i]);\n        svuint64_t vc = svand_u64(pg, va, svnot_u64(pg, vb));\n        svst1_u64(pg, &C[i], vc);\n\n        i += svcntd();\n        pg = svwhilelt_b64(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, length);\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svuint64_t vecA = svld1(pg, &A[i]);\n        svuint64_t vecB = svld1(pg, &B[i]);\n        svuint64_t vecC = svand_z(pg, vecA, svnot_z(pg, vecB));\n        svst1(pg, &C[i], vecC);\n        i += svcntd();\n        pg = svwhilelt_b64(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, length);\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svuint64_t vecA = svld1(pg, &A[i]);\n        svuint64_t vecB = svld1(pg, &B[i]);\n        svuint64_t vecC = svand_z(pg, vecA, svnot_z(pg, vecB));\n        svst1(pg, &C[i], vecC);\n        i += svcntd();\n        pg = svwhilelt_b64(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, length);\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svuint64_t va = svld1(pg, &A[i]);\n        svuint64_t vb = svld1(pg, &B[i]);\n        svuint64_t vc = svand(va, svnot(vb));\n        svst1(pg, &C[i], vc);\n        i += svcntd();\n        pg = svwhilelt_b64(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, length);\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svuint64_t va = svld1_u64(pg, &A[i]);\n        svuint64_t vb = svld1_u64(pg, &B[i]);\n        svuint64_t vc = svand_u64(pg, va, svnot_u64(pg, vb));\n        svst1_u64(pg, &C[i], vc);\n        i += svcntd();\n        pg = svwhilelt_b64(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b8(i, length);\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svint8_t va = svld1_s8(pg, &A[i]);\n        svint8_t vb = svld1_s8(pg, &B[i]);\n\n        svbool_t both_positive = svand_b_z(pg, svcmpgt_n_s8(pg, va, 0), svcmpgt_n_s8(pg, vb, 0));\n        svbool_t both_negative = svand_b_z(pg, svcmplt_n_s8(pg, va, 0), svcmplt_n_s8(pg, vb, 0));\n\n        svint8_t result = svdup_n_s8(0);\n        result = svsel_s8(both_positive, svdup_n_s8(1), result);\n        result = svsel_s8(both_negative, svdup_n_s8(-1), result);\n\n        svst1_s8(pg, &C[i], result);\n\n        i += svcntw();\n        pg = svwhilelt_b8(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b8(i, length);\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svint8_t va = svld1_s8(pg, &A[i]);\n        svint8_t vb = svld1_s8(pg, &B[i]);\n\n        svbool_t both_positive = svand_b_z(pg, svcmpgt_n_s8(pg, va, 0), svcmpgt_n_s8(pg, vb, 0));\n        svbool_t both_negative = svand_b_z(pg, svcmplt_n_s8(pg, va, 0), svcmplt_n_s8(pg, vb, 0));\n\n        svint8_t result = svdup_s8(0);\n        result = svsel_s8(both_positive, svdup_s8(1), result);\n        result = svsel_s8(both_negative, svdup_s8(-1), result);\n\n        svst1_s8(pg, &C[i], result);\n\n        i += svcntb();\n        pg = svwhilelt_b8(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b8(i, length);\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svint8_t va = svld1_s8(pg, &A[i]);\n        svint8_t vb = svld1_s8(pg, &B[i]);\n\n        svbool_t both_positive = svand_b_z(pg, svgt_s8(pg, va, 0), svgt_s8(pg, vb, 0));\n        svbool_t both_negative = svand_b_z(pg, svlt_s8(pg, va, 0), svlt_s8(pg, vb, 0));\n\n        svint8_t result = svdup_s8(0);\n        result = svsel_s8(both_positive, svdup_s8(1), result);\n        result = svsel_s8(both_negative, svdup_s8(-1), result);\n\n        svst1_s8(pg, &C[i], result);\n\n        i += svcntb();\n        pg = svwhilelt_b8(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b8(i, length);\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svint8_t va = svld1_s8(pg, &A[i]);\n        svint8_t vb = svld1_s8(pg, &B[i]);\n\n        svbool_t both_positive = svand_b_z(pg, svcmpgt_n_s8(pg, va, 0), svcmpgt_n_s8(pg, vb, 0));\n        svbool_t both_negative = svand_b_z(pg, svcmplt_n_s8(pg, va, 0), svcmplt_n_s8(pg, vb, 0));\n\n        svint8_t result = svdup_n_s8(0);\n        result = svsel_s8(both_positive, svdup_n_s8(1), result);\n        result = svsel_s8(both_negative, svdup_n_s8(-1), result);\n\n        svst1_s8(pg, &C[i], result);\n\n        i += svcntb();\n        pg = svwhilelt_b8(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b8(i, length);\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svint8_t va = svld1_s8(pg, &A[i]);\n        svint8_t vb = svld1_s8(pg, &B[i]);\n\n        svbool_t both_positive = svand_b_z(pg, svcmpgt_n_s8(pg, va, 0), svcmpgt_n_s8(pg, vb, 0));\n        svbool_t both_negative = svand_b_z(pg, svcmplt_n_s8(pg, va, 0), svcmplt_n_s8(pg, vb, 0));\n\n        svint8_t result = svdup_s8(0);\n        result = svsel_s8(both_positive, svdup_s8(1), result);\n        result = svsel_s8(both_negative, svdup_s8(-1), result);\n\n        svst1_s8(pg, &C[i], result);\n\n        i += svcntw();\n        pg = svwhilelt_b8(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t i = 0;\n\n    // Process elements before the midpoint\n    for (; i + svcntw() <= midpoint; i += svcntw()) {\n        svuint16_t va = svld1_u16(svptrue_b16(), &A[i]);\n        svuint16_t vb = svld1_u16(svptrue_b16(), &B[i]);\n        svuint16_t vc = sveor_u16(va, vb);\n        svst1_u16(svptrue_b16(), &C[i], vc);\n    }\n\n    // Process remaining elements before the midpoint\n    if (i < midpoint) {\n        svbool_t pg = svwhilelt_b16(i, midpoint);\n        svuint16_t va = svld1_u16(pg, &A[i]);\n        svuint16_t vb = svld1_u16(pg, &B[i]);\n        svuint16_t vc = sveor_u16(va, vb);\n        svst1_u16(pg, &C[i], vc);\n        i = midpoint;\n    }\n\n    // Process the element exactly at the midpoint\n    if (midpoint < length) {\n        C[midpoint] = A[midpoint];\n        i = midpoint + 1;\n    }\n\n    // Process elements after the midpoint\n    for (; i + svcntw() <= length; i += svcntw()) {\n        svuint16_t va = svld1_u16(svptrue_b16(), &A[i]);\n        svuint16_t vb = svld1_u16(svptrue_b16(), &B[i]);\n        svuint16_t vc = svand_u16(va, vb);\n        svst1_u16(svptrue_b16(), &C[i], vc);\n    }\n\n    // Process remaining elements after the midpoint\n    if (i < length) {\n        svbool_t pg = svwhilelt_b16(i, length);\n        svuint16_t va = svld1_u16(pg, &A[i]);\n        svuint16_t vb = svld1_u16(pg, &B[i]);\n        svuint16_t vc = svand_u16(va, vb);\n        svst1_u16(pg, &C[i], vc);\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t vl;\n\n    // Process elements before the midpoint: XOR operation\n    for (size_t i = 0; i < midpoint; i += vl) {\n        svbool_t pg = svwhilelt_b16(i, midpoint);\n        vl = svcntw();\n\n        svuint16_t va = svld1(pg, &A[i]);\n        svuint16_t vb = svld1(pg, &B[i]);\n        svuint16_t vc = sveor(va, vb);\n\n        svst1(pg, &C[i], vc);\n    }\n\n    // Process the element exactly at the midpoint: keep value from A\n    if (length % 2 == 1 || midpoint < length) {\n        C[midpoint] = A[midpoint];\n    }\n\n    // Process elements after the midpoint: AND operation\n    for (size_t i = midpoint + 1; i < length; i += vl) {\n        svbool_t pg = svwhilelt_b16(i, length);\n        vl = svcntw();\n\n        svuint16_t va = svld1(pg, &A[i]);\n        svuint16_t vb = svld1(pg, &B[i]);\n        svuint16_t vc = svand(va, vb);\n\n        svst1(pg, &C[i], vc);\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t vl;\n\n    // Process elements before the midpoint: XOR operation\n    for (size_t i = 0; i < midpoint; i += vl) {\n        svbool_t pg = svwhilelt_b16(i, midpoint);\n        vl = svcntw();\n\n        svuint16_t vecA = svld1(pg, &A[i]);\n        svuint16_t vecB = svld1(pg, &B[i]);\n\n        svuint16_t result = sveor(vecA, vecB);\n        svst1(pg, &C[i], result);\n    }\n\n    // Process the element exactly at the midpoint: keep value from A\n    if (length % 2 == 1 || midpoint < length) {\n        C[midpoint] = A[midpoint];\n    }\n\n    // Process elements after the midpoint: AND operation\n    for (size_t i = midpoint + 1; i < length; i += vl) {\n        svbool_t pg = svwhilelt_b16(i, length);\n        vl = svcntw();\n\n        svuint16_t vecA = svld1(pg, &A[i]);\n        svuint16_t vecB = svld1(pg, &B[i]);\n\n        svuint16_t result = svand(vecA, vecB);\n        svst1(pg, &C[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t vl;\n\n    // Process elements before the midpoint: XOR operation\n    for (size_t i = 0; i < midpoint; i += vl) {\n        svbool_t pg = svwhilelt_b16(i, midpoint);\n        vl = svcntw();\n        svuint16_t va = svld1(pg, &A[i]);\n        svuint16_t vb = svld1(pg, &B[i]);\n        svuint16_t vc = sveor_x(pg, va, vb);\n        svst1(pg, &C[i], vc);\n    }\n\n    // Process the element exactly at the midpoint: keep value from A\n    if (length % 2 == 1 || midpoint < length) {\n        C[midpoint] = A[midpoint];\n    }\n\n    // Process elements after the midpoint: AND operation\n    for (size_t i = midpoint + 1; i < length; i += vl) {\n        svbool_t pg = svwhilelt_b16(i, length);\n        vl = svcntw();\n        svuint16_t va = svld1(pg, &A[i]);\n        svuint16_t vb = svld1(pg, &B[i]);\n        svuint16_t vc = svand_x(pg, va, vb);\n        svst1(pg, &C[i], vc);\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t i = 0;\n\n    // Process elements before the midpoint\n    for (; i + svcntw() <= midpoint; i += svcntw()) {\n        svuint16_t va = svld1_u16(svptrue_b16(), &A[i]);\n        svuint16_t vb = svld1_u16(svptrue_b16(), &B[i]);\n        svuint16_t vc = sveor_u16(va, vb);\n        svst1_u16(svptrue_b16(), &C[i], vc);\n    }\n\n    // Process remaining elements before the midpoint\n    if (i < midpoint) {\n        svbool_t pg = svwhilelt_b16(i, midpoint);\n        svuint16_t va = svld1_u16(pg, &A[i]);\n        svuint16_t vb = svld1_u16(pg, &B[i]);\n        svuint16_t vc = sveor_u16(va, vb);\n        svst1_u16(pg, &C[i], vc);\n        i = midpoint;\n    }\n\n    // Process the element exactly at the midpoint\n    if (midpoint < length) {\n        C[midpoint] = A[midpoint];\n        i = midpoint + 1;\n    }\n\n    // Process elements after the midpoint\n    for (; i + svcntw() <= length; i += svcntw()) {\n        svuint16_t va = svld1_u16(svptrue_b16(), &A[i]);\n        svuint16_t vb = svld1_u16(svptrue_b16(), &B[i]);\n        svuint16_t vc = svand_u16(va, vb);\n        svst1_u16(svptrue_b16(), &C[i], vc);\n    }\n\n    // Process remaining elements after the midpoint\n    if (i < length) {\n        svbool_t pg = svwhilelt_b16(i, length);\n        svuint16_t va = svld1_u16(pg, &A[i]);\n        svuint16_t vb = svld1_u16(pg, &B[i]);\n        svuint16_t vc = svand_u16(va, vb);\n        svst1_u16(pg, &C[i], vc);\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b32(i, total_elements);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load vectors for A, B, C, D\n        svfloat32_t vec_A = svld1_f32(pg, &A[i]);\n        svfloat32_t vec_B = svld1_f32(pg, &B[i]);\n        svfloat32_t vec_C = svld1_f32(pg, &C[i]);\n        svfloat32_t vec_D = svld1_f32(pg, &D[i]);\n\n        // Load boolean conditions\n        svbool_t vec_cond1 = svld1sb_b32(pg, &cond1[i]);\n        svbool_t vec_cond2 = svld1sb_b32(pg, &cond2[i]);\n\n        // Compute the output based on conditions\n        svfloat32_t result = svdup_f32(0.0f); // Initialize to avoid undefined behavior\n\n        // Case 1: cond1 && cond2 -> A\n        svbool_t mask_case1 = svand_b_z(pg, vec_cond1, vec_cond2);\n        result = svsel_f32(mask_case1, vec_A, result);\n\n        // Case 2: cond1 && !cond2 -> B\n        svbool_t mask_case2 = svand_b_z(pg, vec_cond1, svnot_b_z(pg, vec_cond2));\n        result = svsel_f32(mask_case2, vec_B, result);\n\n        // Case 3: !cond1 && cond2 -> C\n        svbool_t mask_case3 = svand_b_z(pg, svnot_b_z(pg, vec_cond1), vec_cond2);\n        result = svsel_f32(mask_case3, vec_C, result);\n\n        // Case 4: !cond1 && !cond2 -> D\n        svbool_t mask_case4 = svand_b_z(pg, svnot_b_z(pg, vec_cond1), svnot_b_z(pg, vec_cond2));\n        result = svsel_f32(mask_case4, vec_D, result);\n\n        // Store the result back to memory\n        svst1_f32(pg, &out[i], result);\n\n        // Update index and predicate\n        i += svcntw();\n        pg = svwhilelt_b32(i, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b32(i, total_elements);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load vectors for A, B, C, D, cond1, and cond2\n        svfloat32_t vec_A = svld1_f32(pg, &A[i]);\n        svfloat32_t vec_B = svld1_f32(pg, &B[i]);\n        svfloat32_t vec_C = svld1_f32(pg, &C[i]);\n        svfloat32_t vec_D = svld1_f32(pg, &D[i]);\n\n        svbool_t vec_cond1 = svld1sb_b32(pg, &cond1[i]);\n        svbool_t vec_cond2 = svld1sb_b32(pg, &cond2[i]);\n\n        // Compute conditions\n        svbool_t cond1_and_cond2 = svand_b_z(pg, vec_cond1, vec_cond2);\n        svbool_t cond1_and_not_cond2 = svand_b_z(pg, vec_cond1, svnot_b_z(pg, vec_cond2));\n        svbool_t not_cond1_and_cond2 = svand_b_z(pg, svnot_b_z(pg, vec_cond1), vec_cond2);\n        svbool_t not_cond1_and_not_cond2 = svand_b_z(pg, svnot_b_z(pg, vec_cond1), svnot_b_z(pg, vec_cond2));\n\n        // Select values based on conditions\n        svfloat32_t result = svsel_f32(cond1_and_cond2, vec_A,\n                              svsel_f32(cond1_and_not_cond2, vec_B,\n                              svsel_f32(not_cond1_and_cond2, vec_C, vec_D)));\n\n        // Store the result\n        svst1_f32(pg, &out[i], result);\n\n        // Update index and predicate\n        i += svcntw();\n        pg = svwhilelt_b32(i, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b32(i, total_elements);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load vectors for A, B, C, D\n        svfloat32_t vec_A = svld1_f32(pg, &A[i]);\n        svfloat32_t vec_B = svld1_f32(pg, &B[i]);\n        svfloat32_t vec_C = svld1_f32(pg, &C[i]);\n        svfloat32_t vec_D = svld1_f32(pg, &D[i]);\n\n        // Load boolean conditions\n        svbool_t vec_cond1 = svld1sb_b32(pg, &cond1[i]);\n        svbool_t vec_cond2 = svld1sb_b32(pg, &cond2[i]);\n\n        // Compute the result based on conditions\n        svfloat32_t result = svsel_f32(\n            svand_z(pg, vec_cond1, vec_cond2), vec_A,\n            svsel_f32(\n                svand_z(pg, vec_cond1, svnot_z(pg, vec_cond2)), vec_B,\n                svsel_f32(\n                    svand_z(pg, svnot_z(pg, vec_cond1), vec_cond2), vec_C, vec_D\n                )\n            )\n        );\n\n        // Store the result back to memory\n        svst1_f32(pg, &out[i], result);\n\n        // Update index and predicate\n        i += svcntw();\n        pg = svwhilelt_b32(i, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b32(i, total_elements);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load vectors for A, B, C, D\n        svfloat32_t vec_A = svld1_f32(pg, &A[i]);\n        svfloat32_t vec_B = svld1_f32(pg, &B[i]);\n        svfloat32_t vec_C = svld1_f32(pg, &C[i]);\n        svfloat32_t vec_D = svld1_f32(pg, &D[i]);\n\n        // Load boolean conditions\n        svbool_t vec_cond1 = svld1sb_b32(pg, &cond1[i]);\n        svbool_t vec_cond2 = svld1sb_b32(pg, &cond2[i]);\n\n        // Compute the output based on conditions\n        svfloat32_t result = svsel_f32(\n            svand_z(pg, vec_cond1, vec_cond2), vec_A,\n            svsel_f32(\n                svand_z(pg, vec_cond1, svnot_z(pg, vec_cond2)), vec_B,\n                svsel_f32(\n                    svand_z(pg, svnot_z(pg, vec_cond1), vec_cond2), vec_C, vec_D\n                )\n            )\n        );\n\n        // Store the result back to memory\n        svst1_f32(pg, &out[i], result);\n\n        // Update index and predicate\n        i += svcntw();\n        pg = svwhilelt_b32(i, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    while (i < total_elements) {\n        // Load vectors of conditions and data\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        svfloat32_t vec_A = svld1_f32(pg, &A[i]);\n        svfloat32_t vec_B = svld1_f32(pg, &B[i]);\n        svfloat32_t vec_C = svld1_f32(pg, &C[i]);\n        svfloat32_t vec_D = svld1_f32(pg, &D[i]);\n\n        svbool_t vec_cond1 = svld1sb_b32(pg, &cond1[i]);\n        svbool_t vec_cond2 = svld1sb_b32(pg, &cond2[i]);\n\n        // Compute the output based on conditions\n        svfloat32_t result = svdup_f32(0.0f);\n\n        // Case 1: cond1 && cond2 -> A\n        svbool_t mask_case1 = svand_b_z(pg, vec_cond1, vec_cond2);\n        result = svsel_f32(mask_case1, vec_A, result);\n\n        // Case 2: cond1 && !cond2 -> B\n        svbool_t mask_case2 = svand_b_z(pg, vec_cond1, svnot_b_z(pg, vec_cond2));\n        result = svsel_f32(mask_case2, vec_B, result);\n\n        // Case 3: !cond1 && cond2 -> C\n        svbool_t mask_case3 = svand_b_z(pg, svnot_b_z(pg, vec_cond1), vec_cond2);\n        result = svsel_f32(mask_case3, vec_C, result);\n\n        // Case 4: !cond1 && !cond2 -> D\n        svbool_t mask_case4 = svand_b_z(pg, svnot_b_z(pg, vec_cond1), svnot_b_z(pg, vec_cond2));\n        result = svsel_f32(mask_case4, vec_D, result);\n\n        // Store the result back to memory\n        svst1_f32(pg, &out[i], result);\n\n        // Increment the index by the vector length\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b32(i, total_elements);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t vec_A = svld1(pg, &A[i]);\n        svuint8_t bit_count = svdup_u8(0);\n\n        for (int bit = 0; bit < 32; ++bit) {\n            svuint32_t mask = svdup_u32(1 << bit);\n            svuint32_t bits_set = svand(vec_A, mask);\n            svbool_t bits_set_pred = svcmpeq(bits_set, mask);\n            bit_count = svadd_u8_m(bit_count, svcntp(bits_set_pred));\n        }\n\n        svst1(pg, &out[i], bit_count);\n        i += svcntw();\n        pg = svwhilelt_b32(i, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b32(i, total_elements);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load a vector of 32-bit integers from A\n        svuint32_t vecA = svld1(pg, &A[i]);\n\n        // Count the number of bits set to 1 in each element of vecA\n        svuint8_t bit_count = svcntsb(svcmpeq_n_u32(pg, vecA, 0));\n\n        // Store the result into the output array\n        svst1b(pg, &out[i], bit_count);\n\n        // Update the index and predicate\n        i += svcntw();\n        pg = svwhilelt_b32(i, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b32(i, total_elements);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load a vector of 32-bit integers from A\n        svuint32_t vecA = svld1(pg, &A[i]);\n\n        // Count the number of bits set to 1 in each element of vecA\n        svuint8_t bit_count = svcntsb(svgetlane_u8(svcntb(vecA), 0));\n\n        // Store the result into the output array\n        svst1(pg, &out[i], bit_count);\n\n        // Update the index and predicate\n        i += svcntw();\n        pg = svwhilelt_b32(i, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b32(i, total_elements);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t vec_A = svld1(pg, &A[i]);\n        svuint8_t bit_count = svdup_u8(0);\n\n        for (int bit = 0; bit < 32; ++bit) {\n            svuint32_t mask = svdup_u32(1 << bit);\n            svuint32_t bits_set = svand(vec_A, mask);\n            svbool_t bits_set_pred = svcmpne(bits_set, svdup_u32(0));\n            bit_count = svadd_u8_m(bit_count, bit_count, svdup_u8(1), bits_set_pred);\n        }\n\n        svst1b(pg, &out[i], bit_count);\n        i += svcntw();\n        pg = svwhilelt_b32(i, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b32(i, total_elements);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t vecA = svld1(pg, &A[i]);\n        svuint8_t bitCount = svdup_u8(0);\n\n        for (int bit = 0; bit < 32; ++bit) {\n            svuint32_t mask = svdup_u32(1 << bit);\n            svbool_t bitSet = svcmpeq(svptrue_b32(), svand(vecA, mask), mask);\n            bitCount = svadd_u8_m(bitCount, bitSet, svdup_u8(1));\n        }\n\n        svst1b_u8(pg, &out[i], bitCount);\n        i += svcntw();\n        pg = svwhilelt_b32(i, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t num_elements = rows * cols;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b32(i, num_elements);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec_A = svld1_s32(pg, &A[i]);\n        svbool_t divisible_by_3 = svcmpeq_n_s32(pg, svrem_s32_z(pg, vec_A, 3), 0);\n        svint32_t vec_B = svsel_s32(divisible_by_3, svabs_s32_x(pg, vec_A), vec_A);\n        svst1_s32(pg, &B[i], vec_B);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, num_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t num_elements = rows * cols;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b32(i, num_elements);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec_A = svld1_s32(pg, &A[i]);\n        svbool_t cond = svcmpeq_n_s32(pg, svrem_s32_x(pg, vec_A, 3), 0);\n        svint32_t vec_B = svsel_s32(cond, svabs_s32_x(pg, vec_A), vec_A);\n        svst1_s32(pg, &B[i], vec_B);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, num_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t num_elements = rows * cols;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b32(i, num_elements);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec_A = svld1(pg, &A[i]);\n        svbool_t divisible_by_3 = svcmpeq(pg, svrem(vec_A, 3), 0);\n        svint32_t abs_A = svabs(vec_A);\n        svint32_t result = svsel(divisible_by_3, abs_A, vec_A);\n        svst1(pg, &B[i], result);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, num_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t num_elements = rows * cols;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b32(i, num_elements);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec_A = svld1_s32(pg, &A[i]);\n        svbool_t cond = svcmpeq_n_s32(pg, svrem_s32_x(pg, vec_A, 3), 0);\n        svint32_t vec_B = svsel_s32(cond, svabs_s32_x(pg, vec_A), vec_A);\n        svst1_s32(pg, &B[i], vec_B);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, num_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t size = rows * cols;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b32(i, size);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vecA = svld1(pg, &A[i]);\n        svbool_t cond = svcmpeq_n_s32(pg, svrem_s32_x(pg, vecA, 3), 0);\n        svint32_t absA = svabs_s32_x(pg, vecA);\n        svint32_t result = svsel_s32(cond, absA, vecA);\n        svst1(pg, &B[i], result);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    size_t i = 0;\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t src_vec = svld1(pg, &src[i]);\n        svuint32_t low4_mask = svdup_u32(0xF);\n        svuint32_t low4_bits = svand_u32_z(pg, src_vec, low4_mask);\n        svbool_t cond = svcmpeq_n_u32(pg, low4_bits, 0xF);\n\n        svuint32_t rotated = svror_n_u32_z(pg, src_vec, rotate_bits);\n        svuint32_t negated = svnot_u32_z(pg, src_vec);\n\n        svuint32_t result = svsel_u32(cond, rotated, negated);\n        svst1(pg, &dst[i], result);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    size_t i = 0;\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t src_vec = svld1(pg, &src[i]);\n        svuint32_t low4_mask = svdup_u32(0xF);\n        svuint32_t low4_bits = svand_u32_z(pg, src_vec, low4_mask);\n        svbool_t cond = svcmpeq_n_u32(pg, low4_bits, 0xF);\n\n        svuint32_t rotated = svror_n_u32_z(pg, src_vec, rotate_bits);\n        svuint32_t negated = svnot_u32_z(pg, src_vec);\n\n        svuint32_t result = svsel_u32(cond, rotated, negated);\n        svst1(pg, &dst[i], result);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    size_t i = 0;\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t src_vec = svld1(pg, &src[i]);\n        svuint32_t low4_mask = svdup_u32(0xF);\n        svuint32_t low4_bits = svand_u32_z(pg, src_vec, low4_mask);\n        svbool_t cond = svcmpeq_n_u32(pg, low4_bits, 0xF);\n\n        svuint32_t rotated = svror_n_u32_z(pg, src_vec, rotate_bits);\n        svuint32_t negated = svnot_u32_z(pg, src_vec);\n        svuint32_t result = svsel_u32(cond, rotated, negated);\n\n        svst1(pg, &dst[i], result);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    size_t i = 0;\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t src_vec = svld1(pg, &src[i]);\n        svuint32_t low4_mask = svdup_u32(0xF);\n        svuint32_t low4_bits = svand_u32_z(pg, src_vec, low4_mask);\n        svbool_t cond = svcmpeq_n_u32(pg, low4_bits, 0xF);\n\n        svuint32_t rotated = svror_n_u32_z(pg, src_vec, rotate_bits);\n        svuint32_t negated = svnot_u32_z(pg, src_vec);\n\n        svuint32_t result = svsel_u32(cond, rotated, negated);\n        svst1(pg, &dst[i], result);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    size_t i = 0;\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t src_vec = svld1(pg, &src[i]);\n        svuint32_t low4_mask = svdup_u32(0xF);\n        svuint32_t low4_bits = svand_u32_z(pg, src_vec, low4_mask);\n        svbool_t cond = svcmpeq_n_u32(pg, low4_bits, 0xF);\n\n        svuint32_t rotated = svror_n_u32_z(pg, src_vec, rotate_bits);\n        svuint32_t negated = svnot_u32_z(pg, src_vec);\n\n        svuint32_t result = svsel_u32(cond, rotated, negated);\n        svst1(pg, &dst[i], result);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    svfloat32_t sve_epsilon = svdup_f32(epsilon);\n    svfloat32_t sve_neg_epsilon = svneg_f32_z(svptrue_b32(), sve_epsilon);\n\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t a = svld1_f32(pg, &A[i]);\n        svfloat32_t b = svld1_f32(pg, &B[i]);\n\n        svfloat32_t diff = svsub_f32_z(pg, a, b);\n\n        svbool_t gt_mask = svcmpgt(pg, diff, sve_epsilon);\n        svbool_t lt_mask = svcmplt(pg, diff, sve_neg_epsilon);\n\n        svint8_t result = svdup_s8(0);\n        result = svsel_s8(gt_mask, svdup_s8(1), result);\n        result = svsel_s8(lt_mask, svdup_s8(-1), result);\n\n        svst1_s8(pg, &out[i], result);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    svfloat32_t sve_epsilon = svdup_f32(epsilon);\n    svfloat32_t sve_neg_epsilon = svneg_f32_z(svptrue_b32(), sve_epsilon);\n\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t a_vec = svld1_f32(pg, &A[i]);\n        svfloat32_t b_vec = svld1_f32(pg, &B[i]);\n\n        svfloat32_t diff = svsub_f32_z(pg, a_vec, b_vec);\n\n        svbool_t gt_mask = svcmpgt(pg, diff, sve_epsilon);\n        svbool_t lt_mask = svcmplt(pg, diff, sve_neg_epsilon);\n\n        svint8_t result = svdup_s8(0);\n        result = svsel_s8(gt_mask, svdup_s8(1), result);\n        result = svsel_s8(lt_mask, svdup_s8(-1), result);\n\n        svst1_s8(pg, &out[i], result);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    svfloat32_t sve_epsilon = svdup_f32(epsilon);\n    svfloat32_t sve_neg_epsilon = svneg_f32_z(svptrue_b32(), sve_epsilon);\n\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t a = svld1_f32(pg, &A[i]);\n        svfloat32_t b = svld1_f32(pg, &B[i]);\n\n        svfloat32_t diff = svsub_f32_z(pg, a, b);\n\n        svbool_t gt_mask = svcmpgt(pg, diff, sve_epsilon);\n        svbool_t lt_mask = svcmplt(pg, diff, sve_neg_epsilon);\n\n        svint8_t result = svdup_s8(0);\n        result = svsel_s8(gt_mask, svdup_s8(1), result);\n        result = svsel_s8(lt_mask, svdup_s8(-1), result);\n\n        svst1_s8(pg, &out[i], result);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    svfloat32_t sve_epsilon = svdup_f32(epsilon);\n    svfloat32_t sve_neg_epsilon = svneg_f32_z(svptrue_b32(), sve_epsilon);\n\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t a_vec = svld1_f32(pg, &A[i]);\n        svfloat32_t b_vec = svld1_f32(pg, &B[i]);\n\n        svfloat32_t diff = svsub_f32_z(pg, a_vec, b_vec);\n\n        svbool_t gt_mask = svcmpgt_f32(pg, diff, sve_epsilon);\n        svbool_t lt_mask = svcmplt_f32(pg, diff, sve_neg_epsilon);\n\n        svint8_t result = svdup_s8(0);\n        result = svsel_s8(gt_mask, svdup_s8(1), result);\n        result = svsel_s8(lt_mask, svdup_s8(-1), result);\n\n        svst1_s8(pg, &out[i], result);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    svfloat32_t vec_epsilon = svdup_f32(epsilon);\n    svfloat32_t vec_neg_epsilon = svneg_f32(vec_epsilon);\n\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vec_a = svld1_f32(pg, &A[i]);\n        svfloat32_t vec_b = svld1_f32(pg, &B[i]);\n\n        svfloat32_t vec_diff = svsub_f32(vec_a, vec_b);\n\n        svbool_t mask_gt = svcmpgt(pg, vec_diff, vec_epsilon);\n        svbool_t mask_lt = svcmplt(pg, vec_diff, vec_neg_epsilon);\n\n        svint8_t vec_out = svdup_s8(0);\n        vec_out = svsel_s8(mask_gt, svdup_s8(1), vec_out);\n        vec_out = svsel_s8(mask_lt, svdup_s8(-1), vec_out);\n\n        svst1_s8(pg, &out[i], vec_out);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <limits.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    const float max_float = (float)INT32_MAX;\n    const float min_float = (float)INT32_MIN;\n\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vec_a = svld1_f32(pg, &A[i]);\n        svfloat32_t clamped_a = svmin_f32_z(pg, svmax_f32_z(pg, vec_a, min_float), max_float);\n        svst1_s32(pg, &B[i], svcvt_s32_f32_x(pg, clamped_a));\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vec_a = svld1_f32(pg, &A[i]);\n        svint32_t vec_b = svcvt_s32_f32_x(pg, vec_a);\n        svst1_s32(pg, &B[i], vec_b);\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <limits.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vec_a = svld1_f32(pg, &A[i]);\n        svint32_t vec_b = svcvt_s32_f32_x(pg, vec_a);\n        \n        // Clamp values to INT32_MIN and INT32_MAX\n        vec_b = svmax_s32_x(pg, vec_b, svdup_s32(INT32_MIN));\n        vec_b = svmin_s32_x(pg, vec_b, svdup_s32(INT32_MAX));\n\n        svst1_s32(pg, &B[i], vec_b);\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vec_a = svld1_f32(pg, &A[i]);\n        svint32_t vec_b = svcvt_s32_f32_x(pg, vec_a);\n        svst1_s32(pg, &B[i], vec_b);\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <limits.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    const float max_float = (float)INT32_MAX;\n    const float min_float = (float)INT32_MIN;\n\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vec_a = svld1_f32(pg, &A[i]);\n        svfloat32_t clamped_a = svmin_f32_z(pg, svmax_f32_z(pg, vec_a, min_float), max_float);\n        svst1_s32(pg, &B[i], svcvt_s32_f32_x(pg, clamped_a));\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vecA = svld1_s32(pg, &A[i]);\n        svfloat32_t vecB = svcvt_f32_s32_x(pg, vecA);\n        vecB = svmul_x(pg, vecB, svdup_n_f32(scale));\n        svst1_f32(pg, &B[i], vecB);\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t i = 0;\n    svint32_t vec_scale = svdup_n_s32(scale); // Broadcast scale to a vector\n    do {\n        svbool_t pg = svwhilelt_b32(i, size); // Create predicate for active lanes\n        svint32_t vec_A = svld1_s32(pg, &A[i]); // Load int32_t values from A\n        svfloat32_t vec_float_A = svcvt_f32_s32_x(pg, vec_A); // Convert int32_t to float\n        svfloat32_t vec_scaled = svmul_f32_x(pg, vec_float_A, svcvt_f32_s32_x(pg, vec_scale)); // Scale by factor\n        svst1_f32(pg, &B[i], vec_scaled); // Store results into B\n        i += svcntw(); // Increment index by the number of elements processed\n    } while (i < size);\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t i = 0;\n    svint32_t vec_scale = svdup_n_s32(scale);\n    svbool_t pg;\n\n    for (; i <= size - svcntw(); i += svcntw()) {\n        pg = svwhilelt_b32(i, size);\n        svint32_t vec_a = svld1_s32(pg, &A[i]);\n        svfloat32_t vec_float_a = svcvt_f32_s32_x(pg, vec_a);\n        svfloat32_t vec_scaled = svmul_f32_x(pg, vec_float_a, svcvt_f32_s32_x(pg, vec_scale));\n        svst1_f32(pg, &B[i], vec_scaled);\n    }\n\n    for (; i < size; ++i) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t i = 0;\n    svint32_t vec_scale = svdup_n_s32(scale); // Broadcast scale to a vector\n    svbool_t pg = svwhilelt_b32(i, size);    // Predicate for the active lanes\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec_A = svld1_s32(pg, &A[i]);       // Load int32_t values from A\n        svfloat32_t vec_float_A = svcvt_f32_s32_z(pg, vec_A); // Convert int32_t to float\n        svfloat32_t vec_scaled = svmul_f32_z(pg, vec_float_A, svcvt_f32_s32_z(pg, vec_scale)); // Scale by factor\n        svst1_f32(pg, &B[i], vec_scaled);             // Store results into B\n        i += svcntw();                                // Increment index by vector length\n        pg = svwhilelt_b32(i, size);                  // Update predicate\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t i = 0;\n    svint32_t scale_vec = svdup_n_s32(scale); // Broadcast scale factor to a vector\n    svbool_t pg = svwhilelt_b32(i, size);    // Create predicate for the active lanes\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vecA = svld1_s32(pg, &A[i]);       // Load int32_t values from A\n        svfloat32_t vecB = svcvt_f32_s32(vecA);     // Convert int32_t to float\n        vecB = svmul_f32(vecB, svcvt_f32_s32(scale_vec)); // Scale by the factor\n        svst1_f32(pg, &B[i], vecB);                 // Store results into B\n        i += svcntw();                              // Increment index by vector length\n        pg = svwhilelt_b32(i, size);                // Update predicate\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vecA = svld1_f32(pg, &A[i]);\n        svfloat32_t vecB = svld1_f32(pg, &B[i]);\n\n        // Perform element-wise division\n        svfloat32_t vecDiv = svdiv_f32_z(pg, vecA, vecB);\n\n        // Convert the result to 32-bit integers with rounding\n        svint32_t vecC = svrintn_s32_f32(pg, vecDiv);\n\n        // Store the result into the destination array\n        svst1_s32(pg, &C[i], vecC);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t va = svld1_f32(pg, &A[i]);\n        svfloat32_t vb = svld1_f32(pg, &B[i]);\n\n        // Perform element-wise division\n        svfloat32_t vdiv = svdiv_f32_z(pg, va, vb);\n\n        // Convert the result to 32-bit integers with rounding to nearest\n        svint32_t vresult = svrintn_s32_f32(pg, vdiv);\n\n        // Store the result into the destination array\n        svst1_s32(pg, &C[i], vresult);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t va = svld1_f32(pg, &A[i]);\n        svfloat32_t vb = svld1_f32(pg, &B[i]);\n\n        // Perform element-wise division\n        svfloat32_t vdiv = svdiv_f32_z(pg, va, vb);\n\n        // Convert the result to 32-bit integers with rounding to nearest\n        svint32_t vresult = svrintn_s32_f32(pg, vdiv);\n\n        // Store the result into the destination array\n        svst1_s32(pg, &C[i], vresult);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t va = svld1_f32(pg, &A[i]);\n        svfloat32_t vb = svld1_f32(pg, &B[i]);\n\n        // Perform element-wise division\n        svfloat32_t vdiv = svdiv_f32_z(pg, va, vb);\n\n        // Convert the result to 32-bit integers with rounding\n        svint32_t vresult = svrintn_s32_f32(pg, vdiv);\n\n        // Store the result into the destination array\n        svst1_s32(pg, &C[i], vresult);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t va = svld1_f32(pg, &A[i]);\n        svfloat32_t vb = svld1_f32(pg, &B[i]);\n\n        // Perform element-wise division\n        svfloat32_t vdiv = svdiv_f32_z(pg, va, vb);\n\n        // Round to nearest integer and convert to 32-bit integer\n        svint32_t vresult = svrintn_s32_f32(pg, vdiv);\n\n        // Store the result into the destination array\n        svst1_s32(pg, &C[i], vresult);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, size);\n\n    const float flt_max = FLT_MAX;\n    const float flt_min = -FLT_MAX;\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svfloat64_t vec_a = svld1_f64(pg, &A[i]);\n        svfloat32_t vec_b = svcvt_f32_f64(vec_a);\n\n        svfloat32_t vec_clamped = svmin_f32_z(pg, vec_b, svdup_f32(flt_max));\n        vec_clamped = svmax_f32_z(pg, vec_clamped, svdup_f32(flt_min));\n\n        svst1_f32(pg, &B[i], vec_clamped);\n\n        i += svcntd();\n        pg = svwhilelt_b64(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, size);\n\n    const float flt_max = FLT_MAX;\n    const float flt_min = -FLT_MAX;\n\n    do {\n        svfloat64_t vec_a = svld1_f64(pg, &A[i]);\n        svfloat32_t vec_b = svcvt_f32_f64(pg, vec_a);\n\n        svfloat32_t vec_clamped = svmin_f32_z(pg, vec_b, svdup_f32(flt_max));\n        vec_clamped = svmax_f32_z(pg, vec_clamped, svdup_f32(flt_min));\n\n        svst1_f32(pg, &B[i], vec_clamped);\n\n        i += svcntd();\n        pg = svwhilelt_b64(i, size);\n    } while (svptest_any(svptrue_b64(), pg));\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    const svfloat64_t max_double = svdup_f64((double)FLT_MAX);\n    const svfloat64_t min_double = svdup_f64((double)-FLT_MAX);\n\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, size);\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svfloat64_t vec_a = svld1_f64(pg, &A[i]);\n\n        // Clamp values between -FLT_MAX and FLT_MAX\n        vec_a = svmax_f64_z(pg, vec_a, min_double);\n        vec_a = svmin_f64_z(pg, vec_a, max_double);\n\n        // Convert double to float\n        svfloat32_t vec_b = svcvt_f32_f64(vec_a);\n\n        // Store the result into the destination array\n        svst1_f32(pg, &B[i], vec_b);\n\n        i += svcntd();\n        pg = svwhilelt_b64(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, size);\n\n    const float flt_max = FLT_MAX;\n    const float flt_min = -FLT_MAX;\n\n    do {\n        svfloat64_t vec_a = svld1_f64(pg, &A[i]);\n        svfloat32_t vec_b = svcvt_f32_f64(pg, vec_a);\n\n        svfloat32_t vec_clamped = svmax_f32_z(pg, vec_b, svdup_f32(flt_min));\n        vec_clamped = svmin_f32_z(pg, vec_clamped, svdup_f32(flt_max));\n\n        svst1_f32(pg, &B[i], vec_clamped);\n\n        i += svcntd();\n        pg = svwhilelt_b64(i, size);\n    } while (svptest_any(svptrue_b64(), pg));\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, size);\n\n    const float flt_max = FLT_MAX;\n    const float flt_min = -FLT_MAX;\n\n    do {\n        svfloat64_t vec_a = svld1_f64(pg, &A[i]);\n        svfloat32_t vec_b = svcvt_f32_f64(pg, vec_a);\n\n        svfloat32_t vec_clamped = svmin_f32_z(pg, vec_b, svdup_f32(flt_max));\n        vec_clamped = svmax_f32_z(pg, vec_clamped, svdup_f32(flt_min));\n\n        svst1_f32(pg, &B[i], vec_clamped);\n\n        i += svcntd();\n        pg = svwhilelt_b64(i, size);\n    } while (svptest_any(svptrue_b64(), pg));\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b16(i, size);\n\n    while (svptest_any(svptrue_b16(), pg)) {\n        svint16_t vecA = svld1_s16(pg, &A[i]);\n        svint32_t vecB = svcvt_s32_s16(vecA);\n        svst1_s32(pg, &B[i], vecB);\n        i += svcntw();\n        pg = svwhilelt_b16(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b16(i, size);\n\n    while (svptest_any(svptrue_b16(), pg)) {\n        svint16_t vecA = svld1_s16(pg, &A[i]);\n        svint32_t vecB = svcvt_s32_s16_x(pg, vecA);\n        svst1_s32(pg, &B[i], vecB);\n        i += svcntw();\n        pg = svwhilelt_b16(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b16(i, size);\n\n    while (svptest_any(svptrue_b16(), pg)) {\n        svint16_t vecA = svld1_s16(pg, &A[i]);\n        svint32_t vecB = svcvt_s32_s16_x(pg, vecA);\n        svst1_s32(pg, &B[i], vecB);\n        i += svcntw();\n        pg = svwhilelt_b16(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b16(i, size);\n\n    while (svptest_any(svptrue_b16(), pg)) {\n        svint16_t vec_a = svld1_s16(pg, &A[i]);\n        svint32_t vec_b = svcvt_s32_s16_x(pg, vec_a);\n        svst1_s32(pg, &B[i], vec_b);\n        i += svcntw();\n        pg = svwhilelt_b16(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b16(i, size);\n\n    while (svptest_any(svptrue_b16(), pg)) {\n        svint16_t vec_a = svld1_s16(pg, &A[i]);\n        svint32_t vec_b = svcvt_s32_s16(vec_a);\n        svst1_s32(pg, &B[i], vec_b);\n        i += svcntw();\n        pg = svwhilelt_b16(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    svfloat32_t sve_min_val = svdup_f32(min_val);\n    svfloat32_t sve_max_val = svdup_f32(max_val);\n    svfloat32_t sve_zero = svdup_f32(0.0f);\n    svfloat32_t sve_one = svdup_f32(1.0f);\n    svfloat32_t range = svsub_f32(sve_max_val, sve_min_val);\n\n    size_t i = 0;\n    while (i < size) {\n        svbool_t pg = svwhilelt_b32(i, size);\n\n        svfloat32_t a_vec = svld1_f32(pg, &A[i]);\n        svint32_t control_vec = svld1_s32(pg, &control[i]);\n\n        svbool_t control_gt_zero = svcmpgt_n_s32(pg, control_vec, 0);\n\n        svfloat32_t normalized = svdiv_f32_z(pg, svsub_f32_z(pg, a_vec, sve_min_val), range);\n        normalized = svmax_f32_z(pg, normalized, sve_zero);\n        normalized = svmin_f32_z(pg, normalized, sve_one);\n\n        svfloat32_t result = svsel_f32(control_gt_zero, normalized, a_vec);\n\n        svst1_f32(pg, &B[i], result);\n\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    svfloat32_t sve_min_val = svdup_f32(min_val);\n    svfloat32_t sve_max_val = svdup_f32(max_val);\n    svfloat32_t sve_zero = svdup_f32(0.0f);\n    svfloat32_t sve_one = svdup_f32(1.0f);\n    svfloat32_t range = svsub_f32(sve_max_val, sve_min_val);\n\n    size_t i = 0;\n    while (i < size) {\n        svbool_t pg = svwhilelt_b32(i, size);\n\n        svfloat32_t a_vec = svld1_f32(pg, &A[i]);\n        svint32_t control_vec = svld1_s32(pg, &control[i]);\n\n        svbool_t control_gt_zero = svcmpgt_n_s32(pg, control_vec, 0);\n\n        svfloat32_t normalized = svdiv_f32_z(pg, svsub_f32_z(pg, a_vec, sve_min_val), range);\n        normalized = svmax_f32_z(pg, normalized, sve_zero);\n        normalized = svmin_f32_z(pg, normalized, sve_one);\n\n        svfloat32_t result = svsel_f32(control_gt_zero, normalized, a_vec);\n\n        svst1_f32(pg, &B[i], result);\n\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    svfloat32_t sve_min_val = svdup_f32(min_val);\n    svfloat32_t sve_max_val = svdup_f32(max_val);\n    svfloat32_t sve_zero = svdup_f32(0.0f);\n    svfloat32_t sve_one = svdup_f32(1.0f);\n    svfloat32_t range = svsub_f32(sve_max_val, sve_min_val);\n\n    size_t i = 0;\n    while (i < size) {\n        svbool_t pg = svwhilelt_b32(i, size);\n\n        svfloat32_t a_vec = svld1_f32(pg, &A[i]);\n        svint32_t control_vec = svld1_s32(pg, &control[i]);\n\n        svbool_t control_gt_zero = svcmpgt_n_s32(pg, control_vec, 0);\n\n        svfloat32_t normalized = svdiv_f32_z(pg, svsub_f32_z(pg, a_vec, sve_min_val), range);\n        normalized = svmax_f32_z(pg, normalized, sve_zero);\n        normalized = svmin_f32_z(pg, normalized, sve_one);\n\n        svfloat32_t result = svsel_f32(control_gt_zero, normalized, a_vec);\n\n        svst1_f32(pg, &B[i], result);\n\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    svfloat32_t sve_min_val = svdup_f32(min_val);\n    svfloat32_t sve_max_val = svdup_f32(max_val);\n    svfloat32_t sve_zero = svdup_f32(0.0f);\n    svfloat32_t sve_one = svdup_f32(1.0f);\n    svfloat32_t sve_range = svsub_f32(sve_max_val, sve_min_val);\n\n    size_t i = 0;\n    while (i < size) {\n        svbool_t pg = svwhilelt_b32(i, size);\n\n        svfloat32_t sve_A = svld1_f32(pg, &A[i]);\n        svint32_t sve_control = svld1_s32(pg, &control[i]);\n\n        svbool_t positive_mask = svcmpgt_n_s32(pg, sve_control, 0);\n\n        svfloat32_t normalized = svdiv_f32_z(pg, svsub_f32_z(pg, sve_A, sve_min_val), sve_range);\n        normalized = svmax_f32_z(pg, normalized, sve_zero);\n        normalized = svmin_f32_z(pg, normalized, sve_one);\n\n        svfloat32_t result = svsel_f32(positive_mask, normalized, sve_A);\n\n        svst1_f32(pg, &B[i], result);\n\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    svfloat32_t sve_min_val = svdup_f32(min_val);\n    svfloat32_t sve_max_val = svdup_f32(max_val);\n    svfloat32_t sve_zero = svdup_f32(0.0f);\n    svfloat32_t sve_one = svdup_f32(1.0f);\n    svfloat32_t range = svsub_f32(sve_max_val, sve_min_val);\n\n    size_t i = 0;\n    while (i < size) {\n        svbool_t pg = svwhilelt_b32(i, size);\n\n        svfloat32_t a_vec = svld1_f32(pg, &A[i]);\n        svint32_t control_vec = svld1_s32(pg, &control[i]);\n\n        svbool_t control_gt_zero = svcmpgt_n_s32(pg, control_vec, 0);\n\n        svfloat32_t normalized = svdiv_f32_z(pg, svsub_f32_z(pg, a_vec, sve_min_val), range);\n        normalized = svmax_f32_z(pg, normalized, sve_zero);\n        normalized = svmin_f32_z(pg, normalized, sve_one);\n\n        svfloat32_t result = svsel_f32(control_gt_zero, normalized, a_vec);\n\n        svst1_f32(pg, &B[i], result);\n\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load a vector of uint32_t values from A\n        svuint32_t vecA = svld1(pg, &A[i]);\n\n        // Shift right by 16 to extract the high 16 bits\n        svuint32_t high16 = svlsr_n_u32_z(pg, vecA, 16);\n\n        // Convert the high 16 bits to float\n        svfloat32_t floatVec = svcvt_f32_u32_x(pg, high16);\n\n        // Compute the square root of the float values\n        svfloat32_t sqrtVec = svsqrt_f32_x(pg, floatVec);\n\n        // Store the result into B\n        svst1(pg, &B[i], sqrtVec);\n\n        // Update the index and predicate\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load a vector of uint32_t values from A\n        svuint32_t vecA = svld1_u32(pg, &A[i]);\n\n        // Shift right by 16 to extract the high 16 bits\n        svuint32_t high16 = svlsr_n_u32_z(pg, vecA, 16);\n\n        // Convert the high 16 bits to float\n        svfloat32_t floatVec = svcvt_f32_u32_x(pg, high16);\n\n        // Compute the square root of the float values\n        svfloat32_t sqrtVec = svsqrt_f32_x(pg, floatVec);\n\n        // Store the result into B\n        svst1_f32(pg, &B[i], sqrtVec);\n\n        // Update the index and predicate\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load a vector of uint32_t values from A\n        svuint32_t vecA = svld1(pg, &A[i]);\n\n        // Shift right by 16 bits to extract the high 16 bits\n        svuint32_t high16 = svlsr_n_u32_z(pg, vecA, 16);\n\n        // Convert the high 16 bits to float\n        svfloat32_t floatVec = svcvt_f32_u32_x(pg, high16);\n\n        // Compute the square root of the float values\n        svfloat32_t sqrtVec = svsqrt_f32_x(pg, floatVec);\n\n        // Store the result into B\n        svst1(pg, &B[i], sqrtVec);\n\n        // Update the index and predicate\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load a vector of uint32_t values from A\n        svuint32_t vecA = svld1(pg, &A[i]);\n\n        // Shift right by 16 to extract the high 16 bits\n        svuint32_t highBits = svlsr_n_u32_z(pg, vecA, 16);\n\n        // Convert the high 16 bits to float\n        svfloat32_t floatVec = svcvt_f32_u32_x(pg, highBits);\n\n        // Compute the square root of the float values\n        svfloat32_t sqrtVec = svsqrt_f32_x(pg, floatVec);\n\n        // Store the result into B\n        svst1(pg, &B[i], sqrtVec);\n\n        // Update the index and predicate for the next iteration\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load a vector of uint32_t values from A\n        svuint32_t vecA = svld1(pg, &A[i]);\n\n        // Shift right by 16 bits to extract the high 16 bits\n        svuint32_t high16 = svlsr_n_u32_z(pg, vecA, 16);\n\n        // Convert the high 16 bits to float\n        svfloat32_t floatVec = svcvt_f32_u32_x(pg, high16);\n\n        // Compute the square root of the float values\n        svfloat32_t sqrtVec = svsqrt_f32_x(pg, floatVec);\n\n        // Store the result into B\n        svst1(pg, &B[i], sqrtVec);\n\n        // Update the index and predicate\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t vec_uint = svld1_u32(pg, &A[i]);\n        svfloat32_t vec_float = svreinterpret_f32_u32(vec_uint);\n        svst1_f32(pg, &B[i], vec_float);\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t vecA = svld1_u32(pg, &A[i]);\n        svfloat32_t vecB = svreinterpret_f32_u32(vecA);\n        svst1_f32(pg, &B[i], vecB);\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t vec_uint = svld1_u32(pg, &A[i]);\n        svfloat32_t vec_float = svreinterpret_f32_u32(vec_uint);\n        svst1_f32(pg, &B[i], vec_float);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t vecA = svld1(pg, &A[i]);\n        svfloat32_t vecB = svreinterpret_f32_u32(vecA);\n        svst1(pg, &B[i], vecB);\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t vecA = svld1_u32(pg, &A[i]);\n        svfloat32_t vecB = svreinterpret_f32_u32(vecA);\n        svst1_f32(pg, &B[i], vecB);\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    svbool_t pg = svwhilelt_b32(0, size); // Predicate for the active lanes\n    svfloat32_t zero_vec = svdup_f32(0.0f); // Vector of 0.0f values\n\n    // Set the first element of diff to 0.0f\n    if (size > 0) {\n        diff[0] = 0.0f;\n    }\n\n    for (size_t i = 1; i < size; i += svcntw()) {\n        pg = svwhilelt_b32(i, size); // Update predicate for remaining elements\n\n        // Load values from A and cond arrays\n        svint32_t a_curr = svld1_s32(pg, &A[i]);\n        svint32_t a_prev = svld1_s32(pg, &A[i - 1]);\n        svbool_t cond_vec = svld1_b32(pg, &cond[i]);\n\n        // Compute the difference between consecutive elements\n        svint32_t diff_int = svsub_s32_x(pg, a_curr, a_prev);\n\n        // Convert the difference to float\n        svfloat32_t diff_float = svcvt_f32_s32_x(pg, diff_int);\n\n        // Selectively store the result based on the condition\n        svfloat32_t result = svsel_f32(cond_vec, diff_float, zero_vec);\n        svst1_f32(pg, &diff[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    svbool_t pg = svwhilelt_b32(0, size); // Predicate for the active lanes\n    svint32_t va_prev = svld1_s32(pg, A); // Load the first element of A\n    svfloat32_t vdiff = svdup_f32(0.0f);  // Initialize diff vector with 0.0f\n\n    // Set the first element of diff to 0.0f\n    if (size > 0) {\n        diff[0] = 0.0f;\n    }\n\n    // Process elements from index 1 to size-1\n    for (size_t i = 1; i < size; i += svcntw()) {\n        pg = svwhilelt_b32(i, size); // Update predicate for remaining elements\n\n        svint32_t va_curr = svld1_s32(pg, &A[i]);       // Load current A[i]\n        svint32_t va_prev_shifted = svext_s32(va_prev, va_curr, svcntw() - 1); // Shift to get A[i-1]\n        svint32_t vdelta = svsub_s32(va_curr, va_prev_shifted); // Compute difference A[i] - A[i-1]\n\n        svbool_t vcond = svld1_b32(pg, &cond[i]);       // Load condition array\n        svfloat32_t vdelta_f = svcvt_f32_s32(pg, vdelta); // Convert difference to float\n\n        vdiff = svsel_f32(vcond, vdelta_f, svdup_f32(0.0f)); // Select based on condition\n        svst1_f32(pg, &diff[i], vdiff);                 // Store results in diff\n\n        va_prev = va_curr; // Update previous vector for next iteration\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    svbool_t pg = svwhilelt_b32(0, size); // Predicate for the active lanes\n    svfloat32_t zero_vec = svdup_f32(0.0f); // Vector of 0.0f values\n\n    // Set the first element of diff to 0.0f\n    if (size > 0) {\n        diff[0] = 0.0f;\n    }\n\n    for (size_t i = 1; i < size; i += svcntw()) {\n        pg = svwhilelt_b32(i, size); // Update predicate for remaining elements\n\n        // Load A[i] and A[i-1]\n        svint32_t a_curr = svld1_s32(pg, &A[i]);\n        svint32_t a_prev = svld1_s32(pg, &A[i - 1]);\n\n        // Compute the difference A[i] - A[i-1]\n        svint32_t diff_int = svsub_s32_x(pg, a_curr, a_prev);\n\n        // Convert the difference to float\n        svfloat32_t diff_float = svcvt_f32_s32_x(pg, diff_int);\n\n        // Load the condition array\n        svbool_t cond_mask = svld1_b32(pg, &cond[i]);\n\n        // Apply the condition: set diff[i] to 0.0f where cond[i] is false\n        diff_float = svsel_f32(cond_mask, diff_float, zero_vec);\n\n        // Store the result in the diff array\n        svst1_f32(pg, &diff[i], diff_float);\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    svbool_t pg = svwhilelt_b32(0, size); // Predicate for the active lanes\n    svint32_t va_prev = svld1_s32(pg, A); // Load the first element of A\n    svfloat32_t vdiff = svdup_f32(0.0f);  // Initialize diff vector to 0.0f\n    diff[0] = 0.0f;                       // Explicitly set the first element of diff to 0.0f\n\n    for (size_t i = 1; i < size; i += svcntw()) {\n        pg = svwhilelt_b32(i, size); // Update predicate for remaining elements\n        svint32_t va_curr = svld1_s32(pg, &A[i]); // Load current A[i]\n        svint32_t va_prev_loaded = svld1_s32(pg, &A[i - 1]); // Load previous A[i-1]\n        svint32_t vdelta = svsub_s32(va_curr, va_prev_loaded); // Compute difference\n\n        svbool_t vcond = svld1_b32(pg, &cond[i]); // Load condition array\n        svfloat32_t vdelta_f = svcvt_f32_s32_x(pg, vdelta); // Convert difference to float\n        vdiff = svsel_f32(vcond, vdelta_f, svdup_f32(0.0f)); // Select based on condition\n\n        svst1_f32(pg, &diff[i], vdiff); // Store results into diff array\n        va_prev = va_curr; // Update previous value for next iteration\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    svbool_t pg = svwhilelt_b32(0, size); // Predicate for the active lanes\n    svfloat32_t zero_vec = svdup_f32(0.0f); // Vector of 0.0f values\n\n    // Set the first element of diff to 0.0f\n    if (size > 0) {\n        diff[0] = 0.0f;\n    }\n\n    for (size_t i = 1; i < size; i += svcntw()) {\n        pg = svwhilelt_b32(i, size); // Update predicate for remaining elements\n\n        // Load values from A and cond arrays\n        svint32_t a_curr = svld1_s32(pg, &A[i]);\n        svint32_t a_prev = svld1_s32(pg, &A[i - 1]);\n        svbool_t cond_vec = svld1sb_b32(pg, &cond[i]);\n\n        // Compute the difference between consecutive elements\n        svint32_t diff_int = svsub_s32_x(pg, a_curr, a_prev);\n\n        // Convert the difference to float\n        svfloat32_t diff_float = svcvt_f32_s32_x(pg, diff_int);\n\n        // Selectively store the result based on the condition\n        svfloat32_t result = svsel_f32(cond_vec, diff_float, zero_vec);\n        svst1_f32(pg, &diff[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t src_vec = svld1_u32(pg, &src[i]);\n        svuint64_t dst_vec = svunpklo_u32(src_vec);\n        dst_vec = svorr_u64(dst_vec, svdup_u64(0xFFFFFFFF00000000));\n        svst1_u64(pg, &dst[i], dst_vec);\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t src_vec = svld1_u32(pg, &src[i]);\n        svuint64_t dst_vec = svunpklo_u32(src_vec);\n        dst_vec = svorr_u64(dst_vec, svdup_u64(0xFFFFFFFF00000000));\n        svst1_u64(pg, &dst[i], dst_vec);\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t src_vec = svld1_u32(pg, &src[i]);\n        svuint64_t dst_vec = svunpklo_u32(src_vec);\n        dst_vec = svorr_u64(dst_vec, svdup_u64(0xFFFFFFFF00000000));\n        svst1_u64(pg, &dst[i], dst_vec);\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t src_vec = svld1_u32(pg, &src[i]);\n        svuint64_t dst_vec = svmovlb_u64(src_vec);\n        dst_vec = svorr_u64(dst_vec, svdup_u64(0xFFFFFFFF00000000));\n        svst1_u64(pg, &dst[i], dst_vec);\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t src_vec = svld1_u32(pg, &src[i]);\n        svuint64_t dst_vec = svunpklo_u32(src_vec);\n        dst_vec = svorr_u64(dst_vec, svdup_u64(0xFFFFFFFF00000000));\n        svst1_u64(pg, &dst[i], dst_vec);\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    svbool_t pg = svwhilelt_b16(0, length); // Predicate for the active lanes\n    double sum = 0.0;\n\n    while (svptest_any(svptrue_b16(), pg)) {\n        svint16_t idx_vec = svld1_s16(pg, index); // Load indices\n        svuint16_t uidx_vec = svreinterpret_u16_s16(idx_vec); // Convert to unsigned for indexing\n        svfloat64_t val_vec = svld1_gather_index_f64(pg, vec, uidx_vec); // Gather values from vec\n\n        double temp_sum = svaddv_f64(pg, val_vec); // Horizontal sum of active lanes\n        sum += temp_sum;\n\n        index += svcntw(); // Move to the next chunk of indices\n        length -= svcntw(); // Reduce remaining length\n        pg = svwhilelt_b16(0, length); // Update predicate\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c\n#include <arm_sve.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    svbool_t pg = svwhilelt_b16(0, length); // Predicate for active lanes\n    double sum = 0.0;\n\n    while (svptest_any(svptrue_b16(), pg)) {\n        svint16_t idx_vec = svld1_s16(pg, index); // Load indices\n        svuint16_t uidx_vec = svcvt_u16_s16(pg, idx_vec); // Convert to unsigned for indexing\n        svfloat64_t val_vec = svld1_gather_index_f64(pg, vec, uidx_vec); // Gather values from vec\n\n        double temp_sum = svaddv_f64(pg, val_vec); // Horizontal sum of active lanes\n        sum += temp_sum;\n\n        index += svcntw(); // Move to next chunk of indices\n        length -= svcntw(); // Reduce remaining length\n        pg = svwhilelt_b16(0, length); // Update predicate\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    svbool_t pg = svwhilelt_b16(0, length); // Predicate for active lanes\n    double sum = 0.0;\n\n    while (svptest_any(svptrue_b16(), pg)) {\n        svint16_t idx_vec = svld1(pg, index); // Load indices\n        svuint16_t uidx_vec = svcvt_u16_s16(idx_vec); // Convert to unsigned for indexing\n        svfloat64_t val_vec = svld1_gather_index(pg, vec, uidx_vec); // Gather values from vec\n\n        double temp_sum = svaddv(pg, val_vec); // Horizontal sum of active lanes\n        sum += temp_sum;\n\n        index += svcntw(); // Move to the next chunk\n        length -= svcntw();\n        pg = svwhilelt_b16(0, length); // Update predicate\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c\n#include <arm_sve.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    svbool_t pg = svwhilelt_b16(0, length); // Predicate for the active lanes\n    double sum = 0.0;\n\n    while (svptest_any(svptrue_b16(), pg)) {\n        svint16_t idx_vec = svld1(pg, index); // Load indices\n        svuint16_t uidx_vec = svcvt_u16_s16(pg, idx_vec); // Convert to unsigned for indexing\n        svfloat64_t val_vec = svld1_gather_index(pg, vec, uidx_vec); // Gather values from vec\n\n        // Horizontally add the active elements of val_vec\n        svfloat64_t sum_vec = svaddv(pg, val_vec);\n        sum += svlasta(pg, sum_vec); // Accumulate into scalar sum\n\n        // Update pointers and predicate\n        index += svcntw();\n        length -= svcntw();\n        pg = svwhilelt_b16(0, length);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    svbool_t pg = svwhilelt_b16(0, length); // Predicate for the active lanes\n    double sum = 0.0;\n\n    svfloat64_t sve_sum = svdup_f64(0.0); // Initialize vector accumulator\n\n    size_t i = 0;\n    while (svptest_any(svptrue_b64(), pg)) {\n        svint16_t sve_index = svld1_s16(pg, &index[i]); // Load indices\n        svint64_t sve_index_wide = svunpklo_s16(sve_index); // Zero-extend to 64-bit\n        svuint64_t sve_index_uwide = svcvt_u64_s64_z(pg, sve_index_wide); // Convert to unsigned\n\n        svfloat64_t sve_values = svtbl_f64(svdup_f64(0.0), sve_index_uwide); // Gather values from vec\n        sve_sum = svadd_f64_m(pg, sve_sum, sve_values); // Accumulate valid values\n\n        i += svcntw(); // Move to the next chunk\n        pg = svwhilelt_b16(i, length); // Update predicate\n    }\n\n    // Horizontal reduction of the vector sum\n    sum = svaddv_f64(svptrue_b64(), sve_sum);\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    size_t kernel_elements = kernel_size * kernel_size;\n\n    // Load the entire kernel into a vector register if it fits\n    svbool_t kernel_pred = svwhilelt_b64(0, kernel_elements);\n    svfloat64_t kernel_vec = svld1_f64(kernel_pred, kernel);\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n\n            // Perform convolution for the current output position\n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    size_t input_idx = (i + ki) * input_size + (j + kj);\n                    size_t kernel_idx = ki * kernel_size + kj;\n\n                    // Use SVE to load and multiply elements\n                    svbool_t pred = svwhilelt_b64(0, kernel_elements);\n                    svfloat64_t input_vec = svld1_f64(pred, &input[input_idx]);\n                    svfloat64_t mul_vec = svmul_f64_x(pred, input_vec, kernel_vec);\n\n                    // Reduce the vector to a scalar sum\n                    svfloat64_t sum_vec = svdup_f64(0.0);\n                    sum_vec = svadda_f64(sum_vec, mul_vec);\n                    sum += svlasta_f64(sum_vec);\n                }\n            }\n\n            // Apply ReLU activation\n            output[i * output_size + j] = (sum > 0.0) ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    size_t kernel_elements = kernel_size * kernel_size;\n\n    // Load the entire kernel into a vector register if it fits\n    svbool_t kernel_pred = svwhilelt_b64(0, kernel_elements);\n    svfloat64_t kernel_vec = svld1_f64(kernel_pred, kernel);\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n\n            // Perform convolution for the current output position\n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    size_t input_idx = (i + ki) * input_size + (j + kj);\n                    size_t kernel_idx = ki * kernel_size + kj;\n\n                    // Load input and kernel elements\n                    svbool_t pred = svwhilelt_b64(0, kernel_elements);\n                    svfloat64_t input_vec = svld1_f64(pred, &input[input_idx]);\n                    svfloat64_t kernel_vec = svld1_f64(pred, &kernel[kernel_idx]);\n\n                    // Multiply and accumulate\n                    svfloat64_t prod = svmul_f64_x(pred, input_vec, kernel_vec);\n                    sum += svaddv_f64(pred, prod);\n                }\n            }\n\n            // Apply ReLU activation\n            output[i * output_size + j] = (sum > 0.0) ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    size_t kernel_elements = kernel_size * kernel_size;\n\n    // Load the entire kernel into a vector register if it fits\n    svbool_t kernel_pred = svwhilelt_b64(0, kernel_elements);\n    svfloat64_t kernel_vec = svld1_f64(kernel_pred, kernel);\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n\n            // Perform convolution for the current output position\n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    size_t input_idx = (i + ki) * input_size + (j + kj);\n                    size_t kernel_idx = ki * kernel_size + kj;\n\n                    // Load input and kernel elements\n                    svbool_t pred = svwhilelt_b64(0, kernel_elements);\n                    svfloat64_t input_vec = svld1_f64(pred, &input[input_idx]);\n                    svfloat64_t kernel_vec = svld1_f64(pred, &kernel[kernel_idx]);\n\n                    // Multiply and accumulate\n                    svfloat64_t prod = svmul_f64_x(pred, input_vec, kernel_vec);\n                    sum += svaddv_f64(pred, prod);\n                }\n            }\n\n            // Apply ReLU activation\n            output[i * output_size + j] = (sum > 0.0) ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    size_t kernel_elements = kernel_size * kernel_size;\n\n    // Load the entire kernel into SVE registers if it fits\n    svfloat64_t kernel_vec[kernel_elements];\n    for (size_t i = 0; i < kernel_elements; ++i) {\n        kernel_vec[i] = svdup_f64(kernel[i]);\n    }\n\n    for (size_t out_y = 0; out_y < output_size; ++out_y) {\n        for (size_t out_x = 0; out_x < output_size; ++out_x) {\n            svfloat64_t sum_vec = svdup_f64(0.0);\n\n            for (size_t k_y = 0; k_y < kernel_size; ++k_y) {\n                for (size_t k_x = 0; k_x < kernel_size; ++k_x) {\n                    size_t input_idx = (out_y + k_y) * input_size + (out_x + k_x);\n                    size_t kernel_idx = k_y * kernel_size + k_x;\n\n                    svfloat64_t input_val = svld1_f64(svptrue_b64(), &input[input_idx]);\n                    svfloat64_t kernel_val = kernel_vec[kernel_idx];\n\n                    sum_vec = svmla_f64(sum_vec, input_val, kernel_val);\n                }\n            }\n\n            // Horizontal reduction to get the final sum\n            double result = 0.0;\n            svbool_t pg = svptrue_b64();\n            result = svaddv_f64(pg, sum_vec);\n\n            // Apply ReLU activation\n            if (result < 0.0) {\n                result = 0.0;\n            }\n\n            // Store the result in the output array\n            output[out_y * output_size + out_x] = result;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    size_t kernel_elements = kernel_size * kernel_size;\n\n    // Load the entire kernel into a vector register if it fits\n    svbool_t kernel_pred = svwhilelt_b64(0, kernel_elements);\n    svfloat64_t kernel_vec = svld1_f64(kernel_pred, kernel);\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n\n            // Perform convolution for the current output position\n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    size_t input_idx = (i + ki) * input_size + (j + kj);\n                    size_t kernel_idx = ki * kernel_size + kj;\n\n                    // Load input and kernel elements\n                    svbool_t pred = svwhilelt_b64(0, kernel_elements);\n                    svfloat64_t input_vec = svld1_f64(pred, &input[input_idx]);\n                    svfloat64_t kernel_vec = svld1_f64(pred, &kernel[kernel_idx]);\n\n                    // Multiply and accumulate\n                    svfloat64_t prod = svmul_f64_x(pred, input_vec, kernel_vec);\n                    sum += svaddv_f64(pred, prod);\n                }\n            }\n\n            // Apply ReLU activation\n            output[i * output_size + j] = (sum > 0.0) ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t size = numbers.size();\n    svbool_t pg =svptrue_b64();\n\n    for (size_t i = 0; i < size; ++i) {\n        const double* base_ptr = numbers.data() + i + 1;\n        size_t remaining = size - i - 1;\n\n        svfloat64_t vec_a = svdup_f64(numbers[i]);\n        svfloat64_t vec_threshold = svdup_f64(threshold);\n\n        for (size_t j = 0; j < remaining; j += svcntd()) {\n            svbool_t active_lanes = svwhilelt_b64(j, remaining);\n            svfloat64_t vec_b = svld1_f64(active_lanes, base_ptr + j);\n\n            svfloat64_t diff = svsub_f64(vec_a, vec_b);\n            svfloat64_t abs_diff = svabs_f64(diff);\n\n            svbool_t close_elements = svcmplt_f64(abs_diff, vec_threshold);\n            if (svptest_any(svptrue_b64(), close_elements)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t size = numbers.size();\n    svbool_t pg = svwhilelt_b64(0, size); // Predicate for active lanes\n\n    svfloat64_t vec_threshold = svdup_f64(threshold);\n    svint64_t indices = svindex_s64(0, 1);\n\n    for (size_t i = 0; i < size; ++i) {\n        svfloat64_t vec_a = svld1_f64(pg, &numbers[i]);\n        svint64_t vec_indices = svadd_s64_z(pg, indices, i);\n\n        svbool_t mask = svwhilelt_b64(i + 1, size);\n        svfloat64_t vec_b = svld1_gather_index_f64(mask, &numbers[0], vec_indices);\n\n        svfloat64_t diff = svsub_f64_x(pg, vec_a, vec_b);\n        svfloat64_t abs_diff = svabs_f64_x(pg, diff);\n\n        svbool_t close = svcmplt_f64(pg, abs_diff, vec_threshold);\n        if (svptest_any(svptrue_b64(), close)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool has_close_elements_simd(const std::vector<double> &numbers, double threshold) {\n    size_t size = numbers.size();\n    svbool_t pg = svwhilelt_b64(0, size); // Predicate for active lanes\n\n    const double *data = numbers.data();\n    bool result = false;\n\n    for (size_t i = 0; i < size; ++i) {\n        svfloat64_t vec1 = svdup_f64(data[i]); // Broadcast current element\n        const double *ptr = data + i + 1;\n        size_t j = i + 1;\n\n        while (j < size) {\n            svfloat64_t vec2 = svld1_f64(pg, ptr); // Load vector of elements\n            svfloat64_t diff = svsub_f64(vec1, vec2); // Compute difference\n            svfloat64_t abs_diff = svabs_f64(diff); // Absolute value of difference\n            svbool_t cmp = svcmplt_f64(pg, abs_diff, threshold); // Compare with threshold\n\n            if (svptest_any(svptrue_b64(), cmp)) {\n                return true; // Early exit if any close pair found\n            }\n\n            ptr += svcntd(); // Move pointer to next block\n            j += svcntd();   // Increment index\n            pg = svwhilelt_b64(j, size); // Update predicate\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool has_close_elements_simd(const std::vector<double> &numbers, double threshold) {\n    size_t size = numbers.size();\n    svbool_t pg = svwhilelt_b64(0, size); // Predicate for active elements\n\n    bool result = false;\n    for (size_t i = 0; i < size; ++i) {\n        svfloat64_t vec1 = svdup_f64(numbers[i]); // Broadcast current number\n        const double* ptr = numbers.data();\n        size_t j = 0;\n\n        while (j < size) {\n            svfloat64_t vec2 = svld1(pg, ptr + j); // Load vector of numbers\n            svfloat64_t diff = svsub_f64(vec1, vec2); // Compute difference\n            svfloat64_t abs_diff = svabs_f64(diff); // Absolute value of difference\n            svbool_t cmp = svcmplt_f64(pg, abs_diff, threshold); // Compare with threshold\n\n            if (svptest_any(svptrue_b64(), cmp)) {\n                result = true;\n                break;\n            }\n            j += svcntd(); // Move to next chunk\n        }\n\n        if (result) {\n            break;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool has_close_elements_simd(const std::vector<double> &numbers, double threshold) {\n    size_t size = numbers.size();\n    svbool_t pg = svwhilelt_b64(0, size); // Predicate for active elements\n\n    bool result = false;\n    for (size_t i = 0; i < size; ++i) {\n        svfloat64_t vec1 = svdup_f64(numbers[i]); // Broadcast current number\n        const double* ptr = numbers.data();\n        size_t j = 0;\n\n        while (j < size) {\n            svfloat64_t vec2 = svld1(pg, ptr + j); // Load vector of numbers\n            svfloat64_t diff = svsub_f64(vec1, vec2); // Compute difference\n            svfloat64_t abs_diff = svabs_f64(diff); // Absolute value of difference\n            svbool_t cmp = svcmplt_f64(pg, abs_diff, threshold); // Compare with threshold\n\n            if (svptest_any(svptrue_b64(), cmp)) {\n                result = true;\n                break;\n            }\n            j += svcntd(); // Move to next chunk\n        }\n        if (result) break;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool below_zero_simd(std::vector<int> operations) {\n    svint32_t v_balance = svdup_n_s32(0); // Initialize vector balance to zero\n    size_t i = 0;\n    size_t n = operations.size();\n    bool below_zero = false;\n\n    while (i + svcntw() <= n) {\n        svint32_t v_ops = svld1_s32(svptrue_b32(), &operations[i]);\n        v_balance = svadd_s32_z(svptrue_b32(), v_balance, v_ops);\n        svbool_t neg_mask = svcmplt_s32(svptrue_b32(), v_balance, 0);\n        if (svptest_any(svptrue_b32(), neg_mask)) {\n            below_zero = true;\n            break;\n        }\n        i += svcntw();\n    }\n\n    int balance = 0;\n    for (size_t j = 0; j < i; ++j) {\n        balance += operations[j];\n    }\n\n    for (; i < n; ++i) {\n        balance += operations[i];\n        if (balance < 0) {\n            below_zero = true;\n            break;\n        }\n    }\n\n    return below_zero;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool below_zero_simd(std::vector<int> operations) {\n    size_t size = operations.size();\n    int32_t balance = 0;\n    size_t i = 0;\n\n    // Process as many full SVE vectors as possible\n    svbool_t pg = svwhilelt_b32(i, size);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec_ops = svld1_s32(pg, &operations[i]);\n        svint32_t vec_balance = svadd_n_s32_x(pg, vec_ops, balance);\n\n        // Check if any lane goes below zero\n        svbool_t negative_mask = svcmplt_n_s32(pg, vec_balance, 0);\n        if (svptest_any(pg, negative_mask)) {\n            return true;\n        }\n\n        // Update the scalar balance with the last valid value in the vector\n        balance = svlasta_s32(pg, vec_balance);\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n\n    // Process any remaining elements\n    for (; i < size; ++i) {\n        balance += operations[i];\n        if (balance < 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool below_zero_simd(std::vector<int> operations) {\n    svint32_t v_balance = svdup_n_s32(0); // Initialize vector balance to zero\n    size_t i = 0;\n    size_t n = operations.size();\n    bool below_zero = false;\n\n    while (i + svcntw() <= n) {\n        svint32_t v_ops = svld1_s32(svptrue_b32(), &operations[i]);\n        v_balance = svadd_s32_z(svptrue_b32(), v_balance, v_ops);\n        svbool_t neg_mask = svcmplt_s32(svptrue_b32(), v_balance, svdup_n_s32(0));\n        if (svptest_any(svptrue_b32(), neg_mask)) {\n            below_zero = true;\n            break;\n        }\n        i += svcntw();\n    }\n\n    int balance = 0;\n    for (size_t j = 0; j < i; ++j) {\n        balance += operations[j];\n    }\n\n    for (; i < n; ++i) {\n        balance += operations[i];\n        if (balance < 0) {\n            below_zero = true;\n            break;\n        }\n    }\n\n    return below_zero;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool below_zero_simd(std::vector<int> operations) {\n    svint32_t balance = svdup_n_s32(0);\n    size_t i = 0;\n    size_t length = operations.size();\n    bool below_zero = false;\n\n    while (i <= length - svcntw()) {\n        svint32_t ops = svld1_s32(svptrue_b32(), &operations[i]);\n        balance = svadd_s32_z(svptrue_b32(), balance, ops);\n        svbool_t neg_mask = svcmplt_s32(svptrue_b32(), balance, svdup_n_s32(0));\n        if (svptest_any(svptrue_b32(), neg_mask)) {\n            below_zero = true;\n            break;\n        }\n        i += svcntw();\n    }\n\n    for (; i < length; ++i) {\n        int temp = *(svgetlane_s32(balance, 0)) + operations[i];\n        if (temp < 0) {\n            below_zero = true;\n            break;\n        }\n        balance = svset_lane_s32(temp, balance, 0);\n    }\n\n    return below_zero;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool below_zero_simd(std::vector<int> operations) {\n    svint32_t vec_balance = svdup_n_s32(0);\n    bool below_zero = false;\n    size_t i = 0;\n    size_t length = operations.size();\n\n    while (i <= length - svcntw()) {\n        svint32_t vec_ops = svld1_s32(svptrue_b32(), &operations[i]);\n        vec_balance = svadd_s32_z(svptrue_b32(), vec_balance, vec_ops);\n        svbool_t neg_mask = svcmplt_s32(svptrue_b32(), vec_balance, svdup_n_s32(0));\n        if (svptest_any(svptrue_b32(), neg_mask)) {\n            below_zero = true;\n            break;\n        }\n        i += svcntw();\n    }\n\n    int balance = svaddv_s32(svptrue_b32(), vec_balance);\n\n    for (; i < length; ++i) {\n        balance += operations[i];\n        if (balance < 0) {\n            below_zero = true;\n            break;\n        }\n    }\n\n    return below_zero;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t size = numbers.size();\n    double sum = 0.0;\n    double mean = 0.0;\n    double mad = 0.0;\n\n    // Compute the sum of the numbers to calculate the mean\n    for (size_t i = 0; i < size; ++i) {\n        sum += numbers[i];\n    }\n    mean = sum / size;\n\n    // SVE-based computation of Mean Absolute Deviation\n    svbool_t pg =svptrue_b64(); // Predicate for full vector length\n    double* data = numbers.data();\n    size_t vl = svcntd(); // Get the SVE vector length in terms of doubles\n    svfloat64_t vec_mean = svdup_f64(mean); // Broadcast mean to a vector\n    svfloat64_t vec_sum = svdup_f64(0.0);  // Initialize vector for partial sums\n\n    size_t i = 0;\n    for (; i + vl <= size; i += vl) {\n        svfloat64_t vec_data = svld1(pg, &data[i]); // Load vector of data\n        svfloat64_t vec_diff = svsub_f64(vec_data, vec_mean); // Subtract mean\n        svfloat64_t vec_abs = svabs_f64(vec_diff); // Absolute value\n        vec_sum = svadd_f64(vec_sum, vec_abs); // Accumulate absolute differences\n    }\n\n    // Reduce the vector sum into a scalar\n    double temp_sum = 0.0;\n    svst1(pg, &temp_sum, vec_sum); // Store the partial sum back to memory\n    mad += temp_sum;\n\n    // Handle any remaining elements that didn't fit into the vectorized loop\n    for (; i < size; ++i) {\n        mad += std::abs(data[i] - mean);\n    }\n\n    return mad / size;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t size = numbers.size();\n    double sum = 0.0;\n\n    // Compute the sum of the numbers using SVE\n    svbool_t pg =svptrue_b64(); // Predicate for full vector operations\n    svfloat64_t vec_sum = svdup_f64(0.0);\n\n    for (size_t i = 0; i < size; i += svcntd()) {\n        svfloat64_t vec = svld1_f64(pg, &numbers[i]);\n        vec_sum = svadd_f64_z(pg, vec_sum, vec);\n    }\n\n    // Reduce the vector sum to a scalar\n    sum = svaddv_f64(pg, vec_sum);\n\n    // Compute the mean\n    double mean = sum / size;\n\n    // Compute the Mean Absolute Deviation using SVE\n    svfloat64_t mad_sum_vec = svdup_f64(0.0);\n    svfloat64_t mean_vec = svdup_f64(mean);\n\n    for (size_t i = 0; i < size; i += svcntd()) {\n        svfloat64_t vec = svld1_f64(pg, &numbers[i]);\n        svfloat64_t diff = svsub_f64_z(pg, vec, mean_vec);\n        svfloat64_t abs_diff = svabs_f64_z(pg, diff);\n        mad_sum_vec = svadd_f64_z(pg, mad_sum_vec, abs_diff);\n    }\n\n    // Reduce the MAD sum vector to a scalar\n    double mad_sum = svaddv_f64(pg, mad_sum_vec);\n\n    // Compute the final MAD\n    return mad_sum / size;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t size = numbers.size();\n    double sum = 0.0;\n    double mean = 0.0;\n    double mad = 0.0;\n\n    // Compute the sum of the numbers\n    {\n        svbool_t pg =svptrue_b64();\n        svfloat64_t vec_sum = svdup_f64(0.0);\n\n        for (size_t i = 0; i < size; i += svcntd()) {\n            pg = svwhilelt_b64(i, size);\n            svfloat64_t vec = svld1_f64(pg, &numbers[i]);\n            vec_sum = svadd_f64_m(pg, vec_sum, vec);\n        }\n\n        // Horizontal reduction to get the final sum\n        while (svcntd() > 1) {\n            vec_sum = svadd_f64(vec_sum, svext_f64(vec_sum, svlen(vec_sum) / 2));\n        }\n        sum = svlasta_f64(svptrue_b64(), vec_sum);\n    }\n\n    // Compute the mean\n    mean = sum / size;\n\n    // Compute the Mean Absolute Deviation\n    {\n        svbool_t pg = svptrue_b64();\n        svfloat64_t vec_mad_sum = svdup_f64(0.0);\n        svfloat64_t vec_mean = svdup_f64(mean);\n\n        for (size_t i = 0; i < size; i += svcntd()) {\n            pg = svwhilelt_b64(i, size);\n            svfloat64_t vec = svld1_f64(pg, &numbers[i]);\n            svfloat64_t diff = svsub_f64(vec, vec_mean);\n            svfloat64_t abs_diff = svabs_f64(diff);\n            vec_mad_sum = svadd_f64_m(pg, vec_mad_sum, abs_diff);\n        }\n\n        // Horizontal reduction to get the final MAD sum\n        while (svcntd() > 1) {\n            vec_mad_sum = svadd_f64(vec_mad_sum, svext_f64(vec_mad_sum, svlen(vec_mad_sum) / 2));\n        }\n        mad = svlasta_f64(svptrue_b64(), vec_mad_sum);\n    }\n\n    return mad / size;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t size = numbers.size();\n    double sum = 0.0;\n    double mean = 0.0;\n    double mad = 0.0;\n\n    // Calculate the sum of the numbers\n    {\n        svbool_t pg = svwhilelt_b64(0, size);\n        svfloat64_t vec_sum = svdup_f64(0.0);\n\n        for (size_t i = 0; i < size; i += svcntd()) {\n            svfloat64_t vec = svld1_f64(pg, &numbers[i]);\n            vec_sum = svadd_f64_m(pg, vec_sum, vec);\n            pg = svwhilelt_b64(i + svcntd(), size);\n        }\n\n        // Horizontal reduction to get the final sum\n        double temp[svcntd()];\n        svst1_f64(svptrue_b64(), temp, vec_sum);\n        for (int i = 0; i < svcntd(); ++i) {\n            sum += temp[i];\n        }\n    }\n\n    // Calculate the mean\n    mean = sum / size;\n\n    // Calculate the Mean Absolute Deviation\n    {\n        svbool_t pg = svwhilelt_b64(0, size);\n        svfloat64_t vec_mean = svdup_f64(mean);\n        svfloat64_t vec_mad_sum = svdup_f64(0.0);\n\n        for (size_t i = 0; i < size; i += svcntd()) {\n            svfloat64_t vec = svld1_f64(pg, &numbers[i]);\n            svfloat64_t diff = svsub_f64(vec, vec_mean);\n            svfloat64_t abs_diff = svabs_f64(diff);\n            vec_mad_sum = svadd_f64_m(pg, vec_mad_sum, abs_diff);\n            pg = svwhilelt_b64(i + svcntd(), size);\n        }\n\n        // Horizontal reduction to get the final MAD sum\n        double temp[svcntd()];\n        svst1_f64(svptrue_b64(), temp, vec_mad_sum);\n        for (int i = 0; i < svcntd(); ++i) {\n            mad += temp[i];\n        }\n    }\n\n    // Finalize MAD by dividing by the size\n    mad /= size;\n\n    return mad;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <numeric>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t size = numbers.size();\n    double mean = std::accumulate(numbers.begin(), numbers.end(), 0.0) / size;\n\n    svbool_t pg = svwhilelt_b64(0, size);\n    svfloat64_t vec_mean = svdup_f64(mean);\n    svfloat64_t vec_sum = svdup_f64(0.0);\n\n    for (size_t i = 0; i < size; i += svcntd()) {\n        svfloat64_t vec_data = svld1_f64(pg, &numbers[i]);\n        svfloat64_t vec_diff = svsub_f64(vec_data, vec_mean);\n        svfloat64_t vec_abs = svabs_f64(vec_diff);\n        vec_sum = svadd_f64(vec_sum, vec_abs);\n    }\n\n    double sum = 0.0;\n    svst1_f64(pg, &sum, vec_sum);\n\n    return sum / size;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    std::vector<int> result;\n    size_t n = numbers.size();\n    \n    if (n == 0) return result;\n\n    // Reserve space for the result vector\n    result.reserve(2 * n - 1);\n\n    // SVE register length in bits\n    size_t sve_length = svcntw();\n\n    // Process in chunks of SVE vector length\n    size_t i = 0;\n    for (; i + sve_length <= n; i += sve_length) {\n        // Load a vector of elements from 'numbers'\n        svint32_t vec_numbers = svld1_s32(svptrue_b32(), &numbers[i]);\n\n        // Create a predicate for the active lanes\n        svbool_t pred = svwhilelt_b32(i, n);\n\n        // Create a vector filled with the delimiter\n        svint32_t vec_delim = svdup_s32(delimeter);\n\n        // Interleave the numbers and delimiters\n        svint32_t vec_result1 = svzip1_s32(vec_numbers, vec_delim);\n        svint32_t vec_result2 = svzip2_s32(vec_numbers, vec_delim);\n\n        // Store the interleaved results into the output vector\n        for (size_t j = 0; j < sve_length; ++j) {\n            if (svptest_first(pred, svptrue_b32())) {\n                result.push_back(svlasta_s32(vec_result1));\n            }\n            if (svptest_first(pred, svptrue_b32()) && (i + j + 1 < n)) {\n                result.push_back(svlasta_s32(vec_result2));\n            }\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        result.push_back(numbers[i]);\n        if (i + 1 < n) {\n            result.push_back(delimeter);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    std::vector<int> result;\n    size_t n = numbers.size();\n\n    if (n == 0) {\n        return result;\n    }\n\n    // Reserve space for the result vector\n    result.reserve(2 * n - 1);\n\n    // SVE register length in bits\n    size_t sve_length = svcntw(); // Number of integers in an SVE vector\n\n    // Process in chunks of SVE vector length\n    size_t i = 0;\n    for (; i + sve_length <= n; i += sve_length) {\n        // Load a vector of elements from 'numbers'\n        svint32_t vec_numbers = svld1_s32(svptrue_b32(), &numbers[i]);\n\n        // Create a predicate for the active lanes\n        svbool_t pred = svwhilelt_b32(i, n);\n\n        // Create a vector filled with the delimiter\n        svint32_t vec_delim = svdup_s32(delimeter);\n\n        // Store the first element of the chunk directly\n        if (i == 0) {\n            result.push_back(svlasta_s32(pred, vec_numbers));\n        }\n\n        // Interleave the delimiter and the remaining elements\n        for (size_t j = 1; j < sve_length; ++j) {\n            if (svptest_first(svptrue_b32(), pred)) {\n                result.push_back(delimeter);\n                result.push_back(svlasta_s32(pred, vec_numbers));\n            }\n            pred = svpnext_b32(pred, pred);\n        }\n    }\n\n    // Process any remaining elements\n    for (; i < n; ++i) {\n        if (i > 0) {\n            result.push_back(delimeter);\n        }\n        result.push_back(numbers[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimiter) {\n    std::vector<int> result;\n    size_t n = numbers.size();\n\n    if (n == 0) return result;\n\n    // Reserve space for the result vector\n    result.reserve(2 * n - 1);\n\n    // SVE register length in bits\n    size_t sve_length = svcntw();\n\n    // Process elements in chunks defined by SVE vector length\n    size_t i = 0;\n    for (; i + sve_length <= n; i += sve_length) {\n        // Load a vector of elements from 'numbers'\n        svint32_t vec_numbers = svld1_s32(svptrue_b32(), &numbers[i]);\n\n        // Create a predicate for even positions (to place original numbers)\n        svbool_t pred_even = svbrkb_b_z(svptrue_b32(), svptrue_b32());\n\n        // Create a predicate for odd positions (to place delimiter)\n        svbool_t pred_odd = svnot_b_z(svptrue_b32(), pred_even);\n\n        // Create a vector filled with the delimiter value\n        svint32_t vec_delimiter = svdup_s32(delimiter);\n\n        // Merge the two vectors using predicates\n        svint32_t vec_result = svsel(pred_even, vec_numbers, vec_delimiter);\n\n        // Store the result back to memory\n        for (size_t j = 0; j < sve_length; ++j) {\n            if (svptest_first(svptrue_b32(), pred_even)) {\n                result.push_back(svgetlane(vec_result, j));\n            }\n        }\n    }\n\n    // Process remaining elements (if any) after the last full SVE vector\n    for (; i < n; ++i) {\n        result.push_back(numbers[i]);\n        if (i != n - 1) {\n            result.push_back(delimiter);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimiter) {\n    std::vector<int> result;\n    size_t n = numbers.size();\n\n    if (n == 0) return result;\n\n    // Reserve space for the result vector\n    result.reserve(2 * n - 1);\n\n    // SVE register length in bits\n    size_t sve_length = svcntw(); // Number of integers in an SVE vector\n\n    // Process in chunks of SVE vector length\n    size_t i = 0;\n    for (; i + sve_length <= n; i += sve_length) {\n        svint32_t vec = svld1_s32(svptrue_b32(), &numbers[i]);\n\n        // Create a predicate for odd elements (where delimiter will be inserted)\n        svbool_t pred_odd = svbrkb_b_z(svptrue_b32(), svpfalse());\n\n        // Create a vector filled with delimiter values\n        svint32_t delim_vec = svdup_s32(delimiter);\n\n        // Interleave numbers and delimiters\n        svint32_t res_vec = svsel(pred_odd, delim_vec, vec);\n\n        // Store interleaved results into the output vector\n        for (size_t j = 0; j < sve_length; ++j) {\n            if (!svptest_first(svptrue_b32(), pred_odd)) {\n                result.push_back(svgetlane(vec, j));\n            } else {\n                result.push_back(svgetlane(res_vec, j));\n            }\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        result.push_back(numbers[i]);\n        if (i != n - 1) {\n            result.push_back(delimiter);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimiter) {\n    std::vector<int> result;\n    size_t n = numbers.size();\n\n    if (n == 0) {\n        return result;\n    }\n\n    // Reserve space for the result vector\n    result.reserve(2 * n - 1);\n\n    // Use SVE intrinsics to process the vector in parallel\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active lanes\n    svint32_t vec_numbers = svld1(pg, numbers.data()); // Load input numbers into SVE vector\n    svint32_t vec_delimiter = svdup_n_s32(delimiter); // Broadcast delimiter into SVE vector\n\n    // Temporary storage for interleaved results\n    std::vector<int> temp(2 * n - 1);\n    int* temp_ptr = temp.data();\n\n    size_t i = 0;\n    while (svptest_any(svptrue_b32(), pg)) {\n        svst1(pg, temp_ptr, vec_numbers); // Store numbers\n        temp_ptr += svcntw(); // Move pointer forward by the number of elements processed\n\n        // Insert delimiter between elements\n        svbool_t pg_delim = svwhilelt_b32(i + 1, n); // Predicate for delimiter positions\n        svst1(pg_delim, temp_ptr, vec_delimiter); // Store delimiter\n        temp_ptr += svcntw(); // Move pointer forward\n\n        i += svcntw(); // Increment index by the number of elements processed\n        pg = svwhilelt_b32(i, n); // Update predicate for remaining elements\n    }\n\n    // Copy valid elements from temp to result\n    for (size_t j = 0; j < 2 * n - 1; ++j) {\n        if (j % 2 == 0 || j < 2 * n - 2) {\n            result.push_back(temp[j]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    size_t i = 0;\n    size_t size = numbers.size();\n\n    if (size == 0) {\n        return {sum, product};\n    }\n\n    svint16_t vec_sum = svdup_n_s16(0);\n    svint16_t vec_product = svdup_n_s16(1);\n\n    while (i + svcntw() <= size) {\n        svbool_t pg = svwhilelt_b16(i, size);\n        svint16_t vec = svld1_s16(pg, &numbers[i]);\n\n        vec_sum = svadd_s16_x(pg, vec_sum, vec);\n        vec_product = svmul_s16_x(pg, vec_product, vec);\n\n        i += svcntw();\n    }\n\n    // Reduction for sum\n    int16_t temp_sum = 0;\n    svst1_s16(svptrue_b16(), &temp_sum, vec_sum);\n    for (int j = 0; j < svcntw(); ++j) {\n        sum += temp_sum;\n    }\n\n    // Reduction for product\n    int16_t temp_product = 1;\n    svst1_s16(svptrue_b16(), &temp_product, vec_product);\n    for (int j = 0; j < svcntw(); ++j) {\n        product *= temp_product;\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {static_cast<int64_t>(sum), static_cast<int64_t>(product)};\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    if (numbers.empty()) {\n        return {sum, product};\n    }\n\n    size_t i = 0;\n    size_t n = numbers.size();\n    svint16_t vec_sum = svdup_n_s16(0);\n    svint16_t vec_product = svdup_n_s16(1);\n\n    while (i + svcntw() <= n) {\n        svbool_t pg = svwhilelt_b16(i, n);\n        svint16_t vec = svld1_s16(pg, &numbers[i]);\n\n        vec_sum = svadd_s16_x(pg, vec_sum, vec);\n        vec_product = svmul_s16_x(pg, vec_product, vec);\n\n        i += svcntw();\n    }\n\n    // Reduction for sum\n    int16_t temp_sum = svaddv_s16(svptrue_b16(), vec_sum);\n    sum += temp_sum;\n\n    // Reduction for product\n    int16_t temp_product = svmulv_s16(svptrue_b16(), vec_product);\n    product *= temp_product;\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    size_t size = numbers.size();\n    if (size == 0) {\n        return {sum, product};\n    }\n\n    size_t i = 0;\n    svint16_t vec_sum = svdup_n_s16(0);\n    svint16_t vec_product = svdup_n_s16(1);\n\n    while (i + svcntw() <= size) {\n        svint16_t vec = svld1_s16(svptrue_b16(), &numbers[i]);\n        vec_sum = svadd_s16_m(svptrue_b16(), vec_sum, vec);\n        vec_product = svmul_s16_m(svptrue_b16(), vec_product, vec);\n        i += svcntw();\n    }\n\n    // Reduce the vector sum and product\n    int16_t temp_sum = 0;\n    int16_t temp_product = 1;\n    svst1_s16(svptrue_b16(), &temp_sum, vec_sum);\n    svst1_s16(svptrue_b16(), &temp_product, vec_product);\n\n    sum += temp_sum;\n    product *= temp_product;\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    size_t i = 0;\n    size_t size = numbers.size();\n\n    if (size == 0) {\n        return {sum, product};\n    }\n\n    svint16_t vec_sum = svdup_n_s16(0);\n    svint16_t vec_product = svdup_n_s16(1);\n\n    while (i <= size - svcntw()) {\n        svbool_t pg = svwhilelt_b16(i, size);\n        svint16_t vec = svld1_s16(pg, &numbers[i]);\n\n        vec_sum = svadd_s16_x(pg, vec_sum, vec);\n        vec_product = svmul_s16_x(pg, vec_product, vec);\n\n        i += svcntw();\n    }\n\n    // Reduction for sum\n    int16_t temp_sum = 0;\n    svst1_s16(svptrue_b16(), &temp_sum, vec_sum);\n    for (int j = 0; j < svcntw(); ++j) {\n        sum += temp_sum;\n    }\n\n    // Reduction for product\n    int16_t temp_product = 1;\n    svst1_s16(svptrue_b16(), &temp_product, vec_product);\n    for (int j = 0; j < svcntw(); ++j) {\n        product *= temp_product;\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {static_cast<int64_t>(sum), static_cast<int64_t>(product)};\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    if (numbers.empty()) {\n        return {sum, product};\n    }\n\n    size_t i = 0;\n    size_t n = numbers.size();\n    svint16_t vec_sum = svdup_n_s16(0);\n    svint16_t vec_product = svdup_n_s16(1);\n\n    while (i + svcntw() <= n) {\n        svint16_t vec = svld1_s16(svptrue_b16(), &numbers[i]);\n        vec_sum = svadd_s16_m(svptrue_b16(), vec_sum, vec);\n        vec_product = svmul_s16_m(svptrue_b16(), vec_product, vec);\n        i += svcntw();\n    }\n\n    // Reduce the vector sum and product\n    int16_t temp_sum = 0;\n    int16_t temp_product = 1;\n    svst1_s16(svptrue_b16(), &temp_sum, vec_sum);\n    svst1_s16(svptrue_b16(), &temp_product, vec_product);\n\n    sum += temp_sum;\n    product *= temp_product;\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    std::vector<int> result(numbers.size());\n    size_t i = 0;\n    size_t n = numbers.size();\n\n    while (i < n) {\n        svbool_t pg =svptrue_b32();\n        svint32_t max_vec = svdup_n_s32(INT32_MIN);\n        svint32_t vec = svld1(pg, &numbers[i]);\n\n        size_t j = i;\n        while (j < n) {\n            svint32_t current = svld1(pg, &numbers[j]);\n            max_vec = svmax_s32(pg, max_vec, current);\n            svst1(pg, &result[j], max_vec);\n\n            j += svcntw();\n            if (j >= n) break;\n\n            pg = svwhilelt_b32(j, n);\n        }\n\n        i += svcntw();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    std::vector<int> result(numbers.size());\n    size_t i = 0;\n    size_t size = numbers.size();\n\n    while (i < size) {\n        svbool_t pg =svptrue_b32();\n        svint32_t max_vec = svdup_n_s32(INT32_MIN);\n        svint32_t vec = svld1_s32(pg, &numbers[i]);\n\n        size_t vl = svcntw();\n        size_t j = 0;\n\n        while (j < vl && i + j < size) {\n            max_vec = svmax_s32(pg, max_vec, vec);\n            result[i + j] = svgetlane_s32(max_vec, j);\n            j++;\n        }\n\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    std::vector<int> result(numbers.size());\n    size_t i = 0;\n    size_t num_elements = numbers.size();\n\n    while (i < num_elements) {\n        // Load a vector of elements from the input\n        svint32_t vec = svld1_s32(svptrue_b32(), &numbers[i]);\n\n        // Initialize the rolling maximum with the first element\n        svint32_t rolling_max = svdup_s32(svgetlane_s32(vec, 0));\n\n        // Compute the rolling maximum for the current vector\n        for (int j = 1; j < svcntw(); ++j) {\n            svbool_t pred = svwhilelt_b32(j, svcntw());\n            rolling_max = svmax_s32_m(pred, rolling_max, svext_s32(vec, vec, j));\n        }\n\n        // Store the result back to the output vector\n        svst1_s32(svptrue_b32(), &result[i], rolling_max);\n\n        // Move to the next block of elements\n        i += svcntw();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    std::vector<int> result(numbers.size());\n    size_t i = 0;\n    size_t n = numbers.size();\n\n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t vec = svld1(pg, &numbers[i]);\n        svint32_t max_vec = vec;\n\n        size_t j = i;\n        while (j < i + svcntw() && j < n) {\n            max_vec = svmax_s32(pg, max_vec, svdup_s32(numbers[j]));\n            j++;\n        }\n\n        svst1(pg, &result[i], max_vec);\n        i += svcntw();\n    }\n\n    for (size_t k = 1; k < n; ++k) {\n        if (result[k] < result[k - 1]) {\n            result[k] = result[k - 1];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    std::vector<int> result(numbers.size());\n    size_t i = 0;\n    size_t size = numbers.size();\n\n    while (i < size) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        svint32_t vec = svld1(pg, &numbers[i]);\n\n        static svint32_t max_vec = svdup_n_s32(INT32_MIN);\n        max_vec = svmax(pg, max_vec, vec);\n\n        svst1(pg, &result[i], max_vec);\n        i += svcntw();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.length();\n    std::string result(len, '0');\n\n    size_t i = 0;\n    while (i <= len - svcntb()) {\n        svuint8_t va = svld1sb_u8(svptrue_b8(), reinterpret_cast<const uint8_t*>(&a[i]));\n        svuint8_t vb = svld1sb_u8(svptrue_b8(), reinterpret_cast<const uint8_t*>(&b[i]));\n\n        svuint8_t vxor = sveor_u8(va, vb);\n\n        svst1b_u8(svptrue_b8(), reinterpret_cast<uint8_t*>(&result[i]), vxor);\n        i += svcntb();\n    }\n\n    for (; i < len; ++i) {\n        result[i] = ((a[i] == '1') ^ (b[i] == '1')) ? '1' : '0';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    // Ensure both strings are of the same length by padding with '0's if necessary\n    size_t max_len = std::max(a.size(), b.size());\n    a.insert(a.begin(), max_len - a.size(), '0');\n    b.insert(b.begin(), max_len - b.size(), '0');\n\n    std::string result(max_len, '0');\n    size_t i = 0;\n\n    // Process the strings in chunks of SVE vector length\n    while (i + svcntb() <= max_len) {\n        // Load vectors of 8-bit values from the strings\n        svuint8_t va = svld1sb_u8(svptrue_b8(), reinterpret_cast<const uint8_t*>(&a[i]));\n        svuint8_t vb = svld1sb_u8(svptrue_b8(), reinterpret_cast<const uint8_t*>(&b[i]));\n\n        // Perform XOR operation on the vectors\n        svuint8_t vresult = sveor_u8(va, vb);\n\n        // Store the result back into the result string\n        svst1b_u8(svptrue_b8(), reinterpret_cast<uint8_t*>(&result[i]), vresult);\n\n        i += svcntb();\n    }\n\n    // Process any remaining elements that didn't fit into a full vector\n    for (; i < max_len; ++i) {\n        result[i] = ((a[i] == '1') ^ (b[i] == '1')) ? '1' : '0';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    // Ensure both strings are of the same length by padding with '0's if necessary\n    size_t max_len = std::max(a.size(), b.size());\n    a.resize(max_len, '0');\n    b.resize(max_len, '0');\n\n    std::string result(max_len, '0');\n    size_t i = 0;\n\n    // Process the strings in chunks of SVE vector length\n    while (i + svcntb() <= max_len) {\n        // Load vectors of characters from both strings\n        svuint8_t va = svld1sb_u8(svptrue_b8(), reinterpret_cast<const uint8_t*>(&a[i]));\n        svuint8_t vb = svld1sb_u8(svptrue_b8(), reinterpret_cast<const uint8_t*>(&b[i]));\n\n        // Convert character '0'/'1' to integer 0/1\n        svuint8_t a_bits = svsub_x(svptrue_b8(), va, svdup_u8('0'));\n        svuint8_t b_bits = svsub_x(svptrue_b8(), vb, svdup_u8('0'));\n\n        // Perform XOR operation\n        svuint8_t xor_bits = sveor_x(svptrue_b8(), a_bits, b_bits);\n\n        // Convert back to character '0'/'1'\n        svuint8_t res_chars = svadd_x(svptrue_b8(), xor_bits, svdup_u8('0'));\n\n        // Store the result back into the output string\n        svst1b_u8(svptrue_b8(), reinterpret_cast<uint8_t*>(&result[i]), res_chars);\n\n        i += svcntb();\n    }\n\n    // Process any remaining elements that didn't fit into a full vector\n    for (; i < max_len; ++i) {\n        result[i] = ((a[i] - '0') ^ (b[i] - '0')) + '0';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    // Ensure both strings are of the same length by padding with '0's if necessary\n    size_t max_len = std::max(a.size(), b.size());\n    a.insert(a.begin(), max_len - a.size(), '0');\n    b.insert(b.begin(), max_len - b.size(), '0');\n\n    std::string result(max_len, '0');\n    size_t i = 0;\n\n    // Process the strings in chunks of SVE vector length\n    while (i + svcntb() <= max_len) {\n        // Load vectors of 8-bit elements from the strings\n        svuint8_t vec_a = svld1sb_u8(svptrue_b8(), reinterpret_cast<const uint8_t*>(&a[i]));\n        svuint8_t vec_b = svld1sb_u8(svptrue_b8(), reinterpret_cast<const uint8_t*>(&b[i]));\n\n        // Perform XOR operation on the vectors\n        svuint8_t vec_result = sveor_u8(vec_a, vec_b);\n\n        // Store the result back into the result string\n        svst1b_u8(svptrue_b8(), reinterpret_cast<uint8_t*>(&result[i]), vec_result);\n\n        i += svcntb();\n    }\n\n    // Process any remaining elements that didn't fit into a full vector\n    for (; i < max_len; ++i) {\n        result[i] = ((a[i] - '0') ^ (b[i] - '0')) + '0';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.length();\n    std::string result(len, '0');\n\n    size_t i = 0;\n    while (i <= len - svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, len);\n\n        svuint8_t vec_a = svld1ub(pg, reinterpret_cast<const uint8_t*>(a.data() + i));\n        svuint8_t vec_b = svld1ub(pg, reinterpret_cast<const uint8_t*>(b.data() + i));\n\n        svuint8_t vec_xor = sveor_b(vec_a, vec_b);\n\n        svst1ub(pg, reinterpret_cast<uint8_t*>(result.data() + i), vec_xor);\n\n        i += svcntb();\n    }\n\n    for (; i < len; ++i) {\n        result[i] = ((a[i] == '1') ^ (b[i] == '1')) ? '1' : '0';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::string longest_simd(const std::vector<std::string> &strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    size_t max_length = 0;\n    size_t max_index = 0;\n\n    // Determine the maximum vector length for strings\n    size_t num_strings = strings.size();\n    size_t vl = svcntw(); // Get the number of elements per SVE vector\n\n    for (size_t i = 0; i < num_strings; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, num_strings); // Predicate for active lanes\n        svuint32_t lengths = svld1uw(pg, reinterpret_cast<const uint32_t*>(strings.data() + i)); // Load lengths\n\n        // Compute lengths using SVE intrinsics\n        svuint32_t string_lengths = svdup_u32(0);\n        for (size_t j = 0; j < vl; ++j) {\n            if (i + j < num_strings) {\n                string_lengths = svset_u32(string_lengths, j, strings[i + j].size());\n            }\n        }\n\n        // Find the maximum length in this vector\n        svbool_t mask = svcmpeq_n_u32(pg, string_lengths, svmaxv_u32(pg, string_lengths));\n        size_t index = i + svlasta(pg, mask);\n\n        // Update global maximum if necessary\n        uint32_t current_max = svmaxv_u32(pg, string_lengths);\n        if (current_max > max_length) {\n            max_length = current_max;\n            max_index = index;\n        }\n    }\n\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::string longest_simd(const std::vector<std::string> &strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    size_t max_length = 0;\n    size_t max_index = 0;\n\n    // Determine the maximum vector length for strings\n    size_t num_strings = strings.size();\n    size_t vl = svcntw(); // Get the number of elements per vector\n\n    for (size_t i = 0; i < num_strings; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, num_strings); // Predicate for active lanes\n        svuint32_t lengths = svld1uw(pg, reinterpret_cast<const uint32_t*>(&strings[i]));\n\n        // Compute lengths of strings in parallel\n        svuint32_t string_lengths = svdup_u32(0);\n        for (size_t j = 0; j < vl; ++j) {\n            if (i + j < num_strings) {\n                string_lengths = svset_u32(string_lengths, j, strings[i + j].size());\n            }\n        }\n\n        // Find the maximum length in this vector\n        svbool_t cmp_mask = svcmpgt(pg, string_lengths, svdup_u32(max_length));\n        if (svptest_any(svptrue_b32(), cmp_mask)) {\n            uint32_t new_max_length = svmaxv(pg, string_lengths);\n            size_t index = i + svlasta(pg, cmp_mask);\n            if (new_max_length > max_length) {\n                max_length = new_max_length;\n                max_index = index;\n            }\n        }\n    }\n\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n\nstd::string longest_simd(const std::vector<std::string> &strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    size_t max_length = 0;\n    size_t max_index = 0;\n\n    // Determine the maximum vector length for strings\n    size_t num_strings = strings.size();\n    size_t vl = svcntw(); // Get the number of elements per vector\n\n    for (size_t i = 0; i < num_strings; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, num_strings); // Predicate for active lanes\n        svuint32_t lengths = svld1uw(pg, reinterpret_cast<const uint32_t*>(strings.data() + i)); // Load lengths\n\n        // Compute the maximum length in the current vector\n        uint32_t current_max = svmaxv(pg, lengths);\n\n        // Find the index of the first occurrence of the maximum length\n        svbool_t max_mask = svcmpeq(pg, lengths, current_max);\n        uint32_t max_idx_in_vector = svclastb(pg, max_mask, svindex_u32(0, 1));\n\n        // Update global maximum if necessary\n        if (current_max > max_length) {\n            max_length = current_max;\n            max_index = i + max_idx_in_vector;\n        }\n    }\n\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n\nstd::string longest_simd(const std::vector<std::string> &strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    size_t max_length = 0;\n    size_t max_index = 0;\n\n    // Determine the maximum vector length for strings\n    size_t num_strings = strings.size();\n    size_t vl = svcntw(); // Get the number of elements per vector\n\n    for (size_t i = 0; i < num_strings; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, num_strings); // Predicate for active lanes\n        svuint32_t lengths = svld1uw(pg, reinterpret_cast<const uint32_t*>(strings.data() + i)); // Load lengths\n        svuint32_t indices = svindex_u32(i, 1); // Generate indices starting from i\n\n        // Find the maximum length in this vector\n        svbool_t cmp = svcmpeq(pg, lengths, svmaxv(pg, lengths));\n        uint32_t current_max = svmaxv(pg, lengths);\n        uint32_t current_index = svlasta(pg, indices);\n\n        // Update global maximum if necessary\n        if (current_max > max_length) {\n            max_length = current_max;\n            max_index = current_index;\n        }\n    }\n\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n\nstd::string longest_simd(const std::vector<std::string> &strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    size_t max_length = 0;\n    size_t max_index = 0;\n\n    // Determine the maximum vector length for strings\n    size_t num_strings = strings.size();\n    size_t vl = svcntw(); // Get the number of elements per vector\n\n    for (size_t i = 0; i < num_strings; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, num_strings); // Predicate for active lanes\n        svuint32_t lengths = svld1uw(pg, reinterpret_cast<const uint32_t*>(&strings[i]));\n\n        // Find the maximum length in this vector\n        svuint32_t max_len_vec = svmaxv(pg, lengths);\n        uint32_t current_max = svlasta(pg, max_len_vec);\n\n        // Check if this is the global maximum\n        if (current_max > max_length) {\n            max_length = current_max;\n            max_index = i + svlastb(pg, svindex_u32(0, 1));\n        }\n    }\n\n    // Validate and return the longest string\n    if (max_index < num_strings && strings[max_index].length() == max_length) {\n        return strings[max_index];\n    }\n\n    return \"\";\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    svuint64_t va = svdup_u64(a);\n    svuint64_t vb = svdup_u64(b);\n    svbool_t pg = svptrue_b64();\n\n    while (svcmpeq_m(pg, vb, svdup_u64(0)) == 0) {\n        svuint64_t temp = svmod_u64_x(pg, va, vb);\n        va = vb;\n        vb = temp;\n    }\n\n    return svminv_u64(pg, va);\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    svuint64_t va = svdup_u64(a);\n    svuint64_t vb = svdup_u64(b);\n    svbool_t pg = svptrue_b64();\n\n    while (svptest_any(pg, vb)) {\n        svuint64_t vr = svsub_u64_m(pg, va, vb);\n        va = svmin_u64(pg, va, vb);\n        vb = svmax_u64(pg, vr, vb);\n    }\n\n    return svlasta_u64(pg, va);\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    svuint64_t va = svdup_u64(a);\n    svuint64_t vb = svdup_u64(b);\n    svbool_t pg = svptrue_b64();\n\n    while (svptest_any(pg, vb)) {\n        svuint64_t vr = svsub_u64_m(pg, va, vb);\n        va = svsel_u64(svcmpge(pg, va, vb), vb, va);\n        vb = svsel_u64(svcmpge(pg, vr, vb), vr, vb);\n    }\n\n    return svlasta_u64(pg, va);\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    svuint64_t va = svdup_u64(a);\n    svuint64_t vb = svdup_u64(b);\n    svbool_t pg = svwhilelt_b64(0, 1);\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svuint64_t vr = svsub_u64(va, vb);\n        svbool_t cmp = svcmpge(pg, va, vb);\n        va = svsel_u64(cmp, vr, va);\n        vb = svsel_u64(cmp, vb, vr);\n        pg = svwhilelt_b64(svmin_u64(va, vb), 1);\n    }\n\n    return svlasta_u64(svptrue_b64(), va);\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    svuint64_t va = svdup_u64(a);\n    svuint64_t vb = svdup_u64(b);\n    svbool_t pg = svptrue_b64();\n\n    while (svcmpeq_m(pg, vb, svdup_u64(0)) == 0) {\n        svuint64_t temp = svmod_u64_x(pg, va, vb);\n        va = vb;\n        vb = temp;\n    }\n\n    return svminv_u64(pg, va);\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    std::vector<float> result(2);\n    size_t size = numbers.size();\n    float closest_diff = std::numeric_limits<float>::max();\n    float closest_a = 0.0f, closest_b = 0.0f;\n\n    // Ensure the input vector has at least two elements\n    if (size < 2) {\n        return result;\n    }\n\n    // Load the input data into SVE vectors\n    svbool_t pg = svwhilelt_b32(0, size); // Predicate for active lanes\n    svfloat32_t vec1, vec2;\n    float *data = numbers.data();\n\n    for (size_t i = 0; i < size - 1; ++i) {\n        vec1 = svld1_f32(pg, data + i); // Load starting from index i\n\n        for (size_t j = i + 1; j < size; ++j) {\n            vec2 = svld1_f32(pg, data + j); // Load starting from index j\n\n            // Compute absolute differences between elements\n            svfloat32_t diff = svsub_f32_z(pg, vec1, vec2);\n            diff = svabs_f32_z(pg, diff);\n\n            // Find the minimum difference in the vector\n            float min_diff = svminv_f32(pg, diff);\n\n            // Update closest pair if a smaller difference is found\n            if (min_diff < closest_diff) {\n                closest_diff = min_diff;\n                closest_a = numbers[i];\n                closest_b = numbers[j];\n            }\n        }\n    }\n\n    // Return the closest pair in sorted order\n    if (closest_a < closest_b) {\n        result[0] = closest_a;\n        result[1] = closest_b;\n    } else {\n        result[0] = closest_b;\n        result[1] = closest_a;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    std::vector<float> result(2);\n    size_t n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_a = 0.0f, closest_b = 0.0f;\n\n    // Ensure the input vector has at least two elements\n    if (n < 2) {\n        return result;\n    }\n\n    // Load the input data into SVE vectors\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active lanes\n    svfloat32_t vec = svld1_f32(pg, numbers.data());\n\n    // Iterate over all pairs of elements to find the closest pair\n    for (size_t i = 0; i < n; ++i) {\n        float current = numbers[i];\n        svfloat32_t current_vec = svdup_f32(current);\n\n        // Compute absolute differences between current and all other elements\n        svfloat32_t diff = svsub_f32(vec, current_vec);\n        svfloat32_t abs_diff = svabs_f32(diff);\n\n        // Mask out the diagonal element (difference with itself)\n        svbool_t mask = svcmpeq_n_f32(pg, vec, current_vec);\n        abs_diff = svsel_f32(mask, svdup_f32(std::numeric_limits<float>::max()), abs_diff);\n\n        // Find the minimum difference in the vector\n        float min_val = svminv_f32(pg, abs_diff);\n\n        // Update the closest pair if a smaller difference is found\n        if (min_val < min_diff) {\n            min_diff = min_val;\n\n            // Find the index of the minimum difference\n            for (size_t j = 0; j < n; ++j) {\n                if (fabs(numbers[j] - current) == min_val) {\n                    closest_a = std::min(current, numbers[j]);\n                    closest_b = std::max(current, numbers[j]);\n                    break;\n                }\n            }\n        }\n    }\n\n    result[0] = closest_a;\n    result[1] = closest_b;\n    return result;\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    std::vector<float> result(2);\n    size_t size = numbers.size();\n    float closest_diff = std::numeric_limits<float>::max();\n    float closest_a = 0.0f, closest_b = 0.0f;\n\n    // Ensure the input vector has at least two elements\n    if (size < 2) {\n        return result;\n    }\n\n    // Load the input data into SVE vectors\n    svbool_t pg = svwhilelt_b32(0, size); // Predicate for active lanes\n    svfloat32_t vec1 = svld1(pg, numbers.data());\n\n    for (size_t i = 0; i < size - 1; ++i) {\n        float current = numbers[i];\n        svfloat32_t vec2 = svdup_f32(current); // Broadcast current element\n\n        // Compute absolute differences\n        svfloat32_t diff = svsub_f32(vec1, vec2);\n        diff = svabs_f32(diff);\n\n        // Find the minimum difference and corresponding index\n        svbool_t mask = svcmpeq(pg, diff, svdup_f32(0.0f)); // Exclude self-comparison\n        diff = svmax_f32_m(mask, diff, svdup_f32(std::numeric_limits<float>::max()));\n\n        float min_diff = svminv(pg, diff);\n        if (min_diff < closest_diff) {\n            closest_diff = min_diff;\n            closest_a = current;\n\n            // Find the corresponding number in the vector\n            for (size_t j = i + 1; j < size; ++j) {\n                if (fabs(numbers[j] - current) == min_diff) {\n                    closest_b = numbers[j];\n                    break;\n                }\n            }\n        }\n    }\n\n    // Return the closest pair in order\n    if (closest_a <= closest_b) {\n        result[0] = closest_a;\n        result[1] = closest_b;\n    } else {\n        result[0] = closest_b;\n        result[1] = closest_a;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    std::vector<float> result(2);\n    size_t size = numbers.size();\n    float closest_diff = std::numeric_limits<float>::max();\n    float closest_a = 0.0f, closest_b = 0.0f;\n\n    // Ensure the input vector has at least two elements\n    if (size < 2) {\n        return result;\n    }\n\n    // Load the input data into SVE vectors\n    size_t vl = svcntw(); // Get the SVE vector length for float\n    svbool_t pg = svwhilelt_b32(0, size); // Predicate for active lanes\n\n    for (size_t i = 0; i < size; ++i) {\n        float current = numbers[i];\n        svfloat32_t vec_current = svdup_f32(current);\n\n        for (size_t j = 0; j < size; j += vl) {\n            svfloat32_t vec_numbers = svld1(pg, &numbers[j]);\n            svfloat32_t vec_diff = svsub_f32(vec_numbers, vec_current);\n            svfloat32_t vec_abs_diff = svabs_f32(vec_diff);\n\n            // Find the minimum difference in the current vector\n            svbool_t mask = svcmpeq_f32(pg, vec_numbers, vec_current); // Avoid self-comparison\n            svfloat32_t vec_min_diff = svmin_f32_z(pg, vec_abs_diff, svdup_f32(closest_diff));\n\n            // Extract the minimum difference and corresponding values\n            for (size_t k = 0; k < vl && (j + k) < size; ++k) {\n                float diff = svget_f32(vec_min_diff, k);\n                if (diff < closest_diff && !svptest_any(mask)) {\n                    closest_diff = diff;\n                    closest_a = current;\n                    closest_b = numbers[j + k];\n                }\n            }\n        }\n    }\n\n    // Ensure correct order (smaller, larger)\n    if (closest_a > closest_b) {\n        std::swap(closest_a, closest_b);\n    }\n\n    result[0] = closest_a;\n    result[1] = closest_b;\n    return result;\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    std::vector<float> result(2);\n    size_t size = numbers.size();\n    float closest_diff = std::numeric_limits<float>::max();\n    float closest_a = 0.0f, closest_b = 0.0f;\n\n    // Ensure the input vector has at least two elements\n    if (size < 2) {\n        return result;\n    }\n\n    // Load the input data into SVE vectors\n    svbool_t pg = svwhilelt_b32(0, size); // Predicate for active lanes\n    svfloat32_t vec1 = svld1(pg, numbers.data());\n\n    for (size_t i = 0; i < size - 1; ++i) {\n        float current = numbers[i];\n        svfloat32_t vec2 = svdup_n_f32(current); // Broadcast current element\n\n        // Compute absolute differences\n        svfloat32_t diff = svsub_z(pg, vec1, vec2);\n        diff = svabs_z(pg, diff);\n\n        // Find the minimum difference in the vector\n        svbool_t mask = svcmpeq(pg, diff, 0.0f); // Exclude self-comparison\n        diff = svmax_m(pg, diff, mask, std::numeric_limits<float>::max());\n        float min_diff = svminv(pg, diff);\n\n        // Update closest pair if a smaller difference is found\n        if (min_diff < closest_diff && min_diff > 0.0f) {\n            closest_diff = min_diff;\n            closest_a = current;\n            closest_b = numbers[svclast(pg, diff)];\n        }\n    }\n\n    // Ensure the result is ordered (smaller, larger)\n    if (closest_a > closest_b) {\n        std::swap(closest_a, closest_b);\n    }\n\n    result[0] = closest_a;\n    result[1] = closest_b;\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t size = numbers.size();\n    std::vector<float> result(size);\n\n    // Find the minimum and maximum values in the vector using SVE\n    float min_val = numbers[0];\n    float max_val = numbers[0];\n\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n    svfloat32_t vec_min = svdup_f32(min_val);\n    svfloat32_t vec_max = svdup_f32(max_val);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vec = svld1_f32(pg, &numbers[i]);\n        vec_min = svmin_f32_z(pg, vec_min, vec);\n        vec_max = svmax_f32_z(pg, vec_max, vec);\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n\n    // Reduce across lanes to get scalar min and max\n    min_val = svminv_f32(svptrue_b32(), vec_min);\n    max_val = svmaxv_f32(svptrue_b32(), vec_max);\n\n    float range = max_val - min_val;\n\n    // Rescale the vector using SVE\n    i = 0;\n    pg = svwhilelt_b32(i, size);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vec = svld1_f32(pg, &numbers[i]);\n        svfloat32_t rescaled = svdiv_f32_z(pg, svsub_f32_z(pg, vec, svdup_f32(min_val)), svdup_f32(range));\n        svst1_f32(pg, &result[i], rescaled);\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t size = numbers.size();\n    std::vector<float> result(size);\n\n    // Find the minimum and maximum values in the vector using SVE\n    float min_val = numbers[0];\n    float max_val = numbers[0];\n\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size); // Predicate for active lanes\n\n    svfloat32_t vec_min = svdup_f32(min_val);\n    svfloat32_t vec_max = svdup_f32(max_val);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vec = svld1_f32(pg, &numbers[i]);\n        vec_min = svmin_f32_m(pg, vec_min, vec);\n        vec_max = svmax_f32_m(pg, vec_max, vec);\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n\n    // Reduce across lanes to get scalar min and max\n    min_val = svminv_f32(svptrue_b32(), vec_min);\n    max_val = svmaxv_f32(svptrue_b32(), vec_max);\n\n    float range = max_val - min_val;\n\n    // Rescale the vector using SVE\n    i = 0;\n    pg = svwhilelt_b32(i, size);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vec = svld1_f32(pg, &numbers[i]);\n        svfloat32_t rescaled = svdiv_f32_z(pg, svsub_f32_z(pg, vec, svdup_f32(min_val)), svdup_f32(range));\n        svst1_f32(pg, &result[i], rescaled);\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t size = numbers.size();\n    std::vector<float> result(size);\n\n    // Find the minimum and maximum values in the vector using SVE\n    float min_val = numbers[0];\n    float max_val = numbers[0];\n\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size); // Predicate for active lanes\n\n    svfloat32_t vec_min = svdup_f32(min_val);\n    svfloat32_t vec_max = svdup_f32(max_val);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vec = svld1_f32(pg, &numbers[i]);\n        vec_min = svmin_f32_z(pg, vec_min, vec);\n        vec_max = svmax_f32_z(pg, vec_max, vec);\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n\n    // Reduce across lanes to get scalar min and max\n    min_val = svminv_f32(svptrue_b32(), vec_min);\n    max_val = svmaxv_f32(svptrue_b32(), vec_max);\n\n    float range = max_val - min_val;\n\n    // Rescale the numbers to the unit range [0, 1]\n    i = 0;\n    pg = svwhilelt_b32(i, size);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vec = svld1_f32(pg, &numbers[i]);\n        svfloat32_t rescaled = svdiv_f32_z(pg, svsub_f32_z(pg, vec, svdup_f32(min_val)), svdup_f32(range));\n        svst1_f32(pg, &result[i], rescaled);\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t size = numbers.size();\n    std::vector<float> result(size);\n\n    // Load the input data into SVE vectors\n    svbool_t pg = svwhilelt_b32(0, size); // Predicate for active lanes\n    svfloat32_t vec_min = svld1_f32(pg, &numbers[0]);\n    svfloat32_t vec_max = vec_min;\n\n    // Find the minimum and maximum values in the vector using SVE intrinsics\n    for (size_t i = svcntw(); i < size; i += svcntw()) {\n        pg = svwhilelt_b32(i, size);\n        svfloat32_t vec = svld1_f32(pg, &numbers[i]);\n        vec_min = svmin_f32_z(pg, vec_min, vec);\n        vec_max = svmax_f32_z(pg, vec_max, vec);\n    }\n\n    // Reduce across lanes to get scalar min and max\n    float min_val = svminv_f32(pg, vec_min);\n    float max_val = svmaxv_f32(pg, vec_max);\n\n    // Compute the scale factor\n    float scale = (max_val != min_val) ? 1.0f / (max_val - min_val) : 0.0f;\n\n    // Rescale the vector\n    pg = svwhilelt_b32(0, size);\n    for (size_t i = 0; i < size; i += svcntw()) {\n        pg = svwhilelt_b32(i, size);\n        svfloat32_t vec = svld1_f32(pg, &numbers[i]);\n        svfloat32_t rescaled = svmul_f32_z(pg, svsub_f32_z(pg, vec, svdup_f32(min_val)), svdup_f32(scale));\n        svst1_f32(pg, &result[i], rescaled);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t size = numbers.size();\n    std::vector<float> result(size);\n\n    // Find the minimum and maximum values in the vector using SVE\n    float min_val = numbers[0];\n    float max_val = numbers[0];\n\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size); // Predicate for active lanes\n\n    do {\n        svfloat32_t vec = svld1(pg, &numbers[i]); // Load a vector of floats\n        min_val = svminv(pg, svmin_n_f32(pg, vec, min_val)); // Update min\n        max_val = svmaxv(pg, svmax_n_f32(pg, vec, max_val)); // Update max\n        i += svcntw(); // Increment by the number of elements processed\n        pg = svwhilelt_b32(i, size); // Update predicate\n    } while (svptest_any(svptrue_b32(), pg));\n\n    float range = max_val - min_val;\n\n    // Rescale the numbers to the range [0, 1]\n    i = 0;\n    pg = svwhilelt_b32(i, size); // Reset predicate\n\n    do {\n        svfloat32_t vec = svld1(pg, &numbers[i]); // Load a vector of floats\n        svfloat32_t rescaled = svdiv_n_f32_z(pg, svsub_n_f32_z(pg, vec, min_val), range); // Rescale\n        svst1(pg, &result[i], rescaled); // Store the result\n        i += svcntw(); // Increment by the number of elements processed\n        pg = svwhilelt_b32(i, size); // Update predicate\n    } while (svptest_any(svptrue_b32(), pg));\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    svbool_t pg = svwhilelt_b64(1, n); // Predicate for the range [1, n-1]\n    svuint64_t vec_n = svdup_u64(n);   // Broadcast n into a vector\n    svuint64_t vec_i = svindex_u64(1, 1); // Create a vector of indices [1, 2, 3, ...]\n\n    uint64_t result = 1; // Initialize result to 1 (minimum divisor)\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svuint64_t divisors = svdivr_z(pg, vec_n, vec_i); // Integer division of n by i\n        svbool_t is_divisor = svcmpeq(pg, svmul_z(pg, divisors, vec_i), vec_n); // Check if i divides n evenly\n\n        // Extract the largest divisor from the current active lanes\n        svuint64_t valid_divisors = svand_z(is_divisor, vec_i);\n        uint64_t max_divisor = svmaxv(pg, valid_divisors);\n\n        // Update the result if a larger divisor is found\n        if (max_divisor > result) {\n            result = max_divisor;\n        }\n\n        // Update the predicate to exclude processed elements\n        pg = svwhilelt_b64(svlasta(pg, vec_i) + 1, n);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    uint64_t largest = 1;\n    svbool_t pg = svwhilelt_b64(1, n / 2 + 1);\n\n    svuint64_t vec_n = svdup_u64(n);\n    svuint64_t vec_i = svindex_u64(1, 1);\n    svuint64_t vec_largest = svdup_u64(1);\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svuint64_t vec_mod = svmod_u64_z(pg, vec_n, vec_i);\n        svbool_t pred = svcmpeq_n_u64(pg, vec_mod, 0);\n\n        vec_largest = svsel_u64(pred, vec_i, vec_largest);\n\n        vec_i = svadd_u64_z(pg, vec_i, svlen_u64(vec_i));\n        pg = svwhilelt_b64(svmaxv_u64(pg, vec_i), n / 2 + 1);\n    }\n\n    largest = svmaxv_u64(svptrue_b64(), vec_largest);\n    return largest;\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    uint64_t result = 1;\n    svbool_t pred = svwhilelt_b64(1, n / 2);\n    svuint64_t vec_n = svdup_u64(n);\n    svuint64_t vec_i = svindex_u64(1, 1);\n\n    do {\n        svuint64_t divisors = svdivr_u64_z(pred, vec_n, vec_i);\n        svbool_t divisible = svcmpeq(pred, svmul_u64_z(pred, divisors, vec_i), vec_n);\n        svuint64_t candidates = svsel_u64(divisible, vec_i, svdup_u64(1));\n        uint64_t max_candidate = svmaxv_u64(pred, candidates);\n        result = max_candidate > result ? max_candidate : result;\n\n        vec_i = svadd_u64_z(pred, vec_i, svlen_u64(vec_i));\n        pred = svwhilelt_b64(svminv_u64(pred, vec_i), n / 2);\n    } while (svptest_any(svptrue_b64(), pred));\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    svbool_t pg = svwhilelt_b64(1, n); // Predicate for the range [1, n-1]\n    svuint64_t vec_n = svdup_u64(n);   // Broadcast n into a vector\n    svuint64_t vec_i = svindex_u64(1, 1); // Create a vector of indices [1, 2, 3, ...]\n\n    uint64_t result = 1; // Default result if no divisor is found\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svuint64_t mod = svmod_u64_x(pg, vec_n, vec_i); // Compute n % i for each element\n        svbool_t is_divisor = svcmpeq_n_u64(pg, mod, 0); // Check where mod is zero\n\n        // Extract the largest divisor from the current active lanes\n        if (svptest_any(svptrue_b64(), is_divisor)) {\n            uint64_t max_divisor = svmaxv_u64(is_divisor, vec_i);\n            result = max_divisor > result ? max_divisor : result;\n        }\n\n        // Update the predicate to exclude processed elements\n        pg = svwhilelt_b64(svlast_active_u64(pg, vec_i) + 1, n);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    uint64_t result = 1;\n    svbool_t pg = svwhilelt_b64(1, n / 2);\n    svuint64_t vec_n = svdup_u64(n);\n    svuint64_t vec_i = svindex_u64(1, 1);\n\n    do {\n        svuint64_t vec_mod = svmod_u64_x(pg, vec_n, vec_i);\n        svbool_t pred_zero = svcmpeq_n_u64(pg, vec_mod, 0);\n        uint64_t max_divisor = svmaxv_u64(pred_zero, vec_i);\n        result = max_divisor > result ? max_divisor : result;\n\n        vec_i = svadd_u64_x(pg, vec_i, svlen_u64(vec_i));\n        pg = svwhilelt_b64(svminv_u64(pg, vec_i), n / 2);\n    } while (svptest_any(svptrue_b64(), pg));\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n <= 1) return factors;\n\n    int divisor = 2;\n    while (n > 1) {\n        if (n % divisor == 0) {\n            factors.push_back(divisor);\n            n /= divisor;\n        } else {\n            divisor++;\n        }\n    }\n\n    // SVE implementation for parallelism\n    svint32_t vec_factors = svld1_s32(svptrue_b32(), factors.data());\n    svint32_t vec_result = svdup_s32(0);\n\n    // Example of SVE operation (dummy operation, as factorization is inherently sequential)\n    svbool_t pred = svwhilelt_b32(0, factors.size());\n    vec_result = svadd_s32_z(pred, vec_factors, vec_factors);\n\n    // Store results back to vector (if needed)\n    std::vector<int> result(factors.size());\n    svst1_s32(svptrue_b32(), result.data(), vec_result);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n <= 1) return factors;\n\n    int divisor = 2;\n    while (n > 1) {\n        if (n % divisor == 0) {\n            factors.push_back(divisor);\n            n /= divisor;\n        } else {\n            divisor++;\n        }\n    }\n\n    // SVE implementation for parallelism\n    svint32_t vec_factors = svundef_s32();\n    svbool_t pred = svwhilelt_b32(0, factors.size());\n    for (size_t i = 0; i < factors.size(); i += svcntw()) {\n        svint32_t vec = svld1_s32(pred, &factors[i]);\n        vec_factors = svadd_s32_z(pred, vec_factors, vec);\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n <= 1) return factors;\n\n    int divisor = 2;\n    while (n > 1) {\n        if (n % divisor == 0) {\n            factors.push_back(divisor);\n            n /= divisor;\n        } else {\n            divisor++;\n        }\n    }\n\n    // SVE implementation for parallelism\n    svint32_t vec_factors = svld1_s32(svptrue_b32(), factors.data());\n    svint32_t vec_result = svdup_s32(0);\n\n    // Example of SVE operation (dummy operation for illustration)\n    vec_result = svadd_s32_z(svptrue_b32(), vec_factors, vec_factors);\n\n    // Store the result back to the vector (if needed)\n    svst1_s32(svptrue_b32(), factors.data(), vec_result);\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    int factor = 2;\n\n    while (n > 1) {\n        if (n % factor == 0) {\n            factors.push_back(factor);\n            n /= factor;\n        } else {\n            factor++;\n        }\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    int factor = 2;\n\n    while (n > 1) {\n        if (n % factor == 0) {\n            factors.push_back(factor);\n            n /= factor;\n        } else {\n            factor++;\n        }\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    size_t i = 0;\n    size_t length = l.size();\n\n    while (i < length) {\n        // Load a vector of floats from the input\n        svfloat32_t vec = svld1_f32(svptrue_b32(), &l[i]);\n\n        // Create a predicate mask for positive values\n        svbool_t positive_mask = svcmpgt_f32(svptrue_b32(), vec, 0.0f);\n\n        // Count the number of positive elements in the current vector\n        uint64_t num_positives = svcntp_b32(svptrue_b32(), positive_mask);\n\n        // Resize the result vector to accommodate new positives\n        size_t old_size = result.size();\n        result.resize(old_size + num_positives);\n\n        // Compress the positive values and store them into the result vector\n        svst1_f32(positive_mask, &result[old_size], vec);\n\n        // Move to the next block of data\n        i += svcntw();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> &l) {\n    std::vector<float> result;\n    size_t i = 0;\n    size_t length = l.size();\n\n    while (i < length) {\n        // Load a vector of floats from the input\n        svfloat32_t vec = svld1_f32(svptrue_b32(), &l[i]);\n\n        // Create a predicate mask for positive values\n        svbool_t positive_mask = svcmpgt_f32(svptrue_b32(), vec, 0.0f);\n\n        // Compress the vector to retain only positive values\n        svfloat32_t compressed = svcvt_f32_f32_m(positive_mask, vec);\n\n        // Store the compressed vector into a temporary buffer\n        float buffer[svcntw()];\n        svst1_f32(positive_mask, buffer, compressed);\n\n        // Count the number of positive elements\n        uint64_t num_positives = svcntp_b32(svptrue_b32(), positive_mask);\n\n        // Append the positive values to the result vector\n        for (uint64_t j = 0; j < num_positives; ++j) {\n            result.push_back(buffer[j]);\n        }\n\n        // Move to the next block of data\n        i += svcntw();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> &l) {\n    std::vector<float> result;\n    size_t i = 0;\n    size_t length = l.size();\n\n    while (i < length) {\n        // Load a vector of floats from the input\n        svfloat32_t vec = svld1_f32(svptrue_b32(), &l[i]);\n\n        // Create a predicate mask for positive values\n        svbool_t positive_mask = svcmpgt_f32(svptrue_b32(), vec, 0.0f);\n\n        // Compress the vector to keep only positive values\n        svfloat32_t compressed = svcvt_f32_f32_m(positive_mask, vec);\n\n        // Store the compressed vector into a temporary buffer\n        float buffer[svcntw()];\n        svst1_f32(positive_mask, buffer, compressed);\n\n        // Count the number of positive elements\n        uint64_t num_positives = svcntp_b32(svptrue_b32(), positive_mask);\n\n        // Append the positive values to the result vector\n        for (uint64_t j = 0; j < num_positives; ++j) {\n            result.push_back(buffer[j]);\n        }\n\n        // Move to the next block of data\n        i += svcntw();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> &l) {\n    std::vector<float> result;\n    size_t i = 0;\n    size_t length = l.size();\n\n    while (i < length) {\n        // Load a vector of floats from the input\n        svfloat32_t vec = svld1_f32(svptrue_b32(), &l[i]);\n\n        // Create a predicate mask for positive values\n        svbool_t positive_mask = svcmpgt_f32(svptrue_b32(), vec, 0.0f);\n\n        // Count the number of positive elements in the current vector\n        uint64_t num_positives = svcntp_b32(svptrue_b32(), positive_mask);\n\n        // Resize the result vector to accommodate new positives\n        size_t old_size = result.size();\n        result.resize(old_size + num_positives);\n\n        // Compress the positive values and store them into the result vector\n        svst1_f32(positive_mask, &result[old_size], vec);\n\n        // Move to the next block of elements\n        i += svcntw();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    size_t i = 0;\n    size_t length = l.size();\n\n    while (i < length) {\n        // Load a vector of floats from the input\n        svfloat32_t vec = svld1_f32(svptrue_b32(), &l[i]);\n\n        // Create a predicate mask for positive values\n        svbool_t positive_mask = svcmpgt_f32(svptrue_b32(), vec, 0.0f);\n\n        // Compress the vector to retain only positive values\n        svfloat32_t compressed = svcvt_f32_f32_m(positive_mask, vec);\n\n        // Store the compressed vector into a temporary buffer\n        float temp[svcntw()];\n        svst1_f32(positive_mask, temp, compressed);\n\n        // Count the number of positive elements\n        uint64_t count = svcntp_b32(svptrue_b32(), positive_mask);\n\n        // Append the positive values to the result vector\n        for (uint64_t j = 0; j < count; ++j) {\n            result.push_back(temp[j]);\n        }\n\n        // Move to the next block of data\n        i += svcntw();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t limit = svdiv_n_s64(0, n, 2);\n    int64_t sqrt_n = svsqrt_n_s64(0, n);\n\n    svint64_t vec_n = svdup_n_s64(n);\n    svbool_t pred = svwhilelt_b64(5, sqrt_n);\n    svint64_t vec_i = svindex_s64(5, 1);\n\n    while (svptest_any(svptrue_b64(), pred)) {\n        svint64_t mod = svrem_n_s64_z(pred, vec_n, vec_i);\n        if (svptest_any(svptrue_b64(), svcmpeq_n_s64(pred, mod, 0))) {\n            return false;\n        }\n        vec_i = svadd_n_s64_m(pred, vec_i, 1);\n        pred = svwhilelt_b64(svmaxv_s64(pred, vec_i), sqrt_n);\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t limit = svdiv_n_s64(svmul_n_s64(n, 1), 2);\n    svint64_t vec_n = svdup_n_s64(n);\n    svbool_t pred = svwhilelt_b64(5, limit);\n    svint64_t vec_i = svindex_s64(5, 1);\n\n    while (svptest_any(svptrue_b64(), pred)) {\n        svint64_t mod = svrem_n_s64_x(pred, vec_n, vec_i);\n        svbool_t is_zero = svcmpeq_n_s64(pred, mod, 0);\n        if (svptest_any(svptrue_b64(), is_zero)) {\n            return false;\n        }\n        vec_i = svadd_n_s64_m(pred, vec_i, 1);\n        pred = svwhilelt_b64(svmaxv_s64(pred, vec_i), limit);\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t limit = svdiv_n_s64(0, n, 2);\n    limit = svsqrt_n_s64(limit);\n\n    svint64_t vec_n = svdup_n_s64(n);\n    svbool_t pred = svwhilelt_b64(5, limit);\n    svint64_t vec_i = svindex_s64(5, 1);\n\n    while (svptest_any(svptrue_b64(), pred)) {\n        svbool_t divisible = svcmpeq_n_s64(pred, svrem_s64_x(pred, vec_n, vec_i), 0);\n        if (svptest_any(svptrue_b64(), divisible)) {\n            return false;\n        }\n        vec_i = svadd_n_s64_m(pred, vec_i, 1);\n        pred = svwhilelt_b64(svminv_s64(pred, vec_i), limit);\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t sqrt_n = __builtin_sqrt(n);\n    svint64_t vec_n = svdup_n_s64(n);\n    svbool_t pred = svwhilelt_b64(5, sqrt_n + 1);\n    svint64_t vec_i = svindex_s64(5, 6);\n\n    while (svptest_any(svptrue_b64(), pred)) {\n        svbool_t divisible = svcmpeq_n_s64(pred, svrem_s64_x(pred, vec_n, vec_i), 0);\n        if (svptest_any(svptrue_b64(), divisible)) {\n            return false;\n        }\n        vec_i = svadd_s64_x(pred, vec_i, svdup_n_s64(6));\n        pred = svwhilelt_b64(svminv_s64(pred, vec_i), sqrt_n + 1);\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t limit = svsqrt_s64_z(svptrue_b64(), n);\n    svint64_t vec_n = svdup_s64(n);\n    svbool_t pred = svwhilelt_b64(5, limit + 1);\n    svint64_t vec_i = svindex_s64(5, 1);\n\n    while (svptest_any(svptrue_b64(), pred)) {\n        svbool_t divisible = svcmpeq_s64(pred, svrem_s64_x(pred, vec_n, vec_i), 0);\n        if (svptest_any(svptrue_b64(), divisible)) {\n            return false;\n        }\n        vec_i = svadd_s64_m(pred, vec_i, svdup_s64(6));\n        pred = svwhilelt_b64(svminv_s64(pred, vec_i), limit + 1);\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s) {\n    size_t len = s.size();\n    std::string result = s;\n    bool has_letter = false;\n\n    // Check if the string contains any letters\n    for (char c : s) {\n        if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {\n            has_letter = true;\n            break;\n        }\n    }\n\n    if (!has_letter) {\n        // Reverse the string if no letters are found\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n\n    size_t i = 0;\n    while (i < len) {\n        // Load a vector of characters from the input string\n        svuint8_t vec = svld1sb_u8(svptrue_b8(), reinterpret_cast<const uint8_t*>(&s[i]));\n\n        // Create masks for lowercase and uppercase letters\n        svbool_t is_lower = svcmpge_n_u8(svptrue_b8(), vec, 'a');\n        is_lower = svcmple_n_u8(is_lower, vec, 'z');\n\n        svbool_t is_upper = svcmpge_n_u8(svptrue_b8(), vec, 'A');\n        is_upper = svcmple_n_u8(is_upper, vec, 'Z');\n\n        // Combine masks to identify letters\n        svbool_t is_letter = svorr_b_z(svptrue_b8(), is_lower, is_upper);\n\n        // Toggle case for letters\n        svuint8_t toggled = svsub_n_u8_m(vec, is_lower, 'a' - 'A');\n        toggled = svadd_n_u8_m(toggled, is_upper, 'a' - 'A');\n\n        // Select between original and toggled characters\n        vec = svsel_u8(is_letter, toggled, vec);\n\n        // Store the result back to the output string\n        svst1b_u8(svptrue_b8(), reinterpret_cast<uint8_t*>(&result[i]), vec);\n\n        // Move to the next block\n        i += svcntb();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s) {\n    size_t len = s.size();\n    std::string result(s);\n    bool has_letter = false;\n\n    // Check if the string contains any letters\n    for (char c : s) {\n        if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {\n            has_letter = true;\n            break;\n        }\n    }\n\n    if (!has_letter) {\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n\n    size_t i = 0;\n    while (i < len) {\n        // Load a vector of characters from the input string\n        svuint8_t vec = svld1sb_u8(svptrue_b8(), reinterpret_cast<const uint8_t*>(&s[i]));\n\n        // Create masks for lowercase and uppercase letters\n        svbool_t is_lower = svcmpge_n_u8(svptrue_b8(), vec, 'a');\n        is_lower = svcmple_n_u8(is_lower, vec, 'z');\n\n        svbool_t is_upper = svcmpge_n_u8(svptrue_b8(), vec, 'A');\n        is_upper = svcmple_n_u8(is_upper, vec, 'Z');\n\n        // Combine masks to identify letters\n        svbool_t is_letter = svorr_b_z(svptrue_b8(), is_lower, is_upper);\n\n        // Toggle case for letters\n        svuint8_t toggled = svsub_n_u8_x(is_lower, vec, 'a' - 'A');\n        toggled = svadd_n_u8_x(is_upper, vec, 'a' - 'A');\n\n        // Blend original and toggled characters based on letter mask\n        vec = svsel_u8(is_letter, toggled, vec);\n\n        // Store the result back into the output string\n        svst1b_u8(svptrue_b8(), reinterpret_cast<uint8_t*>(&result[i]), vec);\n\n        // Move to the next block\n        i += svcntb();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s) {\n    size_t len = s.size();\n    std::string result = s;\n    bool has_letter = false;\n\n    // Check if the string contains any letters\n    for (size_t i = 0; i < len; ++i) {\n        if ((s[i] >= 'a' && s[i] <= 'z') || (s[i] >= 'A' && s[i] <= 'Z')) {\n            has_letter = true;\n            break;\n        }\n    }\n\n    if (!has_letter) {\n        // Reverse the string if no letters are found\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n\n    size_t i = 0;\n    while (i < len) {\n        // Load a vector of characters from the input string\n        svuint8_t vec = svld1sb_u8(svptrue_b8(), reinterpret_cast<const uint8_t*>(&s[i]));\n\n        // Create masks for lowercase and uppercase letters\n        svbool_t is_lower = svcmpge_n_u8(svptrue_b8(), vec, 'a');\n        is_lower = svcmple_n_u8(is_lower, vec, 'z');\n\n        svbool_t is_upper = svcmpge_n_u8(svptrue_b8(), vec, 'A');\n        is_upper = svcmple_n_u8(is_upper, vec, 'Z');\n\n        // Toggle case for letters\n        svuint8_t toggled = svsub_n_u8_z(svptrue_b8(), vec, 'a' - 'A');\n        toggled = svadd_n_u8_m(toggled, is_lower, vec, 'A' - 'a');\n\n        // Combine results\n        vec = svsel_u8(is_lower, toggled, vec);\n        vec = svsel_u8(is_upper, toggled, vec);\n\n        // Store the result back to the output string\n        svst1b_u8(svptrue_b8(), reinterpret_cast<uint8_t*>(&result[i]), vec);\n\n        i += svcntb();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s) {\n    size_t len = s.size();\n    std::string result = s;\n\n    // Check if the string contains any letters\n    bool has_letters = false;\n    for (size_t i = 0; i < len; ++i) {\n        if ((s[i] >= 'a' && s[i] <= 'z') || (s[i] >= 'A' && s[i] <= 'Z')) {\n            has_letters = true;\n            break;\n        }\n    }\n\n    if (!has_letters) {\n        // Reverse the string if no letters are present\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n\n    // Process using SVE intrinsics\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b8(i, len);\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t vec = svld1(pg, reinterpret_cast<const uint8_t*>(&s[i]));\n\n        // Create masks for lowercase and uppercase letters\n        svbool_t is_lower = svcmpge(pg, vec, svdup_u8('a'));\n        is_lower = svcmpeq(pg, svand_z(pg, is_lower, svcmple(pg, vec, svdup_u8('z'))), svdup_n_u8(1));\n\n        svbool_t is_upper = svcmpge(pg, vec, svdup_u8('A'));\n        is_upper = svcmpeq(pg, svand_z(pg, is_upper, svcmple(pg, vec, svdup_u8('Z'))), svdup_n_u8(1));\n\n        // Toggle case for letters\n        svuint8_t toggled = svadd_z(pg, vec, svdup_u8(is_lower ? -32 : 32));\n        vec = svsel(pg, toggled, vec);\n\n        // Store the result back to memory\n        svst1(pg, reinterpret_cast<uint8_t*>(&result[i]), vec);\n\n        i += svcntb();\n        pg = svwhilelt_b8(i, len);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s) {\n    size_t len = s.size();\n    std::string result(s);\n    bool has_letter = false;\n\n    // Check if the string contains any letters\n    for (char c : s) {\n        if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {\n            has_letter = true;\n            break;\n        }\n    }\n\n    if (!has_letter) {\n        // Reverse the string if no letters are found\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n\n    size_t i = 0;\n    while (i < len) {\n        // Load a vector of characters from the input string\n        svuint8_t vec = svld1sb_u8(svptrue_b8(), reinterpret_cast<const uint8_t*>(&s[i]));\n\n        // Create masks for lowercase and uppercase letters\n        svbool_t is_lower = svcmpge_n_u8(svptrue_b8(), vec, 'a');\n        is_lower = svcmple_n_u8(is_lower, vec, 'z');\n\n        svbool_t is_upper = svcmpge_n_u8(svptrue_b8(), vec, 'A');\n        is_upper = svcmple_n_u8(is_upper, vec, 'Z');\n\n        // Toggle case for letters\n        svuint8_t toggled = svsub_n_u8_z(svptrue_b8(), vec, 'a' - 'A');\n        toggled = svadd_n_u8_m(toggled, is_upper, vec, 'a' - 'A');\n        vec = svsel(is_lower, toggled, vec);\n        vec = svsel(is_upper, toggled, vec);\n\n        // Store the result back to the output string\n        svst1b_u8(svptrue_b8(), reinterpret_cast<uint8_t*>(&result[i]), vec);\n\n        i += svcntb();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    int n = l.size();\n    std::vector<int> result = l;\n\n    // Extract elements at indices divisible by 3\n    std::vector<int> divisible_by_three;\n    for (int i = 0; i < n; i += 3) {\n        divisible_by_three.push_back(l[i]);\n    }\n\n    // Sort the extracted elements\n    std::sort(divisible_by_three.begin(), divisible_by_three.end());\n\n    // Replace the original indices divisible by 3 with sorted values\n    int j = 0;\n    for (int i = 0; i < n; i += 3) {\n        result[i] = divisible_by_three[j++];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    int n = l.size();\n    std::vector<int> result = l;\n\n    // Extract elements at indices divisible by 3\n    std::vector<int> divisible_by_three;\n    for (int i = 0; i < n; i += 3) {\n        divisible_by_three.push_back(l[i]);\n    }\n\n    // Sort the extracted elements\n    std::sort(divisible_by_three.begin(), divisible_by_three.end());\n\n    // Replace the original indices divisible by 3 with sorted values\n    int j = 0;\n    for (int i = 0; i < n; i += 3) {\n        result[i] = divisible_by_three[j++];\n    }\n\n    // SVE implementation for parallelism\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active lanes\n    svint32_t vec_result = svld1_s32(pg, result.data()); // Load result into SVE vector\n\n    // Process in parallel using SVE intrinsics\n    for (int i = 0; i < n; i += svcntw()) {\n        svbool_t pg_iter = svwhilelt_b32(i, n); // Update predicate for current iteration\n        svint32_t vec_l = svld1_s32(pg_iter, l.data() + i); // Load input vector\n        svint32_t vec_indices = svindex_s32(0, 1); // Generate index vector\n        svbool_t mask = svcmpeq_s32(pg_iter, svrem_s32_z(pg_iter, vec_indices, 3), 0); // Mask for indices divisible by 3\n\n        // Replace values at indices divisible by 3 with sorted values\n        vec_result = svsel_s32(mask, svld1_s32(pg_iter, result.data() + i), vec_l);\n        svst1_s32(pg_iter, result.data() + i, vec_result); // Store back to result\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    int n = l.size();\n    std::vector<int> result = l;\n\n    // Extract elements at indices divisible by 3\n    std::vector<int> divisible_by_three;\n    for (int i = 0; i < n; i += 3) {\n        divisible_by_three.push_back(l[i]);\n    }\n\n    // Sort the extracted elements\n    std::sort(divisible_by_three.begin(), divisible_by_three.end());\n\n    // Replace the original indices divisible by 3 with sorted values\n    int j = 0;\n    for (int i = 0; i < n; i += 3) {\n        result[i] = divisible_by_three[j++];\n    }\n\n    // SVE implementation for parallelism\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active lanes\n    svint32_t vec_l = svld1(pg, l.data()); // Load input vector\n    svint32_t vec_result = svld1(pg, result.data()); // Load result vector\n\n    // Iterate over the vector in chunks of SVE vector length\n    for (int i = 0; i < n; i += svcntw()) {\n        svbool_t pred = svwhilelt_b32(i, n); // Update predicate for remaining elements\n        svint32_t indices = svindex_s32(i, 1); // Generate indices starting from i\n        svbool_t mask = svcmpeq_n_s32(pred, svrem_s32_z(pred, indices, 3), 0); // Mask for indices divisible by 3\n\n        // Replace elements at indices divisible by 3 with sorted values\n        vec_result = svsel(mask, svld1(pred, &result[i]), vec_l);\n    }\n\n    // Store the final result back to the output vector\n    svst1(pg, result.data(), vec_result);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    int n = l.size();\n    std::vector<int> result = l;\n\n    // Extract elements at indices divisible by 3\n    std::vector<int> divisible_by_three;\n    for (int i = 0; i < n; i += 3) {\n        divisible_by_three.push_back(l[i]);\n    }\n\n    // Sort the extracted elements\n    std::sort(divisible_by_three.begin(), divisible_by_three.end());\n\n    // Replace the original indices divisible by 3 with sorted values\n    int j = 0;\n    for (int i = 0; i < n; i += 3) {\n        result[i] = divisible_by_three[j++];\n    }\n\n    // Use SVE to process the vector in parallel\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active lanes\n    svint32_t vec_result = svld1_s32(pg, result.data()); // Load result into SVE register\n\n    // Process the vector (example: identity operation here)\n    svst1_s32(pg, result.data(), vec_result); // Store back to memory\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t size = l.size();\n    std::vector<int> result = l;\n\n    // Extract elements at indices divisible by 3\n    std::vector<int> divisible_by_three;\n    for (size_t i = 0; i < size; i += 3) {\n        divisible_by_three.push_back(l[i]);\n    }\n\n    // Sort the extracted elements\n    std::sort(divisible_by_three.begin(), divisible_by_three.end());\n\n    // Replace the original elements at indices divisible by 3 with sorted values\n    size_t sorted_index = 0;\n    for (size_t i = 0; i < size; i += 3) {\n        result[i] = divisible_by_three[sorted_index++];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nfloat max_element_simd(std::vector<float> l) {\n    float max_val = l[0];\n    size_t i = 0;\n    size_t n = l.size();\n\n    svbool_t pg = svwhilelt_b32(i, n);\n    svfloat32_t vmax = svdup_f32(max_val);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t v = svld1_f32(pg, &l[i]);\n        vmax = svmax_f32_z(pg, vmax, v);\n        i += svcntw();\n        pg = svwhilelt_b32(i, n);\n    }\n\n    max_val = svmaxv_f32(svptrue_b32(), vmax);\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nfloat max_element_simd(std::vector<float> l) {\n    size_t size = l.size();\n    float *data = l.data();\n    size_t i = 0;\n\n    // Initialize the maximum value with the first element\n    svfloat32_t vmax = svld1rq_f32(svptrue_b32(), &data[0]);\n\n    // Process elements in chunks of SVE vector length\n    for (i = svcntw(); i <= size; i += svcntw()) {\n        svfloat32_t vec = svld1_f32(svptrue_b32(), &data[i - svcntw()]);\n        vmax = svmax_f32_z(svptrue_b32(), vmax, vec);\n    }\n\n    // Reduce the vector to find the maximum value\n    float max_val = svmaxv_f32(svptrue_b32(), vmax);\n\n    // Handle any remaining elements\n    for (; i < size; ++i) {\n        if (data[i] > max_val) {\n            max_val = data[i];\n        }\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nfloat max_element_simd(std::vector<float> l) {\n    float max_val = l[0];\n    size_t i = 0;\n    size_t n = l.size();\n\n    // Calculate the vector length\n    size_t vl = svcntw();\n\n    // Initialize the maximum value with the first element\n    svfloat32_t vmax = svdup_f32(max_val);\n\n    // Process elements in chunks of SVE vector length\n    for (; i + vl <= n; i += vl) {\n        svfloat32_t v = svld1_f32(svptrue_b32(), &l[i]);\n        vmax = svmax_f32_z(svptrue_b32(), vmax, v);\n    }\n\n    // Reduce the vector to find the maximum scalar value\n    max_val = svmaxv_f32(svptrue_b32(), vmax);\n\n    // Process any remaining elements\n    for (; i < n; ++i) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nfloat max_element_simd(std::vector<float> l) {\n    float max_val = l[0];\n    size_t i = 0;\n    size_t n = l.size();\n\n    svbool_t pg = svwhilelt_b32(i, n);\n    svfloat32_t vec_max = svdup_f32(max_val);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vec = svld1_f32(pg, &l[i]);\n        vec_max = svmax_f32_z(pg, vec_max, vec);\n        i += svcntw();\n        pg = svwhilelt_b32(i, n);\n    }\n\n    max_val = svmaxv_f32(svptrue_b32(), vec_max);\n\n    for (; i < n; ++i) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nfloat max_element_simd(std::vector<float> l) {\n    float max_val = l[0];\n    size_t i = 0;\n    size_t n = l.size();\n\n    svbool_t pg = svwhilelt_b32(i, n);\n    svfloat32_t vec_max = svdup_f32(max_val);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vec = svld1_f32(pg, &l[i]);\n        vec_max = svmax_f32_z(pg, vec_max, vec);\n        i += svcntw();\n        pg = svwhilelt_b32(i, n);\n    }\n\n    max_val = svmaxv_f32(svptrue_b32(), vec_max);\n\n    for (; i < n; ++i) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active lanes\n    svuint32_t vec = svindex_u32(0, 1); // Vector of indices [0, 1, 2, ..., VL-1]\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t divisible_by_11 = svcmpeq(pg, svmod_u32_x(pg, vec, 11), 0);\n        svuint32_t divisible_by_13 = svcmpeq(pg, svmod_u32_x(pg, vec, 13), 0);\n        svbool_t divisible = svorr_b_z(pg, divisible_by_11, divisible_by_13);\n\n        svuint32_t digits = vec;\n        int local_count = 0;\n\n        while (svptest_any(svptrue_b32(), pg)) {\n            svuint32_t last_digit = svand_u32_x(pg, digits, 7);\n            svbool_t is_seven = svcmpeq(pg, last_digit, 7);\n            local_count += svcntp_b32(svptrue_b32(), svand_b_z(pg, divisible, is_seven));\n\n            digits = svdiv_u32_x(pg, digits, 10);\n            pg = svwhilelt_b32(0, svmaxv_u32(pg, digits));\n        }\n\n        count += local_count;\n        vec = svadd_u32_x(pg, vec, svlen_u32(vec));\n        pg = svwhilelt_b32(svmaxv_u32(pg, vec), n);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active lanes\n    svuint32_t vec = svindex_u32(0, 1); // Vector of indices [0, 1, 2, ..., VL-1]\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t divisible_by_11 = svcmpeq(pg, svrem_u32_x(pg, vec, 11), 0);\n        svuint32_t divisible_by_13 = svcmpeq(pg, svrem_u32_x(pg, vec, 13), 0);\n        svbool_t divisible = svorr_b_z(pg, divisible_by_11, divisible_by_13);\n\n        svuint32_t digits = vec;\n        int local_count = 0;\n\n        for (int i = 0; i < 10; ++i) {\n            svuint32_t digit = svand_u32_z(pg, digits, 7);\n            svbool_t is_seven = svcmpeq(pg, digit, 7);\n            local_count += svcntp_b32(pg, is_seven);\n            digits = svlsr_n_u32_z(pg, digits, 1);\n        }\n\n        count += local_count;\n\n        vec = svadd_u32_z(pg, vec, svlen_u32(vec));\n        pg = svwhilelt_b32(svlasta(pg, vec), n);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active lanes\n    svuint32_t vec = svindex_u32(0, 1); // Vector of indices [0, 1, 2, ..., VL-1]\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t divisible_by_11 = svcmpeq(pg, svrem_u32_x(pg, vec, 11), 0);\n        svuint32_t divisible_by_13 = svcmpeq(pg, svrem_u32_x(pg, vec, 13), 0);\n        svuint32_t divisible = svorr_z(pg, divisible_by_11, divisible_by_13);\n\n        svuint32_t digits = vec;\n        int local_count = 0;\n\n        for (int i = 0; i < 10; ++i) {\n            svuint32_t is_seven = svcmpeq(pg, svand_u32_x(pg, digits, 0xF), 7);\n            local_count += svcntp_b32(pg, svand_z(pg, divisible, is_seven));\n            digits = svlsr_n_u32_x(pg, digits, 4);\n        }\n\n        count += local_count;\n\n        // Update predicate and vector for the next iteration\n        vec = svadd_u32_x(pg, vec, svlen_u32(vec));\n        pg = svwhilelt_b32(svmaxv_u32(pg, vec), n);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active lanes\n    svuint32_t vec = svindex_u32(0, 1); // Vector of indices [0, 1, 2, ..., n-1]\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t divisible_by_11 = svcmpeq(pg, svmod_u32_x(pg, vec, 11), 0);\n        svuint32_t divisible_by_13 = svcmpeq(pg, svmod_u32_x(pg, vec, 13), 0);\n        svbool_t divisible = svorr_b_z(pg, divisible_by_11, divisible_by_13);\n\n        svuint32_t digits = vec;\n        svuint32_t digit_mask = svdup_u32(0xF);\n        svuint32_t seven_count = svdup_u32(0);\n\n        for (int i = 0; i < 10; ++i) { // Process each digit\n            svuint32_t last_digit = svand_u32_x(pg, digits, digit_mask);\n            svbool_t is_seven = svcmpeq(pg, last_digit, 7);\n            seven_count = svadd_u32_x(pg, seven_count, svsel_u32(is_seven, svdup_u32(1), svdup_u32(0)));\n            digits = svlsr_n_u32_x(pg, digits, 4);\n        }\n\n        seven_count = svand_u32_x(pg, seven_count, svdup_u32(divisible));\n        count += svaddv_u32(pg, seven_count);\n\n        vec = svadd_u32_x(pg, vec, svdup_u32(svlen_u32(vec)));\n        pg = svwhilelt_b32(svlasta(pg, vec), n);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for values less than n\n    svuint32_t vec = svindex_u32(0, 1); // Vector of indices [0, 1, 2, ..., VL-1]\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t divisible_by_11 = svcmpeq(pg, svrem_u32_x(pg, vec, 11), 0);\n        svuint32_t divisible_by_13 = svcmpeq(pg, svrem_u32_x(pg, vec, 13), 0);\n        svbool_t divisible = svorr_b_z(pg, divisible_by_11, divisible_by_13);\n\n        svuint32_t digits = vec;\n        do {\n            svuint32_t last_digit = svand_u32_x(pg, digits, 0xF);\n            svbool_t is_seven = svcmpeq(pg, last_digit, 7);\n            count += svcntp_b32(pg, svand_b_z(pg, divisible, is_seven));\n            digits = svlsr_n_u32_x(pg, digits, 4);\n        } while (svptest_any(pg, svcmpne(pg, digits, 0)));\n\n        vec = svadd_u32_x(pg, vec, svlen_u32(vec)); // Increment vector by vector length\n        pg = svwhilelt_b32(svlasta(pg, vec), n); // Update predicate\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t size = l.size();\n    std::vector<float> even_values;\n\n    // Extract even-indexed elements\n    for (size_t i = 0; i < size; i += 2) {\n        even_values.push_back(l[i]);\n    }\n\n    // Sort the even-indexed elements\n    std::sort(even_values.begin(), even_values.end());\n\n    // Reintegrate sorted even-indexed elements back into the original vector using SVE\n    size_t even_idx = 0;\n    svbool_t pg = svwhilelt_b32(0, size); // Predicate for active lanes\n\n    for (size_t i = 0; i < size; i += svcntw()) {\n        svfloat32_t vec = svld1(pg, &l[i]); // Load vector from memory\n\n        // Create a predicate for even indices\n        svbool_t even_pred = svcmpeq_n_s32(pg, svindex_s32(i, 1), 0);\n\n        // Replace even-indexed elements with sorted values\n        svfloat32_t sorted_even = svld1(pg, &even_values[even_idx]);\n        vec = svsel_f32(even_pred, sorted_even, vec);\n\n        svst1(pg, &l[i], vec); // Store the updated vector back to memory\n\n        even_idx += svcntp_b32(pg, even_pred); // Update even index count\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    std::vector<float> result = l;\n\n    // Extract even indices into a separate vector\n    std::vector<float> even_elements;\n    for (size_t i = 0; i < n; i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    // Sort the even elements\n    std::sort(even_elements.begin(), even_elements.end());\n\n    // Use SVE to merge sorted even elements back into the result\n    size_t even_idx = 0;\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for the vector length\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        svfloat32_t vec = svld1(pg, &l[i]); // Load vector from memory\n        svbool_t even_mask = svcmpeq_n_s32(pg, svindex_s32(0, 1), 0); // Mask for even indices\n\n        // Replace even indices with sorted values\n        svfloat32_t sorted_evens = svld1(pg, &even_elements[even_idx]);\n        vec = svsel_f32(even_mask, sorted_evens, vec);\n\n        svst1(pg, &result[i], vec); // Store the updated vector back to memory\n        even_idx += svcntp_b32(pg, even_mask); // Increment even index count\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    std::vector<float> even_values;\n    \n    // Extract even-indexed elements\n    for (size_t i = 0; i < n; i += 2) {\n        even_values.push_back(l[i]);\n    }\n\n    // Sort the even-indexed elements\n    std::sort(even_values.begin(), even_values.end());\n\n    // Reintegrate sorted even-indexed elements back into the original vector using SVE\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active lanes\n    size_t i = 0;\n    size_t even_idx = 0;\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vec = svld1(pg, &l[i]); // Load a vector of elements\n        svbool_t even_pred = svcmpeq_b32(pg, svindex_u32(i, 1), svdup_u32(0)); // Predicate for even indices\n\n        // Replace even indices with sorted values\n        vec = svsel_f32(even_pred, svld1rq(pg, &even_values[even_idx]), vec);\n        svst1(pg, &l[i], vec); // Store the updated vector back to memory\n\n        i += svcntw();\n        even_idx += svcntp_b32(svptrue_b32(), even_pred);\n        pg = svwhilelt_b32(i, n); // Update predicate for remaining elements\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t size = l.size();\n    std::vector<float> result = l;\n\n    // Extract even-indexed elements\n    std::vector<float> even_elements;\n    for (size_t i = 0; i < size; i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    // Sort the even-indexed elements\n    std::sort(even_elements.begin(), even_elements.end());\n\n    // Replace the even-indexed positions in the result with sorted values\n    size_t even_idx = 0;\n    for (size_t i = 0; i < size; i += 2) {\n        result[i] = even_elements[even_idx++];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t size = l.size();\n    size_t vl = svcntw(); // Get the vector length for float\n\n    // Create a predicate for even indices\n    svbool_t even_pred = svwhilelt_b32(0, size); // Predicate for all elements\n    svbool_t odd_pred = svnot_b_z(even_pred, even_pred); // Invert the predicate for odd indices\n\n    // Allocate temporary storage for even indices\n    std::vector<float> even_values((size + 1) / 2);\n\n    // Extract even-indexed elements using SVE\n    size_t even_idx = 0;\n    for (size_t i = 0; i < size; i += vl) {\n        svbool_t pred = svwhilelt_b32(i, size);\n        svfloat32_t vec = svld1_f32(pred, &l[i]);\n        svbool_t even_mask = svbrkb_b_z(pred, svptrue_b32());\n        svst1_f32(svwhilelt_b32(even_idx, even_values.size()), &even_values[even_idx], svcompact_f32(even_mask, vec));\n        even_idx += svcntp_b32(svptrue_b32(), even_mask);\n    }\n\n    // Sort the extracted even-indexed elements\n    std::sort(even_values.begin(), even_values.end());\n\n    // Reinsert sorted even-indexed elements back into the original vector\n    even_idx = 0;\n    for (size_t i = 0; i < size; i += vl) {\n        svbool_t pred = svwhilelt_b32(i, size);\n        svfloat32_t vec = svld1_f32(pred, &l[i]);\n        svbool_t even_mask = svbrkb_b_z(pred, svptrue_b32());\n        svfloat32_t sorted_evens = svld1_f32(svwhilelt_b32(even_idx, even_values.size()), &even_values[even_idx]);\n        vec = svsel_f32(even_mask, sorted_evens, vec);\n        svst1_f32(pred, &l[i], vec);\n        even_idx += svcntp_b32(svptrue_b32(), even_mask);\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 3) return false;\n\n    svint32_t vec_a, vec_b, vec_c;\n    svbool_t pred;\n\n    for (size_t i = 0; i < n - 2; ++i) {\n        for (size_t j = i + 1; j < n - 1; ++j) {\n            int sum_ij = l[i] + l[j];\n            size_t k = j + 1;\n\n            while (k <= n - svcntw()) {\n                pred = svwhilelt_b32(k, n);\n                vec_a = svld1_s32(pred, &l[k]);\n                vec_b = svdup_s32(sum_ij);\n                vec_c = svadd_s32_z(pred, vec_a, vec_b);\n\n                if (svptest_any(svptrue_b32(), svcmpeq_n_s32(pred, vec_c, 0))) {\n                    return true;\n                }\n                k += svcntw();\n            }\n\n            for (; k < n; ++k) {\n                if (sum_ij + l[k] == 0) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 3) return false;\n\n    svint32_t vec_a, vec_b, vec_c;\n    svbool_t pred = svwhilelt_b32(0, n);\n\n    for (size_t i = 0; i < n - 2; ++i) {\n        for (size_t j = i + 1; j < n - 1; ++j) {\n            int target = -(l[i] + l[j]);\n            size_t k = j + 1;\n\n            while (k < n) {\n                size_t vl = svcntw();\n                svbool_t loop_pred = svwhilelt_b32(k, n);\n\n                svint32_t vec_target = svdup_s32(target);\n                svint32_t vec_k = svld1_s32(loop_pred, &l[k]);\n\n                svbool_t match = svcmpeq(svptrue_b32(), vec_k, vec_target);\n                if (svptest_any(svptrue_b32(), match)) {\n                    return true;\n                }\n\n                k += vl;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 3) return false;\n\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active lanes\n\n    for (size_t i = 0; i < n - 2; ++i) {\n        int vi = l[i];\n        for (size_t j = i + 1; j < n - 1; ++j) {\n            int vj = l[j];\n            int target = -(vi + vj);\n\n            size_t k = j + 1;\n            while (k < n) {\n                svint32_t vec = svld1(pg, &l[k]); // Load vector of elements\n                svbool_t match = svcmpeq(pg, vec, target); // Compare with target\n                if (svptest_any(svptrue_b32(), match)) {\n                    return true; // Found a triplet\n                }\n                k += svcntw(); // Move to next chunk\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 3) return false;\n\n    svint32_t va, vb, vc, vsum;\n    svbool_t pg = svwhilelt_b32(0, n);\n\n    for (size_t i = 0; i < n - 2; ++i) {\n        int a = l[i];\n        for (size_t j = i + 1; j < n - 1; ++j) {\n            int b = l[j];\n            size_t k = j + 1;\n\n            while (k < n) {\n                size_t vl = svcntw();\n                size_t limit = k + vl <= n ? k + vl : n;\n\n                svbool_t pg_k = svwhilelt_b32(k, limit);\n                vc = svld1(pg_k, &l[k]);\n\n                va = svdup_n_s32(a);\n                vb = svdup_n_s32(b);\n                vsum = svadd_s32_z(pg_k, va, vb);\n                vsum = svadd_s32_z(pg_k, vsum, vc);\n\n                svbool_t zero_mask = svcmpeq(pg_k, vsum, svdup_n_s32(0));\n                if (svptest_any(pg_k, zero_mask)) {\n                    return true;\n                }\n\n                k += vl;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 3) return false;\n\n    svint32_t vec_a, vec_b, vec_c;\n    svbool_t pred = svwhilelt_b32(0, n);\n\n    for (size_t i = 0; i < n - 2; ++i) {\n        for (size_t j = i + 1; j < n - 1; ++j) {\n            int target = -(l[i] + l[j]);\n            size_t k = j + 1;\n\n            while (k < n) {\n                size_t vl = svcntw();\n                svbool_t loop_pred = svwhilelt_b32(k, n);\n\n                svint32_t vec_target = svdup_s32(target);\n                svint32_t vec_k = svld1_s32(loop_pred, &l[k]);\n\n                svbool_t match = svcmpeq(svptrue_b32(), vec_k, vec_target);\n                if (svptest_any(svptrue_b32(), match)) {\n                    return true;\n                }\n\n                k += vl;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    std::vector<int> result(l.size());\n    size_t i = 0;\n    size_t len = l.size();\n\n    svbool_t pg = svwhilelt_b32(i, len);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec = svld1(pg, &l[i]);\n        svint32_t inc_vec = svadd_n(vec, 1);\n        svst1(pg, &result[i], inc_vec);\n        i += svcntw();\n        pg = svwhilelt_b32(i, len);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    std::vector<int> result(l.size());\n    size_t i = 0;\n    size_t len = l.size();\n\n    svbool_t pg = svwhilelt_b32(i, len);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec = svld1(pg, &l[i]);\n        svint32_t inc_vec = svadd_n(vec, 1);\n        svst1(pg, &result[i], inc_vec);\n        i += svcntw();\n        pg = svwhilelt_b32(i, len);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t size = l.size();\n    std::vector<int> result(size);\n\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec = svld1(pg, &l[i]);\n        vec = svadd_n(vec, 1);\n        svst1(pg, &result[i], vec);\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    std::vector<int> result(l.size());\n    size_t i = 0;\n    size_t len = l.size();\n\n    svbool_t pg = svwhilelt_b32(i, len);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec = svld1_s32(pg, &l[i]);\n        svint32_t inc_vec = svadd_n_s32(pg, vec, 1);\n        svst1_s32(pg, &result[i], inc_vec);\n        i += svcntw();\n        pg = svwhilelt_b32(i, len);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t size = l.size();\n    std::vector<int> result(size);\n\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec = svld1_s32(pg, &l[i]);\n        vec = svadd_n_s32(pg, vec, 1);\n        svst1_s32(pg, &result[i], vec);\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    size_t size = l.size();\n    if (size < 2) return false;\n\n    svbool_t pg =svptrue_b32();\n    svint32_t vec1, vec2;\n    int i, j;\n\n    for (i = 0; i <= size - svcntw(); i += svcntw()) {\n        vec1 = svld1(pg, &l[i]);\n        for (j = i + svcntw(); j <= size - svcntw(); j += svcntw()) {\n            vec2 = svld1(pg, &l[j]);\n            svint32_t sum = svadd(vec1, vec2);\n            svbool_t zero_mask = svcmpeq(pg, sum, 0);\n            if (svptest_any(pg, zero_mask)) {\n                return true;\n            }\n        }\n\n        // Handle remaining elements in the vector for the inner loop\n        for (; j < size; ++j) {\n            svint32_t broadcast_val = svdup_n_s32(l[j]);\n            svint32_t sum = svadd(vec1, broadcast_val);\n            svbool_t zero_mask = svcmpeq(pg, sum, 0);\n            if (svptest_any(pg, zero_mask)) {\n                return true;\n            }\n        }\n    }\n\n    // Handle remaining elements in the vector for the outer loop\n    for (; i < size; ++i) {\n        vec1 = svdup_n_s32(l[i]);\n        for (j = i + 1; j < size; ++j) {\n            vec2 = svdup_n_s32(l[j]);\n            svint32_t sum = svadd(vec1, vec2);\n            svbool_t zero_mask = svcmpeq(pg, sum, 0);\n            if (svptest_any(pg, zero_mask)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    size_t size = l.size();\n    if (size < 2) return false;\n\n    svbool_t pg = svwhilelt_b32(0, size); // Predicate for active lanes\n    svint32_t vec = svld1(pg, l.data()); // Load the input vector into an SVE register\n\n    for (size_t i = 0; i < size; ++i) {\n        int current = l[i];\n        svint32_t neg_current = svdup_n_s32(-current); // Broadcast -current to all lanes\n        svbool_t match = svcmpeq(pg, vec, neg_current); // Compare each element with -current\n        if (svptest_any(svptrue_b32(), match)) { // Check if any lane matches\n            // Ensure the match is not the same element\n            svbool_t not_self = svcmpne(pg, svindex_s32(0, 1), i);\n            svbool_t valid_match = svand_z(pg, match, not_self);\n            if (svptest_any(svptrue_b32(), valid_match)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    size_t size = l.size();\n    if (size < 2) return false;\n\n    svbool_t pg = svwhilelt_b32(0, size); // Predicate for active lanes\n    svint32_t vec = svld1(pg, l.data()); // Load the input vector into an SVE register\n\n    for (size_t i = 0; i < size; ++i) {\n        int current = l[i];\n        svint32_t neg_current = svdup_n_s32(-current); // Broadcast -current to all lanes\n        svbool_t match = svcmpeq(pg, vec, neg_current); // Compare each element with -current\n        if (svptest_any(svptrue_b32(), match)) { // Check if any lane matches\n            // Ensure the match is not the same element\n            svbool_t not_self = svcmpne(pg, svindex_s32(0, 1), i);\n            svbool_t valid_match = svand_z(pg, match, not_self);\n            if (svptest_any(svptrue_b32(), valid_match)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    size_t size = l.size();\n    if (size < 2) return false;\n\n    svbool_t pg = svwhilelt_b32(0, size); // Predicate for active lanes\n    svint32_t vec = svld1(pg, l.data()); // Load the input vector into an SVE register\n\n    for (size_t i = 0; i < size; ++i) {\n        int current = l[i];\n        svint32_t neg_current = svdup_n_s32(-current); // Broadcast -current to all lanes\n        svbool_t match = svcmpeq(pg, vec, neg_current); // Compare each element with -current\n        if (svptest_any(svptrue_b32(), match)) { // Check if any lane matches\n            // Ensure the match is not the same element\n            svbool_t not_self = svcmpne(pg, svindex_s32(0, 1), svdup_n_s32(i));\n            svbool_t valid_match = svand_z(pg, match, not_self);\n            if (svptest_any(svptrue_b32(), valid_match)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    size_t size = l.size();\n    if (size < 2) return false;\n\n    svbool_t pg = svwhilelt_b32(0, size); // Predicate for active lanes\n    svint32_t vec = svld1(pg, l.data()); // Load the input vector into an SVE register\n\n    for (size_t i = 0; i < size; ++i) {\n        int current = l[i];\n        svint32_t neg_current = svdup_n_s32(-current); // Broadcast -current to all lanes\n        svbool_t match = svcmpeq(pg, vec, neg_current); // Compare each element with -current\n        if (svptest_any(svptrue_b32(), match)) { // Check if any lane matches\n            // Ensure the match is not the same element\n            svbool_t not_self = svcmpne(pg, svindex_s32(0, 1), i);\n            svbool_t valid_match = svand_z(pg, match, not_self);\n            if (svptest_any(svptrue_b32(), valid_match)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    std::string result;\n    svint64_t vec_x = svdup_n_s64(x);\n    svint8_t vec_base = svdup_n_s8(base);\n    svbool_t pred = svwhilelt_b64(0, 1);\n\n    while (svptest_any(svptrue_b64(), pred)) {\n        svint64_t quotient = svdiv_n_s64_z(pred, vec_x, base);\n        svint64_t remainder = svsub_n_s64_z(pred, vec_x, svmul_n_s64_z(pred, quotient, base));\n        int64_t rem_scalar = svlasta_s64(pred, remainder);\n        result.push_back('0' + rem_scalar);\n        vec_x = quotient;\n        pred = svcmpne_n_s64(pred, vec_x, 0);\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    std::string result;\n    svint64_t vec_x = svdup_n_s64(x);\n    svint64_t vec_base = svdup_n_s64(base);\n    svbool_t pred = svwhilelt_b64(0, 1);\n\n    while (svptest_any(svptrue_b64(), pred)) {\n        svint64_t remainder = svmod_n_s64_z(pred, vec_x, base);\n        int64_t scalar_remainder = svlasta_s64(pred, remainder);\n        result.push_back('0' + scalar_remainder);\n\n        vec_x = svdivr_n_s64_z(pred, vec_x, base);\n        pred = svcmpne_n_s64(pred, vec_x, 0);\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    std::string result;\n    svint64_t vec_x = svdup_n_s64(x);\n    svint8_t vec_base = svdup_n_s8(base);\n    svbool_t pred = svwhilelt_b64(0, 1);\n\n    while (svptest_any(svptrue_b64(), pred)) {\n        svint64_t quotient = svdiv_s64_z(pred, vec_x, svreinterpret_s64_s8(vec_base));\n        svint64_t remainder = svsub_s64_z(pred, vec_x, svmul_s64_z(pred, quotient, svreinterpret_s64_s8(vec_base)));\n        int64_t rem_scalar = svlasta_s64(pred, remainder);\n        result.push_back('0' + rem_scalar);\n        vec_x = quotient;\n        pred = svcmpne_n_s64(svptrue_b64(), vec_x, 0);\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    std::string result;\n    svint64_t vec_x = svdup_n_s64(x);\n    svint8_t vec_base = svdup_n_s8(base);\n    svbool_t pred = svwhilelt_b64(0, 1);\n\n    while (svptest_any(svptrue_b64(), pred)) {\n        svint64_t quotient = svdiv_n_s64_z(pred, vec_x, base);\n        svint64_t remainder = svsub_n_s64_z(pred, vec_x, svmul_n_s64_z(pred, quotient, base));\n        int64_t rem_scalar = svlasta_s64(pred, remainder);\n        result.push_back('0' + rem_scalar);\n        vec_x = quotient;\n        pred = svcmpne_n_s64(pred, vec_x, 0);\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    std::string result;\n    svint64_t vec_x = svdup_n_s64(x);\n    svint8_t vec_base = svdup_n_s8(base);\n    svbool_t pred = svwhilelt_b64(0, 1);\n\n    while (svptest_any(svptrue_b64(), pred)) {\n        svint64_t quotient = svdiv_n_s64_z(pred, vec_x, base);\n        svint64_t remainder = svsub_n_s64_z(pred, vec_x, svmul_n_s64_z(pred, quotient, base));\n        int64_t rem_scalar = svlasta_s64(pred, remainder);\n        result.push_back('0' + rem_scalar);\n        vec_x = quotient;\n        pred = svcmpne_n_s64(svptrue_b64(), vec_x, 0);\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    size_t n = text.length();\n    if (n == 0) return true;\n\n    const char* data = text.data();\n    size_t vl = svcntb(); // Get the vector length in bytes\n\n    svbool_t all_active = svptrue_b8();\n    bool is_palindrome = true;\n\n    for (size_t i = 0; i < n / 2; i += vl) {\n        svbool_t pred = svwhilelt_b8(i, n / 2);\n        svuint8_t vec1 = svld1sb(pred, data + i);\n        svuint8_t vec2 = svld1sb(pred, data + n - i - svcntb());\n\n        vec2 = svrev_b8(vec2);\n\n        svbool_t cmp = svcmpeq(pred, vec1, vec2);\n        if (!svptest_all(all_active, cmp)) {\n            is_palindrome = false;\n            break;\n        }\n    }\n\n    return is_palindrome;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    size_t n = text.length();\n    if (n == 0) return true;\n\n    const char* data = text.data();\n    size_t vl = svcntb(); // Get the vector length in bytes\n\n    svbool_t all_active = svptrue_b8();\n    bool is_palindrome = true;\n\n    for (size_t i = 0; i < n / 2; i += vl) {\n        svbool_t pred = svwhilelt_b8(i, n / 2);\n        svuint8_t vec1 = svld1sb(pred, &data[i]);\n        svuint8_t vec2 = svld1sb(pred, &data[n - i - 1]);\n\n        svbool_t cmp = svcmpeq(pred, vec1, svrev(vec2));\n        if (!svptest_all(all_active, cmp)) {\n            is_palindrome = false;\n            break;\n        }\n    }\n\n    return is_palindrome;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    size_t len = text.length();\n    if (len == 0) return true;\n\n    const char* data = text.data();\n    size_t vl = svcntb(); // Get the vector length in bytes\n\n    size_t i = 0;\n    for (; i + vl <= len / 2; i += vl) {\n        svbool_t pg = svwhilelt_b8(i, len / 2);\n        svuint8_t vec1 = svld1sb(pg, data + i);\n        svuint8_t vec2 = svld1sb(pg, data + len - i - vl);\n\n        svuint8_t reversed_vec2 = svtbl(vec2, svindex_u8(0, -1));\n        svbool_t cmp = svcmpeq(pg, vec1, reversed_vec2);\n\n        if (!svptest_all(pg, cmp)) {\n            return false;\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < len / 2; ++i) {\n        if (data[i] != data[len - i - 1]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    size_t len = text.length();\n    if (len == 0) return true;\n\n    const char* data = text.data();\n    size_t vl = svcntb(); // Get the vector length in bytes\n\n    svbool_t all_active = svptrue_b8();\n    svbool_t pred = svwhilelt_b8(0, len); // Predicate for active elements\n\n    svuint8_t vec1 = svld1sb(pred, data); // Load forward characters\n    svuint8_t vec2 = svld1sb(pred, data + len - svclastb(pred, svindex_u8(0, 1))); // Load backward characters\n\n    svbool_t cmp_result = svcmpeq(pred, vec1, svrev_b8(vec2)); // Compare forward and reversed backward vectors\n\n    bool is_palindrome = true;\n    while (svptest_any(all_active, pred)) {\n        if (!svptest_first(all_active, svand_z(pred, cmp_result, cmp_result))) {\n            is_palindrome = false;\n            break;\n        }\n        len -= svclastb(pred, svindex_u8(0, 1));\n        pred = svwhilelt_b8(0, len);\n        vec1 = svld1sb(pred, data);\n        vec2 = svld1sb(pred, data + len - svclastb(pred, svindex_u8(0, 1)));\n        cmp_result = svcmpeq(pred, vec1, svrev_b8(vec2));\n    }\n\n    return is_palindrome;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    size_t len = text.length();\n    if (len == 0) return true;\n\n    const char* data = text.data();\n    size_t vl = svcntb(); // Get the vector length in bytes\n\n    svbool_t all_active = svptrue_b8(); // All elements active predicate\n\n    for (size_t i = 0; i < len / 2; i += vl) {\n        svbool_t pred = svwhilelt_b8(i, len / 2); // Predicate for active lanes\n\n        // Load forward and reverse characters\n        svuint8_t vec_forward = svld1sb_u8(pred, data + i);\n        svuint8_t vec_reverse = svld1sb_u8(pred, data + len - i - svcntb());\n\n        // Reverse the loaded reverse vector\n        svuint8_t vec_reverse_rev = svtbl(vec_reverse, svindex_u8(svcntb() - 1, -1));\n\n        // Compare forward and reversed vectors\n        svbool_t cmp_result = svcmpeq(pred, vec_forward, vec_reverse_rev);\n\n        // If any comparison fails, it's not a palindrome\n        if (!svptest_all(all_active, cmp_result)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), 0);\n    size_t i = 0;\n    size_t len = s.length();\n\n    while (i <= len - svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, len);\n        svuint8_t vec = svld1(pg, reinterpret_cast<const uint8_t*>(&s[i]));\n        svuint8_t decoded = svsub_x(pg, vec, 5);\n        svst1(pg, reinterpret_cast<uint8_t*>(&out[i]), decoded);\n        i += svcntb();\n    }\n\n    for (; i < len; ++i) {\n        out[i] = s[i] - 5;\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), 0);\n    size_t i = 0;\n    size_t len = s.length();\n\n    while (i <= len - svcntb()) {\n        svuint8_t input_vec = svld1sb_u8(svptrue_b8(), (const int8_t*)&s[i]);\n        svbool_t pred = svwhilelt_b8(i, len);\n\n        svuint8_t decoded_vec = svsub_x(pred, input_vec, 5);\n        decoded_vec = svadd_x(pred, decoded_vec, 26);\n        decoded_vec = svsub_x(pred, decoded_vec, svdup_u8('a'));\n        decoded_vec = svmod_x(pred, decoded_vec, 26);\n        decoded_vec = svadd_x(pred, decoded_vec, svdup_u8('a'));\n\n        svst1b_u8(pred, (uint8_t*)&out[i], decoded_vec);\n        i += svcntb();\n    }\n\n    for (; i < len; ++i) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out[i] = (char)w;\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.size(), 0);\n    size_t i = 0;\n    size_t len = s.size();\n\n    while (i <= len - svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, len);\n        svuint8_t vec = svld1(pg, reinterpret_cast<const uint8_t*>(&s[i]));\n        svuint8_t decoded = svsub_x(pg, vec, 5);\n        svst1(pg, reinterpret_cast<uint8_t*>(&out[i]), decoded);\n        i += svcntb();\n    }\n\n    for (; i < len; ++i) {\n        out[i] = s[i] - 5;\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.size(), 0);\n    size_t i = 0;\n    size_t len = s.size();\n\n    while (i <= len - svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, len);\n        svuint8_t vec = svld1ub(pg, reinterpret_cast<const uint8_t*>(&s[i]));\n\n        // Subtract 5 and wrap around using modulo 26\n        svuint8_t decoded = svsub_ub(vec, 5);\n        decoded = svadd_ub(decoded, 26);\n        decoded = svsub_ub(decoded, svdup_u8('a'));\n        decoded = svmod_ub(decoded, 26);\n        decoded = svadd_ub(decoded, svdup_u8('a'));\n\n        svst1ub(pg, reinterpret_cast<uint8_t*>(&out[i]), decoded);\n        i += svcntb();\n    }\n\n    for (; i < len; ++i) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out[i] = (char)w;\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.size(), 0);\n    size_t i = 0;\n    size_t len = s.size();\n\n    while (i <= len - svcntb()) {\n        svuint8_t input_vec = svld1sb_u8(svptrue_b8(), reinterpret_cast<const uint8_t*>(&s[i]));\n        svbool_t pred = svwhilelt_b8(i, len);\n        svuint8_t decoded_vec = svsub_u8_x(pred, input_vec, 5);\n        svst1b_u8(pred, reinterpret_cast<uint8_t*>(&out[i]), decoded_vec);\n        i += svcntb();\n    }\n\n    for (; i < len; ++i) {\n        out[i] = s[i] - 5;\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    size_t i = 0;\n    size_t length = l.size();\n    svbool_t pg = svwhilelt_b32(i, length);\n    int32_t threshold = t;\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec = svld1_s32(pg, &l[i]);\n        svbool_t cmp = svcmplt_s32(pg, vec, threshold);\n        if (!svptest_first(svptrue_b32(), pg, cmp)) {\n            return false;\n        }\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    size_t i = 0;\n    size_t length = l.size();\n    svbool_t pg = svwhilelt_b32(i, length);\n    \n    do {\n        svint32_t vec = svld1_s32(pg, &l[i]);\n        svbool_t cmp = svcmplt_s32(pg, vec, svdup_s32(t));\n        \n        if (!svptest_first(pg, cmp)) {\n            return false;\n        }\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    } while (svptest_any(svptrue_b32(), pg));\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    size_t i = 0;\n    size_t length = l.size();\n    svbool_t pg = svwhilelt_b32(i, length);\n    int32_t threshold = t;\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec = svld1_s32(pg, &l[i]);\n        svbool_t cmp = svcmplt_s32(pg, vec, threshold);\n        if (!svptest_first(svptrue_b32(), pg, cmp)) {\n            return false;\n        }\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    size_t i = 0;\n    size_t len = l.size();\n    svbool_t all_true = svptrue_b32();\n\n    while (i <= len - svcntw()) {\n        svint32_t vec = svld1_s32(all_true, &l[i]);\n        svbool_t cmp = svcmplt_s32(all_true, vec, svdup_s32(t));\n        if (!svptest_all(all_true, cmp)) {\n            return false;\n        }\n        i += svcntw();\n    }\n\n    if (i < len) {\n        svbool_t pred = svwhilelt_b32(i, len);\n        svint32_t vec = svld1_s32(pred, &l[i]);\n        svbool_t cmp = svcmplt_s32(pred, vec, svdup_s32(t));\n        if (!svptest_all(pred, cmp)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    svbool_t pg = svptrue_b32();\n    size_t i = 0;\n    bool all_below = true;\n\n    while (i < l.size()) {\n        svint32_t vec = svld1_s32(pg, &l[i]);\n        svbool_t below = svcmplt_s32(pg, vec, svdup_s32(t));\n        if (!svptest_first(pg, below)) {\n            all_below = false;\n            break;\n        }\n        i += svcntw();\n    }\n\n    return all_below;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t len = brackets.length();\n    if (len == 0) return true;\n    if (len % 2 != 0) return false;\n\n    int32_t balance = 0;\n    size_t i = 0;\n\n    // Process the string in chunks using SVE\n    svbool_t pg = svwhilelt_b8(i, len); // Predicate for active lanes\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svint8_t vec = svld1sb(pg, &brackets[i]); // Load vector of characters\n        svint8_t open_bracket = svdup_s8('<');   // Vector of '<'\n        svint8_t close_bracket = svdup_s8('>');  // Vector of '>'\n\n        // Compare and calculate balance\n        svbool_t is_open = svcmpeq(pg, vec, open_bracket);\n        svbool_t is_close = svcmpeq(pg, vec, close_bracket);\n\n        // Increment or decrement balance based on brackets\n        balance += svcntp_b8(pg, is_open); // Count '<' and add to balance\n        balance -= svcntp_b8(pg, is_close); // Count '>' and subtract from balance\n\n        // If balance goes negative, brackets are incorrect\n        if (balance < 0) return false;\n\n        // Move to next chunk\n        i += svcntb();\n        pg = svwhilelt_b8(i, len);\n    }\n\n    // Final check: balance must be zero for correct bracketing\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t len = brackets.size();\n    if (len == 0) return true;\n\n    int32_t balance = 0;\n    svint32_t sv_balance = svdup_s32(0);\n    svbool_t pg = svwhilelt_b8(0, len);\n\n    for (size_t i = 0; i < len; i += svcntb()) {\n        svuint8_t chars = svld1ub(pg, reinterpret_cast<const uint8_t*>(&brackets[i]));\n\n        svbool_t is_less = svcmpeq(pg, chars, svdup_u8('<'));\n        svbool_t is_greater = svcmpeq(pg, chars, svdup_u8('>'));\n\n        svint32_t add_vec = svdup_s32(0);\n        svint32_t sub_vec = svdup_s32(0);\n\n        add_vec = svadd_s32_x(pg, add_vec, svdup_s32(svpopcount_b8(is_less)));\n        sub_vec = svsub_s32_x(pg, sub_vec, svdup_s32(svpopcount_b8(is_greater)));\n\n        sv_balance = svadd_s32_x(pg, sv_balance, add_vec);\n        sv_balance = svsub_s32_x(pg, sv_balance, sub_vec);\n\n        if (svminv_s32(pg, sv_balance) < 0) {\n            return false;\n        }\n    }\n\n    balance = svaddv_s32(pg, sv_balance);\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t len = brackets.size();\n    if (len == 0) return true;\n    if (len % 2 != 0) return false;\n\n    int32_t balance = 0;\n    size_t i = 0;\n\n    while (i + svcntb() <= len) {\n        svbool_t pg = svwhilelt_b8(i, len);\n        svuint8_t vec = svld1(pg, reinterpret_cast<const uint8_t*>(brackets.data() + i));\n\n        svbool_t is_less = svcmpeq(pg, vec, static_cast<uint8_t>('<'));\n        svbool_t is_greater = svcmpeq(pg, vec, static_cast<uint8_t>('>'));\n\n        int32_t add = svcntp_b8(pg, is_less);\n        int32_t sub = svcntp_b8(pg, is_greater);\n\n        balance += add - sub;\n\n        if (balance < 0) return false;\n\n        i += svcntb();\n    }\n\n    for (; i < len; ++i) {\n        if (brackets[i] == '<') {\n            balance++;\n        } else if (brackets[i] == '>') {\n            balance--;\n        }\n        if (balance < 0) return false;\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t len = brackets.length();\n    size_t vl = svcntb(); // Get the vector length in bytes\n\n    int balance = 0;\n    size_t i = 0;\n\n    // Process the string in chunks of SVE vector length\n    for (; i + vl <= len; i += vl) {\n        svuint8_t vec = svld1sb_u8(svptrue_b8(), (const uint8_t*)(brackets.data() + i));\n        svbool_t is_less = svcmpeq_n_u8(svptrue_b8(), vec, '<');\n        svbool_t is_greater = svcmpeq_n_u8(svptrue_b8(), vec, '>');\n\n        int add = svcntp_b8(svptrue_b8(), is_less);\n        int sub = svcntp_b8(svptrue_b8(), is_greater);\n\n        balance += add - sub;\n\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    // Process the remaining elements\n    for (; i < len; ++i) {\n        if (brackets[i] == '<') {\n            balance++;\n        } else if (brackets[i] == '>') {\n            balance--;\n        }\n\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t len = brackets.size();\n    if (len == 0) return true;\n    if (len % 2 != 0) return false;\n\n    int balance = 0;\n    size_t i = 0;\n\n    // Process the string in chunks using SVE\n    svbool_t pg = svwhilelt_b8(i, len); // Predicate for active lanes\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svint8_t vec = svld1sb(pg, &brackets[i]); // Load a vector of characters\n        svint8_t open_bracket = svdup_n_s8('<');  // Vector of '<'\n        svint8_t close_bracket = svdup_n_s8('>'); // Vector of '>'\n\n        // Compare and calculate balance changes\n        svbool_t is_open = svcmpeq(pg, vec, open_bracket);\n        svbool_t is_close = svcmpeq(pg, vec, close_bracket);\n\n        // Count the number of '<' and '>' in the current vector\n        int open_count = svcntp_b8(pg, is_open);\n        int close_count = svcntp_b8(pg, is_close);\n\n        // Update balance\n        balance += open_count - close_count;\n\n        // If balance goes negative at any point, return false\n        if (balance < 0) return false;\n\n        // Move to the next chunk\n        i += svcntb();\n        pg = svwhilelt_b8(i, len);\n    }\n\n    // Final check: balance must be zero\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t len = brackets.size();\n    size_t vl = svcntb(); // Get the vector length in bytes\n    int balance = 0;\n\n    for (size_t i = 0; i < len; i += vl) {\n        svbool_t pg = svwhilelt_b8(i, len); // Predicate for active lanes\n        svuint8_t vec = svld1ub(pg, reinterpret_cast<const uint8_t*>(&brackets[i])); // Load vector of characters\n\n        // Create masks for '(' and ')'\n        svbool_t is_open = svcmpeq(pg, vec, svdup_u8('('));\n        svbool_t is_close = svcmpeq(pg, vec, svdup_u8(')'));\n\n        // Count the number of '(' and ')' in the current vector\n        int open_count = svcntp_b8(pg, is_open);\n        int close_count = svcntp_b8(pg, is_close);\n\n        // Update balance\n        balance += open_count - close_count;\n\n        // Early exit if balance goes negative\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t len = brackets.size();\n    size_t vl = svcntb(); // Get the vector length in bytes\n    int balance = 0;\n    size_t i = 0;\n\n    // Process the string in chunks of SVE vector length\n    for (; i + vl <= len; i += vl) {\n        svuint8_t vec = svld1sb_u8(svptrue_b8(), (const uint8_t*)&brackets[i]);\n        svbool_t is_open = svcmpeq_n_u8(svptrue_b8(), vec, '(');\n        svbool_t is_close = svcmpeq_n_u8(svptrue_b8(), vec, ')');\n\n        // Count the number of opening and closing brackets in the vector\n        int open_count = svcntp_b8(svptrue_b8(), is_open);\n        int close_count = svcntp_b8(svptrue_b8(), is_close);\n\n        // Update the balance\n        balance += open_count - close_count;\n\n        // Early exit if balance goes negative\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    // Process the remaining elements\n    for (; i < len; ++i) {\n        if (brackets[i] == '(') {\n            ++balance;\n        } else if (brackets[i] == ')') {\n            --balance;\n        }\n\n        // Early exit if balance goes negative\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    // Final check: balance must be zero for correct bracketing\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t len = brackets.size();\n    size_t vl = svcntb(); // Get the vector length in bytes\n\n    svint8_t vec_open = svdup_n_s8('(');\n    svint8_t vec_close = svdup_n_s8(')');\n    svint32_t balance = svdup_n_s32(0);\n\n    for (size_t i = 0; i < len; i += vl) {\n        svbool_t pg = svwhilelt_b8(i, len); // Predicate for active lanes\n        svint8_t vec = svld1sb(pg, &brackets[i]); // Load characters into vector\n\n        svbool_t is_open = svcmpeq(pg, vec, vec_open); // Compare with '('\n        svbool_t is_close = svcmpeq(pg, vec, vec_close); // Compare with ')'\n\n        svint32_t open_count = svcnt_s8_m(pg, is_open); // Count '('\n        svint32_t close_count = svcnt_s8_m(pg, is_close); // Count ')'\n\n        balance = svadd_s32_z(pg, balance, svsub_s32_z(pg, open_count, close_count)); // Update balance\n\n        if (svminv_s32(pg, balance) < 0) { // Check if balance goes negative\n            return false;\n        }\n    }\n\n    int final_balance = svaddv_s32(svptrue_b32(), balance); // Sum across all lanes\n    return final_balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t len = brackets.size();\n    size_t vl = svcntb(); // Get the vector length in bytes\n    int32_t balance = 0;\n    int32_t min_balance = 0;\n\n    for (size_t i = 0; i < len; i += vl) {\n        svbool_t pg = svwhilelt_b8(i, len); // Predicate for active lanes\n        svuint8_t vec = svld1ub(pg, reinterpret_cast<const uint8_t*>(&brackets[i])); // Load vector of characters\n\n        // Create a mask where '(' is 1 and ')' is -1\n        svint8_t mask = svdup_s8(0);\n        mask = svsel(sveor_z(pg, svcmpeq(pg, vec, '('), svcmpeq(pg, vec, ')')), svdup_s8(1), mask);\n        mask = svsel(sveor_z(pg, svcmpeq(pg, vec, ')'), svcmpeq(pg, vec, '(')), svdup_s8(-1), mask);\n\n        // Convert to int32_t for accumulation\n        svint32_t wide_mask = svmovlb_s32(mask);\n        wide_mask = svadd_s32_z(pg, wide_mask, svmovlt_s32(mask));\n\n        // Accumulate balance\n        balance += svaddv_s32(pg, wide_mask);\n\n        // Track minimum balance\n        min_balance = std::min(min_balance, balance);\n    }\n\n    return (balance == 0) && (min_balance >= 0);\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t len = brackets.size();\n    size_t vl = svcntb(); // Get the vector length in bytes\n\n    int32_t balance = 0;\n    int32_t min_balance = 0;\n\n    for (size_t i = 0; i < len; i += vl) {\n        svbool_t pg = svwhilelt_b8(i, len); // Predicate for active lanes\n        svuint8_t vec = svld1ub(pg, reinterpret_cast<const uint8_t*>(&brackets[i])); // Load characters\n\n        // Create masks for '(' and ')'\n        svbool_t is_open = svcmpeq(pg, vec, svdup_n_u8('('));\n        svbool_t is_close = svcmpeq(pg, vec, svdup_n_u8(')'));\n\n        // Count the number of '(' and ')' in the current vector\n        int32_t open_count = svcntp_b8(pg, is_open);\n        int32_t close_count = svcntp_b8(pg, is_close);\n\n        // Update balance\n        balance += open_count - close_count;\n\n        // Track the minimum balance encountered\n        if (balance < min_balance) {\n            min_balance = balance;\n        }\n    }\n\n    // The string is correctly bracketed if balance is zero and min_balance never went negative\n    return balance == 0 && min_balance >= 0;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    size_t n = xs.size();\n    std::vector<float> result(n > 1 ? n - 1 : 0);\n\n    if (n <= 1) return result;\n\n    size_t vl;\n    float *x_ptr = xs.data();\n    float *res_ptr = result.data();\n\n    for (size_t i = 1; i < n; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        vl = svcntw();\n\n        svfloat32_t vec = svld1(pg, x_ptr + i);\n        svfloat32_t indices = svindex_f32(i, 1);\n        svfloat32_t res = svmul_x(pg, vec, indices);\n\n        svst1(pg, res_ptr + i - 1, res);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    int n = xs.size();\n    std::vector<float> result(n > 1 ? n - 1 : 0);\n\n    if (n <= 1) return result;\n\n    int i = 0;\n    svbool_t pg = svwhilelt_b32(i, n - 1);\n\n    do {\n        svfloat32_t vec_xs = svld1(pg, &xs[i + 1]);\n        svfloat32_t vec_indices = svindex_f32(1, 1);\n        svfloat32_t vec_result = svmul_f32(vec_xs, vec_indices);\n        svst1(pg, &result[i], vec_result);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, n - 1);\n    } while (svptest_any(svptrue_b32(), pg));\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    std::vector<float> result(xs.size() - 1);\n    size_t i = 0;\n\n    while (i + svcntw() <= xs.size() - 1) {\n        svbool_t pg = svwhilelt_b32(i, xs.size() - 1);\n        svfloat32_t vec_xs = svld1_f32(pg, &xs[i]);\n        svfloat32_t vec_indices = svindex_f32(1, 1);\n        svfloat32_t vec_result = svmul_f32(vec_xs, vec_indices);\n        svst1_f32(pg, &result[i], vec_result);\n        i += svcntw();\n    }\n\n    for (; i < xs.size() - 1; ++i) {\n        result[i] = xs[i + 1] * static_cast<float>(i + 1);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    std::vector<float> result(xs.size() - 1);\n    size_t i = 0;\n\n    // Load the SVE vector length in bits and compute the number of elements it can hold\n    size_t sve_vector_length = svcntw(); // Number of 32-bit floats in a vector\n\n    for (; i + sve_vector_length <= xs.size(); i += sve_vector_length) {\n        svfloat32_t vec = svld1_f32(svptrue_b32(), &xs[i]);\n        svbool_t pred = svwhilelt_b32(i, xs.size() - 1); // Predicate to handle partial vectors\n        svfloat32_t indices = svindex_f32((float)i, 1.0f);\n        svfloat32_t mul_result = svmul_f32_x(pred, vec, indices);\n        svst1_f32(pred, &result[i], mul_result);\n    }\n\n    // Handle remaining elements that do not fill a full vector\n    for (; i < xs.size() - 1; ++i) {\n        result[i] = xs[i + 1] * static_cast<float>(i + 1);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    std::vector<float> result(xs.size() - 1);\n    size_t i = 0;\n\n    // Load the SVE vector length in bits and compute the number of elements it can hold\n    size_t sve_vector_length = svcntw(); // Number of 32-bit floats in one SVE vector\n\n    for (; i + sve_vector_length <= xs.size(); i += sve_vector_length) {\n        svfloat32_t vec = svld1_f32(svptrue_b32(), &xs[i]);\n        svfloat32_t indices = svindex_f32((float)i, 1.0f);\n        svfloat32_t derivative = svmul_f32(vec, indices);\n\n        // Store only the relevant part of the derivative (ignore the first element)\n        svst1_f32(svptrue_b32(), &result[i], derivative);\n    }\n\n    // Handle remaining elements that do not fill a full SVE vector\n    for (; i < xs.size(); ++i) {\n        result[i - 1] = xs[i] * static_cast<float>(i);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint vowels_count_simd(std::string s) {\n    size_t len = s.length();\n    const char* data = s.c_str();\n    int result = 0;\n\n    // SVE register for vowels\n    svuint8_t sve_vowels = svld1rq_u8(\"aeiouAEIOU\");\n\n    // Check if the last character is 'y' or 'Y'\n    if (len > 0 && (data[len - 1] == 'y' || data[len - 1] == 'Y')) {\n        result++;\n        len--;\n    }\n\n    // Process the string in chunks using SVE\n    size_t i = 0;\n    while (i <= len - svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, len);\n        svuint8_t sve_data = svld1sb_u8(pg, data + i);\n\n        // Compare with vowels\n        svbool_t is_vowel = svcmpeq(pg, sve_data, sve_vowels);\n\n        // Count the number of matches\n        result += svcntp_b8(pg, is_vowel);\n\n        i += svcntb();\n    }\n\n    // Handle remaining elements\n    for (; i < len; ++i) {\n        char c = data[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n            c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            result++;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint vowels_count_simd(std::string s) {\n    size_t len = s.length();\n    const char *data = s.c_str();\n    int result = 0;\n\n    // SVE register for vowels\n    svuint8_t sve_vowels = svld1rq_u8(\"aeiouAEIOU\");\n\n    // SVE predicate for active elements\n    svbool_t pg = svwhilelt_b8(0, len);\n\n    // Loop through the string in chunks of SVE vector length\n    for (size_t i = 0; i < len; i += svcntb()) {\n        // Load a vector of characters from the string\n        svuint8_t sve_chars = svld1ub_u8(pg, data + i);\n\n        // Compare each character with the vowel list\n        svbool_t is_vowel = svcmpeq(pg, sve_chars, sve_vowels);\n\n        // Count the number of matches\n        result += svcntp_b8(pg, is_vowel);\n\n        // Update the predicate for the next iteration\n        pg = svwhilelt_b8(i + svcntb(), len);\n    }\n\n    // Handle 'y' or 'Y' at the end of the string\n    if (len > 0 && (data[len - 1] == 'y' || data[len - 1] == 'Y')) {\n        result++;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint vowels_count_simd(std::string s) {\n    int count = 0;\n    size_t len = s.length();\n    const char *data = s.c_str();\n\n    // Define the vowels and 'y' as a vector of characters\n    svuint8_t vowels = svld1rq_u8((const uint8_t *)\"aeiouAEIOU\");\n    svbool_t pg = svwhilelt_b8(0, len);\n\n    for (size_t i = 0; i < len; i += svcntb()) {\n        svuint8_t chars = svld1sb_u8(pg, data + i);\n        svbool_t is_vowel = svcmpeq(pg, svtbl_u8(vowels, chars), chars);\n        count += svcntp_b8(pg, is_vowel);\n    }\n\n    // Check if the last character is 'y' or 'Y'\n    if (len > 0 && (s[len - 1] == 'y' || s[len - 1] == 'Y')) {\n        count++;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint vowels_count_simd(std::string s) {\n    int count = 0;\n    size_t len = s.length();\n    const char *data = s.c_str();\n\n    // SVE register for vowels\n    svuint8_t sve_vowels = svld1rq_u8(\"aeiouAEIOU\");\n\n    // Check if 'y' or 'Y' is at the end of the word\n    if (len > 0 && (data[len - 1] == 'y' || data[len - 1] == 'Y')) {\n        count++;\n    }\n\n    // Process the string in chunks using SVE\n    size_t i = 0;\n    while (i <= len - svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, len);\n        svuint8_t sve_data = svld1sb_u8(pg, data + i);\n\n        // Compare with vowels\n        svbool_t is_vowel = svcmpeq(pg, sve_data, sve_vowels);\n\n        // Count the number of matches\n        count += svcntp_b8(svptrue_b8(), is_vowel);\n\n        i += svcntb();\n    }\n\n    // Handle remaining elements\n    for (; i < len; ++i) {\n        char c = data[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n            c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint vowels_count_simd(std::string s) {\n    int count = 0;\n    size_t len = s.length();\n    const char *data = s.c_str();\n\n    // Define the vowels and 'y' as a vector of characters\n    svuint8_t vowels = svld1rq_u8(\"aeiouAEIOU\");\n    svbool_t pg = svwhilelt_b8(0, len);\n\n    for (size_t i = 0; i < len; i += svcntb()) {\n        svuint8_t chars = svld1sb_u8(pg, data + i);\n        svbool_t is_vowel = svcmpeq(pg, chars, vowels);\n\n        // Count the number of vowels in this segment\n        count += svcntp_b8(pg, is_vowel);\n    }\n\n    // Check if the last character is 'y' or 'Y'\n    if (len > 0 && (s[len - 1] == 'y' || s[len - 1] == 'Y')) {\n        count++;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    size_t len = s.length();\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b8(i, len);\n    svuint8_t vec_upper_mask = svdup_u8(0x40); // Mask for uppercase check (ASCII 'A' starts at 65)\n    svuint8_t vec_lower_mask = svdup_u8(0x5B); // Mask for uppercase check (ASCII 'Z' ends at 90)\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t vec_chars = svld1sb_u8(pg, &s[i]);\n        svbool_t is_upper = svcmpeq_n_u8(pg, svand_u8_z(pg, vec_chars, svdup_u8(0xFF)), vec_upper_mask);\n        svbool_t is_lower = svcmpge_n_u8(pg, svand_u8_z(pg, vec_chars, svdup_u8(0xFF)), vec_lower_mask);\n        svbool_t is_upper_char = svnot_z(pg, svorr_z(pg, is_upper, is_lower));\n\n        svuint8_t filtered_chars = svand_u8_z(pg, vec_chars, svdup_u8(is_upper_char ? 0xFF : 0x00));\n        sum += svaddv_u8(pg, filtered_chars);\n\n        i += svcntb();\n        pg = svwhilelt_b8(i, len);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    size_t len = s.length();\n    size_t i = 0;\n\n    // Process the string in chunks of SVE vector length\n    while (i + svcntb() <= len) {\n        svuint8_t vec = svld1ub(svptrue_b8(), reinterpret_cast<const uint8_t*>(&s[i]));\n        svbool_t mask = svcmpge(svptrue_b8(), vec, static_cast<uint8_t>('A'));\n        mask = svcmpeq(mask, vec, svmin(vec, static_cast<uint8_t>('Z')));\n        svuint8_t upper_chars = svand_z(mask, vec);\n        sum += svaddv(svptrue_b8(), upper_chars);\n        i += svcntb();\n    }\n\n    // Process remaining characters\n    for (; i < len; ++i) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            sum += s[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint digitSum_simd(std::string s) {\n    size_t len = s.size();\n    const char* data = s.data();\n    int result = 0;\n\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b8(i, len);\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t vec = svld1sb_u8(pg, data + i);\n        svbool_t is_upper = svcmpge_n_u8(pg, vec, 'A');\n        is_upper = svcmpeq_n_u8_m(pg, is_upper, vec, 'Z');\n\n        svuint8_t upper_chars = svand_u8_m(pg, is_upper, vec);\n        uint64_t sum = svaddv_u8(svptrue_b8(), upper_chars);\n\n        result += (int)sum;\n\n        i += svcntb();\n        pg = svwhilelt_b8(i, len);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    size_t len = s.length();\n    const char* data = s.c_str();\n\n    size_t i = 0;\n    while (i <= len - svcntb()) {\n        svuint8_t vec = svld1ub(svptrue_b8(), (const uint8_t*)(data + i));\n        svbool_t upper_mask = svcmpge(svptrue_b8(), vec, svdup_n_u8('A'));\n        svbool_t lower_mask = svcmple(svptrue_b8(), vec, svdup_n_u8('Z'));\n        svbool_t mask = svand_b_z(svptrue_b8(), upper_mask, lower_mask);\n\n        svuint8_t masked_vec = svand_u8_z(mask, vec);\n        sum += svaddv(svptrue_b8(), masked_vec);\n\n        i += svcntb();\n    }\n\n    for (; i < len; ++i) {\n        if (data[i] >= 'A' && data[i] <= 'Z') {\n            sum += data[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint digitSum_simd(std::string s) {\n    size_t len = s.length();\n    const char* data = s.c_str();\n    int result = 0;\n\n    size_t i = 0;\n    while (i <= len - svcntb()) {\n        svuint8_t vec = svld1ub(svptrue_b8(), (const uint8_t*)(data + i));\n        svbool_t upper_mask = svcmpge(svptrue_b8(), vec, svdup_u8('A'));\n        svbool_t lower_mask = svcmple(svptrue_b8(), vec, svdup_u8('Z'));\n        svbool_t mask = svand_b_z(svptrue_b8(), upper_mask, lower_mask);\n\n        svuint8_t masked_vec = svand_u8_z(mask, vec);\n        uint64_t sum = svaddv_u8(mask, masked_vec);\n        result += (int)sum;\n\n        i += svcntb();\n    }\n\n    for (; i < len; ++i) {\n        if (data[i] >= 'A' && data[i] <= 'Z') {\n            result += data[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int min_even_value = std::numeric_limits<int>::max();\n    int min_even_index = -1;\n\n    size_t i = 0;\n    size_t array_size = arr.size();\n\n    // Process the array in chunks of SVE vector length\n    while (i <= array_size - svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, array_size);\n        svint32_t vec = svld1_s32(pg, &arr[i]);\n\n        // Mask for even numbers\n        svbool_t even_mask = svcmpeq_n_s32(pg, svand_s32_z(pg, vec, 1), 0);\n\n        // Extract even values and their indices\n        svint32_t even_values = svcompact_s32(even_mask, vec);\n        svint32_t even_indices = svcompact_s32(even_mask, svindex_s32(i, 1));\n\n        // Find the minimum even value in this chunk\n        svbool_t valid_mask = svptrue_b32();\n        int local_min_value = svminv_s32(valid_mask, even_values);\n        svbool_t min_mask = svcmpeq_n_s32(valid_mask, even_values, local_min_value);\n\n        // Find the corresponding index for the minimum value\n        int local_min_index = svminv_s32(min_mask, even_indices);\n\n        // Update global minimum if the local minimum is smaller\n        if (local_min_value < min_even_value) {\n            min_even_value = local_min_value;\n            min_even_index = local_min_index;\n        }\n\n        i += svcntw();\n    }\n\n    // Process remaining elements\n    for (; i < array_size; ++i) {\n        if (arr[i] % 2 == 0 && arr[i] < min_even_value) {\n            min_even_value = arr[i];\n            min_even_index = i;\n        }\n    }\n\n    if (min_even_index == -1) {\n        return {};\n    }\n\n    return {min_even_value, min_even_index};\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int min_val = std::numeric_limits<int>::max();\n    int min_idx = -1;\n    size_t i = 0;\n\n    while (i < arr.size()) {\n        // Load a vector of elements from the array\n        svint32_t vec = svld1_s32(svptrue_b32(), &arr[i]);\n\n        // Create a predicate for valid elements in the vector\n        svbool_t pred = svwhilelt_b32(i, arr.size());\n\n        // Mask out invalid elements\n        vec = svsel_s32(pred, vec, svdup_s32(-1));\n\n        // Check for even numbers\n        svbool_t is_even = svcmpeq_s32(svand_s32(vec, svdup_s32(1)), svdup_s32(0));\n\n        // Extract even numbers and update minimum value and index\n        svint32_t indices = svindex_s32(i, 1);\n        svint32_t valid_vals = svsel_s32(is_even, vec, svdup_s32(min_val));\n        svint32_t valid_indices = svsel_s32(is_even, indices, svdup_s32(min_idx));\n\n        // Find the minimum value and its index\n        svbool_t is_smaller = svclt_s32(valid_vals, svdup_s32(min_val));\n        min_val = svminv_s32(is_smaller, valid_vals);\n        min_idx = svminv_s32(is_smaller, valid_indices);\n\n        // Move to the next chunk\n        i += svcntw();\n    }\n\n    if (min_idx == -1) {\n        return {};\n    }\n\n    return {min_val, min_idx};\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int result_value = std::numeric_limits<int>::max();\n    int result_index = -1;\n\n    size_t i = 0;\n    size_t array_size = arr.size();\n\n    // Process the array in chunks of SVE vector length\n    while (i <= array_size - svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, array_size);\n\n        // Load a vector of elements from the array\n        svint32_t vec = svld1_s32(pg, &arr[i]);\n\n        // Create a predicate for even numbers\n        svbool_t is_even = svcmpeq_n_s32(pg, svand_s32_z(pg, vec, 1), 0);\n\n        // Extract even numbers, use a large value for odd numbers\n        svint32_t even_values = svsel_s32(is_even, vec, svdup_n_s32(std::numeric_limits<int>::max()));\n\n        // Find the minimum value in the vector\n        int min_value = svminv_s32(pg, even_values);\n\n        // If the found minimum is smaller than the current result, update the result\n        if (min_value < result_value) {\n            // Find the index of the minimum value within the vector\n            svbool_t is_min = svcmpeq_n_s32(pg, even_values, min_value);\n            uint64_t first_match = svbrka_b32(svptrue_b32(), is_min);\n            size_t match_index = i + svcntp_b32(svptrue_b32(), first_match);\n\n            // Update result if the new minimum is valid\n            if (match_index < array_size && arr[match_index] == min_value) {\n                result_value = min_value;\n                result_index = match_index;\n            }\n        }\n\n        i += svcntw();\n    }\n\n    // Process any remaining elements that didn't fit into a full vector\n    for (; i < array_size; ++i) {\n        if ((arr[i] % 2 == 0) && (arr[i] < result_value)) {\n            result_value = arr[i];\n            result_index = i;\n        }\n    }\n\n    if (result_index == -1) {\n        return {};\n    }\n\n    return {result_value, result_index};\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int min_val = std::numeric_limits<int>::max();\n    int min_idx = -1;\n    size_t i = 0;\n\n    // Load the array size into a predicate for vectorization\n    size_t array_size = arr.size();\n    svbool_t pg = svwhilelt_b32(i, array_size);\n\n    // Initialize SVE registers\n    svint32_t sve_min_val = svdup_n_s32(std::numeric_limits<int>::max());\n    svint32_t sve_min_idx = svdup_n_s32(-1);\n    svint32_t sve_indices = svindex_s32(0, 1);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load a vector of elements from the array\n        svint32_t sve_values = svld1_s32(pg, &arr[i]);\n\n        // Create a mask for even values\n        svbool_t is_even = svcmpeq_n_s32(pg, svand_s32_z(pg, sve_values, 1), 0);\n\n        // Update minimum value and index for even numbers\n        svbool_t update_mask = svcmpgt_s32(pg, sve_min_val, sve_values);\n        update_mask = svand_b_z(pg, update_mask, is_even);\n\n        sve_min_val = svsel_s32(update_mask, sve_values, sve_min_val);\n        sve_min_idx = svsel_s32(update_mask, sve_indices, sve_min_idx);\n\n        // Increment indices and loop counter\n        sve_indices = svadd_s32_z(pg, sve_indices, svlen_s32(sve_values));\n        i += svcntw();\n        pg = svwhilelt_b32(i, array_size);\n    }\n\n    // Reduce across lanes to find the smallest even value and its index\n    int result_val = std::numeric_limits<int>::max();\n    int result_idx = -1;\n\n    for (size_t j = 0; j < svcntw(); ++j) {\n        int val = svminv_s32(svptrue_b32(), sve_min_val);\n        int idx = svminv_s32(svptrue_b32(), sve_min_idx);\n\n        if (val < result_val && val % 2 == 0) {\n            result_val = val;\n            result_idx = idx;\n        }\n    }\n\n    if (result_idx == -1) {\n        return {};\n    }\n\n    return {result_val, result_idx};\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int min_value = std::numeric_limits<int>::max();\n    int min_index = -1;\n    size_t i = 0;\n\n    while (i < arr.size()) {\n        // Load a vector of elements from the array\n        svbool_t pg = svwhilelt_b32(i, arr.size());\n        svint32_t vec = svld1(pg, &arr[i]);\n\n        // Create a predicate for even numbers\n        svbool_t is_even = svcmpeq_n_s32(pg, svand_n_s32_z(pg, vec, 1), 0);\n\n        // Extract even numbers and their indices\n        svint32_t even_values = svcompact(is_even, vec);\n        svint32_t even_indices = svcompact(is_even, svindex_s32(i, 1));\n\n        // Find the minimum even value in this vector\n        svbool_t has_even = svptest_any(svptrue_b32(), is_even);\n        if (svptest_any(svptrue_b32(), has_even)) {\n            int current_min = svminv(is_even, even_values);\n            svbool_t is_current_min = svcmpeq_n_s32(is_even, even_values, current_min);\n            int current_min_index = svminv(is_current_min, even_indices);\n\n            // Update global minimum if necessary\n            if (current_min < min_value || (current_min == min_value && current_min_index < min_index)) {\n                min_value = current_min;\n                min_index = current_min_index;\n            }\n        }\n\n        // Move to the next chunk\n        i += svcntw();\n    }\n\n    if (min_index == -1) {\n        return {};\n    }\n\n    return {min_value, min_index};\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    int max_val = *std::max_element(lst.begin(), lst.end());\n    std::vector<int> freq(max_val + 1, 0);\n\n    // Count frequencies using SVE\n    size_t i = 0;\n    size_t n = lst.size();\n    svbool_t pg = svwhilelt_b32(i, n);\n    do {\n        svint32_t vec = svld1(pg, &lst[i]);\n        svint32_t indices = svindex_s32(0, 1);\n        svint32_t values = svadd_x(pg, indices, svdup_s32(i));\n\n        for (int j = 0; j < svcntw(); ++j) {\n            if (svptest_first(pg, svcmpeq_n_s32(pg, indices, j))) {\n                freq[lst[i + j]]++;\n            }\n        }\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, n);\n    } while (svptest_any(svptrue_b32(), pg));\n\n    // Find the greatest integer with frequency >= value\n    int result = -1;\n    for (int k = 1; k <= max_val; ++k) {\n        if (freq[k] >= k) {\n            result = std::max(result, k);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    int max_val = *std::max_element(lst.begin(), lst.end());\n    std::vector<int> freq(max_val + 1, 0);\n\n    // Count frequencies using SVE\n    size_t i = 0;\n    size_t n = lst.size();\n    svbool_t pg = svwhilelt_b32(i, n);\n    do {\n        svint32_t vec = svld1_s32(pg, &lst[i]);\n        svint32_t indices = svindex_s32(0, 1);\n        svint32_t values = svadd_s32_z(pg, indices, svdup_s32(i));\n\n        for (int val = 0; val <= max_val; ++val) {\n            svbool_t mask = svcmpeq_s32(pg, vec, svdup_s32(val));\n            freq[val] += svcntp_b32(svptrue_b32(), mask);\n        }\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, n);\n    } while (svptest_any(svptrue_b32(), pg));\n\n    // Find the greatest integer with frequency >= value\n    int result = -1;\n    for (int val = max_val; val > 0; --val) {\n        if (freq[val] >= val) {\n            result = val;\n            break;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    int max_val = *std::max_element(lst.begin(), lst.end());\n    std::vector<int> freq(max_val + 1, 0);\n\n    // Count frequencies using SVE\n    size_t i = 0;\n    size_t n = lst.size();\n    svbool_t pg = svwhilelt_b32(i, n);\n    do {\n        svint32_t vec = svld1_s32(pg, &lst[i]);\n        svuint32_t indices = svcvt_u32_s32(vec);\n        for (int j = 0; j < svcntw(); ++j) {\n            if (svptest_first(pg, svdup_lane_u32(indices, j))) {\n                freq[svget_lane_u32(indices, j)]++;\n            }\n        }\n        i += svcntw();\n        pg = svwhilelt_b32(i, n);\n    } while (svptest_any(svptrue_b32(), pg));\n\n    // Find the greatest integer with frequency >= value\n    int result = -1;\n    for (int k = 1; k <= max_val; ++k) {\n        if (freq[k] >= k) {\n            result = k;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    int max_val = *std::max_element(lst.begin(), lst.end());\n    std::vector<int> freq(max_val + 1, 0);\n\n    // Count frequencies using SVE\n    size_t i = 0;\n    size_t n = lst.size();\n    svbool_t pg = svwhilelt_b32(i, n);\n    do {\n        svint32_t vec = svld1_s32(pg, &lst[i]);\n        svuint32_t indices = svcvt_u32_s32(vec);\n        for (int j = 0; j < svcntw(); ++j) {\n            if (svptest_first(pg, indices)) {\n                freq[svlasta(indices)]++;\n            }\n            indices = svuzp2(indices, indices);\n        }\n        i += svcntw();\n        pg = svwhilelt_b32(i, n);\n    } while (svptest_any(svptrue_b32(), pg));\n\n    // Find the greatest integer with frequency >= value\n    int result = -1;\n    for (int k = 1; k <= max_val; ++k) {\n        if (freq[k] >= k) {\n            result = k;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    int max_val = *std::max_element(lst.begin(), lst.end());\n    std::vector<int> freq(max_val + 1, 0);\n\n    // Count frequencies using SVE\n    size_t i = 0;\n    size_t n = lst.size();\n    svbool_t pg = svwhilelt_b32(i, n);\n    do {\n        svint32_t vec = svld1_s32(pg, &lst[i]);\n        svint32_t indices = svindex_s32(0, 1);\n        svint32_t values = svadd_s32_z(pg, indices, svdup_s32(i));\n\n        for (int val = 0; val <= max_val; ++val) {\n            svbool_t mask = svcmpeq_s32(pg, vec, svdup_s32(val));\n            freq[val] += svcntp_b32(svptrue_b32(), mask);\n        }\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, n);\n    } while (svptest_any(svptrue_b32(), pg));\n\n    // Find the greatest integer with frequency >= value\n    int result = -1;\n    for (int val = max_val; val > 0; --val) {\n        if (freq[val] >= val) {\n            result = val;\n            break;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    size_t n = q.size();\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active lanes\n\n    // Load the vector into SVE registers\n    int* data = q.data();\n    svint32_t vec = svld1(pg, data);\n\n    // Compute the sum of elements using SVE intrinsics\n    svint32_t sum_vec = svdup_n_s32(0);\n    sum_vec = svadd_m(pg, sum_vec, vec);\n    int sum = 0;\n    sum = svaddv(pg, sum_vec);\n\n    // Check if the sum exceeds the maximum weight\n    if (sum > w) {\n        return false;\n    }\n\n    // Check if the vector is palindromic\n    bool is_palindromic = true;\n    for (size_t i = 0; i < n / 2; ++i) {\n        svint32_t left = svld1(svptrue_b32(), &data[i]);\n        svint32_t right = svld1(svptrue_b32(), &data[n - i - 1]);\n        svbool_t cmp = svcmpeq(pg, left, right);\n        if (!svptest_first(pg, cmp)) {\n            is_palindromic = false;\n            break;\n        }\n    }\n\n    return is_palindromic;\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    size_t n = q.size();\n    int sum = 0;\n    bool is_palindromic = true;\n\n    // Calculate vector length\n    size_t vl = svcntw();\n\n    // Process in chunks of SVE vector length\n    for (size_t i = 0; i < n; i += vl) {\n        size_t current_vl = std::min(vl, n - i);\n\n        // Load vector from q\n        svint32_t vec = svld1_s32(svptrue_b32(), &q[i]);\n\n        // Accumulate sum horizontally\n        svint32_t sum_vec = svaddv_s32(svptrue_b32(), vec);\n        sum += svlasta_s32(svptrue_b32(), sum_vec);\n\n        // Check palindromic property\n        svint32_t reverse_vec = svrev_s32(vec);\n        svbool_t cmp = svcmpeq_s32(svptrue_b32(), vec, reverse_vec);\n        if (!svptest_first(svptrue_b32(), cmp)) {\n            is_palindromic = false;\n            break;\n        }\n    }\n\n    // Final check for palindromic property across the entire vector\n    for (size_t i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - i - 1]) {\n            is_palindromic = false;\n            break;\n        }\n    }\n\n    return is_palindromic && (sum <= w);\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active lanes\n\n    // Load the vector into an SVE register\n    svint32_t vec = svld1(pg, q.data());\n\n    // Compute the sum of elements using SVE intrinsics\n    int sum = svaddv(pg, vec);\n\n    // Check if the sum exceeds the maximum weight\n    if (sum > w) {\n        return false;\n    }\n\n    // Check if the vector is palindromic\n    svint32_t reversed_vec = svrev(vec);\n    svbool_t is_palindromic = svcmpeq(pg, vec, reversed_vec);\n\n    // Reduce the predicate to check if all elements are palindromic\n    return svptest_first(pg, is_palindromic);\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active lanes\n\n    // Load the vector into an SVE register\n    svint32_t vec = svld1(pg, q.data());\n\n    // Compute the sum of elements using SVE intrinsics\n    int sum = svaddv(pg, vec);\n\n    // Check if the sum exceeds the maximum weight\n    if (sum > w) {\n        return false;\n    }\n\n    // Check if the vector is palindromic\n    svint32_t reversed_vec = svrev(vec);\n    svbool_t is_palindromic = svcmpeq(pg, vec, reversed_vec);\n\n    // Reduce the predicate to a single boolean value\n    return svptest_first(is_palindromic, pg);\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    int64_t sum = 0;\n    bool is_palindromic = true;\n\n    // Calculate the sum and check if the vector is palindromic using SVE\n    svint32_t vec_sum = svdup_n_s32(0);\n    for (int i = 0; i < n; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t vec1 = svld1_s32(pg, &q[i]);\n        svint32_t vec2 = svld1rw_s32(pg, &q[n - i - svcntw()]);\n\n        // Accumulate sum\n        vec_sum = svadd_s32_z(pg, vec_sum, vec1);\n\n        // Check palindromic property\n        svbool_t cmp = svcmpeq(pg, vec1, svrev_w(pg, vec2));\n        if (!svptest_first(pg, cmp)) {\n            is_palindromic = false;\n        }\n    }\n\n    // Reduce the vector sum to scalar\n    sum = svaddv(svptrue_b32(), vec_sum);\n\n    return is_palindromic && (sum <= w);\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    // Calculate the number of SVE vector elements needed\n    int vec_size = svcntw(); // Number of integers in an SVE vector\n    int num_vecs = (n + vec_size - 1) / vec_size;\n\n    for (int i = 0; i < num_vecs; ++i) {\n        // Load vectors from the start and end of the array\n        svint32_t vec_start = svld1_s32(svptrue_b32(), &arr[i * vec_size]);\n        svint32_t vec_end = svld1_s32(svptrue_b32(), &arr[n - (i + 1) * vec_size]);\n\n        // Reverse the end vector\n        svint32_t vec_end_reversed = svrev_w(vec_end);\n\n        // Compare the two vectors\n        svbool_t cmp_mask = svcmpeq(vec_start, vec_end_reversed);\n\n        // Count mismatches\n        changes += svcntp_b32(svptrue_b32(), svnot_z(svptrue_b32(), cmp_mask));\n    }\n\n    // Adjust for potential over-counting due to padding\n    int total_comparisons = (num_vecs * vec_size) / 2;\n    return changes > total_comparisons ? total_comparisons : changes;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    // Calculate the number of SVE vector registers needed\n    int vec_len = svcntw(); // Number of integers per SVE vector\n    int num_vecs = (n + vec_len - 1) / vec_len; // Ceiling division\n\n    for (int i = 0; i < num_vecs; ++i) {\n        // Load vectors from the start and end of the array\n        svint32_t vec_start = svld1_s32(svptrue_b32(), &arr[i * vec_len]);\n        svint32_t vec_end = svld1_s32(svptrue_b32(), &arr[n - (i + 1) * vec_len]);\n\n        // Reverse the end vector\n        svint32_t vec_end_reversed = svrev_w(vec_end);\n\n        // Compare the two vectors\n        svbool_t cmp_mask = svcmpeq_s32(svptrue_b32(), vec_start, vec_end_reversed);\n\n        // Count mismatches\n        changes += svcntp_b32(svptrue_b32(), svnot_b_z(svptrue_b32(), cmp_mask));\n    }\n\n    // Adjust for potential overcounting due to padding\n    int total_comparisons = (num_vecs * vec_len);\n    if (total_comparisons > n) {\n        changes -= (total_comparisons - n);\n    }\n\n    return changes / 2;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    // Calculate the number of SVE vector elements needed\n    int vec_count = (n + svcntw() - 1) / svcntw();\n\n    for (int i = 0; i < vec_count; ++i) {\n        // Load vectors from the start and end of the array\n        svint32_t vec_start = svld1_s32(svptrue_b32(), &arr[i * svcntw()]);\n        svint32_t vec_end = svld1_s32(svptrue_b32(), &arr[n - (i + 1) * svcntw()]);\n\n        // Reverse the end vector\n        svint32_t vec_end_reversed = svrev_w(vec_end);\n\n        // Compare the two vectors for equality\n        svbool_t cmp_mask = svcmpeq_s32(svptrue_b32(), vec_start, vec_end_reversed);\n\n        // Count the number of non-equal elements\n        changes += svcntp_b32(svptrue_b32(), svnot_b_z(svptrue_b32(), cmp_mask));\n    }\n\n    // Handle any remaining elements that didn't fit into a full vector\n    int remainder = n % svcntw();\n    if (remainder > 0) {\n        svbool_t pred = svwhilelt_b32(0, remainder);\n        svint32_t vec_start = svld1_s32(pred, &arr[vec_count * svcntw()]);\n        svint32_t vec_end = svld1_s32(pred, &arr[n - vec_count * svcntw() - remainder]);\n        svint32_t vec_end_reversed = svrev_w(vec_end);\n\n        svbool_t cmp_mask = svcmpeq_s32(pred, vec_start, vec_end_reversed);\n        changes += svcntp_b32(pred, svnot_b_z(pred, cmp_mask));\n    }\n\n    return changes / 2;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    // Calculate the number of SVE vector elements needed\n    int vec_count = (n + svcntw() - 1) / svcntw();\n\n    for (int i = 0; i < vec_count; ++i) {\n        // Load vectors from the start and end of the array\n        svint32_t vec_start = svld1_s32(svptrue_b32(), &arr[i * svcntw()]);\n        svint32_t vec_end = svld1_s32(svptrue_b32(), &arr[n - (i + 1) * svcntw()]);\n\n        // Reverse the end vector\n        svint32_t vec_end_reversed = svrev_w(vec_end);\n\n        // Compare the two vectors\n        svbool_t cmp_mask = svcmpeq(vec_start, vec_end_reversed);\n\n        // Count the number of mismatches\n        changes += svcntp_b32(svptrue_b32(), svnot_b_z(svptrue_b32(), cmp_mask));\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n\n    // Calculate the number of SVE vector elements needed\n    int vec_count = (n + svcntw() - 1) / svcntw();\n\n    for (int i = 0; i < vec_count; ++i) {\n        // Load vectors from the start and end of the array\n        svint32_t vec_start = svld1_s32(svptrue_b32(), &arr[i * svcntw()]);\n        svint32_t vec_end = svld1_s32(svptrue_b32(), &arr[n - (i + 1) * svcntw()]);\n\n        // Reverse the end vector\n        svint32_t vec_end_reversed = svrev_w(vec_end);\n\n        // Compare the two vectors for equality\n        svbool_t cmp_mask = svcmpeq(svptrue_b32(), vec_start, vec_end_reversed);\n\n        // Count the number of non-equal elements\n        changes += svcntp_b32(svptrue_b32(), svnot_b_z(svptrue_b32(), cmp_mask));\n    }\n\n    // Handle any remaining elements that don't fit into a full vector\n    int remainder = n % svcntw();\n    if (remainder > 0) {\n        svbool_t pred = svwhilelt_b32(0, remainder);\n        svint32_t vec_start = svld1_s32(pred, &arr[vec_count * svcntw()]);\n        svint32_t vec_end = svld1_s32(pred, &arr[n - vec_count * svcntw() - remainder]);\n\n        // Reverse the end vector\n        svint32_t vec_end_reversed = svrev_w(vec_end);\n\n        // Compare the two vectors for equality\n        svbool_t cmp_mask = svcmpeq(pred, vec_start, vec_end_reversed);\n\n        // Count the number of non-equal elements\n        changes += svcntp_b32(pred, svnot_b_z(pred, cmp_mask));\n    }\n\n    return changes / 2;\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    size_t total_chars1 = 0, total_chars2 = 0;\n\n    // Process lst1\n    for (const auto& str : lst1) {\n        size_t len = str.size();\n        size_t i = 0;\n        while (i + svcntb() <= len) {\n            svuint8_t chars = svld1sb_u8((const uint8_t*)(str.data() + i));\n            svbool_t pg = svwhilelt_b8(i, len);\n            total_chars1 += svcntp_b8(pg, chars);\n            i += svcntb();\n        }\n        total_chars1 += len - i; // Handle remaining characters\n    }\n\n    // Process lst2\n    for (const auto& str : lst2) {\n        size_t len = str.size();\n        size_t i = 0;\n        while (i + svcntb() <= len) {\n            svuint8_t chars = svld1sb_u8((const uint8_t*)(str.data() + i));\n            svbool_t pg = svwhilelt_b8(i, len);\n            total_chars2 += svcntp_b8(pg, chars);\n            i += svcntb();\n        }\n        total_chars2 += len - i; // Handle remaining characters\n    }\n\n    return total_chars1 <= total_chars2 ? lst1 : lst2;\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    size_t total_chars1 = 0, total_chars2 = 0;\n\n    // Process lst1\n    for (const auto& str : lst1) {\n        size_t len = str.size();\n        size_t i = 0;\n        while (i <= len - svcntb()) {\n            svuint8_t vec = svld1ub(svptrue_b8(), reinterpret_cast<const uint8_t*>(str.data() + i));\n            total_chars1 += svcntp_b8(svptrue_b8(), vec);\n            i += svcntb();\n        }\n        total_chars1 += len - i; // Handle remaining characters\n    }\n\n    // Process lst2\n    for (const auto& str : lst2) {\n        size_t len = str.size();\n        size_t i = 0;\n        while (i <= len - svcntb()) {\n            svuint8_t vec = svld1ub(svptrue_b8(), reinterpret_cast<const uint8_t*>(str.data() + i));\n            total_chars2 += svcntp_b8(svptrue_b8(), vec);\n            i += svcntb();\n        }\n        total_chars2 += len - i; // Handle remaining characters\n    }\n\n    // Compare total characters and return the appropriate vector\n    if (total_chars1 <= total_chars2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    size_t total_chars1 = 0, total_chars2 = 0;\n\n    // Process lst1\n    for (const auto& str : lst1) {\n        size_t len = str.size();\n        total_chars1 += len;\n    }\n\n    // Process lst2\n    for (const auto& str : lst2) {\n        size_t len = str.size();\n        total_chars2 += len;\n    }\n\n    // Compare total characters and return the appropriate vector\n    if (total_chars1 <= total_chars2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    size_t total_chars1 = 0, total_chars2 = 0;\n    size_t i = 0;\n\n    // Process lst1\n    while (i + svcntw() <= lst1.size()) {\n        svuint32_t lengths = svld1uw(svptrue_b32(), reinterpret_cast<const uint32_t*>(&lst1[i]));\n        svbool_t pg = svwhilelt_b32(i, lst1.size());\n        svuint32_t char_counts = svlen(lengths);\n        total_chars1 += svaddv(pg, char_counts);\n        i += svcntw();\n    }\n    for (; i < lst1.size(); ++i) {\n        total_chars1 += lst1[i].size();\n    }\n\n    i = 0;\n    // Process lst2\n    while (i + svcntw() <= lst2.size()) {\n        svuint32_t lengths = svld1uw(svptrue_b32(), reinterpret_cast<const uint32_t*>(&lst2[i]));\n        svbool_t pg = svwhilelt_b32(i, lst2.size());\n        svuint32_t char_counts = svlen(lengths);\n        total_chars2 += svaddv(pg, char_counts);\n        i += svcntw();\n    }\n    for (; i < lst2.size(); ++i) {\n        total_chars2 += lst2[i].size();\n    }\n\n    return (total_chars1 <= total_chars2) ? lst1 : lst2;\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    size_t total_chars1 = 0, total_chars2 = 0;\n\n    // Process lst1\n    for (const auto& str : lst1) {\n        size_t len = str.size();\n        size_t i = 0;\n        while (i <= len - svcntb()) {\n            svuint8_t vec = svld1sb_u8((const uint8_t*)(str.data() + i));\n            svbool_t pred = svwhilelt_b8(i, len);\n            total_chars1 += svcntp_b8(pred, vec);\n            i += svcntb();\n        }\n        total_chars1 += len - i; // Handle remaining characters\n    }\n\n    // Process lst2\n    for (const auto& str : lst2) {\n        size_t len = str.size();\n        size_t i = 0;\n        while (i <= len - svcntb()) {\n            svuint8_t vec = svld1sb_u8((const uint8_t*)(str.data() + i));\n            svbool_t pred = svwhilelt_b8(i, len);\n            total_chars2 += svcntp_b8(pred, vec);\n            i += svcntb();\n        }\n        total_chars2 += len - i; // Handle remaining characters\n    }\n\n    return total_chars1 <= total_chars2 ? lst1 : lst2;\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n <= 1) {\n        return x == 1;\n    }\n\n    svbool_t pg = svptrue_b64();\n    svuint64_t vx = svdup_u64(x);\n    svuint64_t vn = svdup_u64(n);\n    svuint64_t vresult = svdup_u64(1);\n    svbool_t vcond = svcmpeq(pg, vresult, vx);\n\n    while (svptest_any(pg, vcond) == 0) {\n        vresult = svmul_x(pg, vresult, vn);\n        vcond = svcmpeq(pg, vresult, vx);\n        if (svptest_any(pg, svcmpgt(pg, vresult, vx))) {\n            break;\n        }\n    }\n\n    return svptest_any(pg, vcond);\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n <= 1) {\n        return x == 1;\n    }\n\n    svuint64_t vn = svdup_n_u64(n);\n    svuint64_t vx = svdup_n_u64(x);\n    svbool_t pg = svwhilelt_b64(0, 64); // Predicate for active lanes\n\n    svuint64_t power = svdup_n_u64(1);\n    svbool_t result = svcmpeq(pg, power, vx);\n\n    while (svptest_any(svptrue_b64(), result) == 0) {\n        power = svmul_x(pg, power, vn);\n        result = svcmpeq(pg, power, vx);\n\n        // Break condition to avoid infinite loop\n        svbool_t overflow_check = svcmplt(pg, power, vn);\n        if (svptest_any(svptrue_b64(), overflow_check)) {\n            break;\n        }\n    }\n\n    return svptest_any(svptrue_b64(), result);\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n <= 1) {\n        return x == 1;\n    }\n\n    svuint64_t vn = svdup_u64(n);\n    svuint64_t vx = svdup_u64(x);\n    svbool_t pg = svptrue_b64();\n\n    svuint64_t power = svdup_u64(1);\n    svbool_t result = svcmpeq(pg, power, vx);\n\n    while (svptest_any(pg, result) == 0) {\n        power = svmul_x(pg, power, vn);\n        result = svcmpeq(pg, power, vx);\n\n        if (svmaxv(pg, power) > x) {\n            break;\n        }\n    }\n\n    return svptest_any(pg, result);\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n <= 1) {\n        return x == 1;\n    }\n\n    svuint64_t vn = svdup_u64(n);\n    svuint64_t vx = svdup_u64(x);\n    svbool_t pg = svptrue_b64();\n\n    svuint64_t power = svdup_u64(1);\n    svbool_t result = svcmpeq(pg, power, vx);\n\n    while (svptest_any(svptrue_b64(), result) == 0) {\n        power = svmul_x(pg, power, vn);\n        result = svcmpeq(pg, power, vx);\n\n        // Break condition to avoid infinite loop\n        svbool_t overflow_check = svcmple(pg, power, vx);\n        if (svptest_first(svptrue_b64(), overflow_check) == 0) {\n            break;\n        }\n    }\n\n    return svptest_any(svptrue_b64(), result);\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n <= 1) {\n        return x == 1;\n    }\n\n    svuint64_t vn = svdup_u64(n);\n    svuint64_t vx = svdup_u64(x);\n    svbool_t pg = svptrue_b64();\n\n    svuint64_t power = svdup_u64(1);\n    svbool_t result = svcmpeq(pg, power, vx);\n\n    while (svptest_any(pg, svcmpne(pg, power, vx))) {\n        power = svmul_x(pg, power, vn);\n        result = svorr_z(pg, result, svcmpeq(pg, power, vx));\n    }\n\n    return svptest_any(pg, result);\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint hex_key_simd(const std::string & num) {\n    int count = 0;\n    size_t len = num.length();\n    const char *data = num.c_str();\n\n    // Define the set of prime hexadecimal digits\n    svuint8_t prime_mask = sveor_n_u8_z(svptrue_b8(), \n                                        svcmpeq_n_u8_z(svptrue_b8(), svdup_u8('2'), '2'),\n                                        svcmpeq_n_u8_z(svptrue_b8(), svdup_u8('3'), '3'));\n    prime_mask = sveor_n_u8_z(svptrue_b8(), prime_mask, \n                              svcmpeq_n_u8_z(svptrue_b8(), svdup_u8('5'), '5'));\n    prime_mask = sveor_n_u8_z(svptrue_b8(), prime_mask, \n                              svcmpeq_n_u8_z(svptrue_b8(), svdup_u8('7'), '7'));\n    prime_mask = sveor_n_u8_z(svptrue_b8(), prime_mask, \n                              svcmpeq_n_u8_z(svptrue_b8(), svdup_u8('B'), 'B'));\n    prime_mask = sveor_n_u8_z(svptrue_b8(), prime_mask, \n                              svcmpeq_n_u8_z(svptrue_b8(), svdup_u8('D'), 'D'));\n\n    size_t i = 0;\n    while (i + svcntw() <= len) {\n        svuint8_t vec = svld1sb_u8(svptrue_b8(), data + i);\n        svbool_t matches = svcmpeq_n_u8(svptrue_b8(), vec, prime_mask);\n        count += svcntp_b8(svptrue_b8(), matches);\n        i += svcntw();\n    }\n\n    for (; i < len; ++i) {\n        if (num[i] == '2' || num[i] == '3' || num[i] == '5' || num[i] == '7' ||\n            num[i] == 'B' || num[i] == 'D') {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    int count = 0;\n    size_t len = num.length();\n    size_t i = 0;\n\n    // Create a predicate to identify prime hexadecimal digits\n    svuint8_t prime_mask = svdup_u8(0);\n    prime_mask = svorr_u8(prime_mask, sveor_n_u8(prime_mask, '2'));\n    prime_mask = svorr_u8(prime_mask, sveor_n_u8(prime_mask, '3'));\n    prime_mask = svorr_u8(prime_mask, sveor_n_u8(prime_mask, '5'));\n    prime_mask = svorr_u8(prime_mask, sveor_n_u8(prime_mask, '7'));\n    prime_mask = svorr_u8(prime_mask, sveor_n_u8(prime_mask, 'B'));\n    prime_mask = svorr_u8(prime_mask, sveor_n_u8(prime_mask, 'D'));\n\n    while (i + svcntb() <= len) {\n        // Load a vector of characters from the string\n        svuint8_t vec = svld1sb_u8(svptrue_b8(), reinterpret_cast<const uint8_t*>(&num[i]));\n\n        // Compare with the prime mask\n        svbool_t is_prime = svcmpeq_u8(svptrue_b8(), vec, prime_mask);\n\n        // Count the number of primes in this vector\n        count += svcntp_b8(svptrue_b8(), is_prime);\n\n        i += svcntb();\n    }\n\n    // Process remaining elements\n    for (; i < len; ++i) {\n        char c = num[i];\n        if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n            ++count;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint hex_key_simd(const std::string & num) {\n    int count = 0;\n    size_t len = num.length();\n    size_t i = 0;\n\n    // Create a predicate to identify prime hexadecimal digits\n    svuint8_t prime_mask = svdup_u8(0);\n    prime_mask = svorr_u8(prime_mask, sveor_n_u8(svdup_u8(0), '2', svptrue_b8()));\n    prime_mask = svorr_u8(prime_mask, sveor_n_u8(svdup_u8(0), '3', svptrue_b8()));\n    prime_mask = svorr_u8(prime_mask, sveor_n_u8(svdup_u8(0), '5', svptrue_b8()));\n    prime_mask = svorr_u8(prime_mask, sveor_n_u8(svdup_u8(0), '7', svptrue_b8()));\n    prime_mask = svorr_u8(prime_mask, sveor_n_u8(svdup_u8(0), 'B', svptrue_b8()));\n    prime_mask = svorr_u8(prime_mask, sveor_n_u8(svdup_u8(0), 'D', svptrue_b8()));\n\n    while (i + svcntb() <= len) {\n        // Load a vector of characters from the string\n        svuint8_t vec = svld1sb_u8(svptrue_b8(), reinterpret_cast<const uint8_t*>(&num[i]));\n\n        // Compare with the prime mask\n        svbool_t matches = svcmpeq_u8(svptrue_b8(), vec, prime_mask);\n\n        // Count the number of matches in this vector\n        count += svcntp_b8(svptrue_b8(), matches);\n\n        i += svcntb();\n    }\n\n    // Process any remaining elements\n    for (; i < len; ++i) {\n        char c = num[i];\n        if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n            ++count;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    int count = 0;\n    size_t len = num.length();\n    size_t i = 0;\n\n    // Create a predicate to identify prime hexadecimal digits: 2, 3, 5, 7, B, D\n    svuint8_t prime_mask = svdup_u8(0);\n    prime_mask = svorr_u8(prime_mask, sveor_n_u8(svdup_u8(0), '2'));\n    prime_mask = svorr_u8(prime_mask, sveor_n_u8(svdup_u8(0), '3'));\n    prime_mask = svorr_u8(prime_mask, sveor_n_u8(svdup_u8(0), '5'));\n    prime_mask = svorr_u8(prime_mask, sveor_n_u8(svdup_u8(0), '7'));\n    prime_mask = svorr_u8(prime_mask, sveor_n_u8(svdup_u8(0), 'B'));\n    prime_mask = svorr_u8(prime_mask, sveor_n_u8(svdup_u8(0), 'D'));\n\n    while (i + svcntb() <= len) {\n        // Load a vector of characters from the string\n        svuint8_t vec = svld1sb_u8(svptrue_b8(), reinterpret_cast<const uint8_t*>(&num[i]));\n\n        // Compare the vector with the prime mask\n        svbool_t matches = svcmpeq_u8(svptrue_b8(), vec, prime_mask);\n\n        // Count the number of matches in this vector\n        count += svcntp_b8(svptrue_b8(), matches);\n\n        i += svcntb();\n    }\n\n    // Process remaining elements\n    for (; i < len; ++i) {\n        char c = num[i];\n        if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n            ++count;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    int count = 0;\n    size_t len = num.length();\n    size_t i = 0;\n\n    // Define a predicate for prime hexadecimal digits: 2, 3, 5, 7, B, D\n    uint8_t prime_map[16] = {0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0};\n    svuint8_t prime_lookup = svld1_u8(prime_map);\n\n    while (i + svcntb() <= len) {\n        // Load a vector of characters from the string\n        svuint8_t vec = svld1sb_u8((const int8_t*)(num.data() + i));\n\n        // Convert characters to their numeric values\n        svuint8_t hex_vals = svsub_n_u8(svand_n_u8(vec, 0xDF), '0');\n        svbool_t is_alpha = svcmpge_n_u8(hex_vals, 17);\n        hex_vals = svsel_u8(is_alpha, svsub_n_u8(hex_vals, 7), hex_vals);\n\n        // Lookup if the values are prime using the lookup table\n        svuint8_t indices = svmin_n_u8(hex_vals, 15);\n        svuint8_t is_prime = svtbl_u8(prime_lookup, indices);\n\n        // Count the number of primes in this vector\n        count += svcntp_b8(svptrue_b8(), svcmpeq_n_u8(is_prime, 1));\n\n        i += svcntb();\n    }\n\n    // Process remaining elements\n    for (; i < len; ++i) {\n        char c = num[i];\n        int val = (c >= 'A') ? (c - 'A' + 10) : (c - '0');\n        if (val < 16 && prime_map[val]) {\n            ++count;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool is_happy_simd(const std::string & s) {\n    size_t len = s.length();\n    if (len < 3) return false;\n\n    svbool_t pg = svwhilelt_b8(0, len - 2); // Predicate for valid elements\n    svuint8_t vec1, vec2, vec3;\n\n    for (size_t i = 0; i < len - 2; i += svcntb()) {\n        svbool_t active = svwhilelt_b8(i, len - 2); // Update predicate for remaining elements\n        active = svand_z(pg, active);\n\n        vec1 = svld1sb_u8(active, reinterpret_cast<const int8_t*>(&s[i]));     // Load s[i]\n        vec2 = svld1sb_u8(active, reinterpret_cast<const int8_t*>(&s[i + 1])); // Load s[i+1]\n        vec3 = svld1sb_u8(active, reinterpret_cast<const int8_t*>(&s[i + 2])); // Load s[i+2]\n\n        svbool_t cmp1 = svcmpeq(active, vec1, vec2); // Compare s[i] == s[i+1]\n        svbool_t cmp2 = svcmpeq(active, vec2, vec3); // Compare s[i+1] == s[i+2]\n        svbool_t cmp3 = svcmpeq(active, vec1, vec3); // Compare s[i] == s[i+2]\n\n        svbool_t any_equal = svorr_z(active, cmp1, svorr_z(active, cmp2, cmp3));\n\n        if (svptest_any(pg, any_equal)) {\n            return false; // Found non-distinct triplet\n        }\n    }\n\n    return true; // All triplets are distinct\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool is_happy_simd(const std::string & s) {\n    size_t len = s.length();\n    if (len < 3) return false;\n\n    svbool_t pg = svwhilelt_b8(0, len - 2); // Predicate for valid elements\n    svuint8_t vec1, vec2, vec3;\n\n    for (size_t i = 0; i < len - 2; i += svcntb()) {\n        svbool_t active = svwhilelt_b8(i, len - 2); // Update predicate for remaining elements\n        active = svand_z(pg, active);\n\n        vec1 = svld1sb_u8(active, reinterpret_cast<const int8_t*>(&s[i]));     // Load s[i]\n        vec2 = svld1sb_u8(active, reinterpret_cast<const int8_t*>(&s[i + 1])); // Load s[i+1]\n        vec3 = svld1sb_u8(active, reinterpret_cast<const int8_t*>(&s[i + 2])); // Load s[i+2]\n\n        svbool_t cmp1 = svcmpeq(active, vec1, vec2); // Compare s[i] == s[i+1]\n        svbool_t cmp2 = svcmpeq(active, vec1, vec3); // Compare s[i] == s[i+2]\n        svbool_t cmp3 = svcmpeq(active, vec2, vec3); // Compare s[i+1] == s[i+2]\n\n        svbool_t any_equal = svorr_z(active, cmp1, svorr_z(active, cmp2, cmp3)); // Any of the comparisons true?\n\n        if (svptest_any(svptrue_b8(), any_equal)) {\n            return false; // If any triplet has duplicates, string is not happy\n        }\n    }\n\n    return true; // All triplets are distinct\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool is_happy_simd(const std::string & s) {\n    size_t len = s.length();\n    if (len < 3) return false;\n\n    svbool_t pg = svwhilelt_b8(0, len - 2); // Predicate for valid elements\n\n    svuint8_t vec1 = svld1(pg, reinterpret_cast<const uint8_t*>(s.data()));       // Load s[i]\n    svuint8_t vec2 = svld1(pg, reinterpret_cast<const uint8_t*>(s.data() + 1));   // Load s[i+1]\n    svuint8_t vec3 = svld1(pg, reinterpret_cast<const uint8_t*>(s.data() + 2));   // Load s[i+2]\n\n    svbool_t cmp1 = svcmpeq(pg, vec1, vec2); // Compare s[i] == s[i+1]\n    svbool_t cmp2 = svcmpeq(pg, vec2, vec3); // Compare s[i+1] == s[i+2]\n    svbool_t cmp3 = svcmpeq(pg, vec1, vec3); // Compare s[i] == s[i+2]\n\n    svbool_t happy = svnot_b_z(pg, svorr_z(pg, cmp1, svorr_z(pg, cmp2, cmp3))); // Check all distinct\n\n    return svptest_first(happy); // Return true if all triplets are happy\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool is_happy_simd(const std::string & s) {\n    size_t len = s.length();\n    if (len < 3) return false;\n\n    size_t vl = svcntb(); // Get the vector length in bytes\n    svbool_t pg = svwhilelt_b8(0, len); // Predicate for active elements\n\n    const uint8_t* data = reinterpret_cast<const uint8_t*>(s.data());\n    svuint8_t vec_prev2, vec_prev1, vec_curr;\n\n    for (size_t i = 0; i < len - 2; i += vl) {\n        svbool_t active = svwhilelt_b8(i, len - 2);\n\n        vec_prev2 = svld1sb(pg, data + i);\n        vec_prev1 = svld1sb(pg, data + i + 1);\n        vec_curr = svld1sb(pg, data + i + 2);\n\n        svbool_t cmp1 = svcmpeq(pg, vec_prev2, vec_prev1);\n        svbool_t cmp2 = svcmpeq(pg, vec_prev1, vec_curr);\n        svbool_t cmp3 = svcmpeq(pg, vec_prev2, vec_curr);\n\n        svbool_t any_equal = svorr_z(pg, cmp1, svorr_z(pg, cmp2, cmp3));\n\n        if (svptest_any(pg, any_equal)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool is_happy_simd(const std::string & s) {\n    size_t len = s.length();\n    if (len < 3) return false;\n\n    svbool_t pg = svwhilelt_b8(0, len - 2); // Predicate for valid elements\n    svuint8_t vec1, vec2, vec3;\n\n    for (size_t i = 0; i < len - 2; i += svcntb()) {\n        svbool_t active = svwhilelt_b8(i, len - 2); // Active lanes for this iteration\n        active = svand_b_z(pg, active); // Combine with global predicate\n\n        vec1 = svld1sb_u8(active, &s[i]);     // Load s[i]\n        vec2 = svld1sb_u8(active, &s[i + 1]); // Load s[i+1]\n        vec3 = svld1sb_u8(active, &s[i + 2]); // Load s[i+2]\n\n        svbool_t cmp1 = svcmpeq(active, vec1, vec2); // Compare s[i] == s[i+1]\n        svbool_t cmp2 = svcmpeq(active, vec1, vec3); // Compare s[i] == s[i+2]\n        svbool_t cmp3 = svcmpeq(active, vec2, vec3); // Compare s[i+1] == s[i+2]\n\n        svbool_t any_equal = svorr_b_z(active, cmp1, svorr_b_z(active, cmp2, cmp3));\n\n        if (svptest_any(active, any_equal)) {\n            return false; // Found non-happy triplet\n        }\n    }\n\n    return true; // All triplets are happy\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cmath>\n\nbool prime_length_simd(const std::string & str) {\n    size_t len = str.length();\n    if (len < 2) return false;\n\n    // Load the length into a predicate register for SVE operations\n    svbool_t pg = svwhilelt_b64(0, len);\n\n    // Check divisors from 2 to sqrt(len)\n    size_t limit = static_cast<size_t>(std::sqrt(len));\n    size_t divisor = 2;\n\n    while (divisor <= limit) {\n        // Broadcast the current divisor across the vector\n        svuint64_t vec_divisor = svdup_u64(divisor);\n\n        // Create a vector of indices\n        svuint64_t vec_indices = svindex_u64(0, 1);\n\n        // Compute the remainder of len divided by each index\n        svuint64_t vec_remainder = svsub_u64(svdup_u64(len), svmul_u64(vec_divisor, vec_indices));\n\n        // Check if any remainder is zero\n        svbool_t is_zero = svcmpeq(pg, vec_remainder, svdup_u64(0));\n\n        // If any remainder is zero, len is not prime\n        if (svptest_any(svptrue_b64(), is_zero)) {\n            return false;\n        }\n\n        divisor++;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cmath>\n\nbool prime_length_simd(const std::string & str) {\n    size_t len = str.length();\n    if (len < 2) return false;\n\n    // Load the length into a predicate register for SVE operations\n    svbool_t pg = svwhilelt_b64(0, len);\n\n    // Check divisors from 2 to sqrt(len)\n    size_t sqrt_len = static_cast<size_t>(std::sqrt(len));\n    size_t divisor = 2;\n\n    while (divisor <= sqrt_len) {\n        svuint64_t vec_divisor = svdup_u64(divisor);\n        svuint64_t vec_len = svdup_u64(len);\n\n        // Perform modulo operation in parallel\n        svuint64_t remainder = svsub_u64(vec_len, svmul_u64(svdup_u64(len / divisor), vec_divisor));\n\n        // Check if any remainder is zero\n        if (svptest_any(pg, svcmpeq_n_u64(pg, remainder, 0))) {\n            return false;\n        }\n\n        divisor++;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cmath>\n\nbool prime_length_simd(const std::string & str) {\n    size_t len = str.length();\n    if (len < 2) return false;\n\n    // Load the length into a predicate register for SVE operations\n    svbool_t pg = svwhilelt_b64(0, len);\n\n    // Check divisors from 2 to sqrt(len)\n    size_t sqrt_len = static_cast<size_t>(std::sqrt(len));\n    size_t divisor = 2;\n\n    while (divisor <= sqrt_len) {\n        svuint64_t vec_divisor = svdup_u64(divisor);\n        svuint64_t vec_len = svdup_u64(len);\n\n        // Perform modulo operation in parallel\n        svuint64_t vec_mod = svmod_u64_x(pg, vec_len, vec_divisor);\n\n        // Check if any element is divisible (mod == 0)\n        if (svptest_any(svptrue_b64(), svcmpeq_n_u64(pg, vec_mod, 0))) {\n            return false; // Not a prime length\n        }\n\n        divisor++;\n    }\n\n    return true; // Prime length\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cmath>\n\nbool prime_length_simd(const std::string & str) {\n    size_t len = str.length();\n    if (len < 2) return false;\n\n    // Load the length into a predicate register for SVE operations\n    svbool_t pg = svwhilelt_b64(0, len);\n\n    // Check divisors from 2 to sqrt(len)\n    size_t sqrt_len = static_cast<size_t>(std::sqrt(len));\n    size_t divisor = 2;\n\n    while (divisor <= sqrt_len) {\n        // Broadcast divisor across vector\n        svuint64_t vec_divisor = svdup_u64(divisor);\n\n        // Create a vector of values [0, 1, ..., VL-1] + divisor\n        svuint64_t vec_indices = svindex_u64(divisor, 1);\n\n        // Compute len % divisor for each lane\n        svuint64_t vec_mod = svmod_u64_x(pg, svdup_u64(len), vec_indices);\n\n        // Check if any remainder is zero\n        svbool_t is_zero = svcmpeq_n_u64(pg, vec_mod, 0);\n        if (svptest_any(svptrue_b64(), is_zero)) {\n            return false;\n        }\n\n        // Increment divisor by vector length\n        divisor += svcntd();\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cmath>\n\nbool prime_length_simd(const std::string & str) {\n    size_t len = str.length();\n    if (len < 2) return false;\n\n    // Load the length into a predicate register for SVE operations\n    svbool_t pg = svptrue_b8();\n\n    // Calculate the square root of the length\n    uint64_t sqrt_len = static_cast<uint64_t>(std::sqrt(len));\n\n    // Use SVE to parallelize the divisibility checks\n    svuint64_t vec_len = svdup_u64(len);\n    svuint64_t vec_i = svindex_u64(2, 1); // Start divisors from 2\n\n    bool is_prime = true;\n    uint64_t i = 2;\n\n    while (i <= sqrt_len && is_prime) {\n        svbool_t pred = svwhilelt_b64(i, sqrt_len + 1);\n        svuint64_t vec_mod = svmod_u64_x(pred, vec_len, vec_i);\n\n        // Check if any modulus result is zero\n        is_prime = !svptest_any(svptrue_b64(), svcmpeq_n_u64(pred, vec_mod, 0));\n\n        // Increment the divisor index\n        i += svcntw();\n        vec_i = svadd_u64_z(pg, vec_i, svcntw());\n    }\n\n    return is_prime;\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string solve_simd(uint64_t N) {\n    uint64_t sum = 0;\n    svuint64_t vec_sum = svdup_u64(0);\n\n    while (N > 0) {\n        uint64_t chunk = N % 1000000000; // Process in chunks of 9 digits\n        N /= 1000000000;\n\n        svuint64_t vec_digits = svdup_u64(chunk);\n        svbool_t pred = svwhilelt_b64(0, 9); // Predicate for up to 9 iterations\n\n        while (svptest_any(svptrue_b64(), pred)) {\n            svuint64_t digit_vals = svand_u64_x(pred, vec_digits, 0xF); // Extract last 4 bits\n            vec_sum = svadd_u64_m(pred, vec_sum, digit_vals);\n            vec_digits = svlsr_n_u64_x(pred, vec_digits, 4); // Shift right by 4 bits\n            pred = svwhilelt_b64(0, svsub_n_u64_z(pred, svclz_u64(vec_digits), 60));\n        }\n\n        // Reduce vector sum to scalar\n        sum += svaddv_u64(svptrue_b64(), vec_sum);\n    }\n\n    // Convert sum to binary string\n    std::string binary = \"\";\n    if (sum == 0) return \"0\";\n    while (sum > 0) {\n        binary = char('0' + (sum & 1)) + binary;\n        sum >>= 1;\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <bitset>\n\nstd::string solve_simd(uint64_t N) {\n    uint64_t sum = 0;\n    svuint64_t vec_sum = svdup_u64(0);\n\n    while (N > 0) {\n        uint64_t chunk = N % 1000000000; // Process in chunks of 9 digits\n        N /= 1000000000;\n\n        svuint64_t vec_digits = svdup_u64(chunk);\n        svbool_t pred = svwhilelt_b64(0, 9); // Predicate for up to 9 iterations\n\n        while (svptest_any(svptrue_b64(), pred)) {\n            svuint64_t digit_vals = svand_u64_x(pred, vec_digits, 0xF); // Extract lowest 4 bits\n            vec_sum = svadd_u64_m(vec_sum, pred, vec_sum, digit_vals);\n            vec_digits = svlsr_n_u64_x(pred, vec_digits, 4); // Shift right by 4 bits\n            pred = svwhilelt_b64(0, svsub_n_u64_z(pred, svlen_u64(vec_digits), 1));\n        }\n    }\n\n    // Reduce the vector sum to a scalar\n    uint64_t total_sum = 0;\n    svbool_t all_active = svptrue_b64();\n    total_sum = svaddv_u64(all_active, vec_sum);\n\n    // Convert the sum to binary string\n    std::string binary = std::bitset<64>(total_sum).to_string();\n    // Remove leading zeros\n    size_t first_one = binary.find('1');\n    return first_one != std::string::npos ? binary.substr(first_one) : \"0\";\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <bitset>\n\nstd::string solve_simd(uint64_t N) {\n    uint64_t sum = 0;\n    svuint8_t vec_digits = svld1sb_u8(svptrue_b8(), reinterpret_cast<const uint8_t*>(&N));\n    svbool_t pred = svwhilelt_b8(0, 8);\n\n    while (svptest_any(svptrue_b8(), pred)) {\n        svuint8_t vec_extract = svand_x(pred, vec_digits, 0xF);\n        uint64_t temp_sum = svcntp_b8(pred, vec_extract);\n        sum += temp_sum;\n\n        vec_digits = svtbl(vec_digits, svadd_x(pred, svindex_u8(0, 1), 4));\n        pred = svwhilelt_b8(0, svlen_u8(vec_digits));\n    }\n\n    std::string binary = std::bitset<64>(sum).to_string();\n    auto first_one = binary.find('1');\n    return first_one != std::string::npos ? binary.substr(first_one) : \"0\";\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string solve_simd(uint64_t N) {\n    uint64_t sum = 0;\n    svuint8_t vec_sum = svdup_u8(0);\n\n    while (N > 0) {\n        uint8_t digit = N % 10;\n        svuint8_t vec_digit = svdup_u8(digit);\n        vec_sum = svadd_u8(vec_sum, vec_digit);\n        N /= 10;\n    }\n\n    // Horizontal reduction to sum all elements in the vector\n    uint64_t total_sum = 0;\n    svbool_t pg =svptrue_b8();\n    total_sum += svaddv_u8(pg, vec_sum);\n\n    // Convert the sum to binary string\n    std::string binary = \"\";\n    if (total_sum == 0) {\n        binary = \"0\";\n    } else {\n        while (total_sum > 0) {\n            binary = char('0' + (total_sum & 1)) + binary;\n            total_sum >>= 1;\n        }\n    }\n\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <bitset>\n\nstd::string solve_simd(uint64_t N) {\n    uint64_t sum = 0;\n    svuint64_t vec_sum = svdup_u64(0);\n\n    while (N > 0) {\n        uint64_t chunk = N % 1000000000; // Process in chunks of 9 digits\n        N /= 1000000000;\n\n        svuint64_t vec_digits = svdup_u64(chunk);\n        svbool_t pred = svwhilelt_b64(0, 1); // Predicate for active lanes\n\n        // Extract digits using scalar operations and accumulate into vector\n        uint64_t temp = chunk;\n        while (temp > 0) {\n            uint64_t digit = temp % 10;\n            temp /= 10;\n            vec_sum = svadd_u64_m(pred, vec_sum, svdup_u64(digit));\n        }\n    }\n\n    // Reduce the vector sum to a scalar\n    sum = svaddv_u64(svptrue_b64(), vec_sum);\n\n    // Convert sum to binary string\n    std::string binary = std::bitset<64>(sum).to_string();\n    binary.erase(0, binary.find_first_not_of('0')); // Remove leading zeros\n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint add_simd(std::vector<int> lst) {\n    int result = 0;\n    size_t i = 0;\n    size_t n = lst.size();\n    svbool_t pg = svwhilelt_b32(i, n); // Predicate for active lanes\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec = svld1_s32(pg, &lst[i]); // Load vector of integers\n        svbool_t odd_index_mask = svcmpeq_n_s32(pg, svindex_s32(i, 1), 1); // Mask for odd indices\n        svbool_t even_value_mask = svcmpeq_n_s32(pg, svand_s32_z(pg, vec, 1), 0); // Mask for even values\n        svbool_t combined_mask = svand_b_z(pg, odd_index_mask, even_value_mask); // Combine masks\n        svint32_t selected_values = svsel_s32(combined_mask, vec, 0); // Select values matching the condition\n        result += svaddv_s32(combined_mask, selected_values); // Sum the selected values\n\n        i += svcntw(); // Move to next block\n        pg = svwhilelt_b32(i, n); // Update predicate\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint add_simd(std::vector<int> lst) {\n    int result = 0;\n    size_t i = 0;\n    size_t n = lst.size();\n\n    svbool_t pg = svwhilelt_b32(i, n); // Predicate for active lanes\n    svint32_t vec = svld1(pg, &lst[i]); // Load vector from memory\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svbool_t odd_index_mask = svcmpeq_n_s32(pg, svindex_s32(0, 1), 1); // Mask for odd indices\n        svbool_t even_value_mask = svcmpeq_n_s32(pg, svand(vec, 1), 0); // Mask for even values\n        svbool_t combined_mask = svand(odd_index_mask, even_value_mask); // Combine masks\n\n        svint32_t selected_values = svand_z(combined_mask, vec); // Select values based on mask\n        result += svaddv(selected_values); // Horizontal sum of selected values\n\n        i += svcntw(); // Move to next chunk\n        pg = svwhilelt_b32(i, n); // Update predicate\n        vec = svld1(pg, &lst[i]); // Load next vector chunk\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint add_simd(std::vector<int> lst) {\n    int result = 0;\n    size_t i = 0;\n    size_t len = lst.size();\n\n    svbool_t pg = svwhilelt_b32(i, len);\n    svint32_t vec = svld1_s32(pg, &lst[i]);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svbool_t odd_index_mask = svcmpeq_n_s32(pg, svindex_s32(0, 1), 1);\n        svbool_t even_value_mask = svcmpeq_n_s32(pg, svand_s32_z(pg, vec, 1), 0);\n        svbool_t combined_mask = svand_b_z(pg, odd_index_mask, even_value_mask);\n\n        result += svaddv_s32(combined_mask, vec);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, len);\n        vec = svld1_s32(pg, &lst[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint add_simd(std::vector<int> lst) {\n    int result = 0;\n    size_t i = 0;\n    size_t n = lst.size();\n\n    svbool_t pg = svwhilelt_b32(i, n); // Predicate for active lanes\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec = svld1(pg, &lst[i]); // Load vector of integers\n        svbool_t odd_index_mask = svcmpeq_n_s32(pg, svindex_s32(i, 1), 1); // Mask for odd indices\n        svbool_t even_value_mask = svcmpeq_n_s32(pg, svand(vec, 1), 0); // Mask for even values\n        svbool_t combined_mask = svand(odd_index_mask, even_value_mask); // Combine masks\n\n        svint32_t selected_values = svsel(combined_mask, vec, 0); // Select values based on mask\n        result += svaddv(pg, selected_values); // Sum the selected values\n\n        i += svcntw(); // Move to next chunk\n        pg = svwhilelt_b32(i, n); // Update predicate\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint add_simd(std::vector<int> lst) {\n    int result = 0;\n    size_t i = 0;\n    size_t len = lst.size();\n\n    svbool_t pg = svwhilelt_b32(i, len);\n    svint32_t vec = svld1(pg, &lst[i]);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svbool_t odd_index_mask = svcmpeq_n_s32(pg, svindex_s32(0, 1), 1);\n        svbool_t even_value_mask = svcmpeq_n_s32(pg, svand(vec, 1), 0);\n        svbool_t combined_mask = svand(odd_index_mask, even_value_mask);\n\n        svint32_t selected_values = svsel(combined_mask, vec, svdup_n_s32(0));\n        result += svaddv(pg, selected_values);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, len);\n        vec = svld1(pg, &lst[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    std::string result(s.size(), '\\0');\n    size_t i = 0;\n    size_t len = s.size();\n\n    while (i < len) {\n        // Load a vector of characters from the input string\n        svuint8_t vec = svld1sb_u8(svptrue_b8(), reinterpret_cast<const uint8_t*>(&s[i]));\n\n        // Create a mask for valid elements in the vector\n        svbool_t mask = svwhilelt_b8(i, len);\n\n        // Process only valid elements\n        svuint8_t shifted = svadd_u8_m(mask, vec, svdup_u8(8));\n\n        // Handle wrap-around for alphabetic characters\n        svuint8_t is_alpha_lower = svcmpge_n_u8(mask, vec, 'a');\n        svuint8_t is_alpha_upper = svcmpge_n_u8(mask, vec, 'A');\n        svuint8_t is_alpha = svorr_z(mask, is_alpha_lower, is_alpha_upper);\n\n        svuint8_t wrapped = svsub_u8_m(mask, shifted, svdup_u8(26));\n        svuint8_t final = svsel(is_alpha, wrapped, shifted);\n\n        // Store the result back into the output string\n        svst1b_u8(mask, reinterpret_cast<uint8_t*>(&result[i]), final);\n\n        // Move to the next chunk\n        i += svcntb();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    std::string result(s.size(), ' ');\n    size_t i = 0;\n\n    while (i < s.size()) {\n        // Load a vector of characters from the input string\n        svuint8_t vec = svld1sb_u8(sve_all_true_b8(), reinterpret_cast<const uint8_t*>(&s[i]));\n\n        // Create a mask for valid elements in the vector\n        svbool_t mask = svwhilelt_b8(i, s.size());\n\n        // Check if the character is a lowercase letter\n        svbool_t is_alpha = svcmpge_n_u8(mask, vec, 'a');\n        is_alpha = svcmpeq_n_u8(is_alpha, svcmple_n_u8(mask, vec, 'z'));\n\n        // Apply the rotation only to valid alphabetic characters\n        svuint8_t rotated = svadd_n_u8_z(mask, vec, 4);\n        rotated = svsub_n_u8_m(rotated, is_alpha, rotated, 'z' - 'a' + 1);\n\n        // Store the result back into the output string\n        svst1b_u8(mask, reinterpret_cast<uint8_t*>(&result[i]), rotated);\n\n        // Move to the next block of characters\n        i += svcntb();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    std::string result(s.size(), ' ');\n    size_t i = 0;\n\n    while (i < s.size()) {\n        // Load a vector of characters from the input string\n        svuint8_t vec = svld1sb_u8(sve_all_true_b8(), reinterpret_cast<const uint8_t*>(&s[i]));\n\n        // Create a mask for valid elements in the vector\n        svbool_t mask = svwhilelt_b8(i, s.size());\n\n        // Check if the character is a lowercase letter\n        svbool_t is_lower = svcmpeq_n_u8(mask, svand_n_u8_z(mask, vec, 0xC0), 0x60);\n\n        // Apply the rotation only to lowercase letters\n        svuint8_t rotated = svadd_n_u8_z(mask, vec, 4);\n        rotated = svmin_n_u8_z(mask, rotated, 'z');\n        rotated = svmax_n_u8_z(mask, rotated, 'a');\n\n        // Blend the rotated characters with the original vector\n        vec = svsel_u8(is_lower, rotated, vec);\n\n        // Store the result back into the output string\n        svst1b_u8(mask, reinterpret_cast<uint8_t*>(&result[i]), vec);\n\n        // Move to the next chunk\n        i += svcntb();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    std::string result(s.size(), '\\0');\n    size_t i = 0;\n\n    while (i < s.size()) {\n        // Load a vector of characters from the input string\n        svuint8_t vec = svld1sb_u8(sve_all, reinterpret_cast<const uint8_t*>(&s[i]));\n\n        // Create a predicate to handle active elements within bounds\n        svbool_t pred = svwhilelt_b8(i, s.size());\n\n        // Filter only alphabetic characters\n        svbool_t is_alpha = svcmpeq_n_u8(pred, svand_n_u8_z(pred, vec, 0xC0), 0x40);\n\n        // Separate lowercase and uppercase letters\n        svbool_t is_lower = svcmpeq_n_u8(pred, svand_n_u8_z(pred, vec, 0x20), 0x20);\n        svbool_t is_upper = svnot_z(pred, is_lower);\n\n        // Compute the rotation offset (2 * 2 = 4 places)\n        svuint8_t rotated = svadd_n_u8_z(pred, vec, 4);\n\n        // Wrap around for lowercase letters ('z' -> 'a')\n        rotated = svsel(is_lower,\n                        svsub_n_u8_z(pred, rotated, ('z' + 1 - 'a') * (svcmpgt_n_u8(pred, rotated, 'z'))),\n                        rotated);\n\n        // Wrap around for uppercase letters ('Z' -> 'A')\n        rotated = svsel(is_upper,\n                        svsub_n_u8_z(pred, rotated, ('Z' + 1 - 'A') * (svcmpgt_n_u8(pred, rotated, 'Z'))),\n                        rotated);\n\n        // Store the result back into the output string\n        svst1b_u8(pred, reinterpret_cast<uint8_t*>(&result[i]), rotated);\n\n        // Increment index by vector length\n        i += svcntb();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    std::string result(s.size(), ' ');\n    size_t i = 0;\n    size_t len = s.size();\n\n    while (i < len) {\n        // Load a vector of characters from the input string\n        svuint8_t vec = svld1sb_u8(sve_all_true_b8(), reinterpret_cast<const uint8_t*>(&s[i]));\n\n        // Create a mask for valid elements in the vector\n        svbool_t mask = svwhilelt_b8(i, len);\n\n        // Process only valid elements\n        svuint8_t shifted = svadd_u8_m(mask, vec, 4); // Shift by 4 positions\n\n        // Handle wrap-around for letters outside 'a'-'z'\n        svuint8_t wrapped = svsub_u8_m(mask, shifted, svdup_u8(26));\n        svbool_t is_alpha = svcmpge_n_u8(mask, vec, 'a');\n        svbool_t is_alpha_upper = svcmple_n_u8(mask, vec, 'z');\n        svbool_t alpha_mask = svand_b_z(mask, is_alpha, is_alpha_upper);\n        shifted = svsel_u8(alpha_mask, wrapped, shifted);\n\n        // Store the result back to the output string\n        svst1b_u8(mask, reinterpret_cast<uint8_t*>(&result[i]), shifted);\n\n        // Move to the next block\n        i += svcntb();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encode_simd(const std::string &message) {\n    size_t len = message.size();\n    std::string result(len, '\\0');\n    size_t i = 0;\n\n    // Define constants for vowels and case swapping\n    const svuint8_t vec_a = svdup_u8('a');\n    const svuint8_t vec_e = svdup_u8('e');\n    const svuint8_t vec_i = svdup_u8('i');\n    const svuint8_t vec_o = svdup_u8('o');\n    const svuint8_t vec_u = svdup_u8('u');\n    const svuint8_t vec_A = svdup_u8('A');\n    const svuint8_t vec_E = svdup_u8('E');\n    const svuint8_t vec_I = svdup_u8('I');\n    const svuint8_t vec_O = svdup_u8('O');\n    const svuint8_t vec_U = svdup_u8('U');\n    const svuint8_t vec_32 = svdup_u8(32); // For case swapping\n\n    while (i < len) {\n        // Load a vector of characters from the input string\n        svbool_t pg = svwhilelt_b8(i, len);\n        svuint8_t vec_input = svld1ub(pg, reinterpret_cast<const uint8_t*>(&message[i]));\n\n        // Swap case\n        svbool_t is_lower = svcmpge(pg, vec_input, svdup_u8('a'));\n        svbool_t is_upper = svcmpge(pg, vec_input, svdup_u8('A'));\n        svbool_t is_alpha = svorr_z(pg, is_lower, is_upper);\n        svuint8_t vec_case_swapped = svsub_x(pg, vec_input, vec_32);\n\n        // Replace vowels with letters two places ahead\n        svbool_t is_a = sveor_z(pg, svcmpeq(pg, vec_input, vec_a), svcmpeq(pg, vec_input, vec_A));\n        svbool_t is_e = sveor_z(pg, svcmpeq(pg, vec_input, vec_e), svcmpeq(pg, vec_input, vec_E));\n        svbool_t is_i = sveor_z(pg, svcmpeq(pg, vec_input, vec_i), svcmpeq(pg, vec_input, vec_I));\n        svbool_t is_o = sveor_z(pg, svcmpeq(pg, vec_input, vec_o), svcmpeq(pg, vec_input, vec_O));\n        svbool_t is_u = sveor_z(pg, svcmpeq(pg, vec_input, vec_u), svcmpeq(pg, vec_input, vec_U));\n\n        svuint8_t vec_replaced = svdup_u8(0);\n        vec_replaced = svsel(is_a, svadd_x(pg, vec_input, svdup_u8(2)), vec_replaced);\n        vec_replaced = svsel(is_e, svadd_x(pg, vec_input, svdup_u8(2)), vec_replaced);\n        vec_replaced = svsel(is_i, svadd_x(pg, vec_input, svdup_u8(2)), vec_replaced);\n        vec_replaced = svsel(is_o, svadd_x(pg, vec_input, svdup_u8(2)), vec_replaced);\n        vec_replaced = svsel(is_u, svadd_x(pg, vec_input, svdup_u8(2)), vec_replaced);\n\n        // Combine results: use replaced vowels or case-swapped letters\n        svuint8_t vec_output = svsel(svorr_z(pg, is_a, svorr_z(pg, is_e, svorr_z(pg, is_i, svorr_z(pg, is_o, is_u)))), vec_replaced, vec_case_swapped);\n\n        // Store the result back to the output string\n        svst1ub(pg, reinterpret_cast<uint8_t*>(&result[i]), vec_output);\n\n        // Increment index by vector length\n        i += svcntb();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encode_simd(const std::string &message) {\n    size_t len = message.size();\n    std::string result(len, '\\0');\n    size_t i = 0;\n\n    while (i <= len - svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, len);\n\n        // Load vector of characters\n        svuint8_t vec = svld1(pg, reinterpret_cast<const uint8_t*>(&message[i]));\n\n        // Create masks for uppercase and lowercase letters\n        svbool_t is_upper = svcmpge(pg, vec, svdup_u8('A'));\n        is_upper = svcmpeq(pg, svand_z(pg, is_upper, svcmple(pg, vec, svdup_u8('Z'))), svdup_n_u8(1));\n\n        svbool_t is_lower = svcmpge(pg, vec, svdup_u8('a'));\n        is_lower = svcmpeq(pg, svand_z(pg, is_lower, svcmple(pg, vec, svdup_u8('z'))), svdup_n_u8(1));\n\n        // Swap case\n        svuint8_t swapped_case = svsub_z(pg, vec, svdup_u8('A' ^ 'a'));\n        swapped_case = svsel(is_upper, svadd_z(pg, vec, svdup_u8('A' ^ 'a')), swapped_case);\n        swapped_case = svsel(is_lower, svsub_z(pg, vec, svdup_u8('A' ^ 'a')), swapped_case);\n\n        // Identify vowels and replace them\n        svbool_t is_vowel = svcmpeq(pg, vec, svdup_u8('A'));\n        is_vowel = svorr_z(pg, is_vowel, svcmpeq(pg, vec, svdup_u8('E')));\n        is_vowel = svorr_z(pg, is_vowel, svcmpeq(pg, vec, svdup_u8('I')));\n        is_vowel = svorr_z(pg, is_vowel, svcmpeq(pg, vec, svdup_u8('O')));\n        is_vowel = svorr_z(pg, is_vowel, svcmpeq(pg, vec, svdup_u8('U')));\n        is_vowel = svorr_z(pg, is_vowel, svcmpeq(pg, vec, svdup_u8('a')));\n        is_vowel = svorr_z(pg, is_vowel, svcmpeq(pg, vec, svdup_u8('e')));\n        is_vowel = svorr_z(pg, is_vowel, svcmpeq(pg, vec, svdup_u8('i')));\n        is_vowel = svorr_z(pg, is_vowel, svcmpeq(pg, vec, svdup_u8('o')));\n        is_vowel = svorr_z(pg, is_vowel, svcmpeq(pg, vec, svdup_u8('u')));\n\n        svuint8_t replaced_vowels = svadd_z(pg, vec, svdup_u8(2));\n        svuint8_t final_vec = svsel(is_vowel, replaced_vowels, swapped_case);\n\n        // Store the result back to memory\n        svst1(pg, reinterpret_cast<uint8_t*>(&result[i]), final_vec);\n\n        i += svcntb();\n    }\n\n    // Handle remaining elements\n    for (; i < len; ++i) {\n        char c = message[i];\n        if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) {\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) {\n                c ^= ('A' ^ 'a'); // Swap case\n            }\n            if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ||\n                c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n                c += 2; // Replace vowel\n            }\n        }\n        result[i] = c;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encode_simd(const std::string &message) {\n    size_t len = message.size();\n    std::string result(len, '\\0');\n    size_t i = 0;\n\n    // Define constants for vowels and case swapping\n    const svuint8_t vec_a = svdup_n_u8('a');\n    const svuint8_t vec_e = svdup_n_u8('e');\n    const svuint8_t vec_i = svdup_n_u8('i');\n    const svuint8_t vec_o = svdup_n_u8('o');\n    const svuint8_t vec_u = svdup_n_u8('u');\n    const svuint8_t vec_A = svdup_n_u8('A');\n    const svuint8_t vec_E = svdup_n_u8('E');\n    const svuint8_t vec_I = svdup_n_u8('I');\n    const svuint8_t vec_O = svdup_n_u8('O');\n    const svuint8_t vec_U = svdup_n_u8('U');\n    const svuint8_t vec_32 = svdup_n_u8(32); // For case swapping\n\n    while (i < len) {\n        // Load a vector of characters from the input string\n        svbool_t pg = svwhilelt_b8(i, len);\n        svuint8_t vec_input = svld1sb_u8(pg, reinterpret_cast<const uint8_t*>(&message[i]));\n\n        // Swap case\n        svbool_t is_lower = svcmplt_u8(pg, vec_input, svdup_n_u8('a'));\n        svuint8_t vec_swapped = svsub_u8_z(pg, vec_input, vec_32);\n        vec_swapped = svsel_u8(is_lower, svadd_u8_z(pg, vec_input, vec_32), vec_swapped);\n\n        // Replace vowels with letters 2 places ahead\n        svbool_t is_a = svcmpeq_u8(pg, vec_swapped, vec_a);\n        svbool_t is_e = svcmpeq_u8(pg, vec_swapped, vec_e);\n        svbool_t is_i = svcmpeq_u8(pg, vec_swapped, vec_i);\n        svbool_t is_o = svcmpeq_u8(pg, vec_swapped, vec_o);\n        svbool_t is_u = svcmpeq_u8(pg, vec_swapped, vec_u);\n        svbool_t is_A = svcmpeq_u8(pg, vec_swapped, vec_A);\n        svbool_t is_E = svcmpeq_u8(pg, vec_swapped, vec_E);\n        svbool_t is_I = svcmpeq_u8(pg, vec_swapped, vec_I);\n        svbool_t is_O = svcmpeq_u8(pg, vec_swapped, vec_O);\n        svbool_t is_U = svcmpeq_u8(pg, vec_swapped, vec_U);\n\n        vec_swapped = svsel_u8(is_a, svdup_n_u8('c'), vec_swapped);\n        vec_swapped = svsel_u8(is_e, svdup_n_u8('g'), vec_swapped);\n        vec_swapped = svsel_u8(is_i, svdup_n_u8('k'), vec_swapped);\n        vec_swapped = svsel_u8(is_o, svdup_n_u8('q'), vec_swapped);\n        vec_swapped = svsel_u8(is_u, svdup_n_u8('w'), vec_swapped);\n        vec_swapped = svsel_u8(is_A, svdup_n_u8('C'), vec_swapped);\n        vec_swapped = svsel_u8(is_E, svdup_n_u8('G'), vec_swapped);\n        vec_swapped = svsel_u8(is_I, svdup_n_u8('K'), vec_swapped);\n        vec_swapped = svsel_u8(is_O, svdup_n_u8('Q'), vec_swapped);\n        vec_swapped = svsel_u8(is_U, svdup_n_u8('W'), vec_swapped);\n\n        // Store the result back to the output string\n        svst1b_u8(pg, reinterpret_cast<uint8_t*>(&result[i]), vec_swapped);\n        i += svcntb();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encode_simd(const std::string &message) {\n    size_t len = message.size();\n    std::string result(len, '\\0');\n    size_t i = 0;\n\n    while (i <= len - svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, len);\n\n        // Load a vector of characters from the input message\n        svuint8_t vec = svld1(pg, reinterpret_cast<const uint8_t*>(&message[i]));\n\n        // Create masks for vowels and case swapping\n        svbool_t is_lower = svcmpge(pg, vec, svdup_u8('a')) && svcmple(pg, vec, svdup_u8('z'));\n        svbool_t is_upper = svcmpge(pg, vec, svdup_u8('A')) && svcmple(pg, vec, svdup_u8('Z'));\n\n        // Swap case: toggle the 5th bit (32) to swap between uppercase and lowercase\n        svuint8_t swapped_case = sveor_z(pg, vec, svdup_u8(32));\n\n        // Identify vowels in both cases\n        svbool_t is_a = sveor_z(pg, vec, svdup_u8('a')) == svdup_u8(0);\n        svbool_t is_e = sveor_z(pg, vec, svdup_u8('e')) == svdup_u8(0);\n        svbool_t is_i = sveor_z(pg, vec, svdup_u8('i')) == svdup_u8(0);\n        svbool_t is_o = sveor_z(pg, vec, svdup_u8('o')) == svdup_u8(0);\n        svbool_t is_u = sveor_z(pg, vec, svdup_u8('u')) == svdup_u8(0);\n        svbool_t is_A = sveor_z(pg, vec, svdup_u8('A')) == svdup_u8(0);\n        svbool_t is_E = sveor_z(pg, vec, svdup_u8('E')) == svdup_u8(0);\n        svbool_t is_I = sveor_z(pg, vec, svdup_u8('I')) == svdup_u8(0);\n        svbool_t is_O = sveor_z(pg, vec, svdup_u8('O')) == svdup_u8(0);\n        svbool_t is_U = sveor_z(pg, vec, svdup_u8('U')) == svdup_u8(0);\n\n        // Combine vowel masks\n        svbool_t is_vowel = is_a || is_e || is_i || is_o || is_u || is_A || is_E || is_I || is_O || is_U;\n\n        // Replace vowels with letters two places ahead\n        svuint8_t replaced_vowels = svadd_z(pg, vec, svdup_u8(2));\n\n        // Combine results: if vowel, use replaced_vowels; otherwise, use swapped_case\n        svuint8_t final_vec = svsel(is_vowel, replaced_vowels, swapped_case);\n\n        // Store the result back into the output string\n        svst1(pg, reinterpret_cast<uint8_t*>(&result[i]), final_vec);\n\n        i += svcntb();\n    }\n\n    // Handle remaining elements\n    for (; i < len; ++i) {\n        char c = message[i];\n        if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {\n            // Swap case\n            if (c >= 'a' && c <= 'z') {\n                c = c - 32;\n            } else {\n                c = c + 32;\n            }\n            // Replace vowels\n            if (c == 'A' || c == 'a') c = 'C';\n            else if (c == 'E' || c == 'e') c = 'G';\n            else if (c == 'I' || c == 'i') c = 'K';\n            else if (c == 'O' || c == 'o') c = 'Q';\n            else if (c == 'U' || c == 'u') c = 'W';\n        }\n        result[i] = c;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encode_simd(const std::string &message) {\n    size_t len = message.size();\n    std::string result(len, '\\0');\n\n    const svuint8_t vec_vowels_lower = svld1rq_u8(\"aeiou\");\n    const svuint8_t vec_vowels_upper = svld1rq_u8(\"AEIOU\");\n\n    for (size_t i = 0; i < len; i += svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, len);\n\n        // Load a vector of characters from the input string\n        svuint8_t vec_chars = svld1ub(pg, reinterpret_cast<const uint8_t*>(&message[i]));\n\n        // Swap case: toggle the 5th bit to swap case\n        svuint8_t swapped_case = sveor_z(pg, vec_chars, svdup_u8(32));\n\n        // Identify vowels in both cases\n        svbool_t is_vowel_lower = svcmpeq(pg, sveor_z(pg, vec_chars, svdup_u8(32)), vec_vowels_lower);\n        svbool_t is_vowel_upper = svcmpeq(pg, sveor_z(pg, vec_chars, svdup_u8(32)), vec_vowels_upper);\n        svbool_t is_vowel = svorr_z(pg, is_vowel_lower, is_vowel_upper);\n\n        // Replace vowels with letters two positions ahead\n        svuint8_t replaced_vowels = svadd_z(pg, vec_chars, svdup_u8(2));\n\n        // Combine results: use replaced vowels where applicable, otherwise swapped case\n        svuint8_t final_chars = svsel(is_vowel, replaced_vowels, swapped_case);\n\n        // Store the result back into the output string\n        svst1ub(pg, reinterpret_cast<uint8_t*>(&result[i]), final_chars);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n    size_t max_key_length = 0;\n\n    // Determine the maximum key length in the map\n    for (const auto& pair : dict) {\n        if (pair.first.length() > max_key_length) {\n            max_key_length = pair.first.length();\n        }\n    }\n\n    // Allocate a buffer to hold all keys concatenated\n    std::string all_keys;\n    for (const auto& pair : dict) {\n        all_keys += pair.first;\n        // Pad with null characters to ensure consistent vectorization\n        all_keys.append(max_key_length - pair.first.length(), '\\0');\n    }\n\n    size_t total_length = all_keys.length();\n    size_t vl = svcntb(); // Vector length in bytes\n\n    for (size_t i = 0; i < total_length; i += vl) {\n        svbool_t pred = svwhilelt_b8(i, total_length);\n        svuint8_t vec = svld1ub(pred, reinterpret_cast<const uint8_t*>(all_keys.data() + i));\n\n        // Check for lowercase\n        svbool_t is_lower = svcmpeq(pred, svand(vec, 0x80), 0); // ASCII range\n        is_lower = svand(is_lower, svcmpge(pred, vec, 'a'));\n        is_lower = svand(is_lower, svcmple(pred, vec, 'z'));\n\n        // Check for uppercase\n        svbool_t is_upper = svcmpeq(pred, svand(vec, 0x80), 0); // ASCII range\n        is_upper = svand(is_upper, svcmpge(pred, vec, 'A'));\n        is_upper = svand(is_upper, svcmple(pred, vec, 'Z'));\n\n        // Combine results\n        all_lower = all_lower && svptest_all(is_lower);\n        all_upper = all_upper && svptest_all(is_upper);\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n    size_t max_key_length = 0;\n\n    // Determine the maximum key length in the map\n    for (const auto& pair : dict) {\n        if (pair.first.length() > max_key_length) {\n            max_key_length = pair.first.length();\n        }\n    }\n\n    // Allocate a buffer to hold all keys concatenated\n    std::string all_keys;\n    for (const auto& pair : dict) {\n        all_keys += pair.first;\n        // Pad with null characters to ensure alignment for SVE processing\n        all_keys.append(max_key_length - pair.first.length(), '\\0');\n    }\n\n    const char* keys_data = all_keys.c_str();\n    size_t total_length = all_keys.length();\n\n    // Process the keys using SVE intrinsics\n    size_t i = 0;\n    while (i < total_length) {\n        // Load a vector of characters from the keys\n        svuint8_t vec = svld1sb_u8(svptrue_b8(), reinterpret_cast<const uint8_t*>(keys_data + i));\n\n        // Create masks for lowercase and uppercase checks\n        svbool_t lower_mask = svcmpeq_n_u8(svptrue_b8(), svand_u8_z(svptrue_b8(), vec, 0xC0), 0x60);\n        svbool_t upper_mask = svcmpeq_n_u8(svptrue_b8(), svand_u8_z(svptrue_b8(), vec, 0xC0), 0x40);\n\n        // Update flags based on the masks\n        all_lower &= svptest_all(svptrue_b8(), lower_mask);\n        all_upper &= svptest_all(svptrue_b8(), upper_mask);\n\n        // Move to the next vector block\n        i += svcntb();\n    }\n\n    // Return true if all keys are either lowercase or uppercase\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n    size_t max_key_length = 0;\n\n    // Determine the maximum key length in the map\n    for (const auto& pair : dict) {\n        if (pair.first.length() > max_key_length) {\n            max_key_length = pair.first.length();\n        }\n    }\n\n    // Allocate a buffer to hold all keys concatenated\n    std::string all_keys;\n    for (const auto& pair : dict) {\n        all_keys += pair.first;\n        // Pad with null characters to align with max_key_length\n        all_keys.append(max_key_length - pair.first.length(), '\\0');\n    }\n\n    size_t total_length = all_keys.length();\n    size_t vector_length = svcntb(); // Get the SVE vector length in bytes\n\n    svbool_t predicate = svwhilelt_b8(0, total_length);\n\n    for (size_t i = 0; i < total_length; i += vector_length) {\n        svuint8_t vector = svld1ub(predicate, reinterpret_cast<const uint8_t*>(&all_keys[i]));\n\n        svbool_t is_alpha = svcmpeq_n_u8(predicate, svand_n_u8_z(predicate, vector, 0xC0), 0x40);\n        svbool_t is_lower = svcmpeq_n_u8(predicate, svand_n_u8_z(predicate, vector, 0x20), 0x20);\n        svbool_t is_upper = svcmpeq_n_u8(predicate, svand_n_u8_z(predicate, vector, 0x20), 0x00);\n\n        all_lower &= svptest_all(is_alpha, is_lower);\n        all_upper &= svptest_all(is_alpha, is_upper);\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n    size_t max_key_length = 0;\n\n    // Determine the maximum key length in the map\n    for (const auto& pair : dict) {\n        if (pair.first.length() > max_key_length) {\n            max_key_length = pair.first.length();\n        }\n    }\n\n    // Allocate a buffer to hold all keys concatenated\n    std::string all_keys;\n    for (const auto& pair : dict) {\n        all_keys += pair.first;\n        // Pad with null characters to ensure alignment for SVE processing\n        all_keys.append(max_key_length - pair.first.length(), '\\0');\n    }\n\n    const char* keys_data = all_keys.c_str();\n    size_t total_length = all_keys.size();\n\n    // SVE vector processing\n    svbool_t pg = svwhilelt_b8(0, total_length); // Predicate for active elements\n    const uint8_t* ptr = reinterpret_cast<const uint8_t*>(keys_data);\n\n    svuint8_t vec_lower_mask = svdup_u8(0x20); // Mask for lowercase check (ASCII 'a'-'z' range)\n    svuint8_t vec_upper_mask = svdup_u8(0x40); // Mask for uppercase check (ASCII 'A'-'Z' range)\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t vec = svld1_u8(pg, ptr); // Load vector of characters\n\n        // Check if characters are lowercase ('a'-'z')\n        svbool_t is_lower = svcmpeq_n_u8(pg, svand_u8_z(pg, vec, svdup_u8(0xDF)), svdup_u8('A' & 0xDF));\n        all_lower &= !svptest_any(pg, svnot_b_z(pg, is_lower));\n\n        // Check if characters are uppercase ('A'-'Z')\n        svbool_t is_upper = svcmpeq_n_u8(pg, svand_u8_z(pg, vec, svdup_u8(0xDF)), svdup_u8('A' & 0xDF));\n        all_upper &= !svptest_any(pg, svnot_b_z(pg, is_upper));\n\n        ptr += svcntb(); // Move to the next block of data\n        pg = svwhilelt_b8(ptr - reinterpret_cast<const uint8_t*>(keys_data), total_length);\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n    size_t max_key_length = 0;\n\n    // Determine the maximum key length in the map\n    for (const auto& pair : dict) {\n        if (pair.first.length() > max_key_length) {\n            max_key_length = pair.first.length();\n        }\n    }\n\n    // Allocate buffers for processing\n    char* key_buffer = new char[max_key_length * dict.size()];\n    size_t key_lengths[dict.size()];\n    size_t index = 0;\n\n    // Copy keys into a contiguous buffer and store their lengths\n    for (const auto& pair : dict) {\n        std::copy(pair.first.begin(), pair.first.end(), key_buffer + index * max_key_length);\n        key_lengths[index] = pair.first.length();\n        index++;\n    }\n\n    // Process keys using SVE intrinsics\n    for (size_t i = 0; i < dict.size(); ++i) {\n        size_t key_length = key_lengths[i];\n        const char* key = key_buffer + i * max_key_length;\n\n        // Load key characters into an SVE vector\n        svbool_t pred = svwhilelt_b8(0, key_length);\n        svuint8_t vec = svld1ub(pred, reinterpret_cast<const uint8_t*>(key));\n\n        // Check for lowercase\n        svbool_t is_lower = svcmpeq(pred, svand(vec, 0x7F), vec);\n        is_lower = svcmpeq(pred, svsub(vec, 'a'), svmin(svsub(vec, 'a'), svdup_u8('z' - 'a')));\n\n        // Check for uppercase\n        svbool_t is_upper = svcmpeq(pred, svand(vec, 0x7F), vec);\n        is_upper = svcmpeq(pred, svsub(vec, 'A'), svmin(svsub(vec, 'A'), svdup_u8('Z' - 'A')));\n\n        // Combine results\n        all_lower &= svptest_all(is_lower);\n        all_upper &= svptest_all(is_upper);\n    }\n\n    delete[] key_buffer;\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n\n    // Initialize a boolean array to track prime numbers\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n\n    // Use SVE intrinsics for parallel processing\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active lanes\n    svint32_t vec = svindex_s32(0, 1); // Vector of indices [0, 1, 2, ..., n-1]\n\n    // Mark non-prime numbers using SVE\n    for (int p = 2; p * p < n; ++p) {\n        if (is_prime[p]) {\n            svint32_t multiple = svdup_s32(p * p); // Start marking from p*p\n            svint32_t step = svdup_s32(p);         // Step size is p\n            svbool_t mask = svcmpeq_s32(pg, svrem_s32_z(pg, vec, step), svdup_s32(0));\n\n            // Update the is_prime array for multiples of p\n            for (int i = p * p; i < n; i += p) {\n                is_prime[i] = false;\n            }\n        }\n    }\n\n    // Collect all prime numbers into the result vector\n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n\n    // Allocate a boolean array to mark non-prime numbers\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n\n    // SVE vector length\n    size_t vl = svcntw();\n\n    // Process in chunks of SVE vector length\n    for (int i = 2; i * i < n; i++) {\n        if (is_prime[i]) {\n            svbool_t pg = svwhilelt_b32(i, n); // Predicate for active lanes\n            svint32_t vec_i = svdup_n_s32(i);  // Broadcast current prime\n\n            for (int j = i * i; j < n; j += i) {\n                svint32_t vec_j = svindex_s32(j, i); // Generate vector of multiples\n                svbool_t mask = svcmplt_s32(pg, vec_j, svdup_n_s32(n)); // Mask for valid indices\n                svst1_b32(mask, &is_prime[0], svdup_n_b32(false)); // Mark multiples as non-prime\n            }\n        }\n    }\n\n    // Collect remaining primes\n    for (int i = 2; i < n; i++) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n\n    // Initialize a boolean vector for sieve of Eratosthenes\n    int size = n;\n    bool is_prime[size];\n    for (int i = 0; i < size; ++i) {\n        is_prime[i] = true;\n    }\n    is_prime[0] = is_prime[1] = false;\n\n    // Determine the vector length\n    uint64_t vl = svcntb();\n\n    // Process using SVE intrinsics\n    for (int p = 2; p * p < n; ++p) {\n        if (is_prime[p]) {\n            svbool_t pg = svwhilelt_b8(p * p, n); // Predicate for active lanes\n            svuint32_t vec_p = svdup_u32(p);      // Broadcast current prime\n            svuint32_t vec_i = svindex_u32(p * p, 1); // Vector of indices starting from p*p\n\n            // Mark multiples of p as non-prime\n            while (svptest_any(svptrue_b8(), pg)) {\n                svst1_u32(pg, is_prime + p * p, svbool_to_svuint32_z(pg, false));\n                vec_i = svadd_u32_z(pg, vec_i, vec_p);\n                pg = svwhilelt_b8(svminv_u32(pg, vec_i), n);\n            }\n        }\n    }\n\n    // Collect the primes into the result vector\n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n\n    // Allocate a boolean array to mark non-prime numbers\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n\n    // SVE vector length\n    size_t vl = svcntw();\n\n    // Process in chunks of SVE vector length\n    for (int i = 2; i * i < n; i++) {\n        if (is_prime[i]) {\n            svbool_t pg = svwhilelt_b32(i, n); // Predicate for active lanes\n            svint32_t vec_i = svdup_n_s32(i);  // Broadcast current prime\n\n            for (int j = i * i; j < n; j += i) {\n                svint32_t vec_j = svindex_s32(j, i); // Generate indices for multiples of i\n                svbool_t mask = svcmplt_s32(pg, vec_j, svdup_n_s32(n)); // Mask for valid indices\n                svst1_b8(pg, &is_prime[j], svand_z(pg, svld1_b8(pg, &is_prime[j]), svcmpeq_s32(pg, vec_j, vec_i)));\n            }\n        }\n    }\n\n    // Collect all primes into the result vector\n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n\n    // Allocate a boolean array to mark non-prime numbers\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n\n    // Determine the vector length\n    size_t vl = svcntw();\n\n    // Process primes using SVE intrinsics\n    for (int i = 2; i * i < n; ++i) {\n        if (is_prime[i]) {\n            svbool_t pg = svwhilelt_b32(i, n); // Predicate for active lanes\n            svint32_t vec_i = svdup_n_s32(i); // Broadcast current prime\n            svint32_t vec_j = svindex_s32(i * i, i); // Start at i*i, increment by i\n\n            // Mark multiples of i as non-prime\n            while (svptest_any(svptrue_b32(), pg)) {\n                svst1_s32(pg, &is_prime[0], svand_s32_z(pg, svld1_s32(pg, &is_prime[0]), svdup_n_s32(0)));\n                vec_j = svadd_s32_z(pg, vec_j, vec_i);\n                pg = svwhilelt_b32(svgetlane(vec_j, 0), n);\n            }\n        }\n    }\n\n    // Collect all primes into the result vector\n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint count_upper_simd(const std::string & s) {\n    int count = 0;\n    size_t len = s.size();\n    const char* data = s.data();\n\n    for (size_t i = 0; i < len; i += svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, len);\n\n        // Load a vector of characters from the string\n        svuint8_t vec = svld1ub(pg, (const uint8_t*)(data + i));\n\n        // Create masks for uppercase vowels ('A', 'E', 'I', 'O', 'U')\n        svbool_t is_A = svcmpeq(pg, vec, svdup_u8('A'));\n        svbool_t is_E = svcmpeq(pg, vec, svdup_u8('E'));\n        svbool_t is_I = svcmpeq(pg, vec, svdup_u8('I'));\n        svbool_t is_O = svcmpeq(pg, vec, svdup_u8('O'));\n        svbool_t is_U = svcmpeq(pg, vec, svdup_u8('U'));\n\n        // Combine all vowel masks\n        svbool_t is_vowel = svorr_z(pg, is_A, is_E);\n        is_vowel = svorr_z(pg, is_vowel, is_I);\n        is_vowel = svorr_z(pg, is_vowel, is_O);\n        is_vowel = svorr_z(pg, is_vowel, is_U);\n\n        // Check if indices are even\n        svbool_t is_even = svcmpeq(pg, svand_z(pg, svindex_u8(0, 1), svdup_u8(1)), svdup_u8(0));\n\n        // Combine conditions: must be a vowel AND at an even index\n        svbool_t valid = svand_z(pg, is_vowel, is_even);\n\n        // Count the number of valid elements\n        count += svcntp_b8(pg, valid);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint count_upper_simd(const std::string & s) {\n    int result = 0;\n    size_t len = s.size();\n    const char* data = s.data();\n\n    for (size_t i = 0; i < len; i += svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, len);\n\n        // Load vector of characters from the string\n        svuint8_t vec = svld1ub(pg, (const uint8_t*)(data + i));\n\n        // Create a mask for uppercase vowels ('A', 'E', 'I', 'O', 'U')\n        svbool_t is_upper_vowel = svcmpeq(pg, vec, 'A');\n        is_upper_vowel = svorr_b(pg, is_upper_vowel, svcmpeq(pg, vec, 'E'));\n        is_upper_vowel = svorr_b(pg, is_upper_vowel, svcmpeq(pg, vec, 'I'));\n        is_upper_vowel = svorr_b(pg, is_upper_vowel, svcmpeq(pg, vec, 'O'));\n        is_upper_vowel = svorr_b(pg, is_upper_vowel, svcmpeq(pg, vec, 'U'));\n\n        // Create a mask for even indices\n        svbool_t is_even_index = svcmpeq(pg, svand_n_u64(pg, svindex_u64(i, 1), 1), 0);\n\n        // Combine masks: character must be an uppercase vowel AND at an even index\n        svbool_t combined_mask = svand_b(pg, is_upper_vowel, is_even_index);\n\n        // Count the number of true elements in the combined mask\n        result += svcntp_b8(pg, combined_mask);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint count_upper_simd(const std::string & s) {\n    int count = 0;\n    size_t i = 0;\n    size_t len = s.length();\n\n    while (i < len) {\n        // Load a vector of characters from the string\n        svuint8_t vec = svld1sb_u8(svptrue_b8(), reinterpret_cast<const uint8_t*>(&s[i]));\n\n        // Create a predicate for even indices\n        svbool_t even_pred = svwhilelt_b8(i, len);\n        svbool_t even_indices = svbrkb_z(even_pred, svptrue_b8());\n\n        // Mask to keep only characters at even indices\n        svuint8_t even_chars = svcompact_u8(even_indices, vec);\n\n        // Predicate for uppercase vowels ('A', 'E', 'I', 'O', 'U')\n        svbool_t is_A = svcmpeq_n_u8(svptrue_b8(), even_chars, 'A');\n        svbool_t is_E = svcmpeq_n_u8(svptrue_b8(), even_chars, 'E');\n        svbool_t is_I = svcmpeq_n_u8(svptrue_b8(), even_chars, 'I');\n        svbool_t is_O = svcmpeq_n_u8(svptrue_b8(), even_chars, 'O');\n        svbool_t is_U = svcmpeq_n_u8(svptrue_b8(), even_chars, 'U');\n\n        // Combine predicates for all uppercase vowels\n        svbool_t is_vowel = svorr_b_z(svptrue_b8(), is_A, is_E);\n        is_vowel = svorr_b_z(svptrue_b8(), is_vowel, is_I);\n        is_vowel = svorr_b_z(svptrue_b8(), is_vowel, is_O);\n        is_vowel = svorr_b_z(svptrue_b8(), is_vowel, is_U);\n\n        // Count the number of matches\n        count += svcntp_b8(svptrue_b8(), is_vowel);\n\n        // Move to the next block of characters\n        i += svcntb();\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint count_upper_simd(const std::string & s) {\n    int count = 0;\n    size_t len = s.length();\n    size_t i = 0;\n\n    // Process the string in chunks of SVE vector length\n    while (i + svcntb() <= len) {\n        svuint8_t vec = svld1sb_u8(svptrue_b8(), (const uint8_t*)&s[i]);\n\n        // Create a mask for even indices\n        svbool_t even_mask = svwhilelt_b8(i, i + svcntb());\n        svbool_t index_mask = svbrkb_b_z(even_mask, svptrue_b8());\n\n        // Check for uppercase vowels ('A', 'E', 'I', 'O', 'U')\n        svbool_t is_A = svcmpeq_n_u8(index_mask, vec, 'A');\n        svbool_t is_E = svcmpeq_n_u8(index_mask, vec, 'E');\n        svbool_t is_I = svcmpeq_n_u8(index_mask, vec, 'I');\n        svbool_t is_O = svcmpeq_n_u8(index_mask, vec, 'O');\n        svbool_t is_U = svcmpeq_n_u8(index_mask, vec, 'U');\n\n        // Combine all conditions\n        svbool_t is_vowel = svorr_b_z(index_mask, is_A, is_E);\n        is_vowel = svorr_b_z(index_mask, is_vowel, is_I);\n        is_vowel = svorr_b_z(index_mask, is_vowel, is_O);\n        is_vowel = svorr_b_z(index_mask, is_vowel, is_U);\n\n        // Count the number of matches\n        count += svcntp_b8(svptrue_b8(), is_vowel);\n\n        i += svcntb();\n    }\n\n    // Process remaining elements\n    for (; i < len; i += 2) {\n        char c = s[i];\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint count_upper_simd(const std::string & s) {\n    int count = 0;\n    size_t len = s.length();\n    size_t i = 0;\n\n    // Process the string in chunks of SVE vector length\n    while (i + svcntb() <= len) {\n        svuint8_t vec = svld1ub(svptrue_b8(), reinterpret_cast<const uint8_t*>(&s[i]));\n\n        // Create a predicate for even indices\n        svbool_t even_pred = svwhilelt_b8(i, i + svcntb());\n        svbool_t even_indices = svbrkb_z(even_pred, even_pred);\n\n        // Mask for uppercase vowels ('A', 'E', 'I', 'O', 'U')\n        svuint8_t vowels = svorr_n_u8(\n            svorr_n_u8(\n                svorr_n_u8(\n                    svorr_n_u8(\n                        svdup_n_u8('A'), svdup_n_u8('E')\n                    ),\n                    svdup_n_u8('I')\n                ),\n                svdup_n_u8('O')\n            ),\n            svdup_n_u8('U')\n        );\n\n        // Check if characters are uppercase vowels\n        svbool_t is_vowel = svcmpeq(u8, even_indices, vec, vowels);\n\n        // Count the number of matches\n        count += svcntp_b8(svptrue_b8(), is_vowel);\n\n        i += svcntb();\n    }\n\n    // Process remaining elements\n    for (; i < len; i += 2) {\n        char c = s[i];\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    if (n <= 0) return result;\n\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active lanes\n    svint32_t vlevel = svindex_s32(1, 1); // Vector of levels [1, 2, 3, ...]\n    svint32_t vstones = svdup_s32(n); // Initialize all elements to n\n\n    // Compute the number of stones for each level\n    for (int i = 1; i < n; ++i) {\n        vstones = svadd_s32(pg, vstones, svdup_s32(2)); // Add 2 to get next odd/even number\n    }\n\n    // Store the results into the output vector\n    svst1_s32(pg, result.data(), vstones);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    if (n <= 0) return result;\n\n    svint32_t vec = svindex_s32(0, 1); // Create a vector [0, 1, 2, ...]\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active lanes\n\n    int base = n;\n    int increment = (n % 2 == 0) ? 2 : 1; // Determine the increment based on odd/even\n\n    for (int i = 0; i < n; i += svcntw()) {\n        svint32_t indices = svadd_s32_z(pg, vec, i); // Generate indices for this iteration\n        svint32_t values = svmad_s32_x(pg, indices, increment, base); // Compute values\n        svst1_s32(pg, &result[i], values); // Store results into the vector\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    if (n <= 0) return result;\n\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active lanes\n    svint32_t vlevel = svindex_s32(1, 1); // Vector of levels [1, 2, 3, ...]\n    svint32_t vstones = svdup_s32(n); // Initialize all elements to n\n\n    // Compute the number of stones for each level\n    for (int i = 1; i < n; ++i) {\n        vstones = svadd_s32(pg, vstones, svdup_s32(2)); // Add 2 to get next odd/even number\n        svst1_s32(pg, &result[i], vstones); // Store results back to memory\n    }\n\n    result[0] = n; // Ensure the first level is set to n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    if (n <= 0) return result;\n\n    svint32_t vec = svindex_s32(0, 1); // Create a vector [0, 1, 2, ...]\n    svbool_t pred = svwhilelt_b32(0, n); // Predicate for active lanes\n\n    int base = n;\n    int increment = (n % 2 == 0) ? 2 : 1; // Determine the increment based on odd/even\n\n    for (int i = 0; i < n; i += svcntw()) {\n        svint32_t indices = svadd_s32_z(pred, vec, i); // Add offset to indices\n        svint32_t values = svmul_s32_x(pred, indices, increment); // Multiply by increment\n        values = svadd_s32_x(pred, values, base); // Add base value\n\n        // Store results into the output vector\n        svst1_s32(pred, &result[i], values);\n\n        pred = svwhilelt_b32(i + svcntw(), n); // Update predicate\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    if (n <= 0) return result;\n\n    svint32_t vec = svindex_s32(0, 1); // Create a vector [0, 1, 2, ...]\n    svbool_t pred = svwhilelt_b32(0, n); // Predicate for active lanes\n\n    int base = n;\n    for (int i = 0; i < n; i += svcntw()) {\n        svint32_t level = svadd_s32_z(pred, vec, base); // Add base to each element\n        svint32_t increment = svdup_s32(2); // Increment by 2 for odd/even sequence\n        svint32_t stones = svmul_lane_s32(level, increment); // Multiply by 2\n        svst1_s32(pred, &result[i], stones); // Store results into the vector\n        pred = svwhilelt_b32(i + svcntw(), n); // Update predicate\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <bitset>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n\n    // Calculate the sum of integers from n to m using SVE intrinsics\n    svint64_t vec_n = svdup_s64(n);\n    svint64_t vec_m = svdup_s64(m);\n    svbool_t pred = svwhilelt_b64(n, m + 1);\n\n    svint64_t vec_sum = svdup_s64(0);\n    svint64_t vec_i = svdup_s64(n);\n\n    while (svptest_any(svptrue_b64(), pred)) {\n        vec_sum = svadd_s64_z(pred, vec_sum, vec_i);\n        vec_i = svadd_s64_z(pred, vec_i, svdup_s64(1));\n        pred = svwhilelt_b64(svlasta_s64(pred, vec_i), m + 1);\n    }\n\n    // Reduce the vector sum to a scalar value\n    int64_t sum = 0;\n    sum += svaddv_s64(svptrue_b64(), vec_sum);\n\n    // Calculate the count of integers from n to m\n    int64_t count = m - n + 1;\n\n    // Compute the average and round down\n    int64_t avg = sum / count;\n\n    // Convert the result to binary\n    std::string binary = std::bitset<64>(avg).to_string();\n    // Remove leading zeros\n    size_t first_one = binary.find('1');\n    if (first_one != std::string::npos) {\n        binary = binary.substr(first_one);\n    } else {\n        binary = \"0\";\n    }\n\n    return binary;\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n\n    // Compute the sum of integers from n to m using SVE intrinsics\n    int64_t sum = 0;\n    svint64_t vec_sum = svdup_s64(0);\n\n    // Create a predicate for the range [n, m]\n    svbool_t pred = svwhilelt_b64((uint64_t)n, (uint64_t)(m + 1));\n\n    // Vectorized loop to compute the sum\n    for (int64_t i = n; i <= m;) {\n        svint64_t vec_i = svindex_s64(i, 1); // Generate a vector of indices starting from i\n        vec_sum = svadd_s64_z(pred, vec_sum, vec_i); // Add the vector elements to the sum\n\n        // Update the loop counter and predicate\n        i += svcntd();\n        pred = svwhilelt_b64((uint64_t)i, (uint64_t)(m + 1));\n    }\n\n    // Reduce the vector sum to a scalar\n    sum = svaddv_s64(svptrue_b64(), vec_sum);\n\n    // Compute the count of integers in the range [n, m]\n    int64_t count = m - n + 1;\n\n    // Compute the average and round down\n    int64_t avg = sum / count;\n\n    // Convert the result to binary\n    std::string binary = \"\";\n    if (avg == 0) {\n        binary = \"0\";\n    } else {\n        while (avg > 0) {\n            binary = ((avg % 2) ? \"1\" : \"0\") + binary;\n            avg /= 2;\n        }\n    }\n\n    return binary;\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <bitset>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n\n    // Compute the sum of integers from n to m using SVE intrinsics\n    int64_t sum = 0;\n    svint64_t vec_sum = svdup_s64(0);\n\n    int64_t i = n;\n    while (i <= m) {\n        size_t vl = svcntd(); // Get the vector length\n        svbool_t pg = svwhilelt_b64(i, m + 1); // Predicate for active lanes\n\n        svint64_t vec_i = svindex_s64(i, 1); // Create a vector of indices starting from i\n        vec_sum = svadd_s64_m(pg, vec_sum, vec_i); // Add active elements to vec_sum\n\n        i += vl; // Move to the next set of elements\n    }\n\n    // Reduce the vector sum to a scalar\n    sum = svaddv_s64(svptrue_b64(), vec_sum);\n\n    // Compute the count of numbers from n to m\n    int64_t count = m - n + 1;\n\n    // Compute the average and round down\n    int64_t avg = sum / count;\n\n    // Convert the result to binary\n    std::string binary = std::bitset<64>(avg).to_string();\n    // Remove leading zeros\n    size_t first_one = binary.find('1');\n    if (first_one != std::string::npos) {\n        binary = binary.substr(first_one);\n    } else {\n        binary = \"0\"; // If the result is zero\n    }\n\n    return binary;\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n\n    // Calculate the sum of integers from n to m using SVE intrinsics\n    int64_t sum = 0;\n    svint64_t vec_sum = svdup_s64(0);\n\n    int64_t i = n;\n    while (i <= m) {\n        svbool_t pg = svwhilelt_b64(i, m + 1);\n        svint64_t vec_i = svindex_s64(i, 1);\n        vec_sum = svadd_s64_m(pg, vec_sum, vec_i);\n        i += svcntd();\n    }\n\n    // Reduce the vector sum to a scalar value\n    sum = svaddv_s64(svptrue_b64(), vec_sum);\n\n    // Calculate the count of integers from n to m\n    int64_t count = m - n + 1;\n\n    // Compute the average and round down\n    int64_t avg = sum / count;\n\n    // Convert the result to binary\n    std::string binary = \"\";\n    if (avg == 0) {\n        binary = \"0\";\n    } else {\n        while (avg > 0) {\n            binary = char('0' + (avg % 2)) + binary;\n            avg /= 2;\n        }\n    }\n\n    return binary;\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <bitset>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n\n    // Calculate the sum of integers from n to m using SVE intrinsics\n    int64_t sum = 0;\n    svint64_t vec_sum = svdup_s64(0);\n\n    // Create a predicate for the active lanes\n    svbool_t pred = svwhilelt_b64((uint64_t)n, (uint64_t)(m + 1));\n\n    // Vectorized loop to compute the sum\n    for (int64_t i = n; i <= m; i += svcntd()) {\n        svint64_t vec_i = svindex_s64(i, 1);\n        vec_sum = svadd_s64_z(pred, vec_sum, vec_i);\n        pred = svwhilelt_b64((uint64_t)i, (uint64_t)(m + 1));\n    }\n\n    // Reduce the vector sum to a scalar value\n    sum = svaddv_s64(svptrue_b64(), vec_sum);\n\n    // Compute the count of integers from n to m\n    int64_t count = m - n + 1;\n\n    // Compute the average and round down\n    int64_t avg = sum / count;\n\n    // Convert the result to binary\n    std::string binary = std::bitset<64>(avg).to_string();\n    // Remove leading zeros\n    size_t first_one = binary.find('1');\n    if (first_one != std::string::npos) {\n        binary = binary.substr(first_one);\n    } else {\n        binary = \"0\"; // If the result is zero\n    }\n\n    return binary;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active lanes\n\n    // Initialize vectors\n    svint32_t indices = svindex_s32(1, 1); // Vector of indices starting from 1\n    svint32_t values = svdup_s32(0);       // Result vector initialized to 0\n\n    // Compute factorial modulo 10,000 for even indices\n    svint32_t factorial = svdup_s32(1);   // Factorial accumulator\n    for (int i = 2; i <= n; i += 2) {\n        factorial = svmul_s32_z(pg, factorial, svdup_s32(i));\n        factorial = svrem_s32_z(pg, factorial, svdup_s32(10000));\n    }\n    values = svsel_s32(pg, svcmpeq_s32(pg, svrem_s32_z(pg, indices, svdup_s32(2)), svdup_s32(0)), factorial, values);\n\n    // Compute sum for odd indices\n    svint32_t sum = svdup_s32(0);         // Sum accumulator\n    for (int i = 1; i <= n; i += 2) {\n        sum = svadd_s32_z(pg, sum, svdup_s32(i));\n    }\n    values = svsel_s32(pg, svcmpne_s32(pg, svrem_s32_z(pg, indices, svdup_s32(2)), svdup_s32(0)), sum, values);\n\n    // Store results into the output vector\n    svst1_s32(pg, result.data(), values);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active lanes\n\n    // Initialize vectors\n    svint32_t indices = svindex_s32(1, 1); // Vector of indices starting from 1\n    svint32_t factorial = svdup_s32(1);   // Factorial accumulator\n    svint32_t sum = svdup_s32(0);         // Sum accumulator\n    svint32_t one = svdup_s32(1);         // Constant 1\n    svint32_t mod = svdup_s32(10000);     // Modulo constant\n\n    // Temporary variables for loop\n    int i = 1;\n    while (svptest_any(svptrue_b32(), pg)) {\n        svbool_t even = svcmpeq_n_s32(pg, svrem_s32_x(pg, indices, svdup_s32(2)), 0);\n\n        // Update factorial for even indices\n        factorial = svmul_s32_x(even, factorial, indices);\n        factorial = svrem_s32_x(even, factorial, mod);\n\n        // Update sum for odd indices\n        sum = svadd_s32_x(svnot_z(pg, even), sum, indices);\n\n        // Store results into the output vector\n        svint32_t res = svsel_s32(even, factorial, sum);\n        svst1_s32(pg, &result[i - 1], res);\n\n        // Increment indices and update predicate\n        indices = svadd_s32_x(pg, indices, one);\n        i += svcntw();\n        pg = svwhilelt_b32(i, n);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active lanes\n\n    // Initialize vectors\n    svint32_t indices = svindex_s32(1, 1); // Vector of indices starting from 1\n    svint32_t values = svdup_s32(0);       // Result vector initialized to 0\n\n    // Compute factorial modulo 10,000 for even indices\n    svint32_t factorial = svdup_s32(1);   // Factorial accumulator\n    for (int i = 2; i <= n; i += 2) {\n        factorial = svmul_s32_x(pg, factorial, svdup_s32(i));\n        factorial = svmod_s32_x(pg, factorial, svdup_s32(10000));\n    }\n\n    // Compute sum for odd indices\n    svint32_t sum = svdup_s32(0);         // Sum accumulator\n    for (int i = 1; i <= n; i += 2) {\n        sum = svadd_s32_x(pg, sum, svdup_s32(i));\n    }\n\n    // Combine results based on even/odd condition\n    svbool_t is_even = svcmpeq_n_s32(pg, svmod_s32_x(pg, indices, svdup_s32(2)), 0);\n    values = svsel_s32(is_even, factorial, sum);\n\n    // Store results into the output vector\n    for (int i = 0; i < n; ++i) {\n        if (svptest_first(pg, pg)) {\n            result[i] = svlasta_s32(pg, values);\n        }\n        pg = svwhilelt_b32(i + 1, n);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active lanes\n\n    // Initialize vectors\n    svint32_t indices = svindex_s32(1, 1); // Vector of indices starting from 1\n    svint32_t factorial = svdup_s32(1);    // Factorial accumulator\n    svint32_t sum = svdup_s32(0);          // Sum accumulator\n    svint32_t one = svdup_s32(1);          // Constant 1\n    svint32_t mod = svdup_s32(10000);      // Modulo constant\n\n    // Compute factorial and sum in parallel\n    for (int i = 1; i <= n; ++i) {\n        svbool_t even_mask = svcmpeq_n_s32(pg, svrem_s32_x(pg, indices, svdup_s32(2)), 0);\n\n        // Update factorial for even indices\n        factorial = svmul_s32_x(pg, factorial, indices);\n        factorial = svrem_s32_x(pg, factorial, mod);\n\n        // Update sum for odd indices\n        sum = svadd_s32_x(pg, sum, indices);\n\n        // Select result based on even/odd condition\n        svint32_t res = svsel_s32(even_mask, factorial, sum);\n\n        // Store results into the output vector\n        for (int j = 0; j < svcntw(); ++j) {\n            if (svptest_first(pg, pg)) {\n                result[i - 1] = svlasta_s32(pg, res);\n            }\n        }\n\n        // Increment indices\n        indices = svadd_s32_x(pg, indices, one);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active lanes\n\n    // Initialize vectors\n    svint32_t indices = svindex_s32(1, 1); // Vector of indices [1, 2, 3, ..., n]\n    svint32_t values = svdup_s32(0);      // Result vector initialized to 0\n    svint32_t factorial = svdup_s32(1);   // Factorial accumulator initialized to 1\n    svint32_t sum = svdup_s32(0);         // Sum accumulator initialized to 0\n\n    // Loop through indices in parallel using SVE\n    for (int i = 1; i <= n; ++i) {\n        svbool_t pred = svwhilelt_b32(0, i); // Update predicate for current iteration\n\n        // Compute factorial for even indices\n        svbool_t is_even = svcmpeq_n_s32(pred, svrem_s32_z(pred, indices, 2), 0);\n        factorial = svmul_s32_x(pred, factorial, indices);\n        svint32_t factorial_mod = svrem_s32_z(pred, factorial, 10000);\n\n        // Compute sum for odd indices\n        sum = svadd_s32_x(pred, sum, indices);\n\n        // Combine results based on even/odd condition\n        values = svsel_s32(is_even, factorial_mod, sum);\n\n        // Store results for active lanes\n        svst1_s32(pg, result.data(), values);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0, odd_count = 0;\n    svbool_t pg = svwhilelt_b32(1, n + 1); // Predicate for range [1, n]\n    svint32_t vec = svindex_s32(1, 1);     // Vector of integers [1, 2, ..., n]\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t current = svand_z(pg, vec, pg); // Active elements within range\n        svint32_t reversed = svdup_s32(0);        // Initialize reversed numbers\n\n        // Reverse digits of each number in the vector\n        svint32_t temp = current;\n        while (svptest_any(svptrue_b32(), svcmpne_n_s32(pg, temp, 0))) {\n            svint32_t digit = svand_n_s32_z(pg, temp, 0xF); // Extract last digit\n            reversed = svmla_n_s32_z(pg, reversed, 10, digit); // Build reversed number\n            temp = svasr_n_s32_z(pg, temp, 1);               // Shift right\n        }\n\n        // Check if the number is a palindrome\n        svbool_t is_palindrome = svcmpeq(pg, current, reversed);\n\n        // Count even and odd palindromes\n        svbool_t is_even = svcmpeq_n_s32(pg, svand_n_s32_z(pg, current, 1), 0);\n        svbool_t is_odd = svnot_z(pg, is_even);\n\n        even_count += svcntp_b32(svptrue_b32(), svand_z(pg, is_palindrome, is_even));\n        odd_count += svcntp_b32(svptrue_b32(), svand_z(pg, is_palindrome, is_odd));\n\n        // Update predicate to process remaining elements\n        pg = svwhilelt_b32(svlasta(pg, vec) + 1, n + 1);\n    }\n\n    return std::vector<int>{even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    svbool_t pg = svwhilelt_b32(1, n + 1); // Predicate for range [1, n]\n    svint32_t vec = svindex_s32(1, 1);     // Vector of integers from 1 to n\n\n    svint32_t reversed = svdup_s32(0);     // Initialize reversed number vector\n    svint32_t temp = vec;                  // Temporary vector for reversing digits\n\n    // Reverse the digits of each number in parallel\n    while (svptest_any(pg, pg)) {\n        svint32_t digit = svrem_s32_x(pg, temp, 10); // Extract last digit\n        reversed = svmla_s32_x(pg, reversed, digit); // Append digit to reversed\n        temp = svdiv_n_s32_x(pg, temp, 10);          // Remove last digit\n        pg = svwhilelt_b32(1, svmaxv_s32(pg, temp)); // Update predicate\n    }\n\n    // Check if the number is a palindrome\n    svbool_t is_palindrome = svcmpeq_s32(pg, vec, reversed);\n\n    // Count even and odd palindromes\n    svbool_t is_even = svcmpeq_n_s32(pg, svand_s32_x(pg, vec, 1), 0);\n    svint32_t even_count = svsel_s32(is_palindrome, svdup_s32(1), svdup_s32(0));\n    even_count = svsel_s32(is_even, even_count, svdup_s32(0));\n\n    svint32_t odd_count = svsel_s32(is_palindrome, svdup_s32(1), svdup_s32(0));\n    odd_count = svsel_s32(svnot_b_z(pg, is_even), odd_count, svdup_s32(0));\n\n    int total_even = svaddv_s32(pg, even_count);\n    int total_odd = svaddv_s32(pg, odd_count);\n\n    return {total_even, total_odd};\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0, odd_count = 0;\n    svbool_t pg = svwhilelt_b32(1, n + 1); // Predicate for range [1, n]\n    svuint32_t vec = svindex_u32(1, 1);   // Vector of integers from 1 to n\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t reversed = svdup_u32_z(pg, 0); // Initialize reversed numbers vector\n        svuint32_t temp = vec;                   // Temporary copy of vec for reversal\n\n        // Reverse the digits of each number in the vector\n        while (svptest_any(svptrue_b32(), pg)) {\n            svuint32_t digit = svand_u32_z(pg, temp, 10); // Extract last digit\n            reversed = svmla_u32_z(pg, reversed, digit, 10); // Append digit to reversed\n            temp = svdivr_u32_z(pg, temp, 10); // Remove last digit\n            pg = svcmpne_n_u32(pg, temp, 0); // Update predicate for non-zero temp\n        }\n\n        // Check if the number is a palindrome\n        svbool_t is_palindrome = svcmpeq(pg, vec, reversed);\n\n        // Count even and odd palindromes\n        svbool_t is_even = svcmpeq_n_u32(pg, svand_u32_z(pg, vec, 1), 0);\n        svbool_t is_odd = svnot_z(pg, is_even);\n\n        even_count += svcntp_b32(pg, svand_b_z(pg, is_palindrome, is_even));\n        odd_count += svcntp_b32(pg, svand_b_z(pg, is_palindrome, is_odd));\n\n        // Update predicate for next iteration\n        pg = svwhilelt_b32(svlasta(pg, vec) + 1, n + 1);\n        vec = svindex_u32(svlasta(pg, vec) + 1, 1);\n    }\n\n    return std::vector<int>{even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    svbool_t pg = svwhilelt_b32(1, n + 1); // Predicate for range [1, n]\n    svint32_t vec = svindex_s32(1, 1);     // Vector of integers from 1 to n\n\n    svint32_t reversed = svdup_s32(0);     // Initialize reversed number vector\n    svint32_t temp = vec;                  // Temporary vector for reversing digits\n\n    // Reverse the digits of each number in parallel\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t digit = svrem_s32_x(pg, temp, 10); // Extract last digit\n        reversed = svmla_s32_x(pg, reversed, digit); // Append digit to reversed\n        temp = svdiv_s32_x(pg, temp, 10);           // Remove last digit\n        pg = svcmpne_n_s32(pg, temp, 0);            // Update predicate\n    }\n\n    // Check if the number is a palindrome\n    svbool_t is_palindrome = svcmpeq_s32(vec, reversed);\n\n    // Count even and odd palindromes\n    svbool_t is_even = svcmpeq_n_s32(svand_s32(vec, 1), 0);\n    svint32_t even_count = svsel_s32(is_palindrome, svdup_s32(1), svdup_s32(0));\n    even_count = svsel_s32(is_even, even_count, svdup_s32(0));\n\n    svint32_t odd_count = svsel_s32(is_palindrome, svdup_s32(1), svdup_s32(0));\n    odd_count = svsel_s32(svnot_z(pg, is_even), odd_count, svdup_s32(0));\n\n    int total_even = svaddv_s32(svptrue_b32(), even_count);\n    int total_odd = svaddv_s32(svptrue_b32(), odd_count);\n\n    return std::vector<int>{total_even, total_odd};\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0, odd_count = 0;\n    svbool_t pg = svwhilelt_b32(1, n + 1); // Predicate for range [1, n]\n\n    svint32_t vec = svindex_s32(1, 1); // Vector of integers from 1 to n\n    svint32_t reversed = svdup_s32(0); // Initialize reversed number vector\n\n    svint32_t temp = vec;\n    svbool_t mask = svcmpeq_n_s32(pg, temp, 0); // Mask for non-zero digits\n\n    while (svptest_any(pg, mask)) {\n        svint32_t digit = svand_n_s32(pg, temp, 0xF); // Extract last digit\n        reversed = svmla_n_s32(pg, reversed, digit, 10); // Build reversed number\n        temp = svasr_n_s32(pg, temp, 4); // Shift right to process next digit\n        mask = svcmpne_n_s32(pg, temp, 0); // Update mask\n    }\n\n    svbool_t is_palindrome = svcmpeq_s32(pg, vec, reversed); // Check if palindrome\n    svbool_t is_even = svcmpeq_n_s32(pg, svand_n_s32(pg, vec, 1), 0); // Check if even\n\n    svint32_t even_palindromes = svand_s32_z(pg, svdup_n_s32(1), svand_z(pg, is_palindrome, is_even));\n    svint32_t odd_palindromes = svand_s32_z(pg, svdup_n_s32(1), svand_z(pg, is_palindrome, svnot_z(pg, is_even)));\n\n    even_count = svcntp_b32(svptrue_b32(), even_palindromes);\n    odd_count = svcntp_b32(svptrue_b32(), odd_palindromes);\n\n    return std::vector<int>{even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    size_t i = 0;\n    size_t size = n.size();\n    svbool_t pg = svwhilelt_b32(i, size);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec = svld1_s32(pg, &n[i]);\n        svint32_t sum_digits = svdup_s32(0);\n\n        svint32_t num = vec;\n        svbool_t negative_mask = svcmplt_s32(pg, num, svdup_s32(0));\n        num = svabs_s32_m(negative_mask, num);\n\n        while (svptest_any(svptrue_b32(), svcmpne_s32(pg, num, svdup_s32(0)))) {\n            svint32_t digit = svrem_s32(pg, num, svdup_s32(10));\n            sum_digits = svadd_s32(pg, sum_digits, digit);\n            num = svdiv_s32(pg, num, svdup_s32(10));\n        }\n\n        svint32_t first_digit = svneg_s32_m(negative_mask, svlsr_n_s32(vec, 31));\n        sum_digits = svadd_s32(pg, sum_digits, first_digit);\n\n        svbool_t positive_sum_mask = svcmpgt_s32(pg, sum_digits, svdup_s32(0));\n        count += svcntp_b32(svptrue_b32(), positive_sum_mask);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    size_t i = 0;\n    size_t len = n.size();\n\n    while (i <= len - svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, len);\n        svint32_t vec = svld1_s32(pg, &n[i]);\n\n        svint32_t sum_digits = svdup_s32(0);\n        svint32_t num = vec;\n\n        // Handle negative numbers\n        svbool_t is_negative = svcmplt_n_s32(pg, num, 0);\n        svint32_t sign = svdup_s32(1);\n        sign = svsel_s32(is_negative, svneg_s32(sign), sign);\n        num = svmul_s32_x(pg, num, sign);\n\n        // Sum digits\n        while (svptest_any(svptrue_b32(), pg)) {\n            svint32_t digit = svmod_n_s32_x(pg, num, 10);\n            sum_digits = svadd_s32_x(pg, sum_digits, digit);\n            num = svdiv_n_s32_x(pg, num, 10);\n            pg = svcmpne_n_s32(pg, num, 0);\n        }\n\n        // Adjust sum for negative numbers\n        sum_digits = svmla_lane_s32(sum_digits, is_negative, svneg_s32(svlasta_s32(pg, vec)), 0);\n\n        // Count elements with sum of digits > 0\n        svbool_t positive_sum = svcmpgt_n_s32(pg, sum_digits, 0);\n        count += svcntp_b32(svptrue_b32(), positive_sum);\n\n        i += svcntw();\n    }\n\n    // Process remaining elements\n    for (; i < len; ++i) {\n        int num = n[i];\n        int sum = 0;\n        int sign = num < 0 ? -1 : 1;\n        num *= sign;\n\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n\n        if (sign == -1 && sum > 0) {\n            sum -= 2 * (n[i] % 10);\n        }\n\n        if (sum > 0) {\n            ++count;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    size_t i = 0;\n    size_t size = n.size();\n    svbool_t pg = svwhilelt_b32(i, size);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec = svld1(pg, &n[i]);\n        svint32_t sum_digits = svdup_n_s32(0);\n\n        svint32_t num = vec;\n        svbool_t negative_mask = svcmplt_n_s32(pg, num, 0);\n        num = svabs_s32_x(pg, num);\n\n        while (svptest_any(svptrue_b32(), pg)) {\n            svint32_t digit = svmod_n_s32(pg, num, 10);\n            sum_digits = svadd_s32_x(pg, sum_digits, digit);\n            num = svdiv_n_s32(pg, num, 10);\n            svbool_t zero_mask = svcmpeq_n_s32(pg, num, 0);\n            if (svptest_first(svptrue_b32(), svnot_z(pg, zero_mask))) {\n                break;\n            }\n        }\n\n        svint32_t first_digit = svneg_s32_x(pg, svlsr_n_s32(pg, vec, 31));\n        sum_digits = svadd_s32_x(pg, sum_digits, first_digit);\n\n        svbool_t positive_sum_mask = svcmpgt_n_s32(pg, sum_digits, 0);\n        count += svcntp_b32(svptrue_b32(), positive_sum_mask);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    size_t i = 0;\n    size_t size = n.size();\n\n    while (i <= size - svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        svint32_t vec = svld1_s32(pg, &n[i]);\n\n        svint32_t sum_digits = svdup_s32(0);\n        svint32_t num = vec;\n\n        // Handle negative numbers\n        svbool_t is_negative = svcmplt_n_s32(pg, num, 0);\n        svint32_t sign = svdup_s32(1);\n        sign = svsel(is_negative, svneg(sign), sign);\n        num = svmul_x(pg, num, sign);\n\n        // Compute sum of digits\n        while (svptest_any(svptrue_b32(), pg)) {\n            svint32_t digit = svrem_n_s32(pg, num, 10);\n            sum_digits = svadd_x(pg, sum_digits, digit);\n            num = svdiv_n_s32_z(pg, num, 10);\n            pg = svcmpne_n_s32(pg, num, 0);\n        }\n\n        // Adjust for negative numbers\n        sum_digits = svmla_x(pg, svdup_s32(0), vec, svdup_s32(-2 * (vec < 0)));\n\n        // Count elements where sum of digits > 0\n        svbool_t positive_sum = svcmpgt_n_s32(pg, sum_digits, 0);\n        count += svcntp_b32(svptrue_b32(), positive_sum);\n\n        i += svcntw();\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        int num = n[i];\n        int sum = 0;\n        int sign = num < 0 ? -1 : 1;\n        num *= sign;\n\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n\n        if (sign == -1) {\n            sum = -sum;\n        }\n\n        if (sum > 0) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    size_t i = 0;\n    size_t len = n.size();\n    svbool_t pg = svwhilelt_b32(i, len);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec = svld1(pg, &n[i]);\n        svint32_t sum_digits = svdup_n_s32(0);\n\n        svint32_t num = vec;\n        svbool_t negative_mask = svcmplt_n_s32(pg, num, 0);\n        num = svabs_s32_x(pg, num);\n\n        while (svptest_any(pg, svcmpne_n_s32(pg, num, 0))) {\n            svint32_t digit = svrem_n_s32(pg, num, 10);\n            sum_digits = svadd_s32_x(pg, sum_digits, digit);\n            num = svdiv_n_s32(pg, num, 10);\n        }\n\n        svint32_t first_digit = svneg_s32_x(pg, svlsr_n_s32_x(pg, vec, 31));\n        sum_digits = svadd_s32_x(pg, sum_digits, first_digit);\n\n        svbool_t positive_sum_mask = svcmpgt_n_s32(pg, sum_digits, 0);\n        count += svcntp_b32(pg, positive_sum_mask);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, len);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) return true;\n\n    size_t N = arr.size();\n    int count_drops = 0;\n    int last_index = N - 1;\n\n    // Load the array into SVE vectors\n    svint32_t vec = svld1_s32(svptrue_b32(), arr.data());\n    svint32_t rotated_vec = svext_s32(vec, vec, 1); // Rotate left by 1\n\n    // Compare adjacent elements to find drops\n    svbool_t pg = svptrue_b32();\n    svbool_t drop_mask = svcmpgt(pg, vec, rotated_vec);\n\n    // Count the number of drops\n    count_drops = svcntp_b32(svptrue_b32(), drop_mask);\n\n    // Handle the wrap-around case manually\n    if (arr[last_index] > arr[0]) {\n        count_drops++;\n    }\n\n    return count_drops <= 1;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) return true;\n\n    size_t N = arr.size();\n    int count_drops = 0;\n    int last_element = arr[N - 1];\n\n    svbool_t pg = svwhilelt_b32(0, N); // Predicate for active lanes\n\n    svint32_t vec = svld1_s32(pg, arr.data()); // Load the array into a vector\n    svint32_t rotated_vec = svext_s32(vec, vec, 1); // Rotate the vector by one position\n\n    // Compare adjacent elements to detect drops\n    svbool_t drop_mask = svcmpgt_s32(pg, rotated_vec, vec);\n    count_drops = svcntp_b32(svptrue_b32(), drop_mask);\n\n    // Handle the wrap-around case manually\n    if (arr[0] < last_element) {\n        count_drops++;\n    }\n\n    return count_drops <= 1;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) return true;\n\n    size_t N = arr.size();\n    int count_drops = 0;\n    int last_index = -1;\n\n    // Find the number of drops in the array\n    for (size_t i = 0; i < N; ++i) {\n        if (arr[i] > arr[(i + 1) % N]) {\n            count_drops++;\n            last_index = i;\n        }\n    }\n\n    // If there is more than one drop, it's not possible to sort by right shifts\n    if (count_drops > 1) return false;\n\n    // If no drops or exactly one drop, check if the array can be sorted\n    if (count_drops == 0) return true;\n\n    // Verify that the last element after the drop is less than or equal to the first element\n    return arr[(last_index + 1) % N] <= arr[0];\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) return true;\n\n    size_t N = arr.size();\n    int count_drops = 0;\n    int last_element = arr[N - 1];\n\n    svbool_t pg = svwhilelt_b32(0, N); // Predicate for active lanes\n\n    svint32_t vec = svld1(pg, arr.data()); // Load the array into a vector\n    svint32_t rotated_vec = svext(vec, vec, 1); // Rotate the vector by one position\n\n    // Compare adjacent elements to detect drops\n    svbool_t drop_mask = svcmpgt(pg, vec, rotated_vec);\n\n    // Count the number of drops\n    count_drops = svcntp_b32(svptrue_b32(), drop_mask);\n\n    // Handle the wrap-around case manually\n    if (last_element > arr[0]) {\n        count_drops++;\n    }\n\n    return count_drops <= 1;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) return true;\n\n    size_t N = arr.size();\n    int count_drops = 0;\n    int last_index = -1;\n\n    // Find the number of drops in the array\n    for (size_t i = 0; i < N; ++i) {\n        if (arr[i] > arr[(i + 1) % N]) {\n            count_drops++;\n            last_index = i;\n        }\n    }\n\n    // If there is more than one drop, it's not possible to sort by right shifts\n    if (count_drops > 1) return false;\n\n    // If no drops or exactly one drop, check if the array can be sorted\n    if (count_drops == 0) return true;\n\n    // Verify that the last element is greater than the first element\n    return arr[last_index] > arr[(last_index + 1) % N];\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t n = lst1.size();\n    size_t m = lst2.size();\n\n    // Counters for odd numbers in lst1 and even numbers in lst2\n    int odd_count_lst1 = 0;\n    int even_count_lst2 = 0;\n\n    // Process lst1 to count odd numbers using SVE\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, n);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec1 = svld1(pg, &lst1[i]);\n        svbool_t odd_mask = svcmpne_n_s32(pg, svand_z(pg, vec1, 1), 0);\n        odd_count_lst1 += svcntp_b32(pg, odd_mask);\n        i += svcntw();\n        pg = svwhilelt_b32(i, n);\n    }\n\n    // Process lst2 to count even numbers using SVE\n    size_t j = 0;\n    pg = svwhilelt_b32(j, m);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec2 = svld1(pg, &lst2[j]);\n        svbool_t even_mask = svcmpeq_n_s32(pg, svand_z(pg, vec2, 1), 0);\n        even_count_lst2 += svcntp_b32(pg, even_mask);\n        j += svcntw();\n        pg = svwhilelt_b32(j, m);\n    }\n\n    // Check if the number of even numbers in lst2 is sufficient to replace odd numbers in lst1\n    return (even_count_lst2 >= odd_count_lst1) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t size1 = lst1.size();\n    size_t size2 = lst2.size();\n    size_t max_size = std::max(size1, size2);\n\n    // Allocate aligned memory for SVE operations\n    int* aligned_lst1 = (int*)svmalloc(sizeof(int) * max_size);\n    int* aligned_lst2 = (int*)svmalloc(sizeof(int) * max_size);\n\n    // Copy data to aligned memory\n    for (size_t i = 0; i < size1; ++i) aligned_lst1[i] = lst1[i];\n    for (size_t i = 0; i < size2; ++i) aligned_lst2[i] = lst2[i];\n\n    // Initialize sve registers\n    svbool_t pg = svwhilelt_b32(0, max_size);\n    svint32_t vec1 = svld1(pg, aligned_lst1);\n    svint32_t vec2 = svld1(pg, aligned_lst2);\n\n    // Count odd numbers in lst1\n    svint32_t odd_mask1 = svand_n_s32(pg, vec1, 1);\n    uint64_t odd_count1 = svcntp_b32(pg, svbool_m32(pg, odd_mask1));\n\n    // Count even numbers in lst2\n    svint32_t even_mask2 = svnot_b_z(pg, svbool_m32(svand_n_s32(pg, vec2, 1)));\n    uint64_t even_count2 = svcntp_b32(pg, svbool_m32(even_mask2));\n\n    // Free aligned memory\n    svfree(aligned_lst1);\n    svfree(aligned_lst2);\n\n    // Check if the number of even numbers in lst2 is sufficient to replace odd numbers in lst1\n    return (even_count2 >= odd_count1) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t n = lst1.size();\n    size_t m = lst2.size();\n    size_t max_size = std::max(n, m);\n\n    // Allocate buffers for SVE processing\n    std::vector<int> buf1(max_size, 0);\n    std::vector<int> buf2(max_size, 0);\n\n    // Copy input vectors to buffers, padding with zeros if necessary\n    std::copy(lst1.begin(), lst1.end(), buf1.begin());\n    std::copy(lst2.begin(), lst2.end(), buf2.begin());\n\n    // Initialize SVE predicates and registers\n    svbool_t pg = svwhilelt_b32(0, max_size); // Predicate for active lanes\n    svint32_t vec1 = svld1(pg, buf1.data());  // Load lst1 into SVE register\n    svint32_t vec2 = svld1(pg, buf2.data());  // Load lst2 into SVE register\n\n    // Count odd numbers in lst1\n    svint32_t odd_mask1 = svand_n_s32(pg, vec1, 1); // Mask for odd numbers in lst1\n    svbool_t odd_pred1 = svcmpne_n_s32(pg, odd_mask1, 0); // Predicate for odd numbers in lst1\n    int odd_count1 = svcntp_b32(pg, odd_pred1); // Count odd numbers in lst1\n\n    // Count even numbers in lst2\n    svint32_t even_mask2 = svand_n_s32(pg, vec2, 1); // Mask for even numbers in lst2\n    svbool_t even_pred2 = svcmpeq_n_s32(pg, even_mask2, 0); // Predicate for even numbers in lst2\n    int even_count2 = svcntp_b32(pg, even_pred2); // Count even numbers in lst2\n\n    // Determine if exchange is possible\n    return (odd_count1 <= even_count2) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t size1 = lst1.size();\n    size_t size2 = lst2.size();\n    size_t max_size = std::max(size1, size2);\n\n    // Allocate aligned memory for SVE processing\n    int* aligned_lst1 = (int*)svmalloc(sizeof(int) * max_size);\n    int* aligned_lst2 = (int*)svmalloc(sizeof(int) * max_size);\n\n    // Copy data to aligned memory\n    for (size_t i = 0; i < size1; ++i) aligned_lst1[i] = lst1[i];\n    for (size_t i = 0; i < size2; ++i) aligned_lst2[i] = lst2[i];\n\n    // Initialize predicate for active lanes\n    svbool_t pred = svwhilelt_b32(0, max_size);\n\n    // Count odd numbers in lst1\n    svint32_t vec1 = svld1_s32(pred, aligned_lst1);\n    svint32_t odd_mask1 = svand_n_s32_z(pred, vec1, 1);\n    svbool_t odd_pred1 = svcmpeq_n_s32(pred, odd_mask1, 1);\n    int odd_count1 = svcntp_b32(pred, odd_pred1);\n\n    // Count even numbers in lst2\n    svint32_t vec2 = svld1_s32(pred, aligned_lst2);\n    svint32_t even_mask2 = svbic_n_s32_z(pred, vec2, 1);\n    svbool_t even_pred2 = svcmpeq_n_s32(pred, even_mask2, 0);\n    int even_count2 = svcntp_b32(pred, even_pred2);\n\n    // Free aligned memory\n    svfree(aligned_lst1);\n    svfree(aligned_lst2);\n\n    // Check if the number of even numbers in lst2 is sufficient to replace odd numbers in lst1\n    return (even_count2 >= odd_count1) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t size1 = lst1.size();\n    size_t size2 = lst2.size();\n    size_t max_size = std::max(size1, size2);\n\n    // Allocate aligned memory for SVE operations\n    int* aligned_lst1 = (int*)svmalloc(max_size * sizeof(int));\n    int* aligned_lst2 = (int*)svmalloc(max_size * sizeof(int));\n\n    // Copy data to aligned memory\n    for (size_t i = 0; i < size1; ++i) aligned_lst1[i] = lst1[i];\n    for (size_t i = 0; i < size2; ++i) aligned_lst2[i] = lst2[i];\n\n    // Initialize predicate for vector operations\n    svbool_t pg =svptrue_b32();\n\n    // Count odd numbers in lst1\n    int odd_count_lst1 = 0;\n    for (size_t i = 0; i < size1; i += svcntw()) {\n        svint32_t vec1 = svld1(pg, &aligned_lst1[i]);\n        svbool_t odd_mask = svcmpne_n_s32(pg, svand_s32_z(pg, vec1, 1), 0);\n        odd_count_lst1 += svcntp_b32(svptrue_b32(), odd_mask);\n    }\n\n    // Count even numbers in lst2\n    int even_count_lst2 = 0;\n    for (size_t i = 0; i < size2; i += svcntw()) {\n        svint32_t vec2 = svld1(pg, &aligned_lst2[i]);\n        svbool_t even_mask = svcmpeq_n_s32(pg, svand_s32_z(pg, vec2, 1), 0);\n        even_count_lst2 += svcntp_b32(svptrue_b32(), even_mask);\n    }\n\n    // Free aligned memory\n    svfree(aligned_lst1);\n    svfree(aligned_lst2);\n\n    // Determine if exchange is possible\n    return (odd_count_lst1 <= even_count_lst2) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        size_t count = 0;\n        size_t len = str.length();\n        const char* data = str.data();\n\n        size_t i = 0;\n        svbool_t pg = svwhilelt_b8(i, len);\n\n        while (svptest_any(svptrue_b8(), pg)) {\n            svuint8_t vec = svld1sb(pg, data + i);\n            svuint8_t odd_mask = svcmpeq_n_u8(pg, svand_z(pg, vec, 1), 1);\n            count += svcntp_b8(pg, odd_mask);\n            i += svcntb();\n            pg = svwhilelt_b8(i, len);\n        }\n\n        std::string output = \"the number of odd elements \" + std::to_string(count) +\n                             \"n the str\" + std::to_string(count) + \"ng \" +\n                             std::to_string(count) + \" of the \" +\n                             std::to_string(count) + \"nput.\";\n        result.push_back(output);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        size_t count = 0;\n        size_t i = 0;\n        size_t len = str.length();\n\n        // Process the string in chunks using SVE\n        while (i + svcntb() <= len) {\n            svuint8_t vec = svld1sb_u8(svptrue_b8(), reinterpret_cast<const uint8_t*>(str.data() + i));\n            svbool_t odd_mask = svcmpne_n_u8(svptrue_b8(), svand_z(svptrue_b8(), vec, 1), 0);\n            count += svcntp_b8(svptrue_b8(), odd_mask);\n            i += svcntb();\n        }\n\n        // Process remaining elements\n        for (; i < len; ++i) {\n            if ((str[i] - '0') % 2 != 0) {\n                ++count;\n            }\n        }\n\n        // Replace 'i' with the count in the output string\n        std::string output = \"the number of odd elements \" + std::to_string(count) + \n                             \"n the str\" + std::to_string(count) + \"ng \" + \n                             std::to_string(count) + \" of the \" + \n                             std::to_string(count) + \"nput.\";\n        result.push_back(output);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    const char *template_str = \"the number of odd elements in the string X of the input.\";\n    size_t template_len = strlen(template_str);\n\n    for (const auto &str : lst) {\n        int odd_count = 0;\n        size_t len = str.length();\n        size_t i = 0;\n\n        while (i <= len - svcntb()) {\n            svuint8_t vec = svld1sb_u8(svptrue_b8(), (const uint8_t*)(str.c_str() + i));\n            svbool_t odd_mask = svcmpeq_n_u8(svptrue_b8(), svand_n_u8_z(svptrue_b8(), vec, 1), 1);\n            odd_count += svcntp_b8(svptrue_b8(), odd_mask);\n            i += svcntb();\n        }\n\n        for (; i < len; ++i) {\n            if ((str[i] - '0') % 2 != 0) {\n                odd_count++;\n            }\n        }\n\n        std::string output = template_str;\n        char count_char = '0' + odd_count;\n        for (size_t j = 0; j < output.size(); ++j) {\n            if (output[j] == 'X') {\n                output[j] = count_char;\n            }\n        }\n        result.push_back(output);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        size_t count = 0;\n        size_t len = str.length();\n        const char* data = str.data();\n\n        size_t i = 0;\n        svbool_t pg = svwhilelt_b8(i, len);\n\n        while (svptest_any(svptrue_b8(), pg)) {\n            svuint8_t vec = svld1sb(pg, data + i);\n            svuint8_t odd_mask = svcmpeq_n_u8(pg, svand_n_u8(pg, vec, 1), 1);\n            count += svcntp_b8(pg, odd_mask);\n            i += svcntb();\n            pg = svwhilelt_b8(i, len);\n        }\n\n        std::string output = \"the number of odd elements \" + std::to_string(count) +\n                             \"n the str\" + std::to_string(count) + \"ng \" +\n                             std::to_string(count) + \" of the \" +\n                             std::to_string(count) + \"nput.\";\n        result.push_back(output);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    const char base_message[] = \"the number of odd elements in the string X of the input.\";\n    const size_t message_len = sizeof(base_message) - 1; // Exclude null terminator\n\n    for (const auto& str : lst) {\n        size_t odd_count = 0;\n        size_t len = str.length();\n        size_t i = 0;\n\n        // Process the string in chunks using SVE\n        svbool_t pg = svwhilelt_b8(i, len);\n        while (svptest_any(svptrue_b8(), pg)) {\n            svuint8_t vec = svld1sb_u8(pg, str.data() + i);\n            svuint8_t odd_mask = svand_n_u8_z(pg, vec, 1); // Check if odd digit\n            odd_count += svcntp_b8(pg, odd_mask);\n\n            i += svcntb();\n            pg = svwhilelt_b8(i, len);\n        }\n\n        // Replace 'X' in the base message with the odd count\n        std::string output(base_message, message_len);\n        for (char& c : output) {\n            if (c == 'X') {\n                c = '0' + odd_count;\n            }\n        }\n\n        result.push_back(output);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int64_t result = INT64_MAX;\n    size_t i = 0;\n    size_t n = nums.size();\n\n    svbool_t pg = svwhilelt_b64(i, n);\n    svint64_t vec_min_sum = svdup_s64(0);\n    svint64_t vec_current_sum = svdup_s64(0);\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svint64_t vec_nums = svld1(pg, &nums[i]);\n\n        // Update current sum\n        vec_current_sum = svadd_s64_x(pg, vec_current_sum, vec_nums);\n\n        // Update minimum sum\n        vec_min_sum = svmin_s64_x(pg, vec_min_sum, vec_current_sum);\n\n        // Reset current sum if it becomes positive\n        svbool_t positive_mask = svcmpgt_s64(pg, vec_current_sum, svdup_s64(0));\n        vec_current_sum = svsel_s64(positive_mask, svdup_s64(0), vec_current_sum);\n\n        i += svcntd();\n        pg = svwhilelt_b64(i, n);\n    }\n\n    // Horizontal reduction to find the minimum value in vec_min_sum\n    int64_t min_sum = INT64_MAX;\n    while (svptest_any(svptrue_b64(), pg)) {\n        min_sum = std::min(min_sum, svminv_s64(pg, vec_min_sum));\n        i += svcntd();\n        pg = svwhilelt_b64(i, n);\n    }\n\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    size_t size = nums.size();\n    const int64_t* data = nums.data();\n\n    svbool_t pg = svwhilelt_b64(0, size);\n    svint64_t vec_min_sum = svld1(pg, data);\n    svint64_t vec_current_sum = vec_min_sum;\n\n    size_t i = svcntd();\n    while (i < size) {\n        pg = svwhilelt_b64(i, size);\n        svint64_t vec_nums = svld1(pg, data + i);\n\n        svint64_t vec_temp_sum = svadd(vec_current_sum, vec_nums);\n        svbool_t pred_negative = svcmplt(vec_temp_sum, vec_nums);\n        vec_current_sum = svsel(pred_negative, vec_temp_sum, vec_nums);\n        vec_min_sum = svmin(vec_min_sum, vec_current_sum);\n\n        i += svcntd();\n    }\n\n    int64_t min_sum = svminv(vec_min_sum);\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    size_t size = nums.size();\n    const int64_t* data = nums.data();\n\n    svbool_t pg = svwhilelt_b64(0, size);\n    svint64_t vec_min_sum = svld1(pg, data);\n    svint64_t vec_current_sum = vec_min_sum;\n\n    for (size_t i = 1; i < size; ++i) {\n        svint64_t vec_next = svld1(pg, data + i);\n        vec_current_sum = svadd_z(pg, vec_current_sum, vec_next);\n        vec_min_sum = svmin_z(pg, vec_min_sum, vec_current_sum);\n\n        // Reset current sum if it becomes positive\n        svbool_t positive_mask = svcmpgt(vec_current_sum, 0);\n        vec_current_sum = svsel(positive_mask, sv_next, vec_current_sum);\n    }\n\n    // Horizontal reduction to find the minimum value in vec_min_sum\n    int64_t min_sum = svminv(pg, vec_min_sum);\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    size_t size = nums.size();\n    const int64_t* data = nums.data();\n\n    svint64_t vec_min_sum = svdup_n_s64(0);\n    svint64_t vec_current_sum = svdup_n_s64(0);\n    svbool_t pred = svwhilelt_b64(0, size);\n\n    int64_t global_min = nums[0];\n    size_t i = 0;\n\n    while (svptest_any(svptrue_b64(), pred)) {\n        svint64_t vec_data = svld1_s64(pred, data + i);\n\n        // Update current sum: current_sum = min(vec_data, current_sum + vec_data)\n        svint64_t vec_temp_sum = svadd_s64_z(pred, vec_current_sum, vec_data);\n        vec_current_sum = svmin_s64_m(pred, vec_data, vec_temp_sum);\n\n        // Update global min: global_min = min(global_min, current_sum)\n        svint64_t vec_local_min = svminv_s64(pred, vec_current_sum);\n        global_min = svminv_s64(svptrue_b64(), svset_lane_s64(global_min, vec_local_min, 0));\n\n        i += svcntd();\n        pred = svwhilelt_b64(i, size);\n    }\n\n    return global_min;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    size_t size = nums.size();\n    int64_t *data = nums.data();\n\n    svbool_t pg = svwhilelt_b64(0, size);\n    svint64_t vec_min_sum = svld1(pg, data);\n    svint64_t vec_current_sum = vec_min_sum;\n\n    for (size_t i = 1; i < size; ++i) {\n        svint64_t vec_next = svld1(pg, data + i);\n        svint64_t vec_temp = svadd(vec_current_sum, vec_next);\n        vec_current_sum = svmin(vec_next, vec_temp);\n        vec_min_sum = svmin(vec_min_sum, vec_current_sum);\n    }\n\n    int64_t result = svminv(pg, vec_min_sum);\n    return result;\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint max_fill_simd(const std::vector<std::vector<int>> &grid, int capacity) {\n    int total_buckets = 0;\n\n    for (const auto &row : grid) {\n        int row_size = row.size();\n        int i = 0;\n\n        // Process the row using SVE intrinsics\n        while (i <= row_size - svcntw()) {\n            svbool_t pg = svwhilelt_b32(i, row_size);\n            svuint32_t vec = svld1uw(pg, reinterpret_cast<const uint32_t*>(&row[i]));\n\n            // Count the number of 1s in the vector\n            svuint32_t ones = svcmpeq(pg, vec, 1);\n            int count = svcntp(pg, ones);\n\n            // Add the number of buckets needed for this vector\n            total_buckets += (count + capacity - 1) / capacity;\n            i += svcntw();\n        }\n\n        // Process remaining elements\n        for (; i < row_size; ++i) {\n            if (row[i] == 1) {\n                total_buckets += (1 + capacity - 1) / capacity;\n            }\n        }\n    }\n\n    return total_buckets;\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint max_fill_simd(const std::vector<std::vector<int>> &grid, int capacity) {\n    int total_buckets = 0;\n\n    for (const auto &row : grid) {\n        size_t i = 0;\n        size_t row_size = row.size();\n        int row_sum = 0;\n\n        // Process the row using SVE intrinsics\n        while (i + svcntw() <= row_size) {\n            svbool_t pg = svwhilelt_b32(i, row_size);\n            svuint32_t vec = svld1uw(pg, &row[i]);\n            svuint32_t ones = svdup_u32(1);\n            svuint32_t mask = svcmpeq(pg, vec, ones);\n            row_sum += svcntp_b32(svptrue_b32(), mask);\n            i += svcntw();\n        }\n\n        // Process remaining elements\n        for (; i < row_size; ++i) {\n            row_sum += row[i];\n        }\n\n        // Calculate buckets needed for this row\n        total_buckets += (row_sum + capacity - 1) / capacity;\n    }\n\n    return total_buckets;\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint max_fill_simd(const std::vector<std::vector<int>> &grid, int capacity) {\n    int total_buckets = 0;\n\n    for (const auto &row : grid) {\n        size_t i = 0;\n        size_t row_size = row.size();\n        int row_sum = 0;\n\n        // Process the row using SVE intrinsics\n        while (i <= row_size - svcntw()) {\n            svbool_t pg = svwhilelt_b32(i, row_size);\n            svuint32_t vec = svld1uw(pg, reinterpret_cast<const uint32_t*>(&row[i]));\n            svuint32_t ones = svdup_u32(1);\n            svuint32_t mask = svcmpeq(pg, vec, ones);\n            row_sum += svcntp_b32(svptrue_b32(), mask);\n            i += svcntw();\n        }\n\n        // Process remaining elements\n        for (; i < row_size; ++i) {\n            row_sum += row[i];\n        }\n\n        // Calculate buckets needed for this row\n        total_buckets += (row_sum + capacity - 1) / capacity;\n    }\n\n    return total_buckets;\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint max_fill_simd(const std::vector<std::vector<int>> &grid, int capacity) {\n    int total_buckets = 0;\n\n    for (const auto &row : grid) {\n        size_t i = 0;\n        size_t row_size = row.size();\n        int row_sum = 0;\n\n        // Process the row using SVE intrinsics\n        while (i <= row_size - svcntw()) {\n            svbool_t pg = svwhilelt_b32(i, row_size);\n            svuint32_t vec = svld1uw(pg, reinterpret_cast<const uint32_t*>(&row[i]));\n            svuint32_t ones = svdup_u32(1);\n            svuint32_t mask = svcmpeq(pg, vec, ones);\n            row_sum += svcntp_b32(svptrue_b32(), mask);\n            i += svcntw();\n        }\n\n        // Process remaining elements\n        for (; i < row_size; ++i) {\n            row_sum += row[i];\n        }\n\n        // Calculate buckets needed for this row\n        total_buckets += (row_sum + capacity - 1) / capacity;\n    }\n\n    return total_buckets;\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint max_fill_simd(const std::vector<std::vector<int>> &grid, int capacity) {\n    int total_buckets = 0;\n\n    for (const auto &row : grid) {\n        int row_size = row.size();\n        int i = 0;\n\n        while (i <= row_size - svcntw()) {\n            svbool_t pg = svwhilelt_b32(i, row_size);\n            svuint32_t vec = svld1uw(pg, reinterpret_cast<const uint32_t*>(&row[i]));\n            svuint32_t ones = svdup_u32(1);\n            svuint32_t water_units = svaddv(pg, svcmpeq(pg, vec, ones));\n            total_buckets += svcntp_b32(svdup_b32(0), water_units) / capacity + \n                             (svcntp_b32(svdup_b32(0), water_units) % capacity != 0);\n            i += svcntw();\n        }\n\n        for (; i < row_size; ++i) {\n            if (row[i] == 1) {\n                total_buckets += 1 / capacity + (1 % capacity != 0);\n            }\n        }\n    }\n\n    return total_buckets;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    size_t i = 0;\n    size_t n = lst.size();\n\n    svbool_t pg = svwhilelt_b16(i, n); // Predicate for active lanes\n\n    while (svptest_any(svptrue_b16(), pg)) {\n        svint16_t vec = svld1(pg, &lst[i]); // Load vector of 16-bit integers\n        svbool_t even_pos = svcmpeq_n_s16(pg, svindex_s16(0, 1), 0); // Even positions mask\n        svbool_t odd_val = svcmpne_n_s16(pg, svand(vec, 1), 0); // Odd values mask\n        svbool_t mask = svand(even_pos, odd_val); // Combine masks: even positions AND odd values\n\n        svint16_t selected = svsel(mask, vec, 0); // Select elements matching the condition\n        sum += svcntw() == 4 ? svaddv(svptrue_b16(), svreinterpret_s32_s16(selected)) : \n                                svaddv(svptrue_b16(), svreinterpret_s64_s16(selected));\n\n        i += svcntw(); // Move to next chunk\n        pg = svwhilelt_b16(i, n); // Update predicate\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t result = 0;\n    size_t i = 0;\n    size_t len = lst.size();\n\n    svbool_t pg = svwhilelt_b16(i, len);\n    svint16_t vec = svld1(pg, &lst[i]);\n\n    while (svptest_any(svptrue_b16(), pg)) {\n        // Create a predicate for even positions\n        svbool_t even_pos = svcmpeq_n_s16(pg, svindex_s16(0, 1), 0);\n\n        // Extract elements at even positions\n        svint16_t even_elements = svcompact(even_pos, vec);\n\n        // Check which of these are odd\n        svbool_t odd_mask = svcmpne_n_s16(svptrue_b16(), svand_n_s16(even_elements, 1), 0);\n\n        // Compact the odd elements\n        svint16_t odd_elements = svcompact(odd_mask, even_elements);\n\n        // Sum the odd elements and add to result\n        result += svcntp(svptrue_b16(), odd_mask) > 0 ? svaddv(svptrue_b16(), odd_elements) : 0;\n\n        // Update index and reload vector\n        i += svcntw();\n        pg = svwhilelt_b16(i, len);\n        vec = svld1(pg, &lst[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    size_t i = 0;\n    size_t n = lst.size();\n\n    svbool_t pg = svwhilelt_b16(i, n); // Predicate for active lanes\n\n    while (svptest_any(svptrue_b16(), pg)) {\n        svint16_t vec = svld1(pg, &lst[i]); // Load vector of 16-bit integers\n        svbool_t even_pos_mask = svcmpeq_n_s16(pg, svindex_s16(0, 1), 0); // Mask for even positions\n        svbool_t odd_val_mask = svcmpne_n_s16(pg, svand(vec, 1), 0); // Mask for odd values\n        svbool_t combined_mask = svand(even_pos_mask, odd_val_mask); // Combine masks\n\n        svint16_t selected_vals = svand_z(combined_mask, vec); // Select values matching the condition\n        sum += svcntw() == 4 ? svaddv(svcvt_s32(selected_vals), 0) : svaddv(selected_vals, 0);\n\n        i += svcntw();\n        pg = svwhilelt_b16(i, n);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    size_t i = 0;\n    size_t length = lst.size();\n\n    // Load the vector data into SVE registers and process in chunks\n    while (i <= length - svcntw()) {\n        // Load a vector of 16-bit integers from memory\n        svint16_t vec = svld1_s16(svptrue_b16(), &lst[i]);\n\n        // Create a predicate for even positions (0, 2, 4, ...)\n        svbool_t even_pos_pred = svbrkb_z(svptrue_b16(), svptrue_b16());\n\n        // Extract elements at even positions\n        svint16_t even_pos_vals = svcompact_s16(even_pos_pred, vec);\n\n        // Check which of these values are odd\n        svbool_t odd_val_pred = svcmpne_n_s16(svptrue_b16(), svand_s16_z(svptrue_b16(), even_pos_vals, 1), 0);\n\n        // Compact the odd values\n        svint16_t odd_vals = svcompact_s16(odd_val_pred, even_pos_vals);\n\n        // Convert odd values to 64-bit integers and add to the sum\n        svint64_t odd_vals_wide = svunpklo_s16(odd_vals);\n        sum += svaddv_s64(svptrue_b64(), odd_vals_wide);\n\n        i += svcntw();\n    }\n\n    // Process any remaining elements\n    for (; i < length; ++i) {\n        if (i % 2 == 0 && (lst[i] & 1)) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t result = 0;\n    size_t i = 0;\n    size_t length = lst.size();\n\n    // Load the vector data into SVE registers and process in chunks\n    while (i <= length - svcntw()) {\n        // Load a vector of 16-bit integers from memory\n        svint16_t vec = svld1_s16(svptrue_b16(), &lst[i]);\n\n        // Create a predicate for even positions (0, 2, 4, ...)\n        svbool_t even_pos_pred = svbrkb_z(svptrue_b16(), svptrue_b16());\n\n        // Extract elements at even positions\n        svint16_t even_pos_vals = svcompact_s16(even_pos_pred, vec);\n\n        // Check which of these values are odd\n        svbool_t odd_val_pred = svcmpne_n_s16(svptrue_b16(), svand_s16_x(svptrue_b16(), even_pos_vals, 1), 0);\n\n        // Compact the odd values\n        svint16_t odd_vals = svcompact_s16(odd_val_pred, even_pos_vals);\n\n        // Widen the odd values to 32-bit integers for summation\n        svint32_t odd_vals_wide = svunpklo_s16(odd_vals);\n\n        // Sum the widened odd values horizontally\n        svint32_t sum_vec = svaddv_s32(svptrue_b32(), odd_vals_wide);\n\n        // Add the horizontal sum to the result\n        result += svcvt_s64_s32_z(svptrue_b64(), sum_vec);\n\n        // Move to the next chunk\n        i += svcntw();\n    }\n\n    // Process any remaining elements that didn't fit into a full vector\n    for (; i < length; ++i) {\n        if ((i % 2 == 0) && (lst[i] % 2 != 0)) {\n            result += lst[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    svbool_t pg = svwhilelt_b32(0, k); // Predicate for the first k elements\n    svint32_t vec = svld1(pg, arr.data()); // Load the first k elements into a vector\n    svint32_t abs_vec = svabs(vec); // Compute absolute values to handle negative numbers\n    svbool_t mask = svcmplt(pg, abs_vec, 100); // Mask for elements with at most two digits\n    svint32_t filtered = svsel(mask, vec, svdup_n_s32(0)); // Select elements based on the mask, others set to 0\n    int sum = svaddv(pg, filtered); // Horizontal sum of the selected elements\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    svbool_t pg = svwhilelt_b32(0, k); // Predicate for the first k elements\n    int sum = 0;\n    size_t i = 0;\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec = svld1(pg, &arr[i]); // Load vector of integers\n        svbool_t mask = svabs(vec) < 100;   // Mask for elements with at most two digits\n        svint32_t filtered = svand_z(pg, vec, mask); // Apply mask to filter elements\n        sum += svaddv(pg, filtered);       // Add up the filtered elements\n\n        i += svcntw();                     // Move to the next chunk\n        pg = svwhilelt_b32(i, k);          // Update predicate for remaining elements\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    svbool_t pg = svwhilelt_b32(0, k); // Predicate for the first k elements\n    int sum = 0;\n    size_t i = 0;\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec = svld1(pg, &arr[i]); // Load vector of integers\n        svbool_t mask = svabs(vec) < 100;  // Mask for elements with at most two digits\n        svint32_t filtered = svsel(mask, vec, svdup_n_s32(0)); // Select valid elements or zero\n        sum += svaddv(pg, filtered); // Add up the valid elements\n\n        i += svcntw(); // Move to the next chunk\n        pg = svwhilelt_b32(i, k); // Update predicate for remaining elements\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    svbool_t pg = svwhilelt_b32(0, k); // Predicate for the first k elements\n    int sum = 0;\n    size_t i = 0;\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec = svld1(pg, &arr[i]); // Load elements into a vector\n        svbool_t mask = svcmpge_n_s32(pg, vec, -99); // Elements >= -99\n        mask = svcmpeq_n_s32(mask, vec, 99); // Elements <= 99\n        svint32_t filtered = svand_z(mask, vec); // Zero out elements not in range\n        sum += svaddv(mask, filtered); // Add up the valid elements\n\n        i += svcntw(); // Move to the next chunk of elements\n        pg = svwhilelt_b32(i, k); // Update predicate for remaining elements\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    svbool_t pg = svwhilelt_b32(0, k); // Predicate for the first k elements\n    int sum = 0;\n    size_t i = 0;\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec = svld1(pg, &arr[i]); // Load elements using the predicate\n        svbool_t mask = svcmpge_n_s32(pg, vec, -99); // Elements >= -99\n        mask = svcmpeq_n_s32_m(mask, vec, 99); // Elements <= 99\n        svint32_t filtered = svand_z(mask, vec); // Zero out elements not in range\n        sum += svaddv(mask, filtered); // Sum up the valid elements\n\n        i += svcntw(); // Move to the next chunk\n        pg = svwhilelt_b32(i, k); // Update predicate for remaining elements\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool is_sorted_simd(const std::vector<int> &lst) {\n    size_t size = lst.size();\n    if (size <= 1) return true;\n\n    const int *data = lst.data();\n    size_t vl;\n    svbool_t pg = svwhilelt_b32(0, size);\n    vl = svcntw();\n\n    svint32_t prev = svld1(pg, data);\n    bool sorted = true;\n    bool duplicates = false;\n\n    for (size_t i = 1; i < size; i += vl) {\n        svbool_t pg_next = svwhilelt_b32(i, size);\n        svint32_t curr = svld1(pg_next, data + i);\n\n        // Check if sorted in ascending order\n        svbool_t sorted_mask = svcmpge(pg_next, curr, svext(prev, curr, vl - 1));\n        if (!svptest_all(pg_next, sorted_mask)) {\n            sorted = false;\n            break;\n        }\n\n        // Check for more than one duplicate\n        svbool_t eq_mask = svcmpeq(pg_next, curr, svext(prev, curr, vl - 1));\n        svbool_t dup_mask = svcmpeq(pg_next, curr, svext(curr, curr, vl - 1));\n        svbool_t combined_mask = svorr_z(pg_next, eq_mask, dup_mask);\n        if (svptest_any(pg_next, combined_mask)) {\n            duplicates = true;\n            break;\n        }\n\n        prev = curr;\n    }\n\n    return sorted && !duplicates;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    size_t size = lst.size();\n    if (size <= 1) return true;\n\n    const int *data = lst.data();\n    size_t vl;\n    svbool_t pg = svwhilelt_b32(0, size); // Predicate for the entire vector length\n\n    svint32_t prev = svld1(pg, data); // Load first vector of elements\n    svint32_t curr;\n    svbool_t sorted = svptrue_b32(); // Initialize predicate for sorted check\n    svbool_t no_duplicates = svptrue_b32(); // Initialize predicate for duplicate check\n\n    for (size_t i = 1; i < size; i += vl) {\n        vl = svcntw(); // Get the vector length\n        pg = svwhilelt_b32(i, size); // Update predicate for remaining elements\n\n        curr = svld1(pg, data + i); // Load next vector of elements\n\n        // Check if current vector is sorted compared to previous\n        svbool_t sorted_check = svcmplt(pg, prev, curr);\n        sorted = svand_b_z(pg, sorted, sorted_check);\n\n        // Check for duplicates by comparing adjacent elements\n        svbool_t duplicate_check = svcmpeq(pg, prev, curr);\n        no_duplicates = svand_b_z(pg, no_duplicates, svnot_b_z(pg, duplicate_check));\n\n        prev = curr; // Move to next set of elements\n    }\n\n    // Reduce predicates to scalar result\n    bool is_sorted = svptest_first(svptrue_b32(), sorted);\n    bool has_no_duplicates = svptest_first(svptrue_b32(), no_duplicates);\n\n    return is_sorted && has_no_duplicates;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    size_t size = lst.size();\n    if (size <= 1) return true;\n\n    const int *data = lst.data();\n    size_t vl;\n    svbool_t pg = svwhilelt_b32(0, size); // Predicate for the active lanes\n\n    svint32_t prev = svld1(pg, data); // Load first vector of elements\n    svint32_t curr;\n    bool sorted = true;\n    bool duplicates = false;\n\n    for (size_t i = 1; i < size; i += vl) {\n        vl = svcntw(); // Get the vector length\n        pg = svwhilelt_b32(i, size); // Update predicate for remaining elements\n\n        curr = svld1(pg, data + i); // Load next vector of elements\n\n        // Check if current vector is sorted compared to previous\n        svbool_t sorted_check = svcmplt(pg, prev, curr);\n        if (!svptest_all(pg, sorted_check)) {\n            sorted = false;\n            break;\n        }\n\n        // Check for duplicates by comparing adjacent elements\n        svbool_t duplicate_check = svcmpeq(pg, prev, curr);\n        if (svptest_any(pg, duplicate_check)) {\n            duplicates = true;\n        }\n\n        prev = curr; // Move to the next set of elements\n    }\n\n    // If duplicates were found, check for more than one duplicate\n    if (duplicates) {\n        svint32_t count = svdup_s32(0); // Initialize count vector to zero\n        svint32_t prev_elem = svld1(pg, data); // Load first vector again\n\n        for (size_t i = 1; i < size; i += vl) {\n            vl = svcntw();\n            pg = svwhilelt_b32(i, size);\n\n            curr = svld1(pg, data + i);\n            svbool_t duplicate_check = svcmpeq(pg, prev_elem, curr);\n            count = svadd_m(pg, count, svsel(duplicate_check, svdup_s32(1), svdup_s32(0)));\n\n            // If any count exceeds 1, return false\n            if (svmaxv(pg, count) > 1) {\n                return false;\n            }\n\n            prev_elem = curr;\n        }\n    }\n\n    return sorted;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    size_t size = lst.size();\n    if (size <= 1) return true;\n\n    const int *data = lst.data();\n    size_t vl;\n    svbool_t pg = svwhilelt_b32(0, size - 1); // Predicate for the active lanes\n\n    svint32_t vec_prev = svld1(pg, data); // Load first vector\n    svint32_t vec_curr;\n\n    bool sorted = true;\n    bool duplicates = false;\n\n    for (size_t i = 1; i < size; i += vl) {\n        vl = svcntw(); // Get the vector length\n        pg = svwhilelt_b32(i, size); // Update predicate for remaining elements\n\n        vec_curr = svld1(pg, data + i); // Load next vector\n\n        // Check if current vector is greater than or equal to previous vector\n        svbool_t sorted_check = svcmpge(pg, vec_curr, vec_prev);\n        if (!svptest_all(pg, sorted_check)) {\n            sorted = false;\n            break;\n        }\n\n        // Check for duplicates by comparing adjacent elements\n        svbool_t duplicate_check = svcmpeq(pg, vec_curr, vec_prev);\n        if (svptest_any(pg, duplicate_check)) {\n            duplicates = true;\n        }\n\n        vec_prev = vec_curr; // Move to the next set of elements\n    }\n\n    // If duplicates were found, check for more than one duplicate of the same number\n    if (duplicates) {\n        svbool_t pg_dup = svwhilelt_b32(0, size - 2);\n        svint32_t vec_a = svld1(pg_dup, data);\n        svint32_t vec_b = svld1(pg_dup, data + 1);\n        svint32_t vec_c = svld1(pg_dup, data + 2);\n\n        svbool_t triple_duplicate_check = svcmpeq(pg_dup, vec_a, vec_b);\n        triple_duplicate_check = svand_z(pg_dup, triple_duplicate_check, svcmpeq(pg_dup, vec_b, vec_c));\n\n        if (svptest_any(pg_dup, triple_duplicate_check)) {\n            return false;\n        }\n    }\n\n    return sorted;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    size_t size = lst.size();\n    if (size <= 1) return true;\n\n    const int* data = lst.data();\n    size_t vl = svcntw(); // Get the vector length for integers\n    svbool_t pg = svwhilelt_b32(0, size); // Predicate for active lanes\n\n    svint32_t prev = svld1(pg, data); // Load first vector of elements\n    svint32_t curr;\n    bool sorted = true;\n    bool duplicates = false;\n\n    for (size_t i = vl; i < size && sorted; i += vl) {\n        curr = svld1(pg, data + i); // Load next vector of elements\n\n        // Check if current vector is sorted compared to previous\n        svbool_t sorted_check = svcmplt(pg, prev, curr);\n        sorted &= svptest_first(pg, sorted_check);\n\n        // Check for duplicates within the current vector\n        svbool_t duplicate_check = svcmpeq(pg, prev, curr);\n        duplicates |= svptest_any(pg, duplicate_check);\n\n        prev = curr;\n    }\n\n    // Handle the last partial vector if size is not a multiple of vl\n    if (size % vl != 0) {\n        size_t rem = size % vl;\n        pg = svwhilelt_b32(0, rem);\n        curr = svld1(pg, data + size - rem);\n\n        svbool_t sorted_check = svcmplt(pg, prev, curr);\n        sorted &= svptest_first(pg, sorted_check);\n\n        svbool_t duplicate_check = svcmpeq(pg, prev, curr);\n        duplicates |= svptest_any(pg, duplicate_check);\n    }\n\n    // Check for duplicates in the entire list\n    for (size_t i = 0; i < size - 1 && !duplicates; ++i) {\n        if (data[i] == data[i + 1]) {\n            duplicates = true;\n        }\n    }\n\n    return sorted && !duplicates;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    svbool_t pg = svwhilelt_b32(0, arr.size());\n    svint32_t vec = svld1_s32(pg, arr.data());\n\n    // Compute magnitudes\n    svint32_t abs_vals = svabs_s32_x(pg, vec);\n\n    // Compute signs (-1, 0, or 1)\n    svint32_t signs = svneg_s32_x(pg, svcmpge_n_s32(pg, vec, 0));\n    signs = svadd_s32_x(pg, signs, svcmpeq_n_s32(pg, vec, 0));\n\n    // Sum of magnitudes\n    int sum_magnitudes = svaddv_s32(pg, abs_vals);\n\n    // Product of signs\n    int product_signs = 1;\n    svint32_t ones = svdup_n_s32(1);\n    svint32_t product_vec = svdup_n_s32(1);\n    while (svptest_any(svptrue_b32(), pg)) {\n        product_vec = svmul_s32_x(pg, product_vec, signs);\n        pg = svwhilelt_b32(0, svlasta(pg, product_vec));\n    }\n    product_signs = svlasta(svptrue_b32(), product_vec);\n\n    return sum_magnitudes * product_signs;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    size_t size = arr.size();\n    const int* data = arr.data();\n\n    svint32_t v_sum = svdup_n_s32(0);\n    svint32_t v_sign_product = svdup_n_s32(1);\n\n    size_t i = 0;\n    while (i <= size - svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        svint32_t v_data = svld1_s32(pg, data + i);\n\n        svint32_t v_abs = svabs_s32_x(pg, v_data);\n        v_sum = svadd_s32_x(pg, v_sum, v_abs);\n\n        svint32_t v_sign = svdiv_n_s32_x(pg, v_data, svmax_n_s32_x(pg, v_abs, 1));\n        v_sign_product = svmul_s32_x(pg, v_sign_product, v_sign);\n\n        i += svcntw();\n    }\n\n    int sum = svaddv_s32(svptrue_b32(), v_sum);\n    int sign_product = svmla_n_s32_z(svptrue_b32(), svdup_n_s32(1), v_sign_product, 1);\n\n    for (; i < size; ++i) {\n        sum += abs(arr[i]);\n        if (arr[i] > 0) {\n            sign_product *= 1;\n        } else if (arr[i] < 0) {\n            sign_product *= -1;\n        } else {\n            sign_product = 0;\n            break;\n        }\n    }\n\n    return sign_product * sum;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    svbool_t pg = svwhilelt_b32(0, arr.size());\n    svint32_t vec = svld1_s32(pg, arr.data());\n\n    // Compute the magnitude of each element\n    svuint32_t abs_vec = svabs_s32(vec);\n\n    // Compute the sign of each element (-1, 0, or 1)\n    svint32_t sign_vec = svdiv_s32_z(pg, vec, svmax_s32_z(pg, abs_vec, 1));\n\n    // Sum of magnitudes\n    uint32_t sum_magnitude = 0;\n    svuint32_t sum_vec = svaddv_u32(pg, abs_vec);\n    sum_magnitude += svlasta_u32(pg, sum_vec);\n\n    // Product of signs\n    int product_sign = 1;\n    svint32_t product_sign_vec = svdup_s32(1);\n    product_sign_vec = svmul_s32_x(pg, product_sign_vec, sign_vec);\n    product_sign *= svlasta_s32(pg, product_sign_vec);\n\n    return sum_magnitude * product_sign;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    svbool_t pg = svwhilelt_b32(0, arr.size());\n    svint32_t vec = svld1_s32(pg, arr.data());\n\n    // Compute signs: 0 for 0, 1 for positive, -1 for negative\n    svint32_t signs = svdup_s32(0);\n    signs = svsel(sveq_n_s32(vec, 0), svdup_s32(0), signs);\n    signs = svsel(svcgt_n_s32(vec, 0), svdup_s32(1), signs);\n    signs = svsel(svclt_n_s32(vec, 0), svdup_s32(-1), signs);\n\n    // Compute product of signs\n    int prod_sign = 1;\n    svint32_t prod_vec = svdup_s32(1);\n    prod_vec = svmul_s32_x(pg, prod_vec, signs);\n    prod_sign = svaddv_s32(pg, prod_vec);\n\n    // Compute sum of magnitudes\n    svint32_t abs_vals = svabs_s32_x(pg, vec);\n    int sum_magnitudes = svaddv_s32(pg, abs_vals);\n\n    return prod_sign * sum_magnitudes;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    svbool_t pg = svwhilelt_b32(0, arr.size());\n    svint32_t vec = svld1(pg, arr.data());\n\n    // Compute the magnitude of each element\n    svuint32_t abs_vec = svabs_x(pg, svreinterpret_u32(vec));\n\n    // Compute the sign of each element (-1, 0, or 1)\n    svint32_t sign_vec = svneg_x(pg, svsub_x(pg, svdup_n_s32(0), svclt_n_s32(pg, vec, 0)));\n    sign_vec = svadd_x(pg, sign_vec, svsub_x(pg, svdup_n_s32(0), svcmpgt_n_s32(pg, vec, 0)));\n\n    // Sum of magnitudes\n    uint32_t sum_magnitudes = 0;\n    svuint32_t sum_vec = svdup_n_u32(0);\n    sum_vec = svadd_u32_x(pg, sum_vec, abs_vec);\n    sum_magnitudes = svaddv_u32(pg, sum_vec);\n\n    // Product of signs\n    int32_t product_signs = 1;\n    svint32_t prod_vec = svdup_n_s32(1);\n    prod_vec = svmul_x(pg, prod_vec, sign_vec);\n    product_signs = svmla_n_s32(product_signs, prod_vec, 1);\n\n    // If any zero exists in the array, product_signs should be zero\n    svbool_t has_zero = sveor_z(pg, svcmpeq_n_s32(pg, vec, 0));\n    if (svptest_any(svptrue_b32(), has_zero)) {\n        product_signs = 0;\n    }\n\n    return sum_magnitudes * product_signs;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>> &grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k, 0);\n    std::vector<std::vector<int>> dp(N, std::vector<int>(N, 0));\n    std::vector<std::vector<int>> next_dp(N, std::vector<int>(N, 0));\n\n    // Initialize dp with the grid values as starting points\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            dp[i][j] = grid[i][j];\n        }\n    }\n\n    for (int step = 1; step < k; ++step) {\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N; ++j) {\n                int min_val = INT32_MAX;\n                // Check all 4 possible directions\n                if (i > 0) min_val = std::min(min_val, dp[i - 1][j]);\n                if (i < N - 1) min_val = std::min(min_val, dp[i + 1][j]);\n                if (j > 0) min_val = std::min(min_val, dp[i][j - 1]);\n                if (j < N - 1) min_val = std::min(min_val, dp[i][j + 1]);\n\n                next_dp[i][j] = min_val;\n            }\n        }\n\n        // Use SVE to parallelize the update of dp\n        for (int i = 0; i < N; ++i) {\n            svbool_t pg = svwhilelt_b32(0, N); // Predicate for vectorization\n            svint32_t vec_grid = svld1(pg, &grid[i][0]); // Load grid row into vector\n            svint32_t vec_next_dp = svld1(pg, &next_dp[i][0]); // Load next_dp row into vector\n\n            // Update dp with grid value + next_dp value\n            svint32_t vec_dp = svadd_z(pg, vec_grid, vec_next_dp);\n\n            // Store the updated dp values back to memory\n            svst1(pg, &dp[i][0], vec_dp);\n        }\n\n        // Swap dp and next_dp for the next iteration\n        std::swap(dp, next_dp);\n    }\n\n    // Find the minimum path\n    int min_val = INT32_MAX;\n    int start_x = 0, start_y = 0;\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if (dp[i][j] < min_val) {\n                min_val = dp[i][j];\n                start_x = i;\n                start_y = j;\n            }\n        }\n    }\n\n    // Reconstruct the path\n    int x = start_x, y = start_y;\n    result[0] = grid[x][y];\n\n    for (int step = 1; step < k; ++step) {\n        int min_val = INT32_MAX;\n        int next_x = x, next_y = y;\n\n        if (x > 0 && dp[x - 1][y] < min_val) {\n            min_val = dp[x - 1][y];\n            next_x = x - 1;\n            next_y = y;\n        }\n        if (x < N - 1 && dp[x + 1][y] < min_val) {\n            min_val = dp[x + 1][y];\n            next_x = x + 1;\n            next_y = y;\n        }\n        if (y > 0 && dp[x][y - 1] < min_val) {\n            min_val = dp[x][y - 1];\n            next_x = x;\n            next_y = y - 1;\n        }\n        if (y < N - 1 && dp[x][y + 1] < min_val) {\n            min_val = dp[x][y + 1];\n            next_x = x;\n            next_y = y + 1;\n        }\n\n        x = next_x;\n        y = next_y;\n        result[step] = grid[x][y];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>> &grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k, 0);\n    std::vector<std::vector<int>> dp(N, std::vector<int>(N, 0));\n    std::vector<std::vector<int>> prev_dp(N, std::vector<int>(N, 0));\n\n    // Initialize the first step with grid values\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            dp[i][j] = grid[i][j];\n        }\n    }\n\n    for (int step = 1; step < k; ++step) {\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N; ++j) {\n                int min_val = prev_dp[i][j];\n                if (i > 0) min_val = std::min(min_val, prev_dp[i - 1][j]);\n                if (i < N - 1) min_val = std::min(min_val, prev_dp[i + 1][j]);\n                if (j > 0) min_val = std::min(min_val, prev_dp[i][j - 1]);\n                if (j < N - 1) min_val = std::min(min_val, prev_dp[i][j + 1]);\n                dp[i][j] = grid[i][j] + min_val;\n            }\n        }\n        prev_dp = dp;\n    }\n\n    // Find the minimum path\n    int min_val = INT32_MAX;\n    int start_x = 0, start_y = 0;\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if (dp[i][j] < min_val) {\n                min_val = dp[i][j];\n                start_x = i;\n                start_y = j;\n            }\n        }\n    }\n\n    // Reconstruct the path\n    int x = start_x, y = start_y;\n    for (int step = k - 1; step >= 0; --step) {\n        result[step] = grid[x][y];\n        int min_val = INT32_MAX;\n        int next_x = x, next_y = y;\n        if (x > 0 && prev_dp[x - 1][y] < min_val) {\n            min_val = prev_dp[x - 1][y];\n            next_x = x - 1;\n            next_y = y;\n        }\n        if (x < N - 1 && prev_dp[x + 1][y] < min_val) {\n            min_val = prev_dp[x + 1][y];\n            next_x = x + 1;\n            next_y = y;\n        }\n        if (y > 0 && prev_dp[x][y - 1] < min_val) {\n            min_val = prev_dp[x][y - 1];\n            next_x = x;\n            next_y = y - 1;\n        }\n        if (y < N - 1 && prev_dp[x][y + 1] < min_val) {\n            min_val = prev_dp[x][y + 1];\n            next_x = x;\n            next_y = y + 1;\n        }\n        x = next_x;\n        y = next_y;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>> &grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k, 0);\n    std::vector<std::vector<int>> dp(N, std::vector<int>(N, 0));\n    std::vector<std::vector<int>> next_dp(N, std::vector<int>(N, 0));\n\n    // Initialize dp with the grid values for the first step\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            dp[i][j] = grid[i][j];\n        }\n    }\n\n    for (int step = 1; step < k; ++step) {\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N; ++j) {\n                int min_val = INT32_MAX;\n                // Check all 4 possible directions\n                if (i > 0) min_val = std::min(min_val, dp[i - 1][j]);\n                if (i < N - 1) min_val = std::min(min_val, dp[i + 1][j]);\n                if (j > 0) min_val = std::min(min_val, dp[i][j - 1]);\n                if (j < N - 1) min_val = std::min(min_val, dp[i][j + 1]);\n                next_dp[i][j] = min_val + grid[i][j];\n            }\n        }\n        dp.swap(next_dp);\n    }\n\n    // Find the minimum path value and construct the result\n    int min_path_value = INT32_MAX;\n    int start_x = 0, start_y = 0;\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if (dp[i][j] < min_path_value) {\n                min_path_value = dp[i][j];\n                start_x = i;\n                start_y = j;\n            }\n        }\n    }\n\n    // Trace back the path\n    int x = start_x, y = start_y;\n    for (int step = k - 1; step >= 0; --step) {\n        result[step] = grid[x][y];\n        int min_val = INT32_MAX;\n        int next_x = x, next_y = y;\n        if (x > 0 && dp[x - 1][y] < min_val) { min_val = dp[x - 1][y]; next_x = x - 1; next_y = y; }\n        if (x < N - 1 && dp[x + 1][y] < min_val) { min_val = dp[x + 1][y]; next_x = x + 1; next_y = y; }\n        if (y > 0 && dp[x][y - 1] < min_val) { min_val = dp[x][y - 1]; next_x = x; next_y = y - 1; }\n        if (y < N - 1 && dp[x][y + 1] < min_val) { min_val = dp[x][y + 1]; next_x = x; next_y = y + 1; }\n        x = next_x;\n        y = next_y;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>> &grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k, 0);\n    std::vector<std::vector<int>> dp(N, std::vector<int>(N, 0));\n    std::vector<std::vector<int>> next_dp(N, std::vector<int>(N, 0));\n\n    // Initialize the first step with grid values\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            dp[i][j] = grid[i][j];\n        }\n    }\n\n    for (int step = 1; step < k; ++step) {\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N; ++j) {\n                int min_val = dp[i][j];\n                if (i > 0) min_val = std::min(min_val, dp[i - 1][j]);\n                if (i < N - 1) min_val = std::min(min_val, dp[i + 1][j]);\n                if (j > 0) min_val = std::min(min_val, dp[i][j - 1]);\n                if (j < N - 1) min_val = std::min(min_val, dp[i][j + 1]);\n                next_dp[i][j] = min_val + grid[i][j];\n            }\n        }\n        dp.swap(next_dp);\n    }\n\n    // Find the minimum path\n    int min_val = dp[0][0];\n    int min_i = 0, min_j = 0;\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if (dp[i][j] < min_val) {\n                min_val = dp[i][j];\n                min_i = i;\n                min_j = j;\n            }\n        }\n    }\n\n    // Backtrack to find the path\n    int current_i = min_i, current_j = min_j;\n    for (int step = k - 1; step >= 0; --step) {\n        result[step] = grid[current_i][current_j];\n        int next_min = grid[current_i][current_j];\n        int next_i = current_i, next_j = current_j;\n\n        if (current_i > 0 && dp[current_i - 1][current_j] + grid[current_i][current_j] == next_min) {\n            next_i = current_i - 1;\n        } else if (current_i < N - 1 && dp[current_i + 1][current_j] + grid[current_i][current_j] == next_min) {\n            next_i = current_i + 1;\n        } else if (current_j > 0 && dp[current_i][current_j - 1] + grid[current_i][current_j] == next_min) {\n            next_j = current_j - 1;\n        } else if (current_j < N - 1 && dp[current_i][current_j + 1] + grid[current_i][current_j] == next_min) {\n            next_j = current_j + 1;\n        }\n\n        current_i = next_i;\n        current_j = next_j;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>> &grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k, 0);\n    std::vector<std::vector<int>> dp(N, std::vector<int>(N, 0));\n    std::vector<std::vector<int>> next_dp(N, std::vector<int>(N, 0));\n\n    // Initialize dp with the grid values\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            dp[i][j] = grid[i][j];\n        }\n    }\n\n    for (int step = 1; step < k; ++step) {\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N; ++j) {\n                int min_val = dp[i][j];\n                if (i > 0) min_val = std::min(min_val, dp[i - 1][j]);\n                if (i < N - 1) min_val = std::min(min_val, dp[i + 1][j]);\n                if (j > 0) min_val = std::min(min_val, dp[i][j - 1]);\n                if (j < N - 1) min_val = std::min(min_val, dp[i][j + 1]);\n                next_dp[i][j] = min_val;\n            }\n        }\n        dp.swap(next_dp);\n    }\n\n    // Find the minimum path using SVE intrinsics\n    int min_value = INT32_MAX;\n    int min_i = 0, min_j = 0;\n\n    svbool_t pg = svwhilelt_b32(0, N * N);\n    svint32_t sve_min_value = svdup_n_s32(INT32_MAX);\n    svint32_t sve_min_i = svdup_n_s32(0);\n    svint32_t sve_min_j = svdup_n_s32(0);\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; j += svcntw()) {\n            svint32_t sve_dp = svld1_s32(pg, &dp[i][j]);\n            svint32_t sve_indices = svindex_s32(i * N + j, 1);\n            svbool_t mask = svcmplt_s32(pg, sve_dp, sve_min_value);\n\n            sve_min_value = svsel_s32(mask, sve_dp, sve_min_value);\n            sve_min_i = svsel_s32(mask, svdiv_n_s32_z(pg, sve_indices, N), sve_min_i);\n            sve_min_j = svsel_s32(mask, svrem_n_s32_z(pg, sve_indices, N), sve_min_j);\n        }\n    }\n\n    min_value = svminv_s32(pg, sve_min_value);\n    min_i = svminv_s32(pg, sve_min_i);\n    min_j = svminv_s32(pg, sve_min_j);\n\n    // Reconstruct the path\n    int x = min_i, y = min_j;\n    for (int step = 0; step < k; ++step) {\n        result[step] = grid[x][y];\n        int next_x = x, next_y = y;\n        int min_val = dp[x][y];\n\n        if (x > 0 && dp[x - 1][y] < min_val) {\n            min_val = dp[x - 1][y];\n            next_x = x - 1;\n            next_y = y;\n        }\n        if (x < N - 1 && dp[x + 1][y] < min_val) {\n            min_val = dp[x + 1][y];\n            next_x = x + 1;\n            next_y = y;\n        }\n        if (y > 0 && dp[x][y - 1] < min_val) {\n            min_val = dp[x][y - 1];\n            next_x = x;\n            next_y = y - 1;\n        }\n        if (y < N - 1 && dp[x][y + 1] < min_val) {\n            min_val = dp[x][y + 1];\n            next_x = x;\n            next_y = y + 1;\n        }\n\n        x = next_x;\n        y = next_y;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nuint64_t digits_simd(uint64_t n) {\n    uint64_t product = 1;\n    bool all_even = true;\n\n    // Load the number into a vector register as bytes\n    uint8_t digits[8];\n    for (int i = 0; i < 8; ++i) {\n        digits[i] = (n % 10) + '0';\n        n /= 10;\n    }\n\n    svuint8_t vec_digits = svld1sb_u8(digits);\n    svbool_t pred_odd = svcmpeq_n_u8(svand(vec_digits, 1), 1);\n\n    // Extract odd digits and compute their product\n    svuint8_t odd_digits = svcompact_u8(pred_odd, vec_digits);\n    uint64_t num_odds = svcntp_b8(pred_odd);\n\n    if (num_odds > 0) {\n        all_even = false;\n        for (uint64_t i = 0; i < num_odds; ++i) {\n            uint8_t digit = svlasta_u8(odd_digits) - '0';\n            product *= digit;\n            odd_digits = svextb_u8(odd_digits, 1);\n        }\n    }\n\n    return all_even ? 0 : product;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nuint64_t digits_simd(uint64_t n) {\n    uint64_t result = 1;\n    bool all_even = true;\n\n    // Convert the number to a vector of digits\n    svuint8_t digit_vec = svld1sb_u8(&n);\n    svbool_t pred = svwhilelt_b8(0, 8); // Predicate for active lanes\n\n    // Mask to extract individual digits (0-9)\n    svuint8_t zero_vec = svdup_u8(0);\n    svuint8_t nine_vec = svdup_u8(9);\n    svbool_t digit_mask = svcmpge_u8(pred, digit_vec, zero_vec);\n    digit_mask = svcmpeq_u8(digit_mask, digit_vec, svmin_u8(digit_mask, digit_vec, nine_vec));\n\n    // Filter only odd digits\n    svuint8_t one_vec = svdup_u8(1);\n    svbool_t odd_mask = svcnt_u8(digit_vec, one_vec);\n\n    // Combine masks: valid digit and odd\n    svbool_t combined_mask = svand_b_z(pred, digit_mask, odd_mask);\n\n    // Extract odd digits and compute product\n    svuint8_t odd_digits = svcompact_u8(combined_mask, digit_vec);\n    uint8_t temp[8];\n    svst1_u8(temp, odd_digits);\n\n    for (int i = 0; i < svcntp_b8(combined_mask); ++i) {\n        result *= temp[i];\n        all_even = false;\n    }\n\n    return all_even ? 0 : result;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nuint64_t digits_simd(uint64_t n) {\n    uint64_t result = 1;\n    bool all_even = true;\n\n    // Load the number into a vector\n    svuint8_t vec_n = svdup_u8_x(svptrue_b8(), n);\n    svbool_t pred = svptrue_b8();\n\n    // Vector of digits 0-9\n    svuint8_t digits = svindex_u8(0, 1);\n\n    // Extract digits and process them in parallel\n    while (n > 0) {\n        uint8_t digit = n % 10;\n        n /= 10;\n\n        // Broadcast the current digit to all lanes\n        svuint8_t vec_digit = svdup_u8_x(pred, digit);\n\n        // Check if the digit is odd\n        svbool_t odd_pred = svcmpne_n_u8(pred, svand_u8_z(pred, vec_digit, 1), 0);\n\n        // Update result with the product of odd digits\n        svuint8_t odd_digits = svand_u8_m(vec_digit, odd_pred, vec_digit);\n        result *= svaddv_u8(odd_pred, odd_digits);\n\n        // Update all_even flag\n        all_even = all_even && !svptest_any(svptrue_b8(), odd_pred);\n    }\n\n    return all_even ? 0 : result;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nuint64_t digits_simd(uint64_t n) {\n    uint64_t product = 1;\n    bool all_even = true;\n\n    // Convert the number to a vector of digits\n    svuint8_t vec_digits = svld1sb_u8(svptrue_b8(), (const int8_t*)&n);\n    svbool_t pred = svwhilelt_b8(0, 8); // Predicate for active lanes\n\n    // Mask to extract individual digits\n    svuint8_t ten = svdup_u8(10);\n    svuint8_t zero = svdup_u8(0);\n\n    // Temporary variables\n    svuint8_t digit;\n    svbool_t odd_mask;\n\n    while (svptest_any(svptrue_b8(), pred)) {\n        digit = svadd_u8(vec_digits, svneg_u8(zero)); // Extract digit\n        odd_mask = svcmpne_n_u8(pred, svand_u8(digit, svdup_u8(1)), 0); // Check if odd\n\n        // Update product and all_even flag\n        svbool_t active_odd = svand_b_z(pred, odd_mask);\n        if (svptest_any(svptrue_b8(), active_odd)) {\n            product *= svmls_lane_u8(product, digit, 0);\n            all_even = false;\n        }\n\n        // Prepare for next digit\n        vec_digits = svdiv_u8(vec_digits, ten);\n        pred = svwhilelt_b8(0, svsub_n_u8(svlen_u8(vec_digits), 1));\n    }\n\n    return all_even ? 0 : product;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nuint64_t digits_simd(uint64_t n) {\n    uint64_t product = 1;\n    bool all_even = true;\n\n    // Load the number into a vector\n    svuint64_t vec_n = svdup_u64(n);\n    svbool_t pred = svwhilelt_b64(0, n);\n\n    // Vector to store digits\n    svuint64_t digits = svdup_u64(0);\n\n    // Extract digits using modulo and division\n    while (svptest_any(svptrue_b64(), pred)) {\n        svuint64_t current_digit = svmod_u64_z(pred, vec_n, svdup_u64(10));\n        digits = svsel_u64(pred, current_digit, digits);\n\n        // Check for odd digits and update product\n        svbool_t odd_pred = svcmpne_n_u64(pred, svand_u64_z(pred, digits, svdup_u64(1)), 0);\n        if (svptest_any(svptrue_b64(), odd_pred)) {\n            product *= svprod_lane_u64(svptrue_b64(), svsel_u64(odd_pred, digits, svdup_u64(1)));\n            all_even = false;\n        }\n\n        // Update the number and predicate\n        vec_n = svdiv_u64_z(pred, vec_n, svdup_u64(10));\n        pred = svwhilelt_b64(0, vec_n);\n    }\n\n    return all_even ? 0 : product;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\nuint64_t sum_squares_simd(const std::vector<float> &lst) {\n    size_t i = 0;\n    uint64_t total_sum = 0;\n    size_t size = lst.size();\n\n    svbool_t pg = svwhilelt_b32(i, size);\n\n    do {\n        // Load a vector of floats from the input list\n        svfloat32_t vec = svld1_f32(pg, &lst[i]);\n\n        // Compute the ceiling of each element\n        svfloat32_t ceil_vec = svrintx_f32(pg, vec);\n\n        // Convert to integers (ceiling operation)\n        svint32_t int_vec = svcvt_s32_f32(pg, ceil_vec);\n\n        // Square each integer value\n        svint32_t squared_vec = svmul_s32_x(pg, int_vec, int_vec);\n\n        // Reduce the squared values into a scalar sum\n        total_sum += svaddv_s32(pg, squared_vec);\n\n        // Update the index and predicate\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    } while (svptest_any(svptrue_b32(), pg));\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\nuint64_t sum_squares_simd(const std::vector<float> &lst) {\n    size_t i = 0;\n    uint64_t total_sum = 0;\n    size_t len = lst.size();\n\n    while (i <= len - svcntw()) {\n        // Load a vector of floats from the input list\n        svfloat32_t vec = svld1_f32(svptrue_b32(), &lst[i]);\n\n        // Compute the ceiling of each element\n        svfloat32_t ceil_vec = svrintx_f32(vec);\n\n        // Square each element\n        svfloat32_t squared_vec = svmul_f32(ceil_vec, ceil_vec);\n\n        // Convert squared values to 64-bit integers\n        svuint64_t squared_int_vec = svcvt_u64_f32(squared_vec);\n\n        // Reduce the vector to a scalar sum\n        total_sum += svaddv_u64(svptrue_b64(), squared_int_vec);\n\n        i += svcntw();\n    }\n\n    // Handle remaining elements\n    for (; i < len; ++i) {\n        float val = std::ceil(lst[i]);\n        total_sum += static_cast<uint64_t>(val * val);\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    size_t i = 0;\n    uint64_t total_sum = 0;\n    size_t vector_length = svcntw(); // Get the number of elements processed per SVE vector\n\n    svbool_t pg = svwhilelt_b32(i, lst.size()); // Predicate for active lanes\n\n    svfloat32_t vec_sum = svdup_f32(0.0f); // Initialize vector accumulator\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vec = svld1_f32(pg, &lst[i]); // Load a vector of floats\n        svfloat32_t vec_ceil = svrintx_f32(vec); // Apply ceiling operation\n        svfloat32_t vec_squared = svmul_f32(vec_ceil, vec_ceil); // Square each element\n        vec_sum = svadd_f32_m(pg, vec_sum, vec_squared); // Accumulate squared values\n\n        i += vector_length;\n        pg = svwhilelt_b32(i, lst.size()); // Update predicate\n    }\n\n    // Horizontal reduction to sum up the vector elements\n    float reduced_sum = 0.0f;\n    reduced_sum += svaddv_f32(svptrue_b32(), vec_sum);\n\n    // Add any remaining elements that didn't fit into a full vector\n    for (; i < lst.size(); ++i) {\n        float val = std::ceil(lst[i]);\n        total_sum += val * val;\n    }\n\n    total_sum += static_cast<uint64_t>(reduced_sum);\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\nuint64_t sum_squares_simd(const std::vector<float> &lst) {\n    size_t i = 0;\n    uint64_t total_sum = 0;\n    size_t size = lst.size();\n\n    while (i <= size - svcntw()) {\n        // Load a vector of floats from the input list\n        svfloat32_t vec = svld1_f32(svptrue_b32(), &lst[i]);\n\n        // Compute the ceiling of each element\n        svfloat32_t ceil_vec = svrintx_f32(vec);\n\n        // Square each element\n        svfloat32_t squared_vec = svmul_f32(ceil_vec, ceil_vec);\n\n        // Convert squared values to 64-bit integers\n        svuint64_t squared_int_vec = svcvt_u64_f32(squared_vec);\n\n        // Reduce the vector to a scalar sum\n        total_sum += svaddv_u64(svptrue_b64(), squared_int_vec);\n\n        i += svcntw();\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        float val = std::ceil(lst[i]);\n        total_sum += static_cast<uint64_t>(val * val);\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdint>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t total_sum = 0;\n    size_t i = 0;\n    size_t length = lst.size();\n\n    while (i <= length - svcntw()) {\n        // Load a vector of floats from the input list\n        svfloat32_t vec = svld1_f32(svptrue_b32(), &lst[i]);\n\n        // Compute the ceiling of each element\n        svfloat32_t ceil_vec = svrintx_f32(vec);\n\n        // Convert the ceiling values to integers\n        svint32_t int_vec = svcvt_s32_f32_x(svptrue_b32(), ceil_vec);\n\n        // Square the integer values\n        svint32_t squared_vec = svmul_s32_x(svptrue_b32(), int_vec, int_vec);\n\n        // Reduce the squared values into a scalar sum\n        total_sum += svaddv_s32(svptrue_b32(), squared_vec);\n\n        // Move to the next block of elements\n        i += svcntw();\n    }\n\n    // Handle any remaining elements\n    for (; i < length; ++i) {\n        float val = lst[i];\n        int ceil_val = static_cast<int>(ceilf(val));\n        total_sum += static_cast<uint64_t>(ceil_val * ceil_val);\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n <= 1) return -1;\n\n    svbool_t pg = svwhilelt_b32(0, n - 1);\n    svint32_t vec_prev = svld1(pg, arr.data());\n    svint32_t vec_curr = svld1(pg, arr.data() + 1);\n\n    svbool_t mask = svcmpge(pg, vec_curr, vec_prev);\n    int index = -1;\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svbool_t found = svcmpeq(pg, mask, svpfalse_b());\n        if (svptest_any(svptrue_b32(), found)) {\n            index = svcntp_b32(svptrue_b32(), found) - 1;\n            break;\n        }\n        pg = svwhilelt_b32(0, n - 1);\n    }\n\n    return index;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n <= 1) return -1;\n\n    svbool_t pg = svwhilelt_b32(0, n - 1); // Predicate for valid elements\n    svint32_t vec_prev = svld1(pg, arr.data()); // Load current elements\n    svint32_t vec_next = svld1(pg, arr.data() + 1); // Load next elements\n\n    svbool_t mask = svcmpge(pg, vec_next, vec_prev); // Compare vec_next >= vec_prev\n    svint32_t indices = svindex_s32(1, 1); // Generate indices starting from 1\n    svint32_t valid_indices = svcompact(mask, indices); // Compact indices based on mask\n\n    uint64_t count = svcntp_b32(pg, mask); // Count valid elements\n    if (count == 0) return -1; // No valid index found\n\n    int max_index = svlastb_s32(valid_indices); // Get the last valid index\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int result = -1;\n    size_t i = 1;\n\n    while (i < arr.size()) {\n        svbool_t pg = svwhilelt_b32(i, arr.size());\n        svint32_t vec_current = svld1(pg, &arr[i]);\n        svint32_t vec_prev = svld1(pg, &arr[i - 1]);\n\n        svbool_t mask = svcmpge(pg, vec_current, vec_prev);\n        if (!svptest_any(svptrue_b32(), mask)) {\n            // Find the first index where the condition fails\n            uint64_t first_fail_idx = svbrka_z(pg, mask);\n            if (first_fail_idx != 0) {\n                result = i + svcntp_b32(svptrue_b32(), first_fail_idx) - 1;\n                break;\n            }\n        }\n        i += svcntw();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int result = -1;\n    size_t i = 1;\n\n    while (i < arr.size()) {\n        svbool_t pg = svwhilelt_b32(i, arr.size());\n        svint32_t vec_current = svld1(pg, &arr[i]);\n        svint32_t vec_prev = svld1(pg, &arr[i - 1]);\n\n        svbool_t mask = svcmpge(pg, vec_current, vec_prev);\n\n        if (!svptest_any(svptrue_b32(), mask)) {\n            result = i;\n            break;\n        }\n\n        i += svcntw();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n <= 1) return -1;\n\n    svbool_t pg = svwhilelt_b32(0, n - 1); // Predicate for valid elements\n    svint32_t vec_prev = svld1(pg, arr.data()); // Load current elements\n    svint32_t vec_curr = svld1(pg, arr.data() + 1); // Load next elements\n\n    svbool_t mask = svcmpge(pg, vec_curr, vec_prev); // Compare curr >= prev\n    svint32_t indices = svindex_s32(1, 1); // Generate indices starting from 1\n\n    // Compress indices where condition is true\n    svint32_t result_indices = svcompact(mask, indices);\n\n    // Find the maximum index\n    int max_index = -1;\n    if (!svptest_first(svptrue_b32(), mask)) {\n        return max_index; // No valid index found\n    }\n\n    max_index = svmaxv(pg, result_indices); // Extract maximum value\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    size_t i = 0;\n    size_t vector_length = svcntw(); // Get the number of elements processed per SVE vector\n\n    if (lst.empty()) {\n        return {largest_negative, smallest_positive};\n    }\n\n    svbool_t all_active = svptrue_b32(); // All lanes active\n    svint32_t vec_largest_negative = svdup_n_s32(0); // Initialize to 0\n    svint32_t vec_smallest_positive = svdup_n_s32(0); // Initialize to 0\n\n    for (; i + vector_length <= lst.size(); i += vector_length) {\n        svint32_t vec = svld1_s32(all_active, &lst[i]); // Load vector from memory\n\n        // Mask for negative numbers\n        svbool_t negative_mask = svcmplt_n_s32(all_active, vec, 0);\n        // Mask for positive numbers\n        svbool_t positive_mask = svcgt_n_s32(all_active, vec, 0);\n\n        // Update largest negative\n        svint32_t current_negatives = svmax_s32_z(negative_mask, vec_largest_negative, vec);\n        vec_largest_negative = svsel_s32(negative_mask, current_negatives, vec_largest_negative);\n\n        // Update smallest positive\n        svint32_t current_positives = svmin_s32_z(positive_mask, vec_smallest_positive, vec);\n        vec_smallest_positive = svsel_s32(positive_mask, current_positives, vec_smallest_positive);\n    }\n\n    // Reduce the vector results to scalar values\n    largest_negative = svmaxv_s32(all_active, vec_largest_negative);\n    smallest_positive = svminv_s32(all_active, vec_smallest_positive);\n\n    // Handle remaining elements\n    for (; i < lst.size(); ++i) {\n        if (lst[i] < 0 && lst[i] > largest_negative) {\n            largest_negative = lst[i];\n        }\n        if (lst[i] > 0 && (smallest_positive == 0 || lst[i] < smallest_positive)) {\n            smallest_positive = lst[i];\n        }\n    }\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    size_t i = 0;\n    size_t vector_length = svcntw(); // Get the number of elements in an SVE vector\n\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    svbool_t all_active = svptrue_b32(); // All lanes active\n\n    while (i + vector_length <= lst.size()) {\n        svint32_t vec = svld1_s32(all_active, &lst[i]); // Load vector from memory\n\n        // Mask for negative numbers\n        svbool_t negative_mask = svcmplt_n_s32(all_active, vec, 0);\n        // Mask for positive numbers\n        svbool_t positive_mask = svcmpgt_n_s32(all_active, vec, 0);\n\n        // Extract negatives and positives using masks\n        svint32_t negatives = svand_s32_z(negative_mask, vec);\n        svint32_t positives = svand_s32_z(positive_mask, vec);\n\n        // Find the largest negative\n        svint32_t max_negatives = svmaxv_s32(negatives);\n        int current_max_negative = svlasta_s32(negative_mask, max_negatives);\n        if (current_max_negative < largest_negative || largest_negative == 0) {\n            largest_negative = current_max_negative;\n        }\n\n        // Find the smallest positive\n        svint32_t min_positives = svminv_s32(positives);\n        int current_min_positive = svlastb_s32(positive_mask, min_positives);\n        if ((current_min_positive > 0 && current_min_positive < smallest_positive) || smallest_positive == 0) {\n            smallest_positive = current_min_positive;\n        }\n\n        i += vector_length;\n    }\n\n    // Handle any remaining elements\n    for (; i < lst.size(); ++i) {\n        if (lst[i] < 0 && lst[i] > largest_negative) {\n            largest_negative = lst[i];\n        }\n        if (lst[i] > 0 && (lst[i] < smallest_positive || smallest_positive == 0)) {\n            smallest_positive = lst[i];\n        }\n    }\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    size_t i = 0;\n    size_t vector_length = svcntw(); // Get the number of elements in an SVE vector\n\n    if (lst.empty()) {\n        return {largest_negative, smallest_positive};\n    }\n\n    svint32_t vec_largest_negative = svdup_n_s32(0);\n    svint32_t vec_smallest_positive = svdup_n_s32(0);\n\n    for (; i + vector_length <= lst.size(); i += vector_length) {\n        svint32_t vec = svld1_s32(svptrue_b32(), &lst[i]);\n\n        // Mask for negative numbers\n        svbool_t negative_mask = svcmplt_n_s32(svptrue_b32(), vec, 0);\n        // Mask for positive numbers\n        svbool_t positive_mask = svcgt_n_s32(svptrue_b32(), vec, 0);\n\n        // Update largest negative\n        svint32_t current_negatives = svmax_s32_z(negative_mask, vec, vec_largest_negative);\n        vec_largest_negative = svmax_s32_m(negative_mask, vec_largest_negative, current_negatives);\n\n        // Update smallest positive\n        svint32_t current_positives = svmin_s32_z(positive_mask, vec, vec_smallest_positive);\n        vec_smallest_positive = svmin_s32_m(positive_mask, vec_smallest_positive, current_positives);\n    }\n\n    // Reduce to scalar values\n    largest_negative = svmaxv_s32(svptrue_b32(), vec_largest_negative);\n    smallest_positive = svminv_s32(svptrue_b32(), vec_smallest_positive);\n\n    // Handle remaining elements\n    for (; i < lst.size(); ++i) {\n        if (lst[i] < 0 && lst[i] > largest_negative) {\n            largest_negative = lst[i];\n        }\n        if (lst[i] > 0 && (smallest_positive == 0 || lst[i] < smallest_positive)) {\n            smallest_positive = lst[i];\n        }\n    }\n\n    // If no negatives or positives found, set to 0\n    if (largest_negative == 0) largest_negative = 0;\n    if (smallest_positive == 0) smallest_positive = 0;\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    size_t i = 0;\n    size_t vector_length = svcntw(); // Get the number of elements processed per SVE vector\n\n    svbool_t all_active = svptrue_b32(); // Predicate for full vector length\n\n    while (i + vector_length <= lst.size()) {\n        svint32_t vec = svld1_s32(all_active, &lst[i]); // Load a vector of integers\n\n        // Create masks for negative and positive values\n        svbool_t negative_mask = svcmplt_n_s32(all_active, vec, 0);\n        svbool_t positive_mask = svcgt_n_s32(all_active, vec, 0);\n\n        // Extract negative values and find the largest among them\n        svint32_t negatives = svand_s32_z(negative_mask, vec);\n        if (!svptest_first(all_active, negative_mask)) {\n            largest_negative = std::max(largest_negative, svmaxv_s32(negative_mask, negatives));\n        }\n\n        // Extract positive values and find the smallest among them\n        svint32_t positives = svand_s32_z(positive_mask, vec);\n        if (!svptest_first(all_active, positive_mask)) {\n            smallest_positive = std::min(smallest_positive, svminv_s32(positive_mask, positives));\n        }\n\n        i += vector_length;\n    }\n\n    // Process any remaining elements that didn't fit into a full vector\n    for (; i < lst.size(); ++i) {\n        if (lst[i] < 0) {\n            largest_negative = std::max(largest_negative, lst[i]);\n        } else if (lst[i] > 0) {\n            smallest_positive = smallest_positive == 0 ? lst[i] : std::min(smallest_positive, lst[i]);\n        }\n    }\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    size_t i = 0;\n    size_t vector_length = svcntw(); // Get the number of elements processed per SVE vector\n\n    svbool_t all_active = svptrue_b32(); // Predicate for all active lanes\n\n    while (i + vector_length <= lst.size()) {\n        svint32_t vec = svld1_s32(all_active, &lst[i]); // Load a vector of integers\n\n        // Mask for negative numbers\n        svbool_t neg_mask = svcmplt_n_s32(all_active, vec, 0);\n        // Mask for positive numbers\n        svbool_t pos_mask = svcmpgt_n_s32(all_active, vec, 0);\n\n        // Extract negative numbers and find the largest among them\n        svint32_t negatives = svand_s32_z(neg_mask, vec);\n        if (!svptest_first(all_active, neg_mask)) {\n            int max_neg = svmaxv_s32(neg_mask, negatives);\n            if (max_neg < largest_negative) {\n                largest_negative = max_neg;\n            }\n        }\n\n        // Extract positive numbers and find the smallest among them\n        svint32_t positives = svand_s32_z(pos_mask, vec);\n        if (!svptest_first(all_active, pos_mask)) {\n            int min_pos = svminv_s32(pos_mask, positives);\n            if (min_pos > 0 && (smallest_positive == 0 || min_pos < smallest_positive)) {\n                smallest_positive = min_pos;\n            }\n        }\n\n        i += vector_length;\n    }\n\n    // Handle remaining elements that don't fill a full vector\n    for (; i < lst.size(); ++i) {\n        if (lst[i] < 0 && lst[i] > largest_negative) {\n            largest_negative = lst[i];\n        } else if (lst[i] > 0 && (smallest_positive == 0 || lst[i] < smallest_positive)) {\n            smallest_positive = lst[i];\n        }\n    }\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    uint64_t result = 1;\n    svuint64_t vec_result = svdup_u64(1);\n\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t fact = 1;\n        svuint64_t vec_fact = svdup_u64(1);\n\n        for (uint64_t j = 1; j <= i; ++j) {\n            vec_fact = svmul_u64(vec_fact, svdup_u64(j));\n        }\n\n        vec_result = svmul_u64(vec_result, vec_fact);\n    }\n\n    // Reduce the vector result to a scalar\n    svbool_t pg =svptrue_b64();\n    while (svptest_any(svptrue_b64(), pg)) {\n        result *= svlasta(pg, vec_result);\n        pg = svpnext_b64(pg, pg);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    uint64_t result = 1;\n    svuint64_t vec_result = svdup_u64(1);\n\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t fact = 1;\n        svuint64_t vec_fact = svdup_u64(1);\n\n        for (uint64_t j = 1; j <= i; ++j) {\n            vec_fact = svmul_u64(vec_fact, svdup_u64(j));\n        }\n\n        // Reduce the vector factorial result into a scalar\n        svbool_t pg = svptrue_b64();\n        fact = svaddv_u64(pg, vec_fact);\n\n        // Multiply the scalar factorial into the result\n        vec_result = svmul_u64(vec_result, svdup_u64(fact));\n    }\n\n    // Reduce the final vector result into a scalar\n    svbool_t pg = svptrue_b64();\n    result = svaddv_u64(pg, vec_result);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    uint64_t result = 1;\n    svuint64_t vec_result = svdup_u64(1);\n\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t fact = 1;\n        svuint64_t vec_fact = svdup_u64(1);\n\n        for (uint64_t j = 1; j <= i; ++j) {\n            vec_fact = svmul_u64(vec_fact, svdup_u64(j));\n        }\n\n        svbool_t pg = svwhilelt_b64(0, i);\n        vec_result = svmul_u64_m(pg, vec_result, vec_fact);\n    }\n\n    svbool_t pg = svptrue_b64();\n    result = svaddv_u64(pg, vec_result);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    uint64_t result = 1;\n    svuint64_t vec_result = svdup_u64(1);\n\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t fact = 1;\n        svuint64_t vec_fact = svdup_u64(1);\n\n        for (uint64_t j = 1; j <= i; ++j) {\n            vec_fact = svmul_u64(vec_fact, svdup_u64(j));\n        }\n\n        vec_result = svmul_u64(vec_result, vec_fact);\n    }\n\n    // Reduce the vector result to a scalar\n    svbool_t pred = svptrue_b64();\n    while (svptest_any(svptrue_b64(), pred)) {\n        result *= svlasta_u64(pred, vec_result);\n        pred = svpnext_b64(pred, pred);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    uint64_t result = 1;\n    svuint64_t vec_result = svdup_u64(1);\n\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t factorial = 1;\n        svuint64_t vec_factorial = svdup_u64(1);\n        svbool_t pg =svptrue_b64();\n\n        for (uint64_t j = 1; j <= i; ++j) {\n            vec_factorial = svmul_u64_x(pg, vec_factorial, svdup_u64(j));\n        }\n\n        // Reduce vector factorial into scalar\n        factorial = 1;\n        factorial *= svlasta_u64(pg, vec_factorial);\n\n        // Multiply the scalar factorial into the result\n        vec_result = svmul_u64_x(pg, vec_result, svdup_u64(factorial));\n    }\n\n    // Reduce final vector result into scalar\n    result = 1;\n    result *= svlasta_u64(svptrue_b64(), vec_result);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint sum_squares_simd(const std::vector<int> &lst) {\n    int result = 0;\n    size_t i = 0;\n    size_t n = lst.size();\n\n    svbool_t pg = svwhilelt_b32(i, n);\n    svint32_t vec = svld1(pg, &lst[i]);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t indices = svindex_s32(i, 1);\n\n        // Check if index is a multiple of 3\n        svbool_t is_multiple_of_3 = svcmpeq_n_s32(pg, svrem_s32_x(pg, indices, 3), 0);\n        // Square the elements where index is a multiple of 3\n        svint32_t squared = svmul_s32_x(pg, vec, vec);\n        vec = svsel(is_multiple_of_3, squared, vec);\n\n        // Check if index is a multiple of 4 and not a multiple of 3\n        svbool_t is_multiple_of_4 = svcmpeq_n_s32(pg, svrem_s32_x(pg, indices, 4), 0);\n        svbool_t is_not_multiple_of_3 = svcmpne_n_s32(pg, svrem_s32_x(pg, indices, 3), 0);\n        svbool_t is_multiple_of_4_not_3 = svand_z(pg, is_multiple_of_4, is_not_multiple_of_3);\n        // Cube the elements where index is a multiple of 4 and not a multiple of 3\n        svint32_t cubed = svmul_s32_x(pg, vec, svmul_s32_x(pg, vec, vec));\n        vec = svsel(is_multiple_of_4_not_3, cubed, vec);\n\n        // Accumulate the results\n        result += svaddv(pg, vec);\n\n        // Update the loop variables\n        i += svcntw();\n        pg = svwhilelt_b32(i, n);\n        vec = svld1(pg, &lst[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint sum_squares_simd(const std::vector<int> &lst) {\n    int result = 0;\n    size_t i = 0;\n    size_t len = lst.size();\n\n    while (i < len) {\n        // Load a vector of indices\n        svbool_t pg = svwhilelt_b32(i, len);\n        svint32_t indices = svindex_s32(i, 1);\n\n        // Load the vector of integers from the list\n        svint32_t vec = svld1_s32(pg, &lst[i]);\n\n        // Create masks for multiples of 3 and multiples of 4 (not multiple of 3)\n        svbool_t mask_mult3 = svcmpeq_n_s32(pg, svrem_s32_x(pg, indices, 3), 0);\n        svbool_t mask_mult4 = svcmpeq_n_s32(pg, svrem_s32_x(pg, indices, 4), 0);\n        svbool_t mask_mult4_not3 = svbic_b_z(pg, mask_mult4, mask_mult3);\n\n        // Square elements where index is a multiple of 3\n        svint32_t squared = svmul_s32_x(pg, vec, vec);\n        vec = svsel_s32(mask_mult3, squared, vec);\n\n        // Cube elements where index is a multiple of 4 and not a multiple of 3\n        svint32_t cubed = svmul_s32_x(pg, vec, svmul_s32_x(pg, vec, vec));\n        vec = svsel_s32(mask_mult4_not3, cubed, vec);\n\n        // Accumulate the results\n        result += svaddv_s32(pg, vec);\n\n        // Increment the index by the vector length\n        i += svcntw();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint sum_squares_simd(const std::vector<int> &lst) {\n    int result = 0;\n    size_t i = 0;\n    size_t n = lst.size();\n\n    while (i < n) {\n        // Load a vector of indices\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t indices = svindex_s32(i, 1);\n\n        // Load the vector of integers from the list\n        svint32_t vec = svld1_s32(pg, &lst[i]);\n\n        // Compute masks for multiples of 3 and multiples of 4\n        svbool_t mask_mult3 = svcmpeq_n_s32(pg, svrem_s32_x(pg, indices, 3), 0);\n        svbool_t mask_mult4 = svcmpeq_n_s32(pg, svrem_s32_x(pg, indices, 4), 0);\n\n        // Square elements where index is a multiple of 3\n        svint32_t squared = svmul_s32_x(pg, vec, vec);\n        vec = svsel_s32(mask_mult3, squared, vec);\n\n        // Cube elements where index is a multiple of 4 but not a multiple of 3\n        svbool_t mask_mult4_not3 = svbic_b_z(pg, mask_mult4, mask_mult3);\n        svint32_t cubed = svmul_s32_x(pg, vec, svmul_s32_x(pg, vec, vec));\n        vec = svsel_s32(mask_mult4_not3, cubed, vec);\n\n        // Accumulate the results\n        result += svaddv_s32(pg, vec);\n\n        // Increment the index by the vector length\n        i += svcntw();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint sum_squares_simd(const std::vector<int> &lst) {\n    int result = 0;\n    size_t i = 0;\n    size_t n = lst.size();\n\n    svbool_t pg = svwhilelt_b32(i, n);\n    svint32_t vec = svld1_s32(pg, &lst[i]);\n    svint32_t index_vec = svindex_s32(0, 1);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svbool_t multiple_of_3 = svcmpeq_n_s32(pg, svrem_s32_z(pg, index_vec, 3), 0);\n        svbool_t multiple_of_4 = svcmpeq_n_s32(pg, svrem_s32_z(pg, index_vec, 4), 0);\n        svbool_t multiple_of_4_not_3 = svand_b_z(pg, multiple_of_4, svnot_b_z(pg, multiple_of_3));\n\n        svint32_t squared = svmul_s32_z(pg, vec, vec);\n        svint32_t cubed = svmul_s32_z(pg, svmul_s32_z(pg, vec, vec), vec);\n\n        vec = svsel_s32(multiple_of_3, squared, vec);\n        vec = svsel_s32(multiple_of_4_not_3, cubed, vec);\n\n        result += svaddv_s32(pg, vec);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, n);\n        vec = svld1_s32(pg, &lst[i]);\n        index_vec = svindex_s32(i, 1);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint sum_squares_simd(const std::vector<int> &lst) {\n    int result = 0;\n    size_t i = 0;\n    size_t n = lst.size();\n\n    while (i < n) {\n        // Load a vector of indices\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t indices = svindex_s32(i, 1);\n\n        // Load the vector of integers from the list\n        svint32_t vec = svld1_s32(pg, &lst[i]);\n\n        // Compute masks for multiples of 3 and multiples of 4\n        svbool_t mask_mult3 = svcmpeq_n_s32(pg, svrem_s32_x(pg, indices, 3), 0);\n        svbool_t mask_mult4 = svcmpeq_n_s32(pg, svrem_s32_x(pg, indices, 4), 0);\n\n        // Square elements where index is a multiple of 3\n        svint32_t squared = svmul_s32_x(pg, vec, vec);\n        vec = svsel_s32(mask_mult3, squared, vec);\n\n        // Cube elements where index is a multiple of 4 but not a multiple of 3\n        svbool_t mask_mult4_not3 = svbic_b_z(pg, mask_mult4, mask_mult3);\n        svint32_t cubed = svmul_s32_x(pg, vec, svmul_s32_x(pg, vec, vec));\n        vec = svsel_s32(mask_mult4_not3, cubed, vec);\n\n        // Accumulate the results\n        result += svaddv_s32(pg, vec);\n\n        // Increment the index\n        i += svcntw();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint specialFilter_simd(const std::vector<int> &nums) {\n    int result = 0;\n    size_t i = 0;\n    size_t n = nums.size();\n\n    // Define constants\n    svint32_t vec_ten = svdup_n_s32(10);\n    svint32_t vec_one = svdup_n_s32(1);\n    svbool_t pred_odd = svcmpeq_n_s32(svdup_n_s32(1), svand_n_s32(vec_one, vec_one));\n\n    while (i <= n - svcntw()) {\n        // Load a vector of integers from the array\n        svint32_t vec_nums = svld1_s32(svptrue_b32(), &nums[i]);\n\n        // Check if numbers are greater than 10\n        svbool_t pred_gt_10 = svcmpgt_s32(svptrue_b32(), vec_nums, vec_ten);\n\n        // Extract first digit\n        svint32_t vec_first_digit = vec_nums;\n        svint32_t vec_temp = svabs_s32(vec_nums);\n        while (svptest_any(svptrue_b32(), svcmpge_n_s32(svptrue_b32(), vec_temp, 10))) {\n            vec_temp = svdiv_n_s32_z(svptrue_b32(), vec_temp, 10);\n        }\n        vec_first_digit = vec_temp;\n\n        // Extract last digit\n        svint32_t vec_last_digit = svrem_n_s32_z(svptrue_b32(), svabs_s32(vec_nums), 10);\n\n        // Check if first and last digits are odd\n        svbool_t pred_first_odd = svcmpeq_n_s32(svptrue_b32(), svand_n_s32(vec_first_digit, vec_one), vec_one);\n        svbool_t pred_last_odd = svcmpeq_n_s32(svptrue_b32(), svand_n_s32(vec_last_digit, vec_one), vec_one);\n\n        // Combine all conditions\n        svbool_t pred_final = svand_b_z(svptrue_b32(), pred_gt_10, svand_b_z(svptrue_b32(), pred_first_odd, pred_last_odd));\n\n        // Count the number of elements satisfying the condition\n        result += svcntp_b32(svptrue_b32(), pred_final);\n\n        i += svcntw();\n    }\n\n    // Process remaining elements\n    for (; i < n; ++i) {\n        int num = nums[i];\n        if (num > 10) {\n            int first_digit = std::abs(num);\n            while (first_digit >= 10) {\n                first_digit /= 10;\n            }\n            int last_digit = std::abs(num) % 10;\n            if (first_digit % 2 == 1 && last_digit % 2 == 1) {\n                ++result;\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint specialFilter_simd(const std::vector<int> &nums) {\n    int result = 0;\n    size_t i = 0;\n    size_t num_size = nums.size();\n\n    // Define constants for comparison\n    svint32_t vec_ten = svdup_n_s32(10);\n    svint32_t vec_one = svdup_n_s32(1);\n    svbool_t pred_all = svptrue_b32();\n\n    while (i < num_size) {\n        // Load a vector of integers from the input array\n        svint32_t vec_nums = svld1_s32(pred_all, &nums[i]);\n\n        // Check if numbers are greater than 10\n        svbool_t pred_gt_10 = svcmpgt_n_s32(pred_all, vec_nums, 10);\n\n        // Compute absolute values to handle negative numbers\n        svint32_t vec_abs = svabs_s32_x(pred_all, vec_nums);\n\n        // Extract last digit using modulo 10\n        svint32_t vec_last_digit = svrem_n_s32_x(pred_all, vec_abs, 10);\n\n        // Extract first digit by repeatedly dividing by 10\n        svint32_t vec_first_digit = vec_abs;\n        svbool_t pred_nonzero = svcmpne_n_s32(pred_all, vec_first_digit, 0);\n        while (svptest_any(pred_all, pred_nonzero)) {\n            vec_first_digit = svdiv_n_s32_x(pred_all, vec_first_digit, 10);\n            pred_nonzero = svcmpne_n_s32(pred_all, vec_first_digit, 0);\n        }\n        vec_first_digit = svmul_n_s32_x(pred_all, vec_first_digit, 10);\n        vec_first_digit = svadd_n_s32_x(pred_all, vec_first_digit, svrem_n_s32_x(pred_all, vec_abs, 10));\n\n        // Check if both first and last digits are odd\n        svbool_t pred_first_odd = svcmpeq_n_s32(pred_all, svand_n_s32_x(pred_all, vec_first_digit, 1), 1);\n        svbool_t pred_last_odd = svcmpeq_n_s32(pred_all, svand_n_s32_x(pred_all, vec_last_digit, 1), 1);\n        svbool_t pred_both_odd = svand_b_z(pred_all, pred_first_odd, pred_last_odd);\n\n        // Combine conditions: greater than 10 and both digits odd\n        svbool_t pred_final = svand_b_z(pred_all, pred_gt_10, pred_both_odd);\n\n        // Count the number of elements satisfying the condition\n        result += svcntp_b32(pred_all, pred_final);\n\n        // Move to the next block of data\n        i += svcntw();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> &nums) {\n    int result = 0;\n    size_t i = 0;\n    size_t num_size = nums.size();\n\n    // Define constants\n    svint32_t vec_ten = svdup_n_s32(10);\n    svint32_t vec_one = svdup_n_s32(1);\n\n    while (i <= num_size - svcntw()) {\n        // Load a vector of integers from the input\n        svint32_t vec_nums = svld1_s32(svptrue_b32(), &nums[i]);\n\n        // Check if numbers are greater than 10\n        svbool_t gt_ten_mask = svcmpgt_s32(svptrue_b32(), vec_nums, vec_ten);\n\n        // Compute absolute values to handle negatives\n        svint32_t abs_nums = svabs_s32_x(svptrue_b32(), vec_nums);\n\n        // Extract last digit\n        svint32_t last_digit = svand_s32_x(svptrue_b32(), abs_nums, svdup_n_s32(9));\n\n        // Compute first digit\n        svint32_t first_digit = abs_nums;\n        svbool_t pred = svwhilelt_b32(i, num_size);\n        do {\n            first_digit = svdiv_n_s32_x(pred, first_digit, 10);\n            pred = svcmpge_n_s32(pred, first_digit, 10);\n        } while (svptest_any(svptrue_b32(), pred));\n\n        // Check if both first and last digits are odd\n        svbool_t first_odd_mask = svcmpeq_n_s32(svptrue_b32(), svand_s32_x(svptrue_b32(), first_digit, svdup_n_s32(1)), sv_one);\n        svbool_t last_odd_mask = svcmpeq_n_s32(svptrue_b32(), svand_s32_x(svptrue_b32(), last_digit, svdup_n_s32(1)), sv_one);\n        svbool_t odd_mask = svand_b_z(svptrue_b32(), first_odd_mask, last_odd_mask);\n\n        // Combine masks: greater than 10 AND both digits odd\n        svbool_t final_mask = svand_b_z(svptrue_b32(), gt_ten_mask, odd_mask);\n\n        // Count the number of elements satisfying the condition\n        result += svcntp_b32(svptrue_b32(), final_mask);\n\n        // Move to the next block\n        i += svcntw();\n    }\n\n    // Handle remaining elements\n    for (; i < num_size; ++i) {\n        int num = nums[i];\n        if (num > 10) {\n            int abs_num = std::abs(num);\n            int last_digit = abs_num % 10;\n            int first_digit = abs_num;\n            while (first_digit >= 10) {\n                first_digit /= 10;\n            }\n            if ((first_digit % 2 != 0) && (last_digit % 2 != 0)) {\n                ++result;\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint specialFilter_simd(const std::vector<int> &nums) {\n    int count = 0;\n    size_t i = 0;\n    size_t num_elements = nums.size();\n\n    // Define constants for comparison\n    svint32_t vec_ten = svdup_n_s32(10);\n    svint32_t vec_one = svdup_n_s32(1);\n\n    while (i <= num_elements - svcntw()) {\n        // Load a vector of integers from the input array\n        svint32_t vec_nums = svld1_s32(svptrue_b32(), &nums[i]);\n\n        // Check if numbers are greater than 10\n        svbool_t gt_ten_mask = svcmpgt_s32(svptrue_b32(), vec_nums, vec_ten);\n\n        // Extract absolute values to handle negative numbers\n        svint32_t abs_nums = svabs_s32_x(svptrue_b32(), vec_nums);\n\n        // Compute last digit using modulo 10\n        svint32_t last_digit = svrem_s32_x(svptrue_b32(), abs_nums, svdup_n_s32(10));\n\n        // Compute first digit by repeatedly dividing by 10\n        svint32_t first_digit = abs_nums;\n        svbool_t active_mask = svwhilelt_b32(i, num_elements);\n        while (svptest_any(svptrue_b32(), active_mask)) {\n            first_digit = svdiv_s32_x(active_mask, first_digit, svdup_n_s32(10));\n            active_mask = svcmpge_s32(active_mask, first_digit, svdup_n_s32(10));\n        }\n\n        // Check if both first and last digits are odd\n        svbool_t first_odd_mask = svcmpeq_s32(svptrue_b32(), svand_s32_z(svptrue_b32(), first_digit, vec_one), vec_one);\n        svbool_t last_odd_mask = svcmpeq_s32(svptrue_b32(), svand_s32_z(svptrue_b32(), last_digit, vec_one), vec_one);\n        svbool_t odd_mask = svand_b_z(svptrue_b32(), first_odd_mask, last_odd_mask);\n\n        // Combine masks: greater than 10 AND both digits odd\n        svbool_t final_mask = svand_b_z(svptrue_b32(), gt_ten_mask, odd_mask);\n\n        // Count the number of elements that satisfy the condition\n        count += svcntp_b32(svptrue_b32(), final_mask);\n\n        // Move to the next block of elements\n        i += svcntw();\n    }\n\n    // Process remaining elements (if any)\n    for (; i < num_elements; ++i) {\n        int num = nums[i];\n        if (num > 10) {\n            int abs_num = std::abs(num);\n            int last_digit = abs_num % 10;\n            int first_digit = abs_num;\n            while (first_digit >= 10) {\n                first_digit /= 10;\n            }\n            if ((first_digit % 2 == 1) && (last_digit % 2 == 1)) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint specialFilter_simd(const std::vector<int> &nums) {\n    int result = 0;\n    size_t i = 0;\n    size_t num_size = nums.size();\n\n    while (i <= num_size - svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, num_size);\n        svint32_t vec = svld1_s32(pg, &nums[i]);\n\n        // Check if numbers are greater than 10\n        svbool_t greater_than_10 = svcmpgt_n_s32(pg, vec, 10);\n\n        // Extract absolute values for digit checks\n        svint32_t abs_vec = svabs_s32_x(pg, vec);\n\n        // Extract first digit\n        svint32_t first_digit = abs_vec;\n        svbool_t not_single_digit = svcmpge_n_s32(pg, abs_vec, 10);\n        while (svptest_any(svptrue_b32(), not_single_digit)) {\n            first_digit = svdiv_n_s32_z(pg, first_digit, 10);\n            not_single_digit = svcmpge_n_s32(pg, first_digit, 10);\n        }\n\n        // Extract last digit\n        svint32_t last_digit = svrem_n_s32_x(pg, abs_vec, 10);\n\n        // Check if both first and last digits are odd\n        svbool_t first_digit_odd = svcmpeq_n_s32(pg, svand_n_s32_x(pg, first_digit, 1), 1);\n        svbool_t last_digit_odd = svcmpeq_n_s32(pg, svand_n_s32_x(pg, last_digit, 1), 1);\n        svbool_t both_digits_odd = svand_b_z(pg, first_digit_odd, last_digit_odd);\n\n        // Combine conditions\n        svbool_t valid_numbers = svand_b_z(pg, greater_than_10, both_digits_odd);\n\n        // Count the number of valid elements\n        result += svcntp_b32(svptrue_b32(), valid_numbers);\n\n        i += svcntw();\n    }\n\n    // Handle remaining elements\n    for (; i < num_size; ++i) {\n        int num = nums[i];\n        if (num > 10) {\n            int abs_num = std::abs(num);\n            int first_digit = abs_num;\n            while (first_digit >= 10) {\n                first_digit /= 10;\n            }\n            int last_digit = abs_num % 10;\n            if ((first_digit % 2 == 1) && (last_digit % 2 == 1)) {\n                result++;\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    uint64_t count = 0;\n    svbool_t pg = svwhilelt_b64(0, n);\n\n    // Allocate space for the array a\n    int64_t *a = (int64_t *)malloc(n * sizeof(int64_t));\n\n    // Compute a[i] = i * i - i + 1 using SVE\n    {\n        svint64_t indices = svindex_s64(1, 1);\n        svint64_t vec_a;\n\n        for (uint64_t i = 0; i < n; i += svcntd()) {\n            svbool_t active = svwhilelt_b64(i, n);\n            vec_a = svmad_s64_z(active, indices, indices, -indices);\n            vec_a = svadd_s64_z(active, vec_a, 1);\n            svst1_s64(active, a + i, vec_a);\n        }\n    }\n\n    // Count triples where (a[i] + a[j] + a[k]) % 3 == 0\n    for (uint64_t i = 0; i < n; ++i) {\n        for (uint64_t j = i + 1; j < n; ++j) {\n            int64_t sum_ij = a[i] + a[j];\n            uint64_t k = j + 1;\n\n            while (k + svcntd() <= n) {\n                svbool_t active = svwhilelt_b64(k, n);\n                svint64_t vec_a_k = svld1_s64(active, a + k);\n                svint64_t vec_sum = svadd_s64_z(active, vec_a_k, sum_ij);\n                svbool_t divisible_by_3 = svcmpeq_n_s64(active, svmod_n_s64_z(active, vec_sum, 3), 0);\n                count += svcntp_b64(svptrue_b64(), divisible_by_3);\n                k += svcntd();\n            }\n\n            for (; k < n; ++k) {\n                if ((sum_ij + a[k]) % 3 == 0) {\n                    ++count;\n                }\n            }\n        }\n    }\n\n    free(a);\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    uint64_t count = 0;\n    uint64_t vec_size = svcntw(); // Number of elements processed per SVE vector\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active lanes\n\n    // Allocate space for the array 'a'\n    uint32_t *a = (uint32_t *)malloc(n * sizeof(uint32_t));\n    if (!a) return 0;\n\n    // Compute a[i] = i * i - i + 1 using SVE intrinsics\n    for (uint64_t i = 0; i < n; i += vec_size) {\n        svbool_t p = svwhilelt_b32(i, n); // Update predicate for remaining elements\n        svuint32_t indices = svindex_u32(i, 1); // Generate indices [i, i+1, ..., i+vec_size-1]\n        svuint32_t squares = svmul_x(p, indices, indices); // Compute i * i\n        svuint32_t linear = svsub_x(p, squares, indices); // Compute i * i - i\n        svuint32_t result = svadd_x(p, linear, 1); // Compute i * i - i + 1\n        svst1_u32(p, a + i, result); // Store results into array 'a'\n    }\n\n    // Count triples where (a[i] + a[j] + a[k]) % 3 == 0\n    for (uint64_t i = 0; i < n; ++i) {\n        for (uint64_t j = i + 1; j < n; ++j) {\n            uint32_t sum_ij = a[i] + a[j];\n            for (uint64_t k = j + 1; k < n; k += vec_size) {\n                svbool_t p = svwhilelt_b32(k, n); // Predicate for active lanes\n                svuint32_t vec_a = svld1_u32(p, a + k); // Load a[k], a[k+1], ...\n                svuint32_t sums = svadd_x(p, sum_ij, vec_a); // Compute sum_ij + a[k]\n                svbool_t divisible_by_3 = svcmpeq_x(p, svrem_x(p, sums, 3), 0); // Check divisibility by 3\n                count += svcntp_b32(svptrue_b32(), divisible_by_3); // Count true predicates\n            }\n        }\n    }\n\n    free(a);\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    uint64_t count = 0;\n    uint64_t vec_size = svcntd(); // Number of doublewords in an SVE vector\n    svbool_t pg = svwhilelt_b64(0, n); // Predicate for active lanes\n\n    // Allocate space for the array a\n    uint64_t *a = (uint64_t *)malloc(n * sizeof(uint64_t));\n\n    // Compute a[i] = i * i - i + 1 using SVE\n    for (uint64_t i = 0; i < n; i += vec_size) {\n        svbool_t active_pg = svwhilelt_b64(i, n); // Update predicate for remaining elements\n        svuint64_t indices = svindex_u64(i, 1);   // Generate indices starting from i\n        svuint64_t squares = svmul_x(active_pg, indices, indices); // Compute i * i\n        svuint64_t linear = svsub_x(active_pg, squares, indices);  // Compute i * i - i\n        svuint64_t result = svadd_x(active_pg, linear, 1);         // Compute i * i - i + 1\n        svst1_u64(active_pg, a + i, result);                       // Store results into a\n    }\n\n    // Count triples (a[i], a[j], a[k]) where i < j < k and (a[i] + a[j] + a[k]) % 3 == 0\n    for (uint64_t i = 0; i < n; ++i) {\n        for (uint64_t j = i + 1; j < n; ++j) {\n            uint64_t sum_ij = a[i] + a[j];\n            for (uint64_t k = j + 1; k < n; k += vec_size) {\n                svbool_t active_pg = svwhilelt_b64(k, n); // Predicate for active lanes\n                svuint64_t vec_a = svld1_u64(active_pg, a + k); // Load a[k] values\n                svuint64_t sums = svadd_x(active_pg, sum_ij, vec_a); // Compute sum_ij + a[k]\n                svbool_t divisible_by_3 = svcmpeq_n_u64(active_pg, svrem_x(active_pg, sums, 3), 0); // Check divisibility by 3\n                count += svcntp_b64(active_pg, divisible_by_3); // Count true predicates\n            }\n        }\n    }\n\n    free(a);\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    uint64_t count = 0;\n    uint64_t vec_size = svcntw(); // Number of elements processed per SVE vector\n    svbool_t pg = svwhilelt_b32(0, n); // Predicate for active lanes\n\n    // Allocate space for the array a\n    uint32_t *a = (uint32_t *)malloc(n * sizeof(uint32_t));\n    if (!a) return 0;\n\n    // Compute a[i] = i * i - i + 1 using SVE\n    for (uint64_t i = 0; i < n; i += vec_size) {\n        svbool_t p = svwhilelt_b32(i, n); // Update predicate for remaining elements\n        svuint32_t indices = svindex_u32(i, 1); // Generate indices [i, i+1, ..., i+vec_size-1]\n        svuint32_t squares = svmul_x(p, indices, indices); // Compute i * i\n        svuint32_t linear = svsub_x(p, squares, indices); // Compute i * i - i\n        svuint32_t result = svadd_x(p, linear, 1); // Compute i * i - i + 1\n        svst1_u32(p, a + i, result); // Store results into array a\n    }\n\n    // Count triples where (a[i] + a[j] + a[k]) % 3 == 0\n    for (uint64_t i = 0; i < n; ++i) {\n        for (uint64_t j = i + 1; j < n; ++j) {\n            uint32_t sum_ij = a[i] + a[j];\n            for (uint64_t k = j + 1; k < n; k += vec_size) {\n                svbool_t p = svwhilelt_b32(k, n); // Predicate for active lanes\n                svuint32_t vec_a = svld1_u32(p, a + k); // Load a[k], a[k+1], ...\n                svuint32_t sums = svadd_x(p, sum_ij, vec_a); // Compute sum_ij + a[k]\n                svbool_t divisible_by_3 = svcmpeq_x(p, svrem_x(p, sums, 3), 0); // Check divisibility by 3\n                count += svcntp_b32(svptrue_b32(), divisible_by_3); // Count true predicates\n            }\n        }\n    }\n\n    free(a);\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    // Allocate space for the array a\n    uint64_t *a = (uint64_t *)malloc(n * sizeof(uint64_t));\n    \n    // Compute values of a[i] = i * i - i + 1 using SVE\n    svbool_t pg = svwhilelt_b64(0, n); // Predicate for active lanes\n    svuint64_t indices = svindex_u64(1, 1); // Vector of indices starting from 1\n    svuint64_t vec_a = svdup_u64(0); // Initialize vector for a\n\n    for (uint64_t i = 0; i < n; i += svcntd()) {\n        svbool_t active_pg = svwhilelt_b64(i, n); // Update predicate for remaining elements\n        svuint64_t idx = svadd_u64(indices, svdup_u64(i)); // Adjust indices for current iteration\n        vec_a = svmad_u64_z(active_pg, idx, idx, svneg_u64_z(active_pg, idx)); // Compute i * i - i\n        vec_a = svadd_u64_z(active_pg, vec_a, svdup_u64(1)); // Add 1 to get i * i - i + 1\n        svst1_u64(active_pg, a + i, vec_a); // Store results into array a\n    }\n\n    // Count triples where (a[i] + a[j] + a[k]) % 3 == 0\n    uint64_t count = 0;\n    svuint64_t mod_counts = svdup_u64(0); // Vector to hold counts of mods 0, 1, 2\n\n    for (uint64_t i = 0; i < n; i++) {\n        uint64_t mod = a[i] % 3;\n        mod_counts = svinc_u64_m(mod_counts, svcmpeq_n_u64(pg, mod, 0)); // Increment count for mod 0\n        mod_counts = svinc_u64_m(mod_counts, svcmpeq_n_u64(pg, mod, 1)); // Increment count for mod 1\n        mod_counts = svinc_u64_m(mod_counts, svcmpeq_n_u64(pg, mod, 2)); // Increment count for mod 2\n    }\n\n    // Extract counts for mods 0, 1, and 2\n    uint64_t count_mod0 = svcntp_b64(svmask, mod_counts);\n    uint64_t count_mod1 = svcntp_b64(svmask, mod_counts);\n    uint64_t count_mod2 = svcntp_b64(svmask, mod_counts);\n\n    // Calculate the number of valid triples\n    count += (count_mod0 * (count_mod0 - 1) * (count_mod0 - 2)) / 6; // All mods 0\n    count += (count_mod1 * (count_mod1 - 1) * (count_mod1 - 2)) / 6; // All mods 1\n    count += (count_mod2 * (count_mod2 - 1) * (count_mod2 - 2)) / 6; // All mods 2\n    count += count_mod0 * count_mod1 * count_mod2; // One of each mod\n\n    free(a);\n    return count;\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    if (n <= 1) return y;\n\n    svbool_t pg = svptrue_b8();\n    int limit = svcntw() > n ? n : svcntw();\n    int is_prime = 1;\n\n    for (int i = 2; i <= limit; ++i) {\n        svint32_t vec_i = svdup_n_s32(i);\n        svint32_t vec_n = svdup_n_s32(n);\n        svint32_t rem = svrem_s32_x(pg, vec_n, vec_i);\n\n        if (svptest_any(svptrue_b32(), svcmpeq_n_s32(pg, rem, 0))) {\n            is_prime = 0;\n            break;\n        }\n    }\n\n    return is_prime ? x : y;\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    if (n <= 1) return y;\n\n    svbool_t pg = svptrue_b8();\n    int limit = svcntw() > n ? n : svcntw();\n    int is_prime = 1;\n\n    for (int i = 2; i <= limit; ++i) {\n        if (n % i == 0) {\n            is_prime = 0;\n            break;\n        }\n    }\n\n    return is_prime ? x : y;\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    if (n <= 1) return y;\n\n    svbool_t pg = svptrue_b32();\n    int limit = svcntw() > n ? n : svcntw();\n    int is_prime = 1;\n\n    for (int i = 2; i <= limit; ++i) {\n        if (n % i == 0) {\n            is_prime = 0;\n            break;\n        }\n    }\n\n    return is_prime ? x : y;\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    if (n <= 1) return y;\n\n    svbool_t pg = svptrue_b32();\n    svint32_t vn = svdup_n_s32(n);\n    svint32_t vrange = svindex_s32(2, 1);\n    svbool_t is_divisible = svcmpeq_s32(pg, svrem_s32_x(pg, vn, vrange), 0);\n\n    while (svptest_any(svptrue_b32(), is_divisible)) {\n        return y;\n    }\n\n    return x;\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    if (n <= 1) return y;\n\n    svbool_t pg = svptrue_b32();\n    int limit = svcntw() > n ? n : svcntw();\n    int is_prime = 1;\n\n    for (int i = 2; i <= limit; ++i) {\n        if (n % i == 0) {\n            is_prime = 0;\n            break;\n        }\n    }\n\n    return is_prime ? x : y;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    uint64_t result = 0;\n    size_t i = 0;\n    size_t length = lst.size();\n\n    if (length == 0) return 0;\n\n    svbool_t pg = svwhilelt_b32(i, length);\n    do {\n        svfloat32_t vec = svld1_f32(pg, &lst[i]);\n        svbool_t positive_mask = svcmpge_f32(pg, vec, 0.0f);\n        svbool_t integer_mask = sveq_f32(pg, svrintz_f32(pg, vec), vec);\n        svbool_t odd_mask = svcntw_b32(pg, svcvt_s32_f32(pg, vec)) % 2 != 0;\n\n        svbool_t valid_mask = svand_b_z(pg, svand_b_z(pg, positive_mask, integer_mask), odd_mask);\n        svfloat32_t squared = svmul_f32_z(pg, vec, vec);\n        svfloat32_t selected = svsel_f32(valid_mask, squared, 0.0f);\n\n        svfloat32_t sum_vec = svaddv_f32(pg, selected);\n        result += svcvt_u64_f32(pg, sum_vec);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    } while (svptest_any(svptrue_b32(), pg));\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    uint64_t result = 0;\n    size_t i = 0;\n    size_t n = lst.size();\n\n    if (n == 0) return 0;\n\n    svbool_t pg = svwhilelt_b32(i, n);\n    do {\n        svfloat32_t vec = svld1_f32(pg, &lst[i]);\n        svint32_t vec_int = svcvt_s32_f32_z(pg, vec);\n        svbool_t positive_mask = svcmpge_n_s32(pg, vec_int, 0);\n        svbool_t odd_mask = svcnt_s32(pg, vec_int);\n        svbool_t combined_mask = svand_b_z(pg, positive_mask, odd_mask);\n\n        svint32_t squared = svmul_s32_z(combined_mask, vec_int, vec_int);\n        uint64_t sum = svaddv_u64(svcvt_u64_s32_z(combined_mask, squared));\n        result += sum;\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, n);\n    } while (svptest_any(svptrue_b32(), pg));\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    uint64_t result = 0;\n    size_t i = 0;\n    size_t length = lst.size();\n\n    while (i <= length - svcntw()) {\n        // Load a vector of floats from the input list\n        svfloat32_t vec = svld1_f32(svptrue_b32(), &lst[i]);\n\n        // Create a predicate for valid elements (non-negative and integers)\n        svbool_t pred_valid = svcmpeq_f32(svptrue_b32(), svrintz_f32(vec), vec);\n        pred_valid = svand_b_z(pred_valid, svcmpge_f32(svptrue_b32(), vec, 0.0f));\n\n        // Extract odd integers\n        svint32_t vec_int = svcvt_s32_f32_z(pred_valid, vec);\n        svbool_t pred_odd = svcmpeq_n_s32(pred_valid, svand_s32_z(pred_valid, vec_int, 1), 1);\n\n        // Square the odd integers\n        svfloat32_t squared = svmul_f32_z(pred_odd, vec, vec);\n\n        // Reduce the squared values into the result\n        result += svaddv_f32(pred_odd, squared);\n\n        i += svcntw();\n    }\n\n    // Handle remaining elements\n    for (; i < length; ++i) {\n        float val = lst[i];\n        int intval = static_cast<int>(val);\n        if (val >= 0 && val == intval && (intval & 1)) {\n            result += intval * intval;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    uint64_t result = 0;\n    size_t i = 0;\n    size_t length = lst.size();\n\n    if (length == 0) return 0;\n\n    svbool_t pg = svwhilelt_b32(i, length);\n    do {\n        svfloat32_t vec = svld1_f32(pg, &lst[i]);\n        svbool_t positive_mask = svcmpge_f32(pg, vec, 0.0f);\n        svbool_t integer_mask = sveq_f32(pg, svrintm_f32_x(pg, vec), vec);\n        svbool_t odd_mask = sveq_f32(pg, svand_f32_x(pg, vec, 1.0f), 1.0f);\n\n        svbool_t valid_mask = svand_b_z(pg, svand_b_z(pg, positive_mask, integer_mask), odd_mask);\n        svfloat32_t squared = svmul_f32_x(pg, vec, vec);\n        svfloat32_t selected = svsel_f32(valid_mask, squared, 0.0f);\n\n        svfloat32_t sum_vec = svaddv_f32(pg, selected);\n        result += svcvt_u64_f32(svptrue_b32(), sum_vec);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    } while (svptest_any(svptrue_b32(), pg));\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    size_t i = 0;\n    uint64_t result = 0;\n    size_t vector_length = svcntw(); // Get the number of elements processed per SVE vector\n\n    svbool_t pg = svwhilelt_b32(i, lst.size()); // Predicate for active lanes\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vec = svld1_f32(pg, &lst[i]); // Load a vector of floats\n        svint32_t vec_int = svcvt_s32_f32_x(pg, vec); // Convert floats to integers\n        svbool_t positive_mask = svcmpge_n_s32(pg, vec_int, 0); // Mask for non-negative numbers\n        svbool_t odd_mask = svcmpne_n_s32(pg, svand_s32_z(pg, vec_int, 1), 0); // Mask for odd numbers\n        svbool_t valid_mask = svand_b_z(pg, positive_mask, odd_mask); // Combine masks\n\n        svint32_t squared = svmul_s32_z(valid_mask, vec_int, vec_int); // Square the valid numbers\n        svuint64_t squared_u64 = svcvt_u64_s32_z(valid_mask, squared); // Convert to uint64_t\n\n        uint64_t temp_result = 0;\n        svst1u64(svptrue_b64(), &temp_result, svaddv_u64(svptrue_b64(), squared_u64)); // Horizontal sum\n        result += temp_result;\n\n        i += vector_length;\n        pg = svwhilelt_b32(i, lst.size()); // Update predicate for remaining elements\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result(game.size());\n    size_t i = 0;\n    size_t size = game.size();\n\n    while (i <= size - svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, size);\n\n        svint32_t game_vec = svld1_s32(pg, &game[i]);\n        svint32_t guess_vec = svld1_s32(pg, &guess[i]);\n\n        svint32_t diff_vec = svsub_s32_x(pg, game_vec, guess_vec);\n        svint32_t abs_diff_vec = svabs_s32_x(pg, diff_vec);\n\n        svst1_s32(pg, &result[i], abs_diff_vec);\n\n        i += svcntw();\n    }\n\n    for (; i < size; ++i) {\n        result[i] = std::abs(game[i] - guess[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result(game.size());\n    size_t i = 0;\n    size_t size = game.size();\n\n    while (i <= size - svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, size);\n\n        svint32_t game_vec = svld1_s32(pg, &game[i]);\n        svint32_t guess_vec = svld1_s32(pg, &guess[i]);\n\n        svint32_t diff_vec = svsub_s32_x(pg, game_vec, guess_vec);\n        svint32_t abs_diff_vec = svabs_s32_x(pg, diff_vec);\n\n        svint32_t mask_vec = svcmpeq_s32(pg, game_vec, guess_vec);\n        svint32_t result_vec = svsel_s32(mask_vec, svdup_s32(0), abs_diff_vec);\n\n        svst1_s32(pg, &result[i], result_vec);\n\n        i += svcntw();\n    }\n\n    for (; i < size; ++i) {\n        if (game[i] == guess[i]) {\n            result[i] = 0;\n        } else {\n            result[i] = std::abs(game[i] - guess[i]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result(game.size());\n    size_t i = 0;\n    size_t size = game.size();\n\n    while (i <= size - svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, size);\n\n        svint32_t game_vec = svld1_s32(pg, &game[i]);\n        svint32_t guess_vec = svld1_s32(pg, &guess[i]);\n\n        svint32_t diff_vec = svsub_s32_x(pg, game_vec, guess_vec);\n        svint32_t abs_diff_vec = svabs_s32_x(pg, diff_vec);\n\n        svint32_t mask = svcmpeq_n_s32(pg, game_vec, guess_vec);\n        svint32_t result_vec = svsel_s32(mask, svdup_n_s32(0), abs_diff_vec);\n\n        svst1_s32(pg, &result[i], result_vec);\n\n        i += svcntw();\n    }\n\n    for (; i < size; ++i) {\n        if (game[i] == guess[i]) {\n            result[i] = 0;\n        } else {\n            result[i] = std::abs(game[i] - guess[i]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result(game.size());\n    size_t i = 0;\n    size_t size = game.size();\n\n    while (i <= size - svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, size);\n\n        svint32_t game_vec = svld1_s32(pg, &game[i]);\n        svint32_t guess_vec = svld1_s32(pg, &guess[i]);\n\n        svint32_t diff = svsub_s32_x(pg, game_vec, guess_vec);\n        svint32_t abs_diff = svabs_s32_x(pg, diff);\n\n        svint32_t mask = svcmpeq_n_s32(pg, game_vec, guess_vec);\n        svint32_t result_vec = svsel_s32(mask, svdup_n_s32(0), abs_diff);\n\n        svst1_s32(pg, &result[i], result_vec);\n\n        i += svcntw();\n    }\n\n    for (; i < size; ++i) {\n        if (game[i] == guess[i]) {\n            result[i] = 0;\n        } else {\n            result[i] = std::abs(game[i] - guess[i]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result(game.size());\n    size_t i = 0;\n    size_t size = game.size();\n\n    while (i <= size - svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, size);\n\n        svint32_t game_vec = svld1_s32(pg, &game[i]);\n        svint32_t guess_vec = svld1_s32(pg, &guess[i]);\n\n        svint32_t diff_vec = svsub_s32_x(pg, game_vec, guess_vec);\n        svint32_t abs_diff_vec = svabs_s32_x(pg, diff_vec);\n\n        svint32_t mask = svcmpeq_n_s32(pg, diff_vec, 0);\n        svint32_t result_vec = svsel_s32(mask, svdup_n_s32(0), abs_diff_vec);\n\n        svst1_s32(pg, &result[i], result_vec);\n\n        i += svcntw();\n    }\n\n    for (; i < size; ++i) {\n        int diff = game[i] - guess[i];\n        result[i] = (diff == 0) ? 0 : std::abs(diff);\n    }\n\n    return result;\n}\n```"}

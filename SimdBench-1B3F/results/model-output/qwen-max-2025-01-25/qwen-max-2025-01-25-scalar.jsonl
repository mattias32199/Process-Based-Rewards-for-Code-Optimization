{"task_id": "SimdBench_0", "completion": "```cpp\nvoid conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0", "completion": "```cpp\nvoid conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0", "completion": "```cpp\nvoid conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0", "completion": "```cpp\nvoid conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0", "completion": "```cpp\nvoid conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_1", "completion": "```cpp\nvoid load_modify_store(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        int tmp1 = (src[i] * scale) >> 3;\n        int tmp2 = (src[i] * scale) << 3;\n        dst[i] = (src[i] * scale + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1", "completion": "```cpp\nvoid load_modify_store(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        int tmp1 = (src[i] * scale) >> 3;\n        int tmp2 = (src[i] * scale) << 3;\n        dst[i] = (src[i] * scale + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1", "completion": "```cpp\nvoid load_modify_store(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        int tmp1 = (src[i] * scale) >> 3;\n        int tmp2 = (src[i] * scale) << 3;\n        dst[i] = (src[i] * scale + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1", "completion": "```cpp\nvoid load_modify_store(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        int tmp1 = (src[i] * scale) >> 3;\n        int tmp2 = (src[i] * scale) << 3;\n        dst[i] = (src[i] * scale + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1", "completion": "```c\nvoid load_modify_store(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        int tmp1 = (src[i] * scale) >> 3;\n        int tmp2 = (src[i] * scale) << 3;\n        dst[i] = (src[i] * scale + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_2", "completion": "```cpp\nvoid strided_load_store(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; ++r) {\n        dst[r] = src[r * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2", "completion": "```cpp\nvoid strided_load_store(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; ++r) {\n        dst[r] = src[r * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2", "completion": "```cpp\nvoid strided_load_store(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; ++r) {\n        dst[r] = src[r * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2", "completion": "```cpp\nvoid strided_load_store(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; ++r) {\n        dst[r] = src[r * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2", "completion": "```cpp\nvoid strided_load_store(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; ++r) {\n        dst[r] = src[r * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_3", "completion": "```cpp\nvoid indexed_access(const float *src, const int *indices, float *dst, size_t length) {\n    // Gather operation: copy values from src to dst using indices as lookups\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = src[indices[i]];\n    }\n\n    // Scatter operation: copy values from src to dst using indices as write locations\n    for (size_t i = 0; i < length; ++i) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3", "completion": "```cpp\nvoid indexed_access(const float *src, const int *indices, float *dst, size_t length) {\n    // Gather operation: copy values from src to dst using indices as lookups\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = src[indices[i]];\n    }\n\n    // Scatter operation: copy values from src to dst using indices as write locations\n    for (size_t i = 0; i < length; ++i) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3", "completion": "```cpp\nvoid indexed_access(const float *src, const int *indices, float *dst, size_t length) {\n    // Gather operation: copy values from src to dst using indices as lookups\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = src[indices[i]];\n    }\n\n    // Scatter operation: copy values from src to dst using indices as write locations\n    for (size_t i = 0; i < length; ++i) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3", "completion": "```cpp\nvoid indexed_access(const float *src, const int *indices, float *dst, size_t length) {\n    // Gather operation: copy values from src to dst using indices as lookups\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = src[indices[i]];\n    }\n\n    // Scatter operation: copy values from src to dst using indices as write locations\n    for (size_t i = 0; i < length; ++i) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3", "completion": "```cpp\nvoid indexed_access(const float *src, const int *indices, float *dst, size_t length) {\n    // Gather operation\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = src[indices[i]];\n    }\n\n    // Scatter operation\n    for (size_t i = 0; i < length; ++i) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_4", "completion": "```c\nvoid range_reverse(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start < end) {\n        int16_t temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n```"}
{"task_id": "SimdBench_4", "completion": "```c\nvoid range_reverse(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start < end) {\n        int16_t temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n```"}
{"task_id": "SimdBench_4", "completion": "```c\n#include <stdint.h>\n\nvoid range_reverse(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start < end) {\n        int16_t temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n```"}
{"task_id": "SimdBench_4", "completion": "```c\nvoid range_reverse(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start < end) {\n        int16_t temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n```"}
{"task_id": "SimdBench_4", "completion": "```c\nvoid range_reverse(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start < end) {\n        int16_t temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n```"}
{"task_id": "SimdBench_5", "completion": "```cpp\nvoid extract_tensor_slice(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            slice[i * dim2 + j] = tensor[(i * dim2 * dim3) + (j * dim3) + slice_idx];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5", "completion": "```cpp\nvoid extract_tensor_slice(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            slice[i * dim2 + j] = tensor[(i * dim2 * dim3) + (j * dim3) + slice_idx];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5", "completion": "```cpp\nvoid extract_tensor_slice(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            slice[i * dim2 + j] = tensor[(i * dim2 * dim3) + (j * dim3) + slice_idx];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5", "completion": "```cpp\nvoid extract_tensor_slice(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            slice[i * dim2 + j] = tensor[(i * dim2 * dim3) + (j * dim3) + slice_idx];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5", "completion": "```cpp\nvoid extract_tensor_slice(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            slice[i * dim2 + j] = tensor[(i * dim2 * dim3) + (j * dim3) + slice_idx];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6", "completion": "```c\nvoid blocked_matrix_transpose(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t block_rows = (i + block_size > rows) ? (rows - i) : block_size;\n            size_t block_cols = (j + block_size > cols) ? (cols - j) : block_size;\n\n            for (size_t bi = 0; bi < block_rows; ++bi) {\n                for (size_t bj = 0; bj < block_cols; ++bj) {\n                    dst[(j + bj) * rows + (i + bi)] = src[(i + bi) * cols + (j + bj)];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6", "completion": "```c\nvoid blocked_matrix_transpose(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t block_rows = (i + block_size > rows) ? (rows - i) : block_size;\n            size_t block_cols = (j + block_size > cols) ? (cols - j) : block_size;\n\n            for (size_t bi = 0; bi < block_rows; ++bi) {\n                for (size_t bj = 0; bj < block_cols; ++bj) {\n                    dst[(j + bj) * rows + (i + bi)] = src[(i + bi) * cols + (j + bj)];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6", "completion": "```c\nvoid blocked_matrix_transpose(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t block_rows = (i + block_size > rows) ? (rows - i) : block_size;\n            size_t block_cols = (j + block_size > cols) ? (cols - j) : block_size;\n\n            for (size_t bi = 0; bi < block_rows; ++bi) {\n                for (size_t bj = 0; bj < block_cols; ++bj) {\n                    dst[(j + bj) * rows + (i + bi)] = src[(i + bi) * cols + (j + bj)];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6", "completion": "```c\nvoid blocked_matrix_transpose(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t block_rows = (i + block_size > rows) ? (rows - i) : block_size;\n            size_t block_cols = (j + block_size > cols) ? (cols - j) : block_size;\n\n            for (size_t bi = 0; bi < block_rows; ++bi) {\n                for (size_t bj = 0; bj < block_cols; ++bj) {\n                    dst[(j + bj) * rows + (i + bi)] = src[(i + bi) * cols + (j + bj)];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6", "completion": "```c\nvoid blocked_matrix_transpose(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t block_rows = (i + block_size > rows) ? (rows - i) : block_size;\n            size_t block_cols = (j + block_size > cols) ? (cols - j) : block_size;\n\n            for (size_t bi = 0; bi < block_rows; ++bi) {\n                for (size_t bj = 0; bj < block_cols; ++bj) {\n                    dst[(j + bj) * rows + (i + bi)] = src[(i + bi) * cols + (j + bj)];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_7", "completion": "```c\nfloat diagonal_sum_3d(const float *array, size_t dim) {\n    float sum = 0.0f;\n    for (size_t i = 0; i < dim; ++i) {\n        sum += array[i * dim * dim + i * dim + i];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7", "completion": "```c\nfloat diagonal_sum_3d(const float *array, size_t dim) {\n    float sum = 0.0f;\n    for (size_t i = 0; i < dim; ++i) {\n        sum += array[i * dim * dim + i * dim + i];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7", "completion": "```c\nfloat diagonal_sum_3d(const float *array, size_t dim) {\n    float sum = 0.0f;\n    for (size_t i = 0; i < dim; ++i) {\n        sum += array[i * dim * dim + i * dim + i];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7", "completion": "```c\nfloat diagonal_sum_3d(const float *array, size_t dim) {\n    float sum = 0.0f;\n    for (size_t i = 0; i < dim; ++i) {\n        sum += array[i * dim * dim + i * dim + i];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7", "completion": "```c\nfloat diagonal_sum_3d(const float *array, size_t dim) {\n    float sum = 0.0f;\n    for (size_t i = 0; i < dim; ++i) {\n        sum += array[i * dim * dim + i * dim + i];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_8", "completion": "```cpp\nvoid conditional_scale(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    for (size_t i = 0; i < rows * cols; ++i) {\n        if (src[i] > threshold) {\n            dst[i] = src[i] * scale;\n        } else {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8", "completion": "```cpp\nvoid conditional_scale(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    for (size_t i = 0; i < rows * cols; ++i) {\n        if (src[i] > threshold) {\n            dst[i] = src[i] * scale;\n        } else {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8", "completion": "```cpp\nvoid conditional_scale(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    for (size_t i = 0; i < rows * cols; ++i) {\n        if (src[i] > threshold) {\n            dst[i] = src[i] * scale;\n        } else {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8", "completion": "```cpp\nvoid conditional_scale(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    for (size_t i = 0; i < rows * cols; ++i) {\n        if (src[i] > threshold) {\n            dst[i] = src[i] * scale;\n        } else {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8", "completion": "```cpp\nvoid conditional_scale(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    for (size_t i = 0; i < rows * cols; ++i) {\n        if (src[i] > threshold) {\n            dst[i] = src[i] * scale;\n        } else {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9", "completion": "```c\nvoid reorder_matrix_rows(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; ++i) {\n        size_t src_row_index = indices[i] * cols;\n        size_t dst_row_index = i * cols;\n        for (size_t j = 0; j < cols; ++j) {\n            dst[dst_row_index + j] = src[src_row_index + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9", "completion": "```c\nvoid reorder_matrix_rows(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; ++i) {\n        size_t src_row_index = indices[i];\n        for (size_t j = 0; j < cols; ++j) {\n            dst[i * cols + j] = src[src_row_index * cols + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9", "completion": "```c\nvoid reorder_matrix_rows(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; ++i) {\n        size_t src_row_index = indices[i] * cols;\n        size_t dst_row_index = i * cols;\n        for (size_t j = 0; j < cols; ++j) {\n            dst[dst_row_index + j] = src[src_row_index + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9", "completion": "```c\nvoid reorder_matrix_rows(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; ++i) {\n        size_t src_row = indices[i];\n        for (size_t j = 0; j < cols; ++j) {\n            dst[i * cols + j] = src[src_row * cols + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9", "completion": "```c\nvoid reorder_matrix_rows(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; ++i) {\n        size_t src_row_index = indices[i];\n        for (size_t j = 0; j < cols; ++j) {\n            dst[i * cols + j] = src[src_row_index * cols + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_10", "completion": "```c\nvoid vector_vector_add(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10", "completion": "```c\nvoid vector_vector_add(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10", "completion": "```c\nvoid vector_vector_add(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10", "completion": "```c\nvoid vector_vector_add(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10", "completion": "```c\nvoid vector_vector_add(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int64_t result = (src1[i] + src2[i] + scalar);\n        dst[i] = result / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_11", "completion": "```c\nint vector_even_min(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    int min_even = -1;\n    for (size_t i = 0; i < length; i++) {\n        if (src[i] % 2 == 0) { // Check if the element is even\n            if (min_even == -1 || src[i] < min_even) {\n                min_even = src[i];\n            }\n        }\n    }\n    return min_even;\n}\n```"}
{"task_id": "SimdBench_11", "completion": "```c\nint vector_even_min(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    int min_even = 0x7FFFFFFF; // Initialize to maximum 32-bit integer value\n    int found_even = 0;\n\n    for (size_t i = 0; i < length; i++) {\n        if (src[i] % 2 == 0) { // Check if the element is even\n            if (src[i] < min_even) {\n                min_even = src[i];\n                found_even = 1;\n            }\n        }\n    }\n\n    return found_even ? min_even : -1;\n}\n```"}
{"task_id": "SimdBench_11", "completion": "```c\nint vector_even_min(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    int min_even = -1;\n    for (size_t i = 0; i < length; i++) {\n        if (src[i] % 2 == 0) {\n            if (min_even == -1 || src[i] < min_even) {\n                min_even = src[i];\n            }\n        }\n    }\n    return min_even;\n}\n```"}
{"task_id": "SimdBench_11", "completion": "```c\nint vector_even_min(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    int min_even = 0;\n    int found_even = 0;\n\n    for (size_t i = 0; i < length; i++) {\n        if (src[i] % 2 == 0) { // Check if the element is even\n            if (!found_even || src[i] < min_even) {\n                min_even = src[i];\n                found_even = 1;\n            }\n        }\n    }\n\n    return found_even ? min_even : -1;\n}\n```"}
{"task_id": "SimdBench_11", "completion": "```c\nint vector_even_min(const int *src, size_t length){\n    if (length == 0) return -1;\n    \n    int min_even = -1;\n    for (size_t i = 0; i < length; i++) {\n        if (src[i] % 2 == 0) { // Check if the element is even\n            if (min_even == -1 || src[i] < min_even) {\n                min_even = src[i];\n            }\n        }\n    }\n    return min_even;\n}\n```"}
{"task_id": "SimdBench_12", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid mixed_right_shift(const int *src, int *dst, uint8_t shift, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        // Arithmetic right shift\n        int arithmetic_shift = src[i] >> shift;\n\n        // Logical right shift (convert to unsigned, shift, then cast back to signed)\n        int logical_shift = (int)((uint32_t)src[i] >> shift);\n\n        // Add the results and store in the destination array\n        dst[i] = arithmetic_shift + logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid mixed_right_shift(const int *src, int *dst, uint8_t shift, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        // Arithmetic right shift\n        int arithmetic_shift = src[i] >> shift;\n\n        // Logical right shift\n        uint32_t unsigned_value = (uint32_t)src[i];\n        int logical_shift = (int)(unsigned_value >> shift);\n\n        // Add the results and store in the destination array\n        dst[i] = arithmetic_shift + logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid mixed_right_shift(const int *src, int *dst, uint8_t shift, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int arithmetic_shift = src[i] >> shift;\n        int logical_shift = (int)((uint32_t)src[i] >> shift);\n        dst[i] = arithmetic_shift + logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid mixed_right_shift(const int *src, int *dst, uint8_t shift, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        int arithmetic_shift = src[i] >> shift;\n        int logical_shift = (int)((uint32_t)src[i] >> shift);\n        dst[i] = arithmetic_shift + logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid mixed_right_shift(const int *src, int *dst, uint8_t shift, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        int arithmetic_shift = src[i] >> shift;\n        int logical_shift = (int)((uint32_t)src[i] >> shift);\n        dst[i] = arithmetic_shift + logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_13", "completion": "```c\n#include <stdint.h>\n\nint64_t matrix_sum(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < rows * cols; ++i) {\n        sum += matrix[i];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13", "completion": "```c\n#include <stdint.h>\n\nint64_t matrix_sum(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < rows * cols; ++i) {\n        sum += matrix[i];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13", "completion": "```c\n#include <stdint.h>\n\nint64_t matrix_sum(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < rows * cols; ++i) {\n        sum += matrix[i];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13", "completion": "```c\n#include <stdint.h>\n\nint64_t matrix_sum(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < rows * cols; ++i) {\n        sum += matrix[i];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13", "completion": "```c\n#include <stdint.h>\n\nint64_t matrix_sum(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < rows * cols; ++i) {\n        sum += matrix[i];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_14", "completion": "```c\nsize_t argmax(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n    for (size_t i = 1; i < length; ++i) {\n        if (src[i] > max_value) {\n            max_value = src[i];\n            max_index = i;\n        }\n    }\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14", "completion": "```c\nsize_t argmax(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n    \n    size_t max_index = 0;\n    int8_t max_value = src[0];\n    \n    for (size_t i = 1; i < length; ++i) {\n        if (src[i] > max_value) {\n            max_value = src[i];\n            max_index = i;\n        }\n    }\n    \n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14", "completion": "```c\nsize_t argmax(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n    \n    size_t max_index = 0;\n    int8_t max_value = src[0];\n    \n    for (size_t i = 1; i < length; ++i) {\n        if (src[i] > max_value) {\n            max_value = src[i];\n            max_index = i;\n        }\n    }\n    \n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14", "completion": "```c\nsize_t argmax(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n\n    for (size_t i = 1; i < length; ++i) {\n        if (src[i] > max_value) {\n            max_value = src[i];\n            max_index = i;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14", "completion": "```c\nsize_t argmax(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n    \n    size_t max_index = 0;\n    int8_t max_value = src[0];\n    \n    for (size_t i = 1; i < length; ++i) {\n        if (src[i] > max_value) {\n            max_value = src[i];\n            max_index = i;\n        }\n    }\n    \n    return max_index;\n}\n```"}
{"task_id": "SimdBench_15", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid vector_blend(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if ((i & mask) != 0) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid vector_blend(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if ((i & mask) != 0) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid vector_blend(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if ((i & mask) != 0) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid vector_blend(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if ((i & mask) != 0) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid vector_blend(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if ((i & mask) != 0) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_16", "completion": "```c\n#include <stdint.h>\n\nvoid population_count(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t value = src[i];\n        uint32_t count = 0;\n        while (value) {\n            count += value & 1;\n            value >>= 1;\n        }\n        dst[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_16", "completion": "```c\n#include <stdint.h>\n\nvoid population_count(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t num = src[i];\n        uint32_t count = 0;\n        while (num) {\n            count += num & 1;\n            num >>= 1;\n        }\n        dst[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_16", "completion": "```c\n#include <stdint.h>\n\nvoid population_count(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        uint32_t value = src[i];\n        uint32_t count = 0;\n        while (value) {\n            count += value & 1;\n            value >>= 1;\n        }\n        dst[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_16", "completion": "```c\n#include <stdint.h>\n\nvoid population_count(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t value = src[i];\n        uint32_t count = 0;\n        while (value) {\n            count += value & 1;\n            value >>= 1;\n        }\n        dst[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_16", "completion": "```c\n#include <stdint.h>\n\nvoid population_count(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t value = src[i];\n        uint32_t count = 0;\n        while (value) {\n            count += value & 1;\n            value >>= 1;\n        }\n        dst[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_17", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n#include <limits.h>\n\nvoid saturating_add(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        uint32_t result = (uint32_t)src1[i] + (uint32_t)src2[i];\n        if (result > UINT16_MAX) {\n            dst[i] = UINT16_MAX;\n        } else {\n            dst[i] = (uint16_t)result;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_17", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n#include <limits.h>\n\nvoid saturating_add(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        uint32_t result = (uint32_t)src1[i] + (uint32_t)src2[i];\n        if (result > UINT16_MAX) {\n            dst[i] = UINT16_MAX;\n        } else {\n            dst[i] = (uint16_t)result;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_17", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n#include <limits.h>\n\nvoid saturating_add(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        uint32_t result = (uint32_t)src1[i] + (uint32_t)src2[i];\n        if (result > UINT16_MAX) {\n            dst[i] = UINT16_MAX;\n        } else {\n            dst[i] = (uint16_t)result;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_17", "completion": "```c\n#include <stdint.h>\n#include <limits.h>\n\nvoid saturating_add(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        uint32_t result = (uint32_t)src1[i] + (uint32_t)src2[i];\n        if (result > UINT16_MAX) {\n            dst[i] = UINT16_MAX;\n        } else {\n            dst[i] = (uint16_t)result;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_17", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n#include <limits.h>\n\nvoid saturating_add(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        uint32_t result = (uint32_t)src1[i] + (uint32_t)src2[i];\n        if (result > UINT16_MAX) {\n            dst[i] = UINT16_MAX;\n        } else {\n            dst[i] = (uint16_t)result;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18", "completion": "```cpp\nvoid range_matrix_mul(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                double a_ik = A[i * n + k];\n                double b_kj = B[k * p + j];\n                if (a_ik >= -100.0 && a_ik <= 100.0 && b_kj >= -100.0 && b_kj <= 100.0) {\n                    sum += a_ik * b_kj;\n                }\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18", "completion": "```cpp\nvoid range_matrix_mul(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                double a_ik = A[i * n + k];\n                double b_kj = B[k * p + j];\n                if (a_ik >= -100.0 && a_ik <= 100.0 && b_kj >= -100.0 && b_kj <= 100.0) {\n                    sum += a_ik * b_kj;\n                }\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18", "completion": "```cpp\nvoid range_matrix_mul(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                double a_ik = A[i * n + k];\n                double b_kj = B[k * p + j];\n                if (a_ik >= -100.0 && a_ik <= 100.0 && b_kj >= -100.0 && b_kj <= 100.0) {\n                    sum += a_ik * b_kj;\n                }\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18", "completion": "```cpp\nvoid range_matrix_mul(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                double a_ik = A[i * n + k];\n                double b_kj = B[k * p + j];\n                if (a_ik >= -100.0 && a_ik <= 100.0 && b_kj >= -100.0 && b_kj <= 100.0) {\n                    sum += a_ik * b_kj;\n                }\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18", "completion": "```cpp\nvoid range_matrix_mul(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                double a_ik = A[i * n + k];\n                double b_kj = B[k * p + j];\n                if (a_ik >= -100.0 && a_ik <= 100.0 && b_kj >= -100.0 && b_kj <= 100.0) {\n                    sum += a_ik * b_kj;\n                }\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19", "completion": "```cpp\nvoid tensor_add_3d(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; ++i) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19", "completion": "```cpp\nvoid tensor_add_3d(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; ++i) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19", "completion": "```cpp\nvoid tensor_add_3d(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; ++i) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19", "completion": "```cpp\nvoid tensor_add_3d(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; ++i) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19", "completion": "```cpp\nvoid tensor_add_3d(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; ++i) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_20", "completion": "```cpp\n#include <cmath>\n\nvoid vector_add_round_nearest(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = std::round(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20", "completion": "```cpp\n#include <cmath>\n\nvoid vector_add_round_nearest(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = std::round(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20", "completion": "```cpp\n#include <cmath>\n\nvoid vector_add_round_nearest(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = std::round(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20", "completion": "```cpp\nvoid vector_add_round_nearest(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = nearbyintf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20", "completion": "```cpp\n#include <cmath>\n\nvoid vector_add_round_nearest(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = std::round(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_21", "completion": "```cpp\n#include <cmath>\n\nvoid vector_mul_round_up(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (i % 2 == 0 && std::fabs(src1[i] - src2[i]) <= 50.0f) {\n            dst[i] = std::ceil(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21", "completion": "```cpp\n#include <cmath>\n\nvoid vector_mul_round_up(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (i % 2 == 0 && std::fabs(src1[i] - src2[i]) <= 50.0f) {\n            dst[i] = std::ceil(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21", "completion": "```cpp\n#include <cmath>\n\nvoid vector_mul_round_up(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (i % 2 == 0 && std::fabs(src1[i] - src2[i]) <= 50.0f) {\n            dst[i] = std::ceil(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21", "completion": "```cpp\n#include <cmath>\n\nvoid vector_mul_round_up(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (i % 2 == 0 && std::fabs(src1[i] - src2[i]) <= 50.0f) {\n            dst[i] = std::ceil(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21", "completion": "```cpp\n#include <cmath>\n\nvoid vector_mul_round_up(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (i % 2 == 0 && std::fabs(src1[i] - src2[i]) <= 50.0f) {\n            dst[i] = std::ceil(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_22", "completion": "```cpp\nvoid matrix_scalar_mul(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m * n; ++i) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22", "completion": "```cpp\nvoid matrix_scalar_mul(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m * n; ++i) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22", "completion": "```cpp\nvoid matrix_scalar_mul(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m * n; ++i) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22", "completion": "```cpp\nvoid matrix_scalar_mul(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m * n; ++i) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22", "completion": "```cpp\nvoid matrix_scalar_mul(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m * n; ++i) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_23", "completion": "```cpp\n#include <cmath>\n\nvoid matrix_normalize_rows(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float norm = 0.0f;\n        for (size_t j = 0; j < n; ++j) {\n            float val = mat[i * n + j];\n            norm += val * val;\n        }\n        norm = std::sqrt(norm);\n        if (norm != 0.0f) {\n            for (size_t j = 0; j < n; ++j) {\n                mat[i * n + j] /= norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23", "completion": "```cpp\n#include <cmath>\n\nvoid matrix_normalize_rows(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float norm = 0.0f;\n        for (size_t j = 0; j < n; ++j) {\n            float val = mat[i * n + j];\n            norm += val * val;\n        }\n        norm = std::sqrt(norm);\n        if (norm != 0.0f) {\n            for (size_t j = 0; j < n; ++j) {\n                mat[i * n + j] /= norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23", "completion": "```cpp\n#include <cmath>\n\nvoid matrix_normalize_rows(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float norm = 0.0f;\n        for (size_t j = 0; j < n; ++j) {\n            float val = mat[i * n + j];\n            norm += val * val;\n        }\n        norm = std::sqrt(norm);\n        if (norm != 0.0f) {\n            for (size_t j = 0; j < n; ++j) {\n                mat[i * n + j] /= norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23", "completion": "```cpp\n#include <cmath>\n\nvoid matrix_normalize_rows(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float norm = 0.0f;\n        for (size_t j = 0; j < n; ++j) {\n            float val = mat[i * n + j];\n            norm += val * val;\n        }\n        norm = std::sqrt(norm);\n        if (norm > 0.0f) { // Avoid division by zero\n            for (size_t j = 0; j < n; ++j) {\n                mat[i * n + j] /= norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23", "completion": "```c\n#include <math.h>\n\nvoid matrix_normalize_rows(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float norm = 0.0f;\n        for (size_t j = 0; j < n; ++j) {\n            float val = mat[i * n + j];\n            norm += val * val;\n        }\n        norm = sqrtf(norm);\n        if (norm != 0.0f) {\n            for (size_t j = 0; j < n; ++j) {\n                mat[i * n + j] /= norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24", "completion": "```cpp\nvoid matrix_mul_round_int(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = static_cast<double>(static_cast<int>(sum + (sum >= 0 ? 0.5 : -0.5)));\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24", "completion": "```cpp\nvoid matrix_mul_round_int(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = static_cast<double>(static_cast<int>(sum + (sum >= 0 ? 0.5 : -0.5)));\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24", "completion": "```cpp\nvoid matrix_mul_round_int(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = static_cast<double>(static_cast<int>(sum + 0.5));\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24", "completion": "```cpp\nvoid matrix_mul_round_int(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = static_cast<double>(static_cast<int>(sum + (sum >= 0 ? 0.5 : -0.5)));\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24", "completion": "```cpp\nvoid matrix_mul_round_int(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = static_cast<double>(static_cast<int>(sum + 0.5));\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25", "completion": "```cpp\n#include <cmath>\n\nvoid matrix_transpose_round_quarter(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t r = 0; r < rows; ++r) {\n        for (size_t c = 0; c < cols; ++c) {\n            // Access element in the source matrix\n            float value = src[r * cols + c];\n            \n            // Round to the nearest quarter (0.25)\n            float rounded_value = std::round(value * 4.0f) / 4.0f;\n            \n            // Store in the transposed position in the destination matrix\n            dst[c * rows + r] = rounded_value;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25", "completion": "```cpp\n#include <cmath>\n\nvoid matrix_transpose_round_quarter(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t r = 0; r < rows; ++r) {\n        for (size_t c = 0; c < cols; ++c) {\n            // Transpose: Access src[r * cols + c] and store in dst[c * rows + r]\n            float value = src[r * cols + c];\n            // Round to the nearest quarter\n            float rounded_value = std::round(value * 4.0f) / 4.0f;\n            dst[c * rows + r] = rounded_value;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25", "completion": "```cpp\n#include <cmath>\n\nvoid matrix_transpose_round_quarter(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t r = 0; r < rows; ++r) {\n        for (size_t c = 0; c < cols; ++c) {\n            // Transpose: access src[r * cols + c] and store in dst[c * rows + r]\n            float value = src[r * cols + c];\n            // Round to the nearest quarter\n            float rounded_value = std::round(value * 4.0f) / 4.0f;\n            dst[c * rows + r] = rounded_value;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25", "completion": "```cpp\n#include <cmath>\n\nvoid matrix_transpose_round_quarter(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t r = 0; r < rows; ++r) {\n        for (size_t c = 0; c < cols; ++c) {\n            // Transpose: access src[r * cols + c] and store in dst[c * rows + r]\n            float value = src[r * cols + c];\n            // Round to the nearest quarter\n            float rounded_value = std::round(value * 4.0f) / 4.0f;\n            dst[c * rows + r] = rounded_value;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25", "completion": "```cpp\n#include <cmath>\n\nvoid matrix_transpose_round_quarter(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t r = 0; r < rows; ++r) {\n        for (size_t c = 0; c < cols; ++c) {\n            // Access element in the source matrix\n            float value = src[r * cols + c];\n            \n            // Round to the nearest quarter (0.25)\n            float rounded_value = std::round(value * 4.0f) / 4.0f;\n            \n            // Store in the transposed position in the destination matrix\n            dst[c * rows + r] = rounded_value;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26", "completion": "```cpp\nvoid tensor3d_sub_round_zero(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; ++i) {\n        float result = tensor1[i] - tensor2[i];\n        dst[i] = (result > 0.0f) ? floorf(result) : ceilf(result);\n    }\n}\n```"}
{"task_id": "SimdBench_26", "completion": "```cpp\nvoid tensor3d_sub_round_zero(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; ++i) {\n        float result = tensor1[i] - tensor2[i];\n        dst[i] = (result > 0.0f) ? floorf(result) : ceilf(result);\n    }\n}\n```"}
{"task_id": "SimdBench_26", "completion": "```cpp\nvoid tensor3d_sub_round_zero(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; ++i) {\n        float result = tensor1[i] - tensor2[i];\n        dst[i] = (result > 0.0f) ? floorf(result) : ceilf(result);\n    }\n}\n```"}
{"task_id": "SimdBench_26", "completion": "```cpp\nvoid tensor3d_sub_round_zero(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; ++i) {\n        float result = tensor1[i] - tensor2[i];\n        dst[i] = (result > 0.0f) ? floorf(result) : ceilf(result);\n    }\n}\n```"}
{"task_id": "SimdBench_26", "completion": "```cpp\nvoid tensor3d_sub_round_zero(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; ++i) {\n        dst[i] = (float)((int)(tensor1[i] - tensor2[i]));\n    }\n}\n```"}
{"task_id": "SimdBench_27", "completion": "```cpp\nvoid matrix_hadamard_product(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m * n; ++i) {\n        dst[i] = mat1[i] * mat2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_27", "completion": "```cpp\nvoid matrix_hadamard_product(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m * n; ++i) {\n        dst[i] = mat1[i] * mat2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_27", "completion": "```cpp\nvoid matrix_hadamard_product(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m * n; ++i) {\n        dst[i] = mat1[i] * mat2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_27", "completion": "```cpp\nvoid matrix_hadamard_product(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m * n; ++i) {\n        dst[i] = mat1[i] * mat2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_27", "completion": "```cpp\nvoid matrix_hadamard_product(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m * n; ++i) {\n        dst[i] = mat1[i] * mat2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_28", "completion": "```cpp\nvoid matrix_vector_mul(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float sum = 0.0f;\n        for (size_t j = 0; j < n; ++j) {\n            sum += mat[i * n + j] * vec[j];\n        }\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28", "completion": "```cpp\nvoid matrix_vector_mul(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float sum = 0.0f;\n        for (size_t j = 0; j < n; ++j) {\n            sum += mat[i * n + j] * vec[j];\n        }\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28", "completion": "```cpp\nvoid matrix_vector_mul(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float sum = 0.0f;\n        for (size_t j = 0; j < n; ++j) {\n            sum += mat[i * n + j] * vec[j];\n        }\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28", "completion": "```cpp\nvoid matrix_vector_mul(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float sum = 0.0f;\n        for (size_t j = 0; j < n; ++j) {\n            sum += mat[i * n + j] * vec[j];\n        }\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28", "completion": "```cpp\nvoid matrix_vector_mul(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float sum = 0.0f;\n        for (size_t j = 0; j < n; ++j) {\n            sum += mat[i * n + j] * vec[j];\n        }\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_29", "completion": "```cpp\ndouble matrix_average(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    size_t total_elements = m * n;\n    for (size_t i = 0; i < total_elements; ++i) {\n        sum += mat[i];\n    }\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29", "completion": "```cpp\ndouble matrix_average(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    size_t total_elements = m * n;\n    for (size_t i = 0; i < total_elements; ++i) {\n        sum += mat[i];\n    }\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29", "completion": "```cpp\ndouble matrix_average(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    size_t total_elements = m * n;\n    for (size_t i = 0; i < total_elements; ++i) {\n        sum += mat[i];\n    }\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29", "completion": "```c\ndouble matrix_average(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    size_t total_elements = m * n;\n    for (size_t i = 0; i < total_elements; ++i) {\n        sum += mat[i];\n    }\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29", "completion": "```c\ndouble matrix_average(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    size_t total_elements = m * n;\n    for (size_t i = 0; i < total_elements; ++i) {\n        sum += mat[i];\n    }\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_30", "completion": "```cpp\nbool matrix_rows_sorted_verify(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool ascending = directions[i];\n        const int* row = matrix + i * cols;\n        bool sorted = true;\n\n        if (ascending) {\n            for (size_t j = 1; j < cols; ++j) {\n                if (row[j - 1] > row[j]) {\n                    sorted = false;\n                    break;\n                }\n            }\n        } else {\n            for (size_t j = 1; j < cols; ++j) {\n                if (row[j - 1] < row[j]) {\n                    sorted = false;\n                    break;\n                }\n            }\n        }\n\n        if (!sorted) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30", "completion": "```cpp\nbool matrix_rows_sorted_verify(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool ascending = directions[i];\n        const int* row = matrix + i * cols;\n        bool sorted = true;\n\n        if (ascending) {\n            for (size_t j = 1; j < cols; ++j) {\n                if (row[j - 1] > row[j]) {\n                    sorted = false;\n                    break;\n                }\n            }\n        } else {\n            for (size_t j = 1; j < cols; ++j) {\n                if (row[j - 1] < row[j]) {\n                    sorted = false;\n                    break;\n                }\n            }\n        }\n\n        if (!sorted) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30", "completion": "```cpp\nbool matrix_rows_sorted_verify(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool ascending = directions[i];\n        const int* row = matrix + i * cols;\n        for (size_t j = 1; j < cols; ++j) {\n            if (ascending) {\n                if (row[j - 1] > row[j]) {\n                    return false;\n                }\n            } else {\n                if (row[j - 1] < row[j]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30", "completion": "```cpp\nbool matrix_rows_sorted_verify(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool ascending = directions[i];\n        const int* row = matrix + i * cols;\n        for (size_t j = 1; j < cols; ++j) {\n            if (ascending) {\n                if (row[j - 1] > row[j]) {\n                    return false;\n                }\n            } else {\n                if (row[j - 1] < row[j]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30", "completion": "```cpp\nbool matrix_rows_sorted_verify(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool ascending = directions[i];\n        const int* row = matrix + i * cols;\n        for (size_t j = 1; j < cols; ++j) {\n            if (ascending) {\n                if (row[j - 1] > row[j]) {\n                    return false;\n                }\n            } else {\n                if (row[j - 1] < row[j]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_31", "completion": "```c\nvoid nearest_multiple(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = (src[i] / base) * base;\n    }\n}\n```"}
{"task_id": "SimdBench_31", "completion": "```c\nvoid nearest_multiple(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = (src[i] / base) * base;\n    }\n}\n```"}
{"task_id": "SimdBench_31", "completion": "```c\nvoid nearest_multiple(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = (src[i] / base) * base;\n    }\n}\n```"}
{"task_id": "SimdBench_31", "completion": "```c\nvoid nearest_multiple(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = (src[i] / base) * base;\n    }\n}\n```"}
{"task_id": "SimdBench_31", "completion": "```c\nvoid nearest_multiple(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = (src[i] / base) * base;\n    }\n}\n```"}
{"task_id": "SimdBench_32", "completion": "```cpp\nbool matrix_has_row(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool match = true;\n        for (size_t j = 0; j < cols; ++j) {\n            if (matrix[i * cols + j] != vector[j]) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32", "completion": "```cpp\nbool matrix_has_row(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool match = true;\n        for (size_t j = 0; j < cols; ++j) {\n            if (matrix[i * cols + j] != vector[j]) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32", "completion": "```cpp\nbool matrix_has_row(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool match = true;\n        for (size_t j = 0; j < cols; ++j) {\n            if (matrix[i * cols + j] != vector[j]) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32", "completion": "```cpp\nbool matrix_has_row(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool match = true;\n        for (size_t j = 0; j < cols; ++j) {\n            if (matrix[i * cols + j] != vector[j]) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32", "completion": "```cpp\nbool matrix_has_row(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool match = true;\n        for (size_t j = 0; j < cols; ++j) {\n            if (matrix[i * cols + j] != vector[j]) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_33", "completion": "```cpp\nsize_t tensor_4d_equal_count(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n    for (size_t i = 0; i < total_elements; ++i) {\n        if (A[i] == B[i]) {\n            ++equal_count;\n        }\n    }\n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_33", "completion": "```cpp\nsize_t tensor_4d_equal_count(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n    for (size_t i = 0; i < total_elements; ++i) {\n        if (A[i] == B[i]) {\n            ++equal_count;\n        }\n    }\n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_33", "completion": "```cpp\nsize_t tensor_4d_equal_count(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n    for (size_t i = 0; i < total_elements; ++i) {\n        if (A[i] == B[i]) {\n            ++equal_count;\n        }\n    }\n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_33", "completion": "```cpp\nsize_t tensor_4d_equal_count(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n    for (size_t i = 0; i < total_elements; ++i) {\n        if (A[i] == B[i]) {\n            ++equal_count;\n        }\n    }\n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_33", "completion": "```cpp\nsize_t tensor_4d_equal_count(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n    for (size_t i = 0; i < total_elements; ++i) {\n        if (A[i] == B[i]) {\n            ++equal_count;\n        }\n    }\n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_34", "completion": "```c\nvoid axm_abs(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; ++i) {\n        y[i] = llabs(a * x[i] - y[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_34", "completion": "```c\nvoid axm_abs(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; ++i) {\n        y[i] = llabs(a * x[i] - y[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_34", "completion": "```c\nvoid axm_abs(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; ++i) {\n        y[i] = llabs(a * x[i] - y[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_34", "completion": "```c\nvoid axm_abs(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; ++i) {\n        y[i] = llabs(a * x[i] - y[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_34", "completion": "```c\nvoid axm_abs(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; ++i) {\n        y[i] = llabs(a * x[i] - y[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_35", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    result.min_num = vec[0];\n    result.max_num = vec[0];\n\n    for (size_t i = 1; i < length; ++i) {\n        if (vec[i] < result.min_num) {\n            result.min_num = vec[i];\n        }\n        if (vec[i] > result.max_num) {\n            result.max_num = vec[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_35", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    result.min_num = vec[0];\n    result.max_num = vec[0];\n\n    for (size_t i = 1; i < length; ++i) {\n        if (vec[i] < result.min_num) {\n            result.min_num = vec[i];\n        }\n        if (vec[i] > result.max_num) {\n            result.max_num = vec[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_35", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    result.min_num = vec[0];\n    result.max_num = vec[0];\n\n    for (size_t i = 1; i < length; ++i) {\n        if (vec[i] < result.min_num) {\n            result.min_num = vec[i];\n        }\n        if (vec[i] > result.max_num) {\n            result.max_num = vec[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_35", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    result.min_num = vec[0];\n    result.max_num = vec[0];\n\n    for (size_t i = 1; i < length; ++i) {\n        if (vec[i] < result.min_num) {\n            result.min_num = vec[i];\n        }\n        if (vec[i] > result.max_num) {\n            result.max_num = vec[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_35", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    result.min_num = vec[0];\n    result.max_num = vec[0];\n\n    for (size_t i = 1; i < length; ++i) {\n        if (vec[i] < result.min_num) {\n            result.min_num = vec[i];\n        }\n        if (vec[i] > result.max_num) {\n            result.max_num = vec[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_36", "completion": "```cpp\nbool matrix_rows_strictly_increasing(const int* matrix, size_t rows, size_t cols) {\n    if (matrix == nullptr || rows == 0 || cols == 0) {\n        return false;\n    }\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 1; j < cols; ++j) {\n            if (matrix[i * cols + j] <= matrix[i * cols + j - 1]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_36", "completion": "```cpp\nbool matrix_rows_strictly_increasing(const int* matrix, size_t rows, size_t cols) {\n    if (matrix == nullptr || rows == 0 || cols == 0) {\n        return false;\n    }\n    \n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 1; j < cols; ++j) {\n            if (matrix[i * cols + j] <= matrix[i * cols + j - 1]) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_36", "completion": "```cpp\nbool matrix_rows_strictly_increasing(const int* matrix, size_t rows, size_t cols) {\n    if (matrix == nullptr || rows == 0 || cols == 0) {\n        return false;\n    }\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 1; j < cols; ++j) {\n            if (matrix[i * cols + j] <= matrix[i * cols + j - 1]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_36", "completion": "```cpp\nbool matrix_rows_strictly_increasing(const int* matrix, size_t rows, size_t cols) {\n    if (matrix == nullptr || rows == 0 || cols == 0) {\n        return false;\n    }\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 1; j < cols; ++j) {\n            if (matrix[i * cols + j] <= matrix[i * cols + j - 1]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_36", "completion": "```c\nbool matrix_rows_strictly_increasing(const int* matrix, size_t rows, size_t cols) {\n    if (matrix == NULL || rows == 0 || cols == 0) {\n        return false;\n    }\n    \n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 1; j < cols; ++j) {\n            if (matrix[i * cols + j] <= matrix[i * cols + j - 1]) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_37", "completion": "```cpp\nbool matrix_blocks_equal(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t block_rows = rows / block_size;\n    size_t block_cols = cols / block_size;\n\n    for (size_t i = 0; i < block_rows; ++i) {\n        for (size_t j = 0; j < block_cols; ++j) {\n            for (size_t r = 0; r < block_size; ++r) {\n                for (size_t c = 0; c < block_size; ++c) {\n                    size_t current_row = i * block_size + r;\n                    size_t current_col = j * block_size + c;\n                    size_t first_row = r;\n                    size_t first_col = c;\n\n                    if (matrix[current_row * cols + current_col] != matrix[first_row * cols + first_col]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37", "completion": "```cpp\nbool matrix_blocks_equal(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t block_rows = rows / block_size;\n    size_t block_cols = cols / block_size;\n\n    for (size_t i = 0; i < block_rows; ++i) {\n        for (size_t j = 0; j < block_cols; ++j) {\n            for (size_t r = 0; r < block_size; ++r) {\n                for (size_t c = 0; c < block_size; ++c) {\n                    size_t current_row = i * block_size + r;\n                    size_t current_col = j * block_size + c;\n                    size_t first_row = r;\n                    size_t first_col = c;\n\n                    if (matrix[current_row * cols + current_col] != matrix[first_row * cols + first_col]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37", "completion": "```cpp\nbool matrix_blocks_equal(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t block_rows = rows / block_size;\n    size_t block_cols = cols / block_size;\n\n    for (size_t i = 0; i < block_rows; ++i) {\n        for (size_t j = 0; j < block_cols; ++j) {\n            for (size_t r = 0; r < block_size; ++r) {\n                for (size_t c = 0; c < block_size; ++c) {\n                    size_t current_row = i * block_size + r;\n                    size_t current_col = j * block_size + c;\n                    size_t first_row = r;\n                    size_t first_col = c;\n\n                    if (matrix[current_row * cols + current_col] != matrix[first_row * cols + first_col]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37", "completion": "```cpp\nbool matrix_blocks_equal(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t block_rows = rows / block_size;\n    size_t block_cols = cols / block_size;\n\n    for (size_t i = 0; i < block_rows; ++i) {\n        for (size_t j = 0; j < block_cols; ++j) {\n            for (size_t r = 0; r < block_size; ++r) {\n                for (size_t c = 0; c < block_size; ++c) {\n                    size_t current_row = i * block_size + r;\n                    size_t current_col = j * block_size + c;\n                    size_t first_row = r;\n                    size_t first_col = c;\n\n                    if (matrix[current_row * cols + current_col] != matrix[first_row * cols + first_col]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37", "completion": "```cpp\nbool matrix_blocks_equal(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t block_rows = rows / block_size;\n    size_t block_cols = cols / block_size;\n\n    for (size_t i = 0; i < block_rows; ++i) {\n        for (size_t j = 0; j < block_cols; ++j) {\n            for (size_t r = 0; r < block_size; ++r) {\n                for (size_t c = 0; c < block_size; ++c) {\n                    size_t current_row = i * block_size + r;\n                    size_t current_col = j * block_size + c;\n                    size_t first_block_row = r;\n                    size_t first_block_col = c;\n\n                    if (matrix[current_row * cols + current_col] != matrix[first_block_row * cols + first_block_col]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38", "completion": "```cpp\nbool vector_block_equal(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    size_t num_complete_blocks = length / block_size;\n    if (num_complete_blocks < 2) {\n        return false;\n    }\n\n    for (size_t i = 1; i < num_complete_blocks; ++i) {\n        for (size_t j = 0; j < block_size; ++j) {\n            if (std::fabs(vec[j] - vec[i * block_size + j]) > tolerance) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38", "completion": "```cpp\nbool vector_block_equal(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    size_t num_complete_blocks = length / block_size;\n    if (num_complete_blocks < 2) {\n        return false;\n    }\n\n    for (size_t i = 1; i < num_complete_blocks; ++i) {\n        for (size_t j = 0; j < block_size; ++j) {\n            if (std::fabs(vec[j] - vec[i * block_size + j]) > tolerance) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38", "completion": "```cpp\nbool vector_block_equal(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    size_t num_complete_blocks = length / block_size;\n    if (num_complete_blocks < 2) {\n        return false;\n    }\n\n    for (size_t i = 1; i < num_complete_blocks; ++i) {\n        for (size_t j = 0; j < block_size; ++j) {\n            if (std::fabs(vec[j] - vec[i * block_size + j]) > tolerance) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38", "completion": "```cpp\nbool vector_block_equal(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    size_t num_complete_blocks = length / block_size;\n\n    if (num_complete_blocks < 2) {\n        return false;\n    }\n\n    for (size_t i = 1; i < num_complete_blocks; ++i) {\n        for (size_t j = 0; j < block_size; ++j) {\n            if (std::fabs(vec[j] - vec[i * block_size + j]) > tolerance) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38", "completion": "```cpp\nbool vector_block_equal(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 2) {\n        return false;\n    }\n\n    for (size_t i = 1; i < num_blocks; ++i) {\n        for (size_t j = 0; j < block_size; ++j) {\n            if (std::fabs(vec[j] - vec[i * block_size + j]) > tolerance) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_39", "completion": "```cpp\n#include <cmath>\n\nvoid matrix_row_norm_compare(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        double norm = 0.0;\n        for (size_t j = 0; j < cols; ++j) {\n            double val = matrix[i * cols + j];\n            norm += val * val;\n        }\n        norm = std::sqrt(norm);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39", "completion": "```cpp\n#include <cmath>\n\nvoid matrix_row_norm_compare(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        double norm_sq = 0.0;\n        for (size_t j = 0; j < cols; ++j) {\n            double val = matrix[i * cols + j];\n            norm_sq += val * val;\n        }\n        double norm = std::sqrt(norm_sq);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39", "completion": "```cpp\n#include <cmath>\n\nvoid matrix_row_norm_compare(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        double norm_sq = 0.0;\n        for (size_t j = 0; j < cols; ++j) {\n            double val = matrix[i * cols + j];\n            norm_sq += val * val;\n        }\n        double norm = std::sqrt(norm_sq);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39", "completion": "```cpp\n#include <cmath>\n\nvoid matrix_row_norm_compare(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        double norm = 0.0;\n        for (size_t j = 0; j < cols; ++j) {\n            double val = matrix[i * cols + j];\n            norm += val * val;\n        }\n        norm = std::sqrt(norm);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39", "completion": "```cpp\n#include <cmath>\n\nvoid matrix_row_norm_compare(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        double norm = 0.0;\n        for (size_t j = 0; j < cols; ++j) {\n            double val = matrix[i * cols + j];\n            norm += val * val;\n        }\n        norm = std::sqrt(norm);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_40", "completion": "```cpp\nvoid tensor_bitwise_or(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40", "completion": "```cpp\nvoid tensor_bitwise_or(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40", "completion": "```cpp\nvoid tensor_bitwise_or(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40", "completion": "```cpp\nvoid tensor_bitwise_or(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40", "completion": "```cpp\nvoid tensor_bitwise_or(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_41", "completion": "```c\n#include <stdint.h>\n\nint64_t squarediff(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_of_squares = 0;\n    int64_t sum_of_products = 0;\n\n    for (size_t i = 0; i < length; ++i) {\n        sum_of_squares += (int64_t)A[i] * A[i] + (int64_t)B[i] * B[i];\n        sum_of_products += (int64_t)A[i] * B[i];\n    }\n\n    return sum_of_squares - 2 * sum_of_products;\n}\n```"}
{"task_id": "SimdBench_41", "completion": "```c\n#include <stdint.h>\n\nint64_t squarediff(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_of_squares = 0;\n    int64_t sum_of_products = 0;\n\n    for (size_t i = 0; i < length; ++i) {\n        sum_of_squares += (int64_t)A[i] * A[i] + (int64_t)B[i] * B[i];\n        sum_of_products += (int64_t)A[i] * B[i];\n    }\n\n    return sum_of_squares - 2 * sum_of_products;\n}\n```"}
{"task_id": "SimdBench_41", "completion": "```c\n#include <stdint.h>\n\nint64_t squarediff(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_of_squares = 0;\n    int64_t sum_of_products = 0;\n\n    for (size_t i = 0; i < length; ++i) {\n        sum_of_squares += (int64_t)A[i] * A[i] + (int64_t)B[i] * B[i];\n        sum_of_products += (int64_t)A[i] * B[i];\n    }\n\n    return sum_of_squares - sum_of_products;\n}\n```"}
{"task_id": "SimdBench_41", "completion": "```c\n#include <stdint.h>\n\nint64_t squarediff(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_of_squares = 0;\n    int64_t sum_of_products = 0;\n\n    for (size_t i = 0; i < length; ++i) {\n        sum_of_squares += (int64_t)A[i] * A[i] + (int64_t)B[i] * B[i];\n        sum_of_products += (int64_t)A[i] * B[i];\n    }\n\n    return sum_of_squares - 2 * sum_of_products;\n}\n```"}
{"task_id": "SimdBench_41", "completion": "```c\n#include <stdint.h>\n\nint64_t squarediff(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_of_squares = 0;\n    int64_t sum_of_products = 0;\n\n    for (size_t i = 0; i < length; ++i) {\n        sum_of_squares += (int64_t)A[i] * A[i] + (int64_t)B[i] * B[i];\n        sum_of_products += (int64_t)A[i] * B[i];\n    }\n\n    return sum_of_squares - sum_of_products;\n}\n```"}
{"task_id": "SimdBench_42", "completion": "```cpp\nvoid tensor_bit_clear(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42", "completion": "```cpp\nvoid tensor_bit_clear(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42", "completion": "```cpp\nvoid tensor_bit_clear(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42", "completion": "```cpp\nvoid tensor_bit_clear(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42", "completion": "```cpp\nvoid tensor_bit_clear(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_43", "completion": "```cpp\nvoid tensor_three_valued_logic(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43", "completion": "```cpp\nvoid tensor_three_valued_logic(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43", "completion": "```cpp\nvoid tensor_three_valued_logic(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43", "completion": "```cpp\nvoid tensor_three_valued_logic(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43", "completion": "```cpp\nvoid tensor_three_valued_logic(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44", "completion": "```cpp\nvoid tensor_bit_op(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    for (size_t i = 0; i < length; ++i) {\n        if (i < midpoint) {\n            C[i] = A[i] ^ B[i];\n        } else if (i > midpoint) {\n            C[i] = A[i] & B[i];\n        } else {\n            C[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44", "completion": "```cpp\nvoid tensor_bit_op(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    for (size_t i = 0; i < length; ++i) {\n        if (i < midpoint) {\n            C[i] = A[i] ^ B[i];\n        } else if (i > midpoint) {\n            C[i] = A[i] & B[i];\n        } else {\n            C[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44", "completion": "```cpp\nvoid tensor_bit_op(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    for (size_t i = 0; i < length; ++i) {\n        if (i < midpoint) {\n            C[i] = A[i] ^ B[i];\n        } else if (i > midpoint) {\n            C[i] = A[i] & B[i];\n        } else {\n            C[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44", "completion": "```cpp\nvoid tensor_bit_op(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    for (size_t i = 0; i < length; ++i) {\n        if (i < midpoint) {\n            C[i] = A[i] ^ B[i];\n        } else if (i > midpoint) {\n            C[i] = A[i] & B[i];\n        } else {\n            C[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44", "completion": "```cpp\nvoid tensor_bit_op(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    for (size_t i = 0; i < length; ++i) {\n        if (i < midpoint) {\n            C[i] = A[i] ^ B[i];\n        } else if (i > midpoint) {\n            C[i] = A[i] & B[i];\n        } else {\n            C[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45", "completion": "```cpp\nvoid tensor_multi_select(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; ++i) {\n        if (cond1[i] && cond2[i]) {\n            out[i] = A[i];\n        } else if (cond1[i] && !cond2[i]) {\n            out[i] = B[i];\n        } else if (!cond1[i] && cond2[i]) {\n            out[i] = C[i];\n        } else {\n            out[i] = D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45", "completion": "```cpp\nvoid tensor_multi_select(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; ++i) {\n        if (cond1[i] && cond2[i]) {\n            out[i] = A[i];\n        } else if (cond1[i] && !cond2[i]) {\n            out[i] = B[i];\n        } else if (!cond1[i] && cond2[i]) {\n            out[i] = C[i];\n        } else {\n            out[i] = D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45", "completion": "```cpp\nvoid tensor_multi_select(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; ++i) {\n        if (cond1[i] && cond2[i]) {\n            out[i] = A[i];\n        } else if (cond1[i] && !cond2[i]) {\n            out[i] = B[i];\n        } else if (!cond1[i] && cond2[i]) {\n            out[i] = C[i];\n        } else {\n            out[i] = D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45", "completion": "```cpp\nvoid tensor_multi_select(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; ++i) {\n        if (cond1[i] && cond2[i]) {\n            out[i] = A[i];\n        } else if (cond1[i] && !cond2[i]) {\n            out[i] = B[i];\n        } else if (!cond1[i] && cond2[i]) {\n            out[i] = C[i];\n        } else {\n            out[i] = D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45", "completion": "```cpp\nvoid tensor_multi_select(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; ++i) {\n        if (cond1[i] && cond2[i]) {\n            out[i] = A[i];\n        } else if (cond1[i] && !cond2[i]) {\n            out[i] = B[i];\n        } else if (!cond1[i] && cond2[i]) {\n            out[i] = C[i];\n        } else {\n            out[i] = D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_46", "completion": "```cpp\nvoid tensor_bit_count(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; ++i) {\n        uint32_t value = A[i];\n        uint8_t count = 0;\n        while (value) {\n            count += value & 1;\n            value >>= 1;\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_46", "completion": "```cpp\n#include <stdint.h>\n\nvoid tensor_bit_count(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; ++i) {\n        uint32_t value = A[i];\n        uint8_t count = 0;\n        while (value) {\n            count += value & 1;\n            value >>= 1;\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_46", "completion": "```cpp\n#include <stdint.h>\n\nvoid tensor_bit_count(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; ++i) {\n        uint32_t value = A[i];\n        uint8_t count = 0;\n        while (value) {\n            count += value & 1;\n            value >>= 1;\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_46", "completion": "```cpp\nvoid tensor_bit_count(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; ++i) {\n        uint32_t value = A[i];\n        uint8_t count = 0;\n        while (value) {\n            count += value & 1;\n            value >>= 1;\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_46", "completion": "```cpp\nvoid tensor_bit_count(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; ++i) {\n        uint32_t value = A[i];\n        uint8_t count = 0;\n        while (value) {\n            count += value & 1;\n            value >>= 1;\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_47", "completion": "```cpp\nvoid matrix_conditional_abs(const int* A, int* B, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows * cols; ++i) {\n        if (A[i] % 3 == 0) {\n            B[i] = abs(A[i]);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47", "completion": "```cpp\nvoid matrix_conditional_abs(const int* A, int* B, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows * cols; ++i) {\n        if (A[i] % 3 == 0) {\n            B[i] = abs(A[i]);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47", "completion": "```cpp\nvoid matrix_conditional_abs(const int* A, int* B, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows * cols; ++i) {\n        if (A[i] % 3 == 0) {\n            B[i] = abs(A[i]);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47", "completion": "```cpp\nvoid matrix_conditional_abs(const int* A, int* B, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows * cols; ++i) {\n        if (A[i] % 3 == 0) {\n            B[i] = abs(A[i]);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47", "completion": "```cpp\nvoid matrix_conditional_abs(const int* A, int* B, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows * cols; ++i) {\n        if (A[i] % 3 == 0) {\n            B[i] = abs(A[i]);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid matrix_conditional_bit_rotate(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if ((src[i] & 0xF) == 0xF) { // Check if the low 4 bits are all 1\n            dst[i] = (src[i] >> rotate_bits) | (src[i] << (32 - rotate_bits)); // Rotate right by rotate_bits\n        } else {\n            dst[i] = ~src[i]; // Bitwise negation\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48", "completion": "```cpp\n#include <cstdint>\n\nvoid matrix_conditional_bit_rotate(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if ((src[i] & 0xF) == 0xF) { // Check if the low 4 bits are all 1\n            dst[i] = (src[i] >> rotate_bits) | (src[i] << (32 - rotate_bits)); // Rotate right by rotate_bits\n        } else {\n            dst[i] = ~src[i]; // Bitwise negation\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid matrix_conditional_bit_rotate(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if ((src[i] & 0xF) == 0xF) { // Check if the low 4 bits are all 1\n            dst[i] = (src[i] >> rotate_bits) | (src[i] << (32 - rotate_bits)); // Rotate right by rotate_bits\n        } else {\n            dst[i] = ~src[i]; // Bitwise negation\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48", "completion": "```cpp\n#include <cstdint>\n\nvoid matrix_conditional_bit_rotate(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if ((src[i] & 0xF) == 0xF) { // Check if the low 4 bits are all 1\n            dst[i] = (src[i] >> rotate_bits) | (src[i] << (32 - rotate_bits)); // Rotate right by rotate_bits\n        } else {\n            dst[i] = ~src[i]; // Bitwise negation\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid matrix_conditional_bit_rotate(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if ((src[i] & 0xF) == 0xF) { // Check if the low 4 bits are all 1\n            dst[i] = (src[i] >> rotate_bits) | (src[i] << (32 - rotate_bits)); // Rotate right by rotate_bits\n        } else {\n            dst[i] = ~src[i]; // Bitwise negation\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49", "completion": "```cpp\nvoid tensor_ternary_compare(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float abs_epsilon = fabs(epsilon);\n    for (size_t i = 0; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > abs_epsilon) {\n            out[i] = 1;\n        } else if (diff < -abs_epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49", "completion": "```cpp\nvoid tensor_ternary_compare(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float abs_epsilon = fabsf(epsilon);\n    for (size_t i = 0; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > abs_epsilon) {\n            out[i] = 1;\n        } else if (diff < -abs_epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49", "completion": "```cpp\nvoid tensor_ternary_compare(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float abs_epsilon = fabs(epsilon);\n    for (size_t i = 0; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > abs_epsilon) {\n            out[i] = 1;\n        } else if (diff < -abs_epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49", "completion": "```cpp\nvoid tensor_ternary_compare(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float abs_epsilon = fabs(epsilon);\n    for (size_t i = 0; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > abs_epsilon) {\n            out[i] = 1;\n        } else if (diff < -abs_epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49", "completion": "```cpp\nvoid tensor_ternary_compare(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float abs_epsilon = fabs(epsilon);\n    for (size_t i = 0; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > abs_epsilon) {\n            out[i] = 1;\n        } else if (diff < -abs_epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50", "completion": "```cpp\n#include <stdint.h>\n#include <limits.h>\n\nvoid float_to_int_saturate(const float* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        if (A[i] > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (A[i] < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50", "completion": "```cpp\n#include <stdint.h>\n#include <limits.h>\n\nvoid float_to_int_saturate(const float* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        if (A[i] > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (A[i] < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50", "completion": "```cpp\n#include <cstdint>\n#include <cmath>\n#include <limits>\n\nvoid float_to_int_saturate(const float* A, int32_t* B, size_t size) {\n    const int32_t INT32_MAX_VALUE = std::numeric_limits<int32_t>::max();\n    const int32_t INT32_MIN_VALUE = std::numeric_limits<int32_t>::min();\n\n    for (size_t i = 0; i < size; ++i) {\n        if (std::isnan(A[i])) {\n            B[i] = 0; // NaN can be mapped to 0 or handled as per requirements\n        } else if (A[i] > static_cast<float>(INT32_MAX_VALUE)) {\n            B[i] = INT32_MAX_VALUE;\n        } else if (A[i] < static_cast<float>(INT32_MIN_VALUE)) {\n            B[i] = INT32_MIN_VALUE;\n        } else {\n            B[i] = static_cast<int32_t>(A[i]);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50", "completion": "```c\n#include <stdint.h>\n#include <limits.h>\n#include <math.h>\n\nvoid float_to_int_saturate(const float* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (A[i] < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)lroundf(A[i]);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50", "completion": "```cpp\n#include <cstdint>\n#include <cmath>\n#include <limits>\n\nvoid float_to_int_saturate(const float* A, int32_t* B, size_t size) {\n    const int32_t INT32_MAX_VALUE = std::numeric_limits<int32_t>::max();\n    const int32_t INT32_MIN_VALUE = std::numeric_limits<int32_t>::min();\n\n    for (size_t i = 0; i < size; ++i) {\n        if (A[i] > static_cast<float>(INT32_MAX_VALUE)) {\n            B[i] = INT32_MAX_VALUE;\n        } else if (A[i] < static_cast<float>(INT32_MIN_VALUE)) {\n            B[i] = INT32_MIN_VALUE;\n        } else {\n            B[i] = static_cast<int32_t>(A[i]);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_51", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid int_to_float_scaled(const int32_t* A, int8_t scale, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid int_to_float_scaled(const int32_t* A, int8_t scale, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51", "completion": "```cpp\n#include <stdint.h>\n#include <stddef.h>\n\nvoid int_to_float_scaled(const int32_t* A, int8_t scale, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid int_to_float_scaled(const int32_t* A, int8_t scale, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid int_to_float_scaled(const int32_t* A, int8_t scale, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_52", "completion": "```cpp\n#include <cmath>\n#include <cstdint>\n#include <limits>\n\nvoid float_div_round(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        if (B[i] == 0.0f) {\n            // Handle division by zero: set result to max or min int32 value based on sign of A[i]\n            C[i] = (A[i] >= 0.0f) ? std::numeric_limits<int32_t>::max() : std::numeric_limits<int32_t>::min();\n        } else {\n            float result = A[i] / B[i];\n            // Clamp the result to the range of int32_t before rounding\n            if (result > static_cast<float>(std::numeric_limits<int32_t>::max())) {\n                C[i] = std::numeric_limits<int32_t>::max();\n            } else if (result < static_cast<float>(std::numeric_limits<int32_t>::min())) {\n                C[i] = std::numeric_limits<int32_t>::min();\n            } else {\n                C[i] = static_cast<int32_t>(std::round(result));\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_52", "completion": "```cpp\n#include <cmath>\n#include <cstdint>\n#include <limits>\n\nvoid float_div_round(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        if (B[i] == 0.0f) {\n            // Handle division by zero: set to max/min int32_t based on sign of A[i]\n            C[i] = (A[i] >= 0.0f) ? std::numeric_limits<int32_t>::max() : std::numeric_limits<int32_t>::min();\n        } else {\n            float result = A[i] / B[i];\n            // Clamp the result to the range of int32_t before rounding\n            if (result > static_cast<float>(std::numeric_limits<int32_t>::max())) {\n                C[i] = std::numeric_limits<int32_t>::max();\n            } else if (result < static_cast<float>(std::numeric_limits<int32_t>::min())) {\n                C[i] = std::numeric_limits<int32_t>::min();\n            } else {\n                C[i] = static_cast<int32_t>(std::round(result));\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_52", "completion": "```cpp\n#include <cmath>\n#include <cstdint>\n#include <limits>\n\nvoid float_div_round(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        if (B[i] == 0.0f) {\n            // Handle division by zero: set to max or min int32 value based on sign of A[i]\n            C[i] = (A[i] >= 0.0f) ? std::numeric_limits<int32_t>::max() : std::numeric_limits<int32_t>::min();\n        } else {\n            float result = A[i] / B[i];\n            // Clamp the result to the range of int32_t before rounding\n            if (result > static_cast<float>(std::numeric_limits<int32_t>::max())) {\n                C[i] = std::numeric_limits<int32_t>::max();\n            } else if (result < static_cast<float>(std::numeric_limits<int32_t>::min())) {\n                C[i] = std::numeric_limits<int32_t>::min();\n            } else {\n                C[i] = static_cast<int32_t>(std::round(result));\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_52", "completion": "```c\n#include <stdint.h>\n#include <math.h>\n\nvoid float_div_round(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        if (B[i] == 0.0f) {\n            // Handle division by zero by setting result to 0 (or any other desired behavior)\n            C[i] = 0;\n        } else {\n            float result = A[i] / B[i];\n            // Clamp the result to the range of a 32-bit integer before rounding\n            if (result > (float)INT32_MAX) {\n                C[i] = INT32_MAX;\n            } else if (result < (float)INT32_MIN) {\n                C[i] = INT32_MIN;\n            } else {\n                C[i] = (int32_t)lroundf(result);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_52", "completion": "```cpp\n#include <cmath>\n#include <cstdint>\n#include <limits>\n\nvoid float_div_round(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        if (B[i] == 0.0f) {\n            // Handle division by zero: set to max or min int32 value based on sign of A[i]\n            C[i] = (A[i] >= 0.0f) ? std::numeric_limits<int32_t>::max() : std::numeric_limits<int32_t>::min();\n        } else {\n            float result = A[i] / B[i];\n            // Clamp the result to the range of int32_t before rounding\n            if (result > static_cast<float>(std::numeric_limits<int32_t>::max())) {\n                C[i] = std::numeric_limits<int32_t>::max();\n            } else if (result < static_cast<float>(std::numeric_limits<int32_t>::min())) {\n                C[i] = std::numeric_limits<int32_t>::min();\n            } else {\n                C[i] = static_cast<int32_t>(std::round(result));\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53", "completion": "```cpp\n#include <cfloat>\n#include <cmath>\n\nvoid double_to_float_saturate(const double* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = static_cast<float>(A[i]);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53", "completion": "```cpp\n#include <cfloat>\n#include <cmath>\n\nvoid double_to_float_saturate(const double* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = static_cast<float>(A[i]);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53", "completion": "```cpp\n#include <cfloat>\n#include <cmath>\n\nvoid double_to_float_saturate(const double* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = static_cast<float>(A[i]);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53", "completion": "```cpp\n#include <cfloat>\n#include <cmath>\n\nvoid double_to_float_saturate(const double* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = static_cast<float>(A[i]);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53", "completion": "```cpp\n#include <cfloat>\n#include <cmath>\n\nvoid double_to_float_saturate(const double* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = static_cast<float>(A[i]);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_54", "completion": "```cpp\nvoid int16_to_int32(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        B[i] = static_cast<int32_t>(A[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_54", "completion": "```c\n#include <stdint.h>\n\nvoid int16_to_int32(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54", "completion": "```cpp\nvoid int16_to_int32(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        B[i] = static_cast<int32_t>(A[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_54", "completion": "```cpp\nvoid int16_to_int32(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        B[i] = static_cast<int32_t>(A[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_54", "completion": "```c\n#include <stdint.h>\n\nvoid int16_to_int32(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_55", "completion": "```cpp\n#include <algorithm>\n\nvoid conditional_normalize(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float range = max_val - min_val;\n    for (size_t i = 0; i < size; ++i) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / range;\n            val = std::max(0.0f, std::min(1.0f, val));\n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55", "completion": "```c\n#include <stdint.h>\n\nvoid conditional_normalize(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float range = max_val - min_val;\n    for (size_t i = 0; i < size; ++i) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / range;\n            if (val < 0.0f) {\n                val = 0.0f;\n            } else if (val > 1.0f) {\n                val = 1.0f;\n            }\n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55", "completion": "```cpp\n#include <algorithm>\n\nvoid conditional_normalize(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float range = max_val - min_val;\n    for (size_t i = 0; i < size; ++i) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / range;\n            val = std::max(0.0f, std::min(1.0f, val));\n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55", "completion": "```cpp\n#include <cstdint>\n\nvoid conditional_normalize(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float range = max_val - min_val;\n    for (size_t i = 0; i < size; ++i) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / range;\n            if (val < 0.0f) {\n                val = 0.0f;\n            } else if (val > 1.0f) {\n                val = 1.0f;\n            }\n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55", "completion": "```cpp\n#include <algorithm>\n\nvoid conditional_normalize(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float range = max_val - min_val;\n    for (size_t i = 0; i < size; ++i) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / range;\n            val = std::max(0.0f, std::min(1.0f, val));\n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_56", "completion": "```cpp\n#include <stdint.h>\n#include <math.h>\n\nvoid int_to_float_sqrt(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        uint32_t high_16_bits = A[i] >> 16;\n        float converted_value = (float)high_16_bits;\n        B[i] = sqrtf(converted_value);\n    }\n}\n```"}
{"task_id": "SimdBench_56", "completion": "```cpp\n#include <stdint.h>\n#include <math.h>\n\nvoid int_to_float_sqrt(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        uint32_t high_16_bits = A[i] >> 16;\n        float converted_value = (float)high_16_bits;\n        B[i] = sqrtf(converted_value);\n    }\n}\n```"}
{"task_id": "SimdBench_56", "completion": "```c\n#include <stdint.h>\n#include <math.h>\n\nvoid int_to_float_sqrt(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        uint32_t high_16_bits = A[i] >> 16;\n        float converted_value = (float)high_16_bits;\n        B[i] = sqrtf(converted_value);\n    }\n}\n```"}
{"task_id": "SimdBench_56", "completion": "```cpp\n#include <stdint.h>\n#include <math.h>\n\nvoid int_to_float_sqrt(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        uint32_t high_16_bits = A[i] >> 16;\n        float converted = (float)high_16_bits;\n        B[i] = sqrtf(converted);\n    }\n}\n```"}
{"task_id": "SimdBench_56", "completion": "```cpp\n#include <stdint.h>\n#include <math.h>\n\nvoid int_to_float_sqrt(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        uint32_t high_16_bits = A[i] >> 16;\n        float converted = (float)high_16_bits;\n        B[i] = sqrtf(converted);\n    }\n}\n```"}
{"task_id": "SimdBench_57", "completion": "```c\n#include <stdint.h>\n#include <string.h>\n\nvoid int_bits_to_float(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        memcpy(&B[i], &A[i], sizeof(uint32_t));\n    }\n}\n```"}
{"task_id": "SimdBench_57", "completion": "```c\n#include <stdint.h>\n#include <string.h>\n\nvoid int_bits_to_float(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        memcpy(&B[i], &A[i], sizeof(uint32_t));\n    }\n}\n```"}
{"task_id": "SimdBench_57", "completion": "```c\n#include <stdint.h>\n#include <string.h>\n\nvoid int_bits_to_float(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        memcpy(&B[i], &A[i], sizeof(uint32_t));\n    }\n}\n```"}
{"task_id": "SimdBench_57", "completion": "```c\n#include <stdint.h>\n#include <string.h>\n\nvoid int_bits_to_float(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        memcpy(&B[i], &A[i], sizeof(uint32_t));\n    }\n}\n```"}
{"task_id": "SimdBench_57", "completion": "```c\n#include <stdint.h>\n#include <string.h>\n\nvoid int_bits_to_float(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        memcpy(&B[i], &A[i], sizeof(uint32_t));\n    }\n}\n```"}
{"task_id": "SimdBench_58", "completion": "```cpp\n#include <cstdint>\n#include <cstddef>\n\nvoid conditional_diff(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    diff[0] = 0.0f; // The first element is always 0.0f\n    for (size_t i = 1; i < size; ++i) {\n        if (cond[i]) {\n            diff[i] = static_cast<float>(A[i] - A[i - 1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58", "completion": "```cpp\n#include <cstdint>\n#include <cstddef>\n\nvoid conditional_diff(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    diff[0] = 0.0f; // The first element is always 0.0f\n    for (size_t i = 1; i < size; ++i) {\n        if (cond[i]) {\n            diff[i] = static_cast<float>(A[i] - A[i - 1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58", "completion": "```cpp\n#include <cstdint>\n#include <cstddef>\n\nvoid conditional_diff(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    diff[0] = 0.0f; // The first element is always 0.0f\n    for (size_t i = 1; i < size; ++i) {\n        if (cond[i]) {\n            diff[i] = static_cast<float>(A[i] - A[i - 1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58", "completion": "```cpp\n#include <cstdint>\n#include <cstddef>\n\nvoid conditional_diff(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    diff[0] = 0.0f; // The first element is always 0.0f\n\n    for (size_t i = 1; i < size; ++i) {\n        if (cond[i]) {\n            diff[i] = static_cast<float>(A[i] - A[i - 1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58", "completion": "```cpp\n#include <cstdint>\n#include <cstddef>\n\nvoid conditional_diff(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    diff[0] = 0.0f; // The first element is always 0.0f\n    for (size_t i = 1; i < size; ++i) {\n        if (cond[i]) {\n            diff[i] = static_cast<float>(A[i] - A[i - 1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_59", "completion": "```cpp\nvoid widening_uint(const uint32_t* src, uint64_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = ((uint64_t)src[i]) | 0xFFFFFFFF00000000;\n    }\n}\n```"}
{"task_id": "SimdBench_59", "completion": "```c\n#include <stdint.h>\n\nvoid widening_uint(const uint32_t* src, uint64_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = ((uint64_t)src[i]) | 0xFFFFFFFF00000000;\n    }\n}\n```"}
{"task_id": "SimdBench_59", "completion": "```cpp\nvoid widening_uint(const uint32_t* src, uint64_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = ((uint64_t)src[i]) | 0xFFFFFFFF00000000;\n    }\n}\n```"}
{"task_id": "SimdBench_59", "completion": "```cpp\nvoid widening_uint(const uint32_t* src, uint64_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = ((uint64_t)src[i]) | 0xFFFFFFFF00000000;\n    }\n}\n```"}
{"task_id": "SimdBench_59", "completion": "```c\n#include <stdint.h>\n\nvoid widening_uint(const uint32_t* src, uint64_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = ((uint64_t)src[i]) | 0xFFFFFFFF00000000;\n    }\n}\n```"}
{"task_id": "SimdBench_60", "completion": "```cpp\n#include <cstdint>\n\ndouble indexed_sum(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    for (size_t i = 0; i < length; ++i) {\n        int16_t idx = index[i];\n        if (idx >= 0 && idx < static_cast<int16_t>(length)) {\n            sum += vec[idx];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60", "completion": "```cpp\ndouble indexed_sum(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    for (size_t i = 0; i < length; ++i) {\n        if (index[i] >= 0 && index[i] < static_cast<int16_t>(length)) {\n            sum += vec[index[i]];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60", "completion": "```cpp\ndouble indexed_sum(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    for (size_t i = 0; i < length; ++i) {\n        if (index[i] >= 0 && index[i] < static_cast<int16_t>(length)) {\n            sum += vec[index[i]];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60", "completion": "```cpp\ndouble indexed_sum(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    for (size_t i = 0; i < length; ++i) {\n        if (index[i] >= 0 && index[i] < static_cast<int16_t>(length)) {\n            sum += vec[index[i]];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60", "completion": "```cpp\ndouble indexed_sum(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    for (size_t i = 0; i < length; ++i) {\n        if (index[i] >= 0 && index[i] < static_cast<int16_t>(length)) {\n            sum += vec[index[i]];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_61", "completion": "```cpp\nvoid simple_conv2d(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    size_t input_row = i + ki;\n                    size_t input_col = j + kj;\n                    sum += input[input_row * input_size + input_col] * kernel[ki * kernel_size + kj];\n                }\n            }\n            output[i * output_size + j] = (sum > 0.0) ? sum : 0.0; // ReLU activation\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61", "completion": "```cpp\nvoid simple_conv2d(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    size_t input_idx = (i + ki) * input_size + (j + kj);\n                    size_t kernel_idx = ki * kernel_size + kj;\n                    sum += input[input_idx] * kernel[kernel_idx];\n                }\n            }\n            output[i * output_size + j] = (sum > 0.0) ? sum : 0.0; // ReLU activation\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61", "completion": "```cpp\nvoid simple_conv2d(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    size_t input_row = i + ki;\n                    size_t input_col = j + kj;\n                    sum += input[input_row * input_size + input_col] * kernel[ki * kernel_size + kj];\n                }\n            }\n            output[i * output_size + j] = (sum > 0.0) ? sum : 0.0; // ReLU activation\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61", "completion": "```cpp\nvoid simple_conv2d(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    sum += input[(i + ki) * input_size + (j + kj)] * kernel[ki * kernel_size + kj];\n                }\n            }\n            output[i * output_size + j] = (sum > 0.0) ? sum : 0.0; // ReLU activation\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61", "completion": "```cpp\nvoid simple_conv2d(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    sum += input[(i + ki) * input_size + (j + kj)] * kernel[ki * kernel_size + kj];\n                }\n            }\n            output[i * output_size + j] = (sum > 0.0) ? sum : 0.0; // ReLU activation\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_62", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nbool has_close_elements(const std::vector<double> & numbers, double threshold) {\n    std::vector<double> sorted_numbers = numbers;\n    std::sort(sorted_numbers.begin(), sorted_numbers.end());\n    \n    for (size_t i = 0; i < sorted_numbers.size() - 1; ++i) {\n        if (std::abs(sorted_numbers[i] - sorted_numbers[i + 1]) < threshold) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nbool has_close_elements(const std::vector<double> & numbers, double threshold) {\n    std::vector<double> sorted_numbers = numbers;\n    std::sort(sorted_numbers.begin(), sorted_numbers.end());\n    \n    for (size_t i = 0; i < sorted_numbers.size() - 1; ++i) {\n        if (std::abs(sorted_numbers[i] - sorted_numbers[i + 1]) < threshold) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_62", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nbool has_close_elements(const std::vector<double> & numbers, double threshold) {\n    std::vector<double> sorted_numbers = numbers;\n    std::sort(sorted_numbers.begin(), sorted_numbers.end());\n    \n    for (size_t i = 0; i < sorted_numbers.size() - 1; ++i) {\n        if (std::fabs(sorted_numbers[i] - sorted_numbers[i + 1]) < threshold) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nbool has_close_elements(const std::vector<double> & numbers, double threshold) {\n    std::vector<double> sorted_numbers = numbers;\n    std::sort(sorted_numbers.begin(), sorted_numbers.end());\n    \n    for (size_t i = 0; i < sorted_numbers.size() - 1; ++i) {\n        if (std::abs(sorted_numbers[i] - sorted_numbers[i + 1]) < threshold) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nbool has_close_elements(const std::vector<double> & numbers, double threshold) {\n    if (numbers.size() < 2) return false;\n    \n    std::vector<double> sorted_numbers = numbers;\n    std::sort(sorted_numbers.begin(), sorted_numbers.end());\n    \n    for (size_t i = 0; i < sorted_numbers.size() - 1; ++i) {\n        if (std::fabs(sorted_numbers[i] - sorted_numbers[i + 1]) < threshold) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_63", "completion": "```cpp\nbool below_zero(std::vector<int> operations){\n    int balance = 0;\n    for (int op : operations){\n        balance += op;\n        if (balance < 0){\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63", "completion": "```cpp\nbool below_zero(std::vector<int> operations){\n    int balance = 0;\n    for (int op : operations){\n        balance += op;\n        if (balance < 0){\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63", "completion": "```cpp\nbool below_zero(std::vector<int> operations){\n    int balance = 0;\n    for (int op : operations){\n        balance += op;\n        if (balance < 0){\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63", "completion": "```cpp\nbool below_zero(std::vector<int> operations){\n    int balance = 0;\n    for (int op : operations){\n        balance += op;\n        if (balance < 0){\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63", "completion": "```cpp\nbool below_zero(std::vector<int> operations){\n    int balance = 0;\n    for (int op : operations){\n        balance += op;\n        if (balance < 0){\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_64", "completion": "```cpp\n#include <vector>\n#include <numeric>\n#include <cmath>\n\ndouble mean_absolute_deviation(std::vector<double> numbers) {\n    if (numbers.empty()) return 0.0;\n    \n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / numbers.size();\n    \n    double mad_sum = 0.0;\n    for (const auto& num : numbers) {\n        mad_sum += std::abs(num - mean);\n    }\n    \n    return mad_sum / numbers.size();\n}\n```"}
{"task_id": "SimdBench_64", "completion": "```cpp\n#include <vector>\n#include <numeric>\n#include <cmath>\n\ndouble mean_absolute_deviation(std::vector<double> numbers){\n    if (numbers.empty()) return 0.0;\n    \n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / numbers.size();\n    \n    double mad_sum = 0.0;\n    for (const auto& num : numbers) {\n        mad_sum += std::abs(num - mean);\n    }\n    \n    return mad_sum / numbers.size();\n}\n```"}
{"task_id": "SimdBench_64", "completion": "```cpp\n#include <vector>\n#include <numeric>\n#include <cmath>\n\ndouble mean_absolute_deviation(std::vector<double> numbers) {\n    if (numbers.empty()) return 0.0;\n    \n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / numbers.size();\n    \n    double mad_sum = 0.0;\n    for (const auto& num : numbers) {\n        mad_sum += std::abs(num - mean);\n    }\n    \n    return mad_sum / numbers.size();\n}\n```"}
{"task_id": "SimdBench_64", "completion": "```cpp\n#include <vector>\n#include <numeric>\n#include <cmath>\n\ndouble mean_absolute_deviation(std::vector<double> numbers) {\n    if (numbers.empty()) return 0.0;\n    \n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / numbers.size();\n    \n    double mad_sum = 0.0;\n    for (const auto& num : numbers) {\n        mad_sum += std::abs(num - mean);\n    }\n    \n    return mad_sum / numbers.size();\n}\n```"}
{"task_id": "SimdBench_64", "completion": "```cpp\n#include <vector>\n#include <numeric>\n#include <cmath>\n\ndouble mean_absolute_deviation(std::vector<double> numbers){\n    if (numbers.empty()) return 0.0;\n\n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / numbers.size();\n    \n    double mad_sum = 0.0;\n    for (const auto& num : numbers) {\n        mad_sum += std::abs(num - mean);\n    }\n    \n    return mad_sum / numbers.size();\n}\n```"}
{"task_id": "SimdBench_65", "completion": "```cpp\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter){\n    std::vector<int> result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_65", "completion": "```cpp\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter){\n    std::vector<int> result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_65", "completion": "```cpp\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter){\n    std::vector<int> result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_65", "completion": "```cpp\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter){\n    std::vector<int> result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_65", "completion": "```cpp\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter){\n    std::vector<int> result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_66", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nstd::vector<int64_t> sum_product(std::vector<int16_t> numbers){\n    int64_t sum = 0;\n    int64_t product = 1;\n    for (int16_t num : numbers) {\n        sum += num;\n        product *= num;\n    }\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nstd::vector<int64_t> sum_product(std::vector<int16_t> numbers){\n    int64_t sum = 0;\n    int64_t product = 1;\n    for (int16_t num : numbers) {\n        sum += num;\n        product *= num;\n    }\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nstd::vector<int64_t> sum_product(std::vector<int16_t> numbers){\n    int64_t sum = 0;\n    int64_t product = 1;\n    for (int16_t num : numbers) {\n        sum += num;\n        product *= num;\n    }\n    return std::vector<int64_t>{sum, product};\n}\n```"}
{"task_id": "SimdBench_66", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nstd::vector<int64_t> sum_product(std::vector<int16_t> numbers){\n    int64_t sum = 0;\n    int64_t product = 1;\n    for (int16_t num : numbers) {\n        sum += num;\n        product *= num;\n    }\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nstd::vector<int64_t> sum_product(std::vector<int16_t> numbers){\n    int64_t sum = 0;\n    int64_t product = 1;\n    for (int16_t num : numbers) {\n        sum += num;\n        product *= num;\n    }\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_67", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max(std::vector<int> numbers){\n    std::vector<int> result;\n    if (numbers.empty()) return result;\n    \n    int current_max = numbers[0];\n    result.push_back(current_max);\n    \n    for (size_t i = 1; i < numbers.size(); ++i) {\n        current_max = std::max(current_max, numbers[i]);\n        result.push_back(current_max);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_67", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max(std::vector<int> numbers){\n    std::vector<int> result;\n    if (numbers.empty()) return result;\n    \n    int current_max = numbers[0];\n    result.push_back(current_max);\n    \n    for (size_t i = 1; i < numbers.size(); ++i) {\n        current_max = std::max(current_max, numbers[i]);\n        result.push_back(current_max);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_67", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max(std::vector<int> numbers){\n    std::vector<int> result;\n    if (numbers.empty()) return result;\n    \n    int current_max = numbers[0];\n    result.push_back(current_max);\n    \n    for (size_t i = 1; i < numbers.size(); ++i) {\n        current_max = std::max(current_max, numbers[i]);\n        result.push_back(current_max);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_67", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max(std::vector<int> numbers){\n    std::vector<int> result;\n    if (numbers.empty()) return result;\n    \n    int current_max = numbers[0];\n    result.push_back(current_max);\n    \n    for (size_t i = 1; i < numbers.size(); ++i) {\n        current_max = std::max(current_max, numbers[i]);\n        result.push_back(current_max);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_67", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max(std::vector<int> numbers){\n    std::vector<int> result;\n    if (numbers.empty()) return result;\n    \n    int current_max = numbers[0];\n    result.push_back(current_max);\n    \n    for (size_t i = 1; i < numbers.size(); ++i) {\n        current_max = std::max(current_max, numbers[i]);\n        result.push_back(current_max);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_68", "completion": "```cpp\n#include <string>\n#include <algorithm>\n\nstd::string string_xor(std::string a, std::string b) {\n    int n = a.size();\n    int m = b.size();\n    if (n < m) {\n        a.insert(0, m - n, '0');\n    } else if (m < n) {\n        b.insert(0, n - m, '0');\n    }\n    std::string result = \"\";\n    for (size_t i = 0; i < std::max(n, m); ++i) {\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_68", "completion": "```cpp\n#include <string>\n#include <algorithm>\n\nstd::string string_xor(std::string a, std::string b) {\n    // Determine the maximum length of the two strings\n    size_t max_len = std::max(a.length(), b.length());\n    \n    // Pad the shorter string with leading zeros to match the lengths\n    a.insert(a.begin(), max_len - a.length(), '0');\n    b.insert(b.begin(), max_len - b.length(), '0');\n    \n    // Perform XOR operation character by character\n    std::string result(max_len, '0');\n    for (size_t i = 0; i < max_len; ++i) {\n        result[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_68", "completion": "```cpp\n#include <string>\n#include <algorithm>\n\nstd::string string_xor(std::string a, std::string b) {\n    std::string result;\n    auto it_a = a.rbegin();\n    auto it_b = b.rbegin();\n    \n    while (it_a != a.rend() || it_b != b.rend()) {\n        char bit_a = (it_a != a.rend()) ? *it_a : '0';\n        char bit_b = (it_b != b.rend()) ? *it_b : '0';\n        \n        char xor_bit = ((bit_a == '1') ^ (bit_b == '1')) ? '1' : '0';\n        result.push_back(xor_bit);\n        \n        if (it_a != a.rend()) ++it_a;\n        if (it_b != b.rend()) ++it_b;\n    }\n    \n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_68", "completion": "```cpp\n#include <string>\n#include <algorithm>\n\nstd::string string_xor(std::string a, std::string b) {\n    // Determine the maximum length of the two strings\n    size_t max_len = std::max(a.length(), b.length());\n    \n    // Pad the shorter string with leading zeros to match the lengths\n    a.insert(a.begin(), max_len - a.length(), '0');\n    b.insert(b.begin(), max_len - b.length(), '0');\n    \n    // Perform XOR operation character by character\n    std::string result(max_len, '0');\n    for (size_t i = 0; i < max_len; ++i) {\n        result[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_68", "completion": "```cpp\n#include <string>\n#include <algorithm>\n\nstd::string string_xor(std::string a, std::string b) {\n    std::string result;\n    auto it_a = a.rbegin();\n    auto it_b = b.rbegin();\n    \n    while (it_a != a.rend() || it_b != b.rend()) {\n        char bit_a = (it_a != a.rend()) ? *it_a : '0';\n        char bit_b = (it_b != b.rend()) ? *it_b : '0';\n        \n        char xor_bit = ((bit_a == '1') ^ (bit_b == '1')) ? '1' : '0';\n        result.push_back(xor_bit);\n        \n        if (it_a != a.rend()) ++it_a;\n        if (it_b != b.rend()) ++it_b;\n    }\n    \n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_69", "completion": "```cpp\nstd::string longest(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return \"\";\n    }\n    const std::string* longestStr = &strings[0];\n    for (const auto& str : strings) {\n        if (str.length() > longestStr->length()) {\n            longestStr = &str;\n        }\n    }\n    return *longestStr;\n}\n```"}
{"task_id": "SimdBench_69", "completion": "```cpp\nstd::string longest(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return \"\";\n    }\n    const std::string* longestStr = &strings[0];\n    for (const auto& str : strings) {\n        if (str.length() > longestStr->length()) {\n            longestStr = &str;\n        }\n    }\n    return *longestStr;\n}\n```"}
{"task_id": "SimdBench_69", "completion": "```cpp\nstd::string longest(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return \"\";\n    }\n    const std::string* longestStr = &strings[0];\n    for (const auto& str : strings) {\n        if (str.length() > longestStr->length()) {\n            longestStr = &str;\n        }\n    }\n    return *longestStr;\n}\n```"}
{"task_id": "SimdBench_69", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <optional>\n\nstd::optional<std::string> longest(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return std::nullopt;\n    }\n    const std::string* longestStr = &strings[0];\n    for (const auto& str : strings) {\n        if (str.length() > longestStr->length()) {\n            longestStr = &str;\n        }\n    }\n    return *longestStr;\n}\n```"}
{"task_id": "SimdBench_69", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::string longest(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return \"\";\n    }\n    const std::string* longestStr = &strings[0];\n    for (const auto& str : strings) {\n        if (str.length() > longestStr->length()) {\n            longestStr = &str;\n        }\n    }\n    return *longestStr;\n}\n```"}
{"task_id": "SimdBench_70", "completion": "```cpp\nuint64_t greatest_common_divisor(uint64_t a, uint64_t b){\n    while (b != 0){\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_70", "completion": "```cpp\nuint64_t greatest_common_divisor(uint64_t a, uint64_t b){\n    while (b != 0){\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_70", "completion": "```cpp\nuint64_t greatest_common_divisor(uint64_t a, uint64_t b){\n    while (b != 0){\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_70", "completion": "```cpp\nuint64_t greatest_common_divisor(uint64_t a, uint64_t b){\n    while (b != 0){\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_70", "completion": "```cpp\nuint64_t greatest_common_divisor(uint64_t a, uint64_t b){\n    while (b != 0){\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_71", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <limits>\n\nstd::vector<float> find_closest_elements(std::vector<float> numbers) {\n    std::sort(numbers.begin(), numbers.end());\n    float min_diff = std::numeric_limits<float>::max();\n    std::vector<float> result(2);\n    \n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = std::abs(numbers[i + 1] - numbers[i]);\n        if (diff < min_diff) {\n            min_diff = diff;\n            result[0] = numbers[i];\n            result[1] = numbers[i + 1];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_71", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <limits>\n\nstd::vector<float> find_closest_elements(std::vector<float> numbers) {\n    std::sort(numbers.begin(), numbers.end());\n    float min_diff = std::numeric_limits<float>::max();\n    std::vector<float> result(2);\n    \n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = std::abs(numbers[i + 1] - numbers[i]);\n        if (diff < min_diff) {\n            min_diff = diff;\n            result[0] = numbers[i];\n            result[1] = numbers[i + 1];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_71", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <limits>\n\nstd::vector<float> find_closest_elements(std::vector<float> numbers) {\n    std::sort(numbers.begin(), numbers.end());\n    float min_diff = std::numeric_limits<float>::max();\n    std::vector<float> result(2);\n    \n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = std::abs(numbers[i + 1] - numbers[i]);\n        if (diff < min_diff) {\n            min_diff = diff;\n            result[0] = numbers[i];\n            result[1] = numbers[i + 1];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_71", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <limits>\n\nstd::vector<float> find_closest_elements(std::vector<float> numbers) {\n    std::sort(numbers.begin(), numbers.end());\n    float min_diff = std::numeric_limits<float>::max();\n    std::vector<float> result(2);\n    \n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = std::abs(numbers[i + 1] - numbers[i]);\n        if (diff < min_diff) {\n            min_diff = diff;\n            result[0] = numbers[i];\n            result[1] = numbers[i + 1];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_71", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <limits>\n\nstd::vector<float> find_closest_elements(std::vector<float> numbers) {\n    std::sort(numbers.begin(), numbers.end());\n    float min_diff = std::numeric_limits<float>::max();\n    std::vector<float> result(2);\n    \n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = std::abs(numbers[i + 1] - numbers[i]);\n        if (diff < min_diff) {\n            min_diff = diff;\n            result[0] = numbers[i];\n            result[1] = numbers[i + 1];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_72", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit(std::vector<float> numbers){\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    std::vector<float> result;\n    for (float num : numbers) {\n        result.push_back((num - min_val) / (max_val - min_val));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_72", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit(std::vector<float> numbers){\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    std::vector<float> result;\n    for (float num : numbers) {\n        result.push_back((num - min_val) / (max_val - min_val));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_72", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit(std::vector<float> numbers){\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    std::vector<float> result;\n    for (float num : numbers) {\n        result.push_back((num - min_val) / (max_val - min_val));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_72", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit(std::vector<float> numbers){\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    std::vector<float> result;\n    for (float num : numbers) {\n        result.push_back((num - min_val) / (max_val - min_val));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_72", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit(std::vector<float> numbers){\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    std::vector<float> result;\n    for (float num : numbers) {\n        result.push_back((num - min_val) / (max_val - min_val));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_73", "completion": "```cpp\nuint64_t largest_divisor(uint64_t n){\n    for(uint64_t i = n / 2; i >= 1; --i){\n        if(n % i == 0){\n            return i;\n        }\n    }\n    return 1;\n}\n```"}
{"task_id": "SimdBench_73", "completion": "```cpp\nuint64_t largest_divisor(uint64_t n){\n    for(uint64_t i = n / 2; i >= 1; --i){\n        if(n % i == 0){\n            return i;\n        }\n    }\n    return 1;\n}\n```"}
{"task_id": "SimdBench_73", "completion": "```cpp\nuint64_t largest_divisor(uint64_t n){\n    for(uint64_t i = n / 2; i >= 1; --i){\n        if(n % i == 0){\n            return i;\n        }\n    }\n    return 1;\n}\n```"}
{"task_id": "SimdBench_73", "completion": "```cpp\nuint64_t largest_divisor(uint64_t n){\n    for(uint64_t i = n / 2; i >= 1; --i){\n        if(n % i == 0){\n            return i;\n        }\n    }\n    return 1;\n}\n```"}
{"task_id": "SimdBench_73", "completion": "```cpp\nuint64_t largest_divisor(uint64_t n){\n    for(uint64_t i = n / 2; i >= 1; --i){\n        if(n % i == 0){\n            return i;\n        }\n    }\n    return 1;\n}\n```"}
{"task_id": "SimdBench_74", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> factorize(int n){\n    std::vector<int> factors;\n    if(n < 2) return factors;\n    \n    // Check for number of 2s that divide n\n    while(n % 2 == 0){\n        factors.push_back(2);\n        n /= 2;\n    }\n    \n    // Check for odd factors from 3 onwards\n    for(int i = 3; i * i <= n; i += 2){\n        while(n % i == 0){\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    \n    // If n is a prime number greater than 2\n    if(n > 2){\n        factors.push_back(n);\n    }\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_74", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> factorize(int n) {\n    std::vector<int> factors;\n    if (n < 2) return factors;\n    \n    // Check for number of 2s that divide n\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    \n    // Check for odd factors from 3 onwards\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    \n    // If n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_74", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> factorize(int n) {\n    std::vector<int> factors;\n    if (n < 2) return factors;\n    \n    // Check for number of 2s that divide n\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    \n    // Check for odd factors from 3 onwards\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    \n    // If n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_74", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> factorize(int n){\n    std::vector<int> factors;\n    if(n <= 1){\n        return factors;\n    }\n    // Extract the number of 2s that divide n\n    while(n % 2 == 0){\n        factors.push_back(2);\n        n /= 2;\n    }\n    // n must be odd at this point, so a skip of 2 (i.e., i = i + 2) can be used\n    for(int i = 3; i * i <= n; i += 2){\n        // While i divides n, add i and divide n\n        while(n % i == 0){\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    // This condition is to check if n is a prime number greater than 2\n    if(n > 2){\n        factors.push_back(n);\n    }\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> factorize(int n) {\n    std::vector<int> factors;\n    if (n < 2) return factors;\n    \n    // Handle 2 separately to allow increment of i by 2 later\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    \n    // Check for odd factors from 3 onwards\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    \n    // If remaining n is a prime number greater than 2\n    if (n > 2) {\n        factors.push_back(n);\n    }\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_75", "completion": "```cpp\nstd::vector<float> get_positive(const std::vector<float> & l){\n    std::vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75", "completion": "```cpp\n#include <vector>\n\nstd::vector<float> get_positive(const std::vector<float> & l){\n    std::vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75", "completion": "```cpp\nstd::vector<float> get_positive(const std::vector<float> & l){\n    std::vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75", "completion": "```cpp\n#include <vector>\n\nstd::vector<float> get_positive(const std::vector<float> & l){\n    std::vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75", "completion": "```cpp\n#include <vector>\n\nstd::vector<float> get_positive(const std::vector<float> & l){\n    std::vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_76", "completion": "```cpp\nbool is_prime(int64_t n){\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int64_t i = 5; i * i <= n; i += 6){\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76", "completion": "```cpp\nbool is_prime(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int64_t i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76", "completion": "```cpp\nbool is_prime(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int64_t i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76", "completion": "```cpp\nbool is_prime(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int64_t i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76", "completion": "```cpp\nbool is_prime(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int64_t i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_77", "completion": "```cpp\n#include <string>\n#include <algorithm>\n#include <cctype>\n\nstd::string solve(const std::string & s){\n    bool hasLetter = false;\n    std::string result = s;\n    \n    for (char c : s) {\n        if (std::isalpha(c)) {\n            hasLetter = true;\n            break;\n        }\n    }\n    \n    if (hasLetter) {\n        for (char &c : result) {\n            if (std::islower(c)) {\n                c = std::toupper(c);\n            } else if (std::isupper(c)) {\n                c = std::tolower(c);\n            }\n        }\n    } else {\n        std::reverse(result.begin(), result.end());\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_77", "completion": "```cpp\n#include <algorithm>\n\nstd::string solve(const std::string & s){\n    bool hasLetter = false;\n    std::string result = s;\n    for (char &c : result) {\n        if (isalpha(c)) {\n            hasLetter = true;\n            if (islower(c)) {\n                c = toupper(c);\n            } else {\n                c = tolower(c);\n            }\n        }\n    }\n    if (!hasLetter) {\n        std::reverse(result.begin(), result.end());\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_77", "completion": "```cpp\n#include <algorithm>\n\nstd::string solve(const std::string & s){\n    bool hasLetter = false;\n    std::string result = s;\n    for (char &c : result) {\n        if (isalpha(c)) {\n            hasLetter = true;\n            c = islower(c) ? toupper(c) : tolower(c);\n        }\n    }\n    if (!hasLetter) {\n        std::reverse(result.begin(), result.end());\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_77", "completion": "```cpp\n#include <algorithm>\n\nstd::string solve(const std::string & s){\n    bool hasLetter = false;\n    std::string result = s;\n    for (char &c : result) {\n        if (isalpha(c)) {\n            hasLetter = true;\n            c = islower(c) ? toupper(c) : tolower(c);\n        }\n    }\n    if (!hasLetter) {\n        std::reverse(result.begin(), result.end());\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_77", "completion": "```cpp\n#include <algorithm>\n\nstd::string solve(const std::string & s){\n    bool hasLetter = false;\n    std::string result = s;\n    for (char &c : result) {\n        if (isalpha(c)) {\n            hasLetter = true;\n            c = islower(c) ? toupper(c) : tolower(c);\n        }\n    }\n    if (!hasLetter) {\n        std::reverse(result.begin(), result.end());\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_78", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third(std::vector<int> l){\n    std::vector<int> indices;\n    std::vector<int> values;\n    \n    // Collect values at indices divisible by 3\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            indices.push_back(i);\n            values.push_back(l[i]);\n        }\n    }\n    \n    // Sort the collected values\n    std::sort(values.begin(), values.end());\n    \n    // Replace original values with sorted values\n    for (size_t j = 0; j < indices.size(); ++j) {\n        l[indices[j]] = values[j];\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_78", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third(std::vector<int> l) {\n    std::vector<int> indices;\n    std::vector<int> values;\n    \n    // Collect values at indices divisible by 3\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            indices.push_back(i);\n            values.push_back(l[i]);\n        }\n    }\n    \n    // Sort the collected values\n    std::sort(values.begin(), values.end());\n    \n    // Replace original values with sorted values\n    for (size_t j = 0; j < indices.size(); ++j) {\n        l[indices[j]] = values[j];\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_78", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third(std::vector<int> l){\n    std::vector<int> indices;\n    std::vector<int> values;\n    \n    // Collect values at indices divisible by 3\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            indices.push_back(i);\n            values.push_back(l[i]);\n        }\n    }\n    \n    // Sort the collected values\n    std::sort(values.begin(), values.end());\n    \n    // Replace original values with sorted values\n    for (size_t j = 0; j < indices.size(); ++j) {\n        l[indices[j]] = values[j];\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_78", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third(std::vector<int> l){\n    std::vector<int> indices;\n    std::vector<int> values;\n    \n    // Collect values at indices divisible by 3\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            indices.push_back(i);\n            values.push_back(l[i]);\n        }\n    }\n    \n    // Sort the collected values\n    std::sort(values.begin(), values.end());\n    \n    // Replace original values with sorted values\n    for (size_t j = 0; j < indices.size(); ++j) {\n        l[indices[j]] = values[j];\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_78", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third(std::vector<int> l) {\n    std::vector<int> indices;\n    std::vector<int> values;\n    \n    // Collect values at indices divisible by 3\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            indices.push_back(i);\n            values.push_back(l[i]);\n        }\n    }\n    \n    // Sort the collected values\n    std::sort(values.begin(), values.end());\n    \n    // Replace original values with sorted values\n    for (size_t j = 0; j < indices.size(); ++j) {\n        l[indices[j]] = values[j];\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_79", "completion": "```cpp\nfloat max_element(std::vector<float> l){\n    float max_val = l[0];\n    for (float num : l){\n        if (num > max_val){\n            max_val = num;\n        }\n    }\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79", "completion": "```cpp\nfloat max_element(std::vector<float> l){\n    float max_val = l[0];\n    for(float num : l){\n        if(num > max_val){\n            max_val = num;\n        }\n    }\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79", "completion": "```cpp\nfloat max_element(std::vector<float> l){\n    float max_val = l[0];\n    for(auto num : l){\n        if(num > max_val){\n            max_val = num;\n        }\n    }\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79", "completion": "```cpp\nfloat max_element(std::vector<float> l){\n    float max_val = l[0];\n    for(float num : l){\n        if(num > max_val){\n            max_val = num;\n        }\n    }\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79", "completion": "```cpp\nfloat max_element(std::vector<float> l){\n    float max_val = l[0];\n    for(auto num : l){\n        if(num > max_val){\n            max_val = num;\n        }\n    }\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_80", "completion": "```cpp\nint fizz_buzz(int n){\n    int count = 0;\n    for(int i = 0; i < n; ++i){\n        if(i % 11 == 0 || i % 13 == 0){\n            int num = i;\n            while(num > 0){\n                if(num % 10 == 7){\n                    count++;\n                }\n                num /= 10;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80", "completion": "```cpp\nint fizz_buzz(int n){\n    int count = 0;\n    for(int i = 0; i < n; ++i){\n        if(i % 11 == 0 || i % 13 == 0){\n            int num = i;\n            while(num > 0){\n                if(num % 10 == 7){\n                    count++;\n                }\n                num /= 10;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80", "completion": "```cpp\nint fizz_buzz(int n){\n    int count = 0;\n    for(int i = 0; i < n; ++i){\n        if(i % 11 == 0 || i % 13 == 0){\n            int num = i;\n            while(num > 0){\n                if(num % 10 == 7){\n                    count++;\n                }\n                num /= 10;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80", "completion": "```cpp\nint fizz_buzz(int n){\n    int count = 0;\n    for(int i = 0; i < n; ++i){\n        if(i % 11 == 0 || i % 13 == 0){\n            int num = i;\n            while(num > 0){\n                if(num % 10 == 7){\n                    count++;\n                }\n                num /= 10;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80", "completion": "```cpp\nint fizz_buzz(int n){\n    int count = 0;\n    for(int i = 0; i < n; ++i){\n        if(i % 11 == 0 || i % 13 == 0){\n            int num = i;\n            while(num > 0){\n                if(num % 10 == 7){\n                    count++;\n                }\n                num /= 10;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_81", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even(std::vector<float> l){\n    std::vector<float> even_values;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_values.push_back(l[i]);\n    }\n    std::sort(even_values.begin(), even_values.end());\n    size_t even_idx = 0;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        l[i] = even_values[even_idx++];\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_81", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even(std::vector<float> l){\n    std::vector<float> even_values;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_values.push_back(l[i]);\n    }\n    std::sort(even_values.begin(), even_values.end());\n    for (size_t i = 0, j = 0; i < l.size(); i += 2, ++j) {\n        l[i] = even_values[j];\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_81", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even(std::vector<float> l){\n    std::vector<float> even_values;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_values.push_back(l[i]);\n    }\n    std::sort(even_values.begin(), even_values.end());\n    size_t even_idx = 0;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        l[i] = even_values[even_idx++];\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_81", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even(std::vector<float> l){\n    std::vector<float> even_values;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_values.push_back(l[i]);\n    }\n    std::sort(even_values.begin(), even_values.end());\n    size_t even_idx = 0;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        l[i] = even_values[even_idx++];\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_81", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even(std::vector<float> l){\n    std::vector<float> even_values;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_values.push_back(l[i]);\n    }\n    std::sort(even_values.begin(), even_values.end());\n    for (size_t i = 0, j = 0; i < l.size(); i += 2, ++j) {\n        l[i] = even_values[j];\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_82", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool triples_sum_to_zero(std::vector<int> l) {\n    std::sort(l.begin(), l.end());\n    int n = l.size();\n    for (int i = 0; i < n - 2; ++i) {\n        if (i > 0 && l[i] == l[i - 1]) continue;\n        int left = i + 1, right = n - 1;\n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            if (sum == 0) {\n                return true;\n            } else if (sum < 0) {\n                ++left;\n            } else {\n                --right;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool triples_sum_to_zero(std::vector<int> l) {\n    std::sort(l.begin(), l.end());\n    int n = l.size();\n    for (int i = 0; i < n - 2; ++i) {\n        if (i > 0 && l[i] == l[i - 1]) continue; // Skip duplicate elements\n        int left = i + 1;\n        int right = n - 1;\n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            if (sum == 0) {\n                return true;\n            } else if (sum < 0) {\n                ++left;\n            } else {\n                --right;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool triples_sum_to_zero(std::vector<int> l) {\n    std::sort(l.begin(), l.end());\n    int n = l.size();\n    for (int i = 0; i < n - 2; ++i) {\n        if (i > 0 && l[i] == l[i - 1]) continue;\n        int left = i + 1;\n        int right = n - 1;\n        while (left < right) {\n            int total = l[i] + l[left] + l[right];\n            if (total == 0) {\n                return true;\n            } else if (total < 0) {\n                ++left;\n            } else {\n                --right;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool triples_sum_to_zero(std::vector<int> l) {\n    std::sort(l.begin(), l.end());\n    int n = l.size();\n    for (int i = 0; i < n - 2; ++i) {\n        if (i > 0 && l[i] == l[i - 1]) continue;\n        int left = i + 1;\n        int right = n - 1;\n        while (left < right) {\n            int total = l[i] + l[left] + l[right];\n            if (total == 0) {\n                return true;\n            } else if (total < 0) {\n                ++left;\n            } else {\n                --right;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool triples_sum_to_zero(std::vector<int> l) {\n    std::sort(l.begin(), l.end());\n    int n = l.size();\n    for (int i = 0; i < n - 2; ++i) {\n        if (i > 0 && l[i] == l[i - 1]) continue;\n        int left = i + 1;\n        int right = n - 1;\n        while (left < right) {\n            int total = l[i] + l[left] + l[right];\n            if (total == 0) {\n                return true;\n            } else if (total < 0) {\n                ++left;\n            } else {\n                --right;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_83", "completion": "```cpp\nstd::vector<int> incr_list(std::vector<int> l){\n    for(auto& num : l){\n        num += 1;\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_83", "completion": "```cpp\nstd::vector<int> incr_list(std::vector<int> l){\n    for(auto& num : l){\n        num += 1;\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_83", "completion": "```cpp\nstd::vector<int> incr_list(std::vector<int> l){\n    for(auto& num : l){\n        num += 1;\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_83", "completion": "```cpp\nstd::vector<int> incr_list(std::vector<int> l){\n    for(auto& num : l){\n        num += 1;\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_83", "completion": "```cpp\nstd::vector<int> incr_list(std::vector<int> l){\n    for(auto& num : l){\n        num += 1;\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_84", "completion": "```cpp\n#include <unordered_set>\n#include <vector>\n\nbool pairs_sum_to_zero(std::vector<int> l) {\n    std::unordered_set<int> seen;\n    for (int num : l) {\n        if (seen.count(-num)) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84", "completion": "```cpp\n#include <unordered_set>\n#include <vector>\n\nbool pairs_sum_to_zero(std::vector<int> l) {\n    std::unordered_set<int> seen;\n    for (int num : l) {\n        if (seen.count(-num)) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84", "completion": "```cpp\n#include <unordered_set>\n#include <vector>\n\nbool pairs_sum_to_zero(std::vector<int> l) {\n    std::unordered_set<int> seen;\n    for (int num : l) {\n        if (seen.count(-num)) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84", "completion": "```cpp\n#include <unordered_set>\n#include <vector>\n\nbool pairs_sum_to_zero(std::vector<int> l) {\n    std::unordered_set<int> seen;\n    for (int num : l) {\n        if (seen.count(-num)) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84", "completion": "```cpp\n#include <unordered_set>\n#include <vector>\n\nbool pairs_sum_to_zero(std::vector<int> l) {\n    std::unordered_set<int> seen;\n    for (int num : l) {\n        if (seen.count(-num)) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_85", "completion": "```cpp\n#include <string>\n#include <cstdint>\n\nstd::string change_base(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    std::string result;\n    while (x > 0) {\n        int remainder = x % base;\n        result.insert(result.begin(), '0' + remainder);\n        x /= base;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_85", "completion": "```cpp\n#include <string>\n#include <cstdint>\n\nstd::string change_base(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    std::string result;\n    while (x > 0) {\n        int remainder = x % base;\n        result.insert(result.begin(), '0' + remainder);\n        x /= base;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_85", "completion": "```cpp\n#include <string>\n#include <cstdint>\n\nstd::string change_base(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    std::string result;\n    while (x > 0) {\n        int remainder = x % base;\n        result.insert(result.begin(), '0' + remainder);\n        x /= base;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_85", "completion": "```cpp\n#include <string>\n#include <cstdint>\n\nstd::string change_base(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    std::string result;\n    while (x > 0) {\n        int remainder = x % base;\n        result.insert(result.begin(), '0' + remainder);\n        x /= base;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_85", "completion": "```cpp\n#include <string>\n#include <cstdint>\n\nstd::string change_base(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    std::string result;\n    while (x > 0) {\n        int remainder = x % base;\n        result.insert(result.begin(), '0' + remainder);\n        x /= base;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_86", "completion": "```cpp\nbool is_palindrome(std::string text){\n    int left = 0;\n    int right = text.length() - 1;\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_86", "completion": "```cpp\nbool is_palindrome(std::string text){\n    int left = 0;\n    int right = text.length() - 1;\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_86", "completion": "```cpp\nbool is_palindrome(std::string text){\n    int left = 0;\n    int right = text.length() - 1;\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_86", "completion": "```cpp\nbool is_palindrome(std::string text){\n    int left = 0;\n    int right = text.length() - 1;\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_86", "completion": "```cpp\nbool is_palindrome(std::string text){\n    int left = 0;\n    int right = text.length() - 1;\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_87", "completion": "```cpp\nstd::string decode_shift(std::string s){\n    std::string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]-5-(int)'a'+26)%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_87", "completion": "```cpp\nstd::string decode_shift(std::string s){\n    std::string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]-5-(int)'a'+26)%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_87", "completion": "```cpp\nstd::string decode_shift(std::string s){\n    std::string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]-5-(int)'a'+26)%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_87", "completion": "```cpp\nstd::string decode_shift(std::string s){\n    std::string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]-5-(int)'a'+26)%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_87", "completion": "```cpp\nstd::string decode_shift(std::string s){\n    std::string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]-5-(int)'a'+26)%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_88", "completion": "```cpp\nbool below_threshold(std::vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88", "completion": "```cpp\nbool below_threshold(std::vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88", "completion": "```cpp\nbool below_threshold(std::vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88", "completion": "```cpp\nbool below_threshold(std::vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88", "completion": "```cpp\nbool below_threshold(std::vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_89", "completion": "```cpp\nbool correct_bracketing(std::string brackets){\n    int balance = 0;\n    for(char c : brackets){\n        if(c == '<'){\n            balance++;\n        } else if(c == '>'){\n            balance--;\n        }\n        if(balance < 0){\n            return false;\n        }\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89", "completion": "```cpp\nbool correct_bracketing(std::string brackets){\n    int balance = 0;\n    for(char c : brackets){\n        if(c == '<'){\n            balance++;\n        } else if(c == '>'){\n            balance--;\n        }\n        if(balance < 0){\n            return false;\n        }\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89", "completion": "```cpp\nbool correct_bracketing(std::string brackets){\n    int balance = 0;\n    for(char c : brackets){\n        if(c == '<'){\n            balance++;\n        } else if(c == '>'){\n            balance--;\n        }\n        if(balance < 0){\n            return false;\n        }\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89", "completion": "```cpp\nbool correct_bracketing(std::string brackets){\n    int balance = 0;\n    for(char c : brackets){\n        if(c == '<'){\n            balance++;\n        } else if(c == '>'){\n            balance--;\n        }\n        if(balance < 0){\n            return false;\n        }\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89", "completion": "```cpp\nbool correct_bracketing(std::string brackets){\n    int balance = 0;\n    for(char c : brackets){\n        if(c == '<'){\n            balance++;\n        } else if(c == '>'){\n            balance--;\n        }\n        if(balance < 0){\n            return false;\n        }\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90", "completion": "```cpp\nbool correct_bracketing(std::string brackets){\n    int balance = 0;\n    for(char c : brackets){\n        if(c == '('){\n            balance++;\n        } else if(c == ')'){\n            balance--;\n        }\n        if(balance < 0){\n            return false;\n        }\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90", "completion": "```cpp\nbool correct_bracketing(std::string brackets){\n    int balance = 0;\n    for(char c : brackets){\n        if(c == '('){\n            balance++;\n        } else if(c == ')'){\n            balance--;\n        }\n        if(balance < 0){\n            return false;\n        }\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90", "completion": "```cpp\nbool correct_bracketing(std::string brackets){\n    int balance = 0;\n    for(char c : brackets){\n        if(c == '('){\n            balance++;\n        } else if(c == ')'){\n            balance--;\n        }\n        if(balance < 0){\n            return false;\n        }\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90", "completion": "```cpp\nbool correct_bracketing(std::string brackets){\n    int balance = 0;\n    for(char c : brackets){\n        if(c == '('){\n            balance++;\n        } else if(c == ')'){\n            balance--;\n        }\n        if(balance < 0){\n            return false;\n        }\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90", "completion": "```cpp\nbool correct_bracketing(std::string brackets){\n    int balance = 0;\n    for(char c : brackets){\n        if(c == '('){\n            balance++;\n        } else if(c == ')'){\n            balance--;\n        }\n        if(balance < 0){\n            return false;\n        }\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_91", "completion": "```cpp\nstd::vector<float> derivative(std::vector<float> xs){\n    std::vector<float> result;\n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(xs[i] * static_cast<float>(i));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_91", "completion": "```cpp\nstd::vector<float> derivative(std::vector<float> xs){\n    std::vector<float> result;\n    for(int i = 1; i < xs.size(); ++i){\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_91", "completion": "```cpp\nstd::vector<float> derivative(std::vector<float> xs){\n    std::vector<float> result;\n    for(int i = 1; i < xs.size(); ++i){\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_91", "completion": "```cpp\nstd::vector<float> derivative(std::vector<float> xs){\n    std::vector<float> result;\n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(xs[i] * static_cast<float>(i));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_91", "completion": "```cpp\nstd::vector<float> derivative(std::vector<float> xs){\n    std::vector<float> result;\n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(xs[i] * static_cast<float>(i));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_92", "completion": "```cpp\nint vowels_count(std::string s){\n    int count = 0;\n    int n = s.length();\n    std::string vowels = \"aeiou\";\n    for(int i = 0; i < n; ++i){\n        char c = tolower(s[i]);\n        if(vowels.find(c) != std::string::npos){\n            count++;\n        }\n    }\n    if(n > 0 && tolower(s[n-1]) == 'y'){\n        count++;\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_92", "completion": "```cpp\nint vowels_count(std::string s){\n    int count = 0;\n    int n = s.length();\n    std::string vowels = \"aeiou\";\n    for(int i = 0; i < n; ++i){\n        char c = tolower(s[i]);\n        if(vowels.find(c) != std::string::npos){\n            count++;\n        }\n    }\n    if(n > 0 && tolower(s[n-1]) == 'y'){\n        count++;\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_92", "completion": "```cpp\nint vowels_count(std::string s){\n    int count = 0;\n    int n = s.length();\n    std::string vowels = \"aeiou\";\n    \n    for(int i = 0; i < n; ++i){\n        char c = tolower(s[i]);\n        if(vowels.find(c) != std::string::npos){\n            count++;\n        }\n    }\n    \n    if(n > 0 && tolower(s[n-1]) == 'y'){\n        count++;\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_92", "completion": "```cpp\nint vowels_count(std::string s){\n    int count = 0;\n    int n = s.length();\n    std::string vowels = \"aeiou\";\n    for(int i = 0; i < n; ++i){\n        char c = tolower(s[i]);\n        if(vowels.find(c) != std::string::npos){\n            count++;\n        }\n    }\n    if(n > 0 && tolower(s[n-1]) == 'y'){\n        count++;\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_92", "completion": "```cpp\nint vowels_count(std::string s){\n    int count = 0;\n    int n = s.length();\n    std::string vowels = \"aeiou\";\n    for(int i = 0; i < n; ++i){\n        char c = tolower(s[i]);\n        if(vowels.find(c) != std::string::npos){\n            count++;\n        }\n    }\n    if(n > 0 && tolower(s[n-1]) == 'y'){\n        count++;\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_93", "completion": "```cpp\nint digitSum(std::string s){\n    int sum = 0;\n    for(char c : s){\n        if(isupper(c)){\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93", "completion": "```cpp\nint digitSum(std::string s){\n    int sum = 0;\n    for(char c : s){\n        if(isupper(c)){\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93", "completion": "```cpp\nint digitSum(std::string s){\n    int sum = 0;\n    for(char c : s){\n        if(isupper(c)){\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93", "completion": "```cpp\nint digitSum(std::string s){\n    int sum = 0;\n    for(char c : s){\n        if(isupper(c)){\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93", "completion": "```cpp\nint digitSum(std::string s){\n    int sum = 0;\n    for(char c : s){\n        if(isupper(c)){\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_94", "completion": "```cpp\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck(std::vector<int> arr) {\n    int minEven = std::numeric_limits<int>::max();\n    int minIndex = -1;\n    \n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) {\n            if (arr[i] < minEven) {\n                minEven = arr[i];\n                minIndex = i;\n            }\n        }\n    }\n    \n    if (minIndex == -1) {\n        return {};\n    } else {\n        return {minEven, minIndex};\n    }\n}\n```"}
{"task_id": "SimdBench_94", "completion": "```cpp\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck(std::vector<int> arr) {\n    int minEven = std::numeric_limits<int>::max();\n    int minIndex = -1;\n    \n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) { // Check if the value is even\n            if (arr[i] < minEven || (arr[i] == minEven && i < minIndex)) {\n                minEven = arr[i];\n                minIndex = i;\n            }\n        }\n    }\n    \n    if (minIndex == -1) {\n        return {}; // No even values found\n    }\n    \n    return {minEven, minIndex};\n}\n```"}
{"task_id": "SimdBench_94", "completion": "```cpp\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck(std::vector<int> arr) {\n    int minEven = std::numeric_limits<int>::max();\n    int minIndex = -1;\n    \n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) {\n            if (arr[i] < minEven) {\n                minEven = arr[i];\n                minIndex = i;\n            }\n        }\n    }\n    \n    if (minIndex == -1) {\n        return {};\n    } else {\n        return {minEven, minIndex};\n    }\n}\n```"}
{"task_id": "SimdBench_94", "completion": "```cpp\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck(std::vector<int> arr) {\n    int minEven = std::numeric_limits<int>::max();\n    int minIndex = -1;\n    \n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) { // Check if the value is even\n            if (arr[i] < minEven) {\n                minEven = arr[i];\n                minIndex = i;\n            }\n        }\n    }\n    \n    if (minIndex != -1) {\n        return {minEven, minIndex};\n    }\n    \n    return {};\n}\n```"}
{"task_id": "SimdBench_94", "completion": "```cpp\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck(std::vector<int> arr) {\n    int minEven = std::numeric_limits<int>::max();\n    int minIndex = -1;\n    \n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) {\n            if (arr[i] < minEven) {\n                minEven = arr[i];\n                minIndex = i;\n            }\n        }\n    }\n    \n    if (minIndex == -1) {\n        return {};\n    } else {\n        return {minEven, minIndex};\n    }\n}\n```"}
{"task_id": "SimdBench_95", "completion": "```cpp\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint search(std::vector<int> lst){\n    std::unordered_map<int, int> freq;\n    for(auto num : lst){\n        freq[num]++;\n    }\n    int result = -1;\n    for(const auto &entry : freq){\n        if(entry.first > 0 && entry.second >= entry.first){\n            result = std::max(result, entry.first);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_95", "completion": "```cpp\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint search(std::vector<int> lst){\n    std::unordered_map<int, int> freq;\n    for(auto num : lst){\n        freq[num]++;\n    }\n    int result = -1;\n    for(const auto &entry : freq){\n        if(entry.first > 0 && entry.second >= entry.first){\n            result = std::max(result, entry.first);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_95", "completion": "```cpp\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint search(std::vector<int> lst){\n    std::unordered_map<int, int> freq;\n    for(auto num : lst){\n        freq[num]++;\n    }\n    int result = -1;\n    for(const auto &entry : freq){\n        if(entry.first > 0 && entry.second >= entry.first){\n            result = std::max(result, entry.first);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_95", "completion": "```cpp\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint search(std::vector<int> lst){\n    std::unordered_map<int, int> freq;\n    for(auto num : lst){\n        freq[num]++;\n    }\n    int result = -1;\n    for(const auto &entry : freq){\n        if(entry.first > 0 && entry.second >= entry.first){\n            result = std::max(result, entry.first);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_95", "completion": "```cpp\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint search(std::vector<int> lst){\n    std::unordered_map<int, int> freq;\n    for(auto num : lst){\n        if(num > 0){\n            freq[num]++;\n        }\n    }\n    int result = -1;\n    for(const auto &entry : freq){\n        if(entry.first > 0 && entry.second >= entry.first){\n            result = std::max(result, entry.first);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_96", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool will_it_fly(std::vector<int> q, int w) {\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    if (sum > w) {\n        return false;\n    }\n    std::vector<int> reversed_q = q;\n    std::reverse(reversed_q.begin(), reversed_q.end());\n    return q == reversed_q;\n}\n```"}
{"task_id": "SimdBench_96", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool will_it_fly(std::vector<int> q, int w) {\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    if (sum > w) {\n        return false;\n    }\n    std::vector<int> reversed_q = q;\n    std::reverse(reversed_q.begin(), reversed_q.end());\n    return q == reversed_q;\n}\n```"}
{"task_id": "SimdBench_96", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool will_it_fly(std::vector<int> q, int w) {\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    if (sum > w) {\n        return false;\n    }\n    std::vector<int> reversed_q = q;\n    std::reverse(reversed_q.begin(), reversed_q.end());\n    return q == reversed_q;\n}\n```"}
{"task_id": "SimdBench_96", "completion": "```cpp\nbool will_it_fly(std::vector<int> q, int w) {\n    int sum = 0;\n    int n = q.size();\n    for (int i = 0; i < n; ++i) {\n        sum += q[i];\n        if (q[i] != q[n - 1 - i]) {\n            return false;\n        }\n    }\n    return sum <= w;\n}\n```"}
{"task_id": "SimdBench_96", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool will_it_fly(std::vector<int> q, int w) {\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    if (sum > w) {\n        return false;\n    }\n    std::vector<int> reversed_q = q;\n    std::reverse(reversed_q.begin(), reversed_q.end());\n    return q == reversed_q;\n}\n```"}
{"task_id": "SimdBench_97", "completion": "```cpp\nint smallest_change(std::vector<int> arr){\n    int n = arr.size();\n    int changes = 0;\n    for(int i = 0; i < n / 2; ++i){\n        if(arr[i] != arr[n - 1 - i]){\n            changes++;\n        }\n    }\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97", "completion": "```cpp\nint smallest_change(std::vector<int> arr){\n    int n = arr.size();\n    int changes = 0;\n    for(int i = 0; i < n / 2; ++i){\n        if(arr[i] != arr[n - 1 - i]){\n            changes++;\n        }\n    }\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nint smallest_change(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    for(int i = 0; i < n / 2; ++i){\n        if(arr[i] != arr[n - 1 - i]){\n            changes++;\n        }\n    }\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97", "completion": "```cpp\nint smallest_change(std::vector<int> arr){\n    int n = arr.size();\n    int changes = 0;\n    for(int i = 0; i < n / 2; ++i){\n        if(arr[i] != arr[n - 1 - i]){\n            changes++;\n        }\n    }\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97", "completion": "```cpp\nint smallest_change(std::vector<int> arr){\n    int n = arr.size();\n    int changes = 0;\n    for(int i = 0; i < n / 2; ++i){\n        if(arr[i] != arr[n - 1 - i]){\n            changes++;\n        }\n    }\n    return changes;\n}\n```"}
{"task_id": "SimdBench_98", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <numeric>\n\nstd::vector<std::string> total_match(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    auto count_chars = [](const std::vector<std::string>& lst) {\n        return std::accumulate(lst.begin(), lst.end(), 0, [](int sum, const std::string& s) {\n            return sum + s.size();\n        });\n    };\n\n    int chars1 = count_chars(lst1);\n    int chars2 = count_chars(lst2);\n\n    if (chars1 <= chars2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <numeric>\n\nstd::vector<std::string> total_match(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    auto count_chars = [](const std::vector<std::string>& lst) {\n        return std::accumulate(lst.begin(), lst.end(), 0, [](int sum, const std::string& s) {\n            return sum + s.size();\n        });\n    };\n\n    int chars1 = count_chars(lst1);\n    int chars2 = count_chars(lst2);\n\n    if (chars1 <= chars2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <numeric>\n\nstd::vector<std::string> total_match(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    auto count_chars = [](const std::vector<std::string>& lst) {\n        return std::accumulate(lst.begin(), lst.end(), 0, [](int sum, const std::string& s) {\n            return sum + s.size();\n        });\n    };\n\n    int chars1 = count_chars(lst1);\n    int chars2 = count_chars(lst2);\n\n    if (chars1 <= chars2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <numeric>\n\nstd::vector<std::string> total_match(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    auto count_chars = [](const std::vector<std::string>& lst) {\n        return std::accumulate(lst.begin(), lst.end(), 0, [](int sum, const std::string& s) {\n            return sum + s.size();\n        });\n    };\n\n    int chars1 = count_chars(lst1);\n    int chars2 = count_chars(lst2);\n\n    if (chars1 <= chars2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <numeric>\n\nstd::vector<std::string> total_match(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    auto count_chars = [](const std::vector<std::string>& lst) {\n        return std::accumulate(lst.begin(), lst.end(), 0, [](int sum, const std::string& s) {\n            return sum + s.size();\n        });\n    };\n    \n    int chars1 = count_chars(lst1);\n    int chars2 = count_chars(lst2);\n    \n    if (chars1 <= chars2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_99", "completion": "```cpp\nbool is_simple_power(uint64_t x, uint64_t n){\n    if (n == 0) return x == 0;\n    if (n == 1) return x == 1;\n    if (x == 1) return true;\n    uint64_t power = 1;\n    while (power < x) {\n        if (power > UINT64_MAX / n) break; // Prevent overflow\n        power *= n;\n    }\n    return power == x;\n}\n```"}
{"task_id": "SimdBench_99", "completion": "```cpp\nbool is_simple_power(uint64_t x, uint64_t n){\n    if (n == 0) return x == 0;\n    if (n == 1) return x == 1;\n    if (x == 1) return true;\n    uint64_t power = n;\n    while (power < x) {\n        power *= n;\n    }\n    return power == x;\n}\n```"}
{"task_id": "SimdBench_99", "completion": "```cpp\nbool is_simple_power(uint64_t x, uint64_t n){\n    if (n == 0) return x == 0;\n    if (n == 1) return x == 1;\n    if (x == 1) return true;\n    uint64_t power = 1;\n    while (power < x) {\n        if (power > UINT64_MAX / n) break; // Prevent overflow\n        power *= n;\n    }\n    return power == x;\n}\n```"}
{"task_id": "SimdBench_99", "completion": "```cpp\nbool is_simple_power(uint64_t x, uint64_t n){\n    if (n == 0) return x == 0;\n    if (n == 1) return x == 1;\n    if (x == 1) return true;\n    uint64_t power = 1;\n    while (power < x) {\n        if (power > UINT64_MAX / n) break; // Prevent overflow\n        power *= n;\n    }\n    return power == x;\n}\n```"}
{"task_id": "SimdBench_99", "completion": "```cpp\nbool is_simple_power(uint64_t x, uint64_t n){\n    if (n == 0) return x == 0;\n    if (n == 1) return x == 1;\n    if (x == 1) return true;\n    uint64_t power = 1;\n    while (power < x) {\n        if (power > UINT64_MAX / n) break; // Prevent overflow\n        power *= n;\n    }\n    return power == x;\n}\n```"}
{"task_id": "SimdBench_100", "completion": "```cpp\nint hex_key(const std::string & num){\n    int count = 0;\n    for(char c : num){\n        if(c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D'){\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_100", "completion": "```cpp\nint hex_key(const std::string & num){\n    int count = 0;\n    for(char c : num){\n        if(c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D'){\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_100", "completion": "```cpp\nint hex_key(const std::string & num){\n    int count = 0;\n    for(char c : num){\n        if(c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D'){\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_100", "completion": "```cpp\nint hex_key(const std::string & num){\n    int count = 0;\n    for(char c : num){\n        if(c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D'){\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_100", "completion": "```cpp\nint hex_key(const std::string & num){\n    int count = 0;\n    for(char c : num){\n        if(c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D'){\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_101", "completion": "```cpp\nbool is_happy(const std::string & s){\n    if (s.length() < 3) return false;\n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_101", "completion": "```cpp\nbool is_happy(const std::string & s){\n    if (s.length() < 3) return false;\n    for (size_t i = 0; i < s.length() - 2; ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_101", "completion": "```cpp\nbool is_happy(const std::string & s){\n    if (s.length() < 3) return false;\n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_101", "completion": "```cpp\nbool is_happy(const std::string & s){\n    if (s.length() < 3) return false;\n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_101", "completion": "```cpp\nbool is_happy(const std::string & s){\n    if (s.length() < 3) return false;\n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_102", "completion": "```cpp\nbool prime_length(const std::string & str){\n    int n = str.length();\n    if (n < 2) return false;\n    for(int i = 2; i * i <= n; ++i){\n        if(n % i == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_102", "completion": "```cpp\nbool prime_length(const std::string & str){\n    int n = str.length();\n    if (n < 2) return false;\n    for(int i = 2; i * i <= n; ++i){\n        if(n % i == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_102", "completion": "```cpp\nbool prime_length(const std::string & str){\n    int n = str.length();\n    if (n < 2) return false;\n    for(int i = 2; i * i <= n; ++i){\n        if(n % i == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_102", "completion": "```cpp\nbool prime_length(const std::string & str){\n    int n = str.length();\n    if (n < 2) return false;\n    for(int i = 2; i * i <= n; ++i){\n        if(n % i == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_102", "completion": "```cpp\nbool prime_length(const std::string & str){\n    int length = str.length();\n    if (length < 2) return false;\n    for(int i = 2; i * i <= length; ++i){\n        if(length % i == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_103", "completion": "```cpp\n#include <string>\n\nstd::string solve(uint64_t N){\n    int sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n    std::string binary = \"\";\n    if (sum == 0) return \"0\";\n    while (sum > 0) {\n        binary = char('0' + (sum % 2)) + binary;\n        sum /= 2;\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103", "completion": "```cpp\n#include <string>\n\nstd::string solve(uint64_t N){\n    int sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n    std::string binary = \"\";\n    if (sum == 0) return \"0\";\n    while (sum > 0) {\n        binary = char('0' + (sum % 2)) + binary;\n        sum /= 2;\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103", "completion": "```cpp\n#include <string>\n\nstd::string solve(uint64_t N){\n    int sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n    std::string binary = \"\";\n    if (sum == 0) return \"0\";\n    while (sum > 0) {\n        binary = char('0' + (sum % 2)) + binary;\n        sum /= 2;\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103", "completion": "```cpp\n#include <string>\n\nstd::string solve(uint64_t N){\n    int sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n    std::string binary = \"\";\n    if (sum == 0) return \"0\";\n    while (sum > 0) {\n        binary = char('0' + (sum % 2)) + binary;\n        sum /= 2;\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103", "completion": "```cpp\n#include <string>\n\nstd::string solve(uint64_t N){\n    int sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n    std::string binary = \"\";\n    if (sum == 0) return \"0\";\n    while (sum > 0) {\n        binary = char('0' + (sum % 2)) + binary;\n        sum /= 2;\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_104", "completion": "```cpp\nint add(std::vector<int> lst){\n    int sum = 0;\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104", "completion": "```cpp\nint add(std::vector<int> lst){\n    int sum = 0;\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104", "completion": "```cpp\nint add(std::vector<int> lst){\n    int sum = 0;\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104", "completion": "```cpp\nint add(std::vector<int> lst){\n    int sum = 0;\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104", "completion": "```cpp\nint add(std::vector<int> lst){\n    int sum = 0;\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_105", "completion": "```cpp\n#include <string>\n\nstd::string encrypt(const std::string & s){\n    std::string result;\n    for(char c : s){\n        if(c >= 'a' && c <= 'z'){\n            char shifted = ((c - 'a' + 4) % 26) + 'a';\n            result += shifted;\n        }\n        else if(c >= 'A' && c <= 'Z'){\n            char shifted = ((c - 'A' + 4) % 26) + 'A';\n            result += shifted;\n        }\n        else{\n            result += c; // Non-alphabetic characters remain unchanged\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_105", "completion": "```cpp\n#include <string>\n\nstd::string encrypt(const std::string & s){\n    std::string result;\n    for(char c : s){\n        if(c >= 'a' && c <= 'z'){\n            // Calculate the new character with rotation\n            char rotated = ((c - 'a' + 8) % 26) + 'a';\n            result += rotated;\n        }\n        else if(c >= 'A' && c <= 'Z'){\n            // Handle uppercase letters if needed\n            char rotated = ((c - 'A' + 8) % 26) + 'A';\n            result += rotated;\n        }\n        else{\n            // Non-alphabetic characters are unchanged\n            result += c;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_105", "completion": "```cpp\n#include <string>\n\nstd::string encrypt(const std::string & s){\n    std::string result;\n    for(char c : s){\n        if(c >= 'a' && c <= 'z'){\n            // Calculate the new character with a shift of 2 * 2 = 4 places\n            char shifted = ((c - 'a' + 4) % 26) + 'a';\n            result += shifted;\n        }\n        else if(c >= 'A' && c <= 'Z'){\n            // Handle uppercase letters if needed\n            char shifted = ((c - 'A' + 4) % 26) + 'A';\n            result += shifted;\n        }\n        else{\n            // Non-alphabetic characters are unchanged\n            result += c;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_105", "completion": "```cpp\n#include <string>\n\nstd::string encrypt(const std::string & s){\n    std::string result;\n    for(char c : s){\n        if(c >= 'a' && c <= 'z'){\n            // Calculate the new character with a shift of 2 * 2 = 4 places\n            char shifted = ((c - 'a' + 4) % 26) + 'a';\n            result += shifted;\n        }\n        else if(c >= 'A' && c <= 'Z'){\n            // Handle uppercase letters if needed\n            char shifted = ((c - 'A' + 4) % 26) + 'A';\n            result += shifted;\n        }\n        else{\n            // Non-alphabetic characters are unchanged\n            result += c;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_105", "completion": "```cpp\n#include <string>\n\nstd::string encrypt(const std::string & s){\n    std::string result;\n    for(char c : s){\n        if('a' <= c && c <= 'z'){\n            char shifted = ((c - 'a' + 4) % 26) + 'a';\n            result += shifted;\n        }\n        else if('A' <= c && c <= 'Z'){\n            char shifted = ((c - 'A' + 4) % 26) + 'A';\n            result += shifted;\n        }\n        else{\n            result += c; // Non-alphabetic characters remain unchanged\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_106", "completion": "```cpp\n#include <string>\n#include <cctype>\n\nstd::string encode(const std::string & message){\n    std::string encoded;\n    for(char c : message){\n        if(std::isalpha(c)){\n            // Swap case\n            char swapped = std::islower(c) ? std::toupper(c) : std::tolower(c);\n            \n            // Check if the swapped character is a vowel and replace accordingly\n            if(swapped == 'A') swapped = 'C';\n            else if(swapped == 'E') swapped = 'G';\n            else if(swapped == 'I') swapped = 'K';\n            else if(swapped == 'O') swapped = 'Q';\n            else if(swapped == 'U') swapped = 'W';\n            else if(swapped == 'a') swapped = 'c';\n            else if(swapped == 'e') swapped = 'g';\n            else if(swapped == 'i') swapped = 'k';\n            else if(swapped == 'o') swapped = 'q';\n            else if(swapped == 'u') swapped = 'w';\n            \n            encoded += swapped;\n        }\n        else{\n            encoded += c; // Non-alphabetic characters are unchanged\n        }\n    }\n    return encoded;\n}\n```"}
{"task_id": "SimdBench_106", "completion": "```cpp\n#include <string>\n\nstd::string encode(const std::string & message){\n    std::string encoded;\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowel_replacements = \"cgikmoCGIKMO\"; // Vowels shifted by 2 positions\n    \n    for(char c : message){\n        if(isalpha(c)){\n            // Swap case\n            char swapped = islower(c) ? toupper(c) : tolower(c);\n            \n            // Check if the swapped character is a vowel\n            size_t pos = vowels.find(swapped);\n            if(pos != std::string::npos){\n                // Replace vowel with corresponding replacement\n                swapped = vowel_replacements[pos];\n            }\n            \n            encoded += swapped;\n        }\n        else{\n            // Non-alphabetic characters are unchanged (though problem assumes only letters)\n            encoded += c;\n        }\n    }\n    \n    return encoded;\n}\n```"}
{"task_id": "SimdBench_106", "completion": "```cpp\n#include <string>\n#include <cctype>\n\nstd::string encode(const std::string & message){\n    std::string encoded;\n    for(char c : message){\n        if(std::isalpha(c)){\n            // Swap case\n            char swapped = std::islower(c) ? std::toupper(c) : std::tolower(c);\n            \n            // Check if the swapped character is a vowel and replace accordingly\n            if(swapped == 'A') swapped = 'C';\n            else if(swapped == 'E') swapped = 'G';\n            else if(swapped == 'I') swapped = 'K';\n            else if(swapped == 'O') swapped = 'Q';\n            else if(swapped == 'U') swapped = 'W';\n            else if(swapped == 'a') swapped = 'c';\n            else if(swapped == 'e') swapped = 'g';\n            else if(swapped == 'i') swapped = 'k';\n            else if(swapped == 'o') swapped = 'q';\n            else if(swapped == 'u') swapped = 'w';\n            \n            encoded += swapped;\n        }\n        else{\n            encoded += c; // Non-alphabetic characters are unchanged\n        }\n    }\n    return encoded;\n}\n```"}
{"task_id": "SimdBench_106", "completion": "```cpp\n#include <string>\n#include <cctype>\n\nstd::string encode(const std::string & message){\n    std::string encoded;\n    for(char c : message){\n        if(std::isalpha(c)){\n            // Swap case\n            char swapped = std::islower(c) ? std::toupper(c) : std::tolower(c);\n            \n            // Check if the swapped character is a vowel and replace accordingly\n            if(swapped == 'A') swapped = 'C';\n            else if(swapped == 'E') swapped = 'G';\n            else if(swapped == 'I') swapped = 'K';\n            else if(swapped == 'O') swapped = 'Q';\n            else if(swapped == 'U') swapped = 'W';\n            else if(swapped == 'a') swapped = 'c';\n            else if(swapped == 'e') swapped = 'g';\n            else if(swapped == 'i') swapped = 'k';\n            else if(swapped == 'o') swapped = 'q';\n            else if(swapped == 'u') swapped = 'w';\n            \n            encoded += swapped;\n        }\n        else{\n            encoded += c; // Non-alphabetic characters are unchanged\n        }\n    }\n    return encoded;\n}\n```"}
{"task_id": "SimdBench_106", "completion": "```cpp\n#include <string>\n#include <cctype>\n\nstd::string encode(const std::string & message) {\n    std::string result;\n    for (char c : message) {\n        if (std::isalpha(c)) {\n            // Swap case\n            char swapped = std::islower(c) ? std::toupper(c) : std::tolower(c);\n            \n            // Check if the character is a vowel and replace accordingly\n            if (swapped == 'A' || swapped == 'a') {\n                swapped = 'C';\n            } else if (swapped == 'E' || swapped == 'e') {\n                swapped = 'G';\n            } else if (swapped == 'I' || swapped == 'i') {\n                swapped = 'K';\n            } else if (swapped == 'O' || swapped == 'o') {\n                swapped = 'Q';\n            } else if (swapped == 'U' || swapped == 'u') {\n                swapped = 'W';\n            }\n            result += swapped;\n        } else {\n            result += c; // Non-alphabetic characters are unchanged\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_107", "completion": "```cpp\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_dict_case(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        for (char c : key) {\n            if (!std::islower(c)) all_lower = false;\n            if (!std::isupper(c)) all_upper = false;\n        }\n        if (!all_lower && !all_upper) return false;\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107", "completion": "```cpp\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_dict_case(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    bool hasLower = false, hasUpper = false;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        bool isLower = true, isUpper = true;\n\n        for (char c : key) {\n            if (!std::isalpha(c)) {\n                return false; // Non-alphabetic character found\n            }\n            if (!std::islower(c)) isLower = false;\n            if (!std::isupper(c)) isUpper = false;\n        }\n\n        if (isLower) hasLower = true;\n        if (isUpper) hasUpper = true;\n\n        if (hasLower && hasUpper) return false; // Mixed case detected\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_107", "completion": "```cpp\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_dict_case(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    bool hasLower = false, hasUpper = false;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        if (key.empty()) continue; // Skip empty keys\n\n        bool isLower = true, isUpper = true;\n        for (char c : key) {\n            if (!std::isalpha(c)) {\n                return false; // Non-alphabetic character found\n            }\n            if (!std::islower(c)) isLower = false;\n            if (!std::isupper(c)) isUpper = false;\n        }\n\n        if (isLower) hasLower = true;\n        if (isUpper) hasUpper = true;\n\n        if (hasLower && hasUpper) return false; // Mixed case detected\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_107", "completion": "```cpp\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_dict_case(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    bool hasLower = false, hasUpper = false;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        bool isLower = true, isUpper = true;\n\n        for (char c : key) {\n            if (!std::isalpha(c)) {\n                return false; // Non-alphabetic character found\n            }\n            if (!std::islower(c)) isLower = false;\n            if (!std::isupper(c)) isUpper = false;\n        }\n\n        if (isLower) hasLower = true;\n        if (isUpper) hasUpper = true;\n\n        if (hasLower && hasUpper) {\n            return false; // Mixed case detected\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_107", "completion": "```cpp\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_dict_case(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        for (char c : key) {\n            if (!std::islower(c)) all_lower = false;\n            if (!std::isupper(c)) all_upper = false;\n        }\n        if (!all_lower && !all_upper) return false;\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_108", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> count_up_to(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n\n    for (int i = 2; i < n; ++i) {\n        bool is_prime = true;\n        for (int j = 2; j * j <= i; ++j) {\n            if (i % j == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if (is_prime) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> count_up_to(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n\n    for (int i = 2; i < n; ++i) {\n        bool is_prime = true;\n        for (int j = 2; j * j <= i; ++j) {\n            if (i % j == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if (is_prime) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> count_up_to(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n\n    for (int i = 2; i < n; ++i) {\n        bool is_prime = true;\n        for (int j = 2; j * j <= i; ++j) {\n            if (i % j == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if (is_prime) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> count_up_to(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n\n    for (int i = 2; i < n; ++i) {\n        bool is_prime = true;\n        for (int j = 2; j * j <= i; ++j) {\n            if (i % j == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if (is_prime) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> count_up_to(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n\n    for (int i = 2; i < n; ++i) {\n        bool is_prime = true;\n        for (int j = 2; j * j <= i; ++j) {\n            if (i % j == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if (is_prime) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n```"}
{"task_id": "SimdBench_109", "completion": "```cpp\nint count_upper(const std::string & s){\n    int count = 0;\n    for (size_t i = 0; i < s.length(); ++i) {\n        if (i % 2 == 0 && isupper(s[i]) && (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            ++count;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_109", "completion": "```cpp\nint count_upper(const std::string & s){\n    int count = 0;\n    for (size_t i = 0; i < s.length(); ++i) {\n        if (i % 2 == 0 && isupper(s[i]) && (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            ++count;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_109", "completion": "```cpp\nint count_upper(const std::string & s){\n    int count = 0;\n    for (size_t i = 0; i < s.length(); ++i) {\n        if (i % 2 == 0 && isupper(s[i]) && (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            ++count;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_109", "completion": "```cpp\nint count_upper(const std::string & s){\n    int count = 0;\n    for (size_t i = 0; i < s.length(); ++i) {\n        if (i % 2 == 0 && isupper(s[i]) && (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            ++count;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_109", "completion": "```cpp\nint count_upper(const std::string & s){\n    int count = 0;\n    for (size_t i = 0; i < s.length(); ++i) {\n        if (i % 2 == 0 && isupper(s[i]) && (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            ++count;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_110", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> make_a_pile(int n) {\n    std::vector<int> result;\n    int current = n;\n    for (int i = 0; i < n; ++i) {\n        result.push_back(current);\n        current += 2;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_110", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> make_a_pile(int n) {\n    std::vector<int> result;\n    int current = n;\n    for (int i = 0; i < n; ++i) {\n        result.push_back(current);\n        current += 2;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_110", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> make_a_pile(int n) {\n    std::vector<int> result;\n    int current = n;\n    for (int i = 0; i < n; ++i) {\n        result.push_back(current);\n        current += 2;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_110", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> make_a_pile(int n) {\n    std::vector<int> result;\n    int current = n;\n    for (int i = 0; i < n; ++i) {\n        result.push_back(current);\n        current += 2;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_110", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> make_a_pile(int n) {\n    std::vector<int> result;\n    int current = n;\n    for (int i = 0; i < n; ++i) {\n        result.push_back(current);\n        current += 2;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_111", "completion": "```cpp\n#include <string>\n#include <cmath>\n\nstd::string rounded_avg(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n    \n    int64_t sum = 0;\n    int64_t count = 0;\n    \n    for (int64_t i = n; i <= m; ++i) {\n        sum += i;\n        ++count;\n    }\n    \n    int64_t avg = sum / count;\n    if (sum % count * 2 >= count) {\n        ++avg;\n    }\n    \n    if (avg == 0) return \"0\";\n    \n    std::string binary = \"\";\n    while (avg > 0) {\n        binary = char('0' + (avg % 2)) + binary;\n        avg /= 2;\n    }\n    \n    return binary;\n}\n```"}
{"task_id": "SimdBench_111", "completion": "```cpp\n#include <string>\n#include <cmath>\n\nstd::string rounded_avg(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n    \n    int64_t sum = 0;\n    int64_t count = 0;\n    \n    for (int64_t i = n; i <= m; ++i) {\n        sum += i;\n        ++count;\n    }\n    \n    int64_t avg = sum / count;\n    std::string binary = \"\";\n    \n    if (avg == 0) return \"0\";\n    \n    while (avg > 0) {\n        binary = char('0' + (avg % 2)) + binary;\n        avg /= 2;\n    }\n    \n    return binary;\n}\n```"}
{"task_id": "SimdBench_111", "completion": "```cpp\n#include <string>\n#include <cmath>\n\nstd::string rounded_avg(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n    \n    int64_t sum = 0;\n    int64_t count = 0;\n    \n    for (int64_t i = n; i <= m; ++i) {\n        sum += i;\n        ++count;\n    }\n    \n    int64_t avg = sum / count;\n    std::string binary = \"\";\n    \n    if (avg == 0) {\n        binary = \"0\";\n    } else {\n        while (avg > 0) {\n            binary = char('0' + (avg % 2)) + binary;\n            avg /= 2;\n        }\n    }\n    \n    return binary;\n}\n```"}
{"task_id": "SimdBench_111", "completion": "```cpp\n#include <string>\n#include <cmath>\n\nstd::string rounded_avg(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n    \n    int64_t sum = 0;\n    int64_t count = 0;\n    \n    for (int64_t i = n; i <= m; ++i) {\n        sum += i;\n        ++count;\n    }\n    \n    int64_t avg = sum / count;\n    std::string binary = \"\";\n    \n    if (avg == 0) return \"0\";\n    \n    while (avg > 0) {\n        binary = char('0' + (avg % 2)) + binary;\n        avg /= 2;\n    }\n    \n    return binary;\n}\n```"}
{"task_id": "SimdBench_111", "completion": "```cpp\n#include <string>\n#include <cmath>\n\nstd::string rounded_avg(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n    \n    int64_t sum = 0;\n    int64_t count = 0;\n    \n    for (int64_t i = n; i <= m; ++i) {\n        sum += i;\n        ++count;\n    }\n    \n    int64_t avg = sum / count;\n    std::string binary = \"\";\n    \n    if (avg == 0) {\n        binary = \"0\";\n    } else {\n        while (avg > 0) {\n            binary = char('0' + (avg % 2)) + binary;\n            avg /= 2;\n        }\n    }\n    \n    return binary;\n}\n```"}
{"task_id": "SimdBench_112", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> func(int n) {\n    std::vector<int> result(n);\n    int factorial = 1;\n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            factorial = (factorial * i) % 10000;\n            result[i - 1] = factorial;\n        } else {\n            int sum = (i * (i + 1)) / 2;\n            result[i - 1] = sum;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_112", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> func(int n){\n    std::vector<int> result(n);\n    int factorial = 1;\n    for(int i = 1; i <= n; ++i){\n        if(i % 2 == 0){\n            factorial = (factorial * i) % 10000;\n            result[i-1] = factorial;\n        }\n        else{\n            result[i-1] = (i * (i + 1)) / 2;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_112", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> func(int n) {\n    std::vector<int> result(n);\n    int factorial = 1;\n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            factorial = (factorial * i) % 10000;\n            result[i - 1] = factorial;\n        } else {\n            int sum = (i * (i + 1)) / 2;\n            result[i - 1] = sum;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_112", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> func(int n) {\n    std::vector<int> result(n);\n    int factorial = 1;\n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            factorial = (factorial * i) % 10000;\n            result[i - 1] = factorial;\n        } else {\n            int sum = (i * (i + 1)) / 2;\n            result[i - 1] = sum;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_112", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> func(int n) {\n    std::vector<int> result(n);\n    int factorial = 1;\n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            factorial = (factorial * i) % 10000;\n            result[i - 1] = factorial;\n        } else {\n            int sum = (i * (i + 1)) / 2;\n            result[i - 1] = sum;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_113", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<int> even_odd_palindrome(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        std::string s = std::to_string(i);\n        std::string rev_s = s;\n        std::reverse(rev_s.begin(), rev_s.end());\n\n        if (s == rev_s) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<int> even_odd_palindrome(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        std::string s = std::to_string(i);\n        std::string rev_s = s;\n        std::reverse(rev_s.begin(), rev_s.end());\n\n        if (s == rev_s) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<int> even_odd_palindrome(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        std::string s = std::to_string(i);\n        std::string rev_s = s;\n        std::reverse(rev_s.begin(), rev_s.end());\n\n        if (s == rev_s) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<int> even_odd_palindrome(int n) {\n    int even_count = 0, odd_count = 0;\n    \n    for (int i = 1; i <= n; ++i) {\n        std::string s = std::to_string(i);\n        std::string rev_s = s;\n        std::reverse(rev_s.begin(), rev_s.end());\n        \n        if (s == rev_s) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n    \n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<int> even_odd_palindrome(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n    \n    for (int i = 1; i <= n; ++i) {\n        std::string s = std::to_string(i);\n        std::string rev_s = s;\n        std::reverse(rev_s.begin(), rev_s.end());\n        \n        if (s == rev_s) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n    \n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_114", "completion": "```cpp\nint count_nums(std::vector<int> n){\n    int count = 0;\n    for(auto num : n){\n        int sum = 0;\n        int temp = std::abs(num);\n        bool isNegative = num < 0;\n        if(temp == 0){\n            sum = 0;\n        }\n        else{\n            while(temp > 0){\n                int digit = temp % 10;\n                sum += digit;\n                temp /= 10;\n            }\n            if(isNegative){\n                sum -= 2 * (num % 10);\n            }\n        }\n        if(sum > 0){\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_114", "completion": "```cpp\nint count_nums(std::vector<int> n){\n    int count = 0;\n    for(auto num : n){\n        int sum = 0;\n        int temp = std::abs(num);\n        bool is_negative = num < 0;\n        if(temp == 0){\n            sum = 0;\n        }\n        else{\n            while(temp > 0){\n                int digit = temp % 10;\n                sum += digit;\n                temp /= 10;\n            }\n            if(is_negative){\n                sum -= 2 * (num % 10);\n            }\n        }\n        if(sum > 0){\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_114", "completion": "```cpp\nint count_nums(std::vector<int> n){\n    int count = 0;\n    for(auto num : n){\n        int sum = 0;\n        int temp = std::abs(num);\n        bool is_negative = num < 0;\n        if(temp == 0){\n            sum = 0;\n        }\n        else{\n            while(temp > 0){\n                int digit = temp % 10;\n                sum += digit;\n                temp /= 10;\n            }\n            if(is_negative){\n                sum -= 2 * (num % 10);\n            }\n        }\n        if(sum > 0){\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_114", "completion": "```cpp\nint count_nums(std::vector<int> n){\n    int count = 0;\n    for(auto num : n){\n        int sum = 0;\n        int temp = std::abs(num);\n        bool is_negative = num < 0;\n        if(temp == 0){\n            sum = 0;\n        }\n        else{\n            while(temp > 0){\n                int digit = temp % 10;\n                sum += digit;\n                temp /= 10;\n            }\n            if(is_negative){\n                sum -= 2 * (num % 10);\n            }\n        }\n        if(sum > 0){\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_114", "completion": "```cpp\nint count_nums(std::vector<int> n){\n    int count = 0;\n    for(auto num : n){\n        int sum = 0;\n        int temp = std::abs(num);\n        bool isNegative = num < 0;\n        if(temp == 0){\n            sum = 0;\n        }\n        else{\n            while(temp > 0){\n                int digit = temp % 10;\n                sum += digit;\n                temp /= 10;\n            }\n            if(isNegative){\n                sum -= 2 * (num % 10);\n            }\n        }\n        if(sum > 0){\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_115", "completion": "```cpp\n#include <vector>\n\nbool move_one_ball(std::vector<int> arr) {\n    if (arr.empty()) return true;\n    \n    int drop_count = 0;\n    int n = arr.size();\n    \n    for(int i = 0; i < n; ++i){\n        if(arr[i] > arr[(i + 1) % n]){\n            drop_count++;\n            if(drop_count > 1){\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_115", "completion": "```cpp\nbool move_one_ball(std::vector<int> arr){\n    if(arr.empty()) return true;\n    int count = 0;\n    int n = arr.size();\n    for(int i = 0; i < n; ++i){\n        if(arr[i] > arr[(i+1)%n]){\n            count++;\n            if(count > 1) return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_115", "completion": "```cpp\nbool move_one_ball(std::vector<int> arr){\n    if(arr.empty()) return true;\n    int count = 0;\n    int n = arr.size();\n    for(int i = 0; i < n; ++i){\n        if(arr[i] > arr[(i+1)%n]){\n            count++;\n            if(count > 1) return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_115", "completion": "```cpp\nbool move_one_ball(std::vector<int> arr){\n    if(arr.empty()) return true;\n    int count = 0;\n    int n = arr.size();\n    for(int i = 0; i < n; ++i){\n        if(arr[i] > arr[(i+1)%n]){\n            count++;\n            if(count > 1) return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_115", "completion": "```cpp\nbool move_one_ball(std::vector<int> arr){\n    if(arr.empty()) return true;\n    int count = 0;\n    int n = arr.size();\n    for(int i = 0; i < n; ++i){\n        if(arr[i] > arr[(i+1)%n]){\n            count++;\n            if(count > 1) return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_116", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::string myexchange(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int oddCountLst1 = 0;\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            oddCountLst1++;\n        }\n    }\n\n    int evenCountLst2 = 0;\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            evenCountLst2++;\n        }\n    }\n\n    return (evenCountLst2 >= oddCountLst1) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::string myexchange(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int oddCountLst1 = 0;\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            oddCountLst1++;\n        }\n    }\n\n    int evenCountLst2 = 0;\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            evenCountLst2++;\n        }\n    }\n\n    return (evenCountLst2 >= oddCountLst1) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::string myexchange(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int oddCountLst1 = 0;\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            oddCountLst1++;\n        }\n    }\n\n    int evenCountLst2 = 0;\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            evenCountLst2++;\n        }\n    }\n\n    return (evenCountLst2 >= oddCountLst1) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::string myexchange(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int oddCountLst1 = 0;\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            oddCountLst1++;\n        }\n    }\n\n    int evenCountLst2 = 0;\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            evenCountLst2++;\n        }\n    }\n\n    return (evenCountLst2 >= oddCountLst1) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::string myexchange(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int oddCountLst1 = 0;\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            oddCountLst1++;\n        }\n    }\n\n    int evenCountLst2 = 0;\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            evenCountLst2++;\n        }\n    }\n\n    return (evenCountLst2 >= oddCountLst1) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_117", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for (const auto& s : lst) {\n        int count = 0;\n        for (char c : s) {\n            if ((c - '0') % 2 != 0) {\n                count++;\n            }\n        }\n        std::string output = \"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\";\n        result.push_back(output);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for (const auto& s : lst) {\n        int count = 0;\n        for (char c : s) {\n            if ((c - '0') % 2 != 0) {\n                count++;\n            }\n        }\n        std::string output = \"the number of odd elements \" + std::to_string(count) + \n                             \"n the str\" + std::to_string(count) + \"ng \" + \n                             std::to_string(count) + \" of the \" + \n                             std::to_string(count) + \"nput.\";\n        result.push_back(output);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for(const auto& s : lst){\n        int count = 0;\n        for(char c : s){\n            if((c - '0') % 2 != 0){\n                count++;\n            }\n        }\n        std::string output = \"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\";\n        result.push_back(output);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for (const auto& s : lst) {\n        int count = 0;\n        for (char c : s) {\n            if ((c - '0') % 2 != 0) {\n                count++;\n            }\n        }\n        std::string output = \"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\";\n        result.push_back(output);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        int count = 0;\n        for (char c : str) {\n            if ((c - '0') % 2 != 0) {\n                count++;\n            }\n        }\n        std::string output = \"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\";\n        result.push_back(output);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_118", "completion": "```cpp\nint64_t minSubArraySum(const std::vector<int64_t>& nums) {\n    int64_t minSum = nums[0];\n    int64_t currentSum = nums[0];\n    for (size_t i = 1; i < nums.size(); ++i) {\n        currentSum = std::min(nums[i], currentSum + nums[i]);\n        minSum = std::min(minSum, currentSum);\n    }\n    return minSum;\n}\n```"}
{"task_id": "SimdBench_118", "completion": "```cpp\nint64_t minSubArraySum(const std::vector<int64_t>& nums) {\n    int64_t minSum = nums[0];\n    int64_t currentSum = nums[0];\n    for (size_t i = 1; i < nums.size(); ++i) {\n        currentSum = std::min(nums[i], currentSum + nums[i]);\n        minSum = std::min(minSum, currentSum);\n    }\n    return minSum;\n}\n```"}
{"task_id": "SimdBench_118", "completion": "```cpp\nint64_t minSubArraySum(const std::vector<int64_t>& nums) {\n    int64_t minSum = nums[0];\n    int64_t currentSum = nums[0];\n    \n    for (size_t i = 1; i < nums.size(); ++i) {\n        currentSum = std::min(nums[i], currentSum + nums[i]);\n        minSum = std::min(minSum, currentSum);\n    }\n    \n    return minSum;\n}\n```"}
{"task_id": "SimdBench_118", "completion": "```cpp\nint64_t minSubArraySum(const std::vector<int64_t>& nums) {\n    int64_t minSum = nums[0];\n    int64_t currentSum = nums[0];\n    \n    for (size_t i = 1; i < nums.size(); ++i) {\n        currentSum = std::min(nums[i], currentSum + nums[i]);\n        minSum = std::min(minSum, currentSum);\n    }\n    \n    return minSum;\n}\n```"}
{"task_id": "SimdBench_118", "completion": "```cpp\nint64_t minSubArraySum(const std::vector<int64_t>& nums) {\n    int64_t minSum = nums[0];\n    int64_t currentSum = nums[0];\n    \n    for (size_t i = 1; i < nums.size(); ++i) {\n        currentSum = std::min(nums[i], currentSum + nums[i]);\n        minSum = std::min(minSum, currentSum);\n    }\n    \n    return minSum;\n}\n```"}
{"task_id": "SimdBench_119", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint max_fill(const std::vector<std::vector<int> > & grid, int capacity) {\n    int total_drops = 0;\n    for (const auto& well : grid) {\n        int water_units = 0;\n        for (int unit : well) {\n            water_units += unit;\n        }\n        total_drops += std::ceil(static_cast<double>(water_units) / capacity);\n    }\n    return total_drops;\n}\n```"}
{"task_id": "SimdBench_119", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint max_fill(const std::vector<std::vector<int> > & grid, int capacity) {\n    int total_drops = 0;\n    for (const auto& well : grid) {\n        int water_units = 0;\n        for (int unit : well) {\n            water_units += unit;\n        }\n        total_drops += std::ceil(static_cast<double>(water_units) / capacity);\n    }\n    return total_drops;\n}\n```"}
{"task_id": "SimdBench_119", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint max_fill(const std::vector<std::vector<int> > & grid, int capacity) {\n    int total_drops = 0;\n    for (const auto& well : grid) {\n        int water_units = 0;\n        for (int unit : well) {\n            water_units += unit;\n        }\n        total_drops += std::ceil(static_cast<double>(water_units) / capacity);\n    }\n    return total_drops;\n}\n```"}
{"task_id": "SimdBench_119", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint max_fill(const std::vector<std::vector<int> > & grid, int capacity) {\n    int totalDrops = 0;\n    for (const auto& well : grid) {\n        int waterUnits = 0;\n        for (int unit : well) {\n            waterUnits += unit;\n        }\n        totalDrops += std::ceil(static_cast<double>(waterUnits) / capacity);\n    }\n    return totalDrops;\n}\n```"}
{"task_id": "SimdBench_119", "completion": "```cpp\nint max_fill(const std::vector<std::vector<int> > & grid, int capacity) {\n    int totalDrops = 0;\n    for (const auto& well : grid) {\n        int waterUnits = 0;\n        for (int unit : well) {\n            waterUnits += unit;\n        }\n        totalDrops += (waterUnits + capacity - 1) / capacity;\n    }\n    return totalDrops;\n}\n```"}
{"task_id": "SimdBench_120", "completion": "```cpp\nint64_t solution(const std::vector<int16_t>& lst){\n    int64_t sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120", "completion": "```cpp\nint64_t solution(const std::vector<int16_t>& lst){\n    int64_t sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120", "completion": "```cpp\nint64_t solution(const std::vector<int16_t>& lst){\n    int64_t sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120", "completion": "```cpp\nint64_t solution(const std::vector<int16_t>& lst){\n    int64_t sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120", "completion": "```cpp\nint64_t solution(const std::vector<int16_t>& lst){\n    int64_t sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121", "completion": "```cpp\nint add_elements(std::vector<int> arr, int k){\n    int sum = 0;\n    for(int i = 0; i < k; ++i){\n        if(arr[i] >= -99 && arr[i] <= 99){\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121", "completion": "```cpp\nint add_elements(std::vector<int> arr, int k){\n    int sum = 0;\n    for(int i = 0; i < k; ++i){\n        if(arr[i] >= -99 && arr[i] <= 99){\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121", "completion": "```cpp\nint add_elements(std::vector<int> arr, int k){\n    int sum = 0;\n    for(int i = 0; i < k; ++i){\n        if(arr[i] >= -99 && arr[i] <= 99){\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121", "completion": "```cpp\nint add_elements(std::vector<int> arr, int k){\n    int sum = 0;\n    for(int i = 0; i < k; ++i){\n        if(arr[i] >= -99 && arr[i] <= 99){\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121", "completion": "```cpp\nint add_elements(std::vector<int> arr, int k){\n    int sum = 0;\n    for(int i = 0; i < k; ++i){\n        if(arr[i] >= -99 && arr[i] <= 99){\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_122", "completion": "```cpp\nbool is_sorted(const std::vector<int> & lst){\n    if (lst.empty()) return true;\n    int prev = lst[0];\n    int count = 1;\n    for (size_t i = 1; i < lst.size(); ++i) {\n        if (lst[i] < prev) {\n            return false;\n        }\n        if (lst[i] == prev) {\n            ++count;\n            if (count > 2) {\n                return false;\n            }\n        } else {\n            prev = lst[i];\n            count = 1;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_122", "completion": "```cpp\nbool is_sorted(const std::vector<int> & lst){\n    if (lst.empty()) return true;\n    int prev = lst[0];\n    int count = 1;\n    for (size_t i = 1; i < lst.size(); ++i) {\n        if (lst[i] < prev) {\n            return false;\n        }\n        if (lst[i] == prev) {\n            ++count;\n            if (count > 2) {\n                return false;\n            }\n        } else {\n            prev = lst[i];\n            count = 1;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_122", "completion": "```cpp\nbool is_sorted(const std::vector<int> & lst){\n    if (lst.empty()) return true;\n    int prev = lst[0];\n    int count = 1;\n    for (size_t i = 1; i < lst.size(); ++i) {\n        if (lst[i] < prev) {\n            return false;\n        }\n        if (lst[i] == prev) {\n            ++count;\n            if (count > 2) {\n                return false;\n            }\n        } else {\n            prev = lst[i];\n            count = 1;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_122", "completion": "```cpp\nbool is_sorted(const std::vector<int> & lst){\n    if (lst.empty()) return true;\n    int prev = lst[0];\n    int count = 1;\n    for (size_t i = 1; i < lst.size(); ++i) {\n        if (lst[i] < prev) {\n            return false;\n        }\n        if (lst[i] == prev) {\n            ++count;\n            if (count > 2) {\n                return false;\n            }\n        } else {\n            prev = lst[i];\n            count = 1;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_122", "completion": "```cpp\nbool is_sorted(const std::vector<int> & lst){\n    if (lst.empty()) return true;\n    int prev = lst[0];\n    int count = 1;\n    for (size_t i = 1; i < lst.size(); ++i) {\n        if (lst[i] < prev) {\n            return false;\n        }\n        if (lst[i] == prev) {\n            ++count;\n            if (count > 2) {\n                return false;\n            }\n        } else {\n            prev = lst[i];\n            count = 1;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_123", "completion": "```cpp\nint prod_signs(const std::vector<int> & arr){\n    if (arr.empty()) return -32768;\n    \n    int sign_product = 1;\n    int magnitude_sum = 0;\n    \n    for (int num : arr) {\n        if (num == 0) {\n            return 0;\n        }\n        sign_product *= (num > 0) ? 1 : -1;\n        magnitude_sum += std::abs(num);\n    }\n    \n    return sign_product * magnitude_sum;\n}\n```"}
{"task_id": "SimdBench_123", "completion": "```cpp\nint prod_signs(const std::vector<int> & arr){\n    if (arr.empty()) return -32768;\n    \n    int sign_product = 1;\n    int magnitude_sum = 0;\n    \n    for (int num : arr) {\n        if (num == 0) {\n            return 0;\n        }\n        sign_product *= (num > 0) ? 1 : -1;\n        magnitude_sum += std::abs(num);\n    }\n    \n    return sign_product * magnitude_sum;\n}\n```"}
{"task_id": "SimdBench_123", "completion": "```cpp\nint prod_signs(const std::vector<int> & arr){\n    if (arr.empty()) return -32768;\n    \n    int sign_product = 1;\n    int magnitude_sum = 0;\n    \n    for (int num : arr) {\n        if (num == 0) {\n            return 0;\n        }\n        sign_product *= (num > 0) ? 1 : -1;\n        magnitude_sum += std::abs(num);\n    }\n    \n    return sign_product * magnitude_sum;\n}\n```"}
{"task_id": "SimdBench_123", "completion": "```cpp\nint prod_signs(const std::vector<int> & arr){\n    if(arr.empty()) return -32768;\n    int sign_product = 1;\n    int magnitude_sum = 0;\n    for(auto num : arr){\n        if(num == 0){\n            return 0;\n        }\n        sign_product *= (num > 0) ? 1 : -1;\n        magnitude_sum += abs(num);\n    }\n    return sign_product * magnitude_sum;\n}\n```"}
{"task_id": "SimdBench_123", "completion": "```cpp\nint prod_signs(const std::vector<int> & arr){\n    if (arr.empty()) return -32768;\n    \n    int sign_product = 1;\n    int magnitude_sum = 0;\n    \n    for (int num : arr) {\n        if (num == 0) {\n            return 0;\n        }\n        sign_product *= (num > 0) ? 1 : -1;\n        magnitude_sum += std::abs(num);\n    }\n    \n    return sign_product * magnitude_sum;\n}\n```"}
{"task_id": "SimdBench_124", "completion": "```cpp\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <algorithm>\n\nstd::vector<int> minPath(const std::vector<std::vector<int>>& grid, int k) {\n    int n = grid.size();\n    int dir[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    std::vector<int> result;\n    \n    auto cmp = [&](const std::vector<int>& a, const std::vector<int>& b) -> bool {\n        for (int i = 0; i < a.size(); ++i) {\n            if (a[i] != b[i]) return a[i] > b[i];\n        }\n        return false;\n    };\n    \n    std::priority_queue<std::vector<int>, std::vector<std::vector<int>>, decltype(cmp)> pq(cmp);\n    \n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            std::vector<int> initial = {grid[i][j]};\n            pq.push(initial);\n        }\n    }\n    \n    while (!pq.empty()) {\n        std::vector<int> current = pq.top();\n        pq.pop();\n        \n        if (current.size() == k) {\n            return current;\n        }\n        \n        int last_val = current.back();\n        int x = -1, y = -1;\n        \n        // Find the position of the last value in the path\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] == last_val) {\n                    x = i;\n                    y = j;\n                    break;\n                }\n            }\n            if (x != -1) break;\n        }\n        \n        // Explore neighbors\n        for (int d = 0; d < 4; ++d) {\n            int nx = x + dir[d][0];\n            int ny = y + dir[d][1];\n            \n            if (nx >= 0 && nx < n && ny >= 0 && ny < n) {\n                std::vector<int> next_path = current;\n                next_path.push_back(grid[nx][ny]);\n                pq.push(next_path);\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_124", "completion": "```cpp\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <algorithm>\n\nstd::vector<int> minPath(const std::vector<std::vector<int>> & grid, int k) {\n    int n = grid.size();\n    int dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    std::vector<int> result;\n    \n    auto isValid = [&](int x, int y) -> bool {\n        return x >= 0 && x < n && y >= 0 && y < n;\n    };\n    \n    auto compare = [&](const std::vector<int>& a, const std::vector<int>& b) -> bool {\n        for(int i = 0; i < a.size(); ++i){\n            if(a[i] != b[i]) return a[i] < b[i];\n        }\n        return false;\n    };\n    \n    for(int i = 0; i < n; ++i){\n        for(int j = 0; j < n; ++j){\n            std::priority_queue<std::vector<int>, std::vector<std::vector<int>>, decltype(compare)> pq(compare);\n            pq.push({grid[i][j]});\n            \n            while(!pq.empty()){\n                std::vector<int> path = pq.top(); pq.pop();\n                \n                if(path.size() == k){\n                    if(result.empty() || compare(path, result)){\n                        result = path;\n                    }\n                    continue;\n                }\n                \n                int last = path.back();\n                int x = (last - 1) / n;\n                int y = (last - 1) % n;\n                \n                for(int d = 0; d < 4; ++d){\n                    int nx = x + dir[d][0];\n                    int ny = y + dir[d][1];\n                    \n                    if(isValid(nx, ny)){\n                        std::vector<int> newPath = path;\n                        newPath.push_back(grid[nx][ny]);\n                        pq.push(newPath);\n                    }\n                }\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_124", "completion": "```cpp\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <algorithm>\n\nstd::vector<int> minPath(const std::vector<std::vector<int>> & grid, int k) {\n    int n = grid.size();\n    int dir[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    std::vector<int> result;\n    \n    auto cmp = [&](const std::tuple<int, int, int, std::vector<int>>& a, \n                   const std::tuple<int, int, int, std::vector<int>>& b) -> bool {\n        const std::vector<int>& lstA = std::get<3>(a);\n        const std::vector<int>& lstB = std::get<3>(b);\n        return lstA > lstB;\n    };\n    \n    std::priority_queue<std::tuple<int, int, int, std::vector<int>>, \n                        std::vector<std::tuple<int, int, int, std::vector<int>>>, \n                        decltype(cmp)> pq(cmp);\n    \n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            std::vector<int> initial = {grid[i][j]};\n            pq.emplace(i, j, 1, initial);\n        }\n    }\n    \n    while (!pq.empty()) {\n        auto [x, y, length, path] = pq.top();\n        pq.pop();\n        \n        if (length == k) {\n            return path;\n        }\n        \n        for (int d = 0; d < 4; ++d) {\n            int nx = x + dir[d][0];\n            int ny = y + dir[d][1];\n            \n            if (nx >= 0 && nx < n && ny >= 0 && ny < n) {\n                std::vector<int> newPath = path;\n                newPath.push_back(grid[nx][ny]);\n                pq.emplace(nx, ny, length + 1, newPath);\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_124", "completion": "```cpp\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <limits>\n\nstd::vector<int> minPath(const std::vector<std::vector<int>> & grid, int k) {\n    int n = grid.size();\n    int dir[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    std::vector<int> result;\n    \n    auto compare = [&](const std::vector<int>& a, const std::vector<int>& b) -> bool {\n        for(int i = 0; i < a.size(); ++i){\n            if(a[i] != b[i]) return a[i] > b[i];\n        }\n        return false;\n    };\n    \n    std::priority_queue<std::vector<int>, std::vector<std::vector<int>>, decltype(compare)> pq(compare);\n    \n    for(int i = 0; i < n; ++i){\n        for(int j = 0; j < n; ++j){\n            std::vector<int> initial = {grid[i][j]};\n            pq.push(initial);\n        }\n    }\n\n    while(!pq.empty()){\n        std::vector<int> current = pq.top();\n        pq.pop();\n\n        if(current.size() == k){\n            return current;\n        }\n\n        int last_val = current.back();\n        int x = -1, y = -1;\n\n        // Find the position of the last value in the path\n        for(int i = 0; i < n && x == -1; ++i){\n            for(int j = 0; j < n; ++j){\n                if(grid[i][j] == last_val){\n                    x = i;\n                    y = j;\n                    break;\n                }\n            }\n        }\n\n        for(int d = 0; d < 4; ++d){\n            int nx = x + dir[d][0];\n            int ny = y + dir[d][1];\n\n            if(nx >= 0 && nx < n && ny >= 0 && ny < n){\n                std::vector<int> next = current;\n                next.push_back(grid[nx][ny]);\n                pq.push(next);\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_124", "completion": "```cpp\n#include <vector>\n#include <queue>\n#include <tuple>\n\nstd::vector<int> minPath(const std::vector<std::vector<int>> & grid, int k) {\n    int n = grid.size();\n    int dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    std::vector<int> result;\n    \n    auto cmp = [&](const std::tuple<int, int, int, std::vector<int>> &a, const std::tuple<int, int, int, std::vector<int>> &b) -> bool {\n        const std::vector<int>& lstA = std::get<3>(a);\n        const std::vector<int>& lstB = std::get<3>(b);\n        return lstA > lstB;\n    };\n    \n    std::priority_queue<std::tuple<int, int, int, std::vector<int>>, \n                        std::vector<std::tuple<int, int, int, std::vector<int>>>, \n                        decltype(cmp)> pq(cmp);\n    \n    for(int i = 0; i < n; ++i){\n        for(int j = 0; j < n; ++j){\n            std::vector<int> initial = {grid[i][j]};\n            pq.emplace(i, j, 1, initial);\n        }\n    }\n    \n    while(!pq.empty()){\n        auto [x, y, length, path] = pq.top(); pq.pop();\n        \n        if(length == k){\n            if(result.empty() || path < result){\n                result = path;\n            }\n            continue;\n        }\n        \n        for(int d = 0; d < 4; ++d){\n            int nx = x + dir[d][0];\n            int ny = y + dir[d][1];\n            \n            if(nx >= 0 && nx < n && ny >= 0 && ny < n){\n                std::vector<int> newPath = path;\n                newPath.push_back(grid[nx][ny]);\n                pq.emplace(nx, ny, length + 1, newPath);\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_125", "completion": "```cpp\nuint64_t digits(uint64_t n){\n    uint64_t product = 1;\n    bool has_odd = false;\n    while (n > 0){\n        uint64_t digit = n % 10;\n        if (digit % 2 != 0){\n            product *= digit;\n            has_odd = true;\n        }\n        n /= 10;\n    }\n    return has_odd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_125", "completion": "```cpp\nuint64_t digits(uint64_t n){\n    uint64_t product = 1;\n    bool has_odd = false;\n    while (n > 0) {\n        uint64_t digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n            has_odd = true;\n        }\n        n /= 10;\n    }\n    return has_odd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_125", "completion": "```cpp\nuint64_t digits(uint64_t n){\n    uint64_t product = 1;\n    bool has_odd = false;\n    while (n > 0){\n        uint64_t digit = n % 10;\n        if (digit % 2 != 0){\n            product *= digit;\n            has_odd = true;\n        }\n        n /= 10;\n    }\n    return has_odd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_125", "completion": "```cpp\nuint64_t digits(uint64_t n){\n    uint64_t product = 1;\n    bool has_odd = false;\n    while (n > 0){\n        uint64_t digit = n % 10;\n        if (digit % 2 != 0){\n            product *= digit;\n            has_odd = true;\n        }\n        n /= 10;\n    }\n    return has_odd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_125", "completion": "```cpp\nuint64_t digits(uint64_t n){\n    uint64_t product = 1;\n    bool has_odd = false;\n    while (n > 0){\n        uint64_t digit = n % 10;\n        if (digit % 2 != 0){\n            product *= digit;\n            has_odd = true;\n        }\n        n /= 10;\n    }\n    return has_odd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_126", "completion": "```cpp\n#include <cmath>\n#include <vector>\n#include <cstdint>\n\nuint64_t sum_squares(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    for (float num : lst) {\n        int ceiled = static_cast<int>(std::ceil(num));\n        sum += static_cast<uint64_t>(ceiled * ceiled);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126", "completion": "```cpp\n#include <cmath>\n#include <vector>\n#include <cstdint>\n\nuint64_t sum_squares(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    for (float num : lst) {\n        int ceil_num = static_cast<int>(std::ceil(num));\n        sum += static_cast<uint64_t>(ceil_num * ceil_num);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126", "completion": "```cpp\n#include <cmath>\n#include <vector>\n#include <cstdint>\n\nuint64_t sum_squares(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    for (float num : lst) {\n        int ceil_num = static_cast<int>(std::ceil(num));\n        sum += static_cast<uint64_t>(ceil_num * ceil_num);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126", "completion": "```cpp\n#include <cmath>\n#include <vector>\n#include <cstdint>\n\nuint64_t sum_squares(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    for (float num : lst) {\n        int ceil_num = static_cast<int>(std::ceil(num));\n        sum += static_cast<uint64_t>(ceil_num * ceil_num);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126", "completion": "```cpp\n#include <cmath>\n#include <vector>\n#include <cstdint>\n\nuint64_t sum_squares(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    for (float num : lst) {\n        int ceiled = static_cast<int>(std::ceil(num));\n        sum += static_cast<uint64_t>(ceiled * ceiled);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_127", "completion": "```cpp\nint can_arrange(const std::vector<int> & arr){\n    int n = arr.size();\n    for(int i = n-1; i > 0; --i){\n        if(arr[i] < arr[i-1]){\n            return i;\n        }\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_127", "completion": "```cpp\nint can_arrange(const std::vector<int> & arr){\n    int n = arr.size();\n    for(int i = n-1; i > 0; --i){\n        if(arr[i] < arr[i-1]){\n            return i;\n        }\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_127", "completion": "```cpp\nint can_arrange(const std::vector<int> & arr){\n    int n = arr.size();\n    for(int i = n-1; i > 0; --i){\n        if(arr[i] < arr[i-1]){\n            return i;\n        }\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_127", "completion": "```cpp\nint can_arrange(const std::vector<int> & arr){\n    int n = arr.size();\n    for(int i = n-1; i > 0; --i){\n        if(arr[i] < arr[i-1]){\n            return i;\n        }\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_127", "completion": "```cpp\nint can_arrange(const std::vector<int> & arr){\n    int n = arr.size();\n    for(int i = n-1; i > 0; --i){\n        if(arr[i] < arr[i-1]){\n            return i;\n        }\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_128", "completion": "```cpp\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers(const std::vector<int>& lst) {\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    for (int num : lst) {\n        if (num < 0 && num > largest_negative) {\n            largest_negative = num;\n        }\n        if (num > 0 && (smallest_positive == 0 || num < smallest_positive)) {\n            smallest_positive = num;\n        }\n    }\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_128", "completion": "```cpp\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers(const std::vector<int>& lst) {\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    for (int num : lst) {\n        if (num < 0 && num > largest_negative) {\n            largest_negative = num;\n        }\n        if (num > 0 && (smallest_positive == 0 || num < smallest_positive)) {\n            smallest_positive = num;\n        }\n    }\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_128", "completion": "```cpp\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers(const std::vector<int>& lst) {\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    for (int num : lst) {\n        if (num < 0 && num > largest_negative) {\n            largest_negative = num;\n        }\n        if (num > 0 && (smallest_positive == 0 || num < smallest_positive)) {\n            smallest_positive = num;\n        }\n    }\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_128", "completion": "```cpp\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers(const std::vector<int>& lst) {\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    for (int num : lst) {\n        if (num < 0 && num > largest_negative) {\n            largest_negative = num;\n        }\n        if (num > 0 && (smallest_positive == 0 || num < smallest_positive)) {\n            smallest_positive = num;\n        }\n    }\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_128", "completion": "```cpp\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers(const std::vector<int>& lst) {\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    for (int num : lst) {\n        if (num < 0 && num > largest_negative) {\n            largest_negative = num;\n        }\n        if (num > 0 && (smallest_positive == 0 || num < smallest_positive)) {\n            smallest_positive = num;\n        }\n    }\n\n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_129", "completion": "```cpp\n#include <cstdint>\n\nuint64_t special_factorial(uint64_t n) {\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t factorial = 1;\n        for (uint64_t j = 1; j <= i; ++j) {\n            factorial *= j;\n        }\n        result *= factorial;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_129", "completion": "```cpp\n#include <cstdint>\n\nuint64_t special_factorial(uint64_t n) {\n    uint64_t result = 1;\n    uint64_t factorial = 1;\n    \n    for (uint64_t i = 1; i <= n; ++i) {\n        factorial *= i;\n        result *= factorial;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_129", "completion": "```cpp\n#include <cstdint>\n\nuint64_t special_factorial(uint64_t n) {\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t factorial = 1;\n        for (uint64_t j = 1; j <= i; ++j) {\n            factorial *= j;\n        }\n        result *= factorial;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_129", "completion": "```cpp\n#include <cstdint>\n\nuint64_t special_factorial(uint64_t n) {\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t factorial = 1;\n        for (uint64_t j = 1; j <= i; ++j) {\n            factorial *= j;\n        }\n        result *= factorial;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_129", "completion": "```cpp\n#include <cstdint>\n\nuint64_t special_factorial(uint64_t n) {\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t factorial = 1;\n        for (uint64_t j = 1; j <= i; ++j) {\n            factorial *= j;\n        }\n        result *= factorial;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_130", "completion": "```cpp\nint sum_squares(const std::vector<int> & lst){\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130", "completion": "```cpp\nint sum_squares(const std::vector<int> & lst){\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130", "completion": "```cpp\nint sum_squares(const std::vector<int> & lst){\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130", "completion": "```cpp\nint sum_squares(const std::vector<int> & lst){\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130", "completion": "```cpp\nint sum_squares(const std::vector<int> & lst){\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_131", "completion": "```cpp\nint specialFilter(const std::vector<int> & nums){\n    int count = 0;\n    for (int num : nums) {\n        if (num > 10) {\n            int firstDigit = num;\n            while (firstDigit >= 10) {\n                firstDigit /= 10;\n            }\n            int lastDigit = num % 10;\n            if (firstDigit % 2 != 0 && lastDigit % 2 != 0) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_131", "completion": "```cpp\nint specialFilter(const std::vector<int> & nums){\n    int count = 0;\n    for (int num : nums) {\n        if (num > 10) {\n            int firstDigit = num;\n            while (firstDigit >= 10) {\n                firstDigit /= 10;\n            }\n            int lastDigit = num % 10;\n            if (firstDigit % 2 != 0 && lastDigit % 2 != 0) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_131", "completion": "```cpp\nint specialFilter(const std::vector<int> & nums){\n    int count = 0;\n    for (int num : nums) {\n        if (num > 10) {\n            int firstDigit = num;\n            while (firstDigit >= 10) {\n                firstDigit /= 10;\n            }\n            int lastDigit = num % 10;\n            if (firstDigit % 2 != 0 && lastDigit % 2 != 0) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_131", "completion": "```cpp\nint specialFilter(const std::vector<int> & nums){\n    int count = 0;\n    for (int num : nums) {\n        if (num > 10) {\n            int firstDigit = num;\n            while (firstDigit >= 10) {\n                firstDigit /= 10;\n            }\n            int lastDigit = num % 10;\n            if (firstDigit % 2 != 0 && lastDigit % 2 != 0) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_131", "completion": "```cpp\nint specialFilter(const std::vector<int> & nums){\n    int count = 0;\n    for (int num : nums) {\n        if (num > 10) {\n            int firstDigit = num;\n            while (firstDigit >= 10) {\n                firstDigit /= 10;\n            }\n            int lastDigit = num % 10;\n            if (firstDigit % 2 != 0 && lastDigit % 2 != 0) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_132", "completion": "```cpp\n#include <vector>\n\nuint64_t get_max_triples(uint64_t n) {\n    std::vector<uint64_t> a(n);\n    for (uint64_t i = 1; i <= n; ++i) {\n        a[i - 1] = i * i - i + 1;\n    }\n\n    uint64_t count_mod[3] = {0, 0, 0};\n    for (uint64_t i = 0; i < n; ++i) {\n        count_mod[a[i] % 3]++;\n    }\n\n    uint64_t result = 0;\n\n    // Case 1: All three elements have a remainder of 0 when divided by 3\n    if (count_mod[0] >= 3) {\n        result += (count_mod[0] * (count_mod[0] - 1) * (count_mod[0] - 2)) / 6;\n    }\n\n    // Case 2: All three elements have a remainder of 1 when divided by 3\n    if (count_mod[1] >= 3) {\n        result += (count_mod[1] * (count_mod[1] - 1) * (count_mod[1] - 2)) / 6;\n    }\n\n    // Case 3: All three elements have a remainder of 2 when divided by 3\n    if (count_mod[2] >= 3) {\n        result += (count_mod[2] * (count_mod[2] - 1) * (count_mod[2] - 2)) / 6;\n    }\n\n    // Case 4: One element each with remainders 0, 1, and 2\n    result += count_mod[0] * count_mod[1] * count_mod[2];\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_132", "completion": "```cpp\n#include <vector>\n\nuint64_t get_max_triples(uint64_t n) {\n    std::vector<uint64_t> a(n);\n    for (uint64_t i = 1; i <= n; ++i) {\n        a[i - 1] = i * i - i + 1;\n    }\n\n    uint64_t count_mod[3] = {0, 0, 0};\n    for (uint64_t i = 0; i < n; ++i) {\n        count_mod[a[i] % 3]++;\n    }\n\n    uint64_t result = 0;\n\n    // Case 1: All three numbers are congruent to 0 mod 3\n    if (count_mod[0] >= 3) {\n        result += (count_mod[0] * (count_mod[0] - 1) * (count_mod[0] - 2)) / 6;\n    }\n\n    // Case 2: All three numbers are congruent to 1 mod 3\n    if (count_mod[1] >= 3) {\n        result += (count_mod[1] * (count_mod[1] - 1) * (count_mod[1] - 2)) / 6;\n    }\n\n    // Case 3: All three numbers are congruent to 2 mod 3\n    if (count_mod[2] >= 3) {\n        result += (count_mod[2] * (count_mod[2] - 1) * (count_mod[2] - 2)) / 6;\n    }\n\n    // Case 4: One number from each residue class (0, 1, 2)\n    result += count_mod[0] * count_mod[1] * count_mod[2];\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_132", "completion": "```cpp\n#include <vector>\n\nuint64_t get_max_triples(uint64_t n) {\n    std::vector<uint64_t> a(n);\n    for (uint64_t i = 1; i <= n; ++i) {\n        a[i - 1] = i * i - i + 1;\n    }\n\n    uint64_t count_mod[3] = {0, 0, 0};\n    for (uint64_t i = 0; i < n; ++i) {\n        count_mod[a[i] % 3]++;\n    }\n\n    uint64_t result = 0;\n\n    // Case 1: All three elements have a remainder of 0 when divided by 3\n    if (count_mod[0] >= 3) {\n        result += (count_mod[0] * (count_mod[0] - 1) * (count_mod[0] - 2)) / 6;\n    }\n\n    // Case 2: All three elements have a remainder of 1 when divided by 3\n    if (count_mod[1] >= 3) {\n        result += (count_mod[1] * (count_mod[1] - 1) * (count_mod[1] - 2)) / 6;\n    }\n\n    // Case 3: All three elements have a remainder of 2 when divided by 3\n    if (count_mod[2] >= 3) {\n        result += (count_mod[2] * (count_mod[2] - 1) * (count_mod[2] - 2)) / 6;\n    }\n\n    // Case 4: One element each with remainders 0, 1, and 2\n    result += count_mod[0] * count_mod[1] * count_mod[2];\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_132", "completion": "```cpp\n#include <vector>\n\nuint64_t get_max_triples(uint64_t n) {\n    std::vector<uint64_t> a(n);\n    for (uint64_t i = 1; i <= n; ++i) {\n        a[i - 1] = i * i - i + 1;\n    }\n\n    uint64_t count_mod[3] = {0, 0, 0};\n    for (uint64_t i = 0; i < n; ++i) {\n        count_mod[a[i] % 3]++;\n    }\n\n    uint64_t result = 0;\n\n    // Case 1: All three numbers are congruent to 0 mod 3\n    if (count_mod[0] >= 3) {\n        result += (count_mod[0] * (count_mod[0] - 1) * (count_mod[0] - 2)) / 6;\n    }\n\n    // Case 2: All three numbers are congruent to 1 mod 3\n    if (count_mod[1] >= 3) {\n        result += (count_mod[1] * (count_mod[1] - 1) * (count_mod[1] - 2)) / 6;\n    }\n\n    // Case 3: All three numbers are congruent to 2 mod 3\n    if (count_mod[2] >= 3) {\n        result += (count_mod[2] * (count_mod[2] - 1) * (count_mod[2] - 2)) / 6;\n    }\n\n    // Case 4: One number from each mod class (0, 1, 2)\n    result += count_mod[0] * count_mod[1] * count_mod[2];\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_132", "completion": "```cpp\n#include <vector>\n\nuint64_t get_max_triples(uint64_t n) {\n    std::vector<uint64_t> a(n);\n    for (uint64_t i = 0; i < n; ++i) {\n        a[i] = (i + 1) * (i + 1) - (i + 1) + 1;\n    }\n\n    uint64_t count_mod[3] = {0, 0, 0};\n    for (uint64_t i = 0; i < n; ++i) {\n        count_mod[a[i] % 3]++;\n    }\n\n    uint64_t result = 0;\n\n    // Case 1: All three elements have a remainder of 0 when divided by 3\n    if (count_mod[0] >= 3) {\n        result += (count_mod[0] * (count_mod[0] - 1) * (count_mod[0] - 2)) / 6;\n    }\n\n    // Case 2: All three elements have a remainder of 1 when divided by 3\n    if (count_mod[1] >= 3) {\n        result += (count_mod[1] * (count_mod[1] - 1) * (count_mod[1] - 2)) / 6;\n    }\n\n    // Case 3: All three elements have a remainder of 2 when divided by 3\n    if (count_mod[2] >= 3) {\n        result += (count_mod[2] * (count_mod[2] - 1) * (count_mod[2] - 2)) / 6;\n    }\n\n    // Case 4: One element each with remainder 0, 1, and 2\n    result += count_mod[0] * count_mod[1] * count_mod[2];\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_133", "completion": "```cpp\nint x_or_y(int n, int x, int y){\n    if (n <= 1) return y;\n    for(int i = 2; i * i <= n; i++){\n        if(n % i == 0) return y;\n    }\n    return x;\n}\n```"}
{"task_id": "SimdBench_133", "completion": "```cpp\nint x_or_y(int n, int x, int y){\n    if (n <= 1) return y;\n    for(int i = 2; i * i <= n; i++){\n        if(n % i == 0) return y;\n    }\n    return x;\n}\n```"}
{"task_id": "SimdBench_133", "completion": "```cpp\nint x_or_y(int n, int x, int y){\n    if (n <= 1) return y;\n    for(int i = 2; i * i <= n; i++){\n        if(n % i == 0) return y;\n    }\n    return x;\n}\n```"}
{"task_id": "SimdBench_133", "completion": "```cpp\nint x_or_y(int n, int x, int y){\n    if (n < 2) return y;\n    for(int i = 2; i * i <= n; i++){\n        if(n % i == 0) return y;\n    }\n    return x;\n}\n```"}
{"task_id": "SimdBench_133", "completion": "```cpp\nint x_or_y(int n, int x, int y){\n    if (n <= 1) return y;\n    for (int i = 2; i * i <= n; ++i){\n        if (n % i == 0) return y;\n    }\n    return x;\n}\n```"}
{"task_id": "SimdBench_134", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nuint64_t double_the_difference(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    for (float num : lst) {\n        if (num > 0 && std::floor(num) == num) {\n            int n = static_cast<int>(num);\n            if (n % 2 != 0) {\n                sum += n * n;\n            }\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nuint64_t double_the_difference(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    for (float num : lst) {\n        if (num > 0 && std::floor(num) == num) {\n            int n = static_cast<int>(num);\n            if (n % 2 != 0) {\n                sum += n * n;\n            }\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nuint64_t double_the_difference(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    for (float num : lst) {\n        if (num > 0 && floor(num) == num) {\n            int n = static_cast<int>(num);\n            if (n % 2 != 0) {\n                sum += n * n;\n            }\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nuint64_t double_the_difference(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    for (float num : lst) {\n        if (num > 0 && floor(num) == num) {\n            int n = static_cast<int>(num);\n            if (n % 2 != 0) {\n                sum += n * n;\n            }\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nuint64_t double_the_difference(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    for (float num : lst) {\n        if (num > 0 && static_cast<int>(num) == num) {\n            int int_num = static_cast<int>(num);\n            if (int_num % 2 != 0) {\n                sum += static_cast<uint64_t>(int_num) * int_num;\n            }\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_135", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nstd::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess){\n    std::vector<int> result;\n    for(size_t i = 0; i < game.size(); ++i){\n        if(game[i] == guess[i]){\n            result.push_back(0);\n        }\n        else{\n            result.push_back(std::abs(game[i] - guess[i]));\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nstd::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess){\n    std::vector<int> result;\n    for(size_t i = 0; i < game.size(); ++i){\n        if(game[i] == guess[i]){\n            result.push_back(0);\n        }\n        else{\n            result.push_back(std::abs(game[i] - guess[i]));\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nstd::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess){\n    std::vector<int> result;\n    for(size_t i = 0; i < game.size(); ++i){\n        if(game[i] == guess[i]){\n            result.push_back(0);\n        }\n        else{\n            result.push_back(std::abs(game[i] - guess[i]));\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nstd::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess){\n    std::vector<int> result;\n    for(size_t i = 0; i < game.size(); ++i){\n        if(game[i] == guess[i]){\n            result.push_back(0);\n        }\n        else{\n            result.push_back(std::abs(game[i] - guess[i]));\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nstd::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess){\n    std::vector<int> result;\n    for(size_t i = 0; i < game.size(); ++i){\n        if(game[i] == guess[i]){\n            result.push_back(0);\n        }\n        else{\n            result.push_back(std::abs(game[i] - guess[i]));\n        }\n    }\n    return result;\n}\n```"}

{"task_id": "SimdBench_0_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t vlmax = vsetvl_e64m1(length);\n    vbool64_t vmask = vle8_v_b64((const uint8_t *)mask, vlmax);\n    vint64m1_t vsrc = vle64_v_i64m1(src, vlmax);\n    vint64m1_t vdst = vle64_v_i64m1(dst, vlmax);\n    vdst = vmerge_vvm_i64m1(vsrc, vdst, vmask, vlmax);\n    vse64_v_i64m1(dst, vdst, vlmax);\n}\n```"}
{"task_id": "SimdBench_0_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t vlmax = vsetvl_e64m1(length);\n    vbool64_t vmask = vmv_v_x_b64(0, vlmax);\n    vint64m1_t vsrc;\n    vint64m1_t vdst;\n\n    for (size_t i = 0; i < length; i += vlmax) {\n        size_t vl = vsetvl_e64m1(vlmax > (length - i) ? (length - i) : vlmax);\n        vmask = vle1_v_b64((const uint8_t *)&mask[i], vl);\n        vsrc = vle64_v_i64m1((const int64_t *)&src[i], vl);\n        vdst = vle64_v_i64m1((const int64_t *)&dst[i], vl);\n        vdst = vmerge_vvm_i64m1(vsrc, vdst, vmask, vl);\n        vse64_v_i64m1((int64_t *)&dst[i], vdst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_0_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t vlmax = vsetvl_e64m1(length);\n    vbool64_t vmask = vmv_v_x_b64(0, vlmax);\n    vint64m1_t vsrc, vdst;\n\n    for (size_t vl = vlmax; vl != 0; length -= vl, src += vl, dst += vl, mask += vl) {\n        vl = vsetvl_e64m1(vl);\n\n        // Load mask values into a vector boolean\n        vmask = vle1_v_b64((const uint8_t *)mask, vl);\n\n        // Load source and destination vectors\n        vsrc = vlde64_v_i64m1(src, vl);\n        vdst = vlde64_v_i64m1(dst, vl);\n\n        // Conditionally move elements from src to dst based on the mask\n        vdst = vmerge_vvm_i64m1(vsrc, vdst, vmask, vl);\n\n        // Store the result back to the destination array\n        vsde64_v_i64m1(dst, vdst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_0_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t vlmax = vsetvl_e64m1(length);\n    vbool64_t vmask = vle8_v_b64((const uint8_t *)mask, vlmax);\n    vint64m1_t vsrc = vlseg1e64_v_i64m1(src, vlmax);\n    vint64m1_t vdst = vlseg1e64_v_i64m1(dst, vlmax);\n    vdst = vfmerge_vfm_i64m1(vsrc, vdst, vmask, vlmax);\n    vsseg1e64_v_i64m1(dst, vdst, vlmax);\n}\n```"}
{"task_id": "SimdBench_0_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t vlmax = vsetvl_e64m1(length);\n    vbool64_t vmask = vle8_v_b64((const uint8_t *)mask, vlmax);\n    vint64m1_t vsrc = vluxseg1ei64_v_i64m1(src, 0, vlmax);\n    vint64m1_t vdst = vluxseg1ei64_v_i64m1(dst, 0, vlmax);\n    vdst = vmerge_vvm_i64m1(vsrc, vdst, vmask, vlmax);\n    vsuxseg1ei64_v_i64m1(dst, vdst, 0, vlmax);\n}\n```"}
{"task_id": "SimdBench_1_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t vlmax = vsetvl_e32m1(length);\n    for (size_t vl = 0; vl < length; vl += vlmax) {\n        size_t actual_vl = vsetvl_e32m1(vlmax);\n        vint32m1_t vscale = vmv_v_x_i32m1(scale, actual_vl);\n        vint32m1_t vsrc = vle32_v_i32m1(src + vl, actual_vl);\n\n        vint32m1_t vmul = vmul_vv_i32m1(vsrc, vscale, actual_vl);\n        vint32m1_t vtmp1 = vsra_vx_i32m1(vmul, 3, actual_vl);\n        vint32m1_t vtmp2 = vsll_vx_i32m1(vmul, 3, actual_vl);\n\n        vint32m1_t vprod = vmul_vv_i32m1(vtmp1, vtmp2, actual_vl);\n        vint32m1_t vsum = vadd_vv_i32m1(vmul, vprod, actual_vl);\n        vint32m1_t vres = vddiv_vx_i32m1(vsum, 7, actual_vl);\n\n        vse32_v_i32m1(dst + vl, vres, actual_vl);\n    }\n}\n```"}
{"task_id": "SimdBench_1_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t vlmax = vsetvl_e32m1(length);\n    for (size_t vl = 0; vl < length; vl += vlmax) {\n        size_t actual_vl = vsetvl_e32m1(vlmax);\n\n        vint32m1_t vscale = vmv_v_x_i32m1(scale, actual_vl);\n        vint32m1_t vsrc = vle32_v_i32m1(src + vl, actual_vl);\n\n        vint32m1_t vtmp1 = vsra_vx_i32m1(vmul_vv_i32m1(vsrc, vscale, actual_vl), 3, actual_vl);\n        vint32m1_t vtmp2 = vsll_vx_i32m1(vmul_vv_i32m1(vsrc, vscale, actual_vl), 3, actual_vl);\n\n        vint32m1_t vresult = vmul_vv_i32m1(vsrc, vscale, actual_vl);\n        vresult = vadd_vv_i32m1(vresult, vmul_vv_i32m1(vtmp1, vtmp2, actual_vl), actual_vl);\n        vresult = vdiv_vx_i32m1(vresult, 7, actual_vl);\n\n        vse32_v_i32m1(dst + vl, vresult, actual_vl);\n    }\n}\n```"}
{"task_id": "SimdBench_1_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t vlmax = vsetvl_e32m1(length);\n    for (size_t vl = 0; vl < length; vl += vlmax) {\n        size_t current_vl = vsetvl_e32m1(length - vl);\n        vint32m1_t vscale = vmv_v_x_i32m1(scale, current_vl);\n        vint32m1_t vsrc = vle32_v_i32m1(src + vl, current_vl);\n\n        vint32m1_t vtmp1 = vsra_vx_i32m1(vmul_vv_i32m1(vsrc, vscale, current_vl), 3, current_vl);\n        vint32m1_t vtmp2 = vsll_vx_i32m1(vmul_vv_i32m1(vsrc, vscale, current_vl), 3, current_vl);\n        vint32m1_t vresult = vddiv_vx_i32m1(vadd_vv_i32m1(vmul_vv_i32m1(vsrc, vscale, current_vl), vmul_vv_i32m1(vtmp1, vtmp2, current_vl), current_vl), 7, current_vl);\n\n        vse32_v_i32m1(dst + vl, vresult, current_vl);\n    }\n}\n```"}
{"task_id": "SimdBench_1_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t vlmax = vsetvl_e32m1(length);\n    for (size_t vl = 0; vl < length; vl += vlmax) {\n        size_t actual_vl = vsetvl_e32m1(vlmax);\n        vint32m1_t vscale = vmv_v_x_i32m1(scale, actual_vl);\n        vint32m1_t vsrc = vle32_v_i32m1(src + vl, actual_vl);\n\n        vint32m1_t vtmp1 = vsra_vx_i32m1(vmul_vv_i32m1(vsrc, vscale, actual_vl), 3, actual_vl);\n        vint32m1_t vtmp2 = vsll_vx_i32m1(vmul_vv_i32m1(vsrc, vscale, actual_vl), 3, actual_vl);\n        vint32m1_t vresult = vmul_vv_i32m1(vsrc, vscale, actual_vl);\n        vresult = vadd_vv_i32m1(vresult, vmul_vv_i32m1(vtmp1, vtmp2, actual_vl), actual_vl);\n        vresult = vddiv_vx_i32m1(vresult, 7, actual_vl);\n\n        vse32_v_i32m1(dst + vl, vresult, actual_vl);\n    }\n}\n```"}
{"task_id": "SimdBench_1_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t vlmax = vsetvl_e32m1(length);\n    for (size_t vl = 0; vl < length; vl += vlmax) {\n        size_t actual_vl = vsetvl_e32m1(vlmax);\n\n        vint32m1_t vscale = vmv_v_x_i32m1(scale, actual_vl);\n        vint32m1_t vsrc = vle32_v_i32m1(src + vl, actual_vl);\n\n        vint32m1_t vtmp1 = vsra_vx_i32m1(vmul_vv_i32m1(vsrc, vscale, actual_vl), 3, actual_vl);\n        vint32m1_t vtmp2 = vsll_vx_i32m1(vmul_vv_i32m1(vsrc, vscale, actual_vl), 3, actual_vl);\n\n        vint32m1_t vresult = vddiv_vx_i32m1(vadd_vv_i32m1(vmul_vv_i32m1(vsrc, vscale, actual_vl), vmul_vv_i32m1(vtmp1, vtmp2, actual_vl), actual_vl), 7, actual_vl);\n\n        vse32_v_i32m1(dst + vl, vresult, actual_vl);\n    }\n}\n```"}
{"task_id": "SimdBench_2_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t vlmax = vsetvl_e64m1(1);\n    vfloat64m1_t vzero = vfreinterpret64_m(vf64m1_zero_v_f32m1(vlmax));\n    for (size_t r = 0; r < rows; r++) {\n        size_t index = r * cols + stride;\n        vfloat64m1_t vs = vle64_v_f64m1(&src[index], vlmax);\n        size_t dst_index = r;\n        vse64_v_f64m1(&dst[dst_index], vs, vlmax);\n    }\n}\n```"}
{"task_id": "SimdBench_2_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t vlmax = vsetvl_e64m1(1);\n    for (size_t r = 0; r < rows; r++) {\n        size_t index = r * cols + stride;\n        vfloat64m1_t vs = vlseg1ff_float64(vlse1_v_f64m1(src + index, vlmax), vlmax);\n        vssseg1_ff_float64(dst + r, vs, vlmax);\n    }\n}\n```"}
{"task_id": "SimdBench_2_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t vlmax = vsetvl_e64m1(1);\n    for (size_t r = 0; r < rows; r++) {\n        size_t index = r * cols + stride;\n        vfloat64m1_t vs = vle64_v_f64m1(&src[index], vlmax);\n        vse64_v_f64m1(&dst[r], vs, vlmax);\n    }\n}\n```"}
{"task_id": "SimdBench_2_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t vlmax = vsetvl_e64m1(rows);\n    vfloat64m1_t vzero = vmv_v_x_f64m1(0.0, vlmax);\n    size_t i = 0;\n\n    while (i < rows) {\n        size_t vl = vsetvl_e64m1(rows - i);\n        vfloat64m1_t vresult = vlsseg1e64_v_f64m1(&src[i * cols + stride], cols, vl);\n        vsseg1e64_v_f64m1(&dst[i], vresult, vl);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_2_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t vlmax = vsetvl_e64m8(1);\n    for (size_t r = 0; r < rows; r++) {\n        size_t index = r * cols + stride;\n        vfloat64m8_t vs = vlseg1ff_float64(vlseff_v_f64m8(src + index, vlmax), vlmax);\n        vssseg1ff_float64(dst + r, vs, vlmax);\n    }\n}\n```"}
{"task_id": "SimdBench_3_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t vlmax = vsetvl_e32m1(length);\n    vfloat32m1_t v_src;\n    vint32m1_t v_indices;\n    vfloat32m1_t v_dst;\n\n    for (size_t i = 0; i < length; i += vlmax) {\n        size_t vl = vsetvl_e32m1(vlmax > (length - i) ? (length - i) : vlmax);\n\n        // Load indices\n        v_indices = vle32_v_i32m1(indices + i, vl);\n\n        // Gather operation: load from src using indices\n        v_src = vlgather_v_f32m1_f32(src, v_indices, vl);\n\n        // Store gathered values into dst\n        vsseg1e32_v_f32m1(dst + i, v_src, vl);\n\n        // Scatter operation: scatter src values to dst using indices\n        vscatter_v_f32m1_f32(dst, v_indices, v_src, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_3_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t vlmax = vsetvl_e32m1(length);\n    vfloat32m1_t v_src;\n    vint32m1_t v_indices;\n    vfloat32m1_t v_dst;\n\n    for (size_t i = 0; i < length; i += vlmax) {\n        size_t vl = vsetvl_e32m1(vlmax > (length - i) ? (length - i) : vlmax);\n\n        // Load indices\n        v_indices = vle32_v_i32m1(indices + i, vl);\n\n        // Gather operation: load from src using indices\n        v_src = vlgather_v_f32m1_f32(src, v_indices, vl);\n\n        // Scatter operation: store to dst using indices\n        vscatter_v_f32_f32m1(dst, v_indices, v_src, vl);\n\n        // Direct copy to dst (not using indices)\n        v_dst = vle32_v_f32m1(src + i, vl);\n        vse32_v_f32m1(dst + i, v_dst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_3_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t vlmax = vsetvl_e32m1(length);\n    vfloat32m1_t v_src;\n    vint32m1_t v_indices;\n    vfloat32m1_t v_dst;\n\n    for (size_t i = 0; i < length; i += vlmax) {\n        size_t vl = vsetvl_e32m1(length - i);\n\n        // Load indices\n        v_indices = vle32_v_i32m1(indices + i, vl);\n\n        // Gather operation: load from src using indices\n        v_src = vlgather_v_f32m1_f32(src, v_indices, vl);\n\n        // Scatter operation: store to dst using indices\n        vscatter_v_f32(dst, v_indices, v_src, vl);\n\n        // Direct copy to destination array\n        v_dst = vle32_v_f32m1(src + i, vl);\n        vse32_v_f32m1(dst + i, v_dst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_3_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t vlmax = vsetvl_e32m1(length);\n    vfloat32m1_t v_src;\n    vint32m1_t v_indices;\n    vfloat32m1_t v_dst;\n\n    for (size_t i = 0; i < length; i += vlmax) {\n        size_t vl = vsetvl_e32m1(length - i);\n\n        // Load indices\n        v_indices = vle32_v_i32m1(indices + i, vl);\n\n        // Gather operation: load from src using indices\n        v_src = vlsseg1-e32_v_f32m1(src, v_indices, vl);\n\n        // Scatter operation: store to dst using indices\n        vsseg1e32_v_f32m1(dst, v_indices, v_src, vl);\n\n        // Direct copy to dst (non-indexed)\n        v_dst = vlseg1e32_v_f32m1(src + i, vl);\n        vsseg1e32_v_f32m1(dst + i, v_dst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_3_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t vlmax = vsetvl_e32m1(length);\n    vfloat32m1_t v_src;\n    vint32m1_t v_indices;\n    vfloat32m1_t v_dst;\n\n    for (size_t i = 0; i < length; i += vlmax) {\n        size_t vl = vsetvl_e32m1(length - i);\n        v_indices = vle32_v_i32m1(indices + i, vl);\n        v_src = vle32_v_f32m1(src + i, vl);\n\n        // Gather operation\n        v_dst = vvflta_vf32m1(v_src, v_indices, vl);\n        vse32_v_f32m1(dst + i, v_dst, vl);\n\n        // Scatter operation\n        vfscata_v_f32m1(dst, v_src, v_indices, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_4_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t vl = vsetvl_e16m1(end - start + 1);\n    vint16m1_t v0 = vmv_v_x_i16m1(0, vl);\n\n    uint64_t i = 0;\n    for (i = 0; i + vl <= (end - start + 1); i += vl) {\n        vint16m1_t vstart = vle16_v_i16m1(arr + start + i, vl);\n        vint16m1_t vend = vle16_v_i16m1(arr + end - i, vl);\n        vse16_v_i16m1(arr + start + i, vend, vl);\n        vse16_v_i16m1(arr + end - i, vstart, vl);\n    }\n\n    if (i < (end - start + 1)) {\n        vl = vsetvl_e16m1((end - start + 1) - i);\n        vint16m1_t vstart = vle16_v_i16m1(arr + start + i, vl);\n        vint16m1_t vend = vle16_v_i16m1(arr + end - i, vl);\n        vse16_v_i16m1(arr + start + i, vend, vl);\n        vse16_v_i16m1(arr + end - i, vstart, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_4_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t length = end - start + 1;\n    uint64_t i = 0;\n    size_t vlmax = vsetvl_e16m2(length);\n    int16_t *left = arr + start;\n    int16_t *right = arr + end;\n\n    while (i + vlmax <= length) {\n        size_t vl = vsetvl_e16m2(vlmax);\n        vint16m2_t vleft = vle16_v_i16m2(left + i, vl);\n        vint16m2_t vright = vle16_v_i16m2(right - i, vl);\n        vse16_v_i16m2(left + i, vright, vl);\n        vse16_v_i16m2(right - i, vleft, vl);\n        i += vlmax;\n    }\n\n    if (i < length) {\n        size_t vl = vsetvl_e16m2(length - i);\n        vint16m2_t vleft = vle16_v_i16m2(left + i, vl);\n        vint16m2_t vright = vle16_v_i16m2(right - i, vl);\n        vse16_v_i16m2(left + i, vright, vl);\n        vse16_v_i16m2(right - i, vleft, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_4_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t vl = vsetvl_e16m1(end - start + 1);\n    vint16m1_t v0 = vmv_v_x_i16m1(0, vl);\n\n    uint64_t i = 0;\n    for (i = 0; i <= (end - start) / vl; i++) {\n        vint16m1_t vstart = vle16_v_i16m1(arr + start + i * vl, vl);\n        vint16m1_t vend = vle16_v_i16m1(arr + end - i * vl, vl);\n\n        vint16m1_t vrev = vwrev_v_i16m1(vstart, vl);\n        vse16_v_i16m1(arr + start + i * vl, vend, vl);\n\n        vse16_v_i16m1(arr + end - i * vl, vrev, vl);\n    }\n\n    if ((end - start + 1) % vl != 0) {\n        vl = vsetvl_e16m1((end - start + 1) % vl);\n        vint16m1_t vstart = vle16_v_i16m1(arr + start + i * vl, vl);\n        vint16m1_t vend = vle16_v_i16m1(arr + end - i * vl, vl);\n\n        vint16m1_t vrev = vwrev_v_i16m1(vstart, vl);\n        vse16_v_i16m1(arr + start + i * vl, vend, vl);\n\n        vse16_v_i16m1(arr + end - i * vl, vrev, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_4_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t length = end - start + 1;\n    uint64_t half = length / 2;\n    vuint64m1_t vl = vmv_v_x_u64_m1(length);\n\n    for (uint64_t i = 0; i < half; i++) {\n        uint64_t left_idx = start + i;\n        uint64_t right_idx = end - i;\n\n        vint16m1_t left_val = lvsl16_v_i16m1(arr + left_idx, vl);\n        vint16m1_t right_val = lvsl16_v_i16m1(arr + right_idx, vl);\n\n        svsl16_v_i16m1(arr + right_idx, left_val, vl);\n        svsl16_v_i16m1(arr + left_idx, right_val, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_4_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t vl = vsetvl_e16m1(end - start + 1);\n    vint16m1_t v0 = vmv_v_x_i16m1(0, vl);\n\n    uint64_t i = 0;\n    for (i = 0; i + vl <= (end - start + 1); i += vl) {\n        vint16m1_t v_start = vle16_v_i16m1(arr + start + i, vl);\n        vint16m1_t v_end = vle16_v_i16m1(arr + end - i, vl);\n\n        vsse16_v_i16m1(arr + start + i, v0, v_end, vl);\n        vsse16_v_i16m1(arr + end - i, v0, v_start, vl);\n    }\n\n    if (i < (end - start + 1)) {\n        uint64_t remaining = (end - start + 1) - i;\n        uint64_t vl_remaining = vsetvl_e16m1(remaining);\n\n        vint16m1_t v_start = vle16_v_i16m1(arr + start + i, vl_remaining);\n        vint16m1_t v_end = vle16_v_i16m1(arr + end - i, vl_remaining);\n\n        vsse16_v_i16m1(arr + start + i, v0, v_end, vl_remaining);\n        vsse16_v_i16m1(arr + end - i, v0, v_start, vl_remaining);\n    }\n}\n```"}
{"task_id": "SimdBench_5_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t vlmax = vsetvl_e8m1(dim1 * dim2);\n    size_t offset = slice_idx * dim1 * dim2;\n    for (size_t i = 0; i < dim1 * dim2; i += vlmax) {\n        size_t vl = vsetvl_e8m1(vlmax);\n        vuint8m1_t vt = vle8_v_u8m1(&tensor[offset + i], vl);\n        vse8_v_u8m1(&slice[i], vt, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_5_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t vlmax = vsetvl_e8m1(dim1 * dim2);\n    for (size_t i = 0; i < dim1 * dim2; i += vlmax) {\n        size_t vl = vsetvl_e8m1(vlmax);\n        vuint8m1_t vtensor = vle8_v_u8m1(&tensor[(slice_idx * dim1 * dim2 + i)], vl);\n        vse8_v_u8m1(&slice[i], vtensor, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_5_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t total_elements = dim1 * dim2;\n    size_t stride = dim3;\n    size_t vlmax = vsetvl_e8m1(0);\n\n    for (size_t i = 0; i < total_elements; i += vlmax) {\n        size_t vl = vsetvl_e8m1(total_elements - i);\n        vuint8m1_t vtensor = lvu8_v(&tensor[(i + slice_idx * stride)], vl);\n        svu8_v(slice + i, vtensor, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_5_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t vlmax = vsetvl_e8m1(dim1 * dim2);\n    size_t offset = slice_idx * dim1 * dim2;\n    for (size_t i = 0; i < dim1 * dim2; i += vlmax) {\n        size_t vl = vsetvl_e8m1(dim1 * dim2 - i);\n        vuint8m1_t vtensor = lvu8_v_u8m1(&tensor[offset + i], vl);\n        svu8_v_u8m1(&slice[i], vtensor, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_5_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t vl = vsetvl_e8m1(dim1 * dim2);\n    vuint8m1_t vzero = vmv_v_x_i8m1(0, vl);\n    vuint8m1_t vslice;\n\n    for (size_t i = 0; i < dim1 * dim2; i += vl) {\n        size_t chunk_size = (dim1 * dim2 - i > vl) ? vl : dim1 * dim2 - i;\n        size_t vl_chunk = vsetvl_e8m1(chunk_size);\n\n        vslice = vle8_v_u8m1((const uint8_t *)(tensor + (slice_idx * dim1 * dim2 + i)), vl_chunk);\n        vse8_v_u8m1(slice + i, vslice, vl_chunk);\n    }\n}\n```"}
{"task_id": "SimdBench_6_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    size_t vlmax = vsetvl_e16m2(block_size);\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t k = 0; k < block_size; ++k) {\n                size_t src_row = i + k;\n                if (src_row >= rows) break;\n                vint16m2_t vrow = vmv_v_x_i16m2(0, vlmax);\n                for (size_t l = 0; l < block_size; ++l) {\n                    size_t src_col = j + l;\n                    if (src_col >= cols) break;\n                    size_t idx = src_row * cols + src_col;\n                    vrow = vle16_v_i16m2(&src[idx], vlmax);\n                    size_t dst_idx = src_col * rows + src_row;\n                    vse16_v_i16m2(&dst[dst_idx], vrow, vlmax);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    size_t vlmax = vsetvl_e16m2(block_size);\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t k = 0; k < block_size; ++k) {\n                size_t row_idx = i + k;\n                if (row_idx >= rows) break;\n                vint16m2_t v_src = vmv_v_x_i16m2(0, vlmax);\n                for (size_t l = 0; l < block_size; ++l) {\n                    size_t col_idx = j + l;\n                    if (col_idx >= cols) break;\n                    size_t src_idx = row_idx * cols + col_idx;\n                    v_src = vle16_v_i16m2(&src[src_idx], vlmax);\n                    size_t dst_idx = col_idx * rows + row_idx;\n                    vse16_v_i16m2(&dst[dst_idx], v_src, vlmax);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    size_t vlmax = vsetvl_e16m2(block_size);\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t actual_block_size = (block_size > rows - i ? rows - i : block_size);\n            size_t actual_block_size_cols = (block_size > cols - j ? cols - j : block_size);\n            for (size_t bi = 0; bi < actual_block_size; ++bi) {\n                vint16m2_t vs = vmv_v_x_i16m2(0, vlmax);\n                for (size_t bj = 0; bj < actual_block_size_cols; ++bj) {\n                    size_t idx = ((i + bi) * cols + (j + bj));\n                    int16_t val = src[idx];\n                    vs = vse16(vs, bj, &val);\n                }\n                size_t dst_idx = ((j + 0) * rows + (i + bi));\n                vss16(dst + dst_idx, vs, actual_block_size_cols);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    size_t vlmax = vsetvl_e16m2(1);\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t k = 0; k < block_size; ++k) {\n                size_t r_start = i + k;\n                if (r_start >= rows) break;\n                size_t vl = vsetvl_e16m2(block_size);\n                vint16m2_t vs = vmv_v_x_i16m2(0, vl);\n                for (size_t l = 0; l < block_size; ++l) {\n                    size_t c = j + l;\n                    if (c >= cols) break;\n                    size_t src_idx = r_start * cols + c;\n                    int16_t val = src[src_idx];\n                    vs = vse16_vs_i16m2_i16m1(vs, l, val, vl);\n                }\n                for (size_t l = 0; l < block_size; ++l) {\n                    size_t c = j + l;\n                    if (c >= cols) break;\n                    size_t dst_idx = c * rows + r_start;\n                    int16_t val = vmse16_v_i16m2_i16(vs, l, vl);\n                    dst[dst_idx] = val;\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    size_t vlmax = vsetvl_e16m2(block_size);\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t p = 0; p < block_size; ++p) {\n                size_t src_row = i + p;\n                if (src_row >= rows) break;\n                vint16m2_t v_src = vmv_v_x_i16m2(0, vlmax);\n                for (size_t q = 0; q < block_size; ++q) {\n                    size_t src_col = j + q;\n                    if (src_col >= cols) break;\n                    size_t idx = src_row * cols + src_col;\n                    v_src = vle16_v_i16m2(&src[idx], vlmax);\n                }\n                for (size_t q = 0; q < block_size; ++q) {\n                    size_t dst_col = j + q;\n                    if (dst_col >= cols) break;\n                    size_t dst_idx = dst_col * rows + src_row;\n                    vse16_v_i16m2(&dst[dst_idx], v_src, vlmax);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_7_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t vlmax = vsetvl_e32m1(dim);\n    vfloat32m1_t vsum = vmv_v_f_f32m1(0.0f, vlmax);\n\n    for (size_t i = 0; i < dim; i += vlmax) {\n        size_t vl = vsetvl_e32m1(dim - i);\n        vfloat32m1_t vtemp = vluxei32_v_f32m1(array + i * (dim * dim + dim + 1), i, vl);\n        vsum = vfmacc_vf_f32m1(1.0f, vsum, vtemp, vl);\n    }\n\n    float result = 0.0f;\n    for (size_t i = 0; i < dim; i++) {\n        result += vmv_x_s_f32m1_f32(vsum);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_7_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    size_t vlmax = vsetvl_e32m1(dim);\n    float sum = 0.0f;\n\n    for (size_t i = 0; i < dim; i += vlmax) {\n        size_t vl = vsetvl_e32m1(dim - i);\n        vfloat32m1_t vmask = vmv_v_x_f32m1(0.0f, vl);\n        vfloat32m1_t vsum = vmv_v_x_f32m1(0.0f, vl);\n\n        for (size_t j = i; j < dim && j < i + vlmax; j++) {\n            size_t index = j * dim * dim + j * dim + j;\n            vmask = vle32_v_f32m1(&array[index], vl);\n            vsum = vfadd_vv_f32m1(vsum, vmask, vl);\n        }\n\n        float temp_sum = 0.0f;\n        for (size_t k = 0; k < vl; k++) {\n            temp_sum += vfmv_f_s_f32m1_f32(vsum);\n        }\n        sum += temp_sum;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float result = 0.0f;\n    size_t vlmax = vsetvl_e32m1(dim);\n    vfloat32m1_t vzero = vmv_v_f_f32m1(0.0f, vlmax);\n    vfloat32m1_t vsum = vzero;\n\n    for (size_t i = 0; i < dim; i += vlmax) {\n        size_t vl = vsetvl_e32m1(dim - i);\n        vfloat32m1_t vtemp = vle32_v_f32m1(&array[i * (dim * dim + dim + 1)], vl);\n        vsum = vadd_vv_f32m1(vsum, vtemp, vl);\n    }\n\n    float sum_arr[vlmul_ext8(vlmax)];\n    size_t vl = vsetvl_e32m1(dim);\n    vse32_v_f32m1(sum_arr, vsum, vl);\n\n    for (size_t i = 0; i < dim; i++) {\n        result += sum_arr[i];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_7_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t vlmax = vsetvl_e32m1(dim);\n    vfloat32m1_t vsum = vmv_v_x_f32m1(0.0f, vlmax);\n\n    for (size_t i = 0; i < dim; i += vlmax) {\n        size_t vl = vsetvl_e32m1(dim - i);\n        vfloat32m1_t vtemp = vlmul_v_f32m1(array + i * (dim * dim + dim + 1), vl);\n        vsum = vadd_vv_f32m1(vsum, vtemp, vl);\n    }\n\n    sum = vmv_x_s_f32m1_f32(vredsum_vs_f32m1_f32m1(vsum, vmv_v_x_f32m1(0.0f, vlmax), vlmax));\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t vlmax = vsetvl_e32m1(dim);\n    vfloat32m1_t vsum = vmv_v_f_f32m1(0.0f, vlmax);\n\n    for (size_t i = 0; i < dim; i += vlmax) {\n        size_t vl = vsetvl_e32m1(dim - i);\n        vfloat32m1_t vtemp = vluxseg1ei32_v_f32m1(array + i * (dim + 1), i, vl);\n        vsum = vfmacc_vf_f32m1(vsum, 1.0f, vtemp, vl);\n    }\n\n    float temp_sum = 0.0f;\n    for (size_t i = 0; i < dim; i++) {\n        temp_sum += vmv_x_s_f32m1_f32(vsum);\n    }\n    sum = temp_sum;\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_8_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t vlmax = vsetvl_e64m8(total_elements);\n\n    vfloat64m8_t vt = vmv_v_f_f64m8(threshold, vlmax);\n    vfloat64m8_t vs = vmv_v_f_f64m8(scale, vlmax);\n\n    for (size_t i = 0; i < total_elements; i += vlmax) {\n        size_t vl = vsetvl_e64m8(total_elements - i);\n        vfloat64m8_t vx = vle64_v_f64m8(src + i, vl);\n        vbool8_t mask = vmf_ne_v_f64m8_b8(vx, vt, vl);\n        vfloat64m8_t scaled = vmul_vv_f64m8(vx, vs, vl);\n        vfloat64m8_t result = vmerge_vvm_f64m8(vx, scaled, mask, vl);\n        vse64_v_f64m8(dst + i, result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_8_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t vlmax = vmul_vv_f64_m(vta_all_f64(), vmsne_vf_f64_m(vta_all_f64(), threshold, threshold, __RISCV_VLENB / 8), scale, __RISCV_VLENB / 8);\n    size_t i = 0;\n\n    for (; i <= total_elements - vlmax; i += vlmax) {\n        vfloat64m1_t vsrc = vle64_v_f64m1(&src[i], vlmax);\n        vfloat64m1_t vthreshold = vmv_v_x_f64m1(threshold, vlmax);\n        vbool8_t mask = vmflt_vf_f64m1_b8(vsrc, threshold, vlmax);\n        vfloat64m1_t vscaled = vmul_vf_f64m1(vsrc, scale, vlmax);\n        vfloat64m1_t vresult = vmerge_vvm_f64m1(vsrc, vscaled, mask, vlmax);\n        vse64_v_f64m1(&dst[i], vresult, vlmax);\n    }\n\n    if (i < total_elements) {\n        size_t vl = total_elements - i;\n        vfloat64m1_t vsrc = vle64_v_f64m1(&src[i], vl);\n        vfloat64m1_t vthreshold = vmv_v_x_f64m1(threshold, vl);\n        vbool8_t mask = vmflt_vf_f64m1_b8(vsrc, threshold, vl);\n        vfloat64m1_t vscaled = vmul_vf_f64m1(vsrc, scale, vl);\n        vfloat64m1_t vresult = vmerge_vvm_f64m1(vsrc, vscaled, mask, vl);\n        vse64_v_f64m1(&dst[i], vresult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_8_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t vlmax = vmv_v_x_size_e64_m();\n    size_t i = 0;\n\n    for (; i + vlmax <= total_elements; i += vlmax) {\n        vfloat64m1_t vscale_vec = vmv_v_f_f64(scale);\n        vfloat64m1_t vthreshold_vec = vmv_v_f_f64(threshold);\n        vfloat64m1_t vsrc_vec = vle64_v_f64m1(src + i, vlmax);\n        vbool8_t mask = vmf_nez_b8(vmfc_le_f64(vsrc_vec, vthreshold_vec));\n        vfloat64m1_t vresult = vmul_vv_f64m1(vsrc_vec, vscale_vec, vlmax);\n        vfloat64m1_t vfinal = vmf_n_b8(mask, vsrc_vec, vresult);\n        vse64_v_f64m1(dst + i, vfinal, vlmax);\n    }\n\n    if (i < total_elements) {\n        size_t vl = total_elements - i;\n        vfloat64m1_t vscale_vec = vmv_v_f_f64(scale);\n        vfloat64m1_t vthreshold_vec = vmv_v_f_f64(threshold);\n        vfloat64m1_t vsrc_vec = vle64_v_f64m1(src + i, vl);\n        vbool8_t mask = vmf_nez_b8(vmfc_le_f64(vsrc_vec, vthreshold_vec));\n        vfloat64m1_t vresult = vmul_vv_f64m1(vsrc_vec, vscale_vec, vl);\n        vfloat64m1_t vfinal = vmf_n_b8(mask, vsrc_vec, vresult);\n        vse64_v_f64m1(dst + i, vfinal, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_8_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t vlmax = vsetvl_e64m1(1);\n\n    for (size_t i = 0; i < total_elements; i += vlmax) {\n        size_t vl = vsetvl_e64m1(total_elements - i);\n        vfloat64m1_t v_src = vle64_v_f64m1(&src[i], vl);\n        vfloat64m1_t v_threshold = vmv_v_x_f64m1(threshold, vl);\n        vfloat64m1_t v_scale = vmv_v_x_f64m1(scale, vl);\n\n        vbool64_t mask = vmfge_vf_f64m1_b64(v_src, threshold, vl);\n        vfloat64m1_t scaled = vmul_vv_f64m1(v_src, v_scale, vl);\n        vfloat64m1_t result = vmux_vvm_f64m1(scaled, v_src, mask, vl);\n\n        vse64_v_f64m1(&dst[i], result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_8_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t vlmax = vmgetvl_e64m1();\n    vfloat64m1_t vt = vmv_v_f_f64m1(threshold, vlmax);\n    vfloat64m1_t vs = vmv_v_f_f64m1(scale, vlmax);\n\n    for(size_t i = 0; i < total_elements; i += vlmax) {\n        size_t vl = vsetvl_e64m1(vlmax > (total_elements - i) ? (total_elements - i) : vlmax);\n        vfloat64m1_t vsrc = vle64_v_f64m1(src + i, vl);\n        vbool8_t mask = vmf_ne_vf_f64m1_b8(vsrc, vt, vl);\n        vfloat64m1_t scaled = vmul_vf_f64m1(vsrc, vs, vl);\n        vfloat64m1_t vdst = vmux_vvm_f64m1(scaled, vsrc, mask, vl);\n        vse64_v_f64m1(dst + i, vdst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_9_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t vlmax = vlenb() / sizeof(double);\n    for (size_t i = 0; i < rows; i++) {\n        size_t idx = indices[i];\n        const double *src_row = src + idx * cols;\n        double *dst_row = dst + i * cols;\n        size_t k = 0;\n        for (; k + vlmax <= cols; k += vlmax) {\n            vfloat64m1_t vs = vlseg8ff_float64_v_f64m1(src_row, vlmax);\n            vfloat64m1_t vd = vs;\n            vsseg8ff_float64_v_f64m1(dst_row, vd, vlmax);\n            src_row += vlmax;\n            dst_row += vlmax;\n        }\n        if (k < cols) {\n            size_t vl = cols - k;\n            vfloat64m1_t vs = vlseg8ff_float64_v_f64m1_mask(src_row, vl);\n            vfloat64m1_t vd = vs;\n            vsseg8ff_float64_v_f64m1_mask(dst_row, vd, vl);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t vlmax = vsetvl_e64m1(cols);\n    vfloat64m1_t vzero = vfslide1up_vf64m1(vf64m1_t, double, size_t, size_t);\n    for (size_t i = 0; i < rows; i++) {\n        size_t src_row_idx = indices[i];\n        const double *src_row = src + src_row_idx * cols;\n        double *dst_row = dst + i * cols;\n\n        size_t vl = vlmax;\n        size_t j = 0;\n        for (; vl != 0; j += vl, vl = vsetvl_e64m1_bounded(cols - j)) {\n            vfloat64m1_t vs = vluxseg1ff_v_f64m1(src_row + j, vl);\n            vs = vfslide1down_vf64m1(vs, vzero, vl);\n            vssseg1ff_v_f64m1(dst_row + j, vs, vl);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t vlmax = vsetvl_e64m1(1);\n    for (size_t i = 0; i < rows; ++i) {\n        size_t idx = indices[i];\n        vfloat64m1_t vs = vmv_v_x_f64m1(0.0, vlmax);\n        size_t col = 0;\n        while (col < cols) {\n            size_t vl = vsetvl_e64m1(cols - col);\n            vfloat64m1_t vsrc = lvfr_p_f64m1(&src[idx * cols + col], vl);\n            vs = vfmerge_vfm_f64m1(vs, vsrc, vmv_v_x_i32m1(-1, vl), vl);\n            col += vl;\n        }\n        col = 0;\n        while (col < cols) {\n            size_t vl = vsetvl_e64m1(cols - col);\n            svfr_v_f64m1(&dst[i * cols + col], vs, vl);\n            col += vl;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t vlmax = vsetvl_e64m8(1);\n    for (size_t i = 0; i < rows; i++) {\n        size_t idx = indices[i];\n        vfloat64m8_t vrow_src = vmv_v_x_f64m8(0.0, vlmax);\n        vfloat64m8_t vrow_dst = vmv_v_x_f64m8(0.0, vlmax);\n        size_t j = 0;\n        for (; j + vlmax <= cols; j += vlmax) {\n            vrow_src = vle64_v_f64m8(&src[idx * cols + j], vlmax);\n            vrow_dst = vse64_v_f64m8(&dst[i * cols + j], vrow_src, vlmax);\n        }\n        for (; j < cols; j++) {\n            dst[i * cols + j] = src[idx * cols + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t vlmax = vsetvl_e64m1(1);\n    for (size_t i = 0; i < rows; i++) {\n        size_t idx = indices[i];\n        vfloat64m1_t vrow_src = vmv_v_x_f64m1(0.0, vlmax);\n        vfloat64m1_t vrow_dst = vmv_v_x_f64m1(0.0, vlmax);\n        size_t col = 0;\n        for (; col + vlmax <= cols; col += vlmax) {\n            vrow_src = vle64_v_f64m1((const double *)(src + idx * cols + col), vlmax);\n            vrow_dst = vrow_src;\n            vse64_v_f64m1((double *)(dst + i * cols + col), vrow_dst, vlmax);\n        }\n        vlmax = vsetvl_e64m1(cols - col);\n        if (col < cols) {\n            vrow_src = vle64_v_f64m1((const double *)(src + idx * cols + col), vlmax);\n            vrow_dst = vrow_src;\n            vse64_v_f64m1((double *)(dst + i * cols + col), vrow_dst, vlmax);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_10_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t vlmax = vsetvl_e64m1(length);\n    for (size_t i = 0; i < length; i += vlmax) {\n        size_t vl = vsetvl_e64m1(vlmax);\n        vint64m1_t vsrc1 = vle64_v_i64m1(src1 + i, vl);\n        vint64m1_t vsrc2 = vle64_v_i64m1(src2 + i, vl);\n        vint64m1_t vresult = vrsubu_vx_i64m1(vadd_vv_i64m1(vadd_vv_i64m1(vsrc1, vsrc2, vl), vmv_v_x_i64m1(scalar, vl), vl), 1, vl);\n        vresult = vsra_vx_i64m1(vresult, vmv_v_x_i64m1(1, vl), vl);\n        vse64_v_i64m1(dst + i, vresult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_10_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t vlmax = vsetvl_e64m1(length);\n    vint64m1_t vscalar = vmv_v_x_i64m1(scalar, vlmax);\n    for (size_t i = 0; i < length; i += vlmax) {\n        size_t vl = vsetvl_e64m1(vlmin(vlmax, length - i));\n        vint64m1_t vsrc1 = vle64_v_i64m1(src1 + i, vl);\n        vint64m1_t vsrc2 = vle64_v_i64m1(src2 + i, vl);\n        vint64m1_t vres = vrdiv_vv_i64m1(vadd_vv_i64m1(vadd_vx_i64m1(vsrc1, vsrc2, vl), vscalar, vl), vmv_v_x_i64m1(2, vl), vl);\n        vse64_v_i64m1(dst + i, vres, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_10_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    size_t vlmax = vsetvl_e64m1(length);\n    vint64m1_t vscalar = vmv_v_x_i64m1(scalar, vlmax);\n\n    for (; i <= length - vlmax; i += vlmax) {\n        size_t vl = vsetvl_e64m1(vlmax);\n        vint64m1_t vs1 = vle64_v_i64m1(src1 + i, vl);\n        vint64m1_t vs2 = vle64_v_i64m1(src2 + i, vl);\n        vint64m1_t vres = vfadd_vv_i64m1(vs1, vs2, vl);\n        vres = vfadd_vx_i64m1(vres, scalar, vl);\n        vres = vddiv_vx_i64m1(vres, 2, vl);\n        vse64_v_i64m1(dst + i, vres, vl);\n    }\n\n    // Handle remaining elements\n    if (i < length) {\n        size_t vl = vsetvl_e64m1(length - i);\n        vint64m1_t vs1 = vle64_v_i64m1(src1 + i, vl);\n        vint64m1_t vs2 = vle64_v_i64m1(src2 + i, vl);\n        vint64m1_t vres = vfadd_vv_i64m1(vs1, vs2, vl);\n        vres = vfadd_vx_i64m1(vres, scalar, vl);\n        vres = vddiv_vx_i64m1(vres, 2, vl);\n        vse64_v_i64m1(dst + i, vres, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_10_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t vlmax = vsetvl_e64m1(length);\n    for (size_t vl = 0; vl < length; vl += vlmax) {\n        size_t current_vl = vsetvl_e64m1(vlmax);\n        vint64m1_t vsrc1 = vle64_v_i64m1(src1 + vl, current_vl);\n        vint64m1_t vsrc2 = vle64_v_i64m1(src2 + vl, current_vl);\n        vint64m1_t vadd = vadd_vv_i64m1(vsrc1, vsrc2, current_vl);\n        vint64m1_t vresult = vsadd_vx_i64m1(vadd, scalar, current_vl);\n        vint64m1_t vdiv = vsra_vx_i64m1(vresult, 1, current_vl);\n        vse64_v_i64m1(dst + vl, vdiv, current_vl);\n    }\n}\n```"}
{"task_id": "SimdBench_10_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t vlmax = vsetvl_e64m1(length);\n    for (size_t vl = 0; vl < length; vl += vlmax) {\n        size_t actual_vl = vsetvl_e64m1(vlmax);\n        vint64m1_t vs1 = vle64_v_i64m1(src1 + vl, actual_vl);\n        vint64m1_t vs2 = vle64_v_i64m1(src2 + vl, actual_vl);\n        vint64m1_t vscalar = vmv_v_x_i64m1(scalar, actual_vl);\n        vint64m1_t vres = vadd_vv_i64m1(vs1, vs2, actual_vl);\n        vres = vadd_vv_i64m1(vres, vscalar, actual_vl);\n        vres = vsra_vx_i64m1(vres, 1, actual_vl);\n        vse64_v_i64m1(dst + vl, vres, actual_vl);\n    }\n}\n```"}
{"task_id": "SimdBench_11_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    size_t vlmax = vsetvl_e32m1(length);\n    int result = 0x7FFFFFFF;\n\n    for (size_t vl = vlmax; vl > 0; vl = vsetvl_e32m1(vl)) {\n        vuint32m1_t vmask = vid_v_u32m1(vl);\n        vmask = vrem_vxu32m1(vmask, 2, vl); // Compute index % 2\n        vmask = vne_vxu32m1(vmask, 0, vl);  // Create mask for even indices\n\n        vint32m1_t vsrc = vle32_v_i32m1(src, vl); // Load data\n        vint32m1_t veven = vmop_vvm_i32m1(vsrc, vsrc, vmask, vl); // Select even elements\n\n        vint32m1_t vmin = veven;\n        for (size_t i = 1; i < vl; i <<= 1) {\n            vmin = vmin_vv_i32m1(vmin, vmin, vl);\n        }\n\n        int min_val = vmv_x_s_i32m1_i32(vmin);\n        if (min_val < result) result = min_val;\n\n        src += vl;\n        length -= vl;\n        if (length == 0) break;\n    }\n\n    return result == 0x7FFFFFFF ? -1 : result;\n}\n```"}
{"task_id": "SimdBench_11_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    size_t vl = vsetvl_e32m1(length);\n    vuint32m1_t vmin = vmv_v_x_u32m1(-1, vl);\n    vbool4_t mask = vmsltu_b4_t(vmseq_vx_i32m1_b4(vindex_v_u32m1(vl), 0, vl), 1, vl);\n\n    for (size_t i = 0; i < length; i += vl) {\n        size_t sub_length = (length - i) > vl ? vl : (length - i);\n        vuint32m1_t v_src = vle32_v_u32m1(src + i, sub_length);\n        vbool4_t even_mask = vmseq_vx_i32m1_b4(vindex_v_u32m1(sub_length), 0, sub_length);\n        vuint32m1_t filtered = vmrgt_vx_u32m1(v_src, 0, sub_length);\n        vmin = vmnand_mm_u32m1(vmin, filtered, even_mask, sub_length);\n    }\n\n    int result = -1;\n    for (size_t i = 0; i < vl; i++) {\n        uint32_t value = vmv_x_s_u32m1_u32(vmin);\n        if ((value & 1) == 0 && (result == -1 || value < result)) {\n            result = value;\n        }\n        vmin = vssrl_vx_u32m1(vmin, 1, vl);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_11_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    size_t vlmax = vlenb() / sizeof(int);\n    size_t i = 0;\n    int result = INT32_MAX;\n\n    // Initialize vector with maximum values\n    vint32m1_t vmin = vmv_v_x_i32m1(INT32_MAX, vlmax);\n\n    for (; i + vlmax <= length; i += vlmax) {\n        // Load vector from source array\n        vint32m1_t vsrc = vle32_v_i32m1(src + i, vlmax);\n\n        // Generate mask for even indices\n        vbool4_t mask = vmseq_vx_b4m1(i & 1, 0, vlmax);\n\n        // Select elements at even indices\n        vint32m1_t veven = vmrgt_vx_i32m1(vsrc, 0, vlmax);\n\n        // Find minimum among selected even elements\n        vmin = vmnmsub_vv_i32m1(vmin, veven, veven, mask, vlmax);\n    }\n\n    // Extract scalar minimum from vector\n    for (size_t j = 0; j < vlmax; j++) {\n        int min_val = vmin[j];\n        if (min_val < result) result = min_val;\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        if ((i % 2) == 0 && src[i] < result) {\n            result = src[i];\n        }\n    }\n\n    return result == INT32_MAX ? -1 : result;\n}\n```"}
{"task_id": "SimdBench_11_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    size_t vlmax = vsetvl_e32m1(length);\n    vuint32m1_t vindex = vmv_v_x_u32m1(0, vlmax);\n    vbool4_t vmask = vmsltu_vv_b4mask(vindex, vlmax, vlmax);\n    vindex = vid_v_u32m1(vlmax);\n\n    int min_val = INT32_MAX;\n    size_t i = 0;\n\n    for (; i + vlmax <= length; i += vlmax) {\n        vint32m1_t vsrc = vle32_v_i32m1(src + i, vlmax);\n        vbool4_t even_mask = vmsleu_vx_b4mask(vindex, 0, vlmax);\n        vint32m1_t veven = vmerge_vx_i32m1(vsrc, 0, even_mask, vlmax);\n        vint32m1_t vmin = vmredmin_vs_i32m1_i32m1(veven, veven, vmask, vlmax);\n        int scalar_min = vmv_x_s_i32m1_i32(vmin);\n        if (scalar_min < min_val) min_val = scalar_min;\n        vindex = vadd_vx_u32m1(vindex, vlmax, vlmax);\n    }\n\n    for (; i < length; i++) {\n        if ((i % 2 == 0) && (src[i] < min_val)) min_val = src[i];\n    }\n\n    return (min_val == INT32_MAX) ? -1 : min_val;\n}\n```"}
{"task_id": "SimdBench_11_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    size_t vlmax = vlenb() / sizeof(int);\n    int vmin = 0x7FFFFFFF;\n    size_t i = 0;\n\n    for (; i + vlmax <= length; i += vlmax) {\n        vint32m1_t vmask = vmseq_vXi32_m(vbool4_t, i, 0, vlmax); // Create mask for even indices\n        vint32m1_t vsrc = vle32_v_i32m1(src + i, vlmax); // Load vector\n        vint32m1_t veven = vmrgsort2_v_i32m1(vsrc, vmask, vlmax); // Select even elements\n        vint32m1_t vmin_vec = vmredmin_vs_i32m1_i32m1(veven, vmin, vlmax); // Reduce to find min\n        vmin = vmin_vec[0];\n    }\n\n    for (; i < length; i++) {\n        if ((i % 2 == 0) && (src[i] < vmin)) {\n            vmin = src[i];\n        }\n    }\n\n    return vmin == 0x7FFFFFFF ? -1 : vmin;\n}\n```"}
{"task_id": "SimdBench_12_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t vlmax = vsetvl_e32m1(length);\n    for (size_t vl = 0; vl < length; vl += vlmax) {\n        size_t actual_vl = vsetvl_e32m1(vlmax);\n\n        vint32m1_t vsrc = vle32_v_i32m1(src + vl, actual_vl);\n\n        vint32m1_t varith_shift = vsra_vx_i32m1(vsrc, shift, actual_vl);\n\n        vuint32m1_t vsrc_uint = vmv_x_s_i32_u32m1(vsrc);\n        vuint32m1_t vlogic_shift = vsrl_vx_u32m1(vsrc_uint, shift, actual_vl);\n        vint32m1_t vlogic_shift_int = vmv_x_s_u32i32m1(vlogic_shift);\n\n        vint32m1_t vresult = vadd_vv_i32m1(varith_shift, vlogic_shift_int, actual_vl);\n\n        vse32_v_i32m1(dst + vl, vresult, actual_vl);\n    }\n}\n```"}
{"task_id": "SimdBench_12_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t vlmax = vlenb() / sizeof(int);\n    size_t i = 0;\n\n    while (i < length) {\n        size_t vl = vsetvl_e32m1(vlmax > (length - i) ? (length - i) : vlmax);\n\n        vint32m1_t vsrc = vle32_v_i32m1((const int *)&src[i], vl);\n        vuint32m1_t vsrcu = (vuint32m1_t)vsrc;\n\n        vint32m1_t varith = vsra_vx_i32m1(vsrc, shift, vl);\n        vint32m1_t vlogic = (vint32m1_t)vsrl_vx_u32m1(vsrcu, shift, vl);\n\n        vint32m1_t vresult = vadd_vv_i32m1(varith, vlogic, vl);\n\n        vse32_v_i32m1(&dst[i], vresult, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_12_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t vlmax = vlenb() / sizeof(int);\n    size_t i = 0;\n\n    for (; i <= length - vlmax; i += vlmax) {\n        vint32m1_t vsrc = vle32_v_i32m1((const int *)&src[i], vlmax);\n        vuint32m1_t vsrc_u = vmv_x_s_u32m1_u32(vsrc); // Convert to unsigned\n\n        vint32m1_t arshift = vsra_vx_i32m1(vsrc, shift, vlmax); // Arithmetic right shift\n        vuint32m1_t lrshift = vsrl_vx_u32m1(vsrc_u, shift, vlmax); // Logical right shift\n        vint32m1_t result = vadd_vv_i32m1(arshift, (vint32m1_t)lrshift, vlmax); // Add results\n\n        vse32_v_i32m1(&dst[i], result, vlmax);\n    }\n\n    // Handle leftover elements with scalar code\n    for (; i < length; i++) {\n        int val = src[i];\n        int arshift_val = val >> shift;\n        int lrshift_val = ((unsigned int)val) >> shift;\n        dst[i] = arshift_val + lrshift_val;\n    }\n}\n```"}
{"task_id": "SimdBench_12_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t vlmax = vsetvl_e32m1(length);\n    for (size_t vl = 0; vl < length; vl += vlmax) {\n        size_t actual_vl = vsetvl_e32m1(vlmax);\n\n        vint32m1_t v_src = vle32_v_i32m1(src + vl, actual_vl);\n\n        vint32m1_t v_arith_shift = vsra_vx_i32m1(v_src, shift, actual_vl);\n\n        vuint32m1_t v_src_uint = vmv_x_s_u32m1_u32m1((uint32_t)v_src, actual_vl);\n        vuint32m1_t v_logic_shift = vsrl_vx_u32m1(v_src_uint, shift, actual_vl);\n        vint32m1_t v_logic_shift_int = vmv_x_s_i32m1_i32m1((int32_t)v_logic_shift, actual_vl);\n\n        vint32m1_t v_result = vadd_vv_i32m1(v_arith_shift, v_logic_shift_int, actual_vl);\n\n        vse32_v_i32m1(dst + vl, v_result, actual_vl);\n    }\n}\n```"}
{"task_id": "SimdBench_12_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t vlmax = vsetvl_e32m1(length);\n    for (size_t vl = 0; vl < length; vl += vlmax) {\n        size_t actual_vl = vsetvl_e32m1(vlmax);\n\n        vint32m1_t vsrc = vle32_v_i32m1(src + vl, actual_vl);\n\n        vint32m1_t varith_shift = vsra_vx_i32m1(vsrc, shift, actual_vl);\n\n        vuint32m1_t vsrc_uint = (vuint32m1_t)vsrc;\n        vuint32m1_t vlogic_shift_uint = vsrl_vx_u32m1(vsrc_uint, shift, actual_vl);\n        vint32m1_t vlogic_shift = (vint32m1_t)vlogic_shift_uint;\n\n        vint32m1_t vresult = vadd_vv_i32m1(varith_shift, vlogic_shift, actual_vl);\n\n        vse32_v_i32m1(dst + vl, vresult, actual_vl);\n    }\n}\n```"}
{"task_id": "SimdBench_13_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t vlmax = vsetvl_e32m1(total_elements);\n    vuint32m1_t vsum = vmv_v_x_u32m1(0, vlmax);\n    size_t i = 0;\n\n    for (; i <= total_elements - vlmax; i += vlmax) {\n        vuint32m1_t vdata = vle32_v_u32m1((const uint32_t *)(matrix + i), vlmax);\n        vsum = vadd_vv_u32m1(vsum, vdata, vlmax);\n    }\n\n    uint32_t temp_sum = 0;\n    temp_sum = vmv_x_s_u32m1_u32(vredsum_vs_u32m1_u32m1(vsum, vmv_v_x_u32m1(0, vlmax), vlmax));\n\n    for (; i < total_elements; i++) {\n        temp_sum += matrix[i];\n    }\n\n    return (int64_t)temp_sum;\n}\n```"}
{"task_id": "SimdBench_13_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t vlmax = vsetvl_e32m1(0);\n    int32_t sum = 0;\n    size_t i = 0;\n\n    for (; i <= total_elements - vlmax; i += vlmax) {\n        vuint32m1_t vmask = vmv_v_x_u32m1(0xFFFFFFFF, vlmax);\n        vint32m1_t vdata = vle32_v_i32m1(matrix + i, vlmax);\n        vint32m1_t vsum = vredsum_vs_i32m1_i32m1_i32(vdata, vdata, vmask, vlmax);\n        sum += vmv_x_s_i32m1_i32(vsum);\n    }\n\n    for (; i < total_elements; i++) {\n        sum += matrix[i];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t vlmax = vlenb() / sizeof(int);\n    int64_t sum = 0;\n\n    size_t i = 0;\n    for (; i <= total_elements - vlmax; i += vlmax) {\n        vint32m1_t vmatrix = vle32_v_i32m1(matrix + i, vlmax);\n        vint32m1_t vsum = vmatrix;\n        for (size_t j = 1; j < vlmax; j++) {\n            vsum = vadd_vv_i32m1(vsum, vmatrix, vlmax);\n        }\n        int32_t temp_sum = vmv_x_s_i32m1_i32(vsum);\n        sum += temp_sum;\n    }\n\n    // Handle leftovers\n    if (i < total_elements) {\n        size_t vl = total_elements - i;\n        vint32m1_t vmatrix = vle32_v_i32m1(matrix + i, vl);\n        vint32m1_t vsum = vmatrix;\n        for (size_t j = 1; j < vl; j++) {\n            vsum = vadd_vv_i32m1(vsum, vmatrix, vl);\n        }\n        int32_t temp_sum = vmv_x_s_i32m1_i32(vsum);\n        sum += temp_sum;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t vlmax = vlenb() / sizeof(int);\n    int64_t sum = 0;\n\n    size_t i = 0;\n    for (; i + vlmax <= total_elements; i += vlmax) {\n        vint32m1_t vmatrix = vle32_v_i32m1(matrix + i, vlmax);\n        vint32m1_t vsum = vmatrix;\n        for (size_t j = 1; j < vlmax; j++) {\n            vsum = vredsum_vs_i32m1_i32m1(vsum, vmatrix, vsum, vlmax);\n        }\n        sum += vmv_x_s_i32m1_i32(vsum);\n    }\n\n    // Handle remaining elements\n    if (i < total_elements) {\n        size_t vl = total_elements - i;\n        vint32m1_t vmatrix = vle32_v_i32m1(matrix + i, vl);\n        vint32m1_t vsum = vmatrix;\n        for (size_t j = 1; j < vl; j++) {\n            vsum = vredsum_vs_i32m1_i32m1(vsum, vmatrix, vsum, vl);\n        }\n        sum += vmv_x_s_i32m1_i32(vsum);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t vlmax = vsetvl_e32m1(0);\n    int32_t sum = 0;\n    size_t i = 0;\n\n    for (; i <= total_elements - vlmax; i += vlmax) {\n        vint32m1_t vmatrix = vle32_v_i32m1(&matrix[i], vlmax);\n        vint32m1_t vsum = vmadd_vx_i32m1(vmatrix, 1, 0, vlmax);\n        sum += vredsum_vs_i32m1_i32m1_int(vsum, 0, vlmax);\n    }\n\n    for (; i < total_elements; i++) {\n        sum += matrix[i];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_14_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t vl = vsetvl_e8m1(length);\n    vint8m1_t vmax = vmv_v_x_i8m1(-128, vl);\n    vuint64m8_t idx_max = vmv_v_x_u64m8(0, 1);\n\n    uint64_t current_index = 0;\n    uint64_t result_index = 0;\n    int8_t result_value = -128;\n\n    for(size_t i = 0; i < length; i += vl) {\n        size_t current_vl = vsetvl_e8m1(vmin_v_u_size(length - i, vl));\n        vint8m1_t vec = vle8_v_i8m1(src + i, current_vl);\n        \n        vbool8_t mask = vmge_vv_i8m1_b8(vec, vmax, current_vl);\n        vmax = vmrgt_vv_i8m1(mask, vec, vmax, current_vl);\n\n        vuint64m8_t indices = vmv_v_x_u64m8(current_index, 1);\n        idx_max = vmrgt_vv_u64m8(mask, indices, idx_max, current_vl);\n\n        current_index += current_vl;\n    }\n\n    result_value = vmv_x_s_i8m1_i8(vmax);\n    result_index = vmv_x_s_u64m8_u64(idx_max);\n\n    return result_index;\n}\n```"}
{"task_id": "SimdBench_14_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <limits.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t vl = vsetvl_e8m1(length);\n    vint8m1_t vmax = vmv_v_x_i8m1(INT8_MIN, vl);\n    vuint64m8_t imax = vmv_v_x_u64m8(0, 1);\n\n    size_t stride = vl;\n    size_t i = 0;\n\n    for (; i + stride <= length; i += stride) {\n        vint8m1_t vsrc = vle8_v_i8m1(src + i, vl);\n        vbool8_t mask = vmge_vv_i8m1_b8(vsrc, vmax, vl);\n        vmax = vmrgt_vvm_i8m1(vsrc, vmax, mask, vl);\n        imax = vmrgt_vvm_u64m8(imax, imax, mask, vl);\n    }\n\n    int8_t max_val = vmv_x_s_i8m1_i8(vmax);\n    size_t max_idx = vmv_x_s_u64m8_u64(imax);\n\n    for (; i < length; i++) {\n        if (src[i] > max_val) {\n            max_val = src[i];\n            max_idx = i;\n        }\n    }\n\n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_14_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t vl = vsetvl_e8m1(length);\n    vint8m1_t vmax = vmv_v_x_i8m1(-128, vl);\n    vuint64m4_t idx_max = vmv_v_x_u64m4(0, vl);\n\n    size_t index = 0;\n    for(size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e8m1(length - i);\n        vint8m1_t vec = vle8_v_i8m1(src + i, vl);\n        vbool8_t mask = vmge_vv_i8m1_b8(vec, vmax, vl);\n        vmax = vmrgt_vvm_i8m1(vmax, vec, mask, vl);\n        vuint64m4_t indices = vid_v_u64m4(vl);\n        indices = add_u64(indices, i);\n        idx_max = vmrgt_vvm_u64m4(idx_max, indices, mask, vl);\n    }\n\n    uint64_t res_idx;\n    vmv_s_x_u64_u64m4(&res_idx, idx_max, vl);\n    return (size_t)res_idx;\n}\n```"}
{"task_id": "SimdBench_14_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t vlmax = vsetvl_e8m1(length);\n    vint8m1_t vmax = vmv_v_x_i8m1(-128, vlmax);\n    vuint64m8_t idx_max = vmv_v_x_u64m8(0, 1);\n\n    size_t i = 0;\n    for (; i + vlmax <= length; i += vlmax) {\n        vint8m1_t vec = vle8_v_i8m1(src + i, vlmax);\n        vbool8_t mask = vmge_vv_i8m1_b8(vec, vmax, vlmax);\n        vmax = vmrgt_vvm_i8m1(vmax, vec, mask, vlmax);\n        vuint64m8_t indices = vid_v_u64m8(1);\n        idx_max = vmrgt_vvm_u64m8(idx_max, indices, mask, 1);\n    }\n\n    int8_t max_val = vmv_x_s_i8m1_i8(vmax);\n    size_t result_idx = vmv_x_s_u64m8_u64(idx_max);\n\n    for (; i < length; i++) {\n        if (src[i] > max_val) {\n            max_val = src[i];\n            result_idx = i;\n        }\n    }\n\n    return result_idx;\n}\n```"}
{"task_id": "SimdBench_14_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t vl = vsetvl_e8m1(length);\n    vint8m1_t vmax = vmv_v_x_i8(-128, vl);\n    vuint64m4_t idx_max = vmv_v_x_u64(0, vl);\n    vuint64m4_t vidx = vid_v_u64(vl);\n\n    for (size_t i = 0; i < length; i += vl) {\n        size_t sub_length = length - i > vl ? vl : length - i;\n        vint8m1_t vsrc = vle8_v_i8(src + i, sub_length);\n        vbool8_t mask = vmge_vv_i8_b8(vsrc, vmax, sub_length);\n        vmax = vmrgt_vvm_i8(vmax, vsrc, mask, sub_length);\n        idx_max = vmrgt_vvm_u64(idx_max, vidx, mask, sub_length);\n        vidx = vadd_vx_u64(vidx, sub_length, vl);\n    }\n\n    uint64_t res_idx = vmv_x_s_u64u64(idx_max);\n    return res_idx;\n}\n```"}
{"task_id": "SimdBench_15_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    size_t vlmax = vsetvl_e16m1(length);\n    for (; i + vlmax <= length; i += vlmax) {\n        vuint16m1_t vmask = vmseq_vxu16m1(vsediv_vxu16m1(i, vlmax), mask & vsediv_vxu16m1(i, vlmax), vlmax);\n        vuint16m1_t vsrc1 = vle16_v_u16m1(src1 + i, vlmax);\n        vuint16m1_t vsrc2 = vle16_v_u16m1(src2 + i, vlmax);\n        vuint16m1_t vres = vmerge_vvm_u16m1(vsrc2, vsrc1, vmask, vlmax);\n        vse16_v_u16m1(dst + i, vres, vlmax);\n    }\n    for (; i < length; i++) {\n        if ((i & mask) != 0) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    size_t vlmax = vsetvl_e16m1(length);\n    for (size_t vl = vsetvl_e16m1(length); i < length; i += vl, vl = vsetvl_e16m1(length - i)) {\n        vuint16m1_t v_src1 = lvu16_v_u16m1(src1 + i, vl);\n        vuint16m1_t v_src2 = lvu16_v_u16m1(src2 + i, vl);\n        vbool8_t cond = vmfgtu_vx_b8(vl, ((i & mask) != 0), vl);\n        vuint16m1_t v_res = vmerge_vvm_u16m1(v_src1, v_src2, cond, vl);\n        svu16_v_u16m1(dst + i, v_res, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_15_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t vlmax = vsetvl_e16m1(length);\n    size_t i = 0;\n\n    for (; i + vlmax <= length; i += vlmax) {\n        size_t vl = vsetvl_e16m1(vlmax);\n\n        vuint16m1_t vsrc1 = vle16_v_u16m1(src1 + i, vl);\n        vuint16m1_t vsrc2 = vle16_v_u16m1(src2 + i, vl);\n\n        // Generate index vector\n        vuint32m2_t vidx = vid_v_u32m2(vl);\n        vuint32m2_t vmask = vand_vx_u32m2(vidx, mask, vl);\n\n        // Convert mask to predicate\n        vbool8_t blend_mask = vmv_v_x_b8((vmask != 0), vl);\n\n        vuint16m1_t vres = vmux_vv_b8(vsrc1, vsrc2, blend_mask, vl);\n\n        vse16_v_u16m1(dst + i, vres, vl);\n    }\n\n    // Handle leftover elements\n    if (i < length) {\n        size_t vl = vsetvl_e16m1(length - i);\n\n        vuint16m1_t vsrc1 = vle16_v_u16m1(src1 + i, vl);\n        vuint16m1_t vsrc2 = vle16_v_u16m1(src2 + i, vl);\n\n        // Generate index vector\n        vuint32m2_t vidx = vid_v_u32m2(vl);\n        vuint32m2_t vmask = vand_vx_u32m2(vidx, mask, vl);\n\n        // Convert mask to predicate\n        vbool8_t blend_mask = vmv_v_x_b8((vmask != 0), vl);\n\n        vuint16m1_t vres = vmux_vv_b8(vsrc1, vsrc2, blend_mask, vl);\n\n        vse16_v_u16m1(dst + i, vres, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_15_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    size_t vlmax = vsetvl_e16m1(length);\n    for (; i <= length - vlmax; i += vlmax) {\n        size_t vl = vsetvl_e16m1(vlmax);\n        vuint16m1_t vsrc1 = vle16_v_u16m1(src1 + i, vl);\n        vuint16m1_t vsrc2 = vle16_v_u16m1(src2 + i, vl);\n        \n        // Generate index vector\n        vuint32m2_t vidx = vid_v_u32m2(vl);\n        vuint32m2_t vmasked_idx = vand_vx_u32m2(vidx, mask, vl);\n        vbool8_t blend_mask = vmsne_vx_b8(vmasked_idx, 0, vl);\n\n        vuint16m1_t vres = vmerge_vvm_u16m1(vsrc1, vsrc2, blend_mask, vl);\n        vse16_v_u16m1(dst + i, vres, vl);\n    }\n    for (; i < length; i++) {\n        if ((i & mask) != 0) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    vuint16m1_t vmask;\n    vuint16m1_t vsrc1, vsrc2, vdst;\n\n    size_t vlmax = vsetvl_e16m1(length);\n    for (i = 0; i + vlmax <= length; i += vlmax) {\n        vmask = vmsne_vx_u16m1(vsedu_vx_u16m1(i, vlmax) & mask, 0, vlmax);\n        vsrc1 = vle16_v_u16m1(src1 + i, vlmax);\n        vsrc2 = vle16_v_u16m1(src2 + i, vlmax);\n        vdst = vmerge_vvm_u16m1(vsrc1, vsrc2, vmask, vlmax);\n        vse16_v_u16m1(dst + i, vdst, vlmax);\n    }\n\n    if (i < length) {\n        size_t vl = vsetvl_e16m1(length - i);\n        vmask = vmsne_vx_u16m1(vsedu_vx_u16m1(i, vl) & mask, 0, vl);\n        vsrc1 = vle16_v_u16m1(src1 + i, vl);\n        vsrc2 = vle16_v_u16m1(src2 + i, vl);\n        vdst = vmerge_vvm_u16m1(vsrc1, vsrc2, vmask, vl);\n        vse16_v_u16m1(dst + i, vdst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_16_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t vlmax = vsetvl_e32m1(length);\n    for (size_t vl = 0; vl < length; vl += vlmax) {\n        size_t actual_vl = vsetvl_e32m1(vlmax);\n        vuint32m1_t v_src = vle32_v_u32m1(src + vl, actual_vl);\n        vuint32m1_t v_popcount = __rv_clz(v_src);\n        vse32_v_u32m1(dst + vl, v_popcount, actual_vl);\n    }\n}\n```"}
{"task_id": "SimdBench_16_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t vlmax = vsetvl_e32m1(length);\n    for (size_t i = 0; i < length; i += vlmax) {\n        size_t vl = vsetvl_e32m1(vlmax > (length - i) ? (length - i) : vlmax);\n        vuint32m1_t v_src = vle32_v_u32m1(src + i, vl);\n        vuint32m1_t v_popcount = __rv_clp_u32(v_src);\n        vse32_v_u32m1(dst + i, v_popcount, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_16_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t vlmax = vsetvl_e32m1(length);\n    for (size_t vl = vlmax; vl > 0; vl = vsetvl_e32m1(vl)) {\n        vuint32m1_t vs = vle32_v_u32m1(src, vl);\n        vuint32m1_t res = __rv_vpopc(vs, vl);\n        vse32_v_u32m1(dst, res, vl);\n        src += vl;\n        dst += vl;\n        length -= vl;\n    }\n}\n```"}
{"task_id": "SimdBench_16_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t vlmax = vsetvl_e32m1(length);\n    for (size_t vl = vlmax; vl != 0; vl = vsetvl_e32m1(length)) {\n        vuint32m1_t vsrc = vle32_v_u32m1(src, vl);\n        vuint32m1_t vpopc = vpopc_m_u32m1(vsrc, vl);\n        vse32_v_u32m1(dst, vpopc, vl);\n        src += vl;\n        dst += vl;\n        length -= vl;\n    }\n}\n```"}
{"task_id": "SimdBench_16_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t vlmax = vsetvl_e32m1(length);\n    for (size_t vl = vlmax; vl != 0; vl = vsetvl_e32m1(vl)) {\n        vuint32m1_t vs = vle32_v_u32m1(src, vl);\n        vuint32m1_t vd = vpopc_m_u32m1(vs, vl);\n        vse32_v_u32m1(dst, vd, vl);\n        src += vl;\n        dst += vl;\n        length -= vl;\n        if (length == 0) break;\n    }\n}\n```"}
{"task_id": "SimdBench_17_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t vlmax = vsetvl_e16m1(length);\n    size_t i = 0;\n    for (; i + vlmax <= length; i += vlmax) {\n        vuint16m1_t vs1 = vle16_v_u16m1(src1 + i, vlmax);\n        vuint16m1_t vs2 = vle16_v_u16m1(src2 + i, vlmax);\n        vuint16m1_t vd = vaddu_wv_u16m1(vs1, vs2, vlmax);\n        vse16_v_u16m1(dst + i, vd, vlmax);\n    }\n    if (i < length) {\n        size_t vl = vsetvl_e16m1(length - i);\n        vuint16m1_t vs1 = vle16_v_u16m1(src1 + i, vl);\n        vuint16m1_t vs2 = vle16_v_u16m1(src2 + i, vl);\n        vuint16m1_t vd = vaddu_wv_u16m1(vs1, vs2, vl);\n        vse16_v_u16m1(dst + i, vd, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_17_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t vlmax = vsetvl_e16m1(length);\n    vuint16m1_t v0 = vmv_v_x_u16m1(0, vlmax);\n    size_t i = 0;\n\n    for (; i + vlmax <= length; i += vlmax) {\n        vuint16m1_t vs1 = vle16_v_u16m1(src1 + i, vlmax);\n        vuint16m1_t vs2 = vle16_v_u16m1(src2 + i, vlmax);\n        vuint16m1_t vd = vaddu_vv_u16m1(vs1, vs2, vlmax);\n        vse16_v_u16m1(dst + i, vd, vlmax);\n    }\n\n    if (i < length) {\n        size_t vl = vsetvl_e16m1(length - i);\n        vuint16m1_t vs1 = vle16_v_u16m1(src1 + i, vl);\n        vuint16m1_t vs2 = vle16_v_u16m1(src2 + i, vl);\n        vuint16m1_t vd = vaddu_vv_u16m1(vs1, vs2, vl);\n        vse16_v_u16m1(dst + i, vd, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_17_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t vlmax = vsetvl_e16m1(length);\n    for (size_t vl = 0; vl < length; vl += vlmax) {\n        size_t actual_vl = vsetvl_e16m1(vlmax);\n        vuint16m1_t vs1 = vle16_v_u16m1(src1 + vl, actual_vl);\n        vuint16m1_t vs2 = vle16_v_u16m1(src2 + vl, actual_vl);\n        vuint16m1_t vd = vaddu_wv_u16m1(vs1, vs2, actual_vl);\n        vsseg1e16_v_u16m1(dst + vl, vd, actual_vl);\n    }\n}\n```"}
{"task_id": "SimdBench_17_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t vlmax = vsetvl_e16m1(length);\n    for (size_t vl = vlmax; vl != 0; vl = vsetvl_e16m1(vl)) {\n        vuint16m1_t vs1 = vle16_v_u16m1(src1, vl);\n        vuint16m1_t vs2 = vle16_v_u16m1(src2, vl);\n        vuint16m1_t vd = vaddu_wv_u16m1(vs1, vs2, vl);\n        vse16_v_u16m1(dst, vd, vl);\n        src1 += vl;\n        src2 += vl;\n        dst += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_17_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t vlmax = vsetvl_e16m1(length);\n    for (size_t vl = vlmax; vl != 0; vl = vsetvl_e16m1(vl)) {\n        vuint16m1_t vs1 = vle16_v_u16m1(src1, vl);\n        vuint16m1_t vs2 = vle16_v_u16m1(src2, vl);\n        vuint16m1_t vd = vaddu_wv_u16m1(vs1, vs2, vl);\n        vse16_v_u16m1(dst, vd, vl);\n        src1 += vl;\n        src2 += vl;\n        dst += vl;\n        length -= vl;\n    }\n}\n```"}
{"task_id": "SimdBench_18_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    size_t vlmax = vsetvl_e64m8(1);\n    vfloat64m8_t vzero = vfreinterpret64m8_f32m4(vfmv_v_f_f32m4(0.0f, vlmax));\n    vfloat64m8_t vlower = vf64m8(-100.0, vlmax);\n    vfloat64m8_t vupper = vf64m8(100.0, vlmax);\n\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            size_t vl = vsetvl_e64m8(n);\n            vfloat64m8_t vc = vfmv_v_f_f64m8(0.0, vl);\n            \n            for (size_t k = 0; k < n; k += vl) {\n                size_t actual vl = vsetvl_e64m8(n - k);\n                vfloat64m8_t va = lvf64_v_f64m8(&A[i * n + k], actual_vl);\n                vfloat64m8_t vb = lvf64_v_f64m8(&B[j * n + k], actual_vl);\n                \n                vbool8_t mask_a = vmfgt_vf_f64m8_b8(va, vlower, actual_vl) & vmflt_vf_f64m8_b8(va, vupper, actual_vl);\n                vbool8_t mask_b = vmfgt_vf_f64m8_b8(vb, vlower, actual_vl) & vmflt_vf_f64m8_b8(vb, vupper, actual_vl);\n                vbool8_t mask = vmand_vv_b8(mask_a, mask_b, actual_vl);\n                \n                vfloat64m8_t vprod = vmul_vv_f64m8_m(mask, va, vb, vzero, actual_vl);\n                vc = vredsum_vs_f64m8_f64m1_f64m8(vc, vprod, vzero, actual_vl);\n            }\n            sum += vhsumseg1mf8_f64m8_f64(vc, vlmax);\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    size_t vlmax = vsetvl_e64m8(1);\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double* c_ptr = &C[i * p + j];\n            *c_ptr = 0.0;\n            size_t k = 0;\n            size_t vl;\n            vbool8_t mask;\n            vfloat64m8_t va, vb, vc;\n\n            while (k < n) {\n                vl = vsetvl_e64m8(n - k);\n                va = vle64_v_f64m8(&A[i * n + k], vl);\n                vb = vle64_v_f64m8(&B[j + k * p], vl);\n\n                // Create masks for values in range [-100, 100]\n                mask = vmfgt_f64m8_b8(va, -100.0, vl);\n                mask = vmand_mm(mask, vmflt_f64m8_b8(va, 100.0, vl));\n                mask = vmand_mm(mask, vmfgt_f64m8_b8(vb, -100.0, vl));\n                mask = vmand_mm(mask, vmflt_f64m8_b8(vb, 100.0, vl));\n\n                vc = vmul_vv_f64m8(va, vb, vl);\n                vc = vmasked_add_vv_f64m8(vc, vc, vc, mask, vl);\n\n                *c_ptr += vredsum_vs_f64m8_f64m1(vc, *c_ptr, vl);\n                k += vl;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    size_t vlmax = vsetvl_e64m8(1);\n    vfloat64m8_t vmask;\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t k = 0; k < n; ++k) {\n            double a_val = A[i * n + k];\n            if (a_val < -100.0 || a_val > 100.0) continue;\n            vmask = vmflt_vf_f64m8(vmfle_vf_f64m8(vmload_v_f64m8(&B[k * p], vlmax), -100.0, vlmax), 100.0, vlmax);\n            for (size_t j = 0; j < p; j += vlmax) {\n                size_t vl = vsetvl_e64m8(p - j);\n                vfloat64m8_t vb = vmul_vv_f64m8(vmask, vmload_v_f64m8(&B[k * p + j], vl), vl);\n                vfloat64m8_t vc = vmadd_vv_f64m8(vmload_v_f64m8(&C[i * p + j], vl), vb, vmask, vl);\n                vmstore_v_f64m8(&C[i * p + j], vc, vl);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    size_t vlmax = vsetvl_e64m1(n);\n    for (size_t i = 0; i < m; i++) {\n        for (size_t k = 0; k < p; k++) {\n            double sum = 0.0;\n            size_t j = 0;\n            while (j < n) {\n                size_t vl = vsetvl_e64m1(vlmax);\n                vfloat64m1_t va = vle64_v_f64m1(&A[i * n + j], vl);\n                vfloat64m1_t vb = vle64_v_f64m1(&B[k + j * p], vl);\n                \n                // Mask elements outside [-100, 100]\n                vfloat64m1_t vmin = vmv_v_x_f64m1(-100.0, vl);\n                vfloat64m1_t vmax = vmv_v_x_f64m1(100.0, vl);\n                vbool64_t mask_a = vfredosum_mask_f64m1_b64(va, vmin, vmax, vl);\n                vbool64_t mask_b = vfredosum_mask_f64m1_b64(vb, vmin, vmax, vl);\n                \n                vfloat64m1_t va_masked = vand_vv_f64m1(va, mask_a, vl);\n                vfloat64m1_t vb_masked = vand_vv_f64m1(vb, mask_b, vl);\n                \n                vfloat64m1_t prod = vmul_vv_f64m1(va_masked, vb_masked, vl);\n                sum += vfsumseg_reduction(prod, vl);\n                j += vl;\n            }\n            C[i * p + k] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    size_t vlmax = vsetvl_e64m1(1);\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            size_t k = 0;\n            for (; k + vlmax <= n; k += vlmax) {\n                vfloat64m1_t va = vle64_v_f64m1(&A[i * n + k], vlmax);\n                vfloat64m1_t vb = vle64_v_f64m1(&B[k * p + j], vlmax);\n                vbool8_t mask_a = vmfgt_vf_f64m1_b8(va, -100.0, vlmax);\n                vbool8_t mask_b = vmfgt_vf_f64m1_b8(vb, -100.0, vlmax);\n                vbool8_t mask_a_and = vmand_mm_b8(mask_a, vmflt_vf_f64m1_b8(va, 100.0, vlmax), vlmax);\n                vbool8_t mask_b_and = vmand_mm_b8(mask_b, vmflt_vf_f64m1_b8(vb, 100.0, vlmax), vlmax);\n                vbool8_t mask_final = vmand_mm_b8(mask_a_and, mask_b_and, vlmax);\n                vfloat64m1_t prod = vmul_vv_f64m1(va, vb, vlmax);\n                vfloat64m1_t masked_prod = vmadd_vfm_f64m1_m(sum, prod, 0.0, mask_final, vlmax);\n                sum = vfredosum_vs_f64m1_f64(sum, masked_prod, vlmax);\n            }\n            for (; k < n; ++k) {\n                if (A[i * n + k] > -100 && A[i * n + k] < 100 &&\n                    B[k * p + j] > -100 && B[k * p + j] < 100) {\n                    sum += A[i * n + k] * B[k * p + j];\n                }\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vlmax = vsetvl_e64m1(total_elements);\n\n    for (size_t i = 0; i < total_elements; i += vlmax) {\n        size_t vl = vsetvl_e64m1(total_elements - i);\n        vint64m1_t va = vle64_v_i64m1(A + i, vl);\n        vint64m1_t vb = vle64_v_i64m1(B + i, vl);\n        vint64m1_t vc = vadd_vv_i64m1(va, vb, vl);\n        vse64_v_i64m1(C + i, vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_19_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vlmax = vsetvl_e64m1(total_elements);\n\n    for(size_t i = 0; i < total_elements; i += vlmax) {\n        size_t vl = vsetvl_e64m1(total_elements - i);\n        vint64m1_t va = vle64_v_i64m1(A + i, vl);\n        vint64m1_t vb = vle64_v_i64m1(B + i, vl);\n        vint64m1_t vc = vadd_vv_i64m1(va, vb, vl);\n        vse64_v_i64m1(C + i, vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_19_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vlmax = vsetvl_e64m1(total_elements);\n\n    for (size_t i = 0; i < total_elements; i += vlmax) {\n        size_t vl = vsetvl_e64m1(total_elements - i);\n        vint64m1_t va = vle64_v_i64m1(A + i, vl);\n        vint64m1_t vb = vle64_v_i64m1(B + i, vl);\n        vint64m1_t vc = vadd_vv_i64m1(va, vb, vl);\n        vse64_v_i64m1(C + i, vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_19_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vlmax = vsetvl_e64m1(total_elements);\n    \n    for (size_t i = 0; i < total_elements; i += vlmax) {\n        size_t vl = vsetvl_e64m1(total_elements - i);\n        vint64m1_t va = vle64_v_i64m1(A + i, vl);\n        vint64m1_t vb = vle64_v_i64m1(B + i, vl);\n        vint64m1_t vc = vadd_vv_i64m1(va, vb, vl);\n        vse64_v_i64m1(C + i, vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_19_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vlmax = vsetvl_e64m1(total_elements);\n\n    for (size_t i = 0; i < total_elements; i += vlmax) {\n        size_t vl = vsetvl_e64m1(total_elements - i);\n        vint64m1_t va = vle64_v_i64m1(A + i, vl);\n        vint64m1_t vb = vle64_v_i64m1(B + i, vl);\n        vint64m1_t vc = vadd_vv_i64m1(va, vb, vl);\n        vse64_v_i64m1(C + i, vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_20_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vlmax = vsetvl_e32m1(length);\n    vfloat32m1_t v_src1, v_src2, v_res;\n    vint32m1_t v_res_rounded;\n\n    for (size_t i = 0; i < length; i += vlmax) {\n        size_t vl = vsetvl_e32m1(length - i);\n        v_src1 = vle32_v_f32m1(src1 + i, vl);\n        v_src2 = vle32_v_f32m1(src2 + i, vl);\n        v_res = vfadd_vv_f32m1(v_src1, v_src2, vl);\n        v_res_rounded = vrndne_wv_f32m1_i32m1(v_res, vl);\n        vse32_v_i32m1((int*)dst + i, v_res_rounded, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_20_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vlmax = vsetvl_e32m1(length);\n    for (size_t vl = 0; vl < length; vl += vlmax) {\n        size_t actual_vl = vsetvl_e32m1(vlmax);\n        vfloat32m1_t vs1 = vlload_e32m1(src1 + vl, actual_vl);\n        vfloat32m1_t vs2 = vlload_e32m1(src2 + vl, actual_vl);\n        vfloat32m1_t vresult_f = vfadd_vv_f32m1(vs1, vs2, actual_vl);\n        vint32m1_t vresult_i = vrndne_vf_i32m1(vresult_f, actual_vl);\n        vlstore_e32m1(dst + vl, vresult_i, actual_vl);\n    }\n}\n```"}
{"task_id": "SimdBench_20_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vlmax = vsetvl_e32m1(length);\n    for (size_t vl = 0; vl < length; vl += vlmax) {\n        size_t actual_vl = vsetvl_e32m1(vlmax);\n        vfloat32m1_t vs1 = vlload_e32m1(src1 + vl, actual_vl);\n        vfloat32m1_t vs2 = vlload_e32m1(src2 + vl, actual_vl);\n        vfloat32m1_t vresult = vfadd_vv_f32m1(vs1, vs2, actual_vl);\n        vuint32m1_t vrounded = vrndu_vf32m1_tu(vresult, actual_vl);\n        vlstore_e32m1(dst + vl, vfcvt_f_x_v_u32m1(vrounded, actual_vl), actual_vl);\n    }\n}\n```"}
{"task_id": "SimdBench_20_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vlmax = vsetvl_e32m1(length);\n    for (size_t vl = 0; vl < length; vl += vlmax) {\n        size_t actual_vl = vsetvl_e32m1(vlmax);\n        vfloat32m1_t vs1 = vle32_v_f32m1(src1 + vl, actual_vl);\n        vfloat32m1_t vs2 = vle32_v_f32m1(src2 + vl, actual_vl);\n        vfloat32m1_t vres = vfadd_vv_f32m1(vs1, vs2, actual_vl);\n        vint32m1_t vrounded = vrndna_v_i32m1_f32m1(vres, actual_vl);\n        vse32_v_i32m1((int*)dst + vl, vrounded, actual_vl);\n    }\n}\n```"}
{"task_id": "SimdBench_20_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vlmax = vsetvl_e32m1(length);\n    for (size_t vl = 0; vl < length; vl += vlmax) {\n        size_t actual_vl = vsetvl_e32m1(vlmax);\n        vfloat32m1_t vs1 = vle32_v_f32m1(src1 + vl, actual_vl);\n        vfloat32m1_t vs2 = vle32_v_f32m1(src2 + vl, actual_vl);\n        vfloat32m1_t vres = vfadd_vv_f32m1(vs1, vs2, actual_vl);\n        vfloat32m1_t vrounded = vrndna_v_f32m1(vres, actual_vl);\n        vse32_v_f32m1(dst + vl, vrounded, actual_vl);\n    }\n}\n```"}
{"task_id": "SimdBench_21_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <float.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length){\n    size_t vlmax = vsetvl_e32m1(length);\n    for (size_t i = 0; i < length; i += vlmax) {\n        size_t vl = vsetvl_e32m1(vlmax);\n        vfloat32m1_t vsrc1 = vle32_v_f32m1(src1 + i, vl);\n        vfloat32m1_t vsrc2 = vle32_v_f32m1(src2 + i, vl);\n        vfloat32m1_t vdiff = vfsub_vv_f32m1(vsrc1, vsrc2, vl);\n        vfloat32m1_t vabs_diff = vfabs_v_f32m1(vdiff, vl);\n        vfloat32m1_t vcond_val = vmf_eq_vf_f32m1(vabs_diff, 50.0f, vl);\n        vuint32m1_t vindex = vid_v_u32m1(vl);\n        vbool32_t vcond_index = vmf_and_vv_b32m1(vmseq_vx_u32m1(vindex, 2, vl), vcond_val, vl);\n        vfloat32m1_t vmul_res = vmul_vv_f32m1(vsrc1, vsrc2, vl);\n        vfloat32m1_t vrounded = vrndu_v_f32m1(vmul_res, vl);\n        vfloat32m1_t vres = vfcvt_x_f_w_f32m1(-1.0f, vl);\n        vres = vmf_merge_vv_f32m1(vres, vrounded, vcond_index, vl);\n        vse32_v_f32m1(dst + i, vres, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_21_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length){\n    size_t vlmax = vsetvl_e32m1(length);\n    for (size_t i = 0; i < length; i += vlmax) {\n        size_t vl = vsetvl_e32m1(vlmax > (length - i) ? (length - i) : vlmax);\n        vfloat32m1_t vs1 = vluxseg1ei32_v_f32m1(src1 + i, 4, vl);\n        vfloat32m1_t vs2 = vluxseg1ei32_v_f32m1(src2 + i, 4, vl);\n        vfloat32m1_t vres = vmul_vv_f32m1(vs1, vs2, vl);\n        vfloat32m1_t vdiff = vsub_vv_f32m1(vs1, vs2, vl);\n        vfloat32m1_t vabs_diff = vfabs_v_f32m1(vdiff, vl);\n        vbool32_t cond1 = vle_vf_f32m1_b32(vabs_diff, 50.0f, vl);\n        vuint32m1_t vidx = vid_v_u32m1(vl);\n        vbool32_t cond2 = vand_vv_b32(vmseq_vx_u32m1_b32(vidx, 0, vl), vmseq_vx_u32m1_b32(vidx, 2, vl), vl);\n        vbool32_t cond = vand_vv_b32(cond1, cond2, vl);\n        vfloat32m1_t vcond_res = vfceil_v_f32m1(vres, vl);\n        vfloat32m1_t vneg_one = vmvf_v_f32m1(-1.0f, vl);\n        vfloat32m1_t vfinal = vfcvt_x_f_w_f32m1(vfmerge_vfm_f32m1(vcond_res, vneg_one, cond, vl), vl);\n        vsseg1eiv2_f32(dst + i, vfinal, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_21_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <float.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length){\n    size_t vlmax = vsetvl_e32m1(length);\n    for (size_t i = 0; i < length; i += vlmax) {\n        size_t vl = vsetvl_e32m1(vlmax > (length - i) ? (length - i) : vlmax);\n        vfloat32m1_t vsrc1 = vlloadseg1_float32(&src1[i], vl);\n        vfloat32m1_t vsrc2 = vlloadseg1_float32(&src2[i], vl);\n        vfloat32m1_t vdiff = vfsub_vv_f32m1(vsrc1, vsrc2, vl);\n        vfloat32m1_t vabs_diff = vfabs_v_f32m1(vdiff, vl);\n        vfloat32m1_t vcond_val = vmfle_vf_f32m1_b(vabs_diff, 50.0f, vl);\n        vint32m1_t vindex = vid_v_i32m1(0, vl);\n        vbool8_t vcond_idx = vmseq_vx_b8(vindex, 0, vl);\n        vbool8_t vcond = vand_vv_b8(vcond_val, vcond_idx, vl);\n        vfloat32m1_t vmul_res = vmul_vv_f32m1(vsrc1, vsrc2, vl);\n        vfloat32m1_t vrounded = vrndu_v_f32m1(vmul_res, vl);\n        vfloat32m1_t vres = vfredge_vf_f32m1(-1.0f, vrounded, vcond, vl);\n        vlstoreseg1_float32(&dst[i], vres, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_21_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <float.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length){\n    size_t vlmax = vsetvl_e32m1(0);\n    for (size_t i = 0; i < length; i += vlmax) {\n        size_t vl = vsetvl_e32m1(length - i);\n        vfloat32m1_t v_src1 = vlsov_f32mf2(src1 + i, vl);\n        vfloat32m1_t v_src2 = vlsov_f32mf2(src2 + i, vl);\n        vfloat32m1_t v_diff = vfsub_vv_f32m1(v_src1, v_src2, vl);\n        vfloat32m1_t v_abs_diff = vfabs_v_f32m1(v_diff, vl);\n        vbool32_t cond1 = vmfle_vf_f32m1_b32(v_abs_diff, 50.0f, vl);\n        vuint32m1_t v_idx = vid_v_u32m1(vl);\n        vbool32_t cond2 = vmseq_vx_u32m1_b32(vfmodu_vs_u32m1_u32m1(v_idx, 2, vl), 0, vl);\n        vbool32_t cond = vmand_vv_b32(cond1, cond2, vl);\n        vfloat32m1_t v_mul = vmul_vv_f32m1(v_src1, v_src2, vl);\n        vfloat32m1_t v_res = vrndu_vf_f32m1(v_mul, vl);\n        vfloat32m1_t v_default = vmvf_v_f32m1(-1.0f, vl);\n        vfloat32m1_t v_final = vfcvt_x_f_w_f32m1(vmmerge_vvm_f32m1(v_res, v_default, cond, vl), vl);\n        vsseg1e32_v_f32m1(dst + i, v_final, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_21_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <float.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length){\n    size_t vlmax = vsetvl_e32m8(length);\n    for(size_t i = 0; i < length; i += vlmax) {\n        size_t vl = vsetvl_e32m8(length - i);\n        vfloat32m8_t vsrc1 = vle32_v_f32m8(src1 + i, vl);\n        vfloat32m8_t vsrc2 = vle32_v_f32m8(src2 + i, vl);\n\n        vfloat32m8_t diff = vfsub_vv_f32m8(vsrc1, vsrc2, vl);\n        vfloat32m8_t abs_diff = vfabs_v_f32m8(diff, vl);\n\n        vbool8_t cond1 = vmfle_v_f_f32m8_b8(abs_diff, 50.0f, vl);\n        vuint32m8_t index = vid_v_u32m8(vl);\n        vbool8_t cond2 = vmseq_vx_u32m8_b8(index, 0, vl); // Check if index % 2 == 0\n\n        vbool8_t cond = vmand_vv_b8(cond1, cond2, vl);\n\n        vfloat32m8_t mul_res = vmul_vv_f32m8(vsrc1, vsrc2, vl);\n        vfloat32m8_t ceil_res = vrndu_v_f32m8(mul_res, vl);\n\n        vfloat32m8_t res = vfcvt_x_f_w_f32m8(-1.0f, vl);\n        res = vmerge_vvm_f32m8(res, ceil_res, cond, vl);\n\n        vse32_v_f32m8(dst + i, res, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_22_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vlmax = vsetvl_e64m8(total_elements);\n    vfloat64m8_t vscalar = vmv_v_f_f64m8(scalar, vlmax);\n    for(size_t i = 0; i < total_elements; i += vlmax) {\n        size_t vl = vsetvl_e64m8(total_elements - i);\n        vfloat64m8_t vmat = vle64_v_f64m8(mat + i, vl);\n        vfloat64m8_t vresult = vmul_vf_f64m8(vmat, scalar, vl);\n        vse64_v_f64m8(dst + i, vresult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_22_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vlmax = vsetvl_e64m1(total_elements);\n\n    for (size_t i = 0; i < total_elements; i += vlmax) {\n        size_t vl = vsetvl_e64m1(total_elements - i);\n        vfloat64m1_t vmat = vle64_v_f64m1(&mat[i], vl);\n        vfloat64m1_t vresult = vmul_vf_f64m1(vmat, scalar, vl);\n        vse64_v_f64m1(&dst[i], vresult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_22_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vlmax = vsetvl_e64m1(total_elements);\n\n    for (size_t i = 0; i < total_elements; i += vlmax) {\n        size_t vl = vsetvl_e64m1(vlmax);\n        vfloat64m1_t vmat = vle64_v_f64m1(&mat[i], vl);\n        vfloat64m1_t vresult = vmul_vf_f64m1(vmat, scalar, vl);\n        vse64_v_f64m1(&dst[i], vresult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_22_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vlmax = vsetvl_e64m8(1);\n    \n    for (size_t i = 0; i < total_elements; i += vlmax) {\n        size_t vl = vsetvl_e64m8(total_elements - i);\n        vfloat64m8_t vmat = vle64_v_f64m8(mat + i, vl);\n        vfloat64m8_t vresult = vmul_vf_f64m8(vmat, scalar, vl);\n        vse64_v_f64m8(dst + i, vresult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_22_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vlmax = vsetvl_e64m8(total_elements);\n    vfloat64m8_t vscalar = vmv_v_f_f64m8(scalar, vlmax);\n    for(size_t i = 0; i < total_elements; i += vlmax) {\n        size_t vl = vsetvl_e64m8(total_elements - i);\n        vfloat64m8_t vmat = vle64_v_f64m8(mat + i, vl);\n        vfloat64m8_t vresult = vmul_vv_f64m8(vmat, vscalar, vl);\n        vse64_v_f64m8(dst + i, vresult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_23_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    size_t vlmax = vlenb() / sizeof(float);\n    for (size_t i = 0; i < m; i++) {\n        float* row = &mat[i * n];\n        size_t vl = vlmax;\n\n        // Compute L2 norm\n        float sum_of_squares = 0.0f;\n        for (size_t j = 0; j < n; j += vl) {\n            vl = (j + vlmax > n) ? n - j : vlmax;\n            vfloat32m1_t vec_row = vlrsqrt_v_f32m1(vle32_v_f32m1(row + j, vl), vl);\n            vfloat32m1_t vec_sq = vmul_vv_f32m1(vec_row, vec_row, vl);\n            float red_sq = vmv_s_x_f32m1(vredsum_vs_f32m1_f32m1(vec_sq, 0.0f, vl));\n            sum_of_squares += red_sq;\n        }\n        float norm = sqrtf(sum_of_squares);\n\n        // Normalize the row\n        if (norm > 0.0f) {\n            for (size_t j = 0; j < n; j += vl) {\n                vl = (j + vlmax > n) ? n - j : vlmax;\n                vfloat32m1_t vec_row = vle32_v_f32m1(row + j, vl);\n                vfloat32m1_t vec_norm = vmul_vf_f32m1(vec_row, 1.0f / norm, vl);\n                vse32_v_f32m1(row + j, vec_norm, vl);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    size_t vlmax = vsetvl_e32m1(n);\n    for (size_t i = 0; i < m; i++) {\n        float* row = &mat[i * n];\n        \n        // Compute L2 norm\n        size_t vl = vlmax;\n        vfloat32m1_t vrow = vmv_v_x_f32m1(0.0f, vl);\n        vfloat32m1_t vsum = vmv_v_x_f32m1(0.0f, vl);\n        size_t j = 0;\n        for (; (j + vl) <= n; j += vl) {\n            vrow = vle32_v_f32m1(row + j, vl);\n            vsum = vfmacc_vf_f32m1(vsum, 1.0f, vfmul_vv_f32m1(vrow, vrow, vl), vl);\n        }\n        float sum = 0.0f;\n        if (j < n) {\n            vl = vsetvl_e32m1(n - j);\n            vrow = vle32_v_f32m1(row + j, vl);\n            vsum = vfmacc_vf_f32m1(vsum, 1.0f, vfmul_vv_f32m1(vrow, vrow, vl), vl);\n        }\n        sum += vmv_s_x_f32m1_f32(vredsum_vs_f32m1_f32m1(vmv_v_x_f32m1(0.0f, vlmax), vsum, vlmax));\n        float norm = sqrtf(sum);\n\n        // Normalize row elements\n        if (norm != 0.0f) {\n            j = 0;\n            vl = vlmax;\n            for (; (j + vl) <= n; j += vl) {\n                vrow = vle32_v_f32m1(row + j, vl);\n                vrow = vfdiv_vf_f32m1(vrow, norm, vl);\n                vse32_v_f32m1(row + j, vrow, vl);\n            }\n            if (j < n) {\n                vl = vsetvl_e32m1(n - j);\n                vrow = vle32_v_f32m1(row + j, vl);\n                vrow = vfdiv_vf_f32m1(vrow, norm, vl);\n                vse32_v_f32m1(row + j, vrow, vl);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    size_t vlmax = vsetvl_e32m1(n);\n    for (size_t i = 0; i < m; i++) {\n        float* row = &mat[i * n];\n        \n        // Compute L2 norm\n        vfloat32m1_t vrow = vmv_v_x_f32m1(0.0f, vlmax);\n        vfloat32m1_t vsqrsum = vmv_v_x_f32m1(0.0f, vlmax);\n        size_t j = 0;\n        for (; j + vlmax <= n; j += vlmax) {\n            vrow = vle32_v_f32m1(row + j, vlmax);\n            vsqrsum = vfmacc_vf_f32m1(vsqrsum, 1.0f, vfmul_vv_f32m1(vrow, vrow, vlmax), vlmax);\n        }\n        float sum = 0.0f;\n        for (size_t k = 0; k < vlmax; k++) {\n            sum += vfget_f32m1(vsqrsum, k);\n        }\n        for (; j < n; j++) {\n            sum += row[j] * row[j];\n        }\n        float norm = sqrtf(sum);\n\n        // Normalize row\n        if (norm != 0.0f) {\n            size_t k = 0;\n            for (; k + vlmax <= n; k += vlmax) {\n                vrow = vle32_v_f32m1(row + k, vlmax);\n                vrow = vfdiv_vf_f32m1(vrow, norm, vlmax);\n                vse32_v_f32m1(row + k, vrow, vlmax);\n            }\n            for (; k < n; k++) {\n                row[k] /= norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    size_t vlmax = vsetvl_e32m8(n);\n    for (size_t i = 0; i < m; i++) {\n        float* row = &mat[i * n];\n        \n        // Compute L2 norm\n        float sum_of_squares = 0.0f;\n        size_t j = 0;\n        for (; j + vlmax <= n; j += vlmax) {\n            vfloat32m8_t vec = vlseg8ef32_v_f32m8(&row[j], vlmax);\n            vfloat32m8_t vec_sq = vmul_vv_f32m8(vec, vec, vlmax);\n            vfloat32m1_t reduced = vmv_s_x_f32m1(0.0f);\n            reduced = vredsum_vs_f32m8_f32m1(reduced, vec_sq, reduced, vlmax);\n            sum_of_squares += vfget_v_f32m1_f32(reduced);\n        }\n        for (; j < n; j++) {\n            sum_of_squares += row[j] * row[j];\n        }\n        float norm = sqrtf(sum_of_squares);\n        \n        if (norm != 0.0f) {\n            // Normalize the row\n            j = 0;\n            for (; j + vlmax <= n; j += vlmax) {\n                vfloat32m8_t vec = vlseg8ef32_v_f32m8(&row[j], vlmax);\n                vfloat32m8_t normalized = vmul_vf_f32m8(vec, 1.0f / norm, vlmax);\n                vsseg8ef32_v_f32m8(&row[j], normalized, vlmax);\n            }\n            for (; j < n; j++) {\n                row[j] /= norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    size_t vlmax = vsetvl_e32m1(n);\n    for (size_t i = 0; i < m; i++) {\n        float* row = &mat[i * n];\n        size_t vl = vlmax;\n\n        // Compute L2 norm\n        vfloat32m1_t vrow = vmv_v_x_f32m1(0.0f, vl);\n        size_t j = 0;\n        for (; j + vl <= n; j += vl) {\n            vfloat32m1_t vtmp = vle32_v_f32m1(&row[j], vl);\n            vrow = vfadd_vv_f32m1(vrow, vfmul_vv_f32m1(vtmp, vtmp, vl), vl);\n        }\n        float sum_sq = 0.0f;\n        for (size_t k = 0; k < vl; k++) {\n            sum_sq += vfmv_f_s_f32m1_f32(vrow);\n        }\n        for (; j < n; j++) {\n            sum_sq += row[j] * row[j];\n        }\n        float norm = sqrtf(sum_sq);\n\n        // Normalize the row\n        if (norm != 0.0f) {\n            vfloat32m1_t vnorm = vmv_v_x_f32m1(norm, vl);\n            j = 0;\n            for (; j + vl <= n; j += vl) {\n                vfloat32m1_t vtmp = vle32_v_f32m1(&row[j], vl);\n                vtmp = vfdiv_vv_f32m1(vtmp, vnorm, vl);\n                vse32_v_f32m1(&row[j], vtmp, vl);\n            }\n            for (; j < n; j++) {\n                row[j] /= norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    size_t vlmax = vsetvl_e64m8(1);\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t k = 0; k < p; ++k) {\n            vfloat64m8_t acc_v = vmv_v_f_f64m8(0.0, vlmax);\n            for (size_t j = 0; j < n; j += vlmax) {\n                size_t vl = vsetvl_e64m8(vlmax);\n                vfloat64m8_t mat1_v = vle64_v_f64m8(&mat1[i * n + j], vl);\n                vfloat64m8_t mat2_v = vle64_v_f64m8(&mat2[j * p + k], vl);\n                acc_v = vfadd_vv_f64m8(acc_v, vfmul_vv_f64m8(mat1_v, mat2_v, vl), vl);\n            }\n            double sum = 0.0;\n            for (size_t l = 0; l < vlmax; ++l) {\n                sum += vfmv_f_s_f64m8_f64(acc_v, l);\n            }\n            dst[i * p + k] = nearbyint(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    size_t vlmax = vsetvl_e64m8(1);\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t k = 0; k < p; ++k) {\n            vfloat64m8_t vsum = vmv_v_x_f64m8(0.0, vlmax);\n            for (size_t j = 0; j < n; ++j) {\n                size_t vl = vsetvl_e64m8(n - j);\n                vfloat64m8_t va = vle64_v_f64m8(mat1 + i * n + j, vl);\n                vfloat64m8_t vb = vle64_v_f64m8(mat2 + j * p + k, vl);\n                vsum = vfadd_vv_f64m8(vsum, vmul_vv_f64m8(va, vb, vl), vl);\n            }\n            size_t vl = vsetvl_e64m8(1);\n            double sum = vmv_x_s_f64m8_f64(vredsum_vs_f64m8_f64m8(vsum, vmv_v_x_f64m8(0.0, vl), vl));\n            dst[i * p + k] = nearbyint(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    size_t vlmax = vsetvl_e64m8(1);\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            vfloat64m8_t acc_v = vmv_v_x_f64m8(0.0, vlmax);\n            for (size_t k = 0; k < n; ++k) {\n                double a = mat1[i * n + k];\n                vfloat64m8_t b_v = vlseg1ff_float64_v_f64m8(&mat2[k * p + j], vlmax);\n                vfloat64m8_t prod_v = vmul_vf_f64m8(b_v, a, vlmax);\n                acc_v = vadd_vv_f64m8(acc_v, prod_v, vlmax);\n            }\n            double sum = 0.0;\n            for (size_t l = 0; l < vlmax; ++l) {\n                sum += vget_float64m8_f64(acc_v, l);\n            }\n            dst[i * p + j] = nearbyint(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    size_t vlmax = vsetvl_e64m8(1);\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            vfloat64m8_t vsum = vmv_v_x_f64m8(0.0, vlmax);\n            for (size_t k = 0; k < n; ++k) {\n                double val1 = mat1[i * n + k];\n                size_t vl = vsetvl_e64m8(p - j);\n                vfloat64m8_t vm2 = vle64_v_f64m8(&mat2[k * p + j], vl);\n                vfloat64m8_t vprod = vmul_vf_f64m8(vm2, val1, vl);\n                vsum = vadd_vv_f64m8(vsum, vprod, vl);\n            }\n            size_t vl = vsetvl_e64m8(1);\n            double res = vrndu_v_f64m8_f64m8(vsum, vl)[0];\n            dst[i * p + j] = res;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    size_t vlmax = vsetvl_e64m8(1);\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t k = 0; k < p; ++k) {\n            vfloat64m8_t vsum = vmv_v_x_f64m8(0.0, vlmax);\n            for (size_t j = 0; j < n; j += vlmax) {\n                size_t vl = vsetvl_e64m8(vlmax);\n                vfloat64m8_t vmat1 = vle64_v_f64m8(&mat1[i * n + j], vl);\n                vfloat64m8_t vmat2 = vle64_v_f64m8(&mat2[j * p + k], vl);\n                vsum = vfadd_vv_f64m8(vsum, vmul_vv_f64m8(vmat1, vmat2, vl), vl);\n            }\n            double sum = 0.0;\n            for (size_t l = 0; l < vlmax; ++l) {\n                sum += vmv_x_s_f64m8_f64(vsum, l);\n            }\n            dst[i * p + k] = nearbyint(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t vlmax = vsetvl_e32m1(cols);\n    for (size_t i = 0; i < cols; i++) {\n        size_t vl = vlmax;\n        vfloat32m1_t vresult = vmv_v_x_f32m1(0.0f, vl);\n        for (size_t j = 0; j < rows; j++) {\n            float val = src[j * cols + i];\n            float rounded_val = nearbyintf(val * 4.0f) * 0.25f;\n            vfloat32m1_t vt = vmv_x_s_f32_v_f32m1(rounded_val, vl);\n            vresult = vredmax_vs_f32m1_f32m1(vresult, vt, vresult, vl);\n        }\n        vfloat32m1_t vrnd = vrndnf_v_f32m1(vresult, vl);\n        vse32_v_f32m1(&dst[i * rows], vrnd, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_25_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t vlmax = vsetvl_e32m1(cols);\n    for (size_t i = 0; i < cols; i += vlmax) {\n        size_t vl = vsetvl_e32m1(cols - i);\n        vfloat32m1_t vresult = vmv_v_x_f32m1(0.0f, vl);\n        for (size_t j = 0; j < rows; j++) {\n            vfloat32m1_t vtemp = vle32_v_f32m1(&src[j * cols + i], vl);\n            vtemp = vrndn_v_f32m1(vtemp, vl);\n            vtemp = vmul_vf_f32m1(vtemp, 4.0f, vl);\n            vresult = vfadd_vv_f32m1(vresult, vtemp, vl);\n        }\n        vse32_v_f32m1(&dst[i * rows], vresult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_25_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t vlmax = vlenb() / sizeof(float);\n    for (size_t i = 0; i < cols; i += vlmax) {\n        size_t vl = (cols - i) < vlmax ? (cols - i) : vlmax;\n        vfloat32m1_t vmask = vmv_v_x_f32m1(0.0f, vl);\n        for (size_t j = 0; j < rows; j++) {\n            vfloat32m1_t vrow = vle32_v_f32m1(&src[j * cols + i], vl);\n            vfloat32m1_t vrounded = vrndn_v_f32m1(vrow, vl);\n            vfloat32m1_t vscaled = vfadd_vf_f32m1(vrndn_v_f32m1(vfmul_vf_f32m1(vrounded, 4.0f, vl), vl), 0.0f, vl);\n            vse32_v_f32m1(&dst[i * rows + j], vscaled, vl);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t vlmax = vsetvl_e32m1(1);\n    for (size_t i = 0; i < cols; i += vlmax) {\n        size_t vl = vsetvl_e32m1(cols - i > vlmax ? vlmax : cols - i);\n        vfloat32m1_t vresult = vmv_v_x_f32m1(0.0f, vl);\n        for (size_t j = 0; j < rows; j++) {\n            vfloat32m1_t vtemp = vle32_v_f32m1(&src[j * cols + i], vl);\n            vtemp = vrndnq_v_f32m1(vtemp, vl); // Round to nearest quarter\n            vresult = vfslideup_vf_f32m1(vresult, vtemp, j, vl);\n        }\n        vse32_v_f32m1(&dst[i * rows], vresult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_25_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t vlmax = vsetvl_e32m1(cols);\n    for (size_t i = 0; i < cols; i++) {\n        size_t vl = vlmax;\n        vfloat32m1_t vresult = vmv_v_x_f32m1(0.0f, vl);\n        for (size_t j = 0; j < rows; j++) {\n            float val = src[j * cols + i];\n            float rounded_val = roundf(val * 4.0f) / 4.0f;\n            vfloat32m1_t vt = vmv_v_f_f32m1(rounded_val, vl);\n            vresult = vfmadd_vf_f32m1(1.0f, vt, vresult, vl);\n        }\n        vfloat32m1_t vr = vfncvt_x_f_w_f32m1(vresult, vl);\n        vse32_v_f32m1(&dst[i * rows], vr, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_26_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vlmax = vsetvl_e32m1(0);\n\n    for (size_t i = 0; i < total_elements; i += vlmax) {\n        size_t vl = vsetvl_e32m1(total_elements - i);\n        vfloat32m1_t vt1 = vle32_v_f32m1(tensor1 + i, vl);\n        vfloat32m1_t vt2 = vle32_v_f32m1(tensor2 + i, vl);\n        vfloat32m1_t vres = vsub_vv_f32m1(vt1, vt2, vl);\n        vfloat32m1_t vrounded = vrndtz_v_f32m1(vres, vl);\n        vse32_v_f32m1(dst + i, vrounded, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_26_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vlmax = vsetvl_e32m1(total_size);\n\n    for (size_t i = 0; i < total_size; i += vlmax) {\n        size_t vl = vsetvl_e32m1(total_size - i);\n        vfloat32m1_t vt1 = vlload_e32m1((const float*)&tensor1[i], vl);\n        vfloat32m1_t vt2 = vlload_e32m1((const float*)&tensor2[i], vl);\n        vfloat32m1_t vres = vfsub_wx_e32m1(vt1, vt2, vl);\n        vfloat32m1_t vrounded = vrndtz_wx_e32m1(vres, vl);\n        vlstore_e32m1((float*)&dst[i], vrounded, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_26_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vlmax = vsetvl_e32m1(0);\n\n    for (size_t i = 0; i < total_size; i += vlmax) {\n        size_t vl = vsetvl_e32m1(total_size - i);\n        vfloat32m1_t vt1 = vlload_float32(tensor1 + i, vl);\n        vfloat32m1_t vt2 = vlload_float32(tensor2 + i, vl);\n        vfloat32m1_t vres = vfsub_vv_f32m1(vt1, vt2, vl);\n        vfloat32m1_t vrounded = vrndtz_vf32m1(vres, vl);\n        vlstore_float32(dst + i, vrounded, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_26_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vlmax = vsetvl_e32m1(0);\n    for (size_t i = 0; i < total_size; i += vlmax) {\n        size_t vl = vsetvl_e32m1(total_size - i);\n        vfloat32m1_t vt1 = vle32_v_f32m1(tensor1 + i, vl);\n        vfloat32m1_t vt2 = vle32_v_f32m1(tensor2 + i, vl);\n        vfloat32m1_t vres = vfsub_vv_f32m1(vt1, vt2, vl);\n        vfloat32m1_t vrounded = vrndtz_v_f32m1(vres, vl);\n        vse32_v_f32m1(dst + i, vrounded, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_26_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vlmax = vsetvl_e32m1(0);\n\n    for (size_t i = 0; i < total_size; i += vlmax) {\n        size_t vl = vsetvl_e32m1(total_size - i);\n        vfloat32m1_t vt1 = vle32_v_f32m1(tensor1 + i, vl);\n        vfloat32m1_t vt2 = vle32_v_f32m1(tensor2 + i, vl);\n        vfloat32m1_t vres = vfsub_vv_f32m1(vt1, vt2, vl);\n        vfloat32m1_t vrounded = vrndz_x_f32m1(vres, vl);\n        vse32_v_f32m1(dst + i, vrounded, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_27_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vlmax = vsetvl_e64m8(total_elements);\n    vfloat64m8_t vt;\n    for (size_t i = 0; i < total_elements; i += vlmax) {\n        size_t vl = vsetvl_e64m8(total_elements - i);\n        vfloat64m8_t vm1 = vle64_v_f64m8((const double*)&mat1[i], vl);\n        vfloat64m8_t vm2 = vle64_v_f64m8((const double*)&mat2[i], vl);\n        vt = vmul_vv_f64m8(vm1, vm2, vl);\n        vse64_v_f64m8((double*)&dst[i], vt, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_27_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vlmax = vsetvl_e64m8(total_elements);\n    vfloat64m8_t vt;\n    for (size_t i = 0; i < total_elements; i += vlmax) {\n        size_t vl = vsetvl_e64m8(total_elements - i);\n        vfloat64m8_t vm1 = vle64_v_f64m8(&mat1[i], vl);\n        vfloat64m8_t vm2 = vle64_v_f64m8(&mat2[i], vl);\n        vt = vmul_vv_f64m8(vm1, vm2, vl);\n        vse64_v_f64m8(&dst[i], vt, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_27_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vlmax = vsetvl_e64m8(total_elements);\n    \n    for(size_t i = 0; i < total_elements; i += vlmax) {\n        size_t vl = vsetvl_e64m8(vlmax);\n        vfloat64m8_t vm1 = vle64_v_f64m8(&mat1[i], vl);\n        vfloat64m8_t vm2 = vle64_v_f64m8(&mat2[i], vl);\n        vfloat64m8_t vres = vmul_vv_f64m8(vm1, vm2, vl);\n        vse64_v_f64m8(&dst[i], vres, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_27_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vlmax = vsetvl_e64m8(total_elements);\n\n    for(size_t i = 0; i < total_elements; i += vlmax) {\n        size_t vl = vsetvl_e64m8(vlmax);\n        vfloat64m8_t vm1 = vle64_v_f64m8(mat1 + i, vl);\n        vfloat64m8_t vm2 = vle64_v_f64m8(mat2 + i, vl);\n        vfloat64m8_t vres = vmul_vv_f64m8(vm1, vm2, vl);\n        vse64_v_f64m8(dst + i, vres, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_27_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vlmax = vsetvl_e64m1(total_elements);\n\n    for(size_t i = 0; i < total_elements; i += vlmax) {\n        size_t vl = vsetvl_e64m1(total_elements - i);\n        vfloat64m1_t vm1 = vle64_v_f64m1(&mat1[i], vl);\n        vfloat64m1_t vm2 = vle64_v_f64m1(&mat2[i], vl);\n        vfloat64m1_t vres = vmul_vv_f64m1(vm1, vm2, vl);\n        vse64_v_f64m1(&dst[i], vres, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_28_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    size_t vlmax = vsetvl_e32m1(n);\n    vfloat32m1_t vres = vmv_v_f_f32m1(0.0f, vlmax);\n    vfloat32m1_t vvec;\n\n    for (size_t j = 0; j < n; j += vlmax) {\n        size_t vl = vsetvl_e32m1(n - j);\n        vvec = vle32_v_f32m1(&vec[j], vl);\n        for (size_t i = 0; i < m; i++) {\n            vfloat32m1_t vmat = vle32_v_f32m1(&mat[i * n + j], vl);\n            vres = vfmacc_vf_f32m1(vres, vmat, vvec, vl);\n            if ((j + vl) >= n) {\n                float temp_res = vmv_s_f_f32m1(vres, vl);\n                dst[i] = temp_res;\n                vres = vmv_v_f_f32m1(0.0f, vlmax);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_28_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    size_t vlmax = vlenb() / sizeof(float);\n    for (size_t i = 0; i < m; i++) {\n        float* row = (float*)mat + i * n;\n        vfloat32m1_t vres = vmv_v_f_f32m1(0.0f, vlmax);\n        for (size_t j = 0; j < n; j += vlmax) {\n            size_t vl = vsetvl_e32m1(vlmax);\n            vfloat32m1_t vrow = vle32_v_f32m1(row + j, vl);\n            vfloat32m1_t vvec = vle32_v_f32m1(vec + j, vl);\n            vres = vfma_vv_f32m1(vres, vrow, vvec, vl);\n        }\n        float sum = 0.0f;\n        size_t k = 0;\n        while (k < vlmax) {\n            size_t vl = vsetvl_e32m1(vlmax - k);\n            vfloat32m1_t vt = vmv_v_f_f32m1(0.0f, vl);\n            vt = vredsum_vs_f32m1_f32m1(vt, vres, vt, vl);\n            float temp = vmv_s_f_f32m1_f32(vt);\n            sum += temp;\n            k += vl;\n        }\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    size_t vlmax = vlenb() / sizeof(float);\n    for (size_t i = 0; i < m; i++) {\n        float* row = (float*)mat + i * n;\n        vfloat32m1_t vres = vmv_v_f_f32m1(0.0f, vlmax);\n        for (size_t j = 0; j < n; j += vlmax) {\n            size_t vl = vsetvl_e32m1(vlmax);\n            vfloat32m1_t vrow = vle32_v_f32m1(row + j, vl);\n            vfloat32m1_t vvec = vle32_v_f32m1(vec + j, vl);\n            vres = vfma_vv_f32m1(vres, vrow, vvec, vl);\n        }\n        float sum = 0.0f;\n        size_t vl = vsetvl_e32m1(vlmax);\n        vfloat32m1_t vred =vredu_sum_vs_f32m1_f32m1(vres, vmv_v_f_f32m1(0.0f, vl), vl);\n        sum = vfmv_f_s_f32m1_f32(vred);\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    size_t vlmax = vsetvl_e32m8(n);\n    vfloat32m8_t vres = vmv_v_x_f32m8(0.0f, vlmax);\n    for (size_t j = 0; j < n; j += vlmax) {\n        size_t vl = vsetvl_e32m8(n - j);\n        vfloat32m8_t vvec = vle32_v_f32m8(&vec[j], vl);\n        for (size_t i = 0; i < m; i++) {\n            vfloat32m8_t vmat = vle32_v_f32m8(&mat[i * n + j], vl);\n            vres = vfma_vf_f32m8(vres, vvec, vmat, vl);\n            if ((j + vl) >= n) {\n                float temp_res = vmv_x_s_f32m8_f32(vredsum_vs_f32m8_f32m8(vres, vmv_v_x_f32m8(0.0f, vl), vl));\n                dst[i] = temp_res;\n                vres = vmv_v_x_f32m8(0.0f, vl);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_28_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    size_t vlmax = vsetvl_e32m1(n);\n    vfloat32m1_t vres = vmv_v_x_f32m1(0.0f, vlmax);\n    vfloat32m1_t vvec;\n\n    for (size_t j = 0; j < n; j += vlmax) {\n        size_t vl = vsetvl_e32m1(n - j);\n        vvec = vle32_v_f32m1(&vec[j], vl);\n\n        for (size_t i = 0; i < m; i++) {\n            vfloat32m1_t vmat = vle32_v_f32m1(&mat[i * n + j], vl);\n            vres = vfma_vf_f32m1(vres, vvec, vmat, vl);\n        }\n    }\n\n    for (size_t i = 0; i < m; i++) {\n        size_t vl = vsetvl_e32m1(n);\n        vfloat32m1_t vd = vmv_v_x_f32m1(0.0f, vl);\n        for (size_t j = 0; j < n; j += vl) {\n            vfloat32m1_t vmat = vle32_v_f32m1(&mat[i * n + j], vl);\n            vfloat32m1_t vvec = vle32_v_f32m1(&vec[j], vl);\n            vd = vfma_vv_f32m1(vd, vvec, vmat, vl);\n        }\n        dst[i] = vmv_s_x_f32m1_f32(vredsum_vs_f32m1_f32m1(vd, vmv_v_x_f32m1(0.0f, vl), vl));\n    }\n}\n```"}
{"task_id": "SimdBench_29_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vlmax = vsetvl_e64m1(1);\n    vfloat64m1_t vsum = vmv_v_x_f64m1(0.0, vlmax);\n    size_t i = 0;\n\n    for (; i + vlmax <= total_elements; i += vlmax) {\n        vfloat64m1_t vtemp = vle64_v_f64m1(&mat[i], vlmax);\n        vsum = vadd_vv_f64m1(vsum, vtemp, vlmax);\n    }\n\n    double leftover_sum = 0.0;\n    for (; i < total_elements; i++) {\n        leftover_sum += mat[i];\n    }\n\n    double result = 0.0;\n    size_t j;\n    vfloat64m1_t vzero = vmv_v_x_f64m1(0.0, vlmax);\n    for (j = 0; j < vlmax; j++) {\n        result += vget_float64m1_vf64m1(vsum, j, vlmax);\n    }\n\n    result += leftover_sum;\n    return result / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    double sum = 0.0;\n    size_t vlmax = vsetvl_e64m1(n);\n\n    for (size_t i = 0; i < m; ++i) {\n        const double* row = mat + i * n;\n        vfloat64m1_t vrow = vmv_v_x_f64m1(0.0, vlmax);\n        size_t j = 0;\n\n        for (; j + vlmax <= n; j += vlmax) {\n            vfloat64m1_t vtemp = vle64_v_f64m1(row + j, vlmax);\n            vrow = vadd_vv_f64m1(vrow, vtemp, vlmax);\n        }\n\n        // Horizontal sum of the vector\n        double partial_sum = 0.0;\n        for (size_t k = 0; k < vlmax; ++k) {\n            partial_sum += vget_f64m1_v_f64(vrow, k, vlmax);\n        }\n        sum += partial_sum;\n\n        // Handle leftover elements\n        for (; j < n; ++j) {\n            sum += row[j];\n        }\n    }\n\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vlmax = vsetvl_e64m1(1);\n    vfloat64m1_t vsum = vmv_v_x_f64m1(0.0, vlmax);\n    size_t i = 0;\n\n    for (; i + vlmax <= total_elements; i += vlmax) {\n        vfloat64m1_t vload = vle64_v_f64m1(&mat[i], vlmax);\n        vsum = vadd_vv_f64m1(vsum, vload, vlmax);\n    }\n\n    double leftover_sum = 0.0;\n    for (; i < total_elements; i++) {\n        leftover_sum += mat[i];\n    }\n\n    double result = 0.0;\n    size_t j;\n    for (j = 0; j < vlmax; j++) {\n        result += vget_float64m1_f64(vsum, j);\n    }\n\n    result += leftover_sum;\n    return result / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    double sum = 0.0;\n    size_t vlmax = vsetvl_e64m8(1);\n\n    for (size_t i = 0; i < total_elements; i += vlmax) {\n        size_t vl = vsetvl_e64m8(total_elements - i);\n        vfloat64m8_t vec = vle64_v_f64m8(&mat[i], vl);\n        vfloat64m8_t acc = vmv_v_x_f64m8(0.0, vl);\n        acc = vadd_vv_f64m8(acc, vec, vl);\n        float64_t temp_sum = vfsum_v_f64m8(acc, vl);\n        sum += temp_sum;\n    }\n\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    double sum = 0.0;\n    size_t vlmax = vsetvl_e64m8(1);\n    vfloat64m8_t vsum = vmv_v_x_f64m8(0.0, vlmax);\n\n    for (size_t i = 0; i < total_elements; i += vlmax) {\n        size_t vl = vsetvl_e64m8(total_elements - i);\n        vfloat64m8_t vm = vle64_v_f64m8(mat + i, vl);\n        vsum = vredsum_vs_f64m8_f64m8(vsum, vm, vsum, vl);\n    }\n\n    double temp_sum = 0.0;\n    size_t vl = vsetvl_e64m8(1);\n    temp_sum = vmv_x_s_f64m8_f64(vsum, vl);\n    sum += temp_sum;\n\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_30_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    size_t vl = vsetvl_e32m1(cols);\n    bool result = true;\n    for (size_t i = 0; i < rows && result; ++i) {\n        const int* row = matrix + i * cols;\n        vint32m1_t vrow = vmv_v_x_i32m1(0, vl);\n        vint32m1_t vrow_shifted = vmv_v_x_i32m1(0, vl);\n        vrow = vle32_v_i32m1(row, vl);\n        vrow_shifted = vsrl_vx_i32m1(vrow, 1, vl);\n\n        if (directions[i]) { // Ascending\n            vbool32_t cmp_result = vmge_vv_b32m1(vrow_shifted, vrow, vl);\n            size_t mask = vmfirst_m_b32(cmp_result);\n            if (mask != 0) {\n                result = false;\n            }\n        } else { // Descending\n            vbool32_t cmp_result = vmle_vv_b32m1(vrow_shifted, vrow, vl);\n            size_t mask = vmfirst_m_b32(cmp_result);\n            if (mask != 0) {\n                result = false;\n            }\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_30_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    size_t vl = vsetvl_e32m1(cols);\n    vbool32m1_t vmask = vmv_v_x_b32m1(true, vl);\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        vint32m1_t vrow = vlde32_v_i32m1(row, vl);\n        vint32m1_t vrow_shifted = vlsseg1ei32_v_i32m1(vrow, 1, vl);\n        if (directions[i]) {\n            // Check ascending order\n            vbool32m1_t vcmp = vmge_vv_b32m1(vrow_shifted, vrow, vmask, vl);\n            if (!vmandnot_m_b32m1(vmsbf_m_b32m1(vcmp, vl), vmask, vl)) {\n                return false;\n            }\n        } else {\n            // Check descending order\n            vbool32m1_t vcmp = vmle_vv_b32m1(vrow_shifted, vrow, vmask, vl);\n            if (!vmandnot_m_b32m1(vmsbf_m_b32m1(vcmp, vl), vmask, vl)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    size_t vl = vsetvl_e32m1(cols);\n    bool result = true;\n    for (size_t i = 0; i < rows && result; ++i) {\n        vint32m1_t vrow = vlload_e32m1(matrix + i * cols, vl);\n        vbool32m1_t mask = vmseq_vv_i32m1_b32m1(vrow, vrow, vl); // Initialize mask with true\n        if (directions[i]) {\n            // Check ascending order\n            vbool32m1_t cmp = vmle_vv_i32m1_b32m1(vrow, vslide1down_vx_i32m1(vrow, 1, vl), vl);\n            mask = vmandnot_vm_b32m1(mask, cmp, vl);\n        } else {\n            // Check descending order\n            vbool32m1_t cmp = vmge_vv_i32m1_b32m1(vrow, vslide1down_vx_i32m1(vrow, 1, vl), vl);\n            mask = vmandnot_vm_b32m1(mask, cmp, vl);\n        }\n        result = result && __builtin_bit_and_reduce((unsigned*)vmv_x_s_b32m1_i32(mask, vl));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_30_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    size_t vl = vsetvl_e32m1(cols);\n    bool result = true;\n\n    for (size_t i = 0; i < rows && result; ++i) {\n        const int *row = matrix + i * cols;\n        vint32m1_t v_row = vlload(row, _Float32, vl);\n        vint32m1_t v_shifted = vslide1down_vi32m1(v_row, vl);\n        \n        if (directions[i]) { // Ascending\n            vbool32m1_t v_cmp = vmle_vv_i32m1_b32(v_shifted, v_row, vl);\n            size_t not_less_equal = vpopc_m_b32(vmv_x_s_b32b32(true), vnot_b32(v_cmp), vl);\n            if (not_less_equal > 0) {\n                result = false;\n            }\n        } else { // Descending\n            vbool32m1_t v_cmp = vmge_vv_i32m1_b32(v_shifted, v_row, vl);\n            size_t not_greater_equal = vpopc_m_b32(vmv_x_s_b32b32(true), vnot_b32(v_cmp), vl);\n            if (not_greater_equal > 0) {\n                result = false;\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_30_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    size_t vl = vsetvl_e32m1(cols);\n    bool result = true;\n    for (size_t i = 0; i < rows && result; ++i) {\n        vint32m1_t vrow = lvsl_e32_v_i32m1(matrix + i * cols, vl);\n        vbool32_t mask = vmseq_m_b32_m(vfalse_m(), vrow, vslide1down_vx_i32m1(vrow, 1, vl), vl);\n        if (directions[i]) {\n            // Ascending order\n            vbool32_t ascending_check = vmle_vv_b32m1(vrow, vslide1down_vx_i32m1(vrow, 1, vl), vl);\n            result = result && __builtin_vmv_x_s_b_i32m1_b32(vmfirst_m_b32_m(mask, ascending_check, vl));\n        } else {\n            // Descending order\n            vbool32_t descending_check = vmge_vv_b32m1(vrow, vslide1down_vx_i32m1(vrow, 1, vl), vl);\n            result = result && __builtin_vmv_x_s_b_i32m1_b32(vmfirst_m_b32_m(mask, descending_check, vl));\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_31_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t vlmax = vsetvl_e16m1(length);\n    for (size_t vl = vlmax; vl != 0; vl = vsetvl_e16m1(vl)) {\n        vint16m1_t v_src = vle16_v_i16m1(src, vl);\n        vint16m1_t v_res;\n        \n        if (base == 1) {\n            v_res = v_src;\n        } else {\n            vint16m1_t v_base = vmv_v_x_i16m1(base, vl);\n            vint16m1_t v_div = vddiv_vx_i16m1(v_src, base, vl);\n            v_res = vmul_vx_i16m1(v_div, base, vl);\n        }\n        vse16_v_i16m1(dst, v_res, vl);\n        src += vl;\n        dst += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_31_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t vlmax = vsetvl_e16m1(length);\n    vint16m1_t vbase = vmv_v_x_i16m1(base, vlmax);\n    for (size_t i = 0; i < length; i += vlmax) {\n        size_t vl = vsetvl_e16m1(vlmax);\n        vint16m1_t vsrc = vle16_v_i16m1(src + i, vl);\n        vint16m1_t vdiv = vfdivu_vv_i16m1(vsrc, vbase, vl);\n        vint16m1_t vfloordiv = vfclipu_wx_i16m1(vdiv, 0, vl);\n        vint16m1_t vmul = vmul_vv_i16m1(vfloordiv, vbase, vl);\n        vse16_v_i16m1(vmul, dst + i, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_31_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t vlmax = vsetvl_e16m1(length);\n    vint16m1_t vbase = vmv_v_x_i16m1(base, vlmax);\n    size_t i = 0;\n\n    for (; i + vlmax <= length; i += vlmax) {\n        vint16m1_t vsrc = vle16_v_i16m1(src + i, vlmax);\n        vint16m1_t vdiv = vddivu_vx_i16m1(vsrc, base, vlmax);\n        vint16m1_t vmul = vmul_vx_i16m1(vdiv, base, vlmax);\n        vse16_v_i16m1(dst + i, vmul, vlmax);\n    }\n\n    if (i < length) {\n        size_t vl = vsetvl_e16m1(length - i);\n        vint16m1_t vsrc = vle16_v_i16m1(src + i, vl);\n        vint16m1_t vdiv = vddivu_vx_i16m1(vsrc, base, vl);\n        vint16m1_t vmul = vmul_vx_i16m1(vdiv, base, vl);\n        vse16_v_i16m1(dst + i, vmul, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_31_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t vlmax = vsetvl_e16m1(length);\n    vint16m1_t vbase = vmv_v_x_i16m1(base, vlmax);\n    size_t i = 0;\n\n    for (; i + vlmax <= length; i += vlmax) {\n        vint16m1_t vsrc = vle16_v_i16m1(src + i, vlmax);\n        vint16m1_t vdiv = vdiv_vx_i16m1(vsrc, base, vlmax);\n        vint16m1_t vmul = vmul_vx_i16m1(vdiv, base, vlmax);\n        vse16_v_i16m1(dst + i, vmul, vlmax);\n    }\n\n    if (i < length) {\n        size_t vl = vsetvl_e16m1(length - i);\n        vint16m1_t vsrc = vle16_v_i16m1(src + i, vl);\n        vint16m1_t vdiv = vdiv_vx_i16m1(vsrc, base, vl);\n        vint16m1_t vmul = vmul_vx_i16m1(vdiv, base, vl);\n        vse16_v_i16m1(dst + i, vmul, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_31_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t vlmax = vsetvl_e16m1(length);\n    for (size_t vl = vlmax; vl != 0; vl = vsetvl_e16m1(vl)) {\n        vint16m1_t v_src = vle16_v_i16m1(src, vl);\n        vint16m1_t v_base = vmv_v_x_i16m1(base, vl);\n        vint16m1_t v_zero = vmv_v_x_i16m1(0, vl);\n\n        vint16m1_t v_div = vfdiv_vv_f16m1(v_src, v_base, vl);\n        vint16m1_t v_floor = vftrunc_vf_i16m1(v_div, vl);\n        vint16m1_t v_result = vmul_vv_i16m1(v_floor, v_base, vl);\n\n        vsse16_v_i16m1(dst, 0, v_result, vl);\n        src += vl;\n        dst += vl;\n        if (vl < vlmax) break;\n    }\n}\n```"}
{"task_id": "SimdBench_32_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    bool result = false;\n    size_t vlmax = vsetvl_e64m1(cols);\n    vbool64_t vmask = vmv_v_x_b64(true, vlmax);\n    vfloat64m1_t vcmp_result = vmv_v_x_f64(0.0, vlmax);\n\n    for (size_t i = 0; i < rows; ++i) {\n        vfloat64m1_t vrow = vle64_v_f64m1(matrix + i * cols, vlmax);\n        vfloat64m1_t vvec = vle64_v_f64m1(vector, vlmax);\n        vbool64_t veq = vmfeq_vv_b64(vrow, vvec, vmask, vlmax);\n        vint64m1_t vred = vmseq_m_b64_i64m1(veq, -1, vlmax);\n        int64_t all_match = vmv_x_s_i64m1_i64(vred);\n        if (all_match == (int64_t)cols) {\n            result = true;\n            break;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_32_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    size_t vlmax = vsetvl_e64m8(cols);\n    vfloat64m8_t vcmp = vmv_v_x_f64m8(0.0, vlmax);\n    bool result = false;\n\n    for (size_t i = 0; i < rows; i++) {\n        bool match = true;\n        vfloat64m8_t vvec = vlseg1ff_v_f64m8(vector, vlmax);\n        for (size_t j = 0; j < cols; j += vlmax) {\n            vfloat64m8_t vrow = vlseg1ff_v_f64m8(&matrix[i * cols + j], vlmax);\n            vfloat64m8_t veq = vmfeq_vv_f64m8_b1(vrow, vvec, vlmax);\n            if (vmseq_m_b1bf16(true, veq, vlmax) == false) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            result = true;\n            break;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_32_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    size_t vlmax = vsetvl_e64m8(1);\n    bool result = false;\n\n    for (size_t i = 0; i < rows; i++) {\n        size_t vl = vsetvl_e64m8(cols);\n        vfloat64m8_t vec_v = vlrsseg8_double(vl, vector);\n\n        const double* mat_row = matrix + i * cols;\n        vfloat64m8_t mat_v = vlrsseg8_double(vl, mat_row);\n\n        vfloat64m8_t cmp_v = vmfeq_vv_f64m8(mat_v, vec_v, vl);\n        vuint64m8_t mask_v = vmfne_vv_i64m8(cmp_v, cmp_v, vl);\n\n        uint64_t mask = vmv_x_s_u64m8_u64(mask_v, vl);\n        if (mask == 0) {\n            result = true;\n            break;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_32_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdbool.h>\n#include <stddef.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    size_t vlmax = vsetvl_e64m1(cols);\n    bool result = false;\n    vfloat64m1_t vec_v = vmv_v_x_f64m1(0.0, vlmax);\n    vec_v = vle64_v_f64m1(vector, vlmax);\n\n    for (size_t i = 0; i < rows; ++i) {\n        vfloat64m1_t row_v = vle64_v_f64m1(matrix + i * cols, vlmax);\n        vbool64m1_t cmp = vmfeq_vv_f64m1_b64m1(row_v, vec_v, vlmax);\n        int check = vmall_v_i32m1_b64(cmp, vlmax);\n        if (check) {\n            result = true;\n            break;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_32_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    size_t vl = vsetvl_e64m8(cols);\n    vbool8_t result = vmv_v_x_b8(0, vl);\n    for (size_t i = 0; i < rows; i++) {\n        vfloat64m8_t vec_load = vle64_v_f64m8(vector, vl);\n        vfloat64m8_t row_load = vle64_v_f64m8(&matrix[i * cols], vl);\n        vbool8_t eq = vmfeq_vv_f64m8_b8(row_load, vec_load, vl);\n        result = vor_vv_b8(result, eq, vl);\n        if (vmall_v_x_b8(result, vl)) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_33_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    size_t vlmax = vsetvl_e8m1(total_elements);\n    vuint8m1_t vcount = vmv_v_x_u8m1(0, vlmax);\n\n    for(size_t i = 0; i < total_elements; i += vlmax) {\n        size_t vl = vsetvl_e8m1(total_elements - i);\n        vuint8m1_t va = vle8_v_u8m1(A + i, vl);\n        vuint8m1_t vb = vle8_v_u8m1(B + i, vl);\n        vbool8_t veq = vmseq_vv_b8m1(va, vb, vl);\n        vcount = vaddmv_vx_u8_m(vcount, veq, 1, vl);\n    }\n\n    for(size_t i = 0; i < vlmax; ++i){\n        count += vget_v_u8m1(vcount, i);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_size = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    size_t i = 0;\n    size_t vlmax = vsetvl_e8m1(total_size);\n    for (; i <= total_size - vlmax; i += vlmax) {\n        vuint8m1_t va = vle8_v_u8m1(A + i, vlmax);\n        vuint8m1_t vb = vle8_v_u8m1(B + i, vlmax);\n        vuint8m1_t veq = vmseq_vv_u8m1_b1(va, vb, vlmax);\n        size_t chunk_count = vm popc_m_b1(veq, vlmax);\n        count += chunk_count;\n    }\n\n    // Handle remaining elements\n    if (i < total_size) {\n        size_t vl = vsetvl_e8m1(total_size - i);\n        vuint8m1_t va = vle8_v_u8m1(A + i, vl);\n        vuint8m1_t vb = vle8_v_u8m1(B + i, vl);\n        vuint8m1_t veq = vmseq_vv_u8m1_b1(va, vb, vl);\n        size_t chunk_count = vm_popc_m_b1(veq, vl);\n        count += chunk_count;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_size = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    size_t vl = vsetvl_e8m1(total_size);\n    vuint8m1_t vzero = vmv_v_x_u8m1(0, vl);\n\n    for (size_t i = 0; i < total_size; i += vl) {\n        size_t chunk_size = (total_size - i > vl) ? vl : total_size - i;\n        vuint8m1_t va = lvu8_v_u8m1(A + i, chunk_size);\n        vuint8m1_t vb = lvu8_v_u8m1(B + i, chunk_size);\n        vuint8m1_t veq = vmseq_vv_u8m1(va, vb, chunk_size);\n        vbool8_t vmask = vmf_nez_b8(veq, chunk_size);\n        count += __builtin_popcount(vmask);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    size_t vl = vsetvl_e8m1(total_elements);\n    vuint8m1_t vzero = vmv_v_x_u8m1(0, vl);\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        size_t subvl = vsetvl_e8m1(vl);\n        vuint8m1_t va = vle8_v_u8m1(A + i, subvl);\n        vuint8m1_t vb = vle8_v_u8m1(B + i, subvl);\n        vuint8m1_t veq = vmseq_vv_u8m1_b8(va, vb, subvl);\n        vzero = vor_vv_u8m1(vzero, veq, subvl);\n        vl = subvl;\n    }\n\n    // Count the number of non-zero elements in vzero\n    size_t temp_count = 0;\n    for (size_t i = 0; i < vl; i++) {\n        temp_count += vzero.v[i];\n    }\n    count += temp_count;\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    size_t vlmax = vsetvl_e8m1(total_elements);\n    vuint8m1_t vcount = vmv_v_x_u8m1(0, vlmax);\n\n    for (size_t i = 0; i < total_elements; i += vlmax) {\n        size_t vl = vsetvl_e8m1(total_elements - i);\n        vuint8m1_t va = vle8_v_u8m1(A + i, vl);\n        vuint8m1_t vb = vle8_v_u8m1(B + i, vl);\n        vbool8_t veq = vmseq_vv_u8_b8m1(va, vb, vl);\n        vcount = vaddmv_x_s_u8_b8_u8m1(vcount, veq, vl);\n    }\n\n    size_t temp_count = 0;\n    for (size_t i = 0; i < vlmax; i++) {\n        temp_count += vget_v_u8m1(vcount, i);\n    }\n    count += temp_count;\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_34_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t vlmax = vsetvl_e64m1(length);\n    vint64m1_t va = vmv_v_x_i64m1(a, vlmax);\n    for (size_t i = 0; i < length; i += vlmax) {\n        size_t vl = vsetvl_e64m1(vlmax > (length - i) ? (length - i) : vlmax);\n        vint64m1_t vx = vle64_v_i64m1(x + i, vl);\n        vint64m1_t vy = vle64_v_i64m1(y + i, vl);\n        vint64m1_t vmul = vmul_vx_i64m1(vx, a, vl);\n        vuint64m1_t vabs = vmseq_vv_i64m1(vy, vy, vl); // Absolute value workaround\n        vint64m1_t vsub = vsub_vv_i64m1(vmul, (vint64m1_t)vabs, vl);\n        vse64_v_i64m1(vsub, y + i, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_34_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t vlmax = vsetvl_e64m1(length);\n    vint64m1_t va = vmul_vx_i64m1(vle64_v_i64m1(x, vlmax), a, vlmax);\n    vint64m1_t vy = vabs_v_i64m1(vle64_v_i64m1(y, vlmax), vlmax);\n    vse64_v_i64m1(y, vsub_vv_i64m1(va, vy, vlmax), vlmax);\n}\n```"}
{"task_id": "SimdBench_34_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t vlmax = vsetvl_e64m1(length);\n    vint64m1_t va = vmv_v_x_i64m1(a, vlmax);\n    for (size_t i = 0; i < length; i += vlmax) {\n        size_t vl = vsetvl_e64m1(vlmin(vlmax, length - i));\n        vint64m1_t vx = vle64_v_i64m1(x + i, vl);\n        vint64m1_t vax = vmul_vx_i64m1(va, vx, vl);\n        vint64m1_t vy = vabs_v_i64m1(vle64_v_i64m1(y + i, vl), vl);\n        vse64_v_i64m1(vsub_vv_i64m1(vax, vy, vl), y + i, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_34_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t vlmax = vsetvl_e64m1(length);\n    vint64m1_t va = vmv_v_x_i64m1(a, vlmax);\n    for (size_t i = 0; i < length; i += vlmax) {\n        size_t vl = vsetvl_e64m1(vlmax > (length - i) ? (length - i) : vlmax);\n        vint64m1_t vx = vle64_v_i64m1(x + i, vl);\n        vint64m1_t vmul = vmul_vx_i64m1(vx, a, vl);\n        vint64m1_t vabs = vabs_v_i64m1(vx, vl);\n        vint64m1_t vsub = vsub_vv_i64m1(vmul, vabs, vl);\n        vse64_v_i64m1(y + i, vsub, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_34_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t vlmax = vsetvl_e64m1(length);\n    vint64m1_t va = vmv_v_x_i64m1(a, vlmax);\n    for (size_t i = 0; i < length; i += vlmax) {\n        size_t vl = vsetvl_e64m1(vlmax > (length - i) ? (length - i) : vlmax);\n        vint64m1_t vx = vle64_v_i64m1(x + i, vl);\n        vint64m1_t vmul = vmul_vx_i64m1(vx, a, vl);\n        vint64m1_t vabs = vabs_v_i64m1(vmul, vl);\n        vsb64_v_i64m1(y + i, vabs, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_35_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    size_t vl = vsetvl_e16m1(length);\n    vint16m1_t v_min = vmv_v_x_i16m1(0x7FFF, vl); // Initialize with max int16\n    vint16m1_t v_max = vmv_v_x_i16m1(-0x8000, vl); // Initialize with min int16\n\n    for (size_t i = 0; i < length; i += vl) {\n        size_t sublength = length - i > vl ? vl : length - i;\n        vint16m1_t v_vec = vle16_v_i16m1(vec + i, sublength);\n        \n        v_min = vmin_vv_i16m1(v_min, v_vec, sublength);\n        v_max = vmax_vv_i16m1(v_max, v_vec, sublength);\n    }\n\n    int16_t min_num = vmv_x_s_i16m1_i16(v_min);\n    int16_t max_num = vmv_x_s_i16m1_i16(v_max);\n\n    MinMaxPair result;\n    result.min_num = min_num;\n    result.max_num = max_num;\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    size_t vl = vsetvl_e16m1(length);\n    vint16m1_t v0 = vmv_v_x_i16m1(0, vl); // Initialize vector with 0s\n    vint16m1_t vmax = vle16_v_i16m1(vec, vl); // Load first vector segment\n    vint16m1_t vmin = vmax;\n\n    size_t i = vl;\n    for (; i + vl <= length; i += vl) {\n        vint16m1_t vtemp = vle16_v_i16m1(&vec[i], vl);\n        vmax = vmax_vv_i16m1(vmax, vtemp, vl);\n        vmin = vmin_vv_i16m1(vmin, vtemp, vl);\n    }\n\n    // Horizontal reduction for max\n    for (size_t j = 1; j < vl; j *= 2) {\n        vint16m1_t shifted_max = vsrl_vx_i16m1(vmax, j, vl);\n        vmax = vmax_vv_i16m1(vmax, shifted_max, vl);\n    }\n    int16_t max_result = vmfmax_x_s_i16m1_i16(vmax, vl);\n\n    // Horizontal reduction for min\n    for (size_t j = 1; j < vl; j *= 2) {\n        vint16m1_t shifted_min = vsrl_vx_i16m1(vmin, j, vl);\n        vmin = vmin_vv_i16m1(vmin, shifted_min, vl);\n    }\n    int16_t min_result = vmfmin_x_s_i16m1_i16(vmin, vl);\n\n    // Process remaining elements if any\n    for (; i < length; i++) {\n        if (vec[i] > max_result) max_result = vec[i];\n        if (vec[i] < min_result) min_result = vec[i];\n    }\n\n    MinMaxPair result;\n    result.min_num = min_result;\n    result.max_num = max_result;\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    size_t vl = vsetvl_e16m1(length);\n    vint16m1_t v0 = vmv_v_x_i16m1(0, vl);\n    vint16m1_t vmax = vle16_v_i16m1(vec, vl);\n    vint16m1_t vmin = vmax;\n\n    size_t i = vl;\n    while (i < length) {\n        size_t vl_new = vsetvl_e16m1(length - i);\n        vint16m1_t vtmp = vle16_v_i16m1(vec + i, vl_new);\n        vmax = vmx_vv_i16m1(vmax, vtmp, vl_new);\n        vmin = vmn_vv_i16m1(vmin, vtmp, vl_new);\n        i += vl_new;\n    }\n\n    int16_t max_num = vmv_x_s_i16m1_i16(vmax);\n    int16_t min_num = vmv_x_s_i16m1_i16(vmin);\n\n    for (size_t j = 1; j < vl; j++) {\n        int16_t current_val = vec[j];\n        if (current_val > max_num) max_num = current_val;\n        if (current_val < min_num) min_num = current_val;\n    }\n\n    MinMaxPair result;\n    result.min_num = min_num;\n    result.max_num = max_num;\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    size_t vl = vsetvl_e16m1(length);\n    vint16m1_t v0 = vmv_v_x_i16m1(0, vl); // Initialize vector with 0s\n    vint16m1_t vmin = vle16_v_i16m1(vec, vl); // Load first vector segment\n    vint16m1_t vmax = vmin;\n\n    size_t i = vl;\n    while (i < length) {\n        vl = vsetvl_e16m1(length - i);\n        vint16m1_t vtemp = vle16_v_i16m1(vec + i, vl);\n        vmin = vmn_tum_vv_i16m1(vmin, vtemp, vl);\n        vmax = vmx_tum_vv_i16m1(vmax, vtemp, vl);\n        i += vl;\n    }\n\n    // Reduce to find scalar min and max\n    int16_t smin = vminreduce_min_i16m1(vmin);\n    int16_t smax = vmaxreduce_max_i16m1(vmax);\n\n    return (MinMaxPair){smin, smax};\n}\n```"}
{"task_id": "SimdBench_35_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    size_t vl = vsetvl_e16m1(length);\n    vint16m1_t v0 = vmv_v_x_i16m1(0, vl); // Initialize vector with 0s\n    vint16m1_t vmin = vle16_v_i16m1(vec, vl); // Load first vector segment\n    vint16m1_t vmax = vmin;\n\n    size_t i = vl;\n    while (i < length) {\n        vl = vsetvl_e16m1(length - i);\n        vint16m1_t vtmp = vle16_v_i16m1(&vec[i], vl);\n        vmin = vmERGE_vv_i16m1(vmin, vtmp, vl);\n        vmax = vmxge_vv_i16m1(vmax, vtmp, vl);\n        i += vl;\n    }\n\n    int16_t min_num = vmin;\n    int16_t max_num = vmax;\n\n    for (size_t j = 0; j < vl; j++) {\n        if (vec[j] < min_num) min_num = vec[j];\n        if (vec[j] > max_num) max_num = vec[j];\n    }\n\n    MinMaxPair result;\n    result.min_num = min_num;\n    result.max_num = max_num;\n    return result;\n}\n```"}
{"task_id": "SimdBench_36_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdbool.h>\n#include <stddef.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    size_t vl = vsetvl_e32m1(cols);\n    vbool32m1_t vmTrue = vm_vt_b32m1(true, vl);\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        vint32m1_t vRow = vlseg1ff_v_i32m1(row, vl);\n        vint32m1_t vShiftedRow = vsslide1up_vx_i32m1(vRow, 1, vl);\n        vbool32m1_t vCmp = vmseq_vv_i32m1_b32m1(vRow, vShiftedRow, vl);\n        vbool32m1_t vMask = vmin_vv_b32m1(vmTrue, vCmp, vl);\n        bool is_not_increasing = vmandnot_mm_b32m1(vmTrue, vMask);\n        if (is_not_increasing) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    size_t vl = vsetvl_e32m1(cols);\n    vbool32m1_t vmask = vmop_v_i32m1(true, vl);\n    vbool32m1_t vor_result;\n    bool result = true;\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int *row = &matrix[i * cols];\n        vor_result = vmop_v_i32m1(false, vl);\n\n        for (size_t j = 0; j < cols - 1; j += vl) {\n            size_t current vl = vsetvl_e32m1(cols - j);\n            vint32m1_t vcurrent = vle32_v_i32m1(row + j, current_vl);\n            vint32m1_t vnext = vle32_v_i32m1(row + j + 1, current_vl);\n            vbool32m1_t vcmp = vmge_vv_i32m1_b32m1(vcurrent, vnext, vmask, current_vl);\n            vor_result = vor_mm_b32m1(vor_result, vcmp, current_vl);\n        }\n\n        if (vfredor_b32m1(vor_result, vl)) {\n            result = false;\n            break;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_36_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    size_t vl = vsetvl_e32m1(cols);\n    vbool32m1_t vm_all_true = vmv_v_x_b32m1(true, vl);\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int *row = &matrix[i * cols];\n        vbool32m1_t vm_is_increasing = vm_all_true;\n        for (size_t j = 0; j < cols - 1; j += vl) {\n            size_t actual vl = vsetvl_e32m1(cols - j > vl ? vl : cols - j);\n            vint32m1_t vi_curr = vle32_v_i32m1(row + j, actual_vl);\n            vint32m1_t vi_next = vle32_v_i32m1(row + j + 1, actual_vl);\n            vbool32m1_t vi_cmp = vm.lt.vv_i32m1_b32m1(vi_curr, vi_next, actual_vl);\n            vm_is_increasing = vm.and.vm_b32m1(vm_is_increasing, vi_cmp, actual_vl);\n            if (vm.mv_x_vm_b32m1(vm_is_increasing) == false) break;\n        }\n        if (!vm.mv_x_vm_b32m1(vm_is_increasing)) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdbool.h>\n#include <stddef.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    size_t vl = vsetvl_e32m1(cols);\n    vbool32m1_t vmask = vmv_v_x_b32m1(true, vl);\n    vbool32m1_t vtrue = vmv_v_x_b32m1(true, vl);\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        bool row_increasing = true;\n\n        for (size_t j = 0; j + vl <= cols; j += vl) {\n            vint32m1_t vrow = vle32_v_i32m1(row + j, vl);\n            vint32m1_t vshifted = vsrl_vx_i32m1(vrow, 1, vl);\n            vbool32m1_t vcmp = vmge_vv_b32m1(vrow, vshifted, vmask, vl);\n\n            if (!vfredor_b32m1_b(vcmp, vl)) {\n                row_increasing = false;\n                break;\n            }\n        }\n\n        if (row_increasing) {\n            for (size_t j = (cols / vl) * vl; j < cols - 1; ++j) {\n                if (!(row[j] < row[j + 1])) {\n                    row_increasing = false;\n                    break;\n                }\n            }\n        }\n\n        if (!row_increasing) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdbool.h>\n#include <stddef.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    size_t vl = vsetvl_e32m1(cols);\n    vbool32m1_t vmask = vmv_v_x_b32m1(true, vl);\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int *row = &matrix[i * cols];\n        vint32m1_t vrow = vlde32_v_i32m1(row, vl);\n        vint32m1_t vshifted = vsrl_vx_i32m1(vrow, 1, vl);\n        vbool32m1_t vcmp = vmgt_vv_b32m1(vrow, vshifted, vmask, vl);\n\n        if (!vmandnot_m(vmfirst_m_b32m1(vmask, vl), vcmp)) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdbool.h>\n#include <stddef.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_row_blocks = rows / block_size;\n    size_t num_col_blocks = cols / block_size;\n\n    const int* first_block = matrix;\n    size_t total_elements_per_block = block_size * block_size;\n\n    // Load the first block\n    size_t vl = vsetvl_e32m1(total_elements_per_block);\n    vint32m1_t vfirst_block = vlload_e32_v_int32m1((vint32m1_t)first_block, vl);\n\n    for (size_t rb = 0; rb < num_row_blocks; rb++) {\n        for (size_t cb = 0; cb < num_col_blocks; cb++) {\n            if (rb == 0 && cb == 0) {\n                continue; // Skip comparison with itself\n            }\n\n            const int* current_block = matrix + rb * block_size * cols + cb * block_size;\n            vbool4_t result = true;\n\n            for (size_t i = 0; i < block_size; i++) {\n                const int* current_row = current_block + i * cols;\n                vint32m1_t vcurrent_row = vlload_e32_v_int32m1((vint32m1_t)(current_row), vl);\n                vbool4_t veq = vmseq_vv_i32m1_b4(vfirst_block, vcurrent_row, vl);\n                result = result && veq;\n            }\n\n            if (!vmandnot_b4_v_b4(result, vl)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdbool.h>\n#include <stddef.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = cols / block_size;\n    size_t num_blocks_col = rows / block_size;\n\n    // Get the first block\n    size_t first_block_size = block_size * block_size;\n    vint32m1_t vfirst_block[first_block_size];\n    for (size_t i = 0; i < block_size; ++i) {\n        size_t offset = i * cols;\n        vint32m1_t vl = vmv_v_x_i32m1(matrix[offset], 1);\n        for (size_t j = 0; j < block_size; ++j) {\n            vfirst_block[i * block_size + j] = vl;\n        }\n    }\n\n    // Compare all blocks with the first block\n    for (size_t b_row = 0; b_row < num_blocks_col; ++b_row) {\n        for (size_t b_col = 0; b_col < num_blocks_row; ++b_col) {\n            if ((b_row == 0 && b_col == 0)) {\n                continue; // Skip comparing the first block with itself\n            }\n\n            size_t block_start_row = b_row * block_size;\n            size_t block_start_col = b_col * block_size;\n\n            for (size_t i = 0; i < block_size; ++i) {\n                size_t row_offset = (block_start_row + i) * cols + block_start_col;\n                vint32m1_t vcurrent_row = lv_v_i32m1(&matrix[row_offset], block_size);\n\n                for (size_t j = 0; j < block_size; ++j) {\n                    vbool4_t veq = vmseq_vv_b4m1(vcurrent_row, vfirst_block[i * block_size + j], 1);\n                    if (!vmandnot_m(vmsof_m(veq), vm_tobool(veq))) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdbool.h>\n#include <stddef.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = cols / block_size;\n    size_t num_blocks_col = rows / block_size;\n\n    const int* first_block = matrix;\n    size_t total_elements_per_block = block_size * block_size;\n\n    for (size_t b = 1; b < num_blocks_row * num_blocks_col; b++) {\n        size_t block_row = b / num_blocks_row;\n        size_t block_col = b % num_blocks_row;\n\n        const int* current_block = matrix + (block_row * block_size * cols) + (block_col * block_size);\n\n        for (size_t i = 0; i < total_elements_per_block; i += vlenb()) {\n            size_t vl = vsetvl_e32m1(total_elements_per_block - i);\n            vint32m1_t v_first = vle32_v_i32m1(first_block + i, vl);\n            vint32m1_t v_current = vle32_v_i32m1(current_block + i, vl);\n\n            vbool4_t cmp_result = vmseq_vv_b4m1(v_first, v_current, vl);\n            size_t mask = vmfirst_m_b4(cmp_result, vl);\n            if (mask != 0xFFFFFFFF) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdbool.h>\n#include <stddef.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = cols / block_size;\n    size_t num_blocks_col = rows / block_size;\n\n    const int* first_block = matrix;\n    size_t total_elements = block_size * block_size;\n\n    // Load the first block\n    size_t vl = vsetvl_e32m1(total_elements);\n    vint32m1_t vfirst_block = vlload_e32_v_i32m1(first_block, vl);\n\n    for (size_t b_row = 0; b_row < num_blocks_col; b_row++) {\n        for (size_t b_col = 0; b_col < num_blocks_row; b_col++) {\n            if (b_row == 0 && b_col == 0) {\n                continue; // Skip comparison with itself\n            }\n\n            const int* current_block = matrix + b_row * block_size * cols + b_col * block_size;\n            vint32m1_t vcurrent_block = vlload_e32_v_i32m1(current_block, vl);\n\n            vbool4_t veq = vmseq_vv_i32m1_b4(vfirst_block, vcurrent_block, vl);\n            size_t mask = vmfirst_m_b4(veq);\n            if (mask != (size_t)-1) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdbool.h>\n#include <stddef.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = cols / block_size;\n    size_t num_blocks_col = rows / block_size;\n\n    const int* first_block = matrix;\n    size_t vl = vsetvl_e32m1(block_size);\n\n    for (size_t bcol = 0; bcol < num_blocks_col; ++bcol) {\n        for (size_t brow = 0; brow < num_blocks_row; ++brow) {\n            if ((bcol == 0 && brow == 0)) {\n                continue;\n            }\n            const int* current_block = matrix + bcol * block_size * cols + brow * block_size;\n            for (size_t i = 0; i < block_size; ++i) {\n                vint32m1_t vec_first = lv_int32_v(first_block + i * cols, vl);\n                vint32m1_t vec_curr = lv_int32_v(current_block + i * cols, vl);\n                vbool4_t cmp_result = veq_vv_i32m1_b4(vec_first, vec_curr, vl);\n                size_t mask = vmv_x_s_b4_i32(cmp_result);\n                if (mask != (size_t)-1) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdbool.h>\n#include <stddef.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (block_size == 0 || length == 0 || length < block_size || vec == NULL || tolerance < 0) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n\n    vfloat64m1_t vtolerance = vmv_v_f_f64m1(tolerance);\n    vfloat64m1_t vzero = vmv_v_f_f64m1(0.0);\n\n    for (size_t i = 1; i < num_blocks; i++) {\n        size_t j;\n        for (j = 0; j + vlmax <= block_size; j += vlmax) {\n            size_t l = vsetvl_e64m1(vlmax);\n\n            vfloat64m1_t vfirst = lvf64_v_f64m1(&vec[j], l);\n            vfloat64m1_t vcurrent = lvf64_v_f64m1(&vec[i * block_size + j], l);\n\n            vfloat64m1_t vdiff = vsub_vv_f64m1(vcurrent, vfirst, l);\n            vfloat64m1_t vabsdiff = vfsgnjx_vv_f64m1(vdiff, vdiff, l);\n\n            vbool64m1_t vcond = vle_vv_f64m1_b64(vabsdiff, vtolerance, l);\n\n            if (!vmv_x_m_b64(vcond)) {\n                return false;\n            }\n        }\n\n        if (j < block_size) {\n            size_t l = vsetvl_e64m1(block_size - j);\n\n            vfloat64m1_t vfirst = lvf64_v_f64m1(&vec[j], l);\n            vfloat64m1_t vcurrent = lvf64_v_f64m1(&vec[i * block_size + j], l);\n\n            vfloat64m1_t vdiff = vsub_vv_f64m1(vcurrent, vfirst, l);\n            vfloat64m1_t vabsdiff = vfsgnjx_vv_f64m1(vdiff, vdiff, l);\n\n            vbool64m1_t vcond = vle_vv_f64m1_b64(vabsdiff, vtolerance, l);\n\n            if (!vmv_x_m_b64(vcond)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdbool.h>\n#include <stddef.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (block_size == 0 || length < block_size || length % block_size != 0 || vec == NULL) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n\n    vfloat64m1_t vtolerance = vmv_v_f_f64m1(tolerance);\n    vfloat64m1_t vzero = vmv_v_f_f64m1(0.0);\n\n    for (size_t i = 1; i < num_blocks; ++i) {\n        size_t j = 0;\n        while (j < block_size) {\n            size_t vl = vsetvl_e64m1(block_size - j);\n\n            vfloat64m1_t vref = vle64_v_f64m1(&vec[j], vl);\n            vfloat64m1_t vcurr = vle64_v_f64m1(&vec[i * block_size + j], vl);\n\n            vfloat64m1_t vdiff = vfsub_vv_f64m1(vcurr, vref, vl);\n            vfloat64m1_t vabsdiff = vfabs_v_f64m1(vdiff, vl);\n\n            vbool64m1_t vcmp = vmfle_v_f_f64m1_b64m1(vabsdiff, vtolerance, vl);\n\n            size_t mask = vmv_x_s_b64m1_i64(vcmp);\n            if (mask != ((size_t)-1)) {\n                return false;\n            }\n\n            j += vl;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdbool.h>\n#include <stddef.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (block_size == 0 || length < block_size || length % block_size != 0 || vec == NULL) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    size_t vlmax = vsetvl_e64m1(1);\n\n    // Load the first block\n    vfloat64m1_t v_first_block = vmv_v_x_f64m1(0.0, vlmax);\n    for (size_t i = 0; i < block_size; i += vlmax) {\n        size_t vl = vsetvl_e64m1(block_size - i);\n        vfloat64m1_t v_temp = vle64_v_f64m1(&vec[i], vl);\n        v_first_block = vmERGE_vv_f64m1(v_first_block, v_temp, vl);\n    }\n\n    for (size_t block_idx = 1; block_idx < num_blocks; block_idx++) {\n        size_t offset = block_idx * block_size;\n\n        // Load current block\n        vfloat64m1_t v_curr_block = vmv_v_x_f64m1(0.0, vlmax);\n        for (size_t i = 0; i < block_size; i += vlmax) {\n            size_t vl = vsetvl_e64m1(block_size - i);\n            vfloat64m1_t v_temp = vle64_v_f64m1(&vec[offset + i], vl);\n            v_curr_block = vmERGE_vv_f64m1(v_curr_block, v_temp, vl);\n        }\n\n        // Compare blocks\n        for (size_t i = 0; i < block_size; i += vlmax) {\n            size_t vl = vsetvl_e64m1(block_size - i);\n            vfloat64m1_t v_diff = vfsub_vv_f64m1(v_curr_block, v_first_block, vl);\n            vfloat64m1_t v_abs_diff = vfabs_v_f64m1(v_diff, vl);\n            vbool8_t v_mask = vmfle_vf_f64m1_b8(v_abs_diff, tolerance, vl);\n            size_t mask = vmv_x_s_b8_u32_m(v_mask);\n            if (mask != ((size_t)-1)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdbool.h>\n#include <stddef.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (block_size == 0 || length == 0 || length < block_size || vec == NULL) return false;\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks <= 1) return true;\n\n    vfloat64m8x2_t first_block_vecs[2];\n    vfloat64m8_t tolerance_v = vmv_v_f_f64m8(tolerance);\n\n    for (size_t i = 0; i < block_size; i += 8) {\n        size_t vl = vsetvl_e64m8(block_size - i);\n        vfloat64m8_t first_block = lvf64_v_f64m8(&vec[i], vl);\n        if (i + 8 <= block_size) {\n            first_block_vecs[i / 8] = vmv_x_w_f64m8x2(first_block);\n        }\n    }\n\n    for (size_t block_idx = 1; block_idx < num_blocks; block_idx++) {\n        size_t block_offset = block_idx * block_size;\n        for (size_t i = 0; i < block_size; i += 8) {\n            size_t vl = vsetvl_e64m8(block_size - i);\n            vfloat64m8_t current_block = lvf64_v_f64m8(&vec[block_offset + i], vl);\n            vfloat64m8_t diff = vsub_vv_f64m8(current_block, first_block_vecs[i / 8].f64m8, vl);\n            vfloat64m8_t abs_diff = vabs_v_f64m8(diff, vl);\n            vbool8_t mask = vmfle_vf_f64m8_b8(abs_diff, tolerance_v, vl);\n            size_t all_true = vmv_x_s_b8_i32(mask);\n            if (all_true != (1 << vl) - 1) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdbool.h>\n#include <stddef.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (block_size == 0 || length == 0 || vec == NULL || length < block_size) return false;\n\n    size_t num_blocks = length / block_size;\n    vfloat64m1_t vtolerance = vmv_v_f_f64m1(tolerance);\n    vfloat64m1_t vzero = vmv_v_f_f64m1(0.0);\n\n    for (size_t i = 1; i < num_blocks; i++) {\n        size_t j = 0;\n        while (j < block_size) {\n            size_t vl = __riscv_vsetvl_e64m1(block_size - j);\n            vfloat64m1_t vfirst = __riscv_vle64_v_f64m1(&vec[j], vl);\n            vfloat64m1_t vcurrent = __riscv_vle64_v_f64m1(&vec[i * block_size + j], vl);\n\n            vfloat64m1_t vdiff = vsub_vv_f64m1(vcurrent, vfirst, vl);\n            vfloat64m1_t vabsdiff = vfabs_v_f64m1(vdiff, vl);\n\n            vbool8_t mask = vle_vf_f64m1_b8(vabsdiff, vtolerance, vl);\n            if (__riscv_vmv_x_s_b8(mask, vl) != -1) return false;\n\n            j += vl;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_39_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    size_t vlmax = vsetvl_e64m8(1);\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row = &matrix[i * cols];\n        vfloat64m8_t vsum = vmv_v_x_f64m8(0.0, vlmax);\n        size_t j = 0;\n        for (; j + vlmax <= cols; j += vlmax) {\n            vfloat64m8_t vrow = lvf64_v_f64m8(&row[j], vlmax);\n            vfloat64m8_t vsqr = vmul_vv_f64m8(vrow, vrow, vlmax);\n            vsum = vadd_vv_f64m8(vsum, vsqr, vlmax);\n        }\n        double sum = 0.0;\n        if (j < cols) {\n            size_t vl = vsetvl_e64m8(cols - j);\n            vfloat64m8_t vrow = lvf64_v_f64m8(&row[j], vl);\n            vfloat64m8_t vsqr = vmul_vv_f64m8(vrow, vrow, vl);\n            vsum = vadd_vv_f64m8(vsum, vsqr, vl);\n            sum += vmv_x_s_f64m8_f64(vredsum_vs_f64m8_f64m8(vsum, vsum, vl));\n        }\n        sum += vmv_x_s_f64m8_f64(vredsum_vs_f64m8_f64m8(vsum, vsum, vlmax));\n        double norm = sqrt(sum);\n        result[i] = norm > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_39_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    size_t vlmax = vmgetvl_e64m1();\n    vbool64_t mask = vmv_v_x_i64m1(true, vlmax);\n    size_t stride = cols;\n\n    for (size_t i = 0; i < rows; i++) {\n        double sum_squares = 0.0;\n        size_t j = 0;\n\n        for (; j + vlmax <= cols; j += vlmax) {\n            vfloat64m1_t vec = vle64_v_f64m1(matrix + i * stride + j, vlmax);\n            vfloat64m1_t squared = vmul_vv_f64m1(vec, vec, vlmax);\n            sum_squares += vhsumseg_mv_f64_vf64m1(squared, vlmax);\n        }\n\n        for (; j < cols; j++) {\n            sum_squares += matrix[i * stride + j] * matrix[i * stride + j];\n        }\n\n        double norm = sqrt(sum_squares);\n        result[i] = norm > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_39_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    size_t vlmax = vsetvl_e64m1(1);\n    for (size_t i = 0; i < rows; i++) {\n        double sum_squares = 0.0;\n        size_t j = 0;\n        size_t vl;\n        vfloat64m1_t vmatrix;\n        vfloat64m1_t vsquare;\n        while (j + vlmax <= cols) {\n            vl = vsetvl_e64m1(vlmax);\n            vmatrix = vle64_v_f64m1(&matrix[i * cols + j], vl);\n            vsquare = vmul_vv_f64m1(vmatrix, vmatrix, vl);\n            sum_squares += vadot_vf_f64m1(0.0, vmatrix, vmatrix, vl);\n            j += vl;\n        }\n        while (j < cols) {\n            sum_squares += matrix[i * cols + j] * matrix[i * cols + j];\n            j++;\n        }\n        double norm = sqrt(sum_squares);\n        result[i] = norm > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_39_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    size_t vlmax = vsetvl_e64m8(1);\n    for (size_t i = 0; i < rows; ++i) {\n        double sum = 0.0;\n        size_t j = 0;\n        for (; j + vlmax <= cols; j += vlmax) {\n            vfloat64m8_t vec = vle64_v_f64m8(&matrix[i * cols + j], vlmax);\n            vfloat64m8_t sq_vec = vmul_vv_f64m8(vec, vec, vlmax);\n            double sums[vlmax];\n            vse64_v_f64m8(sums, sq_vec, vlmax);\n            for (size_t k = 0; k < vlmax; ++k) {\n                sum += sums[k];\n            }\n        }\n        for (; j < cols; ++j) {\n            sum += matrix[i * cols + j] * matrix[i * cols + j];\n        }\n        result[i] = (sum > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    size_t vlmax = vsetvl_e64m8(1);\n    for (size_t i = 0; i < rows; i++) {\n        double sum = 0.0;\n        size_t col = 0;\n        size_t vl = 0;\n        const double* row_start = matrix + i * cols;\n\n        while (col < cols) {\n            vl = vsetvl_e64m8(cols - col);\n            vfloat64m8x2_t vmatrix = vle64_v_f64m8(row_start + col, vl);\n            vfloat64m8_t vsqr = vmul_vv_f64m8(vmatrix.v0, vmatrix.v0, vl);\n            vsqr = vadd_vv_f64m8(vsqr, vmul_vv_f64m8(vmatrix.v1, vmatrix.v1, vl), vl);\n            float64_t buffer[2];\n            vse64_v_f64m8(buffer, vsqr, vl);\n            for (size_t j = 0; j < vl; j++) {\n                sum += buffer[j];\n            }\n            col += vl;\n        }\n\n        double norm = sqrt(sum);\n        result[i] = norm > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t vlmax = vsetvl_e32m1(length);\n    vuint32m1_t va, vb, vc;\n    for (size_t i = 0; i < length; i += vlmax) {\n        size_t vl = vsetvl_e32m1(vlmax > (length - i) ? (length - i) : vlmax);\n        va = vle32_v_u32m1(A + i, vl);\n        vb = vle32_v_u32m1(B + i, vl);\n        vc = vor_vv_u32m1(va, vb, vl);\n        vse32_v_u32m1(C + i, vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_40_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t vlmax = vsetvl_e32m1(length);\n    vuint32m1_t va, vb, vc;\n    for (size_t i = 0; i < length; i += vlmax) {\n        size_t vl = vsetvl_e32m1(length - i);\n        va = vle32_v_u32m1(A + i, vl);\n        vb = vle32_v_u32m1(B + i, vl);\n        vc = vor_vv_u32m1(va, vb, vl);\n        vse32_v_u32m1(C + i, vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_40_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t vlmax = vsetvl_e32m1(length);\n    vuint32m1_t va, vb, vc;\n    for (size_t i = 0; i < length; i += vlmax) {\n        size_t vl = vsetvl_e32m1(vlmax > (length - i) ? (length - i) : vlmax);\n        va = vle32_v_u32m1(A + i, vl);\n        vb = vle32_v_u32m1(B + i, vl);\n        vc = vor_vv_u32m1(va, vb, vl);\n        vse32_v_u32m1(C + i, vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_40_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t vlmax = vsetvl_e32m1(length);\n    vuint32m1_t va, vb, vc;\n    for (size_t i = 0; i < length; i += vlmax) {\n        size_t vl = vsetvl_e32m1(vlmax > (length - i) ? (length - i) : vlmax);\n        va = vle32_v_u32m1(A + i, vl);\n        vb = vle32_v_u32m1(B + i, vl);\n        vc = vor_vv_u32m1(va, vb, vl);\n        vse32_v_u32m1(C + i, vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_40_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t vl = vsetvl_e32m1(length);\n    vuint32m1_t va = vmv_v_x_u32m1(0, vl);\n    vuint32m1_t vb = vmv_v_x_u32m1(0, vl);\n    vuint32m1_t vc = vmv_v_x_u32m1(0, vl);\n\n    for(size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n        va = vle32_v_u32m1(A + i, vl);\n        vb = vle32_v_u32m1(B + i, vl);\n        vc = vor_vv_u32m1(va, vb, vl);\n        vse32_v_u32m1(C + i, vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_41_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n\n    size_t vlmax = vlenb();\n    size_t i = 0;\n\n    for (; i <= length - vlmax; i += vlmax) {\n        vint8m1_t va = vle8_v_i8m1(A + i, vlmax);\n        vint8m1_t vb = vle8_v_i8m1(B + i, vlmax);\n\n        // Compute squares of A and B\n        vint16m2_t va_sq = vmul_vv_i16m2(va, va, vlmax);\n        vint16m2_t vb_sq = vmul_vv_i16m2(vb, vb, vlmax);\n\n        // Compute products of A and B\n        vint16m2_t vapb = vmul_vv_i16m2(va, vb, vlmax);\n\n        // Horizontal sum of squares\n        int32_t red_va_sq = vmv_x_s_i32m2_i32(vredsum_vs_i16m2_i32m4(va_sq, 0, vlmax));\n        int32_t red_vb_sq = vmv_x_s_i32m2_i32(vredsum_vs_i16m2_i32m4(vb_sq, 0, vlmax));\n\n        // Horizontal sum of products\n        int32_t red_vapb = vmv_x_s_i32m2_i32(vredsum_vs_i16m2_i32m4(vapb, 0, vlmax));\n\n        sum_squares += (int64_t)(red_va_sq + red_vb_sq);\n        sum_products += (int64_t)red_vapb;\n    }\n\n    // Tail processing if any\n    if (i < length) {\n        size_t vl = length - i;\n        vint8m1_t va = vle8_v_i8m1(A + i, vl);\n        vint8m1_t vb = vle8_v_i8m1(B + i, vl);\n\n        // Compute squares of A and B\n        vint16m2_t va_sq = vmul_vv_i16m2(va, va, vl);\n        vint16m2_t vb_sq = vmul_vv_i16m2(vb, vb, vl);\n\n        // Compute products of A and B\n        vint16m2_t vapb = vmul_vv_i16m2(va, vb, vl);\n\n        // Horizontal sum of squares\n        int32_t red_va_sq = vmv_x_s_i32m2_i32(vredsum_vs_i16m2_i32m4(va_sq, 0, vl));\n        int32_t red_vb_sq = vmv_x_s_i32m2_i32(vredsum_vs_i16m2_i32m4(vb_sq, 0, vl));\n\n        // Horizontal sum of products\n        int32_t red_vapb = vmv_x_s_i32m2_i32(vredsum_vs_i16m2_i32m4(vapb, 0, vl));\n\n        sum_squares += (int64_t)(red_va_sq + red_vb_sq);\n        sum_products += (int64_t)red_vapb;\n    }\n\n    return sum_squares - sum_products;\n}\n```"}
{"task_id": "SimdBench_41_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    size_t vlmax = vsetvl_e8m1(length);\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n\n    for (size_t vl = vlmax; vl != 0; vl = vsetvl_e8m1(vl)) {\n        vint8m1_t va = vle8_v_i8m1(A, vl);\n        vint8m1_t vb = vle8_v_i8m1(B, vl);\n\n        vint16m2_t vsquares = vmul_vv_i16m2(va, va, vl);\n        vint16m2_t vproducts = vmul_vv_i16m2(va, vb, vl);\n\n        int32_t red_squares = vmv_x_s_i32si_h(vmredsum_vs_i16m2_i32m1(vsquares, vmv_v_x_i32m1(0, vl), vl));\n        int32_t red_products = vmv_x_s_i32si_h(vmredsum_vs_i16m2_i32m1(vproducts, vmv_v_x_i32m1(0, vl), vl));\n\n        sum_squares += red_squares;\n        sum_products += red_products;\n\n        A += vl;\n        B += vl;\n        length -= vl;\n        if (length == 0) break;\n        vl = vsetvl_e8m1(length);\n    }\n\n    return sum_squares - sum_products;\n}\n```"}
{"task_id": "SimdBench_41_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n\n    size_t vlmax = vsetvl_e8m1(length);\n    vint8m1_t vzero = vmv_v_x_i8m1(0, vlmax);\n\n    for (size_t i = 0; i < length; i += vlmax) {\n        size_t vl = vsetvl_e8m1(vmin_v_u(size_t, length - i, vlmax));\n\n        vint8m1_t va = lv_s_b(A + i, vl);\n        vint8m1_t vb = lv_s_b(B + i, vl);\n\n        vint8m1_t vsquare_a = vmul_vv_i8m1(va, va, vl);\n        vint8m1_t vsquare_b = vmul_vv_i8m1(vb, vb, vl);\n        vint8m1_t vproduct = vmul_vv_i8m1(va, vb, vl);\n\n        vint8m1_t vsquares_sum = vadd_vv_i8m1(vsquare_a, vsquare_b, vl);\n\n        int64_t red_squares = (int64_t)vmv_x_s_i8m1_i8(vsquares_sum, vl);\n        int64_t red_product = (int64_t)vmv_x_s_i8m1_i8(vproduct, vl);\n\n        sum_squares += red_squares;\n        sum_products += red_product;\n    }\n\n    return sum_squares - sum_products;\n}\n```"}
{"task_id": "SimdBench_41_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    size_t vlmax = vsetvl_e8m1(length);\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n\n    for (size_t i = 0; i < length; i += vlmax) {\n        size_t vl = vsetvl_e8m1(vlmin(vlmax, length - i));\n        vint8m1_t va = vle8_v_i8m1(A + i, vl);\n        vint8m1_t vb = vle8_v_i8m1(B + i, vl);\n\n        // Compute squares of A and B\n        vint8m1_t vsquare_a = vmul_vv_i8m1(va, va, vl);\n        vint8m1_t vsquare_b = vmul_vv_i8m1(vb, vb, vl);\n\n        // Compute products of A and B\n        vint8m1_t vproduct_ab = vmul_vv_i8m1(va, vb, vl);\n\n        // Horizontal sum of squares\n        int32_t red_square_a = vmv_x_s_i32m4(vredsum_vs_i8m1_i32m4(vsquare_a, vmv_v_x_i32m4(0, vl), vl));\n        int32_t red_square_b = vmv_x_s_i32m4(vredsum_vs_i8m1_i32m4(vsquare_b, vmv_v_x_i32m4(0, vl), vl));\n\n        // Horizontal sum of products\n        int32_t red_product_ab = vmv_x_s_i32m4(vredsum_vs_i8m1_i32m4(vproduct_ab, vmv_v_x_i32m4(0, vl), vl));\n\n        sum_squares += red_square_a + red_square_b;\n        sum_products += red_product_ab;\n    }\n\n    return sum_squares - sum_products;\n}\n```"}
{"task_id": "SimdBench_41_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n\n    size_t vlmax = vsetvl_e8m1(length);\n    vint8m1_t vzero = vmv_v_x_i8m1(0, vlmax);\n\n    for (size_t i = 0; i < length; i += vlmax) {\n        size_t vl = vsetvl_e8m1(vlmin(vlmax, length - i));\n        vint8m1_t va = lvx_v_i8m1(A + i, vl);\n        vint8m1_t vb = lvx_v_i8m1(B + i, vl);\n\n        vint8m1_t vsquare_a = vmul_vv_i8m1(va, va, vl);\n        vint8m1_t vsquare_b = vmul_vv_i8m1(vb, vb, vl);\n        vint8m1_t vproduct = vmul_vv_i8m1(va, vb, vl);\n\n        vint32m4_t vred_square_a = vwredsum_vs_i8m1_i32m4(vsquare_a, vzero, vzero, vl);\n        vint32m4_t vred_square_b = vwredsum_vs_i8m1_i32m4(vsquare_b, vzero, vzero, vl);\n        vint32m4_t vred_product = vwredsum_vs_i8m1_i32m4(vproduct, vzero, vzero, vl);\n\n        int32_t red_square_a = vmv_x_s_i32m4_i32(vred_square_a);\n        int32_t red_square_b = vmv_x_s_i32m4_i32(vred_square_b);\n        int32_t red_product = vmv_x_s_i32m4_i32(vred_product);\n\n        sum_squares += red_square_a + red_square_b;\n        sum_products += red_product;\n    }\n\n    return sum_squares - sum_products;\n}\n```"}
{"task_id": "SimdBench_42_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t vlmax = vsetvl_e64m8(length);\n    for (size_t vl = 0; vl < length; vl += vlmax) {\n        size_t actual_vl = vsetvl_e64m8(vlmax);\n        vuint64m8_t va = vle64_v_u64m8(A + vl, actual_vl);\n        vuint64m8_t vb = vle64_v_u64m8(B + vl, actual_vl);\n        vuint64m8_t vc = vand_vv_u64m8(va, vnot_v_u64m8(vb, actual_vl), actual_vl);\n        vse64_v_u64m8(C + vl, vc, actual_vl);\n    }\n}\n```"}
{"task_id": "SimdBench_42_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t vlmax = vsetvl_e64m1(length);\n    for (size_t i = 0; i < length; i += vlmax) {\n        size_t vl = vsetvl_e64m1(vlmax);\n        vuint64m1_t va = vle64_v_u64m1(A + i, vl);\n        vuint64m1_t vb = vle64_v_u64m1(B + i, vl);\n        vuint64m1_t vc = vand_vv_u64m1(va, vnot_v_u64m1(vb, vl), vl);\n        vse64_v_u64m1(C + i, vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_42_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t vlmax = vsetvl_e64m8(length);\n    for (size_t i = 0; i < length; i += vlmax) {\n        size_t vl = vsetvl_e64m8(vlmax > (length - i) ? (length - i) : vlmax);\n        vuint64m8_t va = vle64_v_u64m8(A + i, vl);\n        vuint64m8_t vb = vle64_v_u64m8(B + i, vl);\n        vuint64m8_t vc = vand_vx_u64m8(va, ~0ULL, vl);\n        vc = vxor_vv_u64m8(vc, vb, vl);\n        vsse64_v_u64m8(C + i, 0, vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_42_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t vlmax = vsetvl_e64m1(length);\n    for (size_t i = 0; i < length; i += vlmax) {\n        size_t vl = vsetvl_e64m1(vlmin(vlmax, length - i));\n        vuint64m1_t va = vle64_v_u64m1(A + i, vl);\n        vuint64m1_t vb = vle64_v_u64m1(B + i, vl);\n        vuint64m1_t vc = vand_vv_u64m1(va, vnot_v_u64m1(vb, vl), vl);\n        vse64_v_u64m1(C + i, vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_42_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t vlmax = vsetvl_e64m1(length);\n    for (size_t i = 0; i < length; i += vlmax) {\n        size_t vl = vsetvl_e64m1(vlmax);\n        vuint64m1_t va = vle64_v_u64m1(A + i, vl);\n        vuint64m1_t vb = vle64_v_u64m1(B + i, vl);\n        vuint64m1_t vc = vand_vv_u64m1(va, vnot_v_u64m1(vb, vl), vl);\n        vse64_v_u64m1(C + i, vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_43_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t vlmax = vsetvl_e8m1(length);\n    for (size_t i = 0; i < length; i += vlmax) {\n        size_t vl = vsetvl_e8m1(length - i);\n        vint8m1_t va = vle8_v_i8m1(A + i, vl);\n        vint8m1_t vb = vle8_v_i8m1(B + i, vl);\n\n        vbool8_t pos_a = vmfgt_vx_i8m1_b8(va, 0, vl);\n        vbool8_t pos_b = vmfgt_vx_i8m1_b8(vb, 0, vl);\n        vbool8_t neg_a = vmflt_vx_i8m1_b8(va, 0, vl);\n        vbool8_t neg_b = vmflt_vx_i8m1_b8(vb, 0, vl);\n\n        vbool8_t both_pos = vmf_and_b8(pos_a, pos_b, vl);\n        vbool8_t both_neg = vmf_and_b8(neg_a, neg_b, vl);\n\n        vint8m1_t ones = vmv_v_x_i8m1(1, vl);\n        vint8m1_t neg_ones = vmv_v_x_i8m1(-1, vl);\n\n        vint8m1_t result = vmf_merge_vmasked_i8m1(ones, 0, both_pos, vl);\n        result = vmf_merge_vmasked_i8m1(neg_ones, result, both_neg, vl);\n\n        vse8_v_i8m1(C + i, result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_43_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t vlmax = vsetvl_e8m1(length);\n    for (size_t i = 0; i < length; i += vlmax) {\n        size_t vl = vsetvl_e8m1(length - i);\n        vint8m1_t va = vle8_v_i8m1(A + i, vl);\n        vint8m1_t vb = vle8_v_i8m1(B + i, vl);\n\n        vbool8_t pos_a = vmge_vx_i8m1_b8(va, 0, vl);\n        vbool8_t pos_b = vmge_vx_i8m1_b8(vb, 0, vl);\n        vbool8_t neg_a = vmlt_vx_i8m1_b8(va, 0, vl);\n        vbool8_t neg_b = vmlt_vx_i8m1_b8(vb, 0, vl);\n\n        vbool8_t both_pos = vmand_mm_b8(pos_a, pos_b, vl);\n        vbool8_t both_neg = vmand_mm_b8(neg_a, neg_b, vl);\n\n        vint8m1_t vc = vmfcf_v_i8m1(0, vl);\n        vc = vmvf_merge_v_i8m1(vc, 1, both_pos, vl);\n        vc = vmvf_merge_v_i8m1(vc, -1, both_neg, vl);\n\n        vse8_v_i8m1(C + i, vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_43_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t vlmax = vsetvl_e8m1(length);\n    for (size_t i = 0; i < length; i += vlmax) {\n        size_t vl = vsetvl_e8m1(length - i);\n        vint8m1_t va = vle8_v_i8m1(A + i, vl);\n        vint8m1_t vb = vle8_v_i8m1(B + i, vl);\n\n        vbool8_t pos_a = vmge_vx_i8m1_b8(va, 0, vl);\n        vbool8_t pos_b = vmge_vx_i8m1_b8(vb, 0, vl);\n        vbool8_t neg_a = vmlt_vx_i8m1_b8(va, 0, vl);\n        vbool8_t neg_b = vmlt_vx_i8m1_b8(vb, 0, vl);\n\n        vbool8_t both_pos = vm-and-vm_b8(pos_a, pos_b, vl);\n        vbool8_t both_neg = vm-and-vm_b8(neg_a, neg_b, vl);\n\n        vint8m1_t res = vmv_v_x_i8m1(0, vl);\n        res = vmvf_merge_x_i8m1(res, 1, both_pos, vl);\n        res = vmvf_merge_x_i8m1(res, -1, both_neg, vl);\n\n        vse8_v_i8m1(C + i, res, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_43_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t vlmax = vsetvl_e8m1(length);\n    for (size_t i = 0; i < length; i += vlmax) {\n        size_t vl = vsetvl_e8m1(length - i);\n        vint8m1_t va = vle8_v_i8m1(A + i, vl);\n        vint8m1_t vb = vle8_v_i8m1(B + i, vl);\n\n        vbool8_t pos_a = vmfgt_vx_i8m1_b8(va, 0, vl);\n        vbool8_t pos_b = vmfgt_vx_i8m1_b8(vb, 0, vl);\n        vbool8_t neg_a = vmflt_vx_i8m1_b8(va, 0, vl);\n        vbool8_t neg_b = vmflt_vx_i8m1_b8(vb, 0, vl);\n\n        vbool8_t both_pos = vmand_vv_b8(pos_a, pos_b, vl);\n        vbool8_t both_neg = vmand_vv_b8(neg_a, neg_b, vl);\n\n        vint8m1_t ones = vmv_v_x_i8m1(1, vl);\n        vint8m1_t neg_ones = vmv_v_x_i8m1(-1, vl);\n\n        vint8m1_t result = vmERGEZ_vv_i8m1(ones, both_pos, vl);\n        result = vmERGEV_vvm_i8m1(neg_ones, result, both_neg, vl);\n\n        vse8_v_i8m1(C + i, result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_43_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t vlmax = vsetvl_e8m1(length);\n    for (size_t i = 0; i < length; i += vlmax) {\n        size_t vl = vsetvl_e8m1(length - i);\n        vint8m1_t va = vle8_v_i8m1(A + i, vl);\n        vint8m1_t vb = vle8_v_i8m1(B + i, vl);\n\n        vbool8_t pos_a = vmfgt_vx_i8m1_b8(va, 0, vl);\n        vbool8_t pos_b = vmfgt_vx_i8m1_b8(vb, 0, vl);\n        vbool8_t neg_a = vmflt_vx_i8m1_b8(va, 0, vl);\n        vbool8_t neg_b = vmflt_vx_i8m1_b8(vb, 0, vl);\n\n        vbool8_t both_pos = vmf_and_b8(pos_a, pos_b, vl);\n        vbool8_t both_neg = vmf_and_b8(neg_a, neg_b, vl);\n\n        vint8m1_t ones = vmv_v_x_i8m1(1, vl);\n        vint8m1_t neg_ones = vmv_v_x_i8m1(-1, vl);\n\n        vint8m1_t result = vmfc_fork3_v_i8m1(vmfc_pick_v_i8m1(ones, both_pos, vl), \n                                            vmfc_pick_v_i8m1(neg_ones, both_neg, vl), \n                                            vmv_v_x_i8m1(0, vl), vl);\n\n        vse8_v_i8m1(C + i, result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_44_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t vlmax = vsetvl_e16m1(length);\n    size_t mid = length / 2;\n    size_t i = 0;\n\n    // Process elements before the midpoint with XOR\n    for (; i < mid; i += vlmax) {\n        size_t vl = vsetvl_e16m1(vlmin(vlmax, (size_t)(mid - i)));\n        vuint16m1_t va = vle16_v_u16m1(A + i, vl);\n        vuint16m1_t vb = vle16_v_u16m1(B + i, vl);\n        vuint16m1_t vc = vxor_vv_u16m1(va, vb, vl);\n        vse16_v_u16m1(C + i, vc, vl);\n    }\n\n    // Keep the value at the midpoint\n    if (length % 2 != 0) {\n        C[mid] = A[mid];\n        i = mid + 1;\n    } else {\n        i = mid;\n    }\n\n    // Process elements after the midpoint with AND\n    for (; i < length; i += vlmax) {\n        size_t vl = vsetvl_e16m1(vlmin(vlmax, (size_t)(length - i)));\n        vuint16m1_t va = vle16_v_u16m1(A + i, vl);\n        vuint16m1_t vb = vle16_v_u16m1(B + i, vl);\n        vuint16m1_t vc = vand_vv_u16m1(va, vb, vl);\n        vse16_v_u16m1(C + i, vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_44_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t vl = vsetvl_e16m1(length);\n\n    vuint16m1_t va, vb, vc;\n\n    for (size_t i = 0; i < length; i += vl) {\n        size_t chunk_end = i + vl > length ? length : i + vl;\n        vl = vsetvl_e16m1(chunk_end - i);\n\n        va = vle16_v_u16m1(A + i, vl);\n        vb = vle16_v_u16m1(B + i, vl);\n\n        if (i + vl <= midpoint) {\n            // Before midpoint: XOR operation\n            vc = vxor_vv_u16m1(va, vb, vl);\n        } else if (i >= midpoint) {\n            // After midpoint: AND operation\n            vc = vand_vv_u16m1(va, vb, vl);\n        } else {\n            // Spanning the midpoint\n            size_t before_mid = midpoint - i;\n            size_t after_mid = vl - before_mid;\n\n            vuint16m1_t vc_before = vxor_vv_u16m1(va, vb, before_mid);\n            vuint16m1_t vc_after = vand_vv_u16m1(va, vb, after_mid);\n\n            vc = vmv_v_x_u16m1(0, vl);\n            vc = vse16_v_u16m1(vc_before, C + i, before_mid);\n            vc = vse16_v_u16m1(vc_after, C + i + before_mid, after_mid);\n        }\n\n        vse16_v_u16m1(vc, C + i, vl);\n    }\n\n    if (midpoint < length) {\n        C[midpoint] = A[midpoint];\n    }\n}\n```"}
{"task_id": "SimdBench_44_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t vl = vsetvl_e16m1(length);\n\n    vuint16m1_t va, vb, vc;\n\n    for (size_t i = 0; i < length; i += vl) {\n        size_t chunk = length - i > vl ? vl : length - i;\n\n        va = vle16_v_u16m1(A + i, chunk);\n        vb = vle16_v_u16m1(B + i, chunk);\n\n        if (i == midpoint) {\n            vc = va;\n        } else if (i < midpoint) {\n            vc = vxor_vv_u16m1(va, vb, chunk);\n        } else {\n            vc = vand_vv_u16m1(va, vb, chunk);\n        }\n\n        vse16_v_u16m1(C + i, vc, chunk);\n    }\n}\n```"}
{"task_id": "SimdBench_44_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t vlmax = vsetvl_e16m1(length);\n    size_t midpoint = length / 2;\n    size_t i = 0;\n\n    // Process elements before the midpoint: XOR operation\n    for (; i < midpoint; i += vlmax) {\n        size_t vl = vsetvl_e16m1(vlmin(vlmax, (midpoint - i)));\n        vuint16m1_t va = vle16_v_u16m1(A + i, vl);\n        vuint16m1_t vb = vle16_v_u16m1(B + i, vl);\n        vuint16m1_t vc = vxor_vv_u16m1(va, vb, vl);\n        vse16_v_u16m1(C + i, vc, vl);\n    }\n\n    // Process the element at the midpoint: keep value from A\n    if (length % 2 != 0) {\n        C[midpoint] = A[midpoint];\n        midpoint += 1;\n    } else {\n        C[midpoint - 1] = A[midpoint - 1];\n    }\n\n    // Process elements after the midpoint: AND operation\n    for (; midpoint < length; midpoint += vlmax) {\n        size_t vl = vsetvl_e16m1(vlmin(vlmax, (length - midpoint)));\n        vuint16m1_t va = vle16_v_u16m1(A + midpoint, vl);\n        vuint16m1_t vb = vle16_v_u16m1(B + midpoint, vl);\n        vuint16m1_t vc = vand_vv_u16m1(va, vb, vl);\n        vse16_v_u16m1(C + midpoint, vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_44_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t vl = vsetvl_e16m1(length);\n\n    vuint16m1_t va, vb, vc;\n\n    for (size_t i = 0; i < midpoint; i += vl) {\n        size_t chunk_size = (midpoint - i) < vl ? (midpoint - i) : vl;\n        vl = vsetvl_e16m1(chunk_size);\n        va = vle16_v_u16m1(A + i, vl);\n        vb = vle16_v_u16m1(B + i, vl);\n        vc = vxor_vv_u16m1(va, vb, vl);\n        vse16_v_u16m1(C + i, vc, vl);\n    }\n\n    size_t i = midpoint;\n    vl = vsetvl_e16m1(1);\n    vc = vle16_v_u16m1(A + i, vl);\n    vse16_v_u16m1(C + i, vc, vl);\n\n    i += 1;\n    for (; i < length; i += vl) {\n        size_t chunk_size = (length - i) < vl ? (length - i) : vl;\n        vl = vsetvl_e16m1(chunk_size);\n        va = vle16_v_u16m1(A + i, vl);\n        vb = vle16_v_u16m1(B + i, vl);\n        vc = vand_vv_u16m1(va, vb, vl);\n        vse16_v_u16m1(C + i, vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_45_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vlmax = vsetvl_e32m1(0);\n    size_t vl;\n    for (size_t i = 0; i < total_size; i += vlmax) {\n        vl = vsetvl_e32m1(total_size - i);\n        vfloat32m1_t va = vle32_v_f32m1(A + i, vl);\n        vfloat32m1_t vb = vle32_v_f32m1(B + i, vl);\n        vfloat32m1_t vc = vle32_v_f32m1(C + i, vl);\n        vfloat32m1_t vd = vle32_v_f32m1(D + i, vl);\n\n        vbool8_t vcond1 = vmv_v_x_b8(*(const uint8_t*)(cond1 + i), vl);\n        vbool8_t vcond2 = vmv_v_x_b8(*(const uint8_t*)(cond2 + i), vl);\n\n        vfloat32m1_t vout = vmfgt_vv_f32m1(vcond1, vcond2, vl); // Placeholder for complex condition logic\n        vout = vfmerge_vvm_f32m1(vout, va, vcond1 & vcond2, vl);\n        vout = vfmerge_vvm_f32m1(vout, vb, vcond1 & ~vcond2, vl);\n        vout = vfmerge_vvm_f32m1(vout, vc, ~vcond1 & vcond2, vl);\n        vout = vfmerge_vvm_f32m1(vout, vd, ~vcond1 & ~vcond2, vl);\n\n        vse32_v_f32m1(out + i, vout, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_45_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vlmax = vsetvl_e32m1(total_size);\n    \n    for (size_t i = 0; i < total_size; i += vlmax) {\n        size_t vl = vsetvl_e32m1(total_size - i);\n\n        vfloat32m1_t va = vle32_v_f32m1(A + i, vl);\n        vfloat32m1_t vb = vle32_v_f32m1(B + i, vl);\n        vfloat32m1_t vc = vle32_v_f32m1(C + i, vl);\n        vfloat32m1_t vd = vle32_v_f32m1(D + i, vl);\n\n        vbool8_t vcond1 = vmv_v_x_b8((uint8_t)(cond1[i]), vl);\n        vbool8_t vcond2 = vmv_v_x_b8((uint8_t)(cond2[i]), vl);\n\n        vfloat32m1_t vout = vmERGE3_vfmf32m1(va, vb, vc, vd, vcond1, vcond2, vl);\n\n        vse32_v_f32m1(out + i, vout, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_45_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vlmax = vsetvl_e32m1(total_size);\n\n    for (size_t i = 0; i < total_size; i += vlmax) {\n        size_t vl = vsetvl_e32m1(total_size - i);\n        vfloat32m1_t va = vle32_v_f32m1(A + i, vl);\n        vfloat32m1_t vb = vle32_v_f32m1(B + i, vl);\n        vfloat32m1_t vc = vle32_v_f32m1(C + i, vl);\n        vfloat32m1_t vd = vle32_v_f32m1(D + i, vl);\n\n        vbool8_t vcond1 = vmv_v_x_b8((uint8_t)(cond1[i]), vl);\n        vbool8_t vcond2 = vmv_v_x_b8((uint8_t)(cond2[i]), vl);\n\n        vfloat32m1_t vout = vmfgt_vv_f32m1_b8(vcond1 & vcond2, va, vb, vl);\n        vout = vmfle_vv_f32m1_b8(vcond1 & (~vcond2), vb, vout, vl);\n        vout = vmfle_vv_f32m1_b8((~vcond1) & vcond2, vc, vout, vl);\n        vout = vmfle_vv_f32m1_b8((~vcond1) & (~vcond2), vd, vout, vl);\n\n        vse32_v_f32m1(out + i, vout, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_45_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vlmax = vsetvl_e32m1(0);\n\n    for (size_t i = 0; i < total_size; i += vlmax) {\n        size_t vl = vsetvl_e32m1(total_size - i);\n\n        vfloat32m1_t va = vle32_v_f32m1(A + i, vl);\n        vfloat32m1_t vb = vle32_v_f32m1(B + i, vl);\n        vfloat32m1_t vc = vle32_v_f32m1(C + i, vl);\n        vfloat32m1_t vd = vle32_v_f32m1(D + i, vl);\n\n        vbool8_t vcond1 = vmv_v_x_b8((int)cond1[i], vl);\n        vbool8_t vcond2 = vmv_v_x_b8((int)cond2[i], vl);\n\n        vfloat32m1_t vout = vmfclass_vf_f32m1(vcond1 & vcond2, va, vl);\n        vout = vor_vv_f32m1(vout, vmfclass_vf_f32m1(vcond1 & ~vcond2, vb, vl), vl);\n        vout = vor_vv_f32m1(vout, vmfclass_vf_f32m1(~vcond1 & vcond2, vc, vl), vl);\n        vout = vor_vv_f32m1(vout, vmfclass_vf_f32m1(~vcond1 & ~vcond2, vd, vl), vl);\n\n        vse32_v_f32m1(out + i, vout, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_45_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vlmax = vsetvl_e32m1(0);\n    size_t i = 0;\n\n    for (; i <= total_size - vlmax; i += vlmax) {\n        size_t vl = vsetvl_e32m1(vlmax);\n\n        vbool32_t vm_cond1 = vmv_v_x_b32(vl, (int)*(cond1 + i));\n        vbool32_t vm_cond2 = vmv_v_x_b32(vl, (int)*(cond2 + i));\n\n        vfloat32m1_t va = vle32_v_f32m1(A + i, vl);\n        vfloat32m1_t vb = vle32_v_f32m1(B + i, vl);\n        vfloat32m1_t vc = vle32_v_f32m1(C + i, vl);\n        vfloat32m1_t vd = vle32_v_f32m1(D + i, vl);\n\n        vfloat32m1_t vout = vmfclass_vf_f32m1(vd, 0.0f, vl); // Initialize with D\n\n        vout = vfredosum_vs_f32m1_f32m1(vout, va, vm_and(vm_cond1, vm_cond2), vl); // cond1 && cond2 -> A\n        vout = vfredosum_vs_f32m1_f32m1(vout, vb, vm_and(vm_cond1, vm_not(vm_cond2)), vl); // cond1 && !cond2 -> B\n        vout = vfredosum_vs_f32m1_f32m1(vout, vc, vm_and(vm_not(vm_cond1), vm_cond2), vl); // !cond1 && cond2 -> C\n\n        vse32_v_f32m1(out + i, vout, vl);\n    }\n\n    for (; i < total_size; i++) {\n        if (*(cond1 + i) && *(cond2 + i)) {\n            *(out + i) = *(A + i);\n        } else if (*(cond1 + i) && !(*(cond2 + i))) {\n            *(out + i) = *(B + i);\n        } else if (!(*(cond1 + i)) && *(cond2 + i)) {\n            *(out + i) = *(C + i);\n        } else {\n            *(out + i) = *(D + i);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_46_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vlmax = vsetvl_e32m1(0);\n    size_t i = 0;\n\n    for (; i <= total_size - vlmax; i += vlmax) {\n        vuint32m1_t va = vle32_v_u32m1(A + i, vlmax);\n        vuint32m1_t vb = __builtin_riscv_clz_v_u32m1(va, vlmax);\n        vuint32m1_t vc = __builtin_riscv_ctz_v_u32m1(va, vlmax);\n        vuint8m1_t vd = vadd_vx_u8m1(vslide1up_vx_u8m1(vctpop_v_u32m1(va, vlmax), 0, vlmax), 0, vlmax);\n        vse8_v_u8m1(out + i, vd, vlmax);\n    }\n\n    size_t vl = vsetvl_e32m1(total_size - i);\n    if (i < total_size) {\n        vuint32m1_t va = vle32_v_u32m1(A + i, vl);\n        vuint32m1_t vb = __builtin_riscv_clz_v_u32m1(va, vl);\n        vuint32m1_t vc = __builtin_riscv_ctz_v_u32m1(va, vl);\n        vuint8m1_t vd = vadd_vx_u8m1(vslide1up_vx_u8m1(vctpop_v_u32m1(va, vl), 0, vl), 0, vl);\n        vse8_v_u8m1(out + i, vd, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_46_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vlmax = vsetvl_e32m1(0);\n    size_t i = 0;\n\n    for (; i <= total_size - vlmax; i += vlmax) {\n        vuint32m1_t va = vle32_v_u32m1(A + i, vlmax);\n        vuint8m1_t vres = vmcntx_u_b_u32m1_u8m1(va, vlmax);\n        vse8_v_u8m1(out + i, vres, vlmax);\n    }\n\n    if (i < total_size) {\n        size_t vl = vsetvl_e32m1(total_size - i);\n        vuint32m1_t va = vle32_v_u32m1(A + i, vl);\n        vuint8m1_t vres = vmcntx_u_b_u32m1_u8m1(va, vl);\n        vse8_v_u8m1(out + i, vres, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_46_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vlmax = vsetvl_e32m1(total_size);\n    for (size_t i = 0; i < total_size; i += vlmax) {\n        size_t vl = vsetvl_e32m1(total_size - i);\n        vuint32m1_t va = vle32_v_u32m1(A + i, vl);\n        vuint32m1_t vb = __builtin_riscv_vpopc_u32m1(va, vl);\n        vuint8m1_t vc = vfwredsum_vs_u32m1_u8m1(vb, vb, vl);\n        vse8_v_u8m1(out + i, vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_46_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vlmax = vsetvl_e32m1(1);\n    size_t vl;\n\n    for (size_t i = 0; i < total_size; i += vlmax) {\n        vl = vsetvl_e32m1(total_size - i);\n        vuint32m1_t vmask = vle32_v_u32m1(A + i, vl);\n        vuint32m1_t vpopc = __riscv_vpopc(vmask, vl);\n        vuint8m1_t vresult = vreinterpret_v_u8m1_u32m1(vpopc);\n        vsb8_v_u8m1(out + i, vresult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_46_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vlmax = vsetvl_e32m4(1);\n    size_t vl;\n    for (size_t i = 0; i < total_size; i += vlmax) {\n        vl = vsetvl_e32m4(total_size - i);\n        vuint32m4_t va = vle32_v_u32m4(A + i, vl);\n        vuint8m1_t vres = vmcntx_b_u32_m(vttrue_bf16(), va, vl);\n        vse8_v_u8m1(out + i, vres, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_47_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t vlmax = vlenb() / sizeof(int);\n    size_t i = 0;\n\n    for (; i <= total_elements - vlmax; i += vlmax) {\n        vint32m8_t va = vlseg1_load_v_i32m8(A + i, vlmax);\n        vbool4_t cond = vmseq_vv_i32_b4(va, vmul_vx_i32_v(va, 3, vlmax), vlmax);\n        vint32m8_t abs_val = vabs_v_i32m8(va, vlmax);\n        vint32m8_t result = vselect_vvm_i32m8(cond, abs_val, va, vlmax);\n        vsseg1_store_v_i32m8(B + i, result, vlmax);\n    }\n\n    // Handle remaining elements with scalar code\n    for (; i < total_elements; i++) {\n        if (A[i] % 3 == 0) {\n            B[i] = abs(A[i]);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t vlmax = vsetvl_e32m1(0);\n\n    for (size_t i = 0; i < total_elements; i += vlmax) {\n        size_t vl = vsetvl_e32m1(total_elements - i);\n        vint32m1_t va = vle32_v_i32m1(A + i, vl);\n        vbool32_t cond = vmseq_vv_i32_b32m1(va, vrem_vx_i32m1(va, 3, vl), vl);\n        vint32m1_t abs_val = vabs_v_i32m1(va, vl);\n        vint32m1_t result = vmux_vvm_i32m1(abs_val, va, cond, vl);\n        vse32_v_i32m1(B + i, result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_47_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t vlmax = vlenb() / sizeof(int);\n\n    for (size_t i = 0; i < total_elements; i += vlmax) {\n        size_t vl = vsetvl_e32m1(vlmax > (total_elements - i) ? (total_elements - i) : vlmax);\n        \n        vint32m1_t va = vle32_v_i32m1(A + i, vl);\n        vbool32_t cond = vmseq_vx_i32m1_b32m1(va, 0, vl) | (vmsne_vx_i32m1_b32m1(va, 0, vl) & (vmule_vx_i32m1_b32m1(va, 3, vl)));\n        vint32m1_t abs_a = vabsu_v_i32m1(va, vl);\n        vint32m1_t vb = vmux_vvm_i32m1(abs_a, va, cond, vl);\n        \n        vse32_v_i32m1(B + i, vb, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_47_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t vlmax = vsetvl_e32m1(total_elements);\n\n    for (size_t i = 0; i < total_elements; i += vlmax) {\n        size_t vl = vsetvl_e32m1(total_elements - i);\n        vint32m1_t va = vle32_v_i32m1(A + i, vl);\n        vbool32_t cond = vmseq_vx_i32m1_b32(va, 0, vl); // Check if divisible by 3\n        vint32m1_t abs_val = vabsu_v_i32m1(va, vl);\n        vint32m1_t result = vmux_vvm(abs_val, va, cond, vl);\n        vse32_v_i32m1(B + i, result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_47_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t vlmax = vlenb() / sizeof(int);\n\n    for (size_t i = 0; i < total_elements; i += vlmax) {\n        size_t vl = vsetvl_e32m1(vlmax > (total_elements - i) ? (total_elements - i) : vlmax);\n        vint32m1_t va = vle32_v_i32m1(A + i, vl);\n        vbool32_t cond = vmseq_vx_i32m1_b32m1(va, 0, vl); // Initialize to false\n        cond = vorv_b32m1(cond, vmseq_vx_i32m1_b32m1(vmod_vx_i32m1(va, 3, vl), 0, vl), vl);\n        vint32m1_t abs_val = vabs_v_i32m1(va, vl);\n        vint32m1_t result = vselect_vvm_i32m1(cond, abs_val, va, vl);\n        vse32_v_i32m1(B + i, result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_48_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    size_t vl = vsetvl_e32m1(length);\n    vuint32m1_t vs = vle32_v_u32m1(src, vl);\n    vuint32m1_t vd;\n    vuint32m1_t cond = vmseq_vx_u32m1_b32(vs, 0xF, vl);\n    vuint32m1_t rotated = vror_vx_u32m1(vs, rotate_bits, vl);\n    vuint32m1_t negated = vxor_vv_u32m1(vs, vmv_v_x_u32m1(-1, vl), vl);\n    vd = vselect_vm_u32m1(cond, rotated, negated, vl);\n    vse32_v_u32m1(dst, vd, vl);\n}\n```"}
{"task_id": "SimdBench_48_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    size_t vl = vsetvl_e32m1(length);\n    vuint32m1_t v_src = vlload_e32m1(src, vl);\n    vuint32m1_t v_dst;\n    vuint32m1_t v_mask = vmseq_vu32m1_u32m1(vand_vv_u32m1(v_src, 0xF, vl), 0xF, vl);\n    vuint32m1_t v_rotated = vror_vx_u32m1(v_src, rotate_bits, vl);\n    vuint32m1_t v_negated = vxor_vv_u32m1(v_src, -1, vl);\n    v_dst = vmerge_vvm_u32m1(v_rotated, v_negated, v_mask, vl);\n    vlstore_e32m1(dst, v_dst, vl);\n}\n```"}
{"task_id": "SimdBench_48_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    size_t vl = vsetvl_e32m1(length);\n    vuint32m1_t v_src = vlload_e32m1(src, vl);\n    vuint32m1_t v_dst;\n    vuint32m1_t condition = vmseq_vx_u32m1_b32(vand_vx_u32m1(v_src, 0xF, vl), 0xF, vl);\n    vuint32m1_t rotated = vrorx_vx_u32m1(v_src, rotate_bits, vl);\n    vuint32m1_t negated = vxor_vv_u32m1(v_src, vmv_v_x_u32m1(0xFFFFFFFF, vl), vl);\n    v_dst = vselect_vvm_u32m1(condition, rotated, negated, vl);\n    vlstore_e32m1(dst, v_dst, vl);\n}\n```"}
{"task_id": "SimdBench_48_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    size_t vl = vsetvl_e32m1(length);\n    vuint32m1_t v_src = vlload_e32m1(src, vl);\n    vuint32m1_t v_dst;\n    vuint32m1_t v_mask = vmseq_vx_u32m1(vand_vx_u32m1(v_src, 0xF, vl), 0xF, vl);\n    vuint32m1_t v_rotated = vror_vx_u32m1(v_src, rotate_bits, vl);\n    vuint32m1_t v_negated = vxor_vv_u32m1(v_src, vmv_v_x_u32m1(0xFFFFFFFF, vl), vl);\n    v_dst = vmerge_vvm_u32m1(v_rotated, v_negated, v_mask, vl);\n    vlstore_e32m1(dst, v_dst, vl);\n}\n```"}
{"task_id": "SimdBench_48_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    size_t vl = vsetvl_e32m1(length);\n    vuint32m1_t v_src = vlload_e32m1(src, vl);\n    vuint32m1_t v_dst;\n    vuint32m1_t v_mask = vmseq_vxu32m1_b32m1(vand_vxu32m1(v_src, 0xF, vl), 0xF, vl);\n    vuint32m1_t v_rotated = vrotr_vxu32m1(v_src, rotate_bits, vl);\n    vuint32m1_t v_negated = vnot_vu32m1(v_src, vl);\n    v_dst = vmerge_vvmu32m1(v_rotated, v_negated, v_mask, vl);\n    vlstore_e32m1(dst, v_dst, vl);\n}\n```"}
{"task_id": "SimdBench_49_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t vlmax = vsetvl_e32m1(length);\n    vfloat32m1_t veps = vmv_v_f_f32m1(fabsf(epsilon), vlmax);\n    size_t i = 0;\n\n    for (; i <= length - vlmax; i += vlmax) {\n        vfloat32m1_t va = vle32_v_f32m1(A + i, vlmax);\n        vfloat32m1_t vb = vle32_v_f32m1(B + i, vlmax);\n\n        vfloat32m1_t vdiff = vfsub_vv_f32m1(va, vb, vlmax);\n        vfloat32m1_t vabsdiff = vfabs_v_f32m1(vdiff, vlmax);\n\n        vbool8_t cond_gt = vmfgt_vf_b8m1(vabsdiff, veps, vlmax);\n        vbool8_t cond_lt = vmflt_vf_b8m1(vabsdiff, veps, vlmax);\n\n        vint8m1_t vone = vmv_v_i_i8m1(1, vlmax);\n        vint8m1_t vnegone = vmv_v_i_i8m1(-1, vlmax);\n\n        vint8m1_t vout = vmfcvt_x_f_i8m1(vdiff, vlmax);\n        vout = vfsgnjx_vv_i8m1(vout, vout, vlmax); // Take absolute value of vout\n        vout = vssrl_vx_i8m1(vout, vmv_v_i_i8m1(31, vlmax), vlmax); // Shift to get sign bit\n\n        vout = vselect_vvm_i8m1(vone, vout, cond_gt, vlmax);\n        vout = vselect_vvm_i8m1(vnegone, vout, vmfne_vv_b8m1(vout, vzero_v_i8m1(vlmax), vlmax), vlmax);\n        vout = vselect_vvm_i8m1(vmv_v_i_i8m1(0, vlmax), vout, cond_lt, vlmax);\n\n        vse8_v_i8m1(out + i, vout, vlmax);\n    }\n\n    for (; i < length; i++) {\n        float diff = A[i] - B[i];\n        if (diff > fabsf(epsilon)) {\n            out[i] = 1;\n        } else if (diff < -fabsf(epsilon)) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t vlmax = vsetvl_e32m1(length);\n    vfloat32m1_t vepsilon = vmv_v_f_f32m1(fabsf(epsilon), vlmax);\n    size_t i = 0;\n\n    for (; i + vlmax <= length; i += vlmax) {\n        vfloat32m1_t va = vle32_v_f32m1(A + i, vlmax);\n        vfloat32m1_t vb = vle32_v_f32m1(B + i, vlmax);\n\n        vfloat32m1_t vdiff = vsub_vv_f32m1(va, vb, vlmax);\n        vfloat32m1_t vabsdiff = vfsgnjx_vv_f32m1(vdiff, vdiff, vlmax);\n\n        vbool32_t mask_gt = vmfgt_vv_f32m1_b32(vdiff, vepsilon, vlmax);\n        vbool32_t mask_lt = vmflt_vv_f32m1_b32(vdiff, vmvneg_v_f32m1(vepsilon, vlmax), vlmax);\n        vbool32_t mask_eq = vmfle_vv_f32m1_b32(vabsdiff, vepsilon, vlmax);\n\n        vint8m1_t vout = vmv_v_x_i8m1(0, vlmax);\n        vout = vfmerge_vfm_i8m1(vout, 1, mask_gt, vlmax);\n        vout = vfmerge_vfm_i8m1(vout, -1, mask_lt, vlmax);\n        vout = vfmerge_vfm_i8m1(vout, 0, mask_eq, vlmax);\n\n        vse8_v_i8m1(out + i, vout, vlmax);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        float diff = A[i] - B[i];\n        if (diff > fabsf(epsilon)) {\n            out[i] = 1;\n        } else if (diff < -fabsf(epsilon)) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t vlmax = vlenb() * 8; // Maximum vector length in elements for float\n    size_t i = 0;\n\n    float abs_epsilon = fabsf(epsilon);\n\n    for (; i <= length - vlmax; i += vlmax) {\n        vfloat32m1_t va = vle32_v_f32m1(&A[i], vlmax);\n        vfloat32m1_t vb = vle32_v_f32m1(&B[i], vlmax);\n        vfloat32m1_t vabs_epsilon = vmv_v_x_f32m1(abs_epsilon, vlmax);\n\n        vfloat32m1_t vdiff = vfsub_vv_f32m1(va, vb, vlmax);\n        vfloat32m1_t vabs_diff = vfabs_v_f32m1(vdiff, vlmax);\n\n        vbool32_t mask_gt = vmfgt_vf_f32m1_b32(vdiff, abs_epsilon, vlmax);\n        vbool32_t mask_lt = vmflt_vf_f32m1(vdiff, -abs_epsilon, vlmax);\n        vbool32_t mask_eq = vmfle_vf_f32m1_b32(vabs_diff, abs_epsilon, vlmax);\n\n        vint8m1_t vout = vmv_v_x_i8m1(0, vlmax);\n        vout = vfredmax_vs_i8m1_i8m1(vout, vmv_v_x_i8m1(1, vlmax), mask_gt, vlmax);\n        vout = vfredmin_vs_i8m1_i8m1(vout, vmv_v_x_i8m1(-1, vlmax), mask_lt, vlmax);\n\n        vse8_v_i8m1(&out[i], vout, vlmax);\n    }\n\n    // Handle remaining elements with scalar code\n    for (; i < length; i++) {\n        float diff = A[i] - B[i];\n        if (diff > abs_epsilon) {\n            out[i] = 1;\n        } else if (diff < -abs_epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t vlmax = vsetvl_e32m1(length);\n    float abs_epsilon = fabsf(epsilon);\n\n    for (size_t i = 0; i < length; i += vlmax) {\n        size_t vl = vsetvl_e32m1(vlmin(vlmax, length - i));\n        \n        vfloat32m1_t va = vle32_v_f32m1(A + i, vl);\n        vfloat32m1_t vb = vle32_v_f32m1(B + i, vl);\n        vfloat32m1_t vabs_epsilon = vmv_v_x_f32m1(abs_epsilon, vl);\n\n        vfloat32m1_t vdiff = vfsub_vv_f32m1(va, vb, vl);\n        vfloat32m1_t vabs_diff = vfabs_v_f32m1(vdiff, vl);\n\n        vbool32_t mask_gt = vmfgt_vf_f32m1_b32(vdiff, abs_epsilon, vl);\n        vbool32_t mask_lt = vmflt_vf_f32m1_b32(vdiff, -abs_epsilon, vl);\n        vbool32_t mask_eq = vmfle_vv_f32m1_b32(vabs_diff, vabs_epsilon, vl);\n\n        vint8m1_t vone = vmv_v_x_i8m1(1, vl);\n        vint8m1_t vminus_one = vmv_v_x_i8m1(-1, vl);\n        vint8m1_t vzero = vmv_v_x_i8m1(0, vl);\n\n        vint8m1_t vout = vmux_vvm_i8m1(vone, mask_gt, vzero, vl);\n        vout = vmux_vvm_i8m1(vminus_one, mask_lt, vout, vl);\n\n        vse8_v_i8m1(out + i, vout, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_49_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t vlmax = vsetvl_e32m1(length);\n    vfloat32m1_t vepsilon = vmv_v_f_f32m1(fabsf(epsilon), vlmax);\n    size_t i = 0;\n\n    for (; i + vlmax <= length; i += vlmax) {\n        vfloat32m1_t va = vle32_v_f32m1(A + i, vlmax);\n        vfloat32m1_t vb = vle32_v_f32m1(B + i, vlmax);\n\n        vfloat32m1_t vdiff = vfsub_vv_f32m1(va, vb, vlmax);\n        vfloat32m1_t vabsdiff = vfsgnjx_vv_f32m1(vdiff, vdiff, vlmax);\n\n        vbool32m1_t mask_gt = vmfgt_vv_f32m1_b32m1(vdiff, vepsilon, vlmax);\n        vbool32m1_t mask_lt = vmflt_vv_f32m1_b32m1(vdiff, vmvneg_vf_f32m1(vepsilon, vlmax), vlmax);\n        vbool32m1_t mask_eq = vmfeq_vv_f32m1_b32m1(vabsdiff, vepsilon, vlmax);\n\n        vint8m1_t vout = vmv_v_x_i8m1(0, vlmax);\n        vout = vfmerge_vfm_i8m1(vout, 1, mask_gt, vlmax);\n        vout = vfmerge_vfm_i8m1(vout, -1, mask_lt, vlmax);\n        vout = vfmerge_vfm_i8m1(vout, 0, mask_eq, vlmax);\n\n        vse8_v_i8m1(out + i, vout, vlmax);\n    }\n\n    for (; i < length; i++) {\n        float diff = A[i] - B[i];\n        if (diff > fabsf(epsilon)) {\n            out[i] = 1;\n        } else if (diff < -fabsf(epsilon)) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <limits.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t vlmax = vsetvl_e32m1(size);\n    vfloat32m1_t v_f32;\n    vint32m1_t v_i32, v_i32_min, v_i32_max;\n    v_i32_min = vmv_v_x_i32m1(INT32_MIN, vlmax);\n    v_i32_max = vmv_v_x_i32m1(INT32_MAX, vlmax);\n\n    for (size_t i = 0; i < size; i += vlmax) {\n        size_t vl = vsetvl_e32m1(size - i);\n        v_f32 = vle32_v_f32m1(&A[i], vl);\n        v_i32 = vfncvt_xu_f_w_i32m1(v_f32, vl);\n        v_i32 = vwredmax_vs_i32m1_i32m1(v_i32, v_i32_max, vl);\n        v_i32 = vwredmin_vs_i32m1_i32m1(v_i32, v_i32_min, vl);\n        vse32_v_i32m1(&B[i], v_i32, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_50_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <limits.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t vlmax = vsetvl_e32m1(size);\n    for (size_t i = 0; i < size; i += vlmax) {\n        size_t vl = vsetvl_e32m1(vlmax > (size - i) ? (size - i) : vlmax);\n        vfloat32m1_t v_a = vle32_v_f32m1(A + i, vl);\n        vint32m1_t v_b = vfncvt_x_x_w_i32m1(v_a, vl);\n        vint32m1_t v_clamp = vrndclip_wx_i32m1(v_b, vl);\n        vsseg1eiv32_v_i32m1(B + i, v_clamp, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_50_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <limits.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t vlmax = vlenb() / sizeof(float);\n    size_t i = 0;\n\n    for (; i + vlmax <= size; i += vlmax) {\n        vfloat32m1_t vf_a = vlseg1ff_float32_v_f32m1(&A[i], vlmax);\n        vint32m1_t vi_b = vfwcvt_xu_f_w_i32m1_v_f32m1(vf_a, vlmax);\n        vi_b = vfclipi_wx_i32m1_v_i32m1(vi_b, INT32_MIN, INT32_MAX, vlmax);\n        vsseg1ff_int32_v_i32m1(&B[i], vi_b, vlmax);\n    }\n\n    if (i < size) {\n        size_t vl = size - i;\n        vfloat32m1_t vf_a = vlseg1ff_float32_v_f32m1(&A[i], vl);\n        vint32m1_t vi_b = vfwcvt_xu_f_w_i32m1_v_f32m1(vf_a, vl);\n        vi_b = vfclipi_wx_i32m1_v_i32m1(vi_b, INT32_MIN, INT32_MAX, vl);\n        vsseg1ff_int32_v_i32m1(&B[i], vi_b, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_50_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <limits.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t vlmax = vsetvl_e32m1(size);\n    size_t vl;\n    const float *src = A;\n    int32_t *dst = B;\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n        vfloat32m1_t v_a = vle32_v_f32m1(src + i, vl);\n        vint32m1_t v_b = vfncvt_x_x_w_f32m1(v_a, vl);\n        vint32m1_t v_clamped = vclip_i32m1(v_b, INT32_MAX, INT32_MIN, vl);\n        vsseg1e32_v_i32m1(dst + i, v_clamped, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_50_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <limits.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t vlmax = vlenb() / sizeof(float);\n    size_t i = 0;\n\n    while (i < size) {\n        size_t vl = vsetvl_e32m1(vlmax > (size - i) ? (size - i) : vlmax);\n\n        vfloat32m1_t vf_a = vle32_v_f32m1(A + i, vl);\n\n        vint32m1_t vi_result = vfncvt_xu_w_f_x_v_i32m1(vf_a, vl);\n\n        vint32m1_t vi_clamp_min = vmv_v_x_i32m1(INT32_MIN, vl);\n        vint32m1_t vi_clamp_max = vmv_v_x_i32m1(INT32_MAX, vl);\n\n        vi_result = vclip_i32m1(vi_result, vl);\n\n        vi_result = vfncvt_x_f_w_f_i32m1(vf_a, vl);\n\n        vi_result = vmsge_vx_i32m1_b1(vi_result, INT32_MAX, vl) ? vi_clamp_max : vi_result;\n        vi_result = vmsle_vx_i32m1_b1(vi_result, INT32_MIN, vl) ? vi_clamp_min : vi_result;\n\n        vse32_v_i32m1(B + i, vi_result, vl);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_51_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t vlmax = vsetvl_e32m1(size);\n    for (size_t i = 0; i < size; i += vlmax) {\n        size_t vl = vsetvl_e32m1(size - i);\n        vint32m1_t v_a = vle32_v_i32m1(A + i, vl);\n        vfloat32m1_t v_scale = vmv_v_x_f32m1((float)scale, vl);\n        vfloat32m1_t v_result = vfwmul_vf_f32m1(vse32_v_f32m1(v_a, vl), (float)scale, vl);\n        vse32_v_f32m1(B + i, v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_51_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t vlmax = vsetvl_e32m1(size);\n    for (size_t i = 0; i < size; i += vlmax) {\n        size_t vl = vsetvl_e32m1(size - i);\n        vint32m1_t v_a = vle32_v_i32m1(A + i, vl);\n        vfloat32m1_t v_scale_f = vfmul_vf_f32m1(vfcvt_f_x_v_f32m1(v_a, vl), (float)scale, vl);\n        vse32_v_f32m1(B + i, v_scale_f, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_51_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t vlmax = vsetvl_e32m1(size);\n    for (size_t i = 0; i < size; i += vlmax) {\n        size_t vl = vsetvl_e32m1(size - i);\n        vint32m1_t v_a = vle32_v_i32m1(A + i, vl);\n        vfloat32m1_t v_scale_f = vfreinterpret_v_f32m1(vfncvt_x_f_w_f32m1(vmv_v_x_i32m1(scale, vl), vl));\n        vfloat32m1_t v_b = vfmul_vf_f32m1(vfwcvt_f_x_f32m1(v_a, vl), v_scale_f, vl);\n        vse32_v_f32m1(B + i, v_b, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_51_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t vlmax = vsetvl_e32m1(size);\n    for (size_t i = 0; i < size; i += vlmax) {\n        size_t vl = vsetvl_e32m1(size - i);\n        vint32m1_t vscale = vmv_v_x_i32m1(scale, vl);\n        vint32m1_t va = vle32_v_i32m1((const int32_t*)&A[i], vl);\n        vfloat32m1_t vfa = vfwcvt_f_x_v_f32m1(va, vl);\n        vfloat32m1_t vfresult = vfmul_vf_f32m1(vfa, vscale, vl);\n        vse32_v_f32m1((float*)&B[i], vfresult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_51_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t vlmax = vsetvl_e32m1(size);\n    vfloat32m1_t vscale = vmv_v_x_f32m1((float)scale, vlmax);\n    for (size_t i = 0; i < size; i += vlmax) {\n        size_t vl = vsetvl_e32m1(size - i);\n        vint32m1_t va = vle32_v_i32m1(A + i, vl);\n        vfloat32m1_t vf = vfcvt_f_x_v_f32m1(va, vl);\n        vfloat32m1_t vb = vmul_vv_f32m1(vf, vscale, vl);\n        vse32_v_f32m1(B + i, vb, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_52_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t vlmax = vsetvl_e32m1(size);\n    size_t i = 0;\n    for (; i + vlmax <= size; i += vlmax) {\n        vfloat32m1_t va = vle32_v_f32m1(A + i, vlmax);\n        vfloat32m1_t vb = vle32_v_f32m1(B + i, vlmax);\n        vfloat32m1_t vd = vfdiv_vv_f32m1(va, vb, vlmax);\n        vint32m1_t vr = vrndu_v_i32m1_f32m1(vd, vlmax);\n        vse32_v_i32m1(C + i, vr, vlmax);\n    }\n    if (i < size) {\n        size_t vl = vsetvl_e32m1(size - i);\n        vfloat32m1_t va = vle32_v_f32m1(A + i, vl);\n        vfloat32m1_t vb = vle32_v_f32m1(B + i, vl);\n        vfloat32m1_t vd = vfdiv_vv_f32m1(va, vb, vl);\n        vint32m1_t vr = vrndu_v_i32m1_f32m1(vd, vl);\n        vse32_v_i32m1(C + i, vr, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_52_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t vlmax = vsetvl_e32m1(size);\n    for (size_t i = 0; i < size; i += vlmax) {\n        size_t vl = vsetvl_e32m1(size - i);\n        vfloat32m1_t va = vle32_v_f32m1(A + i, vl);\n        vfloat32m1_t vb = vle32_v_f32m1(B + i, vl);\n        vfloat32m1_t vd = vfdiv_vv_f32m1(va, vb, vl);\n        vint32m1_t vr = vrndu_w_f32m1_i32m1(vd, vl);\n        vse32_v_i32m1(C + i, vr, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_52_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t vlmax = vsetvl_e32m1(size);\n    for (size_t i = 0; i < size; i += vlmax) {\n        size_t vl = vsetvl_e32m1(size - i);\n        vfloat32m1_t va = vle32_v_f32m1(A + i, vl);\n        vfloat32m1_t vb = vle32_v_f32m1(B + i, vl);\n        vfloat32m1_t vd = vfdiv_vv_f32m1(va, vb, vl);\n        vint32m1_t vc = vrndtos_wx_i32m1_f32m1(vd, vl);\n        vse32_v_i32m1(C + i, vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_52_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t vlmax = vsetvl_e32m1(size);\n    for (size_t i = 0; i < size; i += vlmax) {\n        size_t vl = vsetvl_e32m1(size - i);\n        vfloat32m1_t va = vle32_v_f32m1(A + i, vl);\n        vfloat32m1_t vb = vle32_v_f32m1(B + i, vl);\n        vfloat32m1_t vd = vfdiv_vv_f32m1(va, vb, vl);\n        vint32m1_t vc = vrndu_w_f32m1_i32m1(vd, vl);\n        vse32_v_i32m1(C + i, vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_52_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t vlmax = vsetvl_e32m1(size);\n    for (size_t i = 0; i < size; i += vlmax) {\n        size_t vl = vsetvl_e32m1(size - i);\n        vfloat32m1_t va = vle32_v_f32m1(A + i, vl);\n        vfloat32m1_t vb = vle32_v_f32m1(B + i, vl);\n        vfloat32m1_t vd = vfdiv_vv_f32m1(va, vb, vl);\n        vint32m1_t vr = vrndu_w_f32m1_i32m1(vd, vl);\n        vse32_v_i32m1(C + i, vr, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_53_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t vlmax = vsetvl_e64m1(size);\n    size_t i = 0;\n\n    for (; i < size; i += vlmax) {\n        vlmax = vsetvl_e64m1(size - i);\n        vfloat64m1_t vd = vle64_v_f64m1(&A[i], vlmax);\n        vfloat32m1_t vf = (vfloat32m1_t)vfncvt_xu_f_w_f32m1(vd, vlmax);\n\n        // Create masks for values greater than FLT_MAX and less than -FLT_MAX\n        vfloat32m1_t vmax = vmv_v_x_f32m1(FLT_MAX, vlmax);\n        vfloat32m1_t vmin = vmv_v_x_f32m1(-FLT_MAX, vlmax);\n\n        vbool8_t mask_gt = vfredosum_mask_f64m1_b8(vfsgt_vf_f32m1_m(vf, FLT_MAX, vlmax), vlmax);\n        vbool8_t mask_lt = vfredosum_mask_f64m1_b8(vfslt_vf_f32m1_m(vf, -FLT_MAX, vlmax), vlmax);\n\n        vf = vfcvt_rtz_x_f_w_f32m1(vd, vlmax);\n        vf = vfmerge_vfm_f32m1(vmax, vf, mask_gt, vlmax);\n        vf = vfmerge_vfm_f32m1(vmin, vf, mask_lt, vlmax);\n\n        vse32_v_f32m1(&B[i], vf, vlmax);\n    }\n}\n```"}
{"task_id": "SimdBench_53_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t vlmax = vsetvl_e64m1(size);\n    vfloat64m1_t vd;\n    vfloat32m2_t vf;\n    size_t i = 0;\n\n    float FLT_MAX_f = FLT_MAX;\n    float FLT_MIN_f = -FLT_MAX;\n\n    vfloat32m2_t v_FLT_MAX = vmv_v_x_f32m2(FLT_MAX_f, vlmax);\n    vfloat32m2_t v_FLT_MIN = vmv_v_x_f32m2(FLT_MIN_f, vlmax);\n\n    for (; i < size; i += vlmax) {\n        size_t vl = vsetvl_e64m1(size - i);\n        vd = vle64_v_f64m1(A + i, vl);\n        vf = vfcvt_rtz_x_f_v_f32m2_f64m1(vd, vl);\n        vf = vfclip_vf_f32m2(vf, FLT_MAX_f, FLT_MIN_f, vl);\n        vse32_v_f32m2(B + i, vf, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_53_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t vlmax = vsetvl_e64m1(size);\n    for (size_t i = 0; i < size; i += vlmax) {\n        size_t vl = vsetvl_e64m1(size - i);\n        vfloat64m1_t vd = vle64_v_f64m1(&A[i], vl);\n        vfloat32m2_t vf = (vfloat32m2_t)vfncvt_xu_f_w_f32m2(vfclip_f_f_w_f32m2((vfloat32m2_t)vd, FLT_MAX, -FLT_MAX, _RDM_NEARESTUP, vl), vl);\n        vse32_v_f32m2(&B[i], vf, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_53_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t vlmax = vsetvl_e64m1(size);\n    size_t i = 0;\n\n    for (; i < size; i += vlmax) {\n        size_t vl = vsetvl_e64m1(size - i);\n\n        vfloat64m1_t vd = vldup_v_f64m1(A + i, vl);\n        vfloat32m2_t vf = (vfloat32m2_t)vfncvt_xu_f_w_f32m2(vd, vl);\n\n        vfloat32m2_t vmax = vmv_v_f_f32m2(FLT_MAX, vl);\n        vfloat32m2_t vmin = vmv_v_f_f32m2(-FLT_MAX, vl);\n\n        vf = vfredmax_tf_f32m2(vf, vmax, vl);\n        vf = vfredmin_tf_f32m2(vf, vmin, vl);\n\n        vse32_v_f32m2(B + i, vf, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_53_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <float.h>\n#include <math.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t vlmax = vsetvl_e64m1(size);\n    vfloat64m1_t v_A;\n    vfloat32m2_t v_B;\n    vfloat32m2_t v_FLT_MAX = vmv_v_f_f32m2(FLT_MAX);\n    vfloat32m2_t v_neg_FLT_MAX = vmv_v_f_f32m2(-FLT_MAX);\n\n    size_t i = 0;\n    for (; i + vlmax <= size; i += vlmax) {\n        v_A = vle64_v_f64m1(&A[i], vlmax);\n        v_B = vfncvt_xu_f_w_f32m2_f64m1(v_A, vlmax); // Convert to float with saturation\n\n        // Create masks for values greater than FLT_MAX and less than -FLT_MAX\n        vbool32_t mask_gt = vmf_class_m_f64m1_b32(v_A, VMF_CLASS_POS_INF, vlmax);\n        vbool32_t mask_lt = vmf_class_m_f64m1_b32(v_A, VMF_CLASS_NEG_INF, vlmax);\n\n        // Apply saturation\n        v_B = vfredmax_mask_f32m2_f32m2(v_B, v_FLT_MAX, mask_gt, vlmax);\n        v_B = vfredmin_mask_f32m2_f32m2(v_B, v_neg_FLT_MAX, mask_lt, vlmax);\n\n        vse32_v_f32m2(&B[i], v_B, vlmax);\n    }\n\n    // Handle leftover elements\n    vlmax = vsetvl_e64m1(size - i);\n    if (i < size) {\n        v_A = vle64_v_f64m1(&A[i], vlmax);\n        v_B = vfncvt_xu_f_w_f32m2_f64m1(v_A, vlmax); // Convert to float with saturation\n\n        // Create masks for values greater than FLT_MAX and less than -FLT_MAX\n        vbool32_t mask_gt = vmf_class_m_f64m1_b32(v_A, VMF_CLASS_POS_INF, vlmax);\n        vbool32_t mask_lt = vmf_class_m_f64m1_b32(v_A, VMF_CLASS_NEG_INF, vlmax);\n\n        // Apply saturation\n        v_B = vfredmax_mask_f32m2_f32m2(v_B, v_FLT_MAX, mask_gt, vlmax);\n        v_B = vfredmin_mask_f32m2_f32m2(v_B, v_neg_FLT_MAX, mask_lt, vlmax);\n\n        vse32_v_f32m2(&B[i], v_B, vlmax);\n    }\n}\n```"}
{"task_id": "SimdBench_54_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t vlmax = vlenb() / sizeof(int32_t);\n    size_t i = 0;\n    for (; i <= size - vlmax; i += vlmax) {\n        vint16m2_t va = vmv_v_x_i16m2(0, vlmax);\n        va = vle16_v_i16m2(A + i, vlmax);\n        vint32m4_t vb = vsext_vf2_i32m4(va, vlmax);\n        vse32_v_i32m4(B + i, vb, vlmax);\n    }\n    // Handle remaining elements with scalar code\n    for (; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t vlmax = vsetvl_e32m1(size);\n    for (size_t i = 0; i < size; i += vlmax) {\n        size_t vl = vsetvl_e32m1(vlmax > (size - i) ? (size - i) : vlmax);\n        vint16m1_t va = vle16_v_i16m1((const int16_t*)&A[i], vl);\n        vint32m1_t vb = vwadd_vx_i32m1_i16m1(va, 0, vl);\n        vse32_v_i32m1((int32_t*)&B[i], vb, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_54_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t vlmax = vsetvl_e32m1(size);\n    for (size_t i = 0; i < size; i += vlmax) {\n        size_t vl = vsetvl_e32m1(vlmin(vlmax, size - i));\n        vint16m2_t vm_a = vle16_v_i16m2(A + i, vl);\n        vint32m1_t vm_b = vwadd.vx_i32m1_i16m2(0, vm_a, vl);\n        vsseg1e32_v_i32m1(B + i, vm_b, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_54_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t vlmax = vsetvl_e32m1(size);\n    for (size_t i = 0; i < size; i += vlmax) {\n        size_t vl = vsetvl_e32m1(vlmax > (size - i) ? (size - i) : vlmax);\n        vint16m1_t va = vle16_v_i16m1((const int16_t*)&A[i], vl);\n        vint32m1_t vb = vwconvert_x_w_i32m1_i16m1(va, vl);\n        vse32_v_i32m1((int32_t*)&B[i], vb, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_54_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t vlmax = vsetvl_e32m8(size);\n    for (size_t i = 0; i < size; i += vlmax) {\n        size_t vl = vsetvl_e32m8(vlmax > (size - i) ? (size - i) : vlmax);\n        vint16m4_t va = vle16_v_i16m4(A + i, vl);\n        vint32m8_t vb = vwconvert_x_w_i32m8_i16m4(va, vl);\n        vse32_v_i32m8(B + i, vb, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_55_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    size_t vlmax = vsetvl_e32m1(size);\n    for (size_t i = 0; i < size; i += vlmax) {\n        size_t vl = vsetvl_e32m1(size - i);\n        vfloat32m1_t va = vle32_v_f32m1(A + i, vl);\n        vint32m1_t vcontrol = vle32_v_i32m1(control + i, vl);\n        vbool32_t mask = vmgt_vv_i32m1_b32(vcontrol, vcontrol, vl);\n\n        vfloat32m1_t vmin = vmv_v_f_f32m1(min_val, vl);\n        vfloat32m1_t vmax = vmv_v_f_f32m1(max_val, vl);\n        vfloat32m1_t vdiff = vsub_vv_f32m1(va, vmin, vl);\n        vfloat32m1_t vrange = vsub_vv_f32m1(vmax, vmin, vl);\n        vfloat32m1_t vnormalized = vfdiv_vv_f32m1(vdiff, vrange, vl);\n\n        vfloat32m1_t vzero = vmv_v_f_f32m1(0.0f, vl);\n        vfloat32m1_t vone = vmv_v_f_f32m1(1.0f, vl);\n        vnormalized = vfmax_vv_f32m1(vnormalized, vzero, vl);\n        vnormalized = vfmin_vv_f32m1(vnormalized, vone, vl);\n\n        vfloat32m1_t vresult = vmrg_vfm_f32m1(mask, vnormalized, va, vl);\n        vse32_v_f32m1(B + i, vresult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_55_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    size_t vlmax = vsetvl_e32m1(size);\n    size_t i = 0;\n\n    for (; i <= size - vlmax; i += vlmax) {\n        size_t vl = vsetvl_e32m1(vlmax);\n\n        vfloat32m1_t va = vlload_e32m1(A + i, vl);\n        vint32m1_t vcontrol = vlload_e32m1((const int32_t*)(control + i), vl);\n        vfloat32m1_t vmin = vmv_v_f_f32m1(min_val, vl);\n        vfloat32m1_t vmax = vmv_v_f_f32m1(max_val, vl);\n\n        // Create a mask where control > 0\n        vbool32_t mask = vmfgt_vv_i32m1_b32m1(vcontrol, vmv_v_x_i32m1(0, vl), vl);\n\n        // Compute normalization: (A[i] - min_val) / (max_val - min_val)\n        vfloat32m1_t diff = vfsub_vf_f32m1(va, vmin, vl);\n        vfloat32m1_t range = vfsub_vf_f32m1(vmax, vmin, vl);\n        vfloat32m1_t normalized = vfdiv_vv_f32m1(diff, range, vl);\n\n        // Clamp values to [0, 1]\n        vfloat32m1_t zero = vmv_v_f_f32m1(0.0f, vl);\n        vfloat32m1_t one = vmv_v_f_f32m1(1.0f, vl);\n        normalized = vfmax_vv_f32m1(normalized, zero, vl);\n        normalized = vfmin_vv_f32m1(normalized, one, vl);\n\n        // Select between normalized or original based on mask\n        vfloat32m1_t result = vmfclass_vf_f32m1(mask, normalized, va, vl);\n\n        // Store the results\n        vlstore_e32m1(B + i, result, vl);\n    }\n\n    // Handle leftover elements with scalar code\n    for (; i < size; i++) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            B[i] = (val < 0.0f) ? 0.0f : ((val > 1.0f) ? 1.0f : val);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    size_t vlmax = vsetvl_e32m1(size);\n    size_t i = 0;\n\n    for (; i <= size - vlmax; i += vlmax) {\n        size_t vl = vsetvl_e32m1(vlmax);\n\n        vfloat32m1_t va = vle32_v_f32m1(&A[i], vl);\n        vint32m1_t vcontrol = vle32_v_i32m1(&control[i], vl);\n        vbool32_t mask = vmflt_vx_i32m1_b32(vcontrol, 0, vl);\n\n        vfloat32m1_t vmin_val = vmv_v_x_f32m1(min_val, vl);\n        vfloat32m1_t vmax_val = vmv_v_x_f32m1(max_val, vl);\n\n        vfloat32m1_t diff = vfmacc_vf_f32m1(vmin_val, -1.0f, va, vl);\n        vfloat32m1_t range = vfsub_vv_f32m1(vmax_val, vmin_val, vl);\n        vfloat32m1_t normalized = vfdiv_vv_f32m1(diff, range, vl);\n\n        vfloat32m1_t zero = vmv_v_x_f32m1(0.0f, vl);\n        vfloat32m1_t one = vmv_v_x_f32m1(1.0f, vl);\n\n        vfloat32m1_t clamped = vfmin_vv_f32m1(normalized, one, vl);\n        clamped = vfmax_vv_f32m1(clamped, zero, vl);\n\n        vfloat32m1_t result = vmrg_vvm_f32m1(va, clamped, mask, vl);\n\n        vse32_v_f32m1(&B[i], result, vl);\n    }\n\n    for (; i < size; i++) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            B[i] = (val < 0.0f) ? 0.0f : ((val > 1.0f) ? 1.0f : val);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    size_t vlmax = vsetvl_e32m1(0);\n    size_t i = 0;\n\n    for (; i <= size - vlmax; i += vlmax) {\n        size_t vl = vsetvl_e32m1(vlmax);\n\n        vfloat32m1_t va = vle32_v_f32m1(&A[i], vl);\n        vint32m1_t vcontrol = vle32_v_i32m1(&control[i], vl);\n        vfloat32m1_t vmin = vmv_v_f_f32m1(min_val, vl);\n        vfloat32m1_t vmax = vmv_v_f_f32m1(max_val, vl);\n\n        // Create a mask where control > 0\n        vbool32_t mask = vmfgt_vv_i32m1_b32(vcontrol, vmv_v_x_i32m1(0, vl), vl);\n\n        // Compute normalization: (A - min_val) / (max_val - min_val)\n        vfloat32m1_t diff = vfmacc_vf_f32m1(va, -1.0f, vmin, vl);\n        vfloat32m1_t range = vfsub_vf_f32m1(vmax, min_val, vl);\n        vfloat32m1_t normalized = vfdiv_vv_f32m1(diff, range, vl);\n\n        // Clamp values to [0, 1]\n        vfloat32m1_t zero = vmv_v_f_f32m1(0.0f, vl);\n        vfloat32m1_t one = vmv_v_f_f32m1(1.0f, vl);\n        vfloat32m1_t clamped = vfmax_vv_f32m1(vfmin_vv_f32m1(normalized, one, vl), zero, vl);\n\n        // Select between normalized or original based on mask\n        vfloat32m1_t result = vmfc_m_f32m1_f32m1(mask, clamped, va, vl);\n\n        // Store the results\n        vse32_v_f32m1(&B[i], result, vl);\n    }\n\n    // Handle remaining elements with scalar code\n    for (; i < size; ++i) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            B[i] = (val < 0.0f) ? 0.0f : ((val > 1.0f) ? 1.0f : val);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    size_t vlmax = vsetvl_e32m1(size);\n    float norm_factor = 1.0f / (max_val - min_val);\n\n    for (size_t i = 0; i < size; i += vlmax) {\n        size_t vl = vsetvl_e32m1(size - i);\n\n        vfloat32m1_t va = vlload_e32m1(A + i, vl);\n        vint32m1_t vcontrol = vlload_e32m1((const int32_t*)(control + i), vl);\n        vfloat32m1_t vmin = vmv_v_f_f32m1(min_val, vl);\n        vfloat32m1_t vnorm_factor = vmv_v_f_f32m1(norm_factor, vl);\n\n        // Create a mask where control > 0\n        vbool32_t mask = vmERGE_v_i32m1_b32(vcontrol, 0, vl);\n\n        // Normalize: (A[i] - min_val) * norm_factor\n        vfloat32m1_t vdiff = vfmacc_vf_f32m1(-min_val, va, vmin, vl);\n        vfloat32m1_t vnormalized = vfwmul_vf_f32m1(vdiff, vnorm_factor, vl);\n\n        // Clamp values to [0, 1]\n        vfloat32m1_t vzero = vmv_v_f_f32m1(0.0f, vl);\n        vfloat32m1_t vone = vmv_v_f_f32m1(1.0f, vl);\n        vfloat32m1_t vclamped = vfclip_vf_f32m1(vnormalized, vzero, vone, vl);\n\n        // Select normalized or original value based on mask\n        vfloat32m1_t vresult = vmerge_vv_f32m1(va, vclamped, mask, vl);\n\n        // Store the result\n        vlstore_e32m1(B + i, vresult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_56_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vlmax = vsetvl_e32m1(size);\n    size_t vl = 0;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n        vuint32m1_t v_a = vle32_v_u32m1((const uint32_t *)&A[i], vl);\n        vuint16m2_t v_high_bits = vwslide1up_vx_u16m2(v_a, 16, vl);\n        vfloat32m1_t v_float = vfcvt_x_f_v_f32m1(vwconvertu_f_v_u16m2_f32m1(v_high_bits, vl), vl);\n        vfloat32m1_t v_sqrt = vfsqrt_v_f32m1(v_float, vl);\n        vse32_v_f32m1(&B[i], v_sqrt, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_56_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vlmax = vsetvl_e32m1(size);\n    vfloat32m1_t vresult;\n    vuint32m1_t vtemp;\n\n    for (size_t i = 0; i < size; i += vlmax) {\n        size_t vl = vsetvl_e32m1(size - i);\n        vtemp = vle32_v_u32m1((const uint32_t *)&A[i], vl);\n        vtemp = vrshiftr_vx_u32m1(vtemp, 16, vl); // Extract high 16 bits\n        vresult = vfcvt_f_x_v_f32m1(vtemp, vl);  // Convert to float\n        vresult = vfsqrt_v_f32m1(vresult, vl);   // Take square root\n        vse32_v_f32m1(&B[i], vresult, vl);       // Store result\n    }\n}\n```"}
{"task_id": "SimdBench_56_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vlmax = vsetvl_e32m1(size);\n    vfloat32m1_t vres;\n    vuint32m1_t va;\n\n    for (size_t i = 0; i < size; i += vlmax) {\n        size_t vl = vsetvl_e32m1(size - i);\n        va = vle32_v_u32m1((const uint32_t *)&A[i], vl);\n        vfloat32m1_t vtmp = vwfcvt_x_f_v_u16m2(vwclipu_wx_v_u32m1(va, vl), vl);\n        vres = vfsqrt_v_f32m1(vtmp, vl);\n        vse32_v_f32m1(&B[i], vres, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_56_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vlmax = vsetvl_e32m1(size);\n    size_t vl = vlmax;\n    vuint32m1_t vu32 = vmv_v_x_u32m1(0, vl);\n    vfloat32m1_t vf32 = vmv_v_f_f32m1(0.0f, vl);\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n        vu32 = vle32_v_u32m1(A + i, vl);\n        vuint16m1_t vu16 = vrshrx_vx_u16m1(vu32, 16, vl);\n        vfloat16m1_t vf16 = vfwcvt_f_x_f16m1(vu16, vl);\n        vf32 = vwfcvt_f_f_f32m1(vf16, vl);\n        vf32 = vfsqrt_v_f32m1(vf32, vl);\n        vse32_v_f32m1(B + i, vf32, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_56_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vlmax = vlenb() / sizeof(float);\n    size_t i = 0;\n\n    for (; i <= size - vlmax; i += vlmax) {\n        vuint32m8_t va = vle32_v_u32m8(A + i, vlmax);\n        vfloat32m4_t vb = vfwcvt_f_x_v_f32m4(va, vlmax);\n        vfloat32m4_t vc = vfsqrt_v_f32m4(vb, vlmax);\n        vse32_v_f32m4(B + i, vc, vlmax);\n    }\n\n    if (i < size) {\n        size_t vl = size - i;\n        vuint32m8_t va = vle32_v_u32m8(A + i, vl);\n        vfloat32m4_t vb = vfwcvt_f_x_v_f32m4(va, vl);\n        vfloat32m4_t vc = vfsqrt_v_f32m4(vb, vl);\n        vse32_v_f32m4(B + i, vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_57_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vlmax = vsetvl_e32m1(size);\n    size_t i = 0;\n\n    for (; i <= size - vlmax; i += vlmax) {\n        vuint32m1_t vu = vle32_v_u32m1(&A[i], vlmax);\n        vfloat32m1_t vf = vreinterpret_v_u_f32m1(vu);\n        vse32_v_f32m1(&B[i], vf, vlmax);\n    }\n\n    if (i < size) {\n        size_t vl = vsetvl_e32m1(size - i);\n        vuint32m1_t vu = vle32_v_u32m1(&A[i], vl);\n        vfloat32m1_t vf = vreinterpret_v_u_f32m1(vu);\n        vse32_v_f32m1(&B[i], vf, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_57_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vlmax = vmv_v_x_i32m1(0); // Get the maximum vector length\n    size_t i = 0;\n\n    for (; i <= size - vlmax; i += vlmax) {\n        vuint32m1_t vu = lvu32_v_i32m1(&A[i], vlmax);\n        vfloat32m1_t vf = vfwcvt_f_x_v_f32m1(vu, vlmax);\n        svf32_v_f32m1(&B[i], vf, vlmax);\n    }\n\n    if (i < size) {\n        size_t vl = size - i;\n        vuint32m1_t vu = lvu32_v_i32m1(&A[i], vl);\n        vfloat32m1_t vf = vfwcvt_f_x_v_f32m1(vu, vl);\n        svf32_v_f32m1(&B[i], vf, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_57_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vlmax = vsetvl_e32m1(size);\n    for (size_t i = 0; i < size; i += vlmax) {\n        size_t vl = vsetvl_e32m1(size - i);\n        vuint32m1_t v_a = vle32_v_u32m1((const uint32_t*)&A[i], vl);\n        vfloat32m1_t v_b = vreinterpret_v_u32_f32m1(v_a);\n        vse32_v_f32m1((float*)&B[i], v_b, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_57_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vlmax = vsetvl_e32m1(size);\n    size_t i = 0;\n\n    for (; i + vlmax <= size; i += vlmax) {\n        vuint32m1_t va = vle32_v_u32m1(A + i, vlmax);\n        vfloat32m1_t vb = vbitcast_f32m1_u32m1(va);\n        vse32_v_f32m1(B + i, vb, vlmax);\n    }\n\n    if (i < size) {\n        size_t vl = vsetvl_e32m1(size - i);\n        vuint32m1_t va = vle32_v_u32m1(A + i, vl);\n        vfloat32m1_t vb = vbitcast_f32m1_u32m1(va);\n        vse32_v_f32m1(B + i, vb, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_57_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vlmax = vmv_v_x_i32m1(0); // Get the maximum vector length\n    size_t i = 0;\n\n    for (; i <= size - vlmax; i += vlmax) {\n        vuint32m1_t vu = lvu32_v_i32m1(&A[i], vlmax);\n        vfloat32m1_t vf = vfwcvt_f_x_v_f32m1(vu, vlmax); // reinterpret bits as float\n        svf32_v_f32m1(&B[i], vf, vlmax);\n    }\n\n    if (i < size) {\n        size_t vl = size - i;\n        vuint32m1_t vu = lvu32_v_i32m1(&A[i], vl);\n        vfloat32m1_t vf = vfwcvt_f_x_v_f32m1(vu, vl); // reinterpret bits as float\n        svf32_v_f32m1(&B[i], vf, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_58_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    size_t vlmax = vsetvl_e32m1(size);\n    float* diff_ptr = diff;\n    const int32_t* A_ptr = A;\n    const bool* cond_ptr = cond;\n\n    // Set the first element of diff to 0.0f\n    *diff_ptr = 0.0f;\n    diff_ptr++;\n    \n    size_t i = 1;\n    for (size_t vl; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n        \n        // Load vectors\n        vbool8_t cond_v = vmv_v_x_b8(loadu_b8(cond_ptr, vl), vl);\n        vint32m1_t A_curr = vle32_v_i32m1(A_ptr + i, vl);\n        vint32m1_t A_prev = vle32_v_i32m1(A_ptr + i - 1, vl);\n\n        // Compute difference\n        vint32m1_t diff_int = vsub_vv_i32m1(A_curr, A_prev, vl);\n\n        // Masked conversion and store\n        vfloat32m1_t diff_float = vcvt_f_x_v_i32m1_f32m1(diff_int, vl);\n        vfloat32m1_t zero = vmv_v_x_f32m1(0.0f, vl);\n        vfloat32m1_t result = vfmerge_vvm_f32m1(zero, diff_float, cond_v, vl);\n\n        vse32_v_f32m1(diff_ptr, result, vl);\n\n        // Update pointers\n        A_ptr += vl;\n        cond_ptr += vl;\n        diff_ptr += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_58_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    size_t vlmax = vsetvl_e32m1(size);\n    float* diff_ptr = diff;\n    const int32_t* A_ptr = A;\n    const bool* cond_ptr = cond;\n\n    // Set the first element of diff to 0.0f\n    *diff_ptr = 0.0f;\n    diff_ptr++;\n    \n    size_t i = 1;\n    for (size_t vl; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n\n        // Load vectors\n        vbool32_t cond_v = vmv_v_x_b32(vlse1_v_i32m1((const int32_t*)cond_ptr, vl), vl);\n        vint32m1_t A_curr_v = vle32_v_i32m1(A_ptr + i, vl);\n        vint32m1_t A_prev_v = vle32_v_i32m1(A_ptr + i - 1, vl);\n\n        // Compute difference\n        vint32m1_t diff_int_v = vsub_vv_i32m1(A_curr_v, A_prev_v, vl);\n\n        // Convert to float\n        vfloat32m1_t diff_float_v = vfcvt_f_x_v_f32m1(diff_int_v, vl);\n\n        // Zero out elements where condition is false\n        vfloat32m1_t diff_final_v = vfmerge_vfm_f32m1(0.0f, diff_float_v, cond_v, vl);\n\n        // Store result\n        vse32_v_f32m1(diff_ptr, diff_final_v, vl);\n\n        // Update pointers\n        cond_ptr += vl;\n        diff_ptr += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_58_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    size_t vlmax = vsetvl_e32m1(size);\n    float* diff_ptr = diff;\n    const int32_t* A_ptr = A;\n    const bool* cond_ptr = cond;\n\n    // Set the first element to 0.0f\n    *diff_ptr = 0.0f;\n    diff_ptr++;\n    \n    size_t i = 1;\n    for (size_t vl; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n        \n        // Load current and previous elements\n        vint32m1_t va_curr = vle32_v_i32m1(A_ptr + i, vl);\n        vint32m1_t va_prev = vle32_v_i32m1(A_ptr + i - 1, vl);\n\n        // Compute difference\n        vint32m1_t vdiff_int = vsub_vv_i32m1(va_curr, va_prev, vl);\n\n        // Convert difference to float\n        vfloat32m1_t vdiff_float = vfcvt_f_x_v_f32m1(vdiff_int, vl);\n\n        // Load condition array\n        vbool8_t vcond = vlsege8_v_b8m1_b(cond_ptr + i, vl);\n\n        // Prepare zero vector\n        vfloat32m1_t vz = vmv_v_x_f32m1(0.0f, vl);\n\n        // Conditional selection based on cond\n        vfloat32m1_t vresult = vfredmin_vfm_f32m1(vz, vdiff_float, vcond, vl);\n\n        // Store the result in diff array\n        vse32_v_f32m1(diff_ptr + i - 1, vresult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_58_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    size_t vlmax = vsetvl_e32m1(size);\n    float zero = 0.0f;\n    vfloat32m1_t vzero = vfslide1up_v_f32m1(zero, vlmax);\n\n    for (size_t i = 0; i < size; i += vlmax) {\n        size_t vl = vsetvl_e32m1(size - i);\n\n        // Load current and previous elements\n        vint32m1_t va = vle32_v_i32m1(A + i, vl);\n        vbool8_t vcond = vlsege32_v_b8m1(cond + i, vl);\n\n        vint32m1_t va_prev = va;\n        if (i > 0) {\n            va_prev = vlslide1down_vx_i32m1(va_prev, va_prev, 1, vl);\n        }\n\n        // Compute difference\n        vint32m1_t vdiff_int = vsub_vv_i32m1(va, va_prev, vl);\n\n        // Convert to float\n        vfloat32m1_t vdiff_float = vfcvt_f_x_v_f32m1(vdiff_int, vl);\n\n        // Mask based on condition\n        vfloat32m1_t vdiff_masked = vmfgt_vf_f32m1_m(vcond, vdiff_float, zero, vl);\n\n        // Store result\n        if (i == 0) {\n            vdiff_masked = vmfeq_vf_f32m1_m(vcond, vdiff_masked, zero, vl);\n        }\n        vse32_v_f32m1(diff + i, vdiff_masked, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_58_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    size_t vlmax = vsetvl_e32m1(size);\n    float zero = 0.0f;\n    vfloat32m1_t vzero = vmv_v_f_f32m1(zero, vlmax);\n\n    for (size_t i = 0; i < size; i += vlmax) {\n        size_t vl = vsetvl_e32m1(size - i);\n        vint32m1_t va = vle32_v_i32m1(A + i, vl);\n        vbool8_t vcond = vlsege8_v_b8m1_b(cond + i, 1, vl);\n\n        vint32m1_t va_prev = va;\n        if (i > 0) {\n            va_prev = vle32_v_i32m1(A + i - 1, vl);\n        }\n\n        vint32m1_t vdiff_int = vsub_vv_i32m1(va, va_prev, vl);\n        vfloat32m1_t vdiff_float = vfwcvt_f_x_v_f32m1(vdiff_int, vl);\n\n        vfloat32m1_t vresult = vfmerge_vfm_f32m1(vzero, vdiff_float, vcond, vl);\n\n        if (i == 0) {\n            vresult = vmv_v_x_f32m1(0.0f, vl);\n        }\n\n        vse32_v_f32m1(diff + i, vresult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_59_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t vlmax = vsetvl_e32m1(length);\n    for (size_t vl = vlmax; vl > 0; vl = vsetvl_e32m1(vl)) {\n        vuint32m1_t v_src = vle32_v_u32m1(src, vl);\n        vuint64m2_t v_dst = vmv_x_w_u64(vwaddu_wx_u32m1_u64m2(v_src, -1, vl), vl);\n        vsse64_v_u64m2(dst, 0, v_dst, vl);\n        src += vl;\n        dst += vl;\n        length -= vl;\n        if (length == 0) break;\n    }\n}\n```"}
{"task_id": "SimdBench_59_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t vlmax = vsetvl_e32m1(length);\n    for (size_t vl = vlmax; vl != 0; vl = vsetvl_e32m1(vl)) {\n        vuint32m1_t v_src = vle32_v_u32m1(src, vl);\n        vuint64m2_t v_dst = vmv_x_s_u32u64_v_u64m2(v_src, vl);\n        vuint64m2_t v_mask = vmv_v_x_u64m2(-1, vl);\n        vuint64m2_t v_result = vsll_vx_u64m2(v_mask, 32, vl);\n        v_result = vor_vv_u64m2(v_result, v_dst, vl);\n        vse64_v_u64m2(dst, v_result, vl);\n        src += vl;\n        dst += vl;\n        length -= vl;\n        if (length == 0) break;\n    }\n}\n```"}
{"task_id": "SimdBench_59_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t vlmax = vsetvl_e32m1(length);\n    for (size_t vl = 0; vl < length; vl += vlmax) {\n        size_t actual_vl = vsetvl_e32m1(vlmax);\n        vuint32m1_t vsrc = vle32_v_u32m1(src + vl, actual_vl);\n        vuint64m2_t vdst = vwaddu_vx_u32m1_u64m2(vsrc, 0xFFFFFFFF, actual_vl);\n        vse64_v_u64m2(dst + vl, vdst, actual_vl);\n    }\n}\n```"}
{"task_id": "SimdBench_59_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t vlmax = vsetvl_e32m1(length);\n    for (size_t vl = 0; vl < length; vl += vlmax) {\n        size_t actual_vl = vsetvl_e32m1(vlmax);\n        vuint32m1_t vs = vle32_v_u32m1(src + vl, actual_vl);\n        vuint64m2_t vd = vwaddu_vx_u32m1_u64m2(vs, 0xFFFFFFFF, actual_vl);\n        vse64_v_u64m2(dst + vl, vd, actual_vl);\n    }\n}\n```"}
{"task_id": "SimdBench_59_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t vlmax = vsetvl_e32m1(length);\n    for (size_t vl = 0; vl < length; vl += vlmax) {\n        size_t actual_vl = vsetvl_e32m1(vmin_vx_u(size_t, length - vl, vlmax));\n        vuint32m1_t v_src = vle32_v_u32m1((const uint32_t*)&src[vl], actual_vl);\n        vuint64m2_t v_dst = vwaddu_vx_u32m1_u64m2(v_src, 0xFFFFFFFF, actual_vl);\n        vsse64_v_u64m2((uint64_t*)&dst[vl], 0, v_dst, actual_vl);\n    }\n}\n```"}
{"task_id": "SimdBench_60_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double result = 0.0;\n    size_t vlmax = vsetvl_e64m8(length);\n    vfloat64m8_t vsum = vmv_v_x_f64m8(0.0, vlmax);\n\n    for (size_t i = 0; i < length; i += vlmax) {\n        size_t vl = vsetvl_e64m8(vlmax > (length - i) ? (length - i) : vlmax);\n        vint16m2_t vindex = vle16_v_i16m2(index + i, vl);\n        vfloat64m8_t vdata = vluxseg1ff_v_f64m8(vec, vindex, vl);\n        vsum = vadd_vv_f64m8(vsum, vdata, vl);\n    }\n\n    result = vmv_x_s_f64m8_f64(vsum);\n    return result;\n}\n```"}
{"task_id": "SimdBench_60_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double result = 0.0;\n    size_t vlmax = vsetvl_e64m8(length);\n    vfloat64m8_t vsum = vmv_v_x_f64m8(0.0, vlmax);\n\n    for (size_t i = 0; i < length; i += vlmax) {\n        size_t vl = vsetvl_e64m8(vlmin(vlmax, length - i));\n        vint16m2_t vindex = vle16_v_i16m2(index + i, vl);\n        vfloat64m8_t vdata = vvfgather_fd_v_f64m8(vec, vindex, 1, vl);\n        vsum = vadd_vv_f64m8(vsum, vdata, vl);\n    }\n\n    double temp_result = 0.0;\n    for (size_t i = 0; i < vlmax; i++) {\n        temp_result += vmv_x_s_f64m8_f64(vsum, i);\n    }\n    result += temp_result;\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_60_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double result = 0.0;\n    size_t vlmax = vsetvl_e64m1(length);\n    vfloat64m1_t vsum = vmv_v_x_f64m1(0.0, vlmax);\n\n    for (size_t i = 0; i < length; i += vlmax) {\n        size_t vl = vsetvl_e64m1(vlmax > (length - i) ? (length - i) : vlmax);\n        vint16m2_t vindex = vle16_v_i16m2(index + i, vl);\n        vfloat64m1_t vdata = vluxseg1ff_v_f64m1(vec, vindex, vl);\n        vsum = vadd_vv_f64m1(vsum, vdata, vl);\n    }\n\n    result = vmv_s_x_f64m1(vsum);\n    return result;\n}\n```"}
{"task_id": "SimdBench_60_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double result = 0.0;\n    size_t vlmax = vsetvl_e64m8(length);\n    vfloat64m8_t vsum = vmv_v_f_f64m8(0.0, vlmax);\n\n    for (size_t i = 0; i < length; i += vlmax) {\n        size_t vl = vsetvl_e64m8(vlmax > (length - i) ? (length - i) : vlmax);\n        vint16m2_t vindex = vle16_v_i16m2(index + i, vl);\n        vfloat64m8_t vdata = vluxseg1ff_v_f64m8(vec, vindex, vl);\n        vsum = vfmacc_vf_f64m8(1.0, vdata, vsum, vl);\n    }\n\n    result = vmv_s_f_f64m8_f64(vredsum_vs_f64m8_f64m8(vsum, vmv_v_f_f64m8(0.0, vlmax), vlmax));\n    return result;\n}\n```"}
{"task_id": "SimdBench_60_RVV", "completion": "```c\n#include <riscv_vector.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double result = 0.0;\n    size_t vlmax = vsetvl_e64m1(length);\n    vfloat64m1_t vresult = vmv_v_x_f64m1(0.0, vlmax);\n\n    for (size_t i = 0; i < length; i += vlmax) {\n        size_t vl = vsetvl_e64m1(vlmin(vlmax, length - i));\n        vint16m2_t vindex = vle16_v_i16m2(index + i, vl);\n        vfloat64m1_t vvec = vluxseg1ff_v_f64m1(vec, vindex, vl);\n        vresult = vfmacc_vf_f64m1(1.0, vvec, vresult, vl);\n    }\n\n    result = redsum_vec_double(vresult);\n    return result;\n}\n\ndouble redsum_vec_double(vfloat64m1_t v) {\n    size_t vl = vsetvl_e64m1(1);\n    vfloat64m1_t vd = vredsum_vs_f64m1_f64m1_f64m1(v, vmv_v_x_f64m1(0.0, vl), vl);\n    return vmv_x_s_f64m1_f64(vd);\n}\n```"}
{"task_id": "SimdBench_61_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t vlmax = vlenb() / sizeof(double);\n    size_t output_size = input_size - kernel_size + 1;\n\n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j += vlmax) {\n            size_t vl = (output_size - j) > vlmax ? vlmax : (output_size - j);\n\n            vfloat64m1_t vsum = vmv_v_x_f64m1(0.0, vl);\n\n            for (size_t m = 0; m < kernel_size; m++) {\n                for (size_t n = 0; n < kernel_size; n++) {\n                    const double* inp_row = &input[(i + m) * input_size + j + n];\n                    double k_val = kernel[m * kernel_size + n];\n\n                    vfloat64m1_t vinp = vle64_v_f64m1(inp_row, vl);\n                    vfloat64m1_t vk = vmv_v_x_f64m1(k_val, vl);\n                    vsum = vfadd_vv_f64m1(vsum, vmul_vv_f64m1(vinp, vk, vl), vl);\n                }\n            }\n\n            vfloat64m1_t vzero = vmv_v_x_f64m1(0.0, vl);\n            vfloat64m1_t vres = vfmax_vv_f64m1(vsum, vzero, vl);\n            vse64_v_f64m1(&output[i * output_size + j], vres, vl);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t vlmax = vsetvl_e64m1(1);\n    vfloat64m1_t vkernel_v;\n    vfloat64m1_t vinput_v;\n    vfloat64m1_t vsum_v;\n\n    size_t output_size = input_size - kernel_size + 1;\n    size_t i, j, k, l;\n\n    for (i = 0; i < output_size; i++) {\n        for (j = 0; j < output_size; j++) {\n            vsum_v = vmv_v_f_f64m1(0.0, vlmax);\n            for (k = 0; k < kernel_size; k++) {\n                for (l = 0; l < kernel_size; l += vlmax) {\n                    size_t vl = vsetvl_e64m1(vlmax);\n                    vkernel_v = vle64_v_f64m1(&kernel[k * kernel_size + l], vl);\n                    vinput_v = vle64_v_f64m1(&input[(i + k) * input_size + (j + l)], vl);\n                    vsum_v = vfma_vv_f64m1(vsum_v, vinput_v, vkernel_v, vl);\n                }\n            }\n            vsum_v = vfmerge_vf_f64m1(0.0, vsum_v, vmflt_vf_f64m1(0.0, vlmax), vlmax); // ReLU activation\n            vse64_v_f64m1(&output[i * output_size + j], vsum_v, vlmax);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t vlmax = vsetvl_e64m8(1);\n    size_t output_size = input_size - kernel_size + 1;\n    size_t k_area = kernel_size * kernel_size;\n\n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            size_t idx = i * input_size + j;\n            double sum = 0.0;\n            size_t k = 0;\n\n            while(k < k_area){\n                size_t vl = vsetvl_e64m8(vlmax);\n                vfloat64m8x1_t vk = vlmul_eq ? vle64_v_f64m8(kernel + k, vl) : vle64ff_v_f64m8(kernel + k, vl);\n                vfloat64m8x1_t vi = vlmul_eq ? vle64_v_f64m8(input + idx, vl) : vle64ff_v_f64m8(input + idx, vl);\n                vfloat64m8x1_t vmul = vmul_vv_f64m8(vi, vk, vl);\n                vfloat64m8x1_t vsum = vlmul_eq ? vmadd_vf_f64m8(vmul, 0.0, vl) : vmadd_vf_f64m8(vmul, 0.0, vl);\n                sum += vmv_x_s_f64m8_f64(vredsum_vs_f64m8_f64m8(vfloat64m8x1_t{0}, vsum, vl));\n                idx += 1;\n                k += vl;\n            }\n            output[i * output_size + j] = (sum > 0) ? sum : 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t vlmax = vsetvl_e64m1(input_size);\n    size_t output_size = input_size - kernel_size + 1;\n    size_t k_area = kernel_size * kernel_size;\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            size_t out_idx = i * output_size + j;\n            double sum = 0.0;\n\n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    size_t inp_row = i + ki;\n                    size_t inp_col = j + kj;\n                    size_t inp_idx = inp_row * input_size + inp_col;\n                    size_t ker_idx = ki * kernel_size + kj;\n\n                    vfloat64m1_t vinp = vmv_v_x_f64m1(input[inp_idx], vlmax);\n                    vfloat64m1_t vker = vmv_v_x_f64m1(kernel[ker_idx], vlmax);\n\n                    vfloat64m1_t vprod = vmul_vv_f64m1(vinp, vker, vlmax);\n                    sum += vmax_vf_f64m1(vprod, 0.0, vlmax)[0];\n                }\n            }\n            output[out_idx] = (sum > 0) ? sum : 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t vlmax = vlenb() / sizeof(double);\n    size_t output_size = input_size - kernel_size + 1;\n\n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j += vlmax) {\n            size_t vl = vsetvl_e64m1(vlmax);\n\n            vfloat64m1_t vsum = vmv_v_x_f64m1(0.0, vl);\n\n            for (size_t m = 0; m < kernel_size; m++) {\n                for (size_t n = 0; n < kernel_size; n++) {\n                    const double *input_row = &input[(i + m) * input_size + j + n];\n                    double kernel_val = kernel[m * kernel_size + n];\n\n                    vfloat64m1_t vinput = vle64_v_f64m1(input_row, vl);\n                    vfloat64m1_t vkern = vmv_v_x_f64m1(kernel_val, vl);\n                    vfloat64m1_t vprod = vmul_vv_f64m1(vinput, vkern, vl);\n                    vsum = vadd_vv_f64m1(vsum, vprod, vl);\n                }\n            }\n\n            vsum = vfmax_vf_f64m1(vsum, 0.0, vl); // ReLU activation\n\n            vse64_v_f64m1(&output[i * output_size + j], vsum, vl);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_62_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n#include <limits>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold){\n    if (numbers.size() < 2) return false;\n\n    size_t vlen = __riscv_vlmax;\n    size_t num_elements = numbers.size();\n    double abs_threshold = std::abs(threshold);\n\n    for (size_t i = 0; i < num_elements; ++i) {\n        size_t vl = vsetvl_e64m1(std::min(vlen, static_cast<size_t>(num_elements - i - 1)));\n\n        // Load current element\n        double vi = numbers[i];\n\n        // Load vector of subsequent elements\n        vfloat64m1_t vs = __riscv_vle64_v_f64m1(&numbers[i + 1], vl);\n\n        // Compute absolute difference\n        vfloat64m1_t vd = __riscv_vfsub_vf_f64m1(vs, vi, vl);\n        vfloat64m1_t vabs = __riscv_vfabs_v_f64m1(vd, vl);\n\n        // Compare with threshold\n        vfloat64m1_t vthreshold = __riscv_vfmv_v_f_f64m1(abs_threshold, vl);\n        vbool64_t cmp_result = __riscv_vfcmplt_vv_b64m1(vabs, vthreshold, vl);\n\n        // Check if any comparison is true\n        if (__riscv_vmv_x_s_b64m1_b64(__riscv_vredor_b64m1(cmp_result, vl))) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n#include <cfloat>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold){\n    if (numbers.size() < 2) return false;\n\n    size_t vl = vsetvl_e64m1(numbers.size());\n    vfloat64m1_t vthres = vmv_v_f_f64m1(threshold, vl);\n\n    for(size_t i = 0; i < numbers.size(); ++i){\n        double anchor = numbers[i];\n        vfloat64m1_t vanchor = vmv_v_f_f64m1(anchor, vl);\n\n        size_t j = i + 1;\n        for(; j + vl <= numbers.size(); j += vl){\n            vfloat64m1_t vnums = vle64_v_f64m1(&numbers[j], vl);\n            vfloat64m1_t vdiff = vfsub_vv_f64m1(vnums, vanchor, vl);\n            vfloat64m1_t vabsdiff = vfabs_v_f64m1(vdiff, vl);\n            vbool64m1_t vcmp = vmflt_vv_b64m1(vabsdiff, vthres, vl);\n            size_t result = vmfirst_m_b64m1(vcmp, vl);\n            if(result != -1){\n                return true;\n            }\n        }\n\n        // Handle remaining elements\n        for(; j < numbers.size(); ++j){\n            if(std::fabs(numbers[j] - anchor) < threshold){\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n#include <cfloat>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold){\n    if (numbers.size() < 2) return false;\n\n    size_t vlen = __riscv_vlmax();\n    size_t vl = 0;\n\n    for(size_t i = 0; i < numbers.size(); ++i){\n        double anchor = numbers[i];\n        size_t j = i + 1;\n        while(j < numbers.size()){\n            size_t chunk_size = std::min(vlen, static_cast<size_t>(numbers.size() - j));\n            vl = chunk_size;\n\n            vdouble8_t vmask = __riscv_vfredge_mask_f64_m(vl);\n            vdouble8_t vthreshold = __riscv_vfmv_v_f_f64(threshold, vl);\n            vdouble8_t vanchor = __riscv_vfmv_v_f_f64(anchor, vl);\n            vdouble8_t vnums = __riscv_vle64_v_f64(numbers.data()+j, vl);\n\n            vdouble8_t vdiff = __riscv_vfsub_vv_f64(vnums, vanchor, vl);\n            vdouble8_t vabsdiff = __riscv_vfabs_v_f64(vdiff, vl);\n            vbool8_t vcmp = __riscv_vfcmult_vv_b64(vabsdiff, vthreshold, vl);\n\n            bool any_close = __riscv_vmv_x_s_b_i32(__riscv_vanyne_v_b8(vcmp, vl));\n            if(any_close){\n                return true;\n            }\n\n            j += chunk_size;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n#include <cfenv>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold){\n    if (numbers.size() < 2) return false;\n\n    size_t vlen = __riscv_vlmax;\n    size_t size = numbers.size();\n    double *data = const_cast<double*>(numbers.data());\n\n    bool result = false;\n\n    for(size_t i = 0; i < size && !result; ){\n        size_t vl = __riscv_vsetvl_e64m8(size - i);\n        vfloat64m8_t vi = __riscv_vle64_v_f64m8(&data[i], vl);\n\n        for(size_t j = i + 1; j < size && !result; ){\n            size_t vj = __riscv_vsetvl_e64m8(size - j);\n            vfloat64m8_t vj_temp = __riscv_vle64_v_f64m8(&data[j], vj);\n\n            vfloat64m8_t diff = __riscv_vfsub_vv_f64m8(vi, vj_temp, vj);\n            vfloat64m8_t abs_diff = __riscv_vfabs_v_f64m8(diff, vj);\n            vfloat64m8_t vt = __riscv_vfmv_v_f_f64m8(threshold, vj);\n            vbool8_t mask = __riscv_vfcmplt_vv_mask_f64m8_b8(abs_diff, vt, vj);\n\n            if(__riscv_vmv_x_s_b8(mask)){\n                result = true;\n            }\n\n            j += vj;\n        }\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_62_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n#include <climits>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold){\n    size_t n = numbers.size();\n    if (n < 2) return false;\n\n    size_t vl = vsetvl_e64m1(n);\n    vfloat64m1_t vthres = vmv_v_f_f64m1(threshold, vl);\n\n    for(size_t i = 0; i < n; ++i){\n        double anchor = numbers[i];\n        vfloat64m1_t vanchor = vmv_v_f_f64m1(anchor, vl);\n\n        size_t j = i + 1;\n        size_t k = 0;\n        for(; j + vl <= n; j += vl, k += vl){\n            vfloat64m1_t vnums = lvf64_v_f64m1(&numbers[j], vl);\n            vfloat64m1_t vdiff = vsub_vv_f64m1(vnums, vanchor, vl);\n            vfloat64m1_t vabsdiff = vfabs_v_f64m1(vdiff, vl);\n            vbool64m1_t vcmp = vmflt_vv_f64m1_b64m1(vabsdiff, vthres, vl);\n            if (vmfirst_m_b64m1(vcmp)) return true;\n        }\n\n        // Handle remaining elements\n        if(j < n){\n            vl = vsetvl_e64m1(n - j);\n            vfloat64m1_t vnums = lvf64_v_f64m1(&numbers[j], vl);\n            vfloat64m1_t vdiff = vsub_vv_f64m1(vnums, vanchor, vl);\n            vfloat64m1_t vabsdiff = vfabs_v_f64m1(vdiff, vl);\n            vbool64m1_t vcmp = vmflt_vv_f64m1_b64m1(vabsdiff, vthres, vl);\n            if (vmfirst_m_b64m1(vcmp)) return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nbool below_zero_simd(std::vector<int> operations){\n    if (operations.empty()) return false;\n\n    size_t size = operations.size();\n    bool result = false;\n\n    size_t vlmax = vsetvl_e32m1(size);\n    vint32m1_t vbalance = vmv_v_x_i32m1(0, vlmax);\n    vbool32_t vmask;\n\n    for(size_t i = 0; i < size; ){\n        size_t vl = vsetvl_e32m1(size - i);\n        vint32m1_t vop = vle32_v_i32m1(&operations[i], vl);\n        vbalance = vadd_vv_i32m1(vbalance, vop, vl);\n        vmask = vmflt_vx_i32m1_b32(vbalance, 0, vl);\n        if (vfirst_m_b32(vmask, vl)) {\n            result = true;\n            break;\n        }\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_63_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nbool below_zero_simd(std::vector<int> operations){\n    if (operations.empty()) return false;\n\n    size_t size = operations.size();\n    bool result = false;\n\n    size_t vlmax = vsetvl_e32m1(size);\n    vint32m1_t vbalance = vmv_v_x_i32m1(0, vlmax);\n    vbool32_t mask = vmv_v_x_b32m1(false, vlmax);\n\n    for(size_t i = 0; i < size; i += vlmax){\n        size_t vl = vsetvl_e32m1(std::min(vlmax, size - i));\n        vint32m1_t vop = vle32_v_i32m1(&operations[i], vl);\n        vbalance = vfadd_vv_f32m1(vbalance, vop, vl);\n        mask = vor_vv_b32m1(mask, vmflt_vx_b32m1(vbalance, 0, vl));\n    }\n\n    result =vredu_or_b_b32m1(mask, size);\n    return result;\n}\n```"}
{"task_id": "SimdBench_63_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cstdlib>\n\nbool below_zero_simd(std::vector<int> operations){\n    size_t size = operations.size();\n    if (size == 0) return false;\n\n    bool result = false;\n    size_t vlmax = vsetvl_e32m1(size);\n    int *op_data = operations.data();\n\n    int32_t balance = 0;\n    vbool32_t mask = vmv_v_x_b32(true, vlmax);\n    vbool32_t is_negative;\n\n    for (size_t i = 0; i < size; i += vlmax) {\n        size_t vl = vsetvl_e32m1(size - i);\n        vint32m1_t vop = vle32_v_i32m1(op_data + i, vl);\n        vint32m1_t vbalance = vmv_v_x_i32m1(balance, vl);\n        vbalance = vadd_vv_i32m1(vbalance, vop, vl);\n        is_negative = vmflt_vx_i32m1_b32(vbalance, 0, vl);\n        if (vfirst_m_b32(mask & is_negative, vl)) {\n            result = true;\n            break;\n        }\n        balance = vmredsum_vs_i32m1_i32m1(vbalance, balance, vl);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_63_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <climits>\n\nbool below_zero_simd(std::vector<int> operations) {\n    if (operations.empty()) return false;\n\n    size_t size = operations.size();\n    bool result = false;\n\n    size_t vlmax = vsetvl_e32m1(size);\n    vint32m1_t vbalance = vmv_v_x_i32m1(0, vlmax);\n    vbool32_t mask = vmv_v_x_b32m1(0, vlmax);\n\n    for (size_t i = 0; i < size; i += vlmax) {\n        size_t vl = vsetvl_e32m1(size - i);\n        vint32m1_t vop = vle32_v_i32m1(&operations[i], vl);\n        vbalance = vredsum_vs_i32m1_i32m1(vbalance, vop, vbalance, vl);\n        mask = vor_vv_b32m1(mask, vmflt_vx_i32m1_b32m1(vbalance, 0, vl), vl);\n        result |=vredu_or_b_b32m1(mask, vl);\n        if (result) break;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_63_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    if (operations.empty()) return false;\n\n    size_t size = operations.size();\n    bool below_zero = false;\n\n    size_t vlmax = vsetvl_e32m1(1);\n    int balance = 0;\n\n    for (size_t i = 0; i < size; i += vlmax) {\n        size_t vl = vsetvl_e32m1(size - i);\n        vint32m1_t vop = vle32_v_i32m1(&operations[i], vl);\n\n        vint32m1_t vb = vmv_v_x_i32m1(balance, vl);\n        vb = vredsum_vs_i32m1_i32m1_i32(vb, vop, vb, vl);\n\n        vbool32_t vmask = vm lt_vx_i32m1_b32m1(vb, 0, vl);\n        if (vfirst_m_b32(vmask, vl)) {\n            below_zero = true;\n            break;\n        }\n\n        balance = vmv_x_s_i32m1_i32(vb, vl);\n    }\n\n    return below_zero;\n}\n```"}
{"task_id": "SimdBench_64_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers){\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    // Compute the mean\n    double sum = 0.0;\n    for (double num : numbers) {\n        sum += num;\n    }\n    double mean = sum / n;\n\n    // Vectorized computation of MAD\n    double mad = 0.0;\n    size_t i = 0;\n    size_t vl_max = vsetvl_e64m1(n);\n\n    while (i < n) {\n        size_t vl = vsetvl_e64m1(n - i);\n        vfloat64m1_t vm_mean = vmv_v_f_f64m1(mean, vl);\n        vfloat64m1_t vm_numbers = vle64_v_f64m1((const double*)&numbers[i], vl);\n        vfloat64m1_t vm_diff = vsub_vv_f64m1(vm_numbers, vm_mean, vl);\n        vfloat64m1_t vm_abs_diff = vfabs_v_f64m1(vm_diff, vl);\n        vfloat64m1_t vm_mad = vmadd_vf_f64m1(vm_abs_diff, 0.0, 1.0, vl);\n\n        // Accumulate results\n        for (size_t j = 0; j < vl; ++j) {\n            mad += vmget_v_f64m1(vm_mad, j);\n        }\n\n        i += vl;\n    }\n\n    return mad / n;\n}\n```"}
{"task_id": "SimdBench_64_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers){\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    // Calculate the mean\n    double sum = 0.0;\n    for (double num : numbers) {\n        sum += num;\n    }\n    double mean = sum / n;\n\n    // Vectorized MAD calculation\n    double mad = 0.0;\n    size_t i = 0;\n    size_t vlmax = vsetvl_e64m1(n);\n\n    for (; i <= n - vlmax; i += vlmax) {\n        vfloat64m1_t vmask = vmv_v_x_f64m1(1.0, vlmax);\n        vfloat64m1_t vdata = vle64_v_f64m1((const double*)&numbers[i], vlmax);\n        vfloat64m1_t vmean = vmv_v_f_f64m1(mean, vlmax);\n        vfloat64m1_t vdiff = vfsub_vv_f64m1(vdata, vmean, vlmax);\n        vfloat64m1_t vabsdiff = vfabs_v_f64m1(vdiff, vlmax);\n        vfloat64m1_t vsum = vmul_vf_f64m1(vabsdiff, vmask, vlmax);\n        double temp_mad = 0.0;\n        for (size_t j = 0; j < vlmax; ++j) {\n            temp_mad += vget_f64(vsum, j);\n        }\n        mad += temp_mad;\n    }\n\n    // Handle leftover elements\n    for (; i < n; ++i) {\n        mad += std::abs(numbers[i] - mean);\n    }\n\n    return mad / n;\n}\n```"}
{"task_id": "SimdBench_64_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers){\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    // Calculate the sum using RVV\n    double sum = 0.0;\n    size_t vlmax = vsetvl_e64m1(n);\n    vfloat64m1_t v_num = vmv_v_x_f64m1(0.0, vlmax);\n    size_t i = 0;\n    for (; i + vlmax <= n; i += vlmax) {\n        v_num = vle64_v_f64m1(&numbers[i], vlmax);\n        sum += vmv_x_s_f64m1_f64(vmfredosum_vs_f64m1_f64(v_num, 0.0, vlmax), vlmax);\n    }\n    for (; i < n; i++) {\n        sum += numbers[i];\n    }\n    double mean = sum / n;\n\n    // Calculate MAD using RVV\n    double mad = 0.0;\n    i = 0;\n    for (; i + vlmax <= n; i += vlmax) {\n        v_num = vle64_v_f64m1(&numbers[i], vlmax);\n        vfloat64m1_t v_mean = vmv_v_x_f64m1(mean, vlmax);\n        vfloat64m1_t v_abs_diff = vfsub_vv_f64m1(v_num, v_mean, vlmax);\n        v_abs_diff = vfabs_v_f64m1(v_abs_diff, vlmax);\n        mad += vmv_x_s_f64m1_f64(vmfredosum_vs_f64m1_f64(v_abs_diff, 0.0, vlmax), vlmax);\n    }\n    for (; i < n; i++) {\n        mad += std::abs(numbers[i] - mean);\n    }\n    mad /= n;\n    return mad;\n}\n```"}
{"task_id": "SimdBench_64_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers){\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    // Calculate the mean\n    double sum = 0.0;\n    for (double num : numbers) {\n        sum += num;\n    }\n    double mean = sum / n;\n\n    // Vectorized MAD calculation\n    double mad = 0.0;\n    size_t vlmax = vsetvl_e64m8(n);\n    vfloat64m8_t vmean = vmv_v_f_f64(mean, vlmax);\n\n    for (size_t i = 0; i < n; i += vlmax) {\n        size_t vl = vsetvl_e64m8(n - i);\n        vfloat64m8_t vin = vle64_v_f64m8((const double*)&numbers[i], vl);\n        vfloat64m8_t vdiff = vsub_vv_f64m8(vin, vmean, vl);\n        vfloat64m8_t vabsdiff = vfabs_v_f64m8(vdiff, vl);\n        vfloat64m8_t vmad = vmul_vf_f64m8(vabsdiff, 1.0 / n, vl);\n        mad += vmasked_reduction_add_vs_f64m8_f64(vmad, 0.0, vl);\n    }\n\n    return mad;\n}\n```"}
{"task_id": "SimdBench_64_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers){\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    // Calculate the mean\n    double sum = 0.0;\n    for(auto num : numbers) sum += num;\n    double mean = sum / n;\n\n    // Vectorized MAD calculation\n    double mad = 0.0;\n    size_t vl = vsetvl_e64m8(n);\n    vfloat64m8_t v_mean = vmv_v_f_f64m8(mean, vl);\n    size_t i = 0;\n\n    for (; i + vl <= n; i += vl) {\n        vfloat64m8_t v_num = vle64_v_f64m8(&numbers[i], vl);\n        vfloat64m8_t v_diff = vfsub_vv_f64m8(v_num, v_mean, vl);\n        vfloat64m8_t v_abs_diff = vfabs_v_f64m8(v_diff, vl);\n        vfloat64m8_t v_mad_contrib = vfmul_vf_f64m8(v_abs_diff, 1.0/n, vl);\n        mad += vhsum_vm_f64m8_f64(vmad_contrib, vfmadd_vf_f64m8(v_abs_diff, 1.0/n, vmv_v_f_f64m8(0.0, vl), vl), vl);\n    }\n\n    // Handle leftovers\n    for (; i < n; i++) {\n        mad += std::abs(numbers[i] - mean) / n;\n    }\n\n    return mad;\n}\n```"}
{"task_id": "SimdBench_65_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter){\n    size_t vl = vsetvl_e32m1(numbers.size());\n    if (numbers.empty()) return {};\n\n    std::vector<int> result;\n    result.reserve(numbers.size() * 2 - 1);\n\n    size_t i = 0;\n    for (; i + vl <= numbers.size(); i += vl) {\n        vint32m1_t v_numbers = vle32_v_i32m1(&numbers[i], vl);\n        vint32m1_t v_delim = vmv_v_x_i32m1(delimeter, vl);\n\n        // Store the original numbers\n        result.insert(result.end(), &v Numbers[i], &v_numbers[i] + vl);\n\n        if (i + vl < numbers.size()) {\n            // Store the delimeters\n            result.insert(result.end(), vl, delimeter);\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i + 1 < numbers.size()) {\n            result.push_back(delimeter);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter){\n    size_t vl = vsetvl_e32m1(numbers.size());\n    if (numbers.empty()) return {};\n\n    std::vector<int> result;\n    result.reserve(numbers.size() * 2 - 1);\n\n    size_t i = 0;\n    for (; i + vl <= numbers.size(); i += vl) {\n        vint32m1_t vmask = vmv_v_x_i32m1(1, vl);\n        vint32m1_t vnum = vle32_v_i32m1(&numbers[i], vl);\n        \n        // Store numbers\n        for (int j = 0; j < vl; ++j) {\n            result.push_back(vget_v_i32m1_int32(vnum, j));\n            if (i + j < numbers.size() - 1) {\n                result.push_back(delimeter);\n            }\n        }\n    }\n\n    // Handle remaining elements\n    if (i < numbers.size()) {\n        size_t remaining = numbers.size() - i;\n        size_t vl_remaining = vsetvl_e32m1(remaining);\n        vint32m1_t vnum = vle32_v_i32m1(&numbers[i], vl_remaining);\n        for (int j = 0; j < remaining; ++j) {\n            result.push_back(vget_v_i32m1_int32(vnum, j));\n            if (i + j < numbers.size() - 1) {\n                result.push_back(delimeter);\n            }\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter){\n    size_t n = numbers.size();\n    if (n == 0) return {};\n    \n    size_t result_size = 2 * n - 1;\n    std::vector<int> result(result_size);\n    \n    size_t vl = vsetvl_e32m1(n);\n    vint32m1_t v_delimeter = vmv_v_x_i32m1(delimeter, vl);\n    \n    for(size_t i = 0; i < n; i += vl){\n        size_t chunk_size = std::min(vl, (size_t)(n - i));\n        vl = vsetvl_e32m1(chunk_size);\n        \n        vint32m1_t v_num = vle32_v_i32m1(&numbers[i], vl);\n        \n        size_t j = 2 * i;\n        if(j > 0){\n            vmse32_v_i32m1(&result[j-1], v_delimeter, vl-1);\n        }\n        vse32_v_i32m1(&result[j], v_num, vl);\n        \n        if(i + chunk_size < n){\n            vmse32_v_i32m1(&result[j+1], v_delimeter, vl);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter){\n    size_t n = numbers.size();\n    if (n == 0) return {};\n    \n    size_t result_size = 2 * n - 1;\n    std::vector<int> result(result_size);\n    \n    size_t vl = vsetvl_e32m1(n);\n    vint32m1_t v_delimeter = vmv_v_x_i32m1(delimeter, vl);\n    \n    for(size_t i = 0; i < n; i += vl){\n        size_t chunk_size = (n - i) > vl ? vl : (n - i);\n        vl = vsetvl_e32m1(chunk_size);\n        \n        // Load vector chunk\n        vint32m1_t v_num = vle32_v_i32m1(&numbers[i], vl);\n        \n        // Store numbers into result\n        vse32_v_i32m1(&result[2*i], v_num, vl);\n        \n        // Store delimeters into result\n        if(i + chunk_size < n){\n            vse32_v_i32m1(&result[2*i + 1], v_delimeter, vl);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_65_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter){ \n    size_t n = numbers.size();\n    if (n == 0) return {};\n    \n    size_t result_size = 2 * n - 1;\n    std::vector<int> result(result_size);\n    \n    size_t vl = vsetvl_e32m1(n);\n    vint32m1_t v_numbers = vle32_v_i32m1(numbers.data(), vl);\n    vint32m1_t v_delimeter = vmv_v_x_i32m1(delimeter, vl);\n    \n    size_t i = 0;\n    for (; i + vl <= n; i += vl) {\n        vint32m1_t v_num = vle32_v_i32m1(numbers.data() + i, vl);\n        size_t j = 2 * i;\n        vse32_v_i32m1(result.data() + j, v_num, vl);\n        if (i + vl < n) {\n            vse32_v_i32m1(result.data() + j + vl, v_delimeter, vl);\n        }\n    }\n    \n    // Handle remaining elements\n    vl = vsetvl_e32m1(n - i);\n    if (i < n) {\n        vint32m1_t v_num = vle32_v_i32m1(numbers.data() + i, vl);\n        size_t j = 2 * i;\n        vse32_v_i32m1(result.data() + j, v_num, vl);\n        if (i < n - 1) {\n            vse32_v_i32m1(result.data() + j + vl, v_delimeter, vl);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_66_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers){\n    size_t size = numbers.size();\n    if (size == 0) return {0, 1};\n\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    size_t vlmax = vsetvl_e16m2(size);\n    vint16m2_t vmask = vmv_v_x_i16m2(0, vlmax);\n    vint16m2_t vsum = vmv_v_x_i16m2(0, vlmax);\n    vint16m2_t vprod = vmv_v_x_i16m2(1, vlmax);\n\n    for(size_t i = 0; i < size; i += vlmax){\n        size_t vl = vsetvl_e16m2(size - i);\n        vint16m2_t vdata = vle16_v_i16m2(numbers.data() + i, vl);\n        vsum = vadd_vv_i16m2(vsum, vdata, vl);\n        vprod = vmul_vv_i16m2(vprod, vdata, vl);\n    }\n\n    // Horizontal sum\n    for(int j = vlmax / 2; j > 0; j /= 2){\n        vsum = vredsum_vs_i16m2_i64m1(vsum, vsum, vlmax);\n        vprod = vredmul_vs_i16m2_i64m1(vprod, vprod, vlmax);\n    }\n\n    sum += vmv_x_s_i64m1_i64(vsum);\n    product *= vmv_x_s_i64m1_i64(vprod);\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers){\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    size_t size = numbers.size();\n    int16_t *data = numbers.data();\n\n    uint64_t vlen = vsetvl_e16m2(size);\n    vint16m2_t v_num = vmv_v_x_i16m2(0, vlen);\n\n    size_t i = 0;\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    for (; i + vlen <= size; i += vlen) {\n        v_num = vle16_v_i16m2(data + i, vlen);\n        sum += vmv_x_s_i32m2_i32(vredsum_vs_i32m2_i32m2_int(vmseq_vx_i16m2_b16m1(v_num, 0, vlen), v_num, 0, vlen));\n        product *= vmv_x_s_i32m2_i32(vprod_vs_i16m2_i16m2_i32(vmsne_vx_i16m2_b16m1(v_num, 0, vlen), v_num, 1, vlen));\n    }\n\n    for (; i < size; ++i) {\n        sum += data[i];\n        product *= data[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers){\n    size_t size = numbers.size();\n    if (size == 0) return {0, 1};\n\n    int16_t *data = numbers.data();\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    size_t vlmax = vsetvl_e16m2(size);\n    vint16m2_t v_num = vmv_v_x_i16m2(0, vlmax);\n    vint64m4_t v_sum = vmv_v_x_i64m4(0, vlmax);\n    vint64m4_t v_product = vmv_v_x_i64m4(1, vlmax);\n\n    for (size_t i = 0; i < size; i += vlmax) {\n        size_t vl = vsetvl_e16m2(size - i);\n        v_num = vle16_v_i16m2(data + i, vl);\n        v_sum = vredsum_vs_i16m2_i64m4(v_num, v_sum, vl);\n        v_product = vmul_vv_i64m4(v_product, vreinterpret_v_i64m4(v_num), vl);\n    }\n\n    sum = vmv_x_s_i64m4_i64(v_sum);\n    product = vmv_x_s_i64m4_i64(v_product);\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers){\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    size_t size = numbers.size();\n    int16_t *data = numbers.data();\n\n    vl_len_t vlen = __riscv_vl_max();\n    size_t vl = __riscv_vsetvl_e16m2(vlen);\n\n    vint16m2_t vmask = __riscv_vmv_v_x_i16m2(0, vl);\n    vint16m2_t vdata = __riscv_vle16_v_i16m2(data, vl);\n\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    for(size_t i = 0; i < size; i += vl) {\n        size_t current_vl = (size - i) > vl ? vl : (size - i);\n        vint16m2_t vt = __riscv_vlse16_v_i16m2(vmask, data + i, 1, current_vl);\n\n        // Calculate sum\n        vint32m4_t vsumt = __riscv_vwredsum_vs_i16m2_i32m4(vt, __riscv_vmv_v_x_i32m4(0, current_vl), current_vl);\n        sum += __riscv_vmv_x_s_i32m4_i32(vsumt);\n\n        // Calculate product\n        vint16m2_t vprodt = __riscv_vredprod_vs_i16m2_i16m2(vt, __riscv_vmv_v_x_i16m2(1, current_vl), current_vl);\n        product *= __riscv_vmv_x_s_i16m2_i16(vprodt);\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers){\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    size_t size = numbers.size();\n    int16_t *data = numbers.data();\n\n    size_t vlmax = vlenb() / sizeof(int16_t);\n    size_t num_full = size / vlmax;\n    size_t remainder = size % vlmax;\n\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    for (size_t i = 0; i < num_full; ++i) {\n        size_t vl = vlmax;\n        vint16m1_t vmask = vmv_v_x_i16m1(0, vl);\n        vint16m1_t vdata = vle16_v_i16m1(data + i * vlmax, vl);\n\n        // Compute sum\n        vint32m2_t vsum_temp = vmv_v_x_i32m2(0, vl);\n        vsum_temp = vredsum_vs_i16m1_i32m2(vsum_temp, vdata, vmask, vl);\n        sum += vmv_x_s_i32m2_i32(vsum_temp);\n\n        // Compute product\n        vint32m2_t vprod_temp = vmv_v_x_i32m2(1, vl);\n        vprod_temp = vredmul_vs_i16m1_i32m2(vprod_temp, vdata, vmask, vl);\n        product *= vmv_x_s_i32m2_i32(vprod_temp);\n    }\n\n    if (remainder > 0) {\n        size_t vl = remainder;\n        vint16m1_t vmask = vmv_v_x_i16m1(0, vl);\n        vint16m1_t vdata = vle16_v_i16m1(data + num_full * vlmax, vl);\n\n        // Compute sum\n        vint32m2_t vsum_temp = vmv_v_x_i32m2(0, vl);\n        vsum_temp = vredsum_vs_i16m1_i32m2(vsum_temp, vdata, vmask, vl);\n        sum += vmv_x_s_i32m2_i32(vsum_temp);\n\n        // Compute product\n        vint32m2_t vprod_temp = vmv_v_x_i32m2(1, vl);\n        vprod_temp = vredmul_vs_i16m1_i32m2(vprod_temp, vdata, vmask, vl);\n        product *= vmv_x_s_i32m2_i32(vprod_temp);\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_67_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers){\n    size_t size = numbers.size();\n    if (size == 0) return {};\n\n    std::vector<int> result(size);\n    int vm = 1;\n    size_t vlmax = vsetvl_e32m1(1);\n\n    int current_max = numbers[0];\n    result[0] = current_max;\n\n    for(size_t i = 1; i < size; ){\n        size_t vl = vsetvl_e32m1(std::min((size_t)256, size - i));\n        vint32m1_t vmask = vmaskoff_v_i32m1(vl);\n        \n        vint32m1_t vcurrent_max = vmv_v_x_i32m1(current_max, vl);\n        vint32m1_t vnumbers = vle32_v_i32m1(numbers.data() + i, vl);\n\n        vint32m1_t vmax = vmax_vv_i32m1(vcurrent_max, vnumbers, vl);\n        current_max = vmaxreduceumax_vs_i32m1_i32(vmax, vmask, vl);\n\n        vse32_v_i32m1(result.data() + i, vmax, vl);\n        i += vl;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers){\n    if (numbers.empty()) return {};\n\n    size_t size = numbers.size();\n    std::vector<int> result(size, 0);\n\n    size_t vlmax = vsetvl_e32m1(size);\n    int* ptr_numbers = numbers.data();\n    int* ptr_result = result.data();\n\n    int current_max = numbers[0];\n    ptr_result[0] = current_max;\n\n    for(size_t i = 1; i < size; ){\n        size_t vl = vsetvl_e32m1(size - i);\n        vint32m1_t vmask = vmseq_visi32m1(i, vl);\n        vint32m1_t vcurrent_max = vmv_v_x_i32m1(current_max, vl);\n        vint32m1_t vload = vle32_v_i32m1(ptr_numbers + i, vl);\n        vint32m1_t vmax = vmax_vv_i32m1(vcurrent_max, vload, vl);\n        vse32_v_i32m1(ptr_result + i, vmax, vl);\n        current_max = std::max(current_max, ptr_numbers[i + vl - 1]);\n        i += vl;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers){\n    size_t size = numbers.size();\n    if (size == 0) return {};\n\n    std::vector<int> result(size);\n    int vm = 1;\n    size_t vlmax = vsetvl_e32m1(size);\n\n    for (size_t i = 0; i < size; i += vlmax) {\n        size_t vl = vsetvl_e32m1(size - i);\n        vint32m1_t v_numbers = vle32_v_i32m1(&numbers[i], vl);\n        vint32m1_t v_result;\n\n        if (i == 0) {\n            v_result = v_numbers;\n        } else {\n            vint32m1_t v_prev_max = vle32_v_i32m1(&result[i - 1], vl);\n            v_result = vmax_vv_i32m1(v_numbers, v_prev_max, vl);\n        }\n\n        vse32_v_i32m1(&result[i], v_result, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers){\n    size_t size = numbers.size();\n    if (size == 0) return {};\n\n    std::vector<int> result(size);\n    int vm = 1;\n    size_t block_size = sizeof(vuint32m1_t) * 8;\n\n    for (size_t i = 0; i < size; i += block_size) {\n        size_t current_block_size = std::min(block_size, size - i);\n\n        vint32m1_t vmax = vmv_v_x_i32m1(numbers[i], current_block_size);\n        vint32m1_t vdata = vlseg1ea_v_i32m1(&numbers[i], current_block_size);\n\n        for (size_t j = 0; j < current_block_size; ++j) {\n            vmax = vfmax_vv_i32m1(vmax, vlsseg1idx_v_i32m1(j, &numbers[i], current_block_size), vm);\n        }\n\n        vse1seg_v_i32m1(&result[i], vmax, current_block_size);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers){\n    size_t size = numbers.size();\n    if (size == 0) return {};\n\n    std::vector<int> result(size);\n    int vm = 1;\n    size_t vlmax = vsetvl_e32m1(size);\n\n    for(size_t i = 0; i < size; i += vlmax){\n        size_t vl = vsetvl_e32m1(size - i);\n        vint32m1_t v_numbers = vle32_v_i32m1(&numbers[i], vl);\n        vint32m1_t v_result;\n\n        if(i == 0){\n            v_result = v_numbers;\n        }\n        else{\n            vint32m1_t v_prev_max = vle32_v_i32m1(&result[i-1], vl);\n            v_result = vmax_vv_i32m1(v_numbers, v_prev_max, vl);\n        }\n\n        vse32_v_i32m1(&result[i], v_result, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b){\n    size_t size = a.size();\n    std::string result(size, '0');\n    size_t i = 0;\n    size_t vl = 0;\n\n    // Process vectors\n    for (; i <= size - vsetvl_e8m1(0); i += vl) {\n        vl = vsetvl_e8m1(i);\n        vuint8m1_t va = vle8_v_u8m1(reinterpret_cast<const uint8_t*>(&a[i]), vl);\n        vuint8m1_t vb = vle8_v_u8m1(reinterpret_cast<const uint8_t*>(&b[i]), vl);\n        vuint8m1_t vxor = vxor_vv_u8m1(va, vb, vl);\n        vse8_v_u8m1(reinterpret_cast<uint8_t*>(&result[i]), vxor, vl);\n    }\n\n    // Handle remaining scalar elements if any\n    for (; i < size; ++i) {\n        result[i] = (a[i] == '1') ^ (b[i] == '1') ? '1' : '0';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b){\n    size_t size = a.size();\n    std::string result(size, '0');\n    \n    size_t vl = vsetvl_e8m1(size);\n    uint8_t *ptr_a = (uint8_t *)a.data();\n    uint8_t *ptr_b = (uint8_t *)b.data();\n    uint8_t *ptr_result = (uint8_t *)result.data();\n    \n    vuint8m1_t va, vb, vxor;\n    \n    for(size_t i = 0; i < size; i += vl){\n        size_t sub_size = (size - i) > vl ? vl : (size - i);\n        vl = vsetvl_e8m1(sub_size);\n        va = vle8_v_u8m1(ptr_a + i, vl);\n        vb = vle8_v_u8m1(ptr_b + i, vl);\n        vxor = vxor_vv_u8m1(va, vb, vl);\n        vse8_v_u8m1(ptr_result + i, vxor, vl);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_68_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b){\n    size_t size = a.size();\n    size_t vl = vsetvl_e8m1(size);\n    uint8_t *aa = (uint8_t *)a.data();\n    uint8_t *bb = (uint8_t *)b.data();\n    uint8_t *res = new uint8_t[size];\n    vuint8m1_t va, vb, vw;\n    for(size_t i=0; i<size; i+=vl){\n        size_t subvl = vsetvl_e8m1(size - i);\n        va = vle8_v_u8m1(aa + i, subvl);\n        vb = vle8_v_u8m1(bb + i, subvl);\n        vw = vxor_vv_u8m1(va, vb, subvl);\n        vse8_v_u8m1(res + i, vw, subvl);\n    }\n    std::string result(res, res + size);\n    delete[] res;\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b){\n    size_t size = a.size();\n    size_t vl = vsetvl_e8m1(size);\n    uint8_t *result = (uint8_t *)malloc(size * sizeof(uint8_t));\n    const uint8_t *aa = (const uint8_t *)a.c_str();\n    const uint8_t *bb = (const uint8_t *)b.c_str();\n\n    vuint8m1_t va, vb, vr;\n    for(size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e8m1(size - i);\n        va = vle8_v_u8m1(aa + i, vl);\n        vb = vle8_v_u8m1(bb + i, vl);\n        vr = vmxor_vv_u8m1(va, vb, vl);\n        vse8_v_u8m1(result + i, vr, vl);\n    }\n\n    std::string res((char*)result, size);\n    free(result);\n    return res;\n}\n```"}
{"task_id": "SimdBench_68_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b){\n    size_t size = a.size();\n    size_t vl = vsetvl_e8m1(size);\n    uint8_t *vec_a = (uint8_t *)a.data();\n    uint8_t *vec_b = (uint8_t *)b.data();\n    uint8_t *result = new uint8_t[size];\n    \n    vuint8m1_t va = lv_u8_v(vec_a, vl);\n    vuint8m1_t vb = lv_u8_v(vec_b, vl);\n    vuint8m1_t vr = vxor_vv_u8m1(va, vb, vl);\n    sv_u8_v(result, vr, vl);\n\n    std::string res((char*)result, size);\n    delete[] result;\n    return res;\n}\n```"}
{"task_id": "SimdBench_69_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <vector>\n#include <climits>\n\nstd::string longest_simd(const std::vector<std::string> & strings){\n    if (strings.empty()) return \"\";\n\n    size_t max_len = 0;\n    size_t max_idx = 0;\n\n    const size_t vl = strings.size();\n    size_t chunk_size = 8; // Assuming vector can handle 8 strings at once\n\n    for(size_t i = 0; i < vl; i += chunk_size){\n        size_t actual_chunk_size = (vl - i) < chunk_size ? (vl - i) : chunk_size;\n\n        vuint32m1_t v_lengths = vmv_v_x_u32m1(0, actual_chunk_size);\n        for(size_t j = 0; j < actual_chunk_size; ++j){\n            v_lengths = vsext_vf4(vmv_x_s_u32m1_u32(v_lengths, strings[i+j].length()), actual_chunk_size);\n        }\n\n        uint32_t max_in_vec = vmax_v_u32m1(v_lengths, actual_chunk_size);\n        size_t local_max_idx = i + vmfirst_m(vmseq_vu_u32m1_b1(v_lengths, max_in_vec, actual_chunk_size));\n\n        if(max_in_vec > max_len){\n            max_len = max_in_vec;\n            max_idx = local_max_idx;\n        }\n    }\n\n    return strings[max_idx];\n}\n```"}
{"task_id": "SimdBench_69_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <vector>\n#include <climits>\n\nstd::string longest_simd(const std::vector<std::string> & strings){\n    if (strings.empty()) return \"\";\n\n    size_t max_length = 0;\n    size_t max_index = 0;\n\n    size_t vl = vsetvl_e64m1(strings.size());\n    size_t current_index = 0;\n\n    while(current_index < strings.size()){\n        vl = vsetvl_e64m1(std::min(vl, static_cast<size_t>(strings.size() - current_index)));\n        vuint64m1_t indices = vid_v_u64m1(vl);\n        vuint64m1_t lengths = vmv_v_x_u64m1(0, vl);\n\n        for(size_t i = 0; i < vl; ++i){\n            if(current_index + i < strings.size()){\n                uint64_t len = strings[current_index + i].length();\n                lengths = vsext_vf4(lengths, len, vl);\n            }\n        }\n\n        vbool64_t mask = vmge_vv_b64m1(lengths, vmv_v_x_u64m1(max_length, vl), vl);\n        vuint64m1_t candidates = vand_vv_u64m1(indices, mask, vl);\n        uint64_t new_max_length = vmax_reduce_v_s_u64m1_u64(lengths, vl);\n        uint64_t new_max_index = 0;\n\n        if(new_max_length > max_length){\n            max_length = new_max_length;\n            new_max_index = vorReduce_v_s_u64m1(candidates, vl);\n            max_index = current_index + new_max_index;\n        }\n\n        current_index += vl;\n    }\n\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_69_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <vector>\n#include <climits>\n\nstd::string longest_simd(const std::vector<std::string> & strings){\n    if (strings.empty()) return \"\";\n\n    size_t max_length = 0;\n    size_t max_index = 0;\n\n    size_t vl = vsetvl_e64m1(strings.size());\n    size_t current_index = 0;\n\n    while (current_index < strings.size()) {\n        vl = vsetvl_e64m1(std::min<size_t>(strings.size() - current_index, vl));\n        vuint64m1_t v_indices = vid_v_u64m1(vl);\n        vuint64m1_t v_lengths = vmv_v_x_u64m1(0, vl);\n\n        for (size_t i = 0; i < vl; ++i) {\n            if (current_index + i < strings.size()) {\n                uint64_t length = strings[current_index + i].length();\n                vstore_v_u64(&v_lengths, i, length);\n            }\n        }\n\n        vbool64_t mask = vmge_vx_u64m1_b64(v_lengths, max_length, vl);\n        vuint64m1_t candidates = vand_vv_u64m1(v_indices, mask, vl);\n        vuint64m1_t first_candidate = vmfirst_m_u64m1(candidates, vl);\n\n        uint64_t candidate_index = vmfirst_x_u64(first_candidate, vl);\n        if (candidate_index != UINT64_MAX && (current_index + candidate_index) < strings.size()) {\n            uint64_t candidate_length = strings[current_index + candidate_index].length();\n            if (candidate_length > max_length) {\n                max_length = candidate_length;\n                max_index = current_index + candidate_index;\n            }\n        }\n\n        current_index += vl;\n    }\n\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_69_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <vector>\n#include <climits>\n\nstd::string longest_simd(const std::vector<std::string> & strings){\n    if (strings.empty()) return \"\";\n\n    size_t max_length = 0;\n    size_t max_index = 0;\n\n    const size_t vl = strings.size();\n    size_t i = 0;\n\n    // Vectorized processing\n    {\n        size_t vlen = __riscv_vsetvl_e64m8(vl);\n        size_t *lengths = new size_t[vl];\n        for(size_t j = 0; j < vl; ++j){\n            lengths[j] = strings[i+j].length();\n        }\n\n        vuint64m8_t vlens = __riscv_vle64_v_u64m8(lengths, vlen);\n        vuint64m8_t vmax = __riscv_vmxei64_v_u64m8(0, vlen);\n        size_t index = 0;\n\n        for(size_t j = 0; j < vl; ++j){\n            vmax = __riscv_vmax_vx_u64m8(vmax, lengths[j], vlen);\n            if(lengths[j] > max_length){\n                max_length = lengths[j];\n                max_index = i + j;\n            }\n        }\n        i += vl;\n        delete[] lengths;\n    }\n\n    // Sequential processing for remainder\n    for(; i < strings.size(); ++i){\n        if(strings[i].length() > max_length){\n            max_length = strings[i].length();\n            max_index = i;\n        }\n    }\n\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_69_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <vector>\n#include <climits>\n\nstd::string longest_simd(const std::vector<std::string> & strings){\n    if (strings.empty()) return \"\";\n\n    size_t max_length = 0;\n    size_t max_index = 0;\n\n    const size_t vl = strings.size();\n    size_t i = 0;\n\n    // Vectorized processing\n    while (i + vsetvl_e64m1(1) <= vl) {\n        size_t vl_current = vsetvl_e64m1(1);\n        vuint64m1_t v_lengths = vmv_v_x_u64m1(0, vl_current);\n\n        for (size_t j = 0; j < vl_current; ++j) {\n            v_lengths = vssub_vx_u64m1(v_lengths, strings[i+j].length(), vl_current);\n        }\n\n        vbool64_t v_mask = vmge_vx_u64m1_b64(v_lengths, max_length, vl_current);\n        vuint64m1_t v_indices = vmv_v_x_u64m1(i, vl_current);\n        v_indices = vmf_v_x_u64m1(v_indices, i, vl_current);\n\n        uint64_t reduce_max_length = vmr_gte_v_u64m1_u64(v_lengths, vl_current);\n        uint64_t reduce_max_index = vmr_gte_v_u64m1_u64(v_indices, vl_current);\n\n        if (reduce_max_length > max_length) {\n            max_length = reduce_max_length;\n            max_index = reduce_max_index;\n        }\n\n        i += vl_current;\n    }\n\n    // Scalar processing for leftovers\n    for (; i < vl; ++i) {\n        if (strings[i].length() > max_length) {\n            max_length = strings[i].length();\n            max_index = i;\n        }\n    }\n\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_70_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    size_t vl = vsetvl_e64m1(1);\n    vuint64m1_t va = vmv_v_x_u64m1(a, vl);\n    vuint64m1_t vb = vmv_v_x_u64m1(b, vl);\n\n    while (true) {\n        vuint64m1_t vt = vminu_vv_u64m1(va, vb, vl);\n        vb = vsubu_vx_u64m1(vb, vmv_v_x_u64m1(0, vl), vl);\n        vb = vmerge_vvm_u64m1(vt, vb, vb, vl);\n        va = vt;\n        if (vfirst_m(vmseq_vx_b64m1(vb, 0, vl))) {\n            break;\n        }\n    }\n\n    return vmv_x_s_u64m1_v(va, vl);\n}\n```"}
{"task_id": "SimdBench_70_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    size_t vl = vsetvl_e64m1(1);\n    vuint64m1_t va = vmv_v_x_u64m1(a, vl);\n    vuint64m1_t vb = vmv_v_x_u64m1(b, vl);\n\n    while (true) {\n        vuint64m1_t vt = vminu_vv_u64m1(va, vb, vl);\n        vb = vsubu_vv_u64m1(vmaxu_vv_u64m1(va, vb, vl), vt, vl);\n        va = vt;\n        if (vmseq_vx_u64m1_b1(vb, 0, vl).b[0]) {\n            break;\n        }\n    }\n\n    return vmv_x_s_u64m1_u64(va, vl);\n}\n```"}
{"task_id": "SimdBench_70_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    size_t vl = vsetvl_e64m1(1);\n    vuint64m1_t va = vmv_v_x_u64m1(a, vl);\n    vuint64m1_t vb = vmv_v_x_u64m1(b, vl);\n\n    while (true) {\n        vuint64m1_t vt = vminu_vv_u64m1(va, vb, vl);\n        vb = vsubu_vx_u64m1(vb, vmv_v_x_u64m1(0, vl), vl);\n        vb = vmaxu_vv_u64m1(va, vb, vl);\n        va = vt;\n        if (vmsne_vx_i64m1_b64m1(vb, 0, vl) == 0) break;\n    }\n\n    return vmv_x_s_u64m1_v(va, vl);\n}\n```"}
{"task_id": "SimdBench_70_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b){\n    size_t vl = vsetvl_e64m1(1);\n    vuint64m1_t va = vmv_v_x_u64m1(a, vl);\n    vuint64m1_t vb = vmv_v_x_u64m1(b, vl);\n\n    while (true) {\n        vuint64m1_t vt = vminu_vv_u64m1(va, vb, vl);\n        vb = vsubu_vv_u64m1(va, vb, vl);\n        va = vt;\n        if (vmseq_vx_u64m1_b1(vb, 0, vl).b1[0]) {\n            break;\n        }\n    }\n\n    return vmv_x_s_u64m1_v(va, vl);\n}\n```"}
{"task_id": "SimdBench_70_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    uint64_t t;\n    vuint64m1_t va, vb, vt;\n    va = vmv_v_x_u64m1(a, 1);\n    vb = vmv_v_x_u64m1(b, 1);\n\n    while (true) {\n        vt = vmremu_vv_u64m1(va, vb, 1);\n        va = vb;\n        vb = vt;\n        if (vfirst_m(vmsne_vx_u64m1(vb, 0, 1)) == 0) {\n            break;\n        }\n    }\n\n    return vmv_x_s_u64m1_v(va, 1);\n}\n```"}
{"task_id": "SimdBench_71_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers){\n    if (numbers.size() < 2) return {};\n\n    size_t vl = numbers.size();\n    float vmin = std::abs(numbers[1] - numbers[0]);\n    float vnum1 = numbers[0];\n    float vnum2 = numbers[1];\n\n    size_t l = vl;\n    size_t i = 0;\n\n    for (; vl != 0; vl = vsetvl_e32m1(i)) {\n        float* num_ptr = &numbers[i];\n        vfloat32m1_t vm_num = vle32_v_f32m1(num_ptr, vl);\n        vfloat32m1_t vm_min = vmv_v_f_f32m1(vmin, vl);\n\n        size_t j = 0;\n        for (; l != 0; l = vsetvl_e32m1(j)) {\n            float* cmp_ptr = &numbers[j];\n            vfloat32m1_t vm_cmp = vle32_v_f32m1(cmp_ptr, l);\n\n            vfloat32m1_t vm_diff = vfsub_vv_f32m1(vm_num, vm_cmp, vl);\n            vfloat32m1_t vm_absdiff = vfabs_v_f32m1(vm_diff, vl);\n\n            vbool32_t vm_mask = vmflt_vv_f32m1_b32(vm_absdiff, vm_min, vl);\n\n            vm_min = vmfredmin_vs_f32m1_f32(vm_absdiff, vm_min, vl);\n\n            size_t k = 0;\n            for (; k < vl && k < l; k++) {\n                if (vmaskoff_b32(vm_mask, k)) {\n                    float diff = std::abs(numbers[i + k] - numbers[j + k]);\n                    if (diff < vmin) {\n                        vmin = diff;\n                        if (numbers[i + k] < numbers[j + k]) {\n                            vnum1 = numbers[i + k];\n                            vnum2 = numbers[j + k];\n                        } else {\n                            vnum1 = numbers[j + k];\n                            vnum2 = numbers[i + k];\n                        }\n                    }\n                }\n            }\n            j += l;\n        }\n        i += vl;\n    }\n\n    return {vnum1, vnum2};\n}\n```"}
{"task_id": "SimdBench_71_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers){\n    size_t vl = vsetvl_e32m1(numbers.size());\n    vfloat32m1_t v_numbers = vle32_v_f32m1(numbers.data(), vl);\n    float min_diff = std::abs(numbers[1] - numbers[0]);\n    float closest_a = numbers[0];\n    float closest_b = numbers[1];\n\n    for(size_t i = 0; i < numbers.size() - 1; ++i){\n        size_t j_vl = vsetvl_e32m1(numbers.size() - i - 1);\n        vfloat32m1_t v_current = vmv_v_x_f32m1(numbers[i], j_vl);\n        vfloat32m1_t v_remaining = vle32_v_f32m1(&numbers[i+1], j_vl);\n        vfloat32m1_t v_diff = vfsub_vv_f32m1(v_remaining, v_current, j_vl);\n        vfloat32m1_t v_abs_diff = vfabs_v_f32m1(v_diff, j_vl);\n\n        size_t j = i + 1;\n        for (float diff : vget_float32m1_vf(v_abs_diff, j_vl)) {\n            if (diff < min_diff) {\n                min_diff = diff;\n                closest_a = numbers[i];\n                closest_b = numbers[j];\n            }\n            j++;\n        }\n    }\n\n    return {std::min(closest_a, closest_b), std::max(closest_a, closest_b)};\n}\n```"}
{"task_id": "SimdBench_71_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers){\n    size_t vlen = __riscv_vlmax();\n    size_t n = numbers.size();\n    float min_diff = std::abs(numbers[1] - numbers[0]);\n    float closest_a = numbers[0];\n    float closest_b = numbers[1];\n\n    for(size_t i = 0; i < n - 1; ){\n        size_t vl = std::min(vlen, static_cast<size_t>(n - 1 - i));\n        vfloat32m1_t vmask = __riscv_vmv_v_x_f32m1(0.0f, vl);\n        vfloat32m1_t vcurrent = __riscv_vle32_v_f32m1(&numbers[i], vl);\n        vfloat32m1_t vnext = __riscv_vle32_v_f32m1(&numbers[i+1], vl);\n        vfloat32m1_t vdiff = __riscv_vfsub_vv_f32m1(vnext, vcurrent, vl);\n        vfloat32m1_t vdiff_abs = __riscv_vfabs_v_f32m1(vdiff, vl);\n\n        size_t j = 0;\n        while(j < vl){\n            float diff_s = __riscv_vfmv_f_s_f32m1(vdiff_abs, vl);\n            if(diff_s < min_diff){\n                min_diff = diff_s;\n                closest_a = numbers[i + j];\n                closest_b = numbers[i + j + 1];\n            }\n            j++;\n        }\n        i += vl;\n    }\n\n    std::vector<float> result = {std::min(closest_a, closest_b), std::max(closest_a, closest_b)};\n    return result;\n}\n```"}
{"task_id": "SimdBench_71_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers){\n    if (numbers.size() < 2) return {};\n\n    size_t vl = vsetvl_e32m1(numbers.size());\n    float min_diff = std::abs(numbers[1] - numbers[0]);\n    float closest_a = numbers[0];\n    float closest_b = numbers[1];\n\n    for(size_t i = 0; i < numbers.size() - 1; ++i){\n        size_t j = i + 1;\n        size_t vl_j = vsetvl_e32m1(numbers.size() - j);\n        vfloat32m1_t vmask = vmv_v_x_f32m1(1.0, vl_j);\n        vfloat32m1_t vbase = vmv_v_f_f32m1(numbers[i], vl_j);\n        vfloat32m1_t vcurrent = vle32_v_f32m1(&numbers[j], vl_j);\n        vfloat32m1_t vdiff = vfsub_vv_f32m1(vcurrent, vbase, vl_j);\n        vfloat32m1_t vdiff_abs = vfabs_v_f32m1(vdiff, vl_j);\n\n        size_t k = 0;\n        size_t l = j;\n        while(k < vl_j){\n            float diff_val = vfmv_f_s_f32m1_f(vdiff_abs, vl_j);\n            if(diff_val < min_diff){\n                min_diff = diff_val;\n                closest_a = numbers[i];\n                closest_b = numbers[l];\n            }\n            vdiff_abs = vssrl_vx_f32m1(vdiff_abs, 1, vl_j);\n            ++k;\n            ++l;\n        }\n    }\n\n    if(closest_a > closest_b){\n        std::swap(closest_a, closest_b);\n    }\n\n    return {closest_a, closest_b};\n}\n```"}
{"task_id": "SimdBench_71_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers){\n    size_t vl = vsetvl_e32m1(numbers.size());\n    float min_diff = std::abs(numbers[1] - numbers[0]);\n    float closest_a = numbers[0];\n    float closest_b = numbers[1];\n\n    for(size_t i = 0; i < numbers.size() - 1; ){\n        size_t vl = vsetvl_e32m1(numbers.size() - i - 1);\n        vfloat32m1_t vmask = vmv_v_x_f32m1(0, vl);\n        vfloat32m1_t vcurrent = vle32_v_f32m1(&numbers[i], vl);\n        vfloat32m1_t vnext = vle32_v_f32m1(&numbers[i+1], vl);\n        vfloat32m1_t vdiff = vfsub_vv_f32m1(vnext, vcurrent, vl);\n        vfloat32m1_t vabsdiff = vfabs_v_f32m1(vdiff, vl);\n\n        for(int j=0; j < vl; j++){\n            float diff = vfmv_f_s_f32m1(vabsdiff, j);\n            if(diff < min_diff){\n                min_diff = diff;\n                closest_a = numbers[i+j];\n                closest_b = numbers[i+j+1];\n            }\n        }\n        i += vl;\n    }\n\n    if(closest_a > closest_b){\n        std::swap(closest_a, closest_b);\n    }\n\n    return {closest_a, closest_b};\n}\n```"}
{"task_id": "SimdBench_72_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers){ \n    if (numbers.size() < 2) return numbers;\n\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n\n    if (min_val == max_val) {\n        std::vector<float> result(numbers.size(), 0.0f);\n        return result;\n    }\n\n    size_t vl = vsetvl_e32m1(numbers.size());\n    vfloat32m1_t vmin_v = vmv_v_f_f32(min_val, vl);\n    vfloat32m1_t vmax_v = vmv_v_f_f32(max_val, vl);\n\n    std::vector<float> result(numbers.size());\n    for(size_t i = 0; i < numbers.size(); i += vl){\n        size_t subvl = vsetvl_e32m1(std::min(vl, (size_t)(numbers.size() - i)));\n        vfloat32m1_t vin = vle32_v_f32(&numbers[i], subvl);\n        vfloat32m1_t vsub = vfsub_vv_f32(vin, vmin_v, subvl);\n        vfloat32m1_t vrange = vfsub_vv_f32(vmax_v, vmin_v, subvl);\n        vfloat32m1_t vscaled = vfdiv_vv_f32(vsub, vrange, subvl);\n        vse32_v_f32(&result[i], vscaled, subvl);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers){\n    if (numbers.size() < 2) return numbers;\n\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n\n    if (min_val == max_val) {\n        std::vector<float> result(numbers.size(), 0.0f);\n        return result;\n    }\n\n    size_t vl = vsetvl_e32m1(numbers.size());\n    vfloat32m1_t vmin_v = vmv_v_f_f32(min_val, vl);\n    vfloat32m1_t vmax_v = vmv_v_f_f32(max_val, vl);\n\n    std::vector<float> result(numbers.size());\n    for(size_t i = 0; i < numbers.size(); i += vl){\n        size_t subvl = vsetvl_e32m1(std::min(vl, (size_t)(numbers.size() - i)));\n        vfloat32m1_t vnum = vle32_v_f32(&numbers[i], subvl);\n        vfloat32m1_t vsub = vsub_vv_f32(vnum, vmin_v, subvl);\n        vfloat32m1_t vrange = vsub_vv_f32(vmax_v, vmin_v, subvl);\n        vfloat32m1_t vres = vdiv_vv_f32(vsub, vrange, subvl);\n        vse32_v_f32(&result[i], vres, subvl);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers){\n    if (numbers.size() < 2) return numbers;\n\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n\n    if (min_val == max_val) {\n        std::vector<float> result(numbers.size(), 0.0);\n        return result;\n    }\n\n    size_t vl = vsetvl_e32m1(numbers.size());\n    vfloat32m1_t vmin_v = vmv_v_f_f32(min_val, vl);\n    vfloat32m1_t vmax_v = vmv_v_f_f32(max_val, vl);\n\n    std::vector<float> result(numbers.size());\n    for(size_t i = 0; i < numbers.size(); i += vl){\n        size_t subvl = vsetvl_e32m1(std::min(vl, (size_t)(numbers.size() - i)));\n        vfloat32m1_t vnum = vle32_v_f32(&numbers[i], subvl);\n        vfloat32m1_t vsub = vsub_vv_f32(vnum, vmin_v, subvl);\n        vfloat32m1_t vrange = vsub_vv_f32(vmax_v, vmin_v, subvl);\n        vfloat32m1_t vres = vdiv_vv_f32(vsub, vrange, subvl);\n        vse32_v_f32(&result[i], vres, subvl);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers){\n    if (numbers.size() < 2) return numbers;\n\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n\n    if (min_val == max_val) {\n        std::vector<float> result(numbers.size(), 0.0);\n        return result;\n    }\n\n    size_t vl = vsetvl_e32m1(numbers.size());\n    vfloat32m1_t vmin = vmv_v_f_f32(min_val, vl);\n    vfloat32m1_t vmax = vmv_v_f_f32(max_val, vl);\n    vfloat32m1_t vrange = vfsub_vf_f32(vmax, min_val, vl);\n\n    std::vector<float> result(numbers.size());\n    for(size_t i = 0; i < numbers.size(); i += vl){\n        size_t sub vl = vsetvl_e32m1(std::min(vl, (size_t)(numbers.size() - i)));\n        vfloat32m1_t vin = vle32_v_f32(&numbers[i], sub_vl);\n        vfloat32m1_t vrescaled = vfdiv_vv_f32(vfsub_vv_f32(vin, vmin, sub_vl), vrange, sub_vl);\n        vse32_v_f32(&result[i], vrescaled, sub_vl);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    if (numbers.size() < 2) return numbers;\n\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n\n    if (min_val == max_val) {\n        // Avoid division by zero if all elements are the same\n        std::vector<float> result(numbers.size(), 0.0f);\n        return result;\n    }\n\n    size_t size = numbers.size();\n    std::vector<float> result(size);\n\n    float scale = 1.0f / (max_val - min_val);\n\n    size_t vl = vsetvl_e32m1(size);\n    vfloat32m1_t vmin_v = vmv_v_f_f32(min_val, vl);\n    vfloat32m1_t vscale_v = vmv_v_f_f32(scale, vl);\n\n    for (size_t i = 0; i < size; i += vl) {\n        size_t chunk_size = std::min(size - i, (size_t)vl);\n        vfloat32m1_t vnum_v = vle32_v_f32(&numbers[i], chunk_size);\n        vfloat32m1_t vsub_v = vsub_vf_f32m1(vnum_v, vmin_v, chunk_size);\n        vfloat32m1_t vmul_v = vmul_vf_f32m1(vsub_v, vscale_v, chunk_size);\n        vse32_v_f32(&result[i], vmul_v, chunk_size);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_73_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t largest_divisor_simd(uint64_t n){\n    if (n <= 1) return 0;\n    uint64_t result = 0;\n    size_t vlen = vsetvl_e64m1(1);\n    vuint64m1_t vn = vmv_v_x_u64m1(n, vlen);\n    for(uint64_t i = n/2; i > 0; i--){\n        vuint64m1_t vi = vmv_v_x_u64m1(i, vlen);\n        vuint64m1_t rem = vremu_vx_u64m1(vi, n, vlen);\n        vbool64_t check = vmseq_vx_b64m1(rem, 0, vlen);\n        if (vfirst_m_b64m1(check)) {\n            result = i;\n            break;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_73_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t largest_divisor_simd(uint64_t n){\n    if (n <= 1) return 0;\n\n    uint64_t result = 0;\n    size_t vlen = vsetvl_e64m1(n-1);\n    vuint64m1_t vmask = vmseq_u64_vv_i64m1(vmv_v_x_i64m1(n, vlen), vmv_v_x_i64m1(n, vlen), vlen);\n    vuint64m1_t vnums = vid_v_u64m1(vlen);\n    vuint64m1_t vrem = vmremu_vx_u64m1(vnums, n, vmask, vlen);\n    vuint64m1_t vzero = vmv_v_x_u64m1(0, vlen);\n    vmask = vmseq_vv_u64m1(vrem, vzero, vmask, vlen);\n\n    for(int i = n-1; i > 0; i--){\n        if (vbitget_mask_m_b1(vmask, i)) {\n            result = i;\n            break;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_73_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t largest_divisor_simd(uint64_t n){\n    uint64_t result = 1;\n    if (n <= 1) return 0;\n\n    size_t vlen = vsetvl_e64m1(1);\n    vuint64m1_t vn = vmv_v_x_u64m1(n, vlen);\n    vuint64m1_t vone = vmv_v_x_u64m1(1, vlen);\n\n    for(uint64_t i = 2; i < n; i++) {\n        vuint64m1_t vi = vmv_v_x_u64m1(i, vlen);\n        vuint64m1_t remainder = vremu_vx_u64m1(vn, i, vlen);\n        vbool8_t cond = vmseq_vx_b8m1(remainder, 0, vlen);\n        result = vmfmerge_x_m_u64m1(result, vi, cond, vlen);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_73_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t largest_divisor_simd(uint64_t n){\n    uint64_t result = 1;\n    if (n <= 1) return 0;\n\n    size_t vl = vsetvl_e64m1(n-1);\n    vuint64m1_t vmask = vid_v_u64m1(vl);\n    vmask = vmask + 1;\n\n    vbool64_t pred = true;\n    uint64_t temp_result = 0;\n\n    for(size_t i = vl; i > 0; ){\n        size_t subvl = vsetvl_e64m1(i);\n        vuint64m1_t vcand = vmask;\n        vcand = vcand - 1;\n        vuint64m1_t vrem = vmremu_vx_u64m1(vcand, n, subvl);\n        vbool64_t veq = vmseq_vx_b64m1(vrem, 0, subvl);\n        vcand = vmfredmax_vs_u64m1_b64m1(vcand, vcand, veq, subvl);\n        temp_result = vmfirst_m_u64m1(vcand, veq, subvl);\n        if(temp_result != 0){\n            result = temp_result;\n            break;\n        }\n        i -= subvl;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_73_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t largest_divisor_simd(uint64_t n){\n    uint64_t result = 1;\n    if (n <= 1) return 0;\n\n    size_t vl = vsetvl_e64m1(n-1);\n    vuint64m1_t vmask = vid_v_u64m1(vl);\n    vuint64m1_t v_n = vm_v_i64_m(vmask, n);\n\n    for(size_t i = vl; i > 0; ){\n        size_t vl_cur = vsetvl_e64m1(i);\n        vuint64m1_t vdiv = vmulu_vv_u64m1(v_n, vmask, vl_cur);\n        vuint64m1_t vrem = vmremu_vv_u64m1(v_n, vmask, vl_cur);\n        vmask = vmsne_vv_u64m1(vrem, vm_zero_u64m1(), vl_cur);\n        uint64_t temp_res = vmfirst_m_u64_m(vmask, vl_cur);\n        if(temp_res != 0){\n            result = temp_res;\n            break;\n        }\n        i -= vl_cur;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_74_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n < 2) return factors;\n\n    int vl = vsetvl_e32m1(0);\n    vint32m1_t v_n = vmv_v_x_i32m1(n, vl);\n    vbool32_t mask = vmseq_vx_b32m1(v_n, 1, vl);\n\n    int divisor = 2;\n    while (true) {\n        vint32m1_t v_divisor = vmv_v_x_i32m1(divisor, vl);\n        vbool32_t is_divisible = vmseq_vx_b32m1(vmremu_vx_i32m1(v_n, divisor, vl), 0, vl);\n\n        if (vfirst_m_b32m1(is_divisible)) {\n            factors.push_back(divisor);\n            v_n = vmdivu_vx_i32m1(v_n, divisor, vl);\n        } else {\n            divisor++;\n            if (divisor * divisor > n) {\n                if (n > 1) factors.push_back(n);\n                break;\n            }\n        }\n    }\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n){\n    std::vector<int> factors;\n    if (n < 2) return factors;\n\n    int vl = vsetvl_e32m1(1024);\n    vint32m1_t v_n = vmv_v_x_i32m1(n, vl);\n    vint32m1_t v_one = vmv_v_x_i32m1(1, vl);\n    vbool32_t mask = vmsne_vx_b32m1(v_n, v_one, vl);\n\n    int divisor = 2;\n    while (n > 1 && divisor * divisor <= n){\n        while (n % divisor == 0){\n            factors.push_back(divisor);\n            n /= divisor;\n        }\n        divisor += 1;\n    }\n    if (n > 1){\n        factors.push_back(n);\n    }\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n < 2) return factors;\n\n    int vl = vsetvl_e32m1(1);\n    vint32m1_t v_n = vmv_v_x_i32m1(n, vl);\n    vbool4_t mask = vmv_v_x_b4(true, vl);\n\n    int divisor = 2;\n    while (divisor * divisor <= n) {\n        int remainder = 0;\n        vint32m1_t v_divisor = vmv_v_x_i32m1(divisor, vl);\n        while (true) {\n            vint32m1_t v_quotient = vecdiv(v_n, v_divisor);\n            vint32m1_t v_mod = vecrem(v_n, v_divisor);\n            remainder = vmfirst_m_b4_i32m1(mask, v_mod);\n            if (remainder != 0) break;\n            v_n = v_quotient;\n            factors.push_back(divisor);\n        }\n        divisor++;\n    }\n\n    if (n > 1) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n < 2) return factors;\n\n    int vl = vsetvl_e32m1(1);\n    vuint32m1_t v_n = vmv_v_x_u32m1(n, vl);\n\n    for (int i = 2; i <= n; i++) {\n        vuint32m1_t v_i = vmv_v_x_u32m1(i, vl);\n        while (true) {\n            vuint32m1_t v_rem = vremu_vx_u32m1(v_n, i, vl);\n            vbool4_t cond = vmseq_vx_b4m1(v_rem, 0, vl);\n            if (!vfirst_m_b4m1(cond)) break;\n\n            factors.push_back(i);\n            v_n = vdivu_vx_u32m1(v_n, i, vl);\n        }\n    }\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n < 2) return factors;\n\n    int vl = vsetvl_e32m1(1);\n    vuint32m1_t v_n = vmv_v_x_u32m1(n, vl);\n\n    for (int i = 2; i <= n; i++) {\n        vuint32m1_t v_i = vmv_v_x_u32m1(i, vl);\n        while (true) {\n            vuint32m1_t remainder = vmremu_vx_u32m1(v_n, i, vl);\n            uint32_t rem = vmfirst_m_u32(vredu_mask_m(vmseq_vx_b8m1(remainder, 0, vl), vl));\n            if (rem != 0) break;\n            factors.push_back(i);\n            v_n = vmdivu_vx_u32m1(v_n, i, vl);\n            uint32_t new_n = vmfirst_m_u32(vredu_mask_m(vmseq_vx_b8m1(v_n, 1, vl), vl));\n            if (new_n == 1) goto end;\n        }\n    }\nend:\n    return factors;\n}\n```"}
{"task_id": "SimdBench_75_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l){\n    size_t size = l.size();\n    std::vector<float> result;\n    if (size == 0) return result;\n\n    size_t vlmax = vsetvl_e32m1(size);\n    float *data = const_cast<float*>(l.data());\n    vfloat32m1_t v_data = vmv_v_x_f32m1(0.0f, vlmax);\n    vbool32_t mask = vmf_eq_vf_b32m1(0.0f, vlmax); // Initialize mask\n\n    size_t i = 0;\n    for (; i + vlmax <= size; i += vlmax) {\n        v_data = vle32_v_f32m1(&data[i], vlmax);\n        mask = vmf_gt_vf_b32m1(v_data, 0.0f, vlmax);\n        v_data = vmasked_cvt_x_f_w_f32m1(v_data, mask, vlmax);\n        uint32_t *int_data = (uint32_t *) &v_data;\n        for (size_t j = 0; j < vlmax; ++j) {\n            if (mask[j]) result.push_back(int_data[j]);\n        }\n    }\n\n    vlmax = vsetvl_e32m1(size - i);\n    if (i < size) {\n        v_data = vle32_v_f32m1(&data[i], vlmax);\n        mask = vmf_gt_vf_b32m1(v_data, 0.0f, vlmax);\n        v_data = vmasked_cvt_x_f_w_f32m1(v_data, mask, vlmax);\n        uint32_t *int_data = (uint32_t *) &v_data;\n        for (size_t j = 0; j < vlmax; ++j) {\n            if (mask[j]) result.push_back(int_data[j]);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l){\n    size_t vlmax = vsetvl_e32m1(l.size());\n    vfloat32m1_t v_result;\n    vbool32_t vmask;\n    std::vector<float> result;\n\n    size_t i = 0;\n    for (; i + vlmax <= l.size(); i += vlmax) {\n        vfloat32m1_t v_load = vle32_v_f32m1((const float *)&l[i], vlmax);\n        vmask = vmfgt_vf_f32m1_b32(v_load, 0.0f, vlmax);\n        v_result = vmvf_v_f32m1(0.0f, vlmax);\n        v_result = vmerge_vvm_f32m1(v_result, v_load, vmask, vlmax);\n        size_t j = 0;\n        while (j < vlmax) {\n            if (vmask[j]) {\n                result.push_back(vfmv_f_s_f32m1_v(v_result, j, vlmax));\n            }\n            j++;\n        }\n    }\n\n    // Handle remaining elements\n    if (i < l.size()) {\n        size_t vl = vsetvl_e32m1(l.size() - i);\n        vfloat32m1_t v_load = vle32_v_f32m1((const float *)&l[i], vl);\n        vmask = vmfgt_vf_f32m1_b32(v_load, 0.0f, vl);\n        v_result = vmvf_v_f32m1(0.0f, vl);\n        v_result = vmerge_vvm_f32m1(v_result, v_load, vmask, vl);\n        size_t j = 0;\n        while (j < vl) {\n            if (vmask[j]) {\n                result.push_back(vfmv_f_s_f32m1_v(v_result, j, vl));\n            }\n            j++;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l){\n    size_t vlmax = vsetvl_e32m1(l.size());\n    std::vector<float> result;\n    result.reserve(l.size());\n\n    for(size_t i = 0; i < l.size(); i += vlmax){\n        size_t vl = vsetvl_e32m1(std::min(vlmax, (size_t)(l.size() - i)));\n        vfloat32m1_t vmask = vmflt_vf_f32m1(0.0f, vl);\n        vfloat32m1_t vdata = vle32_v_f32m1((const float *)&l[i], vl);\n        vfloat32m1_t vpositive = vfmerge_vfm_f32m1(0.0f, vdata, vmask, vl);\n\n        // Extract positive values\n        size_t j = 0;\n        while(j < vl){\n            size_t subvl = vsetvl_e32m1(std::min(vl - j, (size_t)vlmax));\n            vfloat32m1_t vsub = vslideup_vx_f32m1(vpositive, j, 0.0f, subvl);\n            float *buffer = (float *)malloc(sizeof(float) * subvl);\n            vse32_v_f32m1(buffer, vsub, subvl);\n            for(size_t k = 0; k < subvl; k++){\n                if(buffer[k] > 0.0f){\n                    result.push_back(buffer[k]);\n                }\n            }\n            free(buffer);\n            j += subvl;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l){\n    size_t size = l.size();\n    std::vector<float> result;\n    if (size == 0) return result;\n\n    size_t vlmax = vsetvl_e32m1(size);\n    float *data = const_cast<float*>(l.data());\n    size_t i = 0;\n\n    for (; i <= (size - vlmax); i += vlmax) {\n        vfloat32m1_t vl = lvf32_v_f32m1(data + i, vlmax);\n        vbool32_t mask = vmfgt_vf_f32m1_b32(vl, 0.0f, vlmax);\n        vfloat32m1_t vres = vmvf32_v_f32m1(0.0f, vlmax);\n        vfloat32m1_t masked = vmerge_vvm_f32m1(vres, vl, mask, vlmax);\n\n        size_t j = 0;\n        vfloat32m1_t temp = masked;\n        for(; j < vlmax; j++) {\n            float val = vfmv_f_s_f32m1_f32(temp);\n            if(val > 0.0f) result.push_back(val);\n            temp = vsslide1up_vf_f32m1(temp, 1.0f, vlmax);\n        }\n    }\n\n    // Handle remaining elements\n    if (i < size) {\n        size_t vl = vsetvl_e32m1(size - i);\n        vfloat32m1_t vl_r = lvf32_v_f32m1(data + i, vl);\n        vbool32_t mask = vmfgt_vf_f32m1_b32(vl_r, 0.0f, vl);\n        vfloat32m1_t vres = vmvf32_v_f32m1(0.0f, vl);\n        vfloat32m1_t masked = vmerge_vvm_f32m1(vres, vl_r, mask, vl);\n\n        size_t j = 0;\n        vfloat32m1_t temp = masked;\n        for(; j < vl; j++) {\n            float val = vfmv_f_s_f32m1_f32(temp);\n            if(val > 0.0f) result.push_back(val);\n            temp = vsslide1up_vf_f32m1(temp, 1.0f, vl);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l){\n    size_t size = l.size();\n    std::vector<float> result;\n    if (size == 0) return result;\n\n    size_t vlmax = vsetvl_e32m1(size);\n    float *data = const_cast<float*>(l.data());\n\n    size_t i = 0;\n    for (; i <= size - vlmax; i += vlmax) {\n        vfloat32m1_t vl = vlse32_v_f32m1(data + i, 1, vlmax);\n        vbool32_t vmask = vmfge_vf_f32m1_b32(vl, 0.0f, vlmax);\n        vfloat32m1_t vpositive = vmacc_vf_f32m1(vl, 0.0f, vmask, vlmax);\n\n        // Gather positive results\n        for (int j = 0; j < vlmax; ++j) {\n            if (vmask[j]) {\n                result.push_back(vfget_v_f32m1(vpositive, j, vlmax));\n            }\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        if (data[i] > 0.0f) {\n            result.push_back(data[i]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_76_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nbool is_prime_simd(int64_t n){\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t limit = (int64_t)(sqrt((double)n)) + 1;\n    size_t vlmax = vsetvl_e64m1(1);\n    vuint64m1_t vstart = vmv_v_x_u64m1(5, vlmax);\n    vbool8_t result = vmf_v_i8m1(true, vlmax);\n\n    for(int64_t i=5; i<=limit; i+=vlmax){\n        size_t vl = vsetvl_e64m1(vlmax);\n        vuint64m1_t vi = vrdd_vx_u64m1(vstart, vl);\n        vuint64m1_t vrem = vmrem_vx_u64m1(vi, n, vl);\n        vbool8_t vcmp = vmseq_vx_b8m1(vrem, 0, vl);\n        result = vmand_vv_b8m1(result, vmsne_vx_b8m1(vrem, 0, vl), vl);\n        if(!vfirst_m_b8(result)){\n            return false;\n        }\n        vstart = vradd_vx_u64m1(vstart, vlmax, vl);\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nbool is_prime_simd(int64_t n){\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t limit = (int64_t) sqrt((double)n);\n    size_t vl = vsetvl_e64m1(limit);\n\n    vint64m1_t v_i = vmv_v_x_i64m1(5, vl); // Start from 5\n    vbool64_t result = vmseq_vx_b64m1(true, v_i, 0, vl); // Initialize result as true\n\n    for(int64_t i = 5; i <= limit; ){\n        vint64m1_t v_n = vmul_vx_i64m1(v_i, i, vl);\n        vbool64_t v_cmp = vmseq_vx_b64m1(false, v_n, n, vl);\n        result = vmandnot_b64m1(result, v_cmp, vl);\n\n        i += vl;\n        v_i = vmv_v_x_i64m1(i, vl);\n    }\n\n    int64_t res = vmfirst_m_b64(result, vl);\n    return res != -1;\n}\n```"}
{"task_id": "SimdBench_76_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nbool is_prime_simd(int64_t n){\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if ((n % 2) == 0 || (n % 3) == 0) return false;\n\n    int64_t limit = (int64_t) sqrt((double)n) + 1;\n    int vl = vsetvl_e64m1(1);\n\n    vint64m1_t v_n = vmv_v_x_i64m1(n, vl);\n    vbool64_t result = vmv_v_x_b64(true, vl);\n\n    for(int64_t i = 5; i < limit; i += 6){\n        vint64m1_t v_i = vmv_v_x_i64m1(i, vl);\n        vbool64_t cond1 = vmseq_vv_b64(vmremu_vv_i64m1(v_n, v_i, vl), vmv_v_x_i64m1(0, vl), vl);\n        vbool64_t cond2 = vmseq_vv_b64(vmremu_vv_i64m1(v_n, vmadd_vx_i64m1(v_i, vmv_v_x_i64m1(2, vl), vl), vl), vmv_v_x_i64m1(0, vl), vl);\n        result = vand_vv_b64(result, vnot_v_b64(vor_vv_b64(cond1, cond2, vl), vl), vl);\n        if (!vfirst_m_b64(result, vl)) return false;\n    }\n    return vget_v_b64(result, 0);\n}\n```"}
{"task_id": "SimdBench_76_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nbool is_prime_simd(int64_t n){\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t limit = (int64_t)(sqrt((double)n)) + 1;\n    size_t vl = vsetvl_e64m1(limit);\n\n    vint64m1_t v_i = vmv_v_x_i64m1(5, vl);\n    vbool64_t mask = vmseq_vx_i64m1_b64(v_i, 0, vl);\n\n    for(int64_t i = 5; i <= limit; i += 2){\n        v_i = vmv_v_x_i64m1(i, vl);\n        mask = vmseq_vx_i64m1_b64(mask, n, vl);\n        if (vfirst_m_b64(mask, vl)) return false;\n        mask = vmseq_vx_i64m1_b64(v_i, 0, vl);\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nbool is_prime_simd(int64_t n){\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t limit = (int64_t) sqrt((double)n);\n    size_t esize = sizeof(int64_t) * 8;\n    size_t vlen = vsetvl_e64m1(1);\n    vint64m1_t vn = vmv_v_x_i64m1(n, vlen);\n\n    for(int64_t i = 5; i <= limit; i += 6){\n        size_t vl1 = vsetvl_e64m1(1);\n        vint64m1_t vi = vmv_v_x_i64m1(i, vl1);\n        vbool64_t res1 = vmseq_vv_i64m1_b64(vn, vmul_vx_i64m1(vi, i, vl1), vl1);\n        if (vfirst_m_b64(res1)) return false;\n\n        size_t vl2 = vsetvl_e64m1(1);\n        vint64m1_t vi_2 = vmv_v_x_i64m1(i+2, vl2);\n        vbool64_t res2 = vmseq_vv_i64m1_b64(vn, vmul_vx_i64m1(vi_2, i+2, vl2), vl2);\n        if (vfirst_m_b64(res2)) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_77_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string solve_simd(const std::string &s) {\n    size_t vl = s.size();\n    if (vl == 0) return s;\n\n    // Allocate result string\n    std::string result(s);\n\n    // Vector configuration\n    size_t vlenb = sizeof(vuint8m1_t) * 8;\n    size_t num_iters = (vl + vlenb - 1) / vlenb;\n\n    bool has_letter = false;\n\n    for (size_t i = 0; i < num_iters; ++i) {\n        size_t start_idx = i * vlenb;\n        size_t actual_vl = (start_idx + vlenb <= vl) ? vlenb : vl - start_idx;\n\n        vuint8m1_t vmask = vmsltu_v_u8m1(true, 0, 0, actual_vl);\n        vuint8m1_t vdata = vle8_v_u8m1(&s[start_idx], actual_vl);\n\n        // Check for letters and toggle case\n        vbool8_t is_lower = vmseq_v_u8m1_b8(vdata, 'a', actual_vl) | vmseq_v_u8m1_b8(vdata, 'b', actual_vl) | vmseq_v_u8m1_b8(vdata, 'c', actual_vl) | vmseq_v_u8m1_b8(vdata, 'd', actual_vl) | vmseq_v_u8m1_b8(vdata, 'e', actual_vl) | vmseq_v_u8m1_b8(vdata, 'f', actual_vl) | vmseq_v_u8m1_b8(vdata, 'g', actual_vl) | vmseq_v_u8m1_b8(vdata, 'h', actual_vl) | vmseq_v_u8m1_b8(vdata, 'i', actual_vl) | vmseq_v_u8m1_b8(vdata, 'j', actual_vl) | vmseq_v_u8m1_b8(vdata, 'k', actual_vl) | vmseq_v_u8m1_b8(vdata, 'l', actual_vl) | vmseq_v_u8m1_b8(vdata, 'm', actual_vl) | vmseq_v_u8m1_b8(vdata, 'n', actual_vl) | vmseq_v_u8m1_b8(vdata, 'o', actual_vl) | vmseq_v_u8m1_b8(vdata, 'p', actual_vl) | vmseq_v_u8m1_b8(vdata, 'q', actual_vl) | vmseq_v_u8m1_b8(vdata, 'r', actual_vl) | vmseq_v_u8m1_b8(vdata, 's', actual_vl) | vmseq_v_u8m1_b8(vdata, 't', actual_vl) | vmseq_v_u8m1_b8(vdata, 'u', actual_vl) | vmseq_v_u8m1_b8(vdata, 'v', actual_vl) | vmseq_v_u8m1_b8(vdata, 'w', actual_vl) | vmseq_v_u8m1_b8(vdata, 'x', actual_vl) | vmseq_v_u8m1_b8(vdata, 'y', actual_vl) | vmseq_v_u8m1_b8(vdata, 'z', actual_vl);\n        vbool8_t is_upper = vmseq_v_u8m1_b8(vdata, 'A', actual_vl) | vmseq_v_u8m1_b8(vdata, 'B', actual_vl) | vmseq_v_u8m1_b8(vdata, 'C', actual_vl) | vmseq_v_u8m1_b8(vdata, 'D', actual_vl) | vmseq_v_u8m1_b8(vdata, 'E', actual_vl) | vmseq_v_u8m1_b8(vdata, 'F', actual_vl) | vmseq_v_u8m1_b8(vdata, 'G', actual_vl) | vmseq_v_u8m1_b8(vdata, 'H', actual_vl) | vmseq_v_u8m1_b8(vdata, 'I', actual_vl) | vmseq_v_u8m1_b8(vdata, 'J', actual_vl) | vmseq_v_u8m1_b8(vdata, 'K', actual_vl) | vmseq_v_u8m1_b8(vdata, 'L', actual_vl) | vmseq_v_u8m1_b8(vdata, 'M', actual_vl) | vmseq_v_u8m1_b8(vdata, 'N', actual_vl) | vmseq_v_u8m1_b8(vdata, 'O', actual_vl) | vmseq_v_u8m1_b8(vdata, 'P', actual_vl) | vmseq_v_u8m1_b8(vdata, 'Q', actual_vl) | vmseq_v_u8m1_b8(vdata, 'R', actual_vl) | vmseq_v_u8m1_b8(vdata, 'S', actual_vl) | vmseq_v_u8m1_b8(vdata, 'T', actual_vl) | vmseq_v_u8m1_b8(vdata, 'U', actual_vl) | vmseq_v_u8m1_b8(vdata, 'V', actual_vl) | vmseq_v_u8m1_b8(vdata, 'W', actual_vl) | vmseq_v_u8m1_b8(vdata, 'X', actual_vl) | vmseq_v_u8m1_b8(vdata, 'Y', actual_vl) | vmseq_v_u8m1_b8(vdata, 'Z', actual_vl);\n\n        vbool8_t is_letter = is_lower | is_upper;\n\n        // Check if there are any letters in the vector\n        has_letter |= vfirst_m_b8(is_letter);\n\n        // Toggle case for letters\n        vdata = vsub_vx_u8m1(vdata, 32, is_lower, actual_vl);\n        vdata = vadd_vx_u8m1(vdata, 32, is_upper, actual_vl);\n\n        // Store the result back\n        vse8_v_u8m1(&result[start_idx], vdata, actual_vl);\n    }\n\n    // If no letters were found, reverse the string\n    if (!has_letter) {\n        for (size_t i = 0; i < vl / 2; ++i) {\n            char temp = result[i];\n            result[i] = result[vl - i - 1];\n            result[vl - i - 1] = temp;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cstring>\n\nstd::string solve_simd(const std::string & s){\n    size_t vl = s.size();\n    size_t sew = 8; // 8 bits per element (char)\n    size_t lmul = 1; // lmultiplicity of 1\n    size_t vlen = vl * sew / 8;\n    size_t avl = vlen;\n\n    uint8_t contains_letter = 0;\n    vbool8_t mask = vmv_v_x_b8(0, vl);\n    vuint8m1_t vs = vle8_v_u8m1((const uint8_t *)s.c_str(), vl);\n\n    // Check for letters and toggle case\n    {\n        vbool8_t is_lower = vlge_vx_b8(vs, 'a', vl) & vle_vx_b8(vs, 'z', vl);\n        vbool8_t is_upper = vlge_vx_b8(vs, 'A', vl) & vle_vx_b8(vs, 'Z', vl);\n        contains_letter |= vmax_rm_x_b8(MUQ, vmv_x_s_b8_m(is_lower), vmv_x_s_b8_m(is_upper));\n        vs = vsub_vx_u8m1_m(mask, vs, 'a', vl);\n        vs = vadd_vx_u8m1_m(mask, vs, 'A', vl);\n        vs = vsub_vx_u8m1_m(is_upper, vs, ('A' - 'a'), vl);\n    }\n\n    if (!contains_letter) {\n        // Reverse the string\n        vuint8m1_t reversed = vs;\n        for (size_t i = 0; i < vl / 2; ++i) {\n            size_t j = vl - i - 1;\n            uint8_t tmp = vget_v_u8m1(reversed, i);\n            reversed = vset_v_u8m1(reversed, i, vget_v_u8m1(reversed, j));\n            reversed = vset_v_u8m1(reversed, j, tmp);\n        }\n        vs = reversed;\n    }\n\n    char result[vl + 1];\n    result[vl] = '\\0';\n    vse8_v_u8m1(result, vs, vl);\n\n    return std::string(result, vl);\n}\n```"}
{"task_id": "SimdBench_77_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string solve_simd(const std::string & s){\n    size_t n = s.size();\n    if (n == 0) return \"\";\n    \n    // Determine vector length and sew\n    size_t vlmax = vsetvl_e8m1(n);\n    uint8_t *result = new uint8_t[n];\n    bool has_letter = false;\n\n    for(size_t i = 0; i < n; i += vlmax){\n        size_t vl = vsetvl_e8m1(n - i);\n        vuint8m1_t vmask = vmseq_vu8m1_mask(vle8_v_u8m1((const uint8_t *)&s[i], vl), 0, vl);\n        vuint8m1_t vdata = vle8_v_u8m1((const uint8_t *)&s[i], vl);\n\n        // Check for letters\n        vbool8_t is_upper = vmsge_vu8_b8(vdata, 'A', vl) & vmsle_vu8_b8(vdata, 'Z', vl);\n        vbool8_t is_lower = vmsge_vu8_b8(vdata, 'a', vl) & vmsle_vu8_b8(vdata, 'z', vl);\n        has_letter |= (vpopc_m_b8_b8(vmask, is_upper | is_lower, vl) > 0);\n\n        // Toggle case for letters\n        vdata = vsub_vx_u8m1(vdata, 32, vl & is_upper);\n        vdata = vadd_vx_u8m1(vdata, 32, vl & is_lower);\n\n        // Store results\n        vsse8_v_u8m1((uint8_t *)&result[i], 0, vdata, vl);\n    }\n\n    if (!has_letter){\n        // Reverse the string\n        for(size_t i = 0; i < n / 2; ++i){\n            uint8_t temp = result[i];\n            result[i] = result[n - i - 1];\n            result[n - i - 1] = temp;\n        }\n    }\n\n    std::string res((char *)result, n);\n    delete[] result;\n    return res;\n}\n```"}
{"task_id": "SimdBench_77_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string solve_simd(const std::string & s){\n    size_t n = s.size();\n    if (n == 0) return \"\";\n\n    // Determine max vector length and sew (element width)\n    size_t vlmax = vsetvl_e8m1(n);\n    uint8_t *result = (uint8_t *)malloc(n);\n    const uint8_t *input = (const uint8_t *)s.c_str();\n\n    bool has_letter = false;\n\n    for(size_t i = 0; i < n; i += vlmax){\n        size_t vl = vsetvl_e8m1(n - i);\n        vuint8m1_t vmask = vmseq_vx_i8m1(vlse8_v_i8m1(i, input, vl), 0, vl);\n        vuint8m1_t vdata = vle8_v_u8m1(input + i, vl);\n\n        // Check for letters\n        vbool8_t is_upper = vmsge_vx_i8m1_b8(vdata, 'A', vl) & vmcle_vx_i8m1_b8(vdata, 'Z', vl);\n        vbool8_t is_lower = vmsge_vx_i8m1_b8(vdata, 'a', vl) & vmcle_vx_i8m1_b8(vdata, 'z', vl);\n        vbool8_t is_letter = vismerge_vvm_b8(is_upper, is_lower, vl);\n\n        // Check if there is any letter in the string\n        has_letter |= vimax_vm_b8_i32m1(is_letter, vl) != 0;\n\n        // Toggle case for letters\n        vuint8m1_t toggled = vorv_vv_u8m1(vdata, vsub_vx_u8m1(vdata, 32, vl), vl);\n        vdata = vifnotmasked_else_vvm_u8m1(vdata, toggled, is_letter, vl);\n\n        // Store result\n        vsse8_v_u8m1(result + i, vmask, vdata, vl);\n    }\n\n    // If no letters were found, reverse the string\n    if(!has_letter){\n        for(size_t i = 0; i < n / 2; ++i){\n            uint8_t temp = result[i];\n            result[i] = result[n - i - 1];\n            result[n - i - 1] = temp;\n        }\n    }\n\n    std::string res((char *)result, n);\n    free(result);\n    return res;\n}\n```"}
{"task_id": "SimdBench_77_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string solve_simd(const std::string & s){\n    size_t vl = s.size();\n    if (vl == 0) return s;\n\n    uint8_t contains_letter = 0;\n    vbool8_t vm = vtrue_b8(vl);\n    vuint8m1_t vs = vle8_v_u8m1((const uint8_t *)s.c_str(), vl);\n\n    // Check for letters and toggle case\n    vbool8_t is_lower = vmsle_vx_u8_b8(vs, 'a', vm) & vmsle_vx_u8_b8('z', vs, vm);\n    vbool8_t is_upper = vmsle_vx_u8_b8(vs, 'A', vm) & vmsle_vx_u8_b8('Z', vs, vm);\n    contains_letter |= (int)vpopc_m_b8(vm, is_lower | is_upper, vl);\n    vuint8m1_t toggled = vs ^ vmerge_vvm_u8m1(vsedup_x_u8m1('a' ^ 'A', vl), is_lower | is_upper, vs, vl);\n\n    // If no letters, reverse the string\n    if (!contains_letter) {\n        vuint8m1_t reversed = vwrev_v_u8m1(toggled, vl);\n        std::string result(s.size(), '\\0');\n        vse8_v_u8m1((uint8_t *)result.data(), reversed, vl);\n        return result;\n    } else {\n        std::string result(s.size(), '\\0');\n        vse8_v_u8m1((uint8_t *)result.data(), toggled, vl);\n        return result;\n    }\n}\n```"}
{"task_id": "SimdBench_78_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t size = l.size();\n    if (size == 0) return l;\n\n    // Extract elements at indices divisible by 3\n    std::vector<int> div_by_three;\n    for (size_t i = 0; i < size; ++i) {\n        if (i % 3 == 0) div_by_three.push_back(l[i]);\n    }\n\n    // Sort the extracted elements\n    std::sort(div_by_three.begin(), div_by_three.end());\n\n    // Create a mask for indices divisible by 3\n    size_t vl = vsetvl_e32m1(size);\n    uint8_t mask[size];\n    for (size_t i = 0; i < size; ++i) {\n        mask[i] = (i % 3 == 0) ? 1 : 0;\n    }\n\n    // Load input vector\n    vint32m1_t vl_input = vmv_v_x_i32m1(0, vl);\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n        vl_input = vle32_v_i32m1(&l[i], vl);\n        \n        // Replace elements at indices divisible by 3 with sorted values\n        size_t div_idx = i / 3;\n        for (size_t j = 0; j < vl; ++j) {\n            if (mask[i + j]) {\n                l[i + j] = div_by_three[div_idx];\n                if (++div_idx >= div_by_three.size()) break;\n            }\n        }\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_78_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t size = l.size();\n    if (size == 0) return l;\n\n    // Collect elements at indices divisible by 3\n    std::vector<int> div_by_three;\n    for (size_t i = 0; i < size; ++i) {\n        if (i % 3 == 0) div_by_three.push_back(l[i]);\n    }\n\n    // Sort the collected elements\n    std::sort(div_by_three.begin(), div_by_three.end());\n\n    // Create a mask and replace elements using RVV\n    size_t vl = vsetvl_e32m1(size);\n    int* ptr_l = l.data();\n\n    size_t div_idx = 0;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n\n        // Load vector segment\n        vint32m1_t vl_l = vle32_v_i32m1(ptr_l + i, vl);\n\n        // Create a mask for indices divisible by 3\n        vbool32_t vmask = vminu_vx_b32((i + vseq_v_u32m1(vl)) % 3 == 0, vl);\n\n        // Replace values where mask is true\n        vl_l = vfredosort_x_f32m1(div_by_three[div_idx], vl_l, vl);\n        div_idx += popcount(vmask);\n\n        // Store back to the original vector\n        vse32_v_i32m1(ptr_l + i, vl_l, vl);\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_78_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l){\n    size_t size = l.size();\n    if (size == 0) return l;\n\n    // Find indices divisible by three\n    std::vector<int> div_by_three;\n    for (size_t i = 0; i < size; ++i) {\n        if (i % 3 == 0) div_by_three.push_back(l[i]);\n    }\n\n    // Sort the collected elements\n    std::sort(div_by_three.begin(), div_by_three.end());\n\n    // Prepare to use RVV intrinsics\n    size_t vl = vsetvl_e32m1(div_by_three.size());\n    vint32m1_t v_div_sorted = vmv_v_x_i32m1(0, vl);\n    for (size_t i = 0; i < div_by_three.size(); ++i) {\n        v_div_sorted = vsext_vf4(v_div_sorted, div_by_three[i], vl);\n    }\n\n    // Replace the original vector's values at indices divisible by three\n    size_t div_idx = 0;\n    for (size_t i = 0; i < size; ++i) {\n        if (i % 3 == 0) {\n            if (div_idx < div_by_three.size()) {\n                l[i] = div_by_three[div_idx];\n                div_idx++;\n            }\n        }\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_78_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t size = l.size();\n    if (size == 0) return l;\n\n    // Collect elements at indices divisible by three\n    std::vector<int> div_by_three;\n    for (size_t i = 0; i < size; ++i) {\n        if (i % 3 == 0) {\n            div_by_three.push_back(l[i]);\n        }\n    }\n\n    // Sort the collected elements\n    std::sort(div_by_three.begin(), div_by_three.end());\n\n    // Create a mask and replace elements in l with sorted values where index is divisible by three\n    size_t vl = vsetvl_e32m1(size);\n    int* ptr_l = l.data();\n    size_t div_idx = 0;\n\n    for (size_t i = 0; i < size; i += vl) {\n        size_t batch_size = std::min(vl, size - i);\n\n        vbool32_t mask = vmseq_visi32_b32m1((i + vint32m1_t)vslide1up_vi32m1(i, 0, batch_size), 0, batch_size);\n        vint32m1_t vl_original = vle32_v_i32m1(ptr_l + i, batch_size);\n\n        for (size_t j = 0; j < batch_size; ++j) {\n            if ((i + j) % 3 == 0) {\n                vl_original[j] = div_by_three[div_idx++];\n            }\n        }\n\n        vse32_v_i32m1(ptr_l + i, vl_original, batch_size);\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_78_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l){\n    size_t size = l.size();\n    if (size == 0) return l;\n\n    // Collect elements at indices divisible by three\n    std::vector<int> div_three;\n    for(size_t i = 0; i < size; ++i){\n        if(i % 3 == 0){\n            div_three.push_back(l[i]);\n        }\n    }\n\n    // Sort the collected elements\n    std::sort(div_three.begin(), div_three.end());\n\n    // Create a mask and replace elements using RVV\n    size_t vl = vsetvl_e32m1(size);\n    int* ptr_l = l.data();\n    vint32m1_t vmask = vmseq_vx_i32m1(size, 0, vl); // Initialize with false\n    size_t count = 0;\n\n    for(size_t i = 0; i < size; ++i){\n        if(i % 3 == 0){\n            vint32m1_t vindex = vmv_x_s_i32_i32m1(i, vl);\n            vmask = vmsbf_m_b8m1(vmask, vindex, vl); // Set mask bit to true\n            ptr_l[i] = div_three[count++];\n        }\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_79_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <limits.h>\n#include <math.h>\n\nfloat max_element_simd(std::vector<float> l) {\n    if (l.empty()) {\n        return NAN;\n    }\n\n    size_t size = l.size();\n    float result = -INFINITY;\n\n    vfloat32m1_t vmask = vmv_v_x_f32m1(0.0f, 1);\n    size_t i = 0;\n    for (; i + vsetvl_e32m1(0) <= size; i += vsetvl_e32m1(0)) {\n        size_t vl = vsetvl_e32m1(0);\n        vfloat32m1_t vdata = vle32_v_f32m1((float *)&l[i], vl);\n        vfloat32m1_t vmax = vmv_v_v_f32m1(vdata, vl);\n        size_t j = 0;\n        for (; j < vl; j++) {\n            float current = vmax[j];\n            if (!isinf(result) && current > result) {\n                result = current;\n            }\n        }\n    }\n\n    // Process leftovers\n    for (; i < size; i++) {\n        if (l[i] > result) {\n            result = l[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_79_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <limits.h>\n#include <math.h>\n\nfloat max_element_simd(std::vector<float> l){\n    float result = -INFINITY;\n    size_t vlmax = vsetvl_e32m1(l.size());\n    vfloat32m1_t vmax_v = vmv_v_f_f32m1(-INFINITY, vlmax);\n    size_t i = 0;\n    for(; i + vlmax <= l.size(); i += vlmax){\n        vfloat32m1_t vdata = vle32_v_f32m1((float*)&l[i], vlmax);\n        vmax_v = vmax_vf32_v_f32m1(vmax_v, vdata, vlmax);\n    }\n    size_t remainder = l.size() - i;\n    if(remainder > 0){\n        size_t vlrem = vsetvl_e32m1(remainder);\n        vfloat32m1_t vdata = vle32_v_f32m1((float*)&l[i], vlrem);\n        vmax_v = vmax_vf32_v_f32m1(vmax_v, vdata, vlrem);\n    }\n    float *reduce_data = (float*)&vmax_v;\n    for(int j=0; j<vlmax; j++) {\n        if(reduce_data[j] > result) result = reduce_data[j];\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_79_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <limits.h>\n#include <math.h>\n\nfloat max_element_simd(std::vector<float> l){\n    float vmax = -INFINITY;\n    if (!l.empty()) {\n        size_t vl = vsetvl_e32m1(l.size());\n        vfloat32m1_t v0 = vmv_v_x_f32m1(-INFINITY, vl);\n        for(size_t i = 0; i < l.size(); i += vl) {\n            size_t actual vl = vsetvl_e32m1(vmin(vl, l.size() - i));\n            vfloat32m1_t vi = vle32_v_f32m1((const float *)&l[i], actual_vl);\n            v0 = vfmax_vv_f32m1(v0, vi, actual_vl);\n        }\n        float *red = (float *)malloc(vl * sizeof(float));\n        vse32_v_f32m1(red, v0, vl);\n        vmax = red[0];\n        for(size_t i=1;i<vl;i++) {\n            if(red[i] > vmax) vmax = red[i];\n        }\n        free(red);\n    }\n    return vmax;\n}\n```"}
{"task_id": "SimdBench_79_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <float.h>\n#include <algorithm>\n\nfloat max_element_simd(std::vector<float> l){\n    if (l.empty()) return FLT_MIN;\n    size_t size = l.size();\n    float* data = l.data();\n    float vmax = FLT_MIN;\n\n    size_t vl = vsetvl_e32m1(size);\n    vfloat32m1_t v0 = vmv_v_x_f32m1(FLT_MIN, vl);\n\n    for(size_t i = 0; i < size; i += vl){\n        size_t chunk_size = std::min(size - i, vl);\n        vfloat32m1_t vt = vle32_v_f32m1(data + i, chunk_size);\n        v0 = vmfmax_vv_f32m1(v0, vt, chunk_size);\n    }\n\n    float *red_buf = (float *)malloc(vl * sizeof(float));\n    vse32_v_f32m1(red_buf, v0, vl);\n    \n    for(size_t i = 0; i < vl; ++i){\n        if(red_buf[i] > vmax) vmax = red_buf[i];\n    }\n    free(red_buf);\n    return vmax;\n}\n```"}
{"task_id": "SimdBench_79_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <limits.h>\n#include <math.h>\n\nfloat max_element_simd(std::vector<float> l) {\n    if (l.empty()) {\n        return NAN;\n    }\n\n    size_t size = l.size();\n    float result = -INFINITY;\n\n    size_t vlmax = vsetvl_e32m1(size);\n    vfloat32m1_t vmax_v = vmv_v_f_f32(-INFINITY, vlmax);\n\n    for (size_t i = 0; i < size; i += vlmax) {\n        size_t vl = vsetvl_e32m1(size - i);\n        vfloat32m1_t vdata = vle32_v_f32m1(&l[i], vl);\n        vmax_v = vfmax_vv_f32m1(vmax_v, vdata, vl);\n    }\n\n    size_t sew = sizeof(float) * 8;\n    size_t bm = 1 << sew / 2;\n    size_t vl = vsetvl_e32m1(1);\n    result = reducemax_float32(result, vmax_v, vlmax, bm);\n\n    return result;\n}\n\nfloat reducemax_float32(float res, vfloat32m1_t v, size_t vl, size_t bm) {\n    size_t k = 1;\n    while (k < vl) {\n        v = vfslide1up_vf_f32m1(v, res, vl);\n        res = vmv_x_s_f32_f32m1(v, vl);\n        k *= 2;\n    }\n    return res;\n}\n```"}
{"task_id": "SimdBench_80_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint fizz_buzz_simd(int n){\n    int count = 0;\n    size_t vlmax = vlenb() * 8 / sizeof(int);\n    size_t vl = vlmax;\n\n    for(int i = 0; i < n; i += vlmax){\n        vl = (n - i) > vlmax ? vlmax : (n - i);\n\n        vbool4_t mask = vmv_v_x_i32m1(0, vl);\n        vint32m1_t vi = vmv_v_x_i32m1(i, vl);\n\n        // Check divisible by 11 or 13\n        vint32m1_t mod_11 = vrem_vx_i32m1(vi, 11, vl);\n        vint32m1_t mod_13 = vrem_vx_i32m1(vi, 13, vl);\n        mask = vor_vv_b4m1(mask, vmseq_vx_i32m1_b4m1(mod_11, 0, vl), vl);\n        mask = vor_vv_b4m1(mask, vmseq_vx_i32m1_b4m1(mod_13, 0, vl), vl);\n\n        // Count digit '7'\n        vint32m1_t vseven = vmv_v_x_i32m1(7, vl);\n        vbool4_t is_seven = vmseq_vv_i32m1_b4m1(vi, vseven, vl);\n        is_seven = vand_vv_b4m1(is_seven, mask, vl);\n\n        int temp_count = (int)vpopc_vm_i32m1_b4(is_seven, vl);\n        count += temp_count;\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint fizz_buzz_simd(int n){\n    int count = 0;\n    size_t vl = vsetvl_e32m4(n);\n    vuint32m4_t vmask = vmseq_u32_v_i32_mask(vdefault_m(), 0, 0, vl);\n    vuint32m4_t vseven = vmv_v_x_u32(7, vl);\n    vuint32m4_t vdiv11 = vmv_v_x_u32(11, vl);\n    vuint32m4_t vdiv13 = vmv_v_x_u32(13, vl);\n\n    for(int i = 0; i < n; i += vl){\n        size_t current vl = vsetvl_e32m4(n - i);\n        vuint32m4_t vidx = vmv_v_x_u32(i, current_vl);\n        vbool4_t div11 = vmseq_u32_v_u32_mask(vdefault_m(), vremu_u32_v_u32(vidx, vdiv11, current_vl), 0, current_vl);\n        vbool4_t div13 = vmseq_u32_v_u32_mask(vdefault_m(), vremu_u32_v_u32(vidx, vdiv13, current_vl), 0, current_vl);\n        vbool4_t valid = vor_b4(div11, div13, current_vl);\n        vuint32m4_t vtemp = vidx;\n        vbool4_t isSeven = vmseq_u32_v_u32_mask(valid, vtemp, vseven, current_vl);\n        count += __builtin_popcount(vmfirst_b4(isSeven));\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nint fizz_buzz_simd(int n){\n    int count = 0;\n    size_t vl = vsetvl_e32m1(n);\n    vuint32m1_t vmask = vmseq_u32_v_i32_mask(vdefault_m(), 0, 0, vl);\n    vuint32m1_t vseven = vmv_v_x_u32_m(vmask, 7, vl);\n    vuint32m1_t vzero = vmv_v_x_u32_m(vmask, 0, vl);\n    vuint32m1_t v eleven = vmv_v_x_u32_m(vmask, 11, vl);\n    vuint32m1_t vthirteen = vmv_v_x_u32_m(vmask, 13, vl);\n\n    for(int i = 0; i < n; ++i){\n        if( (i % 11) == 0 || (i % 13) == 0 ){\n            int temp = i;\n            while(temp){\n                vuint32m1_t vtemp = vmv_v_x_u32_m(vmask, temp, vl);\n                vuint32m1_t vrem = vremu_wx_u32_m(vmask, vtemp, 10, vl);\n                vmask = vmseq_u32_mask(vmask, vrem, vseven, vl);\n                count += __builtin_popcount(vmask);\n                temp /= 10;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint fizz_buzz_simd(int n){\n    int count = 0;\n    size_t vlmax = vsetvl_e32m1(0);\n    for (int i = 0; i < n; i += vlmax) {\n        size_t vl = vsetvl_e32m1(n - i);\n        vuint32m1_t vmask = vmsltu_v_u32m1(vmv_v_x_i32m1(i + vl, vl), vl, n);\n        vuint32m1_t vidx = vmv_v_x_i32m1(i, vl);\n        vbool4_t div_11 = vmseq_m_v_u32m1_b4(vmask, vremu_vx_u32m1(vidx, 11, vl), 0, vl);\n        vbool4_t div_13 = vmseq_m_v_u32m1_b4(vmask, vremu_vx_u32m1(vidx, 13, vl), 0, vl);\n        vbool4_t valid = vor_vv_b4(div_11, div_13, vl);\n        vuint32m1_t vnums = vand_vx_u32m1(vidx, -1, vl);\n        vnums = vslide1up_vx_u32m1(vnums, vnums, vl);\n        uint32_t mask = vmv_x_s_b4f4(valid);\n        while(mask){\n            int idx = __builtin_ctz(mask);\n            uint32_t num = vmv_x_s_u32m1_u32(vnums);\n            while(num){\n                if(num % 10 == 7){\n                    count++;\n                }\n                num /= 10;\n            }\n            mask &= ~(1 << idx);\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint fizz_buzz_simd(int n){\n    int count = 0;\n    size_t vlmax = vsetvl_e32m1(n);\n    vbool32_t vm = vmv_v_x_i32m1(1, vlmax);\n    vuint32m1_t vindex = vid_v_u32m1(vlmax);\n    vuint32m1_t vzero = vmv_v_x_u32m1(0, vlmax);\n\n    for (int i = 0; i < n; i += vlmax) {\n        size_t vl = vsetvl_e32m1(n - i);\n        vuint32m1_t vcond = vor_vv_u32m1(vmod_vx_u32m1(vindex, 11, vl), vmod_vx_u32m1(vindex, 13, vl), vl);\n        vuint32m1_t vtemp = vindex;\n        for (int digit = 7; digit >= 0; digit--) {\n            vtemp = vdiv_vx_u32m1(vtemp, 10, vl);\n            vbool32_t vcheck = veq_vx_u32m_b32(vtemp, digit, vl);\n            vcond = vand_vv_b32(vcond, vcheck, vl);\n        }\n        count += vpopc_vm_i32m1_b32(vm, vcond, vl);\n        vindex = vadd_vx_u32m1(vindex, vlmax, vl);\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_81_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l){\n    size_t size = l.size();\n    if (size == 0) return l;\n\n    // Find the maximum vector length\n    size_t vlmax = vsetvl_e32m1(size);\n\n    // Create a mask for even indices\n    uint8_t mask_data[size];\n    for(size_t i = 0; i < size; ++i){\n        mask_data[i] = (i % 2 == 0) ? 1 : 0;\n    }\n\n    // Load input data into a vector\n    float vl_data[size];\n    for(size_t i = 0; i < size; ++i){\n        vl_data[i] = l[i];\n    }\n\n    // Extract even indices values\n    float even_values[size / 2 + (size % 2)];\n    size_t even_count = 0;\n    for(size_t i = 0; i < size; ++i){\n        if(mask_data[i]){\n            even_values[even_count++] = vl_data[i];\n        }\n    }\n\n    // Sort the even indices values\n    std::sort(even_values, even_values + even_count);\n\n    // Interleave sorted even values back into the original vector\n    size_t even_idx = 0;\n    for(size_t i = 0; i < size; ++i){\n        if(mask_data[i]){\n            vl_data[i] = even_values[even_idx++];\n        }\n    }\n\n    // Copy result back to the output vector\n    std::vector<float> result(vl_data, vl_data + size);\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l){\n    size_t size = l.size();\n    if (size == 0) return l;\n\n    // Create a vector mask for even indices\n    std::vector<float> even_elements;\n    even_elements.reserve((size + 1) / 2);\n\n    for (size_t i = 0; i < size; i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    // Sort the even indices elements\n    std::sort(even_elements.begin(), even_elements.end());\n\n    // Reconstruct the vector with sorted even indices\n    size_t even_idx = 0;\n    for (size_t i = 0; i < size; i++) {\n        if (i % 2 == 0) {\n            l[i] = even_elements[even_idx++];\n        }\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_81_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l){\n    size_t size = l.size();\n    if (size == 0) return l;\n\n    // Determine the vector length and create a mask for even indices\n    size_t vl = vsetvl_e32m1(size);\n    float* data = l.data();\n\n    // Load the vector\n    vfloat32m1_t vec = vlload(data, vl);\n\n    // Create a mask for even indices\n    vuint32m1_t indices = vid_v_u32m1(vl);\n    vbool32_t is_even_mask = vmseq_vv_i32m1_b32(indices, vmod_v_i32m1(indices, 2, vl), vl);\n\n    // Extract even elements\n    vfloat32m1_t even_elements = vmasked_load(is_even_mask, data, vl);\n\n    // Convert to array for sorting\n    float even_array[vl];\n    vmv_v_f_f32m1(even_array, even_elements, vl);\n\n    // Sort the even elements\n    std::vector<float> even_vec(even_array, even_array + vl);\n    std::sort(even_vec.begin(), even_vec.end());\n\n    // Store sorted even elements back into the vector\n    vfloat32m1_t sorted_even = vlload(even_vec.data(), vl);\n    vec = vmrg_vf_f32m1(vec, sorted_even, is_even_mask, vl);\n\n    // Store the result back into the original vector\n    vlstore(data, vec, vl);\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_81_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l){\n    size_t size = l.size();\n    if (size == 0) return {};\n\n    // Determine the vector length and element size\n    size_t vl = vsetvl_e32m1(size);\n\n    // Load input data into a vector\n    float* data_ptr = l.data();\n    vfloat32m1_t vl_data = vle32_v_f32m1(data_ptr, vl);\n\n    // Create masks for even indices\n    vbool32_t mask_even = vmseq_vx_b32m1(vm, vl_data, 0, vl);\n    for (size_t i = 1; i < vl; ++i) {\n        if (i % 2 == 0) {\n            mask_even = vmseq_vx_b32m1(mask_even, vl_data, i, vl);\n        }\n    }\n\n    // Extract even-indexed elements\n    vfloat32m1_t vl_even = vmv_v_x_f32m1(0.0f, vl);\n    vl_even = vcompress_vm_f32m1_f32m1(vl_even, vl_data, mask_even, vl);\n\n    // Sort the even-indexed elements\n    std::vector<float> even_elements(size / 2 + size % 2);\n    vse32_v_f32m1(even_elements.data(), vl_even, vl);\n    std::sort(even_elements.begin(), even_elements.end());\n\n    // Reload sorted even elements into a vector\n    vfloat32m1_t vl_sorted_even = vle32_v_f32m1(even_elements.data(), vl);\n\n    // Interleave sorted even elements back into their positions\n    vfloat32m1_t result = vl_data;\n    result = vmerge_vvm_f32m1(result, vl_sorted_even, mask_even, vl);\n\n    // Store the result back into the original vector\n    vse32_v_f32m1(data_ptr, result, vl);\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_81_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t size = l.size();\n    if (size == 0) return {};\n\n    // Determine the vector length and create a vector mask for even indices\n    size_t vl = vsetvl_e32m1(size);\n    vfloat32m1_t vmask_even = vmseq_vf_f32m1(vmsub_vv_i32m1(vslideup_vx_i32m1(vmv_x_x_i32(0), 1, vl), vmv_x_x_i32(2), vl), 0.0f, vl);\n\n    // Load data into a vector\n    vfloat32m1_t vdata = vle32_v_f32m1(l.data(), vl);\n\n    // Extract even-indexed elements using the mask\n    vfloat32m1_t veven = vmrgt_vv_f32m1(vdata, vdata, vl); // Dummy operation; replace with proper masking extraction\n\n    // Convert vector to array for sorting\n    float even_elements[size / 2 + size % 2];\n    vse32_v_f32m1(even_elements, veven, vl);\n\n    // Sort the even-indexed elements\n    std::sort(even_elements, even_elements + (size / 2 + size % 2));\n\n    // Load sorted even elements back into a vector\n    vfloat32m1_t vsorted_even = vle32_v_f32m1(even_elements, vl);\n\n    // Merge sorted even elements back into the original vector\n    vfloat32m1_t result = vmerge_vvm_f32m1(vsorted_even, vdata, vmask_even, vl);\n\n    // Store the result back into the original vector\n    vse32_v_f32m1(l.data(), result, vl);\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_82_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <stdbool.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l){\n    size_t n = l.size();\n    if (n < 3) return false;\n\n    int vl = vsetvl_e32m1(n);\n    vint32m1_t vzero = vmv_v_x_i32m1(0, vl);\n\n    for (size_t i = 0; i < n - 2; ++i) {\n        for (size_t j = i + 1; j < n - 1; ++j) {\n            vint32m1_t va = vmv_v_x_i32m1(l[i], vl);\n            vint32m1_t vb = vmv_v_x_i32m1(l[j], vl);\n            vint32m1_t vsum_ab = vadd_vv_i32m1(va, vb, vl);\n\n            for (size_t k = j + 1; k < n; ++k) {\n                vint32m1_t vc = vmv_v_x_i32m1(l[k], vl);\n                vbool32_t cmp_res = veq_vv_i32m1_b32(vadd_vv_i32m1(vsum_ab, vc, vl), vzero, vl);\n                if (vfirst_m_b32(cmp_res)) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l){\n    size_t n = l.size();\n    if (n < 3) return false;\n\n    // Sort the vector first\n    std::vector<int> sorted_l = l;\n    std::sort(sorted_l.begin(), sorted_l.end());\n\n    size_t vl = vsetvl_e32m1(n);\n\n    for (size_t i = 0; i < n - 2; ++i) {\n        size_t left = i + 1;\n        size_t right = n - 1;\n\n        while (left < right) {\n            int sum = sorted_l[i] + sorted_l[left] + sorted_l[right];\n\n            if (sum == 0) {\n                return true;\n            } else if (sum < 0) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n\n    // Vectorized search (example of using RVV intrinsics)\n    for (size_t i = 0; i < n - 2; i++) {\n        int a = sorted_l[i];\n        if (i > 0 && a == sorted_l[i - 1]) continue;\n\n        size_t j = i + 1;\n        size_t k = n - 1;\n\n        while (j < k) {\n            vint32m1_t vb = vmv_v_x_i32m1(vl, sorted_l[j]);\n            vint32m1_t vc = vmv_v_x_i32m1(vl, sorted_l[k]);\n\n            vint32m1_t va = vmv_v_x_i32m1(vl, a);\n            vint32m1_t vsum = vadd_vv_i32m1(vl, vb, vc);\n            vsum = vadd_vv_i32m1(vl, vsum, va);\n\n            vbool4_t mask = vmseq_vv_i32m1_b4(vl, vsum, vmv_v_x_i32m1(vl, 0));\n            if (vfirst_m_b4(mask)) {\n                return true;\n            }\n\n            if (sorted_l[j] + sorted_l[k] < -a) {\n                j++;\n            } else {\n                k--;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <stdbool.h>\n#include <algorithm>\n\nbool triples_sum_to_zero_simd(std::vector<int> l){\n    int n = l.size();\n    if (n < 3) return false;\n\n    std::vector<int> sorted_l = l;\n    std::sort(sorted_l.begin(), sorted_l.end());\n\n    size_t vl = vsetvl_e32m1(n);\n\n    for(int i = 0; i < n - 2; ++i){\n        int a = sorted_l[i];\n        int low = i + 1;\n        int high = n - 1;\n\n        while(low < high){\n            size_t vlj = vsetvl_e32m1(high - low);\n            vint32m1_t vb_low = vmv_v_x_i32m1(vlj, 0);\n            vint32m1_t vb_high = vmv_v_x_i32m1(vlj, 0);\n\n            for(int j = 0; j < vlj; ++j){\n                vb_low = vsext_vf4(vb_low, sorted_l[low + j]);\n                vb_high = vsext_vf4(vb_high, sorted_l[high - j]);\n            }\n\n            vint32m1_t vb_sum = vadd_vv_i32m1(vlj, vb_low, vb_high);\n            vb_sum = vadd_vx_i32m1(vlj, vb_sum, a);\n\n            vbool32_t mask = vmseq_vx_i32m1_b32(vlj, vb_sum, 0);\n\n            if(vany_nez_b32(mask)){\n                return true;\n            }\n\n            low += vlj;\n            high -= vlj;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nbool triples_sum_to_zero_simd(std::vector<int> l){\n    size_t n = l.size();\n    if (n < 3) return false;\n\n    std::vector<int> sorted_l = l;\n    std::sort(sorted_l.begin(), sorted_l.end());\n\n    size_t vl = vsetvl_e32m1(n);\n\n    for (size_t i = 0; i < n - 2; ++i) {\n        int a = sorted_l[i];\n        size_t left = i + 1;\n        size_t right = n - 1;\n\n        while (left < right) {\n            vint32m1_t vb_left = vmv_v_x_i32m1(sorted_l[left], vl);\n            vint32m1_t vb_right = vmv_v_x_i32m1(sorted_l[right], vl);\n            vint32m1_t vb_sum = vadd_vv_i32m1(vadd_vx_i32m1(vb_left, a, vl), vb_right, vl);\n\n            int sum_result = vmv_x_s_i32m1_i32(vb_sum);\n\n            if (sum_result == 0) {\n                return true;\n            } else if (sum_result < 0) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nbool triples_sum_to_zero_simd(std::vector<int> l){\n    size_t n = l.size();\n    if (n < 3) return false;\n\n    std::sort(l.begin(), l.end());\n\n    size_t vl = vsetvl_e32m1(n);\n\n    for (size_t i = 0; i < n - 2; ++i) {\n        size_t left = i + 1;\n        size_t right = n - 1;\n\n        while (left < right) {\n            int a = l[i];\n            int b = l[left];\n            int c = l[right];\n\n            vint32m1_t va = vmv_v_x_i32m1(a, vl);\n            vint32m1_t vb = vmv_v_x_i32m1(b, vl);\n            vint32m1_t vc = vmv_v_x_i32m1(c, vl);\n\n            vint32m1_t vsum = vadd_vv_i32m1(va, vb, vl);\n            vsum = vadd_vv_i32m1(vsum, vc, vl);\n\n            int sum = vmv_x_s_i32m1_i32(vsum, vl);\n\n            if (sum == 0) {\n                return true;\n            } else if (sum < 0) {\n                ++left;\n            } else {\n                --right;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_83_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l){\n    size_t size = l.size();\n    size_t vlmax = vsetvl_e32m1(size);\n    std::vector<int> result(size);\n\n    for (size_t i = 0; i < size; i += vlmax) {\n        size_t vl = vsetvl_e32m1(size - i);\n        vint32m1_t v_l = vle32_v_i32m1((const int *)&l[i], vl);\n        vint32m1_t v_one = vmv_v_x_i32m1(1, vl);\n        vint32m1_t v_res = vadd_vv_i32m1(v_l, v_one, vl);\n        vse32_v_i32m1(&result[i], v_res, vl);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l){\n    size_t size = l.size();\n    std::vector<int> result(size);\n    if (size == 0) return result;\n\n    size_t vlmax = vsetvl_e32m1(size);\n    int *ptr = l.data();\n    int *res_ptr = result.data();\n\n    for(size_t i = 0; i < size; i += vlmax){\n        size_t vl = vsetvl_e32m1(size - i);\n        vint32m1_t vmask = vmv_v_x_i32m1(vl, 0);\n        vint32m1_t vdata = vle32_v_i32m1(ptr + i, vl);\n        vint32m1_t vone = vmv_v_x_i32m1(1, vl);\n        vint32m1_t vinc = vadd_vv_i32m1(vdata, vone, vl);\n        vse32_v_i32m1(res_ptr + i, vinc, vl);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l){\n    size_t size = l.size();\n    std::vector<int> result(size);\n    if (size == 0) return result;\n\n    size_t vlmax = vsetvl_e32m1(size);\n    int *ptr = l.data();\n    int *res_ptr = result.data();\n\n    for(size_t i = 0; i < size; i += vlmax){\n        size_t vl = vsetvl_e32m1(size - i);\n        vint32m1_t vmask = vmv_v_x_i32m1(0, vl);\n        vint32m1_t vdata = vle32_v_i32m1(ptr + i, vl);\n        vint32m1_t vone = vmv_v_x_i32m1(1, vl);\n        vint32m1_t vresult = vadd_vv_i32m1(vdata, vone, vl);\n        vse32_v_i32m1(res_ptr + i, vresult, vl);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l){\n    size_t size = l.size();\n    std::vector<int> result(size);\n    if (size == 0) return result;\n\n    size_t vlmax = vsetvl_e32m1(size);\n    int *ptr = l.data();\n    int *res_ptr = result.data();\n\n    for(size_t i = 0; i < size; i += vlmax){\n        size_t vl = vsetvl_e32m1(size - i);\n        vint32m1_t vec_a = vle32_v_i32m1(ptr + i, vl);\n        vint32m1_t vec_one = vmv_v_x_i32m1(1, vl);\n        vint32m1_t res = vadd_vv_i32m1(vec_a, vec_one, vl);\n        vse32_v_i32m1(res_ptr + i, res, vl);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l){\n    size_t size = l.size();\n    std::vector<int> result(size);\n    if (size == 0) return result;\n\n    size_t vlmax = vsetvl_e32m1(size);\n    int* ptr = l.data();\n    int* res_ptr = result.data();\n\n    for(size_t i = 0; i < size; i += vlmax){\n        size_t vl = vsetvl_e32m1(size - i);\n        vint32m1_t vmask = vmv_v_x_i32m1(0, vl);\n        vint32m1_t vdata = vle32_v_i32m1(ptr + i, vl);\n        vint32m1_t vone = vmv_v_x_i32m1(1, vl);\n        vint32m1_t vres = vadd_vv_i32m1(vdata, vone, vl);\n        vse32_v_i32m1(res_ptr + i, vres, vl);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_84_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l){\n    if (l.size() < 2) return false;\n\n    size_t vl = vsetvl_e32m1(l.size());\n    vint32m1_t v_l = vmv_v_x_i32m1(0, vl);\n    for(size_t i = 0; i < l.size(); ++i){\n        v_l = vle32_v_i32m1(&l[i], vl);\n        for(size_t j = i + 1; j < l.size(); ++j){\n            vint32m1_t v_temp = vmv_v_x_i32m1(l[j], vl);\n            vbool32_t cmp_res = vmseq_vv_b32m1(v_l, vneg_v_i32m1(v_temp, vl), vl);\n            if (vfirst_m_b32(cmp_res, vl)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l){\n    if (l.size() < 2) return false;\n\n    size_t vl = vsetvl_e32m1(l.size());\n    vint32m1_t v_l = vmv_v_x_i32m1(0, vl);\n    for(size_t i = 0; i < l.size(); ++i){\n        v_l = vse_v_i32m1(&l[i], v_l, vl);\n    }\n\n    for(size_t i = 0; i < l.size(); ++i){\n        int neg = -l[i];\n        vint32m1_t v_neg = vmv_v_x_i32m1(neg, vl);\n        bool found = false;\n        for(size_t j = i+1; j < l.size(); ++j){\n            vint32m1_t v_j = vmv_v_x_i32m1(l[j], vl);\n            if (vmseq_m_b bypass(v_neg, v_j)){\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l){\n    if (l.size() < 2) return false;\n\n    size_t vl = vsetvl_e32m1(l.size());\n    vint32m1_t v0 = vmv_v_x_i32m1(0, vl);\n\n    for(size_t i = 0; i < l.size(); ++i){\n        int current = l[i];\n        vint32m1_t vcurrent = vmv_v_x_i32m1(current, vl);\n        vbool32_t mask = false;\n        for(size_t j = i + 1; j < l.size(); j += vl){\n            size_t num_elements = std::min(vl, (size_t)(l.size() - j));\n            vint32m1_t vload = vle32_v_i32m1(&l[j], num_elements);\n            vbool32_t veq = vmseq_vv_b32m1(vadd_vv_i32m1(vcurrent, vload, num_elements), v0, num_elements);\n            if (vfirst_m_b32(veq)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l){\n    if (l.size() < 2) return false;\n\n    size_t vl = vsetvl_e32m1(l.size());\n    vint32m1_t v0 = vmv_v_x_i32m1(0, vl);\n\n    for(size_t i = 0; i < l.size(); ++i){\n        int current = l[i];\n        size_t j_start = i + 1;\n        if(j_start >= l.size()) break;\n\n        size_t vl_j = vsetvl_e32m1(l.size() - j_start);\n        vint32m1_t vcurrent = vmv_v_x_i32m1(current, vl_j);\n        vint32m1_t vj = vle32_v_i32m1(&l[j_start], vl_j);\n        vbool32m1_t cmp_res = vmseq_vv_i32m1_b32m1(vj, vsub_vx_i32m1(vcurrent, 0, vl_j), vl_j);\n\n        size_t result = vmfirst_m_b32m1(cmp_res, vl_j);\n        if(result != vl_j){\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l){\n    if (l.size() < 2) return false;\n\n    size_t vl = vsetvl_e32m1(l.size());\n    vint32m1_t v_l = vmv_v_x_i32m1(0, vl);\n    vbool4_t result_mask = vmv_v_x_b4(false, vl);\n\n    for(size_t i = 0; i < l.size(); ++i){\n        int current = l[i];\n        vint32m1_t v_current = vmv_v_x_i32m1(current, vl);\n        vint32m1_t v_l_sub = vlsseg1e32_v_i32m1(&l[0], i * sizeof(int), vl);\n        vbool4_t mask = vmseq_vv_b4(v_l_sub, vneg_v_i32m1(v_current, vl), vl);\n        result_mask = vor_vv_b4(result_mask, mask, vl);\n        if (vmfirst_m_b4(result_mask, vl)) return true;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_85_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string change_base_simd(int64_t x, int8_t base){\n    if (x == 0) return \"0\";\n    bool negative = x < 0;\n    x = std::abs(x);\n\n    const int vl = 32;\n    std::vector<int8_t> digits;\n    int8_t mask = -1;\n\n    while (x > 0) {\n        vint8m1_t vx = vmv_v_x_i8m1(x, vl);\n        vint8m1_t vbase = vmv_v_x_i8m1(base, vl);\n        vint8m1_t vrem = vrem_vx_i8m1(vx, base, vl);\n        x = x / base;\n        int8_t rem = vmfirst_m_i8m1(mask, vrem, vl);\n        digits.push_back(rem);\n    }\n\n    if (negative) digits.push_back('-');\n\n    std::reverse(digits.begin(), digits.end());\n\n    std::string result;\n    for(auto d : digits){\n        if(d == '-') result += '-';\n        else result += ('0' + d);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string change_base_simd(int64_t x, int8_t base){\n    if (base < 2 || base > 10) return \"\";\n\n    std::string result;\n    bool is_negative = false;\n\n    if (x == 0) {\n        return \"0\";\n    }\n\n    if (x < 0) {\n        is_negative = true;\n        x = -x;\n    }\n\n    size_t vl = vsetvl_e64m1(1);\n    vuint64m1_t vx = vmv_v_x_u64m1(x, vl);\n    vuint64m1_t vzero = vmv_v_x_u64m1(0, vl);\n    vuint64m1_t vbase = vmv_v_x_u64m1(base, vl);\n    vuint64m1_t vrem;\n    uint64_t rem;\n\n    while (true) {\n        vrem = vdivu_vx_u64m1(vx, base, vl);\n        vx = vremu_vx_u64m1(vx, base, vl);\n        rem = vmv_x_s_u64m1_v(vrem, vl);\n        result += std::to_string(rem);\n        if (vx == vzero) break;\n    }\n\n    if (is_negative) {\n        result += '-';\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string change_base_simd(int64_t x, int8_t base){\n    if (x == 0) return \"0\";\n    bool negative = x < 0;\n    x = negative ? -x : x;\n\n    const int vl = 16; // Assume a vector length of 16 for demonstration purposes\n    uint8_t buffer[64] = {0};\n    size_t index = 0;\n\n    vuint8m1_t vm_one = vmv_v_x_u8m1(1, vl);\n    vuint8m1_t vbase = vmv_v_x_u8m1(base, vl);\n\n    while (x > 0) {\n        int64_t remainder = x % base;\n        x /= base;\n\n        buffer[index++] = remainder + '0';\n    }\n\n    std::string result(buffer, index);\n    if (negative) result += '-';\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string change_base_simd(int64_t x, int8_t base){\n    if (base < 2 || base > 10) return \"\";\n\n    std::string result;\n    bool is_negative = false;\n\n    if (x == 0) {\n        result = \"0\";\n        return result;\n    }\n\n    if (x < 0) {\n        is_negative = true;\n        x = -x;\n    }\n\n    size_t vl = vsetvl_e64m1(1);\n    vuint64m1_t vx = vmv_v_x_i64m1(x, vl);\n    vuint64m1_t vbase = vmv_v_x_i64m1(base, vl);\n\n    std::string digits = \"\";\n    while (true) {\n        vuint64m1_t remainder = vremu_vx_i64m1(vx, base, vl);\n        vx = vdivu_vx_i64m1(vx, base, vl);\n\n        uint64_t rem_val =vredu_vx_i64m1(remainder, vl);\n        digits += ('0' + static_cast<char>(rem_val));\n\n        uint64_t quotient = vredu_vx_i64m1(vx, vl);\n        if (quotient == 0) break;\n    }\n\n    if (is_negative) digits += '-';\n\n    result = std::string(digits.rbegin(), digits.rend());\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string change_base_simd(int64_t x, int8_t base){\n    if (base < 2 || base > 9) return \"\";\n\n    std::string result;\n    bool is_negative = false;\n\n    if (x == 0) {\n        return \"0\";\n    }\n\n    if (x < 0) {\n        is_negative = true;\n        x = -x;\n    }\n\n    size_t vl = vsetvl_e64m1(1);\n    vuint64m1_t vx = vmv_v_x_u64m1(x, vl);\n    vuint64m1_t vbase = vmv_v_x_u64m1(base, vl);\n    vuint64m1_t vzero = vmv_v_x_u64m1(0, vl);\n\n    int64_t remainder = 0;\n    while (true) {\n        vuint64m1_t vrem = vremu_vx_u64m1(vx, base, vl);\n        remainder = vmv_x_s_u64m1_v(vrem, vl);\n        result += ('0' + remainder);\n\n        vx = vdivu_vx_u64m1(vx, base, vl);\n        if (vmseq_vx_u64m1_b1(vx, 0, vl).b0) break;\n    }\n\n    if (is_negative) {\n        result += '-';\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_86_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text){\n    size_t n = text.size();\n    if (n == 0) return true;\n\n    size_t vl = vsetvl_e8m1(n);\n    uint8_t *data = reinterpret_cast<uint8_t*>(&text[0]);\n    bool result = true;\n\n    for(size_t i = 0; i < n / 2; i += vl){\n        size_t current_vl = vsetvl_e8m1(std::min(vl, n / 2 - i));\n        \n        vuint8m1_t vec_front = lv_u8_v(data + i, current_vl);\n        vuint8m1_t vec_back = lv_u8_v(data + n - i - 1, current_vl);\n\n        vuint8m1_t cmp_result = veq_vv_u8_m(vec_front, vec_back, current_vl);\n        size_t mask = vmv_x_s_u8_m(cmp_result);\n        if(mask != ((size_t)-1)){\n            result = false;\n            break;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_86_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    size_t n = text.size();\n    if (n == 0) return true;\n\n    size_t vl = vsetvl_e8m1(n);\n    uint8_t *data = reinterpret_cast<uint8_t*>(&text[0]);\n    bool result = true;\n\n    for (size_t i = 0; i < (n + 1) / 2; i += vl) {\n        size_t current_vl = vsetvl_e8m1(std::min(vl, (n + 1) / 2 - i));\n\n        vuint8m1_t vec_front = lvu_b(&data[i], current_vl);\n        vuint8m1_t vec_back = lvu_b(&data[n - 1 - i], current_vl);\n\n        vuint8m1_t cmp = veq_vv_u8m1(vec_front, vec_back, current_vl);\n        size_t mask = vmv_x_s_u8m1_u8(cmp, current_vl);\n\n        if (mask != ((1 << current_vl) - 1)) {\n            result = false;\n            break;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_86_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    size_t len = text.length();\n    if (len <= 1) return true;\n\n    size_t vl = vsetvl_e8m1(len);\n    uint8_t* data = reinterpret_cast<uint8_t*>(&text[0]);\n    bool result = true;\n\n    for(size_t i = 0; i < len / 2; i += vl) {\n        size_t current_vl = vsetvl_e8m1(vl);\n        vuint8m1_t vec_front = lvu_b(&data[i], current_vl);\n        vuint8m1_t vec_back = lvu_b(&data[len - i - 1], current_vl);\n\n        vuint8m1_t cmp_result = vmseq_u8_m(vec_front, vec_back, current_vl);\n        size_t mask = vmv_x_s_u8_m(cmp_result);\n        \n        if(mask != ((1ULL << current_vl) - 1)) {\n            result = false;\n            break;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_86_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    size_t n = text.size();\n    if (n == 0) return true;\n\n    size_t vl = vsetvl_e8m1(n);\n    uint8_t* data = reinterpret_cast<uint8_t*>(&text[0]);\n\n    for(size_t i = 0; i * vl < n / 2; i++) {\n        size_t current_vl = vsetvl_e8m1(std::min(vl, n / 2 - i * vl));\n\n        vuint8m1_t vec_front = lvu8_v(data + i * vl, current_vl);\n        vuint8m1_t vec_back = lvu8_v(data + (n - i * vl - 1), current_vl);\n\n        vuint8m1_t mask = veq_vv_u8_m(vec_front, vec_back, current_vl);\n\n        if (vmxeqi8_m_b8(mask, 0, current_vl)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    size_t n = text.size();\n    if (n == 0) return true;\n\n    size_t vl = vsetvl_e8m1(n);\n    uint8_t* data = reinterpret_cast<uint8_t*>(&text[0]);\n\n    for (size_t i = 0; i < (n / 2); i += vl) {\n        size_t current_vl = vsetvl_e8m1(std::min(vl, (n / 2) - i));\n\n        vuint8m1_t vec_front = lvu_b(data + i, current_vl);\n        vuint8m1_t vec_back = lvu_b(data + (n - i - 1), current_vl);\n\n        vuint8m1_t cmp_result = vmseq_u8_m(vec_front, vec_back, current_vl);\n        if (!vfredand_m_b8(current_vl, cmp_result)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_87_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s){\n    size_t vl = vsetvl_e8m1(s.length());\n    uint8_t shift = 5;\n    std::string out;\n    out.reserve(s.length());\n\n    const uint8_t a_val = 'a';\n    const uint8_t z_val = 'z';\n\n    for (size_t i = 0; i < s.length(); i += vl) {\n        size_t cur_vl = vsetvl_e8m1(s.length() - i);\n        vuint8m1_t vs = vle8_v_u8m1((const uint8_t *)&s[i], cur_vl);\n        vuint8m1_t va = vmv_v_x_u8m1(a_val, cur_vl);\n\n        // Subtract 'a' to bring into range [0,25]\n        vuint8m1_t vtemp = vsubu_vx_u8m1(vs, a_val, cur_vl);\n\n        // Subtract shift value\n        vtemp = vsubu_vx_u8m1(vtemp, shift, cur_vl);\n\n        // Wrap around using modulo 26\n        vtemp = vaddu_vx_u8m1(vtemp, 26, cur_vl);\n        vtemp = vremu_vx_u8m1(vtemp, 26, cur_v_l);\n\n        // Add 'a' back to get the character value\n        vtemp = vaddu_vx_u8m1(vtemp, a_val, cur_vl);\n\n        // Store the result\n        vse8_v_u8m1((uint8_t *)&out[i], vtemp, cur_vl);\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s){\n    size_t n = s.size();\n    size_t vl = vsetvl_e8m1(n);\n    uint8_t *input = (uint8_t *)s.data();\n    uint8_t *output = new uint8_t[n];\n    \n    for(size_t i = 0; i < n; i += vl) {\n        size_t sub_vl = vsetvl_e8m1(n - i);\n        vuint8m1_t vmask = vmsltu_vv_u8m1(vmv_v_x_i8m1(0, sub_vl), 26, sub_vl);\n        vuint8m1_t vdata = vle8_v_uint8m1(input + i, sub_vl);\n        vuint8m1_t vshifted = vfsubu_vx_u8m1(vdata, 5, sub_vl);\n        vuint8m1_t vadjusted = vfaddu_vx_u8m1(vfremu_vx_u8m1(vshifted, 26, sub_vl), 'a', sub_vl);\n        vse8_v_uint8m1(output + i, vadjusted, sub_vl);\n    }\n    \n    std::string result((char *)output, n);\n    delete[] output;\n    return result;\n}\n```"}
{"task_id": "SimdBench_87_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s){\n    size_t vl = vsetvl_e8m1(s.length());\n    uint8_t shift = 5;\n    std::string out;\n    out.reserve(s.length());\n\n    for(size_t i = 0; i < s.length(); i += vl) {\n        size_t sub_vl = vsetvl_e8m1(s.length() - i);\n        vuint8m1_t vs = vle8_v_u8m1((const uint8_t *)&s[i], sub_vl);\n        vuint8m1_t va = vmv_v_x_u8m1('a', sub_vl);\n        vuint8m1_t temp = vsubu_vx_u8m1(vs, shift, sub_vl);\n        vuint8m1_t wrap = vremu_vx_u8m1(temp, 26, sub_vl);\n        vuint8m1_t result = vaddu_vx_u8m1(wrap, 'a', sub_vl);\n        vse8_v_u8m1((uint8_t *)&out[i], result, sub_vl);\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s){\n    size_t vl = vsetvl_e8m1(s.length());\n    uint8_t shift = 21; // 26 - 5 for reverse shift\n    uint8_t a_val = 'a';\n    uint8_t z_val = 'z';\n    \n    std::string out;\n    out.reserve(s.length());\n\n    for(size_t i = 0; i < s.length(); i += vl){\n        size_t cur_vl = vsetvl_e8m1(s.length() - i);\n        vuint8m1_t vs = vle8_v_u8m1((uint8_t*)&s[i], cur_vl);\n        vuint8m1_t va = vmv_v_x_u8m1(a_val, cur_vl);\n        vuint8m1_t vz = vmv_v_x_u8m1(z_val, cur_vl);\n        \n        vuint8m1_t shifted = vfaddu_vx_u8m1(vs, shift, cur_vl);\n        vuint8m1_t sub_mask = vmsltu_vx_mask_u8m1_b1(shifted, va, cur_vl);\n        vuint8m1_t adjusted = vfwsubu_vx_u8m1(shifted, 26, cur_vl);\n        vuint8m1_t result = vmerge_vvm_u8m1(shifted, adjusted, sub_mask, cur_vl);\n\n        uint8_t buffer[cur_vl];\n        vse8_v_u8m1(buffer, result, cur_vl);\n        out.append((char*)buffer, cur_vl);\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s){\n    size_t vl = vsetvl_e8m1(s.length());\n    uint8_t shift = 5;\n    uint8_t a_char = 'a';\n    uint8_t z_char = 'z';\n    std::string out;\n\n    for (size_t i = 0; i < s.length(); i += vl) {\n        vl = vsetvl_e8m1(s.length() - i);\n        vuint8m1_t vs = vle8_v_u8m1((const uint8_t *)&s[i], vl);\n        vuint8m1_t va = vmv_v_x_u8m1(a_char, vl);\n        vuint8m1_t vz = vmv_v_x_u8m1(z_char, vl);\n\n        // Subtract shift\n        vuint8m1_t vtemp = vsubu_vx_u8m1(vs, shift, vl);\n\n        // Wrap around if less than 'a'\n        vbool8_t mask_lt_a = vle_vx_u8m1_b8(vtemp, a_char, vl);\n        vuint8m1_t vwrap = vaddu_vx_u8m1(vtemp, 26, vl);\n        vtemp = vmerge_vvm_u8m1(vtemp, vwrap, mask_lt_a, vl);\n\n        // Store result\n        vse8_v_u8m1((uint8_t *)&out[i], vtemp, vl);\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_88_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cstdint>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    size_t vl = vsetvl_e32m1(l.size());\n    vint32m1_t v_t = vmv_v_x_i32m1(t, vl);\n    vbool4_t result = vmge_vx_b4_t(true, vl);\n\n    for (size_t i = 0; i < l.size(); i += vl) {\n        size_t sub vl = vsetvl_e32m1(std::min(vl, static_cast<size_t>(l.size() - i)));\n        vint32m1_t vl_vec = vle32_v_i32m1(&l[i], sub_vl);\n        vbool4_t cmp = vmge_vx_b4_t(vl_vec, t, sub_vl);\n        result = vor_vv_b4_t(result, cmp, sub_vl);\n    }\n\n    return !vmfirst_m_b4_t(result, vl);\n}\n```"}
{"task_id": "SimdBench_88_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    size_t vl = vsetvl_e32m1(l.size());\n    vint32m1_t v_t = vmv_v_x_i32m1(t, vl);\n    vbool32_t result = vmf_eq_vv_b32m1(true, vl); // Initialize to true\n\n    for (size_t i = 0; i < l.size(); i += vl) {\n        size_t current vl = vsetvl_e32m1(std::min(vl, (size_t)(l.size() - i)));\n        vint32m1_t vl_data = vle32_v_i32m1((const int *)&l[i], current_vl);\n        vbool32_t v_cmp = vmf_lt_vx_b32m1(vl_data, t, current_vl);\n        result = vand_vv_b32m1(result, v_cmp, current_vl);\n    }\n\n    bool final_result = true;\n    for (size_t i = 0; i < vl; ++i) {\n        if (!result[i]) {\n            final_result = false;\n            break;\n        }\n    }\n    return final_result;\n}\n```"}
{"task_id": "SimdBench_88_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    size_t vl = vsetvl_e32m1(l.size());\n    vint32m1_t vt = vmv_v_x_i32m1(t, vl);\n    vbool4_t result = vmge_vx_b4(l.data(), t, vl);\n    bool final_result = !vmsbf_m_b4(result, vl);\n    return final_result;\n}\n```"}
{"task_id": "SimdBench_88_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    bool result = true;\n    size_t vlmax = vsetvl_e32m1(l.size());\n    vuint32m1_t vt = vmv_v_x_u32m1(t, vlmax);\n    size_t i = 0;\n\n    for (; i + vlmax <= l.size(); i += vlmax) {\n        vuint32m1_t vl_vec = lvu32_v_u32m1((uint32_t *)&l[i], vlmax);\n        vbool4_t cmp_result = vmge_vx_b4m1(vl_vec, t, vlmax);\n        if (vmfirst_m_b4m1(cmp_result, vlmax)) {\n            result = false;\n            break;\n        }\n    }\n\n    for (; i < l.size(); ++i) {\n        if (l[i] >= t) {\n            result = false;\n            break;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_88_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdalign.h>\n\nbool below_threshold_simd(const std::vector<int>& l, int t) {\n    size_t vlmax = vsetvl_e32m1(l.size());\n    bool result = true;\n\n    for (size_t i = 0; i < l.size(); i += vlmax) {\n        size_t vl = vsetvl_e32m1(l.size() - i);\n        vint32m1_t v_t = vmv_v_x_i32m1(t, vl);\n        vint32m1_t v_l = lvsl_v_i32m1((uint8_t*)&l[i], vl);\n\n        vbool32_t mask = vmge_vx_i32m1_b32(v_l, t, vl);\n        if (vmfirst_m_b32(mask, vl)) {\n            result = false;\n            break;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_89_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    if (brackets.empty()) return true;\n\n    size_t vl = vsetvl_e8m1(brackets.size());\n    vuint8m1_t v_zero = vmv_v_x_u8m1(0, vl);\n    vuint8m1_t v_one = vmv_v_x_u8m1(1, vl);\n    vuint8m1_t v_neg_one = vmv_v_x_u8m1(-1, vl);\n\n    int balance = 0;\n    size_t i = 0;\n\n    while (i < brackets.size()) {\n        vl = vsetvl_e8m1(brackets.size() - i);\n        vuint8m1_t v_chars = vle8_v_u8m1(reinterpret_cast<const uint8_t*>(&brackets[i]), vl);\n        vbool8_t v_less = vmseq_vx_u8m1_b8(v_chars, '<', vl);\n        vbool8_t v_greater = vmseq_vx_u8m1_b8(v_chars, '>', vl);\n\n        vuint8m1_t v_balance = vmerge_vvm_u8m1(v_zero, v_one, v_less, vl);\n        v_balance = vmerge_vvm_u8m1(v_balance, v_neg_one, v_greater, vl);\n\n        int temp_balance = 0;\n        for (size_t j = 0; j < vl; ++j) {\n            temp_balance += (int)vget_v_u8m1(v_balance, j);\n            if (temp_balance < 0) return false;\n        }\n        balance += temp_balance;\n\n        i += vl;\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets){\n    size_t vl = vsetvl_e8m1(brackets.length());\n    vuint8m1_t vbrackets = vle8_v_u8m1(reinterpret_cast<const uint8_t*>(brackets.c_str()), vl);\n    vuint8m1_t vopen = vmseq_vx_u8m1_b1(vbrackets, '<', vl);\n    vuint8m1_t vclose = vmseq_vx_u8m1_b1(vbrackets, '>', vl);\n\n    int balance = 0;\n    size_t i = 0;\n    for (; i <= brackets.length() - vl; i += vl) {\n        int popen = (int)vpopc_b_m(vopen, vl);\n        int pclose = (int)vpopc_b_m(vclose, vl);\n        balance += popen - pclose;\n        if (balance < 0) return false;\n        vbrackets = vle8_v_u8m1(reinterpret_cast<const uint8_t*>(&brackets[i + vl]), vl);\n        vopen = vmseq_vx_u8m1_b1(vbrackets, '<', vl);\n        vclose = vmseq_vx_u8m1_b1(vbrackets, '>', vl);\n    }\n    for (; i < brackets.length(); ++i) {\n        if (brackets[i] == '<') balance++;\n        else if (brackets[i] == '>') balance--;\n        if (balance < 0) return false;\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets){\n    size_t n = brackets.size();\n    if (n == 0) return true;\n\n    size_t vl = vsetvl_e8m1(n);\n    uint8_t balance = 0;\n    uint8_t* data = reinterpret_cast<uint8_t*>(&brackets[0]);\n\n    for(size_t i = 0; i < n; i += vl){\n        size_t ei = std::min(i + vl, n);\n        size_t subvl = vsetvl_e8m1(ei - i);\n\n        vuint8m1_t vec = lv_uint8m1(data + i, subvl);\n        vuint8m1_t opening = vmseq_u8_m(vec, 60, true, subvl); // '<' ASCII is 60\n        vuint8m1_t closing = vmseq_u8_m(vec, 62, true, subvl); // '>' ASCII is 62\n\n        vuint8m1_t cum_opening = vmop_v_u8_m(opening, true, subvl);\n        vuint8m1_t cum_closing = vmop_v_u8_m(closing, true, subvl);\n\n        uint8_t sum_opening = vmv_x_s_u8m1_u8(vmredsum_vs_u8_m(cum_opening, 0, true, subvl));\n        uint8_t sum_closing = vmv_x_s_u8m1_u8(vmredsum_vs_u8_m(cum_closing, 0, true, subvl));\n\n        balance += sum_opening - sum_closing;\n        if(balance < 0) return false;\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets){\n    size_t vl = vsetvl_e8m1(brackets.length());\n    vuint8m1_t v_zero = vmv_v_x_i8m1(0, vl);\n    vuint8m1_t v_one = vmv_v_x_i8m1(1, vl);\n    vuint8m1_t v_neg_one = vmv_v_x_i8m1(-1, vl);\n\n    int balance = 0;\n    for(size_t i = 0; i < brackets.length(); i += vl) {\n        size_t chunk_size = (brackets.length() - i > vl) ? vl : brackets.length() - i;\n        uint8_t *chunk = (uint8_t*)&brackets[i];\n        vuint8m1_t v_chunk = vle8_v_u8m1(chunk, chunk_size);\n\n        vbool8_t is_open = vmseq_vx_i8m1_b8(v_chunk, '<', chunk_size);\n        vbool8_t is_close = vmseq_vx_i8m1_b8(v_chunk, '>', chunk_size);\n\n        vuint8m1_t v_balance = vredsum_vs_i8m1_i8m1_i8(v_zero, vmERGE_vvm_i8m1(v_one, is_open, v_zero, chunk_size), v_zero, chunk_size);\n        v_balance = vredsum_vs_i8m1_i8m1_i8(v_balance, vmERGE_vvm_i8m1(v_neg_one, is_close, v_zero, chunk_size), v_balance, chunk_size);\n\n        balance += (int)v Balance[0];\n        if(balance < 0) return false;\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    if (brackets.empty()) return true;\n\n    size_t vl = vsetvl_e8m1(brackets.size());\n    vuint8m1_t v_zero = vmv_v_x_u8m1(0, vl);\n    vuint8m1_t v_one = vmv_v_x_u8m1(1, vl);\n    vuint8m1_t v_neg_one = vmv_v_x_u8m1(-1, vl);\n\n    uint8_t balance = 0;\n    size_t i = 0;\n\n    while (i < brackets.size()) {\n        size_t chunk_size = std::min((size_t)vl, brackets.size() - i);\n        vuint8m1_t v_chars = vle8_v_u8m1(reinterpret_cast<const uint8_t*>(&brackets[i]), chunk_size);\n\n        vbool8_t is_open = vmseq_vx_u8m1_b8(v_chars, '<', chunk_size);\n        vbool8_t is_close = vmseq_vx_u8m1_b8(v_chars, '>', chunk_size);\n\n        vuint8m1_t v_balance_update = vor_vv_u8m1(vand_vv_u8m1(is_open, v_one, chunk_size), \n                                                 vand_vv_u8m1(is_close, v_neg_one, chunk_size), chunk_size);\n\n        vuint8m1_t v_balance = vmv_v_x_u8m1(balance, chunk_size);\n        v_balance = vredsum_vs_u8m1_u64(v_balance_update, v_balance, v_balance, chunk_size);\n\n        balance = vmv_x_s_u64_u8m1(v_balance);\n\n        if (balance < 0) return false;\n\n        i += chunk_size;\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t n = brackets.size();\n    if (n == 0) return true;\n\n    size_t vlen = rvv_vsetvl_e8m1(n);\n    vuint8m1_t vmask = rvv_vle8_v_u8m1((const uint8_t*)brackets.c_str(), vlen);\n\n    vint32m4_t vcount = rvv_vmv_v_x_i32m4(0, vlen);\n    vbool4_t vtrue = rvv_vt_b4_true();\n\n    size_t i = 0;\n    for (; i + vlen <= n; i += vlen) {\n        vuint8m1_t chunk = rvv_vle8_v_u8m1((const uint8_t*)(brackets.c_str() + i), vlen);\n        vbool8_t is_open = rvv_vmsne_vx_i8mf8_b8(chunk, '(', vlen);\n        vbool8_t is_close = rvv_vmsne_vx_i8mf8_b8(chunk, ')', vlen);\n\n        vint32m4_t open_count = rvv_vpopc_vm_i32m4_i8mf8(is_open, vtrue, vlen);\n        vint32m4_t close_count = rvv_vpopc_vm_i32m4_i8mf8(is_close, vtrue, vlen);\n\n        vcount = rvv_vadd_vv_i32m4(vcount, open_count, vlen);\n        vcount = rvv_vsub_vv_i32m4(vcount, close_count, vlen);\n\n        if (rvv_vmslt_vx_i32m4_b4(vcount, 0, vlen)) {\n            return false;\n        }\n    }\n\n    int scalar_count = 0;\n    for (; i < n; ++i) {\n        if (brackets[i] == '(') scalar_count++;\n        else if (brackets[i] == ')') scalar_count--;\n        if (scalar_count < 0) return false;\n    }\n\n    return scalar_count == 0;\n}\n```"}
{"task_id": "SimdBench_90_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t length = brackets.length();\n    if (length == 0) return true;\n\n    size_t vl = vsetvl_e8m1(length);\n    uint8_t balance = 0;\n    bool valid = true;\n\n    for (size_t i = 0; i < length; i += vl) {\n        size_t sub_length = length - i > vl ? vl : length - i;\n\n        vuint8m1_t vmask = __riscv_vmsnevi_b(vdefault_mask(), 0, sub_length);\n        vuint8m1_t vbrackets = __riscv_vle8_v_uint8m1((const uint8_t*)&brackets[i], vmask);\n\n        vuint8m1_t vopen = __riscv_vmseq_vx_uint8m1_b(vbrackets, '(', vmask);\n        vuint8m1_t vclose = __riscv_vmseq_vx_uint8m1_b(vbrackets, ')', vmask);\n\n        uint8_t count_open = __riscv_vpopc_m_b(vmask, vopen);\n        uint8_t count_close = __riscv_vpopc_m_b(vmask, vclose);\n\n        balance += count_open - count_close;\n        if (balance < 0) {\n            valid = false;\n            break;\n        }\n    }\n\n    return valid && (balance == 0);\n}\n```"}
{"task_id": "SimdBench_90_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    if (brackets.empty()) return true;\n\n    size_t vl = brackets.size();\n    size_t max_vl = vmv_v_x_size_e8_m();\n    bool valid = true;\n\n    for (size_t i = 0; i < vl; i += max_vl) {\n        size_t current_vl = (vl - i > max_vl) ? max_vl : (vl - i);\n        vuint8m1_t v_brackets = lv_u8_v((const uint8_t*)(brackets.c_str() + i), current_vl);\n        vbool8_t mask = vmsne_vx_mask_b8_m(v_brackets, '(', current_vl);\n        vint32m4_t count = vmv_x_x_i32(0);\n\n        for (size_t j = 0; j < current_vl; ++j) {\n            vbool8_t cond = vmseq_vx_mask_b8_m(v_brackets, '(', current_vl);\n            count = vmadd_vx_mask_i32_m(count, cond, 1, count, current_vl);\n            cond = vmseq_vx_mask_b8_m(v_brackets, ')', current_vl);\n            count = vmsub_vx_mask_i32_m(count, cond, 1, count, current_vl);\n\n            if (vmifle_vx_i32_m(count, 0, current_vl)) {\n                valid = false;\n                break;\n            }\n        }\n\n        if (valid == false || vmifle_vx_i32_m(count, 0, current_vl)) {\n            break;\n        }\n    }\n\n    return valid && (vmv_x_s_i32_i32(vmop_v_i32_m(count, current_vl)) == 0);\n}\n```"}
{"task_id": "SimdBench_90_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t vl = vsetvl_e8m1(brackets.length());\n    vuint8m1_t v_zero = vmv_v_x_u8m1(0, vl);\n    vuint8m1_t v_one = vmv_v_x_u8m1(1, vl);\n    vuint8m1_t v_neg_one = vmv_v_x_u8m1(-1, vl);\n\n    uint8_t balance = 0;\n    size_t i = 0;\n\n    while (i < brackets.length()) {\n        size_t chunk_size = std::min((size_t)vl, brackets.length() - i);\n        uint8_t buffer[chunk_size];\n        for (size_t j = 0; j < chunk_size; ++j) {\n            buffer[j] = brackets[i + j] == '(' ? 1 : (brackets[i + j] == ')' ? -1 : 0);\n        }\n\n        vint8m1_t v_buffer = vle8_v_i8m1(buffer, chunk_size);\n        vint8m1_t v_balance = vredsum_vs_i8m1_i8m1(v_buffer, v_zero, v_one, chunk_size);\n\n        int8_t temp_balance = vmv_x_s_i8m1_i8(v_balance);\n        balance += temp_balance;\n\n        if (balance < 0) {\n            return false;\n        }\n\n        i += chunk_size;\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    if (brackets.empty()) return true;\n\n    size_t vl = vsetvl_e8m1(brackets.size());\n    vuint8m1_t v_zero = vmv_v_x_u8m1(0, vl);\n    vint32m1_t count = vmv_v_x_i32m1(0, vl);\n\n    int balance = 0;\n    for (size_t i = 0; i < brackets.size(); i += vl) {\n        size_t chunk_size = std::min(vl, (size_t)(brackets.size() - i));\n        vuint8m1_t v_data = vle8_v_u8m1((const uint8_t *)(brackets.c_str() + i), chunk_size);\n\n        vbool8_t is_open = vmseq_vx_u8m1_b8(v_data, '(', chunk_size);\n        vbool8_t is_close = vmseq_vx_u8m1_b8(v_data, ')', chunk_size);\n\n        vuint8m1_t open_count = vmcnt_m_u8m1(is_open, v_zero, chunk_size);\n        vuint8m1_t close_count = vmcnt_m_u8m1(is_close, v_zero, chunk_size);\n\n        int32_t open_sum = (int32_t)vredsum_vs_u8m1_i32m1(open_count, v_zero, chunk_size);\n        int32_t close_sum = (int32_t)vredsum_vs_u8m1_i32m1(close_count, v_zero, chunk_size);\n\n        balance += open_sum - close_sum;\n        if (balance < 0) return false;\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_91_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.size() <= 1) return {};\n\n    size_t vl = vsetvl_e32m8(xs.size() - 1);\n    float* x_ptr = xs.data();\n    size_t n = xs.size();\n\n    std::vector<float> result(n - 1, 0.0f);\n    float* res_ptr = result.data();\n\n    size_t i = 0;\n    for (; i + vl <= n - 1; i += vl) {\n        vfloat32m8_t v_x = vle32_v_f32m8(x_ptr + i + 1, vl);\n        vint32m8_t v_idx = vmv_s_x_i32m8(i + 1, vl);\n        vfloat32m8_t v_res = vmul_vf_f32m8(v_x, v_idx, vl);\n        vse32_v_f32m8(res_ptr + i, v_res, vl);\n    }\n\n    // Handle remaining elements\n    vl = vsetvl_e32m8(n - 1 - i);\n    if (i < n - 1) {\n        vfloat32m8_t v_x = vle32_v_f32m8(x_ptr + i + 1, vl);\n        vint32m8_t v_idx = vmv_s_x_i32m8(i + 1, vl);\n        vfloat32m8_t v_res = vmul_vf_f32m8(v_x, v_idx, vl);\n        vse32_v_f32m8(res_ptr + i, v_res, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.size() <= 1) return {};\n\n    size_t vl = vsetvl_e32m1(xs.size() - 1);\n    vfloat32m1_t v_x = vmv_v_x_f32m1(0.0f, vl);\n    vfloat32m1_t v_res = vmv_v_x_f32m1(0.0f, vl);\n    vint32m1_t v_idx = vid_v_i32m1(0, vl);\n\n    for (size_t i = 1; i < xs.size(); i += vl) {\n        size_t current_vl = std::min(vl, xs.size() - i);\n        v_x = vle32_v_f32m1(&xs[i], current_vl);\n        v_idx = vid_v_i32m1(0, current_vl);\n        v_res = vmul_vf_f32m1(v_x, (float)i, current_vl);\n        vse32_v_f32m1(&xs[i], v_res, current_vl);\n    }\n\n    std::vector<float> result(xs.begin() + 1, xs.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.size() <= 1) return {};\n\n    size_t n = xs.size() - 1;\n    std::vector<float> result(n);\n\n    size_t vlmax = vsetvl_e32m1(n);\n    float* x_ptr = xs.data();\n    float* res_ptr = result.data();\n\n    for (size_t i = 0; i < n; i += vlmax) {\n        size_t vl = vsetvl_e32m1(n - i);\n        vfloat32m1_t v_idx = vid_v_f32m1(vl);\n        vfloat32m1_t v_x = vle32_v_f32m1(x_ptr + i + 1, vl);\n        vfloat32m1_t v_res = vmul_vv_f32m1(v_x, v_idx, vl);\n        vse32_v_f32m1(res_ptr + i, v_res, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.empty()) return {};\n\n    size_t n = xs.size() - 1;\n    if (n == 0) return {};\n\n    std::vector<float> result(n);\n    size_t vl_max = vsetvl_e32m1(n);\n\n    for (size_t i = 0; i < n; i += vl_max) {\n        size_t vl = vsetvl_e32m1(n - i);\n        vfloat32m1_t vx = vmv_v_x_f32m1(0.0f, vl);\n        vfloat32m1_t vcoeff = vle32_v_f32m1((const float *)&xs[i + 1], vl);\n        vint32m1_t vidx = vid_v_i32m1(vl);\n        vint32m1_t vindices = vadd_vx_i32m1(vidx, i + 1, vl);\n        vfloat32m1_t vindices_f = vfcvt_f_x_f32m1(vindices, vl);\n        vx = vmul_vv_f32m1(vcoeff, vindices_f, vl);\n        vse32_v_f32m1(&result[i], vx, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.size() <= 1) return {};\n\n    size_t vlmax = vsetvl_e32m1(0);\n    size_t n = xs.size() - 1;\n    std::vector<float> result(n);\n\n    size_t i = 0;\n    for (; i + vlmax <= n; i += vlmax) {\n        size_t vl = vsetvl_e32m1(vlmax);\n        vfloat32m1_t v_idx = vmv_v_x_f32m1(i, vl);\n        v_idx = vadd_vx_f32m1(v_idx, i, vl);\n        vfloat32m1_t v_xs = vle32_v_f32m1(&xs[i + 1], vl);\n        vfloat32m1_t v_res = vmul_vv_f32m1(v_xs, v_idx, vl);\n        vse32_v_f32m1(&result[i], v_res, vl);\n    }\n\n    if (i < n) {\n        size_t vl = vsetvl_e32m1(n - i);\n        vfloat32m1_t v_idx = vmv_v_x_f32m1(i, vl);\n        v_idx = vadd_vx_f32m1(v_idx, i, vl);\n        vfloat32m1_t v_xs = vle32_v_f32m1(&xs[i + 1], vl);\n        vfloat32m1_t v_res = vmul_vv_f32m1(v_xs, v_idx, vl);\n        vse32_v_f32m1(&result[i], v_res, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_92_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cctype>\n#include <string>\n\nint vowels_count_simd(std::string s){\n    const uint8_t vowels[] = {'a', 'e', 'i', 'o', 'u', 'y'};\n    size_t vl = vsetvl_e8m1(s.size());\n    int count = 0;\n\n    for(size_t i = 0; i < s.size(); i += vl){\n        size_t sub_vl = vsetvl_e8m1(s.size() - i);\n        vuint8m1_t vc = vmv_v_x_i8m1(0, sub_vl);\n        for(char c : vowels){\n            vuint8m1_t vt = vmseq_vx_i8m1(load_string(s, i, sub_vl), tolower(c), sub_vl);\n            vc = vor_vv_i8m1(vc, vt, sub_vl);\n        }\n        // Special case for 'y' at the end\n        if(i + sub_vl > s.size() -1 && tolower(s[s.size()-1]) == 'y'){\n            vc = vor_vx_i8m1(vc, vmseq_vx_i8m1(load_string(s, i, sub_vl), tolower('y'), sub_vl), sub_vl);\n        }\n        count += (int)vpopc_vm_i8m1(vc, sub_vl);\n    }\n    return count;\n}\n\nvuint8m1_t load_string(const std::string& s, size_t start, size_t vl){\n    vuint8m1_t vec = vle8_v_u8m1((const uint8_t*)(s.c_str() + start), vl);\n    return vec;\n}\n```"}
{"task_id": "SimdBench_92_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <algorithm>\n\nint vowels_count_simd(std::string s){\n    const uint8_t vowels[] = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n    size_t vl = vsetvl_e8m1(s.size());\n    int count = 0;\n\n    for(size_t i = 0; i < s.size(); i += vl){\n        size_t chunk_size = std::min(vl, (size_t)(s.size() - i));\n        vl = vsetvl_e8m1(chunk_size);\n\n        vuint8m1_t vs = vle8_v_u8m1(reinterpret_cast<const uint8_t*>(&s[i]), vl);\n        vuint8m1_t vmask = vmv_v_x_u8m1(0, vl);\n\n        for(auto vowel : vowels){\n            vuint8m1_t vc = vmv_v_x_u8m1(static_cast<uint8_t>(vowel), vl);\n            vmask = vor_vv_u8m1(vmask, veq_vv_u8m1(vs, vc, vl), vl);\n        }\n\n        // Check for 'y' or 'Y' at the end of the word\n        if(i + chunk_size == s.size()){\n            uint8_t last_char = static_cast<uint8_t>(s.back());\n            if(last_char == 'y' || last_char == 'Y'){\n                vmask = vor_vv_u8m1(vmask, veq_vv_u8m1(vs, vmv_v_x_u8m1(last_char, vl), vl), vl);\n            }\n        }\n\n        count += __builtin_popcount(vmask.v-seg(0));\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <algorithm>\n\nint vowels_count_simd(std::string s){\n    const uint8_t vowels[] = {'a', 'e', 'i', 'o', 'u', 'y'};\n    size_t vl = vsetvl_e8m1(s.size());\n    int count = 0;\n\n    for(size_t i = 0; i < s.size(); i += vl){\n        size_t chunk_size = std::min(vl, (size_t)(s.size() - i));\n        vuint8m1_t vs = vle8_v_u8m1((const uint8_t*)&s[i], chunk_size);\n        vuint8m1_t vmask = vmseq_vx_u8m1_b1(vs, 'y', chunk_size);\n        if(i + chunk_size == s.size()){\n            vmask = vmf_eq_mask(vmask, true);\n        }\n        for(auto vowel : vowels){\n            vmask = vmf_or_mask(vmask, vmseq_vx_u8m1_b1(vs, vowel, chunk_size));\n        }\n        count += vm popcount_mask(vmask, chunk_size);\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <cctype>\n\nint vowels_count_simd(std::string s){\n    const uint8_t vowels[] = {'a', 'e', 'i', 'o', 'u', 'y'};\n    size_t vl = vsetvl_e8m1(s.size());\n    int count = 0;\n\n    for(size_t i = 0; i < s.size(); i += vl){\n        size_t chunk_size = std::min(vl, (size_t)(s.size() - i));\n        vuint8m1_t vs = vle8_v_u8m1(reinterpret_cast<const uint8_t*>(&s[i]), chunk_size);\n        vuint8m1_t vmask = vmseq_vx_u8m1_b1(vs, 'y', chunk_size);\n\n        for(int j = 0; j < 5; ++j){\n            vuint8m1_t vvowel = vmsegeq_vx_u8m1_b1(vs, vowels[j], chunk_size);\n            if(j == 5){\n                vvowel = vor_vv_b1(vvowel, vmask, chunk_size);\n            }\n            count += vpopc_m_b1(true, vvowel, chunk_size);\n        }\n    }\n\n    if(!s.empty() && tolower(s.back()) == 'y'){\n        count++;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cstring>\n#include <string>\n#include <cctype>\n\nint vowels_count_simd(std::string s) {\n    const uint8_t vowels[] = {'a', 'e', 'i', 'o', 'u', 'y'};\n    size_t len = s.length();\n    if (len == 0) return 0;\n\n    int count = 0;\n    size_t vl = vsetvl_e8m1(len);\n\n    // Convert string to uppercase for uniform comparison\n    std::string upper_str = s;\n    for (size_t i = 0; i < len; ++i) {\n        upper_str[i] = toupper(upper_str[i]);\n    }\n\n    const uint8_t* str_ptr = reinterpret_cast<const uint8_t*>(upper_str.c_str());\n    vuint8m1_t vmask = vmv_v_x_u8m1(0, vl);\n    vuint8m1_t vcount = vmv_v_x_u8m1(0, vl);\n\n    for (size_t i = 0; i < len; i += vl) {\n        size_t sub_len = (len - i) > vl ? vl : (len - i);\n        vuint8m1_t vstr = lv_uint8m1_v_u8(str_ptr + i, sub_len);\n\n        for (size_t j = 0; j < 6; ++j) {\n            vuint8m1_t vvowel = vmv_v_x_u8m1(toupper(vowels[j]), sub_len);\n            vmask = vmseq_vv_u8m1_b1(vstr, vvowel, sub_len);\n            vcount = vaddmv_vx_u8m1_u8m1(vcount, vmask, sub_len);\n        }\n    }\n\n    // Check if 'Y' is at the end of the word\n    if (toupper(s[len - 1]) == 'Y') {\n        vcount = vredsum_vs_u8m1_u64(vcount, vcount, vl);\n        count = static_cast<int>(vget_v_u64(vcount, 0)) - 1;\n    } else {\n        vcount = vredsum_vs_u8m1_u64(vcount, vcount, vl);\n        count = static_cast<int>(vget_v_u64(vcount, 0));\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_93_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint digitSum_simd(std::string s){\n    int sum = 0;\n    size_t n = s.size();\n    if (n == 0) return 0;\n\n    size_t vl = vsetvl_e8m1(n);\n    uint8_t *data = (uint8_t *)s.data();\n    vuint8m1_t vmask = vmseq_vu8m1_b1(vle8_v_u8m1(data, vl), 0, vl);\n    vuint8m1_t vzero = vmv_v_x_u8m1(0, vl);\n\n    for(size_t i = 0; i < n; i += vl){\n        size_t sub_n = (n - i) > vl ? vl : (n - i);\n        vuint8m1_t vch = vle8_v_u8m1(data + i, sub_n);\n        vbool8_t is_upper = vmge_vx_u8m1_b8(vch, 'A', sub_n) & vmlt_vx_u8m1_b8(vch, 'Z'+1, sub_n);\n        vuint8m1_t vupper = vm_and_vvm_u8m1(vch, is_upper, sub_n);\n        vuint8m1_t acc = vredsum_vs_u8m1_u64(vupper, vzero, vmask, sub_n);\n        sum += (int)vget_v_u64m1(acc, 0);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint digitSum_simd(std::string s){\n    int sum = 0;\n    size_t n = s.size();\n    if (n == 0) return 0;\n\n    size_t i = 0;\n    size_t vl = vsetvl_e8m1(n);\n    uint8_t mask;\n    vuint8m1_t vsum = vmv_v_x_u8m1(0, vl);\n\n    for (; i <= n - vl; i += vl) {\n        vuint8m1_t vc = vle8_v_u8m1((const uint8_t *)&s[i], vl);\n        vbool8_t is_upper = vmge_vx_u8m1_b8(vc, 'A', vl) & vmle_vx_u8m1_b8(vc, 'Z', vl);\n        vsum = vadd_vv_u8m1(vsum, vmul_vx_u8m1(vc, is_upper, vl), vl);\n    }\n\n    // Horizontal sum\n    uint8_t temp[vl];\n    vse8_v_u8m1(temp, vsum, vl);\n    for (size_t j = 0; j < vl; ++j) {\n        sum += temp[j];\n    }\n\n    // Tail handling\n    for (; i < n; ++i) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            sum += s[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint digitSum_simd(std::string s){\n    size_t n = s.size();\n    if (n == 0) return 0;\n\n    int result = 0;\n    size_t i = 0;\n\n    size_t vl = vsetvl_e8m1(n);\n    vuint8m1_t vzero = vmv_v_x_i8m1(0, vl);\n    vuint8m1_t vupper = vmv_v_x_i8m1('A', vl);\n    vuint8m1_t vlower = vmv_v_x_i8m1('Z', vl);\n\n    for (; i <= (n - vl); i += vl) {\n        vuint8m1_t vdata = lv_u8_v_i8m1((const uint8_t *)&s[i], vl);\n        vbool8_t is_upper = vmge_vx_i8m1_b8(vdata, 'A', vl) & vmle_vx_i8m1_b8(vdata, 'Z', vl);\n        vuint8m1_t vmasked = vm_and_vv_i8m1(vdata, is_upper, vl);\n        vuint32m1_t vsum =vredu_sum_vs_i8m1_i32m1(vmasked, vzero, vl);\n        result += (int)vget_v_i32m1(vsum, 0);\n    }\n\n    // Handle leftovers\n    for (; i < n; ++i) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            result += s[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_93_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint digitSum_simd(std::string s){\n    int sum = 0;\n    size_t n = s.size();\n    size_t i = 0;\n\n    const uint8_t upper_bound = 'Z';\n    const uint8_t lower_bound = 'A';\n\n    size_t vl = vsetvl_e8m1(n);\n    vuint8m1_t v_upper_bound = vmv_v_x_u8m1(upper_bound, vl);\n    vuint8m1_t v_lower_bound = vmv_v_x_u8m1(lower_bound, vl);\n    vuint8m1_t v_zero = vmv_v_x_u8m1(0, vl);\n\n    for (; i <= (n - vl); i += vl) {\n        vuint8m1_t vec = lv_s_bu(&s[i], vl);\n        vbool8_t is_upper = vmge_vx_u8m1_b8(vec, v_lower_bound, vl) & vmle_vx_u8m1_b8(vec, v_upper_bound, vl);\n        vuint8m1_t filtered = vand_vv_u8m1(vec, is_upper, vl);\n        vuint8m1_t partial_sums = vredsum_vs_u8m1_u64(filtered, v_zero, v_zero, vl);\n        sum += (int)vget_v_u64(partial_sums, 0);\n    }\n\n    // Handle remaining elements\n    if (i < n) {\n        vl = vsetvl_e8m1(n - i);\n        vuint8m1_t vec = lv_s_bu(&s[i], vl);\n        vbool8_t is_upper = vmge_vx_u8m1_b8(vec, v_lower_bound, vl) & vmle_vx_u8m1_b8(vec, v_upper_bound, vl);\n        vuint8m1_t filtered = vand_vv_u8m1(vec, is_upper, vl);\n        vuint8m1_t partial_sums = vredsum_vs_u8m1_u64(filtered, v_zero, v_zero, vl);\n        sum += (int)vget_v_u64(partial_sums, 0);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nint digitSum_simd(std::string s){\n    int sum = 0;\n    size_t n = s.size();\n    size_t i = 0;\n\n    size_t vl = vsetvl_e8m1(n);\n    vuint8m1_t vzero = vmv_v_x_i8m1(0, vl);\n    vuint8m1_t vupper = vmv_v_x_i8m1('A', vl);\n    vuint8m1_t vlower = vmv_v_x_i8m1('Z', vl);\n\n    for (; i <= (n - vl); i += vl) {\n        vuint8m1_t vdata = lv_s_b(&s[i], vl);\n        vbool8_t is_upper = vmge_vx_u8m1_b8(vdata, 'A', vl) & vmle_vx_u8m1_b8(vdata, 'Z', vl);\n        vuint8m1_t vsum = vmul_vx_u8m1(vdata, is_upper, vl);\n        vuint32m1_t vredsum =vredu_sum_vs_u8m1_u32m1(vsum, vmv_v_x_i32m1(0, vl), vl);\n        sum += vmv_x_s_i32m1_i32(vredsum);\n    }\n\n    for (; i < n; ++i) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            sum += static_cast<unsigned char>(s[i]);\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_94_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> pluck_simd(std::vector<int> arr){\n    if (arr.empty()) return {};\n\n    size_t arr_size = arr.size();\n    size_t vl = arr_size;\n\n    // Initialize vectors for the smallest even value and its index\n    int smallest_even = INT32_MAX;\n    int smallest_index = -1;\n\n    size_t block_size = 64; // Assume a reasonable block size for vectorization\n    for(size_t i = 0; i < arr_size; i += block_size){\n        size_t current_vl = std::min(block_size, arr_size - i);\n\n        vint32m1_t vec = vmv_v_x_i32m1(0, vl);\n        vec = vle32_v_i32m1(arr.data() + i, vl);\n\n        vbool32_t is_even = vmseq_vv_i32m1_b32(vec, vmul_vx_i32m1(vec, 2, vl) >> 1, vl);\n        vint32m1_t even_values = vmfclass_v_i32m1(vec, 0x0, vl);\n        even_values = vmul_vx_i32m1(even_values, is_even, vl);\n\n        int current_min = vminreduce_v_i32m1(even_values, vl);\n        int current_min_idx = i + vmfirst_m_b32(is_even, vl);\n\n        if(current_min < smallest_even || (current_min == smallest_even && current_min_idx < smallest_index)){\n            smallest_even = current_min;\n            smallest_index = current_min_idx;\n        }\n    }\n\n    if(smallest_even == INT32_MAX){\n        return {};\n    } else {\n        return {smallest_even, smallest_index};\n    }\n}\n```"}
{"task_id": "SimdBench_94_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> pluck_simd(std::vector<int> arr){\n    if (arr.empty()) return {};\n\n    size_t vl = arr.size();\n    size_t vlen = vl;\n    size_t sew = 32;\n    size_t lmul = 1;\n    size_t avl = vl * (sew / 8) * lmul;\n\n    vuint32m1_t vmask = vmv_v_x_u32m1(0, vl);\n    vuint32m1_t vmin_val = vmv_v_x_u32m1(0xFFFFFFFF, vl);\n    vuint32m1_t vmin_idx = vmv_v_x_u32m1(0xFFFFFFFF, vl);\n    vbool4_t valid_mask = vmsne_vx_b4(vmask, 0, vl);\n\n    for(size_t i = 0; i < vl; i += vsetvl_e32m1(1)){\n        size_t num_elements = vsetvl_e32m1(1);\n        vuint32m1_t vdata = vle32_v_u32m1(&arr[i], num_elements);\n        vbool4_t even_mask = vmsltu_vx_b4(vdata, 1, num_elements);\n        vbool4_t combined_mask = vand_vv_b4(even_mask, valid_mask, num_elements);\n        \n        vuint32m1_t current_min_val = vmin_val;\n        vuint32m1_t current_min_idx = vmin_idx;\n        \n        vuint32m1_t candidate_val = vdata;\n        vuint32m1_t candidate_idx = vmv_v_x_u32m1(i, num_elements);\n        \n        vmin_val = vfmerge_vvm_u32m1(current_min_val, candidate_val, combined_mask, num_elements);\n        vmin_idx = vfmerge_vvm_u32m1(current_min_idx, candidate_idx, combined_mask, num_elements);\n    }\n\n    uint32_t min_val = 0xFFFFFFFF;\n    uint32_t min_idx = 0xFFFFFFFF;\n\n    for(size_t i = 0; i < vl; ++i){\n        if(arr[i] % 2 == 0 && arr[i] < min_val){\n            min_val = arr[i];\n            min_idx = i;\n        }\n    }\n\n    if(min_val != 0xFFFFFFFF){\n        return {static_cast<int>(min_val), static_cast<int>(min_idx)};\n    } else {\n        return {};\n    }\n}\n```"}
{"task_id": "SimdBench_94_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> pluck_simd(std::vector<int> arr){\n    if (arr.empty()) return {};\n\n    size_t vl = arr.size();\n    size_t vlen = vl;\n    size_t sew = 32;\n    size_t lmul = 1;\n\n    uint32_t result_val = -1;\n    uint32_t result_idx = -1;\n\n    size_t i = 0;\n    while (i < vl) {\n        size_t block_size = std::min(vl - i, vlen);\n        vuint32m1_t vmask = vmv_v_x_u32m1(0, block_size);\n        vuint32m1_t vdata = vle32_v_u32m1((uint32_t*)&arr[i], block_size);\n\n        // Check for even numbers\n        vbool4_t is_even = vmseq_vv_b4m1(vdata, vmul_vx_u32m1(vdata, 2, block_size), block_size);\n\n        // Get the indices of the current block\n        vuint32m1_t vindices = vid_v_u32m1(block_size);\n\n        // Mask out odd numbers\n        vuint32m1_t veven_data = vand_vvm_u32m1(vdata, is_even, block_size);\n        vuint32m1_t veven_indices = vand_vvm_u32m1(vindices, is_even, block_size);\n\n        // Find minimum value and index among even numbers\n        uint32_t min_val = -1;\n        uint32_t min_idx = -1;\n        bool found = false;\n\n        for (size_t j = 0; j < block_size; ++j) {\n            if (vget_vi_u32m1(veven_data, j) != 0 && (min_val == -1 || vget_vi_u32m1(veven_data, j) < min_val)) {\n                min_val = vget_vi_u32m1(veven_data, j);\n                min_idx = vget_vi_u32m1(veven_indices, j) + i;\n                found = true;\n            }\n        }\n\n        if (found && (result_val == -1 || min_val < result_val || (min_val == result_val && min_idx < result_idx))) {\n            result_val = min_val;\n            result_idx = min_idx;\n        }\n\n        i += block_size;\n    }\n\n    if (result_val == -1) return {};\n    return {static_cast<int>(result_val), static_cast<int>(result_idx)};\n}\n```"}
{"task_id": "SimdBench_94_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> pluck_simd(std::vector<int> arr){\n    if (arr.empty()) return {};\n\n    size_t arr_size = arr.size();\n    size_t vl = vsetvl_e32m1(arr_size);\n\n    // Initialize vectors for min value and index\n    vint32m1_t vmin = vmv_v_x_i32m1(INT32_MAX, vl);\n    vuint32m1_t imin = vmv_v_x_u32m1(arr_size, vl);\n\n    // Load array into vector\n    vint32m1_t v_arr = vle32_v_i32m1(arr.data(), vl);\n\n    // Create a mask for even numbers\n    vbool32_t is_even = vmseq_vv_i32_b32m1(v_arr, vmul_vx_i32m1(v_arr, 2, vl) >> 1, vl);\n\n    // Create an index vector\n    vuint32m1_t idx = vid_v_u32m1(vl);\n\n    // Filter even numbers\n    vint32m1_t veven = vmfqne_v_i32m1(v_arr, INT32_MAX, vl);\n    vuint32m1_t even_idx = vmfqne_v_u32m1(idx, arr_size, vl);\n\n    // Find minimum even value and its index\n    vmin = vmmin_vvm_i32m1(veven, vmin, is_even, vl);\n    imin = vmfmin_vvm_u32m1(even_idx, imin, is_even, vl);\n\n    // Extract scalar results\n    int min_val = vmv_x_s_i32m1_i32(vmin);\n    unsigned min_idx = vmv_x_s_u32m1_u32(imin);\n\n    // Check if valid even number was found\n    if (min_val == INT32_MAX) return {};\n\n    return {min_val, static_cast<int>(min_idx)};\n}\n```"}
{"task_id": "SimdBench_94_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> pluck_simd(std::vector<int> arr){\n    if (arr.empty()) return {};\n\n    size_t arr_size = arr.size();\n    size_t vl = vsetvl_e32m1(arr_size);\n\n    // Initialize vectors for min value and index\n    vint32m1_t vmin_val = vmv_v_x_i32m1(INT32_MAX, vl);\n    vuint32m1_t vmin_idx = vmv_v_x_u32m1(arr_size, vl);\n\n    // Load input array into vector\n    vint32m1_t v_arr = vle32_v_i32m1(arr.data(), vl);\n\n    // Create a mask for even numbers\n    vbool32_t is_even = vmseq_vx_i32m1_b32(v_arr, 0, vl);\n\n    // Initialize result variables\n    int min_val = INT32_MAX;\n    int min_idx = -1;\n\n    for (size_t i = 0; i < arr_size; i += vl) {\n        size_t sub_vl = std::min(vl, arr_size - i);\n\n        // Load current segment of array\n        vint32m1_t v_curr = vle32_v_i32m1(&arr[i], sub_vl);\n\n        // Check for even numbers\n        vbool32_t v_is_even = vmseq_vx_i32m1_b32(v_curr, 0, sub_vl);\n\n        // Get indices\n        vuint32m1_t v_indices = vid_v_u32m1(sub_vl);\n\n        // Mask out odd numbers\n        vint32m1_t v_even = vmfclass_v_i32m1(v_curr, 0x02, sub_vl); // Extract even numbers\n\n        // Find minimum even value and its index\n        vint32m1_t v_min_val = vmredmin_vs_i32m1_i32m1(v_even, vmin_val, sub_vl);\n        vuint32m1_t v_min_idx = vmfirst_m_u32m1(vmfeq_vv_i32m1_b32(v_even, v_min_val, sub_vl), vmin_idx, sub_vl);\n\n        // Update scalar min value and index\n        int curr_min_val = vmv_x_s_i32m1_i32(v_min_val);\n        if (curr_min_val < min_val) {\n            min_val = curr_min_val;\n            min_idx = vmv_x_s_u32m1_u32(v_min_idx);\n        }\n    }\n\n    if (min_idx == -1) return {};\n    return {min_val, min_idx};\n}\n```"}
{"task_id": "SimdBench_95_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst){\n    if (lst.empty()) return -1;\n\n    int max_val = *std::max_element(lst.begin(), lst.end());\n    std::vector<int> freq(max_val + 2, 0);\n\n    size_t vl = vsetvl_e32m1(lst.size());\n    vuint32m1_t vzero = vmv_v_x_u32m1(0, vl);\n\n    for(size_t i = 0; i < lst.size(); i += vl){\n        size_t subvl = vsetvl_e32m1(std::min(vl, (size_t)(lst.size() - i)));\n        vuint32m1_t vlst = vle32_v_u32m1((uint32_t*)&lst[i], subvl);\n        for(int j = 0; j <= max_val; ++j){\n            vuint32m1_t vcmp = vmseq_vx_u32m1_b1(vlst, j, subvl);\n            uint32_t count = (uint32_t)vpopc_vm_u32m1_b1(vcmp, vzero, subvl);\n            freq[j] += count;\n        }\n    }\n\n    int result = -1;\n    for(int k = 1; k <= max_val; ++k){\n        if(freq[k] >= k){\n            result = k;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_95_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst){\n    if (lst.empty()) return -1;\n\n    int max_val = *std::max_element(lst.begin(), lst.end());\n    std::vector<int> freq(max_val + 2, 0);\n\n    size_t vl = vsetvl_e32m1(lst.size());\n    vuint32m1_t vmask = vmseq_vv_i32m1(vle32_v_u32m1(lst.data(), vl), vle32_v_u32m1(lst.data(), vl), vl);\n\n    for(auto num : lst) {\n        if(num > 0 && num <= max_val){\n            freq[num]++;\n        }\n    }\n\n    int result = -1;\n    for(int i = 1; i <= max_val; ++i){\n        if(freq[i] >= i){\n            result = i;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_95_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst){\n    int max_val = *std::max_element(lst.begin(), lst.end());\n    size_t vl = vsetvl_e32m1(max_val + 1);\n    uint32_t* freq = (uint32_t*) calloc(max_val + 1, sizeof(uint32_t));\n    \n    for(size_t i = 0; i < lst.size(); i += vl){\n        size_t sub_vl = vsetvl_e32m1(std::min<size_t>(vl, lst.size() - i));\n        vuint32m1_t vmasked_indices = vle32_v_u32m1((uint32_t*)&lst[i], sub_vl);\n        for(size_t j = 0; j < sub_vl; ++j){\n            freq[vget_v_u32m1(vmasked_indices, j)]++;\n        }\n    }\n\n    int result = -1;\n    vl = vsetvl_e32m1(max_val + 1);\n    vuint32m1_t vindices = vid_v_u32m1(vl);\n    vuint32m1_t vfrequencies = vle32_v_u32m1((uint32_t*)freq, vl);\n    for(int i = 1; i <= max_val; ++i){\n        if(freq[i] >= i && i > result){\n            result = i;\n        }\n    }\n    free(freq);\n    return result;\n}\n```"}
{"task_id": "SimdBench_95_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst){\n    if (lst.empty()) return -1;\n\n    int max_val = *std::max_element(lst.begin(), lst.end());\n    std::vector<int> freq(max_val + 1, 0);\n\n    size_t vl = vsetvl_e32m1(lst.size());\n    vuint32m1_t vmask = vmv_v_x_u32m1(0, vl);\n    vuint32m1_t vone = vmv_v_x_u32m1(1, vl);\n\n    for(size_t i = 0; i < lst.size(); i += vl){\n        size_t subvl = vsetvl_e32m1(std::min(vl, (size_t)(lst.size() - i)));\n        vuint32m1_t vlst = vle32_v_u32m1((uint32_t*)&lst[i], subvl);\n        for(int j = 0; j <= max_val; ++j){\n            vuint32m1_t vcmp = vmseq_vx_u32m1_b1(vlst, j, subvl);\n            int count = (int)vpopc_m_u32m1_b1(vmask, vcmp, subvl);\n            freq[j] += count;\n        }\n    }\n\n    int result = -1;\n    for(int i = max_val; i > 0; --i){\n        if(freq[i] >= i){\n            result = i;\n            break;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_95_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst){\n    if (lst.empty()) return -1;\n\n    int max_val = *std::max_element(lst.begin(), lst.end());\n    std::vector<int> freq(max_val + 2, 0);\n\n    size_t vl = vsetvl_e32m1(lst.size());\n    vuint32m1_t vmask = vmv_v_x_u32m1(0, vl);\n    vuint32m1_t vone = vmv_v_x_u32m1(1, vl);\n\n    for(size_t i = 0; i < lst.size(); i += vl){\n        size_t subvl = vsetvl_e32m1(std::min(vl, (size_t)(lst.size() - i)));\n        vuint32m1_t vdata = vle32_v_u32m1((uint32_t*)&lst[i], subvl);\n        for(int j = 0; j < subvl; ++j){\n            uint32_t val = vgetelem_u32(vdata, j);\n            if(val > 0 && val <= max_val){\n                freq[val]++;\n            }\n        }\n    }\n\n    int result = -1;\n    for(int i = 1; i <= max_val; ++i){\n        if(freq[i] >= i){\n            result = i;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_96_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    size_t n = q.size();\n    if (n == 0) return false;\n\n    // Check if the vector is a palindrome using RVV\n    bool is_palindrome = true;\n    size_t vl = vsetvl_e32m1(n);\n    for(size_t i = 0; i < (n + vl - 1) / vl; ++i){\n        size_t l = std::min(vl * (i + 1), n) - vl * i;\n        vint32m1_t vec_a = vle32_v_i32m1(&q[vl * i], l);\n        vint32m1_t vec_b = vle32_v_i32m1(&q[n - vl * (i + 1)], l);\n        vbool4_t cmp = vmseq_vv_i32m1_b4(vec_a, vec_b, l);\n        if (!vmandnot_m_b4(vmop_eq_b4(), vmfirst_b4(l), cmp)) {\n            is_palindrome = false;\n            break;\n        }\n    }\n    if (!is_palindrome) return false;\n\n    // Calculate the sum of elements using RVV\n    int sum = 0;\n    size_t vl_sum = vsetvl_e32m1(n);\n    vint32m1_t vsum = vmv_v_x_i32m1(0, vl_sum);\n    for(size_t i = 0; i < (n + vl_sum - 1) / vl_sum; ++i){\n        size_t l = std::min(vl_sum * (i + 1), n) - vl_sum * i;\n        vint32m1_t vec = vle32_v_i32m1(&q[vl_sum * i], l);\n        vsum = vredsum_vs_i32m1_i32m1(vec, vsum, l);\n    }\n    sum = vmv_x_s_i32m1_i32(vsum);\n\n    return sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nbool will_it_fly_simd(std::vector<int> q, int w){\n    size_t n = q.size();\n    if (n == 0) return false;\n\n    // Check if the vector is a palindrome\n    bool is_palindrome = true;\n    {\n        size_t vl = vsetvl_e32m1(n);\n        vint32m1_t v_q = vmv_v_x_i32m1(0, vl);\n        vint32m1_t v_q_rev = vmv_v_x_i32m1(0, vl);\n\n        for(size_t i = 0; i < n; ++i){\n            v_q = vle32_v_i32m1(&q[i], vl);\n            v_q_rev = vle32_v_i32m1(&q[n - i - 1], vl);\n            v_q = vmseq_vv_i32m1_b1(v_q, v_q_rev, vl);\n        }\n\n        int result = 0;\n        for(size_t i = 0; i < n; ++i){\n            result |= vmv_x_s_i32m1_i32(v_q);\n        }\n        is_palindrome = (result == 0xFFFFFFFF);\n    }\n\n    if (!is_palindrome) return false;\n\n    // Calculate the sum of elements\n    int sum = 0;\n    {\n        size_t vl = vsetvl_e32m1(n);\n        vint32m1_t vsum = vmv_v_x_i32m1(0, vl);\n        vint32m1_t v_q_part;\n\n        for(size_t i = 0; i < n; i += vl){\n            size_t tmp_vl = vsetvl_e32m1(n - i);\n            v_q_part = vle32_v_i32m1(&q[i], tmp_vl);\n            vsum = vredsum_vs_i32m1_i32m1(vsum, v_q_part, vsum, tmp_vl);\n        }\n\n        sum = vmv_x_s_i32m1_i32(vsum);\n    }\n\n    return sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w){\n    size_t size = q.size();\n    if (size == 0) return false;\n\n    // Check if the vector is a palindrome using RVV\n    bool is_palindrome = true;\n    size_t vl = vsetvl_e32m1(size);\n    for(size_t i = 0; i < (size + 1)/2; ++i){\n        size_t chunk_size = std::min(vl, size - 2*i);\n        if(chunk_size == 0) break;\n\n        vint32m1_t vec_left = vle32_v_i32m1(&q[i], chunk_size);\n        vint32m1_t vec_right = vle32_v_i32m1(&q[size - i - 1], chunk_size);\n\n        vbool4_t cmp_result = vmne_vv_b4(vec_left, vec_right, chunk_size);\n        if (vimaskall_tobool(cmp_result)) {\n            is_palindrome = false;\n            break;\n        }\n    }\n\n    if(!is_palindrome) return false;\n\n    // Calculate the sum of elements using RVV\n    int sum = 0;\n    size_t i = 0;\n    for(; vl > 0 && i + vl <= size; i += vl){\n        vint32m1_t vec = vle32_v_i32m1(&q[i], vl);\n        vint32m1_t sum_vec = vmv_v_x_i32m1(0, vl);\n        sum_vec = vredsum_vs_i32m1_i32m1(sum_vec, vec, sum_vec, vl);\n        sum +=vredu_sum_i32m1_i32(sum_vec, vl);\n    }\n    for(; i < size; ++i){\n        sum += q[i];\n    }\n\n    return sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nbool will_it_fly_simd(std::vector<int> q, int w){\n    size_t n = q.size();\n    if (n == 0) return false;\n\n    // Check if the vector is a palindrome\n    bool is_palindrome = true;\n    size_t vl = vsetvl_e32m1(n);\n    int* q_data = q.data();\n\n    for(size_t i = 0; i < (n + 1) / 2; i += vl){\n        size_t sub_vl = std::min(vl, (size_t)(n - i));\n        vint32m1_t vec_left = vle32_v_i32m1(q_data + i, sub_vl);\n        vint32m1_t vec_right = vle32_v_i32m1(q_data + (n - i - sub_vl), sub_vl);\n        vbool4_t cmp_result = vmseq_vv_b4m1(vec_left, vec_right, sub_vl);\n        if(!vmandnot_m_b4m1(vmop_eq_b4m1(), cmp_result, sub_vl)){\n            is_palindrome = false;\n            break;\n        }\n    }\n\n    if(!is_palindrome) return false;\n\n    // Calculate the sum of elements\n    size_t vl_sum = vsetvl_e32m1(n);\n    vint32m1_t vsum = vmv_v_x_i32m1(0, vl_sum);\n    for(size_t i = 0; i < n; i += vl_sum){\n        size_t sub_vl = std::min(vl_sum, (size_t)(n - i));\n        vint32m1_t vec_load = vle32_v_i32m1(q_data + i, sub_vl);\n        vsum = vredsum_vs_i32m1_i32m1(vsum, vec_load, vsum, sub_vl);\n    }\n    int total_sum = vmv_x_s_i32m1_i32(vsum);\n\n    return total_sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nbool will_it_fly_simd(std::vector<int> q, int w){\n    size_t vl = q.size();\n    if(vl == 0) return false;\n\n    // Check if the vector is a palindrome\n    bool is_palindrome = true;\n    for(size_t i = 0; i < vl / 2; ++i){\n        if(q[i] != q[vl - i - 1]){\n            is_palindrome = false;\n            break;\n        }\n    }\n    if(!is_palindrome) return false;\n\n    // Calculate the sum using RVV intrinsics\n    int sum = 0;\n    size_t i = 0;\n    size_t chunk_size = vl;\n    __builtin_assume(chunk_size > 0);\n\n    const int *q_ptr = q.data();\n    size_t vlen = __riscv_vsetvl_e32m1(chunk_size);\n    vuint32m1_t vmask = __riscv_vmsltu_vx_u32m1(__riscv_vmv_v_x_u32m1(0, vlen), 0, vlen);\n    vuint32m1_t vsum = __riscv_vmv_v_x_u32m1(0, vlen);\n\n    for (; i + vlen <= chunk_size; i += vlen) {\n        vuint32m1_t vdata = __riscv_vle32_v_u32m1(&q_ptr[i], vlen);\n        vsum = __riscv_vadd_vv_u32m1(vsum, vdata, vlen);\n    }\n\n    int temp_sum = 0;\n    temp_sum = __riscv_vredsum_vs_u32m1_u32m1(temp_sum, vsum, vmask, vlen);\n\n    for (; i < chunk_size; i++) {\n        temp_sum += q_ptr[i];\n    }\n\n    sum = temp_sum;\n\n    return (sum <= w);\n}\n```"}
{"task_id": "SimdBench_97_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nint smallest_change_simd(std::vector<int> arr){\n    int n = arr.size();\n    int changes = 0;\n    size_t vl = vsetvl_e32m1(n);\n\n    for(int i = 0; i < n / 2; ){\n        // Load vector from start and end\n        vint32m1_t v_start = lv_int32_v(arr.data() + i, vl);\n        vint32m1_t v_end = lv_int32_v(arr.data() + (n - i - 1), vl);\n\n        // Compare vectors\n        vbool32_t mask = vmne_vv_i32m1_b32(v_start, v_end, vl);\n\n        // Count the number of differences\n        size_t diff_count = vmopop_m(mask, vl);\n\n        changes += diff_count;\n\n        i += vl;\n        vl = vsetvl_e32m1(std::min((size_t)(n / 2 - i), vl));\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr){\n    int n = arr.size();\n    int changes = 0;\n    size_t vl = vsetvl_e32m1(n);\n\n    for(int i = 0; i < n / 2; ){\n        // Load elements from the start and end of the array\n        vint32m1_t vstart = vle32_v_i32m1(&arr[i], vl);\n        vint32m1_t vend = vle32_v_i32m1(&arr[n - i - 1], vl);\n\n        // Compare elements\n        vbool32_t vmask = vmne_vv_i32m1_b32(vstart, vend, vl);\n\n        // Count the number of differences\n        size_t diff_count = vpopc_m_b32(vmask, vl);\n\n        changes += diff_count;\n\n        i += vl;\n        vl = vsetvl_e32m1(std::min((size_t)(n / 2 - i), vl));\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr){\n    int n = arr.size();\n    int changes = 0;\n    size_t vl = vsetvl_e32m1(n);\n\n    for(int i = 0; i < n / 2; ){\n        // Load elements from the start and end of the array\n        vint32m1_t vstart = lv_int32_v(arr.data() + i, vl);\n        vint32m1_t vend = lv_int32_v(arr.data() + (n - i - 1), vl);\n\n        // Compare elements\n        vbool4_t mask = vmne_vv_i32m1_b4(vstart, vend, vl);\n\n        // Count the number of differences\n        size_t diff_count = vm popc_m_u32(mask, vl);\n        changes += diff_count;\n\n        i += vl;\n        vl = vsetvl_e32m1(n - 2 * i);\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr){\n    int n = arr.size();\n    int changes = 0;\n    size_t vl = vsetvl_e32m1(n);\n\n    for(int i=0; i < n/2; ){\n        // Load vector from start and end\n        vint32m1_t v_start = vle32_v_i32m1(&arr[i], vl);\n        vint32m1_t v_end = vle32_v_i32m1(&arr[n - i - 1], vl);\n\n        // Compare vectors\n        vbool32_t mask = vmne_vv_i32m1_b32(v_start, v_end, vl);\n\n        // Count mismatches\n        size_t count = vpopc_m_b32(mask, vl);\n        changes += count;\n\n        i += vl;\n        vl = vsetvl_e32m1(std::min((size_t)(n / 2 - i), vl));\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr){\n    size_t n = arr.size();\n    int changes = 0;\n\n    if (n == 0) return 0;\n\n    size_t vl = vsetvl_e32m1(n);\n    const size_t half = n / 2;\n    for(size_t i = 0; i < half; i += vl){\n        size_t actual_vl = vsetvl_e32m1(half - i);\n\n        // Load vectors from the start and end of the array\n        vint32m1_t start_vec = vle32_v_i32m1(arr.data() + i, actual_vl);\n        vint32m1_t end_vec = vle32_v_i32m1(arr.data() + (n - i - 1), actual_vl);\n\n        // Compare elements at mirrored positions\n        vbool32_t mask = vmne_vv_i32m1_b32(start_vec, end_vec, actual_vl);\n\n        // Count mismatches in the mask\n        size_t mismatch_count = vm popc_m_b32(mask, actual_vl);\n        changes += mismatch_count;\n    }\n\n    return changes / 2;\n}\n```"}
{"task_id": "SimdBench_98_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    auto count_chars = [](const std::vector<std::string> &lst) -> size_t {\n        size_t total = 0;\n        for (const auto &str : lst) {\n            total += str.length();\n        }\n        return total;\n    };\n\n    size_t total1 = count_chars(lst1);\n    size_t total2 = count_chars(lst2);\n\n    if (total1 <= total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n#include <cstring>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    uint64_t total_chars1 = 0;\n    uint64_t total_chars2 = 0;\n\n    for (const auto& str : lst1) {\n        total_chars1 += str.length();\n    }\n\n    for (const auto& str : lst2) {\n        total_chars2 += str.length();\n    }\n\n    if (total_chars1 <= total_chars2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    size_t sum_len1 = 0;\n    size_t sum_len2 = 0;\n\n    // Calculate the total length of strings in lst1 using RVV\n    {\n        size_t vl = vsetvl_e8m1(lst1.size());\n        vuint8m1_t vmask = vmv_v_x_u8m1(1, vl);\n        vuint8m1_t vsum = vmv_v_x_u8m1(0, vl);\n\n        for (const auto& str : lst1) {\n            uint8_t len = str.length();\n            vsum = vadd_vx_u8m1(vsum, len, vl);\n        }\n\n        size_t temp_sum = 0;\n        for (size_t i = 0; i < vl; ++i) {\n            temp_sum += vget_v_u8m1(vsum, i);\n        }\n        sum_len1 = temp_sum;\n    }\n\n    // Calculate the total length of strings in lst2 using RVV\n    {\n        size_t vl = vsetvl_e8m1(lst2.size());\n        vuint8m1_t vmask = vmv_v_x_u8m1(1, vl);\n        vuint8m1_t vsum = vmv_v_x_u8m1(0, vl);\n\n        for (const auto& str : lst2) {\n            uint8_t len = str.length();\n            vsum = vadd_vx_u8m1(vsum, len, vl);\n        }\n\n        size_t temp_sum = 0;\n        for (size_t i = 0; i < vl; ++i) {\n            temp_sum += vget_v_u8m1(vsum, i);\n        }\n        sum_len2 = temp_sum;\n    }\n\n    if (sum_len1 <= sum_len2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    size_t sum1 = 0;\n    size_t sum2 = 0;\n\n    // Calculate sum of lengths for lst1 using RVV\n    {\n        size_t vl = vsetvl_e8m1(lst1.size());\n        vuint8m1_t vmask = vmv_v_x_u8m1(0, vl);\n        vuint8m1_t vsum = vmv_v_x_u8m1(0, vl);\n\n        for (const auto& str : lst1) {\n            uint8_t len = str.length();\n            vmask = vmv_v_x_u8m1(len, vl);\n            vsum = vadd_vv_u8m1(vsum, vmask, vl);\n        }\n\n        uint8_t temp_sum = 0;\n        temp_sum = vredsum_vs_u8m1_u64(vsum, temp_sum, vl);\n        sum1 = temp_sum;\n    }\n\n    // Calculate sum of lengths for lst2 using RVV\n    {\n        size_t vl = vsetvl_e8m1(lst2.size());\n        vuint8m1_t vmask = vmv_v_x_u8m1(0, vl);\n        vuint8m1_t vsum = vmv_v_x_u8m1(0, vl);\n\n        for (const auto& str : lst2) {\n            uint8_t len = str.length();\n            vmask = vmv_v_x_u8m1(len, vl);\n            vsum = vadd_vv_u8m1(vsum, vmask, vl);\n        }\n\n        uint8_t temp_sum = 0;\n        temp_sum = vredsum_vs_u8m1_u64(vsum, temp_sum, vl);\n        sum2 = temp_sum;\n    }\n\n    if (sum1 <= sum2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    size_t sum1 = 0;\n    size_t sum2 = 0;\n\n    // Calculate sum of lengths for lst1 using RVV\n    {\n        size_t vlmax = vsetvl_e8m1(lst1.size());\n        vuint8m1_t vmask = vmv_v_x_u8m1(0, vlmax);\n        vuint8m1_t vsum = vmv_v_x_u8m1(0, vlmax);\n\n        for (size_t i = 0; i < lst1.size(); i += vlmax) {\n            size_t vl = vsetvl_e8m1(std::min(vlmax, static_cast<size_t>(lst1.size() - i)));\n            vmask = vmv_v_x_u8m1(0, vl);\n            vuint8m1_t vdata = vlstride_v_x_u8m1(i, 1, vl);\n            vsum = vredsum_vs_u8m1_u64m1(vdata, vsum, vmask, vl);\n        }\n\n        uint64_t temp_sum = vmv_x_s_u64m1_u64(vsum);\n        sum1 = static_cast<size_t>(temp_sum);\n    }\n\n    // Calculate sum of lengths for lst2 using RVV\n    {\n        size_t vlmax = vsetvl_e8m1(lst2.size());\n        vuint8m1_t vmask = vmv_v_x_u8m1(0, vlmax);\n        vuint8m1_t vsum = vmv_v_x_u8m1(0, vlmax);\n\n        for (size_t i = 0; i < lst2.size(); i += vlmax) {\n            size_t vl = vsetvl_e8m1(std::min(vlmax, static_cast<size_t>(lst2.size() - i)));\n            vmask = vmv_v_x_u8m1(0, vl);\n            vuint8m1_t vdata = vlstride_v_x_u8m1(i, 1, vl);\n            vsum = vredsum_vs_u8m1_u64m1(vdata, vsum, vmask, vl);\n        }\n\n        uint64_t temp_sum = vmv_x_s_u64m1_u64(vsum);\n        sum2 = static_cast<size_t>(temp_sum);\n    }\n\n    if (sum1 <= sum2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_99_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdbool.h>\n#include <stdint.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n){\n    if (n == 0) return x == 0;\n    if (n == 1) return x == 1;\n    if (x == 1) return true;\n\n    size_t vl = vsetvl_e64m1(1);\n    vuint64m1_t vn = vmv_v_x_u64m1(n, vl);\n    vuint64m1_t vx = vmv_v_x_u64m1(x, vl);\n    vuint64m1_t vone = vmv_v_x_u64m1(1, vl);\n\n    vuint64m1_t vpow = vone;\n    bool result = false;\n\n    for (size_t i = 0; i < 64; i++) {\n        vpow = vmul_vv_u64m1(vpow, vn, vl);\n        if (vmseq_vv_u64m1_b1(vpow, vx, vl)[0]) {\n            result = true;\n            break;\n        }\n        if (vmslt_vv_u64m1_b1(vx, vpow, vl)[0]) {\n            break;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_99_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n){\n    if (n == 0) return x == 0;\n    if (n == 1) return x == 1;\n    if (x == 1) return true;\n\n    uint64_t vlen = 1;\n    size_t vlmax = vsetvl_e64m1(vlen);\n    vuint64m1_t vn = vmv_v_x_u64(n, vlmax);\n    vuint64m1_t vx = vmv_v_x_u64(x, vlmax);\n    vuint64m1_t vone = vmv_v_x_u64(1, vlmax);\n\n    bool result = false;\n    for(int i = 0; i < 64 && !result; ++i){\n        vuint64m1_t vpow = vredmulush_v_u64m1(vn, vlmax);\n        result = vmseq_vu64_b1_mask(vx, vpow, vlmax)[0];\n        vn = vmul_vv_u64(vn, vn, vlmax);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_99_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <stdbool.h>\n#include <stdint.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n){\n    if (n == 0) return x == 0;\n    if (n == 1) return x == 1;\n    if (x == 1) return true;\n\n    uint64_t vl = vsetvl_e64m8(1);\n    vuint64m8_t vx = vmv_v_x_u64(x, vl);\n    vuint64m8_t vn = vmv_v_x_u64(n, vl);\n\n    vuint64m8_t vone = vmv_v_x_u64(1, vl);\n    bool result = false;\n\n    for (size_t i = 0; i < 64; ++i) {\n        if (vmseq_vu64_b1(vx, vone, vl).b0) {\n            result = true;\n            break;\n        }\n        if (vx > vone && vn > vone) {\n            vx = vmul_vv_u64(vx, vn, vl);\n        } else {\n            break;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_99_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdbool.h>\n#include <stdint.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n){\n    if (n == 0) return x == 0;\n    if (n == 1) return x == 1;\n    if (x == 1) return true;\n\n    size_t vl = vsetvl_e64m8(1);\n    vuint64m8_t vx = vmv_v_x_u64m8(x, vl);\n    vuint64m8_t vn = vmv_v_x_u64m8(n, vl);\n    vuint64m8_t vone = vmv_v_x_u64m8(1, vl);\n\n    bool result = false;\n    for (size_t i = 0; i < 64; ++i) {\n        vuint64m8_t vcmp = vx == vone;\n        if (vmsbf_m_b8(vcmp)) {\n            result = true;\n            break;\n        }\n        vx = vmul_vv_u64m8(vx, vn, vl);\n        if (vx > vx) { // Detect overflow\n            break;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_99_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <stdbool.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n){\n    if (n == 0) return x == 0;\n    if (n == 1) return x == 1;\n    if (x == 1) return true;\n\n    size_t vl = vsetvl_e64m1(1);\n    vuint64m1_t vn = vmv_v_x_u64m1(n, vl);\n    vuint64m1_t vx = vmv_v_x_u64m1(x, vl);\n    vuint64m1_t vone = vmv_v_x_u64m1(1, vl);\n\n    bool result = false;\n    vuint64m1_t current = vone;\n    while (true) {\n        vbool64_t check = vmseq_vv_b64m1(current, vx, vl);\n        if (vfirst_m_b64m1(check, vl)) {\n            result = true;\n            break;\n        }\n        if (vmsgeu_vv_b64m1(current, vx, vl)) {\n            break;\n        }\n        current = vmul_vv_u64m1(current, vn, vl);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_100_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cstring>\n\nint hex_key_simd(const std::string & num){\n    if (num.empty()) return 0;\n\n    const uint8_t prime_mask[16] = {0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0};\n    size_t vl = vsetvl_e8m1(num.length());\n    vuint8m1_t vcount = vmv_v_x_u8m1(0, vl);\n\n    for(size_t i = 0; i < num.length(); i += vl){\n        size_t subvl = vsetvl_e8m1(num.length() - i);\n        vuint8m1_t vdata = vle8_v_u8m1(reinterpret_cast<const uint8_t*>(&num[i]), subvl);\n        vdata = vsub_vx_u8m1(vdata, '0', subvl);\n        vdata = vfmerge_vfm_u8m1(vdata, vdata, vdata >= 10, subvl);\n        vdata = vfmerge_vfm_u8m1(vdata, vdata, vdata < 16, subvl);\n        vuint8m1_t vprime = vle8_v_u8m1(prime_mask, subvl);\n        vcount = vadd_vm_u8m1(vcount, vdata == vprime, subvl);\n    }\n\n    int result = 0;\n    for(size_t i = 0; i < num.length(); ++i){\n        result += (vget_v_u8m1_i(vcount, i) != 0);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_100_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cinttypes>\n\nint hex_key_simd(const std::string & num){\n    if (num.empty()) return 0;\n\n    const uint8_t prime_mask[16] = {0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0};\n    size_t vl = vsetvl_e8m1(num.length());\n    vuint8m1_t v_primes = vle8_v_u8m1((const uint8_t *)prime_mask, 16);\n\n    int count = 0;\n    for(size_t i = 0; i < num.length(); i += vl){\n        size_t subvl = vsetvl_e8m1(num.length() - i);\n        vuint8m1_t v_chars = vle8_v_u8m1(reinterpret_cast<const uint8_t*>(&num[i]), subvl);\n        vuint8m1_t v_hex_digits = vmseq_vx_u8m1(v_chars, 'A', subvl);\n        vuint8m1_t v_indices = vor_vx_u8m1(v_hex_digits, '0', subvl);\n        vuint8m1_t v_result = vslidedown_vx_u8m1(v_primes, v_indices, 10, subvl);\n        vbool8_t v_cmp = vmsne_vx_b8m1(v_result, 0, subvl);\n        count += vm popcount_b8m1(v_cmp, subvl);\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cinttypes>\n\nint hex_key_simd(const std::string & num){\n    if (num.empty()) return 0;\n\n    const uint8_t prime_mask[] = {0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1};\n    size_t vl = vsetvl_e8m1(num.length());\n    vuint8m1_t vcount = vmv_v_x_u8m1(0, vl);\n\n    for(size_t i = 0; i < num.length(); i += vl){\n        size_t actual vl = vsetvl_e8m1(num.length() - i);\n        vuint8m1_t vdata = vle8_v_u8m1(reinterpret_cast<const uint8_t*>(&num[i]), actual_vl);\n        vuint8m1_t vadjusted = vor_vx_u8m1(vdata, '0', actual_vl);\n        vbool8_t mask_digit = vle8_v_u8m1_b8(vadjusted, '9', actual_vl);\n        vadjusted = vsub_vx_u8m1(vadjusted, 'A' - 10, actual_vl);\n        vbool8_t mask_upper = vle8_v_u8m1(vadjusted, 'F' - 'A' + 10, actual_vl);\n        vbool8_t mask_valid = vor_vm_b8(mask_digit, mask_upper, actual_vl);\n        vadjusted = vand_vx_u8m1(vadjusted, 0xF, actual_vl);\n        vuint8m1_t vprime = vlsbu_v_u8m1(prime_mask, vadjusted, actual_vl);\n        vbool8_t mask_prime = vmsne_vx_b8(vprime, 0, actual_vl);\n        vbool8_t mask_final = vand_vm_b8(mask_valid, mask_prime, actual_vl);\n        vcount = vaddmv_f_x_u8m1(vcount, mask_final, 1, actual_vl);\n    }\n\n    int result = 0;\n    result = vmv_x_s_u8m1_u8(vredsum_vs_u8m1_u8(vcount, vmv_v_x_u8m1(0, vl), vl));\n    return result;\n}\n```"}
{"task_id": "SimdBench_100_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cstring>\n\nint hex_key_simd(const std::string & num){\n    if (num.empty()) return 0;\n\n    const uint8_t prime_mask[16] = {0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0};\n    size_t vl = vsetvl_e8m1(num.length());\n    vuint8m1_t v_primes = vmv_v_x_u8m1(0, vl);\n    vbool8_t mask = true;\n\n    for(size_t i = 0; i < num.length(); i += vl){\n        size_t chunk = num.length() - i;\n        size_t current_vl = vsetvl_e8m1((chunk > vl) ? vl : chunk);\n\n        // Load characters and convert to numeric values\n        uint8_t buffer[vl];\n        memset(buffer, 0, vl);\n        for(size_t j = 0; j < current_vl; ++j){\n            char c = num[i + j];\n            buffer[j] = (c <= '9') ? (c - '0') : (c - 'A' + 10);\n        }\n        vuint8m1_t v_chars = lv_uint8m1(buffer, current_vl);\n\n        // Apply prime mask\n        vuint8m1_t v_result = vslide1up_vx_u8m1(v_primes, v_chars, current_vl);\n        v_primes = vmv_v_v_u8m1(v_result, current_vl);\n    }\n\n    int count = 0;\n    for(size_t i = 0; i < num.length(); ++i){\n        uint8_t val = vmv_x_s_u8m1_u8(v_primes);\n        count += prime_mask[val];\n        v_primes = vsslide1up_vx_u8m1(v_primes, v_primes, 1, vl);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cstring>\n\nint hex_key_simd(const std::string & num){\n    if (num.empty()) return 0;\n\n    const uint8_t prime_mask[16] = {0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0};\n    size_t vl = vsetvl_e8m1(num.length());\n    vuint8m1_t vmask = vmv_v_x_u8m1(0, vl);\n    const uint8_t *data = reinterpret_cast<const uint8_t *>(num.c_str());\n\n    size_t count = 0;\n    for(size_t i = 0; i < num.length(); i += vl){\n        size_t sub_length = (i + vl > num.length()) ? (num.length() - i) : vl;\n        vuint8m1_t vdata = lvu_b(&data[i], sub_length);\n        vdata = vsubu_vx_u8m1(vdata, '0', vl); // Adjust ASCII to numeric\n        vdata = vfmerge_vfm_u8m1(vdata, vdata, vdata >= 10, vl); // Handle A-F\n        vdata = vfmerge_vfm_u8m1(vdata, vdata - ('A' - 10), vdata >= 10, vl);\n        vmask = vmv_v_x_u8m1(prime_mask, vl);\n        vbool8_t is_prime = vmseq_vv_u8m1_b8(vdata, vmask, vl);\n        count += vpopc_m_b8_i32(is_prime, vl);\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_101_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s){\n    if (s.length() < 3) return false;\n\n    size_t vl = vsetvl_e8m1(s.length() - 2);\n    uint8_t mask = 0b111;\n    vuint8m1_t v_mask = vmv_v_x_i8m1(mask, vl);\n\n    const uint8_t* str_ptr = reinterpret_cast<const uint8_t*>(s.data());\n    vuint8m1_t v_s0 = lvu8_v(str_ptr, vl);\n    vuint8m1_t v_s1 = lvu8_v(str_ptr + 1, vl);\n    vuint8m1_t v_s2 = lvu8_v(str_ptr + 2, vl);\n\n    vuint8m1_t eq_01 = vmseq_vv_u8m1(v_s0, v_s1, vl);\n    vuint8m1_t eq_12 = vmseq_vv_u8m1(v_s1, v_s2, vl);\n    vuint8m1_t eq_02 = vmseq_vv_u8m1(v_s0, v_s2, vl);\n\n    vuint8m1_t any_eq = vor_vv_u8m1(eq_01, eq_12, vl);\n    any_eq = vor_vv_u8m1(any_eq, eq_02, vl);\n\n    uint8_t result = vmfirst_m_b8(v_mask, any_eq, vl);\n    return result == 0;\n}\n```"}
{"task_id": "SimdBench_101_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cstring>\n\nbool is_happy_simd(const std::string & s){\n    if (s.length() < 3) return false;\n\n    size_t vl = vsetvl_e8m1(s.length() - 2);\n    uint8_t *str = (uint8_t *)s.c_str();\n\n    bool result = true;\n    size_t i = 0;\n    for (; i <= s.length() - 3; i += vl) {\n        vuint8m1_t vmask = vmseq_vx_i8m1(vlse8_v_i8m1(str + i, vl), str[i + 2], vl);\n        vmask = vor_vv_i8m1(vmask, vmseq_vx_i8m1(vlse8_v_i8m1(str + i + 1, vl), str[i + 2], vl), vl);\n        if (vfirst_m(vmask)) {\n            result = false;\n            break;\n        }\n    }\n\n    for (; i <= s.length() - 3; ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            result = false;\n            break;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_101_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s){\n    if (s.length() < 3) return false;\n\n    size_t vl = vsetvl_e8m1(s.length() - 2);\n    uint8_t mask = 0b111;\n    vuint8m1_t v_mask = vmv_v_x_i8m1(mask, vl);\n\n    bool happy = true;\n    for(size_t i = 0; i <= s.length() - 3 && happy; i += vl){\n        size_t sub vl = vsetvl_e8m1(std::min(vl, s.length() - i - 2));\n        vuint8m1_t v_s0 = vle8_v_u8m1((const uint8_t*)&s[i], sub_vl);\n        vuint8m1_t v_s1 = vle8_v_u8m1((const uint8_t*)&s[i+1], sub_vl);\n        vuint8m1_t v_s2 = vle8_v_u8m1((const uint8_t*)&s[i+2], sub_vl);\n\n        vuint8m1_t eq1 = veq_vv_u8m1_b8m1(v_s0, v_s1, sub_vl);\n        vuint8m1_t eq2 = veq_vv_u8m1_b8m1(v_s1, v_s2, sub_vl);\n        vuint8m1_t eq3 = veq_vv_u8m1_b8m1(v_s0, v_s2, sub_vl);\n\n        vuint8m1_t any_eq = vor_vv_u8m1(eq1, eq2, sub_vl);\n        any_eq = vor_vv_u8m1(any_eq, eq3, sub_vl);\n\n        int check = vmfirst_m_b8m1_i32(any_eq, sub_vl);\n        happy &= (check == -1);\n    }\n    return happy;\n}\n```"}
{"task_id": "SimdBench_101_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s){\n    if (s.length() < 3) return false;\n\n    size_t vl = vsetvl_e8m1(s.length() - 2);\n    uint8_t mask = 0;\n    bool happy = true;\n\n    for(size_t i = 0; i <= s.length() - 3; i += vl){\n        size_t vl_current = vsetvl_e8m1(std::min((size_t)vl, (size_t)(s.length() - 3 - i)));\n        vuint8m1_t vmask = vmv_v_x_u8m1(0, vl_current);\n        vuint8m1_t v0 = vle8_v_u8m1((const uint8_t *)&s[i], vl_current);\n        vuint8m1_t v1 = vle8_v_u8m1((const uint8_t *)&s[i+1], vl_current);\n        vuint8m1_t v2 = vle8_v_u8m1((const uint8_t *)&s[i+2], vl_current);\n\n        vmask = vor_vv_u8m1(vmask, veq_vx_u8m1(v0, v1, vl_current), vl_current);\n        vmask = vor_vv_u8m1(vmask, veq_vx_u8m1(v1, v2, vl_current), vl_current);\n        vmask = vor_vv_u8m1(vmask, veq_vx_u8m1(v2, v0, vl_current), vl_current);\n\n        uint8_t mmask = vmfirst_m_u8_b(vmask, vl_current);\n        if(mmask){\n            happy = false;\n            break;\n        }\n    }\n\n    return happy;\n}\n```"}
{"task_id": "SimdBench_101_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s){\n    if (s.length() < 3) return false;\n\n    size_t vl = vsetvl_e8m1(s.length() - 2);\n    const uint8_t* ptr = reinterpret_cast<const uint8_t*>(s.data());\n\n    bool happy = true;\n    for(size_t i = 0; i <= s.length() - 3; i += vl){\n        size_t sub_vl = vsetvl_e8m1(std::min(vl, (size_t)(s.length() - 3 - i + 1)));\n\n        vuint8m1_t vmask = vmv_v_x_u8m1(0xFF, sub_vl);\n        vuint8m1_t v0 = lv_uint8m1(ptr + i, sub_vl);\n        vuint8m1_t v1 = lv_uint8m1(ptr + i + 1, sub_vl);\n        vuint8m1_t v2 = lv_uint8m1(ptr + i + 2, sub_vl);\n\n        vuint8m1_t eq01 = veq_vv_u8m1_b8(v0, v1, vmask, sub_vl);\n        vuint8m1_t eq12 = veq_vv_u8m1_b8(v1, v2, vmask, sub_vl);\n        vuint8m1_t eq02 = veq_vv_u8m1_b8(v0, v2, vmask, sub_vl);\n\n        vuint8m1_t any_eq = vor_vv_u8m1(eq01, eq12, vmask, sub_vl);\n        any_eq = vor_vv_u8m1(any_eq, eq02, vmask, sub_vl);\n\n        int result = vmfirst_m_u8m1_b8(any_eq, sub_vl);\n        if(result != -1){\n            happy = false;\n            break;\n        }\n    }\n    return happy;\n}\n```"}
{"task_id": "SimdBench_102_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n\nbool prime_length_simd(const std::string &str) {\n    size_t len = str.length();\n    if (len < 2) return false;\n    if (len == 2) return true;\n    if (len % 2 == 0) return false;\n\n    size_t limit = static_cast<size_t>(std::sqrt(len));\n    size_t vl = vsetvl_e64m1(limit);\n\n    vuint64m1_t v_idx = vid_v_u64m1(vl);\n    vbool64_t is_divisor = vmseq_vv_u64m1_b64(vremu_vx_u64m1(len, v_idx, vl), 0, vl);\n\n    size_t i = 3;\n    for (; i <= limit; i += vl) {\n        if (vfirst_m_b64(is_divisor)) return false;\n        v_idx = vadd_vx_u64m1(v_idx, vl, vl);\n        is_divisor = vmseq_vv_u64m1_b64(vremu_vx_u64m1(len, v_idx, vl), 0, vl);\n    }\n\n    for (; i <= limit; ++i) {\n        if (len % i == 0) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n\nbool is_prime(size_t n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (size_t i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length_simd(const std::string &str) {\n    size_t len = str.length();\n    if (len < 2) return false;\n\n    size_t limit = static_cast<size_t>(std::sqrt(len));\n    if (limit < 2) return true;\n\n    size_t vl = vsetvl_e8m1(limit);\n    uint8_t step = 1;\n    uint8_t factor = 2;\n\n    vuint8m1_t vfactor = vmv_v_x_u8m1(factor, vl);\n    vbool8_t result = vmseq_vu8_b8(vfactor, vfactor, vl);\n\n    for (size_t i = 2; i <= limit; ++i) {\n        vuint8m1_t vi = vmv_v_x_u8m1(static_cast<uint8_t>(i), vl);\n        vbool8_t is_factor = vmseq_vu8_b8(vi, vfactor, vl);\n        result = vor_vv_b8(result, is_factor, vl);\n        if (vmfirst_m_b8(result)) {\n            if (len % i == 0) return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n\nbool prime_length_simd(const std::string &str) {\n    size_t len = str.length();\n    if (len < 2) return false;\n    if (len == 2) return true;\n    if (len % 2 == 0) return false;\n\n    size_t limit = static_cast<size_t>(std::sqrt(len));\n    size_t vl = vsetvl_e64m1(limit);\n\n    vuint64m1_t v_idx = vid_v_u64m1(vl);\n    vbool64_t v_result = vmseq_vv_u64_b64m1(v_idx, v_idx, vl); // Initialize to true\n\n    for(size_t i = 3; i <= limit; i += 2){\n        vbool64_t v_cond = vmseq_vu64_b64m1(v_idx, i, vl);\n        v_result = vor_vv_b64m1(v_result, v_cond, vl);\n        uint64_t mask = vmfirst_m_b64(u64, v_result);\n        if(mask != 0 && ((len % i) == 0)) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n\nbool prime_length_simd(const std::string &str) {\n    size_t n = str.length();\n    if (n < 2) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n\n    size_t limit = static_cast<size_t>(std::sqrt(n));\n    size_t vl = vsetvl_e64m1(limit);\n\n    vuint64m1_t v_idx = vid_v_u64m1(vl);\n    vbool64_t v_mask = vmseq_vx_b64m1(v_idx, 0, vl);\n    vbool64_t v_result = vmfne_vv_b64m1(v_idx, 0, vl);\n\n    for (size_t i = 3; i <= limit; i += 2) {\n        vbool64_t v_divisible = vmuleq_vx_b64m1(n, i, vl);\n        v_result = vor_vv_b64m1(v_result, v_divisible, vl);\n    }\n\n    bool result = !vany_ne_b64_m_b64m1(v_result, v_mask, vl);\n    return result;\n}\n```"}
{"task_id": "SimdBench_102_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n\nbool prime_length_simd(const std::string &str) {\n    size_t len = str.length();\n    if (len < 2) return false;\n    if (len == 2) return true;\n    if (len % 2 == 0) return false;\n\n    size_t limit = static_cast<size_t>(std::sqrt(len));\n    size_t vl = vsetvl_e64m1(limit);\n\n    vuint64m1_t v_i = vid_v_u64m1(vl);\n    vuint64m1_t v_mod = vmremu_vx_u64m1(len, v_i, vl);\n    vbool64_t v_cmp = vmseq_vx_b64m1(v_mod, 0, vl);\n\n    bool result = true;\n    size_t i = 3;\n    size_t step = 2;\n    for (; i <= limit; i += step) {\n        vuint64m1_t v_idx = vmv_s_x_u64m1(i, vl);\n        vbool64_t v_cond = vmseq_vx_b64m1(v_idx, v_i, vl);\n        vbool64_t v_mask = vand_vv_b64m1(v_cmp, v_cond, vl);\n        result = !vmfirst_m_b64m1_b64(v_mask, vl);\n        if (!result) break;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_103_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <bitset>\n#include <string>\n\nstd::string solve_simd(uint64_t N){\n    uint64_t sum = 0;\n    if (N == 0) {\n        return \"0\";\n    }\n\n    size_t vl = vsetvl_e8m1(1);\n    vuint8m1_t v_zero = vmv_v_x_i8m1(0, vl);\n    vbool8_t mask = vmsne_vx_i8m1_b8(v_zero, 0, vl);\n\n    while (N > 0) {\n        uint64_t remainder = N % 10;\n        N /= 10;\n\n        vuint8m1_t v_remainder = vmv_v_x_i8m1(remainder, vl);\n        vuint8m1_t v_sum = vmv_v_x_i8m1(sum, vl);\n        v_sum = vadd_vx_i8m1(v_sum, remainder, vl);\n        sum = vmv_x_s_i8m1_i64(v_sum, vl);\n    }\n\n    std::string binary = std::bitset<64>(sum).to_string();\n    // Remove leading zeros\n    size_t first_one = binary.find_first_of('1');\n    if (first_one != std::string::npos) {\n        binary = binary.substr(first_one);\n    } else {\n        binary = \"0\";\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <bitset>\n\nstd::string solve_simd(uint64_t N){\n    uint64_t sum = 0;\n    if (N == 0) {\n        return \"0\";\n    }\n\n    size_t vl = vsetvl_e8m1(1);\n    vuint8m1_t v_zero = vmv_v_x_i8m1(0, vl);\n    vbool8_t mask = vmsne_vx_i8m1_b8(v_zero, 0, vl);\n\n    while (N > 0) {\n        uint64_t remainder = N % 10;\n        N /= 10;\n\n        vuint8m1_t v_remainder = vmv_v_x_i8m1((uint8_t)remainder, vl);\n        vuint8m1_t v_sum = vmv_v_x_i8m1((uint8_t)sum, vl);\n\n        v_sum = vadd_vv_i8m1(v_sum, v_remainder, vl, mask);\n        sum = (uint64_t)vget_v_i8m1_i8(v_sum, 0);\n    }\n\n    std::bitset<64> binary(sum);\n    std::string binary_str = binary.to_string();\n    // Remove leading zeros\n    size_t first_one = binary_str.find_first_of('1');\n    if(first_one != std::string::npos){\n        return binary_str.substr(first_one);\n    }\n    return \"0\";\n}\n```"}
{"task_id": "SimdBench_103_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <bitset>\n#include <string>\n\nstd::string solve_simd(uint64_t N){\n    uint32_t vl = vsetvl_e8m1(1);\n    vuint8m1_t vsum = vmv_v_x_u8m1(0, vl);\n    vuint8m1_t vtemp;\n\n    while (N > 0) {\n        uint64_t digits[2] = {N % 10, N / 10};\n        N /= 10;\n        vtemp = vmv_v_x_u8m1(digits[0], vl);\n        vsum = vadd_vx_u8m1(vsum, digits[0], vl);\n    }\n\n    uint8_t result = 0;\n    result = (uint8_t)vredsum_vs_u8m1_u8m1(vsum, vmv_v_x_u8m1(result, vl), vl);\n\n    std::string binary = std::bitset<8>(result).to_string();\n    // Remove leading zeros\n    size_t first_one = binary.find_first_of('1');\n    if (first_one != std::string::npos) {\n        binary = binary.substr(first_one);\n    } else {\n        binary = \"0\";\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <bitset>\n#include <string>\n\nstd::string solve_simd(uint64_t N){\n    uint8_t digits[20] = {0};\n    int count = 0;\n    while (N > 0) {\n        digits[count++] = N % 10;\n        N /= 10;\n    }\n\n    size_t vl = vsetvl_e8m1(count);\n    vuint8m1_t v_digits = vmv_v_x_u8m1(0, vl);\n    for(int i=0;i<count;i++) {\n        v_digits = vse_v_u8m1(&digits[i], v_digits, i, vl);\n    }\n\n    vuint8m1_t v_one = vmv_v_x_u8m1(1, vl);\n    vbool8_t mask = vmsltu_vx_b8m1(v_digits, 10, vl);\n    v_digits = vand_vx_u8m1(v_digits, 0xF, vl);\n    vuint32m4_t sum = (vuint32m4_t)vredu_sum_vs_u8m1_u32m4(v_digits, 0, vl);\n\n    uint32_t result = vmv_x_s_u32m4_f32(sum);\n    std::string binary = std::bitset<32>(result).to_string();\n    // Trim leading zeros\n    size_t first_one = binary.find_first_of('1');\n    if(first_one != std::string::npos){\n        binary = binary.substr(first_one);\n    } else {\n        binary = \"0\";\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <bitset>\n#include <string>\n\nstd::string solve_simd(uint64_t N){\n    uint64_t sum = 0;\n    const size_t vl = vsetvl_e8m1(8);\n    vuint8m1_t v_zero = vmv_v_x_i8m1(0, vl);\n    vuint8m1_t v_sum = v_zero;\n\n    while (N > 0) {\n        uint64_t digits[8];\n        for(int i=0;i<8;i++) {\n            digits[i] = N % 10;\n            N /= 10;\n        }\n        vuint8m1_t v_digits = vle8_v_u8m1((const uint8_t *)digits, vl);\n        v_sum = vadd_vx_u8m1(v_sum, 1, vl);\n        v_sum = vadd_vv_u8m1(v_sum, v_digits, vl);\n    }\n\n    uint8_t result[8];\n    vse8_v_u8m1(result, v_sum, vl);\n\n    sum = 0;\n    for(int i=0;i<8;i++) {\n        sum += result[i];\n    }\n\n    std::string binary_representation = std::bitset<64>(sum).to_string();\n    // Remove leading zeros\n    size_t first_one = binary_representation.find_first_of('1');\n    if (first_one != std::string::npos) {\n        return binary_representation.substr(first_one);\n    } else {\n        return \"0\";\n    }\n}\n```"}
{"task_id": "SimdBench_104_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst){\n    int result = 0;\n    size_t size = lst.size();\n    size_t vl = vsetvl_e32m1(size);\n    int *data = lst.data();\n\n    for (size_t i = 1; i < size; i += 2) {\n        size_t sub_vl = vsetvl_e32m1(size - i);\n        vbool32_t mask = vmsltu_vv_i32m1(true, vl);\n        vint32m1_t vdata = vle32_v_i32m1(data + i, sub_vl);\n        vint32m1_t veven = vmseq_vx_i32m1_b32m1(vdata, 0, sub_vl);\n        vint32m1_t vfiltered = vmadd_vv_i32m1(vdata, veven, 0, sub_vl);\n        result += vmv_s_x_int32m1(vredsum_vs_i32m1_i32m1(vfiltered, 0, sub_vl));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_104_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst){\n    int vl = vsetvl_e32m8(lst.size());\n    vuint32m8_t v_lst = vmv_v_x_u32m8(0, vl);\n    vbool4_t idx_mask = vmv_v_x_b4(0, vl);\n\n    for(int i=0;i<lst.size();i++){\n        if( (i%2 ==1) && (lst[i]%2 ==0) ){\n            uint32_t temp = lst[i];\n            v_lst = vle32_v_u32m8(&temp, vl);\n            idx_mask = vmsltu_vx_b4(v_lst, 0, vl);\n        }\n    }\n\n    vuint32m8_t sum_vec = vmv_v_x_u32m8(0, vl);\n    sum_vec = vredsum_vs_u32m8_u32m4_u32(sum_vec, v_lst, idx_mask, vl);\n\n    uint32_t result = vmv_x_s_u32m8_u32(sum_vec);\n    return result;\n}\n```"}
{"task_id": "SimdBench_104_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int result = 0;\n    size_t size = lst.size();\n    size_t vlmax = vsetvl_e32m1(size);\n\n    for (size_t i = 1; i < size; i += 2) {\n        size_t vl = vsetvl_e32m1(size - i);\n        vint32m1_t v_idx = vmv_v_x_i32m1(i, vl);\n        vbool32_t mask = vmsltu_b32m1(v_idx, size, vl);\n        vint32m1_t v_data = vle32_v_i32m1(&lst[0], vl);\n        v_data = vslideup_vx_i32m1(v_data, v_data, 1, vl);\n        vbool32_t even_mask = vmseq_b32m1(vfmod_v_f32m1((vfloat32m1_t)v_data, 2.0f, vl), 0.0f, vl);\n        vint32m1_t filtered = vm_and_vv_i32m1(v_data, even_mask, vl);\n        result += vredsum_vs_i32m1_i32(vmv_v_x_i32m1(0, vl), filtered, vl);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_104_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst){\n    int result = 0;\n    size_t size = lst.size();\n    size_t vlmax = vsetvl_e32m1(size);\n    int *data = lst.data();\n\n    for (size_t i = 1; i < size; i += 2) {\n        size_t vl = vsetvl_e32m1(size - i);\n        vuint32m1_t vmask = vmseq_vx_i32m1(i, vl);\n        vint32m1_t vdata = vle32_v_i32m1(data + i, vl);\n        vbool4_t veven = vmseq_vx_b4m1(vfmod_v_f32m1((float*)vdata, 2.0f, vl), 0.0f, vl);\n        vint32m1_t vsum = vredsum_vs_i32m1_i32(vmask & veven, vdata, result, vl);\n        result = vmv_x_s_i32m1_i32(vsum);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_104_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst){\n    int result = 0;\n    size_t size = lst.size();\n    size_t vl = vsetvl_e32m8(size);\n    vuint32m8_t v_indices = vmv_v_x_u32m8(0, vl);\n    vbool4_t mask = vmfALSE_b4(vl);\n\n    for(size_t i = 0; i < size; i += vl){\n        size_t sub_size = (size - i) > vl ? vl : (size - i);\n        vl = vsetvl_e32m8(sub_size);\n        v_indices = vmv_v_x_u32m8(i, vl);\n        vuint32m8_t v_data = vle32_v_u32m8((uint32_t*)&lst[i], vl);\n        vbool4_t is_odd_idx = vmsltu_vx_b4(v_indices, 1, vl);\n        vbool4_t is_even_elem = vmseq_vx_b4(v_data & 1, 0, vl);\n        mask = vmand_vv_b4(is_odd_idx, is_even_elem, vl);\n        vuint32m8_t masked_data = vmux_vvm_u32m8(v_data, mask, v_data, vl);\n        uint32_t sum = 0;\n        sum = vmv_x_s_u32m8_u32(vredsum_vs_u32m8_u32m8(masked_data, sum, vl));\n        result += sum;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s){\n    size_t vl = vsetvl_e8m1(s.length());\n    uint8_t rotation = 4; // Shift by 2 * 2 = 4 places\n    std::string result(s.length(), '\\0');\n    \n    for(size_t i = 0; i < s.length(); i += vl){\n        size_t current_vl = vsetvl_e8m1(std::min(vl, (size_t)(s.length() - i)));\n        vuint8m1_t vmask = vmv_v_x_u8(current_vl);\n        vuint8m1_t vin = vle8_v_u8m1((const uint8_t *)&s[i], current_vl);\n        vuint8m1_t vout = vfadd_vv_u8m1(vin, vmask, rotation, current_vl);\n        \n        // Wrap around if greater than 'z'\n        vuint8m1_t vmod = vmsub_vx_u8m1(vout, vmask, 'z' - 'a' + 1, current_vl);\n        vuint8m1_t vcond = vmfge_vx_u8m1(vout, vmask, 'z' + 1, current_vl);\n        vout = vfcnd_vv_u8m1(vout, vmod, vcond, current_vl);\n        \n        vse8_v_u8m1((uint8_t *)&result[i], vout, current_vl);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s){\n    size_t vl = vsetvl_e8m1(s.size());\n    uint8_t offset = 4; // Shift by 2 * 2 = 4\n    std::string result(s.size(), '\\0');\n    \n    for(size_t i = 0; i < s.size(); i += vl) {\n        size_t current_vl = vsetvl_e8m1(std::min(vl, (size_t)(s.size() - i)));\n        vuint8m1_t vs = vle8_v_u8m1((const uint8_t *)&s[i], current_vl);\n        vuint8m1_t vo = vmv_v_x_u8m1(offset, current_vl);\n        vuint8m1_t vr = vadd_vv_u8m1(vs, vo, current_vl);\n        \n        // Wrap around within 'a' to 'z'\n        vuint8m1_t va = vmv_v_x_u8m1('a', current_vl);\n        vuint8m1_t vz = vmv_v_x_u8m1('z', current_vl);\n        vuint8m1_t vc = vsub_vx_u8m1(vr, 'a', current_vl);\n        vc = vremu_vx_u8m1(vc, 26, current_vl);\n        vr = vadd_vx_u8m1(vc, 'a', current_vl);\n        vr = vfmerge_vxm_u8m1(vr, va, vmslt_vx_b1_m(vr, 'a', current_vl), current_vl);\n        vr = vfmerge_vxm_u8m1(vr, vz, vmsgt_vx_b1_m(vr, 'z', current_vl), current_vl);\n        \n        vse8_v_u8m1((uint8_t *)&result[i], vr, current_vl);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s){\n    size_t vl = vsetvl_e8m1(s.length());\n    uint8_t shift = 4; // 2 * 2 shift for alphabet rotation\n    uint8_t lower_a = 'a';\n    uint8_t lower_z = 'z';\n    uint8_t upper_a = 'A';\n    uint8_t upper_z = 'Z';\n\n    std::string result;\n    result.reserve(s.length());\n\n    for(size_t i = 0; i < s.length(); i += vl){\n        size_t current_vl = vsetvl_e8m1(std::min(vl, (size_t)(s.length() - i)));\n        vuint8m1_t vs = vle8_v_u8m1((const uint8_t *)&s[i], current_vl);\n        vuint8m1_t encrypted = vs + shift;\n\n        // Handle lowercase letters wrapping\n        vuint8m1_t mask_lower = vmge_vx_u8m1(vs, lower_a, current_vl) & vle_vx_u8m1(vs, lower_z, current_vl);\n        vuint8m1_t wrapped_lower = vmadd_vx_u8m1(encrypted, lower_a, current_vl) - (lower_z + 1 - shift);\n        encrypted = vmerge_vvm_u8m1(encrypted, wrapped_lower, mask_lower, current_vl);\n\n        // Handle uppercase letters wrapping\n        vuint8m1_t mask_upper = vmge_vx_u8m1(vs, upper_a, current_vl) & vle_vx_u8m1(vs, upper_z, current_vl);\n        vuint8m1_t wrapped_upper = vmadd_vx_u8m1(encrypted, upper_a, current_vl) - (upper_z + 1 - shift);\n        encrypted = vmerge_vvm_u8m1(encrypted, wrapped_upper, mask_upper, current_vl);\n\n        // Store the results\n        uint8_t buffer[current_vl];\n        vse8_v_u8m1(buffer, encrypted, current_vl);\n        result.append((char *)buffer, current_vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s){\n    const uint8_t shift = 4; // 2 * 2\n    const uint8_t mask = 0x1F;\n    const uint8_t base_lower = 'a';\n    const uint8_t base_upper = 'A';\n    const uint8_t alphabet_size = 26;\n\n    size_t vl = vsetvl_e8m1(s.size());\n    vuint8m1_t vmask = vmv_v_x_u8m1(0, vl);\n    vuint8m1_t vshift = vmv_v_x_u8m1(shift, vl);\n    vuint8m1_t valphabet_size = vmv_v_x_u8m1(alphabet_size, vl);\n    vuint8m1_t vbase_lower = vmv_v_x_u8m1(base_lower, vl);\n    vuint8m1_t vbase_upper = vmv_v_x_u8m1(base_upper, vl);\n    vuint8m1_t vzero = vmv_v_x_u8m1(0, vl);\n\n    std::string result;\n    result.reserve(s.size());\n\n    for(size_t i = 0; i < s.size(); i += vl){\n        size_t sub vl = vsetvl_e8m1(std::min(vl, (size_t)(s.size() - i)));\n        vuint8m1_t vdata = lv_uint8m1(&s[i], sub_vl);\n        vuint8m1_t vis_lower = vmsltu_vx_u8m1_b1(vdata, 'a' + 26, sub_vl);\n        vuint8m1_t vis_upper = vmsltu_vx_u8m1_b1(vdata, 'A' + 26, sub_vl);\n        vuint8m1_t vlower = vand_vx_u8m1(vdata, vmask, sub_vl);\n        vuint8m1_t vupper = vor_vv_u8m1(vlower, vshift, sub_vl);\n        vuint8m1_t vwrap = vsubu_wv_u8m1(valphabet_size, vupper, sub_vl);\n        vuint8m1_t vresult_lower = vaddu_vv_u8m1(vbase_lower, vwrap, sub_vl);\n        vuint8m1_t vresult_upper = vaddu_vv_u8m1(vbase_upper, vwrap, sub_vl);\n        vuint8m1_t vresult = vmerge_vvm_u8m1(vresult_lower, vresult_upper, vis_upper, sub_vl);\n        vresult = vmerge_vvm_u8m1(vresult, vdata, vis_lower, sub_vl);\n        sv_uint8m1(&result[i], vresult, sub_vl);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s){\n    size_t vl = vsetvl_e8m1(s.length());\n    uint8_t rotation = 4; // Shift by 2 * 2 = 4 places\n    std::string result(s.length(), '\\0');\n    \n    const uint8_t* src = reinterpret_cast<const uint8_t*>(s.data());\n    uint8_t* dst = reinterpret_cast<uint8_t*>(&result[0]);\n    \n    vuint8m1_t vmask = vmv_v_x_u8m1(0, vl);\n    vuint8m1_t vrotation = vmv_v_x_u8m1(rotation, vl);\n    vuint8m1_t vin = vle8_v_u8m1(src, vl);\n    \n    // Perform the rotation with wrap-around for 'a' to 'z'\n    vuint8m1_t vout = vfaddu_vv_u8m1(vin, vrotation, vl);\n    vout = vor_vx_u8m1(vout, vmv_v_x_u8m1(0, vl), vl); // Ensure no negative values\n    \n    // Wrap around if greater than 'z'\n    vuint8m1_t vlower_bound = vmv_v_x_u8m1('a', vl);\n    vuint8m1_t vupper_bound = vmv_v_x_u8m1('z', vl);\n    vuint8m1_t vwrap = vsubu_vx_u8m1(vout, vupper_bound, vl);\n    vwrap = vand_vx_u8m1(vwrap, vmv_v_x_u8m1(1, vl), vl); // Check if overflowed\n    vout = vsubu_vx_u8m1(vout, vmul_vx_u8m1(vwrap, vmv_v_x_u8m1(26, vl), vl), vl);\n    vout = vaddu_vx_u8m1(vout, vmul_vx_u8m1(vwrap, vlower_bound, vl), vl);\n    \n    // Store the result back\n    vse8_v_u8m1(dst, vout, vl);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_106_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message){\n    const uint8_t vowels[] = {'a','e','i','o','u','A','E','I','O','U'};\n    const uint8_t repl[] = {'c','g','k','q','w','C','G','K','Q','W'};\n    size_t vl = vsetvl_e8m1(message.length());\n    std::string result;\n    result.reserve(message.length());\n\n    for(size_t i = 0; i < message.length(); i += vl){\n        size_t subvl = vsetvl_e8m1(std::min(vl, (size_t)(message.length() - i)));\n        vuint8m1_t vmask = vmseq_vx_i8m1(vle8_v_i8m1((const uint8_t *)(message.c_str()+i), subvl), 0, subvl);\n        vuint8m1_t vmsg = vle8_v_u8m1((const uint8_t *)(message.c_str()+i), subvl);\n\n        // Swap case\n        vbool8_t is_lower = vsge_vx_i8m1_b8(vmsg, 'a', subvl) & vsle_vx_i8m1_b8(vmsg, 'z', subvl);\n        vbool8_t is_upper = vsge_vx_i8m1_b8(vmsg, 'A', subvl) & vsle_vx_i8m1_b8(vmsg, 'Z', subvl);\n        vmsg = vsub_vx_i8m1(vmsg, ('a'-'A'), subvl, is_lower);\n        vmsg = vadd_vx_i8m1(vmsg, ('a'-'A'), subvl, is_upper);\n\n        // Replace vowels\n        for(int j=0; j<10; ++j){\n            vbool8_t is_vowel = vmseq_vx_i8m1_b8(vmsg, vowels[j], subvl);\n            vmsg = vmerge_vx_i8m1(vmsg, repl[j], is_vowel, subvl);\n        }\n\n        // Store results\n        char buffer[vl];\n        vse8_v_u8m1((uint8_t *)buffer, vmsg, subvl);\n        result.append(buffer, subvl);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message){\n    const uint8_t vowels[] = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n    const uint8_t repl_vowels[] = {'c', 'g', 'k', 'q', 'w', 'C', 'G', 'K', 'Q', 'W'};\n    \n    size_t msg_len = message.size();\n    std::string result;\n    result.resize(msg_len);\n\n    size_t vl = vsetvl_e8m1(msg_len);\n    uint8_t *msg_ptr = (uint8_t *)message.c_str();\n    uint8_t *res_ptr = (uint8_t *)result.data();\n\n    for(size_t i = 0; i < msg_len; i += vl) {\n        vl = vsetvl_e8m1(msg_len - i);\n        vuint8m1_t vmask = vmseq_vx_i8m1(msg_ptr + i, 0, vl); // Mask for non-letters\n        vuint8m1_t vmsg = lv_u8_v(msg_ptr + i, vl);\n\n        // Swap case\n        vbool8_t is_lower = vsge_vx_i8m1_b8(vmsg, 'a', vl) & vsle_vx_i8m1_b8(vmsg, 'z', vl);\n        vbool8_t is_upper = vsge_vx_i8m1_b8(vmsg, 'A', vl) & vsle_vx_i8m1_b8(vmsg, 'Z', vl);\n        vmsg = vmerge_vvm_i8m1(vmsg, vsrl_vx_i8m1(vmsg, 32, vl), is_lower, vl);\n        vmsg = vmerge_vvm_i8m1(vmsg, vsll_vx_i8m1(vmsg, 32, vl), is_upper, vl);\n\n        // Replace vowels\n        for(int j = 0; j < 10; ++j){\n            vbool8_t is_vowel = vmseq_vx_i8m1_b8(vmsg, vowels[j], vl);\n            vmsg = vmerge_vxm_i8m1(vmsg, repl_vowels[j], is_vowel, vl);\n        }\n\n        sv_u8_v(res_ptr + i, vmsg, vl);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message){\n    const uint8_t vowels[] = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n    const uint8_t replacements[] = {'c', 'g', 'k', 'q', 'w', 'C', 'G', 'K', 'Q', 'W'};\n    \n    size_t vl = vsetvl_e8m1(message.size());\n    vuint8m1_t vmask = vmseq_vx_i8m1(message.data(), 0, vl);\n    vuint8m1_t vmsg = vle8_v_u8m1((const uint8_t *)message.data(), vl);\n\n    // Swap case\n    vbool8_t is_lower = vmsle_vx_i8m1_b8(vmsg, 'a', vl) & vmsge_vx_i8m1_b8(vmsg, 'z', vl);\n    vbool8_t is_upper = vmsle_vx_i8m1_b8(vmsg, 'A', vl) & vmsge_vx_i8m1_b8(vmsg, 'Z', vl);\n    vmsg = vmERGE_vvm_i8m1(vmsg, vmsg ^ 0x20, is_lower | is_upper, vl);\n\n    // Replace vowels\n    for(size_t i = 0; i < sizeof(vowels); ++i){\n        vbool8_t is_vowel = vmseq_vx_i8m1_b8(vmsg, vowels[i], vl);\n        vmsg = vmERGE_vvm_i8m1(vmsg, vmsg ^ (vowels[i] ^ replacements[i]), is_vowel, vl);\n    }\n\n    std::string result(message.size(), '\\0');\n    vse8_v_u8m1((uint8_t *)result.data(), vmsg, vl);\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message){\n    const uint8_t vowels_lower[] = {'a','e','i','o','u'};\n    const uint8_t vowels_upper[] = {'A','E','I','O','U'};\n    const uint8_t replace_lower[] = {'c','g','k','q','w'};\n    const uint8_t replace_upper[] = {'C','G','K','Q','W'};\n    \n    size_t vl = vsetvl_e8m1(message.length());\n    vuint8m1_t vmask = vmseq_vx_i8m1(vl, 0);\n    vuint8m1_t vresult = vle8_v_u8m1(reinterpret_cast<const uint8_t *>(message.c_str()), vl);\n\n    for(int i=0;i<5;i++){\n        vuint8m1_t vvowels = vmv_x_s_u8m1_u8((i<5)?vowels_lower[i]:0);\n        vmask = vmseq_vv_i8m1(vresult, vvowels, vl);\n        vresult = vmerge_vvm_u8m1(vresult, vmv_x_s_u8m1_u8(replace_lower[i]), vmask, vl);\n\n        vvowels = vmv_x_s_u8m1_u8((i<5)?vowels_upper[i]:0);\n        vmask = vmseq_vv_i8m1(vresult, vvowels, vl);\n        vresult = vmerge_vvm_u8m1(vresult, vmv_x_s_u8m1_u8(replace_upper[i]), vmask, vl);\n    }\n\n    // Swap case\n    vuint8m1_t lower_mask = vmsle_vx_i8m1(vresult, 'a', vl);\n    vuint8m1_t upper_mask = vmsgt_vx_i8m1(vresult, 'Z', vl);\n    vuint8m1_t case_mask = vor_vv_i8m1(lower_mask, upper_mask, vl);\n    vresult = vsub_vx_i8m1(vresult, ' ', vl);\n    vresult = vxor_vv_i8m1(vresult, case_mask, vl);\n    vresult = vadd_vx_i8m1(vresult, ' ', vl);\n\n    std::string result(message.length(), '\\0');\n    vse8_v_u8m1(reinterpret_cast<uint8_t *>(&result[0]), vresult, vl);\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message){\n    const uint8_t vowels[] = {'a','e','i','o','u','A','E','I','O','U'};\n    const uint8_t repl[] = {'c','g','k','q','w','C','G','K','Q','W'};\n    \n    size_t vl = vsetvl_e8m1(message.size());\n    vuint8m1_t vmask = vle8_v_u8m1((uint8_t*)message.c_str(), vl);\n    vuint8m1_t vres = vmask;\n\n    // Swap case\n    vres = vor_vx_u8m1(vres, 32, vl);\n    vres = vxor_vv_u8m1(vres, vmask, vl);\n\n    // Replace vowels\n    for(int i=0; i<10; ++i){\n        vbool8_t is_vowel = veq_vx_u8m1_b8(vmask, vowels[i], vl);\n        vres = vmerge_vvm_u8m1(vres, vfmv_x_w_u8m1(repl[i]), is_vowel, vl);\n    }\n\n    // Convert back to string\n    std::string result(message.size(), '\\0');\n    vse8_v_u8m1((uint8_t*)result.data(), vres, vl);\n    return result;\n}\n```"}
{"task_id": "SimdBench_107_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict){\n    if (dict.empty()) return false;\n\n    bool first_key_checked = false;\n    bool all_lower = false;\n    bool all_upper = false;\n\n    for (const auto& [key, value] : dict) {\n        const char* str = key.c_str();\n        size_t length = key.length();\n\n        if (length == 0) return false;\n\n        size_t vl = vsetvl_e8m1(length);\n        uint8_t is_lower = 0;\n        uint8_t is_upper = 0;\n\n        for (size_t i = 0; i < length; i += vl) {\n            vuint8m1_t v_str = lvu8_v((const uint8_t*)(str + i), vl);\n            vbool8_t v_is_lower_mask = vmge_vxu_b8m1(v_str, 'a', vl) & vmle_vxu_b8m1(v_str, 'z', vl);\n            vbool8_t v_is_upper_mask = vmge_vxu_b8m1(v_str, 'A', vl) & vmle_vxu_b8m1(v_str, 'Z', vl);\n\n            is_lower |= vmfirst_m_b8m1(v_is_lower_mask);\n            is_upper |= vmfirst_m_b8m1(v_is_upper_mask);\n        }\n\n        if (!first_key_checked) {\n            first_key_checked = true;\n            all_lower = is_lower && !is_upper;\n            all_upper = is_upper && !is_lower;\n        } else {\n            if ((is_lower && is_upper) || \n                (all_lower && is_upper) || \n                (all_upper && is_lower)) {\n                return false;\n            }\n        }\n    }\n\n    return first_key_checked && ((all_lower && !all_upper) || (all_upper && !all_lower));\n}\n```"}
{"task_id": "SimdBench_107_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict){\n    if (dict.empty()) return false;\n\n    auto it = dict.begin();\n    bool is_upper = true;\n    bool is_lower = true;\n\n    // Check the first key to determine initial case\n    const std::string& first_key = it->first;\n    size_t len = first_key.size();\n\n    if (len == 0) return false;\n\n    size_t vl = vsetvl_e8m1(len);\n    uint8_t mask_upper = 0;\n    uint8_t mask_lower = 0;\n\n    for (size_t i = 0; i < len; i += vl) {\n        vl = vsetvl_e8m1(len - i);\n        vuint8m1_t vmask = vwload_v_u8m1(first_key.data() + i, vl);\n        vuint8m1_t vA = vmask;\n        vuint8m1_t vZ = vmask;\n        vuint8m1_t v_a = vmask;\n        vuint8m1_t v_z = vmask;\n\n        vuint8m1_t cmp_A = vmseq_vx_u8m1_b1(vmask, 'A', vl);\n        vuint8m1_t cmp_Z = vmseq_vx_u8m1_b1(vmask, 'Z', vl);\n        vuint8m1_t cmp_a = vmseq_vx_u8m1_b1(vmask, 'a', vl);\n        vuint8m1_t cmp_z = vmseq_vx_u8m1_b1(vmask, 'z', vl);\n\n        vuint8m1_t in_range_upper = vmsltu_vx_u8m1_b1(vmask, 'Z' + 1, vl);\n        vuint8m1_t in_range_lower = vmsltu_vx_u8m1_b1(vmask, 'z' + 1, vl);\n\n        vuint8m1_t is_upper_char = vmand_vv_b1(cmp_A, in_range_upper, vl);\n        vuint8m1_t is_lower_char = vmand_vv_b1(cmp_a, in_range_lower, vl);\n\n        mask_upper |=vredu_or_b1(is_upper_char, vl);\n        mask_lower |=vredu_or_b1(is_lower_char, vl);\n    }\n\n    is_upper = (mask_upper == len);\n    is_lower = (mask_lower == len);\n\n    for (++it; it != dict.end(); ++it) {\n        const std::string& key = it->first;\n        len = key.size();\n        if (len == 0) return false;\n\n        uint8_t current_mask_upper = 0;\n        uint8_t current_mask_lower = 0;\n\n        for (size_t i = 0; i < len; i += vl) {\n            vl = vsetvl_e8m1(len - i);\n            vuint8m1_t vmask = vwload_v_u8m1(key.data() + i, vl);\n            vuint8m1_t vA = vmask;\n            vuint8m1_t vZ = vmask;\n            vuint8m1_t v_a = vmask;\n            vuint8m1_t v_z = vmask;\n\n            vuint8m1_t cmp_A = vmseq_vx_u8m1_b1(vmask, 'A', vl);\n            vuint8m1_t cmp_Z = vmseq_vx_u8m1_b1(vmask, 'Z', vl);\n            vuint8m1_t cmp_a = vmseq_vx_u8m1_b1(vmask, 'a', vl);\n            vuint8m1_t cmp_z = vmseq_vx_u8m1_b1(vmask, 'z', vl);\n\n            vuint8m1_t in_range_upper = vmsleu_vx_u8m1_b1(vmask, 'Z', vl);\n            vuint8m1_t in_range_lower = vmsleu_vx_u8m1_b1(vmask, 'z', vl);\n\n            vuint8m1_t is_upper_char = vmand_vv_b1(cmp_A, in_range_upper, vl);\n            vuint8m1_t is_lower_char = vmand_vv_b1(cmp_a, in_range_lower, vl);\n\n            current_mask_upper |=vredu_or_b1(is_upper_char, vl);\n            current_mask_lower |=vredu_or_b1(is_lower_char, vl);\n        }\n\n        if ((is_upper && current_mask_upper != len) || (is_lower && current_mask_lower != len)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_107_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict){\n    if (dict.empty()) return false;\n\n    bool first_key_checked = false;\n    bool all_lower = false;\n    bool all_upper = false;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        if (key.empty()) return false;\n\n        size_t key_len = key.length();\n        size_t i = 0;\n\n        bool is_lower = true;\n        bool is_upper = true;\n\n        while (i < key_len) {\n            size_t vl = vsetvl_e8m1(key_len - i);\n            vuint8m1_t vmask = vle8_v_u8m1(reinterpret_cast<const uint8_t*>(&key[i]), vl);\n\n            vbool8_t vis_lower = vmask >= vtrue_v_u8m1(97) & vmask <= vtrue_v_u8m1(122); // 'a' to 'z'\n            vbool8_t vis_upper = vmask >= vtrue_v_u8m1(65) & vmask <= vtrue_v_u8m1(90);   // 'A' to 'Z'\n\n            is_lower &= !vmsifbm_b8(vis_lower, vl);\n            is_upper &= !vmsifbm_b8(vis_upper, vl);\n\n            i += vl;\n        }\n\n        if (!first_key_checked) {\n            first_key_checked = true;\n            all_lower = is_lower;\n            all_upper = is_upper;\n            if (!all_lower && !all_upper) return false;\n        } else {\n            if (all_lower && !is_lower) return false;\n            if (all_upper && !is_upper) return false;\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict){\n    if (dict.empty()) return false;\n\n    bool first = true;\n    bool is_lower = false;\n    bool is_upper = false;\n\n    for (const auto& [key, value] : dict) {\n        size_t key_len = key.length();\n        if (key_len == 0) continue;\n\n        // Determine the case of the first character\n        if (first) {\n            if (std::islower(key[0])) {\n                is_lower = true;\n            } else if (std::isupper(key[0])) {\n                is_upper = true;\n            } else {\n                return false; // Non-alphabetic character\n            }\n            first = false;\n        }\n\n        // Process the key using RVV intrinsics\n        size_t vl = vsetvl_e8m1(key_len);\n        uint8_t mask = 0;\n        if (is_lower) {\n            vuint8m1_t vkey = lvu8_v(key.c_str(), vl);\n            vuint8m1_t vlower = vmv_v_x_u8m1(0, vl);\n            for (size_t i = 0; i < vl; ++i) {\n                vlower[i] = static_cast<uint8_t>('a') + (vkey[i] - static_cast<uint8_t>('A'));\n            }\n            vbool8m1_t vislower = vmge_vx_u8m1_b8(vkey, 'a', vl);\n            vbool8m1_t visalpha = vmle_vx_u8m1_b8(vkey, 'z', vl);\n            vbool8m1_t visvalid = vmand_mm(vislower, visalpha, vl);\n            mask = vmfirst_m_b8(visvalid, vl);\n        } else if (is_upper) {\n            vuint8m1_t vkey = lvu8_v(key.c_str(), vl);\n            vbool8m1_t visupper = vmge_vx_u8m1_b8(vkey, 'A', vl);\n            vbool8m1_t visalpha = vmle_vx_u8m1_b8(vkey, 'Z', vl);\n            vbool8m1_t visvalid = vmand_mm(visupper, visalpha, vl);\n            mask = vmfirst_m_b8(visvalid, vl);\n        }\n\n        if (mask != 0xFF) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_107_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict){\n    if (dict.empty()) return false;\n\n    bool first_key_checked = false;\n    bool all_lower = false;\n    bool all_upper = false;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        if (key.empty()) return false;\n\n        size_t key_len = key.length();\n        size_t i = 0;\n\n        bool is_lower = true;\n        bool is_upper = true;\n\n        // Determine vl\n        size_t vl = vsetvl_e8m1(key_len);\n\n        // Load key into vector\n        uint8_t key_data[key_len];\n        for (size_t j = 0; j < key_len; ++j) {\n            key_data[j] = static_cast<uint8_t>(key[j]);\n        }\n\n        vuint8m1_t vk = vle8_v_u8m1(key_data, vl);\n\n        // ASCII 'a' to 'z'\n        vuint8m1_t lower_min = vmv_v_x_u8m1('a', vl);\n        vuint8m1_t lower_max = vmv_v_x_u8m1('z', vl);\n\n        // ASCII 'A' to 'Z'\n        vuint8m1_t upper_min = vmv_v_x_u8m1('A', vl);\n        vuint8m1_t upper_max = vmv_v_x_u8m1('Z', vl);\n\n        // Check if each character is between 'a' and 'z'\n        vbool8_t is_lower_mask = vle_vx_u8m1_b8(lower_min, vk, vl) & vle_vx_u8m1_b8(vk, lower_max, vl);\n        is_lower = vill_v_b8(is_lower_mask, vl) == key_len;\n\n        // Check if each character is between 'A' and 'Z'\n        vbool8_t is_upper_mask = vle_vx_u8m1_b8(upper_min, vk, vl) & vle_vx_u8m1_b8(vk, upper_max, vl);\n        is_upper = vill_v_b8(is_upper_mask, vl) == key_len;\n\n        if (!first_key_checked) {\n            first_key_checked = true;\n            all_lower = is_lower;\n            all_upper = is_upper;\n        } else {\n            if (is_lower && all_upper) return false;\n            if (is_upper && all_lower) return false;\n            all_lower &= is_lower;\n            all_upper &= is_upper;\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_108_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> count_up_to_simd(int n){\n    std::vector<int> primes;\n    if (n <= 1) return primes;\n\n    int size = n - 1;\n    uint8_t *sieve = new uint8_t[size];\n    std::fill(sieve, sieve + size, 1);\n\n    size_t vl = vsetvl_e32m1(size);\n    vuint32m1_t v_idx = vmv_v_x_i32m1(0, vl);\n    vbool32_t v_true = vmv_v_x_b32m1(-1, vl);\n\n    for (int i = 2; i * i < n; ++i) {\n        if (sieve[i - 1]) {\n            int j_start = i * i;\n            if (j_start < 2) j_start = i * i;\n            for (int j = j_start; j < n; j += i) {\n                sieve[j - 1] = 0;\n            }\n        }\n    }\n\n    int count = 0;\n    for (int i = 2; i < n; ++i) {\n        if (sieve[i - 1]) count++;\n    }\n\n    primes.reserve(count);\n    count = 0;\n    for (int i = 2; i < n; ++i) {\n        if (sieve[i - 1]) primes.push_back(i);\n    }\n\n    delete[] sieve;\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cstring>\n\nstd::vector<int> count_up_to_simd(int n){\n    std::vector<int> primes;\n    if (n <= 1) return primes;\n\n    int limit = n;\n    size_t vl = vsetvl_e32m1(limit);\n\n    // Create a vector sieve\n    uint32_t* sieve = new uint32_t[limit];\n    memset(sieve, 1, sizeof(uint32_t) * limit);\n    sieve[0] = sieve[1] = 0;\n\n    for(int i = 2; i*i < limit; ++i){\n        if(sieve[i]){\n            for(int j = i*i; j < limit; j += i){\n                sieve[j] = 0;\n            }\n        }\n    }\n\n    // Collect primes using RVV\n    for(int i = 2; i < limit; ++i){\n        if(sieve[i]){\n            primes.push_back(i);\n            if(primes.size() == n){\n                break;\n            }\n        }\n    }\n\n    delete[] sieve;\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cstring>\n\nstd::vector<int> count_up_to_simd(int n){\n    std::vector<int> primes;\n    if (n <= 1) return primes;\n\n    // Determine the vector length and group size\n    size_t vlmax = vsetvl_e32m1(1);\n    size_t num_elements = (n + vlmax - 1) / vlmax * vlmax;\n    uint32_t *is_prime = (uint32_t *)malloc(num_elements * sizeof(uint32_t));\n    memset(is_prime, 1, num_elements * sizeof(uint32_t));\n    is_prime[0] = 0; // 0 is not prime\n    is_prime[1] = 0; // 1 is not prime\n\n    for (int i = 2; i * i < n; ++i) {\n        if (is_prime[i]) {\n            size_t vl = vlmax;\n            for (int j = i * i; j < n; j += i) {\n                is_prime[j] = 0;\n            }\n        }\n    }\n\n    // Collect primes using RVV\n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    free(is_prime);\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n){\n    std::vector<int> primes;\n    if (n <= 1) return primes;\n\n    size_t vl = vsetvl_e32m1(n);\n    vbool32_t mask = vmv_v_x_b32(vl, 1);\n    vint32m1_t numbers = vid_v_i32m1(vl);\n\n    vbool32_t is_prime = vmv_v_x_b32(vl, 1);\n    is_prime = vor_vx_b32(is_prime, 0, vl); // Initialize to true\n    is_prime = vand_vv_b32(is_prime, vle32_v_b32((uint8_t*)(&numbers), vl), vl); // Exclude 0 and 1\n\n    for(int i = 2; i * i < n; ++i){\n        vbool32_t divisible = vmseq_vx_b32(numbers, i, vl);\n        is_prime = vandn_vv_b32(is_prime, divisible, vl);\n        if(i % 2 == 0){\n            is_prime = vor_vv_b32(is_prime, vmslt_vx_b32(numbers, i, vl), vl);\n        }\n    }\n\n    size_t count = 0;\n    for(size_t i = 0; i < vl; ++i){\n        if(vmvt_x_v_b32(mask, is_prime, vl)[i]){\n            primes.push_back(i);\n            if(primes.back() >= n) break;\n        }\n    }\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n){\n    std::vector<int> primes;\n    if (n <= 1) return primes;\n\n    int vl = vsetvl_e32m1(n);\n    vbool32_t mask = vmv_v_x_b32(true, vl);\n    vint32m1_t vindex = vid_v_i32m1(mask, vl);\n    vbool32_t is_prime = vmv_v_x_b32(true, vl);\n\n    // Set 0 and 1 as non-prime\n    is_prime = vmsbf_m_b32_b32(mask, is_prime, 0);\n    is_prime = vmsbf_m_b32_b32(mask, is_prime, 1);\n\n    for(int i = 2; i * i < n; ++i){\n        vbool32_t multiple = vmseq_m_b32_b32(mask, vindex, i, vl);\n        for(int j = i * i; j < n; j += i){\n            multiple = vmsorf_m_b32_b32_b32(mask, multiple, vmseq_m_b32_b32(mask, vindex, j, vl));\n        }\n        is_prime = vmandnf_m_b32_b32_b32(mask, is_prime, multiple);\n    }\n\n    for(int i = 2; i < n; ++i){\n        if(vmop_b32(is_prime, i)){\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_109_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cstring>\n\nint count_upper_simd(const std::string &s) {\n    const uint8_t uppercase_vowels[5] = {'A', 'E', 'I', 'O', 'U'};\n    size_t len = s.length();\n    int count = 0;\n\n    size_t vl = vsetvl_e8m1(len);\n    vuint8m1_t v_mask = vmv_v_x_u8m1(0, vl);\n    vuint8m1_t v_uppercase_vowels = vmv_v_x_u8m1(0, vl);\n\n    for (size_t i = 0; i < 5; ++i) {\n        v_uppercase_vowels = vor_vx_u8m1(v_uppercase_vowels, uppercase_vowels[i], vl);\n    }\n\n    for (size_t i = 0; i < len; i += vl) {\n        size_t chunk_size = len - i > vl ? vl : len - i;\n        vl = vsetvl_e8m1(chunk_size);\n\n        vuint8m1_t v_data = vle8_v_u8m1(reinterpret_cast<const uint8_t *>(&s[i]), vl);\n        vbool8_t is_even_idx = viota_v_u8m1(vl) & 1;\n        vbool8_t is_uppercase_vowel = vmseq_vv_b8m1(v_data, v_uppercase_vowels, vl);\n        vbool8_t combined_mask = vand_vv_b8m1(is_even_idx, is_uppercase_vowel, vl);\n        count += vpopc_m_b8(combined_mask, vl);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cstring>\n\nint count_upper_simd(const std::string &s) {\n    const uint8_t uppercase_vowels[5] = {'A', 'E', 'I', 'O', 'U'};\n    size_t len = s.length();\n    int count = 0;\n\n    if (len == 0) return 0;\n\n    size_t i = 0;\n    size_t vl = vsetvl_e8m1(len);\n    uint8_t mask[5] = {1, 1, 1, 1, 1};\n    vuint8m1_t v_mask = vmv_v_x_u8m1(0, vl);\n    for (size_t j = 0; j < 5; ++j) {\n        v_mask = vor_vx_u8m1(v_mask, uppercase_vowels[j], vl);\n    }\n\n    for (; i + vl <= len; i += vl) {\n        vuint8m1_t v_data = vle8_v_u8m1(reinterpret_cast<const uint8_t*>(&s[i]), vl);\n        vbool8_t is_even_idx = viota_m_b8m1(true, vl);\n        is_even_idx = vand_vvm_b8m1(is_even_idx, vmslt_vx_b8m1(viota_v_u8m1(vl), 2, vl), vl);\n\n        vuint8m1_t v_upper = vand_vv_u8m1(v_data, v_mask, vl);\n        vbool8_t is_upper_vowel = veq_vv_b8m1(v_data, v_upper, vl);\n        is_upper_vowel = vand_vvm_b8m1(is_upper_vowel, is_even_idx, vl);\n\n        count += vm popc_m_u8_b8m1(is_upper_vowel, vl);\n    }\n\n    for (; i < len; ++i) {\n        if ((i % 2 == 0) && strchr((const char*)uppercase_vowels, s[i])) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cstring>\n\nint count_upper_simd(const std::string &s) {\n    if (s.empty()) return 0;\n\n    const uint8_t uppercase_vowels[5] = {'A', 'E', 'I', 'O', 'U'};\n    size_t len = s.length();\n    int count = 0;\n\n    size_t i = 0;\n    size_t vl = vsetvl_e8m1(len);\n    vuint8m1_t vmask, vzero, vtemp, vupper;\n\n    vzero = vmv_v_x_i8m1(0, vl);\n    vupper = vle8_v_u8m1((uint8_t *)uppercase_vowels, 5);\n\n    for (; i <= len - vl; i += vl) {\n        vmask = vmsne_vx_i8m1(vlseq_vx_i8m1(vlse8_v_i8m1(i, (uint8_t *)s.c_str(), vl), 0, vl), 0, vl);\n        vtemp = vand_vx_i8m1(vlse8_v_i8m1(i, (uint8_t *)s.c_str(), vl), 0xDF, vl); // Convert to uppercase\n        count += (int)vpopc_m_b8m1(vmask, vmsub_vv_i8m1(vtemp, vupper, vl), vl);\n    }\n\n    for (; i < len; ++i) {\n        if (i % 2 == 0 && strchr(\"AEIOU\", s[i])) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cstring>\n\nint count_upper_simd(const std::string &s) {\n    int count = 0;\n    size_t length = s.length();\n    const uint8_t *str = reinterpret_cast<const uint8_t *>(s.c_str());\n    uint8_t mask_vowel[8] = {0, 1, 0, 0, 0, 0, 1, 0}; // Mask for uppercase vowels AEIOU\n    vuint8m1_t vmask_vowel = vle8_v_u8m1(mask_vowel, 8);\n\n    size_t i = 0;\n    size_t vlmax = vsetvl_e8m1(0);\n    for (; i <= length - vlmax; i += vlmax) {\n        vuint8m1_t vdata = lvu8_v_u8m1(str + i, vlmax);\n        vbool8_t is_even_idx = vmseq_vx_u8m1_b8(vlsltu_xff_i8m1(i, vlmax), 0, vlmax);\n        vbool8_t is_upper = vmsle_vx_u8m1_b8(vdata, 'Z', vlmax) & vmsge_vx_u8m1_b8(vdata, 'A', vlmax);\n        vbool8_t is_vowel = vmseq_vv_u8m1_b8(vdata, vmask_vowel, vlmax);\n        vbool8_t condition = is_even_idx & is_upper & is_vowel;\n        count += vmopopcount_m_b8(condition, vlmax);\n    }\n\n    for (; i < length; ++i) {\n        if (i % 2 == 0 && str[i] >= 'A' && str[i] <= 'Z') {\n            char c = str[i];\n            if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cstring>\n\nint count_upper_simd(const std::string &s) {\n    const uint8_t uppercase_vowels[5] = {'A', 'E', 'I', 'O', 'U'};\n    size_t len = s.length();\n    int count = 0;\n\n    if (len == 0) return 0;\n\n    size_t i = 0;\n    size_t vl = vsetvl_e8m1(len);\n    vuint8m1_t vzero = vmv_v_x_i8m1(0, vl);\n    vuint8m1_t vcount = vmv_v_x_i8m1(0, vl);\n\n    for (; i <= len - vl; i += vl) {\n        vuint8m1_t vdata = vle8_v_u8m1(reinterpret_cast<const uint8_t*>(&s[i]), vl);\n        vuint8m1_t veven_idx_mask = vmseq_vx_i8m1(i + vmv_v_x_i8m1(0, vl), 0, vl); // Generate even index mask\n        vuint8m1_t vupper_mask = vmsge_vx_i8m1(vdata, 'A', vl);\n        vuint8m1_t vlower_mask = vmsle_vx_i8m1(vdata, 'Z', vl);\n        vuint8m1_t vis_vowel = vmsne_vx_i8m1(vdata, 'A', vl); // Initialize to all true\n\n        for (size_t j = 0; j < 5; j++) {\n            vbool8_t is_vowel = vmseq_vx_i8m1(vdata, uppercase_vowels[j], vl);\n            vis_vowel = vmand_mm.vis_vowel(is_vowel, vl);\n        }\n\n        vuint8m1_t vvalid = vm_and_vvm(veven_idx_mask, vm_and_vvm(vupper_mask, vlower_mask, vl), vl);\n        vvalid = vm_and_vvm(vvalid, vis_vowel, vl);\n        vcount = vm_add_vv_u8m1(vcount, vvalid, vl);\n    }\n\n    count += vmv_x_s_u8m1_i8(vredsum_vs_u8m1_u8(vcount, vzero, vl));\n\n    for (; i < len; ++i) {\n        if (i % 2 == 0 && s[i] >= 'A' && s[i] <= 'Z') {\n            for (size_t j = 0; j < 5; j++) {\n                if (s[i] == uppercase_vowels[j]) {\n                    count++;\n                    break;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_110_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n){\n    int vl = n;\n    std::vector<int> result(n);\n    if (vl == 0) return result;\n\n    int start = n;\n    vint32m1_t v_start = vmv_v_x_i32m1(start, vl);\n    vint32m1_t v_step = vmv_v_x_i32m1(2, vl);\n    vint32m1_t v_idx = vid_v_i32m1(vl);\n\n    vbool32_t is_odd = vmseq_vx_b32m1(start, 1, vl);\n    vint32m1_t v_even_adjust = vmul_vx_i32m1(v_idx, 2, vl);\n    vint32m1_t v_odd_adjust = vadd_vv_i32m1(v_even_adjust, v_step, vl);\n\n    vint32m1_t v_result = vfwredsum_vs_i32m1i32m1(v_start, vmux_vm_i32m1(is_odd, v_odd_adjust, v_even_adjust), v_start, vl);\n\n    for(int i=0; i<n; ++i){\n        result[i] = vresult_v_i32m1_i(v_result, i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n){\n    int vl = n;\n    std::vector<int> result(n);\n    if (n <= 0) return result;\n\n    int start = n;\n    vint32m1_t v_start = vmv_v_x_i32m1(start, vl);\n    vint32m1_t v_step = vmv_v_x_i32m1(2, vl);\n    vint32m1_t v_idx = vid_v_i32m1(vl);\n\n    vbool32_t is_odd = vmf_eq_vx_b32m1(vmod_vx_i32m1(start, 2, vl), 0, vl);\n    vint32m1_t v_stones = vadd_vx_i32m1(v_start, vmul_vx_i32m1(v_idx, 2, vl), vl);\n\n    // Adjust for even/odd starting condition\n    vint32m1_t adjusted = vmsub_vv_i32m1(v Stones, vmerge_vx_i32m1(vmv_v_x_i32m1(2, vl), vmv_v_x_i32m1(0, vl), is_odd, vl), vl);\n\n    // Store results back to array\n    for(int i=0;i<n;i++) {\n        result[i] = vmv_x_s_i32m1_i32(velement_v_i32m1_i32(adjusted, i));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n){\n    std::vector<int> result(n);\n    if (n <= 0) return result;\n\n    size_t vl = n;\n    vint32m1_t vmask = vmv_v_x_i32m1(1, vl);\n    vint32m1_t vstart = vmv_v_x_i32m1(n, vl);\n\n    result[0] = n;\n    int current = n;\n    for(int i = 1; i < n; ++i){\n        current += 2;\n        result[i] = current;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n){\n    int vl = n;\n    std::vector<int> result(n);\n    if (vl == 0) return result;\n\n    // Initialize the vector with the first value 'n'\n    vint32m1_t v_n = vmv_v_x_i32m1(n, vl);\n    vint32m1_t v_result = v_n;\n\n    // Compute the increment values (2 for each element)\n    vint32m1_t v_two = vmv_v_x_i32m1(2, vl);\n\n    // Generate the sequence using cumulative addition\n    for(int i = 1; i < vl; i++) {\n        v_result = vfadd_vv_i32m1(v_result, v_two, vl);\n        // Store the results into the output array\n        int *base_addr = &result[0] + i;\n        vse32_v_i32m1(base_addr, v_result, vl - i);\n    }\n\n    // Store the initial value\n    result[0] = n;\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n){\n    int vl = n;\n    size_t vlen = 0;\n    if (vl == 0) return {};\n    \n    // Determine vector length and create vectors\n    vint32m1_t vm_n = vmv_v_x_i32m1(n, vl);\n    vbool4_t mask = vm_geu_b4_m(vmv_v_x_i32m1(1, vl), vm_n, vl);\n    \n    vint32m1_t result = vmv_v_x_i32m1(n, vl);\n    vint32m1_t incr = vmv_v_x_i32m1(n % 2 == 0 ? 2 : 1, vl);\n\n    for(int i = 1; i < vl; ++i){\n        result = vfadd_vv_i32m1(result, incr, vl);\n        incr = vfadd_vv_i32m1(incr, vmv_v_x_i32m1(2, vl), vl);\n    }\n\n    int *raw_results = (int *)malloc(sizeof(int) * vl);\n    vse32_v_i32m1(raw_results, result, vl);\n\n    std::vector<int> ret(raw_results, raw_results + vl);\n    free(raw_results);\n    return ret;\n}\n```"}
{"task_id": "SimdBench_111_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <bit>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n\n    size_t vl = vsetvl_e64m1(m - n + 1);\n    vint64m1_t v_n_m = vmv_v_x_i64m1(n, vl);\n    vint64m1_t v_inc = vid_v_i64m1(vl);\n    vint64m1_t v_range = vadd_vv_i64m1(v_n_m, v_inc, vl);\n\n    int64_t sum = 0;\n    for (size_t i = 0; i < vl; ++i) {\n        sum += vget_v_i64m1_i64(v_range, i);\n    }\n\n    int64_t count = m - n + 1;\n    int64_t avg = sum / count;\n\n    std::string binary = std::bitset<64>(avg).to_string();\n    // Remove leading zeros\n    size_t first_one = binary.find_first_of('1');\n    if (first_one != std::string::npos) {\n        binary = binary.substr(first_one);\n    } else {\n        binary = \"0\";\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_111_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m){\n    if (n > m) return \"-1\";\n\n    uint64_t length = m - n + 1;\n    uint64_t sum = 0;\n\n    size_t vl = vsetvl_e64m1(length);\n    vuint64m1_t vn = vmv_v_x_u64m1(n, vl);\n    vuint64m1_t vm = vmv_v_x_u64m1(m, vl);\n\n    vbool64_t mask = vmge_vx_u64m1_b64(vn, n, vl);\n    vuint64m1_t idx = vid_v_u64m1(vl);\n    vuint64m1_t vrange = vmadd_vx_u64m1(idx, 1, n, vl);\n\n    sum = vredsum_vs_u64m1_u64m1_u64(vrange, vmv_v_x_u64m1(0, vl), vl);\n\n    int64_t avg = sum / length;\n\n    std::string binary = \"\";\n    int64_t temp = avg;\n    if (temp == 0) {\n        binary = \"0\";\n    }\n    while (temp > 0){\n        binary = (char)('0' + (temp % 2)) + binary;\n        temp /= 2;\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_111_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m){\n    if (n > m) return \"-1\";\n\n    int64_t total_elements = m - n + 1;\n    int64_t sum = 0;\n\n    size_t vl = vsetvl_e64m1(total_elements);\n    vint64m1_t vn = vmv_v_x_i64m1(n, vl);\n    vint64m1_t vm = vmv_v_x_i64m1(m, vl);\n\n    vbool64_t mask = vmge_vx_b64m1(vm, n, vl);\n    vint64m1_t vidx = vid_v_i64m1(vl);\n    vint64m1_t vrng = vfadd_vv_f64m1(vn, vidx, vl);\n\n    sum = vmvredu_sum_vs_i64m1_i64(vrng, 0, mask, vl);\n\n    int64_t avg = sum / total_elements;\n    std::string binary = \"\";\n    int64_t num = avg;\n    if (num == 0) {\n        binary = \"0\";\n    }\n    while (num > 0) {\n        binary = (char)('0' + (num & 1)) + binary;\n        num >>= 1;\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_111_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m){\n    if (n > m) return \"-1\";\n\n    size_t vl = vsetvl_e64m1(m - n + 1);\n    vint64m1_t v_n_m = vmv_v_x_i64m1(n, vl);\n    vint64m1_t v_step = vmv_v_x_i64m1(1, vl);\n    vint64m1_t v_indices = vid_v_i64m1(vl);\n    vint64m1_t v_range = vadd_vv_i64m1(v_n_m, v_mul_vx_i64m1(v_step, v_indices, vl), vl);\n\n    vint64m1_t v_one = vmv_v_x_i64m1(1, vl);\n    int64_t sum = 0;\n    for(size_t i = 0; i < vl; ++i){\n        sum += (int64_t)vget_v_i64m1_i64(v_range, i);\n    }\n    int64_t count = m - n + 1;\n    int64_t avg = (sum / count);\n\n    std::string binary = \"\";\n    int64_t num = avg;\n    if(num == 0){\n        binary = \"0\";\n    }\n    else{\n        while(num > 0){\n            binary = std::to_string(num % 2) + binary;\n            num /= 2;\n        }\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_111_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m){\n    if(n > m){\n        return \"-1\";\n    }\n    \n    uint64_t length = m - n + 1;\n    uint64_t sum = 0;\n    \n    size_t vl = vsetvl_e64m8(length);\n    vuint64m8_t vn = vmv_v_x_u64m8(n, vl);\n    vuint64m8_t vm_vec = vmv_v_x_u64m8(m, vl);\n    \n    vbool8_t mask = vle64_v_b8((uint64_t*)&length, vl);\n    vuint64m8_t vsum = vid_v_u64m8(vl);\n    vsum = vfadd_vv_u64m8(vsum, vn, vl);\n    \n    uint64_t total_sum = 0;\n    for(uint64_t i = 0; i < length; ++i){\n        total_sum += n + i;\n    }\n    \n    uint64_t avg = total_sum / length;\n    std::string binary = \"\";\n    uint64_t num = avg;\n    \n    if(num == 0){\n        binary = \"0\";\n    }\n    else{\n        while(num > 0){\n            binary = (char)('0' + (num & 1)) + binary;\n            num >>= 1;\n        }\n    }\n    \n    return binary;\n}\n```"}
{"task_id": "SimdBench_112_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n){\n    if (n <= 0) return {};\n\n    std::vector<int> result(n);\n    int vl = vsetvl_e32m1(n);\n\n    // Initialize index vector {0, 1, 2, ..., n-1}\n    vint32m1_t v_i = vid_v_i32m1(vl);\n\n    // Add one to index vector to start from 1 {1, 2, 3, ..., n}\n    vint32m1_t v_idx = vadd_vx_i32m1(v_i, 1, vl);\n\n    // Compute mask for even indices\n    vbool32_t is_even = vmseq_vx_i32m1_b32(v_idx, 0, vl); \n    for(int i=2; i<=n; i+=2){\n        vbool32_t tmp = vmseq_vx_i32m1_b32(v_idx, i, vl);\n        is_even = vor_vv_b32(is_even, tmp, vl);\n    }\n\n    // Compute factorial modulo 10000 for even indices\n    vint32m1_t v_fact = vmsel_vv_i32m1(v_idx, v_idx, v_idx, vl); \n    for(int i=2; i<=n; ++i){\n        v_fact = vmul_vv_i32m1(v_fact, v Fact, vl);\n        v_fact = visplit_vx_i32m1(v_fact, 10000, vl);\n    }\n\n    // Compute sum for odd indices\n    vint32m1_t v_sum = vmsel_vv_i32m1(v_idx, v_idx, v_idx, vl);\n    for(int i=2; i<=n; ++i){\n        v_sum = vadd_vv_i32m1(v_sum, v_idx, vl);\n    }\n\n    // Combine results\n    vint32m1_t v_res = vmerge_vvm_i32m1(v_fact, v_sum, is_even, vl);\n\n    // Store result into array\n    vstore_v_i32(result.data(), vl, v_res);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n){\n    if (n <= 0) return {};\n    \n    std::vector<int> result(n);\n    int vl = vsetvl_e32m1(n);\n    vint32m1_t vindex = vid_v_i32m1(vl);\n    vbool32_t vmask_even = vmsltu_vx_i32m1_b32(vindex, 1, vl);\n    vbool32_t vmask_odd = vmsgeu_vx_i32m1_b32(vindex, 1, vl);\n\n    // Initialize vector with ones for factorial computation\n    vint32m1_t vones = vmv_v_x_i32m1(1, vl);\n    vint32m1_t vresult = vones;\n\n    for(int i = 1; i <= n; ++i){\n        vint32m1_t vi = vmv_v_x_i32m1(i, vl);\n        vint32m1_t vtemp = vmul_vv_i32m1(vresult, vi, vl);\n        vresult = vfmerge_vvm_i32m1(vresult, vtemp, vmask_even, vl);\n        \n        // Compute sum for odd indices\n        vint32m1_t vsum = vredsum_vs_i32m1_i32m1(vi, vones, vl);\n        vresult = vfmerge_vvm_i32m1(vresult, vsum, vmask_odd, vl);\n    }\n\n    // Apply modulo operation\n    vint32m1_t vmod = vmv_v_x_i32m1(10000, vl);\n    vresult = vrem_vx_i32m1(vresult, 10000, vl);\n\n    // Store results back to the array\n    vse32_v_i32m1(result.data(), vresult, vl);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n){\n    if (n <= 0) return {};\n\n    std::vector<int> result(n, 0);\n\n    size_t vl = vsetvl_e32m1(n);\n    vint32m1_t v_index = vid_v_i32m1(vl);\n    vbool32_t vm = true;\n\n    // Compute factorial modulo 10000 for even indices\n    vint32m1_t v_fact = vmsltu_vx_i32m1_b32(vm, v_index, 2, vl); // Initialize with 1 for i=0 and i=1\n    vint32m1_t v_mod = vmv_v_x_i32m1(10000, vl);\n\n    for (int i = 2; i < n; ++i) {\n        vint32m1_t v_i = vmv_v_x_i32m1(i, vl);\n        vbool32_t is_even = vmseq_vx_b32(vm, v_i & 1, 0, vl);\n        v_fact = vfmerge_vvm_i32m1(is_even, v Fact * v_i % v_mod, v_fact, vl);\n    }\n\n    vint32m1_t v_res = v Fact;\n    vstore(result.data(), vl, v_res);\n\n    // Compute sum for odd indices\n    for (int i = 1; i < n; ++i) {\n        if (i % 2 != 0) {\n            int sum = (i * (i + 1)) / 2;\n            result[i] = sum;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n){\n    if (n <= 0) return {};\n\n    std::vector<int> result(n);\n    int vl = vsetvl_e32m1(n);\n\n    vint32m1_t v_index = vid_v_i32m1(vl);\n    vbool32_t mask_even = vmseq_vv_i32m1_b32(v_index, vmod_v_i32m1(v_index, 2), vl);\n    vbool32_t mask_odd = vmseq_vv_i32m1_b32(v_index, vmadd_vx_i32m1(v_index, 1, 2), vl);\n\n    // Compute factorial modulo for even indices\n    vint32m1_t v_fact = vmsel_vv_i32m1(v_index, v_index, v_index, vl);\n    vint32m1_t v_one = vmv_v_x_i32m1(1, vl);\n    for(int i = 1; i <= n; ++i){\n        v_fact = vmul_vv_i32m1(v_fact, v Fact, vl);\n        v_fact = vmrem_vx_i32m1(v_fact, 10000, vl);\n    }\n\n    // Compute sum for odd indices\n    vint32m1_t v_sum = vmul_vv_i32m1(v_index, vmadd_vx_i32m1(v_index, 1, 2), vl);\n    v_sum = vmdiv_vx_i32m1(v_sum, 2, vl);\n\n    // Select based on masks\n    vint32m1_t v_result = vmsel_vv_i32m1(mask_even, v_fact, v_sum, vl);\n\n    // Store results back to array\n    vse32_v_i32m1(result.data(), v_result, vl);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n){\n    if (n <= 0) return {};\n\n    std::vector<int> result(n);\n    int vl = vsetvl_e32m1(n);\n\n    // Initialize index vector {0, 1, ..., n-1}\n    vint32m1_t v_idx = vmv_v_x_i32m1(0, vl);\n    vint32m1_t v_one = vmv_v_x_i32m1(1, vl);\n    for(int i = 0; i < n; ++i){\n        v_idx = vid_v_i32m1(v_idx, vl);\n    }\n\n    // Add one to make it {1, 2, ..., n}\n    v_idx = vadd_vx_i32m1(v_idx, 1, vl);\n\n    // Mask for even indices\n    vbool32_t is_even = vmsltu_vx_b32m1(v_idx, 1, vl);\n\n    // Compute factorial mod 10000 for even indices\n    vint32m1_t fact = vmv_v_x_i32m1(1, vl);\n    vint32m1_t temp = vmv_v_x_i32m1(1, vl);\n    for(int i = 1; i < n; ++i){\n        temp = vle32_v_i32m1(result.data()+i-1, vl);\n        fact = vmul_vx_i32m1(fact, i, vl);\n        fact = vsrl_vx_i32m1(fact, 4, vl); // Equivalent to modulo 10000\n        vse32_v_i32m1(result.data()+i, fact, vl);\n    }\n\n    // Compute sum for odd indices\n    vint32m1_t sum = vdivu_vx_i32m1(vmul_vx_i32m1(v_idx, v_idx, vl), 2, vl);\n\n    // Merge results based on mask\n    vint32m1_t res_vec = vmerge_vvm_i32m1(fact, sum, is_even, vl);\n\n    // Store the result back to memory\n    vse32_v_i32m1(result.data(), res_vec, vl);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_113_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n){\n    int even = 0, odd = 0;\n    size_t vl = vsetvl_e32m1(n);\n    vuint32m1_t vmask = vid_v_u32m1(vl);\n    vuint32m1_t vcmp = vm_vle32_v_u32m1((uint32_t *)(&n), vl);\n    uint32_t result[n];\n    for (size_t i = 1; i <= n; ++i) {\n        uint32_t num = i;\n        uint32_t rev = 0;\n        uint32_t temp = num;\n        while (temp != 0) {\n            rev = rev * 10 + temp % 10;\n            temp /= 10;\n        }\n        if (rev == num) {\n            if (num % 2 == 0) {\n                even++;\n            } else {\n                odd++;\n            }\n        }\n    }\n    std::vector<int> res = {even, odd};\n    return res;\n}\n```"}
{"task_id": "SimdBench_113_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n){\n    int even = 0, odd = 0;\n    size_t vlen = 0;\n    size_t vlmax = __riscv_vlmax();\n    uint8_t *range = (uint8_t *)malloc(vlmax * sizeof(uint8_t));\n    \n    for(int i=1; i<=n; ++i){\n        int temp = i, rev = 0;\n        int num = i;\n        while(temp > 0){\n            rev = rev * 10 + temp % 10;\n            temp /= 10;\n        }\n        if(rev == num){\n            range[i-1] = i;\n        } else {\n            range[i-1] = 0;\n        }\n    }\n\n    vbool8_t vm = __riscv_vmv_v_x_i8(true, vlen);\n    vuint8mf8_t vx = __riscv_vle8_v_u8mf8(range, vlen);\n\n    vbool8_t is_even = __riscv_vmsne_vx_i8mf8_b8(vx, 0, vm);\n    vbool8_t is_odd = __riscv_vmseq_vx_i8mf8_b8(vx, 0, vm);\n\n    uint32_t mask_even = __riscv_vmv_x_s_b8_i32(__riscv_vmandnot_mm_b8(vm, is_even, vm), vlen);\n    uint32_t mask_odd = __riscv_vmv_x_s_b8_i32(__riscv_vmand_mm_b8(vm, is_odd, vm), vlen);\n\n    even += __builtin_popcount(mask_even);\n    odd += __builtin_popcount(mask_odd);\n\n    free(range);\n    return {even, odd};\n}\n```"}
{"task_id": "SimdBench_113_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n){\n    int even = 0, odd = 0;\n    size_t vl = vsetvl_e32m1(n);\n    vuint32m1_t v_n = vmv_v_x_u32m1(n, vl);\n    vuint32m1_t v_i = vmv_v_x_u32m1(1, vl);\n    vbool32_t mask;\n\n    for (int i = 1; i <= n; ) {\n        size_t vl_i = vsetvl_e32m1(n - i + 1);\n        vuint32m1_t v_idx = vmv_v_x_u32m1(i, vl_i);\n        vuint32m1_t reversed = vrev_v_u32m1(v_idx, vl_i);\n        mask = vmseq_vv_b32m1(v_idx, reversed, vl_i);\n        vuint32m1_t filtered = vm_and_vx_u32m1(v_idx, mask, vl_i);\n        vuint32m1_t even_mask = vmsle_vx_u32m1(filtered, 0, vl_i);\n        even += __riscv_vpopc(even_mask, vl_i);\n        odd += __riscv_vpopc(vmnot_b32m1(even_mask), vl_i);\n        i += vl_i;\n    }\n    return std::vector<int>{even, odd};\n}\n```"}
{"task_id": "SimdBench_113_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n){\n    int even = 0, odd = 0;\n    size_t vl = vsetvl_e32m1(n);\n\n    uint32_t start = 1;\n    uint32_t step = 1;\n\n    vuint32m1_t v_n = vmv_v_x_u32m1(n, vl);\n    vbool4_t mask = true;\n\n    for (uint32_t i = start; i <= n; i += step * vl) {\n        vuint32m1_t vi = vmv_v_x_u32m1(i, vl);\n        vuint32m1_t vtemp = vi;\n        vuint32m1_t vrev = __riscv_vrev8_v_u32m1(vtemp, vl);\n        vrev = __riscv_vslidedown_vx_u32m1(vrev, vrev, 1, vl);\n        vrev = __riscv_vrev8_v_u32m1(vrev, vl);\n        vrev = __riscv_vslidedown_vx_u32m1(vrev, vrev, 1, vl);\n\n        vbool4_t is_palindrome = vmseq_vv_b4(vi, vrev, vl);\n        vbool4_t is_even = vmsle_vx_b4(vi, 0, vl);\n        vbool4_t is_odd = vmslt_vx_b4(vi, 0, vl);\n\n        even += __riscv_vpopc_m_b4(mask, is_palindrome & is_even, vl);\n        odd += __riscv_vpopc_m_b4(mask, is_palindrome & is_odd, vl);\n    }\n\n    return {even, odd};\n}\n```"}
{"task_id": "SimdBench_113_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n){\n    int even = 0, odd = 0;\n    size_t vl = vsetvl_e32m1(n);\n    vuint32m1_t vmask = vid_v_u32m1(vl);\n    vuint32m1_t vcmp = vm_vle32_v_u32m1((const uint32_t *)&vmask, vl);\n    for(int i=1;i<=n;i++){\n        int num = i;\n        int rev = 0;\n        int temp = num;\n        while(temp != 0){\n            rev = rev * 10 + temp % 10;\n            temp /= 10;\n        }\n        if(rev == num){\n            if(num % 2 == 0){\n                even++;\n            }\n            else{\n                odd++;\n            }\n        }\n    }\n    std::vector<int> result = {even, odd};\n    return result;\n}\n```"}
{"task_id": "SimdBench_114_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    if (n.empty()) return 0;\n\n    size_t vl = vsetvl_e32m1(n.size());\n    vbool32_t mask = vmv_v_x_b32(true, vl);\n    vint32m1_t vsum = vmv_v_x_i32m1(0, vl);\n\n    for (size_t i = 0; i < n.size(); i += vl) {\n        size_t subvl = vsetvl_e32m1(std::min(vl, (size_t)(n.size() - i)));\n        vint32m1_t vdata = vle32_v_i32m1((int*)&n[i], subvl);\n\n        vint32m1_t vabs_data = vfsgnjx_vv_i32m1(vdata, vdata, subvl);\n        vint32m1_t vtens = vmul_vx_i32m1(vabs_data, 10, subvl);\n\n        vint32m1_t vdigits = vdivu_vx_i32m1(vabs_data, 10, subvl);\n        vdigits = vremu_vx_i32m1(vabs_data, 10, subvl);\n\n        vbool32_t isneg = vmflt_vx_i32m1(vdata, 0, subvl);\n        vdigits = vfcvt_x_f_w_i32m1(vdigits, subvl);\n        vdigits = vfmerge_vfm_i32m1(vdigits, -vdigits, isneg, subvl);\n\n        vsum = vredsum_vs_i32m1_i32m1(vsum, vdigits, vsum, subvl);\n    }\n\n    int result_sum = 0;\n    result_sum = vmv_x_s_i32m1_i32(vsum);\n\n    return result_sum > 0 ? 1 : 0;\n}\n```"}
{"task_id": "SimdBench_114_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n){\n    if (n.empty()) return 0;\n\n    size_t vl = vsetvl_e32m1(n.size());\n    vuint32m1_t vmask = vmseq_vx_i32m1(vl, 0, 0);\n    vint32m1_t vnum = vle32_v_i32m1((const int*)n.data(), vl);\n\n    vint32m1_t vabs_num = vabsu_v_i32m1(vnum, vl);\n    vbool4_t vsgn = vmfsgnj_vv_f32m1(vfmv_v_f_f32m1(0.0f, vl), vfmv_v_f_f32m1(0.0f, vl), vl);\n\n    vuint32m1_t vsum = vmv_v_x_u32m1(0, vl);\n\n    for(int i = 0; i < 10; ++i){\n        vuint32m1_t vrem = vremu_vx_u32m1(vabs_num, 10, vl);\n        vint32m1_t vsign = vsltu_vx_i32m1(vnum, 0, vl);\n        vint32m1_t vsdigit = vsub_vv_i32m1(vrem, vsign, vl);\n        vsum = vadd_vv_u32m1(vsum, vsdigit, vl);\n        vabs_num = vdivu_vx_u32m1(vabs_num, 10, vl);\n    }\n\n    vmask = vmgt_vx_i32m1(vsum, 0, vl);\n    uint32_t result = vm popc mask_m_b32(vmask, vl);\n    return result;\n}\n```"}
{"task_id": "SimdBench_114_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n){\n    if (n.empty()) return 0;\n\n    size_t vl = n.size();\n    size_t vlen = vl;\n    int result = 0;\n\n    vuint32m8_t vmask = vmv_v_x_u32m8(0, vl);\n    vint32m8_t vnums = vle32_v_i32m8((const int*)n.data(), vl);\n\n    // Compute absolute values and extract signs\n    vbool32_t is_neg = vmflt_vx_i32m8_b32(vnums, 0, vl);\n    vuint32m8_t abs_vals = vmabsu_v_i32m8_u32m8(vnums, vl);\n\n    // Extract digits and compute sum of digits\n    vuint32m8_t units = vmandnot_vv_u32m8(abs_vals, vmulh_vx_u32m8(abs_vals, 10, vl), vl);\n    vint32m8_t signed_units = vmerge_vvm_i32m8(units, vnclip_wx_i32m8(-units, 1, vl), is_neg, vl);\n\n    vuint32m8_t tens = vmulh_vx_u32m8(abs_vals, 10, vl);\n    vuint32m8_t tens_units = vmandnot_vv_u32m8(tens, vmulh_vx_u32m8(tens, 10, vl), vl);\n    vint32m8_t signed_tens_units = vmerge_vvm_i32m8(tens_units, vnclip_wx_i32m8(-tens_units, 1, vl), is_neg, vl);\n\n    vint32m8_t sum_digits = vadd_vv_i32m8(signed_units, signed_tens_units, vl);\n\n    // Check if sum of digits > 0\n    vbool32_t cond = vmgt_vx_i32m8_b32(sum_digits, 0, vl);\n    result = vmopop_m_b32_i32(cond, vl);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_114_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    if (n.empty()) return 0;\n\n    size_t vl = vsetvl_e32m1(n.size());\n    vuint32m1_t vmask = vle32_v_u32m1(reinterpret_cast<const uint32_t*>(&n[0]), vl);\n    \n    int count = 0;\n    size_t i = 0;\n    for (; i + vl <= n.size(); i += vl) {\n        vint32m1_t vdata = vlse32_v_i32m1(0, reinterpret_cast<const int*>(&n[i]), 4, vl);\n\n        vbool32_t is_neg = vmfgt_vv_i32m1_b32(vdata, vmsub_vx_i32m1(vdata, 1, vl), vl);\n        vuint32m1_t digits = vmabsu_wv_i32m1(vdata, vl);\n        \n        vbool32_t digit_mask = vmseq_vx_u32m1_b32(digits, 0, vl);\n        vbool32_t sum_gt_zero = vmandnot_b32_m(vbool32_t, is_neg, digit_mask, vl);\n        \n        count += vm popc_m(sum_gt_zero, vl);\n    }\n\n    for (; i < n.size(); ++i) {\n        int num = n[i];\n        int sum = 0;\n        bool negative = false;\n        if (num < 0) {\n            negative = true;\n            num = -num;\n        }\n        while (num > 0) {\n            int digit = num % 10;\n            if (negative && sum == 0) {\n                digit = -digit;\n            }\n            sum += abs(digit);\n            num /= 10;\n        }\n        if (sum > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n){\n    if (n.empty()) return 0;\n\n    size_t vl = vsetvl_e32m1(n.size());\n    vuint32m1_t vcount = vmv_v_x_u32m1(0, vl);\n    vbool32_t vmask;\n    int result = 0;\n\n    for(size_t i = 0; i < n.size(); i += vl){\n        size_t subvl = vsetvl_e32m1(n.size() - i);\n        vint32m1_t vin = vle32_v_i32m1((int*)&n[i], subvl);\n\n        vbool32_t vcond = vmfle_v_i32m1_b32m1(vin, 0, subvl);\n        vint8m1_t vabs_digits = vsmul_vx_i32m1_i8m1(vin, 10, subvl);\n        vabs_digits = vfmerge_vfm_i8m1(vabs_digits, vabs_digits, vcond, subvl);\n        \n        vint8m1_t vsum = vmv_v_x_i8m1(0, subvl);\n        for(int j = 0; j < 4; ++j){\n            vint8m1_t vdigs = vrshuf_v_i8m1(vabs_digits, j, subvl);\n            vsum = vadd_vv_i8m1(vsum, vdigs, subvl);\n        }\n\n        vmask = vmfsgt_v_i8m1_b32m1(vsum, 0, subvl);\n        vcount = vredsum_mask_u32m1(vmask, vcount, vmask, subvl);\n    }\n    result = vmv_x_s_u32m1_u32(vcount);\n    return result;\n}\n```"}
{"task_id": "SimdBench_115_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nbool move_one_ball_simd(std::vector<int> arr){\n    size_t n = arr.size();\n    if (n == 0) return true;\n\n    // Find the index where the order breaks\n    size_t break_point = 0;\n    for (size_t i = 1; i < n; ++i) {\n        if (arr[i] < arr[i - 1]) {\n            break_point = i;\n            break;\n        }\n    }\n\n    // If no breakpoint, already sorted\n    if (break_point == 0 && arr[n - 1] <= arr[0]) return true;\n\n    // Check if rotating at break_point results in a sorted array\n    size_t vl = n;\n    size_t emul = 1;\n    size_t lmul = vset_lmul_factor(emul);\n    size_t sew = 32;\n    size_t avl = vl * (sew / 8) * lmul;\n\n    vint32m1_t v_break = vmv_v_x_i32m1(arr[break_point], vl);\n    vint32m1_t v_prev = vmv_v_x_i32m1(arr[break_point - 1], vl);\n\n    bool valid_break = arr[break_point] < arr[break_point - 1];\n    if (!valid_break) return false;\n\n    for (size_t i = break_point; i < n + break_point - 1; ++i) {\n        size_t j = i % n;\n        size_t k = (i + 1) % n;\n        if (arr[k] < arr[j]) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_115_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nbool move_one_ball_simd(std::vector<int> arr){\n    size_t n = arr.size();\n    if (n == 0) return true;\n\n    // Find the index where the order breaks\n    size_t break_point = 0;\n    for (size_t i = 1; i < n; ++i) {\n        if (arr[i] < arr[i - 1]) {\n            break_point = i;\n            break;\n        }\n    }\n\n    // If no breakpoint, already sorted\n    if (break_point == 0 && arr[n - 1] <= arr[0]) return true;\n\n    // Check if rotating at break_point results in a sorted array\n    for (size_t i = 1; i < n; ++i) {\n        size_t prev_idx = (i + break_point - 1) % n;\n        size_t curr_idx = (i + break_point) % n;\n        if (arr[curr_idx] < arr[prev_idx]) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_115_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nbool move_one_ball_simd(std::vector<int> arr){\n    if (arr.empty()) return true;\n\n    size_t vl = vsetvl_e32m1(arr.size());\n    vint32m1_t v_arr = vmv_v_x_i32m1(arr[0], vl);\n    vbool32_t mask = vmv_v_x_b32m1(0, vl);\n\n    for(size_t i = 1; i < arr.size(); ++i){\n        int32_t current = arr[i];\n        v_arr = vslide1up_vx_i32m1(v_arr, current, vl);\n    }\n\n    vint32m1_t sorted_v = vmv_v_x_i32m1(arr[0], vl);\n    std::vector<int> sorted_arr = arr;\n    std::sort(sorted_arr.begin(), sorted_arr.end());\n    for(size_t i = 1; i < arr.size(); ++i){\n        sorted_v = vslide1up_vx_i32m1(sorted_v, sorted_arr[i], vl);\n    }\n\n    vbool32_t compare_result = vmseq_vv_b32m1(v_arr, sorted_v, vl);\n    bool result = !vmsbf_m_b32m1(compare_result);\n    return result;\n}\n```"}
{"task_id": "SimdBench_115_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    size_t N = arr.size();\n    if (N == 0) return true;\n\n    // Find the index where the array breaks the non-decreasing order\n    size_t break_point = 0;\n    for (size_t i = 1; i < N; ++i) {\n        if (arr[i] < arr[i - 1]) {\n            break_point = i;\n            break;\n        }\n    }\n\n    // If no break point, already sorted\n    if (break_point == 0 && arr[N - 1] <= arr[0]) return true;\n\n    // Check if rotating at break_point results in a sorted array\n    size_t vl = vsetvl_e32m1(N);\n    size_t count = 0;\n    bool result = true;\n\n    for (size_t i = 0; i < N; i += vl) {\n        vint32m1_t v_arr = lvsl_e32_v_i32m1(vl, &arr[(i + break_point) % N]);\n        vbool32_t mask = vmge_vv_i32m1_b32m1(v_arr, vlsl_e32_v_i32m1(vl, &arr[(i + break_point + 1) % N], vl), vl);\n        count += __builtin_popcount(vmop_m(mask));\n    }\n\n    if (count > 1) result = false;\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_115_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nbool move_one_ball_simd(std::vector<int> arr){\n    size_t N = arr.size();\n    if (N == 0) return true;\n\n    // Find the index where the order breaks\n    size_t break_point = 0;\n    size_t vm = 0;\n    size_t vl = vsetvl_e32m1(N);\n    vint32m1_t v_arr = vmv_v_x_i32m1(0, vl);\n    vint32m1_t v_arr_rotated = vmv_v_x_i32m1(0, vl);\n\n    for(size_t i = 0; i < N; ++i){\n        if(i > 0 && arr[i] < arr[i-1]){\n            break_point = i;\n            break;\n        }\n    }\n\n    // Check if breaking point is valid for rotation\n    if(break_point == 0){\n        if(arr[N-1] > arr[0]) return false;\n    } else {\n        for(size_t i = 1; i < N; ++i){\n            size_t j = (break_point + i - 1) % N;\n            size_t k = (break_point + i) % N;\n            if(arr[j] > arr[k]){\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_116_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n#include <vector>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2){\n    size_t vl = vsetvl_e32m1(lst1.size());\n    vbool32_t vm = vmsnevi_b32_m(vbool32_t(True), vl, 0);\n    \n    // Load lst1 and lst2 into vectors\n    vint32m1_t v_lst1 = vle32_v_i32m1((const int*)lst1.data(), vl);\n    vint32m1_t v_lst2 = vle32_v_i32m1((const int*)lst2.data(), vl);\n\n    // Check if elements in lst1 are odd\n    vbool32_t is_odd_lst1 = vm & vmodeqi_m(vm, vl, v_lst1, 1);\n\n    // Check if elements in lst2 are even\n    vbool32_t is_even_lst2 = vm & vmsceqi_m(vm, vl, v_lst2, 0);\n\n    // Count the number of odd elements in lst1\n    size_t count_odd_lst1 = vpopc_m_u32(is_odd_lst1, vl);\n\n    // Count the number of even elements in lst2\n    size_t count_even_lst2 = vpopc_m_u32(is_even_lst2, vl);\n\n    if (count_even_lst2 >= count_odd_lst1) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2){\n    size_t vl = vsetvl_e32m1(lst1.size());\n    vbool32_t vmTrue = vm_vt_b32(vl, -1);\n    vint32m1_t vzero = vm_vsi32_v_i32m1(0, vl);\n\n    int count_odd_lst1 = 0;\n    {\n        size_t vl = vsetvl_e32m1(lst1.size());\n        vint32m1_t vlst1 = lv_v_i32m1(&lst1[0], vl);\n        vbool32_t is_odd = vm_and_vv_b32(vm_neq_vv_b32(vm_mod_vv_u32(vm_sext_vf4_u32(vlst1, vl), vm_vsi32_v_i32m1(2, vl), vl), vzero, vl), vmTrue, vl);\n        count_odd_lst1 = (int)vm_popc_b32(is_odd, vl);\n    }\n\n    int count_even_lst2 = 0;\n    {\n        size_t vl = vsetvl_e32m1(lst2.size());\n        vint32m1_t vlst2 = lv_v_i32m1(&lst2[0], vl);\n        vbool32_t is_even = vm_eq_vv_b32(vm_mod_vv_u32(vm_sext_vf4_u32(vlst2, vl), vm_vsi32_v_i32m1(2, vl), vl), vzero, vl);\n        count_even_lst2 = (int)vm_popc_b32(is_even, vl);\n    }\n\n    if(count_even_lst2 >= count_odd_lst1){\n        return \"YES\";\n    }\n    else{\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2){\n    size_t vl = vsetvl_e32m1(lst1.size());\n    vbool32_t vm = vtrue_b32(vl);\n    vint32m1_t vzero = vmv_v_x_i32m1(0, vl);\n\n    // Count odd numbers in lst1\n    size_t odd_count_lst1 = 0;\n    for (size_t i = 0; i < lst1.size(); i += vl) {\n        size_t subvl = vsetvl_e32m1(std::min(vl, static_cast<size_t>(lst1.size() - i)));\n        vbool32_t vm_sub = vtrue_b32(subvl);\n        vint32m1_t vlst1 = vle32_v_i32m1(&lst1[i], subvl);\n        vbool32_t is_odd = vmseq_vv_i32m1_b32m1(vlst1, vand_vv_i32m1(vlst1, vmv_v_x_i32m1(1, subvl), subvl), subvl);\n        odd_count_lst1 += vpopc_m_b32_i32(vm_sub, is_odd, subvl);\n    }\n\n    // Count even numbers in lst2\n    size_t even_count_lst2 = 0;\n    for (size_t i = 0; i < lst2.size(); i += vl) {\n        size_t subvl = vsetvl_e32m1(std::min(vl, static_cast<size_t>(lst2.size() - i)));\n        vbool32_t vm_sub = vtrue_b32(subvl);\n        vint32m1_t vlst2 = vle32_v_i32m1(&lst2[i], subvl);\n        vbool32_t is_even = vmsne_vv_i32m1_b32m1(vlst2, vand_vv_i32m1(vlst2, vmv_v_x_i32m1(1, subvl), subvl), subvl);\n        even_count_lst2 += vpopc_m_b32_i32(vm_sub, is_even, subvl);\n    }\n\n    return (even_count_lst2 >= odd_count_lst1) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2){\n    size_t vl = vsetvl_e32m1(lst1.size());\n    vbool32_t vmTrue = vtm_v_i32m1(true, vl);\n    vint32m1_t vzero = vmv_v_x_i32m1(0, vl);\n\n    // Count odd numbers in lst1\n    size_t odd_count_lst1 = 0;\n    for (size_t i = 0; i < lst1.size(); i += vl) {\n        size_t subvl = vsetvl_e32m1(std::min(vl, static_cast<size_t>(lst1.size() - i)));\n        vint32m1_t vlst1 = vle32_v_i32m1(reinterpret_cast<const int*>(&lst1[i]), subvl);\n        vbool32_t vodd_mask = vmseq_vv_i32m1_b32m1(vand_vv_i32m1(vlst1, vmv_v_x_i32m1(1, subvl), subvl), vmv_v_x_i32m1(1, subvl), subvl);\n        odd_count_lst1 += vpopc_m_b32m1_i32(vodd_mask, vmTrue, subvl);\n    }\n\n    // Count even numbers in lst2\n    size_t even_count_lst2 = 0;\n    for (size_t i = 0; i < lst2.size(); i += vl) {\n        size_t subvl = vsetvl_e32m1(std::min(vl, static_cast<size_t>(lst2.size() - i)));\n        vint32m1_t vlst2 = vle32_v_i32m1(reinterpret_cast<const int*>(&lst2[i]), subvl);\n        vbool32_t veven_mask = vmsne_vv_i32m1_b32m1(vand_vv_i32m1(vlst2, vmv_v_x_i32m1(1, subvl), subvl), vmv_v_x_i32m1(1, subvl), subvl);\n        even_count_lst2 += vpopc_m_b32m1_i32(veven_mask, vmTrue, subvl);\n    }\n\n    return (even_count_lst2 >= odd_count_lst1) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2){\n    size_t vl = vsetvl_e32m1(lst1.size());\n    vbool32_t vmTrue = vtm_v_i32m1(true, vl);\n    \n    // Load lst1 and check for odd numbers\n    vint32m1_t v_lst1 = vle32_v_i32m1((const int*)lst1.data(), vl);\n    vbool32_t v_odd_lst1 = vmseq_vv_i32_b32m1(v_lst1, vand_vv_i32_m(vmTrue, v_lst1, v_lst1, vl), vl);\n    \n    int num_odds_lst1 = (int)vpopc_m_b32_i32(vmTrue, v_odd_lst1, vl);\n    \n    if(num_odds_lst1 == 0){\n        return \"YES\";\n    }\n    \n    // Load lst2 and check for even numbers\n    vint32m1_t v_lst2 = vle32_v_i32m1((const int*)lst2.data(), vl);\n    vbool32_t v_even_lst2 = vmsne_vv_i32_b32m1(v_lst2, vand_vv_i32_m(vmTrue, v_lst2, v_lst2, vl), vl);\n    \n    int num_evens_lst2 = (int)vpopc_m_b32_i32(vmTrue, v_even_lst2, vl);\n    \n    if(num_evens_lst2 >= num_odds_lst1){\n        return \"YES\";\n    }\n    else{\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_117_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        size_t vl = str.size();\n        uint8_t *data = reinterpret_cast<uint8_t*>(&str[0]);\n        \n        size_t count = 0;\n        size_t i = 0;\n        for (; i + vl <= str.size(); i += vl) {\n            vuint8m1_t vec = vle8_v_u8m1(data + i, vl);\n            vuint8m1_t mask = vmseq_vx_u8m1(vec, '0', vl);\n            vuint8m1_t odds = vmge_vx_u8m1(vec, '1', vl);\n            odds = vmandnot_vv_u8m1(mask, odds, vl);\n            vbool8_t cmp = vmge_vx_b8m1(odds, '9', vl);\n            odds = vmxor_vv_u8m1(odds, vmfcvt_x_f_w(vmfdiv_vf_f8m1(vmfadd_vf_f8m1(vmfcvt_f_x_w(odds), -48.0, vl), 2.0, vl), vl), vl);\n            odds = vmseq_vx_u8m1(odds, 1, vl);\n            count += vm popc_m_u8m1(cmp, odds, vl);\n        }\n        for (; i < str.size(); ++i) {\n            if ((str[i] - '0') % 2 != 0) {\n                count++;\n            }\n        }\n\n        std::string output = \"the number of odd elements \";\n        output += std::to_string(count);\n        output += \"n the str\";\n        output += std::to_string(count);\n        output += \"ng \";\n        output += std::to_string(count);\n        output += \" of the \";\n        output += std::to_string(count);\n        output += \"nput.\";\n        result.push_back(output);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        size_t vl = str.size();\n        uint8_t *data = reinterpret_cast<uint8_t*>(&str[0]);\n        \n        size_t count = 0;\n        size_t i = 0;\n        for (; vl > 0; vl -= vsetvl_e8m1(i), i = vsetvl_e8m1(i)) {\n            vuint8m1_t vmask = vle8_v_u8m1(data, i);\n            vuint8m1_t vones = vmask & vtbl_vx_u8m1(1, (uint8_t*)\"13579\", i);\n            count += vpopc_v_u8m1(vones, i);\n            data += i;\n        }\n        \n        std::string output = \"the number of odd elements \";\n        output += std::to_string(count);\n        output += \"n the str\";\n        output += std::to_string(count);\n        output += \"ng \";\n        output += std::to_string(count);\n        output += \" of the \";\n        output += std::to_string(count);\n        output += \"nput.\";\n        result.push_back(output);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        size_t vl = str.size();\n        uint8_t *data = reinterpret_cast<uint8_t*>(&str[0]);\n        \n        size_t count = 0;\n        size_t i = 0;\n        for (; i + vl > i; i += vl) {\n            vuint8m1_t vec = vle8_v_u8m1(data + i, vl);\n            vuint8m1_t ones = vmv_v_x_u8m1(1, vl);\n            vbool8_t mask = vmseq_vu8_b8m1(vec, '1', vl);\n            for (int digit = 3; digit <= 7; digit += 2) {\n                vbool8_t temp_mask = vmseq_vu8_b8m1(vec, digit + '0', vl);\n                mask = vor_vv_b8m1(mask, temp_mask, vl);\n            }\n            vuint8m1_t masked_ones = vand_vv_u8m1(ones, mask, vl);\n            count += vpopc_v_i32m2(masked_ones, vl);\n        }\n        \n        // Handle remaining elements if any\n        if (i < str.size()) {\n            size_t remainder = str.size() - i;\n            vuint8m1_t vec = vle8_v_u8m1(data + i, remainder);\n            vuint8m1_t ones = vmv_v_x_u8m1(1, remainder);\n            vbool8_t mask = vmseq_vu8_b8m1(vec, '1', remainder);\n            for (int digit = 3; digit <= 7; digit += 2) {\n                vbool8_t temp_mask = vmseq_vu8_b8m1(vec, digit + '0', remainder);\n                mask = vor_vv_b8m1(mask, temp_mask, remainder);\n            }\n            vuint8m1_t masked_ones = vand_vv_u8m1(ones, mask, remainder);\n            count += vpopc_v_i32m2(masked_ones, remainder);\n        }\n\n        // Construct the result string\n        std::string res = \"the number of odd elements \";\n        res += std::to_string(count);\n        res += \"n the str\";\n        res += std::to_string(count);\n        res += \"ng \";\n        res += std::to_string(count);\n        res += \" of the \";\n        res += std::to_string(count);\n        res += \"nput.\";\n        result.push_back(res);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        size_t count = 0;\n        size_t n = str.size();\n        if (n == 0) {\n            result.emplace_back(\"the number of odd elements 0n the str0ng 0 of the 0nput.\");\n            continue;\n        }\n        size_t vl = vsetvl_e8m1(n);\n        uint8_t mask = 0x01;\n        vuint8m1_t vmask = vmv_v_x_u8m1(mask, vl);\n        vuint8m1_t vzero = vmv_v_x_u8m1(0, vl);\n        vuint8m1_t vdata = vle8_v_u8m1(reinterpret_cast<const uint8_t*>(str.c_str()), vl);\n        vbool8_t is_odd = vmseq_vu8_b8_m(vmask, vdata & vmask, true, vl);\n        count = vpopc_vm_u8_b8(is_odd, vzero, vl);\n        \n        std::string output = \"the number of odd elements \";\n        output += std::to_string(count);\n        output += \"n the str\";\n        output += std::to_string(count);\n        output += \"ng \";\n        output += std::to_string(count);\n        output += \" of the \";\n        output += std::to_string(count);\n        output += \"nput.\";\n        result.emplace_back(output);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> &lst) {\n    std::vector<std::string> result;\n    for (const auto &s : lst) {\n        size_t count = 0;\n        size_t vl = s.size();\n        if (vl == 0) {\n            result.emplace_back(\"the number of odd elements 0n the str0ng 0 of the 0nput.\");\n            continue;\n        }\n        uint8_t *data = const_cast<uint8_t *>(reinterpret_cast<const uint8_t *>(s.data()));\n        size_t i = 0;\n        for (; vl >= 16; vl -= 16, data += 16) {\n            vuint8m1_t vec_data = vle8_v_u8m1(data, 16);\n            vuint8m1_t vec_mask = vmseq_vx_u8m1(vec_data, '0', 16);\n            vuint8m1_t vec_odd = vmsge_vx_u8m1(vec_data, '0', 16);\n            vec_odd = vmandnot_vv_u8m1(vec_odd, vmseq_vx_u8m1(vec_data, '9', 16), 16);\n            vec_odd = vmslt_vx_u8m1(vec_odd, 10, 16);\n            vec_odd = vmxor_vv_u8m1(vec_odd, vec_mask, 16);\n            vbool8_t mask = vmfgt_vu8m1_b8(vec_odd, 0, 16);\n            count += vmopopcnt_m_b8(mask, 16);\n        }\n        for (; i < s.size(); ++i) {\n            if ((s[i] - '0') % 2 != 0) {\n                count++;\n            }\n        }\n        std::string res = \"the number of odd elements \";\n        res += std::to_string(count);\n        res += \"n the str\";\n        res += std::to_string(count);\n        res += \"ng \";\n        res += std::to_string(count);\n        res += \" of the \";\n        res += std::to_string(count);\n        res += \"nput.\";\n        result.emplace_back(res);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_118_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <limits.h>\n#include <algorithm>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums){\n    if (nums.empty()) return 0;\n\n    size_t size = nums.size();\n    int64_t current_min = nums[0];\n    int64_t global_min = nums[0];\n\n    size_t vl = vsetvl_e64m1(size);\n    vint64m1_t vcurrent_min = vmv_v_x_i64m1(nums[0], vl);\n    vint64m1_t vglobal_min = vmv_v_x_i64m1(nums[0], vl);\n\n    for(size_t i = 1; i < size; i += vl){\n        size_t sub_size = std::min(vl, size - i);\n        vl = vsetvl_e64m1(sub_size);\n        vint64m1_t vnums = vle64_v_i64m1(&nums[i], vl);\n        vcurrent_min = vmv_v_x_i64m1(current_min, vl);\n        vcurrent_min = vfmin_vv_i64m1(vnums, vadd_vv_i64m1(vcurrent_min, vnums, vl), vl);\n        vglobal_min = vfmin_vv_i64m1(vglobal_min, vcurrent_min, vl);\n\n        // Reduction to find the minimum value in vglobal_min\n        int64_t temp_global_min = global_min;\n        for(size_t j = 0; j < sub_size; j++){\n            int64_t val = vget_v_i64m1_i64(vglobal_min, j);\n            if(val < temp_global_min){\n                temp_global_min = val;\n            }\n        }\n        global_min = temp_global_min;\n    }\n\n    return global_min;\n}\n```"}
{"task_id": "SimdBench_118_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <algorithm>\n#include <vector>\n#include <climits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums){\n    if (nums.empty()) return 0;\n\n    size_t size = nums.size();\n    int64_t current_min = nums[0];\n    int64_t global_min = nums[0];\n\n    const size_t vlmax = vsetvl_e64m1(1);\n    vint64m1_t vcurrent_min = vmv_v_x_i64m1(nums[0], vlmax);\n    vint64m1_t vglobal_min = vmv_v_x_i64m1(nums[0], vlmax);\n\n    for(size_t i = 1; i < size; ){\n        size_t vl = vsetvl_e64m1(std::min((size_t)vlmax, size - i));\n        vint64m1_t vnums = vle_v_i64m1(&nums[i], vl);\n        \n        vcurrent_min = vmv_v_x_i64m1(current_min, vl);\n        vcurrent_min = vfmin_vv_i64m1(vnums, vadd_vv_i64m1(vcurrent_min, vnums, vl), vl);\n        \n        vglobal_min = vfmin_vv_i64m1(vglobal_min, vcurrent_min, vl);\n\n        // Extract the minimum value from vector\n        int64_t temp_min = vminreduce_siv_i64m1(vglobal_min, vl);\n        global_min = std::min(global_min, temp_min);\n\n        i += vl;\n    }\n\n    return global_min;\n}\n```"}
{"task_id": "SimdBench_118_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <algorithm>\n#include <limits>\n#include <vector>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums){\n    if (nums.empty()) return 0;\n\n    size_t vl = vsetvl_e64m1(nums.size());\n    vint64m1_t v_min_sum = vmv_v_x_i64m1(std::numeric_limits<int64_t>::max(), vl);\n    vint64m1_t v_current_min = vmv_v_x_i64m1(0, vl);\n\n    for(size_t i = 0; i < nums.size(); i += vl){\n        size_t current_vl = std::min(vl, (size_t)(nums.size() - i));\n        vint64m1_t v_nums = lv_int64_v_i64m1(nums.data() + i, current_vl);\n\n        v_current_min = vfmin_vv_i64m1(v_nums, vadd_vv_i64m1(v_current_min, v_nums, vl), vl);\n        v_min_sum = vfmin_vv_i64m1(v_min_sum, v_current_min, vl);\n    }\n\n    int64_t result = std::numeric_limits<int64_t>::max();\n    for(size_t i = 0; i < vl; ++i){\n        int64_t temp;\n        sv_int64_v_i64m1(&temp, v_min_sum, i, vl);\n        result = std::min(result, temp);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_118_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <limits.h>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums){\n    if (nums.empty()) return 0;\n\n    size_t size = nums.size();\n    int64_t current_min = nums[0];\n    int64_t global_min = nums[0];\n\n    size_t vl = vsetvl_e64m1(size);\n    vint64m1_t vcurrent_min = vmv_v_x_i64m1(nums[0], vl);\n    vint64m1_t vglobal_min = vmv_v_x_i64m1(nums[0], vl);\n\n    for(size_t i = 1; i < size; i += vl){\n        size_t sub_size = (size - i) > vl ? vl : (size - i);\n        vl = vsetvl_e64m1(sub_size);\n        vint64m1_t vtemp = vle64_v_i64m1(&nums[i], vl);\n        vcurrent_min = vmv_v_x_i64m1(current_min, vl);\n        vcurrent_min = vfmin_vv_i64m1(vtemp, vadd_vv_i64m1(vcurrent_min, vtemp, vl), vl);\n        vglobal_min = vfmin_vv_i64m1(vglobal_min, vcurrent_min, vl);\n\n        // Reduction to find the minimum in vector\n        for(int j=0; j<sub_size; j++){\n            int64_t temp = vget_v_i64m1_i64(vglobal_min, j);\n            if(temp < global_min){\n                global_min = temp;\n            }\n        }\n    }\n    return global_min;\n}\n```"}
{"task_id": "SimdBench_118_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <limits.h>\n#include <algorithm>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums){\n    if (nums.empty()) return 0;\n\n    size_t n = nums.size();\n    size_t vl = vsetvl_e64m1(n);\n\n    vint64m1_t vmin = vmv_v_x_i64m1(INT64_MAX, vl);\n    vint64m1_t vcurrent_min = vmv_v_x_i64m1(0, vl);\n\n    for(size_t i = 0; i < n; i += vl){\n        size_t chunk_size = std::min(vl, n - i);\n        vint64m1_t vchunk = vle64_v_i64m1((const int64_t*)&nums[i], chunk_size);\n\n        vcurrent_min = vfadd_vv_i64m1(vcurrent_min, vchunk, chunk_size);\n        vbool64_t mask = vlgt_vx_i64m1_b64(vcurrent_min, vchunk, chunk_size);\n        vcurrent_min = vmerge_vvm_i64m1(vcurrent_min, vchunk, mask, chunk_size);\n\n        vmin = vmin_vv_i64m1(vmin, vcurrent_min, chunk_size);\n    }\n\n    int64_t result = vminreduce_min_i64m1(vmin, vl);\n    return result;\n}\n```"}
{"task_id": "SimdBench_119_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity){\n    if (grid.empty() || grid[0].empty()) return 0;\n\n    size_t num_wells = grid.size();\n    size_t well_length = grid[0].size();\n    int total_drops = 0;\n\n    size_t vlmax = vsetvl_e8m1(well_length);\n    uint8_t vmask[vlmax];\n    for(size_t i = 0; i < well_length; ++i) vmask[i] = 1;\n\n    for(size_t i = 0; i < num_wells; ++i){\n        const uint8_t *well_data = reinterpret_cast<const uint8_t*>(&grid[i][0]);\n        size_t vl = vlmax;\n        size_t j = 0;\n\n        uint64_t sum = 0;\n        while(j < well_length){\n            vuint8m1_t vw = vle8_v_u8m1(well_data + j, vl);\n            uint64_t chunk_sum = vmv_x_s_u8m1_u64(vredsum_vs_u8_u64(vw, 0, vl));\n            sum += chunk_sum;\n            j += vl;\n        }\n        total_drops += (sum + capacity - 1) / capacity;\n    }\n\n    return total_drops;\n}\n```"}
{"task_id": "SimdBench_119_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity){\n    if (grid.empty() || grid[0].empty()) return 0;\n\n    size_t m = grid.size();\n    size_t n = grid[0].size();\n\n    size_t vl = vsetvl_e32m1(n);\n    uint32_t vs = 0;\n    for(size_t i = 0; i < m; ++i){\n        const uint32_t *row_ptr = reinterpret_cast<const uint32_t*>(grid[i].data());\n        size_t j = 0;\n        uint32_t sum = 0;\n        for(; j + vl <= n; j += vl){\n            vuint32m1_t vrow = lvu32_v(row_ptr + j, vl);\n            vuint32m1_t vones = vmv_v_x_u32m1(1, vl);\n            vbool4_t vmask = vmseq_vv_b4m1(vrow, vones, vl);\n            sum += vpopc_m_u32_m(vmask, vrow, vl);\n        }\n        for(; j < n; ++j){\n            sum += row_ptr[j];\n        }\n        vs += (sum + capacity - 1) / capacity;\n    }\n    return vs;\n}\n```"}
{"task_id": "SimdBench_119_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity){\n    if (grid.empty() || grid[0].empty()) return 0;\n\n    size_t num_wells = grid.size();\n    size_t well_length = grid[0].size();\n    int total_drops = 0;\n\n    size_t vl = vsetvl_e32m1(well_length);\n    vuint32m1_t vzero = vmv_v_x_u32m1(0, vl);\n\n    for (size_t i = 0; i < num_wells; ++i) {\n        const std::vector<int>& well = grid[i];\n        vuint32m1_t vsum = vmv_v_x_u32m1(0, vl);\n\n        for (size_t j = 0; j < well_length; j += vl) {\n            size_t vl_j = std::min(vl, well_length - j);\n            uint32_t* well_ptr = reinterpret_cast<uint32_t*>(&well[j]);\n            vuint32m1_t vwell = vle32_v_u32m1(well_ptr, vl_j);\n            vsum = vadd_vx_u32m1(vsum, 1, vl_j);\n            vsum = vand_vv_u32m1(vsum, vwell, vl_j);\n        }\n\n        uint32_t sum = 0;\n        vredsum_vs_u32m1_u32m1(&sum, vsum, vzero, vl);\n        total_drops += (sum + capacity - 1) / capacity;\n    }\n\n    return total_drops;\n}\n```"}
{"task_id": "SimdBench_119_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity){\n    if (grid.empty() || grid[0].empty()) return 0;\n\n    size_t m = grid.size();\n    size_t n = grid[0].size();\n\n    size_t vl = vsetvl_e32m1(n);\n    size_t num_buckets = 0;\n\n    for (size_t i = 0; i < m; ++i) {\n        const int *row = grid[i].data();\n        vuint32m1_t v_row = vmv_v_x_u32m1(0, vl);\n        for(size_t j = 0; j < n; j += vl){\n            size_t sub_n = std::min(n - j, (size_t)vl);\n            vuint32m1_t v_temp = vle32_v_u32m1(row + j, sub_n);\n            v_row = vor_vv_u32m1(v_row, v_temp, sub_n);\n        }\n        uint32_t sum = vmv_x_s_u32m1_u32(vredsum_vs_u32m1_u32m1(vmv_v_x_u32m1(0, vl), v_row, vl));\n        num_buckets += (sum + capacity - 1) / capacity;\n    }\n\n    return num_buckets;\n}\n```"}
{"task_id": "SimdBench_119_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity){\n    if (grid.empty() || grid[0].empty()) return 0;\n\n    size_t num_wells = grid.size();\n    size_t well_length = grid[0].size();\n    int total_drops = 0;\n\n    size_t vlmax = vsetvl_e32m1(well_length);\n    for(size_t i = 0; i < num_wells; ++i){\n        const int *well_ptr = grid[i].data();\n        size_t vl = vlmax;\n        uint32_t sum = 0;\n\n        while (vl != 0) {\n            vuint32m1_t vw = vle32_v_u32m1(well_ptr, vl);\n            uint32_t red_sum = vmv_x_s_u32m1_u32(vredsum_vs_u32m1_u32m1(vw, vw, vl));\n            sum += red_sum;\n            vl = vsetvl_e32m1(vl / 2);\n            well_ptr += vlmax - vl;\n        }\n        total_drops += (sum + capacity - 1) / capacity;\n    }\n    return total_drops;\n}\n```"}
{"task_id": "SimdBench_120_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst){\n    int64_t result = 0;\n    size_t size = lst.size();\n    if (size == 0) return result;\n\n    size_t i = 0;\n    const int16_t* ptr = lst.data();\n    size_t vlmax = vsetvl_e16m1(size);\n\n    while (i < size) {\n        size_t vl = vsetvl_e16m1(size - i);\n        vint16m1_t vmask = vmseq_vx_i16m1(i & 1, 0, vl); // Even positions mask\n        vint16m1_t vdata = vle16_v_i16m1(ptr + i, vl); // Load data\n        vbool8_t is_odd = vmfne_vv_i16m1_b8(vdata, vmul_vx_i16m1(2, vdivu_vx_i16m1(vdata, 2, vl), vl), vl); // Check odd\n        vint16m1_t filtered = vand_vvm_i16m1(vdata, vmask, vl); // Apply even position mask\n        vint16m1_t odds = vslide1up_vx_i16m1(filtered, 0, is_odd, vl); // Select odd elements\n        int32_t sum =vredu_sum_siv_i16m1_i32(odds, vl); // Sum the selected elements\n        result += sum;\n        i += vl;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_120_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst){\n    int64_t sum = 0;\n    size_t size = lst.size();\n    if (size == 0) return sum;\n\n    size_t vl = vsetvl_e16m1(size);\n    vint16m1_t v_zero = vmv_v_x_i16m1(0, vl);\n\n    for(size_t i = 0; i < size; i += vl){\n        size_t chunk_size = (size - i) > vl ? vl : (size - i);\n        vint16m1_t v_src = vle16_v_i16m1((const int16_t*)&lst[i], chunk_size);\n        \n        // Create a mask for even indices\n        vbool8_t vmask_even = vmseq_vx_i16m1_b8(vmv_v_x_i16m1(i, chunk_size), 0, chunk_size);\n        for(size_t j = 1; j < chunk_size; ++j){\n            vmask_even = vfmerge_vvm_b8(vmask_even, vmseq_vx_i16m1_b8(vadd_vx_i16m1(vmv_v_x_i16m1(j, chunk_size), j, chunk_size), 0, chunk_size), vmask_even, chunk_size);\n        }\n\n        // Apply the mask to get elements at even positions\n        vint16m1_t v_even = vm\u4e58_vvm_i16m1(v_src, vmask_even, v_zero, chunk_size);\n\n        // Check for odd values\n        vbool8_t vmask_odd = vmodor_v_i16m1_b8(v_and_vv_i16m1(v_even, vmv_v_x_i16m1(1, chunk_size), chunk_size));\n\n        // Mask out non-odd values\n        vint16m1_t v_odd = vm\u4e58_vvm_i16m1(v_even, vmask_odd, v_zero, chunk_size);\n\n        // Calculate partial sums\n        vint16m1_t v_sum = vredsum_vs_i16m1_i16m1(v_odd, v_zero, chunk_size);\n\n        // Accumulate to total sum\n        sum += (int64_t)vget_v_i16m1_i16(v_sum, 0);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst){\n    uint32_t vlen = vsetvl_e16m1(lst.size());\n    vint16m1_t v_lst = vle16_v_i16m1((const int16_t*)lst.data(), vlen);\n    vbool8_t mask_even_idx = vmseq_vv_b8m1(vget_vi_u16m2(0, vlen), vslide1up_vx_i16m1(vget_vi_u16m2(0, vlen), 1, vlen), vlen);\n    vbool8_t mask_odd_val = vmne_vv_b8m1(v_lst, vslide1down_vx_i16m1(v_lst, 1, vlen), vlen);\n    vbool8_t combined_mask = vand_vv_b8m1(mask_even_idx, mask_odd_val, vlen);\n    vint16m1_t filtered = vmseq_vv_i16m1_m(combined_mask, v_lst, v_lst, v_lst, vlen);\n    int32_t sum = (int32_t)vredsum_vs_i16m1_i32m2(filtered, vget_vi_i32m2(0, vlen / 2), vlen / 2);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst){\n    int64_t sum = 0;\n    size_t size = lst.size();\n    if (size == 0) return sum;\n\n    size_t i = 0;\n    size_t vl = vsetvl_e16m1(size);\n    vint16m1_t vmask, vdata, vzero, vrem, vodd;\n\n    vzero = vm_vle16_v_i16m1((const int16_t *)&lst[0], vl);\n    for(i = 0; i < size; i += vl){\n        vl = vsetvl_e16m1(size - i);\n        vdata = vm_vle16_v_i16m1((const int16_t *)&lst[i], vl);\n        vmask = vmseq_vx_i16m1_b1(vdata, 0, vl);\n        vrem = vmsub_vx_i16m1(vdata, 1, vl);\n        vodd = vmrem_vx_i16m1(vrem, 2, vl);\n        vdata = vm_and_vv_i16m1(vdata, vodd, vl);\n        sum += vmv_sra_x_i64(vm_sum_reduce_add_vs_i16m1_i64(vdata, vzero, vl));\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst){\n    uint32_t vlen = 0;\n    size_t vlmax = vsetvl_e16m1(vlen);\n    int16_t *data = const_cast<int16_t*>(lst.data());\n    size_t size = lst.size();\n    int64_t sum = 0;\n\n    for(size_t i = 0; i < size; i += vlmax * 2){\n        size_t vl = vsetvl_e16m1(size - i > vlmax ? vlmax : size - i);\n        vint16m1_t vmask = vmseq_vx_i16m1(data + i, 0, vl);\n        vbool8_t is_odd = vmseq_vx_b8mf4(vmask, 1, vl);\n        vint16m1_t vec = vle16_v_i16m1(data + i, vl);\n        vint16m1_t filtered = vmadd_vim_i16m1(vec, is_odd, 0, vl);\n        int16_t temp_sum = 0;\n        for(size_t j = 0; j < vl; ++j){\n            if( (i + j) % 2 == 0 ){\n                temp_sum += (int16_t)vget_v_i16m1(filtered, j);\n            }\n        }\n        sum += temp_sum;\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k){\n    int vl = vsetvl_e32m1(k);\n    vint32m1_t v_arr = vle32_v_i32m1(arr.data(), vl);\n    vbool8_t mask = (vabsu_v_i32m1_i32(v_arr, vl) < 100);\n    vint32m1_t filtered = vmaskedoff_v_i32m1(v_arr, v_arr, mask, vl);\n    int sum = 0;\n    for(int i = 0; i < k; ++i){\n        if((arr[i] >= -99) && (arr[i] <= 99)){\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nint add_elements_simd(std::vector<int> arr, int k){\n    int sum = 0;\n    size_t vlmax = vsetvl_e32m1(k);\n    int *arr_ptr = arr.data();\n\n    for(size_t i = 0; i < k; i += vlmax){\n        size_t vl = vsetvl_e32m1(std::min((int)(k - i), (int)vlmax));\n        vint32m1_t vmask = vmleu_vx_i32m1_b(true, 99, vl); // Create mask where elements <= 99\n        vint32m1_t v_arr = vle32_v_i32m1(arr_ptr + i, vl); // Load vector elements\n        vint32m1_t v_filtered = vmadd_vx_i32m1(v_arr, 0, 0, vmask, vl); // Apply mask to filter elements\n\n        // Horizontal sum of filtered elements\n        int temp_sum = 0;\n        for(size_t j = 0; j < vl; ++j){\n            if(vmask[j]){\n                temp_sum += vfiltered[j];\n            }\n        }\n        sum += temp_sum;\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k){\n    int sum = 0;\n    size_t arr_size = arr.size();\n    size_t vlmax = vsetvl_e32m1(k);\n    \n    for(size_t i=0; i < arr_size; i+=vlmax){\n        size_t vl = vsetvl_e32m1(k - i > vlmax ? vlmax : k - i);\n        vint32m1_t v_arr = vle32_v_i32m1((int*)&arr[i], vl);\n        vbool8_t mask = vmagge_vx_i32m1_b8(v_arr, 100, vl);\n        vint32m1_t filtered = vmseq_vv_i32m1(v_arr, v_arr, vl); // Keep original values\n        filtered = vmfalsedm_v_i32m1(filtered, mask, vl); // Zero out elements >= 100\n        int result = vmv_x_s_i32m1_i32(vredsum_vs_i32m1_i32m1_v(filtered, 0, vl));\n        sum += result;\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k){\n    int vl = vsetvl_e32m1(k);\n    vuint32m1_t v_arr = vmv_v_x_u32m1(0, vl);\n    vuint32m1_t v_mask = vmv_v_x_u32m1(0, vl);\n    uint32_t sum = 0;\n\n    for(int i = 0; i < k; i += vl){\n        vl = vsetvl_e32m1(k - i);\n        v_arr = vle32_v_u32m1(arr.data() + i, vl);\n        v_mask = vmge_vx_u32m1_b8(v_arr, -99, vl);\n        v_mask = vmandnot_vm_b8(v_mask, vmle_vx_u32m1_b8(v_arr, 99, vl), vl);\n        v_arr = vand_vv_u32m1(v_arr, v_mask, vl);\n        sum += vmv_x_s_u32m1_u32(vredsum_vs_u32m1_u32m1(v_arr, vmv_v_x_u32m1(0, vl), vl));\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <climits>\n\nint add_elements_simd(std::vector<int> arr, int k){\n    int vl = vsetvl_e32m1(k);\n    vuint32m1_t v_arr = vle32_v_u32m1(arr.data(), vl);\n    vbool32_t mask = (v_arr >= -99) & (v_arr <= 99);\n    vuint32m1_t v_filtered = vmadd_vx_u32m1(v_arr, 0, 0, mask);\n    uint32_t sum = 0;\n    sum = vredsum_vs_u32m1_u32m1_u32(0, v_filtered, vl);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_122_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <stdalign.h>\n#include <cstring>\n\nbool is_sorted_simd(const std::vector<int> & lst){\n    if (lst.size() <= 1) return true;\n\n    size_t vl = vsetvl_e32m1(lst.size()-1);\n    alignas(64) int32_t data[lst.size()];\n    std::memcpy(data, lst.data(), lst.size() * sizeof(int));\n\n    vint32m1_t v0 = vmv_v_x_i32m1(0, vl);\n    vint32m1_t prev = vlsege32_v_i32m1(v0, data, 1, vl);\n    vbool32_t mask = true;\n\n    for(size_t i = 1; i < lst.size(); i += vl){\n        size_t subvl = vsetvl_e32m1(std::min<size_t>(vl, lst.size() - i));\n        vint32m1_t curr = vlsege32_v_i32m1(v0, &data[i], 1, subvl);\n        vbool32_t cmp_ge = vmge_vv_i32m1_b32(curr, prev, subvl);\n        vbool32_t cmp_eq = vmseq_vv_i32m1_b32(curr, prev, subvl);\n\n        // Check if any element is smaller than the previous one\n        if(!vmall_t_b32(cmp_ge, subvl)) return false;\n\n        // Count duplicates and ensure no more than one duplicate exists\n        vuint32m1_t count = vmseq_vx_i32m1_u32(prev, data[i-1], subvl);\n        uint32_t total_duplicates = vmcnt_m_u32m1(count, mask, subvl);\n        if(total_duplicates > 1) return false;\n\n        prev = curr;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <stdc++/vector>\n\nbool is_sorted_simd(const std::vector<int> & lst){\n    if (lst.size() <= 1) return true;\n\n    size_t vl = vsetvl_e32m1(lst.size()-1);\n    vint32m1_t v0 = vmv_v_x_i32m1(0, vl);\n\n    for(size_t i = 0; i < lst.size()-1; i+=vl){\n        size_t subvl = vsetvl_e32m1(std::min(vl, (size_t)(lst.size()-1 - i)));\n        vint32m1_t v_curr = vle32_v_i32m1((const int*)&lst[i], subvl);\n        vint32m1_t v_next = vle32_v_i32m1((const int*)&lst[i+1], subvl);\n        \n        vbool32m1_t cmp_ge = vmge_vv_b32m1(v_curr, v_next, subvl);\n        if (vfirst_m_b32m1(cmp_ge, subvl) != -1) return false;\n\n        vbool32m1_t cmp_eq = vmseq_vv_b32m1(v_curr, v_next, subvl);\n        vint32m1_t count_ones = vredsum_vs_i32m1_i32(v0, cmp_eq, subvl);\n        if (vmv_x_s_i32m1_i32(count_ones, subvl) > 1) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <stdalign.h>\n#include <cstring>\n\nbool is_sorted_simd(const std::vector<int> & lst){\n    if (lst.size() <= 1) return true;\n\n    size_t vl = vsetvl_e32m1(lst.size() - 1);\n    vuint32m1_t v0 = vmv_v_x_u32m1(0, vl);\n\n    alignas(64) int32_t src_arr[lst.size()];\n    std::memcpy(src_arr, lst.data(), lst.size() * sizeof(int));\n\n    vuint32m1_t v_src = vle32_v_u32m1(src_arr, vl);\n    vuint32m1_t v_src_next = vle32_v_u32m1(&src_arr[1], vl);\n\n    vbool32m1_t cmp_lt = vmultne_vv_b32m1(v_src, v_src_next, vl);\n    vbool32m1_t cmp_eq = vmseq_vv_b32m1(v_src, v_src_next, vl);\n\n    uint32_t mask_lt = vmv_x_s_b32m1_b_u32(cmp_lt, vl);\n    uint32_t mask_eq = vmv_x_s_b32m1_b_u32(cmp_eq, vl);\n\n    if (~mask_lt != 0) return false;\n\n    // Check for more than one duplicate\n    int count_eq = __builtin_popcount(mask_eq);\n    if (count_eq > 1) return false;\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <stdc++-vectors>\n\nbool is_sorted_simd(const std::vector<int> & lst){\n    if (lst.size() <= 1) return true;\n\n    size_t vl = vsetvl_e32m1(lst.size()-1);\n    vint32m1_t v_curr = vmv_v_x_i32m1(0, vl);\n    vint32m1_t v_next = vmv_v_x_i32m1(0, vl);\n\n    const int *data = lst.data();\n    for(size_t i = 0; i + vl <= lst.size() - 1; i += vl){\n        v_curr = vle32_v_i32m1(data + i, vl);\n        v_next = vle32_v_i32m1(data + i + 1, vl);\n\n        vbool32_t cmp_ge = vmge_vv_b32m1(v_next, v_curr, vl);\n        vbool32_t cmp_eq = vmseq_vv_b32m1(v_next, v_curr, vl);\n\n        if(!vmall_t_b32m1(cmp_ge, vl)) return false;\n\n        // Check duplicates\n        uint32_t eq_count = vmopop_count_m(cmp_eq, vl);\n        if(eq_count > 1) return false;\n    }\n\n    // Handle leftover elements\n    size_t i = (lst.size() - 1) / vl * vl;\n    if(i < lst.size() - 1){\n        vl = vsetvl_e32m1(lst.size() - i - 1);\n        v_curr = vle32_v_i32m1(data + i, vl);\n        v_next = vle32_v_i32m1(data + i + 1, vl);\n\n        vbool32_t cmp_ge = vmge_vv_b32m1(v_next, v_curr, vl);\n        vbool32_t cmp_eq = vmseq_vv_b32m1(v_next, v_curr, vl);\n\n        if(!vmall_t_b32m1(cmp_ge, vl)) return false;\n\n        uint32_t eq_count = vmopop_count_m(cmp_eq, vl);\n        if(eq_count > 1) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <stdc++/vector>\n\nbool is_sorted_simd(const std::vector<int> & lst){\n    if (lst.size() <= 1) return true;\n\n    size_t vl = vsetvl_e32m1(lst.size()-1);\n    vint32m1_t v0 = vmv_v_x_i32m1(0, vl);\n    vbool32_t vmask = vmsne_vx_i32m1_b32(v0, 0, vl);\n\n    for(size_t i = 0; i < lst.size()-1; i += vl){\n        size_t subvl = vsetvl_e32m1(std::min(vl, lst.size()-1 - i));\n        vint32m1_t vcur = vle32_v_i32m1((const int *)&lst[i], subvl);\n        vint32m1_t vnext = vle32_v_i32m1((const int *)&lst[i+1], subvl);\n        \n        vbool32_t vcmp_ge = vmge_vv_i32m1_b32(vcur, vnext, subvl);\n        vbool32_t vcmp_eq = vmseq_vv_i32m1_b32(vcur, vnext, subvl);\n\n        int reduce_ge = vmfirst_m_b32_i32(vmask, vcmp_ge, subvl);\n        int reduce_eq = vmfirst_m_b32_i32(vmask, vcmp_eq, subvl);\n\n        if(reduce_ge || reduce_eq > 1){\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_123_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr){\n    if (arr.empty()) return -32768;\n\n    size_t size = arr.size();\n    int result = 0;\n    int sign_product = 1;\n\n    // Vector length and type setup\n    size_t vl = vsetvl_e32m1(size);\n    vint32m1_t v_zero = vmv_v_x_i32m1(0, vl);\n    vbool4_t mask = vmsne_vx_i32m1_b4(v_zero, 0, vl);\n\n    for (size_t i = 0; i < size; i += vl) {\n        size_t chunk_size = std::min(size - i, vl);\n\n        // Load vector data\n        vint32m1_t v_data = vle32_v_i32m1(arr.data() + i, chunk_size);\n\n        // Compute absolute values\n        vuint32m1_t v_abs_data = vabsu_v_i32m1(v_data, chunk_size);\n\n        // Sum of magnitudes\n        vint32m1_t v_sum = vredsum_vs_i32m1_i32m1(v_abs_data, v_zero, chunk_size);\n        result += vmv_x_s_i32m1_i32(v_sum);\n\n        // Compute signs (-1, 0, 1)\n        vint32m1_t v_signs = vsign_vx_i32m1(v_data, 1, chunk_size);\n\n        // Product of signs\n        vint32m1_t v_prod_signs = vredprod_vs_i32m1_i32m1(v_signs, v_zero, chunk_size);\n        sign_product *= vmv_x_s_i32m1_i32(v_prod_signs);\n    }\n\n    return result * sign_product;\n}\n```"}
{"task_id": "SimdBench_123_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr){\n    if (arr.empty()) return -32768;\n\n    size_t size = arr.size();\n    int result = 0;\n    int sign_product = 1;\n\n    // Vector configuration\n    size_t vl = vsetvl_e32m1(size);\n    vint32m1_t v0 = vmv_v_x_i32m1(0, vl);\n\n    for (size_t i = 0; i < size; i += vl) {\n        size_t chunk_size = (size - i) > vl ? vl : (size - i);\n        vint32m1_t v_arr = vle32_v_i32m1((const int *)&arr[i], chunk_size);\n\n        // Compute absolute values\n        vuint32m1_t v_abs = vuabsu_v_u32m1(v_arr, chunk_size);\n\n        // Sum of magnitudes\n        v0 = vadd_vv_i32m1(v0, (vint32m1_t)v_abs, chunk_size);\n\n        // Compute signs (-1, 0, 1)\n        vbool4_t v_sign_neg = vlne_vx_i32m1(v_arr, 0, chunk_size);\n        vbool4_t v_sign_pos = vge_vx_i32m1(v_arr, 0, chunk_size);\n        vint32m1_t v_signs = vsub_vv_i32m1(vmux_vvm_i32m1(v_arr, v_sign_pos, v_sign_neg, chunk_size), v0, chunk_size);\n\n        // Reduce signs to scalar product\n        int temp_signs = 1;\n        for (size_t j = 0; j < chunk_size; ++j) {\n            int current_sign = (i + j < size) ? ((arr[i + j] > 0) - (arr[i + j] < 0)) : 1;\n            temp_signs *= current_sign;\n        }\n        sign_product *= temp_signs;\n    }\n\n    // Horizontal sum of magnitudes\n    int sum_magnitudes = 0;\n    for (size_t i = 0; i < vl; ++i) {\n        sum_magnitudes += vmv_x_s_i32m1_i32(v0);\n    }\n\n    return sign_product * sum_magnitudes;\n}\n```"}
{"task_id": "SimdBench_123_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr){\n    if (arr.empty()) return -32768;\n\n    size_t size = arr.size();\n    int result = 0;\n    int sign_product = 1;\n\n    // Vector length and data type\n    size_t vl = vsetvl_e32m1(size);\n    vint32m1_t v_zero = vmv_v_x_i32m1(0, vl);\n    vint32m1_t v_one = vmv_v_x_i32m1(1, vl);\n    vint32m1_t v_neg_one = vmv_v_x_i32m1(-1, vl);\n\n    for (size_t i = 0; i < size; i += vl) {\n        size_t chunk_size = std::min(size - i, vl);\n        vint32m1_t v = vle32_v_i32m1((const int *)&arr[i], chunk_size);\n\n        // Compute signs\n        vbool32_t is_positive = vmge_vx_i32m1_b32(v, 0, chunk_size);\n        vbool32_t is_negative = vmlt_vx_i32m1_b32(v, 0, chunk_size);\n        vbool32_t is_zero = vmseq_vx_i32m1_b32(v, 0, chunk_size);\n\n        vint32m1_t v_sign = vmux_vvm_i32m1(v_one, is_positive, v_zero, chunk_size);\n        v_sign = vmux_vvm_i32m1(v_neg_one, is_negative, v_sign, chunk_size);\n\n        // Update sign product\n        int current_sign_product = 1;\n        for (size_t j = 0; j < chunk_size; ++j) {\n            int sign = is_zero[j] ? 0 : (is_positive[j] ? 1 : -1);\n            current_sign_product *= sign;\n        }\n        sign_product *= current_sign_product;\n\n        // Compute magnitudes\n        vuint32m1_t v_magnitude = vmabsu_v_i32m1(v, chunk_size);\n\n        // Sum magnitudes\n        int sum = 0;\n        for (size_t j = 0; j < chunk_size; ++j) {\n            sum += v_magnitude[j];\n        }\n        result += sum;\n    }\n\n    return result * sign_product;\n}\n```"}
{"task_id": "SimdBench_123_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr){\n    if (arr.empty()) return -32768;\n\n    size_t size = arr.size();\n    int result = 0;\n    int sign_product = 1;\n\n    // Vector length and data type\n    size_t vl = vsetvl_e32m1(size);\n    vint32m1_t v_zero = vmv_v_x_i32m1(0, vl);\n    vint32m1_t v_one = vmv_v_x_i32m1(1, vl);\n    vint32m1_t v_neg_one = vmv_v_x_i32m1(-1, vl);\n\n    for (size_t i = 0; i < size; i += vl) {\n        size_t chunk_size = std::min(size - i, vl);\n        vint32m1_t v = vle32_v_i32m1((const int *)&arr[i], chunk_size);\n\n        // Compute signs\n        vbool32_t is_positive = vmge_vx_i32m1_b32(v, 0, chunk_size);\n        vbool32_t is_negative = vmlt_vx_i32m1_b32(v, 0, chunk_size);\n        vbool32_t is_zero = vmseq_vx_i32m1_b32(v, 0, chunk_size);\n\n        vint32m1_t v_sign = vfcvt_xu_f_v_i32m1(vmux_vvm_i32m1(v_one, v_neg_one, is_negative, chunk_size), chunk_size);\n        v_sign = vmux_vvm_i32m1(v_zero, v_sign, is_zero, chunk_size);\n\n        // Update sign product\n        int temp_sign_product = 1;\n        for (size_t j = 0; j < chunk_size; ++j) {\n            int current_sign = vsign_v_i32m1_i32(v_sign, j);\n            if (current_sign == 0) {\n                return 0;\n            }\n            temp_sign_product *= current_sign;\n        }\n        sign_product *= temp_sign_product;\n\n        // Compute magnitudes\n        vuint32m1_t v_magnitude = vabsu_v_i32m1(v, chunk_size);\n\n        // Sum of magnitudes\n        int sum = 0;\n        for (size_t j = 0; j < chunk_size; ++j) {\n            sum += vget_v_i32m1_i32(v_magnitude, j);\n        }\n        result += sum;\n    }\n\n    return result * sign_product;\n}\n```"}
{"task_id": "SimdBench_123_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr){\n    if (arr.empty()) return -32768;\n\n    size_t size = arr.size();\n    int result = 0;\n    int sign_product = 1;\n\n    // Vector length and data type\n    size_t vl = vsetvl_e32m4(size);\n    vint32m4_t v_zero = vmv_v_x_i32m4(0, vl);\n    vint32m4_t v_one = vmv_v_x_i32m4(1, vl);\n    vint32m4_t v_neg_one = vmv_v_x_i32m4(-1, vl);\n\n    for (size_t i = 0; i < size; i += vl) {\n        size_t chunk_size = std::min(size - i, vl);\n        vint32m4_t v_arr = vle32_v_i32m4(&arr[i], chunk_size);\n\n        // Compute signs\n        vbool32_t is_positive = vmge_vx_i32m4_b32(v_arr, 0, chunk_size);\n        vbool32_t is_negative = vmlt_vx_i32m4_b32(v_arr, 0, chunk_size);\n        vbool32_t is_zero = vmseq_vx_i32m4_b32(v_arr, 0, chunk_size);\n\n        vint32m4_t v_signs = vfredosum_vs_i32m4_i32(vmerge_vvm_i32m4(v_one, v_neg_one, is_positive, chunk_size), v_zero, chunk_size);\n        v_signs = vmerge_vvm_i32m4(v_zero, v_signs, is_zero, chunk_size);\n\n        // Update sign product\n        int scalar_sign_product = 1;\n        for (size_t j = 0; j < chunk_size; ++j) {\n            int current_sign = vmv_x_s_i32m4_i32(vsign_v_i32m4(v_arr, chunk_size));\n            if (current_sign == 0) {\n                return 0;\n            }\n            scalar_sign_product *= (current_sign > 0) ? 1 : -1;\n        }\n        sign_product *= scalar_sign_product;\n\n        // Compute sum of magnitudes\n        vuint32m4_t v_magnitudes = vabsu_v_i32m4(v_arr, chunk_size);\n        uint32_t sum_magnitudes = vredsum_vs_u32m4_u32(vmv_v_x_u32m4(0, chunk_size), v_magnitudes, chunk_size);\n        result += sum_magnitudes;\n    }\n\n    return result * sign_product;\n}\n```"}
{"task_id": "SimdBench_124_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k){\n    int N = grid.size();\n    std::vector<int> result(k);\n    if (k == 0) return result;\n\n    // Flatten the grid into a single vector for easier SIMD access\n    std::vector<int> flat_grid;\n    for (const auto& row : grid) {\n        flat_grid.insert(flat_grid.end(), row.begin(), row.end());\n    }\n\n    int vl = vsetvl_e32m1(k);\n    size_t min_index = 0;\n    int current_min = flat_grid[0];\n\n    for (size_t i = 0; i < N * N; ++i) {\n        if (flat_grid[i] < current_min) {\n            current_min = flat_grid[i];\n            min_index = i;\n        }\n    }\n\n    result[0] = flat_grid[min_index];\n    int prev = min_index;\n\n    for (int step = 1; step < k; ++step) {\n        int best_val = INT32_MAX;\n        size_t best_idx = prev;\n\n        // Define neighborhood bounds\n        int row = prev / N;\n        int col = prev % N;\n\n        // Collect neighbors\n        std::vector<int> candidates;\n        std::vector<size_t> indices;\n\n        for (int dr = -1; dr <= 1; ++dr) {\n            for (int dc = -1; dc <= 1; ++dc) {\n                if (dr == 0 && dc == 0) continue;\n                int nr = row + dr;\n                int nc = col + dc;\n                if (nr >= 0 && nr < N && nc >= 0 && nc < N) {\n                    size_t idx = nr * N + nc;\n                    candidates.push_back(flat_grid[idx]);\n                    indices.push_back(idx);\n                }\n            }\n        }\n\n        // Use RVV to find the minimum value among candidates\n        size_t num_candidates = candidates.size();\n        vl = vsetvl_e32m1(num_candidates);\n\n        vint32m1_t vec_candidates = vmv_v_x_i32m1(0, vl);\n        vbool4_t mask = vmv_v_x_b4(true, vl);\n\n        for (size_t j = 0; j < num_candidates; j += vl) {\n            size_t sub_len = std::min(vl, num_candidates - j);\n            vint32m1_t temp_vec = vle32_v_i32m1(&candidates[j], sub_len);\n            vec_candidates = vmERGE_vv_i32m1(vec_candidates, temp_vec, mask, vl);\n        }\n\n        int min_candidate = vmin_vx_i32m1(vec_candidates, INT32_MAX, vl);\n        auto it = std::find(candidates.begin(), candidates.end(), min_candidate);\n        if (it != candidates.end()) {\n            size_t idx = indices[it - candidates.begin()];\n            result[step] = flat_grid[idx];\n            prev = idx;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_124_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <climits>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k){\n    int N = grid.size();\n    std::vector<int> result;\n    if (k <= 0 || N == 0) return result;\n\n    // Initialize variables\n    int vm = 0;\n    size_t vlen = sizeof(int) * N;\n    size_t vl = vsetvl_e32m1(vlen);\n\n    // Create a vector of minimum values\n    vint32m1_t vmin = vmv_v_x_i32m1(INT_MAX, vl);\n\n    for(int i = 0; i < N; ++i){\n        for(int j = 0; j < N; ++j){\n            // Start from each cell\n            std::vector<int> path;\n            path.push_back(grid[i][j]);\n            \n            // Use RVV to process neighbors in parallel\n            int current_val = grid[i][j];\n            vint32m1_t vcurrent = vmv_v_x_i32m1(current_val, vl);\n            \n            for(int step = 1; step < k; ++step){\n                vint32m1_t vneighbors = vmv_v_x_i32m1(INT_MAX, vl);\n                \n                // Check all possible moves: up, down, left, right\n                if(i > 0) {\n                    vint32m1_t vup = vmv_v_x_i32m1(grid[i-1][j], vl);\n                    vneighbors = vmin_vv_i32m1(vneighbors, vup, vl);\n                }\n                if(i < N-1) {\n                    vint32m1_t vdown = vmv_v_x_i32m1(grid[i+1][j], vl);\n                    vneighbors = vmin_vv_i32m1(vneighbors, vdown, vl);\n                }\n                if(j > 0) {\n                    vint32m1_t vleft = vmv_v_x_i32m1(grid[i][j-1], vl);\n                    vneighbors = vmin_vv_i32m1(vneighbors, vleft, vl);\n                }\n                if(j < N-1) {\n                    vint32m1_t vright = vmv_v_x_i32m1(grid[i][j+1], vl);\n                    vneighbors = vmin_vv_i32m1(vneighbors, vright, vl);\n                }\n\n                // Select the minimum neighbor\n                int min_neighbor = vmin Reduction[vneighbors];\n                path.push_back(min_neighbor);\n                current_val = min_neighbor;\n                vcurrent = vmv_v_x_i32m1(current_val, vl);\n            }\n\n            // Compare paths lexicographically and update result\n            if(result.empty() || lexicographical_compare(path.begin(), path.end(), result.begin(), result.end())){\n                result = path;\n            }\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_124_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k){\n    int N = grid.size();\n    std::vector<int> result;\n    if (k <= 0 || N == 0) return result;\n\n    // Flatten the grid into a single vector for easier SIMD access\n    std::vector<int> flat_grid;\n    for (const auto& row : grid) {\n        flat_grid.insert(flat_grid.end(), row.begin(), row.end());\n    }\n\n    int vl = vsetvl_e32m1(k);\n    vint32m1_t vmin = vmv_v_x_i32m1(0x7FFFFFFF, vl);\n    vbool4_t mask = true;\n\n    for (int i = 0; i < N * N; ++i) {\n        int current = flat_grid[i];\n        vint32m1_t vcurrent = vmv_v_x_i32m1(current, vl);\n\n        vint32m1_t vpath = vle32_v_i32m1(&flat_grid[0], vl);\n        vpath = vmule_vx_i32m1(vpath, 1, vl); // Simulate path accumulation\n\n        vmin = vmERGE_vv_i32m1(vmin, vpath, mask, vl);\n    }\n\n    // Extract the minimum path from vmin\n    for (int i = 0; i < k; ++i) {\n        result.push_back(vmve_v_x_i32m1_i32(vmin, i));\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_124_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <climits>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k){\n    int N = grid.size();\n    std::vector<int> result;\n    if (k <= 0 || N == 0) return result;\n\n    // Initialize variables for RVV\n    size_t vl = vsetvl_e32m1(k);\n    vint32m1_t v_min_path = vmv_v_x_i32m1(INT_MAX, vl);\n    vbool4_t mask = vmsltu_vx_b4(true, v_min_path, INT_MAX, vl);\n\n    for(int start_row = 0; start_row < N; ++start_row){\n        for(int start_col = 0; start_col < N; ++start_col){\n            std::vector<int> current_path;\n            current_path.push_back(grid[start_row][start_col]);\n\n            // Use RVV to process paths in parallel\n            vint32m1_t v_current_path = vmv_v_x_i32m1(grid[start_row][start_col], vl);\n            for(int step = 1; step < k; ++step){\n                int min_val = INT_MAX;\n                int next_row = -1, next_col = -1;\n                \n                for(int dr = -1; dr <=1; ++dr){\n                    for(int dc = -1; dc <=1; ++dc){\n                        if(dr == 0 && dc == 0) continue;\n                        int nr = start_row + dr * step;\n                        int nc = start_col + dc * step;\n                        if(nr >=0 && nr <N && nc >=0 && nc <N){\n                            int val = grid[nr][nc];\n                            if(val < min_val){\n                                min_val = val;\n                                next_row = nr;\n                                next_col = nc;\n                            }\n                        }\n                    }\n                }\n                if(next_row != -1 && next_col != -1){\n                    current_path.push_back(grid[next_row][next_col]);\n                    v_current_path = vle32_v_i32m1(current_path.data(), vl);\n                }\n            }\n\n            // Compare and update the minimum path using RVV\n            v_min_path = vfmin_vv_i32m1(v_min_path, v_current_path, vl);\n        }\n    }\n\n    // Extract the result from vector registers\n    for(int i=0;i<k;i++){\n        result.push_back(vmveq_x_i32m1_i32(v_min_path, i));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_124_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k){\n    int N = grid.size();\n    std::vector<int> result;\n    \n    if (k <= 0 || N == 0) return result;\n\n    // Flatten the grid for vectorized access\n    std::vector<int> flat_grid;\n    for (const auto& row : grid) {\n        flat_grid.insert(flat_grid.end(), row.begin(), row.end());\n    }\n\n    int vl = vsetvl_e32m1(k);\n    size_t total_elements = flat_grid.size();\n\n    // Initialize vectors to store path values\n    vint32m1_t v_min_path = vmv_v_x_i32m1(0x7FFFFFFF, vl);\n    vint32m1_t v_current_path;\n\n    for (size_t start = 0; start < total_elements; ++start) {\n        v_current_path = vmv_v_x_i32m1(grid[start / N][start % N], vl);\n\n        // Simulate path exploration using neighbors\n        for (int step = 1; step < k; ++step) {\n            vint32m1_t v_candidate = vmv_v_x_i32m1(0x7FFFFFFF, vl);\n            for (int dr = -1; dr <= 1; ++dr) {\n                for (int dc = -1; dc <= 1; ++dc) {\n                    if (dr == 0 && dc == 0) continue;\n                    for (int idx = 0; idx < vl; ++idx) {\n                        int r = (start / N) + dr;\n                        int c = (start % N) + dc;\n                        if (r >= 0 && r < N && c >= 0 && c < N) {\n                            int val = grid[r][c];\n                            v_candidate = vmin_vv_i32m1(v_candidate, vmv_v_x_i32m1(val, vl), vl);\n                        }\n                    }\n                }\n            }\n            v_current_path = vle32_v_i32m1((int*)&v_candidate, vl);\n        }\n\n        // Compare current path with minimum path\n        v_min_path = vmin_vv_i32m1(v_min_path, v_current_path, vl);\n    }\n\n    // Extract the result from vector\n    result.resize(k);\n    vse32_v_i32m1(result.data(), v_min_path, vl);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_125_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t digits_simd(uint64_t n){\n    uint64_t product = 1;\n    uint8_t has_odd = 0;\n\n    while (n > 0) {\n        size_t vl = vsetvl_e8m1(10);\n        vuint8m1_t v_digits = vmv_v_x_u8m1(n % 10, vl);\n        vuint8m1_t v_ones = vmv_v_x_u8m1(1, vl);\n        vuint8m1_t v_twos = vmv_v_x_u8m1(2, vl);\n        \n        vbool8_t is_odd = vmseq_vv_b8m1(v_digits, v_twos, vl);\n        vuint8m1_t odd_digits = vand_vv_u8m1(v_digits, is_odd, vl);\n        \n        vuint8m1_t v_product = vmul_vv_u8m1(v_product, odd_digits, vl);\n        uint8_t temp_product = vmfirst_u8m1(v_product, vl);\n        \n        if (temp_product != 0) {\n            product *= temp_product;\n            has_odd = 1;\n        }\n        n /= 10;\n    }\n\n    return has_odd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_125_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t digits_simd(uint64_t n){\n    uint64_t result = 1;\n    int all_even = 0;\n\n    size_t vl = vsetvl_e8m1(10);\n    vuint8m1_t vzero = vmv_v_x_u8m1(0, vl);\n    vuint8m1_t vone = vmv_v_x_u8m1(1, vl);\n    vuint8m1_t vn = vmv_v_x_u8m1(0, vl);\n\n    uint8_t mask[10];\n    memset(mask, 0, sizeof(mask));\n\n    for (int i = 0; i < 10; ++i) {\n        mask[i] = (i & 1) ? 1 : 0;\n    }\n\n    vuint8m1_t vmask = lv_v_u8m1(mask, vl);\n\n    while (n > 0) {\n        uint64_t digit = n % 10;\n        n /= 10;\n\n        vn = vmv_v_x_u8m1(digit, vl);\n        vbool8_t is_odd = vmseq_vv_b8m1(vn, vmask, vl);\n        vuint8m1_t vodd = vand_vvm_u8m1(vn, vmask, vl);\n\n        if (vmsbf_m_b8m1(is_odd)) {\n            result *= (uint64_t)vredsum_vs_u8m1_u64(vodd, vzero, vone, vl);\n        } else {\n            all_even += 1;\n        }\n    }\n\n    return all_even == 10 ? 0 : result;\n}\n```"}
{"task_id": "SimdBench_125_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t digits_simd(uint64_t n){\n    uint64_t product = 1;\n    uint8_t has_odd = 0;\n\n    while (n > 0) {\n        vuint8m1_t vzero = vmv_v_x_u8m1(0, 0);\n        vuint8m1_t vmod = vmv_v_x_u8m1(n % 10, 0);\n        vbool8_t is_odd = vmsltu_b8_m(vmod, vmv_v_x_u8m1(2, 0), vmod);\n        vuint8m1_t vodd = vand_vv_u8m1(vmod, is_odd, 0);\n\n        uint8_t odd_count = vpopc_m_u8_b8(is_odd, vodd, 0);\n        if (odd_count > 0) {\n            has_odd = 1;\n            uint8_t odd_val = vfirst_a_u8(vodd);\n            product *= odd_val;\n        }\n        n /= 10;\n    }\n\n    if (!has_odd) {\n        return 0;\n    }\n    return product;\n}\n```"}
{"task_id": "SimdBench_125_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t digits_simd(uint64_t n){\n    uint64_t product = 1;\n    uint8_t has_odd = 0;\n\n    while (n > 0) {\n        vuint8m1_t vzero = vmv_v_x_u8m1(0, 1);\n        vbool8_t vm_all_ones = vmsbf_b8(vzero);\n\n        uint64_t digits[2] = {0};\n        size_t i = 0;\n        for (; i + 8 <= 8 && n > 0; i += 8, n /= 10) {\n            uint8_t digit = n % 10;\n            digits[i / 8] = digit;\n        }\n\n        if (i == 0) break;\n\n        vuint8m1_t vdigits = vle8_v_u8m1((const uint8_t *)digits, 8);\n        vuint8m1_t vodd_mask = vmfne_vx_u8m1_b8(vdigits, 0, vm_all_ones);\n        vuint8m1_t vodds = vmul_vx_u8m1(vdigits, 1, vm_all_ones);\n\n        uint64_t reduced_product = 1;\n        for (size_t j = 0; j < 8; ++j) {\n            uint8_t odd_digit = vget_v_u8m1(vodds, j);\n            if (odd_digit != 0) {\n                reduced_product *= odd_digit;\n                has_odd = 1;\n            }\n        }\n        product *= reduced_product;\n    }\n\n    return has_odd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_125_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t digits_simd(uint64_t n){\n    uint64_t product = 1;\n    int all_even = 0;\n    size_t vl = vsetvl_e8m1(10);\n    vuint8m1_t vzero = vmv_v_x_i8m1(0, vl);\n    vuint8m1_t vone = vmv_v_x_i8m1(1, vl);\n    vuint8m1_t vtens = vmv_v_x_i8m1(10, vl);\n    vuint8m1_t vnum = vle8_v_i8m1((const uint8_t *)&n, vl);\n    vbool8_t mask = vmsltu_vx_b8m1(vnum, 10, vl);\n    vnum = vmremu_vx_i8m1(vnum, 10, vl);\n    while (vfirst_m_b8m1(mask, vl) != -1) {\n        vbool8_t is_odd = vmandnot_b8m1(vmseq_vx_b8m1(vnum, 0, vl), vmseq_vx_b8m1(vmod_vx_i8m1(vnum, 2, vl), 0, vl));\n        vuint8m1_t vodd = vand_vv_i8m1(vnum, is_odd, vl);\n        vuint8m1_t vprod = vmul_vv_i8m1(vodd, vone, vl);\n        product *= vmaxu reduction(mul,vs) vprod;\n        if (vfredosum_mask_b8m1(is_odd, vl) == 0) {\n            all_even = 1;\n        }\n        vnum = vmdivu_vx_i8m1(vnum, 10, vl);\n        mask = vmsltu_vx_b8m1(vnum, 10, vl);\n    }\n    if (all_even) {\n        return 0;\n    }\n    return product;\n}\n```"}
{"task_id": "SimdBench_126_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n#include <vector>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    uint64_t total_sum = 0;\n    size_t size = lst.size();\n    if (size == 0) return total_sum;\n\n    float *data = const_cast<float *>(lst.data());\n    size_t vlmax = vsetvl_e32m8(size);\n\n    for(size_t i = 0; i < size; i += vlmax){\n        size_t vl = vsetvl_e32m8(size - i);\n        vfloat32m8_t vmask = vmv_v_x_f32m8(0.0f, vl);\n        vfloat32m8_t vdata = vle32_v_f32m8(data + i, vl);\n\n        // Ceiling operation\n        vfloat32m8_t vceil = vfncvt_xu_f_w_f32m8(vdata, vl);\n\n        // Square operation\n        vfloat32m8_t vsquare = vmul_vv_f32m8(vceil, vceil, vl);\n\n        // Reduction sum\n        float chunk_sum = 0.0f;\n        chunk_sum =vredu_sum_vs_f32m8_f32m1(chunk_sum, vsquare, vl);\n        total_sum += static_cast<uint64_t>(chunk_sum);\n    }\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_126_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n#include <cfloat>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    uint64_t total_sum = 0;\n    size_t size = lst.size();\n    if (size == 0) return total_sum;\n\n    const float *data = lst.data();\n    size_t vlmax = vsetvl_e32m1(size);\n\n    float sum = 0.0f;\n    for(size_t i = 0; i < size; i += vlmax){\n        size_t vl = vsetvl_e32m1(size - i);\n        vfloat32m1_t vmask = vmv_v_x_f32m1(0.0f, vl);\n        vfloat32m1_t vdata = vle32_v_f32m1(data + i, vl);\n        vfloat32m1_t vceil = vfncemadd_vf_f32m1(vmask, vdata, 0.0f, vl);\n        vfloat32m1_t vsquare = vmul_vv_f32m1(vceil, vceil, vl);\n        sum += vredsum_vs_f32m1_f32m1(vsquare, vmask, vl);\n    }\n    total_sum = static_cast<uint64_t>(std::lround(sum));\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_126_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n#include <cfloat>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    uint64_t result = 0;\n    size_t size = lst.size();\n    if (size == 0) return result;\n\n    float *data = const_cast<float *>(lst.data());\n    size_t vlmax = vsetvl_e32m1(size);\n\n    vfloat32m1_t vt_data, vt_ceil, vt_square;\n    vint32m1_t vt_int;\n    vfloat32m1_t vzero = vmv_v_f_f32(0.0f, vlmax);\n    vbool4_t mask;\n\n    for (size_t i = 0; i < size; i += vlmax) {\n        size_t vl = vsetvl_e32m1(size - i);\n        vt_data = vle32_v_f32m1(data + i, vl);\n        vt_ceil = vfncelimu_v_f32m1(vt_data, vl);\n        vt_square = vmul_vv_f32m1(vt_ceil, vt_ceil, vl);\n        vt_int = vfcvt_xu_f_v_i32m1(vt_square, vl);\n        result += vredsum_vs_i32m1_i64m1(vt_int, vl);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_126_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n#include <cinttypes>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    uint64_t total_sum = 0;\n    if (lst.empty()) return total_sum;\n\n    size_t size = lst.size();\n    float *data = const_cast<float *>(lst.data());\n\n    size_t vlmax = vsetvl_e32m1(size);\n    vfloat32m1_t vt, vt_ceil;\n    vfloat32m1_t vzero = vmv_v_f_f32m1(0.0f, vlmax);\n    vint32m1_t vi;\n    vfloat32m1_t vsqr;\n    vfloat32m1_t vsum = vmv_v_f_f32m1(0.0f, vlmax);\n\n    for(size_t i = 0; i < size; i += vlmax){\n        size_t vl = vsetvl_e32m1(size - i);\n        vt = vle32_v_f32m1(data + i, vl);\n        vt_ceil = vfncvt_xu_f_w_f32m1(vt, vl); // Ceiling operation\n        vi = vfwtc_v_i32m1(vt_ceil, vl);       // Convert to int32\n        vt = vwcvtxu_f_w_i32m1(vi, vl);        // Convert back to float\n        vsqr = vmul_vv_f32m1(vt, vt, vl);      // Square the elements\n        vsum = vredsum_vs_f32m1_f32m1(vsum, vsqr, vzero, vl); // Partial sum\n    }\n\n    float temp_sum = vmv_s_f_f32m1(vsum);\n    total_sum = static_cast<uint64_t>(temp_sum);\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_126_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <cmath>\n#include <cfloat>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    uint64_t result = 0;\n    if (lst.empty()) return result;\n\n    size_t size = lst.size();\n    float *data = const_cast<float *>(lst.data());\n\n    size_t vlmax = vsetvl_e32m1(size);\n    vfloat32m1_t vmask = vmv_v_x_f32m1(0.0f, vlmax);\n    vfloat32m1_t vone = vmv_v_x_f32m1(1.0f, vlmax);\n\n    for (size_t i = 0; i < size; i += vlmax) {\n        size_t vl = vsetvl_e32m1(std::min(vlmax, size - i));\n        vfloat32m1_t vdata = vle32_v_f32m1(data + i, vl);\n        // Ceiling operation\n        vfloat32m1_t vceil = vfncvt_xu_f_w_f32m1(vdata, vl);\n        vfloat32m1_t vsquare = vmul_vv_f32m1(vceil, vceil, vl);\n        // Reduction\n        float sum = 0.0f;\n        for (size_t j = 0; j < vl; ++j) {\n            sum += vget_v_f32m1(vsquare, j);\n        }\n        result += static_cast<uint64_t>(sum);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <climits>\n\nint can_arrange_simd(const std::vector<int> & arr){\n    if (arr.size() <= 1) return -1;\n\n    size_t vl = vsetvl_e32m1(arr.size()-1);\n    vint32m1_t v0 = vmv_v_x_i32m1(0, vl);\n\n    for(size_t i = 0; i < arr.size()-1; i+=vl){\n        size_t subvl = vsetvl_e32m1(std::min(vl, arr.size()-1 - i));\n        \n        // Load current and next elements\n        vint32m1_t vcurr = vle32_v_i32m1(&arr[i], subvl);\n        vint32m1_t vnext = vle32_v_i32m1(&arr[i+1], subvl);\n\n        // Compare current with next\n        vbool4_t cmp_res = vmge_vv_b4m1(vnext, vcurr, subvl);\n\n        // Find the first false in comparison\n        vint32m1_t indices = vmseq_vx_i32m1(cmp_res, 0, subvl);\n        int first_false_idx = vmfirst_m_i32m1_b4(indices, subvl);\n        \n        if(first_false_idx != -1){\n            return i + first_false_idx;\n        }\n    }\n\n    return -1;\n}\n```"}
{"task_id": "SimdBench_127_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <climits>\n\nint can_arrange_simd(const std::vector<int> & arr){\n    if (arr.size() <= 1) return -1;\n\n    size_t arr_size = arr.size();\n    size_t vl = vsetvl_e32m1(arr_size - 1);\n\n    // Load the first n-1 elements into a vector\n    vint32m1_t v_prev = vlload_e32m1(&arr[0], vl);\n    // Load the last n-1 elements into another vector\n    vint32m1_t v_curr = vlload_e32m1(&arr[1], vl);\n\n    // Compare each element with its previous one\n    vbool32_t mask = vmge_vv_i32m1_b32(v_curr, v_prev, vl);\n\n    // Find indices where the condition is false\n    vuint32m1_t indices = vid_v_u32m1(vl);\n    vuint32m1_t invalid_indices = vmxn_mask_v_u32m1(indices, mask, vl);\n\n    // Extract the largest index\n    uint32_t max_index = 0;\n    for(size_t i = 0; i < vl; ++i){\n        uint32_t idx = vget_uint32m1(invalid_indices, i);\n        if(idx > max_index && idx < arr_size){\n            max_index = idx;\n        }\n    }\n\n    return (max_index == 0) ? -1 : max_index;\n}\n```"}
{"task_id": "SimdBench_127_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <climits>\n\nint can_arrange_simd(const std::vector<int> & arr){\n    if (arr.size() <= 1) return -1;\n\n    size_t vl = vsetvl_e32m1(arr.size()-1);\n    vuint32m1_t v_idx = vmv_v_x_u32m1(0, vl);\n    vbool4_t mask = vmseq_vv_b4m1(v_idx, v_idx, vl); // Initialize mask\n\n    int result = -1;\n    for(size_t i = 0; i + vl <= arr.size() - 1; i += vl){\n        vint32m1_t v_curr = vle32_v_i32m1((int*)&arr[i+1], vl);\n        vint32m1_t v_prev = vle32_v_i32m1((int*)&arr[i], vl);\n\n        vbool4_t cond = vlge_vv_b4m1(v_curr, v_prev, vl);\n        vbool4_t not_cond = vmfalses_b4m1(vl);\n        not_cond = vmsbf_m_b4m1(mask, cond, vl);\n        not_cond = vmsof_m_b4m1(mask, not_cond, vl);\n\n        if (vfirst_m_b4m1(not_cond, vl)){\n            result = i + vminxseg_b4m1(not_cond, vl);\n            break;\n        }\n        mask = vmxor_m_b4m1(mask, mask, cond, vl);\n    }\n\n    // Handle remaining elements\n    for(size_t i = ((arr.size()-1)/vl)*vl; i < arr.size()-1; ++i){\n        if(arr[i+1] < arr[i]){\n            result = i;\n            break;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <climits>\n\nint can_arrange_simd(const std::vector<int> & arr){\n    if (arr.size() < 2) return -1;\n\n    size_t vl = vsetvl_e32m1(arr.size()-1);\n    int result = -1;\n\n    vbool32m1_t vmask = vmsnevi_b32m1(vl, 0, 0); // Initialize mask to true\n    vint32m1_t prev_vec = vmv_v_x_i32m1(vl, arr[0]); // Load first element\n\n    for(size_t i = 1; i < arr.size(); i += vl){\n        size_t ei = i + vl > arr.size() ? arr.size() : i + vl;\n        size_t current_vl = vsetvl_e32m1(ei - i);\n\n        vint32m1_t current_vec = vlde32_v_i32m1((int*)&arr[i], current_vl);\n        vbool32m1_t cond = vmge_vv_b32m1(current_vec, prev_vec, current_vl);\n\n        // Find indices where condition is false\n        vint32m1_t idx_vec = vid_v_i32m1(current_vl);\n        vbool32m1_t mismatch = vmfalsedm_b32m1(cond, current_vl);\n        vint32m1_t mismatch_idx = vmfredmax_vs_i32m1_i32(idx_vec, mismatch, current_vl);\n\n        // Check if there is any mismatch in this block\n        if(vmfirst_m_b32m1(mismatch, current_vl)){\n            int temp_result = (int)vget_v_i32m1(mismatch_idx, 0);\n            if(temp_result > result){\n                result = temp_result + i - 1;\n            }\n        }\n\n        prev_vec = current_vec;\n    }\n\n    return result == -1 ? -1 : result;\n}\n```"}
{"task_id": "SimdBench_127_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <climits>\n\nint can_arrange_simd(const std::vector<int> & arr){\n    if (arr.size() <= 1) return -1;\n\n    size_t vl = vsetvl_e32m1(arr.size() - 1);\n    vint32m1_t v_prev = vmv_v_x_i32m1(arr[0], vl);\n    int result = -1;\n\n    for(size_t i = 1; i < arr.size(); i += vl){\n        size_t current_vl = vsetvl_e32m1(std::min((size_t)(arr.size() - i), vl));\n        vint32m1_t v_curr = vle32_v_i32m1(&arr[i], current_vl);\n        vbool32_t mask = vmge_vv_b32m1(v_curr, v_prev, current_vl);\n        vint32m1_t indices = vmv_v_x_i32m1(i, current_vl);\n        vbool32_t mismatch_mask = !mask;\n        indices = vmfredmax_vs_i32m1_i32m1(indices, indices, mismatch_mask, current_vl);\n        int candidate = vmfirst_m_i32m1_i32(indices, mismatch_mask, current_vl);\n        if(candidate != 0){\n            result = candidate + i - 1;\n        }\n        v_prev = vle32_v_i32m1(&arr[i], current_vl);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_128_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <climits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst){\n    if (lst.empty()) return {0, 0};\n\n    size_t vl = lst.size();\n    size_t vlen = vl;\n    size_t esz = sizeof(int);\n    uint64_t vmul = 1;\n    uint64_t sew = 32;\n\n    vint32m1_t v_a = vmv_v_x_i32m1(INT_MIN, vlen);\n    vint32m1_t v_b = vmv_v_x_i32m1(INT_MAX, vlen);\n\n    for(size_t i = 0; i < vl; i += vlen) {\n        size_t subvl = (vl - i) > vlen ? vlen : (vl - i);\n        vint32m1_t v_src = vle32_v_i32m1((const int*)&lst[i], subvl);\n\n        // Mask for negative numbers\n        vbool32_t is_neg = vmflt_vx_i32m1_b32(v_src, 0, subvl);\n        v_a = vmax_vv_i32m1_m(is_neg, v_a, v_src, subvl);\n\n        // Mask for positive numbers\n        vbool32_t is_pos = vmfgt_vx_i32m1_b32(v_src, 0, subvl);\n        v_b = vmin_vv_i32m1_m(is_pos, v_b, v_src, subvl);\n    }\n\n    int a_res = vmmax_vx_i32m1_i32(v_a, 0, vl);\n    int b_res = vmmin_vx_i32m1_i32(v_b, 0, vl);\n\n    if(a_res == INT_MIN) a_res = 0;\n    if(b_res == INT_MAX) b_res = 0;\n\n    return {a_res, b_res};\n}\n```"}
{"task_id": "SimdBench_128_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <climits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst){\n    if (lst.empty()) return {0, 0};\n\n    size_t vl = vsetvl_e32m1(lst.size());\n    vint32m1_t v_lst = vmv_v_x_i32m1(0, vl);\n    vint32m1_t v_neg_max = vmv_v_x_i32m1(INT_MIN, vl);\n    vint32m1_t v_pos_min = vmv_v_x_i32m1(INT_MAX, vl);\n\n    for(size_t i = 0; i < lst.size(); i += vl){\n        size_t subvl = vsetvl_e32m1(std::min(vl, (size_t)(lst.size() - i)));\n        vint32m1_t v_temp = vle32_v_i32m1((const int*)&lst[i], subvl);\n        \n        // Mask for negative numbers\n        vbool32_t is_neg = vmflt_vx_i32m1_b32(v_temp, 0, subvl);\n        v_neg_max = vmax_vv_i32m1_m(is_neg, v_neg_max, v_temp, subvl);\n\n        // Mask for positive numbers\n        vbool32_t is_pos = vmfgt_vx_i32m1_b32(v_temp, 0, subvl);\n        v_pos_min = vmin_vv_i32m1_m(is_pos, v_pos_min, v_temp, subvl);\n    }\n\n    int neg_max = vmmax_v_i32m1_i32(v_neg_max, vl);\n    int pos_min = vmmin_v_i32m1_i32(v_pos_min, vl);\n\n    if(neg_max == INT_MIN) neg_max = 0;\n    if(pos_min == INT_MAX) pos_min = 0;\n\n    return {neg_max, pos_min};\n}\n```"}
{"task_id": "SimdBench_128_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst){\n    if (lst.empty()) return {0, 0};\n\n    size_t vl = vsetvl_e32m1(lst.size());\n    vint32m1_t v_lst = vmv_v_x_i32m1(0, vl);\n    vint32m1_t v_neg_max = vmv_v_x_i32m1(-1, vl);\n    vint32m1_t v_pos_min = vmv_v_x_i32m1(0, vl);\n    vbool32_t mask;\n\n    for(size_t i = 0; i < lst.size(); i += vl){\n        size_t sub vl = vsetvl_e32m1(std::min(vl, (size_t)(lst.size() - i)));\n        vint32m1_t v_temp = vle32_v_i32m1((const int*)&lst[i], sub_vl);\n        \n        // For negative max\n        mask = vmflt_vx_b32m1(v_temp, 0, sub_vl);\n        v_neg_max = vmmax_vv_i32m1(v_neg_max, v_temp, mask, sub_vl);\n\n        // For positive min\n        mask = vmfgt_vx_b32m1(v_temp, 0, sub_vl);\n        v_pos_min = vmmin_vv_i32m1(v_pos_min, v_temp, mask, sub_vl);\n    }\n\n    int neg_max = vmax_v_i32m1_i32(v_neg_max, vl);\n    int pos_min = vmin_v_i32m1_i32(v_pos_min, vl);\n\n    if(neg_max >= 0) neg_max = 0;\n    if(pos_min <= 0) pos_min = 0;\n\n    return {neg_max, pos_min};\n}\n```"}
{"task_id": "SimdBench_128_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst){\n    if (lst.empty()) return {0, 0};\n\n    size_t vl = lst.size();\n    vint32m1_t v_lst = vmv_v_x_i32m1(0, vl);\n    vbool32_t mask = vmv_v_x_b32m1(0, vl);\n\n    // Load vector\n    for(size_t i = 0; i < vl; ++i){\n        v_lst = vle32_v_i32m1(&lst[i], vl);\n        \n        // Find max negative\n        vbool32_t neg_mask = vlge_vx_i32m1_b32m1(v_lst, 0, vl);\n        vint32m1_t neg_v = vmfmerge_vfm_i32m1(v_lst, 0, neg_mask, vl);\n        int current_max_neg = vmmax_vx_i32m1_i32(neg_v, 0, vl);\n        int max_neg = current_max_neg < 0 ? current_max_neg : 0;\n\n        // Find min positive\n        vbool32_t pos_mask = vllt_vx_i32m1_b32m1(v_lst, 0, vl);\n        vint32m1_t pos_v = vmfmerge_vfm_i32m1(v_lst, 0, pos_mask, vl);\n        int current_min_pos = vmmin_vx_i32m1_i32(pos_v, 0, vl);\n        int min_pos = current_min_pos > 0 ? current_min_pos : 0;\n\n        return {max_neg, min_pos};\n    }\n    return {0, 0};\n}\n```"}
{"task_id": "SimdBench_128_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <climits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst){\n    if (lst.empty()) return {0, 0};\n\n    size_t vl = vsetvl_e32m1(lst.size());\n    vint32m1_t v_lst = vmv_v_x_i32m1(0, vl);\n    vbool32_t mask = vmv_v_x_b32m1(false, vl);\n\n    for(size_t i = 0; i < lst.size(); i += vl){\n        size_t sub vl = vsetvl_e32m1(std::min(vl, (size_t)(lst.size() - i)));\n        vint32m1_t v_temp = vle32_v_i32m1(&lst[i], sub_vl);\n        v_lst = vmv_v_v_i32m1(v_lst, v_temp, sub_vl);\n        \n        // Separate negative and positive numbers\n        vbool32_t neg_mask = vmflt_vx_i32m1_b32m1(v_lst, 0, sub_vl);\n        vbool32_t pos_mask = vmfgt_vx_i32m1_b32m1(v_lst, 0, sub_vl);\n\n        // Find max of negative\n        vint32m1_t v_max_neg = vmfredmax_vs_i32m1_i32m1(v_lst, neg_mask, v_lst, sub_vl);\n        int max_neg = vmfvt_v_i32m1_i32(v_max_neg, sub_vl);\n        \n        // Find min of positive\n        vint32m1_t v_min_pos = vmfredmin_vs_i32m1_i32m1(v_lst, pos_mask, v_lst, sub_vl);\n        int min_pos = vmfvt_v_i32m1_i32(v_min_pos, sub_vl);\n        \n        // Update results\n        if (max_neg > 0) {\n            mask = vor_v_b32m1(mask, neg_mask, sub_vl);\n        }\n        if (min_pos < INT_MAX) {\n            mask = vor_v_b32m1(mask, pos_mask, sub_vl);\n        }\n    }\n\n    int a = vmfredmax_vs_i32m1_i32m1(v_lst, mask, v_lst, vl);\n    int b = vmfredmin_vs_i32m1_i32m1(v_lst, mask, v_lst, vl);\n\n    if(a >=0 ) a =0;\n    if(b <=0 ) b =0;\n\n    return {a, b};\n}\n```"}
{"task_id": "SimdBench_129_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t special_factorial_simd(uint64_t n){\n    uint64_t result = 1;\n    if (n == 0 || n == 1) return result;\n\n    size_t vl = vsetvl_e64m1(n);\n    vuint64m1_t vmul = vmv_v_x_u64m1(1, vl);\n\n    for(uint64_t i = 2; i <= n; i++){\n        size_t vli = vsetvl_e64m1(i);\n        vuint64m1_t vidx = vid_v_u64m1(vli);\n        vuint64m1_t vone = vmv_v_x_u64m1(1, vli);\n        vuint64m1_t vfact = vredmulush_vs_u64m1_u64m1_u64m1(vone, vidx, vone, vli);\n        vmul = vmul_vx_u64m1(vmul, (uint64_t)vfact, vl);\n    }\n\n    result = (uint64_t)vsum_vx_u64m1_u64(vmul, 1, vl);\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t special_factorial_simd(uint64_t n){\n    uint64_t result = 1;\n    if (n == 0) return 1;\n\n    size_t vl = vsetvl_e64m8(n);\n    vuint64m8_t v_n = vmv_v_x_u64m8(n, vl);\n    vuint64m8_t v_one = vmv_v_x_u64m8(1, vl);\n    vuint64m8_t v_res = vmv_v_x_u64m8(1, vl);\n\n    for (uint64_t i = 1; i <= n; i++) {\n        vuint64m8_t v_i = vmv_v_x_u64m8(i, vl);\n        vuint64m8_t v_fact = v_one;\n        for (uint64_t j = 1; j <= i; j++) {\n            v_fact = vmul_vv_u64m8(v_fact, v_i, vl);\n            v_i = vsub_vx_u64m8(v_i, 1, vl);\n        }\n        v_res = vmul_vv_u64m8(v_res, v_fact, vl);\n    }\n\n    uint64_t temp_result = 1;\n    for (size_t i = 0; i < vl; i++) {\n        temp_result *= vget_v_u64m8_u64(v_res, i);\n    }\n    result *= temp_result;\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t special_factorial_simd(uint64_t n){\n    uint64_t result = 1;\n    size_t vl = vsetvl_e64m1(n);\n    vuint64m1_t v_n = vmv_v_x_u64m1(n, vl);\n    vuint64m1_t v_one = vmv_v_x_u64m1(1, vl);\n    vuint64m1_t v_i = vid_v_u64m1(vl);\n    vuint64m1_t v_acc = vmv_v_x_u64m1(1, vl);\n\n    for (uint64_t i = 1; i <= n; i++) {\n        vuint64m1_t v_temp_acc = v_acc;\n        vuint64m1_t v_temp_i = vmv_v_x_u64m1(i, vl);\n        for (uint64_t j = 1; j <= i; j++) {\n            v_temp_acc = vmul_vv_u64m1(v_temp_acc, v_temp_i, vl);\n            v_temp_i = vsub_vx_u64m1(v_temp_i, 1, vl);\n        }\n        v_acc = vmul_vv_u64m1(v_acc, v_temp_acc, vl);\n    }\n\n    uint64_t temp_result = 1;\n    for (size_t i = 0; i < vl; i++) {\n        temp_result *= vget_v_u64m1(v_acc, i);\n    }\n    result *= temp_result;\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t special_factorial_simd(uint64_t n){\n    uint64_t result = 1;\n    if (n == 0 || n == 1) return result;\n\n    size_t vl = vsetvl_e64m1(n);\n    vuint64m1_t vn = vmv_v_x_u64m1(n, vl);\n    vuint64m1_t vone = vmv_v_x_u64m1(1, vl);\n\n    for (uint64_t i = 1; i <= n; i++) {\n        vuint64m1_t vi = vmv_v_x_u64m1(i, vl);\n        vuint64m1_t vf = vone;\n        for (uint64_t j = 1; j <= i; j++) {\n            vf = vmul_vv_u64m1(vf, vi, vl);\n            vi = vsub_vx_u64m1(vi, 1, vl);\n        }\n        result *= (uint64_t)vredsum_vs_u64m1_u64m1(vf, vone, vone, vl);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t special_factorial_simd(uint64_t n){\n    uint64_t result = 1;\n    if (n == 0) return 1;\n\n    size_t vl = vsetvl_e64m1(n);\n    vuint64m1_t vn = vmv_v_x_u64m1(n, vl);\n    vuint64m1_t vone = vmv_v_x_u64m1(1, vl);\n\n    for (uint64_t i = 1; i <= n; i++) {\n        vuint64m1_t vi = vmv_v_x_u64m1(i, vl);\n        vuint64m1_t vf = vone;\n        for (uint64_t j = 1; j <= i; j++) {\n            vf = vmul_vv_u64m1(vf, vi, vl);\n            vi = vsub_vx_u64m1(vi, 1, vl);\n        }\n        result *= (uint64_t)vredsum_vs_u64m1_u64m1(vf, vone, vl);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_130_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst){\n    if (lst.empty()) return 0;\n\n    size_t vl = vsetvl_e32m1(lst.size());\n    int sum = 0;\n    for(size_t i = 0; i < lst.size(); i += vl){\n        size_t current_vl = vsetvl_e32m1(std::min(vl, (size_t)(lst.size() - i)));\n\n        vint32m1_t vmask = vmv_v_x_i32m1(0, current_vl);\n        vint32m1_t vidx = vid_v_i32m1(current_vl);\n        vbool32_t is_multiple_of_3 = vmseq_vv_b32m1(vidx, vmul_vx_i32m1(vidx, 3, current_vl), current_vl);\n        vbool32_t is_multiple_of_4 = vmseq_vv_b32m1(vidx, vmul_vx_i32m1(vidx, 4, current_vl), current_vl);\n        vbool32_t is_multiple_of_3_and_4 = vmsne_vv_b32m1(vidx, vmul_vx_i32m1(vidx, 12, current_vl), current_vl);\n\n        vint32m1_t vdata = vle32_v_i32m1((const int *)&lst[i], current_vl);\n        vint32m1_t vsquared = vmul_vv_i32m1(vdata, vdata, current_vl);\n        vint32m1_t vcubed = vmul_vv_i32m1(vdata, vmul_vv_i32m1(vdata, vdata, current_vl), current_vl);\n\n        vdata = vmerge_vvm_i32m1(vdata, vsquared, is_multiple_of_3, current_vl);\n        vdata = vmerge_vvm_i32m1(vdata, vcubed, vand_vv_b32m1(is_multiple_of_4, is_multiple_of_3_and_4, current_vl), current_vl);\n\n        int temp_sum = 0;\n        for(size_t j = 0; j < current_vl; ++j){\n            temp_sum += vdata[j];\n        }\n        sum += temp_sum;\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst){\n    if (lst.empty()) return 0;\n\n    size_t size = lst.size();\n    int result = 0;\n\n    size_t vlmax = vsetvl_e32m1(size);\n    vbool32_t vm_t = vmsltu_vv_i32m1(true, 0, 0, vlmax); // Initialize predicate register\n\n    for(size_t i = 0; i < size; i += vlmax){\n        size_t vl = vsetvl_e32m1(std::min(vlmax, size - i));\n\n        vbool32_t idx_mod3 = vmsleu_vv_i32m1(vm_t, i, i + 3, vl) & vmsneu_vv_i32m1(vm_t, (i + 1) % 3, 0, vl);\n        vbool32_t idx_mod4 = vmsleu_vv_i32m1(vm_t, i, i + 4, vl) & vmsneu_vv_i32m1(vm_t, (i + 1) % 4, 0, vl) & vmsneu_vv_i32m1(vm_t, (i + 1) % 3, 0, vl);\n\n        vint32m1_t v_lst = vluxseg1ei32_v_i32m1(&lst[i], vl);\n        vint32m1_t v_sq = vmul_vv_i32m1(v_lst, v_lst, vl);\n        vint32m1_t v_cube = vmul_vv_i32m1(v_sq, v_lst, vl);\n\n        vint32m1_t v_res = vredsum_vs_i32m1_i32m1(vm_t, vifnotmaskedzero_v_i32m1(idx_mod3, v_sq, vl), vifnotmaskedzero_v_i32m1(idx_mod4, v_cube, v_lst, vl), vl);\n\n        result += vmv_x_s_i32m1_i32(v_res);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_130_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> &lst) {\n    if (lst.empty()) return 0;\n\n    size_t vl = vsetvl_e32m1(lst.size());\n    int result = 0;\n\n    for(size_t i = 0; i < lst.size(); i += vl) {\n        size_t current_vl = vsetvl_e32m1(std::min(vl, (size_t)(lst.size() - i)));\n\n        vint32m1_t v_lst = vlde32_v_i32m1((const int *)&lst[i], current_vl);\n        vbool32_t idx_multiple_of_3 = vmseq_vx_b32m1(vmseq_vx_b32m1(i + vid_v_u32m1(current_vl), 3, current_vl), 0, current_vl);\n        vbool32_t idx_multiple_of_4_not_3 = vmseq_vx_b32m1(vmseq_vx_b32m1(i + vid_v_u32m1(current_vl), 4, current_vl), 0, current_vl) & !vmseq_vx_b32m1(vmseq_vx_b32m1(i + vid_v_u32m1(current_vl), 3, current_vl), 0, current_vl);\n\n        vint32m1_t squared = vmul_vv_i32m1(v_lst, v_lst, current_vl);\n        vint32m1_t cubed = vmul_vv_i32m1(vmul_vv_i32m1(v_lst, v_lst, current_vl), v_lst, current_vl);\n\n        vint32m1_t updated = vmERGE_vvm_i32m1(v_lst, squared, idx_multiple_of_3, current_vl);\n        updated = vmERGE_vvm_i32m1(updated, cubed, idx_multiple_of_4_not_3, current_vl);\n\n        int partial_sum = vmv_x_s_i32m1_i32(vredsum_vs_i32m1_i32(updated, vmv_v_x_i32m1(0, current_vl), current_vl));\n        result += partial_sum;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_130_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> &lst) {\n    if (lst.empty()) return 0;\n\n    size_t size = lst.size();\n    int result = 0;\n\n    size_t vlmax = vsetvl_e32m1(size);\n    vuint32m1_t vmul = vmul_vv_u32m1(vmv_v_x_u32m1(1, vlmax), vmv_v_x_u32m1(1, vlmax), vlmax); // dummy init\n\n    for (size_t i = 0; i < size; i += vlmax) {\n        size_t vl = vsetvl_e32m1(size - i);\n\n        vint32m1_t v = vle32_v_i32m1((const int *)&lst[i], vl);\n\n        vbool32_t idx_multiple_of_3 = vmseq_vx_i32m1_b32(vmsub_vx_i32m1(vmv_v_x_i32m1(i, vl), vmv_v_x_i32m1(i, vl), vl), 0, vl);\n        vbool32_t idx_multiple_of_4 = vmseq_vx_i32m1_b32(vmsub_vx_i32m1(vmv_v_x_i32m1(i, vl), vmv_v_x_i32m1(i, vl), vl), 0, vl);\n\n        vint32m1_t vsquare = vmul_vv_i32m1(v, v, vl);\n        vint32m1_t vcube = vmul_vv_i32m1(vsquare, v, vl);\n\n        vint32m1_t vresult = vredsum_vs_i32m1_i32m1(vmerge_vvm_i32m1(vsquare, v, idx_multiple_of_3, vl), \n                                                   vmerge_vvm_i32m1(vcube, v, idx_multiple_of_4 & ~idx_multiple_of_3, vl), \n                                                   vmv_v_x_i32m1(0, vl), vl);\n\n        result +=vredu_sum_i32m1_i32(vresult, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_130_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> &lst) {\n    if (lst.empty()) return 0;\n\n    size_t size = lst.size();\n    int result = 0;\n\n    size_t vlmax = vsetvl_e32m1(size);\n    vuint32m1_t vmask = vmv_v_x_u32m1(0, vlmax);\n    vint32m1_t vzero = vmv_v_x_i32m1(0, vlmax);\n    vint32m1_t vsum = vmv_v_x_i32m1(0, vlmax);\n\n    for (size_t i = 0; i < size; i += vlmax) {\n        size_t vl = vsetvl_e32m1(std::min(vlmax, size - i));\n        vint32m1_t vdata = vle32_v_i32m1((const int *)&lst[i], vl);\n\n        // Create mask for index % 3 == 0\n        vmask = vmseq_vx_u32m1(i + vmv_v_x_u32m1(0, vl), 3, vl);\n        vint32m1_t vsquare = vmul_vv_i32m1(vdata, vdata, vl);\n        vdata = vmerge_vvm_i32m1(vdata, vsquare, vmask, vl);\n\n        // Create mask for index % 4 == 0 and index % 3 != 0\n        vmask = vmsne_vx_u32m1(i + vmv_v_x_u32m1(0, vl), 3, vl);\n        vmask = vmandeq_vx_u32m1(vmask, i + vmv_v_x_u32m1(0, vl), 4, vl);\n        vint32m1_t vcube = vmul_vv_i32m1(vmul_vv_i32m1(vdata, vdata, vl), vdata, vl);\n        vdata = vmerge_vvm_i32m1(vdata, vcube, vmask, vl);\n\n        vsum = vadd_vv_i32m1(vsum, vdata, vl);\n    }\n\n    result = vmv_x_s_i32m1_i32(vredsum_vs_i32m1_i32(vzero, vsum, vlmax));\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_131_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <cinttypes>\n\nint specialFilter_simd(const std::vector<int> & nums){\n    int vl = nums.size();\n    if (vl == 0) return 0;\n\n    uint8_t mask_first_digit[10] = {0, 1, 0, 1, 0, 1, 0, 1, 0, 1};\n    uint8_t mask_last_digit[10] = {0, 1, 0, 1, 0, 1, 0, 1, 0, 1};\n\n    size_t vlen = __riscv_vlmax();\n    int result = 0;\n\n    for(size_t i = 0; i < vl; i += vlen){\n        size_t remaining = vl - i;\n        size_t vl_i = __riscv_vsetvl_e32m1(remaining);\n\n        vuint32m1_t v_nums = __riscv_vle32_v_u32m1(&nums[i], vl_i);\n        vbool4_t cond_gt_10 = __riscv_vmfgt_vv_i32m1_b4(v_nums, __riscv_vmv_v_x_i32m1(10, vl_i), vl_i);\n\n        // Extract last digit\n        vuint32m1_t v_last_digit = __riscv_vand_vx_u32m1(v_nums, 9, vl_i);\n        vuint8m1_t v_last_digit_masked = __riscv_vluxseg1ei8_v_u8m1(mask_last_digit, v_last_digit, vl_i);\n        vbool4_t cond_last_digit = __riscv_vmsne_vx_i8m1_b4(v_last_digit_masked, 0, vl_i);\n\n        // Extract first digit\n        vuint32m1_t v_abs = __riscv_vmax_vx_i32m1(v_nums, 0, vl_i);\n        vuint32m1_t v_powers_of_ten[5];\n        v_powers_of_ten[0] = __riscv_vmv_v_x_u32m1(1, vl_i);\n        v_powers_of_ten[1] = __riscv_vmv_v_x_u32m1(10, vl_i);\n        v_powers_of_ten[2] = __riscv_vmv_v_x_u32m1(100, vl_i);\n        v_powers_of_ten[3] = __riscv_vmv_v_x_u32m1(1000, vl_i);\n        v_powers_of_ten[4] = __riscv_vmv_v_x_u32m1(10000, vl_i);\n\n        vuint32m1_t v_first_digit = __riscv_vdivu_vx_u32m1(v_abs, 1, vl_i);\n        for(int j = 0; j < 5; ++j){\n            vbool4_t is_ge = __riscv_vmfgtu_vx_i32m1_b4(v_abs, v_powers_of_ten[j], vl_i);\n            v_first_digit = __riscv_vfmerge_vfm_u32m1(v_first_digit, __riscv_vdivu_vx_u32m1(v_abs, v_powers_of_ten[j], vl_i), is_ge, vl_i);\n        }\n        v_first_digit = __riscv_vremu_vx_u32m1(v_first_digit, 10, vl_i);\n\n        vuint8m1_t v_first_digit_masked = __riscv_vluxseg1ei8_v_u8m1(mask_first_digit, v_first_digit, vl_i);\n        vbool4_t cond_first_digit = __riscv_vmsne_vx_i8m1_b4(v_first_digit_masked, 0, vl_i);\n\n        vbool4_t final_cond = __riscv_vmand3_b4(cond_gt_10, cond_last_digit, cond_first_digit, vl_i);\n        result += __riscv_vpopc_m_b4(final_cond, vl_i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_131_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums){\n    int result = 0;\n    size_t vl = vsetvl_e32m1(nums.size());\n    vbool32_t mask = vmv_v_x_b32(0, vl);\n    vint32m1_t vten = vmv_v_x_i32m1(10, vl);\n    size_t i = 0;\n\n    for (; i + vl <= nums.size(); i += vl) {\n        vint32m1_t vin = vle32_v_i32m1((const int *)&nums[i], vl);\n        vbool32_t cond1 = vmge_vx_b32m1_b32(vin, 10, vl); // Check if greater than 10\n\n        // Extract last digit\n        vint32m1_t abs_val = vabsu_v_i32m1_i32m1(vin, vl);\n        vint32m1_t last_digit = vremu_vx_i32m1_i32m1(abs_val, 10, vl);\n\n        // Check if last digit is odd\n        vbool32_t last_odd = vmandnot_vvm_b32m1(vmseq_vx_b32m1(last_digit, 0, vl), \n                                               vmremu_vx_b32m1(last_digit, 2, vl), vl);\n\n        // Extract first digit\n        vbool32_t not_zero = vmne_vx_b32m1(abs_val, 0, vl);\n        vint32m1_t first_digit = abs_val;\n        for (size_t j = 0; j < 10; ++j) {\n            vbool32_t ge_ten = vmge_vx_b32m1(first_digit, 10, vl);\n            first_digit = vmul_vx_i32m1_i32m1(first_digit, ge_ten, 0.1f, vl);\n            not_zero = vmand_vvm_b32m1(not_zero, ge_ten, vl);\n        }\n        first_digit = vtrunc_wx_i32m1_i32m1(first_digit, vl);\n\n        // Check if first digit is odd\n        vbool32_t first_odd = vmandnot_vvm_b32m1(vmseq_vx_b32m1(first_digit, 0, vl), \n                                                vmremu_vx_b32m1(first_digit, 2, vl), vl);\n\n        // Combine conditions\n        vbool32_t final_cond = vmand_vvm_b32m1(cond1, vmand_vvm_b32m1(last_odd, first_odd, vl), vl);\n        mask = vor_vv_b32m1_b32(mask, final_cond, vl);\n    }\n\n    result += __builtin_popcount(mask);\n\n    for (; i < nums.size(); ++i) {\n        int num = nums[i];\n        if (num > 10) {\n            int abs_num = std::abs(num);\n            int last_digit = abs_num % 10;\n            int first_digit = abs_num;\n            while (first_digit >= 10) first_digit /= 10;\n            if ((last_digit % 2 != 0) && (first_digit % 2 != 0)) {\n                result++;\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_131_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums){\n    int result = 0;\n    size_t vlmax = vsetvl_e32m1(nums.size());\n    size_t i = 0;\n    for(; i + vlmax <= nums.size(); i += vlmax){\n        vuint32m1_t vmask = vmv_v_x_u32m1(0, vlmax);\n        vuint32m1_t vnums = vle32_v_u32m1((uint32_t*)&nums[i], vlmax);\n        \n        // Check if number > 10\n        vmask = vmgtu_vv_u32m1_b1(vnums, vmv_v_x_u32m1(10, vlmax), vmask, vlmax);\n\n        // Extract last digit\n        vuint32m1_t last_digit = vremu_vx_u32m1(vnums, 10, vmask, vlmax);\n\n        // Extract first digit\n        vuint32m1_t temp = vnums;\n        for(int j=0; j<9; j++){\n            temp = vdivu_vx_u32m1(temp, 10, vmask, vlmax);\n        }\n        vuint32m1_t first_digit = vremu_vx_u32m1(temp, 10, vmask, vlmax);\n\n        // Check if both first and last digits are odd\n        vmask = vand_vv_u32m1_b1(vmask, vremu_vx_u32m1(first_digit, 2, vmask, vlmax), vmask, vlmax);\n        vmask = vand_vv_u32m1_b1(vmask, vremu_vx_u32m1(last_digit, 2, vmask, vlmax), vmask, vlmax);\n\n        // Count the valid elements\n        result += vpopc_m_u32m1_b1(vmask, vlmax);\n    }\n\n    // Handle remaining elements\n    if(i < nums.size()){\n        size_t vl = vsetvl_e32m1(nums.size() - i);\n        vuint32m1_t vmask = vmv_v_x_u32m1(0, vl);\n        vuint32m1_t vnums = vle32_v_u32m1((uint32_t*)&nums[i], vl);\n        \n        // Check if number > 10\n        vmask = vmgtu_vv_u32m1_b1(vnums, vmv_v_x_u32m1(10, vl), vmask, vl);\n\n        // Extract last digit\n        vuint32m1_t last_digit = vremu_vx_u32m1(vnums, 10, vmask, vl);\n\n        // Extract first digit\n        vuint32m1_t temp = vnums;\n        for(int j=0; j<9; j++){\n            temp = vdivu_vx_u32m1(temp, 10, vmask, vl);\n        }\n        vuint32m1_t first_digit = vremu_vx_u32m1(temp, 10, vmask, vl);\n\n        // Check if both first and last digits are odd\n        vmask = vand_vv_u32m1_b1(vmask, vremu_vx_u32m1(first_digit, 2, vmask, vl), vmask, vl);\n        vmask = vand_vv_u32m1_b1(vmask, vremu_vx_u32m1(last_digit, 2, vmask, vl), vmask, vl);\n\n        // Count the valid elements\n        result += vpopc_m_u32m1_b1(vmask, vl);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_131_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums){\n    int result = 0;\n    size_t n = nums.size();\n    if (n == 0) return 0;\n\n    size_t vl = vsetvl_e32m1(n);\n    vbool32_t mask = vmv_v_x_b32(0, vl);\n    vint32m1_t vzero = vmv_v_x_i32m1(0, vl);\n    vint32m1_t vten = vmv_v_x_i32m1(10, vl);\n    vint32m1_t vabs_val;\n    vint32m1_t vfirst_digit, vlast_digit;\n    vbool32_t vcond;\n\n    for(size_t i = 0; i < n; i += vl){\n        size_t num_elements = (n - i) > vl ? vl : (n - i);\n        vl = vsetvl_e32m1(num_elements);\n\n        vint32m1_t vnums = vle32_v_i32m1((int*)&nums[i], vl);\n\n        // Compute absolute value\n        vabs_val = vabsu_v_i32m1(vnums, vl);\n\n        // Check if greater than 10\n        vcond = vmgt_vv_b32m1(vabs_val, vten, vl);\n\n        // Extract last digit\n        vlast_digit = vrem_vx_i32m1(vabs_val, 10, vl);\n\n        // Extract first digit\n        vfirst_digit = vabs_val;\n        while (vmv_x_s_b32_b1(vmsox_v_b32m1(vfirst_digit, vl)) != 0){\n            vfirst_digit = vdivu_vx_i32m1(vfirst_digit, 10, vl);\n        }\n\n        // Check if both first and last digits are odd\n        vbool32_t vodd_last = vand_vv_b32m1(vrem_vx_b32m1(vlast_digit, 2, vl), vcond, vl);\n        vbool32_t vodd_first = vand_vv_b32m1(vrem_vx_b32m1(vfirst_digit, 2, vl), vodd_last, vl);\n\n        // Count the number of elements satisfying the condition\n        result += vm popc_b32(vodd_first, vl);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_131_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums){\n    int result = 0;\n    size_t vl = vsetvl_e32m1(nums.size());\n    vuint32m1_t v_num = vmv_v_x_u32m1(0, vl);\n    vbool4_t mask = vmf_eq_v_i32m1_b4(0, vl);\n\n    for(size_t i = 0; i < nums.size(); i += vl){\n        size_t subvl = vsetvl_e32m1(std::min((size_t)vl, nums.size() - i));\n        v_num = vle32_v_u32m1(&nums[i], subvl);\n\n        // Check if number > 10\n        vbool4_t cond1 = vmf_gt_v_i32m1_b4(v_num, 10, subvl);\n\n        // Extract last digit and check if it's odd\n        vuint32m1_t last_digit = vmul_vx_u32m1(v_num, 1, subvl); // No-op to get last digit\n        last_digit = vmrem_vx_u32m1(last_digit, 10, subvl);\n        vbool4_t cond2 = vmf_and_v_b4(vmfv_f_s.lu32m1_b4(last_digit, subvl), \n                                      vmf_ne_v_i32m1_b4(vmrem_vx_u32m1(vmadd_vx_u32m1(last_digit, 1, subvl), 2, subvl), 0, subvl), subvl);\n\n        // Extract first digit and check if it's odd\n        vuint32m1_t temp = v_num;\n        while (1) {\n            vbool4_t non_zero = vmf_ne_v_i32m1_b4(temp, 0, subvl);\n            if (!vmf_all_b4(non_zero, subvl)) break;\n            temp = vmdiv_vx_u32m1(temp, 10, subvl);\n        }\n        vuint32m1_t first_digit = temp;\n        vbool4_t cond3 = vmf_and_v_b4(vmfv_f_s.lu32m1_b4(first_digit, subvl), \n                                      vmf_ne_v_i32m1_b4(vmrem_vx_u32m1(vmadd_vx_u32m1(first_digit, 1, subvl), 2, subvl), 0, subvl), subvl);\n\n        // Combine conditions\n        vbool4_t final_mask = vmf_and_v_b4(cond1, vmf_and_v_b4(cond2, cond3, subvl), subvl);\n        result += vm popc_b4(final_mask, subvl);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_132_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t get_max_triples_simd(uint64_t n){\n    uint64_t triples = 0;\n    if (n < 3) return triples;\n\n    size_t vl = vsetvl_e64m1(n);\n    vuint64m1_t va = vmv_v_x_u64m1(0, vl);\n\n    for (uint64_t i = 1; i <= n; ++i){\n        vuint64m1_t vi = vmv_v_x_u64m1(i, vl);\n        vuint64m1_t vi_sq = vmul_vv_u64m1(vi, vi, vl);\n        vuint64m1_t vi_sub = vsub_vx_u64m1(vi_sq, 1, vl);\n        va = vadd_vv_u64m1(va, vi_sub, vl);\n    }\n\n    uint64_t a_mod3[3] = {0};\n    for (size_t i = 0; i < n; ++i){\n        uint64_t val = va.v[i];\n        a_mod3[val % 3]++;\n    }\n\n    triples += (a_mod3[0] * (a_mod3[0] - 1) * (a_mod3[0] - 2)) / 6;\n    triples += (a_mod3[1] * (a_mod3[1] - 1) * (a_mod3[1] - 2)) / 6;\n    triples += (a_mod3[2] * (a_mod3[2] - 1) * (a_mod3[2] - 2)) / 6;\n    triples += (a_mod3[0] * a_mod3[1] * a_mod3[2]);\n\n    return triples;\n}\n```"}
{"task_id": "SimdBench_132_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t get_max_triples_simd(uint64_t n){\n    if (n < 3) return 0;\n\n    uint64_t triples = 0;\n    size_t vl = vsetvl_e64m1(n);\n\n    // Compute vector a\n    vuint64m1_t va = vmv_v_x_u64m1(0, vl);\n    for (uint64_t i = 1; i <= n; ++i) {\n        va = vredmax_vs_u64m1_u64m1(va, vmul_vx_u64m1(va, i, vl), vl);\n        va = vsub_vx_u64m1(va, i - 1, vl);\n        va = vadd_vx_u64m1(va, 1, vl);\n    }\n\n    // Count remainders modulo 3\n    uint64_t count[3] = {0};\n    vuint64m1_t mod3 = vmrem_vx_u64m1(va, 3, vl);\n    for (size_t i = 0; i < n; ++i) {\n        uint64_t val = vget_v_u64(mod3, i);\n        count[val % 3]++;\n    }\n\n    // Calculate number of valid triples\n    triples += count[0] * (count[0] - 1) * (count[0] - 2) / 6;\n    triples += count[1] * (count[1] - 1) * (count[1] - 2) / 6;\n    triples += count[2] * (count[2] - 1) * (count[2] - 2) / 6;\n    triples += count[0] * count[1] * count[2];\n\n    return triples;\n}\n```"}
{"task_id": "SimdBench_132_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t get_max_triples_simd(uint64_t n){\n    uint64_t triples = 0;\n    if (n < 3) return triples;\n\n    size_t vl = vsetvl_e64m1(n);\n    vuint64m1_t va = vmv_v_x_u64m1(0, vl);\n\n    for (uint64_t i = 0; i < n; ++i){\n        va = vredmax_vs_u64m1_u64m1(va, vmul_vx_u64m1(i, i, vl), vl);\n    }\n\n    uint64_t a_mod[3] = {0};\n    for (uint64_t i = 1; i <= n; ++i){\n        uint64_t val = i * i - i + 1;\n        a_mod[val % 3]++;\n    }\n\n    triples += a_mod[0] * (a_mod[0] - 1) * (a_mod[0] - 2) / 6;\n    triples += a_mod[0] * a_mod[1] * a_mod[2];\n    triples += a_mod[1] * (a_mod[1] - 1) / 2 * a_mod[2];\n    triples += a_mod[2] * (a_mod[2] - 1) / 2 * a_mod[1];\n\n    return triples;\n}\n```"}
{"task_id": "SimdBench_132_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t get_max_triples_simd(uint64_t n){\n    uint64_t triples = 0;\n    if (n < 3) return triples;\n\n    size_t vl = vsetvl_e64m1(n);\n    vuint64m1_t va = vmv_v_x_u64m1(0, vl);\n\n    for (uint64_t i = 0; i < n; ++i){\n        uint64_t val = i * i - i + 1;\n        va = vse_v_u64m1(va, i, val, vl);\n    }\n\n    vuint64m1_t vec_3 = vmv_v_x_u64m1(3, vl);\n    uint64_t count_mod[3] = {0};\n\n    for (uint64_t i = 0; i < n; ++i){\n        uint64_t val = va[i];\n        uint64_t mod_val = val % 3;\n        count_mod[mod_val]++;\n    }\n\n    uint64_t c0 = count_mod[0];\n    uint64_t c1 = count_mod[1];\n    uint64_t c2 = count_mod[2];\n\n    triples += (c0 * (c0 - 1) * (c0 - 2)) / 6;\n    triples += (c0 * (c0 - 1) / 2) * (c1 * (c1 - 1) / 2);\n    triples += (c0 * (c0 - 1) / 2) * (c2 * (c2 - 1) / 2);\n    triples += (c1 * (c1 - 1) * (c1 - 2)) / 6;\n    triples += (c2 * (c2 - 1) * (c2 - 2)) / 6;\n    triples += c0 * (c1 * (c1 - 1) / 2);\n    triples += c0 * (c2 * (c2 - 1) / 2);\n    triples += c1 * (c2 * (c2 - 1) / 2);\n    triples += c2 * (c1 * (c1 - 1) / 2);\n    triples += c0 * c1 * c2;\n\n    return triples;\n}\n```"}
{"task_id": "SimdBench_132_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nuint64_t get_max_triples_simd(uint64_t n){\n    uint64_t triples = 0;\n    if (n < 3) return 0;\n\n    size_t vl = vsetvl_e64m1(n);\n    vuint64m1_t va = vmv_v_x_u64m1(0, vl);\n\n    for (uint64_t i = 0; i < n; ++i){\n        uint64_t val = i * i - i + 1;\n        va = vse_v_u64m1(va, val, i, vl);\n    }\n\n    vuint64m1_t vrem0 = vmv_v_x_u64m1(0, vl);\n    vuint64m1_t vrem1 = vmv_v_x_u64m1(0, vl);\n    vuint64m1_t vrem2 = vmv_v_x_u64m1(0, vl);\n\n    for (uint64_t i = 0; i < n; ++i){\n        uint64_t rem = (i * i - i + 1) % 3;\n        if (rem == 0){\n            vrem0 = vse_v_u64m1(vrem0, i, i, vl);\n        }\n        else if (rem == 1){\n            vrem1 = vse_v_u64m1(vrem1, i, i, vl);\n        }\n        else {\n            vrem2 = vse_v_u64m1(vrem2, i, i, vl);\n        }\n    }\n\n    uint64_t count0 = 0, count1 = 0, count2 = 0;\n    for (uint64_t i = 0; i < n; ++i){\n        if (vmsbf_m_u64m1_b64(vrem0, i, vl)) count0++;\n        if (vmsbf_m_u64m1_b64(vrem1, i, vl)) count1++;\n        if (vmsbf_m_u64m1_b64(vrem2, i, vl)) count2++;\n    }\n\n    triples += (count0 / 3) * (count0 - 1) * (count0 - 2) / 6;\n    triples += (count1 / 3) * (count1 - 1) * (count1 - 2) / 6;\n    triples += (count2 / 3) * (count2 - 1) * (count2 - 2) / 6;\n    triples += count0 * ((count1 * (count1 - 1)) / 2);\n    triples += count0 * ((count2 * (count2 - 1)) / 2);\n    triples += count1 * ((count2 * (count2 - 1)) / 2);\n    triples += count2 * ((count1 * (count1 - 1)) / 2);\n\n    return triples;\n}\n```"}
{"task_id": "SimdBench_133_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint x_or_y_simd(int n, int x, int y){\n    if (n < 2) return y;\n\n    size_t vl = vsetvl_e32m1(1);\n    vuint32m1_t vn = vmv_v_x_i32m1(n, vl);\n    vbool4_t is_prime = vmsne_vx_b4m1(vn, 1, vl);\n\n    for(int i=2; i*i<=n; i++){\n        vbool4_t cond = vmseq_vx_b4m1(vn, i, vl);\n        is_prime = vand_vv_b4m1(is_prime, vnot_v_b4m1(cond, vl), vl);\n        if(vmv_x_s_b4f4_m(vanyne_v_b4m1(is_prime, vmsne_vx_b4m1(vn, n, vl), vl)) == 0){\n            return y;\n        }\n    }\n    return x;\n}\n```"}
{"task_id": "SimdBench_133_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    if (n < 2) return y;\n\n    int is_prime = 1;\n    int limit = (int)(sqrt(n) + 0.5);\n\n    size_t vl = vsetvl_e32m1(limit);\n    vuint32m1_t v_i = vid_v_u32m1(vl);\n    vbool32_t mask = vmleu_vx_b32m1(v_i, limit, vl);\n\n    vuint32m1_t vn = vmv_v_x_u32m1(n, vl);\n    vuint32m1_t v_zero = vmv_v_x_u32m1(0, vl);\n\n    for (int i = 2; i <= limit; i++) {\n        vuint32m1_t v_mod = vremu_vx_u32m1(vn, i, vl);\n        vbool32_t eq_mask = vmseq_vx_b32m1(v_mod, 0, vl);\n        eq_mask = vand_vv_b32m1(eq_mask, mask, vl);\n        vuint32m1_t temp = vmERGE_vx_u32m1(v_zero, 1, vl);\n        temp = vmerge_vvm_u32m1(temp, v_zero, eq_mask, vl);\n        uint32_t result = vmfirst_m_u32m1(temp, vl);\n        if (result) {\n            is_prime = 0;\n            break;\n        }\n    }\n\n    return is_prime ? x : y;\n}\n```"}
{"task_id": "SimdBench_133_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint x_or_y_simd(int n, int x, int y){\n    if (n < 2) return y;\n\n    int is_prime = 1;\n    int limit = n / 2;\n\n    size_t vl = vsetvl_e32m1(limit);\n    vuint32m1_t v_i = vid_v_u32m1(vl);\n    vuint32m1_t v_n = vmv_v_x_u32m1(n, vl);\n    vuint32m1_t v_one = vmv_v_x_u32m1(1, vl);\n\n    vbool32_t mask = vmuleq_vv_b32m1_b(v_n, v_i, v_i, vl);\n    mask = vor_vv_b32m1_b(mask, veq_vx_b32m1_b(v_i, v_one, vl));\n\n    int result = vmfirst_m_b32_i32(mask, vl);\n    if (result != -1) {\n        is_prime = 0;\n    }\n\n    return is_prime ? x : y;\n}\n```"}
{"task_id": "SimdBench_133_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint x_or_y_simd(int n, int x, int y){\n    if (n < 2) return y;\n\n    int is_prime = 1;\n    int limit = (int)vsetvl_e32m1(1);\n    vbool32_t mask = vmv_v_x_b32(0, limit);\n    vint32m1_t vn = vmv_v_x_i32m1(n, limit);\n\n    for(int i=2; i*i <= n; i++){\n        vint32m1_t vi = vmv_v_x_i32m1(i, limit);\n        vbool32_t cmp = vmseq_vv_b32m1(vn, vi, mask);\n        is_prime &= !vmbitirst_m_b32(cmp);\n    }\n\n    return is_prime ? x : y;\n}\n```"}
{"task_id": "SimdBench_133_RVV", "completion": "```c\n#include <riscv_vector.h>\n\nint x_or_y_simd(int n, int x, int y){\n    if (n < 2) return y;\n\n    size_t vl = vsetvl_e32m1(1);\n    vbool32_t true_bitmask = vmv_v_x_b32(true, vl);\n    vbool32_t false_bitmask = vmv_v_x_b32(false, vl);\n\n    int is_prime = 1;\n    for(int i=2; i*i<=n; i++){\n        size_t vl = vsetvl_e32m1(1);\n        vbool32_t condition = (n % i == 0);\n        int temp = vmf_eq_b32_m(condition, true_bitmask, false_bitmask, vl);\n        is_prime &= !temp;\n    }\n\n    return (is_prime ? x : y);\n}\n```"}
{"task_id": "SimdBench_134_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n#include <stdlib.h>\n\nuint64_t double_the_difference_simd(const float *lst, size_t len) {\n    uint64_t sum = 0;\n    size_t vlmax = vsetvl_e32m1(len);\n    for (size_t i = 0; i < len; i += vlmax) {\n        size_t vl = vsetvl_e32m1(len - i);\n        vfloat32m1_t vmask = vfmv_v_f_f32m1(0.0f, vl);\n        vfloat32m1_t vsrc = vle32_v_f32m1((const float *)&lst[i], vl);\n        \n        vmask = vfsgnj_vv_f32m1(vsrc, vsrc, vl); // Get absolute value\n        vmask = vfcvt_xu_f_v_u32m1(vmask, vl);   // Convert to unsigned integer\n        \n        vbool32_t is_odd = vmfredosum_vs_b32m1_b32m1(vmask & 1, vmask, vl); // Check if odd\n        \n        vfloat32m1_t vsqr = vmul_vv_f32m1(vsrc, vsrc, vl); // Square the values\n        vsqr = vfwredsum_vs_f32m1_f32m1(vsqr, vsqr, is_odd, vl); // Sum squares of odd numbers\n        \n        float temp_sum = vfmv_f_s_f32m1_f32(vsqr);\n        sum += (uint64_t)temp_sum;\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <cmath>\n\nuint64_t double_the_difference_simd(const std::vector<float> &lst) {\n    uint64_t sum = 0;\n    if (lst.empty()) return sum;\n\n    size_t size = lst.size();\n    float *data = const_cast<float *>(lst.data());\n\n    size_t vlmax = vsetvl_e32m1(size);\n    vfloat32m1_t vmask, vdata, vsquares, vzero, vone_half;\n\n    vzero = vmv_v_f_f32m1(0.0f, vlmax);\n    vone_half = vmv_v_f_f32m1(0.5f, vlmax);\n\n    for (size_t i = 0; i < size; i += vlmax) {\n        size_t vl = vsetvl_e32m1(size - i);\n        vdata = vle32_v_f32m1(data + i, vl);\n\n        // Check if the number is non-negative and integer\n        vmask = vfsgnjx_vv_f32m1(vdata, vdata, vl); // Absolute value\n        vmask = vfadd_vv_f32m1(vmask, vone_half, vl); // Add 0.5\n        vmask = vrndu_vf_f32m1(vmask, vl); // Round up to nearest integer\n        vmask = vfcvt_f_x_v_i32m1(vmask, vl); // Convert to int\n        vmask = vfne_vv_f32m1(vmask, vdata, vl); // Check if original was not an integer\n\n        // Mask out negative or non-integer values\n        vdata = vfredosum_vs_f32m1_f32m1(vdata, vzero, vl);\n\n        // Check if the number is odd\n        vmask = vrem_vv_i32m1(vmask, vmv_v_i_i32m1(2, vl), vl);\n        vmask = vmsne_vv_i32m1(vmask, vmv_v_i_i32m1(0, vl), vl);\n\n        // Square the numbers that are odd\n        vsquares = vmul_vv_f32m1(vdata, vdata, vl);\n\n        // Sum the squares\n        sum += (uint64_t)vfredusum_vs_f32m1_f32m1(vsquares, vzero, vl);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n#include <stdlib.h>\n\nuint64_t double_the_difference_simd(const float *lst, size_t length){\n    uint64_t sum = 0;\n    size_t vlmax = vsetvl_e32m1(length);\n    for(size_t i=0; i<length; i+=vlmax){\n        size_t vl = vsetvl_e32m1(length - i);\n        vfloat32m1_t vmasked = vlrsqrt8ff_v_f32m1(0.0f, vl); // dummy load to set VL\n        vmasked = vle32_v_f32m1((const float *)&lst[i], vl);\n        \n        vfloat32m1_t vzero = vmv_v_x_f32m1(0.0f, vl);\n        vbool8_t is_positive = vmfgt_vf_b8(vmasked, 0.0f, vl);\n        vmasked = vfcvt_xu_f_v_f32m1(vmasked, vl); // convert to int\n        vbool8_t is_odd = vmfne_vx_b8(vmasked, 0, vl);\n        vbool8_t mask = vmand_mm(is_positive, is_odd, vl);\n        \n        vmasked = vfmerge_vfm_f32m1(0.0f, vmasked, mask, vl);\n        vmasked = vmul_vv_f32m1(vmasked, vmasked, vl); // square\n        \n        float temp_sum = 0.0f;\n        for(size_t j=0; j<vl; j++){\n            temp_sum += vmasked[j];\n        }\n        sum += (uint64_t)temp_sum;\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n#include <stdlib.h>\n\nuint64_t double_the_difference_simd(const float *lst, size_t len) {\n    uint64_t sum = 0;\n    size_t vlmax = vsetvl_e32m8(len);\n    vfloat32m8_t v_zero = vmv_v_x_f32m8(0.0f, vlmax);\n    vfloat32m8_t v_half = vmv_v_x_f32m8(0.5f, vlmax);\n    vfloat32m8_t v_one = vmv_v_x_f32m8(1.0f, vlmax);\n\n    for (size_t i = 0; i < len; i += vlmax) {\n        size_t vl = vsetvl_e32m8(len - i);\n        vfloat32m8_t v_num = vle32_v_f32m8(lst + i, vl);\n        vfloat32m8_t v_abs_num = vfabs_v_f32m8(v_num, vl);\n        vfloat32m8_t v_floor_num = vrnddown_v_f32m8(v_abs_num, vl);\n        vfloat32m8_t v_diff = vsub_vv_f32m8(v_abs_num, v_floor_num, vl);\n        vbool8_t is_odd = vfclass_v_f32m8_b8(v_diff, VFCLASS_F32_ANY_SNAN | VFCLASS_F32_ZERO, vl);\n        vfloat32m8_t v_int_part = vand_vv_f32m8(v_floor_num, vmv_v_x_f32m8(1.0f, vl), vl);\n        vfloat32m8_t v_sq = vmul_vv_f32m8(v_int_part, v_int_part, vl);\n        vfloat32m8_t v_masked_sq = vfcvt_xu_f_f32m8(vsq, vl);\n        sum += vredsum_vs_u32m8_u64(vmask, vmask, vl);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_RVV", "completion": "```c\n#include <riscv_vector.h>\n#include <stdint.h>\n#include <stdlib.h>\n\nuint64_t double_the_difference_simd(const float *lst, size_t len){\n    uint64_t sum = 0;\n    size_t vlmax = vsetvl_e32m1(len);\n    for(size_t i=0; i<len; i+=vlmax){\n        size_t vl = vsetvl_e32m1(len - i);\n        vfloat32m1_t v_lst = vle32_v_f32m1((const float *)&lst[i], vl);\n        vmask_t mask = vmfle_vf_f32m1_b8(v_lst, 0.0f, vl); // Create a mask for non-negative numbers\n        vfloat32m1_t v_floor = vftrunc_wx_f32m1_f32m1(v_lst, vl); // Floor the values\n        vfloat32m1_t v_diff = vfsub_vv_f32m1(v_lst, v_floor, vl); // Calculate difference between original and floored value\n        vmask_t int_mask = vmsle_vf_f32m1_b8(v_diff, 0.0f, vl); // Mask for integer values\n        vmask_t combined_mask = vmand_vv_b8(mask, int_mask, vl); // Combine masks\n        vfloat32m1_t v_odd_mask = vfmul_vf_f32m1(v_floor, 2.0f, vl); // Multiply by 2\n        vfloat32m1_t v_is_odd = vfredosum_vs_f32m1_f32m1(vmfne_vv_f32m1_b8(v_floor, v_odd_mask, vl), 0.0f, vl); // Check if odd\n        vmask_t odd_mask = vmfne_vf_f32m1_b8(v_is_odd, 0.0f, vl); // Mask for odd numbers\n        vmask_t final_mask = vmand_vv_b8(combined_mask, odd_mask, vl); // Final mask\n        vfloat32m1_t v_sq = vmulf_vf_f32m1(v_floor, v_floor, vl); // Square the values\n        vfloat32m1_t v_sum_sq = vfredsum_vs_f32m1_f32m1(final_mask, v_sq, 0.0f, vl); // Sum of squares\n        sum += (uint64_t)vfmv_f_s_f32(v_sum_sq);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_135_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess){\n    size_t size = game.size();\n    std::vector<int> result(size, 0);\n\n    if (size == 0) return result;\n\n    size_t i = 0;\n    size_t vlmax = vsetvl_e32m1(size);\n    while(i < size){\n        size_t vl = vsetvl_e32m1(std::min(vlmax, size - i));\n        vint32m1_t vg = vle32_v_i32m1(&guess[i], vl);\n        vint32m1_t vs = vle32_v_i32m1(&game[i], vl);\n        vbool32_t eq_mask = vmseq_vv_b32m1(vs, vg, vl);\n        vint32m1_t diff = vsub_vv_i32m1(vs, vg, vl);\n        vint32m1_t abs_diff = vfsgnjx_vv_f32m1_f32m1((vfloat32m1_t)diff, (vfloat32m1_t)diff, vl);\n        vint32m1_t res = vmux_vv_i32m1(eq_mask, 0, (vint32m1_t)abs_diff, vl);\n        vse32_v_i32m1(&result[i], (vint32m1_t)res, vl);\n        i += vl;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess){\n    size_t size = game.size();\n    std::vector<int> result(size, 0);\n\n    if (size == 0) return result;\n\n    size_t vl = 0;\n    int* res_data = result.data();\n    const int* game_data = game.data();\n    const int* guess_data = guess.data();\n\n    for(size_t i = 0; i < size; i += vl){\n        vl = vsetvl_e32m1(std::min((size - i), (size_t)512));\n        vint32m1_t vg = vle32_v_i32m1(&guess_data[i], vl);\n        vint32m1_t vs = vle32_v_i32m1(&game_data[i], vl);\n        vint32m1_t vd = vsub_vv_i32m1(vs, vg, vl);\n        vuint32m1_t va = vmseq_vv_i32m1_b32(vs, vg, vl);\n        vd = vmabs_vv_i32m1(vd, vl);\n        vd = vmux_vvm_i32m1(vd, vmsub_vv_i32m1(va, va, va, vl), va, vl);\n        vse32_v_i32m1(&res_data[i], vd, vl);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess){\n    size_t size = game.size();\n    std::vector<int> result(size, 0);\n\n    if (size == 0) return result;\n\n    size_t i = 0;\n    size_t vlmax = vsetvl_e32m1(size);\n    int *game_ptr = const_cast<int*>(game.data());\n    int *guess_ptr = const_cast<int*>(guess.data());\n    int *result_ptr = result.data();\n\n    for (; i <= size - vlmax; i += vlmax) {\n        vint32m1_t vg = lv_int32_v(game_ptr + i, vlmax);\n        vint32m1_t vs = lv_int32_v(guess_ptr + i, vlmax);\n        vint32m1_t vd = vsub_vv_i32m1(vg, vs, vlmax);\n        vuint32m1_t vabsd = vabsu_v_i32m1(vd, vlmax);\n        sv_int32_v(result_ptr + i, vabsd, vlmax);\n    }\n\n    // Handle remaining elements\n    vlmax = vsetvl_e32m1(size - i);\n    if (i < size) {\n        vint32m1_t vg = lv_int32_v(game_ptr + i, vlmax);\n        vint32m1_t vs = lv_int32_v(guess_ptr + i, vlmax);\n        vint32m1_t vd = vsub_vv_i32m1(vg, vs, vlmax);\n        vuint32m1_t vabsd = vabsu_v_i32m1(vd, vlmax);\n        sv_int32_v(result_ptr + i, vabsd, vlmax);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess){\n    size_t size = game.size();\n    std::vector<int> result(size, 0);\n\n    if (size == 0) return result;\n\n    size_t vlmax = vsetvl_e32m1(size);\n    int* res_ptr = result.data();\n    const int* game_ptr = game.data();\n    const int* guess_ptr = guess.data();\n\n    for(size_t i = 0; i < size; i += vlmax){\n        size_t vl = vsetvl_e32m1(std::min(vlmax, size - i));\n        vint32m1_t vg = vle32_v_i32m1(game_ptr + i, vl);\n        vint32m1_t vs = vle32_v_i32m1(guess_ptr + i, vl);\n        vint32m1_t vd = vsub_vv_i32m1(vs, vg, vl);\n        vbool32_t vmask = vmseq_vv_b32m1(vs, vg, vl);\n        vuint32m1_t vabsdiff = vabsu_v_i32m1(vd, vl);\n        vse32_v_i32m1(res_ptr + i, vmfc_m_f32m1_v_u32m1(vmask, vabsdiff, vl), vl);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess){\n    size_t size = game.size();\n    std::vector<int> result(size, 0);\n\n    if (size == 0) return result;\n\n    size_t vl = vsetvl_e32m1(size);\n    vint32m1_t vresult;\n    vint32m1_t vgame;\n    vint32m1_t vguess;\n\n    for(size_t i = 0; i < size; i += vl){\n        size_t actual_vl = std::min(vl, size - i);\n        vgame = vle32_v_i32m1(&game[i], actual_vl);\n        vguess = vle32_v_i32m1(&guess[i], actual_vl);\n        vresult = vsub_vv_i32m1(vgame, vguess, actual_vl);\n        vresult = vmabs_v_i32m1(vresult, actual_vl);\n        vse32_v_i32m1(&result[i], vresult, actual_vl);\n    }\n    return result;\n}\n```"}

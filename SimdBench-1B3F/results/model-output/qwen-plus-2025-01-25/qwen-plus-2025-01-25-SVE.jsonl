{"task_id": "SimdBench_0_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b64();\n    const size_t vec_len = svcntd();\n\n    for (; i <= length - vec_len; i += vec_len) {\n        svbool_t pred = svcmpeq_b64(pg, svreinterpret_m_u64_z(pg, svld1_b8(pg, mask + i)), 1);\n        svst1_s64(pg, dst + i, svsel_s64(pred, svld1_s64(pg, src + i), svld1_s64(pg, dst + i)));\n    }\n\n    if (i < length) {\n        svbool_t pg_partial = svwhilelt_b64(i, length);\n        svbool_t pred = svcmpeq_b64(pg_partial, svreinterpret_m_u64_z(pg_partial, svld1_b8(pg_partial, mask + i)), 1);\n        svst1_s64(pg_partial, dst + i, svsel_s64(pred, svld1_s64(pg_partial, src + i), svld1_s64(pg_partial, dst + i)));\n    }\n}\n```"}
{"task_id": "SimdBench_0_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b64();\n    svbool_t pred;\n\n    while (i + svcntd() <= length) {\n        // Load mask values into a predicate register\n        pred = svcmpeq_b64(svlde1g_b64(pg, mask + i), 1);\n\n        // Load source data\n        svint64_t vec_src = svld1(pg, src + i);\n\n        // Conditionally store into destination\n        svst1(pred, dst + i, vec_src);\n\n        i += svcntd();\n    }\n\n    // Handle remaining elements if length is not a multiple of svcntd()\n    if (i < length) {\n        pg = svwhilelt_b64(i, length);\n        pred = svcmpeq_b64(svlde1g_b64(pg, mask + i), 1);\n\n        svint64_t vec_src = svld1(pg, src + i);\n        svst1(pred, dst + i, vec_src);\n    }\n}\n```"}
{"task_id": "SimdBench_0_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b64();\n    svbool_t pred;\n\n    while (i + svcntd() <= length) {\n        svint64_t s = svld1(pg, &src[i]);\n        svint64_t d = svld1(pg, &dst[i]);\n        pred = svcmpeq(pg, svreinterpret_b64_m(svtrue_b8(), svld1(pg, &mask[i])), svdup_n_b64(0));\n        svst1(pg, &dst[i], svsel(pred, s, d));\n        i += svcntd();\n    }\n\n    if (i < length) {\n        size_t left = length - i;\n        pg = svwhilelt_b64(i, length);\n        svint64_t s = svld1(pg, &src[i]);\n        svint64_t d = svld1(pg, &dst[i]);\n        pred = svcmpeq(pg, svreinterpret_b64_m(svtrue_b8(), svld1(pg, &mask[i])), svdup_n_b64(0));\n        svst1(pg, &dst[i], svsel(pred, s, d));\n    }\n}\n```"}
{"task_id": "SimdBench_0_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b64();\n    svbool_t pred;\n\n    while (i + svcntd() <= length) {\n        pred = svcmpeq_b64(pg, *(svbool_t *)mask, svtrue_b64());\n        svst1_s64(pred, dst, svld1_s64(pg, src));\n        src += svcntd();\n        dst += svcntd();\n        mask += svcntd();\n        i += svcntd();\n    }\n\n    if (i < length) {\n        size_t left = length - i;\n        pg = svwhilelt_b64(i, length);\n        pred = svcmpeq_b64(pg, *(svbool_t *)mask, svtrue_b64());\n        svst1_s64(pred, dst, svld1_s64(pg, src));\n    }\n}\n```"}
{"task_id": "SimdBench_0_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b64();\n    svbool_t pred;\n\n    while (i + svcntd() <= length) {\n        svbool_t mask_vec = svcmpeq_b64(svtrue_b64(), svld1_b64(pg, &mask[i]));\n        svint64_t src_vec = svld1(pg, &src[i]);\n        svst1(pg, &dst[i], svsel(mask_vec, src_vec, svld1(pg, &dst[i])));\n        i += svcntd();\n    }\n\n    if (i < length) {\n        pg = svwhilelt_b64((svint64_t){(int64_t)i}, (svint64_t){(int64_t)length});\n        svbool_t mask_vec = svcmpeq_b64(pg, svld1_b64(pg, &mask[i]));\n        svint64_t src_vec = svld1(pg, &src[i]);\n        svst1(pg, &dst[i], svsel(mask_vec, src_vec, svld1(pg, &dst[i])));\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t index = 0;\n    svbool_t pg = svptrue_b32();\n    const int shift_right = 3;\n    const int shift_left = 3;\n    const int divide_by = 7;\n\n    while (index <= length - svcntw()) {\n        svint32_t s = svld1(pg, &src[index]);\n        svint32_t scaled = svmul_x(pg, s, svdup_n_s32(scale));\n        \n        svint32_t tmp1 = svshr_n_x(pg, scaled, shift_right);\n        svint32_t tmp2 = svshl_n_x(pg, scaled, shift_left);\n        \n        svint32_t product = svmul_x(pg, tmp1, tmp2);\n        svint32_t result = svadd_x(pg, scaled, product);\n        result = svdiv_x(pg, result, svdup_n_s32(divide_by));\n        \n        svst1(pg, &dst[index], result);\n        index += svcntw();\n    }\n\n    // Handle remaining elements if length is not a multiple of svcntw()\n    if (index < length) {\n        svbool_t pg_partial = svwhilelt_b32(index, length);\n        svint32_t s = svld1(pg_partial, &src[index]);\n        svint32_t scaled = svmul_x(pg_partial, s, svdup_n_s32(scale));\n        \n        svint32_t tmp1 = svshr_n_x(pg_partial, scaled, shift_right);\n        svint32_t tmp2 = svshl_n_x(pg_partial, scaled, shift_left);\n        \n        svint32_t product = svmul_x(pg_partial, tmp1, tmp2);\n        svint32_t result = svadd_x(pg_partial, scaled, product);\n        result = svdiv_x(pg_partial, result, svdup_n_s32(divide_by));\n        \n        svst1(pg_partial, &dst[index], result);\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t index = 0;\n    svbool_t pg = svptrue_b32();\n    svint32_t s_scale = svdup_n_s32(scale);\n\n    while (index <= length - sve_vl()) {\n        svint32_t s_src = svld1(pg, &src[index]);\n        svint32_t s_mul = svmul_x(pg, s_src, s_scale);\n        \n        svint32_t tmp1 = svsshiftr_x(pg, s_mul, 3);\n        svint32_t tmp2 = svsshiftl_x(pg, s_mul, 3);\n        \n        svint32_t product = svmul_x(pg, tmp1, tmp2);\n        svint32_t sum = svadd_x(pg, s_mul, product);\n        \n        svint32_t result = svdiv_x(pg, sum, 7);\n        svst1(pg, &dst[index], result);\n        \n        index += sve_vl();\n    }\n\n    // Handle leftover elements with scalar code if necessary\n    for (; index < length; ++index) {\n        int element = src[index];\n        int tmp1 = (element * scale) >> 3;\n        int tmp2 = (element * scale) << 3;\n        int result = (element * scale + tmp1 * tmp2) / 7;\n        dst[index] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t index = 0;\n    svbool_t pg = svptrue_b32();\n    svint32_t vscale = svdup_n_s32(scale);\n\n    while (index <= length - sve_vl()) {\n        svint32_t vsrc = svld1(pg, &src[index]);\n        svint32_t vmul = svmul_x(pg, vsrc, vscale);\n        \n        svint32_t vtmp1 = svasr_x(pg, vmul, 3);\n        svint32_t vtmp2 = svsl_x(pg, vmul, 3);\n        \n        svint32_t vresult = svadd_x(pg, vmul, svmul_x(pg, vtmp1, vtmp2));\n        vresult = svdiv_x(pg, vresult, 7);\n        \n        svst1(pg, &dst[index], vresult);\n        \n        index += sve_vl();\n    }\n\n    // Handle leftover elements if any\n    for (; index < length; ++index) {\n        int element = src[index];\n        int tmp1 = (element * scale) >> 3;\n        int tmp2 = (element * scale) << 3;\n        dst[index] = (element * scale + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n    size_t i = 0;\n\n    for (; i <= length - vl; i += vl) {\n        svint32_t svec = svld1(pg, &src[i]);\n        svint32_t scaled = svmul_x(pg, svec, svdup_n_s32(scale));\n        \n        svint32_t tmp1 = svshr_x(pg, scaled, svdup_n_s32(3));\n        svint32_t tmp2 = svshl_x(pg, scaled, svdup_n_s32(3));\n        \n        svint32_t product = svmul_x(pg, tmp1, tmp2);\n        svint32_t sum = svadd_x(pg, scaled, product);\n        \n        svint32_t result = svdiv_x(pg, sum, svdup_n_s32(7));\n        \n        svst1(pg, &dst[i], result);\n    }\n\n    // Handle leftover elements\n    if (i < length) {\n        svbool_t pg_partial = svwhilelt_b32(i, length);\n        svint32_t svec = svld1(pg_partial, &src[i]);\n        svint32_t scaled = svmul_x(pg_partial, svec, svdup_n_s32(scale));\n        \n        svint32_t tmp1 = svshr_x(pg_partial, scaled, svdup_n_s32(3));\n        svint32_t tmp2 = svshl_x(pg_partial, scaled, svdup_n_s32(3));\n        \n        svint32_t product = svmul_x(pg_partial, tmp1, tmp2);\n        svint32_t sum = svadd_x(pg_partial, scaled, product);\n        \n        svint32_t result = svdiv_x(pg_partial, sum, svdup_n_s32(7));\n        \n        svst1(pg_partial, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t index = 0;\n    svbool_t pg = svptrue_b32();\n    while (index <= length - svcntw()) {\n        svint32_t svec = svld1(pg, src + index);\n        svint32_t scaled = svmul_x(pg, svec, svdup_n_s32(scale));\n        \n        svint32_t tmp1 = svshr_x(pg, scaled, 3);\n        svint32_t tmp2 = svshl_x(pg, scaled, 3);\n        \n        svint32_t product = svmul_x(pg, tmp1, tmp2);\n        svint32_t result = svadd_x(pg, scaled, product);\n        svint32_t final_result = svdiv_x(pg, result, 7);\n        \n        svst1(pg, dst + index, final_result);\n        index += svcntw();\n    }\n    for (; index < length; ++index) {\n        int element = src[index];\n        int tmp1 = (element * scale) >> 3;\n        int tmp2 = (element * scale) << 3;\n        int result = (element * scale + tmp1 * tmp2) / 7;\n        dst[index] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t vl = svcntd(); // Vector length in terms of double-precision elements\n    size_t i = 0;\n\n    for (; i <= rows - vl; i += vl) {\n        svindex_t index = svindex_s64((svint64_t)(stride + i * (int64_t)cols), (svint64_t)cols);\n        svbool_t pg = svptrue_b64();\n        svfloat64_t vec = svld1_gather_index_f64(pg, src, index);\n        svst1_f64(pg, &dst[i], vec);\n    }\n\n    for (; i < rows; i++) {\n        dst[i] = src[i * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t vl = svcntd(); // Vector length in terms of double-precision elements\n    size_t i = 0;\n\n    for (; i <= rows - vl; i += vl) {\n        svindex_s64 idx(0, cols); // Generate indices: 0, cols, 2*cols, ..., (vl-1)*cols\n        svbool_t pg = svptrue_b64(); // Predicate for all active lanes\n        svfloat64_t vec = svld1_gather_offset_z(pg, SV_NULL_F64, src + stride, idx); // Gather load\n        svst1(pg, dst + i, vec); // Store the vector into dst\n    }\n\n    // Handle remaining rows (if any)\n    if (i < rows) {\n        size_t remaining = rows - i;\n        svbool_t pg = svptrue_b64_first(remaining); // Generate predicate for remaining elements\n        svindex_s64 idx(0, cols); // Generate indices: 0, cols, 2*cols, ..., (remaining-1)*cols\n        svfloat64_t vec = svld1_gather_offset_z(pg, SV_NULL_F64, src + stride, idx); // Gather load\n        svst1(pg, dst + i, vec); // Store the vector into dst\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    svbool_t pg = svptrue_b64();\n    size_t i = 0;\n    svfloat64_t vec;\n\n    for (; i <= rows - svcntd(); i += svcntd()) {\n        // Calculate indices for loading from src\n        size_t indices[svcntd()];\n        for (size_t j = 0; j < svcntd(); j++) {\n            indices[j] = (i + j) * cols + stride;\n        }\n\n        // Gather load from src using calculated indices\n        vec = svld1_gather_offset_z(pg, SV_NULL, src, indices);\n\n        // Store the loaded values into dst\n        svst1(pg, &dst[i], vec);\n    }\n\n    // Handle leftover rows if rows is not a multiple of svcntd()\n    if (i < rows) {\n        size_t num_leftovers = rows - i;\n        svbool_t pg_partial = svwhilelt_b64(i, rows);\n\n        // Calculate indices for loading from src\n        size_t indices[svcntd()];\n        for (size_t j = 0; j < svcntd(); j++) {\n            indices[j] = (i + j) * cols + stride;\n        }\n\n        // Gather load from src using calculated indices\n        vec = svld1_gather_offset_z(pg_partial, SV_NULL, src, indices);\n\n        // Store the loaded values into dst\n        svst1(pg_partial, &dst[i], vec);\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    svbool_t pg = svptrue_b64();\n    size_t i = 0;\n    svindex_s64 indices = svindex_s64(0, cols);\n\n    while (i + svcntd() <= rows) {\n        svuint64_t src_indices = svadd_x_u64(pg, svmul_x_u64(pg, indices, i), stride);\n        svfloat64_t data = svld1_gather_index_f64(pg, src, src_indices);\n        svst1_f64(pg, &dst[i], data);\n        i += svcntd();\n    }\n\n    if (i < rows) {\n        size_t left = rows - i;\n        svbool_t pg_left = svwhilelt_b64(i, rows);\n        svuint64_t src_indices = svadd_x_u64(pg_left, svmul_x_u64(pg_left, indices, i), stride);\n        svfloat64_t data = svld1_gather_index_f64(pg_left, src, src_indices);\n        svst1_f64(pg_left, &dst[i], data);\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t vl = svcntd(); // Vector length in terms of double-precision elements\n    size_t i = 0;\n\n    for (; i <= rows - vl; i += vl) {\n        svindex_t indices = svindex_s64(i, 1);\n        svbool_t pg = svptrue_b64();\n        \n        // Compute the source addresses for the strided load\n        svuint64_t src_offsets = svadd_x_u64(svdup_n_u64(stride), svmla_x_u64(svmul_x_u64(svindex_u64(i, 1), svdup_n_u64(cols)), svdup_n_u64(stride)));\n        svfloat64_t loaded_data = svld1_gather_index(pg, src, src_offsets);\n\n        // Store the loaded data into the dst array\n        svst1(pg, &dst[i], loaded_data);\n    }\n\n    // Handle leftover rows (if any)\n    if (i < rows) {\n        size_t vl_left = rows - i;\n        svbool_t pg = svwhilelt_b64(i, rows);\n\n        // Compute the source addresses for the strided load\n        svuint64_t src_offsets = svadd_x_u64(svdup_n_u64(stride), svmla_x_u64(svmul_x_u64(svindex_u64(i, 1), svdup_n_u64(cols)), svdup_n_u64(stride)));\n        svfloat64_t loaded_data = svld1_gather_index(pg, src, src_offsets);\n\n        // Store the loaded data into the dst array\n        svst1(pg, &dst[i], loaded_data);\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    svbool_t pg = svptrue_b32();\n    size_t vec_len = svcntw(); // Number of 32-bit elements in a vector\n    size_t i = 0;\n\n    for (; i <= length - vec_len; i += vec_len) {\n        // Load indices\n        svint32_t svidx = svld1(pg, &indices[i]);\n\n        // Gather operation: load from src using indices\n        svfloat32_t gather_data = svld1_gather_offset_z(pg, src, svidx, sizeof(float));\n\n        // Store gathered data into dst (direct copy)\n        svst1(pg, &dst[i], gather_data);\n\n        // Scatter operation: store src values to dst using indices as write locations\n        svst1_scatter_offset(pg, dst, svidx, gather_data, sizeof(float));\n    }\n\n    // Handle leftover elements (if any)\n    if (i < length) {\n        svbool_t pg_partial = svwhilelt_b32(i, length);\n        size_t left = length - i;\n\n        // Load indices\n        svint32_t svidx = svld1(pg_partial, &indices[i]);\n\n        // Gather operation: load from src using indices\n        svfloat32_t gather_data = svld1_gather_offset_z(pg_partial, src, svidx, sizeof(float));\n\n        // Store gathered data into dst (direct copy)\n        svst1(pg_partial, &dst[i], gather_data);\n\n        // Scatter operation: store src values to dst using indices as write locations\n        svst1_scatter_offset(pg_partial, dst, svidx, gather_data, sizeof(float));\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < length; i += vl) {\n        size_t chunk = (length - i > vl) ? vl : (length - i);\n\n        svbool_t pg_chunk = svwhilelt_b32(i, i + chunk);\n\n        // Load indices\n        svint32_t svidx = svld1(pg_chunk, &indices[i]);\n\n        // Gather operation: load from src using indices\n        svfloat32_t gathered = svld1_gather_index(pg_chunk, src, svidx);\n\n        // Store gathered values into dst\n        svst1(pg_chunk, &dst[i], gathered);\n\n        // Scatter operation: load from src and scatter to dst using indices\n        svfloat32_t src_vals = svld1(pg_chunk, &src[i]);\n        svst1_scatter_index(pg_chunk, dst, svidx, src_vals);\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    svbool_t pg = svptrue_b32();\n    size_t vec_len = svcntw(); // Number of elements in a vector\n    size_t i = 0;\n\n    for (; i <= length - vec_len; i += vec_len) {\n        // Load indices\n        svint32_t svidx = svld1(pg, &indices[i]);\n\n        // Gather operation: load from src using indices\n        svfloat32_t gather_vals = svld1_gather_index(pg, src, svidx);\n\n        // Store gathered values into dst (copy to destination)\n        svst1(pg, &dst[i], gather_vals);\n\n        // Scatter operation: load values from src\n        svfloat32_t scatter_vals = svld1(pg, &src[i]);\n\n        // Scatter these values into dst using indices\n        svst1_scatter_index(pg, dst, svidx, scatter_vals);\n    }\n\n    // Handle leftover elements (if any)\n    if (i < length) {\n        svbool_t pg_partial = svwhilelt_b32(i, length);\n        size_t left = length - i;\n\n        // Load indices\n        svint32_t svidx = svld1(pg_partial, &indices[i]);\n\n        // Gather operation: load from src using indices\n        svfloat32_t gather_vals = svld1_gather_index(pg_partial, src, svidx);\n\n        // Store gathered values into dst (copy to destination)\n        svst1(pg_partial, &dst[i], gather_vals);\n\n        // Scatter operation: load values from src\n        svfloat32_t scatter_vals = svld1(pg_partial, &src[i]);\n\n        // Scatter these values into dst using indices\n        svst1_scatter_index(pg_partial, dst, svidx, scatter_vals);\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    svbool_t pg = svptrue_b32();\n    for (size_t i = 0; i < length; i += svcntw()) {\n        size_t vl = SVE_VL;\n        svbool_t pred = svwhilelt_b32(i, length);\n        svint32_t svidx = svld1_gather_index_z(pred, indices + i, i, sizeof(float));\n        svfloat32_t svsrc = svld1_gather_offset_z(pred, src, svidx, sizeof(float));\n        svst1_scatter_index(pred, dst + i, i, svsrc, sizeof(float));\n        svst1(pred, dst + i, svsrc);\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < length; i += vl) {\n        size_t chunk = (length - i > vl) ? vl : length - i;\n\n        svbool_t pgi = svwhilelt_b32(i, i + chunk);\n\n        // Load indices\n        svint32_t idx_vec = svld1_gather_offset_z(pg, indices + i, pgi);\n\n        // Gather operation: load from src using indices\n        svfloat32_t gather_vec = svld1_gather_index(pg, src, idx_vec);\n\n        // Store the gathered values into dst\n        svst1_scatter_index(pg, dst, idx_vec, gather_vec);\n\n        // Scatter operation: store src values into dst using indices\n        svfloat32_t src_vec = svld1(pg, src + i);\n        svst1_scatter_offset(pg, dst, idx_vec, src_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t index = start;\n    uint64_t last = end;\n\n    while (index < last) {\n        svbool_t pg = svwhilelt_b16(index, last);\n        int16_t *left_ptr = arr + index;\n        int16_t *right_ptr = arr + last;\n\n        svint16_t left_vec = svld1(pg, left_ptr);\n        svint16_t right_vec = svld1(pg, right_ptr);\n\n        svst1(pg, left_ptr, right_vec);\n        svst1(pg, right_ptr, left_vec);\n\n        index += svcntw() / 2;\n        last -= svcntw() / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t index = start;\n    uint64_t last = end;\n\n    svbool_t pg = svptrue_b16();\n    svuint64_t svidx = svindex_u64((uint64_t)start, 1);\n\n    while (index < last) {\n        svuint64_t vec_idx = svadd_x_u64(pg, svidx, index);\n        int16_t *left_ptr = arr + svaddv_u64(pg, vec_idx);\n        int16_t *right_ptr = arr + last;\n\n        svint16_t left_vec = svld1(pg, left_ptr);\n        svint16_t right_vec = svld1(pg, right_ptr);\n\n        svst1(pg, left_ptr, right_vec);\n        svst1(pg, right_ptr, left_vec);\n\n        index += svcntw() / 2;\n        last -= svcntw() / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t len = end - start + 1;\n    if (len == 0 || len == 1) return;\n\n    int16_t *left = arr + start;\n    int16_t *right = arr + end;\n\n    svbool_t pg = svptrue_b16();\n    svint16_t zero = svdup_s16(0);\n\n    while (left < right) {\n        // Load left and right elements\n        svint16_t vl = svld1(pg, left);\n        svint16_t vr = svld1(pg, right);\n\n        // Swap the elements\n        svst1(pg, left, vr);\n        svst1(pg, right, vl);\n\n        // Move pointers\n        left += svcntd() / 2;\n        right -= svcntd() / 2;\n    }\n\n    // Handle any remaining scalar elements\n    while (left <= right) {\n        int16_t tmp = *left;\n        *left = *right;\n        *right = tmp;\n        left++;\n        right--;\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t pred_bits = sve_ptrue_b16();\n    uint64_t len = end - start + 1;\n    int16_t *left = arr + start;\n    int16_t *right = arr + end;\n\n    while (left < right) {\n        svbool_t pg = svwhilelt_b16(left - arr, pred_bits);\n        svbool_t pg_inv = svnot_b(pg);\n\n        svint16_t left_vec = svld1(pg, left);\n        svint16_t right_vec = svld1(pg, right);\n\n        svst1(pg, right, left_vec);\n        svst1(pg, left, right_vec);\n\n        left += svcntw() / sizeof(int16_t);\n        right -= svcntw() / sizeof(int16_t);\n    }\n\n    if (left == right) {\n        svbool_t pg = svwhilelt_b16(left - arr, pred_bits);\n        svint16_t left_vec = svld1(pg, left);\n        svint16_t reversed_vec = svrev16_x(pg, left_vec);\n        svst1(pg, left, reversed_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t i = start;\n    uint64_t j = end;\n\n    svbool_t pg = svptrue_b16();\n    int vl = svcntw() / 2; // Vector length in terms of 16-bit elements\n\n    while (j - i + 1 >= vl) {\n        svint16_t vec_i = svld1(pg, arr + i);\n        svint16_t vec_j = svld1(pg, arr + j);\n\n        svst1(pg, arr + i, svrev(vec_j));\n        svst1(pg, arr + j, svrev(vec_i));\n\n        i += vl;\n        j -= vl;\n    }\n\n    // Handle remaining elements with a scalar loop\n    while (i <= j) {\n        int16_t temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n        i++;\n        j--;\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t total_elements = dim1 * dim2;\n    size_t stride = dim3;\n    size_t offset = slice_idx;\n\n    svbool_t pg = svptrue_b8();\n    size_t vl = svcntb();\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        size_t n = total_elements - i;\n        size_t num = (n > vl) ? vl : n;\n\n        svbool_t pg_temp = svwhilelt_b8(i, i + num);\n        svuint8_t vec = svld1_gather_u8(pg_temp, tensor + i * stride + offset, stride);\n\n        svst1_u8(pg_temp, slice + i, vec);\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t total_elements = dim1 * dim2;\n    size_t stride = dim3;\n    size_t offset = slice_idx;\n\n    svbool_t pg = svptrue_b8();\n    size_t vl = svcntb();\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        size_t idx = i + offset * stride;\n        svuint8_t data = svld1(pg, &tensor[idx]);\n        svst1(pg, &slice[i], data);\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t total_elements = dim1 * dim2;\n    size_t slice_offset = slice_idx * dim1;\n\n    svbool_t pg = svptrue_b8();\n    size_t vl = svcntb();\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        size_t j = i;\n        size_t k = i + vl > total_elements ? total_elements - i : vl;\n\n        svuint8_t data = svld1(pg, &tensor[slice_offset + j]);\n        svst1(pg, &slice[j], data);\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t total_elements = dim1 * dim2;\n    size_t stride = dim3 * total_elements;\n    const uint8_t *target_slice = tensor + slice_idx * total_elements;\n\n    svbool_t pg = svptrue_b8();\n    size_t vl = svcntb();\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        size_t count = total_elements - i;\n        if (count < vl) {\n            pg = svwhilelt_b8(i, (int8_t)total_elements);\n        }\n        svuint8_t vec = svld1(pg, target_slice + i);\n        svst1(pg, slice + i, vec);\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t total_elements = dim1 * dim2;\n    size_t stride = dim3;\n    size_t vl = svcntb(); // Vector length in bytes\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        size_t n = total_elements - i;\n        svbool_t pg = svwhilelt_b8(i, total_elements);\n        \n        const uint8_t *src = tensor + (i * stride + slice_idx);\n        uint8_t *dst = slice + i;\n\n        svst1_u8(pg, dst, svld1(pg, src));\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    size_t i, j, k, l;\n    svbool_t pg = svptrue_b16();\n    size_t vl = svcntw() / 2;\n\n    for (i = 0; i < rows; i += block_size) {\n        for (j = 0; j < cols; j += block_size) {\n            for (k = i; k < i + block_size && k < rows; k++) {\n                const int16_t *row_ptr = src + k * cols + j;\n                int16_t *col_ptr = dst + j * rows + k;\n                svint16_t vec = svld1(pg, row_ptr);\n                for (l = 0; l < block_size && j + l < cols; l++) {\n                    svint16_t shuffled = svdup_n_s16(vec[l]);\n                    svst1(pg, col_ptr + l * rows, shuffled);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    size_t vl = svcntw();\n    size_t block_rows = (rows + block_size - 1) / block_size;\n    size_t block_cols = (cols + block_size - 1) / block_size;\n\n    for (size_t br = 0; br < block_rows; br++) {\n        size_t r_start = br * block_size;\n        size_t r_end = (r_start + block_size > rows) ? rows : r_start + block_size;\n\n        for (size_t bc = 0; bc < block_cols; bc++) {\n            size_t c_start = bc * block_size;\n            size_t c_end = (c_start + block_size > cols) ? cols : c_start + block_size;\n\n            for (size_t r = r_start; r < r_end; r += vl) {\n                size_t actual_vl = (r + vl > r_end) ? r_end - r : vl;\n                svbool_t pg = svptrue_b16();\n                svint16_t vec[block_size];\n\n                for (size_t c = c_start; c < c_end; c++) {\n                    svint16_t data = svld1(pg, &src[r * cols + c]);\n                    vec[c - c_start] = svzip1(pg, data, svdup_n_s16(0));\n                }\n\n                for (size_t c = c_start; c < c_end; c++) {\n                    svst1(pg, &dst[c * rows + r], vec[c - c_start]);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t ii = i; ii < i + block_size && ii < rows; ++ii) {\n                size_t jj_start = j;\n                size_t jj_limit = jj_start + block_size;\n                if (jj_limit > cols) jj_limit = cols;\n\n                svbool_t pg = svptrue_b16();\n                size_t k = jj_start;\n                svint16_t vec;\n\n                while (k + svcntw() <= jj_limit) {\n                    vec = svld1(pg, &src[ii * cols + k]);\n                    svst1(pg, &dst[k * rows + ii], vec);\n                    k += svcntw();\n                }\n\n                if (k < jj_limit) {\n                    size_t rem = jj_limit - k;\n                    pg = svwhilelt_b16(k, jj_limit);\n                    vec = svld1(pg, &src[ii * cols + k]);\n                    svst1(pg, &dst[k * rows + ii], vec);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    size_t i, j, k;\n    svbool_t pg = svptrue_b16();\n    size_t vl = svcntw() / 2;\n\n    for (i = 0; i < rows; i += block_size) {\n        for (j = 0; j < cols; j += block_size) {\n            for (k = 0; k < block_size; k++) {\n                if (i + k >= rows) break;\n                svint16_t vec = svld1(pg, &src[(i + k) * cols + j]);\n                size_t l;\n                for (l = 0; l < block_size; l += vl) {\n                    if (j + l >= cols) break;\n                    svst1(pg, &dst[(j + l) * rows + i + k], vec);\n                    vec = svext(vec, vec, vl);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    size_t i, j, k;\n    svbool_t pg = svptrue_b16();\n    size_t vl = svcntw();\n\n    for (i = 0; i < rows; i += block_size) {\n        for (j = 0; j < cols; j += block_size) {\n            for (k = 0; k < block_size; k++) {\n                size_t src_row = i + k;\n                if (src_row >= rows) break;\n\n                svint16_t vec = svld1(pg, &src[src_row * cols + j]);\n                size_t dst_col = j;\n                \n                for (size_t l = 0; l < block_size && dst_col < cols; l += vl) {\n                    svst1(pg, &dst[dst_col * rows + src_row], vec);\n                    dst_col += vl;\n                    vec = svdup_n_s16(0); // Clear or reload as needed\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\n#include <arm_sve.h> \n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < dim; i += vl) {\n        size_t n = dim - i < vl ? dim - i : vl;\n        svbool_t pg_n = svwhilelt_b32(i, i + n);\n        svfloat32_t idx_vec = svindex_f32(0.0f, 1.0f);\n        svfloat32_t diag_elements = svld1(pg_n, &array[i + dim * i + dim * dim * i]);\n        svfloat32_t partial_sums = svadd(pg_n, idx_vec, diag_elements);\n        sum += svaddv_f32(pg, partial_sums);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\n#include <arm_sve.h> \n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float result = 0.0f;\n    size_t i;\n\n    svbool_t pg = svptrue_b32();\n    svfloat32_t acc = svdup_f32(pg, 0.0f);\n\n    for (i = 0; i <= dim - svcntw(); i += svcntw()) {\n        svfloat32_t vec = svld1_f32(pg, &array[i + dim * (i + dim * i)]);\n        acc = svadd_f32(pg, acc, vec);\n    }\n\n    // Handle leftover elements\n    if (i < dim) {\n        svbool_t pg_part = svwhilelt_b32(i, (int)dim);\n        svfloat32_t vec = svld1_f32(pg_part, &array[i + dim * (i + dim * i)]);\n        acc = svadd_f32(pg_part, acc, vec);\n    }\n\n    // Horizontal sum\n    float tmp[svcntw()];\n    svst1_f32(pg, tmp, acc);\n    for (i = 0; i < svcntw(); i++) {\n        result += tmp[i];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\n#include <arm_sve.h> \n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float result = 0.0f;\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    svfloat32_t sum_vec = svdup_f32(pg, 0.0f);\n\n    for (; i + svcntw() <= dim; i += svcntw()) {\n        svfloat32_t vec = svld1_f32(pg, &array[i * (dim * dim + dim + 1)]);\n        sum_vec = svadd_f32(pg, sum_vec, vec);\n    }\n\n    // Horizontal add\n    float tmp[svcntw()];\n    svst1_f32(pg, tmp, sum_vec);\n    for (size_t j = 0; j < svcntw(); ++j) {\n        result += tmp[j];\n    }\n\n    // Tail handling\n    for (; i < dim; ++i) {\n        result += array[i * (dim * dim + dim + 1)];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\n#include <arm_sve.h> \n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float result = 0.0f;\n    if (dim == 0) return result;\n\n    size_t vl = svcntw(); // Vector length in terms of elements\n    svbool_t pg = svptrue_b32(); // Predicate for all active elements\n\n    for (size_t i = 0; i < dim; i += vl) {\n        size_t chunk = (dim - i > vl) ? vl : dim - i;\n\n        svfloat32_t vec = svld1(pg, &array[i + dim * (i + dim * i)]);\n        svfloat32_t sum_vec = svadd_x(pg, vec, svdup_f32(0.0f));\n        \n        // Horizontal reduction\n        float tmp[svcntw()];\n        svst1(pg, tmp, sum_vec);\n        for (size_t j = 0; j < chunk; j++) {\n            result += tmp[j];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\n#include <arm_sve.h> \n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float32x4_t sum_vec = svdup_n_f32(0.0f);\n    size_t vl = svcntw();\n    size_t i, j;\n\n    for (i = 0; i <= dim - vl / 4; i += vl / 4) {\n        svbool_t pg = svptrue_b32();\n        float32x4_t diag_vec = svld1_gather_index_f32(pg, array + i * (dim * dim + dim + 1), i + i * dim + i * dim * dim);\n        sum_vec = svadd_z_f32(pg, sum_vec, diag_vec);\n    }\n\n    // Tail handling if dim is not a multiple of vl/4\n    if (i < dim) {\n        svbool_t pg = svwhilelt_b32(i, dim);\n        float32x4_t diag_vec = svld1_gather_index_f32(pg, array + i * (dim * dim + dim + 1), i + i * dim + i * dim * dim);\n        sum_vec = svadd_m_f32(pg, sum_vec, sum_vec, diag_vec);\n        i += svcntp_b32(pg);\n    }\n\n    // Horizontal sum\n    float acc = 0.0f;\n    for (j = 0; j < vl / 4; j++) {\n        acc += sum_vec[j];\n    }\n\n    return acc;\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    svbool_t pg = svptrue_b64();\n    svfloat64_t svt = svdup_n_f64(threshold);\n    svfloat64_tsvs = svdup_n_f64(scale);\n\n    for (size_t i = 0; i < total_elements; i += svcntd()) {\n        size_t vl = svcntd();\n        size_t k = total_elements - i;\n        if (k < vl) {\n            pg = svwhilelt_b64(k, vl);\n        }\n        svfloat64_t vec_src = svld1(pg, &src[i]);\n        svbool_t cond = svcmpgt_f64(pg, vec_src, svt);\n        svfloat64_t scaled = svmul_f64(pg, vec_src, svs);\n        svfloat64_t result = svsel_f64(cond, scaled, vec_src);\n        svst1(pg, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t count = rows * cols;\n    svbool_t pg = svptrue_b64();\n    svfloat64_t svt = svdup_n_f64(threshold);\n    svfloat64_t svsc = svdup_n_f64(scale);\n\n    for (size_t i = 0; i < count; i += svcntd()) {\n        size_t k = svcntd() - ((i + svcntd()) > count ? (i + svcntd()) - count : 0);\n        svbool_t pgb = svwhilelt_b64(i, count);\n        svfloat64_t svsrc = svld1_f64(pgb, &src[i]);\n        svfloat64_t cmp_result = svcmplt_f64(pgb, svsrc, svt);\n        svfloat64_t scaled = svmul_f64(pgb, svsrc, svsc);\n        svfloat64_t result = svsel_f64(pgb, scaled, svsrc, cmp_result);\n        svst1_f64(pgb, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t count = rows * cols;\n    svbool_t pg = svptrue_b64();\n    svfloat64_t svt = svdup_n_f64(threshold);\n    svfloat64_t svsc = svdup_n_f64(scale);\n\n    for (size_t i = 0; i < count; i += svcntd()) {\n        size_t k = svcntd();\n        if (i + k > count)\n            k = count - i;\n\n        svbool_t pgb = svwhilelt_b64(i, count);\n        svfloat64_t vs = svld1(pgb, src + i);\n        svbool_t cond = svcmpgt_f64(pgb, vs, svt);\n        svfloat64_t scaled = svmul_f64(pgb, cond, vs, svsc);\n        svfloat64_t result = svsel_f64(pgb, cond, vs, scaled);\n        svst1(pgb, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t count = rows * cols;\n    svbool_t pg = svptrue_b64();\n    svfloat64_t svt = svdup_n_f64(threshold);\n    svfloat64_t svsc = svdup_n_f64(scale);\n\n    for (size_t i = 0; i < count; i += svcntd()) {\n        size_t k = svcntd();\n        if (i + k > count)\n            k = count - i;\n        svbool_t pgb = svwhilelt_b64(i, count);\n        svfloat64_t vs = svld1(pgb, src + i);\n        svbool_t cmp = svcmpgt_f64(pgb, vs, svt);\n        svfloat64_t scaled = svmul_f64(pgb, cmp, vs, svsc);\n        svfloat64_t result = svsel_f64(pgb, scaled, vs);\n        svst1(pgb, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t count = rows * cols;\n    svbool_t pg = svptrue_b64();\n    svfloat64_t sthreshold = svdup_n_f64(threshold);\n    svfloat64_t sscale = svdup_n_f64(scale);\n\n    for (size_t i = 0; i < count; i += svcntd()) {\n        size_t k = svcntd() - (count - i > svcntd() ? 0 : count - i);\n        svbool_t pgb = svwhilelt_b64(k, svcntd());\n        svfloat64_t svalues = svld1(pgb, src + i);\n        svbool_t cond = svcmpgt_f64(pgb, svalues, sthreshold);\n        svfloat64_t scaled = svmul_x_f64(pg, svalues, sscale);\n        svfloat64_t result = svsel_f64(cond, scaled, svalues);\n        svst1(pgb, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t pg_size = svcntd(); // Get the number of 64-bit elements in a vector\n\n    for (size_t i = 0; i < rows; ++i) {\n        size_t idx = indices[i];\n        const double *src_row = src + idx * cols;\n        double *dst_row = dst + i * cols;\n\n        size_t k = 0;\n        while (k + pg_size <= cols) {\n            svbool_t pg = svptrue_b64();\n            svfloat64_t vec = svld1(pg, src_row + k);\n            svst1(pg, dst_row + k, vec);\n            k += pg_size;\n        }\n\n        if (k < cols) {\n            svbool_t pg = svptrue_b64();\n            pg = svwhilelt_b64(k, cols);\n            svfloat64_t vec = svld1(pg, src_row + k);\n            svst1(pg, dst_row + k, vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t pg_size = svcntd(); // Get the number of 64-bit elements in a vector\n\n    for (size_t i = 0; i < rows; ++i) {\n        size_t idx = indices[i];\n        const double *src_row = src + idx * cols;\n        double *dst_row = dst + i * cols;\n\n        size_t k = 0;\n        svbool_t pg = svptrue_b64(); // Predicate for all active elements\n\n        for (; k + pg_size <= cols; k += pg_size) {\n            svfloat64_t vec = svld1(pg, src_row + k);\n            svst1(pg, dst_row + k, vec);\n        }\n\n        if (k < cols) {\n            pg = svwhilelt_b64(k, cols); // Generate predicate for remaining elements\n            svfloat64_t vec = svld1(pg, src_row + k);\n            svst1(pg, dst_row + k, vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    svbool_t pg = svptrue_b64();\n    size_t row_size = cols;\n    size_t i, j;\n\n    for (i = 0; i < rows; ++i) {\n        size_t idx = indices[i];\n        const double *src_row = src + idx * row_size;\n        double *dst_row = dst + i * row_size;\n\n        size_t k = 0;\n        for (; k + svcntd() <= row_size; k += svcntd()) {\n            svfloat64_t vec = svld1(pg, src_row + k);\n            svst1(pg, dst_row + k, vec);\n        }\n\n        for (; k < row_size; ++k) {\n            dst_row[k] = src_row[k];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t pg_size = svcntd(); // Number of double-precision elements per vector\n\n    for (size_t i = 0; i < rows; ++i) {\n        size_t idx = indices[i];\n        const double *src_row = src + idx * cols;\n        double *dst_row = dst + i * cols;\n\n        size_t k = 0;\n        svbool_t pg = svptrue_b64();\n        for (; k + pg_size <= cols; k += pg_size) {\n            svfloat64_t vec = svld1(pg, src_row + k);\n            svst1(pg, dst_row + k, vec);\n        }\n\n        // Handle leftover elements\n        if (k < cols) {\n            pg = svwhilelt_b64(k, cols);\n            svfloat64_t vec = svld1(pg, src_row + k);\n            svst1(pg, dst_row + k, vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    svbool_t pg = svptrue_b64();\n    size_t row_size = cols;\n    size_t i, j;\n\n    for (i = 0; i < rows; ++i) {\n        size_t src_row_idx = indices[i];\n        const double *src_row = &src[src_row_idx * row_size];\n        double *dst_row = &dst[i * row_size];\n\n        size_t k = 0;\n        while (k < row_size) {\n            svindex_t index = svindex_s64(k, sve_vl());\n            svuint64_t gather_indices = svadd_x_u64(pg, svreinterpret_u64_z(pg, index), src_row_idx * row_size);\n            svfloat64_t data = svld1_gather_index_f64(pg, gather_indices, src);\n            svst1_f64(pg, &dst_row[k], data);\n            k += sve_vl();\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b64();\n    svint64_t sv_scalar = svdup_n_s64(scalar);\n\n    for (; i <= length - sve_vl(); i += sve_vl()) {\n        svint64_t vec_src1 = svld1(pg, &src1[i]);\n        svint64_t vec_src2 = svld1(pg, &src2[i]);\n        svint64_t result = svadd_x(pg, vec_src1, vec_src2);\n        result = svadd_x(pg, result, sv_scalar);\n        result = svasr_x(pg, result, 1); // Arithmetic shift right by 1 (divide by 2)\n        svst1(pg, &dst[i], result);\n    }\n\n    // Handle leftover elements if any\n    if (i < length) {\n        size_t vl = length - i;\n        svbool_t pg_vl = svwhilelt_b64(i, length);\n        svint64_t vec_src1 = svld1(pg_vl, &src1[i]);\n        svint64_t vec_src2 = svld1(pg_vl, &src2[i]);\n        svint64_t result = svadd_x(pg_vl, vec_src1, vec_src2);\n        result = svadd_x(pg_vl, result, sv_scalar);\n        result = svasr_x(pg_vl, result, 1); // Arithmetic shift right by 1 (divide by 2)\n        svst1(pg_vl, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t index = 0;\n    svbool_t pg = svptrue_b64();\n    svint64_t s = svdup_n_s64(scalar);\n\n    while (index <= length - svcntd()) {\n        svint64_t v1 = svld1(pg, &src1[index]);\n        svint64_t v2 = svld1(pg, &src2[index]);\n        svint64_t res = svadd_x(pg, v1, v2);\n        res = svadd_x(pg, res, s);\n        res = svshrd_x(pg, res, 1);\n        svst1(pg, &dst[index], res);\n        index += svcntd();\n    }\n\n    // Handle leftover elements\n    if (index < length) {\n        pg = svwhilelt_b64(index, length);\n        svint64_t v1 = svld1(pg, &src1[index]);\n        svint64_t v2 = svld1(pg, &src2[index]);\n        svint64_t res = svadd_x(pg, v1, v2);\n        res = svadd_x(pg, res, s);\n        res = svshrd_x(pg, res, 1);\n        svst1(pg, &dst[index], res);\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b64();\n    size_t vl = svcntd();\n\n    for (; i <= length - vl; i += vl) {\n        svint64_t vec1 = svld1(pg, &src1[i]);\n        svint64_t vec2 = svld1(pg, &src2[i]);\n        svint64_t result = svadd_z(pg, vec1, vec2);\n        svint64_t result_with_scalar = svaddv_z(pg, result, scalar);\n        svint64_t final_result = svsri_z(pg, result_with_scalar, 1);\n        svst1(pg, &dst[i], final_result);\n    }\n\n    // Handle leftover elements\n    if (i < length) {\n        pg = svwhilelt_b64(i, length);\n        svint64_t vec1 = svld1(pg, &src1[i]);\n        svint64_t vec2 = svld1(pg, &src2[i]);\n        svint64_t result = svadd_z(pg, vec1, vec2);\n        svint64_t result_with_scalar = svaddv_z(pg, result, scalar);\n        svint64_t final_result = svsri_z(pg, result_with_scalar, 1);\n        svst1(pg, &dst[i], final_result);\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    svbool_t pg = svptrue_b64();\n    size_t vec_len = svcntd(); // Number of 64-bit elements in a vector\n    size_t i = 0;\n\n    for (; i <= length - vec_len; i += vec_len) {\n        svint64_t vec_src1 = svld1(pg, &src1[i]);\n        svint64_t vec_src2 = svld1(pg, &src2[i]);\n        svint64_t result = svadd_x(pg, vec_src1, vec_src2);\n        result = svadd_x(pg, result, svdup_n_s64(scalar));\n        result = svsri_x(pg, result, result, 1); // Arithmetic shift right by 1 (divide by 2 round-toward-zero)\n        svst1(pg, &dst[i], result);\n    }\n\n    // Handle leftover elements\n    if (i < length) {\n        svbool_t pg_part = svwhilelt_b64(i, length);\n        svint64_t vec_src1 = svld1(pg_part, &src1[i]);\n        svint64_t vec_src2 = svld1(pg_part, &src2[i]);\n        svint64_t result = svadd_x(pg_part, vec_src1, vec_src2);\n        result = svadd_x(pg_part, result, svdup_n_s64(scalar));\n        result = svsri_x(pg_part, result, result, 1); // Arithmetic shift right by 1 (divide by 2 round-toward-zero)\n        svst1(pg_part, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t index = 0;\n    svbool_t pg = svptrue_b64();\n    svint64_t sv_scalar = svdup_n_s64(scalar);\n\n    while (index <= length - svcntd()) {\n        svint64_t vec1 = svld1_s64(pg, &src1[index]);\n        svint64_t vec2 = svld1_s64(pg, &src2[index]);\n        svint64_t result = svsdivx(pg, svadd_x(pg, svadd_x(pg, vec1, vec2), sv_scalar), 2);\n        svst1_s64(pg, &dst[index], result);\n        index += svcntd();\n    }\n\n    // Handle leftover elements\n    if (index < length) {\n        pg = svwhilelt_b64(index, length);\n        svint64_t vec1 = svld1_s64(pg, &src1[index]);\n        svint64_t vec2 = svld1_s64(pg, &src2[index]);\n        svint64_t result = svsdivx(pg, svadd_x(pg, svadd_x(pg, vec1, vec2), sv_scalar), 2);\n        svst1_s64(pg, &dst[index], result);\n    }\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint vector_even_min_simd(const int *src, size_t length){\n    if (length == 0) return -1;\n\n    svbool_t pg = svptrue_b32();\n    svint32_t vmin = svdup_n_s32(0x7FFFFFFF);\n\n    size_t vec_len = svcntw() / sizeof(int);\n    size_t i = 0;\n\n    for (; i <= length - vec_len; i += vec_len) {\n        svint32_t vload = svld1(pg, &src[i]);\n        svbool_t even_mask = svcmpeq(pg, svmul_x(pg, svindex_s32(0, 2), svdup_n_s32(2)), svdup_n_s32(0));\n        svint32_t veven = svand_x(pg, vload, svreinterpret_s32(even_mask));\n        vmin = svmin_z(pg, vmin, veven);\n    }\n\n    int min_val = 0x7FFFFFFF;\n    svint32_t res = svdup_n_s32(0x7FFFFFFF);\n    res = svmin_z(pg, res, vmin);\n    svint32_t mask = svdup_n_s32(0xFFFFFFFF);\n    svst1(pg, &min_val, svand_x(pg, res, mask));\n\n    for (; i < length; i++) {\n        if ((i % 2 == 0) && (src[i] < min_val)) {\n            min_val = src[i];\n        }\n    }\n\n    return (min_val == 0x7FFFFFFF) ? -1 : min_val;\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint vector_even_min_simd(const int *src, size_t length){\n    if (length == 0) return -1;\n\n    svbool_t pg = svptrue_b32();\n    svint32_t vmin = svdup_n_s32(0x7FFFFFFF);\n\n    size_t vec_len = svcntw() / sizeof(int);\n    size_t i = 0;\n\n    for (; i <= length - vec_len; i += vec_len) {\n        svint32_t vload = svld1(pg, &src[i]);\n        svbool_t even_mask = svcmpeq(pg, svmul_n_s32(svindex_s32(i, 1), 1), svdup_n_s32(0));\n        svint32_t veven = svand_x(pg, vload, svreinterpret_s32(even_mask));\n        vmin = svmin_z(pg, vmin, veven);\n    }\n\n    int min_val = 0x7FFFFFFF;\n    svint32_t res = svdup_n_s32(0x7FFFFFFF);\n    res = svmin_z(pg, res, vmin);\n\n    for (size_t j = 0; j < svcntw(); ++j) {\n        min_val = min_val < sve_extract(res, j) ? min_val : sve_extract(res, j);\n    }\n\n    for (; i < length; ++i) {\n        if ((i % 2) == 0 && src[i] < min_val) {\n            min_val = src[i];\n        }\n    }\n\n    return min_val == 0x7FFFFFFF ? -1 : min_val;\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint vector_even_min_simd(const int *src, size_t length){\n    if (length == 0) return -1;\n\n    svbool_t pg = svptrue_b32();\n    svint32_t vmin = svdup_n_s32(0x7FFFFFFF);\n\n    for (size_t i = 0; i < length; i += 2 * svcntw()) {\n        size_t j = i / 2;\n        if (j * 2 >= length) break;\n\n        size_t count = svcntw();\n        size_t upper_bound = (j + count > length / 2) ? (length / 2 - j) * 2 : count * 2;\n        svbool_t pred = svcmp_eq_u32(pg, svindex_s32(i, 2), svindex_s32(i, 2));\n        svint32_t vec = svld1(pg, &src[i]);\n        svint32_t even_vec = svand_x(pg, vec, svdup_n_s32(0xFFFFFFFE));\n        vmin = svmin_z(pg, vmin, even_vec);\n    }\n\n    int min_val = 0x7FFFFFFF;\n    svint32_t res = svdup_n_s32(min_val);\n    res = svmin_z(pg, res, vmin);\n\n    uint32x4_t res_n = svastype_n_s32_u32(svcompact(res));\n    min_val = res_n.val[0];\n    for (int i = 1; i < svcntw(); ++i) {\n        if (res_n.val[i] < min_val) min_val = res_n.val[i];\n    }\n\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint vector_even_min_simd(const int *src, size_t length){\n    if (length == 0) return -1;\n\n    svbool_t pg = svptrue_b32();\n    svint32_t vmin = svdup_s32(SV_MAX_INT);\n    size_t vec_len = svcntw() / sizeof(int);\n    size_t i = 0;\n\n    for (; i <= length - vec_len; i += vec_len) {\n        svint32_t vload = svld1(pg, &src[i]);\n        svbool_t even_mask = svand_b32(pg, svtst_m_u32(pg, vload, 1));\n        svint32_t veven = svsel_s32(even_mask, vload, svdup_s32(SV_MAX_INT));\n        vmin = svmin_v(vmin, veven);\n    }\n\n    int res = SV_MAX_INT;\n    svint32_t res_vec = svdup_s32(res);\n    res_vec = svmin_v(res_vec, vmin);\n    res = svminv(res_vec);\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        if ((src[i] % 2) == 0 && src[i] < res) {\n            res = src[i];\n        }\n    }\n\n    return (res == SV_MAX_INT) ? -1 : res;\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint vector_even_min_simd(const int *src, size_t length){\n    if (length == 0) return -1;\n\n    svbool_t pg = svptrue_b32();\n    svint32_t vmin = svdup_n_s32(0x7FFFFFFF);\n\n    for (size_t i = 0; i < length; i += svcntw()) {\n        size_t j = i;\n        svbool_t pred = svwhilelt_b32(j, length);\n        svint32_t vec = svld1_gather_index_z_s32(pred, src, svindex_s32((int)j, 1));\n        \n        // Mask out odd indices\n        svbool_t even_pred = svand_b32(pred, svtst_b32(sveor_b32(svbrka_b32(), svbrkb_b32()), svindex_s32((int)j, 1)));\n        svint32_t even_vec = svdup_n_s32(0x7FFFFFFF);\n        even_vec = svminmvav_x_s32(pg, even_vec, vec);\n        vmin = svminv_s32(pg, vmin, even_vec);\n    }\n\n    int min_val = vmin[0];\n    for (size_t i = 1; i < svcntw(); ++i) {\n        if (vmin[i] < min_val) min_val = vmin[i];\n    }\n\n    return min_val == 0x7FFFFFFF ? -1 : min_val;\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t index = 0;\n    svbool_t pg = svptrue_b32();\n    while (index < length) {\n        svint32_t svec = svld1(pg, &src[index]);\n        svint32_t ashr_result = svsshift_r_z(pg, svec, shift);\n        svuint32_t uvec = svcvt_u32_x(pg, svec);\n        svuint32_t lshr_result_u = svushift_r_z(pg, uvec, shift);\n        svint32_t lshr_result = svcvt_s32_x(pg, lshr_result_u);\n        svint32_t result = svadd(pg, ashr_result, lshr_result);\n        svst1(pg, &dst[index], result);\n        index += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t index = 0;\n    svbool_t pg = svptrue_b32();\n    while (index < length) {\n        size_t vl = svcntw();\n        svbool_t pg_vl = svwhilelt_b32(index, length);\n        svint32_t vec_src = svld1_gather_offset_z(pg_vl, src, svindex_s64(index, 1));\n        \n        // Arithmetic right shift\n        svint32_t vec_arith_shift = svsshift_r_z(pg_vl, vec_src, shift);\n        \n        // Logical right shift: cast to unsigned, shift, then cast back to signed\n        svuint32_t vec_logic_shift_unsigned = svreinterpret_u32(vec_src);\n        svuint32_t vec_logic_shift = svushift_r_z(pg_vl, vec_logic_shift_unsigned, shift);\n        svint32_t vec_logic_shift_signed = svreinterpret_s32(vec_logic_shift);\n        \n        // Add arithmetic and logical shifts\n        svint32_t vec_result = svadd_z(pg_vl, vec_arith_shift, vec_logic_shift_signed);\n        \n        // Store the result\n        svst1_scatter_offset(pg_vl, dst, svindex_s64(index, 1), vec_result);\n        \n        index += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    while (i + svcntw() <= length) {\n        svint32_t vec = svld1(pg, &src[i]);\n        \n        svint32_t arith_shifted = svsshift_r_z(pg, vec, shift);\n        svuint32_t vec_uint = svreinterpret_u32(arith_shifted);\n        svint32_t logic_shifted = svushift_r_z(pg, vec_uint, shift);\n        \n        svint32_t result = svadd_z(pg, arith_shifted, logic_shifted);\n        svst1(pg, &dst[i], result);\n        \n        i += svcntw();\n    }\n    for (; i < length; ++i) {\n        int val = src[i];\n        int asr = val >> shift;\n        int lsr = static_cast<int>(static_cast<unsigned int>(val) >> shift);\n        dst[i] = asr + lsr;\n    }\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t index = 0;\n\n    while (index < length) {\n        svbool_t pg = svptrue_b32();\n        svint32_t vec_src = svld1(pg, &src[index]);\n        \n        // Arithmetic right shift\n        svint32_t vec_arith_shift = svsshift_r_z(pg, vec_src, shift);\n\n        // Logical right shift: cast to unsigned, shift, then cast back to signed\n        svuint32_t vec_logic_shift_unsigned = svushift_r_z(pg, svcvt_u32_z(pg, vec_src), shift);\n        svint32_t vec_logic_shift = svcvt_s32_z(pg, vec_logic_shift_unsigned);\n\n        // Add the results of arithmetic and logical shifts\n        svint32_t vec_result = svadd_z(pg, vec_arith_shift, vec_logic_shift);\n\n        // Store the result\n        svst1(pg, &dst[index], vec_result);\n\n        // Update index by the number of elements processed in this iteration\n        index += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t index = 0;\n    svbool_t pg = svptrue_b32();\n    while (index <= length - svcntw()) {\n        svint32_t svec = svld1_s32(pg, &src[index]);\n        svint32_t ashr_result = svsshiftn_s32(pg, svec, shift);\n        svuint32_t lshr_result_u = svushiftn_u32(pg, svreinterpret_u32_s32(svec), shift);\n        svint32_t lshr_result = svreinterpret_s32_u32(lshr_result_u);\n        svint32_t result = svadd_s32(pg, ashr_result, lshr_result);\n        svst1_s32(pg, &dst[index], result);\n        index += svcntw();\n    }\n    // Handle remaining elements (if any)\n    if (index < length) {\n        pg = svwhilelt_b32(index, length);\n        svint32_t svec = svld1_s32(pg, &src[index]);\n        svint32_t ashr_result = svsshiftn_s32(pg, svec, shift);\n        svuint32_t lshr_result_u = svushiftn_u32(pg, svreinterpret_u32_s32(svec), shift);\n        svint32_t lshr_result = svreinterpret_s32_u32(lshr_result_u);\n        svint32_t result = svadd_s32(pg, ashr_result, lshr_result);\n        svst1_s32(pg, &dst[index], result);\n    }\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    if (total_elements == 0) return 0;\n\n    svbool_t pg = svptrue_b32();\n    int64_t sum = 0;\n    size_t vec_len = svcntw(); // Number of elements in a vector\n    size_t i = 0;\n\n    for (; i <= total_elements - vec_len; i += vec_len) {\n        svint32_t vec = svld1(pg, &matrix[i]);\n        svint32_t acc = svadd_x(pg, vec, vec);\n        sum += svaddv_s32(acc);\n    }\n\n    // Handle leftover elements\n    if (i < total_elements) {\n        size_t left = total_elements - i;\n        svbool_t pg_partial = svwhilelt_b32(i, total_elements);\n        svint32_t vec = svld1(pg_partial, &matrix[i]);\n        svint32_t acc = svadd_x(pg_partial, vec, vec);\n        sum += svaddv_s32(acc);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t count = rows * cols;\n    if (count == 0) return 0;\n\n    svbool_t pg = svptrue_b32();\n    svint32_t acc = svdup_s32(0);\n\n    size_t vec_len = svcntw();\n    size_t i = 0;\n\n    for (; i <= count - vec_len; i += vec_len) {\n        svint32_t vec = svld1_s32(pg, &matrix[i]);\n        acc = svadd_s32(pg, acc, vec);\n    }\n\n    int32x4_t partial_sum = svaddv_s32(acc);\n\n    int64_t total_sum = 0;\n    for (size_t j = 0; j < 4; ++j) {\n        total_sum += partial_sum[j];\n    }\n\n    for (; i < count; ++i) {\n        total_sum += matrix[i];\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t length = rows * cols;\n    if (length == 0) return 0;\n\n    int64_t total_sum = 0;\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i <= length - vl; i += vl) {\n        svint32_t vec = svld1(pg, &matrix[i]);\n        svint32_t acc = svadd_x(pg, vec, vec);\n        int32x4_t res = svaddv(acc);\n        total_sum += vaddvq_s32(res);\n    }\n\n    // Handle leftover elements\n    if (length % vl != 0) {\n        size_t remainder = length % vl;\n        svbool_t pg_remainder = svwhilelt_b32(0, remainder);\n        svint32_t vec = svld1(pg_remainder, &matrix[length - remainder]);\n        svint32_t acc = svadd_x(pg_remainder, vec, vec);\n        int32x4_t res = svaddv(acc);\n        total_sum += vaddvq_s32(res);\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    if (total_elements == 0) return 0;\n\n    int64_t sum = 0;\n    svbool_t pg = svptrue_b32();\n    size_t vec_len = svcntw();\n    size_t i = 0;\n\n    for (; i <= total_elements - vec_len; i += vec_len) {\n        svint32_t vl = svld1(pg, &matrix[i]);\n        svint32_t acc = svadd_x(pg, vl, svdup_z(pg, 0));\n        sum += svaddv(pg, acc);\n    }\n\n    // Handle leftover elements\n    if (i < total_elements) {\n        size_t left = total_elements - i;\n        svbool_t pg_left = svwhilelt_b32(i, total_elements);\n        svint32_t vl = svld1(pg_left, &matrix[i]);\n        svint32_t acc = svadd_x(pg_left, vl, svdup_z(pg_left, 0));\n        sum += svaddv(pg_left, acc);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    svbool_t pg = svptrue_b32();\n    int64_t sum = 0;\n\n    size_t vl = svcntw(); // Vector length in terms of 32-bit elements\n    size_t i = 0;\n\n    for (; i <= total_elements - vl; i += vl) {\n        svint32_t vec = svld1(pg, &matrix[i]);\n        svint32_t acc = svadd_x(pg, vec, vec);\n        sum += svaddv_s32(acc);\n    }\n\n    // Handle leftover elements\n    if (i < total_elements) {\n        size_t left = total_elements - i;\n        svbool_t pg_partial = svwhilelt_b32(i, total_elements);\n        svint32_t vec = svld1(pg_partial, &matrix[i]);\n        svint32_t acc = svadd_x(pg_partial, vec, vec);\n        sum += svaddv_s32(acc);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\n#include <arm_sve.h> \n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t result = 0;\n    svbool_t pg = svptrue_b8();\n    svint8_t vmax = svdup_s8(SV_MIN_INT8);\n    svuint64_t idx = svindex_u64(0, 1);\n\n    for (size_t i = 0; i < length; i += svcntb()) {\n        svint8_t vec = svld1(pg, &src[i]);\n        svbool_t cmp = svcmplt(pg, vmax, vec);\n        vmax = svsel(cmp, vec, vmax);\n        idx = svsel(cmp, svdup_u64(idx), idx);\n        if (svcntb() + i > length) break;\n    }\n\n    // Horizontal reduction to find the final maximum index\n    int8_t max_val = svget_lane_s8(vmax, 0);\n    size_t max_idx = svget_lane_u64(idx, 0);\n    for (size_t i = 1; i < svcntb(); ++i) {\n        if (svget_lane_s8(vmax, i) > max_val) {\n            max_val = svget_lane_s8(vmax, i);\n            max_idx = svget_lane_u64(idx, i);\n        }\n    }\n\n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\n#include <arm_sve.h> \n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t result = 0;\n    int8_t max_val = -128;\n    svbool_t pg = svptrue_b8();\n    svint8_t vmx = svdup_s8(-128);\n    svuint64_t vidx = svindex_u64(0, 1);\n    svuint64_t vmax_idx = svdup_u64(0);\n\n    for (size_t i = 0; i < length; i += svcntb()) {\n        size_t chunk = length - i;\n        size_t vl = svcntb();\n        if (chunk < vl) {\n            pg = svwhilelt_b8((int8_t)(chunk - 1), (int8_t)vl);\n            vl = chunk;\n        }\n\n        svint8_t vdata = svld1(pg, src + i);\n        svbool_t cmp = svcmplt(pg, vmx, vdata);\n        vmx = svsel(cmp, vdata, vmx);\n        vmax_idx = svsel(cmp, vidx, vmax_idx);\n\n        vidx = svadd_u64(vidx, svdup_n_u64(vl));\n    }\n\n    max_val = svlastactiveLane_s8(svptrue_b8(), vmx);\n    result = svlastactiveLane_u64(svptrue_b8(), vmax_idx);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\n#include <arm_sve.h> \n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t result = 0;\n    int8_t max_val = src[0];\n    svbool_t pg = svptrue_b8();\n    svint8_t vec_max = svdup_s8(src[0]);\n    svuint64_t indices = svindex_u64(0, 1);\n\n    for (size_t i = 0; i + svcntb() <= length; i += svcntb()) {\n        svint8_t vec = svld1(pg, &src[i]);\n        svbool_t is_greater = svcmpgt_s8(pg, vec, vec_max);\n        vec_max = svsel(is_greater, vec, vec_max);\n        indices = svsel_u64(is_greater, svdup_n_u64(i), indices);\n    }\n\n    // Handle remaining elements\n    if (length % svcntb() != 0) {\n        size_t i = length - (length % svcntb());\n        svbool_t pg_remain = svwhilelt_b8(i, length);\n        svint8_t vec = svld1(pg_remain, &src[i]);\n        svbool_t is_greater = svcmpgt_s8(pg_remain, vec, vec_max);\n        vec_max = svsel(is_greater, vec, vec_max);\n        indices = svsel_u64(is_greater, svdup_n_u64(i), indices);\n    }\n\n    // Extract scalar result\n    uint64x2_t res_indices = sv interpreted as uint64x2_t;\n    int8x16_t res_values = sv reinterpret as int8x16_t;\n    for (int i = 0; i < 2; ++i) {\n        if (res_values[i] > max_val) {\n            max_val = res_values[i];\n            result = res_indices[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\n#include <arm_sve.h> \n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t result = 0;\n    int8_t max_val = src[0];\n    svbool_t pg = svptrue_b8();\n    svint8_t vmax = svdup_s8(max_val);\n    svuint64_t idx_vec = svindex_u64(0, 1);\n\n    for (size_t i = 0; i < length; i += svcntb()) {\n        size_t chunk = svcntb();\n        if (i + chunk > length) {\n            chunk = length - i;\n            pg = svwhilelt_b8((uint8_t)i, (uint8_t)length);\n        }\n\n        svint8_t vec = svld1(pg, src + i);\n        svbool_t gt = svcmpgt(pg, vec, vmax);\n        vmax = svsel(gt, vec, vmax);\n\n        svuint64_t current_indices = svadd_u64(idx_vec, svdup_u64(i));\n        svuint64_t new_result = svreinterpret_u64_s8(svsel(gt, vec, svdup_s8(-1)));\n        new_result = svand_u64(new_result, svindex_u64(0, 1));\n        result = svtbl1_u64(current_indices, new_result)[0];\n\n        if (!svptest_any(svptrue_b8(), gt)) continue;\n\n        max_val = svmaxv_s8(pg, vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\n#include <arm_sve.h> \n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t result = 0;\n    svbool_t pg = svptrue_b8();\n    svint8_t vmax = svdup_s8(SV_INT8_MIN);\n    svuint64_t imax = svdup_u64(0);\n\n    for (size_t i = 0; i < length; i += svcntb()) {\n        svint8_t v = svld1(pg, &src[i]);\n        svbool_t cmp = svcmplt(pg, vmax, v);\n        vmax = svsel(cmp, v, vmax);\n        imax = svsel(cmp, svindex_u64(i, 1), imax);\n    }\n\n    result = svlastactive_scalar(pg, imax);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b16();\n    while (i + svcntw() <= length) {\n        svuint16_t vec_src1 = svld1(pg, &src1[i]);\n        svuint16_t vec_src2 = svld1(pg, &src2[i]);\n        svuint16_t vec_dst;\n\n        svindex_t indices = svindex_s32(i, 1);\n        svuint32_t index_masked = svasr_u32(svreinterpret_u32(indices), __builtin_ctz(mask));\n        svbool_t cond = svcmpeq(pg, svand_x(pg, index_masked, svdup_n_u32(mask)), svdup_n_u32(0));\n\n        vec_dst = svsel(cond, vec_src2, vec_src1);\n        svst1(pg, &dst[i], vec_dst);\n\n        i += svcntw();\n    }\n    for (; i < length; ++i) {\n        if ((i & mask) == 0) {\n            dst[i] = src2[i];\n        } else {\n            dst[i] = src1[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    while (i + svcntw() <= length) {\n        svbool_t pg = svptrue_b16();\n        svuint16_t vec_idx = svindex_u16((uint16_t)i, (uint16_t)svcntw());\n        svuint16_t cond = svand_x(pg, vec_idx, svdup_n_u16(mask));\n        svuint16_t sel_src1 = svcmpeq(pg, cond, svdup_n_u16(0));\n        svuint16_t vec_src1 = svld1(pg, src1 + i);\n        svuint16_t vec_src2 = svld1(pg, src2 + i);\n        svuint16_t result = svsel(svnot_b16(sel_src1), vec_src1, vec_src2);\n        svst1(pg, dst + i, result);\n        i += svcntw();\n    }\n    for (; i < length; ++i) {\n        if ((i & mask) != 0) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b16();\n    while (i + svcntw() <= length) {\n        svuint16_t vec_src1 = svld1(pg, &src1[i]);\n        svuint16_t vec_src2 = svld1(pg, &src2[i]);\n        \n        svuint16_t indices = svindex_n_u16(i, 1);\n        svuint16_t cond = svand_x(pg, indices, svdup_n_u16(mask));\n        svbool_t blend_pg = svmovemask_b16(svcmpne_z(pg, cond, svdup_n_u16(0)));\n        \n        svuint16_t result = svsel(blend_pg, vec_src1, vec_src2);\n        svst1(pg, &dst[i], result);\n        \n        i += svcntw();\n    }\n    for (; i < length; ++i) {\n        if ((i & mask) != 0) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b16();\n    size_t vl = svcntw();\n\n    for (; i <= length - vl; i += vl) {\n        svuint16_t vec_src1 = svld1(pg, &src1[i]);\n        svuint16_t vec_src2 = svld1(pg, &src2[i]);\n\n        svuint16_t vec_dst;\n        svindex_t indices = svindex((int64_t)i, 1);\n        svuint16_t cond = svmov_n_u16(svcmpne_z(pg, svasr_x(pg, indices, svebits(mask)), svdup_n_u16(0)));\n\n        vec_dst = svsel(cond, vec_src1, vec_src2);\n\n        svst1(pg, &dst[i], vec_dst);\n    }\n\n    // Handle leftover elements\n    if (i < length) {\n        svbool_t pg_part = svwhilelt_b16(i, length);\n        svuint16_t vec_src1 = svld1(pg_part, &src1[i]);\n        svuint16_t vec_src2 = svld1(pg_part, &src2[i]);\n\n        svuint16_t vec_dst;\n        svindex_t indices = svindex((int64_t)i, 1);\n        svuint16_t cond = svmov_n_u16(svcmpne_z(pg_part, svasr_x(pg_part, indices, svebits(mask)), svdup_n_u16(0)));\n\n        vec_dst = svsel(cond, vec_src1, vec_src2);\n\n        svst1(pg_part, &dst[i], vec_dst);\n    }\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b16();\n    while (i + svcntw() <= length) {\n        svuint16_t vec_src1 = svld1_u16(pg, &src1[i]);\n        svuint16_t vec_src2 = svld1_u16(pg, &src2[i]);\n        \n        svuint32_t indices = svindex_u32((uint32_t)i, 1);\n        svuint32_t masked_indices = svand_u32(pg, indices, svdup_n_u32(mask));\n        svbool_t cond = svcmpe_ne_z(pg, masked_indices, svdup_n_u32(0));\n        \n        svuint16_t result = svsel_u16(cond, vec_src1, vec_src2);\n        svst1_u16(pg, &dst[i], result);\n        \n        i += svcntw();\n    }\n    for (; i < length; ++i) {\n        if ((i & mask) != 0) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t vl = svcntw(); // Get the vector length in terms of 32-bit elements\n    uint32x4_t ones = svdup_n_u32(1); // Vector of ones for accumulation\n\n    for (size_t i = 0; i < length; i += vl) {\n        size_t chunk = (length - i) > vl ? vl : (length - i);\n        svbool_t pg = svptrue_b32(); // Predicate for all active elements\n        svuint32_t vec = svld1(pg, &src[i]); // Load vector from source array\n        svuint32_t count = svcntp_u32(pg, vec); // Count population bits\n        svst1(pg, &dst[i], count); // Store result to destination array\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t vl = svcntw();\n    const uint32_t *src_end = src + (length / vl) * vl;\n\n    for (; src < src_end; src += vl, dst += vl) {\n        svuint32_t vec = svld1(svptrue_b32(), src);\n        svuint32_t popcnt_vec = svclz(vec);\n        svst1(svptrue_b32(), dst, popcnt_vec);\n    }\n\n    // Handle leftover elements\n    size_t left = length % vl;\n    if (left > 0) {\n        svbool_t pg = svptrue_b32_z(left);\n        svuint32_t vec = svld1(pg, src);\n        svuint32_t popcnt_vec = svclz(vec);\n        svst1(pg, dst, popcnt_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t vl = svcntw();\n    uint32x4_t mask = svdup_n_u32(0xFFFFFFFF);\n    for (size_t i = 0; i < length; i += vl) {\n        size_t chunk_size = (length - i) > vl ? vl : (length - i);\n        svbool_t pg = svwhilelt_b32(i, i + chunk_size);\n        uint32x4_t vec = svld1(pg, &src[i]);\n        uint32x4_t popcnt_vec = svclz_m_u32(pg, vec, mask);\n        svst1(pg, &dst[i], popcnt_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t vl = svcntw();\n    const uint32_t *src_end = src + (length / vl) * vl;\n\n    for (; src < src_end; src += vl, dst += vl) {\n        svuint32_t vec = svld1_u32(svptrue_b32(), src);\n        svuint32_t popcnt_vec = svclz_u32(svptrue_b32(), vec);\n        svst1_u32(svptrue_b32(), dst, popcnt_vec);\n    }\n\n    // Handle leftover elements\n    size_t left = length % vl;\n    if (left > 0) {\n        svbool_t pg = svwhilelt_b32(0, (int)left);\n        svuint32_t vec = svld1_u32(pg, src);\n        svuint32_t popcnt_vec = svclz_u32(pg, vec);\n        svst1_u32(pg, dst, popcnt_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t vl = svcntw(); // Get the vector length in terms of 32-bit elements\n    svbool_t pg = svptrue_b32(); // Predicate for all active elements\n\n    for (size_t i = 0; i < length; i += vl) {\n        size_t chunk = length - i;\n        svbool_t pred = svptrue_b32();\n        if (chunk < vl) {\n            pred = svwhilelt_b32(i, length);\n        }\n\n        svuint32_t vec = svld1_u32(pred, &src[i]);\n        svuint32_t popcnt_vec = svclz_u32(pred, vec); // Count leading zeros\n        popcnt_vec = sveor_u32(pred, vec, svdup_n_u32(0xFFFFFFFF)); // Invert bits\n        popcnt_vec = svclz_u32(pred, popcnt_vec); // Count leading zeros again\n        popcnt_vec = svsub_u32(pred, svdup_n_u32(32), popcnt_vec); // Subtract from 32\n\n        svst1_u32(pred, &dst[i], popcnt_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b16();\n    svuint16_t zero = svdup_n_u16(0);\n\n    while (i + svcntw() <= length) {\n        svuint16_t vec1 = svld1_u16(pg, &src1[i]);\n        svuint16_t vec2 = svld1_u16(pg, &src2[i]);\n        svuint16_t result = svsadd_u16(pg, vec1, vec2);\n        svst1_u16(pg, &dst[i], result);\n        i += svcntw();\n    }\n\n    if (i < length) {\n        size_t left = length - i;\n        svbool_t pg_left = svwhilelt_b16(i, length);\n        svuint16_t vec1 = svld1_u16(pg_left, &src1[i]);\n        svuint16_t vec2 = svld1_u16(pg_left, &src2[i]);\n        svuint16_t result = svsadd_u16(pg_left, vec1, vec2);\n        svst1_u16(pg_left, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b16();\n    svuint16_t zero = svdup_n_u16(0);\n\n    while (i + svcntw() / 2 <= length) {\n        svuint16_t vec1 = svld1_u16(pg, &src1[i]);\n        svuint16_t vec2 = svld1_u16(pg, &src2[i]);\n        svuint16_t result = svsadd_u16(pg, vec1, vec2);\n        svst1_u16(pg, &dst[i], result);\n        i += svcntw() / 2;\n    }\n\n    if (i < length) {\n        size_t left = length - i;\n        svbool_t pg_left = svwhilelt_b16(i, length);\n        svuint16_t vec1 = svld1_u16(pg_left, &src1[i]);\n        svuint16_t vec2 = svld1_u16(pg_left, &src2[i]);\n        svuint16_t result = svsadd_u16(pg_left, vec1, vec2);\n        svst1_u16(pg_left, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b16();\n    svuint16_t zero = svdup_n_u16(0);\n\n    while (i + svcntw() / 2 <= length) {\n        svuint16_t vec1 = svld1_u16(pg, &src1[i]);\n        svuint16_t vec2 = svld1_u16(pg, &src2[i]);\n        svuint16_t result = svsadd_u16(pg, vec1, vec2);\n        svst1_u16(pg, &dst[i], result);\n        i += svcntw() / 2;\n    }\n\n    if (i < length) {\n        size_t left = length - i;\n        svbool_t pg_left = svwhilelt_b16(i, length);\n        svuint16_t vec1 = svld1_u16(pg_left, &src1[i]);\n        svuint16_t vec2 = svld1_u16(pg_left, &src2[i]);\n        svuint16_t result = svsadd_u16(pg_left, vec1, vec2);\n        svst1_u16(pg_left, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b16();\n    svuint16_t zero = svdup_n_u16(0);\n\n    while (i + svcntw() <= length) {\n        svuint16_t vec1 = svld1_u16(pg, &src1[i]);\n        svuint16_t vec2 = svld1_u16(pg, &src2[i]);\n        svuint16_t result = svsadd_u16(pg, vec1, vec2);\n        svst1_u16(pg, &dst[i], result);\n        i += svcntw();\n    }\n\n    if (i < length) {\n        size_t left = length - i;\n        svbool_t pg_left = svwhilelt_b16(i, length);\n        svuint16_t vec1 = svld1_u16(pg_left, &src1[i]);\n        svuint16_t vec2 = svld1_u16(pg_left, &src2[i]);\n        svuint16_t result = svsadd_u16(pg_left, vec1, vec2);\n        svst1_u16(pg_left, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b16();\n    svuint16_t zero = svdup_n_u16(0);\n\n    while (i + svcntw() / 2 <= length) {\n        svuint16_t vec1 = svld1_u16(pg, &src1[i]);\n        svuint16_t vec2 = svld1_u16(pg, &src2[i]);\n        svuint16_t result = svsadd_u16(pg, vec1, vec2);\n        svst1_u16(pg, &dst[i], result);\n        i += svcntw() / 2;\n    }\n\n    if (i < length) {\n        size_t left = length - i;\n        svbool_t pg_left = svwhilelt_b16(i * 2, length * 2);\n        svuint16_t vec1 = svld1_u16(pg_left, &src1[i]);\n        svuint16_t vec2 = svld1_u16(pg_left, &src2[i]);\n        svuint16_t result = svsadd_u16(pg_left, vec1, vec2);\n        svst1_u16(pg_left, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t k = 0; k < p; ++k) {\n            svbool_t pg = svptrue_b64();\n            svfloat64_t acc = svdup_f64(pg, 0.0);\n\n            for (size_t j = 0; j < n; j += svcntd()) {\n                size_t vl = svcntd();\n                size_t block_size = n - j > vl ? vl : n - j;\n\n                svbool_t pg_block = svwhilelt_b64(j, n);\n                svfloat64_t vec_a = svld1_f64(pg_block, &A[i * n + j]);\n                svfloat64_t vec_b = svld1_f64(pg_block, &B[j * p + k]);\n\n                svbool_t in_range_a = svand_b64(svcgt_f64(pg_block, vec_a, svdup_n_f64(-100.0)), svcle_f64(pg_block, vec_a, svdup_n_f64(100.0)));\n                svbool_t in_range_b = svand_b64(svcgt_f64(pg_block, vec_b, svdup_n_f64(-100.0)), svcle_f64(pg_block, vec_b, svdup_n_f64(100.0)));\n                svbool_t in_range = svand_b64(in_range_a, in_range_b);\n\n                svfloat64_t prod = svmul_x_f64(pg_block, vec_a, vec_b);\n                acc = svmla_m_f64(pg_block, acc, prod, in_range);\n            }\n\n            double result = svaddv_f64(pg, acc);\n            C[i * p + k] += result;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    svbool_t pg = svptrue_b64();\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t k = 0; k < n; ++k) {\n            svfloat64_t va = svld1_f64(pg, &A[i * n + k]);\n            svbool_t in_range_a = svand_b64(svcmlt_f64(pg, va, svdup_f64(100.0)), svcmlt_f64(pg, svdup_f64(-100.0), va));\n            for (size_t j = 0; j < p; ++j) {\n                svfloat64_t vb = svld1_f64(pg, &B[k * p + j]);\n                svbool_t in_range_b = svand_b64(svcmlt_f64(pg, vb, svdup_f64(100.0)), svcmlt_f64(pg, svdup_f64(-100.0), vb));\n                svbool_t in_range = svand_b64(in_range_a, in_range_b);\n                svfloat64_t vc = svld1_f64(pg, &C[i * p + j]);\n                vc = svsel_f64(in_range, svmla_f64(pg, vc, va, vb), vc);\n                svst1_f64(pg, &C[i * p + j], vc);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    svbool_t pg = svptrue_b64();\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t k = 0; k < p; ++k) {\n            svfloat64_t acc = svdup_f64(0.0);\n            size_t j = 0;\n            for (; j + svcntd() <= n; j += svcntd()) {\n                svfloat64_t va = svld1_f64(pg, &A[i * n + j]);\n                svfloat64_t vb = svld1_f64(pg, &B[j * p + k]);\n                \n                svbool_t in_range_a = svand_b64(svcmpge_f64(pg, va, svdup_n_f64(-100.0)), svcmplt_f64(pg, va, svdup_n_f64(100.0)));\n                svbool_t in_range_b = svand_b64(svcmpge_f64(pg, vb, svdup_n_f64(-100.0)), svcmplt_f64(pg, vb, svdup_n_f64(100.0)));\n                svbool_t in_range = svand_b64(in_range_a, in_range_b);\n\n                svfloat64_t prod = svmla_f64(pg, svdup_f64(0.0), va, vb);\n                acc = svadd_f64(pg, acc, svsel_f64(in_range, prod, svdup_f64(0.0)));\n            }\n            for (; j < n; ++j) {\n                if (A[i * n + j] >= -100.0 && A[i * n + j] <= 100.0 &&\n                    B[j * p + k] >= -100.0 && B[j * p + k] <= 100.0) {\n                        acc = svadd_f64(pg, acc, svdup_n_f64(A[i * n + j] * B[j * p + k]));\n                }\n            }\n            float64x2_t res = svaddv_f64(pg, acc);\n            C[i * p + k] += vget_lane_f64(res, 0) + vget_lane_f64(res, 1);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    svbool_t pg = svptrue_b64();\n    size_t vl = svcntd();\n\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t k = 0; k < p; ++k) {\n            svfloat64_t acc = svdup_f64(0.0);\n            size_t j = 0;\n\n            for (; j + vl <= n; j += vl) {\n                svfloat64_t vec_a = svld1_f64(pg, &A[i * n + j]);\n                svfloat64_t vec_b = svld1_f64(pg, &B[j * p + k]);\n\n                svbool_t in_range_a = svand_b64(svcgt_f64(pg, vec_a, svdup_n_f64(-100.0)), svcle_f64(pg, vec_a, svdup_n_f64(100.0)));\n                svbool_t in_range_b = svand_b64(svcgt_f64(pg, vec_b, svdup_n_f64(-100.0)), svcle_f64(pg, vec_b, svdup_n_f64(100.0)));\n\n                svbool_t valid = svand_b64(in_range_a, in_range_b);\n\n                svfloat64_t prod = svmul_x_f64(valid, vec_a, vec_b);\n                acc = svadd_f64(pg, acc, prod);\n            }\n\n            for (; j < n; ++j) {\n                if (A[i * n + j] > -100.0 && A[i * n + j] <= 100.0 && B[j * p + k] > -100.0 && B[j * p + k] <= 100.0) {\n                    acc = svadd_f64(pg, acc, svdup_n_f64(A[i * n + j] * B[j * p + k]));\n                }\n            }\n\n            double sum = 0.0;\n            for (size_t l = 0; l < vl; ++l) {\n                sum += svget_f64(acc, l);\n            }\n            C[i * p + k] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    svbool_t pg = svptrue_b64();\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t k = 0; k < p; ++k) {\n            svfloat64_t acc = svdup_f64(0.0);\n            for (size_t j = 0; j < n; j += svcntd()) {\n                size_t vl = svcntd();\n                size_t ubound = j + vl;\n                if (ubound > n) ubound = n;\n\n                svfloat64_t va = svld1_f64(pg, &A[i * n + j]);\n                svfloat64_t vb = svld1_f64(pg, &B[j * p + k]);\n\n                svfloat64_t cmpa_low = svclt_f64(pg, va, svdup_n_f64(-100.0));\n                svfloat64_t cmpa_high = svcgte_f64(pg, va, svdup_n_f64(100.0));\n                svbool_t pa = svbor_b64(svcmeq_m_b64(pg, cmpa_low, cmpa_low), svcmeq_m_b64(pg, cmpa_high, cmpa_high));\n\n                svfloat64_t cmpb_low = svclt_f64(pg, vb, svdup_n_f64(-100.0));\n                svfloat64_t cmpb_high = svcgte_f64(pg, vb, svdup_n_f64(100.0));\n                svbool_t pb = svbor_b64(svcmeq_m_b64(pg, cmpb_low, cmpb_low), svcmeq_m_b64(pg, cmpb_high, cmpb_high));\n\n                svbool_t pab = svand_b64(pa, pb);\n\n                svfloat64_t prod = svmul_x_f64(pab, va, vb);\n                acc = svadd_f64(pg, acc, prod);\n            }\n            C[i * p + k] += svaddv_f64(pg, acc);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    svbool_t pg = svptrue_b64();\n    size_t vl = svcntd();\n\n    for (; i <= total_elements - vl; i += vl) {\n        svint64_t vec_a = svld1(pg, &A[i]);\n        svint64_t vec_b = svld1(pg, &B[i]);\n        svint64_t vec_c = svadd_z(pg, vec_a, vec_b);\n        svst1(pg, &C[i], vec_c);\n    }\n\n    if (i < total_elements) {\n        size_t remaining = total_elements - i;\n        svbool_t pg_remain = svwhilelt_b64(i, total_elements);\n        svint64_t vec_a = svld1(pg_remain, &A[i]);\n        svint64_t vec_b = svld1(pg_remain, &B[i]);\n        svint64_t vec_c = svadd_z(pg_remain, vec_a, vec_b);\n        svst1(pg_remain, &C[i], vec_c);\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    svbool_t pg = svptrue_b64();\n    svint64_t zero = svdup_z(pg, 0);\n\n    for (; i <= total_elements - svcntd(); i += svcntd()) {\n        svint64_t va = svld1(pg, &A[i]);\n        svint64_t vb = svld1(pg, &B[i]);\n        svint64_t vc = svadd(pg, va, vb);\n        svst1(pg, &C[i], vc);\n    }\n\n    // Handle leftover elements\n    if (i < total_elements) {\n        size_t left = total_elements - i;\n        svbool_t pg_partial = svwhilelt_b64(i, total_elements);\n        svint64_t va = svld1(pg_partial, &A[i]);\n        svint64_t vb = svld1(pg_partial, &B[i]);\n        svint64_t vc = svadd(pg_partial, va, vb);\n        svst1(pg_partial, &C[i], vc);\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    svbool_t pg = svptrue_b64();\n    size_t vl = svcntd(); // Vector length in terms of 64-bit elements\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        size_t n = total_elements - i;\n        svbool_t pred = svwhilelt_b64(i, total_elements);\n        svint64_t vec_a = svld1_z(pred, &A[i]);\n        svint64_t vec_b = svld1_z(pred, &B[i]);\n        svint64_t vec_c = svadd_x(pred, vec_a, vec_b);\n        svst1_p(pred, &C[i], vec_c);\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    svbool_t pg = svptrue_b64();\n    size_t vl = svcntd(); // Vector length in terms of 64-bit elements\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        size_t num_elements = (total_elements - i > vl) ? vl : total_elements - i;\n\n        svbool_t pred = svwhilelt_b64(i, total_elements);\n        \n        svint64_t vec_a = svld1_z_s64(pred, &A[i]);\n        svint64_t vec_b = svld1_z_s64(pred, &B[i]);\n        svint64_t vec_c = svadd_x_s64(pg, vec_a, vec_b);\n        \n        svst1_x_s64(pred, &C[i], vec_c);\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    svbool_t pg = svptrue_b64();\n    size_t vl = svcntd();\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        size_t num = total_elements - i;\n        size_t this_vl = (num > vl) ? vl : num;\n\n        svbool_t pg_temp = svwhilelt_b64(i, i + this_vl);\n\n        svint64_t va = svld1(pg_temp, &A[i]);\n        svint64_t vb = svld1(pg_temp, &B[i]);\n\n        svint64_t vc = svadd(pg_temp, va, vb);\n\n        svst1(pg_temp, &C[i], vc);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    svbool_t pg = svptrue_b32();\n    size_t vec_len = svcntw();\n    size_t i = 0;\n\n    for (; i <= length - vec_len; i += vec_len) {\n        svfloat32_t v1 = svld1_f32(pg, &src1[i]);\n        svfloat32_t v2 = svld1_f32(pg, &src2[i]);\n        svfloat32_t res = svadd_f32(pg, v1, v2);\n        svint32_t rounded_res = svfcvt_n_s32_f32(pg, res, SV_ROUND_NEAREST);\n        svst1_f32(pg, &dst[i], svreinterpret_f32_s32(rounded_res));\n    }\n\n    if (i < length) {\n        svbool_t pg_part = svwhilelt_b32(i, length);\n        svfloat32_t v1 = svld1_f32(pg_part, &src1[i]);\n        svfloat32_t v2 = svld1_f32(pg_part, &src2[i]);\n        svfloat32_t res = svadd_f32(pg_part, v1, v2);\n        svint32_t rounded_res = svfcvt_n_s32_f32(pg_part, res, SV_ROUND_NEAREST);\n        svst1_f32(pg_part, &dst[i], svreinterpret_f32_s32(rounded_res));\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    do {\n        svfloat32_t vec1 = svld1_f32(pg, &src1[i]);\n        svfloat32_t vec2 = svld1_f32(pg, &src2[i]);\n        svfloat32_t result = svadd_f32(pg, vec1, vec2);\n        svint32_t rounded = svfcvt_n_s_f_x(svtrue(), result);\n        svst1_f32(pg, &dst[i], svreinterpret_f32_s32(rounded));\n        i += svcntw();\n    } while (i < length);\n\n    // Handle remaining scalar elements if any\n    for (; i < length; i++) {\n        dst[i] = nearbyintf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    svfloat32_t zero = svdup_f32(0.0f);\n\n    while (i + svcntw() <= length) {\n        svfloat32_t vec1 = svld1(pg, &src1[i]);\n        svfloat32_t vec2 = svld1(pg, &src2[i]);\n        svfloat32_t result = svadd_x(pg, vec1, vec2);\n        svint32_t rounded_result = svrintn_x(pg, result);\n        svst1(pg, &dst[i], sveconvert_s32_f32(pg, rounded_result));\n        i += svcntw();\n    }\n\n    if (i < length) {\n        size_t left = length - i;\n        svbool_t pg_tail = svwhilelt_b32(i, length);\n        svfloat32_t vec1 = svld1(pg_tail, &src1[i]);\n        svfloat32_t vec2 = svld1(pg_tail, &src2[i]);\n        svfloat32_t result = svadd_x(pg_tail, vec1, vec2);\n        svint32_t rounded_result = svrintn_x(pg_tail, result);\n        svst1(pg_tail, &dst[i], sveconvert_s32_f32(pg_tail, rounded_result));\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    svbool_t pg = svptrue_b32();\n    size_t vec_len = svcntw() / sizeof(float);\n    size_t i = 0;\n\n    for (; i <= length - vec_len; i += vec_len) {\n        svfloat32_t v1 = svld1_f32(pg, &src1[i]);\n        svfloat32_t v2 = svld1_f32(pg, &src2[i]);\n        svfloat32_t res = svadd_f32(pg, v1, v2);\n        svint32_t rounded = svrintn_x_f32(pg, res);\n        svst1_f32(pg, &dst[i], sveconverta_f32_s32(rounded));\n    }\n\n    // Handle leftover elements\n    if (i < length) {\n        svbool_t pg_part = svwhilelt_b32(i, length);\n        svfloat32_t v1 = svld1_f32(pg_part, &src1[i]);\n        svfloat32_t v2 = svld1_f32(pg_part, &src2[i]);\n        svfloat32_t res = svadd_f32(pg_part, v1, v2);\n        svint32_t rounded = svrintn_x_f32(pg_part, res);\n        svst1_f32(pg_part, &dst[i], sveconverta_f32_s32(rounded));\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    do {\n        svfloat32_t vec1 = svld1_f32(pg, &src1[i]);\n        svfloat32_t vec2 = svld1_f32(pg, &src2[i]);\n        svfloat32_t result = svadd_f32(pg, vec1, vec2);\n        svint32_t rounded = svfcvt_rni_x_s32_f32(pg, result);\n        svst1_f32(pg, &dst[i], svcvt_f32_x_s32(pg, rounded));\n        i += svcntw();\n    } while (i < length);\n\n    // Handle remaining scalar elements if any\n    for (; i < length; i++) {\n        dst[i] = nearbyintf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length){\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    svfloat32_t neg_one = svdup_n_f32(-1.0f);\n    svfloat32_t fifty = svdup_n_f32(50.0f);\n\n    for (; i <= length - svcntw(); i += svcntw()) {\n        svfloat32_t vec_src1 = svld1(pg, &src1[i]);\n        svfloat32_t vec_src2 = svld1(pg, &src2[i]);\n\n        // Compute absolute difference\n        svfloat32_t diff = svabs_f32(pg, svsub_f32(pg, vec_src1, vec_src2));\n\n        // Check if the absolute value of the difference is within 50\n        svbool_t cond_diff = svcmple_f32(pg, diff, fifty);\n\n        // Check if index is a multiple of 2\n        svbool_t cond_index = svand_b32(pg, svcmpeq_n_u32(pg, svindex_u32(i, 1), 0));\n\n        // Combine conditions\n        svbool_t cond = svand_b32(pg, cond_diff, cond_index);\n\n        // Perform multiplication\n        svfloat32_t mul_res = svmul_x_f32(cond, vec_src1, vec_src2);\n\n        // Round up toward positive infinity\n        svfloat32_t rounded_res = svceil_f32(pg, mul_res);\n\n        // Set to -1 where condition is not met\n        svfloat32_t res = svsel_f32(cond, rounded_res, neg_one);\n\n        // Store the result\n        svst1(pg, &dst[i], res);\n    }\n\n    // Handle remaining elements (if any)\n    for (; i < length; i++) {\n        if (i % 2 == 0 && fabs(src1[i] - src2[i]) <= 50.0f) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length){\n    size_t index = 0;\n    svbool_t pg = svptrue_b32();\n    svfloat32_t res;\n\n    while (index + svcntw() <= length) {\n        svfloat32_t v_src1 = svld1(pg, &src1[index]);\n        svfloat32_t v_src2 = svld1(pg, &src2[index]);\n\n        // Compute absolute difference\n        svfloat32_t diff = svabs_f32(pg, svsub_f32(pg, v_src1, v_src2));\n\n        // Check if the absolute difference is within 50\n        svbool_t cond_diff = svcmple_f32(pg, diff, svdup_n_f32(50.0f));\n\n        // Check if index is a multiple of 2\n        svbool_t cond_index = svand_b32(pg, svcmpeq_n_u32(pg, svindex_u32(index, 1), 0));\n\n        // Combine conditions\n        svbool_t cond = svand_b32(pg, cond_diff, cond_index);\n\n        // Perform multiplication where condition is true\n        res = svsel_f32(cond, svmul_f32(pg, v_src1, v_src2), svdup_n_f32(-1.0f));\n\n        // Round up toward positive infinity\n        res = svrintp_f32(pg, res);\n\n        // Store results\n        svst1(pg, &dst[index], res);\n\n        index += svcntw();\n    }\n\n    // Handle remaining elements\n    if (index < length) {\n        pg = svwhilelt_b32(index, length);\n        svfloat32_t v_src1 = svld1(pg, &src1[index]);\n        svfloat32_t v_src2 = svld1(pg, &src2[index]);\n\n        // Compute absolute difference\n        svfloat32_t diff = svabs_f32(pg, svsub_f32(pg, v_src1, v_src2));\n\n        // Check if the absolute difference is within 50\n        svbool_t cond_diff = svcmple_f32(pg, diff, svdup_n_f32(50.0f));\n\n        // Check if index is a multiple of 2\n        svbool_t cond_index = svand_b32(pg, svcmpeq_n_u32(pg, svindex_u32(index, 1), 0));\n\n        // Combine conditions\n        svbool_t cond = svand_b32(pg, cond_diff, cond_index);\n\n        // Perform multiplication where condition is true\n        res = svsel_f32(cond, svmul_f32(pg, v_src1, v_src2), svdup_n_f32(-1.0f));\n\n        // Round up toward positive infinity\n        res = svrintp_f32(pg, res);\n\n        // Store results\n        svst1(pg, &dst[index], res);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length){\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    svfloat32_t res;\n\n    while (i + svcntw() <= length) {\n        svfloat32_t v_src1 = svld1_f32(pg, &src1[i]);\n        svfloat32_t v_src2 = svld1_f32(pg, &src2[i]);\n\n        // Calculate the absolute difference\n        svfloat32_t diff = svabs_f32(pg, svsub_f32(pg, v_src1, v_src2));\n\n        // Check if the difference is within 50\n        svbool_t cond_diff = svcmple_f32(pg, diff, svdup_f32(50.0f));\n\n        // Check if index is a multiple of 2\n        svbool_t cond_index = svand_b32(pg, svcmpeq_n_u32(pg, svindex_u32(0, 1), i | 1));\n\n        // Combine conditions\n        svbool_t cond = svand_b32(pg, cond_diff, cond_index);\n\n        // Perform multiplication for elements that meet the condition\n        svfloat32_t mul_res = svmul_f32(cond, v_src1, v_src2);\n\n        // Round up toward positive infinity\n        res = svrintp_f32(pg, mul_res);\n\n        // Set -1 for elements that do not meet the condition\n        res = svsel_f32(pg, res, svdup_n_f32(-1.0f), svnot_b32(pg, cond));\n\n        // Store the result\n        svst1_f32(pg, &dst[i], res);\n\n        i += svcntw();\n    }\n\n    // Handle remaining elements if any\n    if (i < length) {\n        pg = svwhilelt_b32(i, length);\n        svfloat32_t v_src1 = svld1_f32(pg, &src1[i]);\n        svfloat32_t v_src2 = svld1_f32(pg, &src2[i]);\n\n        // Calculate the absolute difference\n        svfloat32_t diff = svabs_f32(pg, svsub_f32(pg, v_src1, v_src2));\n\n        // Check if the difference is within 50\n        svbool_t cond_diff = svcmple_f32(pg, diff, svdup_f32(50.0f));\n\n        // Check if index is a multiple of 2\n        svbool_t cond_index = svand_b32(pg, svcmpeq_n_u32(pg, svindex_u32(i, 1), i | 1));\n\n        // Combine conditions\n        svbool_t cond = svand_b32(pg, cond_diff, cond_index);\n\n        // Perform multiplication for elements that meet the condition\n        svfloat32_t mul_res = svmul_f32(cond, v_src1, v_src2);\n\n        // Round up toward positive infinity\n        res = svrintp_f32(pg, mul_res);\n\n        // Set -1 for elements that do not meet the condition\n        res = svsel_f32(pg, res, svdup_n_f32(-1.0f), svnot_b32(pg, cond));\n\n        // Store the result\n        svst1_f32(pg, &dst[i], res);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length){\n    size_t index = 0;\n    svbool_t pg = svptrue_b32();\n    svfloat32_t res;\n\n    while (index < length) {\n        size_t vl = svcntw();\n        size_t bound = index + vl > length ? length - index : vl;\n        svbool_t pred = svwhilelt_b32(index, length);\n\n        // Load data\n        svfloat32_t vec_src1 = svld1_f32(pred, src1);\n        svfloat32_t vec_src2 = svld1_f32(pred, src2);\n\n        // Compute absolute difference\n        svfloat32_t diff = svabs_f32(pred, svsub_f32(pred, vec_src1, vec_src2));\n\n        // Check if the difference is within 50\n        svbool_t cond_diff = svcmple_f32(pred, diff, svdup_n_f32(50.0f));\n\n        // Check if index is a multiple of 2\n        svint32_t indices = svindex_s32((int)index, 1);\n        svbool_t cond_index = svand_x_b32(pred, svcmpeq_n_s32(svand_x_n_s32(indices, 1), 0));\n\n        // Combine conditions\n        svbool_t cond_combined = svand_b32(cond_diff, cond_index);\n\n        // Perform multiplication for elements meeting the condition\n        svfloat32_t mul_res = svmul_f32(cond_combined, vec_src1, vec_src2);\n\n        // Round up toward positive infinity\n        res = svrintp_f32(cond_combined, mul_res);\n\n        // Set elements not meeting the condition to -1\n        res = svsel_f32(pred, res, svdup_n_f32(-1.0f));\n\n        // Store the result\n        svst1_f32(pred, dst, res);\n\n        src1 += vl;\n        src2 += vl;\n        dst += vl;\n        index += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length){\n    size_t index = 0;\n    svbool_t pg = svptrue_b32();\n    svfloat32_t v_res;\n\n    while (index + svcntw() <= length) {\n        svfloat32_t v_src1 = svld1_f32(pg, &src1[index]);\n        svfloat32_t v_src2 = svld1_f32(pg, &src2[index]);\n\n        svfloat32_t v_diff = svabs_f32(pg, svsub_f32(pg, v_src1, v_src2));\n        svbool_t cond = svcmp_le_f32(pg, v_diff, svdup_n_f32(50.0f));\n\n        svuint32_t v_index = svindex_u32(index, 1);\n        svbool_t even_idx = svand_x_b32(pg, svcmpeq_m_b32(pg, svand_x_u32(pg, v_index, svdup_n_u32(1)), svdup_n_u32(0)));\n\n        svbool_t final_cond = svand_b32(cond, even_idx);\n\n        svfloat32_t v_mul = svmul_f32(pg, v_src1, v_src2);\n        svfloat32_t v_rounded = svrintp_f32(pg, v_mul);\n\n        v_res = svsel_f32(pg, v_rounded, svdup_n_f32(-1.0f), final_cond);\n\n        svst1_f32(pg, &dst[index], v_res);\n\n        index += svcntw();\n    }\n\n    // Handle remaining elements if any\n    if (index < length) {\n        size_t i;\n        for (i = index; i < length; i++) {\n            float diff = fabsf(src1[i] - src2[i]);\n            if ((diff <= 50.0f) && (i % 2 == 0)) {\n                dst[i] = ceilf(src1[i] * src2[i]);\n            } else {\n                dst[i] = -1.0f;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    svbool_t pg = svptrue_b64();\n    size_t index = 0;\n\n    while (index <= total_elements - svcntd()) {\n        svfloat64_t vec_mat = svld1_f64(pg, &mat[index]);\n        svfloat64_t vec_res = svmul_x_f64(pg, vec_mat, svdup_n_f64(scalar));\n        svst1_f64(pg, &dst[index], vec_res);\n        index += svcntd();\n    }\n\n    // Handle remaining elements\n    if (index < total_elements) {\n        size_t num_left = total_elements - index;\n        svbool_t pg_tail = svwhilelt_b64(index, total_elements);\n        svfloat64_t vec_mat = svld1_f64(pg_tail, &mat[index]);\n        svfloat64_t vec_res = svmul_x_f64(pg_tail, vec_mat, svdup_n_f64(scalar));\n        svst1_f64(pg_tail, &dst[index], vec_res);\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    svbool_t pg = svptrue_b64();\n    svfloat64_t s = svdup_n_f64(scalar);\n\n    for (size_t i = 0; i < total_elements; i += svcntd()) {\n        size_t vl = svcntd();\n        if (i + vl > total_elements) {\n            vl = total_elements - i;\n            pg = svwhilelt_b64(i, total_elements);\n        }\n        svfloat64_t vec = svld1(pg, &mat[i]);\n        svfloat64_t res = svmul_x(pg, vec, s);\n        svst1(pg, &dst[i], res);\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    svbool_t pg = svptrue_b64();\n    svfloat64_t s = svdup_n_f64(scalar);\n\n    for (size_t i = 0; i < total_elements; i += svcntd()) {\n        size_t vl = svcntd();\n        size_t k = i + vl > total_elements ? total_elements - i : vl;\n        svbool_t pred = svwhilelt_b64(i, total_elements);\n        svfloat64_t vec = svld1_f64(pred, &mat[i]);\n        svfloat64_t res = svmul_f64(pg, vec, s);\n        svst1_f64(pred, &dst[i], res);\n        i += k - 1;\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    svbool_t pg = svptrue_b64();\n    svfloat64_t s = svdup_n_f64(scalar);\n\n    for (size_t i = 0; i < total_elements; i += svcntd()) {\n        size_t vl = svcntd();\n        if (i + vl > total_elements) {\n            pg = svwhilelt_b64(i, total_elements);\n        }\n        svfloat64_t vec = svld1_f64(pg, &mat[i]);\n        svfloat64_t res = svmul_x_f64(pg, vec, s);\n        svst1_f64(pg, &dst[i], res);\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    svbool_t pg = svptrue_b64();\n    svfloat64_t s = svdup_f64(pg, scalar);\n\n    for (size_t i = 0; i < total_elements; i += svcntd()) {\n        size_t vl = svcntd();\n        svbool_t pg_vl = svwhilelt_b64(i, total_elements);\n        svfloat64_t vec_mat = svld1_f64(pg_vl, &mat[i]);\n        svfloat64_t result = svmul_f64(pg_vl, vec_mat, s);\n        svst1_f64(pg_vl, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float* row = &mat[i * n];\n        svbool_t pg = svptrue_b32();\n        size_t index = 0;\n\n        // Compute L2 norm\n        float l2_norm = 0.0f;\n        while (index < n) {\n            size_t vl = svcntw();\n            if (index + vl > n)\n                pg = svwhilelt_b32(index, n);\n            \n            svfloat32_t vec = svld1(pg, row + index);\n            svfloat32_t squared = svmul_x(pg, vec, vec);\n            svfloat32_t partial_sum = svhadd_x(pg, squared, squared);\n\n            float sum_arr[vl];\n            svst1(pg, sum_arr, partial_sum);\n            for (size_t j = 0; j < vl && index + j < n; ++j) {\n                l2_norm += sum_arr[j];\n            }\n\n            index += vl;\n        }\n        l2_norm = sqrtf(l2_norm);\n\n        // Normalize the row\n        index = 0;\n        while (index < n) {\n            size_t vl = svcntw();\n            if (index + vl > n)\n                pg = svwhilelt_b32(index, n);\n\n            svfloat32_t vec = svld1(pg, row + index);\n            svfloat32_t norm = svdup_n_f32(l2_norm);\n            svfloat32_t normalized = svdiv_x(pg, vec, norm);\n            svst1(pg, row + index, normalized);\n\n            index += vl;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    size_t vl = svcntw(); // Vector length in terms of number of 32-bit elements\n\n    for (size_t i = 0; i < m; ++i) {\n        float* row = &mat[i * n];\n        size_t k = 0;\n\n        svbool_t pg = svptrue_b32();\n        svfloat32_t sum_sq = svdup_f32(pg, 0.0f);\n\n        // Compute the L2 norm using SVE intrinsics\n        for (; k + vl <= n; k += vl) {\n            svfloat32_t vec = svld1(pg, &row[k]);\n            svfloat32_t squared = svmul_x_f32(pg, vec, vec);\n            sum_sq = svadd_x_f32(pg, sum_sq, squared);\n        }\n\n        float partial_sum = 0.0f;\n        svfloat32_t res = svaddv_f32(pg, sum_sq);\n        for (int j = 0; j < svcntw(); ++j) {\n            partial_sum += res[j];\n        }\n\n        for (; k < n; ++k) {\n            partial_sum += row[k] * row[k];\n        }\n\n        float norm = sqrtf(partial_sum);\n\n        if (norm != 0.0f) {\n            norm = 1.0f / norm;\n        }\n\n        // Normalize the row elements\n        k = 0;\n        for (; k + vl <= n; k += vl) {\n            svfloat32_t vec = svld1(pg, &row[k]);\n            svfloat32_t normalized = svmul_x_f32(pg, vec, svdup_f32(pg, norm));\n            svst1(pg, &row[k], normalized);\n        }\n\n        for (; k < n; ++k) {\n            row[k] *= norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float* row = mat + i * n;\n\n        // Compute L2 norm\n        svfloat32_t acc = svdup_f32(0.0f);\n        size_t vl = svcntw();\n        for (size_t j = 0; j < n; j += vl) {\n            size_t k = j + vl > n ? n - j : vl;\n            svbool_t pg = svwhilelt_b32(j, n);\n            svfloat32_t vec = svld1(pg, row + j);\n            svfloat32_t sq = svmul_x(pg, vec, vec);\n            acc = svadd_x(pg, acc, sq);\n        }\n\n        float sum_sq = 0.0f;\n        svfloat32_t res = svaddv(acc);\n        for (size_t j = 0; j < vl; ++j) {\n            sum_sq += svget(res, j);\n        }\n        float norm = sqrtf(sum_sq);\n\n        if (norm != 0.0f) {\n            norm = 1.0f / norm;\n\n            // Normalize the row\n            for (size_t j = 0; j < n; j += vl) {\n                size_t k = j + vl > n ? n - j : vl;\n                svbool_t pg = svwhilelt_b32(j, n);\n                svfloat32_t vec = svld1(pg, row + j);\n                svst1(pg, row + j, svmul_x(pg, vec, svdup_f32(norm)));\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    size_t vl = svcntw(); // Vector length in terms of 32-bit elements\n\n    for (size_t i = 0; i < m; ++i) {\n        float* row = &mat[i * n];\n        size_t k = 0;\n\n        svbool_t pg = svptrue_b32();\n        svfloat32_t sum_sq = svdup_f32(pg, 0.0f);\n\n        // Process full vectors\n        for (; k <= n - vl; k += vl) {\n            svfloat32_t vec = svld1(pg, &row[k]);\n            svfloat32_t squared = svmul_x_f32(pg, vec, vec);\n            sum_sq = svadd_x_f32(pg, sum_sq, squared);\n        }\n\n        // Horizontal reduction to get the total sum of squares\n        float sum_of_squares = 0.0f;\n        svfloat32_t partial_sums = svdup_f32(pg, 0.0f);\n        partial_sums = svaddv_f32(pg, sum_sq);\n        for (int j = 0; j < vl; ++j) {\n            sum_of_squares += svget_f32(partial_sums, j);\n        }\n\n        // Process leftovers\n        for (; k < n; ++k) {\n            float val = row[k];\n            sum_of_squares += val * val;\n        }\n\n        // Compute L2 norm\n        float l2_norm = sqrtf(sum_of_squares);\n\n        // Avoid division by zero\n        if (l2_norm == 0.0f) {\n            l2_norm = 1.0f;\n        }\n\n        // Normalize the row\n        k = 0;\n        svfloat32_t inv_norm = svdup_f32(pg, 1.0f / l2_norm);\n\n        for (; k <= n - vl; k += vl) {\n            svfloat32_t vec = svld1(pg, &row[k]);\n            svfloat32_t normalized = svmul_x_f32(pg, vec, inv_norm);\n            svst1(pg, &row[k], normalized);\n        }\n\n        // Handle leftovers\n        for (; k < n; ++k) {\n            row[k] /= l2_norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    size_t vl = svcntw(); // Vector length in terms of 32-bit elements\n\n    for (size_t i = 0; i < m; ++i) {\n        float* row = &mat[i * n];\n        size_t k = 0;\n\n        svfloat32_t sum_sq = svdup_f32(0.0f);\n\n        // Process full vectors\n        for (; k <= n - vl; k += vl) {\n            svfloat32_t vec = svld1_f32(svdup_gather_offset(row + k));\n            svfloat32_t sq = svmul_x_f32(vec, vec);\n            sum_sq = svaddv_f32(sum_sq, sq);\n        }\n\n        // Horizontal sum of squares\n        float horiz_sum = 0.0f;\n        for (int j = 0; j < vl; ++j) {\n            horiz_sum += svindex_f32(j)[j];\n        }\n        float norm = sqrtf(horiz_sum);\n\n        // Normalize the vector if norm is not zero\n        if (norm != 0.0f) {\n            norm = 1.0f / norm;\n\n            // Reset k to process full vectors again for normalization\n            k = 0;\n            for (; k <= n - vl; k += vl) {\n                svfloat32_t vec = svld1_f32(svdup_gather_offset(row + k));\n                svfloat32_t normalized = svmul_x_f32(vec, svdup_f32(norm));\n                svst1_f32(svdup_scatter_offset(row + k), normalized);\n            }\n\n            // Handle leftovers\n            for (; k < n; ++k) {\n                row[k] *= norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t k = 0; k < p; ++k) {\n            svbool_t pg = svptrue_b64();\n            svfloat64_t acc = svdup_f64(pg, 0.0);\n\n            for (size_t j = 0; j < n; ++j) {\n                svfloat64_t vmat1 = svdup_f64(pg, mat1[i * n + j]);\n                svfloat64_t vmat2 = svld1_f64(pg, &mat2[j * p + k]);\n                acc = svmla_f64(pg, acc, vmat1, vmat2);\n            }\n\n            svfloat64_t rounded = svrintn_f64(pg, acc);\n            svfloat64_t converted = svcvt_f64_x(pg, rounded);\n            svst1_f64(pg, &dst[i * p + k], converted);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t k = 0; k < p; ++k) {\n            svbool_t pg = svptrue_b64();\n            svfloat64_t acc = svdup_f64(0.0);\n\n            for (size_t j = 0; j < n; ++j) {\n                svfloat64_t vmat1 = svld1_f64(pg, &mat1[i * n + j]);\n                svfloat64_t vmat2 = svld1_f64(pg, &mat2[j * p + k]);\n                acc = svmla_f64(pg, acc, vmat1, vmat2);\n            }\n\n            svfloat64_t rounded = svrintn_f64(acc);\n            svfloat64_t converted = svcvt_f64_x(pg, rounded);\n            svst1_f64(pg, &dst[i * p + k], converted);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t k = 0; k < p; ++k) {\n            size_t vl = svcntd(); // Vector length in terms of double-precision elements\n            svbool_t pg = svptrue_b64(); // Predicate for all active elements\n            svfloat64_t acc = svdup_f64(pg, 0.0); // Initialize accumulator to zero\n\n            for (size_t j = 0; j < n; j += vl) {\n                size_t num_elements = (n - j > vl) ? vl : n - j;\n                svbool_t pred = svwhilelt_b64(j, n);\n\n                svfloat64_t vec_mat1 = svld1_f64(pred, &mat1[i * n + j]);\n                svfloat64_t vec_mat2 = svld1_f64(pred, &mat2[j * p + k]);\n\n                acc = svmla_f64(pg, acc, vec_mat1, vec_mat2);\n            }\n\n            // Horizontal sum and rounding\n            float64x2_t res = svaddv_f64(acc);\n            int64x2_t rounded_res = vrndiq_s64(vcvtaq_s64_f64(res));\n\n            // Store the result\n            dst[i * p + k] = (double)vget_lane_s64(rounded_res, 0);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t k = 0; k < p; ++k) {\n            svbool_t pg = svptrue_b64();\n            svfloat64_t acc = svdup_f64(0.0);\n\n            for (size_t j = 0; j < n; ++j) {\n                svfloat64_t vec_mat1 = svld1_f64(pg, &mat1[i * n + j]);\n                svfloat64_t vec_mat2 = svld1_f64(pg, &mat2[j * p + k]);\n                acc = svmla_f64(pg, acc, vec_mat1, vec_mat2);\n            }\n\n            svfloat64_t rounded = svrintn_f64(acc);\n            svfloat64_t converted = svcvt_f64_x_f64(pg, rounded);\n            double result = svfirst_f64(svaddv_f64(pg, converted));\n            dst[i * p + k] = result;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t k = 0; k < p; ++k) {\n            size_t l = 0;\n            svbool_t pg = svptrue_b64();\n            svfloat64_t acc = svdup_f64(pg, 0.0);\n\n            for (; l + svcntd() <= n; l += svcntd()) {\n                svfloat64_t vec_mat1 = svld1_f64(pg, &mat1[i * n + l]);\n                svfloat64_t vec_mat2 = svld1_f64(pg, &mat2[k * n + l]);\n                acc = svmla_f64(pg, acc, vec_mat1, vec_mat2);\n            }\n\n            // Handle leftover elements\n            if (l < n) {\n                svindex_t indices = svindex_s64(l, 1);\n                svbool_t pg_tail = svcmplt_u64(indices, n);\n                svfloat64_t vec_mat1 = svld1_idx_f64(pg_tail, indices, &mat1[i * n]);\n                svfloat64_t vec_mat2 = svld1_idx_f64(pg_tail, indices, &mat2[k * n]);\n                acc = svmla_f64(pg_tail, acc, vec_mat1, vec_mat2);\n            }\n\n            // Horizontal reduction and rounding\n            float64x2_t res = svaddv_f64(acc);\n            int64x2_t rounded = vrndq_n_s64(vcvtaq_s64_f64(res));\n            dst[i * p + k] = (double)vget_lane_s64(rounded, 0) + (double)vget_lane_s64(rounded, 1);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    if (cols == 0 || rows == 0) return;\n\n    size_t vl = svcntw();\n    float32x4_t quarter = svdup_n_f32(0.25f);\n\n    for (size_t c = 0; c < cols; c += vl) {\n        size_t ul = svcvt_size_t_svw(min(vl, cols - c));\n        svbool_t pg = svwhilelt_b32(c, cols);\n\n        for (size_t r = 0; r < rows; r++) {\n            float* dst_row = &dst[c * rows + r];\n            svfloat32_t vec = svld1(pg, &src[r * cols + c]);\n            svfloat32_t rounded = svrintn(vec);\n            svfloat32_t diff = svsub_z(pg, vec, rounded);\n            svfloat32_t abs_diff = svasqabs_z(pg, diff);\n            svbool_t cond = svcmplt_z(pg, abs_diff, quarter);\n            svfloat32_t adj = svsel(cond, svadd_z(pg, rounded, quarter), svsub_z(pg, rounded, quarter));\n            svst1(pg, dst_row, adj);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n    size_t col_blocks = (cols + vl - 1) / vl;\n\n    for (size_t c = 0; c < col_blocks; c++) {\n        size_t actual_cols = (c < col_blocks - 1) ? vl : (cols - c * vl);\n        svbool_t pg_actual = svwhilelt_b32(c * vl, cols);\n\n        for (size_t r = 0; r < rows; r++) {\n            svfloat32_t vec = svld1(pg_actual, &src[r * cols + c * vl]);\n            svfloat32_t rounded = svrintn(vec); // Round to nearest integer\n            svfloat32_t scaled = svmla_n_f32(rounded, svdup_n_f32(0.25f), svdup_n_f32(0.0f)); // Scale by 0.25\n            svst1(pg_actual, &dst[c * rows * vl + r * vl], scaled);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n    size_t i, j;\n\n    for (i = 0; i < cols; i += vl) {\n        svfloat32_t col_vecs[rows];\n        size_t k;\n        \n        // Load columns into vectors\n        for (k = 0; k < rows; k++) {\n            const float *row_ptr = &src[k * cols];\n            svfloat32_t vec = svld1(pg, &row_ptr[i]);\n            col_vecs[k] = svrintn_x(pg, svmul_x(pg, vec, svdup_n_f32(4.0f)));\n        }\n\n        // Store transposed rows\n        for (k = 0; k < vl && (i + k) < cols; k++) {\n            float *dst_row = &dst[(i + k) * rows];\n            for (size_t l = 0; l < rows; l++) {\n                svfloat32_t res = svdiv_x(pg, col_vecs[l], svdup_n_f32(4.0f));\n                dst_row[l] = svfirst(pg, res);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n    size_t col_blocks = (cols + vl - 1) / vl;\n\n    for (size_t c = 0; c < col_blocks; c++) {\n        size_t start_col = c * vl;\n        size_t end_col = (start_col + vl > cols) ? cols : start_col + vl;\n        size_t block_size = end_col - start_col;\n\n        svbool_t pg_block = svwhilelt_b32(start_col, end_col);\n\n        for (size_t r = 0; r < rows; r++) {\n            svfloat32_t vec = svld1(pg_block, &src[r * cols + start_col]);\n            svfloat32_t rounded = svrintn(vec);\n            svfloat32_t quartered = svmla_n_f32(svmul_n_f32(rounded, 4.0f), rounded, 0.5f);\n            svst1(pg_block, &dst[c * rows + r], quartered);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    const size_t vl = svcntw();\n    const float32x4_t quarter = {0.25f, 0.25f, 0.25f, 0.25f};\n\n    for (size_t c = 0; c < cols; c += vl) {\n        size_t col_end = (c + vl > cols) ? cols : c + vl;\n        size_t active_lanes = col_end - c;\n\n        svbool_t pg = svwhilelt_b32(c, col_end);\n\n        for (size_t r = 0; r < rows; r++) {\n            float* dst_row = &dst[c * rows + r];\n            svfloat32_t vec = svld1(pg, &src[r * cols + c]);\n            svfloat32_t rounded = svrintn(vec);\n            svfloat32_t scaled = svmul_x(pg, rounded, quarter);\n            svst1(pg, dst_row, scaled);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    svbool_t pg = svptrue_b32();\n    svfloat32_t zero = svdup_f32(0.0f);\n\n    for (; i <= total_elements - svcntw(); i += svcntw()) {\n        svfloat32_t t1 = svld1(pg, &tensor1[i]);\n        svfloat32_t t2 = svld1(pg, &tensor2[i]);\n\n        svfloat32_t diff = svsub_x(pg, t1, t2);\n        svint32_t truncated = svtoint_x(pg, diff);\n        svfloat32_t rounded = svcvt_f32_s32_x(pg, truncated);\n\n        svst1(pg, &dst[i], rounded);\n    }\n\n    // Handle leftover elements with a scalar loop\n    for (; i < total_elements; ++i) {\n        float diff = tensor1[i] - tensor2[i];\n        dst[i] = (float)(int)(diff);\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    for (; i <= total_size - vl; i += vl) {\n        svfloat32_t vec1 = svld1_f32(pg, &tensor1[i]);\n        svfloat32_t vec2 = svld1_f32(pg, &tensor2[i]);\n        svfloat32_t res = svsub_x_f32(pg, vec1, vec2);\n        svfloat32_t rounded_res = svtowards_x_f32(pg, res);\n        svst1_f32(pg, &dst[i], rounded_res);\n    }\n\n    if (i < total_size) {\n        size_t remaining = total_size - i;\n        svbool_t pg_remain = svwhilelt_b32(i, total_size);\n        svfloat32_t vec1 = svld1_f32(pg_remain, &tensor1[i]);\n        svfloat32_t vec2 = svld1_f32(pg_remain, &tensor2[i]);\n        svfloat32_t res = svsub_x_f32(pg_remain, vec1, vec2);\n        svfloat32_t rounded_res = svtowards_x_f32(pg_remain, res);\n        svst1_f32(pg_remain, &dst[i], rounded_res);\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    svbool_t pg = svptrue_b32();\n    svfloat32_t zero = svdup_f32(0.0f);\n\n    for (; i <= total_size - svcntw(); i += svcntw()) {\n        svfloat32_t vec1 = svld1(pg, &tensor1[i]);\n        svfloat32_t vec2 = svld1(pg, &tensor2[i]);\n\n        svfloat32_t diff = svsub_x(pg, vec1, vec2);\n        svint32_t rounded_diff = svcvtfixeds_x(pg, diff, 0); // Round towards zero\n\n        svst1(pg, &dst[i], svreinterpret_f32_s32(rounded_diff));\n    }\n\n    // Handle leftover elements\n    if (i < total_size) {\n        size_t left = total_size - i;\n        svbool_t pg_left = svwhilelt_b32(i, total_size);\n\n        svfloat32_t vec1 = svld1(pg_left, &tensor1[i]);\n        svfloat32_t vec2 = svld1(pg_left, &tensor2[i]);\n\n        svfloat32_t diff = svsub_x(pg_left, vec1, vec2);\n        svint32_t rounded_diff = svcvtfixeds_x(pg_left, diff, 0); // Round towards zero\n\n        svst1(pg_left, &dst[i], svreinterpret_f32_s32(rounded_diff));\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    svbool_t pg = svptrue_b32();\n    svfloat32_t zero = svdup_f32(0.0f);\n\n    for (; i <= total_size - svcntw(); i += svcntw()) {\n        svfloat32_t t1 = svld1_f32(pg, &tensor1[i]);\n        svfloat32_t t2 = svld1_f32(pg, &tensor2[i]);\n\n        svfloat32_t diff = svsub_f32(pg, t1, t2);\n        svfloat32_t rounded = svmin_f32(pg, svmax_f32(pg, diff, zero), svreinterpret_f32_s32(svneg_s32(pg, zero)));\n\n        svst1_f32(pg, &dst[i], rounded);\n    }\n\n    // Handle leftover elements\n    for (; i < total_size; ++i) {\n        dst[i] = (float)((int)(tensor1[i] - tensor2[i]));\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    svbool_t pg = svptrue_b32();\n    size_t i = 0;\n\n    for (; i <= total_size - svcntw(); i += svcntw()) {\n        svfloat32_t t1 = svld1_f32(pg, &tensor1[i]);\n        svfloat32_t t2 = svld1_f32(pg, &tensor2[i]);\n        svfloat32_t res = svsub_x_f32(pg, t1, t2);\n        svint32_t rounded_res = svtoint_x_n_f32(pg, res); // Round towards zero\n        svst1_f32(pg, &dst[i], (svfloat32_t)rounded_res);\n    }\n\n    // Handle leftover elements\n    if (i < total_size) {\n        size_t left = total_size - i;\n        svbool_t pg_left = svwhilelt_b32(i, total_size);\n        svfloat32_t t1 = svld1_f32(pg_left, &tensor1[i]);\n        svfloat32_t t2 = svld1_f32(pg_left, &tensor2[i]);\n        svfloat32_t res = svsub_x_f32(pg_left, t1, t2);\n        svint32_t rounded_res = svtoint_x_n_f32(pg_left, res); // Round towards zero\n        svst1_f32(pg_left, &dst[i], (svfloat32_t)rounded_res);\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    svbool_t pg = svptrue_b64();\n    size_t vl = svcntd();\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        size_t k = total_elements - i;\n        size_t active = (k > vl) ? vl : k;\n\n        svbool_t pg_active = svwhilelt_b64(i, i + active);\n\n        svfloat64_t vec_mat1 = svld1(pg_active, &mat1[i]);\n        svfloat64_t vec_mat2 = svld1(pg_active, &mat2[i]);\n\n        svfloat64_t result = svmul_x(pg_active, vec_mat1, vec_mat2);\n\n        svst1(pg_active, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    svbool_t pg = svptrue_b64();\n    size_t vl = svcntd();\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        size_t k = total_elements - i;\n        size_t active = (k > vl) ? vl : k;\n\n        svbool_t pg_active = svwhilelt_b64(i, i + active);\n\n        svfloat64_t vec_mat1 = svld1(pg_active, &mat1[i]);\n        svfloat64_t vec_mat2 = svld1(pg_active, &mat2[i]);\n\n        svfloat64_t result = svmul_x(pg_active, vec_mat1, vec_mat2);\n\n        svst1(pg_active, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    svbool_t pg = svptrue_b64();\n    size_t vl = svcntd();\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        size_t num = total_elements - i > vl ? vl : total_elements - i;\n        svbool_t pg_temp = svwhilelt_b64(i, total_elements);\n        svfloat64_t vec1 = svld1(pg_temp, &mat1[i]);\n        svfloat64_t vec2 = svld1(pg_temp, &mat2[i]);\n        svfloat64_t res = svmul_x(pg_temp, vec1, vec2);\n        svst1(pg_temp, &dst[i], res);\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    svbool_t pg = svptrue_b64();\n    size_t vl = svcntd();\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        size_t k = total_elements - i;\n        size_t active = (k > vl) ? vl : k;\n\n        svbool_t pg_active = svwhilelt_b64(i, i + active);\n\n        svfloat64_t vec_mat1 = svld1_f64(pg_active, &mat1[i]);\n        svfloat64_t vec_mat2 = svld1_f64(pg_active, &mat2[i]);\n\n        svfloat64_t result = svmul_f64(pg_active, vec_mat1, vec_mat2);\n\n        svst1_f64(pg_active, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    svbool_t pg = svptrue_b64();\n    size_t vl = svcntd();\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        size_t current_vl = (total_elements - i > vl) ? vl : total_elements - i;\n\n        svbool_t pg_current = svwhilelt_b64(i, i + current_vl);\n\n        svfloat64_t vec_mat1 = svld1(pg_current, &mat1[i]);\n        svfloat64_t vec_mat2 = svld1(pg_current, &mat2[i]);\n\n        svfloat64_t result = svmul_x(pg_current, vec_mat1, vec_mat2);\n\n        svst1(pg_current, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        svbool_t pg = svptrue_b32();\n        float32x4_t acc = svdup_f32(0.0f);\n\n        size_t index = 0;\n        size_t vl = svcntw(); // Vector length in terms of elements\n\n        for (; index <= n - vl; index += vl) {\n            svfloat32_t s_vec = svld1(pg, &vec[index]);\n            svfloat32_t s_mat = svld1(pg, &mat[i * n + index]);\n            acc = svmla(acc, s_mat, s_vec);\n        }\n\n        float sum = 0.0f;\n        for (int j = 0; j < vl; j++) {\n            sum += svget_f32(acc, j);\n        }\n\n        for (; index < n; index++) {\n            sum += mat[i * n + index] * vec[index];\n        }\n\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        svfloat32_t acc = svdup_f32(0.0f);\n        size_t vl = svcntw();\n        size_t j = 0;\n\n        for (; j + vl <= n; j += vl) {\n            svfloat32_t v_mat = svld1_f32(svptrue_b32(), mat + i * n + j);\n            svfloat32_t v_vec = svld1_f32(svptrue_b32(), vec + j);\n            acc = svmla_f32(acc, v_mat, v_vec);\n        }\n\n        // Handle leftover elements\n        if (j < n) {\n            svbool_t pg = svptrue_b32();\n            pg = svwhilelt_b32(j, n);\n            svfloat32_t v_mat = svld1_f32(pg, mat + i * n + j);\n            svfloat32_t v_vec = svld1_f32(pg, vec + j);\n            acc = svmla_f32(acc, v_mat, v_vec);\n        }\n\n        float result = 0.0f;\n        svfloat32_t tmp = svaddv_f32(acc);\n        result += svget_f32(tmp, 0);\n\n        dst[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    size_t vl = svcntw(); // Vector length in terms of 32-bit elements\n    size_t i, j;\n    svbool_t pg = svptrue_b32(); // Predicate for all true\n\n    for (i = 0; i < m; i++) {\n        svfloat32_t acc = svdup_f32(pg, 0.0f); // Initialize accumulator to zero\n        size_t k = 0;\n\n        for (; k <= n - vl; k += vl) {\n            svfloat32_t v_vec = svld1_f32(pg, &vec[k]); // Load vector elements\n            svfloat32_t v_mat = svld1_f32(pg, &mat[i * n + k]); // Load matrix row elements\n            acc = svmla_f32(pg, acc, v_mat, v_vec); // Multiply and accumulate\n        }\n\n        // Handle remaining elements\n        if (k < n) {\n            svbool_t pg_remain = svwhilelt_b32(k, n);\n            svfloat32_t v_vec = svld1_f32(pg_remain, &vec[k]);\n            svfloat32_t v_mat = svld1_f32(pg_remain, &mat[i * n + k]);\n            acc = svmla_f32(pg_remain, acc, v_mat, v_vec);\n        }\n\n        // Horizontal sum of the accumulator\n        float32x4_t res = svaddv_f32(acc);\n        dst[i] = res[0] + res[1] + res[2] + res[3];\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        svfloat32_t acc = svdup_f32(0.0f);\n        size_t index = 0;\n        while (index < n) {\n            svbool_t pg = svwhilelt_b32(index, n);\n            svfloat32_t s = svld1(pg, &vec[index]);\n            svfloat32_t a = svld1(pg, &mat[i * n + index]);\n            acc = svmla_f32(acc, a, s);\n            index += svcntw();\n        }\n        dst[i] = svaddv_f32(acc);\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        svfloat32_t acc = svdup_f32(0.0f);\n        size_t index = i * n;\n        for (size_t j = 0; j < n; j += svcntw()) {\n            svbool_t pg = svwhilelt_b32(j, n);\n            svfloat32_t v_mat = svld1(pg, &mat[index + j]);\n            svfloat32_t v_vec = svld1(pg, &vec[j]);\n            acc = svmla(acc, v_mat, v_vec);\n        }\n        float result = svaddv_f32(acc);\n        dst[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```c\n#include <arm_sve.h> \n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vl = svcntd(); // Vector length in terms of 64-bit elements\n    size_t full_vectors = total_elements / vl;\n    size_t remaining_elements = total_elements % vl;\n\n    svbool_t pg_full = svptrue_b64();\n    svbool_t pg_partial = svtbz_b64(remaining_elements);\n\n    svfloat64_t sum_vec = svdup_f64(pg_full, 0.0);\n    const double* p = mat;\n\n    // Process full vectors\n    for (size_t i = 0; i < full_vectors; ++i) {\n        svfloat64_t vec = svld1_f64(pg_full, p);\n        sum_vec = svadd_f64(pg_full, sum_vec, vec);\n        p += vl;\n    }\n\n    // Process remaining elements\n    if (remaining_elements > 0) {\n        svfloat64_t vec = svld1_f64(pg_partial, p);\n        sum_vec = svadd_f64(pg_partial, sum_vec, vec);\n    }\n\n    // Horizontal sum\n    double sum = 0.0;\n    svfloat64_t sum_h = svdup_f64(pg_full, 0.0);\n    for (size_t i = 0; i < vl; ++i) {\n        svbool_t pg_single = svindex_b64(i, i + 1);\n        sum_h = svadd_f64(pg_single, sum_h, svdup_f64(pg_full, svget_f64(sum_vec, i)));\n    }\n    sum = svmvmla_z_f64(pg_full, sum, sum_h, svdup_n_f64(1.0));\n\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```c\n#include <arm_sve.h> \n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t vl = svcntd(); // Vector length in terms of 64-bit elements\n    svbool_t pg = svptrue_b64(); // Predicate for all true\n    double sum = 0.0;\n    size_t total_elements = m * n;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        size_t count = (total_elements - i > vl) ? vl : total_elements - i;\n        svbool_t pred = svwhilelt_b64(i, total_elements);\n        svfloat64_t vec = svld1_gather_index_f64(pg, mat + i, svindex_s64(0, 1));\n        svfloat64_t acc = svdup_f64(0.0);\n        acc = svadd_f64(pred, acc, vec);\n        float64x2_t res = svaddv_f64(pred, acc);\n        sum += vget_lane_f64(res, 0) + vget_lane_f64(res, 1);\n    }\n\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```c\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    svbool_t pg = svptrue_b64();\n    svfloat64_t sum_vec = svdup_f64(pg, 0.0);\n    size_t vec_len = svcntd();\n    size_t i = 0;\n\n    for (; i <= total_elements - vec_len; i += vec_len) {\n        svfloat64_t vec = svld1_f64(pg, &mat[i]);\n        sum_vec = svadd_f64(pg, sum_vec, vec);\n    }\n\n    double partial_sum = 0.0;\n    for (size_t j = 0; j < vec_len; ++j) {\n        partial_sum += svget_f64(sum_vec, j);\n    }\n\n    for (; i < total_elements; ++i) {\n        partial_sum += mat[i];\n    }\n\n    return partial_sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```c\n#include <arm_sve.h> \n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vl = svcntd(); // Vector length in terms of 64-bit elements\n    uint64_t index = 0;\n    svbool_t pg = svptrue_b64();\n    svfloat64_t sum_vec = svdup_f64(pg, 0.0);\n    \n    for (size_t i = 0; i < total_elements; i += vl) {\n        svfloat64_t vec = svld1_f64(pg, &mat[i]);\n        sum_vec = svadd_f64(pg, sum_vec, vec);\n    }\n\n    double total_sum = 0.0;\n    for (size_t i = 0; i < vl; ++i) {\n        total_sum += svget_f64(sum_vec, i);\n    }\n\n    return total_sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```c\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    svbool_t pg = svptrue_b64();\n    svfloat64_t sum_vec = svdup_f64(pg, 0.0);\n    size_t vec_len = svcntd();\n    size_t i = 0;\n\n    for (; i <= total_elements - vec_len; i += vec_len) {\n        svfloat64_t vec = svld1_f64(pg, &mat[i]);\n        sum_vec = svadd_f64(pg, sum_vec, vec);\n    }\n\n    double partial_sum = 0.0;\n    for (size_t j = 0; j < vec_len; ++j) {\n        partial_sum += svget_f64(sum_vec, j);\n    }\n\n    for (; i < total_elements; ++i) {\n        partial_sum += mat[i];\n    }\n\n    return partial_sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```c\n#include <arm_sve.h> \n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    bool result = true;\n    svbool_t pg = svptrue_b32();\n    for (size_t i = 0; i < rows && result; ++i) {\n        const int* row = matrix + i * cols;\n        svint32_t prev_vec = svdup_n_s32(0);\n        svbool_t first = svptrue_b32();\n        size_t j = 0;\n        for (; j + svcntw() <= cols; j += svcntw()) {\n            svint32_t curr_vec = svld1(pg, row + j);\n            if (directions[i]) {\n                svbool_t cond = svcmplt(pg, curr_vec, prev_vec);\n                if (svptest_any(svptrue_b1(), cond)) {\n                    result = false;\n                    break;\n                }\n            } else {\n                svbool_t cond = svcmpgt(pg, curr_vec, prev_vec);\n                if (svptest_any(svptrue_b1(), cond)) {\n                    result = false;\n                    break;\n                }\n            }\n            prev_vec = curr_vec;\n        }\n        // Handle remaining elements\n        for (; j < cols - 1; ++j) {\n            if (directions[i] && row[j] >= row[j + 1]) {\n                result = false;\n                break;\n            } else if (!directions[i] && row[j] <= row[j + 1]) {\n                result = false;\n                break;\n            }\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```c\n#include <arm_sve.h> \n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    bool result = true;\n    for (size_t i = 0; i < rows && result; ++i) {\n        svbool_t pg = svptrue_b32();\n        size_t col = 0;\n        size_t vl = svcntw(); // Vector length in terms of 32-bit elements\n\n        while (col + vl <= cols) {\n            svint32_t vec_curr = svld1(pg, &matrix[i * cols + col]);\n            svint32_t vec_next = svld1(pg, &matrix[i * cols + col + 1]);\n\n            if (directions[i]) {\n                svbool_t cmp_result = svcle(vec_curr, vec_next);\n                if (!svptest_all(pg, cmp_result)) {\n                    result = false;\n                    break;\n                }\n            } else {\n                svbool_t cmp_result = svcge(vec_curr, vec_next);\n                if (!svptest_all(pg, cmp_result)) {\n                    result = false;\n                    break;\n                }\n            }\n            col += vl;\n        }\n\n        // Handle remaining scalar elements\n        for (; col < cols - 1; ++col) {\n            if (directions[i]) {\n                if (matrix[i * cols + col] > matrix[i * cols + col + 1]) {\n                    result = false;\n                    break;\n                }\n            } else {\n                if (matrix[i * cols + col] < matrix[i * cols + col + 1]) {\n                    result = false;\n                    break;\n                }\n            }\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        svbool_t is_ascending = directions[i] ? pg : svnot_b32(pg);\n\n        size_t j = 0;\n        for (; j <= cols - vl; j += vl) {\n            svint32_t vec_curr = svld1(pg, row + j);\n            svint32_t vec_next = svld1(pg, row + j + 1);\n\n            svbool_t cond_asc = svcmple(pg, vec_curr, vec_next);\n            svbool_t cond_desc = svcmpge(pg, vec_curr, vec_next);\n\n            svbool_t result = svand_x(is_ascending, cond_asc, cond_desc);\n            if (svptest_any(svptrue_b1(), result)) {\n                return false;\n            }\n        }\n\n        for (; j < cols - 1; ++j) {\n            if (directions[i]) {\n                if (row[j] > row[j + 1]) return false;\n            } else {\n                if (row[j] < row[j + 1]) return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```c\n#include <arm_sve.h> \n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    bool result = true;\n    for (size_t i = 0; i < rows && result; ++i) {\n        svbool_t pg = svptrue_b32();\n        size_t row_offset = i * cols;\n        const int* row = matrix + row_offset;\n        \n        svint32_t vec_curr, vec_next;\n        size_t index = 0;\n\n        while (index + svcntw() <= cols) {\n            vec_curr = svld1(pg, &row[index]);\n            vec_next = svld1(pg, &row[index + 1]);\n\n            svbool_t cond;\n            if (directions[i]) {\n                cond = svclt(pg, vec_curr, vec_next);\n            } else {\n                cond = svclt(pg, vec_next, vec_curr);\n            }\n\n            if (svptest_any(svptrue_b1(), cond)) {\n                result = false;\n                break;\n            }\n            index += svcntw();\n        }\n\n        // Handle remaining elements\n        if (index < cols - 1) {\n            for (size_t j = index; j < cols - 1; ++j) {\n                if (directions[i]) {\n                    if (row[j] >= row[j + 1]) {\n                        result = false;\n                        break;\n                    }\n                } else {\n                    if (row[j] <= row[j + 1]) {\n                        result = false;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```c\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    bool result = true;\n    svbool_t pg = svptrue_b32();\n    size_t vec_len = svcntw(); // Number of 32-bit elements per vector\n\n    for (size_t i = 0; i < rows && result; ++i) {\n        const int* row = matrix + i * cols;\n        svint32_t prev_vec = svdup_s32(0);\n        bool row_result = true;\n\n        for (size_t j = 0; j + vec_len <= cols && row_result; j += vec_len) {\n            svint32_t curr_vec = svld1(pg, row + j);\n\n            if (directions[i]) { // Ascending order\n                svbool_t cmp_result = svcmplt(pg, curr_vec, prev_vec);\n                if (svptest_any(pg, cmp_result)) {\n                    row_result = false;\n                }\n            } else { // Descending order\n                svbool_t cmp_result = svcmpgt(pg, curr_vec, prev_vec);\n                if (svptest_any(pg, cmp_result)) {\n                    row_result = false;\n                }\n            }\n\n            prev_vec = curr_vec;\n        }\n\n        // Handle remaining elements if cols is not a multiple of vec_len\n        size_t rem = cols - (cols / vec_len) * vec_len;\n        if (rem > 0 && row_result) {\n            svbool_t pg_rem = svwhilelt_b32(0, rem);\n            svint32_t curr_vec = svld1(pg_rem, row + cols - rem);\n\n            if (directions[i]) { // Ascending order\n                svbool_t cmp_result = svcmplt(pg_rem, curr_vec, prev_vec);\n                if (svptest_any(pg_rem, cmp_result)) {\n                    row_result = false;\n                }\n            } else { // Descending order\n                svbool_t cmp_result = svcmpgt(pg_rem, curr_vec, prev_vec);\n                if (svptest_any(pg_rem, cmp_result)) {\n                    row_result = false;\n                }\n            }\n        }\n\n        if (!row_result) {\n            result = false;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    svbool_t pg = svptrue_b16();\n    size_t vec_len = svcntw() / sizeof(int16_t);\n    size_t i = 0;\n\n    for (; i <= length - vec_len; i += vec_len) {\n        svint16_t s = svld1(pg, &src[i]);\n        svint16_t result = svdiv_rn(s, svdup_n_s16(base));\n        result = svmla(pg, result, svdup_n_s16(base), svdup_n_s16(-base));\n        svst1(pg, &dst[i], result);\n    }\n\n    // Handle leftover elements\n    if (i < length) {\n        svbool_t pg_partial = svwhilelt_b16(i, length);\n        svint16_t s = svld1(pg_partial, &src[i]);\n        svint16_t result = svdiv_rn(s, svdup_n_s16(base));\n        result = svmla(pg_partial, result, svdup_n_s16(base), svdup_n_s16(-base));\n        svst1(pg_partial, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    svbool_t pg = svptrue_b16();\n    size_t vec_len = svcntw() / sizeof(int16_t);\n    size_t i = 0;\n\n    for (; i <= length - vec_len; i += vec_len) {\n        svint16_t vec_src = svld1(pg, &src[i]);\n        svint16_t result = svdiv_floor_n_s16(vec_src, base);\n        result = svmul_n_s16(result, base);\n        svst1(pg, &dst[i], result);\n    }\n\n    // Handle remaining elements\n    if (i < length) {\n        svbool_t pg_remainder = svwhilelt_b16(i, length);\n        svint16_t vec_src = svld1(pg_remainder, &src[i]);\n        svint16_t result = svdiv_floor_n_s16(vec_src, base);\n        result = svmul_n_s16(result, base);\n        svst1(pg_remainder, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    svbool_t pg = svptrue_b16();\n    size_t vec_len = svcntw() / 2; // Number of 16-bit elements per vector\n    size_t i = 0;\n\n    for (; i <= length - vec_len; i += vec_len) {\n        svint16_t vec_src = svld1(pg, &src[i]);\n        svint16_t vec_base = svdup_n_s16(base);\n\n        svint16_t quotient = svdiv_rn(vec_src, vec_base);\n        svint16_t result = svmul(pg, quotient, vec_base);\n\n        svst1(pg, &dst[i], result);\n    }\n\n    // Handle leftover elements\n    if (i < length) {\n        svbool_t pg_part = svwhilelt_b16(i, length);\n        svint16_t vec_src = svld1(pg_part, &src[i]);\n        svint16_t vec_base = svdup_n_s16(base);\n\n        svint16_t quotient = svdiv_rn(vec_src, vec_base);\n        svint16_t result = svmul(pg_part, quotient, vec_base);\n\n        svst1(pg_part, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    svbool_t pg = svptrue_b16();\n    size_t vec_len = svcntw() / 2; // Number of 16-bit elements in a vector\n    size_t i = 0;\n\n    for (; i <= length - vec_len; i += vec_len) {\n        svint16_t svec = svld1(pg, &src[i]);\n        svint16_t bvec = svmov_n_s16(base);\n        svint16_t res = svdiv_floor_x(pg, svec, bvec);\n        res = svmul_x(pg, res, bvec);\n        svst1(pg, &dst[i], res);\n    }\n\n    // Handle leftover elements\n    if (i < length) {\n        svbool_t pg_partial = svwhilelt_b16(i, length);\n        svint16_t svec = svld1(pg_partial, &src[i]);\n        svint16_t bvec = svmov_n_s16(base);\n        svint16_t res = svdiv_floor_x(pg_partial, svec, bvec);\n        res = svmul_x(pg_partial, res, bvec);\n        svst1(pg_partial, &dst[i], res);\n    }\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    svbool_t pg = svptrue_b16();\n    size_t vec_len = svcntw() / sizeof(int16_t);\n    size_t i = 0;\n\n    for (; i <= length - vec_len; i += vec_len) {\n        svint16_t vec_src = svld1(pg, &src[i]);\n        svuint8_t vec_base = svdup_n_u8(base);\n        svint16_t vec_res = svdiv_rtn_s16(vec_src, svreinterpret_s16_u8(vec_base));\n        vec_res = svmul_x_s16(pg, vec_res, svreinterpret_s16_u8(vec_base));\n        svst1(pg, &dst[i], vec_res);\n    }\n\n    // Handle remaining elements\n    svbool_t pg_remainder = svwhilelt_b16(i, length);\n    if (svptest_any(svptrue_b16(), pg_remainder)) {\n        svint16_t vec_src = svld1(pg_remainder, &src[i]);\n        svuint8_t vec_base = svdup_n_u8(base);\n        svint16_t vec_res = svdiv_rtn_s16(vec_src, svreinterpret_s16_u8(vec_base));\n        vec_res = svmul_x_s16(pg_remainder, vec_res, svreinterpret_s16_u8(vec_base));\n        svst1(pg_remainder, &dst[i], vec_res);\n    }\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```c\n#include <arm_sve.h> \n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    svbool_t pg = svptrue_b64();\n    size_t vl = svcntd(); // Vector length in terms of double elements\n\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row = &matrix[i * cols];\n        size_t j = 0;\n\n        svbool_t match = pg;\n        while (j + vl <= cols) {\n            svfloat64_t vec_sve = svld1(pg, &vector[j]);\n            svfloat64_t row_sve = svld1(pg, &row[j]);\n            match = svand_z(pg, match, svcmpeq(pg, row_sve, vec_sve));\n            j += vl;\n        }\n\n        if (svcntp(match, pg) == vl && j == cols) {\n            return true;\n        }\n\n        // Handle remaining elements if cols is not a multiple of vl\n        for (; j < cols; ++j) {\n            if (row[j] != vector[j]) {\n                break;\n            }\n            if (j == cols - 1) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```c\n#include <arm_sve.h> \n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    svbool_t pg = svptrue_b64();\n    size_t vl = svcntd();\n    size_t i, j;\n\n    for (i = 0; i < rows; i++) {\n        bool match = true;\n        for (j = 0; j < cols; j += vl) {\n            svfloat64_t vec_sve = svld1_f64(pg, &vector[j]);\n            svfloat64_t mat_sve = svld1_f64(pg, &matrix[i * cols + j]);\n            svbool_t cmp_result = svcmpeq_f64(pg, mat_sve, vec_sve);\n            if (svcntp_b64(cmp_result) != vl) {\n                match = false;\n            }\n            if (!match || (j + vl > cols)) {\n                break;\n            }\n        }\n        if (match && j == cols) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```c\n#include <arm_sve.h> \n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    svbool_t pg = svptrue_b64();\n    size_t vl = svcntd();\n    size_t i, j;\n    for (i = 0; i < rows; i++) {\n        const double* row = matrix + i * cols;\n        svbool_t match = svptrue_b64();\n        for (j = 0; j < cols; j += vl) {\n            svfloat64_t vec_sve = svld1(pg, vector + j);\n            svfloat64_t row_sve = svld1(pg, row + j);\n            svbool_t eq = svcmpeq(pg, row_sve, vec_sve);\n            match = svand(pg, match, eq);\n            if (svcntp(match) == 0) {\n                break;\n            }\n        }\n        if (svptest_any(svptrue_b64(), match)) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```c\n#include <arm_sve.h> \n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    svbool_t pg = svptrue_b64();\n    size_t vl = svcntd(); // Vector length in terms of 64-bit elements\n    size_t i, j;\n\n    for (i = 0; i < rows; i++) {\n        const double* row = matrix + i * cols;\n        bool match = true;\n\n        for (j = 0; j < cols; j += vl) {\n            svfloat64_t vec_sve = svld1_f64(pg, vector + j);\n            svfloat64_t row_sve = svld1_f64(pg, row + j);\n            svbool_t cmp_result = svcmpeq_f64(pg, row_sve, vec_sve);\n            if (svcntp_b64(cmp_result) != vl) {\n                match = false;\n            }\n            if (!match || (j + vl > cols)) break;\n        }\n\n        if (match) return true;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```c\n#include <arm_sve.h> \n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    svbool_t pg = svptrue_b64();\n    size_t vl = svcntd(); // Vector length in terms of double elements\n\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row = &matrix[i * cols];\n        size_t j = 0;\n\n        bool match = true;\n        while (j + vl <= cols) {\n            svfloat64_t vec_sve = svld1(pg, &vector[j]);\n            svfloat64_t row_sve = svld1(pg, &row[j]);\n            svbool_t cmp_result = svcmpeq(pg, row_sve, vec_sve);\n            if (svcntp_m(cmp_result, pg) != vl) {\n                match = false;\n                break;\n            }\n            j += vl;\n        }\n\n        if (match && j < cols) {\n            for (; j < cols; ++j) {\n                if (vector[j] != row[j]) {\n                    match = false;\n                    break;\n                }\n            }\n        }\n\n        if (match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```c\n#include <arm_sve.h> \n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    svbool_t pg = svptrue_b8();\n    size_t vl = svcntb();\n\n    for (size_t i = 0; i <= total_elements - vl; i += vl) {\n        svuint8_t vec_a = svld1(pg, &A[i]);\n        svuint8_t vec_b = svld1(pg, &B[i]);\n        svbool_t eq_mask = svcmpeq_b_u8(pg, vec_a, vec_b);\n        count += svpopcnt_b8(eq_mask);\n    }\n\n    // Handle remaining elements\n    if (total_elements % vl != 0) {\n        size_t remainder = total_elements % vl;\n        svbool_t pg_remainder = svptrue_b8();\n        pg_remainder = svwhilelt_b8(0, remainder);\n        svuint8_t vec_a = svld1(pg_remainder, &A[total_elements - remainder]);\n        svuint8_t vec_b = svld1(pg_remainder, &B[total_elements - remainder]);\n        svbool_t eq_mask = svcmpeq_b_u8(pg_remainder, vec_a, vec_b);\n        count += svpopcnt_b8(eq_mask);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```c\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    svbool_t pg = svptrue_b8();\n    size_t vec_len = svcntb();\n\n    for (size_t i = 0; i <= total_elements - vec_len; i += vec_len) {\n        svuint8_t va = svld1(pg, &A[i]);\n        svuint8_t vb = svld1(pg, &B[i]);\n        svbool_t eq = svcmpeq(pg, va, vb);\n        count += svmovemask_b8(eq);\n    }\n\n    // Handle remaining elements\n    if (total_elements % vec_len != 0) {\n        size_t leftover = total_elements % vec_len;\n        svbool_t pg_left = svptrue_b8();\n        pg_left = svwhilelt_b8((svint8_t){0}, (svint8_t){leftover});\n        svuint8_t va = svld1(pg_left, &A[total_elements - leftover]);\n        svuint8_t vb = svld1(pg_left, &B[total_elements - leftover]);\n        svbool_t eq = svcmpeq(pg_left, va, vb);\n        count += svmovemask_b8(eq);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```c\n#include <arm_sve.h> \n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    svbool_t pg = svptrue_b8();\n    size_t vl = svcntb();\n\n    for (size_t i = 0; i <= total_elements - vl; i += vl) {\n        svuint8_t vec_a = svld1(pg, &A[i]);\n        svuint8_t vec_b = svld1(pg, &B[i]);\n        svbool_t eq_mask = svcmpeq_b_u8(pg, vec_a, vec_b);\n        uint64x2_t partial_count = svcntb_m(pg, eq_mask);\n        count += vaddvq_u64(partial_count);\n    }\n\n    // Handle leftover elements\n    if (total_elements % vl != 0) {\n        size_t remainder = total_elements % vl;\n        svbool_t pg_remainder = svwhilelt_b8(0, remainder);\n        svuint8_t vec_a = svld1(pg_remainder, &A[total_elements - remainder]);\n        svuint8_t vec_b = svld1(pg_remainder, &B[total_elements - remainder]);\n        svbool_t eq_mask = svcmpeq_b_u8(pg_remainder, vec_a, vec_b);\n        uint64x2_t partial_count = svcntb_m(pg_remainder, eq_mask);\n        count += vaddvq_u64(partial_count);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```c\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    svbool_t pg = svptrue_b8();\n    size_t vec_len = svcntb();\n\n    for (size_t i = 0; i <= total_elements - vec_len; i += vec_len) {\n        svuint8_t va = svld1(pg, A + i);\n        svuint8_t vb = svld1(pg, B + i);\n        svbool_t eq = svcmpeq_u8_m(pg, va, vb);\n        count += svmovem_mask(eq);\n    }\n\n    // Handle remaining elements\n    if (total_elements % vec_len != 0) {\n        size_t remainder = total_elements % vec_len;\n        svbool_t pg_remainder = svptrue_b8();\n        pg_remainder = svwhilelt_b8((uint8_t)(total_elements - remainder), (uint8_t)total_elements);\n\n        svuint8_t va = svld1(pg_remainder, A + total_elements - remainder);\n        svuint8_t vb = svld1(pg_remainder, B + total_elements - remainder);\n        svbool_t eq = svcmpeq_u8_m(pg_remainder, va, vb);\n        count += svmovem_mask(eq);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```c\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    svbool_t pg = svptrue_b8();\n    size_t vec_len = svcntb();\n\n    for (size_t i = 0; i <= total_elements - vec_len; i += vec_len) {\n        svuint8_t va = svld1_u8(pg, A + i);\n        svuint8_t vb = svld1_u8(pg, B + i);\n        svbool_t eq = svcmpeq_b_u8(pg, va, vb);\n        count += svmovemask_b_u8(eq);\n    }\n\n    // Handle remaining elements\n    if (total_elements % vec_len != 0) {\n        size_t remainder = total_elements % vec_len;\n        svbool_t pg_remainder = svptrue_b8();\n        pg_remainder = svwhilelt_b8((svint8_t){0}, (svint8_t){remainder});\n        svuint8_t va = svld1_u8(pg_remainder, A + total_elements - remainder);\n        svuint8_t vb = svld1_u8(pg_remainder, B + total_elements - remainder);\n        svbool_t eq = svcmpeq_b_u8(pg_remainder, va, vb);\n        count += svmovemask_b_u8(eq);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b64();\n    svint64_t sa = svdup_n_s64(a);\n\n    while (i + svcntd() <= length) {\n        svint64_t vx = svld1(pg, &x[i]);\n        svint64_t vy = svld1(pg, &y[i]);\n\n        svint64_t mul = svmul_x(pg, sa, vx);\n        svint64_t abs_y = svasr_x(pg, vy, svabs_z(pg, vy));\n        svint64_t res = svsub_x(pg, mul, abs_y);\n\n        svst1(pg, &y[i], res);\n        i += svcntd();\n    }\n\n    if (i < length) {\n        size_t left = length - i;\n        svbool_t tail_pg = svwhilelt_b64(i, length);\n        \n        svint64_t vx = svld1(tail_pg, &x[i]);\n        svint64_t vy = svld1(tail_pg, &y[i]);\n\n        svint64_t mul = svmul_x(tail_pg, sa, vx);\n        svint64_t abs_y = svasr_x(tail_pg, vy, svabs_z(tail_pg, vy));\n        svint64_t res = svsub_x(tail_pg, mul, abs_y);\n\n        svst1(tail_pg, &y[i], res);\n    }\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b64();\n    do {\n        size_t vl = sve_vl();\n        svint64_t sax = svmul_x_s64(pg, svdup_n_s64(a), svld1(pg, &x[i]));\n        svint64_t say = svabs_x_s64(pg, svld1(pg, &y[i]));\n        svst1(pg, &y[i], svsub_x_s64(pg, sax, say));\n        i += vl;\n    } while (i < length);\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b64();\n    do {\n        svint64_t sx = svld1(pg, &x[i]);\n        svint64_t sy = svld1(pg, &y[i]);\n        svint64_t res = svsub_x(pg, svmul_x(pg, svdup_n_s64(a), sx), svasr_x(pg, sy, svdup_n_u64(63)));\n        svst1(pg, &y[i], res);\n        i += svcntd();\n    } while (i < length);\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b64();\n    do {\n        size_t vl = sve_vl();\n        svint64_t sx = svld1(pg, &x[i]);\n        svint64_t sy = svld1(pg, &y[i]);\n        svint64_t sa = svdup_n_s64(a);\n        svint64_t mul = svmul_x(pg, sa, sx);\n        svint64_t abs_y = svabs_x(pg, sy);\n        svint64_t res = svsub_x(pg, mul, abs_y);\n        svst1(pg, &y[i], res);\n        i += svcntd();\n    } while (i < length);\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    svbool_t pg = svptrue_b64();\n    size_t vec_len = svcntd(); // Number of 64-bit elements in an SVE vector\n    size_t i = 0;\n\n    for (; i <= length - vec_len; i += vec_len) {\n        svint64_t vx = svld1(pg, &x[i]);\n        svint64_t vy = svld1(pg, &y[i]);\n\n        svint64_t scaled_vx = svmul_x(pg, vx, a);\n        svint64_t abs_vy = svasqabs(pg, vy);\n\n        svint64_t result = svsub(pg, scaled_vx, abs_vy);\n\n        svst1(pg, &y[i], result);\n    }\n\n    if (i < length) {\n        svbool_t tail_pg = svwhilelt_b64(i, length);\n        svint64_t vx = svld1(tail_pg, &x[i]);\n        svint64_t vy = svld1(tail_pg, &y[i]);\n\n        svint64_t scaled_vx = svmul_x(tail_pg, vx, a);\n        svint64_t abs_vy = svasqabs(tail_pg, vy);\n\n        svint64_t result = svsub(tail_pg, scaled_vx, abs_vy);\n\n        svst1(tail_pg, &y[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\n#include <arm_sve.h> \n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    svbool_t pg = svptrue_b16();\n    svint16_t vmin = svdup_n_s16(INT16_MAX);\n    svint16_t vmax = svdup_n_s16(INT16_MIN);\n\n    size_t i = 0;\n    for (; i <= length - svcntw(); i += svcntw()) {\n        svint16_t vload = svld1_s16(pg, &vec[i]);\n        vmin = svmin_z(pg, vmin, vload);\n        vmax = svmax_z(pg, vmax, vload);\n    }\n\n    int16_t min_result = INT16_MAX;\n    int16_t max_result = INT16_MIN;\n\n    svint16_t vtmp_min = svminv(pg, vmin);\n    svint16_t vtmp_max = svmaxv(pg, vmax);\n\n    for (size_t j = 0; j < svcntw(); ++j) {\n        if (svindex_s16(j, 1) < svcntw()) {\n            min_result = (int16_t)svmin_x(pg, vtmp_min, svdup_lane_s16(vtmp_min, j));\n            max_result = (int16_t)svmax_x(pg, vtmp_max, svdup_lane_s16(vtmp_max, j));\n        }\n    }\n\n    // Process remaining elements\n    for (; i < length; ++i) {\n        if (vec[i] < min_result) min_result = vec[i];\n        if (vec[i] > max_result) max_result = vec[i];\n    }\n\n    MinMaxPair result;\n    result.min_num = min_result;\n    result.max_num = max_result;\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\n#include <arm_sve.h> \n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    svbool_t pg = svptrue_b16();\n    svint16_t vmin = svdup_n_s16(INT16_MAX);\n    svint16_t vmax = svdup_n_s16(INT16_MIN);\n\n    size_t i = 0;\n    for (; i + svcntw() <= length; i += svcntw()) {\n        svint16_t vload = svld1(pg, &vec[i]);\n        vmin = svmin_v_s16(vmin, vload);\n        vmax = svmax_v_s16(vmax, vload);\n    }\n\n    int16_t min_val = INT16_MAX;\n    int16_t max_val = INT16_MIN;\n\n    svint16_t vtmp_min = svminv_s16(vmin);\n    svint16_t vtmp_max = svmaxv_s16(vmax);\n\n    min_val = svminv_s16(vtmp_min);\n    max_val = svmaxv_s16(vtmp_max);\n\n    // Process remaining elements\n    for (; i < length; ++i) {\n        if (vec[i] < min_val) min_val = vec[i];\n        if (vec[i] > max_val) max_val = vec[i];\n    }\n\n    MinMaxPair result;\n    result.min_num = min_val;\n    result.max_num = max_val;\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\n#include <arm_sve.h> \n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    svbool_t pg = svptrue_b16();\n    svint16_t vmin = svdup_s16(SV_MAXINT16);\n    svint16_t vmax = svdup_s16(SV_MININT16);\n\n    size_t i = 0;\n    for (; i + svcntw() <= length; i += svcntw()) {\n        svint16_t v = svld1(pg, &vec[i]);\n        vmin = svmin(vmin, v);\n        vmax = svmax(vmax, v);\n    }\n\n    int16_t min_val = SV_MAXINT16;\n    int16_t max_val = SV_MININT16;\n\n    // Reduce across lanes to find the final min and max\n    svuint16_t indices = svindex_u16(0, 1);\n    while (svptest_any(svptrue_b16(), svcmpge_u16(indices, svdup_n_u16(svcntw())))) {\n        svbool_t last_lane = svcmpeq(pg, indices, svlastlane_b16());\n        min_val = svminv(pg, vmin);\n        max_val = svmaxv(pg, vmax);\n        vmin = svsel(last_lane, svdup_s16(min_val), vmin);\n        vmax = svsel(last_lane, svdup_s16(max_val), vmax);\n        indices = svadd_u16(indices, svdup_n_u16(svcntw()));\n    }\n\n    // Process remaining elements\n    for (; i < length; ++i) {\n        if (vec[i] < min_val) min_val = vec[i];\n        if (vec[i] > max_val) max_val = vec[i];\n    }\n\n    return (MinMaxPair){min_val, max_val};\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\n#include <arm_sve.h> \n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    svbool_t pg = svptrue_b16();\n    svint16_t vmin = svdup_n_s16(INT16_MAX);\n    svint16_t vmax = svdup_n_s16(INT16_MIN);\n\n    size_t i = 0;\n    for (; i <= length - svcntw(); i += svcntw()) {\n        svint16_t vload = svld1(pg, &vec[i]);\n        vmin = svmin_v_s16(vmin, vload);\n        vmax = svmax_v_s16(vmax, vload);\n    }\n\n    // Horizontal reduction for remaining elements\n    int16_t min_val = INT16_MAX;\n    int16_t max_val = INT16_MIN;\n\n    svuint16_t indices = svindex_u16(0, 1);\n    svbool_t pred = svwhilelt_b16(i, (uint16_t)length);\n    while (svptest_any(svptrue_b16(), pred)) {\n        svint16_t vload = svld1_gather_offset_z(pg, pred, vec, indices);\n        vmin = svmin_m(pg, vmin, vmin, vload);\n        vmax = svmax_m(pg, vmax, vmax, vload);\n        indices = svadd_u16(indices, svcntw());\n        i += svcntw();\n        pred = svwhilelt_b16(i, (uint16_t)length);\n    }\n\n    // Reduce across vectors\n    min_val = svminv_s16(vmin);\n    max_val = svmaxv_s16(vmax);\n\n    return (MinMaxPair){min_val, max_val};\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\n#include <arm_sve.h> \n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    svbool_t pg = svptrue_b16();\n    svint16_t vmin = svdup_s16(SV_MAXINT16);\n    svint16_t vmax = svdup_s16(SV_MININT16);\n\n    size_t i = 0;\n    for (; i <= length - svcntw(); i += svcntw()) {\n        svint16_t vload = svld1(pg, &vec[i]);\n        vmin = svmin_z(pg, vmin, vload);\n        vmax = svmax_z(pg, vmax, vload);\n    }\n\n    int16_t min_result = SV_MAXINT16;\n    int16_t max_result = SV_MININT16;\n\n    svint16_t vtmp_min = svwhilelt_b16(i - length, vmin);\n    svint16_t vtmp_max = svwhilelt_b16(i - length, vmax);\n\n    for (size_t j = 0; j < svcntw(); ++j) {\n        if (svptest_any(svptrue_b16(), svcmpeq_z(pg, vtmp_min, svindex_n_s16(j, 1)))) {\n            min_result = svmovemask_n_b16(svcmpeq_z(pg, vtmp_min, svindex_n_s16(j, 1)));\n        }\n        if (svptest_any(svptrue_b16(), svcmpeq_z(pg, vtmp_max, svindex_n_s16(j, 1)))) {\n            max_result = svmovemask_n_b16(svcmpeq_z(pg, vtmp_max, svindex_n_s16(j, 1)));\n        }\n    }\n\n    // Process remaining scalar elements\n    for (; i < length; ++i) {\n        if (vec[i] < min_result) min_result = vec[i];\n        if (vec[i] > max_result) max_result = vec[i];\n    }\n\n    return (MinMaxPair){min_result, max_result};\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```c\n#include <arm_sve.h> \n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    svbool_t pg = svptrue_b32();\n    svint32_t v_zero = svdup_n_s32(0);\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        size_t j = 0;\n\n        for (; j + svcntw() <= cols; j += svcntw()) {\n            svint32_t v_curr = svld1(pg, row + j);\n            svint32_t v_next = svld1(pg, row + j + 1);\n\n            svbool_t cond = svclt(pg, v_curr, v_next);\n            if (svcntp(cond, pg) != svcntw()) {\n                return false;\n            }\n        }\n\n        for (; j < cols - 1; ++j) {\n            if (row[j] >= row[j + 1]) return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```c\n#include <arm_sve.h> \n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = &matrix[i * cols];\n        size_t j = 0;\n\n        for (; j + vl <= cols; j += vl) {\n            svint32_t vec_curr = svld1(pg, &row[j]);\n            svint32_t vec_next = svld1(pg, &row[j + 1]);\n\n            svbool_t cmp_result = svclt_s32(pg, vec_curr, vec_next);\n            if (!svbrdl_all_b32(pg, cmp_result)) {\n                return false;\n            }\n        }\n\n        // Handle leftover elements\n        for (; j < cols - 1; ++j) {\n            if (!(row[j] < row[j + 1])) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```c\n#include <arm_sve.h> \n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = &matrix[i * cols];\n        size_t j = 0;\n\n        for (; j + vl <= cols; j += vl) {\n            svint32_t vec_curr = svld1(pg, &row[j]);\n            svint32_t vec_next = svld1(pg, &row[j + 1]);\n\n            svbool_t pred = svcmplt(vec_curr, vec_next);\n            if (!svptest_all(pg, pred)) {\n                return false;\n            }\n        }\n\n        // Handle leftover elements\n        for (; j < cols - 1; ++j) {\n            if (!(row[j] < row[j + 1])) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```c\n#include <arm_sve.h> \n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    svbool_t pg = svptrue_b32();\n    svint32_t zero = svdup_n_s32(0);\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        size_t index = 0;\n\n        svint32_t prev = svdup_n_s32(row[0]);\n        bool row_valid = true;\n\n        while (index + svcntw() <= cols) {\n            svint32_t curr = svld1(pg, row + index);\n            svbool_t gt_mask = svcmpgt(pg, curr, prev);\n            if (svcntp(gt_mask, pg) != svcntw()) {\n                row_valid = false;\n                break;\n            }\n            prev = curr;\n            index += svcntw();\n        }\n\n        // Handle remaining elements\n        if (index < cols && row_valid) {\n            svint32_t curr = svdup_n_s32(row[index]);\n            svbool_t gt_mask = svcmpgt(pg, curr, prev);\n            if (!svptest_all(pg, gt_mask)) {\n                row_valid = false;\n            }\n        }\n\n        if (!row_valid) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```c\n#include <arm_sve.h> \n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    size_t vl = svcntw();\n    svbool_t pg = svptrue_b32();\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = &matrix[i * cols];\n        size_t j = 0;\n\n        for (; j + vl <= cols - 1; j += vl) {\n            svint32_t vec_curr = svld1(pg, &row[j]);\n            svint32_t vec_next = svld1(pg, &row[j + 1]);\n            svbool_t pred = svcmplt(vec_curr, vec_next);\n            if (svptest_any(pg, pred)) {\n                // If any element fails the test, return false\n                if (!svall(pred, pg)) return false;\n            }\n        }\n\n        // Handle remaining elements with a scalar loop\n        for (; j < cols - 1; ++j) {\n            if (!(row[j] < row[j + 1])) return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```c\n#include <arm_sve.h> \n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_row_blocks = rows / block_size;\n    size_t num_col_blocks = cols / block_size;\n\n    // Load the first block\n    const int* first_block = matrix;\n    size_t block_elements = block_size * block_size;\n    svbool_t pg = svptrue_b32();\n    svint32_t first_block_vecs[block_elements / sve_vl()];\n    for (size_t i = 0; i < block_elements / sve_vl(); ++i) {\n        first_block_vecs[i] = svld1(pg, &first_block[i * sve_vl()]);\n    }\n\n    // Compare all other blocks to the first block\n    for (size_t rb = 0; rb < num_row_blocks; ++rb) {\n        for (size_t cb = 0; cb < num_col_blocks; ++cb) {\n            if (rb == 0 && cb == 0) continue; // Skip comparison with itself\n\n            const int* current_block = matrix + rb * block_size * cols + cb * block_size;\n            for (size_t i = 0; i < block_size; ++i) {\n                for (size_t j = 0; j < block_size; j += sve_vl()) {\n                    svint32_t vec_current = svld1(pg, &current_block[i * cols + j]);\n                    svint32_t vec_first = svld1(pg, &first_block[i * block_size + j]);\n                    svbool_t mismatch = svcmpeq(pg, vec_current, vec_first);\n                    if (svcntp(mismatch) != sve_vl()) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```c\n#include <arm_sve.h> \n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_row_blocks = rows / block_size;\n    size_t num_col_blocks = cols / block_size;\n\n    // Get the first block and store it in a buffer.\n    const int* first_block = matrix;\n    size_t first_block_size = block_size * block_size;\n\n    for (size_t i = 1; i < num_row_blocks * num_col_blocks; ++i) {\n        size_t block_row = (i / num_col_blocks) * block_size;\n        size_t block_col = (i % num_col_blocks) * block_size;\n        const int* current_block = matrix + block_row * cols + block_col;\n\n        size_t idx = 0;\n        svbool_t pg = svptrue_b32();\n        svint32_t vfirst, vcurrent;\n\n        while (idx < first_block_size) {\n            size_t vl = svcntw(); // Vector length in terms of elements\n            size_t remaining = first_block_size - idx;\n            if (remaining < vl) {\n                pg = svwhilelt_b32(idx, first_block_size);\n            }\n\n            vfirst = svld1(pg, &first_block[idx]);\n            vcurrent = svld1(pg, &current_block[idx]);\n\n            if (svany_p(svcmeq(pg, vfirst, vcurrent)) == 0) {\n                return false;\n            }\n\n            idx += vl;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```c\n#include <arm_sve.h> \n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_row_blocks = rows / block_size;\n    size_t num_col_blocks = cols / block_size;\n\n    // Get the first block and store it in a buffer\n    const int* first_block = matrix;\n    size_t first_block_size = block_size * block_size;\n\n    svbool_t pg = svptrue_b32();\n    svint32_t first_block_vecs[block_size];\n    for (size_t i = 0; i < block_size; ++i) {\n        first_block_vecs[i] = svld1_s32(pg, &first_block[i * block_size]);\n    }\n\n    // Compare each block with the first block\n    for (size_t rb = 0; rb < num_row_blocks; ++rb) {\n        for (size_t cb = 0; cb < num_col_blocks; ++cb) {\n            if (rb == 0 && cb == 0) {\n                continue; // Skip comparing the first block with itself\n            }\n            const int* current_block = &matrix[(rb * block_size * cols) + (cb * block_size)];\n            bool blocks_equal = true;\n\n            for (size_t i = 0; i < block_size && blocks_equal; ++i) {\n                svint32_t current_block_vec = svld1_s32(pg, &current_block[i * block_size]);\n                svint32_t cmp = svcmpeq_s32(pg, current_block_vec, first_block_vecs[i]);\n                if (svcntp_m_b32(pg, cmp) != block_size) {\n                    blocks_equal = false;\n                }\n            }\n\n            if (!blocks_equal) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```c\n#include <arm_sve.h> \n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_row_blocks = rows / block_size;\n    size_t num_col_blocks = cols / block_size;\n\n    // Get the first block as reference\n    const int* first_block = matrix;\n    svbool_t pg = svptrue_b32();\n\n    for (size_t i = 1; i < num_row_blocks * num_col_blocks; ++i) {\n        size_t row_idx = (i / num_col_blocks) * block_size;\n        size_t col_idx = (i % num_col_blocks) * block_size;\n\n        const int* current_block = matrix + row_idx * cols + col_idx;\n\n        for (size_t r = 0; r < block_size; ++r) {\n            for (size_t c = 0; c < block_size; c += svcntw()) {\n                svint32_t vec_ref = svld1(pg, first_block + r * cols + c);\n                svint32_t vec_curr = svld1(pg, current_block + r * cols + c);\n\n                svbool_t mismatch = svcmpeq(pg, vec_ref, vec_curr);\n                if (svptest_first(pg, mismatch) == 0) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```c\n#include <arm_sve.h> \n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_row_blocks = rows / block_size;\n    size_t num_col_blocks = cols / block_size;\n\n    // Get the first block as reference\n    const int* first_block = matrix;\n    size_t first_block_size = block_size * block_size;\n\n    svbool_t pg = svptrue_b32();\n    svint32_t first_block_vec;\n\n    for (size_t i = 1; i < num_row_blocks * num_col_blocks; ++i) {\n        const int* current_block = matrix + ((i / num_col_blocks) * block_size * cols) + ((i % num_col_blocks) * block_size);\n\n        for (size_t j = 0; j < first_block_size; j += svcntw()) {\n            size_t k = svcntw();\n            svint32_t vec_first = svld1(pg, &first_block[j]);\n            svint32_t vec_current = svld1(pg, &current_block[j]);\n\n            svbool_t mismatch = svcmpeq(pg, vec_first, vec_current);\n            if (svcntb(mismatch) != k) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```c\n#include <arm_sve.h> \n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (block_size == 0 || length == 0 || vec == NULL) return false;\n\n    size_t num_complete_blocks = length / block_size;\n    if (num_complete_blocks < 2) return true;\n\n    svbool_t pg = svptrue_b64();\n    svfloat64_t tol_vec = svdup_n_f64(pg, tolerance);\n\n    const double* first_block = vec;\n    for (size_t i = 1; i < num_complete_blocks; ++i) {\n        const double* current_block = vec + i * block_size;\n        size_t j = 0;\n        while (j < block_size) {\n            size_t vl = svcntd();\n            size_t k = (block_size - j) < vl ? (block_size - j) : vl;\n            svfloat64_t first = svld1(pg, first_block + j);\n            svfloat64_t curr = svld1(pg, current_block + j);\n\n            svfloat64_t diff = svabs_f64(pg, svsub_f64(pg, first, curr));\n            svbool_t cmp = svcmple_f64(pg, diff, tol_vec);\n            if (svcntp_m_b64(cmp, pg) != k) return false;\n\n            j += k;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```c\n#include <arm_sve.h> \n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (block_size == 0 || length < block_size || vec == NULL) return false;\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 1) return false;\n\n    svbool_t pg = svptrue_b64();\n    svfloat64_t tol_vec = svdup_n_f64(pg, tolerance);\n\n    const double* first_block = vec;\n    svfloat64_t first_block_vec[block_size];\n\n    for (size_t i = 0; i < block_size; i += svcntd()) {\n        svfloat64_t vb = svld1_f64(pg, &first_block[i]);\n        first_block_vec[i] = vb;\n    }\n\n    for (size_t block_idx = 1; block_idx < num_blocks; block_idx++) {\n        const double* current_block = vec + block_idx * block_size;\n\n        for (size_t i = 0; i < block_size; i += svcntd()) {\n            svfloat64_t vb = svld1_f64(pg, &current_block[i]);\n            svfloat64_t diff = svabs_f64(pg, svsub_f64(pg, vb, first_block_vec[i]));\n            if (svany_gt_f64(pg, diff, tol_vec)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```c\n#include <arm_sve.h> \n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (block_size == 0 || length < block_size || vec == NULL) return false;\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 1) return false;\n\n    svbool_t pg = svptrue_b64();\n    svfloat64_t tol_vec = svdup_n_f64(tolerance);\n\n    for (size_t i = 1; i < num_blocks; i++) {\n        size_t offset = i * block_size;\n        for (size_t j = 0; j < block_size; j += svcntd()) {\n            svfloat64_t first_block = svld1_f64(pg, &vec[j]);\n            svfloat64_t curr_block = svld1_f64(pg, &vec[offset + j]);\n\n            svfloat64_t diff = svabs_f64(pg, svsub_f64(pg, first_block, curr_block));\n            svbool_t cmp = svcmplt_f64(pg, diff, tol_vec);\n\n            if (!svall_b64(pg, cmp)) return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```c\n#include <arm_sve.h> \n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (block_size == 0 || length == 0 || vec == NULL) return false;\n\n    size_t num_complete_blocks = length / block_size;\n    if (num_complete_blocks < 2 || block_size == 0) return false;\n\n    svbool_t pg = svptrue_b64();\n    svfloat64_t tol_vec = svdup_n_f64(tolerance);\n\n    const double* first_block = vec;\n    const double* current_block = vec + block_size;\n\n    for (size_t i = 1; i < num_complete_blocks; ++i) {\n        size_t j = 0;\n        for (; j + svcntd() <= block_size; j += svcntd()) {\n            svfloat64_t first = svld1(pg, first_block + j);\n            svfloat64_t curr = svld1(pg, current_block + j);\n\n            svfloat64_t diff = svabs_f64(pg, svsub_f64(pg, first, curr));\n            svbool_t not_within_tolerance = svcmpgt_f64(pg, diff, tol_vec);\n\n            if (svptest_any(svptrue_b1(), not_within_tolerance)) {\n                return false;\n            }\n        }\n\n        // Handle leftover elements in the block (if any)\n        if (j < block_size) {\n            svbool_t pg_partial = svwhilelt_b64(j, block_size);\n            svfloat64_t first = svld1(pg_partial, first_block + j);\n            svfloat64_t curr = svld1(pg_partial, current_block + j);\n\n            svfloat64_t diff = svabs_f64(pg_partial, svsub_f64(pg_partial, first, curr));\n            svbool_t not_within_tolerance = svcmpgt_f64(pg_partial, diff, tol_vec);\n\n            if (svptest_any(svptrue_b1(), not_within_tolerance)) {\n                return false;\n            }\n        }\n\n        current_block += block_size;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```c\n#include <arm_sve.h> \n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (block_size == 0 || length == 0 || vec == NULL) return false;\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 2) return true;\n\n    svbool_t pg = svptrue_b64();\n    svfloat64_t tol_vec = svdup_n_f64(tolerance);\n\n    const double* first_block = vec;\n    for (size_t i = 1; i < num_blocks; ++i) {\n        const double* current_block = vec + i * block_size;\n        for (size_t j = 0; j < block_size; j += svcntd()) {\n            size_t k = j;\n            svfloat64_t first = svld1_f64(pg, first_block + k);\n            svfloat64_t curr = svld1_f64(pg, current_block + k);\n\n            svfloat64_t diff = svabs_f64(pg, svsub_f64(pg, first, curr));\n            svbool_t cond = svcmpge_f64(pg, diff, tol_vec);\n\n            if (svptest_any(svptrue_b64(), cond)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    size_t vl = svcntd(); // Vector length in 64-bit elements\n\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row = &matrix[i * cols];\n        svbool_t pg = svptrue_b64();\n        svfloat64_t acc = svdup_f64(pg, 0.0);\n\n        size_t col = 0;\n        for (; col <= cols - vl; col += vl) {\n            svfloat64_t vec = svld1_f64(pg, &row[col]);\n            acc = svadd_f64(pg, acc, svmul_f64(pg, vec, vec));\n        }\n\n        // Horizontal reduction for the remaining partial vector\n        float64x2_t sum = svaddv_f64(acc);\n        for (; col < cols; ++col) {\n            sum += row[col] * row[col];\n        }\n\n        double norm = sqrt(sum[0] + sum[1]);\n        result[i] = norm > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    size_t vl = svcntd(); // Vector length in terms of double-precision elements\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row_start = matrix + i * cols;\n        svbool_t pg = svptrue_b64();\n        svfloat64_t acc = svdup_f64(0.0);\n\n        for (size_t j = 0; j < cols; j += vl) {\n            size_t k = j + vl > cols ? cols - j : vl;\n            svfloat64_t vec = svld1(pg, row_start + j);\n            svfloat64_t squared = svmul_x_f64(pg, vec, vec);\n            acc = svadd_x_f64(pg, acc, squared);\n        }\n\n        double sum = 0.0;\n        svfloat64_t temp = svwhilelt_b64(0, vl);\n        do {\n            svuint64_t indices = svindex_u64(0, 1);\n            svfloat64_t gather = svdup_f64(0.0);\n            gather = svsel_f64(temp, acc, gather);\n            sum += svaddv_f64(temp, gather);\n            acc = svext_f64(acc, temp);\n            temp = svwhilelt_b64(svcntd() * svcnth(), vl);\n        } while (svptest_any(svptrue_b64(), temp));\n\n        double norm = sqrt(sum);\n        result[i] = norm > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    size_t vl = svcntd(); // Vector length in terms of double-precision elements\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row_start = matrix + i * cols;\n        svbool_t pg = svptrue_b64();\n        svfloat64_t acc = svdup_f64(pg, 0.0);\n\n        size_t j = 0;\n        for (; j + vl <= cols; j += vl) {\n            svfloat64_t vec = svld1_f64(pg, row_start + j);\n            svfloat64_t squared = svmul_x_f64(pg, vec, vec);\n            acc = svadd_x_f64(pg, acc, squared);\n        }\n\n        double sum = 0.0;\n        svfloat64_t partial_acc = svaddv_f64(acc);\n        for (size_t k = 0; k < vl; ++k) {\n            sum += partial_acc[k];\n        }\n\n        for (; j < cols; ++j) {\n            sum += row_start[j] * row_start[j];\n        }\n\n        double norm = sqrt(sum);\n        result[i] = norm > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    size_t vl = svcntd();\n    for (size_t i = 0; i < rows; ++i) {\n        double sum_sq = 0.0;\n        size_t j = 0;\n\n        for (; j + vl <= cols; j += vl) {\n            svbool_t pg = svptrue_b64();\n            svfloat64_t vec = svld1(pg, &matrix[i * cols + j]);\n            svfloat64_t squared = svmul_x_f64(pg, vec, vec);\n            sum_sq += svaddv_f64(pg, squared);\n        }\n\n        for (; j < cols; ++j) {\n            sum_sq += matrix[i * cols + j] * matrix[i * cols + j];\n        }\n\n        double norm = sqrt(sum_sq);\n        result[i] = norm > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    size_t vl = svcntd();\n    svbool_t pg = svptrue_b64();\n\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row = &matrix[i * cols];\n        svfloat64_t acc = svdup_f64(pg, 0.0);\n\n        size_t j = 0;\n        for (; j + vl <= cols; j += vl) {\n            svfloat64_t vec = svld1_f64(pg, &row[j]);\n            acc = svadd_f64(pg, acc, svmul_f64(pg, vec, vec));\n        }\n\n        // Handle leftover elements\n        if (j < cols) {\n            svbool_t pg_partial = svwhilelt_b64(j, cols);\n            svfloat64_t vec = svld1_f64(pg_partial, &row[j]);\n            acc = svadd_f64(pg, acc, svmul_f64(pg, vec, vec));\n        }\n\n        // Horizontal sum of the vector\n        double norm_sq = 0.0;\n        svfloat64_t temp = svdup_f64(pg, 0.0);\n        for (size_t k = 0; k < vl; ++k) {\n            temp = svadd_f64(pg, temp, svext_f64(acc, k));\n        }\n        norm_sq = svaddv_f64(pg, temp);\n\n        double norm = sqrt(norm_sq);\n        result[i] = norm > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    const size_t vec_len = svcntw();\n\n    for (; i <= length - vec_len; i += vec_len) {\n        svuint32_t va = svld1(pg, &A[i]);\n        svuint32_t vb = svld1(pg, &B[i]);\n        svuint32_t vc = svor_u32(va, vb);\n        svst1(pg, &C[i], vc);\n    }\n\n    // Handle leftover elements\n    if (i < length) {\n        pg = svwhilelt_b32(i, length);\n        svuint32_t va = svld1(pg, &A[i]);\n        svuint32_t vb = svld1(pg, &B[i]);\n        svuint32_t vc = svor_u32(va, vb);\n        svst1(pg, &C[i], vc);\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    while (i + svcntw() <= length) {\n        svuint32_t vec_a = svld1(pg, &A[i]);\n        svuint32_t vec_b = svld1(pg, &B[i]);\n        svuint32_t result = svor_u32(vec_a, vec_b);\n        svst1(pg, &C[i], result);\n        i += svcntw();\n    }\n    if (i < length) {\n        size_t left = length - i;\n        svbool_t pg_left = svwhilelt_b32(i, length);\n        svuint32_t vec_a = svld1(pg_left, &A[i]);\n        svuint32_t vec_b = svld1(pg_left, &B[i]);\n        svuint32_t result = svor_u32(vec_a, vec_b);\n        svst1(pg_left, &C[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    while (i + svcntw() <= length) {\n        svuint32_t va = svld1(pg, &A[i]);\n        svuint32_t vb = svld1(pg, &B[i]);\n        svuint32_t vc = svor(pg, va, vb);\n        svst1(pg, &C[i], vc);\n        i += svcntw();\n    }\n    if (i < length) {\n        size_t left = length - i;\n        svbool_t pg_partial = svwhilelt_b32(i, length);\n        svuint32_t va = svld1(pg_partial, &A[i]);\n        svuint32_t vb = svld1(pg_partial, &B[i]);\n        svuint32_t vc = svor(pg_partial, va, vb);\n        svst1(pg_partial, &C[i], vc);\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    while (i + svcntw() <= length) {\n        svuint32_t va = svld1(pg, &A[i]);\n        svuint32_t vb = svld1(pg, &B[i]);\n        svuint32_t vc = svor_u32(va, vb);\n        svst1(pg, &C[i], vc);\n        i += svcntw();\n    }\n    if (i < length) {\n        size_t left = length - i;\n        svbool_t pg_left = svwhilelt_b32(i, (int32_t)length);\n        svuint32_t va = svld1(pg_left, &A[i]);\n        svuint32_t vb = svld1(pg_left, &B[i]);\n        svuint32_t vc = svor_u32(va, vb);\n        svst1(pg_left, &C[i], vc);\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    do {\n        svuint32_t va = svld1_u32(pg, &A[i]);\n        svuint32_t vb = svld1_u32(pg, &B[i]);\n        svuint32_t vc = svor_u32(pg, va, vb);\n        svst1_u32(pg, &C[i], vc);\n        i += svcntw() / sizeof(uint32_t);\n    } while (i < length);\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_of_squares = 0;\n    int64_t sum_of_products = 0;\n\n    size_t index = 0;\n    svbool_t pg = svptrue_b8();\n    svint8_t zero = svdup_n_s8(0);\n\n    while (index + svcntb() <= length) {\n        svint8_t va = svld1(pg, &A[index]);\n        svint8_t vb = svld1(pg, &B[index]);\n\n        // Compute squares of A and B\n        svint16_t sq_a = svmul_x_s16(sv\u89e3\u8bfbt_s8(pg, va, va),_svcastb_s16(zero));\n        svint16_t sq_b = svmul_x_s16(sv\u89e3\u8bfbt_s8(pg, vb, vb), svcastb_s16(zero));\n\n        // Sum of squares\n        svint16_t sum_sq = svadd_x_s16(sq_a, sq_b);\n        sum_of_squares += svaddv_s16(pg, sum_sq);\n\n        // Compute product of A and B\n        svint16_t prod_ab = svmul_x_s16(sv\u89e3\u8bfbt_s8(pg, va, vb), svcastb_s16(zero));\n        sum_of_products += svaddv_s16(pg, prod_ab);\n\n        index += svcntb();\n    }\n\n    // Tail handling if length is not a multiple of svcntb()\n    if (index < length) {\n        size_t left = length - index;\n        pg = svwhilelt_b8(index, length);\n        svint8_t va = svld1(pg, &A[index]);\n        svint8_t vb = svld1(pg, &B[index]);\n\n        // Compute squares of A and B\n        svint16_t sq_a = svmul_x_s16(sv\u89e3\u8bfbt_s8(pg, va, va), svcastb_s16(zero));\n        svint16_t sq_b = svmul_x_s16(sv\u89e3\u8bfbt_s8(pg, vb, vb), svcastb_s16(zero));\n\n        // Sum of squares\n        svint16_t sum_sq = svadd_x_s16(sq_a, sq_b);\n        sum_of_squares += svaddv_s16(pg, sum_sq);\n\n        // Compute product of A and B\n        svint16_t prod_ab = svmul_x_s16(sv\u89e3\u8bfbt_s8(pg, va, vb), svcastb_s16(zero));\n        sum_of_products += svaddv_s16(pg, prod_ab);\n    }\n\n    return sum_of_squares - sum_of_products;\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n\n    size_t i = 0;\n    svbool_t pg = svptrue_b8();\n    svint8_t zero = svdup_s8(0);\n\n    while (i + svcntb() <= length) {\n        svint8_t va = svld1(pg, &A[i]);\n        svint8_t vb = svld1(pg, &B[i]);\n\n        // Compute squares and products\n        svint16_t squares_a = svreinterpret_s16_s8(svmla_x(pg, zero, va, va));\n        svint16_t squares_b = svreinterpret_s16_s8(svmla_x(pg, zero, vb, vb));\n        svint16_t products = svreinterpret_s16_s8(svmla_x(pg, zero, va, vb));\n\n        // Horizontal add for squares\n        svint64x2_t sum_squares_a = svaddv_s16(pg, squares_a);\n        svint64x2_t sum_squares_b = svaddv_s16(pg, squares_b);\n        sum_squares += svaddv_s64(sum_squares_a) + svaddv_s64(sum_squares_b);\n\n        // Horizontal add for products\n        svint64x2_t sum_products_ab = svaddv_s16(pg, products);\n        sum_products += svaddv_s64(sum_products_ab);\n\n        i += svcntb();\n    }\n\n    // Tail handling if length is not a multiple of svcntb()\n    if (i < length) {\n        pg = svwhilelt_b8(i, length);\n        svint8_t va = svld1(pg, &A[i]);\n        svint8_t vb = svld1(pg, &B[i]);\n\n        // Compute squares and products\n        svint16_t squares_a = svreinterpret_s16_s8(svmla_x(pg, zero, va, va));\n        svint16_t squares_b = svreinterpret_s16_s8(svmla_x(pg, zero, vb, vb));\n        svint16_t products = svreinterpret_s16_s8(svmla_x(pg, zero, va, vb));\n\n        // Horizontal add for squares\n        svint64x2_t sum_squares_a = svaddv_s16(pg, squares_a);\n        svint64x2_t sum_squares_b = svaddv_s16(pg, squares_b);\n        sum_squares += svaddv_s64(sum_squares_a) + svaddv_s64(sum_squares_b);\n\n        // Horizontal add for products\n        svint64x2_t sum_products_ab = svaddv_s16(pg, products);\n        sum_products += svaddv_s64(sum_products_ab);\n    }\n\n    return sum_squares - sum_products;\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    svbool_t pg = svptrue_b8();\n    int64_t sum_of_squares = 0;\n    int64_t sum_of_products = 0;\n\n    size_t i = 0;\n    svint8_t zero = svdup_n_s8(0);\n\n    while (i + svcntb() <= length) {\n        svint8_t va = svld1_s8(pg, &A[i]);\n        svint8_t vb = svld1_s8(pg, &B[i]);\n\n        // Compute squares of A and B\n        svint16_t squares_a = svreinterpret_s16_s8(svmla_x_s8(pg, zero, va, va));\n        svint16_t squares_b = svreinterpret_s16_s8(svmla_x_s8(pg, zero, vb, vb));\n\n        // Compute products of A and B\n        svint16_t products = svreinterpret_s16_s8(svmla_x_s8(pg, zero, va, vb));\n\n        // Horizontal add for squares\n        svint64_t sum_squares_a = svaddv_s16(squares_a);\n        svint64_t sum_squares_b = svaddv_s16(squares_b);\n\n        // Horizontal add for products\n        svint64_t sum_products = svaddv_s16(products);\n\n        sum_of_squares += sum_squares_a[0] + sum_squares_b[0];\n        sum_of_products += sum_products[0];\n\n        i += svcntb();\n    }\n\n    // Handle remaining elements if any\n    if (i < length) {\n        size_t vl = svcntb();\n        svbool_t pg_remainder = svwhilelt_b8(i, length);\n        svint8_t va = svld1_s8(pg_remainder, &A[i]);\n        svint8_t vb = svld1_s8(pg_remainder, &B[i]);\n\n        // Compute squares of A and B\n        svint16_t squares_a = svreinterpret_s16_s8(svmla_x_s8(pg_remainder, zero, va, va));\n        svint16_t squares_b = svreinterpret_s16_s8(svmla_x_s8(pg_remainder, zero, vb, vb));\n\n        // Compute products of A and B\n        svint16_t products = svreinterpret_s16_s8(svmla_x_s8(pg_remainder, zero, va, vb));\n\n        // Horizontal add for squares\n        svint64_t sum_squares_a = svaddv_s16(squares_a);\n        svint64_t sum_squares_b = svaddv_s16(squares_b);\n\n        // Horizontal add for products\n        svint64_t sum_products = svaddv_s16(products);\n\n        sum_of_squares += sum_squares_a[0] + sum_squares_b[0];\n        sum_of_products += sum_products[0];\n    }\n\n    return sum_of_squares - sum_of_products;\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_of_squares = 0;\n    int64_t sum_of_products = 0;\n\n    size_t i = 0;\n    svbool_t pg = svptrue_b8();\n    const size_t vec_len = svcntb();\n\n    while (i + vec_len <= length) {\n        svint8_t va = svld1(pg, &A[i]);\n        svint8_t vb = svld1(pg, &B[i]);\n\n        // Compute squares and products\n        svint16_t squares = svmulh_s8(pg, va, va);\n        svint16_t products = svmulh_s8(pg, va, vb);\n\n        // Horizontal reduction for squares\n        svint64_t sum_squares = svaddv_s16(pg, squares);\n        sum_of_squares += svaddv_s64(pg, sum_squares);\n\n        // Horizontal reduction for products\n        svint64_t sum_products = svaddv_s16(pg, products);\n        sum_of_products += svaddv_s64(pg, sum_products);\n\n        i += vec_len;\n    }\n\n    // Tail handling if length is not a multiple of vec_len\n    if (i < length) {\n        pg = svwhilelt_b8(i, length);\n        svint8_t va = svld1(pg, &A[i]);\n        svint8_t vb = svld1(pg, &B[i]);\n\n        // Compute squares and products\n        svint16_t squares = svmulh_s8(pg, va, va);\n        svint16_t products = svmulh_s8(pg, va, vb);\n\n        // Horizontal reduction for squares\n        svint64_t sum_squares = svaddv_s16(pg, squares);\n        sum_of_squares += svaddv_s64(pg, sum_squares);\n\n        // Horizontal reduction for products\n        svint64_t sum_products = svaddv_s16(pg, products);\n        sum_of_products += svaddv_s64(pg, sum_products);\n    }\n\n    return sum_of_squares - sum_of_products;\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n\n    size_t i = 0;\n    svbool_t pg = svptrue_b8();\n    svint8_t zero = svdup_s8(0);\n\n    while (i + svcntb() <= length) {\n        svint8_t va = svld1_s8(pg, &A[i]);\n        svint8_t vb = svld1_s8(pg, &B[i]);\n\n        // Compute squares and products\n        svint16_t squares_a = svreinterpret_s16_s8(svshl_s8(va, va));\n        svint16_t squares_b = svreinterpret_s16_s8(svshl_s8(vb, vb));\n        svint16_t products = svreinterpret_s16_s8(svmulh_s8(va, vb));\n\n        // Add to running totals\n        sum_squares += svaddv_s16(pg, svadd_s16(squares_a, squares_b));\n        sum_products += svaddv_s16(pg, products);\n\n        i += svcntb();\n    }\n\n    // Tail handling if length is not a multiple of svcntb()\n    if (i < length) {\n        size_t left = length - i;\n        svbool_t tail_pg = svwhilelt_b8(i, length);\n        svint8_t va = svld1_s8(tail_pg, &A[i]);\n        svint8_t vb = svld1_s8(tail_pg, &B[i]);\n\n        // Compute squares and products\n        svint16_t squares_a = svreinterpret_s16_s8(svshl_s8(va, va));\n        svint16_t squares_b = svreinterpret_s16_s8(svshl_s8(vb, vb));\n        svint16_t products = svreinterpret_s16_s8(svmulh_s8(va, vb));\n\n        // Add to running totals\n        sum_squares += svaddv_s16(tail_pg, svadd_s16(squares_a, squares_b));\n        sum_products += svaddv_s16(tail_pg, products);\n    }\n\n    return sum_squares - sum_products;\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b64();\n    do {\n        svuint64_t va = svld1_u64(pg, &A[i]);\n        svuint64_t vb = svld1_u64(pg, &B[i]);\n        svuint64_t vc = svandnot_u64(pg, va, vb);\n        svst1_u64(pg, &C[i], vc);\n        i += svcntd();\n    } while (i < length);\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b64();\n    while (i + svcntd() <= length) {\n        svuint64_t vec_a = svld1(pg, &A[i]);\n        svuint64_t vec_b = svld1(pg, &B[i]);\n        svuint64_t vec_c = svandnot_z(pg, vec_b, vec_a);\n        svst1(pg, &C[i], vec_c);\n        i += svcntd();\n    }\n    if (i < length) {\n        size_t left = length - i;\n        svbool_t pg_left = svwhilelt_b64(i, length);\n        svuint64_t vec_a = svld1(pg_left, &A[i]);\n        svuint64_t vec_b = svld1(pg_left, &B[i]);\n        svuint64_t vec_c = svandnot_z(pg_left, vec_b, vec_a);\n        svst1(pg_left, &C[i], vec_c);\n    }\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b64();\n    size_t vl = svcntd();\n\n    for (; i <= length - vl; i += vl) {\n        svuint64_t vec_a = svld1(pg, &A[i]);\n        svuint64_t vec_b = svld1(pg, &B[i]);\n        svuint64_t vec_c = svandnot_x(pg, vec_a, vec_b);\n        svst1(pg, &C[i], vec_c);\n    }\n\n    if (i < length) {\n        size_t left = length - i;\n        svbool_t pg_partial = svwhilelt_b64(i, length);\n        svuint64_t vec_a = svld1(pg_partial, &A[i]);\n        svuint64_t vec_b = svld1(pg_partial, &B[i]);\n        svuint64_t vec_c = svandnot_x(pg_partial, vec_a, vec_b);\n        svst1(pg_partial, &C[i], vec_c);\n    }\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b64();\n    const size_t vec_len = svcntd();\n\n    for (; i <= length - vec_len; i += vec_len) {\n        svuint64_t va = svld1(pg, &A[i]);\n        svuint64_t vb = svld1(pg, &B[i]);\n        svuint64_t vc = svand_x(pg, va, svnot_x(pg, vb));\n        svst1(pg, &C[i], vc);\n    }\n\n    if (i < length) {\n        svbool_t pg_tail = svwhilelt_b64(i, length);\n        svuint64_t va = svld1(pg_tail, &A[i]);\n        svuint64_t vb = svld1(pg_tail, &B[i]);\n        svuint64_t vc = svand_x(pg_tail, va, svnot_x(pg_tail, vb));\n        svst1(pg_tail, &C[i], vc);\n    }\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b64();\n    while (i + svcntd() <= length) {\n        svuint64_t va = svld1_u64(pg, &A[i]);\n        svuint64_t vb = svld1_u64(pg, &B[i]);\n        svuint64_t vc = svandnot_u64(pg, va, vb);\n        svst1_u64(pg, &C[i], vc);\n        i += svcntd();\n    }\n    if (i < length) {\n        size_t left = length - i;\n        svbool_t pg_partial = svwhilelt_b64(i, length);\n        svuint64_t va = svld1_u64(pg_partial, &A[i]);\n        svuint64_t vb = svld1_u64(pg_partial, &B[i]);\n        svuint64_t vc = svandnot_u64(pg_partial, va, vb);\n        svst1_u64(pg_partial, &C[i], vc);\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b8();\n    do {\n        svint8_t va = svld1(pg, &A[i]);\n        svint8_t vb = svld1(pg, &B[i]);\n        \n        svbool_t both_pos = svcmpgt(va, SVINT8(0)) & svcmpgt(vb, SVINT8(0));\n        svbool_t both_neg = svcmplt(va, SVINT8(0)) & svcmplt(vb, SVINT8(0));\n        \n        svint8_t vc = svdup_s8(0);\n        vc = svsel(both_pos, svdup_s8(1), vc);\n        vc = svsel(both_neg, svdup_s8(-1), vc);\n        \n        svst1(pg, &C[i], vc);\n        \n        i += svcntb();\n    } while (i < length);\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b8();\n    while (i + svcntb() <= length) {\n        svint8_t vec_a = svld1(pg, &A[i]);\n        svint8_t vec_b = svld1(pg, &B[i]);\n\n        svbool_t both_pos = svcmpgt(vec_a, SVINT8_ZERO) & svcmpgt(vec_b, SVINT8_ZERO);\n        svbool_t both_neg = svcmplt(vec_a, SVINT8_ZERO) & svcmplt(vec_b, SVINT8_ZERO);\n\n        svint8_t result = svdup_s8(0);\n        result = svsel(both_pos, svdup_s8(1), result);\n        result = svsel(both_neg, svdup_s8(-1), result);\n\n        svst1(pg, &C[i], result);\n\n        i += svcntb();\n    }\n\n    // Handle leftover elements\n    for (; i < length; ++i) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b8();\n    while (i + svcntb() <= length) {\n        svint8_t va = svld1(pg, A + i);\n        svint8_t vb = svld1(pg, B + i);\n\n        svint8_t pos_mask_a = svmovem_b8(svcmpgt(va, SVINT8_ZERO));\n        svint8_t pos_mask_b = svmovem_b8(svcmpgt(vb, SVINT8_ZERO));\n\n        svint8_t neg_mask_a = svmovem_b8(svcmplt(va, SVINT8_ZERO));\n        svint8_t neg_mask_b = svmovem_b8(svcmplt(vb, SVINT8_ZERO));\n\n        svint8_t both_pos = svand_x(pos_mask_a, pos_mask_b);\n        svint8_t both_neg = svand_x(neg_mask_a, neg_mask_b);\n\n        svint8_t result = svorr_x(both_pos, svneg_x(SVINT8_ONE, both_neg));\n\n        svst1(pg, C + i, result);\n\n        i += svcntb();\n    }\n\n    // Handle remaining elements if length is not a multiple of svcntb()\n    for (; i < length; ++i) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b8();\n    while (i + svcntb() <= length) {\n        svint8_t va = svld1(pg, A + i);\n        svint8_t vb = svld1(pg, B + i);\n\n        svbool_t pos_a = svcmpgt(va, SVINT8_ZERO);\n        svbool_t pos_b = svcmpgt(vb, SVINT8_ZERO);\n        svbool_t neg_a = svcmplt(va, SVINT8_ZERO);\n        svbool_t neg_b = svcmplt(vb, SVINT8_ZERO);\n\n        svbool_t both_pos = svand_b8(pg, pos_a, pos_b);\n        svbool_t both_neg = svand_b8(pg, neg_a, neg_b);\n\n        svint8_t res = svdup_s8(0);\n        res = svsel(both_pos, svdup_s8(1), res);\n        res = svsel(both_neg, svdup_s8(-1), res);\n\n        svst1(pg, C + i, res);\n\n        i += svcntb();\n    }\n\n    // Handle leftover elements\n    if (i < length) {\n        svbool_t pg_partial = svwhilelt_b8(i, length);\n        svint8_t va = svld1(pg_partial, A + i);\n        svint8_t vb = svld1(pg_partial, B + i);\n\n        svbool_t pos_a = svcmpgt_m(pg_partial, pg_partial, va, SVINT8_ZERO);\n        svbool_t pos_b = svcmpgt_m(pg_partial, pg_partial, vb, SVINT8_ZERO);\n        svbool_t neg_a = svcmplt_m(pg_partial, pg_partial, va, SVINT8_ZERO);\n        svbool_t neg_b = svcmplt_m(pg_partial, pg_partial, vb, SVINT8_ZERO);\n\n        svbool_t both_pos = svand_b8(pg_partial, pos_a, pos_b);\n        svbool_t both_neg = svand_b8(pg_partial, neg_a, neg_b);\n\n        svint8_t res = svdup_s8(0);\n        res = svsel_m(pg_partial, both_pos, res, svdup_s8(1));\n        res = svsel_m(pg_partial, both_neg, res, svdup_s8(-1));\n\n        svst1(pg_partial, C + i, res);\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b8();\n    do {\n        svint8_t va = svld1(pg, &A[i]);\n        svint8_t vb = svld1(pg, &B[i]);\n\n        svbool_t both_pos = svcmpgt(va, SVINT8_SVCONST(0)) & svcmpgt(vb, SVINT8_SVCONST(0));\n        svbool_t both_neg = svcmplt(va, SVINT8_SVCONST(0)) & svcmplt(vb, SVINT8_SVCONST(0));\n\n        svint8_t res = svdup_s8(0);\n        res = svsel(both_pos, svdup_s8(1), res);\n        res = svsel(both_neg, svdup_s8(-1), res);\n\n        svst1(pg, &C[i], res);\n\n        i += svcntw() / sizeof(int8_t);\n    } while (i < length);\n\n    // Handle any remaining elements if length is not a multiple of vector length\n    size_t vec_length = svcntw() / sizeof(int8_t);\n    if (i < length) {\n        pg = svwhilelt_b8(i, length);\n        svint8_t va = svld1(pg, &A[i]);\n        svint8_t vb = svld1(pg, &B[i]);\n\n        svbool_t both_pos = svcmpgt(va, SVINT8_SVCONST(0)) & svcmpgt(vb, SVINT8_SVCONST(0));\n        svbool_t both_neg = svcmplt(va, SVINT8_SVCONST(0)) & svcmplt(vb, SVINT8_SVCONST(0));\n\n        svint8_t res = svdup_s8(0);\n        res = svsel(both_pos, svdup_s8(1), res);\n        res = svsel(both_neg, svdup_s8(-1), res);\n\n        svst1(pg, &C[i], res);\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    svbool_t pg = svptrue_b16();\n    svuint16_t zero = svdup_n_u16(0);\n\n    for (size_t i = 0; i < length; i += svcntw() / sizeof(uint16_t)) {\n        size_t bound = i + svcntw() / sizeof(uint16_t);\n        if (bound > length)\n            bound = length;\n\n        svbool_t pred = svwhilelt_b16(i, length);\n        svuint16_t vec_a = svld1_u16(pred, &A[i]);\n        svuint16_t vec_b = svld1_u16(pred, &B[i]);\n\n        svuint16_t vec_c;\n        if (i + svcntw() / sizeof(uint16_t) <= midpoint) {\n            // Before midpoint: XOR operation\n            vec_c = svxor_u16(vec_a, vec_b);\n        } else if (i >= midpoint) {\n            // After midpoint: AND operation\n            vec_c = svand_u16(vec_a, vec_b);\n        } else {\n            // Midpoint index: keep value from A\n            svbool_t before_mid = svwhilelt_b16(i, midpoint);\n            svbool_t after_mid = svwhilege_b16(i, midpoint);\n            svuint16_t xor_res = svsel_u16(before_mid, svxor_u16(vec_a, vec_b), zero);\n            svuint16_t and_res = svsel_u16(after_mid, svand_u16(vec_a, vec_b), zero);\n            vec_c = svsel_u16(svcmpeq_u16(svidx(), svidx()), vec_a, svorr_u16(xor_res, and_res));\n        }\n\n        svst1_u16(pred, &C[i], vec_c);\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    svbool_t pg_full = svptrue_b16();\n    svbool_t pg_midpoint = svindex_b16(0, 1) == (svint16_t){midpoint};\n\n    for (size_t i = 0; i < length; i += svcntw() / sizeof(uint16_t)) {\n        size_t index = i;\n        svbool_t pg = svwhilelt_b16(i, length);\n\n        svuint16_t sva = svld1(pg, &A[index]);\n        svuint16_t svb = svld1(pg, &B[index]);\n\n        svuint16_t svres;\n        svbool_t is_midpoint = svcmpeq(pg, svindex_b16(i, 1), svdup_n_s16(midpoint));\n        svbool_t before_midpoint = svcmplt(pg, svindex_b16(i, 1), svdup_n_s16(midpoint));\n\n        svres = svsel(is_midpoint, sva, svorr_b16(before_midpoint, sva, svb));\n        svres = svsel(svnot_b16(is_midpoint), svres, svand_b16(svnot_b16(before_midpoint), sva, svb));\n\n        svst1(pg, &C[index], svres);\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    svbool_t pg = svptrue_b16();\n    size_t i = 0;\n\n    // Process elements before the midpoint: XOR operation\n    for (; i <= (length - svcntw()) && i < midpoint; i += svcntw()) {\n        svuint16_t vec_a = svld1(pg, &A[i]);\n        svuint16_t vec_b = svld1(pg, &B[i]);\n        svuint16_t result = svxor(vec_a, vec_b);\n        svst1(pg, &C[i], result);\n    }\n\n    // Scalar processing for remaining elements before midpoint if any\n    for (; i < midpoint; ++i) {\n        C[i] = A[i] ^ B[i];\n    }\n\n    // Set the midpoint element to the value in A\n    if (midpoint < length) {\n        C[midpoint] = A[midpoint];\n        ++midpoint;\n    }\n\n    // Process elements after the midpoint: AND operation\n    i = midpoint;\n    for (; i <= (length - svcntw()); i += svcntw()) {\n        svuint16_t vec_a = svld1(pg, &A[i]);\n        svuint16_t vec_b = svld1(pg, &B[i]);\n        svuint16_t result = svand(vec_a, vec_b);\n        svst1(pg, &C[i], result);\n    }\n\n    // Scalar processing for remaining elements after midpoint if any\n    for (; i < length; ++i) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    svbool_t pg = svptrue_b16();\n    size_t i = 0;\n\n    // Process elements before the midpoint: XOR operation\n    for (; i <= (length - svcntw() / 2) && i < midpoint; i += svcntw() / 2) {\n        svuint16_t va = svld1_u16(pg, A + i);\n        svuint16_t vb = svld1_u16(pg, B + i);\n        svuint16_t vc = svxor_u16(pg, va, vb);\n        svst1_u16(pg, C + i, vc);\n    }\n\n    // Handle leftover elements before the midpoint if any\n    if (i < midpoint) {\n        size_t left = midpoint - i;\n        svbool_t pg_left = svwhilelt_b16((uint64_t)i * 2, (uint64_t)midpoint * 2);\n        svuint16_t va = svld1_u16(pg, A + i);\n        svuint16_t vb = svld16_u(pg, B + i);\n        svuint16_t vc = svxor_u16(pg_left, va, vb);\n        svst1_u16(pg_left, C + i, vc);\n        i = midpoint;\n    }\n\n    // Process the element at the midpoint: keep value in A\n    if (length % 2 != 0 || length == 1) {\n        C[midpoint] = A[midpoint];\n        midpoint++;\n    }\n\n    // Process elements after the midpoint: AND operation\n    for (; i <= (length - svcntw() / 2) && i < length; i += svcntw() / 2) {\n        svuint16_t va = svld1_u16(pg, A + i);\n        svuint16_t vb = svld1_u16(pg, B + i);\n        svuint16_t vc = svand_u16(pg, va, vb);\n        svst1_u16(pg, C + i, vc);\n    }\n\n    // Handle leftover elements after the midpoint if any\n    if (i < length) {\n        size_t left = length - i;\n        svbool_t pg_left = svwhilelt_b16((uint64_t)i * 2, (uint64_t)length * 2);\n        svuint16_t va = svld1_u16(pg, A + i);\n        svuint16_t vb = svld1_u16(pg, B + i);\n        svuint16_t vc = svand_u16(pg_left, va, vb);\n        svst1_u16(pg_left, C + i, vc);\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    svbool_t pg = svptrue_b16();\n    size_t i = 0;\n\n    // Process elements before the midpoint with XOR\n    for (; i <= (length - svcntw()) && i < midpoint; i += svcntw()) {\n        svuint16_t vec_a = svld1(pg, &A[i]);\n        svuint16_t vec_b = svld1(pg, &B[i]);\n        svuint16_t result = svxor(vec_a, vec_b);\n        svst1(pg, &C[i], result);\n    }\n\n    // Handle remaining scalar elements before midpoint if any\n    for (; i < midpoint; ++i) {\n        C[i] = A[i] ^ B[i];\n    }\n\n    // Store the midpoint element from A\n    if (midpoint < length) {\n        C[midpoint] = A[midpoint];\n        ++midpoint;\n    }\n\n    // Process elements after the midpoint with AND\n    i = midpoint;\n    for (; i <= (length - svcntw()) && i < length; i += svcntw()) {\n        svuint16_t vec_a = svld1(pg, &A[i]);\n        svuint16_t vec_b = svld1(pg, &B[i]);\n        svuint16_t result = svand(vec_a, vec_b);\n        svst1(pg, &C[i], result);\n    }\n\n    // Handle remaining scalar elements after midpoint if any\n    for (; i < length; ++i) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < total_size; i += vl) {\n        size_t num = svcntw();\n        size_t k = total_size - i;\n        if (k < vl) {\n            pg = svwhilelt_b32(i, total_size);\n        }\n\n        svfloat32_t sva = svld1(pg, &A[i]);\n        svfloat32_t svb = svld1(pg, &B[i]);\n        svfloat32_t svc = svld1(pg, &C[i]);\n        svfloat32_t svd = svld1(pg, &D[i]);\n\n        svbool_t svcond1 = svcmpeq(pg, svindex_s32(0, 1), svindex_s32(0, 1));\n        uint32_t* cond1_ptr = (uint32_t*)&cond1[i];\n        svbool_t svcond1_loaded = svcmpeq(pg, svld1_u32(pg, cond1_ptr), 1);\n\n        uint32_t* cond2_ptr = (uint32_t*)&cond2[i];\n        svbool_t svcond2_loaded = svcmpeq(pg, svld1_u32(pg, cond2_ptr), 1);\n\n        svbool_t cond_and = svand(pg, svcond1_loaded, svcond2_loaded);\n        svbool_t cond_not_and = svandnot(pg, svcond1_loaded, svcond2_loaded);\n        svbool_t not_cond_and = svandnot(pg, svcond2_loaded, svcond1_loaded);\n        svbool_t not_cond_not_and = svandnot(pg, svcond1_loaded, svnot(pg, svcond2_loaded));\n\n        svfloat32_t result = svsel_f32(cond_and, sva, \n                        svsel_f32(cond_not_and, svb,\n                        svsel_f32(not_cond_and, svc, svd)));\n\n        svst1(pg, &out[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        size_t num = total_elements - i;\n        size_t current_vl = (num > vl) ? vl : num;\n\n        svbool_t pg_current = svwhilelt_b32(i, i + current_vl);\n\n        svfloat32_t sva = svld1(pg_current, &A[i]);\n        svfloat32_t svb = svld1(pg_current, &B[i]);\n        svfloat32_t svc = svld1(pg_current, &C[i]);\n        svfloat32_t svd = svld1(pg_current, &D[i]);\n\n        svbool_t cond1_vec = svcmpeq(pg_current, svindex_s32(i, 1), svindex_s32(i, 1));\n        uint8_t* cond1_ptr = (uint8_t*)&cond1[i];\n        uint8_t* cond2_ptr = (uint8_t*)&cond2[i];\n        svbool_t cond1_true = svcmpeq(pg_current, *(svuint8_t*)cond1_ptr, 1);\n        svbool_t cond2_true = svcmpeq(pg_current, *(svuint8_t*)cond2_ptr, 1);\n\n        svbool_t both_true = svand_b32(cond1_true, cond2_true);\n        svbool_t cond1_true_cond2_false = svand_b32(cond1_true, svnot_b32(cond2_true));\n        svbool_t cond1_false_cond2_true = svand_b32(svnot_b32(cond1_true), cond2_true);\n        svbool_t both_false = svand_b32(svnot_b32(cond1_true), svnot_b32(cond2_true));\n\n        svfloat32_t result = svsel_f32(both_true, sva,\n            svsel_f32(cond1_true_cond2_false, svb,\n                svsel_f32(cond1_false_cond2_true, svc, svd)));\n\n        svst1(pg_current, &out[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        size_t num = total_elements - i;\n        size_t current_vl = (num > vl) ? vl : num;\n\n        svbool_t pg_current = svwhilelt_b32(i, i + current_vl);\n\n        svfloat32_t vec_A = svld1(pg_current, &A[i]);\n        svfloat32_t vec_B = svld1(pg_current, &B[i]);\n        svfloat32_t vec_C = svld1(pg_current, &C[i]);\n        svfloat32_t vec_D = svld1(pg_current, &D[i]);\n\n        svbool_t vec_cond1 = svcmpeq(pg_current, *(svint32_t *)(&cond1[i]), 1);\n        svbool_t vec_cond2 = svcmpeq(pg_current, *(svint32_t *)(&cond2[i]), 1);\n\n        svbool_t cond1_and_cond2 = svand_b32(pg_current, vec_cond1, vec_cond2);\n        svbool_t cond1_not_cond2 = svand_b32(pg_current, vec_cond1, svnot_b32(pg_current, vec_cond2));\n        svbool_t not_cond1_cond2 = svand_b32(pg_current, svnot_b32(pg_current, vec_cond1), vec_cond2);\n        svbool_t not_cond1_not_cond2 = svand_b32(pg_current, svnot_b32(pg_current, vec_cond1), svnot_b32(pg_current, vec_cond2));\n\n        svfloat32_t result = svsel_f32(cond1_and_cond2, vec_A,\n                     svsel_f32(cond1_not_cond2, vec_B,\n                     svsel_f32(not_cond1_cond2, vec_C, vec_D)));\n\n        svst1(pg_current, &out[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t index = 0;\n\n    svbool_t pg = svptrue_b32();\n    svfloat32_t zero = svdup_f32(0.0f);\n\n    while (index <= total_elements - sve_vl()) {\n        svfloat32_t vec_A = svld1(pg, &A[index]);\n        svfloat32_t vec_B = svld1(pg, &B[index]);\n        svfloat32_t vec_C = svld1(pg, &C[index]);\n        svfloat32_t vec_D = svld1(pg, &D[index]);\n\n        svbool_t cond1_vec = svcmpeq(pg, svld1_b8(pg, (uint8_t*)&cond1[index]), 1);\n        svbool_t cond2_vec = svcmpeq(pg, svld1_b8(pg, (uint8_t*)&cond2[index]), 1);\n\n        svbool_t both_true = svand_b32(cond1_vec, cond2_vec);\n        svbool_t cond1_true_cond2_false = svand_b32(cond1_vec, svnot_b32(cond2_vec));\n        svbool_t cond1_false_cond2_true = svand_b32(svnot_b32(cond1_vec), cond2_vec);\n        svbool_t both_false = svand_b32(svnot_b32(cond1_vec), svnot_b32(cond2_vec));\n\n        svfloat32_t result = svsel_f32(both_true, vec_A,\n                     svsel_f32(cond1_true_cond2_false, vec_B,\n                     svsel_f32(cond1_false_cond2_true, vec_C, vec_D)));\n\n        svst1(pg, &out[index], result);\n        index += sve_vl();\n    }\n\n    for (; index < total_elements; ++index) {\n        if (cond1[index] && cond2[index]) {\n            out[index] = A[index];\n        } else if (cond1[index] && !cond2[index]) {\n            out[index] = B[index];\n        } else if (!cond1[index] && cond2[index]) {\n            out[index] = C[index];\n        } else {\n            out[index] = D[index];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < total_size; i += vl) {\n        size_t n = total_size - i;\n        size_t active = (n > vl) ? vl : n;\n\n        svbool_t pactive = svwhilelt_b32(i, i + active);\n\n        svfloat32_t sA = svld1(pactive, &A[i]);\n        svfloat32_t sB = svld1(pactive, &B[i]);\n        svfloat32_t sC = svld1(pactive, &C[i]);\n        svfloat32_t sD = svld1(pactive, &D[i]);\n\n        svbool_t scond1 = svcmpeq(pg, svdup_n_u8((uint8_t)1), svreinterpret_u8_b32(svld1(pactive, reinterpret_cast<const uint32_t*>(&cond1[i]))));\n        svbool_t scond2 = svcmpeq(pg, svdup_n_u8((uint8_t)1), svreinterpret_u8_b32(svld1(pactive, reinterpret_cast<const uint32_t*>(&cond2[i]))));\n\n        svbool_t both_true = svand_b32(scond1, scond2);\n        svbool_t cond1_true_cond2_false = svand_b32(scond1, svnot_b32(scond2));\n        svbool_t cond1_false_cond2_true = svand_b32(svnot_b32(scond1), scond2);\n\n        svfloat32_t result = svsel(both_true, sA, \n            svsel(cond1_true_cond2_false, sB,\n                svsel(cond1_false_cond2_true, sC, sD)));\n\n        svst1(pactive, &out[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    svbool_t pg = svptrue_b32();\n    size_t vec_len = svcntw(); // Number of 32-bit elements in a vector\n    \n    for (size_t i = 0; i <= total_size - vec_len; i += vec_len) {\n        svuint32_t vec = svld1_u32(pg, A + i);\n        svuint32_t cnt = svclz_u32(pg, vec); // Count leading zeros\n        cnt = sveor_u32(pg, cnt, svctz_u32(pg, vec)); // Combine with count trailing zeros\n        cnt = svsub_u32(pg, svdup_n_u32(31), cnt); // Subtract from 31 to get bit count\n        svst1_u8(pg, out + i, svreinterpret_u8_u32(cnt)); // Store as 8-bit values\n    }\n\n    // Handle remaining elements if total_size is not a multiple of vec_len\n    size_t remainder = total_size % vec_len;\n    if (remainder > 0) {\n        size_t i = total_size - remainder;\n        svbool_t pg_remainder = svptrue_b32((svcntw() / vec_len) * remainder);\n        svuint32_t vec = svld1_u32(pg_remainder, A + i);\n        svuint32_t cnt = svclz_u32(pg_remainder, vec);\n        cnt = sveor_u32(pg_remainder, cnt, svctz_u32(pg_remainder, vec));\n        cnt = svsub_u32(pg_remainder, svdup_n_u32(31), cnt);\n        svst1_u8(pg_remainder, out + i, svreinterpret_u8_u32(cnt));\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < total_size; i += vl) {\n        size_t n = total_size - i;\n        svbool_t pred = svwhilelt_b32(i, total_size);\n        svuint32_t vec_A = svld1_u32(pred, &A[i]);\n        svuint8_t result = svcntp_b_u8(pred, vec_A);\n        svst1_u8(pred, &out[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    svbool_t pg = svptrue_b32();\n    size_t vec_len = svcntw();\n\n    for (size_t i = 0; i < total_elements; i += vec_len) {\n        size_t n = svcntw();\n        if (i + n > total_elements) {\n            n = total_elements - i;\n            pg = svwhilelt_b32(i, total_elements);\n        }\n\n        svuint32_t vec_A = svld1(pg, A + i);\n        svuint8_t bit_counts = svcntp_b8(pg, vec_A);\n\n        svst1(pg, out + i, bit_counts);\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vl = svcntw();\n    for (size_t i = 0; i < total_size; i += vl) {\n        size_t count = total_size - i;\n        if (count < vl) {\n            svbool_t pg = svptrue_b32();\n            pg = svwhilelt_b32(i, (uint32_t)total_size);\n            svuint32_t vec_A = svld1(pg, &A[i]);\n            svuint8_t vec_popcnt = svmov_b8(svclz_x_u32(pg, vec_A));\n            svst1_b8(pg, &out[i], vec_popcnt);\n        } else {\n            svuint32_t vec_A = svld1_s32(&A[i]);\n            svuint8_t vec_popcnt = svcntp_b8(vec_A);\n            svst1_s8(&out[i], vec_popcnt);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vl = svcntw(); // Vector length in 32-bit elements\n\n    for (size_t i = 0; i < total_size; i += vl) {\n        size_t n = total_size - i;\n        svbool_t pg = svwhilelt_b32(i, total_size);\n        \n        // Load data from A into a vector\n        svuint32_t vec_A = svld1(pg, &A[i]);\n        \n        // Count the number of bits set to 1\n        svuint8_t bit_counts = svmovl_b8(svcntb_z(pg, vec_A));\n        \n        // Store the result into out\n        svst1_b8(pg, &out[i], bit_counts);\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    svbool_t pg = svptrue_b32();\n    svint32_t zero = svdup_n_s32(0);\n\n    while (i + svcntw() <= total_elements) {\n        svint32_t vec_a = svld1(pg, &A[i]);\n        svint32_t abs_vec_a = svasg_s32(pg, vec_a, zero);\n        \n        svint32_t rem = svmoda_s32(pg, vec_a, svdup_n_s32(3));\n        svbool_t cond = svcmpeq(pg, rem, zero);\n\n        svst1(cond, &B[i], abs_vec_a);\n        svsel_sv(pg, cond, svst1, pg, &B[i], vec_a);\n\n        i += svcntw();\n    }\n\n    // Handle remaining elements\n    for (; i < total_elements; ++i) {\n        if (A[i] % 3 == 0) {\n            B[i] = abs(A[i]);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t n = rows * cols;\n    svbool_t pg = svptrue_b32();\n    size_t index = 0;\n\n    // Process elements in vectorized batches\n    while (index + svcntw() <= n) {\n        svint32_t vec_A = svld1(pg, &A[index]);\n        svint32_t zero = svdup_s32(0);\n        svuint32_t abs_vec_A = svasr_u32(svabs_z(pg, vec_A), svcntw() - 1);\n\n        // Check divisibility by 3\n        svint32_t rem = svsmod(pg, vec_A, svdup_n_s32(3));\n        svbool_t cond = svcmpeq(pg, rem, zero);\n\n        // Conditional move\n        svint32_t result = svsel(cond, svabs_z(pg, vec_A), vec_A);\n\n        // Store the result\n        svst1(pg, &B[index], result);\n\n        index += svcntw();\n    }\n\n    // Handle remaining scalar elements\n    for (; index < n; index++) {\n        if (A[index] % 3 == 0) {\n            B[index] = abs(A[index]);\n        } else {\n            B[index] = A[index];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    svbool_t pg = svptrue_b32();\n    svbool_t cond;\n\n    for (size_t i = 0; i < total_elements; i += svcntw()) {\n        size_t vl = svcntw();\n        svint32_t vec_a = svld1(pg, &A[i]);\n        svint32_t zero = svdup_n_s32(0);\n        svuint32_t three = svdup_n_u32(3);\n\n        // Compute remainder when divided by 3\n        svint32_t rem = svsmod(pg, vec_a, three);\n\n        // Check if remainder is zero (divisible by 3)\n        cond = svcmpeq(pg, rem, zero);\n\n        // Compute absolute value of vec_a\n        svint32_t abs_val = svabs(pg, vec_a);\n\n        // Select between abs_val and vec_a based on condition\n        svint32_t result = svsel(cond, abs_val, vec_a);\n\n        // Store the result into B\n        svst1(pg, &B[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        size_t k = total_elements - i;\n        if (k < vl) {\n            pg = svwhilelt_b32((svint32_t){k}, (svint32_t){0});\n        } else {\n            pg = svptrue_b32();\n        }\n\n        svint32_t vec_a = svld1(pg, &A[i]);\n        svint32_t mod_result = svmul_x(pg, vec_a, svindex_s32(0, 1));\n        svbool_t cond = svceq(pg, svmul_x(pg, mod_result, svdup_n_s32(3)), svdup_n_s32(0));\n\n        svint32_t abs_vec_a = svasr_x(pg, vec_a, svdup_n_u32(31));\n        abs_vec_a = svand_x(pg, abs_vec_a, svdup_n_u32(0x7FFFFFFF));\n\n        svint32_t result = svsel(cond, abs_vec_a, vec_a);\n        svst1(pg, &B[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t n = rows * cols;\n    svbool_t pg = svptrue_b32();\n    for (size_t i = 0; i < n; i += svcntw()) {\n        size_t k = n - i;\n        if (k < svcntw()) {\n            pg = svwhilelt_b32(i, n);\n        }\n        svint32_t vec_a = svld1(pg, A + i);\n        svint32_t zero = svdup_s32(0);\n        svuint32_t abs_vec_a = svabs(vec_a);\n        svint32_t rem = svsrh(vec_a, svdup_n_s32(3));\n        svbool_t cond = svceq(rem, zero);\n        svst1(pg, B + i, svsel(cond, abs_vec_a, vec_a));\n    }\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    while (i + svcntw() <= length) {\n        svuint32_t s = svld1(pg, &src[i]);\n        svuint32_t mask = svand_x(pg, s, svdup_n_u32(0xF));\n        svuint32_t cmp = svmovemask_b32(pg, svcmpeq(pg, mask, svdup_n_u32(0xF)));\n        svuint32_t rotated = svror_n_x(pg, s, rotate_bits);\n        svuint32_t negated = svnot_x(pg, s);\n        svuint32_t result = svsel(cmp, rotated, negated);\n        svst1(pg, &dst[i], result);\n        i += svcntw();\n    }\n    // Handle leftover elements if any\n    if (i < length) {\n        svbool_t pg_part = svwhilelt_b32(i, length);\n        svuint32_t s = svld1(pg_part, &src[i]);\n        svuint32_t mask = svand_x(pg_part, s, svdup_n_u32(0xF));\n        svuint32_t cmp = svmovemask_b32(pg_part, svcmpeq(pg_part, mask, svdup_n_u32(0xF)));\n        svuint32_t rotated = svror_n_x(pg_part, s, rotate_bits);\n        svuint32_t negated = svnot_x(pg_part, s);\n        svuint32_t result = svsel(cmp, rotated, negated);\n        svst1(pg_part, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    while (i + svcntw() <= length) {\n        svuint32_t s = svld1(pg, &src[i]);\n        svuint32_t mask = svand_x(pg, s, svdup_n_u32(0xF));\n        svuint32_t cmp_result = svmovemask_b32(svcmpeq(pg, mask, svdup_n_u32(0xF)));\n        svuint32_t rotated = svror_x(pg, s, svdup_n_u32(rotate_bits));\n        svuint32_t negated = svnot_x(pg, s);\n        svuint32_t result = svsel(cmp_result, rotated, negated);\n        svst1(pg, &dst[i], result);\n        i += svcntw();\n    }\n    // Handle remaining elements if length is not a multiple of svcntw()\n    if (i < length) {\n        pg = svwhilelt_b32(i, length);\n        svuint32_t s = svld1(pg, &src[i]);\n        svuint32_t mask = svand_x(pg, s, svdup_n_u32(0xF));\n        svuint32_t cmp_result = svmovemask_b32(svcmpeq(pg, mask, svdup_n_u32(0xF)));\n        svuint32_t rotated = svror_x(pg, s, svdup_n_u32(rotate_bits));\n        svuint32_t negated = svnot_x(pg, s);\n        svuint32_t result = svsel(cmp_result, rotated, negated);\n        svst1(pg, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    size_t index = 0;\n    while (index < length) {\n        svbool_t pg = svptrue_b32();\n        svuint32_t vec_src = svld1(pg, &src[index]);\n        \n        // Check if the low 4 bits of each element are all 1s (0xF)\n        svuint32_t mask = svdup_n_u32(0xF);\n        svuint32_t low_bits = svand_u32(pg, vec_src, mask);\n        svbool_t condition = svcmpeq(pg, low_bits, mask);\n\n        // Rotate right by rotate_bits for elements meeting the condition\n        svuint32_t rotated = svrshr_u32(condition, vec_src, rotate_bits);\n\n        // Negate the elements not meeting the condition\n        svuint32_t negated = svneg_x_u32(svpnot_b32(condition), vec_src);\n\n        // Combine results based on the condition\n        svuint32_t result = svsel_u32(condition, rotated, negated);\n\n        // Store the result into the destination array\n        svst1(pg, &dst[index], result);\n\n        // Increment the index by the vector length\n        index += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    const uint32_t mask = 0xF;\n\n    while (i < length) {\n        svuint32_t s = svld1(pg, &src[i]);\n        svuint32_t low_bits = svand_z(pg, s, mask);\n        svbool_t cond = svcmpeq_m(pg, low_bits, mask);\n\n        svuint32_t rotated = svror_z(pg, s, rotate_bits);\n        svuint32_t negated = svnot_z(pg, s);\n\n        svuint32_t result = svsel(cond, rotated, negated);\n        svst1(pg, &dst[i], result);\n\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    svbool_t pg = svptrue_b32();\n    size_t vec_len = svcntw();\n    size_t i = 0;\n\n    for (; i <= length - vec_len; i += vec_len) {\n        svuint32_t s = svld1(pg, &src[i]);\n        svuint32_t mask = svand_x(pg, s, svdup_n_u32(0xF));\n        svbool_t cond = svcmpeq(pg, mask, svdup_n_u32(0xF));\n\n        svuint32_t rotated = svror_x(cond, s, rotate_bits);\n        svuint32_t negated = svnot_x(svnot_b32(cond), s);\n\n        svuint32_t result = svsel(cond, rotated, negated);\n        svst1(pg, &dst[i], result);\n    }\n\n    // Handle leftover elements\n    if (i < length) {\n        svbool_t pg_part = svwhilelt_b32(i, length);\n        svuint32_t s = svld1(pg_part, &src[i]);\n        svuint32_t mask = svand_x(pg_part, s, svdup_n_u32(0xF));\n        svbool_t cond = svcmpeq(pg_part, mask, svdup_n_u32(0xF));\n\n        svuint32_t rotated = svror_x(cond, s, rotate_bits);\n        svuint32_t negated = svnot_x(svnot_b32(cond), s);\n\n        svuint32_t result = svsel(cond, rotated, negated);\n        svst1(pg_part, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    svbool_t pg = svptrue_b32();\n    size_t index = 0;\n\n    while (index <= length - svcntw()) {\n        svfloat32_t sva = svld1_f32(pg, &A[index]);\n        svfloat32_t svb = svld1_f32(pg, &B[index]);\n        svfloat32_t diff = svsub_f32(pg, sva, svb);\n        svfloat32_t abs_epsilon = svasfabs_f32(pg, svdup_f32(epsilon));\n        svfloat32_t abs_diff = svasfabs_f32(pg, diff);\n\n        svbool_t gt = svcmpgt_f32(pg, diff, abs_epsilon);\n        svbool_t lt = svcmplt_f32(pg, diff, svneg_f32(pg, abs_epsilon));\n        svbool_t eq = svcmpeq_f32(pg, abs_diff, svdup_f32(0.0f));\n\n        svint8_t res_gt = svreinterpret_s8_z(pg, svdup_n_s32(1));\n        svint8_t res_lt = svreinterpret_s8_z(pg, svdup_n_s32(-1));\n        svint8_t res_eq = svreinterpret_s8_z(pg, svdup_n_s32(0));\n\n        svint8_t result = svsel_s8(gt, res_gt, res_lt);\n        result = svsel_s8(eq, res_eq, result);\n\n        svst1_u8(pg, &out[index], svreinterpret_u8(result));\n\n        index += svcntw();\n    }\n\n    for (; index < length; ++index) {\n        float diff = A[index] - B[index];\n        if (diff > fabsf(epsilon)) {\n            out[index] = 1;\n        } else if (diff < -fabsf(epsilon)) {\n            out[index] = -1;\n        } else {\n            out[index] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    svbool_t pg = svptrue_b32();\n    size_t i = 0;\n\n    for (; i <= length - svcntw(); i += svcntw()) {\n        svfloat32_t va = svld1(pg, &A[i]);\n        svfloat32_t vb = svld1(pg, &B[i]);\n        svfloat32_t vdif = svsub_x(pg, va, vb);\n        \n        svfloat32_t vabs_epsilon = svasqabs_x(pg, svdup_n_f32(epsilon));\n        svfloat32_t vabs_dif = svasqabs_x(pg, vdif);\n\n        svbool_t gt_eps = svcmpgt(pg, vabs_dif, vabs_epsilon);\n        svbool_t pos_diff = svcmpgt(pg, vdif, svdup_n_f32(0.0f));\n        svbool_t neg_diff = svcmplt(pg, vdif, svdup_n_f32(0.0f));\n\n        svint8_t res_zero = svdup_n_s8(0);\n        svint8_t res_one = svdup_n_s8(1);\n        svint8_t res_neg_one = svdup_n_s8(-1);\n\n        svint8_t result = svsel(gt_eps, svsel(pos_diff, res_one, res_neg_one), res_zero);\n\n        svst1(pg, &out[i], (svint8_t)result);\n    }\n\n    for (; i < length; ++i) {\n        float dif = A[i] - B[i];\n        if (dif > fabsf(epsilon)) {\n            out[i] = 1;\n        } else if (dif < -fabsf(epsilon)) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    svbool_t pg = svptrue_b32();\n    svfloat32_t svepsilon = svdup_n_f32(fabsf(epsilon));\n\n    size_t i = 0;\n    for (; i <= length - svcntw(); i += svcntw()) {\n        svfloat32_t va = svld1(pg, &A[i]);\n        svfloat32_t vb = svld1(pg, &B[i]);\n\n        svfloat32_t diff = svsub(pg, va, vb);\n        svfloat32_t abs_diff = svabs(pg, diff);\n\n        svbool_t gt_epsilon = svcmpgt(pg, diff, svepsilon);\n        svbool_t lt_neg_epsilon = svcmplt(pg, diff, svneg(pg, svepsilon));\n        svbool_t within_epsilon = svcmpeq(pg, svfcvtzs(pg, abs_diff), svdup_n_s32(0));\n\n        svint8_t res_gt = svreinterpret_s8_z(pg, svdup_n_u32(1));\n        svint8_t res_lt = svreinterpret_s8_z(pg, svdup_n_u32(-1));\n        svint8_t res_eq = svreinterpret_s8_z(pg, svdup_n_u32(0));\n\n        svint8_t result = svsel_b8(gt_epsilon, res_gt, \n                     svsel_b8(lt_neg_epsilon, res_lt, res_eq));\n\n        svst1(pg, &out[i], result);\n    }\n\n    // Handle remaining elements with scalar code\n    for (; i < length; i++) {\n        float diff = A[i] - B[i];\n        if (diff > fabsf(epsilon)) {\n            out[i] = 1;\n        } else if (diff < -fabsf(epsilon)) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    svbool_t pg = svptrue_b32();\n    size_t vec_len = svcntw();\n    size_t i = 0;\n\n    float abs_epsilon = fabsf(epsilon);\n    svfloat32_t sve_abs_epsilon = svdup_n_f32(abs_epsilon);\n\n    for (; i <= length - vec_len; i += vec_len) {\n        svfloat32_t va = svld1(pg, &A[i]);\n        svfloat32_t vb = svld1(pg, &B[i]);\n\n        svfloat32_t diff = svsub(pg, va, vb);\n        svfloat32_t abs_diff = svabs(pg, diff);\n\n        svbool_t gt_eps = svcmpgt_f32(pg, diff, sve_abs_epsilon);\n        svbool_t lt_neg_eps = svcmplt_f32(pg, diff, svneg_f32(pg, sve_abs_epsilon));\n        svbool_t within_eps = svcmpeq_f32_m(pg, abs_diff, sve_abs_epsilon, svfalse());\n\n        svint8_t res_gt = svdup_n_s8(1);\n        svint8_t res_lt = svdup_n_s8(-1);\n        svint8_t res_eq = svdup_n_s8(0);\n\n        svint8_t result = svsel_s8(gt_eps, res_gt, res_eq);\n        result = svsel_s8(lt_neg_eps, res_lt, result);\n\n        svst1(pg, &out[i], result);\n    }\n\n    // Handle leftover elements\n    for (; i < length; i++) {\n        float diff = A[i] - B[i];\n        if (diff > abs_epsilon) {\n            out[i] = 1;\n        } else if (diff < -abs_epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    svbool_t pg = svptrue_b32();\n    size_t vec_len = svcntw();\n    size_t i = 0;\n\n    for (; i <= length - vec_len; i += vec_len) {\n        svfloat32_t sva = svld1_f32(pg, &A[i]);\n        svfloat32_t svb = svld1_f32(pg, &B[i]);\n\n        svfloat32_t diff = svsub_f32(pg, sva, svb);\n        svfloat32_t abs_diff = svabs_f32(pg, diff);\n        svfloat32_t abs_epsilon = svdup_n_f32(fabsf(epsilon));\n\n        svbool_t gt = svcmpgt_f32(pg, diff, abs_epsilon);\n        svbool_t lt = svcmplt_f32(pg, diff, svneg_f32(pg, abs_epsilon));\n        svbool_t eq = svcmpeq_f32(pg, abs_diff, abs_epsilon);\n\n        svint8_t one = svdup_n_s8(1);\n        svint8_t minus_one = svdup_n_s8(-1);\n        svint8_t zero = svdup_n_s8(0);\n\n        svint8_t res = svsel_s8(gt, one, svsel_s8(lt, minus_one, zero));\n\n        svst1_s8(pg, &out[i], res);\n    }\n\n    // Handle remaining elements\n    if (i < length) {\n        svbool_t pg_remainder = svwhilelt_b32(i, length);\n        size_t vec_len_remainder = svcntw();\n\n        svfloat32_t sva = svld1_f32(pg_remainder, &A[i]);\n        svfloat32_t svb = svld1_f32(pg_remainder, &B[i]);\n\n        svfloat32_t diff = svsub_f32(pg_remainder, sva, svb);\n        svfloat32_t abs_diff = svabs_f32(pg_remainder, diff);\n        svfloat32_t abs_epsilon = svdup_n_f32(fabsf(epsilon));\n\n        svbool_t gt = svcmpgt_f32(pg_remainder, diff, abs_epsilon);\n        svbool_t lt = svcmplt_f32(pg_remainder, diff, svneg_f32(pg_remainder, abs_epsilon));\n        svbool_t eq = svcmpeq_f32(pg_remainder, abs_diff, abs_epsilon);\n\n        svint8_t one = svdup_n_s8(1);\n        svint8_t minus_one = svdup_n_s8(-1);\n        svint8_t zero = svdup_n_s8(0);\n\n        svint8_t res = svsel_s8(gt, one, svsel_s8(lt, minus_one, zero));\n\n        svst1_s8(pg_remainder, &out[i], res);\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    const svfloat32_t v_maxf = svdup_f32(pg, (float)INT32_MAX);\n    const svfloat32_t v_minf = svdup_f32(pg, (float)INT32_MIN);\n\n    while (i + svcntw() <= size) {\n        svfloat32_t v_a = svld1_f32(pg, &A[i]);\n        svint32_t v_result = svfcvt_x_s32_f32(pg, svmin_f32(pg, svmax_f32(pg, v_a, v_minf), v_maxf));\n        svst1_i32(pg, &B[i], v_result);\n        i += svcntw();\n    }\n\n    if (i < size) {\n        pg = svwhilelt_b32(i, (int)size);\n        svfloat32_t v_a = svld1_f32(pg, &A[i]);\n        svint32_t v_result = svfcvt_x_s32_f32(pg, svmin_f32(pg, svmax_f32(pg, v_a, v_minf), v_maxf));\n        svst1_i32(pg, &B[i], v_result);\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    const svfloat32_t v_max_f = svdup_n_f32((float)INT32_MAX);\n    const svfloat32_t v_min_f = svdup_n_f32((float)INT32_MIN);\n\n    while (i + svcntw() <= size) {\n        svfloat32_t vec_a = svld1(pg, &A[i]);\n        svint32_t vec_result;\n\n        // Clamp the values between INT32_MIN and INT32_MAX\n        vec_a = svmin(pg, vec_a, v_max_f);\n        vec_a = svmax(pg, vec_a, v_min_f);\n\n        // Convert to int32_t\n        vec_result = svcvt_x_f32(pg, vec_a);\n\n        // Store the result\n        svst1(pg, &B[i], vec_result);\n\n        i += svcntw();\n    }\n\n    // Handle leftover elements if size is not a multiple of svcntw()\n    if (i < size) {\n        pg = svwhilelt_b32(i, size);\n        svfloat32_t vec_a = svld1(pg, &A[i]);\n        svint32_t vec_result;\n\n        // Clamp the values between INT32_MIN and INT32_MAX\n        vec_a = svmin(pg, vec_a, v_max_f);\n        vec_a = svmax(pg, vec_a, v_min_f);\n\n        // Convert to int32_t\n        vec_result = svcvt_x_f32(pg, vec_a);\n\n        // Store the result\n        svst1(pg, &B[i], vec_result);\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    const svfloat32_t v_max_f = svdup_f32(INT32_MAX);\n    const svfloat32_t v_min_f = svdup_f32(INT32_MIN);\n\n    while (i + svcntw() <= size) {\n        svfloat32_t v_a = svld1(pg, &A[i]);\n        svint32_t v_clamped = svfcvt_x_s32_f32(pg, svmin_v(svmax_v(v_a, v_min_f), v_max_f));\n        svst1(pg, &B[i], v_clamped);\n        i += svcntw();\n    }\n\n    if (i < size) {\n        pg = svwhilelt_b32(i, size);\n        svfloat32_t v_a = svld1(pg, &A[i]);\n        svint32_t v_clamped = svfcvt_x_s32_f32(pg, svmin_v(svmax_v(v_a, v_min_f), v_max_f));\n        svst1(pg, &B[i], v_clamped);\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    const int32_t INT32_MIN_VAL = SV_INT32_MIN;\n    const int32_t INT32_MAX_VAL = SV_INT32_MAX;\n\n    while (i + svcntw() <= size) {\n        svfloat32_t vec_a = svld1_f32(pg, &A[i]);\n        svint32_t vec_b = svfcvt_x_s32_f32(pg, vec_a);\n        svint32_t vec_min = svdup_n_s32(INT32_MIN_VAL);\n        svint32_t vec_max = svdup_n_s32(INT32_MAX_VAL);\n        vec_b = svmin_s32(pg, vec_b, vec_max);\n        vec_b = svmax_s32(pg, vec_b, vec_min);\n        svst1_s32(pg, &B[i], vec_b);\n        i += svcntw();\n    }\n\n    if (i < size) {\n        pg = svwhilelt_b32(i, size);\n        svfloat32_t vec_a = svld1_f32(pg, &A[i]);\n        svint32_t vec_b = svfcvt_x_s32_f32(pg, vec_a);\n        svint32_t vec_min = svdup_n_s32(INT32_MIN_VAL);\n        svint32_t vec_max = svdup_n_s32(INT32_MAX_VAL);\n        vec_b = svmin_s32(pg, vec_b, vec_max);\n        vec_b = svmax_s32(pg, vec_b, vec_min);\n        svst1_s32(pg, &B[i], vec_b);\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    const svfloat32_t v_maxf = svdup_f32(pg, (float)INT32_MAX);\n    const svfloat32_t v_minf = svdup_f32(pg, (float)INT32_MIN);\n\n    while (i + svcntw() <= size) {\n        svfloat32_t vec_a = svld1_f32(pg, &A[i]);\n        svint32_t vec_result;\n\n        vec_result = svfcvt_x_s32_f32(pg, svmin_f32(pg, svmax_f32(pg, vec_a, v_minf), v_maxf));\n        \n        svst1_s32(pg, &B[i], vec_result);\n        i += svcntw();\n    }\n\n    // Handle leftover elements\n    if (i < size) {\n        pg = svwhilelt_b32(i, size);\n        svfloat32_t vec_a = svld1_f32(pg, &A[i]);\n        svint32_t vec_result;\n\n        vec_result = svfcvt_x_s32_f32(pg, svmin_f32(pg, svmax_f32(pg, vec_a, v_minf), v_maxf));\n        \n        svst1_s32(pg, &B[i], vec_result);\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n    size_t i = 0;\n\n    for (; i <= size - vl; i += vl) {\n        svint32_t vec_a = svld1(pg, &A[i]);\n        svfloat32_t vec_f = svcvt_f32_s32_x(pg, vec_a);\n        svfloat32_t scaled_vec_f = svmul_x_n_f32(pg, vec_f, (float)scale);\n        svst1(pg, &B[i], scaled_vec_f);\n    }\n\n    if (i < size) {\n        svbool_t pg_tail = svwhilelt_b32(i, (svint32_t){size});\n        svint32_t vec_a = svld1(pg_tail, &A[i]);\n        svfloat32_t vec_f = svcvt_f32_s32_x(pg_tail, vec_a);\n        svfloat32_t scaled_vec_f = svmul_x_n_f32(pg_tail, vec_f, (float)scale);\n        svst1(pg_tail, &B[i], scaled_vec_f);\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    svbool_t pg = svptrue_b32();\n    size_t vec_len = svcntw() / sizeof(int32_t);\n    size_t i = 0;\n\n    for (; i <= size - vec_len; i += vec_len) {\n        svint32_t vec_a = svld1(pg, &A[i]);\n        svfloat32_t vec_f = svcvt_f32_s32_x(pg, vec_a);\n        svfloat32_t scaled_vec_f = svmul_x_n_f32(pg, vec_f, (float)scale);\n        svst1(pg, &B[i], scaled_vec_f);\n    }\n\n    // Handle leftover elements\n    if (i < size) {\n        svbool_t pg_part = svwhilelt_b32(i, size);\n        svint32_t vec_a = svld1(pg_part, &A[i]);\n        svfloat32_t vec_f = svcvt_f32_s32_x(pg_part, vec_a);\n        svfloat32_t scaled_vec_f = svmul_x_n_f32(pg_part, vec_f, (float)scale);\n        svst1(pg_part, &B[i], scaled_vec_f);\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    svbool_t pg = svptrue_b32();\n    size_t vec_len = svcntw() / sizeof(int32_t);\n    size_t i = 0;\n\n    for (; i <= size - vec_len; i += vec_len) {\n        svint32_t vec_a = svld1(pg, &A[i]);\n        svfloat32_t vec_f = svcvt_f32_s32_x(pg, vec_a);\n        float scale_f = (float)scale;\n        svfloat32_t scaled_vec = svmul_x_f32(pg, vec_f, svdup_f32(scale_f));\n        svst1(pg, &B[i], scaled_vec);\n    }\n\n    // Handle leftover elements\n    if (i < size) {\n        svbool_t pg_partial = svwhilelt_b32(i, size);\n        svint32_t vec_a = svld1(pg_partial, &A[i]);\n        svfloat32_t vec_f = svcvt_f32_s32_x(pg_partial, vec_a);\n        float scale_f = (float)scale;\n        svfloat32_t scaled_vec = svmul_x_f32(pg_partial, vec_f, svdup_f32(scale_f));\n        svst1(pg_partial, &B[i], scaled_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    svint32_t v_scale = svdup_n_s32(scale);\n\n    while (i + svcntw() <= size) {\n        svint32_t v_a = svld1_s32(pg, &A[i]);\n        svfloat32_t v_f = svcvt_f32_s32_x(pg, svsmul_s32(pg, v_a, v_scale));\n        svst1_f32(pg, &B[i], v_f);\n        i += svcntw();\n    }\n\n    if (i < size) {\n        size_t left = size - i;\n        svbool_t pg_left = svwhilelt_b32(i, size);\n        svint32_t v_a = svld1_s32(pg_left, &A[i]);\n        svfloat32_t v_f = svcvt_f32_s32_x(pg_left, svsmul_s32(pg_left, v_a, v_scale));\n        svst1_f32(pg_left, &B[i], v_f);\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    svbool_t pg = svptrue_b32();\n    size_t vec_len = svcntw(); // Number of 32-bit elements in a vector\n    size_t i = 0;\n\n    for (; i <= size - vec_len; i += vec_len) {\n        svint32_t vec_a = svld1(pg, &A[i]);\n        svfloat32_t vec_f = svcvt_f32_s32_x(pg, vec_a);\n        svfloat32_t scaled_vec_f = svmla_x_f32(pg, vec_f, vec_f, (float)scale);\n        svst1(pg, &B[i], scaled_vec_f);\n    }\n\n    // Handle leftover elements\n    if (i < size) {\n        svbool_t pg_tail = svwhilelt_b32(i, size);\n        svint32_t vec_a = svld1(pg_tail, &A[i]);\n        svfloat32_t vec_f = svcvt_f32_s32_x(pg_tail, vec_a);\n        svfloat32_t scaled_vec_f = svmla_x_f32(pg_tail, vec_f, vec_f, (float)scale);\n        svst1(pg_tail, &B[i], scaled_vec_f);\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    svbool_t pg = svptrue_b32();\n    size_t vec_len = svcntw(); // Number of 32-bit elements in a vector\n    size_t i = 0;\n\n    for (; i <= size - vec_len; i += vec_len) {\n        svfloat32_t vec_A = svld1_f32(pg, &A[i]);\n        svfloat32_t vec_B = svld1_f32(pg, &B[i]);\n        svfloat32_t result_f = svdiv_f32(pg, vec_A, vec_B);\n        svint32_t result_i = svfcvt_rni_x_s32(pg, result_f);\n        svst1_s32(pg, &C[i], result_i);\n    }\n\n    // Handle leftover elements\n    if (i < size) {\n        svbool_t pg_partial = svwhilelt_b32(i, (int)size);\n        svfloat32_t vec_A = svld1_f32(pg_partial, &A[i]);\n        svfloat32_t vec_B = svld1_f32(pg_partial, &B[i]);\n        svfloat32_t result_f = svdiv_f32(pg_partial, vec_A, vec_B);\n        svint32_t result_i = svfcvt_rni_x_s32(pg_partial, result_f);\n        svst1_s32(pg_partial, &C[i], result_i);\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    svbool_t pg = svptrue_b32();\n    size_t vec_len = svcntw() / sizeof(float);\n    size_t i = 0;\n\n    for (; i <= size - vec_len; i += vec_len) {\n        svfloat32_t va = svld1_f32(pg, &A[i]);\n        svfloat32_t vb = svld1_f32(pg, &B[i]);\n        svint32_t vc = svfcvt_n_sfixu_xv_bf16(pg, svdiv_f32(pg, va, vb));\n        svst1_s32(pg, &C[i], vc);\n    }\n\n    if (i < size) {\n        svbool_t pg_tail = svwhilelt_b32(i, size);\n        svfloat32_t va = svld1_f32(pg_tail, &A[i]);\n        svfloat32_t vb = svld1_f32(pg_tail, &B[i]);\n        svint32_t vc = svfcvt_n_sfixu_xv_bf16(pg_tail, svdiv_f32(pg_tail, va, vb));\n        svst1_s32(pg_tail, &C[i], vc);\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    svfloat32_t zero = svdup_f32(pg, 0.0f);\n\n    while (i + svcntw() <= size) {\n        svfloat32_t va = svld1_f32(pg, &A[i]);\n        svfloat32_t vb = svld1_f32(pg, &B[i]);\n\n        // Perform division and handle division by zero\n        svfloat32_t result = svdiv_f32(pg, va, svsel_f32(pg, vb, zero, svcmpeq_f32(pg, vb, zero)));\n\n        // Round to nearest integer\n        svint32_t rounded = svfcvt_rni_x_s32_f32(pg, result);\n\n        // Store the result in the destination array\n        svst1_s32(pg, &C[i], rounded);\n\n        i += svcntw();\n    }\n\n    // Handle remaining elements if size is not a multiple of vector length\n    if (i < size) {\n        svbool_t pg_remainder = svwhilelt_b32(i, (int)size);\n        svfloat32_t va = svld1_f32(pg_remainder, &A[i]);\n        svfloat32_t vb = svld1_f32(pg_remainder, &B[i]);\n\n        svfloat32_t result = svdiv_f32(pg_remainder, va, svsel_f32(pg_remainder, vb, zero, svcmpeq_f32(pg_remainder, vb, zero)));\n\n        svint32_t rounded = svfcvt_rni_x_s32_f32(pg_remainder, result);\n\n        svst1_s32(pg_remainder, &C[i], rounded);\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    svfloat32_t zero = svdup_f32(0.0f);\n\n    while (i + svcntw() <= size) {\n        svfloat32_t va = svld1(pg, &A[i]);\n        svfloat32_t vb = svld1(pg, &B[i]);\n        svfloat32_t vres = svdiv_x(pg, va, vb);\n        svint32_t vrounded = svfcvt_n_sfv_x(pg, vres, SV_ROUND_NEAREST);\n        svst1(pg, &C[i], vrounded);\n        i += svcntw();\n    }\n\n    if (i < size) {\n        size_t left = size - i;\n        svbool_t pg_partial = svwhilelt_b32(i, size);\n        svfloat32_t va = svld1(pg_partial, &A[i]);\n        svfloat32_t vb = svld1(pg_partial, &B[i]);\n        svfloat32_t vres = svdiv_x(pg_partial, va, vb);\n        svint32_t vrounded = svfcvt_n_sfv_x(pg_partial, vres, SV_ROUND_NEAREST);\n        svst1(pg_partial, &C[i], vrounded);\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    while (i + svcntw() <= size) {\n        svfloat32_t vec_a = svld1_f32(pg, &A[i]);\n        svfloat32_t vec_b = svld1_f32(pg, &B[i]);\n        svint32_t vec_c = svfcvt_n_s_f32_x(pg, svdiv_f32(pg, vec_a, vec_b));\n        svst1_s32(pg, &C[i], vec_c);\n        i += svcntw();\n    }\n    if (i < size) {\n        svbool_t pg_tail = svwhilelt_b32(i, size);\n        svfloat32_t vec_a = svld1_f32(pg_tail, &A[i]);\n        svfloat32_t vec_b = svld1_f32(pg_tail, &B[i]);\n        svint32_t vec_c = svfcvt_n_s_f32_x(pg_tail, svdiv_f32(pg_tail, vec_a, vec_b));\n        svst1_s32(pg_tail, &C[i], vec_c);\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    svbool_t pg = svptrue_b64();\n    const float flt_max = FLT_MAX;\n    const float neg_flt_max = -FLT_MAX;\n\n    for (size_t i = 0; i < size; i += svcntd()) {\n        size_t vl = svszindex(i, size);\n        svbool_t pred = svwhilelt_b64(i, size);\n\n        // Load vector of doubles\n        svfloat64_t vec_dbl = svld1_f64(pred, &A[i]);\n\n        // Convert to float with saturation\n        svfloat32_t vec_flt = svfcvt_x_f64_f32(pred, vec_dbl);\n\n        // Compare and saturate to FLT_MAX\n        svbool_t gt_flt_max = svcmpgt_f64(pred, vec_dbl, svdup_f64(flt_max));\n        vec_flt = svsel_f32(gt_flt_max, svdup_f32(flt_max), vec_flt);\n\n        // Compare and saturate to -FLT_MAX\n        svbool_t lt_neg_flt_max = svcmplt_f64(pred, vec_dbl, svdup_f64(neg_flt_max));\n        vec_flt = svsel_f32(lt_neg_flt_max, svdup_f32(neg_flt_max), vec_flt);\n\n        // Store the results\n        svst1_f32(pred, &B[i], vec_flt);\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    svbool_t pg = svptrue_b64();\n    svfloat32_t max_f = svdup_n_f32(FLT_MAX);\n    svfloat32_t min_f = svdup_n_f32(-FLT_MAX);\n\n    size_t i = 0;\n    for (; i <= size - svcntd(); i += svcntd()) {\n        svfloat64_t vec_d = svld1_f64(pg, &A[i]);\n        svfloat32_t vec_f = svfcvt_f64_f32_x(pg, vec_d);\n\n        svbool_t overflows = svcmpgt_f32(pg, vec_f, max_f);\n        svbool_t underflows = svcmplt_f32(pg, vec_f, min_f);\n\n        vec_f = svsel_f32(overflows, max_f, vec_f);\n        vec_f = svsel_f32(underflows, min_f, vec_f);\n\n        svst1_f32(pg, &B[i], vec_f);\n    }\n\n    // Handle leftover elements\n    if (i < size) {\n        svbool_t pg_part = svwhilelt_b64(i, size);\n        svfloat64_t vec_d = svld1_f64(pg_part, &A[i]);\n        svfloat32_t vec_f = svfcvt_f64_f32_x(pg_part, vec_d);\n\n        svbool_t overflows = svcmpgt_f32(pg_part, vec_f, max_f);\n        svbool_t underflows = svcmplt_f32(pg_part, vec_f, min_f);\n\n        vec_f = svsel_f32(overflows, max_f, vec_f);\n        vec_f = svsel_f32(underflows, min_f, vec_f);\n\n        svst1_f32(pg_part, &B[i], vec_f);\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    svbool_t pg = svptrue_b64();\n    size_t vec_len = svcntd();\n    size_t i = 0;\n\n    const float flt_max = FLT_MAX;\n    svfloat32_t v_flt_max = svdup_n_f32(flt_max);\n    svfloat32_t v_flt_neg_max = svdup_n_f32(-flt_max);\n\n    for (; i <= size - vec_len; i += vec_len) {\n        svfloat64_t vec_a = svld1_f64(pg, &A[i]);\n        svfloat32_t vec_b = svfcvt_x_f64_f32(pg, vec_a);\n\n        svfloat32_t v_cmp_gt = svcmgt_f32(pg, vec_b, v_flt_max);\n        svfloat32_t v_cmp_lt = svcmplt_f32(pg, vec_b, v_flt_neg_max);\n\n        vec_b = svsel_f32(v_cmp_gt, v_flt_max, vec_b);\n        vec_b = svsel_f32(v_cmp_lt, v_flt_neg_max, vec_b);\n\n        svst1_f32(pg, &B[i], vec_b);\n    }\n\n    // Handle leftover elements\n    if (i < size) {\n        svbool_t pg_part = svwhilelt_b64(i, size);\n        svfloat64_t vec_a = svld1_f64(pg_part, &A[i]);\n        svfloat32_t vec_b = svfcvt_x_f64_f32(pg_part, vec_a);\n\n        svfloat32_t v_cmp_gt = svcmgt_f32(pg_part, vec_b, v_flt_max);\n        svfloat32_t v_cmp_lt = svcmplt_f32(pg_part, vec_b, v_flt_neg_max);\n\n        vec_b = svsel_f32(v_cmp_gt, v_flt_max, vec_b);\n        vec_b = svsel_f32(v_cmp_lt, v_flt_neg_max, vec_b);\n\n        svst1_f32(pg_part, &B[i], vec_b);\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    svbool_t pg = svptrue_b64();\n    size_t vec_len = svcntd();\n    size_t i = 0;\n\n    float32_t flt_max = FLT_MAX;\n    float32_t neg_flt_max = -FLT_MAX;\n\n    for (; i <= size - vec_len; i += vec_len) {\n        svfloat64_t vec_double = svld1_f64(pg, &A[i]);\n        svfloat32_t vec_convert = svfcvt_x_f64_f32(pg, vec_double);\n\n        svfloat32_t vec_fmax = svmov_n_f32(flt_max);\n        svfloat32_t vec_fneg_fmax = svmov_n_f32(neg_flt_max);\n\n        svbool_t overflows = svcmpgt_f32(pg, vec_convert, vec_fmax);\n        svbool_t underflows = svcmplt_f32(pg, vec_convert, vec_fneg_fmax);\n\n        vec_convert = svsel_f32(overflows, vec_fmax, vec_convert);\n        vec_convert = svsel_f32(underflows, vec_fneg_fmax, vec_convert);\n\n        svst1_f32(pg, &B[i], vec_convert);\n    }\n\n    // Handle leftover elements\n    if (i < size) {\n        svbool_t pg_remainder = svwhilelt_b64(i, size);\n        svfloat64_t vec_double = svld1_f64(pg_remainder, &A[i]);\n        svfloat32_t vec_convert = svfcvt_x_f64_f32(pg_remainder, vec_double);\n\n        svfloat32_t vec_fmax = svmov_n_f32(flt_max);\n        svfloat32_t vec_fneg_fmax = svmov_n_f32(neg_flt_max);\n\n        svbool_t overflows = svcmpgt_f32(pg_remainder, vec_convert, vec_fmax);\n        svbool_t underflows = svcmplt_f32(pg_remainder, vec_convert, vec_fneg_fmax);\n\n        vec_convert = svsel_f32(overflows, vec_fmax, vec_convert);\n        vec_convert = svsel_f32(underflows, vec_fneg_fmax, vec_convert);\n\n        svst1_f32(pg_remainder, &B[i], vec_convert);\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    svbool_t pg = svptrue_b64();\n    const float flt_max = FLT_MAX;\n    const float neg_flt_max = -FLT_MAX;\n\n    size_t i = 0;\n    while (i + svcntd() <= size) {\n        svfloat64_t vec_double = svld1_f64(pg, &A[i]);\n        svfloat32_t vec_float = svfcvt_x_f64_f32(pg, vec_double);\n        \n        svfloat32_t vec_fmax = svmov_n_f32(pg, flt_max);\n        svfloat32_t vec_fnegmax = svmov_n_f32(pg, neg_flt_max);\n\n        svbool_t gt_mask = svcmpgt_f32(pg, vec_float, vec_fmax);\n        svbool_t lt_mask = svcmplt_f32(pg, vec_float, vec_fnegmax);\n\n        vec_float = svsel_f32(gt_mask, vec_fmax, vec_float);\n        vec_float = svsel_f32(lt_mask, vec_fnegmax, vec_float);\n\n        svst1_f32(pg, &B[i], vec_float);\n        i += svcntd();\n    }\n\n    // Handle leftover elements\n    if (i < size) {\n        svbool_t pg_partial = svwhilelt_b64(i, size);\n        svfloat64_t vec_double = svld1_f64(pg_partial, &A[i]);\n        svfloat32_t vec_float = svfcvt_x_f64_f32(pg_partial, vec_double);\n\n        svfloat32_t vec_fmax = svmov_n_f32(pg_partial, flt_max);\n        svfloat32_t vec_fnegmax = svmov_n_f32(pg_partial, neg_flt_max);\n\n        svbool_t gt_mask = svcmpgt_f32(pg_partial, vec_float, vec_fmax);\n        svbool_t lt_mask = svcmplt_f32(pg_partial, vec_float, vec_fnegmax);\n\n        vec_float = svsel_f32(gt_mask, vec_fmax, vec_float);\n        vec_float = svsel_f32(lt_mask, vec_fnegmax, vec_float);\n\n        svst1_f32(pg_partial, &B[i], vec_float);\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b16();\n    while (i + svcntw() / 2 <= size) {\n        svint16_t vec_a = svld1_s16(pg, &A[i]);\n        svint32_t vec_b = svreinterpret_s32(svxtl_n_s16(vec_a, 0));\n        svst1_s32(pg, &B[i * 2], vec_b);\n        i += svcntw() / 2;\n    }\n    // Handle remaining elements if size is not a multiple of svcntw()/2\n    if (i < size) {\n        size_t left = size - i;\n        svbool_t pg_left = svwhilelt_b16(i, size);\n        svint16_t vec_a = svld1_s16(pg_left, &A[i]);\n        svint32_t vec_b = svreinterpret_s32(svxtl_n_s16(vec_a, 0));\n        svst1_s32(pg_left, &B[i * 2], vec_b);\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b16();\n    const size_t vec_len = svcntw() / 2; // Number of int16_t elements in a vector\n\n    while (i + vec_len <= size) {\n        svint16_t vec_a = svld1(pg, &A[i]);\n        svint32_t vec_b = svreinterpret_s32_s16(svshll_n_s16(vec_a, 16));\n        svst1(pg, &B[i], vec_b);\n        i += vec_len;\n    }\n\n    if (i < size) {\n        pg = svwhilelt_b16(i, size);\n        svint16_t vec_a = svld1(pg, &A[i]);\n        svint32_t vec_b = svreinterpret_s32_s16(svshll_n_s16(vec_a, 16));\n        svst1(pg, &B[i], vec_b);\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b16();\n    do {\n        svint16_t vec = svld1(pg, &A[i]);\n        svint32_t res = svcvt_x_n_s32(pg, vec, 0);\n        svst1(pg, &B[i], res);\n        i += svcntw() / 2;\n    } while (i < size);\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b16();\n    svint16_t vec;\n\n    while (i + svcntw() <= size) {\n        vec = svld1_s16(pg, &A[i]);\n        svst1_s32(pg, &B[i], svreinterpret_s32_s16(vec));\n        i += svcntw();\n    }\n\n    if (i < size) {\n        pg = svwhilelt_b16(i, size);\n        vec = svld1_s16(pg, &A[i]);\n        svst1_s32(pg, &B[i], svreinterpret_s32_s16(vec));\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b16();\n    svint16_t vec;\n\n    while (i + svcntw() / 2 <= size) {\n        vec = svld1_s16(pg, &A[i]);\n        svst1_s32(pg, &B[i], svreinterpret_s32_s16(vec));\n        i += svcntw() / 2;\n    }\n\n    // Handle remaining elements\n    if (i < size) {\n        pg = svwhilelt_b16((svint32_t)i, (svint32_t)size);\n        vec = svld1_s16(pg, &A[i]);\n        svst1_s32(pg, &B[i], svreinterpret_s32_s16(vec));\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    svbool_t pg = svptrue_b32();\n    svfloat32_t vmin = svdup_n_f32(min_val);\n    svfloat32_t vmax = svdup_n_f32(max_val);\n    svfloat32_t vzero = svdup_n_f32(0.0f);\n    svfloat32_t vone = svdup_n_f32(1.0f);\n\n    size_t i = 0;\n    for (; i <= size - svcntw(); i += svcntw()) {\n        svfloat32_t vA = svld1(pg, &A[i]);\n        svint32_t vcontrol = svld1(pg, &control[i]);\n\n        svbool_t cond = svcmplt(pg, vcontrol, svdup_n_s32(1));\n\n        svfloat32_t normalized = svsdiv_x(pg, svsub_x(pg, vA, vmin), svsub_x(pg, vmax, vmin));\n        svfloat32_t clamped = svmovl_m(pg, cond, svmin_x(pg, svmax_x(pg, normalized, vzero), vone), vA);\n\n        svst1(pg, &B[i], clamped);\n    }\n\n    for (; i < size; ++i) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            B[i] = (val < 0.0f) ? 0.0f : ((val > 1.0f) ? 1.0f : val);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    svfloat32_t s_min_val = svdup_n_f32(min_val);\n    svfloat32_t s_max_val = svdup_n_f32(max_val);\n    svfloat32_t s_range = svsub_f32(pg, s_max_val, s_min_val);\n\n    for (size_t i = 0; i < size; i += vl) {\n        size_t current_size = size - i;\n        if (current_size < vl) {\n            pg = svwhilelt_b32(i, size);\n        }\n\n        svfloat32_t s_A = svld1_f32(pg, &A[i]);\n        svint32_t s_control = svld1_s32(pg, &control[i]);\n\n        svbool_t cond = svcmpgt_s32(pg, s_control, svdup_n_s32(0));\n\n        svfloat32_t normalized = svdiv_f32(cond, svsub_f32(pg, s_A, s_min_val), s_range);\n        normalized = svmovmlt_f32(pg, normalized, svmin_f32(pg, svdup_n_f32(1.0f), normalized));\n        normalized = svmovmlt_f32(pg, normalized, svmax_f32(pg, svdup_n_f32(0.0f), normalized));\n\n        svfloat32_t result = svsel_f32(cond, normalized, s_A);\n\n        svst1_f32(pg, &B[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    svbool_t pg = svptrue_b32();\n    svfloat32_t vmin = svdup_n_f32(min_val);\n    svfloat32_t vmax = svdup_n_f32(max_val);\n    svfloat32_t vzero = svdup_n_f32(0.0f);\n    svfloat32_t vone = svdup_n_f32(1.0f);\n\n    size_t i = 0;\n    for (; i <= size - svcntw(); i += svcntw()) {\n        svfloat32_t vA = svld1_f32(pg, &A[i]);\n        svint32_t vcontrol = svld1_s32(pg, &control[i]);\n\n        svbool_t cond = svcmpgt_s32(pg, vcontrol, svdup_n_s32(0));\n\n        svfloat32_t diff = svsub_f32(pg, vA, vmin);\n        svfloat32_t range = svsub_f32(pg, vmax, vmin);\n        svfloat32_t normalized = svdiv_x_f32(pg, diff, range);\n\n        svfloat32_t clamped = svmovle_f32(pg, normalized, vone);\n        clamped = svmovge_f32(pg, clamped, vzero);\n\n        svfloat32_t result = svsel_f32(cond, clamped, vA);\n        svst1_f32(pg, &B[i], result);\n    }\n\n    for (; i < size; ++i) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            B[i] = (val < 0.0f) ? 0.0f : ((val > 1.0f) ? 1.0f : val);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    svbool_t pg = svptrue_b32();\n    float diff = max_val - min_val;\n    \n    for (size_t i = 0; i < size; i += svcntw()) {\n        size_t current_size = size - i;\n        if (current_size < svcntw()) {\n            pg = svwhilelt_b32(i, size);\n        }\n\n        svfloat32_t vec_A = svld1(pg, &A[i]);\n        svint32_t vec_control = svld1(pg, &control[i]);\n\n        svbool_t normalize = svcmpgt(pg, vec_control, svdup_n_s32(0));\n        svbool_t copy = svcmpeq(pg, vec_control, svdup_n_s32(0));\n\n        svfloat32_t normalized = svsel(normalize, \n                                     svdiv_x(pg, svsel(normalize, svsub_x(pg, vec_A, svdup_n_f32(min_val)), svdup_n_f32(0.0f)), svdup_n_f32(diff)),\n                                     svdup_n_f32(0.0f));\n\n        normalized = svsel(svand_x(pg, normalize, svcmplt(pg, normalized, svdup_n_f32(0.0f))), svdup_n_f32(0.0f), normalized);\n        normalized = svsel(svand_x(pg, normalize, svcmplt(pg, svdup_n_f32(1.0f), normalized)), svdup_n_f32(1.0f), normalized);\n\n        svst1(pg, &B[i], svsel(copy, vec_A, normalized));\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    svbool_t pg = svptrue_b32();\n    float diff = max_val - min_val;\n    svfloat32_t s_min_val = svdup_n_f32(min_val);\n    svfloat32_t s_diff = svdup_n_f32(diff);\n    svfloat32_t s_zero = svdup_n_f32(0.0f);\n    svfloat32_t s_one = svdup_n_f32(1.0f);\n\n    size_t i = 0;\n    for (; i <= size - svcntw(); i += svcntw()) {\n        svfloat32_t vec_A = svld1(pg, &A[i]);\n        svint32_t vec_control = svld1(pg, &control[i]);\n\n        svbool_t cond = svcmplt(pg, svreinterpret_s32_f32(vec_control), svdup_n_s32(1));\n\n        svfloat32_t normalized = svsel(cond, \n                                     svsel(svcmeq(pg, s_diff, s_zero), \n                                           s_zero, \n                                           svmax(pg, s_zero, svmin(pg, s_one, svdiv_x(pg, svsub_x(pg, vec_A, s_min_val), s_diff)))), \n                                     vec_A);\n\n        svst1(pg, &B[i], normalized);\n    }\n\n    for (; i < size; ++i) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / diff;\n            B[i] = (val < 0.0f) ? 0.0f : ((val > 1.0f) ? 1.0f : val);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    const size_t vec_len = svcntw();\n\n    while (i + vec_len <= size) {\n        svuint32_t vec_a = svld1_u32(pg, &A[i]);\n        svfloat32_t vec_f = svmov_n_f32(pg, 0.0f);\n        \n        // Extract the high 16 bits and convert to float\n        svuint16_t high_bits = svasr_u16(pg, svreinterpret_u16(vec_a), 16);\n        svfloat32_t converted = svcvt_f32_u32(pg, svreinterpret_u32_u16(high_bits));\n        \n        // Compute square root\n        svfloat32_t sqrt_result = svsqrt_f32(pg, converted);\n        \n        // Store the result\n        svst1_f32(pg, &B[i], sqrt_result);\n        \n        i += vec_len;\n    }\n\n    // Handle leftover elements\n    if (i < size) {\n        svbool_t pg_tail = svwhilelt_b32(i, size);\n        svuint32_t vec_a = svld1_u32(pg_tail, &A[i]);\n        svfloat32_t vec_f = svmov_n_f32(pg_tail, 0.0f);\n        \n        // Extract the high 16 bits and convert to float\n        svuint16_t high_bits = svasr_u16(pg_tail, svreinterpret_u16(vec_a), 16);\n        svfloat32_t converted = svcvt_f32_u32(pg_tail, svreinterpret_u32_u16(high_bits));\n        \n        // Compute square root\n        svfloat32_t sqrt_result = svsqrt_f32(pg_tail, converted);\n        \n        // Store the result\n        svst1_f32(pg_tail, &B[i], sqrt_result);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    while (i + svcntw() <= size) {\n        svuint32_t vec_a = svld1_u32(pg, &A[i]);\n        svuint16_t high_bits = svreinterpret_u16_u32(svshrq_n_u32(vec_a, 16));\n        svfloat32_t vec_f = svcvt_f32_u16(pg, high_bits);\n        svfloat32_t sqrt_vec = svsqrt_f32(pg, vec_f);\n        svst1_f32(pg, &B[i], sqrt_vec);\n        i += svcntw();\n    }\n    // Handle leftover elements if size is not a multiple of svcntw()\n    if (i < size) {\n        svbool_t pg_part = svwhilelt_b32(i, size);\n        svuint32_t vec_a = svld1_u32(pg_part, &A[i]);\n        svuint16_t high_bits = svreinterpret_u16_u32(svshrq_n_u32(vec_a, 16));\n        svfloat32_t vec_f = svcvt_f32_u16(pg_part, high_bits);\n        svfloat32_t sqrt_vec = svsqrt_f32(pg_part, vec_f);\n        svst1_f32(pg_part, &B[i], sqrt_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    while (i + svcntw() <= size) {\n        svuint32_t vec_a = svld1_u32(pg, &A[i]);\n        svfloat32_t vec_f = svreinterpret_f32_u32(svushr_n_u32(pg, vec_a, 16));\n        svfloat32_t vec_sqrt = svsqrt_f32(pg, vec_f);\n        svst1_f32(pg, &B[i], vec_sqrt);\n        i += svcntw();\n    }\n    if (i < size) {\n        svbool_t pg_partial = svwhilelt_b32(i, size);\n        svuint32_t vec_a = svld1_u32(pg_partial, &A[i]);\n        svfloat32_t vec_f = svreinterpret_f32_u32(svushr_n_u32(pg_partial, vec_a, 16));\n        svfloat32_t vec_sqrt = svsqrt_f32(pg_partial, vec_f);\n        svst1_f32(pg_partial, &B[i], vec_sqrt);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t index = 0;\n    svbool_t pg = svptrue_b32();\n    svuint32_t zero = svdup_n_u32(0);\n\n    while (index < size) {\n        svuint32_t vec_a = svld1_u32(pg, &A[index]);\n        svfloat32_t vec_f = svcvt_f32_x_u32(pg, svasr_u32(vec_a, svdup_n_u32(16)));\n        svfloat32_t vec_sqrt = svsqrt_f32(pg, vec_f);\n        svst1_f32(pg, &B[index], vec_sqrt);\n        index += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    const size_t vec_len = svcntw();\n\n    while (i + vec_len <= size) {\n        svuint32_t vec_a = svld1_u32(pg, &A[i]);\n        svuint16_t vec_high = svreinterpret_u16_u32(svushr_n_u32(pg, vec_a, 16));\n        svfloat32_t vec_f = svcvt_f32_u16(pg, vec_high);\n        svfloat32_t vec_sqrt = svsqrt_f32(pg, vec_f);\n        svst1_f32(pg, &B[i], vec_sqrt);\n        i += vec_len;\n    }\n\n    // Handle leftover elements\n    if (i < size) {\n        svbool_t pg_tail = svwhilelt_b32(i, size);\n        svuint32_t vec_a = svld1_u32(pg_tail, &A[i]);\n        svuint16_t vec_high = svreinterpret_u16_u32(svushr_n_u32(pg_tail, vec_a, 16));\n        svfloat32_t vec_f = svcvt_f32_u16(pg_tail, vec_high);\n        svfloat32_t vec_sqrt = svsqrt_f32(pg_tail, vec_f);\n        svst1_f32(pg_tail, &B[i], vec_sqrt);\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t index = 0;\n    svbool_t pg = svptrue_b32();\n    const uint32_t *a_ptr = A;\n    float *b_ptr = B;\n\n    while (index <= size - svcntw()) {\n        svuint32_t vec_a = svld1_u32(pg, a_ptr);\n        svst1_f32(pg, b_ptr, svbitcast_f32_u32(vec_a));\n        a_ptr += svcntw() / sizeof(uint32_t);\n        b_ptr += svcntw() / sizeof(float);\n        index += svcntw() / sizeof(uint32_t);\n    }\n\n    // Handle leftover elements\n    if (index < size) {\n        svbool_t pg_partial = svwhilelt_b32(index, size);\n        svuint32_t vec_a = svld1_u32(pg_partial, a_ptr);\n        svst1_f32(pg_partial, b_ptr, svbitcast_f32_u32(vec_a));\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    while (i + svcntw() <= size) {\n        svuint32_t vec_a = svld1_u32(pg, &A[i]);\n        svst1_f32(pg, &B[i], svbitcast_f32(vec_a));\n        i += svcntw();\n    }\n    if (i < size) {\n        svbool_t pg_tail = svptrue_b32();\n        pg_tail = svwhilelt_b32(i, size);\n        svuint32_t vec_a_tail = svld1_u32(pg_tail, &A[i]);\n        svst1_f32(pg_tail, &B[i], svbitcast_f32(vec_a_tail));\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    while (i + svcntw() <= size) {\n        svuint32_t vec_a = svld1_u32(pg, &A[i]);\n        svst1_f32(pg, &B[i], svreinterpret_f32_u32(vec_a));\n        i += svcntw();\n    }\n    if (i < size) {\n        svbool_t pg_tail = svwhilelt_b32(i, size);\n        svuint32_t vec_a = svld1_u32(pg_tail, &A[i]);\n        svst1_f32(pg_tail, &B[i], svreinterpret_f32_u32(vec_a));\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t index = 0;\n    svbool_t pg = svptrue_b32();\n    while (index <= size - svcntw()) {\n        svuint32_t vec_a = svld1_u32(pg, &A[index]);\n        svst1_f32(pg, &B[index], svbitcast_f32_u32(vec_a));\n        index += svcntw();\n    }\n    // Handle leftover elements if size is not a multiple of svcntw()\n    if (index < size) {\n        pg = svwhilelt_b32(index, (svint32_t){size});\n        svuint32_t vec_a = svld1_u32(pg, &A[index]);\n        svst1_f32(pg, &B[index], svbitcast_f32_u32(vec_a));\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl = svcntw(); // Get the vector length in terms of 32-bit elements\n    uint32_t *pA = (uint32_t *)A;\n    float *pB = B;\n\n    for (size_t i = 0; i < size; i += vl) {\n        svbool_t pg = svptrue_b32(); // Predicate for all active elements\n        svuint32_t vec_a = svld1(pg, pA + i); // Load uint32_t vector\n        svst1_f32(pg, pB + i, svreinterpret_f32_u32(vec_a)); // Reinterpret and store as float\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    svfloat32_t zero = svdup_f32(pg, 0.0f);\n\n    if (size > 0) {\n        diff[0] = 0.0f;\n        i = 1;\n    }\n\n    for (; i + svcntw() <= size; i += svcntw()) {\n        svbool_t cond_vec = svld1_b32(pg, &cond[i]);\n        svint32_t vec_A = svld1_s32(pg, &A[i]);\n        svint32_t vec_A_prev = svld1_s32(pg, &A[i - 1]);\n\n        svint32_t diff_int = svsub_s32(pg, vec_A, vec_A_prev);\n        svfloat32_t diff_float = vcvt_f32_s32(pg, diff_int);\n\n        svfloat32_t result = svsel_f32(cond_vec, diff_float, zero);\n        svst1_f32(pg, &diff[i], result);\n    }\n\n    for (; i < size; ++i) {\n        diff[i] = cond[i] ? (float)(A[i] - A[i-1]) : 0.0f;\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    svfloat32_t zero = svdup_f32(0.0f);\n\n    if (size > 0) {\n        // Set the first element to 0.0f\n        diff[0] = 0.0f;\n        i = 1;\n    }\n\n    for (; i <= size - svcntw(); i += svcntw()) {\n        svbool_t pred = svcmpne_b32(pg, svld1_b32((uint32_t*)&cond[i]), 0);\n        svint32_t vec_A = svld1_s32(pg, &A[i]);\n        svint32_t vec_A_prev = svld1_s32(pg, &A[i - 1]);\n        svint32_t diff_int = svsub_s32(pg, vec_A, vec_A_prev);\n        svfloat32_t diff_float = svcvt_f32_s32(pg, diff_int);\n        svfloat32_t res = svsel_f32(pred, diff_float, zero);\n        svst1_f32(pg, &diff[i], res);\n    }\n\n    for (; i < size; i++) {\n        diff[i] = cond[i] ? (float)(A[i] - A[i - 1]) : 0.0f;\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    svfloat32_t zero = svdup_f32(pg, 0.0f);\n\n    if (size > 0) {\n        diff[0] = 0.0f;\n        i = 1;\n    }\n\n    for (; i <= size - svcntw(); i += svcntw()) {\n        svbool_t cond_vec = svld1_b32(pg, &cond[i]);\n        svint32_t vec_A = svld1_s32(pg, &A[i]);\n        svint32_t vec_A_prev = svld1_s32(pg, &A[i - 1]);\n\n        svint32_t diff_int = svsub_s32(pg, vec_A, vec_A_prev);\n        svfloat32_t diff_float = svcvt_f32_s32(pg, diff_int);\n\n        svfloat32_t res = svsel_f32(cond_vec, diff_float, zero);\n        svst1_f32(pg, &diff[i], res);\n    }\n\n    for (; i < size; ++i) {\n        diff[i] = cond[i] ? (float)(A[i] - A[i-1]) : 0.0f;\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    svbool_t pg_cond;\n    svindex_s32 idx = svindex_s32(1, 1);\n    svfloat32_t zero = svdup_f32(0.0f);\n\n    for (; i <= size - svcntw(); i += svcntw()) {\n        svint32_t sva = svld1_s32(pg, &A[i]);\n        svint32_t svprev = svld1_offset_s32(pg, &A[i], idx);\n        svint32_t svdiff = svsub_s32(pg, sva, svprev);\n\n        pg_cond = svcmpeq_b32(pg, sv reinterpret_m_b32_z(pg, svld1_b8(pg, &cond[i])), svdup_b8(true));\n        svfloat32_t cond_diff = svreinterpret_f32_z(pg, svreinterpret_m_s32_z(pg, pg_cond));\n        svfloat32_t res = svsel_f32(pg, svfcvt_f32_s32(pg, svdiff), zero);\n\n        svst1_f32(pg, &diff[i], res);\n    }\n\n    if (i < size) {\n        svbool_t pg_part = svwhilelt_b32(i, size);\n        svint32_t sva = svld1_s32(pg_part, &A[i]);\n        svint32_t svprev = svld1_offset_s32(pg_part, &A[i], idx);\n        svint32_t svdiff = svsub_s32(pg_part, sva, svprev);\n\n        pg_cond = svcmpeq_b32(pg_part, sv reinterpret_m_b32_z(pg_part, svld1_b8(pg_part, &cond[i])), svdup_b8(true));\n        svfloat32_t cond_diff = svreinterpret_f32_z(pg_part, svreinterpret_m_s32_z(pg_part, pg_cond));\n        svfloat32_t res = svsel_f32(pg_part, svfcvt_f32_s32(pg_part, svdiff), zero);\n\n        svst1_f32(pg_part, &diff[i], res);\n    }\n\n    diff[0] = 0.0f;\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    svfloat32_t zero = svdup_f32(0.0f);\n\n    if (size > 0) {\n        // Set the first element of diff to 0.0f\n        diff[0] = 0.0f;\n\n        for (; i + svcntw() <= size; i += svcntw()) {\n            svbool_t cond_vec = svconvert_b_z(pg, svld1_u8(pg, (uint8_t*)&cond[i]));\n            svint32_t vec_A = svld1_s32(pg, &A[i]);\n            svint32_t vec_A_prev = svld1_s32(pg, &A[i - 1]);\n\n            svint32_t diff_int = svsub_s32(pg, vec_A, vec_A_prev);\n            svfloat32_t diff_float = svcvt_f32_s32_x(pg, diff_int);\n\n            svfloat32_t result = svsel_f32(cond_vec, diff_float, zero);\n            svst1_f32(pg, &diff[i], result);\n        }\n    }\n\n    // Handle leftover elements with a scalar loop\n    for (; i < size; ++i) {\n        diff[i] = cond[i] ? (float)(A[i] - A[i-1]) : 0.0f;\n    }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    const size_t vec_len = svcntw() / sizeof(uint32_t);\n\n    while (i + vec_len <= length) {\n        svuint32_t vec_src = svld1_u32(pg, &src[i]);\n        svuint64_t vec_dst = svreinterpret_u64_u32(svdupq_n_u32(0xFFFFFFFF)) & svreinterpret_u64_u32(svushll_n_u32(pg, vec_src, 32));\n        svst1_u64(pg, &dst[i], vec_dst);\n        i += vec_len;\n    }\n\n    if (i < length) {\n        size_t left = length - i;\n        svbool_t pg_left = svwhilelt_b32(i, length);\n        svuint32_t vec_src = svld1_u32(pg_left, &src[i]);\n        svuint64_t vec_dst = svreinterpret_u64_u32(svdupq_n_u32(0xFFFFFFFF)) & svreinterpret_u64_u32(svushll_n_u32(pg_left, vec_src, 32));\n        svst1_u64(pg_left, &dst[i], vec_dst);\n    }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    while (i + svcntw() <= length) {\n        svuint32_t vec_src = svld1_u32(pg, &src[i]);\n        svuint64_t vec_dst = svreinterpret_u64_u32(svuzp1_u32(vec_src, vec_src));\n        svuint64_t high_bits = svdup_u64(0xFFFFFFFF);\n        vec_dst = svorr_u64(vec_dst, svshl_u64(high_bits, 32));\n        svst1_u64(pg, &dst[i], vec_dst);\n        i += svcntw();\n    }\n    // Handle leftover elements if any\n    if (i < length) {\n        svbool_t pg_tail = svwhilelt_b32(i, length);\n        svuint32_t vec_src = svld1_u32(pg_tail, &src[i]);\n        svuint64_t vec_dst = svreinterpret_u64_u32(svuzp1_u32(vec_src, vec_src));\n        svuint64_t high_bits = svdup_u64(0xFFFFFFFF);\n        vec_dst = svorr_u64(vec_dst, svshl_u64(high_bits, 32));\n        svst1_u64(pg_tail, &dst[i], vec_dst);\n    }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    const uint32_t high_bits = 0xFFFFFFFF;\n\n    while (i + svcntw() <= length) {\n        svuint32_t vec_src = svld1_u32(pg, &src[i]);\n        svuint64_t vec_high = svdup_n_u64(high_bits);\n        svuint64_t vec_dst = svreinterpret_u64_u32(svzip1_u32(vec_src, vec_src));\n        vec_dst = svorr_u64(vec_dst, svshl_n_u64(vec_high, 32));\n        svst1_u64(pg, &dst[i], vec_dst);\n        i += svcntw();\n    }\n\n    if (i < length) {\n        pg = svwhilelt_b32(i, length);\n        svuint32_t vec_src = svld1_u32(pg, &src[i]);\n        svuint64_t vec_high = svdup_n_u64(high_bits);\n        svuint64_t vec_dst = svreinterpret_u64_u32(svzip1_u32(vec_src, vec_src));\n        vec_dst = svorr_u64(vec_dst, svshl_n_u64(vec_high, 32));\n        svst1_u64(pg, &dst[i], vec_dst);\n    }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    while (i + svcntw() <= length) {\n        svuint32_t vec_src = svld1_u32(pg, &src[i]);\n        svuint64_t vec_dst = svreinterpret_u64_u32(svdupq_m_u32(pg, vec_src, 0xFFFFFFFF));\n        svst1_u64(pg, &dst[i], vec_dst);\n        i += svcntw();\n    }\n    if (i < length) {\n        size_t left = length - i;\n        svbool_t pg_left = svwhilelt_b32(i, length);\n        svuint32_t vec_src = svld1_u32(pg_left, &src[i]);\n        svuint64_t vec_dst = svreinterpret_u64_u32(svdupq_m_u32(pg_left, vec_src, 0xFFFFFFFF));\n        svst1_u64(pg_left, &dst[i], vec_dst);\n    }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    const uint32_t mask = 0xFFFFFFFF;\n\n    while (i + svcntw() <= length) {\n        svuint32_t vec_src = svld1_u32(pg, &src[i]);\n        svuint64_t vec_dst = svreinterpret_u64(svushll_u32(pg, vec_src, 32));\n        vec_dst = svorr_u64(pg, vec_dst, svdup_n_u64(mask << 32));\n        svst1_u64(pg, &dst[i], vec_dst);\n        i += svcntw();\n    }\n\n    if (i < length) {\n        size_t left = length - i;\n        svbool_t pg_left = svwhilelt_b32(i, length);\n        svuint32_t vec_src = svld1_u32(pg_left, &src[i]);\n        svuint64_t vec_dst = svreinterpret_u64(svushll_u32(pg_left, vec_src, 32));\n        vec_dst = svorr_u64(pg_left, vec_dst, svdup_n_u64(mask << 32));\n        svst1_u64(pg_left, &dst[i], vec_dst);\n    }\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    svbool_t pg = svptrue_b16();\n    svint16_t svidx = svld1_s16(pg, index);\n    svfloat64_t sum = svdup_f64(0.0);\n\n    for (size_t i = 0; i < length; i += svcntd()) {\n        svbool_t pred = svcmpge_b16(pg, svidx, svdup_n_s16(0));\n        pred = svand_b16(pred, svcmpeq_b16(pg, svidx, svmin_u16(pg, svidx, svdup_n_s16(length - 1))));\n        \n        svfloat64_t gather = svldff_z_f64(pred, vec, svidx);\n        sum = svadd_x_f64(pg, sum, gather);\n        \n        if (i + svcntd() < length)\n            svidx = svld1_s16(pg, &index[i + svcntd()]);\n    }\n\n    float64x2_t res = svaddv_f64(pg, sum);\n    return vget_lane_f64(res, 0) + vget_lane_f64(res, 1);\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    svbool_t pg = svptrue_b16();\n    svint16_t svidx = svld1_s16(pg, index);\n    svfloat64_t sum = svdup_f64(0.0);\n\n    size_t i = 0;\n    while (i + svcntd() <= length) {\n        svbool_t pred = svcmpge_u32(pg, svtoint(svidx), 0);\n        pred = svand_b64(pred, svcmp_lt_u32(pg, svtoint(svidx), (uint32_t)length));\n        svfloat64_t gather = svldff1_gather_index_f64(pred, vec, svtouint(svidx));\n        sum = svaddv_f64(pred, sum, gather);\n        svidx = svld1_s16(pg, &index[i + svcntd()]);\n        i += svcntd();\n    }\n\n    // Handle leftover elements if any\n    if (i < length) {\n        size_t left = length - i;\n        svbool_t tail_pg = svwhilelt_b64(i, length);\n        svint16_t tail_svidx = svld1_s16(tail_pg, &index[i]);\n        svbool_t tail_pred = svcmpge_u32(tail_pg, svtoint(tail_svidx), 0);\n        tail_pred = svand_b64(tail_pred, svcmp_lt_u32(tail_pg, svtoint(tail_svidx), (uint32_t)length));\n        svfloat64_t tail_gather = svldff1_gather_index_f64(tail_pred, vec, svtouint(tail_svidx));\n        sum = svaddv_f64(tail_pred, sum, tail_gather);\n    }\n\n    double result = 0.0;\n    for (size_t j = 0; j < svcntd(); ++j) {\n        result += svget(sum, j);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    svbool_t pg = svptrue_b16();\n    svfloat64_t sum = svdup_f64(0.0);\n    size_t vl = svcntd();\n\n    for (size_t i = 0; i < length; i += vl) {\n        size_t chunk = (length - i > vl) ? vl : length - i;\n        svint16_t idx_vec = svld1_s16(pg, &index[i]);\n        svfloat64_t gather_vec = svmgatherv_f64(pg, vec, idx_vec);\n        sum = svaddv_f64(pg, sum, gather_vec);\n    }\n\n    double result = 0.0;\n    for (size_t j = 0; j < vl; ++j) {\n        result += svget_f64(sum, j);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    svbool_t pg = svptrue_b16();\n    svint16_t svidx = svld1_s16(pg, index);\n    svfloat64_t sum = svdup_f64(0.0);\n\n    for (size_t i = 0; i < length; i += svcntd()) {\n        svbool_t pred = svcmpge_u32(pg, svindex_s32(i, i + 1), svdup_n_s32(0));\n        pred = svand_b32(pred, svcmplt_u32(pg, svindex_s32(i, i + 1), svdup_n_s32((int)length)));\n\n        svint16_t idx_vec = svld1_s16(pg, &index[i]);\n        svfloat64_t gather_vec = svld1_gather_index_f64(pred, vec, svconvert_s64_s16(pg, idx_vec));\n\n        sum = svadd_f64_m(pred, sum, sum, gather_vec);\n    }\n\n    double result = 0.0;\n    for (size_t i = 0; i < svcntd(); ++i) {\n        result += svget_f64(sum, i);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    svbool_t pg = svptrue_b16();\n    svint16_t svidx = svdup_s16(0);\n    svfloat64_t sum_vec = svdup_f64(0.0);\n\n    size_t i = 0;\n    for (; i + svcntd() <= length; i += svcntd()) {\n        svint16_t indices = svld1_s16(pg, &index[i]);\n        svfloat64_t gather = svmgathr_f64(pg, svreinterpret_s64_z(pg, indices), vec, sizeof(double));\n        sum_vec = svadd_f64(pg, sum_vec, gather);\n    }\n\n    double total_sum = 0.0;\n    svfloat64_t sum_reduction = svdup_f64(0.0);\n    sum_reduction = svaddv_f64(pg, sum_reduction, sum_vec);\n    total_sum += svaddv_f64(pg, sum_reduction).f64[0];\n\n    // Handle leftover elements\n    if (i < length) {\n        svbool_t pg_tail = svwhilelt_b16(i, length);\n        svint16_t indices = svld1_s16(pg_tail, &index[i]);\n        svfloat64_t gather = svmgathr_f64(pg_tail, svreinterpret_s64_z(pg_tail, indices), vec, sizeof(double));\n        svfloat64_t sum_vec_tail = svadd_f64(pg_tail, svdup_f64(0.0), gather);\n        svfloat64_t sum_reduction_tail = svdup_f64(0.0);\n        sum_reduction_tail = svaddv_f64(pg_tail, sum_reduction_tail, sum_vec_tail);\n        total_sum += svaddv_f64(pg_tail, sum_reduction_tail).f64[0];\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    size_t vl = svcntd(); // Vector length in terms of double elements\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; j += vl) {\n            size_t k = j + vl > output_size ? output_size - j : vl;\n            svbool_t pg = svptrue_b64();\n            svfloat64_t acc = svdup_f64(pg, 0.0);\n\n            for (size_t m = 0; m < kernel_size; ++m) {\n                for (size_t n = 0; n < kernel_size; ++n) {\n                    const double* inp_row = &input[(i + m) * input_size + j + n];\n                    svfloat64_t vec_input = svld1(pg, inp_row);\n                    svfloat64_t vec_kernel = svdup_f64(pg, kernel[m * kernel_size + n]);\n                    acc = svadd_z(pg, acc, svmul_x(pg, vec_input, vec_kernel));\n                }\n            }\n\n            acc = svmax_f64_m(pg, acc, svdup_f64(pg, 0.0), acc); // ReLU activation\n\n            svfloat64_t zero = svdup_f64(pg, 0.0);\n            size_t jj = j;\n            for (svindxt_t z = svwhilelt_b64(jj, output_size); svptest_any(svptrue_b64(), z); z = svwhilelt_b64(jj, output_size)) {\n                svst1_x(z, &output[i * output_size + jj], acc);\n                jj += svcntd();\n                acc = svdup_f64(pg, 0.0);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    size_t vl = svcntd(); // Vector length in terms of double elements\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            size_t idx = i * input_size + j;\n            svbool_t pg = svptrue_b64();\n            svfloat64_t acc = svdup_f64(pg, 0.0);\n\n            for (size_t k = 0; k < kernel_size; ++k) {\n                for (size_t l = 0; l < kernel_size; l += vl) {\n                    size_t m = svcvtzud_siz(vl);\n                    svfloat64_t inp_vec = svld1_f64(pg, &input[(i + k) * input_size + j + l]);\n                    svfloat64_t ker_vec = svld1_f64(pg, &kernel[k * kernel_size + l]);\n                    acc = svadd_f64(pg, acc, svmul_f64(pg, inp_vec, ker_vec));\n                }\n            }\n\n            svfloat64_t res = svmov_f64(pg, acc);\n            res = svmov_f64(pg, svmaxv_f64(res)); // ReLU activation: max(0, value)\n            output[idx] = svfirst_f64(res);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    size_t vl = svcntd(); // Vector length in terms of double elements\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            size_t idx = i * input_size + j;\n            svbool_t pg = svptrue_b64();\n            svfloat64_t acc = svdup_f64(pg, 0.0);\n\n            for (size_t m = 0; m < kernel_size; ++m) {\n                for (size_t n = 0; n < kernel_size; n += vl) {\n                    size_t k_idx = m * kernel_size + n;\n                    svfloat64_t k_vec = svld1_f64(pg, &kernel[k_idx]);\n                    size_t in_idx = (i + m) * input_size + (j + n);\n                    svfloat64_t in_vec = svld1_f64(pg, &input[in_idx]);\n                    acc = svmla_f64(pg, acc, in_vec, k_vec);\n                }\n            }\n\n            acc = svmax_f64(pg, acc, svdup_f64(pg, 0.0)); // ReLU activation\n            size_t out_idx = i * output_size + j;\n            svst1_f64(pg, &output[out_idx], acc);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    size_t vl = svcntd(); // Vector length in terms of double-precision elements\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            size_t idx = i * input_size + j;\n            svbool_t pg = svptrue_b64();\n            svfloat64_t acc = svdup_f64(pg, 0.0);\n\n            for (size_t m = 0; m < kernel_size; ++m) {\n                for (size_t n = 0; n < kernel_size; n += vl) {\n                    svfloat64_t k_vec = svld1_f64(pg, &kernel[m * kernel_size + n]);\n                    svfloat64_t in_vec = svld1_f64(pg, &input[(i + m) * input_size + j + n]);\n                    acc = svadd_f64(pg, acc, svmul_f64(pg, k_vec, in_vec));\n                }\n            }\n\n            svfloat64_t res = svmov_f64(pg, acc);\n            res = svmax_f64(pg, res, svdup_f64(pg, 0.0)); // ReLU activation\n\n            for (size_t k = 0; k < vl; ++k) {\n                if (j + k < output_size) {\n                    output[idx + k] = svget_f64(res, k);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    size_t vl = svcntd(); // Vector length in terms of double elements\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; j += vl) {\n            size_t k;\n            svbool_t pg = svwhilelt_b64(j, output_size);\n            svfloat64_t acc = svdup_f64(pg, 0.0);\n\n            for (size_t m = 0; m < kernel_size; ++m) {\n                for (size_t n = 0; n < kernel_size; ++n) {\n                    svfloat64_t inp_vec = svld1(pg, &input[(i + m) * input_size + (j + n)]);\n                    double kern_val = kernel[m * kernel_size + n];\n                    svfloat64_t kern_vec = svbroadcast_f64(kern_val);\n                    acc = svadd_z(pg, acc, svmul_x(pg, inp_vec, kern_vec));\n                }\n            }\n\n            svfloat64_t res = svmovle_z(pg, acc); // ReLU activation: max(0, acc)\n            svst1(pg, &output[i * output_size + j], res);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <cmath>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold){\n    if (numbers.size() < 2) return false;\n\n    size_t n = numbers.size();\n    svbool_t pg = svptrue_b64();\n    size_t vl = svcntd();\n\n    for (size_t i = 0; i < n; i += vl) {\n        size_t len = n - i;\n        if (len < vl) {\n            pg = svwhilelt_b64(i, n);\n        }\n        svfloat64_t vi = svld1(pg, &numbers[i]);\n\n        for (size_t j = i + 1; j < n; j += vl) {\n            size_t len_j = n - j;\n            if (len_j < vl) {\n                pg = svwhilelt_b64(j, n);\n            }\n            svfloat64_t vj = svld1(pg, &numbers[j]);\n\n            svfloat64_t diff = svabs(pg, svsub_z(pg, vi, vj));\n            svbool_t cmp = svcmplt(pg, diff, svdup_n_f64(threshold));\n            if (svptest_any(svptrue_b64(), cmp)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <cmath>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold){\n    if (numbers.size() < 2) return false;\n\n    size_t n = numbers.size();\n    svbool_t pg = svptrue_b64();\n    svfloat64_t svt = svdup_f64(threshold);\n\n    for(size_t i = 0; i < n; ++i){\n        svfloat64_t svxi = svdup_f64(numbers[i]);\n        for(size_t j = i + 1; j < n; j += svcntd()){\n            size_t window = std::min(svcntd(), n - j);\n            svbool_t pgb = svwhilelt_b64(j - i, window);\n            svfloat64_t svxj = svld1(pgb, &numbers[j]);\n            svfloat64_t diff = svabs_f64(pg, svsub_f64(pg, svxi, svxj));\n            if(svany_pg(pgb, svcmp_lt_f64(diff, svt))){\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold){\n    if (numbers.size() < 2) return false;\n\n    size_t n = numbers.size();\n    svbool_t pg = svptrue_b64();\n    size_t vl = svcntd();\n\n    for (size_t i = 0; i < n; i += vl) {\n        size_t len = std::min(vl, n - i);\n        svbool_t pg_len = svwhilelt_b64(i, i + len);\n\n        svfloat64_t vi = svld1_f64(pg_len, &numbers[i]);\n\n        for (size_t j = i + 1; j < n; j++) {\n            svfloat64_t vj = svdup_f64(numbers[j]);\n            svfloat64_t diff = svabs_f64(svsub_f64(pg, vi, vj));\n            svbool_t cmp = svcmplt_f64(pg, diff, svdup_f64(threshold));\n            if (svptest_any(svptrue_b64(), cmp)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cmath>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold){\n    if (numbers.size() < 2) return false;\n\n    svbool_t pg = svptrue_b64();\n    size_t n = numbers.size();\n    const double *data = numbers.data();\n    svfloat64_t sthreshold = svdup_n_f64(threshold);\n\n    for (size_t i = 0; i < n; ++i) {\n        svfloat64_t svi = svdup_n_f64(data[i]);\n        for (size_t j = i + 1; j < n; j += svcntd()) {\n            size_t window = svcntd();\n            if (j + window > n) window = n - j;\n\n            svfloat64_t svj = svld1_f64(pg, &data[j]);\n            svfloat64_t diff = svabs_f64(pg, svsub_f64(pg, svi, svj));\n            svbool_t cmp_result = svcmplt_f64(pg, diff, sthreshold);\n            \n            if (svptest_any(svptrue_b64(), cmp_result)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cmath>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold){\n    if (numbers.size() < 2) return false;\n\n    size_t n = numbers.size();\n    svbool_t pg = svptrue_b64();\n    svfloat64_t svt_threshold = svdup_f64(pg, threshold);\n\n    for(size_t i = 0; i < n; ++i){\n        svfloat64_t svt_xi = svdup_f64(pg, numbers[i]);\n        for(size_t j = i + 1; j < n; j += svcntd()){\n            size_t window = std::min(svcntd(), n - j);\n            svbool_t pgb = svwhilelt_b64(j, j + window);\n            svfloat64_t svt_xj = svld1_f64(pgb, &numbers[j]);\n            svfloat64_t diff = svabs_f64(pgb, svsub_f64(pgb, svt_xj, svt_xi));\n            svbool_t closer = svcmplt_f64(pgb, diff, svt_threshold);\n            if(svptest_any(pgb, closer)){\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations){\n    if (operations.empty()) return false;\n\n    svbool_t pg = svptrue_b32();\n    int *data = operations.data();\n    size_t size = operations.size();\n\n    svint32_t balance = svdup_s32(pg, 0);\n\n    for (size_t i = 0; i < size; i += svcntw()) {\n        size_t j = i + svcntw();\n        j = (j > size) ? size : j;\n\n        svint32_t op = svld1(pg, &data[i]);\n        balance = svadd(pg, balance, op);\n\n        svbool_t below_zero = svcmplt(pg, balance, svdup_n_s32(0));\n        if (svptest_any(svptrue_b32(), below_zero)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations){\n    if (operations.empty()) return false;\n\n    svbool_t pg = svptrue_b32();\n    size_t vec_len = svcntw();\n    int* ops_data = operations.data();\n    size_t ops_size = operations.size();\n\n    svint32_t balance = svdup_n_s32(pg, 0);\n\n    for (size_t i = 0; i < ops_size; i += vec_len) {\n        size_t chunk = (ops_size - i > vec_len) ? vec_len : ops_size - i;\n        svbool_t pred = svwhilelt_b32(svindex_n_u32(0, 1), (uint32_t)chunk);\n        svint32_t op_chunk = svld1_gather_offset_z(pg, pred, ops_data + i, svindex_s32((int)i, (int)chunk));\n        \n        balance = svadd_x(pg, balance, op_chunk);\n\n        svbool_t below_zero = svcmplt(pg, balance, svdup_n_s32(pg, 0));\n        if (svptest_any(svptrue_b32(), below_zero)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    if (operations.empty()) return false;\n\n    svbool_t pg = svptrue_b32();\n    size_t vec_len = svcntw();\n    int *data = operations.data();\n    size_t n = operations.size();\n\n    svint32_t balance = svdup_s32(0);\n    svint32_t zero = svdup_s32(0);\n\n    for (size_t i = 0; i < n; i += vec_len) {\n        size_t k = n - i < vec_len ? n - i : vec_len;\n        svbool_t pg_k = svwhilelt_b32(i, i + k);\n\n        svint32_t ops = svld1(pg_k, data + i);\n        balance = svadd(pg_k, balance, ops);\n\n        svbool_t below_zero = svcmplt(pg_k, balance, zero);\n        if (svptest_any(pg_k, below_zero)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    if (operations.empty()) return false;\n\n    svbool_t pg = svptrue_b32();\n    int balance = 0;\n    size_t index = 0;\n    size_t veclen = svcntw();\n\n    while (index < operations.size()) {\n        size_t len = operations.size() - index;\n        size_t chunk = (len > veclen) ? veclen : len;\n\n        svint32_t sv_balance = svdup_n_s32(balance);\n        svint32_t sv_ops = svld1_s32(pg, &operations[index]);\n\n        for (size_t i = 0; i < chunk; ++i) {\n            svint32_t updated_balance = svaddv_s32(pg, sv_balance, svdup_n_s32(sv_ops[i]));\n            sv_balance = updated_balance;\n            if (svany_lt_s32(pg, updated_balance, svdup_n_s32(0))) {\n                return true;\n            }\n        }\n\n        balance = svlasta_s32(pg, sv_balance);\n        index += chunk;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    if (operations.empty()) return false;\n\n    svbool_t pg = svptrue_b32();\n    int32_t balance = 0;\n    svint32_t sv_balance = svdup_n_s32(balance);\n\n    size_t i = 0;\n    const size_t vec_len = svcntw();\n    for (; i + vec_len <= operations.size(); i += vec_len) {\n        svint32_t sv_ops = svld1(pg, &operations[i]);\n        sv_balance = svadd(pg, sv_balance, sv_ops);\n\n        svbool_t below_zero = svclt(pg, sv_balance, svdup_n_s32(0));\n        if (svptest_any(below_zero, pg)) {\n            return true;\n        }\n    }\n\n    // Handle remaining scalar elements\n    for (; i < operations.size(); ++i) {\n        balance += operations[i];\n        if (balance < 0) return true;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers){\n    if (numbers.empty()) return 0.0;\n\n    size_t n = numbers.size();\n    svbool_t pg = svptrue_b64();\n    svfloat64_t sum_vec = svdup_f64(pg, 0.0);\n    size_t i = 0;\n\n    // Compute the sum of elements using SVE\n    for (; i + svcntd() <= n; i += svcntd()) {\n        svfloat64_t vec = svld1_f64(pg, &numbers[i]);\n        sum_vec = svadd_f64(pg, sum_vec, vec);\n    }\n    double sum = 0.0;\n    for (size_t j = 0; j < svcntd(); ++j) {\n        sum += svget_f64(sum_vec, j);\n    }\n    for (; i < n; ++i) {\n        sum += numbers[i];\n    }\n\n    double mean = sum / n;\n    sum_vec = svdup_f64(pg, 0.0);\n    i = 0;\n\n    // Compute the sum of absolute deviations using SVE\n    for (; i + svcntd() <= n; i += svcntd()) {\n        svfloat64_t vec = svld1_f64(pg, &numbers[i]);\n        svfloat64_t diff = svsub_f64(pg, vec, svdup_f64(pg, mean));\n        svfloat64_t abs_diff = svasqabs_f64(pg, diff);\n        sum_vec = svadd_f64(pg, sum_vec, abs_diff);\n    }\n    double mad_sum = 0.0;\n    for (size_t j = 0; j < svcntd(); ++j) {\n        mad_sum += svget_f64(sum_vec, j);\n    }\n    for (; i < n; ++i) {\n        mad_sum += std::fabs(numbers[i] - mean);\n    }\n\n    return mad_sum / n;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers){\n    if (numbers.empty()) return 0.0;\n\n    // Calculate the mean\n    double sum = 0.0;\n    for (double num : numbers) {\n        sum += num;\n    }\n    double mean = sum / numbers.size();\n\n    // SVE intrinsics for MAD calculation\n    size_t vl = svcntd(); // Vector length in terms of double-precision elements\n    svbool_t pg = svptrue_b64(); // Predicate for all true\n    svfloat64_t s = svdup_f64(0.0); // Accumulator initialized to zero\n\n    for (size_t i = 0; i < numbers.size(); i += vl) {\n        size_t n = std::min(vl, (size_t)(numbers.size() - i));\n        svbool_t pg_n = svwhilelt_b64(i, numbers.size());\n        \n        // Load data into vector\n        svfloat64_t vec = svld1(pg_n, &numbers[i]);\n        \n        // Compute absolute difference |x - mean|\n        svfloat64_t diff = svabs_f64(svsub_f64(pg_n, vec, svdup_f64(mean)));\n        \n        // Accumulate the differences\n        s = svadd_f64(pg_n, s, diff);\n    }\n\n    // Horizontal sum of the accumulator\n    double total_diff = 0.0;\n    for (size_t i = 0; i < vl; ++i) {\n        total_diff += svget_f64(s, i);\n    }\n\n    // Compute MAD\n    double mad = total_diff / numbers.size();\n    return mad;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers){\n    if (numbers.empty()) return 0.0;\n\n    size_t n = numbers.size();\n    svbool_t pg = svptrue_b64();\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    size_t i = 0;\n\n    // Compute the sum of elements using SVE\n    for (; i + svcntd() <= n; i += svcntd()) {\n        svfloat64_t vec = svld1_f64(pg, &numbers[i]);\n        sum_vec = svadd_f64(pg, sum_vec, vec);\n    }\n\n    // Handle leftover elements\n    if (i < n) {\n        size_t left = n - i;\n        svbool_t pg_left = svwhilelt_b64(i, n);\n        svfloat64_t vec = svld1_f64(pg_left, &numbers[i]);\n        sum_vec = svadd_f64(pg_left, sum_vec, vec);\n    }\n\n    double total_sum = svaddv_f64(pg, sum_vec);\n    double mean = total_sum / n;\n\n    svfloat64_t mean_vec = svdup_f64(mean);\n    svfloat64_t mad_sum_vec = svdup_f64(0.0);\n    i = 0;\n\n    // Compute the sum of absolute deviations using SVE\n    for (; i + svcntd() <= n; i += svcntd()) {\n        svfloat64_t vec = svld1_f64(pg, &numbers[i]);\n        svfloat64_t diff = svabs_f64(pg, svsub_f64(pg, vec, mean_vec));\n        mad_sum_vec = svadd_f64(pg, mad_sum_vec, diff);\n    }\n\n    // Handle leftover elements\n    if (i < n) {\n        size_t left = n - i;\n        svbool_t pg_left = svwhilelt_b64(i, n);\n        svfloat64_t vec = svld1_f64(pg_left, &numbers[i]);\n        svfloat64_t diff = svabs_f64(pg_left, svsub_f64(pg_left, vec, mean_vec));\n        mad_sum_vec = svadd_f64(pg_left, mad_sum_vec, diff);\n    }\n\n    double mad_sum = svaddv_f64(pg, mad_sum_vec);\n    return mad_sum / n;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers){\n    if (numbers.empty()) return 0.0;\n\n    size_t n = numbers.size();\n    svbool_t pg = svptrue_b64();\n    svfloat64_t sum_vec = svdup_f64(pg, 0.0);\n    svfloat64_t count_vec = svdup_f64(pg, 0.0);\n\n    // Compute the sum of all elements\n    for(size_t i = 0; i < n; i += svcntd()) {\n        size_t k = std::min(svcntd(), n - i);\n        svbool_t pred = svwhilelt_b64(i, n);\n        svfloat64_t vec = svld1_f64(pred, &numbers[i]);\n        sum_vec = svadd_f64(pg, sum_vec, vec);\n        count_vec = svadd_f64(pg, count_vec, svdup_f64(pred, 1.0));\n    }\n\n    double total_sum = svaddv_f64(pg, sum_vec);\n    double count = svaddv_f64(pg, count_vec);\n    double mean = total_sum / count;\n\n    sum_vec = svdup_f64(pg, 0.0);\n\n    // Compute the MAD\n    for(size_t i = 0; i < n; i += svcntd()) {\n        size_t k = std::min(svcntd(), n - i);\n        svbool_t pred = svwhilelt_b64(i, n);\n        svfloat64_t vec = svld1_f64(pred, &numbers[i]);\n        svfloat64_t diff = svabs_f64(pg, svsub_f64(pg, vec, svdup_f64(pg, mean)));\n        sum_vec = svadd_f64(pg, sum_vec, diff);\n    }\n\n    double mad = svaddv_f64(pg, sum_vec) / count;\n    return mad;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers){\n    if (numbers.empty()) return 0.0;\n\n    size_t n = numbers.size();\n    svbool_t pg = svptrue_b64();\n    svfloat64_t sum_vec = svdup_f64(pg, 0.0);\n    size_t i = 0;\n\n    // Compute the sum of the numbers using SVE\n    for (; i + svcntd() <= n; i += svcntd()) {\n        svfloat64_t vec = svld1_f64(pg, &numbers[i]);\n        sum_vec = svadd_f64(pg, sum_vec, vec);\n    }\n    double sum = 0.0;\n    for (size_t j = 0; j < svcntd(); ++j) {\n        sum += svget(sum_vec, j);\n    }\n    for (; i < n; ++i) {\n        sum += numbers[i];\n    }\n\n    double mean = sum / n;\n    svfloat64_t mean_vec = svdup_f64(pg, mean);\n    sum_vec = svdup_f64(pg, 0.0);\n    i = 0;\n\n    // Compute the sum of absolute deviations using SVE\n    for (; i + svcntd() <= n; i += svcntd()) {\n        svfloat64_t vec = svld1_f64(pg, &numbers[i]);\n        svfloat64_t diff = svabs_f64(pg, svsub_f64(pg, vec, mean_vec));\n        sum_vec = svadd_f64(pg, sum_vec, diff);\n    }\n    double abs_dev_sum = 0.0;\n    for (size_t j = 0; j < svcntd(); ++j) {\n        abs_dev_sum += svget(sum_vec, j);\n    }\n    for (; i < n; ++i) {\n        abs_dev_sum += std::abs(numbers[i] - mean);\n    }\n\n    return abs_dev_sum / n;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter){ \n    if (numbers.empty()) return {};\n\n    size_t orig_size = numbers.size();\n    size_t new_size = 2 * orig_size - 1;\n    std::vector<int> result(new_size);\n\n    svbool_t pg = svptrue_b32();\n    size_t vec_len = svcntw(); // Number of elements in one SVE register\n\n    size_t i = 0;\n    for (; i <= orig_size - vec_len; i += vec_len) {\n        svint32_t vec_numbers = svld1(pg, &numbers[i]);\n        svst1(pg, &result[2*i], vec_numbers);\n\n        svint32_t vec_delim = svdup_n_s32(delimeter);\n        svst1(pg, &result[2*i + vec_len], vec_delim);\n    }\n\n    // Handle remaining scalar elements\n    for (; i < orig_size - 1; ++i) {\n        result[2*i] = numbers[i];\n        result[2*i + 1] = delimeter;\n    }\n    if (i < orig_size) {\n        result[2*i] = numbers[i];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter){ \n    if (numbers.empty()) return {};\n\n    size_t num_elements = numbers.size();\n    size_t result_size = 2 * num_elements - 1;\n    std::vector<int> result(result_size);\n\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < num_elements; i += vl) {\n        size_t chunk = num_elements - i;\n        svbool_t pred = svwhilelt_b32(i, num_elements);\n        \n        // Load vector elements\n        svint32_t vec = svld1(pred, &numbers[i]);\n        \n        // Store the original elements in the result\n        svst1(pred, &result[2 * i], vec);\n\n        // Check if we need to insert a delimiter after this element\n        if (i + vl < num_elements) {\n            svint32_t delim_vec = svdup_n_s32(delimeter);\n            svst1(pred, &result[2 * i + 1], delim_vec);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter){ \n    if (numbers.empty()) return {};\n\n    size_t orig_size = numbers.size();\n    size_t new_size = 2 * orig_size - 1;\n    std::vector<int> result(new_size);\n\n    svbool_t pg = svptrue_b32();\n    size_t vec_len = svcntw(); // Number of elements in one SVE vector\n\n    // Handle the main loop using SVE intrinsics\n    for (size_t i = 0; i < orig_size - 1; i += vec_len) {\n        size_t k = i * 2;\n        size_t n = (orig_size - 1 - i > vec_len) ? vec_len : orig_size - 1 - i;\n\n        svint32_t nums = svld1(pg, &numbers[i]);\n        svst1(pg, &result[k], nums);\n\n        svint32_t delims = svdup_n_s32(delimeter);\n        svst1(pg, &result[k + n], delims);\n    }\n\n    // Copy the last element\n    result[new_size - 1] = numbers[orig_size - 1];\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter){ \n    if (numbers.empty()) return {};\n\n    size_t orig_size = numbers.size();\n    size_t new_size = 2 * orig_size - 1;\n    std::vector<int> result(new_size);\n\n    svbool_t pg = svptrue_b32();\n    size_t vec_len = svcntw(); // Number of elements in one SVE vector\n\n    for (size_t i = 0; i < orig_size; i += vec_len) {\n        size_t j = i * 2;\n        svint32_t vec_nums = svld1(pg, &numbers[i]);\n        svst1(pg, &result[j], vec_nums);\n\n        if (i + vec_len < orig_size) {\n            svint32_t vec_delim = svdup_n_s32(delimeter);\n            svst1(pg, &result[j + 1], vec_delim);\n        }\n    }\n\n    // Handle the last element without delimiter\n    result[new_size - 1] = numbers[orig_size - 1];\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter){ \n    if (numbers.empty()) return {};\n\n    size_t orig_size = numbers.size();\n    size_t new_size = 2 * orig_size - 1;\n    std::vector<int> result(new_size);\n\n    svbool_t pg = svptrue_b32();\n    size_t i = 0;\n\n    // Process in vectorized chunks\n    size_t vec_len = svcntw(); // Number of elements per vector register\n    for (; i <= orig_size - vec_len; i += vec_len) {\n        svint32_t vec_nums = svld1(pg, &numbers[i]);\n        svst1(pg, &result[2*i], vec_nums); // Store original numbers\n\n        // Create a vector of delimeters and store them\n        svint32_t vec_delim = svdup_n_s32(delimeter);\n        svst1(pg, &result[2*i + vec_len], vec_delim);\n    }\n\n    // Handle remaining scalar elements\n    for (; i < orig_size - 1; ++i) {\n        result[2*i] = numbers[i];\n        result[2*i + 1] = delimeter;\n    }\n    if (i < orig_size) {\n        result[2*i] = numbers[i];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers){\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    size_t num_elements = numbers.size();\n    const int16_t *data = numbers.data();\n\n    svbool_t pg = svptrue_b16();\n    svint16_t svec = svdup_s16(0);\n    svint16_t pvec = svdup_s16(1);\n\n    size_t i = 0;\n    size_t vl = svcntw() / sizeof(int16_t);\n\n    for (; i <= num_elements - vl; i += vl) {\n        svint16_t vec = svld1(pg, &data[i]);\n        svec = svadd_z(pg, svec, vec);\n        pvec = svmul_x(pg, pvec, vec);\n    }\n\n    int64_t partial_sum = svaddv(svec);\n    int64_t partial_product = svmlav(pvec);\n\n    sum += partial_sum;\n    product *= partial_product;\n\n    for (; i < num_elements; ++i) {\n        sum += data[i];\n        product *= data[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers){\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    size_t n = numbers.size();\n    svbool_t pg = svptrue_b16();\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    size_t i = 0;\n    svint16_t acc_sum = svdup_n_s16(0);\n    svint16_t acc_product = svdup_n_s16(1);\n\n    while (i + svcntw() <= n) {\n        svint16_t vec = svld1(pg, &numbers[i]);\n        acc_sum = svadd(pg, acc_sum, vec);\n        acc_product = svmul_x(pg, acc_product, vec);\n        i += svcntw();\n    }\n\n    sum += svaddv(pg, acc_sum);\n    product *= svmlav(pg, acc_product);\n\n    // Handle remaining elements\n    if (i < n) {\n        size_t vl = n - i;\n        svbool_t pg_partial = svwhilelt_b16(i, n);\n        svint16_t vec = svld1(pg_partial, &numbers[i]);\n        acc_sum = svadd(pg_partial, svdup_n_s16(0), vec);\n        acc_product = svmul_x(pg_partial, svdup_n_s16(1), vec);\n        sum += svaddv(pg_partial, acc_sum);\n        product *= svmlav(pg_partial, acc_product);\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers){\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    svbool_t pg = svptrue_b16();\n    int16x8_t vsum = svdup_n_s16(0);\n    int16x8_t vprod = svdup_n_s16(1);\n\n    size_t i = 0;\n    size_t vl = svcntw() / 2; // Number of 16-bit elements per vector\n\n    for (; i <= numbers.size() - vl; i += vl) {\n        int16x8_t vload = svld1_s16(pg, &numbers[i]);\n        vsum = svadd_s16(pg, vsum, vload);\n        vprod = svmla_s16(pg, vprod, vload, svdup_n_s16(1));\n    }\n\n    // Horizontal sum and product\n    int64_t hsum = 0;\n    int64_t hprod = 1;\n\n    int16x8_t tmpsum = svaddv_s16(vsum);\n    int16x8_t tmpprod = svmlav_s16(vprod, svdup_n_s16(1));\n\n    hsum += svaddv_s16(tmpsum);\n    hprod *= svaddv_s16(tmpprod);\n\n    // Tail handling\n    for (; i < numbers.size(); ++i) {\n        hsum += numbers[i];\n        hprod *= numbers[i];\n    }\n\n    return {hsum, hprod};\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers){\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    int vl = svcntw(); // Get the vector length in terms of elements\n    svbool_t pg = svptrue_b16(); // Predicate for all true\n    svint16_t vec_sum = svdup_n_s16(0); // Initialize vector sum to zero\n    svint16_t vec_prod = svdup_n_s16(1); // Initialize vector product to one\n\n    size_t i = 0;\n    size_t n = numbers.size();\n\n    // Process full vectors\n    for (; i <= n - vl; i += vl) {\n        svint16_t data = svld1(pg, &numbers[i]);\n        vec_sum = svadd(pg, vec_sum, data);\n        vec_prod = svmul(pg, vec_prod, data);\n    }\n\n    // Horizontal sum and product for the accumulated vector\n    int64_t total_sum = 0;\n    int64_t total_prod = 1;\n\n    svuint64_t indices = svindex_u64(0, 1);\n    svbool_t pred = svcmpne_z_b16(pg, svindex_s16(0, 1), svcntw());\n    svint16_t mask = svsel(pg, svdup_n_s16(1), svdup_n_s16(0));\n\n    total_sum = svaddv_s16(pg, vec_sum);\n    total_prod = svmlav_s16(pg, svdup_n_s16(total_prod), vec_prod, mask);\n\n    // Process leftovers\n    for (; i < n; ++i) {\n        total_sum += numbers[i];\n        total_prod *= numbers[i];\n    }\n\n    return {total_sum, total_prod};\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers){\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    svbool_t pg = svptrue_b16();\n    size_t vec_len = numbers.size();\n    size_t vl = svcntw();\n\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    for (size_t i = 0; i < vec_len; i += vl) {\n        size_t chunk_size = (vec_len - i > vl) ? vl : vec_len - i;\n        svbool_t pg_chunk = svwhilelt_b16(i, i + chunk_size);\n\n        svint16_t data = svld1(pg_chunk, &numbers[i]);\n        svint16_t ones = svdup_n_s16(1);\n\n        // Summation\n        svint32_t partial_sums = svaddl(pg_chunk, data, data);\n        int64x2_t res_sum = svaddv(pg_chunk, partial_sums);\n        sum += res_sum[0] + res_sum[1];\n\n        // Product\n        svint16_t partial_products = svmla(pg_chunk, ones, data);\n        int64x2_t res_product = svaddv(pg_chunk, svreinterpret_s32_u32(svpmul(partial_products, partial_products)));\n        product *= res_product[0] * res_product[1];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers){\n    size_t n = numbers.size();\n    if (n == 0) return {};\n\n    std::vector<int> result(n);\n    int *data_ptr = numbers.data();\n    int *result_ptr = result.data();\n\n    svbool_t pg = svptrue_b32(); // Predicate for all active elements\n    svint32_t current_max = svdup_s32(data_ptr[0]); // Initialize current max with first element\n\n    size_t vl = svcntw(); // Vector length in terms of 32-bit elements\n    size_t i = 0;\n\n    // Process vectors\n    for (; i <= n - vl; i += vl) {\n        svint32_t vec = svld1(pg, &data_ptr[i]);\n        current_max = svmax(current_max, vec);\n        svst1(pg, &result_ptr[i], current_max);\n    }\n\n    // Handle leftovers\n    if (i < n) {\n        svbool_t pg_part = svwhilelt_b32(i, n);\n        svint32_t vec = svld1(pg_part, &data_ptr[i]);\n        current_max = svmax_m(pg_part, current_max, vec, current_max);\n        svst1(pg_part, &result_ptr[i], current_max);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers){\n    size_t n = numbers.size();\n    if (n == 0) return {};\n\n    std::vector<int> result(n);\n    int *data = numbers.data();\n    int *res = result.data();\n\n    svbool_t pg = svptrue_b32();\n    svint32_t current_max = svdup_n_s32(data[0]);\n    res[0] = data[0];\n\n    for (size_t i = 1; i < n; ++i) {\n        svint32_t vec = svld1(pg, &data[i]);\n        current_max = svmovlb_z(pg, svmax_z(pg, current_max, vec));\n        res[i] = sveor32(current_max)[0];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers){\n    size_t n = numbers.size();\n    if (n == 0) return {};\n\n    std::vector<int> result(n);\n    int* data_ptr = numbers.data();\n    int* result_ptr = result.data();\n\n    svbool_t pg = svptrue_b32();\n    svint32_t current_max = svdup_s32(numbers[0]);\n    svint32_t temp;\n\n    size_t index = 0;\n    size_t vec_len = svcntw(); // Vector length in elements\n\n    // Process full vectors\n    for (; index <= n - vec_len; index += vec_len) {\n        svint32_t vec = svld1(pg, data_ptr + index);\n        current_max = svmax(current_max, vec);\n        svst1(pg, result_ptr + index, current_max);\n    }\n\n    // Handle remaining scalar elements\n    for (; index < n; ++index) {\n        int val = numbers[index];\n        int max_val = (val > svget(current_max, 0)) ? val : svget(current_max, 0);\n        result[index] = max_val;\n        current_max = svdup_s32(max_val);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers){\n    if (numbers.empty()) return {};\n\n    size_t n = numbers.size();\n    std::vector<int> result(n);\n    \n    svbool_t pg = svptrue_b32();\n    int* data = numbers.data();\n    int* res = result.data();\n\n    svint32_t vmax = svdup_n_s32(data[0]);\n    svst1_s32(pg, &res[0], vmax);\n\n    for (size_t i = 1; i < n; i += svcntw()) {\n        size_t k = n - i > svcntw() ? svcntw() : n - i;\n        svbool_t pgb = svwhilelt_b32(0, k);\n\n        svint32_t vin = svld1_gather_offset_z_s32(pg, NULL, &data[i], svindex_s64(0, 1));\n        vmax = svmaxv_s32(pg, vmax, vin);\n        svst1_scatter_offset_s32(pgb, &res[i], svindex_s64(0, 1), vmax);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers){\n    size_t n = numbers.size();\n    if (n == 0) return {};\n\n    std::vector<int> result(n);\n    int* data = numbers.data();\n    int* res = result.data();\n\n    svbool_t pg = svptrue_b32();\n    svint32_t current_max = svdup_n_s32(data[0]);\n    svint32_t temp;\n\n    size_t i = 0;\n    size_t vl = svcntw(); // Vector length in terms of number of elements\n\n    for (; i <= n - vl; i += vl) {\n        svint32_t vec = svld1(pg, &data[i]);\n        current_max = svmax(current_max, vec);\n        svst1(pg, &res[i], current_max);\n    }\n\n    // Handle remaining scalar elements\n    for (; i < n; ++i) {\n        current_max = svmax_n_s32(current_max, data[i]);\n        res[i] = svfirst(current_max);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b){\n    size_t len = a.size();\n    if (len != b.size()) return \"\"; // Strings must be of the same length\n\n    std::vector<char> result(len);\n    svbool_t pg = svptrue_b8();\n    char *ap = reinterpret_cast<char*>(const_cast<char*>(a.c_str()));\n    char *bp = reinterpret_cast<char*>(const_cast<char*>(b.c_str()));\n    char *rp = result.data();\n\n    size_t i = 0;\n    while (i + svcntb() <= len) {\n        svuint8_t va = svld1(pg, reinterpret_cast<const uint8_t*>(ap + i));\n        svuint8_t vb = svld1(pg, reinterpret_cast<const uint8_t*>(bp + i));\n        svuint8_t vr = svxor(va, vb);\n        svst1(pg, reinterpret_cast<uint8_t*>(rp + i), vr);\n        i += svcntb();\n    }\n\n    // Handle leftover elements\n    if (i < len) {\n        pg = svwhilelt_b8(i, len);\n        svuint8_t va = svld1(pg, reinterpret_cast<const uint8_t*>(ap + i));\n        svuint8_t vb = svld1(pg, reinterpret_cast<const uint8_t*>(bp + i));\n        svuint8_t vr = svxor(va, vb);\n        svst1(pg, reinterpret_cast<uint8_t*>(rp + i), vr);\n    }\n\n    return std::string(result.begin(), result.end());\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b){\n    size_t len = a.size();\n    if (len != b.size()) return \"\"; // Ensure both strings are of same length\n\n    std::vector<char> result(len);\n    size_t i = 0;\n\n    while (i + svcntb() <= len) {\n        svbool_t pg = svptrue_b8();\n        svuint8_t va = svld1(pg, reinterpret_cast<const uint8_t*>(&a[i]));\n        svuint8_t vb = svld1(pg, reinterpret_cast<const uint8_t*>(&b[i]));\n        svuint8_t vr = svxor(va, vb);\n        svst1(pg, reinterpret_cast<uint8_t*>(&result[i]), vr);\n        i += svcntb();\n    }\n\n    // Handle remaining elements\n    if (i < len) {\n        svbool_t pg = svptrue_b8();\n        pg = svwhilelt_b8(i, len);\n        svuint8_t va = svld1(pg, reinterpret_cast<const uint8_t*>(&a[i]));\n        svuint8_t vb = svld1(pg, reinterpret_cast<const uint8_t*>(&b[i]));\n        svuint8_t vr = svxor(va, vb);\n        svst1(pg, reinterpret_cast<uint8_t*>(&result[i]), vr);\n    }\n\n    return std::string(result.begin(), result.end());\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b){\n    size_t len = a.size();\n    if (len != b.size()) {\n        return \"\";\n    }\n\n    std::string result;\n    result.reserve(len);\n\n    svbool_t pg = svptrue_b8();\n    size_t i = 0;\n\n    // Process vectors\n    for (; i <= len - svcntb(); i += svcntb()) {\n        svuint8_t va = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&a[i]));\n        svuint8_t vb = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&b[i]));\n        svuint8_t vr = svxor_u8(pg, va, vb);\n        uint8_t r[16];\n        svst1_u8(pg, r, vr);\n        result.append(reinterpret_cast<char*>(r), svcntb());\n    }\n\n    // Process leftovers\n    if (i < len) {\n        svbool_t pg_left = svwhilelt_b8(i, len);\n        svuint8_t va = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&a[i]));\n        svuint8_t vb = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&b[i]));\n        svuint8_t vr = svxor_u8(pg_left, va, vb);\n        uint8_t r[16] = {0};\n        svst1_u8(pg_left, r, vr);\n        result.append(reinterpret_cast<char*>(r), len - i);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b){\n    size_t len = a.size();\n    if (len != b.size()) return \"\"; // Strings must be of equal length\n\n    std::vector<char> result(len);\n    size_t i = 0;\n\n    while (i + svcntb() <= len) {\n        svbool_t pg = svptrue_b8();\n        svuint8_t va = svld1(pg, reinterpret_cast<const uint8_t*>(&a[i]));\n        svuint8_t vb = svld1(pg, reinterpret_cast<const uint8_t*>(&b[i]));\n        svuint8_t vr = svxor(va, vb);\n        svst1(pg, reinterpret_cast<uint8_t*>(&result[i]), vr);\n        i += svcntb();\n    }\n\n    // Handle remaining elements\n    if (i < len) {\n        svbool_t pg = svptrue_b8();\n        pg = svwhilelt_b8(i, len);\n        svuint8_t va = svld1(pg, reinterpret_cast<const uint8_t*>(&a[i]));\n        svuint8_t vb = svld1(pg, reinterpret_cast<const uint8_t*>(&b[i]));\n        svuint8_t vr = svxor(va, vb);\n        svst1(pg, reinterpret_cast<uint8_t*>(&result[i]), vr);\n    }\n\n    return std::string(result.begin(), result.end());\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n#include <vector>\n\nstd::string string_xor_simd(std::string a, std::string b){\n    size_t len = a.size();\n    if (len != b.size()) return \"\"; // Strings must be of equal length\n\n    std::vector<char> result(len);\n    size_t i = 0;\n\n    svbool_t pg = svptrue_b8(); // Predicate for full vector of uint8_t\n    while (i + svcntb() <= len) {\n        svuint8_t va = svld1(pg, reinterpret_cast<const uint8_t*>(&a[i]));\n        svuint8_t vb = svld1(pg, reinterpret_cast<const uint8_t*>(&b[i]));\n        svuint8_t vr = svxor(va, vb);\n        svst1(pg, reinterpret_cast<uint8_t*>(&result[i]), vr);\n        i += svcntb();\n    }\n\n    // Handle remaining elements if any\n    if (i < len) {\n        size_t remaining = len - i;\n        svbool_t pg_remain = svptrue_b8(static_cast<int>(remaining));\n        svuint8_t va = svld1(pg_remain, reinterpret_cast<const uint8_t*>(&a[i]));\n        svuint8_t vb = svld1(pg_remain, reinterpret_cast<const uint8_t*>(&b[i]));\n        svuint8_t vr = svxor(va, vb);\n        svst1(pg_remain, reinterpret_cast<uint8_t*>(&result[i]), vr);\n    }\n\n    return std::string(result.begin(), result.end());\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <string>\n\nstd::string longest_simd(const std::vector<std::string> & strings){\n    if (strings.empty()) return \"\";\n\n    size_t max_length = 0;\n    size_t max_index = 0;\n    size_t vl = svcntw(); // Get the vector length in terms of number of elements\n\n    for (size_t i = 0; i < strings.size(); i += vl) {\n        svbool_t pg = svptrue_b32(); // Predicate for all true\n        size_t j = i + vl > strings.size() ? strings.size() - i : vl;\n\n        svint32_t lengths = svdup_n_s32(0); // Initialize vector to store lengths\n        svint32_t indices = svindex_s32(i, 1); // Create vector of indices\n\n        for (size_t k = 0; k < j; ++k) {\n            int32_t len = strings[i + k].length();\n            svint32_t current_len = svdup_n_s32(len);\n            lengths = svmaxv_m(pg, lengths, current_len); // Find maximum length\n        }\n\n        int32_t current_max = svmaxv_s32(lengths); // Extract scalar max length\n        if (current_max > max_length) {\n            max_length = current_max;\n            max_index = i + svminv_idx_s32(sveq_z(pg, lengths, svdup_n_s32(max_length)));\n        }\n    }\n\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n#include <cstddef>\n\nstd::string longest_simd(const std::vector<std::string> & strings){\n    if (strings.empty()) return \"\";\n\n    size_t max_length = 0;\n    size_t max_index = 0;\n    size_t num_strings = strings.size();\n\n    svbool_t pg = svptrue_b32();\n    svuint32_t sve_lengths = svdup_n_u32(pg, 0);\n    svuint32_t sve_indices = svindex_u32(pg, 0, 1);\n\n    for(size_t i = 0; i < num_strings; i += svcntw()){\n        size_t j = i;\n        svbool_t pred = svwhilelt_b32(pg, j, num_strings);\n        svuint32_t current_lengths = svdup_n_u32(pg, 0);\n\n        for(size_t k = j; k < num_strings && k < j + svcntw(); ++k){\n            if(strings[k].size() > max_length){\n                max_length = strings[k].size();\n                max_index = k;\n            }\n        }\n    }\n\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::string longest_simd(const std::vector<std::string> & strings){\n    if (strings.empty()) return \"\";\n\n    size_t max_length = 0;\n    int max_idx = 0;\n\n    size_t num_strings = strings.size();\n    svbool_t pg = svptrue_b32();\n\n    for(size_t i = 0; i < num_strings; i += svcntw()){\n        size_t k = i + svcntw();\n        if(k > num_strings) k = num_strings;\n\n        svuint32_t indices = svindex_u32(i, 1);\n        svbool_t active = svcmpge_u32(pg, svdup_n_u32(i), svdup_n_u32(0));\n        active = svcmpeq_b32(active, svdup_n_u32(0), svdup_n_u32(k));\n\n        svuint32_t lengths = svdup_n_u32(0);\n        for(size_t j = i; j < k; ++j){\n            uint32_t len = static_cast<uint32_t>(strings[j].length());\n            lengths = svinsert_u32(lengths, lengths, len, j - i);\n        }\n\n        svbool_t is_greater = svcmplt_u32(pg, svdup_n_u32(max_length), lengths);\n        svbool_t update = svand_b32(active, is_greater);\n\n        uint32_t current_max = svmaxv_u32(update, lengths);\n        if(current_max > max_length){\n            max_length = current_max;\n            max_idx = indices[svlastidx_b32(update)];\n        }\n    }\n\n    return strings[max_idx];\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n#include <climits>\n\nstd::string longest_simd(const std::vector<std::string> & strings){\n    if (strings.empty()) return \"\";\n\n    size_t max_length = 0;\n    size_t max_index = 0;\n    size_t vl = svcntw(); // Vector length in terms of the number of elements\n\n    for(size_t i = 0; i < strings.size(); i += vl){\n        svbool_t pg = svptrue_b32();\n        size_t j = i + vl > strings.size() ? strings.size() - i : vl;\n        \n        svuint32_t lengths = svdup_n_u32(0);\n        svuint32_t indices = svindex_u32(0, 1);\n\n        for(size_t k = 0; k < j; ++k){\n            uint32_t len = static_cast<uint32_t>(strings[i + k].length());\n            lengths = svinsert_u32(pg, lengths, len, k);\n        }\n\n        svbool_t cmp = svcmpgt_u32(pg, lengths, svdup_n_u32(max_length));\n        svuint32_t new_max_lengths = svsel_u32(cmp, lengths, svdup_n_u32(max_length));\n        svuint32_t new_indices = svsel_u32(cmp, indices, svdup_n_u32(max_index));\n\n        max_length = svmovemask_b32(cmp) ? svmaxv_u32(pg, new_max_lengths) : max_length;\n        max_index = svmovemask_b32(cmp) ? svfirstb_b32(cmp) + i : max_index;\n    }\n\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n\nstd::string longest_simd(const std::vector<std::string> & strings){\n    if (strings.empty()) return \"\";\n\n    size_t max_length = 0;\n    size_t max_index = 0;\n    size_t num_strings = strings.size();\n\n    svbool_t pg = svptrue_b32();\n    svuint32_t indices = svindex_u32(0, 1);\n\n    for (size_t i = 0; i < num_strings; i += svcntw()) {\n        size_t chunk_size = std::min(svcntw(), static_cast<size_t>(num_strings - i));\n        svbool_t pg_chunk = svwhilelt_b32(i, i + chunk_size);\n\n        // Load string lengths into a vector\n        svuint32_t lengths = svdup_n_u32(0);\n        for (size_t j = 0; j < chunk_size; ++j) {\n            lengths = svinsert_u32(lengths, j, static_cast<uint32_t>(strings[i + j].length()));\n        }\n\n        // Compare and find the maximum length\n        svuint32_t current_max = svdup_n_u32(max_length);\n        svbool_t is_greater = svcmpgt_u32(pg_chunk, lengths, current_max);\n        svuint32_t new_indices = svsel_u32(is_greater, indices, svdup_n_u32(max_index));\n        svuint32_t new_lengths = svsel_u32(is_greater, lengths, current_max);\n\n        // Update max_length and max_index\n        max_length = svmaxv_u32(pg, new_lengths);\n        max_index = svfirstb_u32(pg, svcmpeq_u32(pg, new_lengths, svdup_n_u32(max_length)) & svcmpeq_u32(pg, new_indices, svdup_n_u32(max_index))) ? max_index : svindex_u32(0, 1)[0];\n\n        indices = svadd_u32(pg, indices, svdup_n_u32(chunk_size));\n    }\n\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b){\n    svbool_t pg = svptrue_b64();\n    svuint64_t sa = svdup_u64(a);\n    svuint64_t sb = svdup_u64(b);\n\n    while (svanyTrue_b64(pg, sb)) {\n        svuint64_t temp = svrem_u64(pg, sa, sb);\n        sa = sb;\n        sb = temp;\n    }\n\n    uint64_t result;\n    svst1_u64(&result, pg, sa);\n    return result;\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b){\n    svbool_t pg = svptrue_b64();\n    svuint64_t sa = svdup_n_u64(pg, a);\n    svuint64_t sb = svdup_n_u64(pg, b);\n\n    while (svanyTrue_b64(svcmpne_u64(pg, sb, svdup_n_u64(pg, 0)))) {\n        svuint64_t temp = svmin_u64(pg, sa, sb);\n        sb = svsub_u64(pg, sa, temp);\n        sa = temp;\n    }\n\n    return svindex1_u64(pg, 0, 1)[0];\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b){\n    svbool_t pg = svptrue_b64();\n    svuint64_t sa = svdup_u64(a);\n    svuint64_t sb = svdup_u64(b);\n\n    while (svanyTrue_b64(svcmpne_u64(pg, sb, svdup_u64(0)))) {\n        svuint64_t temp = svmin_u64(pg, sa, sb);\n        sb = svsub_u64(pg, sa, temp);\n        sa = temp;\n    }\n\n    return svindex_u64()[0];\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b){\n    svbool_t pg = svptrue_b64();\n    svuint64_t sva = svdup_u64(a);\n    svuint64_t svb = svdup_u64(b);\n\n    while (svptest_any(svptrue_b64(), svbor_x(pg, sva, svb))) {\n        svuint64_t temp = svmin_u64(pg, sva, svb);\n        svb = svsub_u64(pg, sva, temp);\n        sva = temp;\n    }\n\n    return svaddv_u64(pg, sva);\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b){\n    svbool_t pg = svptrue_b64();\n    svuint64_t sa = svdup_n_u64(a);\n    svuint64_t sb = svdup_n_u64(b);\n\n    while (svanyTrue(pg, sb)) {\n        svuint64_t temp = svmin_u64(pg, sa, sb);\n        sb = svsub_u64(pg, sa, temp);\n        sa = temp;\n    }\n\n    return svindex_m_u64(pg, 0, 1)[0];\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers){\n    size_t n = numbers.size();\n    if (n < 2) return {};\n\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    float min_diff = std::numeric_limits<float>::infinity();\n    float closest_a = 0.0f, closest_b = 0.0f;\n\n    for (size_t i = 0; i < n - 1; ++i) {\n        svfloat32_t svi = svld1(pg, &numbers[i]);\n\n        for (size_t j = i + 1; j < n; j += vl) {\n            size_t len = std::min(vl, n - j);\n            svbool_t pg_len = svwhilelt_b32(j - i, len);\n\n            svfloat32_t svj = svld1(pg_len, &numbers[j]);\n            svfloat32_t diff = svabs(pg_len, svsub(pg_len, svi, svj));\n\n            svfloat32_t min_diff_vec = svdup_n_f32(min_diff);\n            svbool_t is_less = svcmplt(pg_len, diff, min_diff_vec);\n\n            svuint32_t mask = svsel_u32(pg_len, svreinterpret_u32_f32(diff), svdup_n_u32(0));\n            uint32_t active = svcntp_b32(is_less);\n\n            if (active) {\n                uint32_t indices[svcntw()];\n                svst1(pg_len, indices, mask);\n\n                for (size_t k = 0; k < len; ++k) {\n                    if ((indices[k] >> 5) == k && (indices[k] & 0x1F) < min_diff * (1 << 5)) {\n                        min_diff = numbers[i] - numbers[j + k];\n                        closest_a = numbers[i];\n                        closest_b = numbers[j + k];\n                    }\n                }\n            }\n        }\n    }\n\n    return {closest_a, closest_b};\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n#include <algorithm>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers){\n    if (numbers.size() < 2) return {};\n\n    size_t vl = svcntw();\n    float diff_min = std::numeric_limits<float>::infinity();\n    float result_a = 0.0f, result_b = 0.0f;\n\n    for (size_t i = 0; i + vl <= numbers.size(); i += vl) {\n        svfloat32_t pg = svptrue_f32();\n        svfloat32_t vec_a = svld1_f32(pg, &numbers[i]);\n\n        for (size_t j = i + 1; j + vl <= numbers.size(); j += vl) {\n            svfloat32_t vec_b = svld1_f32(pg, &numbers[j]);\n            svfloat32_t diffs = svabs_f32(pg, svsub_f32(pg, vec_a, vec_b));\n\n            svuint32_t indices = svtbl_idx(pg, j - i - 1);\n            svbool_t cond = svcmplt_f32(pg, diffs, svdup_f32(diff_min));\n\n            svbool_t active = svwhilelt_b32(i, numbers.size());\n            cond = svand_b32(cond, active);\n\n            if (svptest_any(svptrue_b32(), cond)) {\n                size_t idx = svindex_z(pg, 0);\n                idx = svtbl_idx(pg, j - i - 1);\n                diff_min = svminv_f32(pg, diffs);\n                result_a = numbers[i + svminv_idx(pg, idx)];\n                result_b = numbers[j + svminv_idx(pg, idx)];\n            }\n        }\n    }\n\n    return {std::min(result_a, result_b), std::max(result_a, result_b)};\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers){\n    if (numbers.size() < 2) return {};\n\n    svbool_t pg = svptrue_b32();\n    size_t n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_a = 0.0f, closest_b = 0.0f;\n\n    for(size_t i = 0; i < n -1; ){\n        size_t vl = svcntw();\n        size_t max_i = n -1 -i;\n        size_t num = (max_i < vl) ? max_i : vl;\n\n        svfloat32_t svi = svld1(pg, &numbers[i]);\n        svfloat32_t next = svld1(pg, &numbers[i+1]);\n\n        svfloat32_t diff = svabs(pg, svsub(pg, svi, next));\n        svfloat32_t broadcast_min_diff = svdup_n_f32(min_diff);\n\n        svbool_t cond = svcmplt(pg, diff, broadcast_min_diff);\n        svuint32_t indices = svindex_u32(0, 1);\n        int first = svfirstb(cond);\n\n        if(first != -1){\n            size_t j = first + i;\n            float current_diff = fabs(numbers[j] - numbers[j+1]);\n            if(current_diff < min_diff){\n                min_diff = current_diff;\n                closest_a = numbers[j];\n                closest_b = numbers[j+1];\n            }\n        }\n        i += num;\n    }\n\n    std::vector<float> result = {closest_a, closest_b};\n    if(closest_a > closest_b){\n        std::swap(result[0], result[1]);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <float.h>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers){\n    if (numbers.size() < 2) return {};\n\n    float *data = numbers.data();\n    size_t n = numbers.size();\n\n    float32xN_t min_diff = svdup_f32(DBL_MAX);\n    float32xN_t closest_a = svdup_f32(0.0f);\n    float32xN_t closest_b = svdup_f32(0.0f);\n\n    svbool_t pg = svptrue_b32();\n\n    for (size_t i = 0; i < n - 1; ++i) {\n        float32xN_t a = svdup_f32(data[i]);\n        for (size_t j = i + 1; j < n; ++j) {\n            float32xN_t b = svdup_f32(data[j]);\n            float32xN_t diff = svabs_f32(svsub_f32(a, b));\n            svbool_t cond = svcmplt_f32(pg, diff, min_diff);\n            min_diff = svmin_f32_m(pg, cond, diff, min_diff);\n            closest_a = svsel_f32(cond, a, closest_a);\n            closest_b = svsel_f32(cond, b, closest_b);\n        }\n    }\n\n    float result_min_diff = svminv_f32(pg, min_diff);\n    float result_a = svfirst_f32(pg, closest_a);\n    float result_b = svfirst_f32(pg, closest_b);\n\n    if (result_a > result_b) std::swap(result_a, result_b);\n\n    return {result_a, result_b};\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n#include <tuple>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers){\n    if (numbers.size() < 2) return {};\n\n    size_t n = numbers.size();\n    float min_diff = INFINITY;\n    std::vector<float> closest_pair;\n\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < n - 1; i++) {\n        svfloat32_t svi = svdup_n_f32(numbers[i]);\n        svfloat32_t min_diff_vec = svdup_n_f32(min_diff);\n\n        for (size_t j = i + 1; j + vl <= n; j += vl) {\n            svfloat32_t svj = svld1(pg, &numbers[j]);\n            svfloat32_t diff = svabs(pg, svsub(pg, svi, svj));\n            svfloat32_t pred_min = svmin(pg, diff, min_diff_vec);\n\n            svuint32_t indices = svindex_u32(j, 1);\n            svbool_t cond = svcmp_lt_f32(pg, pred_min, min_diff_vec);\n\n            if (svptest_any(svptrue_b32(), cond)) {\n                size_t idx = svfirstb_i32(svcompact(cond));\n                float current_diff = numbers[idx];\n                if (current_diff < min_diff) {\n                    min_diff = current_diff;\n                    closest_pair = {numbers[i], numbers[idx]};\n                }\n            }\n\n            min_diff_vec = pred_min;\n        }\n\n        // Handle remaining elements\n        for (size_t j = (n / vl) * vl; j < n; ++j) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                closest_pair = {numbers[i], numbers[j]};\n            }\n        }\n    }\n\n    if (closest_pair.empty()) return {};\n    if (closest_pair[0] > closest_pair[1]) std::swap(closest_pair[0], closest_pair[1]);\n    return closest_pair;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers){ \n    if (numbers.size() < 2) return numbers;\n\n    size_t n = numbers.size();\n    svbool_t pg = svptrue_b32();\n    svfloat32_t vmin = svdup_f32(pg, numbers[0]);\n    svfloat32_t vmax = svdup_f32(pg, numbers[0]);\n\n    for(size_t i = 0; i < n; i += svcntw()) {\n        size_t k = svcntw();\n        size_t j = i + k > n ? n - i : k;\n        svfloat32_t v = svld1_f32(pg, &numbers[i]);\n        vmin = svmin_f32_m(pg, vmin, v);\n        vmax = svmax_f32_m(pg, vmax, v);\n    }\n\n    float min_val = svminv_f32(pg, vmin);\n    float max_val = svmaxv_f32(pg, vmax);\n\n    float scale = max_val - min_val;\n    if(scale == 0.0f) return numbers;\n\n    std::vector<float> result(n);\n    for(size_t i = 0; i < n; i += svcntw()) {\n        size_t k = svcntw();\n        size_t j = i + k > n ? n - i : k;\n        svfloat32_t v = svld1_f32(pg, &numbers[i]);\n        svfloat32_t scaled = svsdiv_f32_m(pg, svsub_f32_m(pg, v, svdup_f32(pg, min_val)), svdup_f32(pg, scale));\n        svst1_f32(pg, &result[i], scaled);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers){ \n    if (numbers.size() < 2) return numbers;\n\n    size_t n = numbers.size();\n    float *data = numbers.data();\n\n    svbool_t pg = svptrue_b32();\n    svfloat32_t svec = svld1_f32(pg, data);\n\n    float min_val = svminv_f32(pg, svec);\n    float max_val = svmaxv_f32(pg, svec);\n\n    for (size_t i = 1; i < n; i += svcntw()) {\n        svec = svld1_f32(pg, &data[i]);\n        min_val = std::min(min_val, svminv_f32(pg, svec));\n        max_val = std::max(max_val, svmaxv_f32(pg, svec));\n    }\n\n    float scale = max_val - min_val;\n    if (scale == 0.0f) return numbers;\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        svfloat32_t vec = svld1_f32(pg, &data[i]);\n        svfloat32_t rescaled = svdiv_n_f32(svmul_x_f32(pg, svsub_x_f32(pg, vec, svdup_n_f32(min_val)), 1.0f / scale), 1.0f);\n        svst1_f32(pg, &data[i], rescaled);\n    }\n\n    return numbers;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers){ \n    if (numbers.size() < 2) return numbers;\n\n    size_t n = numbers.size();\n    float *data = numbers.data();\n\n    svbool_t pg = svptrue_b32();\n    int vl = svcntw();\n\n    // Compute min and max using SVE intrinsics\n    float min_val = data[0];\n    float max_val = data[0];\n\n    for (size_t i = 0; i < n; i += vl) {\n        svfloat32_t svec = svld1(pg, &data[i]);\n        float current_min = svminv_f32(pg, svec);\n        float current_max = svmaxv_f32(pg, svec);\n        if (current_min < min_val) min_val = current_min;\n        if (current_max > max_val) max_val = current_max;\n    }\n\n    // Handle case where all elements are the same\n    if (min_val == max_val) {\n        std::vector<float> result(n, 0.0f);\n        return result;\n    }\n\n    // Perform rescaling\n    float scale_factor = 1.0f / (max_val - min_val);\n\n    for (size_t i = 0; i < n; i += vl) {\n        svfloat32_t svec = svld1(pg, &data[i]);\n        svfloat32_t scaled = svmul_x_f32(pg, scale_factor, svsub_x_f32(pg, svec, svdup_n_f32(min_val)));\n        svst1(pg, &data[i], scaled);\n    }\n\n    return numbers;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers){ \n    if (numbers.size() < 2) return numbers;\n\n    size_t n = numbers.size();\n    float *data = numbers.data();\n\n    svbool_t pg = svptrue_b32();\n    svfloat32_t svec, dvec;\n    float min_val = data[0], max_val = data[0];\n\n    // Find min and max values\n    for(size_t i = 0; i < n; i += svcntw()) {\n        svfloat32_t vec = svld1(pg, &data[i]);\n        min_val = svminv_f32(pg, min_val, vec);\n        max_val = svmaxv_f32(pg, max_val, vec);\n    }\n\n    float range = max_val - min_val;\n    if(range == 0.0f) return numbers; // Avoid division by zero\n\n    // Rescale the vector\n    for(size_t i = 0; i < n; i += svcntw()) {\n        svfloat32_t vec = svld1(pg, &data[i]);\n        svfloat32_t rescaled = svsdiv_n_f32(pg, svsub_f32(pg, vec, svdup_n_f32(min_val)), range);\n        svst1(pg, &data[i], rescaled);\n    }\n\n    return numbers;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers){ \n    size_t n = numbers.size();\n    if (n < 2)\n        return numbers;\n\n    float *data = numbers.data();\n    svbool_t pg = svptrue_b32();\n\n    // Load the data into a vector\n    svfloat32_t vec = svld1(pg, data);\n\n    // Find min and max using SVE intrinsics\n    float min_val = data[0];\n    float max_val = data[0];\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        svfloat32_t v = svld1(pg, &data[i]);\n        min_val = svmnvm_f32(pg, min_val, v);\n        max_val = svmxvm_f32(pg, max_val, v);\n    }\n\n    // Handle case where all elements are the same\n    if (min_val == max_val)\n        return std::vector<float>(n, 0.0f);\n\n    // Compute scale factor\n    float scale = 1.0f / (max_val - min_val);\n\n    // Apply transformation in parallel\n    for (size_t i = 0; i < n; i += svcntw()) {\n        svfloat32_t v = svld1(pg, &data[i]);\n        svfloat32_t rescaled = svsus\u6986m_f32_m(pg, v, min_val, scale);\n        svst1(pg, &data[i], rescaled);\n    }\n\n    return numbers;\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t largest_divisor_simd(uint64_t n){\n    uint64_t result = 1;\n    if (n <= 1) return 0;\n\n    svbool_t pg = svptrue_b64();\n    uint64_t vl = svcntd();\n    uint64_t index = n - 1;\n    svuint64_t vec_index = svdupq_n_u64(index);\n    svuint64_t vec_n = svdupq_n_u64(n);\n\n    while (index > 0) {\n        svuint64_t remainder = svmod_u64(pg, vec_n, vec_index);\n        svbool_t is_zero = svcmpeq_m(pg, remainder, svdupq_n_u64(0));\n        svuint64_t candidates = svsel_u64(is_zero, vec_index, svdupq_n_u64(0));\n        uint64_t max_candidate = svmovem_u64(candidates);\n        if (max_candidate > result) {\n            result = max_candidate;\n        }\n        index -= vl;\n        vec_index = svsub_u64(pg, vec_index, svdupq_n_u64(vl));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t largest_divisor_simd(uint64_t n){\n    uint64_t result = 0;\n    svbool_t pg = svptrue_b64();\n    svuint64_t vn = svdup_n_u64(n);\n    \n    for (uint64_t i = 1; i <= n / 2; i += svcntd()) {\n        svuint64_t vi = svindex_u64(i, i + svcntd());\n        svuint64_t vrem = svmod_u64(pg, vn, vi);\n        svbool_t is_zero = svcmpeq_z(pg, vrem, svdup_n_u64(0));\n        svuint64_t vand = svand_x_u64(pg, vi, svdup_n_u64(-1), is_zero);\n        uint64_t max_val = svmovemask_z_u64(pg, vand);\n        if (max_val != 0) {\n            result = __builtin_ctzll(max_val);\n            break;\n        }\n    }\n    return result == 0 ? 1 : result;\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t largest_divisor_simd(uint64_t n){\n    uint64_t result = 0;\n    if (n <= 1) return 0;\n\n    svbool_t pg = svptrue_b64();\n    uint64_t vl = svcntd();\n    uint64_t max_index = n / 2;\n    uint64_t stride = (max_index + vl - 1) / vl;\n    uint64_t start = 1;\n\n    svuint64_t indices = svseq_u64(pg, start);\n    svuint64_t vec_n = svdup_n_u64(n);\n\n    for (uint64_t i = start; i <= max_index; i += stride * vl) {\n        svuint64_t mod_result = svmod_u64(pg, vec_n, indices);\n        svbool_t is_zero = svcmpeq_z(pg, mod_result, svdup_n_u64(0));\n        svuint64_t candidates = svsel_u64(is_zero, indices, svdup_n_u64(0));\n        uint64_t max_candidate = svmaxv_u64(pg, candidates);\n        if (max_candidate > result) result = max_candidate;\n        indices = svadd_u64(pg, indices, svdup_n_u64(stride * vl));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t largest_divisor_simd(uint64_t n){\n    uint64_t result = 0;\n    if (n <= 1) return result;\n\n    svbool_t pg = svptrue_b64();\n    uint64_t index = n - 1;\n    svuint64_t vec_index = svdup_n_u64(index);\n    svuint64_t vec_n = svdup_n_u64(n);\n\n    do {\n        svuint64_t remainder = svmod_u64(pg, vec_n, vec_index);\n        svbool_t is_zero = svcmpeq_m(pg, remainder, svdup_n_u64(0));\n        uint64x2_t min_result = svminv_u64(pg, vec_index);\n        if (svptest_any(svptrue_b64(), is_zero)) {\n            result = min_result[0];\n            break;\n        }\n        index -= svcntd();\n        vec_index = svsub_n_u64(pg, vec_index, svcntd());\n    } while (index > 0);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t largest_divisor_simd(uint64_t n){\n    uint64_t result = 0;\n    if (n <= 1) return result;\n\n    svbool_t pg = svptrue_b64();\n    uint64_t vl = svcntd();\n    uint64_t max_index = n / 2;\n\n    // Create a vector with values from 1 to vl\n    svuint64_t indices = svizero(pg);\n    svuint64_t step = svdup_n_u64(pg, 1);\n    svuint64_t candidates = svadd_x(pg, indices, step);\n\n    uint64x2_t remainder;\n    uint64_t temp_result;\n\n    for (uint64_t i = 0; i < max_index; i += vl) {\n        svuint64_t current = svadd_x(pg, candidates, svdup_n_u64(pg, i));\n        svuint64_t mod_results = svmul_x(pg, current, svdup_n_u64(pg, n));\n        mod_results = svsdiv_x(pg, mod_results, svdup_n_u64(pg, n));\n\n        svbool_t is_zero = svcmpeq(pg, mod_results, svdup_n_u64(pg, 0));\n        svuint64_t valid = svsel(is_zero, current, svdup_n_u64(pg, 0));\n\n        uint64_t max_valid = svmaxv_u64(pg, valid);\n        if (max_valid > result) result = max_valid;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n < 2) return factors;\n\n    int original_n = n;\n    svbool_t pg = svptrue_b32();\n    int32x4_t v_factor = svdup_n_s32(2);\n    int32x4_t v_n = svdup_n_s32(n);\n\n    while (true) {\n        int32x4_t v_rem = svmoda_x_s32(pg, v_n, v_factor);\n        svbool_t pred = svcmpeq_any_s32(v_rem, svdup_n_s32(0));\n        if (svptest_any(svptrue_b32(), pred)) {\n            int factor = svindex_s32(0, 1)[0];\n            factors.push_back(factor);\n            v_n = svdiv_x_s32(pg, v_n, v_factor);\n            n = svget_lane_s32(v_n, 0);\n            if (n == 1) break;\n        } else {\n            int current_factor = svget_lane_s32(v_factor, 0);\n            int next_factor = current_factor + 1;\n            v_factor = svdup_n_s32(next_factor);\n        }\n    }\n\n    // Verify the product of factors equals the original number\n    int product = 1;\n    for (int factor : factors) {\n        product *= factor;\n    }\n    if (product != original_n) return {};\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n < 2) return factors;\n\n    int original_n = n;\n    svbool_t pg = svptrue_b32();\n    int32x4_t v_factor = svdup_n_s32(2);\n\n    while (n > 1) {\n        int count = 0;\n        while (true) {\n            int32x4_t v_n = svdup_n_s32(n);\n            int32x4_t v_mod = svmla_s32(pg, v_n, svdup_n_s32(-n), v_factor);\n            int32x4_t v_zero = svdup_n_s32(0);\n            svbool_t pred = svcmpeq(pg, v_mod, v_zero);\n            if (svptest_any(pg, pred)) {\n                count++;\n                n /= svindex_s32(0, 1)[0];\n            } else {\n                break;\n            }\n        }\n        if (count > 0) {\n            for (int i = 0; i < count; ++i) {\n                factors.push_back(svindex_s32(0, 1)[0]);\n            }\n        }\n        svbool_t pred = svcmplt(pg, v_factor, svdup_n_s32(original_n));\n        if (!svptest_any(pg, pred)) break;\n        v_factor = svadd(pg, v_factor, svdup_n_s32(1));\n    }\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n < 2) return factors;\n\n    int original_n = n;\n    svbool_t pg = svptrue_b32();\n    int32x4_t v_factor = svdup_n_s32(2);\n\n    while (n > 1) {\n        int count = 0;\n        while (true) {\n            int32x4_t v_n = svdup_n_s32(n);\n            int32x4_t v_mod = svmoda_s32(pg, v_n, v_factor);\n            int32x4_t v_zero = svdup_n_s32(0);\n            svbool_t pred = svcmpeq(pg, v_mod, v_zero);\n            int32x4_t v_res = svsuba_s32(pg, v_n, svand_s32(pred, v_factor, v_factor));\n            n = svfirst_s32(v_res);\n            if (!svptrue_any_b32(pg, pred)) break;\n            count++;\n        }\n        if (count > 0) {\n            for (int i = 0; i < count; ++i) {\n                factors.push_back(svfirst_s32(v_factor));\n            }\n        }\n        int32x4_t v_next = svadd_n_s32(pg, v_factor, 1);\n        v_factor = svsel_s32(pg, v_next, v_factor);\n        if (svany_gte_s32(pg, v_factor, svdup_n_s32(original_n))) break;\n    }\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n < 2) return factors;\n\n    int original_n = n;\n    svbool_t pg = svptrue_b32();\n    int factor = 2;\n\n    while (factor * factor <= n) {\n        svint32_t sfactor = svdup_n_s32(pg, factor);\n        svint32_t sn = svdup_n_s32(pg, n);\n\n        // Check divisibility\n        svbool_t is_divisible = svceq_m(pg, svmodi_s32(pg, sn, sfactor), svdup_n_s32(pg, 0));\n\n        if (svptest_any(svptrue_b32(), is_divisible)) {\n            factors.push_back(factor);\n            n /= factor;\n        } else {\n            factor++;\n        }\n    }\n\n    if (n > 1) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n <= 1) return factors;\n\n    int original_n = n;\n    svbool_t pg = svptrue_b32();\n    int32x4_t divisors = {2, 3, 5, 7};\n\n    while (n > 1) {\n        int32x4_t count = svdup_n_s32(0);\n        svbool_t pred = svptrue_b32();\n        for (int i = 0; i < 4; ++i) {\n            int divisor = svindex_s32(i, 1);\n            int remainder = n % divisor;\n            pred = svcmp_eq_u32(pg, remainder, 0);\n            if (svptest_any(svptrue_b8(), pred)) {\n                n /= divisor;\n                factors.push_back(divisor);\n                break;\n            }\n        }\n        if (!pred) {\n            int d = 11;\n            while (d * d <= n) {\n                if (n % d == 0) {\n                    factors.push_back(d);\n                    n /= d;\n                    break;\n                }\n                d += 2;\n            }\n            if (d * d > n && n > 1) {\n                factors.push_back(n);\n                n = 1;\n            }\n        }\n    }\n    return factors;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l){\n    std::vector<float> result;\n    if (l.empty()) return result;\n\n    size_t vec_size = l.size();\n    svbool_t pg = svptrue_b32();\n    const float *data = l.data();\n\n    size_t i = 0;\n    // Process vectors\n    for (; i + svcntw() <= vec_size; i += svcntw()) {\n        svfloat32_t svec = svld1(pg, &data[i]);\n        svbool_t mask = svcmpgt_f32(pg, svec, svdup_f32(0.0f));\n        svfloat32_t filtered = svsel(mask, svec, svdup_f32(0.0f));\n        \n        // Extract active lanes and store in result\n        for (int j = 0; j < svcntw(); ++j) {\n            if (svindex_b32(j) && svmovemask(mask)) {\n                result.push_back(filtered[j]);\n            }\n        }\n    }\n\n    // Process leftovers\n    for (; i < vec_size; ++i) {\n        if (data[i] > 0.0f) {\n            result.push_back(data[i]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l){\n    std::vector<float> result;\n    if (l.empty()) return result;\n\n    size_t vec_size = l.size();\n    float *data = const_cast<float*>(l.data());\n    svbool_t pg = svptrue_b32();\n\n    size_t i = 0;\n    svfloat32_t zero = svdup_n_f32(0.0f);\n    while (i + svcntw() <= vec_size) {\n        svfloat32_t vec = svld1(pg, &data[i]);\n        svbool_t mask = svcmpgt_f32(pg, vec, zero);\n        svst1(mask, &data[i], vec);\n        i += svcntw();\n    }\n\n    for (; i < vec_size; ++i) {\n        if (data[i] > 0.0f) {\n            result.push_back(data[i]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l){\n    std::vector<float> result;\n    if (l.empty()) return result;\n\n    size_t vec_size = l.size();\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    size_t i = 0;\n    for (; i + vl <= vec_size; i += vl) {\n        svfloat32_t vec = svld1(pg, &l[i]);\n        svbool_t mask = svcmpgt_f32(pg, vec, svdup_f32(0.0f));\n        size_t num_active = svcntp_b32(mask);\n        result.reserve(result.size() + num_active);\n\n        float temp[svlen_b32 / sizeof(float)];\n        svst1(mask, temp, vec);\n        for (size_t j = 0; j < vl; ++j) {\n            if (svptest_any(svptrue_b32(), svand_b32(mask, svindex_z(pg, j)))) {\n                result.push_back(temp[j]);\n            }\n        }\n    }\n\n    // Handle leftover elements\n    for (; i < vec_size; ++i) {\n        if (l[i] > 0) {\n            result.push_back(l[i]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l){\n    size_t vec_size = l.size();\n    if (vec_size == 0) return {};\n\n    // Determine the SVE vector length in floats\n    size_t vl = svcntw() / sizeof(float);\n\n    std::vector<float> result;\n    result.reserve(vec_size);\n\n    const float *data = l.data();\n    size_t i = 0;\n\n    // Process vectors\n    for (; i <= vec_size - vl; i += vl) {\n        svbool_t pg = svptrue_b32(); // Predicate for full vector\n        svfloat32_t v = svld1(pg, &data[i]); // Load vector\n        svbool_t pred = svcmpgt_f32(pg, v, svdup_n_f32(0.0f)); // Compare > 0\n        svfloat32_t filtered = svsel_f32(pred, v, svdup_n_f32(0.0f)); // Select positives\n\n        // Extract and store positive values\n        float temp[vl];\n        svst1(pg, temp, filtered);\n        for (size_t j = 0; j < vl; ++j) {\n            if (temp[j] > 0.0f) result.push_back(temp[j]);\n        }\n    }\n\n    // Process leftovers\n    for (; i < vec_size; ++i) {\n        if (data[i] > 0.0f) result.push_back(data[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l){\n    std::vector<float> result;\n    if (l.empty()) return result;\n\n    size_t vec_size = l.size();\n    const float *data = l.data();\n\n    svbool_t pg = svptrue_b32();\n    size_t index = 0;\n\n    while (index <= vec_size - svcntw()) {\n        svfloat32_t vec = svld1(pg, &data[index]);\n        svbool_t mask = svcmpgt_f32(pg, vec, svdup_f32(0.0f));\n        size_t active_len = svcntw();\n\n        float temp[svcntw()];\n        svst1(mask, temp, vec);\n\n        for (size_t i = 0; i < active_len; ++i) {\n            if (svptest_any(svptrue_b8(), mask)) {\n                result.push_back(temp[i]);\n            }\n        }\n        index += active_len;\n    }\n\n    // Handle leftover elements\n    for (; index < vec_size; ++index) {\n        if (data[index] > 0) {\n            result.push_back(data[index]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool is_prime_simd(int64_t n){\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if ((n % 2) == 0 || (n % 3) == 0) return false;\n\n    int64_t limit = (int64_t)svlmax_b64();\n    limit = (int64_t)(sqrt((double)n));\n    \n    svbool_t pg = svptrue_b64();\n    svint64_t vec_n = svdup_n_s64(n);\n\n    for (int64_t i = 5; i <= limit; i += 6) {\n        svint64_t vec_i = svdup_n_s64(i);\n        svint64_t rem1 = svmod_x_s64(pg, vec_n, vec_i);\n        svint64_t rem2 = svmod_x_s64(pg, vec_n, svadd_n_s64(vec_i, 2));\n        \n        svbool_t pred1 = svcmpeq_s64(pg, rem1, svdup_n_s64(0));\n        svbool_t pred2 = svcmpeq_s64(pg, rem2, svdup_n_s64(0));\n        \n        if (svptest_any(svptrue_b1(), pred1) || svptest_any(svptrue_b1(), pred2)) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```c\n#include <arm_sve.h> \n\nbool is_prime_simd(int64_t n){\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if ((n % 2) == 0 || (n % 3) == 0) return false;\n\n    int64_t limit = (int64_t)svsqrt_x(svdup_n_s64(n), svtrue());\n    limit += (limit % 2 == 0) ? 1 : 0;\n\n    svbool_t pg = svptrue_b64();\n    svbool_t pred = svwhilelt_b64(5, limit);\n    int64x2_t factors = svdup_n_s64(5);\n\n    while (svptest_any(svptrue_b64(), pred)) {\n        int64x2_t mod_results = svmla_s64(pg, factors, svdup_n_s64(0), svdup_n_s64(n));\n        svbool_t divisible = svceq_z(pg, mod_results, svdup_n_s64(0));\n        if (svptest_any(divisible, pred)) return false;\n\n        factors = svadd_x(pg, factors, svdup_n_s64(6));\n        pred = svwhilelt_b64(svgetelt_s64(factors, 0), limit);\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```c\n#include <arm_sve.h> \n\nbool is_prime_simd(int64_t n){\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if ((n % 2 == 0) || (n % 3 == 0)) return false;\n\n    int64_t limit = (int64_t)svmin_b64(n * n > 9 ? svsqrt_x(svptrue_b64(), n * n) : 3);\n\n    svbool_t pg = svptrue_b64();\n    svbool_t pred = svcmpge(pg, svindex_z(pg, 5, 1), svdup_n_s64(1));\n    svbool_t valid = svwhilelt_b64(5, limit + 1);\n\n    int64x2_t factors = svdup_n_s64(0);\n    int64_t i = 5;\n\n    do {\n        int64_t remainder = n % i;\n        pred = svcmpeq(pg, svdup_n_s64(remainder), svdup_n_s64(0));\n        factors = svsel(pred, svdup_n_s64(i), factors);\n\n        i += 2;\n        valid = svwhilelt_b64(i, limit + 1);\n    } while (!svbrkpa(valid, pred));\n\n    return svaddv(pg, factors) == 0;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```c\n#include <arm_sve.h> \n\nbool is_prime_simd(int64_t n){\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if ((n % 2) == 0 || (n % 3) == 0) return false;\n\n    int64_t limit = (int64_t)svsqrt_x(svdup_n_s64(n), n);\n    limit += 1; // Ensure we test up to the integer part of the square root\n\n    svbool_t pg = svptrue_b64();\n    svbool_t pred = svcmpge(pg, svindex_s64(5, 1), svdup_n_s64(limit));\n\n    int64x2_t mod_results;\n    while (svptest_any(svptrue_b64(), pred)) {\n        mod_results = svmla_x(pg, svindex_s64(5, 1), svdup_n_s64(n), svdup_n_s64(0));\n        if (svptest_any(pg, svcmpeq(pg, mod_results, svdup_n_s64(0)))) {\n            return false;\n        }\n        pred = svand_x(pg, pred, svcmpge(pg, svadd_x(pg, svindex_s64(5, 1), svdup_n_s64(6)), svdup_n_s64(limit)));\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```c\n#include <arm_sve.h> \n\nbool is_prime_simd(int64_t n){\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if ((n % 2) == 0 || (n % 3) == 0) return false;\n\n    int64_t limit = (int64_t)svminv_n_s64(n, svsqrt_f64(svptrue_b64(), (float64_t)n));\n    svbool_t pg = svptrue_b64();\n    int64x1_t result = {1};\n\n    for (int64_t i = 5; i <= limit; i += 6){\n        svbool_t pred = svcmpge(pg, svindex_z(pg, i), svdup_n_s64(0));\n        int64x1_t mod1 = svaddv(pg, svmla_x(pred, svdup_n_s64(n), svindex_z(pg, i), svdup_n_s64(0)));\n        int64x1_t mod2 = svaddv(pg, svmla_x(pred, svdup_n_s64(n), svindex_z(pg, i + 2), svdup_n_s64(0)));\n\n        result = svand_x(pg, result, svand_x(pg, svcmpeq_x(pg, mod1, svdup_n_s64(0)), svcmpeq_x(pg, mod2, svdup_n_s64(0))));\n        \n        if (svptest_any(svptrue_b64(), result) == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cstring>\n#include <string>\n\nstd::string solve_simd(const std::string & s){\n    int len = s.length();\n    if (len == 0) return \"\";\n\n    // Determine the maximum vector length\n    svbool_t pg = svptrue_b8();\n    size_t vl = svcntb();\n\n    // Convert input string to char array\n    const char *input = s.c_str();\n    char *output = new char[len + 1];\n    std::memset(output, 0, len + 1);\n\n    bool has_letter = false;\n\n    for (size_t i = 0; i < len; i += vl) {\n        svbool_t active = svwhilelt_b8(i, len);\n        svuint8_t vec = svld1_u8(active, reinterpret_cast<const uint8_t *>(input + i));\n\n        // Check for letters and toggle case\n        svbool_t is_lower = svand_b8(active, svcmpeq_b8(vec, 'a', 'z'));\n        svbool_t is_upper = svand_b8(active, svcmpeq_b8(vec, 'A', 'Z'));\n\n        has_letter |= svptest_any(svptrue_b8(), svor_b8(is_lower, is_upper));\n\n        svuint8_t toggled = svsel_u8(is_lower, svsub_u8(vec, ' '), svadd_u8(vec, ' '));\n        svst1_u8(active, reinterpret_cast<uint8_t *>(output + i), toggled);\n    }\n\n    if (!has_letter) {\n        // Reverse the string\n        for (size_t i = 0; i < len / 2; ++i) {\n            std::swap(output[i], output[len - i - 1]);\n        }\n    }\n\n    output[len] = '\\0';\n    std::string result(output);\n    delete[] output;\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n\nstd::string solve_simd(const std::string & s){\n    int len = s.length();\n    if (len == 0) return \"\";\n\n    // Determine the maximum vector length in bytes\n    svbool_t pg = svptrue_b8();\n    size_t vl = svcntb();\n\n    // Convert input string to a vector of chars\n    std::vector<char> result(s.begin(), s.end());\n    size_t i = 0;\n\n    bool has_letter = false;\n\n    while (i < len) {\n        size_t chunk_size = len - i;\n        svbool_t pg_chunk = svwhilelt_b8(i, len);\n\n        // Load data into SVE register\n        svuint8_t vec = svld1(pg_chunk, reinterpret_cast<const uint8_t*>(&s[i]));\n\n        // Check for alphabetic characters\n        svbool_t is_alpha = svand(pg_chunk, svcmpeq(pg_chunk, svand_v(vec, 0x80 - 1), svor_v(svcmpge_z(pg_chunk, vec, 'A'), svcmple_z(pg_chunk, vec, 'Z'))));\n        is_alpha = svbor(pg_chunk, is_alpha, svcmpeq(pg_chunk, svand_v(vec, 0x80 - 1), svor_v(svcmpge_z(pg_chunk, vec, 'a'), svcmple_z(pg_chunk, vec, 'z'))));\n\n        // Toggle case for alphabetic characters\n        svuint8_t toggled = sveor_z(pg_chunk, vec, svdup_n_u8(' '));\n        vec = svsel(is_alpha, toggled, vec);\n\n        // Store results back\n        svst1(pg_chunk, reinterpret_cast<uint8_t*>(&result[i]), vec);\n\n        // Check if there are any letters in this chunk\n        has_letter |= svptest_any(svptrue_b1(), is_alpha);\n\n        i += svcntb();\n    }\n\n    // If no letters were found, reverse the string\n    if (!has_letter) {\n        std::reverse(result.begin(), result.end());\n    }\n\n    return std::string(result.begin(), result.end());\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n\nstd::string solve_simd(const std::string & s){\n    int len = s.length();\n    if (len == 0) return s;\n\n    // Allocate result buffer\n    std::string result(s);\n\n    svbool_t pg = svptrue_b8();\n    size_t index = 0;\n    size_t vec_len = svcntb();\n\n    while (index < len) {\n        size_t slice = len - index;\n        svbool_t pred = svwhilelt_b8(index, len);\n        \n        // Load characters\n        svuint8_t chars = svld1_u8(pred, reinterpret_cast<const uint8_t*>(&s[index]));\n\n        // Check for alphabetic characters\n        svbool_t is_alpha = svand_b8(svcmpeq_b8_m(pg, svurot_r_u8(chars, 'A'), svurot_r_u8('Z', 'A')), \n                                    svcmpge_b8_m(pg, chars, 'A'));\n\n        is_alpha = svbor_b8(is_alpha, svcmpeq_b8_m(pg, svurot_r_u8(chars, 'a'), svurot_r_u8('z', 'a')));\n\n        // Toggle case for alphabetic characters\n        svuint8_t toggled = svsub_u8_m(pg, chars, svsel_u8(is_alpha, svdup_n_u8(' '), svdup_n_u8(0)));\n        toggled = svadd_u8_m(pg, toggled, svsel_u8(is_alpha, svdup_n_u8(' '), svdup_n_u8(0)));\n\n        // Check if there are any letters in this vector\n        bool has_letters = svptest_any(svptrue_b8(), is_alpha);\n\n        // Store the results conditionally\n        svst1_u8(pred, reinterpret_cast<uint8_t*>(&result[index]), toggled);\n\n        // If no letters in the entire string, reverse it\n        if (!has_letters && index + vec_len >= len) {\n            for(int i = 0; i < len / 2; ++i){\n                char temp = result[i];\n                result[i] = result[len - i - 1];\n                result[len - i - 1] = temp;\n            }\n        }\n\n        index += vec_len;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n\nstd::string solve_simd(const std::string & s){\n    int len = s.length();\n    if (len == 0) return \"\";\n\n    svbool_t pg = svptrue_b8();\n    size_t vl = svcntb();\n    size_t num_iters = (len + vl - 1) / vl;\n\n    std::string result(s);\n\n    bool has_letter = false;\n    for (size_t i = 0; i < num_iters; ++i) {\n        size_t index = i * vl;\n        size_t count = len - index > vl ? vl : len - index;\n\n        svuint8_t vec = svld1(pg, reinterpret_cast<const uint8_t*>(&s[index]));\n        svuint8_t toggled = svsel(svucmpw(pg, vec, 'a', SV_GRE), svsub_u8(vec, ' '), vec);\n        toggled = svsel(svucmpw(pg, toggled, 'A', SV_GRE), svadd_u8(toggled, ' '), toggled);\n\n        svuint8_t is_letter = svorr_b8(svucmppg(pg, toggled, 'a', SV_LTE), svucmppg(pg, toggled, 'A', SV_LTE));\n        has_letter = has_letter || svptest_any(svptrue_b8(), is_letter);\n\n        svst1(pg, reinterpret_cast<uint8_t*>(&result[index]), toggled);\n    }\n\n    if (!has_letter) {\n        result = std::string(s.rbegin(), s.rend());\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cstring>\n#include <string>\n\nstd::string solve_simd(const std::string & s){\n    int len = s.length();\n    if (len == 0) return \"\";\n\n    // Determine the maximum vector length in bytes\n    svbool_t pg = svptrue_b8();\n    size_t vl = svcntb();\n\n    // Convert input string to mutable char array\n    std::string result(s);\n    char *data = const_cast<char*>(result.data());\n\n    bool has_letter = false;\n    svuint8_t zero = svdup_n_u8(0);\n\n    for (size_t i = 0; i < len; i += vl) {\n        size_t chunk_size = len - i > vl ? vl : len - i;\n\n        // Load data\n        svuint8_t vec = svld1(pg, reinterpret_cast<const uint8_t*>(&data[i]));\n\n        // Check for alphabetic characters\n        svbool_t is_alpha = svand_b8(pg, svcmpge_b8(pg, vec, 'a'), svcmple_b8(pg, vec, 'z'));\n        is_alpha = svbor_b8(pg, is_alpha, svand_b8(pg, svcmpge_b8(pg, vec, 'A'), svcmple_b8(pg, vec, 'Z')));\n\n        // Toggle case\n        svuint8_t toggled = svsub_x(pg, vec, svdup_n_u8(' '));\n        svsel_u8(pg, vec, toggled, svnot_b8(pg, is_alpha));\n\n        // Store back\n        svst1(pg, reinterpret_cast<uint8_t*>(&data[i]), svsel_u8(pg, toggled, vec, is_alpha));\n\n        // Check if there are any letters\n        has_letter |= svptest_any(svptrue_b8(), is_alpha);\n    }\n\n    // If no letters, reverse the string\n    if (!has_letter) {\n        for(int i = 0; i < len / 2; ++i){\n            char temp = data[i];\n            data[i] = data[len - i - 1];\n            data[len - i - 1] = temp;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n == 0) return {};\n\n    // Extract elements at indices divisible by 3\n    std::vector<int> div_by_three;\n    for (size_t i = 0; i < n; ++i) {\n        if ((i % 3) == 0) {\n            div_by_three.push_back(l[i]);\n        }\n    }\n\n    // Sort the extracted elements\n    std::sort(div_by_three.begin(), div_by_three.end());\n\n    // Create an SVE predicate for indices divisible by 3\n    svbool_t pg = svptrue_b32();\n    svint32_t sorted_vec;\n\n    size_t sorted_idx = 0;\n    for (size_t i = 0; i < n; i += svcntw()) {\n        size_t k = std::min(n - i, (size_t)svcntw());\n        svbool_t pred = svwhilelt_b32(i, n);\n        svint32_t vl = svld1_z(pred, &l[i]);\n\n        // Replace elements where index is divisible by 3\n        for (size_t j = 0; j < k; ++j) {\n            if ((i + j) % 3 == 0) {\n                int val = div_by_three[sorted_idx++];\n                vl = svinsert_n_s32(vl, j, val);\n            }\n        }\n\n        svst1(pred, &l[i], vl);\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l){\n    size_t n = l.size();\n    if (n == 0) return l;\n\n    // Find the maximum index divisible by 3 to determine the number of elements to sort\n    size_t max_index = n / 3;\n    if (max_index == 0) return l;\n\n    // Collect indices divisible by 3\n    std::vector<int> divisible_by_three;\n    for (size_t i = 0; i < n; i += 3) {\n        divisible_by_three.push_back(l[i]);\n    }\n\n    // Sort the collected elements\n    std::sort(divisible_by_three.begin(), divisible_by_three.end());\n\n    // Create an SVE predicate for indices divisible by 3\n    svbool_t pg = svptrue_b32();\n    svint32_t vec_sorted = svdup_n_s32(0);\n\n    size_t vec_len = svcntw(); // Vector length in terms of elements\n    size_t num_iters = (n + vec_len - 1) / vec_len;\n\n    for (size_t iter = 0; iter < num_iters; ++iter) {\n        size_t start_idx = iter * vec_len;\n        size_t end_idx = std::min(start_idx + vec_len, n);\n\n        // Load a vector chunk from l\n        svint32_t vec_l = svld1(pg, &l[start_idx]);\n\n        // Create a predicate for indices divisible by 3 in this chunk\n        svbool_t pred_div_three = svfalse_b32();\n        for (size_t j = start_idx; j < end_idx; ++j) {\n            if ((j % 3) == 0) {\n                size_t offset = j - start_idx;\n                pred_div_three = svsetbit_b32(pred_div_three, offset);\n            }\n        }\n\n        // Replace elements at indices divisible by 3 with sorted values\n        size_t sorted_idx = start_idx / 3;\n        for (size_t j = start_idx; j < end_idx && sorted_idx < divisible_by_three.size(); ++j, ++sorted_idx) {\n            if ((j % 3) == 0) {\n                size_t offset = j - start_idx;\n                vec_sorted = svinsert_s32(vec_sorted, offset, divisible_by_three[sorted_idx]);\n            }\n        }\n\n        // Merge the original vector with the sorted values\n        svst1(pg, &l[start_idx], svsel(pred_div_three, vec_sorted, vec_l));\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l){\n    size_t vec_size = l.size();\n    if (vec_size == 0) return l;\n\n    // Determine SVE vector length\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    // Create a vector of elements at indices divisible by 3\n    std::vector<int> div_by_three;\n    for (size_t i = 0; i < vec_size; ++i) {\n        if ((i % 3) == 0) {\n            div_by_three.push_back(l[i]);\n        }\n    }\n\n    // Sort the extracted vector\n    std::sort(div_by_three.begin(), div_by_three.end());\n\n    // Replace the original elements with sorted values\n    size_t div_idx = 0;\n    for (size_t i = 0; i < vec_size; ++i) {\n        if ((i % 3) == 0) {\n            l[i] = div_by_three[div_idx++];\n        }\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n == 0) return {};\n\n    // Extract elements at indices divisible by three\n    std::vector<int> div_by_three;\n    for (size_t i = 0; i < n; i++) {\n        if ((i % 3) == 0) {\n            div_by_three.push_back(l[i]);\n        }\n    }\n\n    // Sort the extracted elements\n    std::sort(div_by_three.begin(), div_by_three.end());\n\n    // Create an SVE predicate for indices divisible by three\n    svbool_t pg = svptrue_b32();\n    size_t idx = 0;\n\n    // Iterate over the vector in chunks to apply SVE operations\n    for (size_t i = 0; i < n; i += svcntw()) {\n        size_t chunk_size = std::min(svcntw(), n - i);\n\n        // Load a chunk of data\n        svint32_t vl = svld1(pg, &l[i]);\n\n        // Create a predicate for indices divisible by three in this chunk\n        svbool_t p_div_by_three = svcmpeq(pg, (i + svindex_n_u32(0, 1)) % 3, svdup_n_u32(0));\n\n        // Replace values at indices divisible by three with sorted values\n        svst1(p_div_by_three, &l[i], svins_m(p_div_by_three, vl, svdup_n_s32(div_by_three[idx])));\n        idx += svcntw() / 3; // Increment only for divisible indices\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t vec_size = l.size();\n    if (vec_size == 0) return {};\n\n    // Extract elements at indices divisible by three\n    std::vector<int> div_by_three;\n    for (size_t i = 0; i < vec_size; ++i) {\n        if (i % 3 == 0) {\n            div_by_three.push_back(l[i]);\n        }\n    }\n\n    // Sort the extracted elements\n    std::sort(div_by_three.begin(), div_by_three.end());\n\n    // Create an SVE predicate for indices divisible by three\n    svbool_t pg = svptrue_b32();\n    size_t index = 0;\n\n    // Iterate over the vector in chunks to apply SVE operations\n    for (size_t i = 0; i < vec_size; i += svcntw()) {\n        size_t chunk_size = std::min(svlen() / sizeof(int), static_cast<size_t>(vec_size - i));\n        svbool_t pred = svfalse();\n\n        for (size_t j = 0; j < chunk_size; ++j) {\n            if ((i + j) % 3 == 0) {\n                pred = svset_bit(pred, j);\n            }\n        }\n\n        svint32_t vl = svld1(pg, &l[i]);\n        svint32_t sorted_vals = svdup_n_s32(0);\n\n        size_t k = 0;\n        for (size_t j = 0; j < chunk_size; ++j) {\n            if (svtest_bit(pred, j)) {\n                sorted_vals = svinsert(sorted_vals, k++, div_by_three[index++]);\n            }\n        }\n\n        vl = svsel(pred, sorted_vals, vl);\n        svst1(pg, &l[i], vl);\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cfloat>\n\nfloat max_element_simd(std::vector<float> l){\n    size_t n = l.size();\n    if (n == 0) return FLT_MIN;\n\n    const float *data = l.data();\n    svbool_t pg = svptrue_b32();\n    svfloat32_t vmax = svdup_f32(pg, FLT_MIN);\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        size_t j = n - i;\n        svbool_t pred = svptrue_b32();\n        if (j < svcntw()) {\n            pred = svwhilelt_b32(i, n);\n        }\n        svfloat32_t v = svld1_f32(pred, data + i);\n        vmax = svmax_f32(pg, vmax, v);\n    }\n\n    float result = FLT_MIN;\n    svfloat32_t vtemp = svdup_f32(pg, FLT_MIN);\n    size_t index = 0;\n    do {\n        vtemp = svmax_f32(pg, vtemp, svindex_f32(index, svcntw()));\n        index += svcntw();\n    } while (index < n);\n\n    svst1_f32(svptrue_b32(), &result, vmax);\n    return result;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nfloat max_element_simd(std::vector<float> l){\n    size_t n = l.size();\n    if (n == 0) return std::numeric_limits<float>::quiet_NaN();\n\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n    size_t i = 0;\n    float current_max = -std::numeric_limits<float>::infinity();\n\n    svfloat32_t vmax = svdup_f32(pg, current_max);\n\n    for (; i <= n - vl; i += vl) {\n        svfloat32_t vec = svld1_f32(pg, &l[i]);\n        vmax = svmaxv_f32(pg, vmax, vec);\n    }\n\n    current_max = svmaxv_f32(pg, vmax);\n\n    for (; i < n; ++i) {\n        if (l[i] > current_max) {\n            current_max = l[i];\n        }\n    }\n\n    return current_max;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cfloat>\n\nfloat max_element_simd(std::vector<float> l){\n    size_t n = l.size();\n    if (n == 0) return FLT_MIN;\n\n    const float *data = l.data();\n    svbool_t pg = svptrue_f32();\n    svfloat32_t vmax = svdup_f32(FLT_MIN);\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        size_t j = n - i;\n        svbool_t ptmp = svwhilelt_b32(i, n);\n        svfloat32_t vec = svld1(pg, data + i);\n        vmax = svmax_f32_m(pg, vmax, vec, ptmp);\n    }\n\n    float result = FLT_MIN;\n    svfloat32_t vtmp = svdup_f32(FLT_MIN);\n    size_t index = 0;\n\n    do {\n        vtmp = svmax_f32(vtmp, svindex_f32(index, index + 1));\n        index += svcntw();\n    } while (index < svcntw());\n\n    svst1(pg, &result, vmax);\n    return result;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <limits>\n\nfloat max_element_simd(std::vector<float> l){\n    size_t n = l.size();\n    if (n == 0) return std::numeric_limits<float>::quiet_NaN();\n\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n    size_t i = 0;\n\n    float current_max = -std::numeric_limits<float>::infinity();\n\n    while (i <= n - vl) {\n        svfloat32_t vec = svld1(pg, &l[i]);\n        svfloat32_t max_vec = svmax_n_f32(pg, vec, current_max);\n        current_max = svmovmax_f32(pg, current_max, max_vec);\n        i += vl;\n    }\n\n    // Process remaining elements\n    if (i < n) {\n        svbool_t pg_remainder = svwhilelt_b32(i, n);\n        svfloat32_t vec = svld1(pg_remainder, &l[i]);\n        svfloat32_t max_vec = svmax_n_f32(pg_remainder, vec, current_max);\n        current_max = svmovmax_f32(pg_remainder, current_max, max_vec);\n    }\n\n    return current_max;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <climits>\n\nfloat max_element_simd(std::vector<float> l){\n    size_t n = l.size();\n    if (n == 0) return NAN;\n\n    svbool_t pg = svptrue_f32();\n    float current_max = -FLT_MAX;\n    size_t i = 0;\n\n    // Process elements in vectorized chunks\n    for (; i <= n - svcntw(); i += svcntw()) {\n        svfloat32_t vec = svld1(pg, &l[i]);\n        svfloat32_t max_vec = svmax_n_f32(pg, vec, current_max);\n        current_max = svmaxv_f32(pg, max_vec);\n    }\n\n    // Handle any remaining scalar elements\n    for (; i < n; ++i) {\n        if (l[i] > current_max) {\n            current_max = l[i];\n        }\n    }\n\n    return current_max;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint fizz_buzz_simd(int n){\n    int count = 0;\n    svbool_t pg = svptrue_b32();\n    const int64_t limit = n;\n\n    for (int64_t i = 0; i < limit; i += svcntw()) {\n        svint32_t svi = svindex_s32(i, i + svcntw());\n        svbool_t div11 = svcmpeq_b32(svmod_u32(svi, 11), svdup_n_u32(0));\n        svbool_t div13 = svcmpeq_b32(svmod_u32(svi, 13), svdup_n_u32(0));\n        svbool_t pred = svbor_b32(div11, div13);\n        \n        // Mask values not less than 'n'\n        pred = svand_b32(pred, svclt_b32(svi, svdup_n_s32(n)));\n\n        // Convert to string and check for '7'\n        svuint32_t nums = svreinterpret_u32(pg, svi);\n        svuint32_t sevens = svdup_n_u32('7');\n        int lane_count = svcntw();\n\n        for (int j = 0; j < lane_count; ++j) {\n            if (svptest_any(pg, pred)) {\n                uint32_t val = svindex_s32(i + j, i + j + 1);\n                if (val >= n) break;\n                if (val % 11 == 0 || val % 13 == 0) {\n                    int temp = val;\n                    while (temp > 0) {\n                        if (temp % 10 == 7) {\n                            count++;\n                            break;\n                        }\n                        temp /= 10;\n                    }\n                }\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint fizz_buzz_simd(int n){\n    int count = 0;\n    svbool_t pg = svptrue_b32();\n    int vl = svcntw();\n    int inc = vl;\n    int i = 0;\n\n    for (; i <= n - inc; i += inc) {\n        svint32_t svi = svindex_s32(i, inc);\n        svint32_t mod11 = svmod_s32(pg, svi, 11);\n        svint32_t mod13 = svmod_s32(pg, svi, 13);\n\n        svbool_t pred1 = svcmpeq_b32(pg, mod11, svdup_n_s32(0));\n        svbool_t pred2 = svcmpeq_b32(pg, mod13, svdup_n_s32(0));\n        svbool_t pred = svlor_b32(pred1, pred2);\n\n        svint32_t filtered = svsel_s32(pred, svi, svdup_n_s32(-1));\n\n        // Check for digit '7'\n        svuint32_t digits_mask = svdup_n_u32(0x07070707);\n        svuint32_t tens_mask = svdup_n_u32(0x00FF00FF);\n        svuint32_t hundreds_mask = svdup_n_u32(0x0F0F0F0F);\n\n        svuint32_t abs_val = svasr_u32(pg, svreinterpret_u32(filtered), 0); \n        svuint32_t ones = svand_u32(pg, abs_val, svdup_n_u32(0x0000000F));\n        svuint32_t tmp = svshr_u32(pg, abs_val, svdup_n_u32(4)); \n        svuint32_t tens = svand_u32(pg, tmp, svdup_n_u32(0x0000000F));\n        svuint32_t hundreds = svand_u32(pg, svshr_u32(pg, abs_val, svdup_n_u32(8)), svdup_n_u32(0x0000000F));\n        svuint32_t thousands = svand_u32(pg, svshr_u32(pg, abs_val, svdup_n_u32(12)), svdup_n_u32(0x0000000F));\n\n        svbool_t ones_pred = svcmpeq_b32(pg, ones, svand_u32(pg, digits_mask, svdup_n_u32(0x0000000F)));\n        svbool_t tens_pred = svcmpeq_b32(pg, tens, svand_u32(pg, svshr_u32(pg, digits_mask, svdup_n_u32(4)), svdup_n_u32(0x0000000F)));\n        svbool_t hundreds_pred = svcmpeq_b32(pg, hundreds, svand_u32(pg, svshr_u32(pg, digits_mask, svdup_n_u32(8)), svdup_n_u32(0x0000000F)));\n        svbool_t thousands_pred = svcmpeq_b32(pg, thousands, svand_u32(pg, svshr_u32(pg, digits_mask, svdup_n_u32(12)), svdup_n_u32(0x0000000F)));\n\n        svbool_t final_pred = svlor_b32(ones_pred, svlor_b32(tens_pred, svlor_b32(hundreds_pred, thousands_pred)));\n        count += svpopcnt_b32(pg, final_pred);\n    }\n\n    for (; i < n; i++) {\n        if ((i % 11 == 0 || i % 13 == 0) && (int)(log10(i)+1) <= 9) {\n            int num = i;\n            while (num > 0) {\n                if (num % 10 == 7) {\n                    count++;\n                    break;\n                }\n                num /= 10;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint fizz_buzz_simd(int n){\n    int count = 0;\n    svbool_t pg = svptrue_b32();\n    int vl = svcntw();\n    int inc = vl;\n\n    for (int i = 0; i < n; i += inc) {\n        svint32_t svi = svseq_s32(pg, i);\n        svint32_t mod11 = svmod_s32(pg, svi, 11);\n        svint32_t mod13 = svmod_s32(pg, svi, 13);\n        svbool_t pred = svorr_b32(svcmpeq(pg, mod11, svdup_n_s32(0)), svcmpeq(pg, mod13, svdup_n_s32(0)));\n\n        svint32_t selected = svsel_s32(pred, svi, svdup_n_s32(-1));\n        svuint32_t digits = svand_x_u32(pg, svabsdup_x_u32(pg, selected), svdup_n_u32(0x07));\n\n        int predicate_count = svpopcnt_b32(pg, svcmpeq(pg, digits, svdup_n_u32('7')));\n        count += predicate_count;\n        \n        // Handle any elements that exceed the limit n\n        int max_in_vector = i + vl - 1;\n        if (max_in_vector >= n) {\n            inc = n - i;\n            if (inc <= 0) break;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint fizz_buzz_simd(int n){\n    int count = 0;\n    svbool_t pg = svptrue_b32();\n    const uint32_t step = svcntw(); // Vector length in terms of 32-bit elements\n\n    for (int i = 0; i < n; i += step) {\n        // Create a vector starting from i to i + step\n        svuint32_t indices = svindex_u32(i, i + step);\n\n        // Compute which numbers are divisible by 11 or 13\n        svbool_t div_11 = svceq_m_b32(pg, svmul_u32(pg, indices, 11), svadd_u32(pg, svmul_u32(pg, indices, 11), indices));\n        svbool_t div_13 = svceq_m_b32(pg, svmul_u32(pg, indices, 13), svadd_u32(pg, svmul_u32(pg, indices, 13), indices));\n        svbool_t valid = svorr_b32(div_11, div_13);\n\n        // Mask out numbers >= n\n        valid = svand_b32(valid, svclt_u32(pg, indices, n));\n\n        // Convert valid indices to their string representation and check for '7'\n        svuint32_t valid_indices = svsel_u32(valid, indices, svdup_n_u32(0));\n        int32x4_t vcount = svdup_n_s32(0);\n\n        for (int j = 0; j < step; j++) {\n            uint32_t val = svindex_n_u32(valid_indices, j);\n            if (val != 0 && (val % 11 == 0 || val % 13 == 0)) {\n                int temp = val;\n                while (temp > 0) {\n                    if (temp % 10 == 7) {\n                        count++;\n                        break;\n                    }\n                    temp /= 10;\n                }\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint fizz_buzz_simd(int n){\n    int count = 0;\n    svbool_t pg = svptrue_b32();\n    const uint32_t factor1 = 11;\n    const uint32_t factor2 = 13;\n\n    for (int i = 0; i < n; i += svcntw()) {\n        svuint32_t idx = svindex_u32(i, i + svcntw());\n        svuint32_t num = svand_x(pg, idx, svcmple_n_u32(idx, n - 1));\n\n        svuint32_t mod1 = svmod_u32(pg, num, factor1);\n        svuint32_t mod2 = svmod_u32(pg, num, factor2);\n\n        svbool_t pred = svorr_z(pg, svtst_u32(pg, mod1, svdup_n_u32(0)), svtst_u32(pg, mod2, svdup_n_u32(0)));\n        svuint32_t filtered = svsel_u32(pred, num, svdup_n_u32(0));\n\n        // Check for digit '7'\n        svuint32_t tens = svudiv_x(pg, filtered, svdup_n_u32(10));\n        svuint32_t ones = svmul_x(pg, tens, svdup_n_u32(10));\n        ones = svsub_x(pg, filtered, ones);\n\n        svbool_t is_seven_ones = svcmpeq_x(pg, ones, svdup_n_u32(7));\n        svbool_t is_seven_tens = svcmpeq_x(pg, tens, svdup_n_u32(7));\n\n        svbool_t is_seven = svorr_z(pg, is_seven_ones, is_seven_tens);\n        count += svpopcnt_b32(pg, is_seven);\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l){\n    size_t vec_size = l.size();\n    if (vec_size == 0) return l;\n\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    // Convert vector to array and process in-place\n    float *arr = l.data();\n\n    // Number of full vectors\n    size_t num_full_vecs = vec_size / vl;\n    size_t remainder = vec_size % vl;\n\n    // Extract even indices into a separate array\n    std::vector<float> evens;\n    for (size_t i = 0; i < vec_size; i += 2) {\n        evens.push_back(arr[i]);\n    }\n\n    // Sort the even indices\n    std::sort(evens.begin(), evens.end());\n\n    // Reassign sorted evens back to even indices\n    size_t even_idx = 0;\n    for (size_t i = 0; i < num_full_vecs; ++i) {\n        svfloat32_t vec_load = svld1_f32(pg, arr + i * vl);\n        svfloat32_t vec_update = vec_load;\n\n        for (size_t j = 0; j < vl; j += 2) {\n            svdup_f32_t val = svdup_n_f32(evens[even_idx++]);\n            vec_update = svinsert_f32(vec_update, vec_update, val, j);\n        }\n\n        svst1_f32(pg, arr + i * vl, vec_update);\n    }\n\n    // Handle remaining elements\n    if (remainder > 0) {\n        svbool_t pg_remainder = svwhilelt_b32(0, remainder);\n        svfloat32_t vec_load = svld1_f32(pg_remainder, arr + num_full_vecs * vl);\n        svfloat32_t vec_update = vec_load;\n\n        for (size_t j = 0; j < remainder; j += 2) {\n            if (even_idx < evens.size()) {\n                svdup_f32_t val = svdup_n_f32(evens[even_idx++]);\n                vec_update = svinsert_f32(vec_update, vec_update, val, j);\n            }\n        }\n\n        svst1_f32(pg_remainder, arr + num_full_vecs * vl, vec_update);\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l){\n    size_t vec_size = l.size();\n    if (vec_size == 0) return l;\n\n    // Determine the SVE vector length\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    // Create a copy of the original vector\n    std::vector<float> sorted_vec = l;\n\n    // Extract even indices elements into a separate vector\n    std::vector<float> even_elements;\n    for (size_t i = 0; i < vec_size; i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    // Sort the even indices elements\n    std::sort(even_elements.begin(), even_elements.end());\n\n    // Scatter the sorted even elements back into their positions\n    for (size_t i = 0; i < even_elements.size(); ++i) {\n        sorted_vec[2 * i] = even_elements[i];\n    }\n\n    return sorted_vec;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l){\n    size_t vec_size = l.size();\n    if (vec_size == 0) return l;\n\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    // Convert vector to array for SVE processing\n    float *arr = l.data();\n    size_t num_iterations = (vec_size + vl - 1) / vl;\n\n    for (size_t i = 0; i < num_iterations; ++i) {\n        svfloat32_t vec_load = svld1_f32(pg, arr + i * vl);\n\n        // Extract even indices\n        svbool_t even_pg = svand_b32(pg, sviseq_m_u32(pg, svindex_u32(0, 1), svdup_n_u32(0)));\n        svfloat32_t even_elements = svsel_f32(even_pg, vec_load, svdup_n_f32(0));\n\n        // Extract odd indices\n        svbool_t odd_pg = svnot_b32(even_pg);\n        svfloat32_t odd_elements = svsel_f32(odd_pg, vec_load, svdup_n_f32(0));\n\n        // Sort even elements\n        float even_arr[vl];\n        svst1_f32(pg, even_arr, even_elements);\n        std::sort(even_arr, even_arr + vl, [](float a, float b) { return a < b; });\n        svfloat32_t sorted_even = svld1_f32(pg, even_arr);\n\n        // Reconstruct the vector with sorted even and original odd elements\n        svfloat32_t result = svsel_f32(even_pg, sorted_even, odd_elements);\n        svst1_f32(pg, arr + i * vl, result);\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l){\n    size_t vec_size = l.size();\n    if (vec_size == 0) return l;\n\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    // Convert vector to array for SVE processing\n    float *arr = l.data();\n\n    // Process elements in chunks of vector length\n    for (size_t i = 0; i < vec_size; i += vl) {\n        size_t chunk_size = std::min(vl, vec_size - i);\n        svbool_t pred = svwhilelt_b32(i, i + chunk_size);\n\n        // Load vector\n        svfloat32_t vec = svld1_f32(pred, arr + i);\n\n        // Extract even indices within the current chunk\n        svbool_t even_pred = svand_b32(pred, svtbl_b32(svindex_z(pg, 0, 2), svtrue_gather_index()));\n        svfloat32_t even_vec = svdup_f32(0.0f);\n        even_vec = svsel_f32(even_pred, vec, even_vec);\n\n        // Count number of valid even elements\n        int num_even = svpopcnt_b32(svmov_b32(even_pred));\n\n        // Store even elements into a temporary buffer\n        float temp_buffer[num_even];\n        svst1_scatter_offset_f32(pg, temp_buffer, even_vec, svindex_s32(0, sizeof(float)));\n\n        // Sort the temporary buffer\n        std::sort(temp_buffer, temp_buffer + num_even);\n\n        // Reload sorted values back into the vector at even positions\n        svbool_t sorted_even_pred = svand_b32(pred, svtbl_b32(svindex_z(pg, 0, 2), svtrue_gather_index()));\n        svfloat32_t sorted_even_vec = svld1_f32(pg, temp_buffer);\n        vec = svsel_f32(sorted_even_pred, sorted_even_vec, vec);\n\n        // Store the updated vector back to memory\n        svst1_f32(pred, arr + i, vec);\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l){\n    size_t n = l.size();\n    if (n == 0) return {};\n\n    // Determine the SVE vector length\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    // Create a copy of the input vector\n    std::vector<float> result = l;\n\n    // Extract even indices into a separate array\n    std::vector<float> even_elements;\n    for (size_t i = 0; i < n; i += 2) {\n        even_elements.push_back(l[i]);\n    }\n\n    // Sort the even elements\n    std::sort(even_elements.begin(), even_elements.end());\n\n    // Scatter the sorted even elements back into their positions\n    size_t even_idx = 0;\n    for (size_t i = 0; i < n; i += vl * 2) {\n        svbool_t pred = svcmp_eq_u32(pg, svindex_u32(i, i + vl), svand_u32(pg, svindex_u32(0, vl), svdup_n_u32(1)));\n        svfloat32_t sorted_vec = svld1(pg, &even_elements[even_idx]);\n        svst1_scatter_offset(pg, &result[0], sorted_vec, svindex_s64(i, i + vl * 2), sizeof(float));\n        even_idx += vl / 2;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l){\n    size_t n = l.size();\n    if (n < 3) return false;\n\n    svbool_t pg = svptrue_b32();\n    int *data = l.data();\n\n    for (size_t i = 0; i < n - 2; ++i) {\n        svint32_t svi = svdup_n_s32(data[i]);\n        for (size_t j = i + 1; j < n - 1; ++j) {\n            svint32_t svj = svdup_n_s32(data[j]);\n            svint32_t svk = svld1(pg, &data[j+1]);\n            svint32_t sum = svadd_x(pg, svadd_x(pg, svi, svj), svk);\n            svbool_t match = svcmpeq(pg, sum, svdup_n_s32(0));\n            if (svptest_any(svptrue_b32(), match)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nbool triples_sum_to_zero_simd(std::vector<int> l){\n    if (l.size() < 3) return false;\n\n    svbool_t pg = svptrue_b32();\n    size_t n = l.size();\n    int *data = l.data();\n\n    for (size_t i = 0; i < n - 2; ++i) {\n        for (size_t j = i + 1; j < n - 1; ++j) {\n            int sum_ij = data[i] + data[j];\n            svint32_t sv_sum_ij = svdup_n_s32(sum_ij);\n\n            // Load the rest of the array into a vector\n            size_t k = j + 1;\n            size_t vl = svcntw();\n            size_t num_iters = (n - k + vl - 1) / vl;\n\n            for (size_t it = 0; it < num_iters; ++it) {\n                svint32_t sv_k = svld1(pg, &data[k]);\n\n                // Compute the sum and check for zero\n                svbool_t result = svcmpeq(pg, svadd(pg, sv_sum_ij, sv_k), svdup_n_s32(0));\n                if (svptest_any(svptrue_b32(), result)) {\n                    return true;\n                }\n\n                k += vl;\n                if (k >= n) break;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 3)\n        return false;\n\n    int n = l.size();\n    svbool_t pg = svptrue_b32();\n    svint32_t zero = svdup_n_s32(0);\n\n    for (int i = 0; i < n - 2; ++i) {\n        for (int j = i + 1; j < n - 1; ++j) {\n            // Load elements for k-loop\n            svint32_t vsum = svdup_n_s32(l[i] + l[j]);\n            svint32_t vl = svld1_s32(pg, &l[j + 1]);\n\n            // Compute pairwise sums and check for zero\n            svint32_t vcmp = svadd_x_s32(pg, vsum, vl);\n            svbool_t result = svcmpeq_z(pg, vcmp, zero);\n\n            // Check if any element is true\n            if (svcntp_b32(pg, result) > 0)\n                return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 3) return false;\n\n    size_t n = l.size();\n    svbool_t pg = svptrue_b32();\n\n    for (size_t i = 0; i < n - 2; ++i) {\n        for (size_t j = i + 1; j < n - 1; ++j) {\n            int sum_ij = l[i] + l[j];\n            svint32_t sv_sum_ij = svdup_n_s32(sum_ij);\n\n            size_t k = j + 1;\n            size_t vl = svcntw(); // Vector length in terms of 32-bit elements\n            size_t num_iters = (n - k + vl - 1) / vl;\n\n            for (size_t it = 0; it < num_iters; ++it) {\n                size_t start_idx = k + it * vl;\n                size_t end_idx = start_idx + vl;\n                if (end_idx > n) end_idx = n;\n\n                svint32_t vec_k = svld1(pg, &l[start_idx]);\n                svint32_t cmp = svadd_x(pg, sv_sum_ij, vec_k);\n                svbool_t is_zero = svcmpeq(pg, cmp, svdup_n_s32(0));\n\n                if (svptest_any(svptrue_b32(), is_zero)) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 3) return false;\n\n    size_t n = l.size();\n    svbool_t pg = svptrue_b32();\n\n    for (size_t i = 0; i < n - 2; ++i) {\n        for (size_t j = i + 1; j < n - 1; ++j) {\n            int sum_ij = l[i] + l[j];\n            svint32_t sv_sum_ij = svdup_n_s32(sum_ij);\n\n            size_t k = j + 1;\n            size_t vl = svcntw();\n            size_t num_iters = (n - k + vl - 1) / vl;\n\n            for (size_t it = 0; it < num_iters; ++it) {\n                size_t start = k + it * vl;\n                size_t end = start + vl;\n                if (end > n) end = n;\n\n                svint32_t vec_k = svld1(pg, &l[start]);\n                svbool_t cmp_eq = svceq(pg, sv_sum_ij, svneg(vec_k));\n                if (svptest_any(svptrue_b32(), cmp_eq)) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l){\n    size_t vec_size = l.size();\n    if (vec_size == 0) return {};\n\n    svbool_t pg = svptrue_b32();\n    int *data = l.data();\n    size_t vl = svcntw(); // Vector length in terms of the number of 32-bit elements\n\n    size_t i = 0;\n    for (; i <= vec_size - vl; i += vl) {\n        svint32_t vec = svld1(pg, &data[i]);\n        svst1(pg, &data[i], svadd_n(pg, vec, 1));\n    }\n\n    // Handle remaining elements\n    if (i < vec_size) {\n        size_t remaining = vec_size - i;\n        svbool_t pg_pred = svwhilelt_b32(i, vec_size);\n        svint32_t vec = svld1(pg_pred, &data[i]);\n        svst1(pg_pred, &data[i], svadd_n(pg_pred, vec, 1));\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l){\n    size_t vec_size = l.size();\n    if (vec_size == 0) return {};\n\n    svbool_t pg = svptrue_b32();\n    int *data = l.data();\n\n    for (size_t i = 0; i < vec_size; i += svcntw()) {\n        svint32_t vec = svld1(pg, &data[i]);\n        svint32_t result = svadd(pg, vec, svdup_n_s32(1));\n        svst1(pg, &data[i], result);\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l){\n    size_t n = l.size();\n    if (n == 0) return {};\n\n    // Determine the maximum vector length\n    svbool_t pg = svptrue_b32();\n    int *data = &l[0];\n    \n    for (size_t i = 0; i < n; i += svcntw()) {\n        size_t k = n - i;\n        svbool_t pg_k = svwhilelt_b32(i, n);\n        \n        svint32_t vec = svld1(pg_k, data + i);\n        svint32_t res = svadd(pg_k, vec, svdup_n_s32(1));\n        svst1(pg_k, data + i, res);\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l){\n    size_t vec_size = l.size();\n    if (vec_size == 0) return {};\n\n    // Determine the maximum vector length supported by the hardware\n    svbool_t pg = svptrue_b32();\n    int *data = l.data();\n\n    for (size_t i = 0; i < vec_size; i += svcntw()) {\n        size_t k = svcntw(); // Number of elements in a vector\n        size_t j = i;\n        if (i + k > vec_size) {\n            k = vec_size - i;\n            pg = svwhilelt_b32(j, vec_size);\n        }\n        svint32_t vec_load = svld1(pg, &data[j]);\n        svint32_t vec_incr = svadd(pg, vec_load, svdup_n_s32(1));\n        svst1(pg, &data[j], vec_incr);\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l){\n    size_t vec_size = l.size();\n    if (vec_size == 0) return {};\n\n    // Determine the maximum vector length supported by the hardware\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    size_t i = 0;\n    std::vector<int> result(vec_size);\n\n    for (; i <= vec_size - vl; i += vl) {\n        svint32_t vec_load = svld1(pg, &l[i]);\n        svint32_t incremented = svadd_n(pg, vec_load, 1);\n        svst1(pg, &result[i], incremented);\n    }\n\n    // Handle leftover elements\n    if (i < vec_size) {\n        svbool_t pg_partial = svwhilelt_b32(i, vec_size);\n        svint32_t vec_load = svld1(pg_partial, &l[i]);\n        svint32_t incremented = svadd_n(pg_partial, vec_load, 1);\n        svst1(pg_partial, &result[i], incremented);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 2) return false;\n\n    size_t n = l.size();\n    svbool_t pg = svptrue_b32();\n    svint32_t zero = svdup_n_s32(0);\n\n    for (size_t i = 0; i < n; ++i) {\n        int x = l[i];\n        svint32_t vec_x = svdup_n_s32(x);\n        \n        size_t j = i + 1;\n        for (; j + svcntw() <= n; j += svcntw()) {\n            svint32_t vec_y = svld1(pg, &l[j]);\n            svint32_t sum = svadd_z(pg, vec_x, vec_y);\n            svbool_t match = svcmpeq_z(pg, sum, zero);\n            if (svptest_any(svptrue_b8(), match)) {\n                return true;\n            }\n        }\n\n        // Handle leftover elements\n        if (j < n) {\n            size_t left = n - j;\n            svbool_t pg_left = svwhilelt_b32(j, n);\n            svint32_t vec_y = svld1(pg_left, &l[j]);\n            svint32_t sum = svadd_z(pg_left, vec_x, vec_y);\n            svbool_t match = svcmpeq_z(pg_left, sum, zero);\n            if (svptest_any(svptrue_b8(), match)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l){\n    if (l.size() < 2) return false;\n\n    int *data = l.data();\n    size_t n = l.size();\n    svbool_t pg = svptrue_b32();\n    svint32_t zero = svdup_n_s32(0);\n\n    for (size_t i = 0; i < n; ++i) {\n        svint32_t vi = svdup_n_s32(data[i]);\n        size_t j = i + 1;\n        for (; j + svcntw() <= n; j += svcntw()) {\n            svint32_t vj = svld1(pg, &data[j]);\n            svbool_t match = svcmpeq(pg, svadd(pg, vi, vj), zero);\n            if (svptest_any(svptrue_b32(), match)) {\n                return true;\n            }\n        }\n        for (; j < n; ++j) {\n            if (data[i] + data[j] == 0) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l){\n    if (l.size() < 2) return false;\n\n    int *data = l.data();\n    size_t n = l.size();\n    svbool_t pg = svptrue_b32();\n\n    for (size_t i = 0; i < n; ++i) {\n        svint32_t vi = svdup_n_s32(data[i]);\n        svint32_t vj;\n        svbool_t pred;\n\n        for (size_t j = i + 1; j < n; j += svcntw()) {\n            size_t k = n - j;\n            size_t len = (k > svcntw()) ? svcntw() : k;\n\n            pred = svwhilelt_b32(j - i, len);\n            vj = svld1_idx_s32(pred, data + j, j);\n\n            svbool_t match = svcmpeq_s32(pg, svadd_s32(pg, vi, vj), svdup_n_s32(0));\n            if (svptest_any(svptrue_b1(), match)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <unordered_set>\n\nbool pairs_sum_to_zero_simd(const std::vector<int>& l) {\n    if (l.size() < 2) return false;\n\n    svbool_t pg = svptrue_b32();\n    size_t n = l.size();\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < n; ++i) {\n        int a = l[i];\n        svint32_t sva = svdup_n_s32(a);\n\n        size_t j = i + 1;\n        for (; j + vl <= n; j += vl) {\n            svint32_t svb = svld1(pg, &l[j]);\n            svbool_t match = svcmpeq(pg, svadd(pg, sva, svb), svdup_n_s32(0));\n            if (svptest_any(svptrue_b32(), match)) {\n                return true;\n            }\n        }\n\n        for (; j < n; ++j) {\n            if (a + l[j] == 0) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l){\n    if (l.size() < 2) return false;\n\n    int *data = l.data();\n    size_t n = l.size();\n\n    svbool_t pg = svptrue_b32();\n    size_t index = 0;\n\n    for (size_t i = 0; i < n; ++i) {\n        svint32_t vec_i = svdup_n_s32(l[i]);\n        size_t j = i + 1;\n        for (; j + svcntw() <= n; j += svcntw()) {\n            svint32_t vec_j = svld1(pg, &data[j]);\n            svbool_t cmp = svcmpeq(pg, vec_i, sve_neg_s32(vec_j));\n            if (svptest_any(svptrue_b32(), cmp)) {\n                return true;\n            }\n        }\n        // Handle leftover elements\n        if (j < n) {\n            size_t num_left = n - j;\n            svbool_t pg_partial = svwhilelt_b32(index, num_left);\n            svint32_t vec_j = svld1(pg_partial, &data[j]);\n            svbool_t cmp = svcmpeq(pg_partial, vec_i, sve_neg_s32(vec_j));\n            if (svptest_any(svptrue_b32(), cmp)) {\n                return true;\n            }\n            index++;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n\nstd::string change_base_simd(int64_t x, int8_t base){\n    if (base < 2 || base > 10) return \"\";\n\n    // Handle zero case\n    if (x == 0) return \"0\";\n\n    int64_t num = x;\n    bool is_negative = false;\n    if (num < 0) {\n        is_negative = true;\n        num = -num;\n    }\n\n    svbool_t pg = svptrue_b64();\n    svuint8_t digits_vec = svdup_n_u8(0);\n    int count = 0;\n\n    while (num > 0) {\n        svuint8_t remainder = svdup_n_u8(num % base);\n        digits_vec = svsel_u8(pg, remainder, digits_vec);\n        num /= base;\n        count++;\n    }\n\n    std::vector<uint8_t> digits(count);\n    for (int i = count - 1; i >= 0; --i) {\n        uint8_t digit = svindex_u8(i, 1);\n        digits[count - i - 1] = svtbl1_u8(digits_vec, digit)[0];\n    }\n\n    if (is_negative) {\n        digits.push_back('-');\n    }\n\n    std::reverse(digits.begin(), digits.end());\n\n    std::ostringstream oss;\n    for (auto d : digits) {\n        oss << static_cast<char>('0' + d);\n    }\n\n    return oss.str();\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::string change_base_simd(int64_t x, int8_t base){\n    if (base < 2 || base > 10) return \"\";\n\n    svbool_t pg = svptrue_b8();\n    int64_t num = x;\n    std::vector<int8_t> digits;\n\n    // Handle zero case\n    if (num == 0) {\n        return \"0\";\n    }\n\n    svint8_t svbase = svdup_n_s8(base);\n\n    while (num > 0) {\n        svint8_t svn = svdup_n_s8(num);\n        svint8_t remainder = svsub_x_s8(pg, svn, svmul_x_s8(pg, svudiv_x_s8(pg, svn, svbase), svbase));\n        int8_t rem = sveorval_s8(pg, remainder);\n        digits.push_back(rem + '0');\n        num /= base;\n    }\n\n    std::reverse(digits.begin(), digits.end());\n    std::string result(digits.begin(), digits.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string change_base_simd(int64_t x, int8_t base){\n    if (base < 2 || base > 10) return \"\";\n\n    svbool_t pg = svptrue_b8();\n    int64_t num = x;\n    std::vector<int8_t> digits;\n\n    // Handle negative numbers\n    bool is_negative = num < 0;\n    if (is_negative) {\n        num = -num;\n    }\n\n    // Compute digits in reverse order\n    while (num > 0) {\n        svint8_t vec_base = svdup_n_s8(base);\n        svint8_t vec_num = svdup_n_s8(num);\n        svint8_t rem = svsub_x(pg, vec_num, svmul_x(pg, svudiv_x(pg, vec_num, vec_base), vec_base));\n        digits.push_back(svindex_s8(0, 1)[0] + svtoint_s8(pg, rem)[0]);\n        num /= base;\n    }\n\n    if (digits.empty()) {\n        return \"0\";\n    }\n\n    if (is_negative) {\n        digits.push_back('-');\n    }\n\n    std::string result(digits.size(), ' ');\n    for (size_t i = 0; i < digits.size(); ++i) {\n        result[digits.size() - i - 1] = '0' + digits[i];\n    }\n\n    if (is_negative) {\n        result[0] = '-';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <string>\n\nstd::string change_base_simd(int64_t x, int8_t base){\n    if (base < 2 || base > 10) return \"\";\n\n    svbool_t pg = svptrue_b8();\n    int64_t num = x;\n    std::vector<int8_t> digits;\n\n    // Handle zero case\n    if (num == 0) {\n        return \"0\";\n    }\n\n    svint8_t svbase = svdup_n_s8(base);\n\n    while (num > 0) {\n        svint8_t svn = svdup_n_s8(num);\n        svint8_t remainder = svsub_x_s8(pg, svn, svmul_x_s8(pg, svudiv_x_s8(pg, svn, svbase), svbase));\n        int8_t rem = sve_extract_s8(remainder, 0);\n        digits.push_back(rem);\n        num /= base;\n    }\n\n    std::string result;\n    for (auto it = digits.rbegin(); it != digits.rend(); ++it) {\n        result += std::to_string(*it);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <string>\n\nstd::string change_base_simd(int64_t x, int8_t base){\n    if (base <= 0 || base > 10) return \"\";\n\n    int64_t num = x;\n    if (num == 0) return \"0\";\n\n    bool is_negative = num < 0;\n    if (is_negative) num = -num;\n\n    std::vector<int8_t> digits;\n    svbool_t pg = svptrue_b8();\n    svint8_t svbase = svdup_n_s8(base);\n\n    while (num > 0) {\n        svint8_t svn = svdup_n_s8(num);\n        svint8_t remainder = svsub_x_s8(pg, svn, svmul_x_s8(pg, svudivx_s8(pg, svn, svbase), svbase));\n        int8_t rem = sve_int8_to_scalar(remainder);\n        digits.push_back(rem);\n        num /= base;\n    }\n\n    if (is_negative) digits.push_back('-');\n\n    std::string result;\n    result.reserve(digits.size());\n    for(auto it = digits.rbegin(); it != digits.rend(); ++it){\n        if (*it == '-') {\n            result += *it;\n        }\n        else {\n            result += (*it + '0');\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n\nbool is_palindrome_simd(std::string text){\n    size_t len = text.length();\n    if (len == 0) return true;\n\n    svbool_t pg = svptrue_b8();\n    size_t vl = svcntb();\n    size_t i = 0;\n\n    while (i < len / 2) {\n        size_t chunk_size = (len / 2 - i > vl) ? vl : (len / 2 - i);\n        svuint8_t left = svld1(pg, reinterpret_cast<const uint8_t*>(&text[i]));\n        svuint8_t right = svld1(pg, reinterpret_cast<const uint8_t*>(&text[len - i - chunk_size]));\n\n        svbool_t mismatch = svcmpne_u8_m(pg, left, right);\n        if (svptest_any(pg, mismatch)) {\n            return false;\n        }\n        i += chunk_size;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    size_t len = text.length();\n    if (len == 0) return true;\n\n    svbool_t pg = svptrue_b8();\n    size_t vl = svcntb();\n    const uint8_t* data = reinterpret_cast<const uint8_t*>(text.data());\n\n    size_t i = 0;\n    for (; i + vl <= len / 2; i += vl) {\n        svuint8_t vec_start = svld1(pg, data + i);\n        svuint8_t vec_end = svld1(pg, data + len - i - 1);\n\n        svbool_t mismatch = svcmpne_u8(pg, vec_start, vec_end);\n        if (svptest_any(pg, mismatch)) {\n            return false;\n        }\n    }\n\n    for (; i < len / 2; ++i) {\n        if (data[i] != data[len - i - 1]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n\nbool is_palindrome_simd(std::string text){\n    size_t len = text.length();\n    if (len == 0) return true;\n\n    svbool_t pg = svptrue_b8();\n    size_t vl = svcntb();\n    size_t i = 0;\n\n    while (i + vl <= len / 2) {\n        svuint8_t vec_start = svld1(pg, reinterpret_cast<const uint8_t*>(&text[i]));\n        svuint8_t vec_end = svld1(pg, reinterpret_cast<const uint8_t*>(&text[len - i - 1]));\n\n        svbool_t mismatch = svcmpeq(pg, vec_start, vec_end);\n        if (svptest_any(svpfalse_b8(), mismatch)) {\n            return false;\n        }\n        i += vl;\n    }\n\n    // Handle remaining elements\n    for (; i < len / 2; ++i) {\n        if (text[i] != text[len - i - 1]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    size_t len = text.length();\n    if (len == 0) return true;\n\n    svbool_t pg = svptrue_b8();\n    size_t vl = svcntb();\n\n    const uint8_t* start = reinterpret_cast<const uint8_t*>(text.data());\n    const uint8_t* end = start + len - 1;\n\n    size_t i = 0;\n    for (; i + vl <= len / 2; i += vl) {\n        svuint8_t vec_start = svld1(pg, start + i);\n        svuint8_t vec_end = svld1(pg, end - i);\n\n        svuint8_t diff = svsub_u8(pg, vec_start, vec_end);\n        svuint8_t zero = svdup_n_u8(0);\n\n        svbool_t mismatch = svcmpeq(pg, diff, zero);\n        if (svcntp(mismatch) != vl) {\n            return false;\n        }\n    }\n\n    size_t remaining = len / 2 - i;\n    if (remaining > 0) {\n        svbool_t pg_remaining = svwhilelt_b8(i, len / 2);\n        svuint8_t vec_start = svld1(pg_remaining, start + i);\n        svuint8_t vec_end = svld1(pg_remaining, end - i);\n\n        svuint8_t diff = svsub_u8(pg_remaining, vec_start, vec_end);\n        svuint8_t zero = svdup_n_u8(0);\n\n        svbool_t mismatch = svcmpeq(pg_remaining, diff, zero);\n        if (svcntp(mismatch) != svcntp(pg_remaining)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n\nbool is_palindrome_simd(std::string text){\n    size_t len = text.length();\n    if (len == 0) return true;\n\n    svbool_t pg = svptrue_b8();\n    size_t vec_len = svcntb();\n    size_t i = 0;\n\n    for (; i + vec_len <= len / 2; i += vec_len) {\n        svuint8_t left = svld1(pg, reinterpret_cast<const uint8_t*>(&text[i]));\n        svuint8_t right = svld1(pg, reinterpret_cast<const uint8_t*>(&text[len - i - vec_len]));\n\n        svbool_t mismatch = svcmpeq(pg, left, right);\n        if (svptest_any(svpfalse_b8(), mismatch)) {\n            return false;\n        }\n    }\n\n    for (; i < len / 2; ++i) {\n        if (text[i] != text[len - i - 1]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n\nstd::string decode_shift_simd(std::string s){\n    int8_t shift = -5;\n    size_t vec_len = s.size();\n    svbool_t pg = svptrue_b8();\n    std::string out;\n\n    size_t i = 0;\n    while (i <= vec_len - svcntb()) {\n        svint8_t vec = svld1(pg, reinterpret_cast<const int8_t*>(&s[i]));\n        svint8_t shifted_vec = svadd(pg, vec, shift);\n        svst1(pg, reinterpret_cast<int8_t*>(const_cast<char*>(&s[i])), shifted_vec);\n        i += svcntb();\n    }\n\n    // Handle remaining elements\n    if (i < vec_len) {\n        pg = svwhilelt_b8(i, vec_len);\n        svint8_t vec = svld1(pg, reinterpret_cast<const int8_t*>(&s[i]));\n        svint8_t shifted_vec = svadd(pg, vec, shift);\n        svst1(pg, reinterpret_cast<int8_t*>(const_cast<char*>(&s[i])), shifted_vec);\n    }\n\n    // Wrap around alphabet if necessary\n    i = 0;\n    while (i <= vec_len - svcntb()) {\n        svint8_t vec = svld1(pg, reinterpret_cast<const int8_t*>(&s[i]));\n        svint8_t lower_a = svcmple(pg, vec, 'a');\n        svint8_t wrapped_vec = svadd(pg, vec, 26);\n        svint8_t result = svsel(lower_a, wrapped_vec, vec);\n        svst1(pg, reinterpret_cast<int8_t*>(const_cast<char*>(&s[i])), result);\n        i += svcntb();\n    }\n\n    if (i < vec_len) {\n        pg = svwhilelt_b8(i, vec_len);\n        svint8_t vec = svld1(pg, reinterpret_cast<const int8_t*>(&s[i]));\n        svint8_t lower_a = svcmple(pg, vec, 'a');\n        svint8_t wrapped_vec = svadd(pg, vec, 26);\n        svint8_t result = svsel(lower_a, wrapped_vec, vec);\n        svst1(pg, reinterpret_cast<int8_t*>(const_cast<char*>(&s[i])), result);\n    }\n\n    return s;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n\nstd::string decode_shift_simd(std::string s){\n    svbool_t pg = svptrue_b8();\n    size_t vec_len = svcntb();\n    size_t str_len = s.length();\n    std::string out;\n    out.reserve(str_len);\n\n    const uint8_t shift = 21; // Decode shift is -5, equivalent to +21 in modulo 26\n    const uint8_t a_val = 'a';\n    const uint8_t z_val = 'z';\n\n    for (size_t i = 0; i < str_len; i += vec_len) {\n        size_t k = str_len - i;\n        size_t n = (k > vec_len) ? vec_len : k;\n\n        svbool_t pg_n = svwhilelt_b8(i, str_len);\n        svuint8_t vec = svld1(pg_n, reinterpret_cast<const uint8_t*>(&s[i]));\n\n        svuint8_t decoded_vec = sve_addmod_u8(pg_n, a_val, vec, shift);\n\n        uint8_t temp[vec_len];\n        svst1(pg_n, temp, decoded_vec);\n\n        out.append(reinterpret_cast<char*>(temp), n);\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n\nstd::string decode_shift_simd(std::string s){\n    int len = s.length();\n    if (len == 0) return \"\";\n\n    svbool_t pg = svptrue_b8(); // Predicate for all elements\n    size_t vl = svcntb(); // Vector length in bytes\n    size_t num_iters = (len + vl - 1) / vl; // Number of iterations\n\n    std::string out;\n    out.reserve(len);\n\n    for (size_t i = 0; i < num_iters; ++i) {\n        size_t start_idx = i * vl;\n        size_t end_idx = start_idx + vl;\n        if (end_idx > len) end_idx = len;\n\n        svuint8_t vec_in = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&s[start_idx]));\n        svuint8_t shifted = svsub_x_u8(pg, vec_in, svdup_n_u8(5));\n        svuint8_t wrapped = svadd_x_u8(pg, shifted, svdup_n_u8('a'));\n        svuint8_t decoded = svmla_x_u8(pg, wrapped, svdup_n_u8(26), svdup_n_u8('a'));\n\n        uint8_t buffer[64] = {0}; // Ensure buffer is large enough for maximum VL\n        svst1_u8(pg, buffer, decoded);\n\n        for (size_t j = 0; j < (end_idx - start_idx); ++j) {\n            out += static_cast<char>(buffer[j]);\n        }\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n\nstd::string decode_shift_simd(std::string s){\n    int len = s.length();\n    if (len == 0) return \"\";\n\n    // Determine a suitable vector length\n    svbool_t pg = svptrue_b8();\n    uint8_t shift_val = 26 - 5; // To decode, shift back by 21 (26-5)\n    uint8_t lower_bound = 'a';\n    uint8_t upper_bound = 'z';\n\n    std::string out;\n    out.reserve(len);\n\n    for (size_t i = 0; i < len; i += svcntb()) {\n        size_t chunk_size = len - i;\n        if (chunk_size < svcntb()) {\n            pg = svwhilelt_b8(i, len);\n        }\n\n        // Load characters from input string\n        svuint8_t vec_in = svld1(pg, reinterpret_cast<const uint8_t*>(&s[i]));\n\n        // Subtract 'a' to bring into range [0,25]\n        svuint8_t temp = svsub_u8_m(pg, vec_in, vec_in, lower_bound);\n\n        // Add the shift value\n        temp = svadd_u8_m(pg, temp, temp, shift_val);\n\n        // Perform modulo 26 using subtraction\n        svuint8_t mod_res = svsub_u8_m(pg, temp, temp, 26);\n        temp = svsel(pg, svcmpge_m(pg, temp, mod_res), temp, mod_res);\n\n        // Bring back into ASCII range ['a','z']\n        svuint8_t vec_out = svadd_u8_m(pg, temp, temp, lower_bound);\n\n        // Store results back to output string\n        uint8_t data[svcntb()];\n        svst1(pg, data, vec_out);\n        out.append(reinterpret_cast<char*>(data), svcntp_b8(pg));\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nstd::string decode_shift_simd(std::string s){\n    int len = s.length();\n    if (len == 0) return \"\";\n\n    // Determine the maximum vector length in bytes\n    svbool_t pg = svptrue_b8();\n    size_t vl = svcntb();\n\n    std::string out;\n    out.reserve(len);\n\n    const uint8_t shift = 5;\n    const uint8_t mod_base = 'a';\n    const uint8_t mod_range = 26;\n\n    for (size_t i = 0; i < len; i += vl) {\n        size_t chunk_size = len - i > vl ? vl : len - i;\n        svbool_t pred = svwhilelt_b8(i, i + chunk_size);\n\n        // Load characters from input string\n        uint8x16_t data = svld1_u8(pred, reinterpret_cast<const uint8_t*>(&s[i]));\n\n        // Perform decoding: (c - 'a' - 5 + 26) % 26 + 'a'\n        uint8x16_t decoded = ((data - mod_base - shift + mod_range) % mod_range) + mod_base;\n\n        // Store the decoded characters into the output string\n        alignas(16) uint8_t temp[16];\n        svst1_u8(pg, temp, decoded);\n        out.append(reinterpret_cast<char*>(temp), chunk_size);\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t){\n    if (l.empty()) return true;\n\n    svbool_t pg = svptrue_b32();\n    size_t vec_len = l.size();\n    const size_t vl = svcntw(); // Vector length in terms of number of 32-bit elements\n    size_t i = 0;\n\n    for (; i <= vec_len - vl; i += vl) {\n        svint32_t vec = svld1(pg, &l[i]);\n        svbool_t result = svclt(pg, vec, svdup_n_s32(t));\n        if (!svall_b32(pg, result)) {\n            return false;\n        }\n    }\n\n    // Handle remaining elements\n    if (i < vec_len) {\n        size_t left = vec_len - i;\n        svbool_t pg_partial = svwhilelt_b32(i, vec_len);\n        svint32_t vec = svld1(pg_partial, &l[i]);\n        svbool_t result = svclt(pg_partial, vec, svdup_n_s32(t));\n        if (!svall_b32(pg_partial, result)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nbool below_threshold_simd(const std::vector<int>& l, int t){\n    bool result = true;\n    size_t count = l.size();\n    if (count == 0) return true;\n\n    svbool_t pg = svptrue_b32();\n    size_t vec_len = svcntw(); // Number of elements in a vector\n    size_t i = 0;\n\n    for (; i <= count - vec_len; i += vec_len) {\n        svint32_t vl = svld1(pg, &l[i]);\n        svbool_t cmp_result = svclt(pg, vl, svdup_n_s32(t));\n        if (!svall_b(pg, cmp_result)) {\n            result = false;\n            break;\n        }\n    }\n\n    for (; i < count; ++i) {\n        if (l[i] >= t) {\n            result = false;\n            break;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t){\n    svbool_t pg = svptrue_b32();\n    size_t vec_size = l.size();\n    bool result = true;\n\n    for (size_t i = 0; i < vec_size; i += svcntw()) {\n        size_t k = svcntw();\n        if (i + k > vec_size) {\n            k = vec_size - i;\n        }\n        svint32_t vl = svld1(pg, &l[i]);\n        svint32_t vt = svdup_n_s32(t);\n        svbool_t pred = svclt(pg, vl, vt);\n        pg = svwhilelt_b32(i, vec_size);\n        if (svcntp(pred, pg) != svcntp(pg)) {\n            result = false;\n            break;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    svbool_t pg = svptrue_b32(); // Predicate for all true\n    size_t vec_size = l.size();\n    const int *data = l.data();\n    bool result = true;\n\n    size_t i = 0;\n    svint32_t st = svdup_n_s32(t); // Vectorize the threshold\n\n    // Process in vectorized chunks\n    for (; i <= vec_size - svcntw(); i += svcntw()) {\n        svint32_t vl = svld1(pg, &data[i]); // Load vector\n        svbool_t cmp = svclt(pg, vl, st);   // Compare: vl < t\n        pg = svand(pg, cmp);                // Update predicate\n    }\n\n    // Horizontal AND of predicate register\n    result = svptest_all(pg, svptrue_b32());\n\n    // Tail handling for any remaining elements\n    if (i < vec_size) {\n        svbool_t tail_pg = svtrue_b32(); // Initialize predicate for tail\n        tail_pg = svwhilelt_b32(i, (svint32_t){(int)vec_size}); // Generate predicate for tail\n        svint32_t vtail = svld1(tail_pg, &data[i]); // Load tail elements\n        svbool_t cmp = svclt(tail_pg, vtail, st);   // Compare: vtail < t\n        pg = svand(pg, cmp);                        // Update predicate\n        result = result && svptest_all(pg, tail_pg);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    if (l.empty()) return true;\n\n    svbool_t pg = svptrue_b32();\n    size_t vec_len = sve_vl();\n    size_t num_elem = l.size();\n    int* data = l.data();\n\n    svint32_t st = svdup_n_s32(t);\n\n    size_t i = 0;\n    for (; i <= num_elem - vec_len; i += vec_len) {\n        svint32_t vl = svld1(pg, &data[i]);\n        svbool_t cmp_result = svclt_s32(pg, vl, st);\n        if (!svall_b32(pg, cmp_result)) {\n            return false;\n        }\n    }\n\n    // Handle remaining elements\n    if (i < num_elem) {\n        size_t leftover = num_elem - i;\n        svbool_t pg_leftover = svwhilelt_b32(i, num_elem);\n        svint32_t vl = svld1(pg_leftover, &data[i]);\n        svbool_t cmp_result = svclt_s32(pg_leftover, vl, st);\n        if (!svall_b32(pg_leftover, cmp_result)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <cstddef>\n\nbool correct_bracketing_simd(const std::string& brackets){\n    size_t n = brackets.size();\n    if (n == 0) return true;\n\n    const uint8_t* data = reinterpret_cast<const uint8_t*>(brackets.c_str());\n    svbool_t pg = svptrue_b8();\n    svint8_t balance = svdup_s8(pg, 0);\n\n    size_t i = 0;\n    svuint8_t open = svdup_u8(pg, '<');\n    svuint8_t close = svdup_u8(pg, '>');\n\n    while (i < n) {\n        size_t vl = svcntb();\n        size_t chunk = n - i;\n        if (chunk < vl) vl = chunk;\n\n        svuint8_t chars = svld1_u8(pg, data + i);\n        svuint8_t is_open = svcmpeq_u8(pg, chars, open);\n        svuint8_t is_close = svcmpeq_u8(pg, chars, close);\n\n        balance = svaddvs_s8(pg, balance, is_open);\n        balance = svsubvs_s8(pg, balance, is_close);\n\n        if (svptest_any(svpfalse_b8(), svclt_s8(pg, balance, svdup_s8(pg, 0)))) {\n            return false;\n        }\n\n        i += vl;\n    }\n\n    return svptest_all(svptrue_b8(), svceq_z(pg, balance, svdup_s8(pg, 0)));\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n\nbool correct_bracketing_simd(std::string brackets){\n    svbool_t pg = svptrue_b8();\n    int32_t balance = 0;\n    size_t i = 0;\n    size_t vec_len = brackets.size() / svcntb();\n\n    for (size_t v = 0; v < vec_len; ++v) {\n        svuint8_t chars = svld1(pg, reinterpret_cast<const uint8_t*>(&brackets[i]));\n        svuint8_t is_open = svcmpeq(pg, chars, '<');\n        svuint8_t is_close = svcmpeq(pg, chars, '>');\n\n        int32x4_t open_count = svaddv(pg, is_open);\n        int32x4_t close_count = svaddv(pg, is_close);\n\n        balance += (svcntw() * open_count - svcntw() * close_count);\n\n        if (balance < 0) {\n            return false;\n        }\n        i += svcntb();\n    }\n\n    // Process remaining characters\n    size_t remainder = brackets.size() % svcntb();\n    if (remainder > 0) {\n        svbool_t pg_remainder = svwhilelt_b8(0, remainder);\n        svuint8_t chars = svld1(pg_remainder, reinterpret_cast<const uint8_t*>(&brackets[i]));\n        svuint8_t is_open = svcmpeq(pg_remainder, chars, '<');\n        svuint8_t is_close = svcmpeq(pg_remainder, chars, '>');\n\n        int32x4_t open_count = svaddv(pg_remainder, is_open);\n        int32x4_t close_count = svaddv(pg_remainder, is_close);\n\n        balance += (remainder * open_count - remainder * close_count);\n\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    if (brackets.empty()) return true;\n\n    size_t vl = svcntb(); // Vector length in bytes\n    uint8_t opening = '<';\n    uint8_t closing = '>';\n\n    svbool_t pg = svptrue_b8(); // Predicate for full vector\n\n    int balance = 0;\n    size_t n = brackets.size();\n\n    for (size_t i = 0; i < n; i += vl) {\n        size_t chunk = (n - i) > vl ? vl : (n - i);\n\n        svuint8_t vec = svld1(pg, reinterpret_cast<const uint8_t*>(&brackets[i]));\n        svuint8_t open_mask = svcmpeq(pg, vec, opening);\n        svuint8_t close_mask = svcmpeq(pg, vec, closing);\n\n        int pop_open = svpopcnt_b8(open_mask);\n        int pop_close = svpopcnt_b8(close_mask);\n\n        balance += pop_open - pop_close;\n\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n\nbool correct_bracketing_simd(std::string brackets){\n    int balance = 0;\n    size_t num_elements = brackets.size();\n    size_t i = 0;\n\n    while (i < num_elements) {\n        svbool_t pg = svptrue_b8();\n        size_t vl = svcntb();\n        size_t chunk_size = (num_elements - i > vl) ? vl : (num_elements - i);\n\n        // Load characters and adjust predicate for the last partial vector\n        svbool_t pred = svwhilelt_b8(i, num_elements);\n        svuint8_t chars = svld1_u8(pred, reinterpret_cast<const uint8_t*>(&brackets[i]));\n\n        // Compare with '<' and '>'\n        svuint8_t open = svdup_n_u8('<');\n        svuint8_t close = svdup_n_u8('>');\n        \n        svbool_t is_open = svcmpeq_b_u8(chars, open);\n        svbool_t is_close = svcmpeq_b_u8(chars, close);\n\n        // Count opens and closes\n        int32x4_t count_open = svcntp_s32(is_open, pg);\n        int32x4_t count_close = svcntp_s32(is_close, pg);\n\n        // Accumulate balance\n        balance += (svaddv_s32(count_open) - svaddv_s32(count_close));\n\n        if (balance < 0) {\n            return false;\n        }\n\n        i += chunk_size;\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <cstddef>\n\nbool correct_bracketing_simd(const std::string& brackets){\n    size_t n = brackets.size();\n    if (n == 0) return true;\n\n    svbool_t pg = svptrue_b8();\n    svint8_t balance = svdup_s8(pg, 0);\n\n    const uint8_t* str = reinterpret_cast<const uint8_t*>(brackets.c_str());\n    size_t i = 0;\n\n    svuint8_t open = svdup_u8(pg, '<');\n    svuint8_t close = svdup_u8(pg, '>');\n\n    while (i < n) {\n        size_t vl = svcntb();\n        size_t chunk = n - i;\n        if (chunk < vl) {\n            pg = svwhilelt_b8(i, n);\n            vl = chunk;\n        }\n\n        svuint8_t chars = svld1_u8(pg, str + i);\n        svuint8_t is_open = svcmpeq_u8(chars, open);\n        svuint8_t is_close = svcmpeq_u8(chars, close);\n\n        balance = svaddvs_s8(pg, balance, is_open);\n        balance = svsubvs_s8(pg, balance, is_close);\n\n        if (svminv_s8(pg, balance) < 0) {\n            return false;\n        }\n\n        i += vl;\n    }\n\n    return svminv_s8(pg, balance) == 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int balance = 0;\n    svbool_t pg = svptrue_b32();\n    svint32_t vec_balance = svdup_n_s32(pg, 0);\n\n    size_t vec_len = svcntw() / sizeof(int32_t);\n    size_t i = 0;\n\n    for (; i + vec_len <= brackets.size(); i += vec_len) {\n        svuint8_t chars = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&brackets[i]));\n        svuint8_t open = svcmpeq_u8(pg, chars, '(');\n        svuint8_t close = svcmpeq_u8(pg, chars, ')');\n\n        svint32_t inc = svreinterpret_s32_u8(svshl_n_u8(open, 31));\n        svint32_t dec = svreinterpret_s32_u8(svshl_n_u8(close, 31));\n\n        vec_balance = svadd_s32(pg, vec_balance, inc);\n        vec_balance = ssub_s32(pg, vec_balance, dec);\n\n        svint32_t negative_check = svclt_s32(pg, vec_balance, svdup_n_s32(pg, 0));\n        if (svptest_any(svptrue_b32(), negative_check)) {\n            return false;\n        }\n    }\n\n    balance = svaddv_s32(pg, vec_balance);\n\n    for (; i < brackets.size(); ++i) {\n        if (brackets[i] == '(') {\n            ++balance;\n        } else if (brackets[i] == ')') {\n            --balance;\n            if (balance < 0) return false;\n        }\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n\nbool correct_bracketing_simd(const std::string& brackets){\n    svbool_t pg = svptrue_b8();\n    size_t vl = svcntb();\n    int balance = 0;\n\n    for (size_t i = 0; i < brackets.size(); i += vl) {\n        size_t chunk = (brackets.size() - i > vl) ? vl : brackets.size() - i;\n        svuint8_t vec = svld1(pg, reinterpret_cast<const uint8_t*>(&brackets[i]));\n        \n        svuint8_t open = svdup_n_u8('(');\n        svuint8_t close = svdup_n_u8(')');\n        \n        svbool_t is_open = svcmpeq_b_u8(pg, vec, open);\n        svbool_t is_close = svcmpeq_b_u8(pg, vec, close);\n\n        int popen = svcntp(is_open, pg);\n        int pclose = svcntp(is_close, pg);\n\n        balance += popen - pclose;\n\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    if (brackets.empty()) return true;\n\n    size_t vl = svcntb();\n    uint8_t *str = reinterpret_cast<uint8_t *>(const_cast<char *>(brackets.c_str()));\n    size_t len = brackets.size();\n    int32_t balance = 0;\n\n    svbool_t pg = svptrue_b8();\n    svint32_t sv_balance = svdup_s32(pg, 0);\n\n    for (size_t i = 0; i < len; i += vl) {\n        size_t chunk = len - i > vl ? vl : len - i;\n        svuint8_t sv_chars = svld1_b8(pg, str + i);\n        svuint8_t open = svcmpeq_b8(pg, sv_chars, static_cast<uint8_t>('('));\n        svuint8_t close = svcmpeq_b8(pg, sv_chars, static_cast<uint8_t>(')'));\n\n        svint32_t inc = svreinterpret_s32_u8(svand_u8(pg, open, svdup_n_u8(pg, 1)));\n        svint32_t dec = svreinterpret_s32_u8(svand_u8(pg, close, svdup_n_u8(pg, 1)));\n\n        sv_balance = svaddv_s32(pg, sv_balance, svreinterpret_s32_u8(svneg_u8(pg, dec)));\n        sv_balance = svsubv_s32(pg, sv_balance, svreinterpret_s32_u8(inc));\n\n        int32_t min_balance = svmnvm_s32(pg, sv_balance);\n        if (min_balance < 0) return false;\n    }\n\n    balance = svaddv_s32(pg, sv_balance);\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    if (brackets.empty()) return true;\n\n    svbool_t pg = svptrue_b8();\n    size_t vl = svcntb();\n    int8_t balance = 0;\n    int8_t min_balance = 0;\n\n    for (size_t i = 0; i < brackets.size(); i += vl) {\n        size_t chunk = (brackets.size() - i) > vl ? vl : (brackets.size() - i);\n        svuint8_t vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&brackets[i]));\n\n        svbool_t is_open = svcmpeq_b_u8(pg, vec, svdup_n_u8('('));\n        svbool_t is_close = svcmpeq_b_u8(pg, vec, svdup_n_u8(')'));\n\n        svint8_t inc = svreinterpret_s8_u8(svsel_u8(is_open, svdup_n_u8(1), svdup_n_u8(0)));\n        svint8_t dec = svreinterpret_s8_u8(svsel_u8(is_close, svdup_n_u8(-1), svdup_n_u8(0)));\n\n        svint8_t deltas = svadd_s8(pg, inc, dec);\n        svint8_t cumulative = svpadd_s8(pg, deltas);\n\n        int8x16_t res = svaddv_s8(pg, cumulative);\n        balance += svaddv_s8(pg, res).front();\n\n        if (balance < 0) return false;\n\n        min_balance = std::min(min_balance, balance);\n    }\n\n    return balance == 0 && min_balance >= 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int balance = 0;\n    svbool_t pg = svptrue_b8();\n    size_t vec_len = svcntb();\n    size_t num_iters = (brackets.size() + vec_len - 1) / vec_len;\n\n    for (size_t i = 0; i < num_iters; ++i) {\n        size_t start = i * vec_len;\n        size_t len = std::min(vec_len, brackets.size() - start);\n\n        svuint8_t chars = svld1(pg, reinterpret_cast<const uint8_t*>(&brackets[start]));\n        svuint8_t open = svdup_n_u8('(');\n        svuint8_t close = svdup_n_u8(')');\n        \n        svbool_t is_open = svcmpeq(pg, chars, open);\n        svbool_t is_close = svcmpeq(pg, chars, close);\n\n        int32x4_t count_open = svmovlb_s32(svindex_s32(0, 1));\n        int32x4_t count_close = svmovlb_s32(svindex_s32(0, 1));\n\n        count_open = svaddv(pg, count_open, svreinterpret_s32_u8(is_open));\n        count_close = svaddv(pg, count_close, svreinterpret_s32_u8(is_close));\n\n        int open_count = svaddv(pg, count_open);\n        int close_count = svaddv(pg, count_close);\n\n        balance += open_count - close_count;\n\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs){\n    if (xs.size() <= 1) return {};\n\n    size_t n = xs.size() - 1;\n    std::vector<float> result(n);\n\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    for(size_t i = 0; i < n; i += vl){\n        size_t k = n - i;\n        vl = (k > vl) ? vl : k;\n\n        svbool_t pg_vl = svwhilelt_b32(i, i + vl);\n        \n        svfloat32_t idx_vec = svindex_f32(i+1, 1);\n        svfloat32_t xs_vec = svld1(pg_vl, &xs[i+1]);\n        \n        svfloat32_t res = svmul_x(pg_vl, idx_vec, xs_vec);\n        \n        svst1(pg_vl, &result[i], res);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs){\n    int n = xs.size();\n    if (n <= 1) return {};\n\n    std::vector<float> result(n - 1, 0.0f);\n\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    for(int i = 0; i < n - 1; i += vl){\n        size_t k = n - 1 - i;\n        size_t num_vectors = (k + vl - 1) / vl;\n\n        for(size_t j = 0; j < num_vectors; ++j){\n            size_t idx_start = i + j * vl;\n            size_t idx_end = idx_start + vl;\n            if(idx_end > n - 1){\n                idx_end = n - 1;\n                pg = svwhilelt_b32(idx_start, n - 1);\n            }\n\n            svfloat32_t vec_coeffs = svld1(pg, &xs[idx_start + 1]);\n            svfloat32_t vec_indices = svindex_f32(idx_start + 1, 1.0f);\n            svfloat32_t vec_result = svmul_x(pg, vec_coeffs, vec_indices);\n            svst1(pg, &result[idx_start], vec_result);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs){\n    if (xs.size() <= 1) return {};\n\n    size_t n = xs.size() - 1;\n    std::vector<float> result(n);\n\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    for(size_t i = 0; i < n; i += vl){\n        size_t k = n - i;\n        size_t num = (k > vl) ? vl : k;\n\n        svbool_t pred = svwhilelt_b32(i, i + num);\n        svint32_t indices = svindex_s32(0, 1);\n        svfloat32_t coeffs = svld1_f32(pred, &xs[i+1]);\n        svfloat32_t res = svmul_f32(pred, svconvert_f32_s32(pred, indices), coeffs);\n        svst1_f32(pred, &result[i], res);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.size() <= 1) return {};\n\n    size_t n = xs.size() - 1;\n    std::vector<float> result(n);\n\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < n; i += vl) {\n        size_t k = n - i;\n        size_t num_active = (k > vl) ? vl : k;\n\n        svbool_t pg_active = svwhilelt_b32(i, i + num_active);\n\n        svint32_t indices = svindex_s32(0, 1);\n        svfloat32_t coeffs = svld1(pg_active, &xs[i + 1]);\n        svfloat32_t factors = svconvert_f32_s32(pg_active, svadd_n_s32(indices, i));\n\n        svst1(pg_active, &result[i], svmla_x(pg_active, coeffs, factors, SV_ZERO));\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs){\n    size_t n = xs.size();\n    if (n <= 1) return {};\n\n    std::vector<float> result(n - 1, 0.0f);\n\n    size_t vl = svcntw(); // Vector length in terms of number of float elements\n    size_t i = 0;\n\n    for (; i + vl <= n - 1; i += vl) {\n        svbool_t pg = svptrue_b32();\n        svfloat32_t vec_x = svld1(pg, &xs[i + 1]);\n        svint32_t indices = svindex_s32(i + 1, 1);\n        svfloat32_t vec_res = svmul_x_f32(pg, vec_x, svcvt_f32_x_s32(pg, indices));\n        svst1(pg, &result[i], vec_res);\n    }\n\n    for (; i < n - 1; ++i) {\n        result[i] = xs[i + 1] * (i + 1);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <cctype>\n#include <string>\n\nint vowels_count_simd(std::string s){\n    int count = 0;\n    const uint8_t* str = reinterpret_cast<const uint8_t*>(s.c_str());\n    size_t len = s.length();\n    svbool_t pg = svptrue_b8();\n    svuint8_t vowels = svdup_n_u8('a');\n    \n    // Prepare a vector of vowels: 'a', 'e', 'i', 'o', 'u'\n    svuint8_t vowel_list = svdup_n_u8(0);\n    uint8_t vowel_chars[] = {'a', 'e', 'i', 'o', 'u'};\n    for (size_t i = 0; i < sizeof(vowel_chars); ++i) {\n        vowel_list = svinslane_u8(vowel_list, pg, vowel_chars[i], i);\n    }\n\n    size_t i = 0;\n    svbool_t y_check = svfalse_b8();\n    while (i + svcntb() <= len) {\n        svuint8_t vec = svld1(pg, str + i);\n        svbool_t is_vowel = svcmpeq_any_u8(svindex_n_u8(0,1), vowel_list);\n        count += svcntp(is_vowel, pg);\n        \n        if (i + svcntb() == len - 1) {\n            y_check = svcmpeq_n_u8(vec, 'y' | ('Y' - 'y'));\n            count += svcntp(y_check, pg);\n        }\n        i += svcntb();\n    }\n\n    // Tail handling\n    for (; i < len; ++i) {\n        char c = tolower(s[i]);\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        } else if (c == 'y' && i == len - 1) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <cctype>\n#include <string>\n\nint vowels_count_simd(std::string s){\n    int count = 0;\n    if (s.empty()) return count;\n\n    const uint8_t* str = reinterpret_cast<const uint8_t*>(s.c_str());\n    size_t len = s.length();\n    svbool_t pg = svptrue_b8();\n\n    // Define the vowels in both lowercase and uppercase\n    uint8_t vowels[] = { 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U' };\n    svuint8_t sv_vowels = svld1_u8(pg, vowels);\n\n    size_t i = 0;\n    for (; i + svcntb() <= len; i += svcntb()) {\n        svuint8_t vec = svld1_u8(pg, str + i);\n        svbool_t is_vowel = svorr_b(pg, svcmpeq_u8(pg, vec, sv_vowels), svcmpeq_u8(pg, vec, 'y'));\n        is_vowel = svorr_b(pg, is_vowel, svcmpeq_u8(pg, vec, 'Y'));\n        count += svpopcnt_b8(pg, is_vowel);\n    }\n\n    // Handle remaining scalar elements\n    for (; i < len; ++i) {\n        char c = std::tolower(s[i]);\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || \n            (c == 'y' && i == len - 1)) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <cctype>\n#include <string>\n\nint vowels_count_simd(std::string s){\n    int count = 0;\n    const uint8_t* str = reinterpret_cast<const uint8_t*>(s.c_str());\n    size_t len = s.length();\n    svbool_t pg = svptrue_b8();\n\n    // Define the vowels mask (including 'y' which will be handled separately)\n    uint8_t vowels[6] = {'a', 'e', 'i', 'o', 'u', 'y'};\n    svuint8_t sv_vowels = svld1_u8(pg, vowels);\n\n    size_t i = 0;\n    for (; i + svcntb() <= len; i += svcntb()) {\n        svuint8_t vec = svld1_u8(pg, str + i);\n        svuint8_t lower_vec = svand_u8(pg, vec, svdup_n_u8(0xDF)); // Convert to uppercase\n\n        // Check if each character is a vowel (excluding 'y')\n        svbool_t is_vowel = svcmpeq_any_u8(lower_vec, sv_vowels);\n\n        // Count the number of vowels in this vector\n        count += svcntp_b8(pg, is_vowel);\n    }\n\n    // Handle remaining scalar elements\n    for (; i < len; ++i) {\n        char c = std::tolower(static_cast<unsigned char>(s[i]));\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        } else if (c == 'y' && i == len - 1) {\n            count++;\n        }\n    }\n\n    // Check if 'y' is at the end of the string\n    if (!s.empty() && std::tolower(static_cast<unsigned char>(s.back())) == 'y') {\n        count++;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cctype>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    int count = 0;\n    const uint8_t* str = reinterpret_cast<const uint8_t*>(s.c_str());\n    size_t len = s.size();\n    svbool_t pg = svptrue_b8();\n\n    // Define the vowels 'a', 'e', 'i', 'o', 'u' in both lowercase and uppercase\n    uint8_t vowels[] = { 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U' };\n    svuint8_t sv_vowels = svld1(pg, vowels);\n\n    size_t i = 0;\n    for (; i + svcntb() <= len; i += svcntb()) {\n        svuint8_t sv_char = svld1(pg, str + i);\n        svbool_t is_vowel = svfalse_b8();\n        for (int j = 0; j < 10; j++) {\n            svbool_t match = svcmpeq_b8(pg, sv_char, svdup_n_u8(vowels[j]));\n            is_vowel = svbor_b8(pg, is_vowel, match);\n        }\n        count += svcntp(is_vowel, pg);\n    }\n\n    // Handle remaining scalar elements\n    for (; i < len; ++i) {\n        char c = std::tolower(s[i]);\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        } else if (c == 'y' && i == len - 1) {\n            count++;\n        }\n    }\n\n    // Check if 'y' or 'Y' is at the end of the word\n    if (!s.empty() && (std::tolower(s.back()) == 'y')) {\n        count++;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cctype>\n#include <string>\n\nint vowels_count_simd(std::string s){\n    int count = 0;\n    const uint8_t* str = reinterpret_cast<const uint8_t*>(s.c_str());\n    size_t len = s.length();\n    svbool_t pg = svptrue_b8();\n    svuint8_t vowels = svdup_n_u8('a');\n    \n    // Prepare a vector of vowels: 'a', 'e', 'i', 'o', 'u'\n    svuint8_t v_a = svdup_n_u8('a');\n    svuint8_t v_e = svdup_n_u8('e');\n    svuint8_t v_i = svdup_n_u8('i');\n    svuint8_t v_o = svdup_n_u8('o');\n    svuint8_t v_u = svdup_n_u8('u');\n    svuint8_t v_y = svdup_n_u8('y');\n    \n    size_t i = 0;\n    for (; i + svcntb() <= len; i += svcntb()) {\n        svuint8_t vec = svld1(pg, str + i);\n        svbool_t is_a = svcmpeq(pg, vec, v_a);\n        svbool_t is_e = svcmpeq(pg, vec, v_e);\n        svbool_t is_i = svcmpeq(pg, vec, v_i);\n        svbool_t is_o = svcmpeq(pg, vec, v_o);\n        svbool_t is_u = svcmpeq(pg, vec, v_u);\n        \n        // Check if 'y' is at the end of the word\n        svbool_t is_y = svcmpeq(pg, vec, v_y);\n        svbool_t is_last = svcmpeq(pg, svindex_n_s64(i, 1), svdup_n_s64(len - 1));\n        is_y = svand(pg, is_y, is_last);\n\n        // Combine all vowel checks\n        svbool_t is_vowel = svorr(pg, is_a, is_e);\n        is_vowel = svorr(pg, is_vowel, is_i);\n        is_vowel = svorr(pg, is_vowel, is_o);\n        is_vowel = svorr(pg, is_vowel, is_u);\n        is_vowel = svorr(pg, is_vowel, is_y);\n\n        count += svpopcnt_b8(is_vowel);\n    }\n\n    // Scalar tail processing\n    for (; i < len; ++i) {\n        char c = std::tolower(str[i]);\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || (c == 'y' && i == len - 1)) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n\nint digitSum_simd(std::string s){\n    int sum = 0;\n    size_t vec_len = svcntb();\n    size_t len = s.length();\n    const unsigned char* str = reinterpret_cast<const unsigned char*>(s.c_str());\n    \n    svbool_t pg = svptrue_b8();\n    svuint8_t zero = svdup_n_u8(0);\n    svuint8_t upper_A = svdup_n_u8('A');\n    svuint8_t upper_Z = svdup_n_u8('Z');\n    \n    for (size_t i = 0; i + vec_len <= len; i += vec_len) {\n        svuint8_t vec = svld1_u8(pg, str + i);\n        svbool_t is_upper = svand_b8(svcmeq_u8(vec, upper_A), svcle_u8(vec, upper_Z));\n        svuint8_t masked_vec = svsel_u8(is_upper, vec, zero);\n        svuint8_t partial_sums = svhadd_u8(masked_vec, masked_vec);\n        uint64x2_t tmp = svaddv_u8(partial_sums);\n        sum += static_cast<int>(vaddvq_u32(vreinterpretq_u32_u8(tmp)));\n    }\n    \n    // Handle remaining elements\n    if (len % vec_len != 0) {\n        size_t i = len - (len % vec_len);\n        svbool_t pg_remain = sv interpreted as the number of active lanes.\n        svuint8_t vec = svld1_u8(pg_remain, str + i);\n        svbool_t is_upper = svand_b8(svcmeq_u8(vec, upper_A), svcle_u8(vec, upper_Z));\n        svuint8_t masked_vec = svsel_u8(is_upper, vec, zero);\n        svuint8_t partial_sums = svhadd_u8(masked_vec, masked_vec);\n        uint64x2_t tmp = svaddv_u8(partial_sums);\n        sum += static_cast<int>(vaddvq_u32(vreinterpretq_u32_u8(tmp)));\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n\nint digitSum_simd(std::string s){\n    int result = 0;\n    size_t len = s.length();\n    if (len == 0) return 0;\n\n    svbool_t pg = svptrue_b8();\n    const uint8_t upper_limit = 'Z';\n    const uint8_t lower_limit = 'A';\n\n    size_t i = 0;\n    for (; i <= len - svcntb(); i += svcntb()) {\n        svuint8_t vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&s[i]));\n        svuint8_t filtered = svsel_u8(pg, vec, svdup_n_u8(0));\n        filtered = svand_u8(pg, filtered, svcmpge_u8(pg, vec, svdup_n_u8(lower_limit)));\n        filtered = svand_u8(pg, filtered, svcmple_u8(pg, vec, svdup_n_u8(upper_limit)));\n        result += svaddv_u8(pg, filtered);\n    }\n\n    for (; i < len; ++i) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            result += static_cast<uint8_t>(s[i]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n\nint digitSum_simd(std::string s){\n    int sum = 0;\n    size_t len = s.length();\n    if (len == 0) return 0;\n\n    svbool_t pg = svptrue_b8();\n    const uint8_t upper_mask = 0x40; // Mask for checking uppercase letters (bit 6 is set)\n\n    size_t i = 0;\n    for (; i + svcntb() <= len; i += svcntb()) {\n        svuint8_t vec = svld1(pg, reinterpret_cast<const uint8_t*>(&s[i]));\n        svuint8_t masked_vec = svand_u8(pg, vec, svdup_n_u8(upper_mask));\n        svbool_t is_upper = svcmpeq(pg, masked_vec, svdup_n_u8(upper_mask));\n        svuint8_t upper_chars = svsel_u8(is_upper, vec, svdup_n_u8(0));\n        svuint32_t partial_sums = svaddv_u8(pg, upper_chars);\n        sum += svaddv_u32(pg, partial_sums);\n    }\n\n    for (; i < len; ++i) {\n        if ((s[i] & upper_mask) == upper_mask) {\n            sum += static_cast<unsigned char>(s[i]);\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n\nint digitSum_simd(std::string s){\n    int result = 0;\n    size_t index = 0;\n    size_t vec_len = s.size();\n\n    svbool_t pg = svptrue_b8(); // Predicate for all true\n    const uint8_t upper_limit = 'Z';\n    const uint8_t lower_limit = 'A';\n\n    while (index <= vec_len - svcntb()) {\n        svuint8_t vec = svld1(pg, reinterpret_cast<const uint8_t*>(&s[index]));\n        svuint8_t masked_vec = svand_u8(vec, svcmpge_u8(vec, lower_limit));\n        masked_vec = svand_u8(masked_vec, svcmple_u8(vec, upper_limit));\n        result += svaddv_u8(pg, masked_vec);\n        index += svcntb();\n    }\n\n    // Tail handling\n    if (index < vec_len) {\n        size_t left = vec_len - index;\n        svbool_t tail_pg = svwhilelt_b8(index, vec_len);\n        svuint8_t vec = svld1(tail_pg, reinterpret_cast<const uint8_t*>(&s[index]));\n        svuint8_t masked_vec = svand_u8(vec, svcmpge_u8(vec, lower_limit));\n        masked_vec = svand_u8(masked_vec, svcmple_u8(vec, upper_limit));\n        result += svaddv_u8(tail_pg, masked_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n\nint digitSum_simd(std::string s){\n    int sum = 0;\n    if (s.empty()) return 0;\n\n    const unsigned char* str = reinterpret_cast<const unsigned char*>(s.c_str());\n    size_t len = s.size();\n    svbool_t pg = svptrue_b8();\n\n    while (len >= svcntb()) {\n        svuint8_t vec = svld1_u8(pg, str);\n        svuint8_t upper_chars = svand_u8(pg, vec, svcmpge_u8(pg, vec, svdup_n_u8('A'))); // Filter >= 'A'\n        upper_chars = svand_u8(pg, upper_chars, svcmple_u8(pg, upper_chars, svdup_n_u8('Z'))); // Filter <= 'Z'\n        svuint8_t zero_vec = svdup_n_u8(0);\n        svuint8_t masked = svsel_u8(pg, upper_chars, zero_vec); // Mask non-upper characters\n        sum += svaddv_u8(pg, masked); // Add the ASCII values of upper characters\n\n        str += svcntb();\n        len -= svcntb();\n    }\n\n    // Handle leftover characters\n    if (len > 0) {\n        svbool_t pg_partial = svwhilelt_b8(len, svcntb());\n        svuint8_t vec = svld1_u8(pg_partial, str);\n        svuint8_t upper_chars = svand_u8(pg_partial, vec, svcmpge_u8(pg_partial, vec, svdup_n_u8('A')));\n        upper_chars = svand_u8(pg_partial, upper_chars, svcmple_u8(pg_partial, upper_chars, svdup_n_u8('Z')));\n        svuint8_t zero_vec = svdup_n_u8(0);\n        svuint8_t masked = svsel_u8(pg_partial, upper_chars, zero_vec);\n        sum += svaddv_u8(pg_partial, masked);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n\n    svbool_t pg = svptrue_b32();\n    size_t vec_len = arr.size();\n    size_t vl = svcntw();\n\n    int min_even = INT32_MAX;\n    int min_index = -1;\n\n    for (size_t i = 0; i < vec_len; i += vl) {\n        size_t chunk_size = (vec_len - i > vl) ? vl : vec_len - i;\n        svbool_t pg_chunk = svwhilelt_b32(i, i + chunk_size);\n\n        // Load the current chunk of data\n        svint32_t data = svld1(pg_chunk, &arr[i]);\n\n        // Check for even numbers\n        svbool_t is_even = svand_z(pg, svcmpeq_z(pg, svarith_rshift_s32(pg, data, 1), 0), pg_chunk);\n\n        // Filter out only even numbers\n        svint32_t even_data = svsel(is_even, data, svdup_n_s32(INT32_MAX));\n\n        // Find the minimum value and its index in this chunk\n        svuint32_t indices = svindex_u32((uint32_t)i, 1);\n        svuint32_t min_indices = svminima_idx(pg_chunk, even_data);\n\n        int chunk_min = svminv(pg_chunk, even_data);\n        int chunk_min_idx = svminv_idx(pg_chunk, even_data);\n\n        if (chunk_min < min_even) {\n            min_even = chunk_min;\n            min_index = chunk_min_idx;\n        }\n    }\n\n    if (min_even == INT32_MAX) return {};\n    return {min_even, min_index};\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n\n    svbool_t pg = svptrue_b32();\n    size_t vec_len = arr.size();\n    size_t vl = svcntw(); // Vector length in terms of 32-bit elements\n    size_t nitt = (vec_len + vl - 1) / vl; // Number of iterations\n\n    int min_val = INT32_MAX;\n    int min_idx = -1;\n\n    for (size_t i = 0; i < nitt; ++i) {\n        size_t start = i * vl;\n        size_t end = (start > vec_len) ? vec_len : start + vl;\n\n        svint32_t svec = svdup_s32(0);\n        if (end - start == vl) {\n            svec = svld1(pg, &arr[start]);\n        } else {\n            svint32_t zero_vec = svdup_s32(0);\n            svec = svld1_gather_offset_z(pg, zero_vec, &arr[0], svindex_s64(start, 1));\n        }\n\n        // Check for even numbers\n        svbool_t is_even = svcmpeq_m(pg, svand_x(pg, svec, svdup_n_s32(1)), svdup_n_s32(0));\n\n        // Find the minimum value among the even numbers\n        svint32_t pred_min_val = svminval_mask(pg, is_even, svec);\n\n        // Get the index of the minimum value\n        svuint32_t indices = svindex_s32((int)start, 1);\n        svuint32_t pred_min_idx = svminval_mask(pg, is_even, indices);\n\n        // Extract scalar values if a new minimum is found\n        if (svptest_any(svptrue_b32(), is_even)) {\n            int current_min_val = svminv_s32(pg, pred_min_val);\n            if (current_min_val < min_val) {\n                min_val = current_min_val;\n                min_idx = svminv_u32(pg, pred_min_idx);\n            }\n        }\n    }\n\n    if (min_idx != -1) {\n        return {min_val, min_idx};\n    } else {\n        return {};\n    }\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdint>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n    int32x4_t result = {INT32_MAX, INT32_MAX, 0, 0};\n    size_t num_elements = arr.size();\n\n    for (size_t i = 0; i < num_elements; i += vl) {\n        size_t count = (num_elements - i > vl) ? vl : num_elements - i;\n        svbool_t pg_count = svwhilelt_b32(i, num_elements);\n\n        // Load data\n        svint32_t vec = svld1(pg_count, &arr[i]);\n\n        // Check for even numbers\n        svbool_t is_even = svand_x(pg_count, sveq_z(pg_count, svmul_x(pg_count, svdup_n_s32(2), svshrq_n_s32(vec, 1)), svtrue_p(sveq_z)));\n\n        // Get indices\n        svint32_t indices = svindex(pg_count, i);\n\n        // Select even numbers and their indices\n        svint32_t even_numbers = svsel(is_even, vec, svdup_n_s32(INT32_MAX));\n        svint32_t even_indices = svsel(is_even, indices, svdup_n_s32(INT32_MAX));\n\n        // Find minimum even number and its index\n        svuint32_t min_idx = svminv_idx_u32(pg_count, svreinterpret_u32_s32(even_numbers));\n        int32_t min_val = svget_lane_s32(svminv_z(pg_count, even_numbers), 0);\n        int32_t min_idx_val = svget_lane_s32(svminv_z(pg_count, even_indices), 0);\n\n        // Update result if smaller value or same value with smaller index\n        if (min_val < svget_lane_s32(result, 0) || (min_val == svget_lane_s32(result, 0) && min_idx_val < svget_lane_s32(result, 1))) {\n            result = svdup_n_s32(min_val);\n            result = svins_lane_s32(result, 1, min_idx_val);\n        }\n    }\n\n    if (svget_lane_s32(result, 0) == INT32_MAX) return {};\n    return {svget_lane_s32(result, 0), svget_lane_s32(result, 1)};\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdint>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n\n    svbool_t pg = svptrue_b32();\n    size_t vec_len = arr.size();\n    size_t vl = svcntw(); // Vector length in terms of lanes\n    size_t n_iter = (vec_len + vl - 1) / vl;\n\n    int32x4_t min_val = {INT32_MAX, INT32_MAX, INT32_MAX, INT32_MAX};\n    uint32x4_t min_idx = {UINT32_MAX, UINT32_MAX, UINT32_MAX, UINT32_MAX};\n\n    for (size_t i = 0; i < n_iter; ++i) {\n        size_t start_idx = i * vl;\n        size_t end_idx = std::min(start_idx + vl, vec_len);\n\n        svint32_t v = svld1(pg, &arr[start_idx]);\n        svint32_t even_mask = svand_x(pg, v, svdup_n_s32(1));\n        svbool_t is_even = svcmpeq(pg, even_mask, svdup_n_s32(0));\n\n        svint32_t cmp_val = svminv_m(pg, is_even, v, min_val);\n        svuint32_t cmp_idx = svminv_idx_m(pg, is_even, svindex_n_u32(start_idx), min_idx);\n\n        min_val = cmp_val;\n        min_idx = cmp_idx;\n    }\n\n    int min_value = INT32_MAX;\n    int min_index = -1;\n\n    for (int i = 0; i < 4; ++i) {\n        if (min_val[i] < min_value || (min_val[i] == min_value && min_idx[i] < min_index)) {\n            min_value = min_val[i];\n            min_index = min_idx[i];\n        }\n    }\n\n    if (min_value == INT32_MAX) return {};\n    return {min_value, min_index};\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdint>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n\n    uint32_t vl = sve_vl();\n    size_t n = arr.size();\n    int32_t result_value = -1;\n    int32_t result_index = -1;\n\n    for (size_t i = 0; i < n; i += vl) {\n        svbool_t pg = svptrue_b32();\n        svint32_t vec = svld1(pg, &arr[i]);\n\n        // Check for even numbers\n        svbool_t is_even = svand_b32(pg, svcmpeq_m(pg, svmul_x(pg, svindex_z(pg, 0, 1), 2), vec));\n\n        // Check for smallest even number\n        svbool_t is_smaller = svcmplt_m(pg, vec, svdup_n_s32(result_value));\n        svbool_t update_mask = svand_b32(pg, is_even, is_smaller);\n\n        // Update result value and index\n        int32x4_t min_val = svminv(update_mask, vec);\n        if (min_val != INT32_MAX) {\n            result_value = min_val;\n            int32x4_t min_idx = svminv_idx(update_mask, svindex_z(pg, i, 1));\n            result_index = min_idx;\n        }\n    }\n\n    if (result_value == -1) return {};\n    return {result_value, result_index};\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <unordered_map>\n\nint search_simd(std::vector<int> lst){\n    if (lst.empty()) return -1;\n\n    // Calculate frequency using a hash map\n    std::unordered_map<int, int> freq;\n    for(auto num : lst){\n        freq[num]++;\n    }\n\n    // Determine the maximum possible value in the list\n    int max_val = *max_element(lst.begin(), lst.end());\n\n    // Prepare SVE predicates and vectors\n    svbool_t pg = svptrue_b32();\n    svint32_t result = svdup_n_s32(-1);\n\n    for(int i = 1; i <= max_val; ++i){\n        if(freq[i] >= i){\n            svint32_t candidate = svdup_n_s32(i);\n            result = svmovmla_x(pg, result, candidate);\n        }\n    }\n\n    // Extract the final result from the vector\n    int scalar_result = svlasta_s32(result);\n\n    return scalar_result;\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <unordered_map>\n\nint search_simd(std::vector<int> lst){\n    if (lst.empty()) return -1;\n\n    // Count frequencies using a hash map\n    std::unordered_map<int, int> freq;\n    for(auto num : lst){\n        freq[num]++;\n    }\n\n    // Determine the maximum possible value in the list\n    int max_val = *std::max_element(lst.begin(), lst.end());\n\n    // Prepare SVE-related variables\n    svbool_t pg = svptrue_b32();\n    svint32_t result = svdup_n_s32(-1);\n    svint32_t max_value = svdup_n_s32(max_val);\n\n    // Iterate through potential candidates in reverse order\n    for(int i = max_val; i > 0; --i){\n        if(freq[i] >= i){\n            svint32_t candidate = svdup_n_s32(i);\n            result = svmax_s32(pg, result, candidate);\n        }\n    }\n\n    // Extract the scalar result from the SVE vector\n    int final_result = svlasta_s32(result);\n\n    return final_result == -1 ? -1 : final_result;\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst){\n    if (lst.empty()) return -1;\n\n    size_t n = lst.size();\n    int max_val = *std::max_element(lst.begin(), lst.end());\n    if (max_val <= 0) return -1;\n\n    // Initialize frequency array\n    std::vector<int> freq(max_val + 1, 0);\n\n    // Count frequencies using SVE\n    size_t vl = svcntw(); // Vector length in elements for word size\n    for (size_t i = 0; i < n; i += vl) {\n        svbool_t pg = svptrue_b32(); // Predicate for all active lanes\n        svint32_t vec = svld1(pg, &lst[i]); // Load vector of integers\n        svint32_t ones = svdup_n_s32(1); // Create a vector of ones\n\n        // Compute histogram in parallel\n        for (int j = 1; j <= max_val; ++j) {\n            svbool_t cmp = svcmpeq(pg, vec, svdup_n_s32(j)); // Compare each element with j\n            freq[j] += svpopcnt_s32(cmp); // Add the count of matches\n        }\n    }\n\n    // Find the greatest integer satisfying the condition\n    int result = -1;\n    for (int i = max_val; i > 0; --i) {\n        if (freq[i] >= i) {\n            result = i;\n            break;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst){\n    int max_val = *std::max_element(lst.begin(), lst.end());\n    if (max_val > 128) max_val = 128;\n\n    svbool_t pg = svptrue_b32();\n    svint32_t zero = svdup_s32(0);\n\n    std::vector<int> freq(max_val + 1, 0);\n\n    size_t num_elements = lst.size();\n    size_t vec_len = svcntw();\n    size_t i = 0;\n\n    // Compute frequency using SVE\n    for (; i <= num_elements - vec_len; i += vec_len) {\n        svint32_t vl = svld1(pg, &lst[i]);\n        svint32_t idx = svmin_u32(pg, vl, svdup_n_s32(max_val));\n        svint32_t ones = svdup_n_s32(1);\n        for (int j = 0; j <= max_val; ++j) {\n            svbool_t cmp = svcmpeq(pg, idx, svdup_n_s32(j));\n            int count = svaddv(pg, svand(cmp, ones));\n            freq[j] += count;\n        }\n    }\n\n    // Handle remaining scalar elements\n    for (; i < num_elements; ++i) {\n        if (lst[i] <= max_val) freq[lst[i]]++;\n    }\n\n    // Find the greatest integer satisfying the condition\n    int result = -1;\n    for (int k = 1; k <= max_val; ++k) {\n        if (freq[k] >= k) result = k;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst){\n    int max_val = *std::max_element(lst.begin(), lst.end());\n    if (max_val <= 0) return -1;\n\n    svbool_t pg = svptrue_b32();\n    svint32_t zero = svdup_n_s32(0);\n\n    // Create a frequency array\n    std::vector<int> freq(max_val + 1, 0);\n    size_t vec_len = lst.size();\n    size_t index = 0;\n\n    while (index < vec_len) {\n        size_t num_elts = svcntw();\n        if (index + num_elts > vec_len) num_elts = vec_len - index;\n\n        svint32_t vl = svld1(pg, &lst[index]);\n        svint32_t ones = svdup_n_s32(1);\n\n        for (int i = 0; i <= max_val; ++i) {\n            svbool_t cmp = svcmpeq(pg, vl, svdup_n_s32(i));\n            svst1(cmp, &freq[i], ones);\n        }\n\n        index += num_elts;\n    }\n\n    int result = -1;\n    for (int i = max_val; i >= 1; --i) {\n        if (freq[i] >= i) {\n            result = i;\n            break;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w){\n    if (q.empty()) return false;\n\n    size_t n = q.size();\n    svbool_t pg = svptrue_b32();\n    svint32_t sum_vec = svdup_n_s32(0);\n\n    // Calculate the sum using SVE\n    for(size_t i = 0; i < n; i += svcntw()){\n        size_t chunk = svcntw();\n        svint32_t vec = svld1_s32(pg, &q[i]);\n        sum_vec = svadd_s32(pg, sum_vec, vec);\n    }\n\n    int sum = 0;\n    svint32_t zero = svdup_n_s32(0);\n    sum_vec = svaddv_s32(pg, sum_vec);\n    sum = svaddv_s32(pg, sum_vec)[0];\n\n    // Check if the vector is a palindrome using SVE\n    bool is_palindrome = true;\n    for(size_t i = 0; i < n / 2; ++i){\n        if(q[i] != q[n - i - 1]){\n            is_palindrome = false;\n            break;\n        }\n    }\n\n    return is_palindrome && (sum <= w);\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w){\n    if (q.empty()) return false;\n\n    size_t n = q.size();\n    svbool_t pg = svptrue_b32();\n    svint32_t sum_vec = svdup_s32(0);\n\n    // Calculate the sum using SVE intrinsics\n    for(size_t i = 0; i < n; i += svcntw()){\n        size_t chunk = svcntw();\n        size_t limit = (n - i) < chunk ? (n - i) : chunk;\n        svbool_t pred = svwhilelt_b32(i, limit + i);\n        svint32_t vec = svld1_gather_index_z_s32(pg, pred, &q[i], svindex_s64(0, 1));\n        sum_vec = svadd_s32_m(pg, pred, sum_vec, vec);\n    }\n\n    int sum = 0;\n    sum = svaddv_s32(pg, sum_vec);\n\n    // Check if the vector is a palindrome using SVE intrinsics\n    bool is_palindrome = true;\n    for(size_t i = 0; i < n / 2 && is_palindrome; ++i){\n        if(q[i] != q[n - i - 1]){\n            is_palindrome = false;\n        }\n    }\n\n    return is_palindrome && sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w){\n    if (q.empty()) return false;\n\n    size_t n = q.size();\n    svbool_t pg = svptrue_b32();\n    svint32_t sum_vec = svdup_n_s32(0);\n\n    // Calculate the sum using SVE\n    for(size_t i = 0; i < n; i += svcntw()){\n        size_t chunk = svcntw();\n        svint32_t vec = svld1_s32(pg, &q[i]);\n        sum_vec = svadd_s32(pg, sum_vec, vec);\n    }\n\n    int sum = 0;\n    svint32_t zero = svdup_n_s32(0);\n    sum_vec = svaddv_s32(pg, zero, sum_vec);\n    sum = svaddv_s32(pg, zero, sum_vec)[0];\n\n    if(sum > w) return false;\n\n    // Check if the vector is a palindrome\n    for(size_t i = 0; i < n / 2; ++i){\n        if(q[i] != q[n - i -1]) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w){\n    if (q.empty()) return false;\n\n    size_t n = q.size();\n    svbool_t pg = svptrue_b32();\n    svint32_t sum_vec = svdup_s32(0);\n\n    // Calculate the sum using SVE\n    for(size_t i = 0; i < n; i += svcntw()){\n        size_t k = svcntw();\n        size_t j = i + k > n ? n - i : k;\n        svint32_t vec = svld1_s32(pg, &q[i]);\n        sum_vec = svadd_s32(pg, sum_vec, vec);\n    }\n\n    // Horizontal sum\n    int32_t total_sum = 0;\n    for(size_t i = 0; i < svcntw(); ++i){\n        total_sum += svget_lane_s32(sum_vec, i);\n    }\n\n    // Check if the sum exceeds weight\n    if(total_sum > w) return false;\n\n    // Check if the vector is a palindrome\n    size_t half = n / 2;\n    for(size_t i = 0; i < half; ++i){\n        if(q[i] != q[n - i - 1]) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w){\n    if (q.empty()) return false;\n\n    size_t n = q.size();\n    svbool_t pg = svptrue_b32();\n    svint32_t sum_vec = svdup_n_s32(0);\n\n    // Calculate the sum using SVE\n    for(size_t i = 0; i < n; i += svcntw()){\n        size_t chunk_size = svcntw();\n        size_t k = n - i < chunk_size ? n - i : chunk_size;\n        svbool_t pred = svwhilelt_b32(i, n);\n        svint32_t vec = svld1_idx_s32(pred, &q[0], i);\n        sum_vec = svadd_s32(pg, sum_vec, vec);\n    }\n\n    int total_sum = 0;\n    svint32_t sum_zero = svdup_n_s32(0);\n    total_sum = svaddv_s32(pg, sum_vec);\n\n    // Check if the vector is a palindrome using SVE\n    bool is_palindrome = true;\n    for(size_t i = 0; i < n / 2; ++i){\n        if(q[i] != q[n - i - 1]){\n            is_palindrome = false;\n            break;\n        }\n    }\n\n    return is_palindrome && total_sum <= w;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr){\n    int n = arr.size();\n    int changes = 0;\n\n    svbool_t pg = svptrue_b32(); // Predicate for all true\n    intvl_t vchanges = svdup_n_s32(0); // Vector to accumulate changes\n\n    for(int i = 0; i < n / 2; ){\n        // Load elements from start and end\n        svint32_t vstart = svld1(pg, &arr[i]);\n        svint32_t vend = svld1(pg, &arr[n - i - 1]);\n\n        // Compare elements\n        svbool_t mismatch = svcmpne_z(pg, vstart, vend);\n\n        // Count mismatches\n        intvl_t count = svmovl(mismatch);\n        vchanges = svadd_z(pg, vchanges, count);\n\n        // Update index by vector length\n        int vl = svcntw();\n        i += vl;\n    }\n\n    // Horizontal sum of changes\n    changes = svaddv(vchanges);\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr){\n    int n = arr.size();\n    intvl_t changes = 0;\n    svbool_t pg = svptrue_b32();\n\n    for(int i=0; i < n/2; ){\n        svint32_t left = svld1(pg, &arr[i]);\n        svint32_t right = svld1(pg, &arr[n - i - 1]);\n\n        svuint32_t diff = svcmpeq(pg, left, right);\n        svuint32_t count = svcntb(pg, diff);\n\n        changes += svcntp_b32(pg, count);\n        i += svcntw();\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstddef>\n\nint smallest_change_simd(std::vector<int> arr){\n    size_t n = arr.size();\n    int changes = 0;\n\n    svbool_t pg = svptrue_b32(); // Predicate for all true\n    size_t vl = svcntw(); // Vector length in terms of the number of 32-bit elements\n\n    for(size_t i = 0; i < n / 2; i += vl){\n        size_t j = n - i - 1;\n        size_t len = (n / 2 - i < vl) ? n / 2 - i : vl;\n\n        svint32_t left = svld1(pg, &arr[i]);\n        svint32_t right = svld1(pg, &arr[j]);\n\n        svbool_t mismatch = svcmpne_z(pg, left, right);\n        changes += svpopcnt_b32(mismatch) - (vl - len);\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr){\n    int n = arr.size();\n    int changes = 0;\n\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    for(int i = 0; i < n / 2; i += vl){\n        size_t k = (n / 2 - i) < vl ? (n / 2 - i) : vl;\n        svbool_t pgi = svwhilelt_b32(i, i + k);\n\n        int *left_ptr = &arr[i];\n        int *right_ptr = &arr[n - i - 1];\n\n        svint32_t left_vec = svld1(pgi, left_ptr);\n        svint32_t right_vec = svld1(pgi, right_ptr);\n\n        svbool_t mismatch = svcmpne(pgi, left_vec, right_vec);\n\n        changes += svmovemask_b32(mismatch);\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr){\n    int n = arr.size();\n    int changes = 0;\n\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    for(int i = 0; i < (n + vl - 1) / vl; ++i){\n        int idx_start = i * vl;\n        if(idx_start >= n / 2)\n            break;\n\n        svint32_t left_vec = svld1(pg, &arr[idx_start]);\n        svint32_t right_vec = svld1(pg, &arr[n - 1 - idx_start]);\n\n        svbool_t mismatch = svcmpne(pg, left_vec, right_vec);\n        changes += svpopcnt(mismatch);\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    auto count_chars = [](const std::vector<std::string> &lst) -> size_t {\n        if (lst.empty()) return 0;\n\n        size_t total = 0;\n        svbool_t pg = svptrue_b8();\n        for (const auto& str : lst) {\n            size_t len = str.length();\n            // Use SVE to sum lengths in parallel (simulated here with a loop)\n            svuint8_t vec_len = svdup_n_u8(len);\n            svuint64_t sum_vec = svaddv_u8(pg, vec_len);\n            total += (size_t)sum_vec;\n        }\n        return total;\n    };\n\n    size_t total1 = count_chars(lst1);\n    size_t total2 = count_chars(lst2);\n\n    if (total1 <= total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    int count_chars(const std::vector<std::string> &);\n    \n    int total1 = count_chars(lst1);\n    int total2 = count_chars(lst2);\n\n    if(total1 <= total2){\n        return lst1;\n    }\n    else{\n        return lst2;\n    }\n}\n\nint count_chars(const std::vector<std::string> &lst){\n    int total = 0;\n    for(const auto& str : lst){\n        svbool_t pg = svptrue_b8();\n        size_t vec_len = str.length();\n        size_t i = 0;\n\n        // Process vectorized characters\n        for (; i + svcntb() <= vec_len; i += svcntb()) {\n            svuint8_t vec = svld1(pg, reinterpret_cast<const uint8_t*>(&str[i]));\n            svuint8_t ones = svdup_n_u8(1);\n            svuint8_t res = svadd_u8(pg, vec, ones); // dummy operation to use sve intrinsic\n            total += svcntp_b8(pg, res); // Count active elements\n        }\n\n        // Tail processing\n        if (i < vec_len) {\n            size_t left = vec_len - i;\n            svbool_t tail_pg = svwhilelt_b8(i, vec_len);\n            svuint8_t vec = svld1(tail_pg, reinterpret_cast<const uint8_t*>(&str[i]));\n            total += svcntp_b8(tail_pg, vec);\n        }\n    }\n    return total;\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    auto count_chars = [](const std::vector<std::string> &lst) -> size_t {\n        size_t total = 0;\n        for (const auto& str : lst) {\n            total += str.length();\n        }\n        return total;\n    };\n\n    size_t total1 = count_chars(lst1);\n    size_t total2 = count_chars(lst2);\n\n    if (total1 <= total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    int sum1 = 0, sum2 = 0;\n    \n    svbool_t pg = svptrue_b8();\n    size_t block_size = svcntb();\n\n    // Calculate total number of characters in lst1\n    for (const auto& str : lst1) {\n        size_t len = str.length();\n        size_t i = 0;\n        for (; i + block_size <= len; i += block_size) {\n            svuint8_t vec = svld1(pg, reinterpret_cast<const uint8_t*>(&str[i]));\n            svuint8_t ones = svdup_n_u8(1);\n            svuint8_t res = svadd_u8(pg, vec, ones); // dummy add to use sve\n            sum1 += block_size;\n        }\n        for (; i < len; ++i) {\n            sum1 += 1;\n        }\n    }\n\n    // Calculate total number of characters in lst2\n    for (const auto& str : lst2) {\n        size_t len = str.length();\n        size_t i = 0;\n        for (; i + block_size <= len; i += block_size) {\n            svuint8_t vec = svld1(pg, reinterpret_cast<const uint8_t*>(&str[i]));\n            svuint8_t ones = svdup_n_u8(1);\n            svuint8_t res = svadd_u8(pg, vec, ones); // dummy add to use sve\n            sum2 += block_size;\n        }\n        for (; i < len; ++i) {\n            sum2 += 1;\n        }\n    }\n\n    if (sum1 <= sum2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    auto count_chars_sve = [](const std::vector<std::string> &lst) -> size_t {\n        size_t total = 0;\n        for (const auto& str : lst) {\n            size_t len = str.length();\n            if (len == 0) continue;\n\n            // SVE intrinsics to sum characters in parallel\n            size_t index = 0;\n            svbool_t pg = svptrue_b8(); // Predicate for full vector\n            size_t vl = svcntb(); // Vector length in bytes\n\n            size_t sum = 0;\n            while (index + vl <= len) {\n                svuint8_t vec = svld1(pg, reinterpret_cast<const uint8_t*>(&str[index]));\n                svuint8_t ones = svdup_n_u8(1);\n                svuint8_t res = svadd_u8(pg, vec, ones); // Add one to each byte\n                sum += svaddv_u8(pg, res); // Horizontal sum of the vector\n                index += vl;\n            }\n\n            // Tail handling\n            if (index < len) {\n                size_t tail_len = len - index;\n                svbool_t pg_tail = svwhilelt_b8(tail_len, vl);\n                svuint8_t vec = svld1(pg_tail, reinterpret_cast<const uint8_t*>(&str[index]));\n                svuint8_t ones = svdup_n_u8(1);\n                svuint8_t res = svadd_u8(pg_tail, vec, ones);\n                sum += svaddv_u8(pg_tail, res);\n            }\n            total += sum;\n        }\n        return total;\n    };\n\n    size_t total1 = count_chars_sve(lst1);\n    size_t total2 = count_chars_sve(lst2);\n\n    if (total1 <= total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```c\n#include <arm_sve.h> \n\nbool is_simple_power_simd(uint64_t x, uint64_t n){\n    if (n == 0) return x == 0;\n    if (n == 1) return x == 1;\n    if (x == 1) return true;\n\n    svbool_t pg = svptrue_b64();\n    uint64_t result = 1;\n    uint64_t power = 1;\n\n    while (true) {\n        power = svmla_z_u64(pg, power, n, power)[0];\n        if (power > x) break;\n        if (power == x) return true;\n        result = power;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```c\n#include <arm_sve.h> \n\nbool is_simple_power_simd(uint64_t x, uint64_t n){\n    if (n == 0) return x == 0;\n    if (n == 1) return x == 1;\n    if (x == 1) return true;\n\n    svbool_t pg = svptrue_b64();\n    uint64_t result = 1;\n    uint64_t power = 1;\n\n    while (result < x) {\n        power = svadd_x_s64(pg, power, 1);\n        result = svpowu_x_s64(pg, n, power);\n        if (svany_bit_true_b64(pg, svcmpeq_x_s64(pg, result, x))) {\n            return true;\n        }\n    }\n\n    return result == x;\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```c\n#include <arm_sve.h> \n\nbool is_simple_power_simd(uint64_t x, uint64_t n){\n    if (n == 0) return x == 0;\n    if (n == 1) return x == 1;\n\n    svbool_t pg = svptrue_b64();\n    svuint64_t vx = svdup_n_u64(x);\n    svuint64_t vn = svdup_n_u64(n);\n\n    svuint64_t vpow = svdup_n_u64(1);\n    svuint64_t vcmp = svdup_n_u64(0);\n\n    do {\n        vcmp = vpow;\n        vpow = svmul_x_u64(pg, vpow, vn);\n    } while (svany_pgt_u64(pg, vpow, vx) || svnone_eq_u64(pg, vpow, vx));\n\n    return sveor_z_u64(pg, vcmp, vx) == 0;\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```c\n#include <arm_sve.h> \n\nbool is_simple_power_simd(uint64_t x, uint64_t n){\n    if (n == 0) return x == 0;\n    if (n == 1) return x == 1;\n    if (x == 1) return true;\n\n    svbool_t pg = svptrue_b64();\n    uint64_t result = 1;\n    uint64_t power = 1;\n\n    while (result < x) {\n        result = svadd_x_u64(pg, result, result * n);\n        power++;\n        if (svcmpge_u64(pg, result, x)) break;\n    }\n\n    return result == x;\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```c\n#include <arm_sve.h> \n\nbool is_simple_power_simd(uint64_t x, uint64_t n){\n    if (n == 0) {\n        return x == 0;\n    }\n    if (n == 1) {\n        return x == 1;\n    }\n    if (x == 1) {\n        return true;\n    }\n\n    svbool_t pg = svptrue_b64();\n    svuint64_t vx = svdup_n_u64(x);\n    svuint64_t vn = svdup_n_u64(n);\n\n    svuint64_t vresult = svdup_n_u64(1);\n    svuint64_t vone = svdup_n_u64(1);\n\n    while (svany_true_b64(pg)) {\n        svuint64_t vtemp = svmul_x_u64(pg, vresult, vn);\n        vresult = svsel_u64(pg, vtemp, vresult);\n        pg = svcmp_eq_u64(pg, vresult, vx);\n        if (svall_true_b64(pg)) {\n            return true;\n        }\n        pg = svcmp_lt_u64(pg, vresult, vx);\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cstddef>\n\nint hex_key_simd(const std::string & num){\n    if (num.empty()) return 0;\n\n    const uint8_t prime_mask[] = { 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0 };\n    int count = 0;\n\n    size_t vec_len = svcntb();\n    size_t i = 0;\n    size_t n = num.size();\n\n    for (; i <= n - vec_len; i += vec_len) {\n        svbool_t pg = svptrue_b8();\n        svuint8_t vec = svld1(pg, reinterpret_cast<const uint8_t*>(&num[i]));\n        \n        // Convert hex digits to values\n        svuint8_t val = svand_x(pg, vec, 0x0F); // Handle '0'-'9'\n        svuint8_t adjusted = svsub_x(pg, vec, 'A' - 10); // Handle 'A'-'F'\n        svuint8_t ge_A = svmage_x(pg, vec, 'A');\n        val = svsel(pg, val, svadd_x(pg, adjusted, svdup_n_u8(10)), ge_A);\n\n        // Use prime mask to check primality\n        svuint8_t masked = svtbl(pg, prime_mask, val);\n        svuint8_t is_prime = svmov_x(pg, masked);\n        count += svcntp(pg, is_prime);\n    }\n\n    for (; i < n; ++i) {\n        char c = num[i];\n        uint8_t val = (c <= '9') ? (c - '0') : (c - 'A' + 10);\n        if (prime_mask[val]) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n\nint hex_key_simd(const std::string & num){\n    if (num.empty()) return 0;\n\n    const uint8_t prime_mask[16] = {0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0};\n    int result = 0;\n    size_t vec_len = svcntb();\n    size_t len = num.length();\n\n    for (size_t i = 0; i < len; i += vec_len) {\n        size_t block_size = len - i > vec_len ? vec_len : len - i;\n        svbool_t pg = svwhilelt_b8((uint64_t)i, (uint64_t)(i + block_size));\n\n        svuint8_t vec = svld1(pg, (const uint8_t*)&num[i]);\n        svuint8_t digits = svsub_u8(pg, svmin_u8(pg, svadd_u8(pg, vec, vec >= 'A'), svtrue_u8()), '0');\n\n        svuint8_t lookup = svindex_u8_z(pg, 0, 1);\n        svuint8_t primes = svld1_gather_u8(pg, prime_mask, digits, 0);\n\n        svbool_t is_prime = svcmpeq(pg, primes, lookup);\n        result += svpopcnt_b8(svand(pg, is_prime));\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <cstddef>\n\nint hex_key_simd(const std::string & num){\n    if (num.empty()) return 0;\n\n    const uint8_t prime_mask[] = {0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0};\n    int result = 0;\n    size_t vl = svcntb();\n\n    for(size_t i = 0; i < num.size(); i += vl){\n        size_t count = (i + vl > num.size()) ? (num.size() - i) : vl;\n        svbool_t pg = svwhilelt_b8(i, num.size());\n        \n        // Load characters and convert to their numeric values\n        svuint8_t chars = svld1(pg, reinterpret_cast<const uint8_t*>(&num[i]));\n        svuint8_t digits = svsub_u8(pg, svmov_n_u8('0'), chars);\n        svuint8_t letters = svsub_u8(pg, svmov_n_u8('A' - 10), chars);\n        svuint8_t values = svsel(pg, digits, letters, svcmple_u8(pg, chars, svmov_n_u8('9')));\n\n        // Create a mask for primes\n        svuint8_t primes = svmovl(pg, svld1(pg, prime_mask));\n        svbool_t is_prime = svcmpeq(pg, svand_u8(pg, primes, svushr_n_u8(pg, values, 4)), svmov_n_u8(0));\n\n        // Count the number of primes in this vector\n        result += svpopcnt_b8(pg, is_prime);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cinttypes>\n\nint hex_key_simd(const std::string & num){\n    if (num.empty()) return 0;\n\n    // Lookup table for prime hexadecimal digits: 2, 3, 5, 7, B, D\n    constexpr uint8_t prime_mask[16] = {\n        0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0\n    };\n\n    int count = 0;\n    size_t vl = svcntb(); // Vector length in bytes\n    const uint8_t *data = reinterpret_cast<const uint8_t *>(num.c_str());\n    size_t len = num.length();\n\n    for (size_t i = 0; i <= len - svcntb(); i += vl) {\n        svbool_t pg = svptrue_b8();\n        svuint8_t vec = svld1(pg, data + i);\n\n        // Create a mask for each digit based on the lookup table\n        svuint8_t masked_vec = svindex_u8(0, 1); // Initialize to index values\n        masked_vec = svreinterpret_u8_m(pg, masked_vec, svld1_gather_index_z(pg, prime_mask, masked_vec));\n\n        // Check if the corresponding bit is set in the prime_mask\n        svuint8_t cmp_result = svcmpeq(pg, masked_vec, 1);\n\n        // Count the number of matches\n        svuint8_t ones = svdup_n_u8(1);\n        svuint8_t cnt_vec = svadd_u8(pg, cnt_vec, cmp_result);\n\n        // Horizontal sum\n        uint64x2_t res = svaddv_u8(cnt_vec);\n        count += vaddvq_u8(res);\n    }\n\n    // Handle remaining elements if any\n    if (len % vl != 0) {\n        svbool_t pg = svptrue_b8();\n        pg = svwhilelt_b8(i, len);\n        svuint8_t vec = svld1(pg, data + i);\n\n        svuint8_t masked_vec = svindex_u8(0, 1); // Initialize to index values\n        masked_vec = svreinterpret_u8_m(pg, masked_vec, svld1_gather_index_z(pg, prime_mask, masked_vec));\n\n        svuint8_t cmp_result = svcmpeq(pg, masked_vec, 1);\n\n        svuint8_t ones = svdup_n_u8(1);\n        svuint8_t cnt_vec = svadd_u8(pg, cnt_vec, cmp_result);\n\n        uint64x2_t res = svaddv_u8(cnt_vec);\n        count += vaddvq_u8(res);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint hex_key_simd(const std::string & num){\n    if (num.empty()) return 0;\n\n    const uint8_t prime_mask[16] = { 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0 };\n    int result = 0;\n    size_t vl = svcntb();\n\n    for(size_t i = 0; i < num.size(); i += vl){\n        size_t count = (i + vl > num.size()) ? (num.size() - i) : vl;\n        svbool_t pg = svptrue_b8();\n        svuint8_t vec = svld1(pg, reinterpret_cast<const uint8_t*>(&num[i]));\n\n        // Convert hex characters to values 0-15\n        svuint8_t digits = svand_u8(pg, vec, 0xFu); // Mask for 0-9\n        svuint8_t letters = svsub_u8(pg, vec, 'A'-10); // Adjust A-F to 10-15\n        svuint8_t cond = svmovlb_u8(pg, svcmpeq(pg, vec, vec)); // Check if >= 'A'\n        svuint8_t hex_vals = svsel_u8(pg, letters, digits, cond);\n\n        // Broadcast prime mask and compare\n        svuint8_t primes = svld1(pg, prime_mask);\n        svbool_t is_prime = svcmpeq(pg, hex_vals, primes);\n\n        // Count the number of primes in this vector\n        result += svcntp(is_prime, pg);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n\nbool is_happy_simd(const std::string & s){\n    if (s.size() < 3) return false;\n\n    size_t vl = svcntb(); // Vector length in terms of bytes\n    uint8_t *str = reinterpret_cast<uint8_t *>(const_cast<char *>(s.c_str()));\n    size_t len = s.size();\n\n    for (size_t i = 0; i <= len - 3; i += vl) {\n        svbool_t pg = svptrue_b8();\n        svuint8_t v0 = svld1(pg, str + i);\n        svuint8_t v1 = svld1(pg, str + i + 1);\n        svuint8_t v2 = svld1(pg, str + i + 2);\n\n        svuint8_t cmp1 = svceq(v0, v1);\n        svuint8_t cmp2 = svceq(v1, v2);\n        svuint8_t cmp3 = svceq(v0, v2);\n\n        svbool_t mask1 = svcmpeq_m(pg, cmp1, cmp1, cmp1);\n        svbool_t mask2 = svcmpeq_m(pg, cmp2, cmp2, cmp2);\n        svbool_t mask3 = svcmpeq_m(pg, cmp3, cmp3, cmp3);\n\n        svbool_t any_equal = svorr_m(pg, mask1, mask1, mask2);\n        any_equal = svorr_m(pg, any_equal, any_equal, mask3);\n\n        if (svptest_any(svptrue_b8(), any_equal)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s){\n    if (s.size() < 3) return false;\n\n    size_t vec_len = svcntw(); // Get the length of the SVE vector in elements\n    size_t n = s.size();\n\n    const uint8_t * str = reinterpret_cast<const uint8_t *>(s.data());\n\n    for (size_t i = 0; i <= n - 3; i += vec_len) {\n        svbool_t pg = svptrue_b8(); // Predicate for full vector\n        size_t limit = i + vec_len;\n        if (limit > n - 2) {\n            pg = svwhilelt_b8(i, n - 2);\n            limit = n;\n        }\n\n        svuint8_t v0 = svld1(pg, str + i);\n        svuint8_t v1 = svld1(pg, str + i + 1);\n        svuint8_t v2 = svld1(pg, str + i + 2);\n\n        svbool_t cmp01 = svcmpeq(pg, v0, v1);\n        svbool_t cmp12 = svcmpeq(pg, v1, v2);\n        svbool_t cmp02 = svcmpeq(pg, v0, v2);\n\n        svbool_t unhappy = svorr(cmp01, svorr(cmp12, cmp02));\n\n        if (svptest_any(svptrue_b8(), unhappy)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n\nbool is_happy_simd(const std::string & s){\n    if (s.size() < 3) return false;\n\n    svbool_t pg = svptrue_b8();\n    size_t vec_len = svcntb();\n    size_t i = 0;\n\n    const uint8_t * str = reinterpret_cast<const uint8_t *>(s.data());\n    size_t len = s.size();\n\n    while (i + vec_len <= len - 2) {\n        svuint8_t vec0 = svld1(pg, str + i);\n        svuint8_t vec1 = svld1(pg, str + i + 1);\n        svuint8_t vec2 = svld1(pg, str + i + 2);\n\n        svbool_t cmp1 = svcmpeq(pg, vec0, vec1);\n        svbool_t cmp2 = svcmpeq(pg, vec1, vec2);\n        svbool_t cmp3 = svcmpeq(pg, vec0, vec2);\n\n        if (svptest_any(pg, cmp1) || svptest_any(pg, cmp2) || svptest_any(pg, cmp3)) {\n            return false;\n        }\n\n        i += vec_len;\n    }\n\n    for (; i <= len - 3; ++i) {\n        if (str[i] == str[i+1] || str[i] == str[i+2] || str[i+1] == str[i+2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n\nbool is_happy_simd(const std::string & s){\n    if (s.size() < 3) return false;\n\n    size_t vl = svcntb(); // Vector length in bytes\n    uint8_t *data = reinterpret_cast<uint8_t *>(const_cast<char *>(s.data()));\n    size_t n = s.size();\n\n    for (size_t i = 0; i <= n - 3; i += vl) {\n        svbool_t pg = svptrue_b8();\n        svuint8_t v0 = svld1(pg, data + i);\n        svuint8_t v1 = svld1(pg, data + i + 1);\n        svuint8_t v2 = svld1(pg, data + i + 2);\n\n        svuint8_t cmp1 = svceq(pg, v0, v1);\n        svuint8_t cmp2 = svceq(pg, v1, v2);\n        svuint8_t cmp3 = svceq(pg, v0, v2);\n\n        svuint8_t any_match = svorr(cmp1, svorr(cmp2, cmp3));\n        if (svptest_any(pg, any_match)) {\n            return false;\n        }\n\n        // Handle partial vectors at the end of the string\n        size_t remaining = n - 3 - i;\n        if (remaining < vl) {\n            pg = svwhilelt_b8(i, n - 3);\n            v0 = svld1(pg, data + i);\n            v1 = svld1(pg, data + i + 1);\n            v2 = svld1(pg, data + i + 2);\n\n            cmp1 = svceq(pg, v0, v1);\n            cmp2 = svceq(pg, v1, v2);\n            cmp3 = svceq(pg, v0, v2);\n\n            any_match = svorr(cmp1, svorr(cmp2, cmp3));\n            if (svptest_any(pg, any_match)) {\n                return false;\n            }\n            break;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n\nbool is_happy_simd(const std::string & s){\n    if (s.length() < 3) return false;\n\n    size_t vec_len = svcntb();\n    size_t str_len = s.length();\n    uint8_t *str = reinterpret_cast<uint8_t*>(&s[0]);\n\n    svbool_t pg = svptrue_b8();\n    svuint8_t zero = svdup_n_u8(0);\n\n    for (size_t i = 0; i <= str_len - 3; i += vec_len) {\n        size_t k = (str_len - i > vec_len) ? vec_len : str_len - i;\n        svbool_t pg_k = svwhilelt_b8(i, i + k);\n\n        svuint8_t v0 = svld1_u8(pg_k, str + i);\n        svuint8_t v1 = svld1_u8(pg_k, str + i + 1);\n        svuint8_t v2 = svld1_u8(pg_k, str + i + 2);\n\n        svbool_t cmp1 = svcmpeq_pg_b8(pg_k, v0, v1);\n        svbool_t cmp2 = svcmpeq_pg_b8(pg_k, v1, v2);\n        svbool_t cmp3 = svcmpeq_pg_b8(pg_k, v0, v2);\n\n        svbool_t unhappy = svorr_b8(cmp1, svorr_b8(cmp2, cmp3));\n        if (svptest_any(svptrue_b8(), unhappy)) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cmath>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if ((n & 1) == 0 || n % 3 == 0) return false;\n    int limit = std::sqrt(n);\n    for (int i = 5; i <= limit; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length_simd(const std::string &str) {\n    svbool_t pg = svptrue_b8();\n    int length = str.length();\n    svint32_t vec_len = svdup_n_s32(length);\n    svint32_t vec_one = svdup_n_s32(1);\n\n    // Check if length is less than or equal to 1\n    svbool_t pred_le_1 = svcmple_s32(pg, vec_len, svdup_n_s32(1));\n    if (svcntp_b32(pg, pred_le_1)) return false;\n\n    // Check if length is 2 or 3\n    svbool_t pred_eq_2 = svcmpeq_s32(pg, vec_len, svdup_n_s32(2));\n    svbool_t pred_eq_3 = svcmpeq_s32(pg, vec_len, svdup_n_s32(3));\n    if (svcntp_b32(pg, svor_b32(pg, pred_eq_2, pred_eq_3))) return true;\n\n    // Check if length is divisible by 2 or 3\n    svint32_t mod_2 = svand_s32(pg, vec_len, svdup_n_s32(1));\n    svbool_t pred_div_2 = svcmpeq_s32(pg, mod_2, svdup_n_s32(0));\n    if (svcntp_b32(pg, pred_div_2)) return false;\n\n    svint32_t mod_3 = svmla_s32(pg, svdup_n_s32(0), svdup_n_s32(3), vec_len);\n    svbool_t pred_div_3 = svcmpeq_s32(pg, mod_3, svdup_n_s32(0));\n    if (svcntp_b32(pg, pred_div_3)) return false;\n\n    // Check divisors from 5 to sqrt(length)\n    int limit = std::sqrt(length);\n    for (int i = 5; i <= limit; i += 6) {\n        svint32_t vec_i = svdup_n_s32(i);\n        svint32_t vec_i2 = svadd_s32(pg, vec_i, svdup_n_s32(2));\n\n        svint32_t mod_i = svmla_s32(pg, svdup_n_s32(0), vec_i, vec_len);\n        svint32_t mod_i2 = svmla_s32(pg, svdup_n_s32(0), vec_i2, vec_len);\n\n        svbool_t pred_div_i = svcmpeq_s32(pg, mod_i, svdup_n_s32(0));\n        svbool_t pred_div_i2 = svcmpeq_s32(pg, mod_i2, svdup_n_s32(0));\n\n        if (svcntp_b32(pg, pred_div_i) || svcntp_b32(pg, pred_div_i2)) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cmath>\n\nbool is_prime(int num) {\n    if (num < 2) return false;\n    int sqrt_num = static_cast<int>(std::sqrt(num));\n    svbool_t pg = svptrue_b32();\n    for (int i = 2; i <= sqrt_num; ++i) {\n        svuint32_t vec_i = svdup_n_u32(pg, i);\n        svuint32_t vec_num = svdup_n_u32(pg, num);\n        svuint32_t remainder = svmoda_u32(pg, vec_num, vec_i);\n        if (svany_fst_u32(pg, remainder)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool prime_length_simd(const std::string &str) {\n    int length = str.length();\n    return is_prime(length);\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cmath>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if ((n & 1) == 0 || n % 3 == 0) return false;\n    int sqrt_n = static_cast<int>(std::sqrt(n));\n    for (int i = 5; i <= sqrt_n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length_simd(const std::string & str){\n    svbool_t pg = svptrue_b8();\n    int len = static_cast<int>(str.length());\n    int vec_len = svcntw(); // Vector length in terms of the number of elements\n    int num_vectors = (len + vec_len - 1) / vec_len;\n\n    // Use SVE to process multiple checks in parallel if needed\n    svint32_t sv_len = svdup_n_s32(len);\n    svbool_t result = svptrue_b32();\n\n    for (int i = 0; i < num_vectors; ++i) {\n        // Parallel primality test can be conceptualized here, but primality is inherently sequential\n        // Thus, we fallback to a scalar check\n        if (!is_prime(len)) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cmath>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if ((n & 1) == 0 || n % 3 == 0) return false;\n    int sqrt_n = static_cast<int>(std::sqrt(n));\n    for (int i = 5; i <= sqrt_n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length_simd(const std::string &str) {\n    // Determine the length of the string\n    int len = str.length();\n    \n    // Use SVE to perform parallel checks on a range of divisors\n    svbool_t pg = svptrue_b32(); // Predicate for all active elements\n    svuint32_t vec_len = svdup_n_u32(len); // Broadcast the length into a vector\n    \n    // Check divisors from 2 up to sqrt(len)\n    int limit = static_cast<int>(std::sqrt(len)) + 1;\n    for (int i = 2; i < limit; ++i) {\n        svuint32_t vec_i = svdup_n_u32(i); // Broadcast the current divisor\n        svuint32_t remainder = svmod_u32(pg, vec_len, vec_i); // Compute len % i\n        if (svany_p(svcmeq_u32(pg, remainder, svdup_n_u32(0)))) {\n            return false; // If any remainder is zero, len is not prime\n        }\n    }\n    \n    // If no divisors were found, check using scalar fallback\n    return is_prime(len);\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cmath>\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if ((n & 1) == 0) return false;\n\n    svbool_t pg = svptrue_b32();\n    int limit = static_cast<int>(std::sqrt(n));\n    for (int i = 3; i <= limit; i += 2) {\n        svuint32_t vi = svdup_n_u32(i);\n        svuint32_t vr = svmod_u32(pg, svdup_n_u32(n), vi);\n        if (svany_p(svcmeq_u32(pg, vr, svdup_n_u32(0)))) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool prime_length_simd(const std::string &str) {\n    int length = static_cast<int>(str.length());\n    return is_prime(length);\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n\nstd::string solve_simd(uint64_t N){\n    uint64_t sum = 0;\n    svbool_t pg = svptrue_b64();\n    svuint64_t vec_n = svdup_n_u64(pg, N);\n\n    // Extract digits and sum them using SVE intrinsics\n    for (int i = 0; i < 20; ++i) { // Assuming max 20 iterations for a 64-bit number\n        svuint64_t remainder = svand_x_u64(pg, vec_n, svdup_n_u64(pg, 0xF));\n        vec_n = svasr_x_u64(pg, vec_n, svdup_n_u64(pg, 4));\n        sum += svaddv_u64(pg, remainder);\n    }\n\n    // Convert sum to binary string\n    std::string binary_sum = \"\";\n    if (sum == 0) {\n        binary_sum = \"0\";\n    } else {\n        uint64_t temp_sum = sum;\n        while (temp_sum > 0) {\n            binary_sum = static_cast<char>('0' + (temp_sum & 1)) + binary_sum;\n            temp_sum >>= 1;\n        }\n    }\n    return binary_sum;\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n\nstd::string solve_simd(uint64_t N){\n    uint64_t sum = 0;\n    svbool_t pg = svptrue_b64();\n    svuint64_t vec_n = svdup_n_u64(pg, N);\n\n    // Extract digits and sum them in a vectorized manner\n    for (int i = 0; i < 20; ++i) { // Assuming max 20 iterations for 64-bit numbers\n        svuint64_t remainder = svsrh_u64(pg, vec_n, 10);\n        svuint64_t digit = svsub_u64(pg, vec_n, svmla_n_u64(pg, remainder, 10));\n        sum += svaddv_u64(pg, digit);\n        vec_n = remainder;\n    }\n\n    // Convert sum to binary string\n    std::vector<char> binary_digits;\n    do {\n        binary_digits.push_back('0' + (sum & 1));\n        sum >>= 1;\n    } while (sum != 0);\n\n    std::string binary_str(binary_digits.rbegin(), binary_digits.rend());\n    return binary_str;\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n\nstd::string solve_simd(uint64_t N){\n    uint64_t sum = 0;\n    svbool_t pg = svptrue_b64();\n    svuint64_t vec_n = svdup_n_u64(N);\n\n    // Extract digits and sum them in parallel\n    for (int i = 0; i < 20; ++i) { // Assuming max 20 iterations for a 64-bit number\n        svuint64_t remainder = svsrh(vec_n, pg, 10);\n        svuint64_t digit = svsub_x(pg, vec_n, svmla_x(pg, remainder, svdup_n_u64(10), svdup_n_u64(0)));\n        sum += svaddv_u64(pg, digit);\n        vec_n = remainder;\n\n        if (svcntp_b64(pg, svcmpeq_z(pg, vec_n, svdup_n_u64(0))) == svcntd()) {\n            break;\n        }\n    }\n\n    // Convert sum to binary string\n    std::vector<char> binary_digits;\n    do {\n        binary_digits.push_back('0' + (sum & 1));\n        sum >>= 1;\n    } while (sum != 0);\n\n    std::string binary_str(binary_digits.rbegin(), binary_digits.rend());\n    return binary_str;\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <bit>\n\nstd::string solve_simd(uint64_t N){\n    uint64_t sum = 0;\n    svbool_t pg = svptrue_b64();\n    svuint64_t vec = svdup_n_u64(N);\n\n    while (true) {\n        svuint64_t remainder = svmodi_u64(pg, vec, 10);\n        sum += svaddv_u64(pg, remainder);\n        vec = svsdivi_u64(pg, vec, 10);\n        if (svcntp_b64(pg, svcmpeq_u64(pg, vec, svdup_n_u64(0))) == svcntd()) {\n            break;\n        }\n    }\n\n    return std::bitset<64>(sum).to_string();\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n\nstd::string solve_simd(uint64_t N){\n    uint64_t sum = 0;\n    svbool_t pg = svptrue_b64();\n    svuint64_t vec_n = svdup_n_u64(N);\n\n    // Extract digits and sum them in parallel\n    for (int i = 0; i < 19; ++i) { // Maximum number of digits in a 64-bit integer\n        svuint64_t digit = svand_x(pg, vec_n, svdup_n_u64(0xF)); // Extract last hex digit\n        sum += svaddv_u64(pg, digit); // Add the extracted digits to the sum\n        vec_n = svasr_x(pg, vec_n, svdup_n_u64(4)); // Shift right by 4 to process next digit\n    }\n\n    // Convert sum to binary string\n    std::string binary_sum;\n    uint64_t temp_sum = sum;\n    if (sum == 0) {\n        binary_sum = \"0\";\n    } else {\n        std::vector<char> bits;\n        while (temp_sum > 0) {\n            bits.push_back('0' + (temp_sum & 1));\n            temp_sum >>= 1;\n        }\n        binary_sum.assign(bits.rbegin(), bits.rend());\n    }\n\n    return binary_sum;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nint add_simd(std::vector<int> lst){\n    int result = 0;\n    size_t count = lst.size();\n    size_t vl = svcntw(); // Vector length in terms of the number of int elements\n\n    for (size_t i = 1; i < count; i += 2 * vl) {\n        size_t num_active = svmin(vl, count - i);\n        svbool_t pg = svwhilelt_b32(i, i + num_active);\n\n        const int *data = &lst[i];\n        svint32_t vec = svld1(pg, data); // Load vector from memory\n\n        // Check if elements are even\n        svbool_t is_even = svand_b32(pg, sveq_z(pg, svmul_x(pg, vec, 2), svdup_n_s32(0)));\n\n        // Mask out odd elements and sum\n        svint32_t filtered = svsel(is_even, vec, svdup_n_s32(0));\n        int partial_sum = svaddv(pg, filtered);\n        result += partial_sum;\n\n        i += vl - 1; // Adjust loop index to skip processed elements\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nint add_simd(std::vector<int> lst){\n    int result = 0;\n    size_t count = lst.size();\n    size_t vec_count = (count + svcntw() - 1) / svcntw();\n\n    for(size_t i = 0; i < vec_count; ++i){\n        svbool_t pg = svptrue_b32();\n        svint32_t vec = svdup_s32(0);\n        size_t idx_start = i * svcntw();\n        \n        if(idx_start + svcntw() > count){\n            pg = svwhilelt_b32((svint32_t)idx_start, (svint32_t)count);\n            vec = svld1(pg, &lst[idx_start]);\n        }\n        else{\n            vec = svld1(pg, &lst[idx_start]);\n        }\n\n        svbool_t is_odd_idx = svand_b32(pg, svtindex_u32(0,1) );\n        svbool_t is_even_val = svcmpeq(pg, svmul_x(pg, vec, svdup_n_s32(2)), vec);\n\n        svbool_t to_add = svand_b32(pg, is_odd_idx, is_even_val);\n        svint32_t masked_vec = svsel(pg, vec, svdup_s32(0));\n        svint32_t sum_vec = svadd_x(to_add, svdup_s32(0), masked_vec);\n        \n        int temp_sum = 0;\n        for (size_t j = 0; j < svcntw(); ++j){\n            temp_sum += svindex_x(svdup_n_s32(j)) ? sum_vec[j] : 0;\n        }\n        result += temp_sum;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nint add_simd(std::vector<int> lst){\n    int result = 0;\n    size_t count = lst.size();\n    if (count == 0) return result;\n\n    svbool_t pg = svptrue_b32();\n    size_t index = 1;\n    size_t vec_len = svcntw();\n\n    for (; index + vec_len <= count; index += vec_len * 2) {\n        svint32_t vec = svld1(pg, &lst[index]);\n        svint32_t mod_mask = svand(pg, svdup_n_s32(1), svindex_s32(0, 1));\n        svbool_t even_mask = svcmpeq(pg, svmul(pg, lst[index], svdup_n_s32(1)), svdup_n_s32(0));\n        svbool_t final_mask = svand_b32(pg, even_mask, mod_mask);\n        result += svaddv(pg, svsel(final_mask, vec, svdup_n_s32(0)));\n    }\n\n    for (; index < count; index += 2) {\n        if (index % 2 != 0 && lst[index] % 2 == 0) {\n            result += lst[index];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nint add_simd(std::vector<int> lst){\n    int result = 0;\n    size_t num_elements = lst.size();\n    size_t vl = svcntw(); // Vector length in terms of the number of elements\n    size_t i = 1;\n\n    for (; i + vl <= num_elements; i += 2 * vl) {\n        int32x4_t vec = svld1(svlpg, (const int32_t*)&lst[i]);\n        svbool_t pred = svand_b32(svtst(vec, svdup_n_s32(1)), svcmpeq(vec, svdup_n_s32(0)));\n        int32x4_t even_masked = svsel(pred, vec, svdup_n_s32(0));\n        result += svaddv(svlpg, even_masked);\n    }\n\n    for (; i < num_elements; i += 2) {\n        if (i >= lst.size()) break;\n        if ((i % 2) && !(lst[i] % 2)) {\n            result += lst[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nint add_simd(std::vector<int> lst){\n    int result = 0;\n    size_t n = lst.size();\n    if (n == 0) return result;\n\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n    size_t i = 1;\n\n    for (; i + vl <= n; i += vl * 2) {\n        svint32_t vec = svld1(pg, &lst[i]);\n        svint32_t mod_vec = svmul_x(pg, vec, svindex_w(0, 2));\n        svbool_t is_odd_idx = svcmpne_z(pg, svindex_w(i, 1), svindex_w(0, 2));\n        svbool_t is_even = svand_x(pg, svcmpeq_z(pg, svmod_x(pg, vec, 2), 0), is_odd_idx);\n        svint32_t filtered = svsel(is_even, vec, svdup_z(pg, 0));\n        result += svaddv(pg, filtered);\n    }\n\n    for (; i < n; i += 2) {\n        if (i % 2 != 0 && lst[i] % 2 == 0) {\n            result += lst[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n\nstd::string encrypt_simd(const std::string & s){\n    const int shift = 4; // Shift by two multiplied by two places\n    const svbool_t pg = svptrue_b8(); // Predicate for all elements\n    std::string result;\n    result.reserve(s.size());\n\n    size_t vec_len = svcntb(); // Vector length in bytes\n    size_t i = 0;\n\n    for (; i + vec_len <= s.size(); i += vec_len) {\n        // Load characters into a vector\n        svuint8_t chars = svld1(pg, reinterpret_cast<const uint8_t*>(&s[i]));\n        \n        // Perform the rotation\n        svuint8_t rotated = svadd_u8(pg, chars, shift);\n\n        // Handle wrapping within 'a' to 'z'\n        svuint8_t lower_a = svdup_n_u8('a');\n        svuint8_t lower_z = svdup_n_u8('z');\n        svuint8_t overflow = svcmplt_u8(pg, rotated, lower_a);\n        rotated = svmin_u8(pg, rotated, svadd_u8(pg, lower_z, 1));\n        rotated = svmax_u8(pg, rotated, lower_a);\n        rotated = svsub_u8(pg, rotated, svand_u8(pg, lower_z, overflow));\n\n        // Store the encrypted characters back into the result string\n        uint8_t temp[vec_len];\n        svst1(pg, temp, rotated);\n        result.append(reinterpret_cast<char*>(temp), vec_len);\n    }\n\n    // Process any remaining characters\n    for (; i < s.size(); ++i) {\n        char c = s[i];\n        c = ((c - 'a' + shift) % 26) + 'a';\n        result += c;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s){\n    const int shift = 4; // 2 * 2\n    const int a_val = 'a';\n    const int z_val = 'z';\n    const int num_letters = 26;\n\n    size_t vec_len = s.size();\n    svbool_t pg = svptrue_b8(); // Predicate for full vector processing\n\n    std::string result;\n    result.reserve(vec_len);\n\n    size_t i = 0;\n    while (i < vec_len) {\n        // Load characters into a vector\n        svuint8_t chars = svld1(pg, reinterpret_cast<const uint8_t*>(&s[i]));\n\n        // Perform the encryption (rotate alphabet)\n        svuint8_t encrypted_chars = svadd_u8(pg, chars, shift);\n\n        // Wrap around if greater than 'z'\n        svuint8_t over_z = svcmplt(pg, z_val, encrypted_chars);\n        encrypted_chars = svsub_u8(pg, encrypted_chars, svand_u8(pg, num_letters, over_z));\n\n        // Store the encrypted characters back into the result string\n        uint8_t temp_result[64]; // Temporary buffer to store results\n        svst1(pg, temp_result, encrypted_chars);\n\n        // Append valid characters to result string\n        size_t j = 0;\n        svbool_t pred = svwhilelt_b8(i, vec_len);\n        while (svptest_any(svptrue_b8(), pred)) {\n            result += static_cast<char>(temp_result[j]);\n            i++;\n            j++;\n            pred = svwhilelt_b8(i, vec_len);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n\nstd::string encrypt_simd(const std::string & s){\n    const int shift = 4; // 2 * 2\n    const int a_val = 'a';\n    const int z_val = 'z';\n    const int num_letters = 26;\n\n    size_t vec_len = s.size();\n    svbool_t pg = svptrue_b8();\n    std::vector<char> result(vec_len);\n\n    for (size_t i = 0; i < vec_len; i += svcntb()) {\n        size_t j = i + svcntb();\n        if (j > vec_len) j = vec_len;\n        size_t count = j - i;\n\n        svbool_t pg_count = svwhilelt_b8(i, static_cast<svint8_t>(vec_len));\n        svuint8_t vec = svld1(pg_count, reinterpret_cast<const uint8_t*>(&s[i]));\n        \n        svuint8_t shifted_vec = svadd_u8(pg_count, vec, shift);\n        \n        // Wrap around within 'a' to 'z'\n        svuint8_t sub_a = svsub_u8(pg_count, shifted_vec, a_val);\n        svuint8_t mod_wrap = svsel(svscmpge_u8(pg_count, sub_a, num_letters), \n                                   svsub_u8(pg_count, sub_a, num_letters), sub_a);\n        svuint8_t final_vec = svadd_u8(pg_count, mod_wrap, a_val);\n        \n        svst1(pg_count, reinterpret_cast<uint8_t*>(&result[i]), final_vec);\n    }\n\n    return std::string(result.begin(), result.end());\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s){\n    int shift = 4; // two multiplied by two places\n    size_t len = s.length();\n    size_t vec_len = svcntb(); // Number of bytes in a vector\n    size_t num_full_vecs = len / vec_len;\n    size_t remaining = len % vec_len;\n\n    std::string result(len, '\\0');\n\n    for (size_t i = 0; i < num_full_vecs; ++i) {\n        svbool_t pg = svptrue_b8(); // Predicate for full vectors\n        svuint8_t vec = svld1(pg, reinterpret_cast<const uint8_t*>(&s[i * vec_len]));\n        svuint8_t shifted = svadd_u8(pg, vec, svdup_n_u8(shift));\n\n        // Wrap around within 'a' to 'z'\n        svuint8_t lower_a = svdup_n_u8('a');\n        svuint8_t lower_z = svdup_n_u8('z');\n        svbool_t gt_z = svcmpgt(pg, shifted, lower_z);\n        svuint8_t wrapped = svsub_u8(pg, shifted, svdup_n_u8(26));\n        shifted = svsel(gt_z, wrapped, shifted);\n\n        svst1(pg, reinterpret_cast<uint8_t*>(&result[i * vec_len]), shifted);\n    }\n\n    if (remaining > 0) {\n        svbool_t pg = svinterpreted_t(svtrue_b8(), remaining); // Predicate for partial vector\n        svuint8_t vec = svld1(pg, reinterpret_cast<const uint8_t*>(&s[num_full_vecs * vec_len]));\n        svuint8_t shifted = svadd_u8(pg, vec, svdup_n_u8(shift));\n\n        // Wrap around within 'a' to 'z'\n        svuint8_t lower_a = svdup_n_u8('a');\n        svuint8_t lower_z = svdup_n_u8('z');\n        svbool_t gt_z = svcmpgt(pg, shifted, lower_z);\n        svuint8_t wrapped = svsub_u8(pg, shifted, svdup_n_u8(26));\n        shifted = svsel(gt_z, wrapped, shifted);\n\n        svst1(pg, reinterpret_cast<uint8_t*>(&result[num_full_vecs * vec_len]), shifted);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n#include <vector>\n\nstd::string encrypt_simd(const std::string & s){\n    const int shift = 4; // 2 * 2\n    const svbool_t pg = svptrue_b8(); // Predicate for all elements\n    const uint8_t a = 'a';\n    const uint8_t z = 'z';\n    const uint8_t A = 'A';\n    const uint8_t Z = 'Z';\n\n    size_t vec_len = svcntb(); // Vector length in bytes\n    size_t num_full_vecs = s.size() / vec_len;\n    size_t remainder = s.size() % vec_len;\n\n    std::vector<uint8_t> result(s.size());\n\n    for (size_t i = 0; i < num_full_vecs; ++i) {\n        size_t idx = i * vec_len;\n        svuint8_t vec = svld1(pg, reinterpret_cast<const uint8_t*>(&s[idx]));\n        \n        svuint8_t shifted = svadd_u8(pg, vec, svdup_n_u8(shift));\n\n        svuint8_t ge_a = svcmpge_u8(pg, shifted, svdup_n_u8(a));\n        svuint8_t le_z = svcmple_u8(pg, shifted, svdup_n_u8(z));\n        svbool_t is_lower = svand(pg, ge_a, le_z);\n\n        svuint8_t ge_A = svcmpge_u8(pg, shifted, svdup_n_u8(A));\n        svuint8_t le_Z = svcmple_u8(pg, shifted, svdup_n_u8(Z));\n        svbool_t is_upper = svand(pg, ge_A, le_Z);\n\n        svuint8_t wrap_lower = svsub_u8(pg, shifted, svdup_n_u8('z' - 'y'));\n        svuint8_t wrap_upper = svsub_u8(pg, shifted, svdup_n_u8('Z' - 'Y'));\n\n        shifted = svsel(is_lower, wrap_lower, shifted);\n        shifted = svsel(is_upper, wrap_upper, shifted);\n\n        svst1(pg, &result[idx], shifted);\n    }\n\n    if (remainder > 0) {\n        size_t idx = num_full_vecs * vec_len;\n        svbool_t pg_remainder = svwhilelt_b8(0, remainder);\n        svuint8_t vec = svld1(pg_remainder, reinterpret_cast<const uint8_t*>(&s[idx]));\n        \n        svuint8_t shifted = svadd_u8(pg_remainder, vec, svdup_n_u8(shift));\n\n        svuint8_t ge_a = svcmpge_u8(pg_remainder, shifted, svdup_n_u8(a));\n        svuint8_t le_z = svcmple_u8(pg_remainder, shifted, svdup_n_u8(z));\n        svbool_t is_lower = svand(pg_remainder, ge_a, le_z);\n\n        svuint8_t ge_A = svcmpge_u8(pg_remainder, shifted, svdup_n_u8(A));\n        svuint8_t le_Z = svcmple_u8(pg_remainder, shifted, svdup_n_u8(Z));\n        svbool_t is_upper = svand(pg_remainder, ge_A, le_Z);\n\n        svuint8_t wrap_lower = svsub_u8(pg_remainder, shifted, svdup_n_u8('z' - 'y'));\n        svuint8_t wrap_upper = svsub_u8(pg_remainder, shifted, svdup_n_u8('Z' - 'Y'));\n\n        shifted = svsel(is_lower, wrap_lower, shifted);\n        shifted = svsel(is_upper, wrap_upper, shifted);\n\n        svst1(pg_remainder, &result[idx], shifted);\n    }\n\n    return std::string(result.begin(), result.end());\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cctype>\n#include <string>\n\nstd::string encode_simd(const std::string & message){\n    const uint8_t vowels[] = {'a','e','i','o','u','A','E','I','O','U'};\n    const uint8_t repl[] = {'c','g','k','q','w','C','G','K','Q','W'};\n    \n    svbool_t pg = svptrue_b8();\n    std::string result;\n    result.reserve(message.size());\n\n    size_t i = 0;\n    size_t vec_len = message.size() / svcntb();\n    size_t rem = message.size() % svcntb();\n\n    for (; i < vec_len * svcntb(); i += svcntb()) {\n        svuint8_t msg_vec = svld1(pg, reinterpret_cast<const uint8_t*>(&message[i]));\n        \n        // Swap case\n        svuint8_t lower_mask = svandb(pg, svcmpeq(pg, svandb(pg, msg_vec, 0xDF), svandb(pg, msg_vec, 0xDF)));\n        svuint8_t swapped_case = svsel(pg, svsubb(pg, msg_vec, 0x20), svaddb(pg, msg_vec, 0x20), lower_mask);\n        \n        // Replace vowels\n        svuint8_t replace_mask = svorr(pg, svcmpeq(pg, swapped_case, svdup_n_u8(vowels[0])), \n                                      svorr(pg, svcmpeq(pg, swapped_case, svdup_n_u8(vowels[1])),\n                                      svorr(pg, svcmpeq(pg, swapped_case, svdup_n_u8(vowels[2])),\n                                      svorr(pg, svcmpeq(pg, swapped_case, svdup_n_u8(vowels[3])),\n                                      svorr(pg, svcmpeq(pg, swapped_case, svdup_n_u8(vowels[4])),\n                                      svorr(pg, svcmpeq(pg, swapped_case, svdup_n_u8(vowels[5])),\n                                      svorr(pg, svcmpeq(pg, swapped_case, svdup_n_u8(vowels[6])),\n                                      svorr(pg, svcmpeq(pg, swapped_case, svdup_n_u8(vowels[7])),\n                                      svorr(pg, svcmpeq(pg, swapped_case, svdup_n_u8(vowels[8])),\n                                      svcmpeq(pg, swapped_case, svdup_n_u8(vowels[9])))));\n\n        svuint8_t replaced = svsel(pg, svindex_n_u8(repl[0], 1), swapped_case, replace_mask);\n\n        uint8_t out[64];\n        svst1(pg, out, replaced);\n        result.append(reinterpret_cast<char*>(out), svcntb());\n    }\n\n    // Handle remaining elements\n    if (rem > 0) {\n        svbool_t pg_rem = svwhilelt_b8(i, message.size());\n        svuint8_t msg_vec = svld1(pg_rem, reinterpret_cast<const uint8_t*>(&message[i]));\n\n        svuint8_t lower_mask = svandb(pg_rem, svcmpeq(pg_rem, svandb(pg_rem, msg_vec, 0xDF), svandb(pg_rem, msg_vec, 0xDF)));\n        svuint8_t swapped_case = svsel(pg_rem, svsubb(pg_rem, msg_vec, 0x20), svaddb(pg_rem, msg_vec, 0x20), lower_mask);\n\n        svuint8_t replace_mask = svorr(pg_rem, svcmpeq(pg_rem, swapped_case, svdup_n_u8(vowels[0])), \n                                      svorr(pg_rem, svcmpeq(pg_rem, swapped_case, svdup_n_u8(vowels[1])),\n                                      svorr(pg_rem, svcmpeq(pg_rem, swapped_case, svdup_n_u8(vowels[2])),\n                                      svorr(pg_rem, svcmpeq(pg_rem, swapped_case, svdup_n_u8(vowels[3])),\n                                      svorr(pg_rem, svcmpeq(pg_rem, swapped_case, svdup_n_u8(vowels[4])),\n                                      svorr(pg_rem, svcmpeq(pg_rem, swapped_case, svdup_n_u8(vowels[5])),\n                                      svorr(pg_rem, svcmpeq(pg_rem, swapped_case, svdup_n_u8(vowels[6])),\n                                      svorr(pg_rem, svcmpeq(pg_rem, swapped_case, svdup_n_u8(vowels[7])),\n                                      svorr(pg_rem, svcmpeq(pg_rem, swapped_case, svdup_n_u8(vowels[8])),\n                                      svcmpeq(pg_rem, swapped_case, svdup_n_u8(vowels[9]))));\n\n        svuint8_t replaced = svsel(pg_rem, svindex_n_u8(repl[0], 1), swapped_case, replace_mask);\n\n        uint8_t out[64] = {0};\n        svst1(pg_rem, out, replaced);\n        result.append(reinterpret_cast<char*>(out), rem);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n#include <cctype>\n\nstd::string encode_simd(const std::string & message){\n    svbool_t pg = svptrue_b8();\n    size_t vec_len = svcntb();\n    size_t len = message.size();\n    std::string result;\n    result.reserve(len);\n\n    const uint8_t vowels[] = {'a','e','i','o','u','A','E','I','O','U'};\n    const uint8_t repl_vowels[] = {'c','g','k','q','w','C','G','K','Q','W'};\n\n    for (size_t i = 0; i < len; i += vec_len) {\n        size_t count = (len - i > vec_len) ? vec_len : len - i;\n        svbool_t pg_count = svwhilelt_b8(i, len);\n        svuint8_t vec = svld1_u8(pg_count, reinterpret_cast<const uint8_t*>(&message[i]));\n\n        // Swap case\n        svuint8_t lower_mask = svand_u8(pg_count, svcmpeq_u8(pg_count, svand_u8(pg_count, vec, svdup_n_u8(0xDF)), svdup_n_u8(0)));\n        svuint8_t upper_mask = svand_u8(pg_count, svcmpeq_u8(pg_count, svand_u8(pg_count, vec, svdup_n_u8(0x7F)), svdup_n_u8(0)), svnot_u8(pg_count, lower_mask));\n        svuint8_t swapped_case = svsel_u8(pg_count, svsub_u8(pg_count, vec, svdup_n_u8(0x20)), svadd_u8(pg_count, vec, svdup_n_u8(0x20)));\n\n        // Replace vowels\n        for (int j = 0; j < 10; ++j) {\n            svbool_t is_vowel = svcmpeq_u8(pg_count, vec, svdup_n_u8(vowels[j]));\n            swapped_case = svsel_u8(pg_count, svdup_n_u8(repl_vowels[j]), swapped_case, is_vowel);\n        }\n\n        // Store results\n        uint8_t temp[vec_len];\n        svst1_u8(pg_count, temp, swapped_case);\n        result.append(reinterpret_cast<char*>(temp), count);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cctype>\n#include <string>\n\nstd::string encode_simd(const std::string & message){\n    const uint8_t vowels[] = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n    const uint8_t vowel_replacements[] = {'c', 'g', 'k', 'q', 'w', 'C', 'G', 'K', 'Q', 'W'};\n    \n    svbool_t pg = svptrue_b8();\n    std::string result;\n    result.reserve(message.size());\n\n    size_t i = 0;\n    size_t vec_len = svcntb();\n    size_t num_full_vecs = message.size() / vec_len;\n\n    for (size_t v = 0; v < num_full_vecs; ++v) {\n        svuint8_t msg_vec = svld1(pg, reinterpret_cast<const uint8_t*>(&message[i]));\n        \n        // Swap case\n        svuint8_t lower_mask = svandb(pg, svcmeq(pg, msg_vec, svdup_n_u8('a')), svcmeq(pg, msg_vec, svdup_n_u8('z')));\n        svuint8_t upper_mask = svandb(pg, svcmeq(pg, msg_vec, svdup_n_u8('A')), svcmeq(pg, msg_vec, svdup_n_u8('Z')));\n        svuint8_t swapped_case = svsel(pg, svsub(msg_vec, svdup_n_u8(32)), svadd(msg_vec, svdup_n_u8(32)), svor(lower_mask, upper_mask));\n\n        // Replace vowels\n        svuint8_t replaced_vowels = msg_vec;\n        for (int j = 0; j < 10; ++j) {\n            svbool_t is_vowel = svcmeq(pg, msg_vec, svdup_n_u8(vowels[j]));\n            replaced_vowels = svsel(pg, svdup_n_u8(vowel_replacements[j]), replaced_vowels, is_vowel);\n        }\n\n        // Store the result\n        uint8_t res[vec_len];\n        svst1(pg, res, replaced_vowels);\n        result.append(reinterpret_cast<char*>(res), vec_len);\n        i += vec_len;\n    }\n\n    // Handle remaining elements\n    size_t remaining = message.size() % vec_len;\n    if (remaining > 0) {\n        svbool_t pg_partial = svwhilelt_b8(i, message.size());\n        svuint8_t msg_vec = svld1(pg_partial, reinterpret_cast<const uint8_t*>(&message[i]));\n\n        // Swap case\n        svuint8_t lower_mask = svandb(pg_partial, svcmeq(pg_partial, msg_vec, svdup_n_u8('a')), svcmeq(pg_partial, msg_vec, svdup_n_u8('z')));\n        svuint8_t upper_mask = svandb(pg_partial, svcmeq(pg_partial, msg_vec, svdup_n_u8('A')), svcmeq(pg_partial, msg_vec, svdup_n_u8('Z')));\n        svuint8_t swapped_case = svsel(pg_partial, svsub(msg_vec, svdup_n_u8(32)), svadd(msg_vec, svdup_n_u8(32)), svor(lower_mask, upper_mask));\n\n        // Replace vowels\n        svuint8_t replaced_vowels = msg_vec;\n        for (int j = 0; j < 10; ++j) {\n            svbool_t is_vowel = svcmeq(pg_partial, msg_vec, svdup_n_u8(vowels[j]));\n            replaced_vowels = svsel(pg_partial, svdup_n_u8(vowel_replacements[j]), replaced_vowels, is_vowel);\n        }\n\n        // Store the result\n        uint8_t res[vec_len];\n        svst1(pg_partial, res, replaced_vowels);\n        result.append(reinterpret_cast<char*>(res), remaining);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <cctype>\n#include <string>\n\nstd::string encode_simd(const std::string & message){\n    const uint8_t vowels[] = {'a','e','i','o','u','A','E','I','O','U'};\n    const uint8_t repl[] = {'c','g','k','q','w','C','G','K','Q','W'};\n    size_t len = message.size();\n    svbool_t pg = svptrue_b8();\n    std::string result;\n    result.reserve(len);\n\n    for (size_t i = 0; i < len; i += svcntb()) {\n        size_t chunk = len - i;\n        if (chunk < svcntb()) {\n            pg = svwhilelt_b8((uint64_t)i, (uint64_t)len);\n        }\n        \n        svuint8_t vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&message[i]));\n        svuint8_t swapped_case = svxor_u8(pg, vec, svcmpv_f32(pg, vec, vec)); // Placeholder for case swap logic\n\n        // Create masks for vowels\n        svbool_t is_vowel = svfalse_b8();\n        for(int j=0; j<10; ++j){\n            is_vowel = svbor_b8(is_vowel, svcmpeq_b8(pg, vec, svdup_n_u8(vowels[j])));\n        }\n\n        // Replace vowels with corresponding replacement characters\n        svuint8_t replaced = svsel_u8(is_vowel, svindex_u8(repl[0], 1), vec);\n\n        // Swap case logic\n        svbool_t is_upper = svandb(pg, svcmpeq_b8(pg, svand_u8(pg, vec, svdup_n_u8(0xDF)), vec));\n        svuint8_t toggled_case = svsel_u8(is_upper, svadd_u8(pg, vec, svdup_n_u8(0x20)), svsub_u8(pg, vec, svdup_n_u8(0x20)));\n        svuint8_t final_vec = svsel_u8(is_vowel, replaced, toggled_case);\n\n        uint8_t out[svcntb()];\n        svst1_u8(pg, out, final_vec);\n        result.append(reinterpret_cast<char*>(out), svcntp_b8(pg));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n#include <cctype>\n\nstd::string encode_simd(const std::string & message){\n    const uint8_t vowels_lower[] = { 'a', 'e', 'i', 'o', 'u' };\n    const uint8_t vowels_upper[] = { 'A', 'E', 'I', 'O', 'U' };\n    const uint8_t vowel_replacements_lower[] = { 'c', 'g', 'k', 'q', 'w' };\n    const uint8_t vowel_replacements_upper[] = { 'C', 'G', 'K', 'Q', 'W' };\n\n    std::string result;\n    result.reserve(message.size());\n\n    svbool_t pg = svptrue_b8();\n    size_t vec_len = svcntb();\n\n    for (size_t i = 0; i < message.size(); i += vec_len) {\n        size_t n = message.size() - i;\n        if (n < vec_len) {\n            pg = svwhilelt_b8(i, message.size());\n        }\n\n        svuint8_t vec = svld1(pg, reinterpret_cast<const uint8_t*>(&message[i]));\n\n        // Swap case\n        svuint8_t lower_mask = svmovemask_b8(svand(pg, svcmeq(vec, svdup_n_u8('a')), svcmeq(vec, svdup_n_u8('z'))));\n        svuint8_t upper_mask = svmovemask_b8(svand(pg, svcmeq(vec, svdup_n_u8('A')), svcmeq(vec, svdup_n_u8('Z'))));\n\n        svuint8_t swapped_case = svsub_x(pg, vec, svdup_n_u8(' '));\n\n        // Replace vowels\n        for (int j = 0; j < 5; ++j) {\n            swapped_case = svsel(pg, svcmeq(swapped_case, svdup_n_u8(vowels_lower[j])), svdup_n_u8(vowel_replacements_lower[j]), swapped_case);\n            swapped_case = svsel(pg, svcmeq(swapped_case, svdup_n_u8(vowels_upper[j])), svdup_n_u8(vowel_replacements_upper[j]), swapped_case);\n        }\n\n        // Store results\n        uint8_t buffer[vec_len];\n        svst1(pg, buffer, swapped_case);\n        result.append(reinterpret_cast<char*>(buffer), svcntp_b8(pg));\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cctype>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict){\n    if (dict.empty()) return false;\n\n    bool first = true;\n    svbool_t pg = svptrue_b8();\n    uint8_t case_type = 0; // 0: unknown, 1: lower, 2: upper\n\n    for (const auto& [key, value] : dict) {\n        const char* str = key.c_str();\n        size_t len = key.length();\n\n        if (len == 0) return false;\n\n        svuint8_t sv_zero = svdup_n_u8(0);\n        svuint8_t sv_upper = svdup_n_u8('A');\n        svuint8_t sv_lower = svdup_n_u8('a');\n        svuint8_t sv_Z = svdup_n_u8('Z');\n        svuint8_t sv_z = svdup_n_u8('z');\n\n        size_t i = 0;\n        for (; i + svcntb() <= len; i += svcntb()) {\n            svuint8_t vec = svld1(pg, reinterpret_cast<const uint8_t*>(str + i));\n            svbool_t is_upper = svand_pg(pg, svcmpge_u8(pg, vec, sv_upper), svcmple_u8(pg, vec, sv_Z));\n            svbool_t is_lower = svand_pg(pg, svcmpge_u8(pg, vec, sv_lower), svcmple_u8(pg, vec, sv_z));\n\n            if (svcntp(is_upper) > 0 && svcntp(is_lower) > 0) {\n                return false; // Mixed case in a single key\n            }\n\n            if (first) {\n                if (svcntp(is_upper) > 0) case_type = 2;\n                if (svcntp(is_lower) > 0) case_type = 1;\n            } else {\n                if ((case_type == 1 && svcntp(is_upper) > 0) || (case_type == 2 && svcntp(is_lower) > 0)) {\n                    return false; // Inconsistent case\n                }\n            }\n        }\n\n        for (; i < len; ++i) {\n            if (std::isalpha(str[i])) {\n                if (first) {\n                    if (std::islower(str[i])) case_type = 1;\n                    else if (std::isupper(str[i])) case_type = 2;\n                    else return false;\n                } else {\n                    if ((case_type == 1 && !std::islower(str[i])) || (case_type == 2 && !std::isupper(str[i]))) {\n                        return false;\n                    }\n                }\n            } else {\n                return false; // Non-alphabetic character\n            }\n        }\n\n        first = false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cctype>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict){\n    if (dict.empty()) return false;\n\n    bool first = true;\n    svbool_t pg = svptrue_b8();\n    uint8_t case_type = 0; // 0: unknown, 1: lower, 2: upper\n\n    for (const auto& [key, value] : dict) {\n        const char* str = key.c_str();\n        size_t len = key.length();\n\n        if (len == 0) return false;\n\n        svuint8_t sv_zero = svdup_n_u8(0);\n        svuint8_t sv_upper = svdup_n_u8('A');\n        svuint8_t sv_lower = svdup_n_u8('a');\n        svuint8_t sv_Z = svdup_n_u8('Z');\n        svuint8_t sv_z = svdup_n_u8('z');\n\n        size_t i = 0;\n        bool is_lower = true, is_upper = true;\n\n        while (i < len) {\n            size_t vl = svcntb();\n            size_t k = len - i > vl ? vl : len - i;\n\n            svuint8_t sv_chars = svld1(pg, reinterpret_cast<const uint8_t*>(str + i));\n            svbool_t is_alpha = svand_pg(pg, svcmpge(sv_chars, sv_upper), svcmple(sv_chars, sv_Z));\n            svbool_t is_lower_check = svand_pg(pg, svcmpge(sv_chars, sv_lower), svcmple(sv_chars, sv_z));\n\n            is_upper &= !(svcntp(is_alpha, pg) != k);\n            is_lower &= !(svcntp(is_lower_check, pg) != k);\n\n            i += k;\n        }\n\n        if (first) {\n            if (is_lower) case_type = 1;\n            else if (is_upper) case_type = 2;\n            else return false;\n            first = false;\n        } else {\n            if ((case_type == 1 && !is_lower) || (case_type == 2 && !is_upper)) return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cctype>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    bool first = true;\n    svbool_t pg = svptrue_b8();\n    uint8_t case_type = 0; // 1 for all upper, 2 for all lower\n\n    for (const auto& [key, value] : dict) {\n        const char* str = key.c_str();\n        size_t len = key.length();\n\n        if (len == 0) return false;\n\n        svuint8_t sv_zero = svdup_n_u8(0);\n        svuint8_t sv_A = svdup_n_u8('A');\n        svuint8_t sv_Z = svdup_n_u8('Z');\n        svuint8_t sv_a = svdup_n_u8('a');\n        svuint8_t sv_z = svdup_n_u8('z');\n\n        bool is_upper = true;\n        bool is_lower = true;\n\n        for (size_t i = 0; i < len; i += svcntb()) {\n            size_t chunk = len - i > svcntb() ? svcntb() : len - i;\n            svuint8_t sv_chars = svld1(pg, reinterpret_cast<const uint8_t*>(str + i));\n            svbool_t is_alpha = svand_b8(pg, svcmpge_b8(pg, sv_chars, sv_A), svcmple_b8(pg, sv_chars, sv_Z));\n            svbool_t is_digit = svand_b8(pg, svcmpge_b8(pg, sv_chars, sv_zero), svcmple_b8(pg, sv_chars, sv_zero));\n\n            if (svcntp_m_b8(pg, is_alpha | is_digit) != chunk) {\n                is_upper = false;\n            }\n\n            is_alpha = svand_b8(pg, svcmpge_b8(pg, sv_chars, sv_a), svcmple_b8(pg, sv_chars, sv_z));\n            if (svcntp_m_b8(pg, is_alpha | is_digit) != chunk) {\n                is_lower = false;\n            }\n\n            if (!is_upper && !is_lower) break;\n        }\n\n        if (first) {\n            if (is_upper) case_type = 1;\n            else if (is_lower) case_type = 2;\n            else return false;\n            first = false;\n        } else {\n            if ((case_type == 1 && !is_upper) || (case_type == 2 && !is_lower)) return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cctype>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict){\n    if (dict.empty()) return false;\n\n    bool first = true;\n    svbool_t pg = svptrue_b8();\n    uint8_t case_type = 0; // 1 for all upper, 2 for all lower\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        if (key.empty()) return false;\n\n        svuint8_t vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(key.c_str()));\n        svuint8_t lower_mask = svand_u8(pg, vec, svdup_n_u8(0xDF));\n        svuint8_t upper_mask = svand_u8(pg, vec, svdup_n_u8(0x5F));\n\n        bool is_lower = svcmpne_m_b8(pg, lower_mask, vec).bits == 0;\n        bool is_upper = svcmpeq_m_b8(pg, upper_mask, vec).bits == 0;\n\n        if (first) {\n            if (is_lower) case_type = 2;\n            else if (is_upper) case_type = 1;\n            else return false;\n            first = false;\n        } else {\n            if ((case_type == 1 && !is_upper) || (case_type == 2 && !is_lower)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cctype>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict){\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    svbool_t pg = svptrue_b8(); // Predicate for all elements\n\n    for (const auto& [key, value] : dict) {\n        const char* str = key.c_str();\n        size_t len = key.length();\n\n        all_lower = true;\n        all_upper = true;\n\n        size_t i = 0;\n        for (; i + svcntb() <= len; i += svcntb()) {\n            svuint8_t vec = svld1(pg, reinterpret_cast<const uint8_t*>(str + i));\n            svuint8_t lower_mask = svand_u8(pg, vec, svdup_n_u8(0x20));\n            svuint8_t upper_mask = svnot_u8(pg, lower_mask);\n\n            all_lower &= !(svcntb() - svcntp_m_b(pg, svcmpeq(pg, lower_mask, svdup_n_u8(0x20))));\n            all_upper &= !(svcntb() - svcntp_m_b(pg, svcmpeq(pg, upper_mask, svdup_n_u8(0x20))));\n        }\n\n        for (; i < len; ++i) {\n            if (islower(str[i])) {\n                all_upper = false;\n            } else if (isupper(str[i])) {\n                all_lower = false;\n            } else {\n                all_lower = false;\n                all_upper = false;\n            }\n        }\n\n        if (!all_lower && !all_upper) {\n            return false;\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n){\n    std::vector<int> primes;\n    if (n <= 1) return primes;\n\n    svbool_t pg = svptrue_b32();\n    int vl = svcntw();\n\n    // Create a sieve buffer\n    std::vector<bool> sieve(n, true);\n    sieve[0] = false;\n    if (n > 1) sieve[1] = false;\n\n    int limit = sqrt(n);\n\n    for(int i = 2; i <= limit; ++i){\n        if(sieve[i]){\n            svint32_t vi = svdup_n_s32(i);\n            int num_iter = (n - i * i + vl - 1) / vl + 1;\n            for(int j = 0; j < num_iter; ++j){\n                svint32_t idx = svadd_n_s32(svindex_s32(j * vl, (j+1)*vl -1), i);\n                svint32_t mul_res = svmul_x_s32(pg, vi, idx);\n                svbool_t pred = svcmplt_u32(pg, mul_res, svdup_n_s32(n));\n                svint32_t res = svsel_s32(pred, mul_res, svdup_n_s32(0));\n                int32_t* ptr = reinterpret_cast<int32_t*>(&res);\n                for(int k = 0; k < vl; ++k){\n                    if(ptr[k] != 0 && ptr[k] < n){\n                        sieve[ptr[k]] = false;\n                    }\n                }\n            }\n        }\n    }\n\n    // Collect primes\n    for(int i = 2; i < n; ++i){\n        if(sieve[i]) primes.push_back(i);\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n){\n    std::vector<int> primes;\n    if (n <= 1) return primes;\n\n    int vl = svcntw(); // Vector length in terms of number of elements\n    svbool_t pg = svptrue_b32(); // Predicate for all true\n    svint32_t zero = svdup_n_s32(0);\n\n    // Sieve of Eratosthenes using SVE\n    int limit = n;\n    std::vector<int> is_prime(limit, 1);\n    is_prime[0] = is_prime[1] = 0;\n\n    int sqrt_n = static_cast<int>(std::sqrt(n));\n    for(int i = 2; i <= sqrt_n; ++i){\n        if(is_prime[i]){\n            int start_index = i * i;\n            if(start_index >= limit) continue;\n\n            // Load vector of indices\n            for(int idx = start_index; idx < limit; idx += i){\n                is_prime[idx] = 0;\n            }\n        }\n    }\n\n    // Collect primes using SVE\n    for(int i = 0; i < limit; i += vl){\n        svint32_t indices = svindex_s32(i, 1);\n        svint32_t values = svld1_gather_index(pg, is_prime.data(), indices, sizeof(int));\n        svbool_t pred = svcmpeq(pg, values, zero);\n        pred = svnot_b32(pred);\n\n        int active_count = svcntp_b32(pred);\n        if(active_count == 0) continue;\n\n        svint32_t masked_indices = svsel(pred, indices, svdup_n_s32(-1));\n        int32_t results[vl];\n        svst1(pg, results, masked_indices);\n\n        for(int j = 0; j < vl; ++j){\n            if(results[j] != -1){\n                primes.push_back(results[j]);\n            }\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n){\n    std::vector<int> primes;\n    if (n <= 1) return primes;\n\n    int vl = svcntw(); // Vector length in terms of the number of elements\n    svbool_t pg = svptrue_b32(); // Predicate for all true\n    svint32_t zero = svdup_n_s32(0);\n\n    // Create a sieve buffer\n    std::vector<bool> sieve(n, true);\n    sieve[0] = false;\n    if (n > 1) sieve[1] = false;\n\n    int limit = static_cast<int>(svsqrt_f32(svf32_t{n - 1}));\n\n    for (int p = 2; p <= limit; ++p) {\n        if (sieve[p]) {\n            int start = p * p;\n            if (start >= n) break;\n\n            // Compute vectorized indices\n            svint32_t idx = svindex_s32(start, 1);\n            svbool_t pred = svcmplt_s32(pg, idx, svdup_n_s32(n));\n\n            while (svptest_any(pg, pred)) {\n                svst1_scatter_u32(pg, &sieve[start], pred, idx, [](bool b, bool& s) { return !(b && s); });\n                idx = svadd_s32(pg, idx, svdup_n_s32(p));\n                pred = svcmplt_s32(pg, idx, svdup_n_s32(n));\n            }\n        }\n    }\n\n    // Collect primes\n    for (int i = 2; i < n; ++i) {\n        if (sieve[i]) primes.push_back(i);\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n){\n    std::vector<int> primes;\n    if (n <= 1) return primes;\n\n    int vl = svcntw(); // Vector length in terms of elements\n    svbool_t pg = svptrue_b32(); // Predicate for all true\n\n    for(int i = 2; i < n; ){\n        svint32_t vi = svdup_n_s32(i);\n        svbool_t is_prime = pg;\n\n        for(int j = 2; j*j <= i && svptest_any(pg, is_prime); ++j){\n            svint32_t vj = svdup_n_s32(j);\n            is_prime = svand_b32(is_prime, svcmpne_m(pg, svmla_s32(pg, svdup_n_s32(i/j), vj, svdup_n_s32(0)), svdup_n_s32(0)));\n        }\n\n        if(svptest_any(pg, is_prime)){\n            primes.push_back(i);\n        }\n        i++;\n    }\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n){\n    std::vector<int> primes;\n    if (n <= 1) return primes;\n\n    int vl = svcntw(); // Vector length in terms of the number of int elements\n    svbool_t pg = svptrue_b32(); // Predicate for all true\n    svint32_t zero = svdup_n_s32(0);\n\n    // Create a sieve buffer\n    std::vector<bool> sieve(n, true);\n    sieve[0] = sieve[1] = false;\n\n    int limit = static_cast<int>(svsqrt_f32(svf32_t{n - 1})) + 1;\n\n    for(int i = 2; i < limit; ++i){\n        if(sieve[i]){\n            int start = i * i;\n            if(start >= n) break;\n\n            // Compute vectorized indices\n            svint32_t vi = svindex_s32(start, i);\n            svbool_t p = svcmp_lt_u32(pg, vi, svdup_n_s32(n)); // Indices less than n\n\n            do {\n                svst1_b(p, &sieve[0], svand_b_z(pg, p, svdup_n_u8(0))); // Clear non-prime flags\n                vi = svadd_s32(pg, vi, svdup_n_s32(i));\n                p = svcmp_lt_u32(pg, vi, svdup_n_s32(n));\n            } while(svptest_any(pg, p));\n        }\n    }\n\n    // Collect primes\n    for(int i = 2; i < n; ++i){\n        if(sieve[i]) primes.push_back(i);\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n\nint count_upper_simd(const std::string & s){\n    int count = 0;\n    const uint8_t *data = reinterpret_cast<const uint8_t *>(s.data());\n    size_t length = s.length();\n    size_t vec_length = svcntb();\n\n    uint64_t index_mask = 0x5555555555555555; // Mask for even indices\n    svbool_t pred_even = svbrmask_b8(index_mask);\n\n    svuint8_t vowels = svdup_n_u8('A');\n    svuint8_t tmp = svdup_n_u8('E' - 'A');\n    vowels = svadd_u8(vowels, tmp);\n    tmp = svdup_n_u8('I' - 'E');\n    vowels = svadd_u8(vowels, tmp);\n    tmp = svdup_n_u8('O' - 'I');\n    vowels = svadd_u8(vowels, tmp);\n    tmp = svdup_n_u8('U' - 'O');\n    vowels = svadd_u8(vowels, tmp);\n\n    for (size_t i = 0; i <= length - vec_length; i += vec_length) {\n        svbool_t pred = svwhilelt_b8(i, length);\n        svuint8_t vec = svld1_u8(pred, data + i);\n        svbool_t is_upper = svcmpeq_u8_m(pred, vec, vowels);\n        svbool_t is_even = svand_b8(pred, is_upper, pred_even);\n        count += svpopcnt_b8(is_even);\n    }\n\n    // Handle remaining elements\n    if (length % vec_length != 0) {\n        svbool_t pred = svwhilelt_b8(length - (length % vec_length), length);\n        svuint8_t vec = svld1_u8(pred, data + length - (length % vec_length));\n        svbool_t is_upper = svcmpeq_u8_m(pred, vec, vowels);\n        svbool_t is_even = svand_b8(pred, is_upper, pred_even);\n        count += svpopcnt_b8(is_even);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n\nint count_upper_simd(const std::string & s){\n    int count = 0;\n    const uint8_t *data = reinterpret_cast<const uint8_t *>(s.data());\n    size_t len = s.length();\n    uint64_t index = 0;\n\n    svbool_t pg = svptrue_b8(); // Predicate for all true\n    svuint8_t upper_vowels = svdup_n_u8(0);\n    upper_vowels = svorr_u8(upper_vowels, svdup_n_u8('A'));\n    upper_vowels = svorr_u8(upper_vowels, svdup_n_u8('E'));\n    upper_vowels = svorr_u8(upper_vowels, svdup_n_u8('I'));\n    upper_vowels = svorr_u8(upper_vowels, svdup_n_u8('O'));\n    upper_vowels = svorr_u8(upper_vowels, svdup_n_u8('U'));\n\n    while (index <= len - svcntb()) {\n        svbool_t even_pred = svcmpeq_n_b64(svindex_u64(index, 1), 0); // Even indices predicate\n        svuint8_t vec = svld1(pg, data + index);\n        svbool_t is_upper_vowel = svceq_m(pg, even_pred, vec, upper_vowels);\n        count += svcntp(is_upper_vowel, pg);\n        index += svcntb();\n    }\n\n    // Handle leftover elements\n    if (index < len) {\n        svbool_t tail_mask = svwhilelt_b8(index, len);\n        svbool_t even_pred = svand_b8(tail_mask, svcmpeq_n_b64(svindex_u64(index, 1), 0));\n        svuint8_t vec = svld1(pg, data + index);\n        svbool_t is_upper_vowel = svceq_m(pg, even_pred, vec, upper_vowels);\n        count += svcntp_m(pg, is_upper_vowel, tail_mask);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint count_upper_simd(const std::string &s) {\n    int count = 0;\n    const uint8_t *data = reinterpret_cast<const uint8_t *>(s.data());\n    size_t length = s.size();\n    size_t i = 0;\n\n    // Define the mask for uppercase vowels: A E I O U\n    uint8x16_t vowels_mask = { 'A', 'E', 'I', 'O', 'U', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n\n    while (i + svcntb() <= length) {\n        svbool_t pg = svptrue_b8();\n        svuint8_t vec = svld1(pg, data + i);\n        svbool_t is_even = svand_x(pg, svcmpeq(pg, svaddv_u8(svindex_n_u8(0, 1)), svdup_n_u8(0)), svptrue_b8());\n        svbool_t is_vowel = svcmpeq(pg, vec, vowels_mask);\n        svbool_t result = svand_b8(is_even, is_vowel);\n        count += svpopcnt_b8(result);\n        i += svcntb();\n    }\n\n    for (; i < length; ++i) {\n        if (i % 2 == 0 && strchr(\"AEIOU\", data[i]) != nullptr) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n\nint count_upper_simd(const std::string & s){\n    int count = 0;\n    const uint8_t *str = reinterpret_cast<const uint8_t *>(s.c_str());\n    size_t len = s.length();\n    size_t index = 0;\n\n    svbool_t pg = svptrue_b8(); // Predicate for all true\n    svuint8_t upper_vowels = svdup_n_u8('A' + ('E' - 'A' + 1)); // Vector of uppercase vowels A, E, I, O, U\n\n    while (index < len) {\n        size_t vl = svcntb(); // Vector length in bytes\n        size_t process_len = len - index;\n        if (process_len < vl) {\n            pg = svwhilelt_b8(index, len); // Generate predicate for remaining elements\n        }\n\n        svuint8_t vec = svld1(pg, str + index); // Load vector from string\n        svuint8_t even_mask = svand_n_u8(svcmpe_eq_u8(pg, svaddv_u8(vec), svdup_n_u8(1)), 0x55); // Even indices mask\n        svuint8_t is_upper_vowel = svcmpeq_u8(pg, vec, upper_vowels); // Compare with uppercase vowels\n        svuint8_t result = svand_u8(pg, even_mask, is_upper_vowel); // Combine masks\n\n        count += svpopcnt_b8(pg, result); // Count matches\n\n        index += vl;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n\nint count_upper_simd(const std::string & s){\n    int count = 0;\n    const uint8_t *data = reinterpret_cast<const uint8_t *>(s.data());\n    size_t len = s.length();\n    svbool_t pg = svptrue_b8();\n    svuint8_t upper_vowels = svdup_n_u8('A' + ('E' - 'A') / 2); // Midpoint for comparison\n    svuint8_t mask_even_indices = svdup_n_u8(1);\n\n    for (size_t i = 0; i < len; i += svcntb()) {\n        svbool_t index_mask = svand_b8(svcvt_b8_z(pg, svindexz_s32(pg, static_cast<int32_t>(i))), mask_even_indices);\n        svuint8_t vec = svld1_u8(index_mask, data + i);\n        svbool_t is_upper_vowel = svorr_b8(svcmpeq_b8(vec, svdup_n_u8('A')), svcmpeq_b8(vec, svdup_n_u8('E')));\n        is_upper_vowel = svand_b8(is_upper_vowel, index_mask);\n        count += svpopcnt_b8(is_upper_vowel);\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n){\n    int vl = svcntw(); // Get the vector length in terms of number of 32-bit elements\n    int levels = n;\n    std::vector<int> result;\n\n    if (levels <= 0) return result;\n\n    svbool_t pg = svptrue_b32(); // Predicate for all true\n    svint32_t current = svdup_n_s32(n); // Initialize the first level with n stones\n    svint32_t step = svdup_n_s32(2); // Step is always 2 for odd/even progression\n\n    for(int i = 0; i < (levels + vl - 1) / vl; ++i){\n        svint32_t vec = svwhilelt_u32(pg, i * vl, levels);\n        svint32_t stones = svadd_s32(vec, current);\n        int *data = (int *)sv interpreted data;\n        for(int j = 0; j < vl; ++j){\n            if(j + i * vl < levels){\n                result.push_back(data[j]);\n            }\n        }\n        current = svadd_s32(pg, current, step);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n){\n    int vl = svcntw(); // Get the vector length in terms of the number of 32-bit elements\n    int num_vectors = (n + vl - 1) / vl; // Calculate the number of vectors needed\n\n    std::vector<int> result(n);\n    int current = n;\n    for(int i = 0; i < num_vectors; ++i){\n        svbool_t pg = svptrue_b32(); // Predicate for all active elements\n        svint32_t vec_current = svdup_n_s32(current); // Broadcast current value to all lanes\n        svint32_t step = svdup_n_s32(2); // Step is always 2 (next odd/even)\n\n        // Generate the sequence in parallel\n        svint32_t indices = svindex_s32(0, 1); // Generate {0, 1, 2, ..., vl-1}\n        svint32_t values = svadd_s32(pg, vec_current, svmul_s32(pg, indices, step));\n\n        // Store the results into the array\n        int *result_ptr = &result[i * vl];\n        svst1_s32(pg, result_ptr, values);\n\n        // Update the starting point for the next iteration\n        current += 2 * vl;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n){\n    int levels = n;\n    svbool_t pg = svptrue_b32();\n    SVint32_t vec_n = svdup_n_s32(n);\n    SVint32_t result = vec_n;\n    std::vector<int> pile;\n\n    for(int i = 1; i < levels; ++i){\n        SVint32_t increment = svand_s32(pg, svadd_n_s32(svcmpne_m_s32(pg, vec_n, svdup_n_s32(0)), 2), svsub_n_s32(svor_s32(pg, vec_n, svdup_n_s32(1)), vec_n));\n        vec_n = svadd_s32(pg, vec_n, increment);\n        result = svmla_s32(pg, result, svdup_n_s32(1), vec_n);\n    }\n\n    int active_len = svcntw();\n    if(active_len > levels){\n        active_len = levels;\n    }\n\n    pile.reserve(levels);\n    int tmp[active_len];\n    svst1(pg, tmp, result);\n    for(int i = 0; i < levels; ++i){\n        pile.push_back(tmp[i]);\n    }\n    return pile;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n){\n    int vl = svcntw(); // Get the vector length in terms of the number of int elements\n    int num_vectors = (n + vl - 1) / vl; // Calculate how many vectors we need\n    std::vector<int> result(n);\n\n    int32_t start = n;\n    svbool_t pg = svptrue_b32(); // Predicate for all true\n\n    for(int i = 0; i < num_vectors; ++i){\n        int32_t index_vec = svindex_n_s32(i * vl, 1); // Generate index vector\n        int32_t cond = svand_x(pg, svidup_n_s32(1), index_vec); // Create a condition vector to check even/odd\n        int32_t incr = svadd_x(pg, svidup_n_s32(start), svlsl_x(pg, index_vec, svidup_n_s32(1))); // Compute increment\n        int32_t res_vec = svsel_x(pg, svadd_x(pg, incr, svidup_n_s32(1)), incr, sveq_z(pg, svarr_i32(cond, 0), svidup_n_s32(0))); // Select based on condition\n\n        // Store the results into the array\n        for(int j = 0; j < vl && i*vl + j < n; ++j){\n            result[i*vl + j] = svasrrd_x(pg, res_vec, j);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n){\n    int vl = svcntw(); // Get the vector length in terms of the number of int elements\n    int levels = n;\n    std::vector<int> result;\n\n    svbool_t pg = svptrue_b32(); // Predicate for all true\n    svint32_t current = svdup_n_s32(n); // Initialize vector with starting value n\n    svint32_t step = svdup_n_s32(2); // Step is always 2\n\n    while (levels > 0) {\n        int num_active = (levels > vl) ? vl : levels; // Determine active elements\n        svbool_t pred = svwhilelt_b32(num_active, 0); // Create predicate for active elements\n\n        svint32_t tmp = svsel_s32(pred, current, svdup_n_s32(0)); // Select only active elements\n        int32_t *ptr = (int32_t *)sv interpreted_cast(tmp, pred); // Extract active elements\n        result.insert(result.end(), ptr, ptr + num_active); // Append to result\n\n        current = svadd_s32(pg, current, step); // Update current values\n        levels -= num_active; // Decrease remaining levels\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <bit>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m){\n    if(n > m){\n        return \"-1\";\n    }\n\n    svbool_t pg = svptrue_b64();\n    int64x2_t sum_vec = svdupq_n_s64(pg, 0);\n    int64_t count = 0;\n\n    for(int64_t i = n; i <= m; ){\n        svint64_t indices = svindex_s64(i, 1);\n        svbool_t cond = svcmpge(pg, indices, svdup_n_s64(pg, n));\n        cond = svand_b64(cond, svcmple(pg, indices, svdup_n_s64(pg, m)));\n        \n        int64x2_t partial_sum = svaddv_s64(pg, cond, indices);\n        sum_vec = svadd_z(pg, sum_vec, partial_sum);\n        \n        int64_t active = svcntw() - svcntp_b64(cond, pg);\n        count += active;\n        \n        i += svcntw();\n    }\n\n    int64_t total_sum = svaddv_s64(pg, sum_vec);\n    int64_t avg = total_sum / count;\n\n    std::string binary = std::bitset<64>(avg).to_string();\n    // Trim leading zeros\n    size_t first_one = binary.find_first_of('1');\n    if(first_one != std::string::npos){\n        binary = binary.substr(first_one);\n    }\n    else{\n        binary = \"0\";\n    }\n\n    return binary;\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <bit>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n\n    svbool_t pg = svptrue_b64();\n    int64_t count = m - n + 1;\n\n    // Create a vector containing the range [n, m]\n    svint64_t vec = svdup_s64(n);\n    svint64_t inc = svdup_s64(1);\n    svint64_t sum_vec = svdup_s64(0);\n\n    for (int64_t i = 0; i < count; ++i) {\n        sum_vec = svadd_z(pg, sum_vec, vec);\n        vec = svadd_z(pg, vec, inc);\n    }\n\n    // Horizontal sum of the vector\n    int64_t total_sum = svaddv_s64(pg, sum_vec);\n\n    // Compute average and round down\n    int64_t avg = total_sum / count;\n\n    // Convert to binary string\n    std::string binary = std::bitset<64>(avg).to_string();\n    // Remove leading zeros\n    binary.erase(0, binary.find_first_of('1'));\n    return binary;\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <bit>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n\n    svbool_t pg = svptrue_b64();\n    int64_t count = m - n + 1;\n    int64x2_t sum = svdupq_n_s64(0);\n\n    for (int64_t i = n; i <= m; i += svcntd()) {\n        svint64_t indices = svindex_s64(i, i + svcntd());\n        svint64_t pred_indices = svsel_s64(svcmpge(pg, indices, svdup_n_s64(n)), indices, svdupq_n_s64(0));\n        pred_indices = svsel_s64(svcmpgt(pg, indices, svdup_n_s64(m)), svdupq_n_s64(0), pred_indices);\n        sum = svadd_z(pg, sum, pred_indices);\n    }\n\n    int64_t total_sum = svaddv_s64(pg, sum);\n    int64_t avg = total_sum / count;\n\n    std::string binary = std::bitset<64>(avg).to_string();\n    // Remove leading zeros\n    size_t first_one = binary.find_first_of('1');\n    if (first_one != std::string::npos) {\n        binary = binary.substr(first_one);\n    } else {\n        binary = \"0\";\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <bit>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n\n    svbool_t pg = svptrue_b64();\n    int64_t count = m - n + 1;\n\n    // Calculate sum using SVE\n    svint64_t acc = svdupq_n_s64(0);\n    for (int64_t i = n; i <= m; ++i) {\n        svint64_t val = svdupq_n_s64(i);\n        acc = svaddaq(pg, acc, val);\n    }\n\n    // Extract the total sum from the vector accumulator\n    int64_t total_sum = svaddv(pg, acc);\n\n    // Compute average and round down\n    int64_t avg = total_sum / count;\n\n    // Convert to binary string\n    std::string binary = std::bitset<64>(avg).to_string();\n\n    // Remove leading zeros\n    size_t first_one = binary.find('1');\n    if (first_one != std::string::npos) {\n        binary = binary.substr(first_one);\n    } else {\n        binary = \"0\";\n    }\n\n    return binary;\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n\n    svbool_t pg = svptrue_b64();\n    int64x_n_t vl = svcntd();\n\n    int64_t count = m - n + 1;\n    int64_t sum = 0;\n\n    // Vectorized summation\n    for (int64_t i = n; i <= m; i += vl) {\n        int64_t num_elements = svcntp_b64(pg, svwhilelt_b64(i, m + 1));\n        svint64_t indices = svindex_s64(i, i + vl);\n        svint64_t masked_indices = svdupq_n_s64(0);\n        masked_indices = svsel_s64(pg, indices, masked_indices);\n        sum += svaddv_s64(pg, masked_indices);\n        i += vl - 1;\n    }\n\n    int64_t avg = sum / count;\n    std::string binary = \"\";\n\n    // Convert average to binary\n    int64_t temp = avg;\n    if (temp == 0) binary = \"0\";\n    while (temp > 0) {\n        binary = (temp % 2 ? \"1\" : \"0\") + binary;\n        temp /= 2;\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n){\n    if (n <= 0) return {};\n\n    std::vector<int> result(n, 0);\n\n    svbool_t pg = svptrue_b32();\n    int vl = svcntw();\n\n    for (int i = 0; i < n; i += vl){\n        int k = i;\n        svint32_t idx = svindex_n_s32(k, 1);\n        svint32_t res = svdup_n_s32(1);\n\n        svbool_t pred = svcmpeq_b32(pg, svmul_x_n_s32(pg, idx, 2), idx); // Check if index is even\n\n        // Compute factorial mod 10000 for even indices\n        svint32_t fact = svdup_n_s32(1);\n        for (int j = 1; j <= svcvtas_x_n_s32(pg, idx); ++j){\n            fact = svmul_x_s32(pg, fact, svdup_n_s32(j));\n            fact = svsmod_x_n_s32(pg, fact, 10000);\n        }\n\n        // Compute sum for odd indices\n        svint32_t sum = svdup_n_s32(0);\n        for (int j = 1; j <= svcvtas_x_n_s32(pg, idx); ++j){\n            sum = svadd_x_s32(pg, sum, svdup_n_s32(j));\n        }\n\n        // Select based on predicate\n        res = svsel_s32(pred, fact, sum);\n\n        // Store results into vector\n        int *ptr = &result[0] + i;\n        svst1(pg, ptr, res);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n){\n    if (n <= 0) return {};\n\n    std::vector<int> result(n, 0);\n\n    svbool_t pg = svptrue_b32();\n    int vl = svcntw();\n\n    for(int i = 0; i < n; i += vl){\n        int k = (n - i) < vl ? (n - i) : vl;\n        svbool_t pgi = svwhilelt_b32(i, i + k);\n\n        svint32_t idxs = svindex_s32(0, 1);\n        svint32_t values = svdup_s32(0);\n\n        for(int j = 1; j <= vl; ++j){\n            svint32_t current = svaddvs_s32(pgi, values, j);\n            svint32_t mask = svcmpeq_s32(pgi, svandvs_s32(idxs, 1), 0);\n            svint32_t factorial_mod = svsmodvs_s32(pgi, current, 10000);\n            values = svsel_s32(pgi, factorial_mod, current);\n        }\n\n        int *res_ptr = &result[i];\n        svst1_s32(pgi, res_ptr, values);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n){\n    if (n <= 0) return {};\n\n    svbool_t pg = svptrue_b32();\n    int *result = static_cast<int *>(svmemdup_n_s32(n, 0));\n\n    for (int i = 1; i <= n; ++i) {\n        svint32_t vi = svdup_n_s32(i);\n        svint32_t vres = svld1(pg, result);\n\n        if (i % 2 == 0) {\n            // Compute factorial mod 10000\n            int fact = 1;\n            for (int j = 1; j <= i; ++j) {\n                fact = (fact * j) % 10000;\n            }\n            svst1(pg, result, svaddv_n_s32(fact));\n        } else {\n            // Compute sum from 1 to i\n            int sum = (i * (i + 1)) / 2;\n            svst1(pg, result, svaddv_n_s32(sum));\n        }\n    }\n\n    std::vector<int> ret(result, result + n);\n    free(result);\n    return ret;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n){\n    std::vector<int> result(n, 0);\n    if (n <= 0) return result;\n\n    svbool_t pg = svptrue_b32();\n    int vl = svcntw();\n\n    for(int i = 0; i < n; i += vl){\n        int k = (n - i) < vl ? (n - i) : vl;\n        svbool_t pg_k = svwhilelt_b32(i, i + k);\n\n        svint32_t idx = svindex_s32(i, i + 1);\n\n        // Compute factorial modulo 10000 for even indices\n        svint32_t fact_mod = svdup_n_s32(1);\n        svint32_t sum = svdup_n_s32(0);\n\n        for(int j = 1; j <= n; ++j){\n            svint32_t j_vec = svdup_n_s32(j);\n            svint32_t mask_even = svand_b32(pg_k, svcmeq_m_s32(pg_k, idx, svdup_n_s32(j)));\n            fact_mod = svmul_x_s32(mask_even, fact_mod, j_vec);\n            fact_mod = svmla_s32(mask_even, fact_mod, svdup_n_s32(10000));\n            fact_mod = svsub_s32(mask_even, fact_mod, svdup_n_s32(10000));\n\n            svint32_t mask_odd = svnot_b32(mask_even);\n            sum = svadd_x_s32(mask_odd, sum, j_vec);\n        }\n\n        svint32_t res = svsel_s32(svcmeq_m_s32(pg_k, svand_s32(idx, svdup_n_s32(1)), svdup_n_s32(0)), fact_mod, sum);\n\n        svst1(pg_k, &result[i], res);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    if (n <= 0) return {};\n\n    std::vector<int> result(n);\n\n    svbool_t pg = svptrue_b32();\n    int vl = svcntw();\n\n    for (int i = 0; i < n; i += vl) {\n        int bound = n - i;\n        int chunks = (bound > vl) ? vl : bound;\n\n        svbool_t pg_chunk = svwhilelt_b32(i, i + chunks);\n\n        svint32_t idxs = svindex_s32(i, i + chunks);\n\n        // Compute factorial mod 10000 for even indices\n        svint32_t fact_mod = svdup_s32(1);\n        svint32_t temp = svdup_s32(1);\n        for (int j = 1; j <= chunks; ++j) {\n            svint32_t mask_even = svand_b32(pg_chunk, svtst_m_s32(pg_chunk, idxs, 1));\n            temp = svmla_s32(mask_even, temp, svdup_n_s32(j));\n            fact_mod = svmla_s32(mask_even, fact_mod, temp);\n            fact_mod = svaddv_s32(mask_even, fact_mod, svdup_n_s32(10000));\n            fact_mod = svsubv_s32(mask_even, fact_mod, svdup_n_s32(10000));\n        }\n\n        // Compute sum for odd indices\n        svint32_t sum = svdup_s32(0);\n        for (int j = 1; j <= chunks; ++j) {\n            svint32_t mask_odd = svbic_b32(pg_chunk, svtst_m_s32(pg_chunk, idxs, 1));\n            sum = svmla_s32(mask_odd, sum, svdup_n_s32(j));\n        }\n\n        // Combine results\n        svint32_t res = svsel_s32(svtst_m_s32(pg_chunk, idxs, 1), fact_mod, sum);\n\n        // Store results into the vector\n        svst1_scatter_offset_s32(pg_chunk, result.data() + i, res, svindex_s32(0, 4));\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n){\n    int even = 0, odd = 0;\n    svbool_t pg = svptrue_b32();\n    svint32_t count_even = svdup_n_s32(0);\n    svint32_t count_odd = svdup_n_s32(0);\n\n    for(int i = 1; i <= n; ++i){\n        int num = i;\n        int rev = 0;\n        int temp = num;\n\n        while(temp > 0){\n            rev = rev * 10 + (temp % 10);\n            temp /= 10;\n        }\n\n        svint32_t svi = svdup_n_s32(i);\n        svint32_t svrev = svdup_n_s32(rev);\n\n        svbool_t is_palindrome = svcmpeq_s32(pg, svi, svrev);\n        svbool_t is_even = svand_b32(pg, is_palindrome, svcmpeq_m_s32(pg, svand_s32(pg, svi, svdup_n_s32(1)), svdup_n_s32(0)));\n        svbool_t is_odd = svand_b32(pg, is_palindrome, svcmpeq_m_s32(pg, svand_s32(pg, svi, svdup_n_s32(1)), svdup_n_s32(1)));\n\n        count_even = svaddv_s32(pg, count_even, svreinterpret_s32_u32(svsel_u32(pg, svdup_n_u32(1), svdup_n_u32(0), is_even)));\n        count_odd = svaddv_s32(pg, count_odd, svreinterpret_s32_u32(svsel_u32(pg, svdup_n_u32(1), svdup_n_u32(0), is_odd)));\n    }\n\n    even = svaddv_s32(pg, count_even);\n    odd = svaddv_s32(pg, count_odd);\n\n    return std::vector<int>{even, odd};\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even = 0, odd = 0;\n    svbool_t pg = svptrue_b32();\n    svint32_t count = svdup_n_s32(0);\n\n    for (int i = 1; i <= n; ++i) {\n        int num = i;\n        int rev = 0;\n        int temp = num;\n\n        // Reverse the number\n        while (temp != 0) {\n            rev = rev * 10 + (temp % 10);\n            temp /= 10;\n        }\n\n        // Check if palindrome\n        svint32_t v_num = svdup_n_s32(num);\n        svint32_t v_rev = svdup_n_s32(rev);\n        svbool_t is_palindrome = svcmpeq(pg, v_num, v_rev);\n\n        // Check if even or odd\n        svbool_t is_even = svcmpeq(pg, svand_s32(pg, v_num, svdup_n_s32(1)), svdup_n_s32(0));\n        svbool_t is_odd = svcmpne(pg, svand_s32(pg, v_num, svdup_n_s32(1)), svdup_n_s32(0));\n\n        // Count even and odd palindromes\n        count = svadd_m_s32(pg, is_palindrome & is_even, count, svdup_n_s32(1));\n        count = svadd_m_s32(pg, is_palindrome & is_odd, count, svdup_n_s32(1));\n\n        // Accumulate results\n        even += svaddv_s32(pg, svand_s32(pg, count, svcmpne_z(pg, svdup_n_s32(0), count)));\n        odd += svaddv_s32(pg, svand_s32(pg, count, svcmpeq_z(pg, svdup_n_s32(0), count)));\n    }\n\n    return std::vector<int>{even, odd};\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even = 0, odd = 0;\n    svbool_t pg = svptrue_b32();\n    svint32_t count_even = svdup_n_s32(0);\n    svint32_t count_odd = svdup_n_s32(0);\n\n    for (int i = 1; i <= n; ++i) {\n        int num = i;\n        int rev = 0;\n        int temp = num;\n\n        while (temp > 0) {\n            rev = rev * 10 + (temp % 10);\n            temp /= 10;\n        }\n\n        svint32_t svi = svdup_n_s32(i);\n        svint32_t svrev = svdup_n_s32(rev);\n\n        svbool_t is_palindrome = svcmpeq(pg, svi, svrev);\n        svbool_t is_even = svand_b32(pg, is_palindrome, svcmpeq(pg, svand_s32(pg, svi, svdup_n_s32(1)), svdup_n_s32(0)));\n        svbool_t is_odd = svand_b32(pg, is_palindrome, svcmpne(pg, svand_s32(pg, svi, svdup_n_s32(1)), svdup_n_s32(0)));\n\n        count_even = svadd_x(pg, count_even, svsel_s32(is_even, svone_s32(), svdup_n_s32(0)));\n        count_odd = svadd_x(pg, count_odd, svsel_s32(is_odd, svone_s32(), svdup_n_s32(0)));\n    }\n\n    even = svaddv_s32(pg, count_even);\n    odd = svaddv_s32(pg, count_odd);\n\n    return std::vector<int>{even, odd};\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n){\n    int even = 0, odd = 0;\n    svbool_t pg = svptrue_b32();\n    svint32_t count_even = svdup_n_s32(pg, 0);\n    svint32_t count_odd = svdup_n_s32(pg, 0);\n\n    for(int i=1; i<=n; ++i){\n        int num = i;\n        int rev = 0;\n        int temp = num;\n\n        while(temp > 0){\n            rev = rev * 10 + (temp % 10);\n            temp /= 10;\n        }\n\n        svint32_t vec_i = svdup_n_s32(pg, i);\n        svint32_t vec_rev = svdup_n_s32(pg, rev);\n\n        svbool_t is_palindrome = svcmpeq(pg, vec_i, vec_rev);\n        svbool_t is_even = svand_b32(is_palindrome, svcmpeq(pg, svand_s32(pg, vec_i, svdup_n_s32(pg, 1)), svdup_n_s32(pg, 0)));\n        svbool_t is_odd = svand_b32(is_palindrome, svnot_b32(pg, is_even));\n\n        count_even = svadda_x_s32(pg, count_even, svreinterpret_s32_m(svsel_m(is_even, svones(), svdup_n_s32(pg, 0))));\n        count_odd = svadda_x_s32(pg, count_odd, svreinterpret_s32_m(svsel_m(is_odd, svones(), svdup_n_s32(pg, 0))));\n    }\n\n    even = svaddv_s32(pg, count_even);\n    odd = svaddv_s32(pg, count_odd);\n\n    return std::vector<int>{even, odd};\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n){\n    int even = 0, odd = 0;\n    svbool_t pg = svptrue_b32();\n    svint32_t count_even = svdup_n_s32(0);\n    svint32_t count_odd = svdup_n_s32(0);\n\n    for(int i = 1; i <= n; ++i){\n        int num = i;\n        int rev = 0;\n        int temp = num;\n\n        while(temp != 0){\n            rev = rev * 10 + (temp % 10);\n            temp /= 10;\n        }\n\n        svint32_t palindrome_check = svcmpeq_s32(svindex_s32(0, 1), svbroadcast_n_s32(rev));\n        svint32_t is_even = svand_s32(palindrome_check, svcmpeq_s32(svreinterpret_s32_u32(svindex_u32(0, 1)), svdup_n_s32(0)));\n        svint32_t is_odd = svand_s32(palindrome_check, svcmpeq_s32(svreinterpret_s32_u32(svindex_u32(0, 1)), svdup_n_s32(1)));\n\n        count_even = svaddsv_s32(pg, count_even, is_even);\n        count_odd = svaddsv_s32(pg, count_odd, is_odd);\n    }\n\n    even = svaddv_s32(pg, count_even);\n    odd = svaddv_s32(pg, count_odd);\n\n    return std::vector<int>{even, odd};\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint count_nums_simd(const std::vector<int>& n) {\n    if (n.empty()) return 0;\n\n    size_t vl = svcntw();\n    int result = 0;\n    const int* data = n.data();\n    size_t len = n.size();\n\n    for (size_t i = 0; i < len; i += vl) {\n        svbool_t pg = svptrue_b32();\n        svint32_t vec = svld1(pg, &data[i]);\n\n        // Compute absolute values except for the sign of the first digit\n        svuint32_t abs_vec = svasr_u32(pg, svabs_s32(pg, vec), svdup_n_s32(0));\n\n        // Extract the first signed digit\n        svint32_t tens = svdup_n_s32(10);\n        svint32_t first_digit = svsra_n_s32(pg, vec, 1);\n        first_digit = svand_x(pg, svabs_s32(pg, first_digit), svcmpeq(pg, vec, svneg_z(pg, svabs_s32(pg, vec))));\n\n        // Sum of digits logic: sum all digits after taking absolute value\n        svuint32_t sum_digits = svaddv_u32(pg, abs_vec);\n        sum_digits = svadd_x(pg, sum_digits, svreinterpret_u32_s32(first_digit));\n\n        // Check if sum of digits > 0\n        svbool_t cond = svcmpgt(pg, svreinterpret_s32_u32(sum_digits), svdup_n_s32(0));\n        result += svcntp_b32(pg, cond);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint count_nums_simd(const std::vector<int>& n) {\n    if (n.empty()) return 0;\n\n    int result = 0;\n    size_t index = 0;\n    svbool_t pg = svptrue_b32();\n\n    while (index <= n.size() - svcntw()) {\n        svint32_t vec = svld1(pg, &n[index]);\n        svuint32_t abs_vec = svabs(vec);\n        svint32_t sign_vec = svsign_m(pg, vec, vec);\n\n        // Compute absolute digits sum\n        svuint32_t ones = svdup_n_u32(1);\n        svuint32_t tens = svdup_n_u32(10);\n        svuint32_t hundreds = svdup_n_u32(100);\n\n        svuint32_t digit1 = svand(abs_vec, ones);\n        svuint32_t digit2 = svasr_u32(svand(svrshl_u32(abs_vec, ones), tens), ones);\n        svuint32_t digit3 = svasr_u32(svand(svrshl_u32(abs_vec, tens), hundreds), tens);\n\n        svuint32_t digits_sum = svadd_u32(digit1, digit2);\n        digits_sum = svadd_u32(digits_sum, digit3);\n\n        // Apply sign to the first digit\n        svint32_t signed_digits_sum = svsub_x(pg, digits_sum, svand(sign_vec, ones));\n\n        // Count elements with sum > 0\n        svbool_t cond = svcmpgt(pg, signed_digits_sum, svdup_n_s32(0));\n        result += svcntp(cond);\n\n        index += svcntw();\n    }\n\n    // Handle remaining elements\n    for (; index < n.size(); ++index) {\n        int num = n[index];\n        int sum = 0;\n        bool is_negative = false;\n        if (num < 0) {\n            is_negative = true;\n            num = -num;\n        }\n        if (num >= 100) {\n            sum += (is_negative ? -(num / 100) : (num / 100));\n            num %= 100;\n        }\n        if (num >= 10) {\n            sum += (num / 10);\n            num %= 10;\n        }\n        sum += num;\n        if (sum > 0) {\n            result++;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    size_t vl = svcntw();\n    int *data = n.data();\n    size_t len = n.size();\n\n    for (size_t i = 0; i < len; i += vl) {\n        svbool_t pg = svptrue_b32();\n        size_t chunk = len - i;\n        if (chunk < vl) {\n            pg = svwhilelt_b32(i, len);\n        }\n\n        svint32_t vec = svld1(pg, &data[i]);\n        svint32_t abs_vec = svabs(vec);\n        svint32_t sign_vec = svdup_n_s32(1);\n\n        // Extract the first digit's sign\n        svint32_t first_digit_sign = svand_x(pg, svsli(pg, svdup_n_s32(-1), svdup_n_s32(31)), vec);\n        svint32_t signed_digits = svsub_x(pg, abs_vec, first_digit_sign);\n\n        // Compute sum of digits\n        svuint32_t digits_mask = svdup_n_u32(0x3F803F80); // Mask to isolate digits\n        svuint32_t shifted_digits = svand_x(pg, svreinterpret_u32_s32(signed_digits), digits_mask);\n        svuint32_t sum_of_digits = svaddv_u32(pg, shifted_digits);\n\n        // Check if sum of digits > 0\n        svbool_t cond = svcmpgt_z(pg, svreinterpret_s32_u32(sum_of_digits), svdup_n_s32(0));\n        count += svpopcnt_b32(pg, cond);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    if (n.empty()) return 0;\n\n    int result = 0;\n    size_t vl = svcntw();\n    int *data = n.data();\n    size_t num_elements = n.size();\n\n    for (size_t i = 0; i < num_elements; i += vl) {\n        svbool_t pg = svptrue_b32();\n        size_t chunk = (i + vl > num_elements) ? num_elements - i : vl;\n        svint32_t vec = svld1(pg, &data[i]);\n\n        svuint32_t digits_mask = svdup_n_u32(0x0F0F0F0F);\n        svint32_t signs_mask = svdup_n_s32(0x00000080);\n\n        svint32_t abs_vec = svasr_n_s32(svabs_s32(vec), 4);\n        svint32_t signed_digits = svand_s32(vec, signs_mask);\n        svuint32_t digits = svand_u32(svtst_n_u32(abs_vec, 0x0F), digits_mask);\n\n        svint32_t sum = svaddv_s32(pg, digits);\n        sum = svsub_s32(sum, signed_digits);\n\n        svbool_t cond = svcmpgt_s32(pg, sum, svdup_n_s32(0));\n        result += svpopcnt_b32(pg, cond);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    if (n.empty()) return 0;\n\n    int result = 0;\n    size_t num_elements = n.size();\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < num_elements; i += vl) {\n        size_t chunk_size = (num_elements - i > vl) ? vl : num_elements - i;\n        svbool_t pred = svwhilelt_b32(i, num_elements);\n        svint32_t vec = svld1_gather_offset_z(pred, n.data(), svindex_n_s32(i, 1));\n\n        svint32_t abs_vec = svabs_s32(vec);\n        svint32_t sign_vec = svasr_s32(vec, svdup_n_s32(31));\n\n        svuint32_t mask = svdup_n_u32(0x0F0F0F0F);\n        svint32_t digits = svasr_s32(abs_vec, svdup_n_u32(4));\n        digits = svand_s32(digits, mask);\n\n        svint32_t signed_digits = svsub_x(pred, digits, svasr_s32(digits, svdup_n_u32(31)));\n        signed_digits = svadd_x(pred, signed_digits, svasr_s32(sign_vec, svdup_n_u32(4)));\n\n        svint32_t sum = svdup_n_s32(0);\n        sum = svadd_x(pred, sum, signed_digits);\n\n        svbool_t cond = svcmpgt_s32(pred, sum, svdup_n_s32(0));\n        result += svpopcnt_b32(cond);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) return true;\n\n    size_t n = arr.size();\n    int *data = arr.data();\n\n    svbool_t pg = svptrue_b32();\n    svint32_t min_val = svdup_n_s32(0x7FFFFFFF);\n\n    // Find the minimum value in the array\n    for (size_t i = 0; i < n; i += svcntw()) {\n        size_t k = n - i > svcntw() ? svcntw() : n - i;\n        svbool_t pgi = svwhilelt_b32(i, i + k);\n        svint32_t vec = svld1(pgi, data + i);\n        min_val = svmin_m(pg, min_val, vec, pgi);\n    }\n\n    int min_value = svminv(pg, min_val);\n\n    // Find the index of the minimum value\n    size_t min_index = 0;\n    for (size_t i = 0; i < n; ++i) {\n        if (data[i] == min_value) {\n            min_index = i;\n            break;\n        }\n    }\n\n    // Perform a virtual rotation and check if sorted\n    size_t count = 0;\n    int prev = data[min_index];\n    size_t i = (min_index + 1) % n;\n\n    while (count < n - 1) {\n        svbool_t pred = svcmpge(pg, svdup_n_s32(data[i]), svdup_n_s32(prev));\n        if (!svptest_all(pg, pred)) return false;\n        prev = data[i];\n        i = (i + 1) % n;\n        count++;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr){\n    if (arr.empty()) return true;\n\n    int N = arr.size();\n    svbool_t pg = svptrue_b32();\n    int count = 0;\n\n    for(int start = 0; start < N; ++start){\n        int drop_count = 0;\n        bool valid = true;\n\n        for(int i = 0; i < N && valid; ++i){\n            int current_idx = (start + i) % N;\n            int next_idx = (start + i + 1) % N;\n\n            svint32_t curr_vec = svdup_n_s32(arr[current_idx]);\n            svint32_t next_vec = svdup_n_s32(arr[next_idx]);\n\n            svbool_t cond = svcmpge(pg, curr_vec, next_vec);\n            uint32x4_t mask = svmovemask_u32(cond);\n\n            if(mask != 0){\n                drop_count++;\n                if(drop_count > 1){\n                    valid = false;\n                }\n            }\n        }\n\n        if(valid){\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) return true;\n\n    int N = arr.size();\n    svbool_t pg = svptrue_b32();\n    int drop_count = 0;\n\n    for (int i = 0; i < N; ++i) {\n        int j = i;\n        svint32_t vec_a, vec_b;\n        int k = 0;\n\n        // Load a vector of elements\n        while (j < N && k < svcntw()) {\n            svst1_w(pg, &vec_a, arr[j]);\n            j++;\n            k++;\n        }\n\n        j = (i + 1) % N;\n        k = 0;\n\n        // Load the next vector of elements\n        while (j < N && k < svcntw()) {\n            svst1_w(pg, &vec_b, arr[j]);\n            j = (j + 1) % N;\n            k++;\n        }\n\n        // Compare vectors\n        svbool_t cmp_result = svclt_s32(pg, vec_a, vec_b);\n        svuint32_t mask = svreinterpret_u32(cmp_result);\n        drop_count += svcntp_m(mask, pg);\n\n        if (drop_count > 1) {\n            return false;\n        }\n    }\n\n    return drop_count <= 1;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr){\n    if (arr.empty()) return true;\n\n    size_t n = arr.size();\n    int *data = arr.data();\n\n    svbool_t pg = svptrue_b32();\n    svint32_t min_val = svdup_n_s32(arr[0]);\n    svint32_t max_val = svdup_n_s32(arr[0]);\n\n    // Find global min and max\n    for (size_t i = 0; i < n; i += svcntw()) {\n        svint32_t vec = svld1(pg, &data[i]);\n        min_val = svmin_z(pg, min_val, vec);\n        max_val = svmax_z(pg, max_val, vec);\n    }\n\n    int global_min = svminv(pg, min_val);\n    int global_max = svmaxv(pg, max_val);\n\n    // Check if the array can be rotated to sorted order\n    int count_breaks = 0;\n    int prev = global_max + 1; // Initialize with a value greater than any element\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        svint32_t vec = svld1(pg, &data[i]);\n        svint32_t prev_vec = svdup_n_s32(prev);\n\n        // Compare current vector with previous value\n        svbool_t breaks_order = svcmpgt(pg, prev_vec, vec);\n        count_breaks += svcntp(breaks_order);\n\n        // Update previous value for next iteration\n        int last_in_vec = svlastactive_index(i, svcntw(), n);\n        if (last_in_vec != -1) {\n            prev = data[last_in_vec];\n        }\n    }\n\n    return count_breaks <= 1;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) return true;\n\n    size_t n = arr.size();\n    int *data = arr.data();\n\n    svbool_t pg = svptrue_b32(); // Predicate for all true\n    size_t vl = svcntw(); // Vector length in terms of 32-bit elements\n\n    int breaks = 0;\n    for (size_t start = 0; start < n; ++start) {\n        breaks = 0;\n        for (size_t i = 0; i < n; ++i) {\n            size_t j = (start + i) % n;\n            size_t k = (start + i + 1) % n;\n\n            svint32_t ve_j = svdup_n_s32(data[j]);\n            svint32_t ve_k = svdup_n_s32(data[k]);\n\n            svbool_t cond = svclt_s32(pg, ve_j, ve_k); // Check if data[j] < data[k]\n            int res = svcntp_b32(cond); // Count predicate results\n\n            if (res != vl) {\n                breaks++;\n                if (breaks > 1) break;\n            }\n        }\n        if (breaks <= 1) return true;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2){\n    int vl = svcntw(); // Get the vector length in terms of number of int elements\n\n    // Count odd numbers in lst1\n    int count_odd_lst1 = 0;\n    for (size_t i = 0; i < lst1.size(); i += vl) {\n        svbool_t pg = svptrue_b32();\n        svint32_t vec = svld1(pg, &lst1[i]);\n        svbool_t is_odd = svandb(pg, svcmpne_z(pg, svand_x(pg, vec, svdup_n_s32(1)), svdup_n_s32(0)));\n        count_odd_lst1 += svcntp_b32(is_odd);\n    }\n\n    // Count even numbers in lst2\n    int count_even_lst2 = 0;\n    for (size_t i = 0; i < lst2.size(); i += vl) {\n        svbool_t pg = svptrue_b32();\n        svint32_t vec = svld1(pg, &lst2[i]);\n        svbool_t is_even = svcmpeq_z(pg, svand_x(pg, vec, svdup_n_s32(1)), svdup_n_s32(0));\n        count_even_lst2 += svcntp_b32(is_even);\n    }\n\n    if (count_even_lst2 >= count_odd_lst1) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2){\n    intvl_t pred_all = svptrue_b32();\n    int count_odd_lst1 = 0;\n    int count_even_lst2 = 0;\n\n    // Count odd numbers in lst1\n    size_t index = 0;\n    while (svwhilelt_b32(index, lst1.size())) {\n        svint32_t vec = svld1(svptrue_b32(), &lst1[index]);\n        svbool_t pred_odd = svcmpne_z(pred_all, vec & 1, 0);\n        count_odd_lst1 += svcntp(pred_odd, pred_all);\n        index += svcnt();\n    }\n\n    // Count even numbers in lst2\n    index = 0;\n    while (svwhilelt_b32(index, lst2.size())) {\n        svint32_t vec = svld1(svptrue_b32(), &lst2[index]);\n        svbool_t pred_even = svcmpeq_z(pred_all, vec & 1, 0);\n        count_even_lst2 += svcntp(pred_even, pred_all);\n        index += svcnt();\n    }\n\n    return (count_even_lst2 >= count_odd_lst1) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2){\n    if (lst1.empty() || lst2.empty()) {\n        return \"NO\";\n    }\n\n    int vl = svcntw();\n\n    // Check all elements in lst1\n    size_t i = 0;\n    svbool_t pg = svptrue_b32();\n    svuint32_t even_count_lst2 = svdup_n_u32(0);\n\n    for (; i <= lst1.size() - vl; i += vl) {\n        svint32_t vec1 = svld1(pg, &lst1[i]);\n        svbool_t is_odd_lst1 = svcmpne_m(pg, svand_x(pg, vec1, svdup_n_s32(1)), svdup_n_s32(0));\n        if (svptest_any(svptrue_b32(), is_odd_lst1)) {\n            break;\n        }\n    }\n\n    if (i > lst1.size() - vl) {\n        // All elements in lst1 are already even\n        return \"YES\";\n    }\n\n    // Count odd numbers in lst2\n    i = 0;\n    for (; i <= lst2.size() - vl; i += vl) {\n        svint32_t vec2 = svld1(pg, &lst2[i]);\n        svbool_t is_even_lst2 = sveq_z(pg, svand_x(pg, vec2, svdup_n_s32(1)), svdup_n_s32(0));\n        even_count_lst2 = svadd_x(pg, even_count_lst2, svcntb(is_even_lst2));\n    }\n\n    // Handle remaining elements in lst2\n    svbool_t pg_remainder = svwhilelt_b32(i, static_cast<int>(lst2.size()));\n    if (svptest_any(pg, pg_remainder)) {\n        svint32_t vec2 = svld1(pg_remainder, &lst2[i]);\n        svbool_t is_even_lst2 = sveq_z(pg_remainder, svand_x(pg_remainder, vec2, svdup_n_s32(1)), svdup_n_s32(0));\n        even_count_lst2 = svadd_x(pg, even_count_lst2, svcntp_b32(pg, is_even_lst2));\n    }\n\n    int total_even_lst2 = svaddv(pg, even_count_lst2);\n\n    // Count odd numbers in lst1\n    i = 0;\n    svuint32_t odd_count_lst1 = svdup_n_u32(0);\n    for (; i <= lst1.size() - vl; i += vl) {\n        svint32_t vec1 = svld1(pg, &lst1[i]);\n        svbool_t is_odd_lst1 = svcmpne_m(pg, svand_x(pg, vec1, svdup_n_s32(1)), svdup_n_s32(0));\n        odd_count_lst1 = svadd_x(pg, odd_count_lst1, svcntp_b32(pg, is_odd_lst1));\n    }\n\n    // Handle remaining elements in lst1\n    svbool_t pg_remainder_lst1 = svwhilelt_b32(i, static_cast<int>(lst1.size()));\n    if (svptest_any(pg, pg_remainder_lst1)) {\n        svint32_t vec1 = svld1(pg_remainder_lst1, &lst1[i]);\n        svbool_t is_odd_lst1 = svcmpne_m(pg_remainder_lst1, svand_x(pg_remainder_lst1, vec1, svdup_n_s32(1)), svdup_n_s32(0));\n        odd_count_lst1 = svadd_x(pg, odd_count_lst1, svcntp_b32(pg, is_odd_lst1));\n    }\n\n    int total_odd_lst1 = svaddv(pg, odd_count_lst1);\n\n    return (total_even_lst2 >= total_odd_lst1) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2){\n    int vl = svcntw(); // Get the vector length in terms of the number of int elements\n    svbool_t pg = svptrue_b32(); // Predicate for all true\n\n    size_t len1 = lst1.size();\n    size_t len2 = lst2.size();\n\n    // Count odd numbers in lst1\n    int count_odd_lst1 = 0;\n    for (size_t i = 0; i < len1; i += vl) {\n        svint32_t vec = svld1(pg, &lst1[i]);\n        svbool_t is_odd = svand_pg(pg, svcmp_ne_z(pg, svand_z(pg, vec, svdup_n_s32(1)), svdup_n_s32(0)));\n        count_odd_lst1 += svcntp(is_odd);\n    }\n\n    // Count even numbers in lst2\n    int count_even_lst2 = 0;\n    for (size_t i = 0; i < len2; i += vl) {\n        svint32_t vec = svld1(pg, &lst2[i]);\n        svbool_t is_even = svcmpeq_z(pg, svand_z(pg, vec, svdup_n_s32(1)), svdup_n_s32(0));\n        count_even_lst2 += svcntp(is_even);\n    }\n\n    if (count_even_lst2 >= count_odd_lst1) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2){\n    int vl = svcntw(); // Get the vector length in terms of the number of int elements\n\n    // Initialize predicates for even counts\n    svbool_t pg_all = svptrue_b32(); // A predicate where all elements are true\n\n    // Count odd numbers in lst1\n    size_t count_odd_lst1 = 0;\n    for(size_t i = 0; i < lst1.size(); i += vl){\n        svint32_t vec = svld1(pg_all, &lst1[i]);\n        svbool_t is_odd = svand_b32(pg_all, svcmpne_z(pg_all, sveor_z(pg_all, vec, vec), svdup_n_s32(0)));\n        count_odd_lst1 += svcntp_b32(pg_all, is_odd);\n    }\n\n    // Count even numbers in lst2\n    size_t count_even_lst2 = 0;\n    for(size_t i = 0; i < lst2.size(); i += vl){\n        svint32_t vec = svld1(pg_all, &lst2[i]);\n        svbool_t is_even = svtst_z(pg_all, vec, svdup_n_s32(1));\n        count_even_lst2 += svcntp_b32(pg_all, is_even);\n    }\n\n    return (count_even_lst2 >= count_odd_lst1) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        int count = 0;\n        size_t num_elements = str.size();\n        size_t pg_size = svcntb(); // Get the number of bytes in a predicate register\n        size_t i = 0;\n\n        while (i + pg_size <= num_elements) {\n            svbool_t pg = svptrue_b8(); // Generate a predicate with all active elements\n            uint8x16_t vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&str[i])); // Load vector of characters\n            uint8x16_t ones = svdup_n_u8('1'); // Create a vector of '1' characters\n            svbool_t is_one = svcmpeq_u8_m(pg, vec, ones); // Compare if each character is '1'\n            \n            // Check for other odd digits '3', '5', '7', '9'\n            uint8x16_t threes = svdup_n_u8('3');\n            svbool_t is_three = svcmpeq_u8_m(pg, vec, threes);\n            uint8x16_t fives = svdup_n_u8('5');\n            svbool_t is_five = svcmpeq_u8_m(pg, vec, fives);\n            uint8x16_t sevens = svdup_n_u8('7');\n            svbool_t is_seven = svcmpeq_u8_m(pg, vec, sevens);\n            uint8x16_t nines = svdup_n_u8('9');\n            svbool_t is_nine = svcmpeq_u8_m(pg, vec, nines);\n\n            // Combine predicates for all odd digits\n            svbool_t is_odd = svbor_b8(is_one, is_three);\n            is_odd = svbor_b8(is_odd, is_five);\n            is_odd = svbor_b8(is_odd, is_seven);\n            is_odd = svbor_b8(is_odd, is_nine);\n\n            // Count the number of active elements in the predicate\n            count += svpopcnt_b8(is_odd);\n            i += pg_size;\n        }\n\n        // Handle remaining elements\n        if (i < num_elements) {\n            svbool_t pg = svptrue_b8(num_elements - i); // Generate a predicate for remaining elements\n            uint8x16_t vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(&str[i]));\n            uint8x16_t ones = svdup_n_u8('1');\n            svbool_t is_one = svcmpeq_u8_m(pg, vec, ones);\n            uint8x16_t threes = svdup_n_u8('3');\n            svbool_t is_three = svcmpeq_u8_m(pg, vec, threes);\n            uint8x16_t fives = svdup_n_u8('5');\n            svbool_t is_five = svcmpeq_u8_m(pg, vec, fives);\n            uint8x16_t sevens = svdup_n_u8('7');\n            svbool_t is_seven = svcmpeq_u8_m(pg, vec, sevens);\n            uint8x16_t nines = svdup_n_u8('9');\n            svbool_t is_nine = svcmpeq_u8_m(pg, vec, nines);\n\n            svbool_t is_odd = svbor_b8(is_one, is_three);\n            is_odd = svbor_b8(is_odd, is_five);\n            is_odd = svbor_b8(is_odd, is_seven);\n            is_odd = svbor_b8(is_odd, is_nine);\n\n            count += svpopcnt_b8(is_odd);\n        }\n\n        // Construct the result string\n        std::string res = \"the number of odd elements \";\n        res += std::to_string(count);\n        res += \"n the str\";\n        res += std::to_string(count);\n        res += \"ng \";\n        res += std::to_string(count);\n        res += \" of the \";\n        res += std::to_string(count);\n        res += \"nput.\";\n        result.push_back(res);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        int count = 0;\n        size_t num_elements = str.size();\n        svbool_t pg = svptrue_b8();\n        const uint8_t* data = reinterpret_cast<const uint8_t*>(str.data());\n        \n        // Process full vectors\n        size_t i = 0;\n        for (; i + svcntb() <= num_elements; i += svcntb()) {\n            svuint8_t vec = svld1(pg, data + i);\n            svuint8_t ones = svdup_n_u8('1');\n            svbool_t is_odd = svcmpeq(pg, vec & ones, ones);\n            count += svpopcnt(is_odd);\n        }\n        \n        // Process leftovers\n        if (i < num_elements) {\n            pg = svwhilelt_b8(i, num_elements);\n            svuint8_t vec = svld1(pg, data + i);\n            svuint8_t ones = svdup_n_u8('1');\n            svbool_t is_odd = svcmpeq(pg, vec & ones, ones);\n            count += svpopcnt(is_odd);\n        }\n\n        // Construct the result string\n        std::string res = \"the number of odd elements \";\n        res += std::to_string(count);\n        res += \"n the str\";\n        res += std::to_string(count);\n        res += \"ng \";\n        res += std::to_string(count);\n        res += \" of the \";\n        res += std::to_string(count);\n        res += \"nput.\";\n        result.push_back(res);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        int count = 0;\n        size_t str_len = str.length();\n        if (str_len == 0) {\n            result.push_back(\"the number of odd elements 0n the str0ng 0 of the 0nput.\");\n            continue;\n        }\n\n        svbool_t pg = svptrue_b8();\n        size_t vl = svcntb();\n        size_t i = 0;\n\n        // Process in vectorized chunks\n        for (; i <= str_len - vl; i += vl) {\n            svuint8_t vec = svld1(pg, reinterpret_cast<const uint8_t*>(&str[i]));\n            svuint8_t ones = svdup_n_u8('1');\n            svbool_t is_odd = svand_pg(pg, svcmpeq(pg, svand_v_u8(vec, ones), ones));\n            count += svcntp(is_odd);\n        }\n\n        // Tail processing\n        if (i < str_len) {\n            pg = svwhilelt_b8(i++, str_len);\n            svuint8_t vec = svld1(pg, reinterpret_cast<const uint8_t*>(&str[i]));\n            svuint8_t ones = svdup_n_u8('1');\n            svbool_t is_odd = svand_pg(pg, svcmpeq(pg, svand_v_u8(vec, ones), ones));\n            count += svcntp(is_odd);\n        }\n\n        // Construct result string\n        std::string res = \"the number of odd elements \";\n        res += std::to_string(count);\n        res += \"n the str\";\n        res += std::to_string(count);\n        res += \"ng \";\n        res += std::to_string(count);\n        res += \" of the \";\n        res += std::to_string(count);\n        res += \"nput.\";\n        result.push_back(res);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        int count = 0;\n        size_t vl = sve_vl();\n        svbool_t pg = svptrue_b8();\n        const uint8_t* data = reinterpret_cast<const uint8_t*>(str.data());\n        size_t len = str.length();\n\n        for (size_t i = 0; i < len; i += vl) {\n            svuint8_t vec = svld1(pg, data + i);\n            svuint8_t ones = svdup_n_u8('1');\n            svbool_t is_odd = svcmp_ne_u8(pg, vec & ones, svdup_n_u8('0'));\n            count += svcntp_b8(pg, is_odd);\n        }\n\n        std::string output = \"the number of odd elements \";\n        output += std::to_string(count);\n        output += \"n the str\";\n        output += std::to_string(count);\n        output += \"ng \";\n        output += std::to_string(count);\n        output += \" of the \";\n        output += std::to_string(count);\n        output += \"nput.\";\n        result.push_back(output);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        size_t count = 0;\n        size_t len = str.size();\n        if (len == 0) {\n            result.push_back(\"the number of odd elements 0n the str0ng 0 of the 0nput.\");\n            continue;\n        }\n\n        svbool_t pg = svptrue_b8();\n        const uint8_t odd_digits[10] = { '1', '3', '5', '7', '9' };\n        svuint8_t sv_odds = svld1_u8(pg, odd_digits);\n\n        for (size_t i = 0; i < len; i += svcntb()) {\n            size_t chunk = len - i;\n            svbool_t pgb = svwhilelt_b8(i, len);\n            svuint8_t sv_chars = svld1_u8(pgb, str.data() + i);\n\n            // Check if each character is an odd digit\n            svuint8_t diff = svsub_u8(pgb, sv_chars, sv_odds);\n            svbool_t is_zero = svcmpeq_z(pg, diff, svdup_n_u8(0));\n            count += svcntp(is_zero);\n        }\n\n        // Construct the result string with replacements\n        std::string res = \"the number of odd elements \";\n        res += std::to_string(count);\n        res += \"n the str\";\n        res += std::to_string(count);\n        res += \"ng \";\n        res += std::to_string(count);\n        res += \" of the \";\n        res += std::to_string(count);\n        res += \"nput.\";\n        result.push_back(res);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <climits>\n#include <vector>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums){\n    if (nums.empty()) return 0;\n\n    const int64_t* data = nums.data();\n    size_t n = nums.size();\n\n    svbool_t pg = svptrue_b64();\n    svint64_t current_min = svdup_s64(INT64_MAX);\n    svint64_t global_min = svdup_s64(INT64_MAX);\n    svint64_t zero = svdup_s64(0);\n\n    for (size_t i = 0; i < n; i += svcntd()) {\n        svint64_t vec = svld1_s64(pg, &data[i]);\n        current_min = svmin_s64(pg, current_min, vec);\n        current_min = svadd_s64(pg, current_min, svmin_s64(pg, vec, zero));\n        global_min = svmin_s64(pg, global_min, current_min);\n    }\n\n    int64_t result = INT64_MAX;\n    for (size_t i = 0; i < svcntd(); ++i) {\n        result = std::min(result, svget Lane(global_min, i));\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <climits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums){\n    if (nums.empty()) return 0;\n\n    const int64_t* data = nums.data();\n    size_t n = nums.size();\n\n    svbool_t pg = svptrue_b64();\n    svint64_t current_min = svdupq_n_s64(INT64_MAX);\n    svint64_t global_min = svdupq_n_s64(INT64_MAX);\n    svint64_t zero = svdupq_n_s64(0);\n\n    for (size_t i = 0; i < n; i += svcntd()) {\n        svbool_t pg_idx = svwhilelt_b64(i, n);\n        svint64_t vec = svld1_gather_index(pg_idx, data, svindex_z(pg_idx, i));\n\n        current_min = svmin_z(pg_idx, current_min, vec);\n        current_min = svadd_z(pg_idx, current_min, vec);\n        global_min = svmin_z(pg_idx, global_min, current_min);\n\n        // Reset current_min if it becomes greater than the current element\n        svbool_t reset_mask = svcmpgt(vec, current_min, pg_idx);\n        current_min = svsel(reset_mask, vec, current_min);\n    }\n\n    int64_t result = INT64_MAX;\n    for (size_t i = 0; i < svcntd(); ++i) {\n        int64_t val = svgetLane(global_min, i);\n        if (val < result) result = val;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <climits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums){\n    if (nums.empty()) return INT64_MAX;\n\n    const int64_t* data = nums.data();\n    size_t n = nums.size();\n\n    svbool_t pg = svptrue_b64();\n    svint64_t current_min = svdupq_n_s64(data[0]);\n    svint64_t global_min = svdupq_n_s64(data[0]);\n\n    for (size_t i = 1; i < n; ++i) {\n        svint64_t vec = svld1(pg, &data[i]);\n        current_min = svminq_x(pg, svadd_x(pg, current_min, vec), vec);\n        global_min = svminq_x(pg, global_min, current_min);\n    }\n\n    int64_t result = INT64_MAX;\n    svint64_t res_vec = svminv(pg, global_min);\n    for (size_t i = 0; i < svcntd(); ++i) {\n        result = result < svget(res_vec, i) ? result : svget(res_vec, i);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <climits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums){\n    if (nums.empty()) return 0;\n\n    svbool_t pg = svptrue_b64();\n    int64_t current_min = nums[0];\n    int64_t overall_min = nums[0];\n\n    size_t index = 0;\n    size_t vl = svcntd();\n\n    // Initialize vectors\n    svint64_t v_current_min = svdup_n_s64(current_min);\n    svint64_t v_overall_min = svdup_n_s64(overall_min);\n\n    for (; index + vl <= nums.size(); index += vl) {\n        svint64_t v_nums = svld1(pg, &nums[index]);\n\n        // Compute the minimum subarray sum ending at each position\n        v_current_min = svmin(pg, v_nums, svadd(pg, v_current_min, v_nums));\n\n        // Update the overall minimum\n        v_overall_min = svmin(pg, v_overall_min, v_current_min);\n    }\n\n    // Reduce to find the scalar overall_min\n    for (size_t i = 0; i < vl; ++i) {\n        overall_min = (overall_min < svindexas_s64(v_overall_min, i)) ? overall_min : svindexas_s64(v_overall_min, i);\n    }\n\n    // Handle remaining elements\n    for (; index < nums.size(); ++index) {\n        current_min = std::min(nums[index], current_min + nums[index]);\n        overall_min = std::min(overall_min, current_min);\n    }\n\n    return overall_min;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <climits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums){\n    if (nums.empty()) return 0;\n\n    const int64_t* data = nums.data();\n    size_t n = nums.size();\n\n    svbool_t pg = svptrue_b64();\n    svbool_t pred = svwhilelt_b64(0, n);\n\n    svint64_t vmin = svdupq_n_s64(INT64_MAX);\n    svint64_t current_min = svdupq_n_s64(data[0]);\n\n    int64_t result = data[0];\n    size_t index = 1;\n\n    do {\n        svint64_t vec = svld1_gather_index_z(pg, pred, 0, (const int64_t*)data + index - 1, svindexz_s64());\n        svint64_t temp = svmin_z(pg, svadd_z(pg, current_min, vec), vec);\n        current_min = svsel(pred, temp, current_min);\n        vmin = svmin_z(pg, vmin, current_min);\n\n        int64_t min_val;\n        svminv_scalar_s64(min_val, vmin);\n        result = result < min_val ? result : min_val;\n\n        index += svcntd();\n        pred = svwhilelt_b64(index, n);\n    } while (svptest_any(svptrue_b64(), pred));\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int>> &grid, int capacity) {\n    if (grid.empty() || grid[0].empty()) return 0;\n\n    size_t num_wells = grid.size();\n    size_t well_length = grid[0].size();\n    int total_drops = 0;\n\n    svbool_t pg = svptrue_b32(); // Predicate for full participation\n    svuint32_t sum_vec = svdup_n_u32(0); // Vector to accumulate sums\n\n    size_t vl = svcntw(); // Vector length in terms of 32-bit elements\n\n    for (size_t i = 0; i < well_length; ++i) {\n        svuint32_t vec = svdup_n_u32(0);\n        for (size_t j = 0; j < num_wells; ++j) {\n            uint32_t val = grid[j][i];\n            svuint32_t tmp = svinslane_u32(vec, val, j % vl);\n            vec = tmp;\n        }\n        sum_vec = svadd_u32(pg, sum_vec, vec);\n    }\n\n    uint32_t total_sum = 0;\n    svuint32_t res = svaddv_u32(pg, sum_vec);\n    for (size_t i = 0; i < vl; ++i) {\n        total_sum += svindex_n_u32(res, i);\n    }\n\n    total_drops = (total_sum + capacity - 1) / capacity;\n\n    return total_drops;\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    if (grid.empty() || grid[0].empty()) return 0;\n\n    size_t num_wells = grid.size();\n    size_t well_length = grid[0].size();\n    int total_drops = 0;\n\n    svbool_t pg = svptrue_b32(); // Predicate for full vector operations\n\n    for (size_t i = 0; i < num_wells; ++i) {\n        int water_units = 0;\n        size_t j = 0;\n\n        // Process elements in vectors\n        for (; j + svcntw() <= well_length; j += svcntw()) {\n            svint32_t vec = svld1(pg, &grid[i][j]);\n            water_units += svaddv(pg, vec);\n        }\n\n        // Handle leftovers\n        if (j < well_length) {\n            svbool_t pgl = svwhilelt_b32(j, well_length);\n            svint32_t vec = svld1(pgl, &grid[i][j]);\n            water_units += svaddv(pgl, vec);\n        }\n\n        // Calculate drops for this well\n        total_drops += (water_units + capacity - 1) / capacity;\n    }\n\n    return total_drops;\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity){\n    if (grid.empty() || grid[0].empty()) return 0;\n\n    size_t num_wells = grid.size();\n    size_t well_length = grid[0].size();\n    int total_drops = 0;\n\n    svbool_t pg = svptrue_b32();\n    svint32_t sum_vec = svdup_n_s32(0);\n\n    for(size_t j = 0; j < well_length; ++j){\n        svint32_t vec = svdup_n_s32(0);\n        size_t i = 0;\n        for(; i <= num_wells - svcntw(); i += svcntw()){\n            svint32_t data = svld1_s32(pg, reinterpret_cast<const int*>(&grid[i][j]));\n            vec = svadd_s32(pg, vec, data);\n        }\n        sum_vec = svadd_s32(pg, sum_vec, vec);\n\n        // Process leftovers\n        if(i < num_wells){\n            svbool_t pg_part = svwhilelt_b32(i, num_wells);\n            svint32_t data_part = svld1_s32(pg_part, reinterpret_cast<const int*>(&grid[i][j]));\n            sum_vec = svadd_s32(pg, sum_vec, data_part);\n        }\n    }\n\n    // Horizontal sum\n    int sum = 0;\n    svint32_t res = svaddv_s32(pg, sum_vec);\n    for (size_t i = 0; i < svcntw(); ++i) {\n        sum += svget_lane_s32(res, i);\n    }\n\n    total_drops = (sum + capacity - 1) / capacity;\n    return total_drops;\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity){\n    if (grid.empty() || grid[0].empty()) return 0;\n\n    size_t num_wells = grid.size();\n    size_t well_length = grid[0].size();\n    int total_drops = 0;\n\n    svbool_t pg = svptrue_b32(); // Predicate for all true\n    size_t vl = svcntw(); // Vector length in terms of number of lanes\n\n    for (size_t i = 0; i < num_wells; ++i) {\n        int water_units = 0;\n        for (size_t j = 0; j < well_length; j += vl) {\n            svint32_t vec = svdup_s32(0);\n            size_t k;\n            for (k = j; k < j + vl && k < well_length; ++k) {\n                vec = svaddv_s32(pg, vec, svdup_n_s32(grid[i][k]));\n            }\n            water_units += svaddv_s32(pg, vec);\n            if (k < j + vl) break; // Handle cases where the loop doesn't fill a full vector\n        }\n        total_drops += (water_units + capacity - 1) / capacity;\n    }\n\n    return total_drops;\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity){\n    if (grid.empty()) return 0;\n\n    size_t num_wells = grid.size();\n    size_t well_length = grid[0].size();\n    int total_drops = 0;\n\n    // Determine the SVE vector length in bits and elements\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < num_wells; ++i) {\n        int water_units = 0;\n        for (size_t j = 0; j < well_length; j += vl) {\n            // Load a vector of integers from the current well row\n            svint32_t vec = svld1(pg, &grid[i][j]);\n\n            // Count the number of '1's in the vector\n            svuint32_t cmp = svcmpeq(pg, vec, svdup_n_s32(1));\n            water_units += svpopcnt_b32(cmp);\n        }\n\n        // Calculate drops for the current well and add to total\n        total_drops += (water_units + capacity - 1) / capacity;\n    }\n\n    return total_drops;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst){\n    int64_t sum = 0;\n    size_t vec_len = lst.size();\n    svbool_t pg = svptrue_b16();\n    const int16_t* data = lst.data();\n\n    for (size_t i = 0; i < vec_len; i += svcntw() * 2) {\n        // Load vector starting at even positions\n        svint16_t vl = svld1(pg, &data[i]);\n        \n        // Create a mask for even indices within the vector\n        size_t num_active = svcntw();\n        svbool_t even_mask = svcmpeq(pg, svindex_s64(0, 1), svbroadcast_lane_s64(pg, 0, i / 2));\n\n        // Select elements at even positions\n        svint16_t even_elements = svand_x(pg, vl, svreinterpret_s16(svshl_n_u64(svptrue_b64(), svindex_u64(0, 2), 1)));\n\n        // Check if the elements are odd\n        svbool_t is_odd = svtestbits_m(pg, even_elements, 0x1);\n\n        // Multiply by the mask to get only odd elements at even positions\n        svint16_t odd_even_elements = svsel(is_odd, even_elements, svdup_z(pg, 0));\n\n        // Sum the selected elements\n        svint64_t partial_sums = svhadd_x(pg, sv reinterpret_s64(odd_even_elements));\n        int64_t tmp_sum = svaddv(pg, partial_sums);\n        sum += tmp_sum;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst){\n    int64_t sum = 0;\n    size_t index = 0;\n    size_t vl = svcntw(); // Vector length in terms of 16-bit elements\n    size_t num_elements = lst.size();\n    \n    for (size_t i = 0; i < num_elements; i += vl * 2) {\n        svbool_t pg = svptrue_b16();\n        svint16_t vec = svld1(pg, &lst[i]);\n        \n        // Mask to select even positions within the vector\n        svbool_t even_mask = svcmpeq_n_b16(svand_n_u16(svindex_z(pg, 0), 1), 0);\n        \n        // Select elements at even positions\n        svint16_t even_pos = svsel(even_mask, vec, svdup_n_s16(0));\n        \n        // Check if the elements are odd\n        svbool_t is_odd = svtestbit_n_b16(svand_x(pg, even_pos, svdup_n_s16(1)), 0);\n        \n        // Accumulate odd elements at even positions\n        svint16_t filtered = svsel(is_odd, even_pos, svdup_n_s16(0));\n        sum += svaddv(pg, filtered);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst){\n    int64_t sum = 0;\n    if (lst.empty()) return sum;\n\n    size_t vl = svcntw();\n    size_t n = lst.size();\n    const int16_t* data = lst.data();\n\n    svbool_t pg = svptrue_b16();\n    svint16_t zero = svdup_s16(0);\n\n    for (size_t i = 0; i < n; i += vl) {\n        size_t count = (n - i > vl) ? vl : n - i;\n        svbool_t pcount = svwhilelt_b16(i, i + count);\n\n        // Load vector\n        svint16_t vec = svld1(pcount, &data[i]);\n\n        // Check even positions\n        svbool_t peven = svand_b16(pcount, svtstb1(pcount, 0x55555555));\n\n        // Check odd values\n        svbool_t podd = svcmpeq_b16(peven, svmul_x_n_s16(svadd_x_n_s16(vec, 1), 2), vec);\n\n        // Masked select odd values at even positions\n        svint16_t filtered = svsel(podd, vec, zero);\n\n        // Sum the selected values\n        svint16_t acc = svaddv_s16(pg, filtered);\n        sum += svaddv_s64(pg, svreinterpret_s64_s16(acc));\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst){\n    int64_t sum = 0;\n    size_t vec_len = lst.size();\n    if (vec_len == 0) return sum;\n\n    svbool_t pg = svptrue_b16();\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < vec_len; i += vl * 2) {\n        size_t j = i / 2;\n        size_t k = (i + vl * 2 - 1) / 2;\n        if (k >= vec_len) k = vec_len - 1;\n\n        svint16_t svec = svdup_z(pg, 0);\n        for (size_t m = j; m <= k; ++m) {\n            if ((m % 2) == 0) {\n                svint16_t v = svinslane_s16(svec, lst[m], m - j);\n                svec = v;\n            }\n        }\n\n        svuint16_t mask = svand_x(pg, svec, svreinterpret_u16(svec));\n        mask = svand_x(pg, mask, svcmpeq_x(pg, svaddv_s16(pg, svec), svaddv_s16(pg, svec)));\n\n        svint16_t odd_elements = svand_x(pg, svec, mask);\n\n        int16x8_t res = svaddv_s16(pg, odd_elements);\n        sum += svaddv_s16(pg, res);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nint64_t solution_simd(const std::vector<int16_t>& lst){\n    int64_t sum = 0;\n    size_t count = lst.size();\n    if (count == 0) return sum;\n\n    const int16_t* data = lst.data();\n    svbool_t pg = svptrue_b16();\n    svint16_t zero = svdup_n_s16(0);\n\n    for (size_t i = 0; i < count; i += svcntw() * 2) {\n        size_t j = i;\n        svbool_t pg_even = svand_b16(pgptrue_b16(), svcmpeq_n_u32(svindex_u32(j, j + svcntw() - 1), 0));\n        svint16_t vec = svld1(pg, data + j);\n        svbool_t is_odd = svand_b16(pg_even, svmul_x_h_u16(pg, svabs(vec), svdup_n_u16(1)));\n        svint16_t filtered = svsel(is_odd, vec, zero);\n        sum += svaddv_s64(pg, svreinterpret_s64_s16(svmovl_s16(filtered)));\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k){\n    int result = 0;\n    size_t vl = svcntw(); // Get the vector length in terms of number of 32-bit elements\n    size_t num_full_vectors = k / vl;\n    size_t remainder = k % vl;\n\n    for (size_t i = 0; i < num_full_vectors; ++i) {\n        svbool_t pg = svptrue_b32();\n        svint32_t vec = svld1(pg, &arr[i * vl]);\n        \n        // Create a mask where |x| <= 99\n        svbool_t cond = svand_b32(svcmeq_m(pg, svabs(vec), 0), svclt_m(pg, svabs(vec), 100));\n        \n        // Set elements not satisfying condition to 0\n        svint32_t filtered = svsel(vec, cond, svdup_z(pg, 0));\n        \n        // Horizontal sum\n        int partial_sum = 0;\n        for (size_t j = 0; j < vl; ++j) {\n            partial_sum += filtered[j];\n        }\n        result += partial_sum;\n    }\n\n    if (remainder > 0) {\n        svbool_t pg = svptrue_b32();\n        svint32_t vec = svld1(pg, &arr[num_full_vectors * vl]);\n        \n        // Mask for loading only 'remainder' elements\n        svbool_t remainder_mask = svcntb() < remainder;\n        vec = svdup_z(pg, 0);\n        vec = svsel(vec, remainder_mask, svld1_gather_offset_z(pg, &arr[num_full_vectors * vl], svindex_n_s32(0, 1)));\n\n        // Create a mask where |x| <= 99\n        svbool_t cond = svand_b32(svcmeq_m(pg, svabs(vec), 0), svclt_m(pg, svabs(vec), 100));\n        \n        // Set elements not satisfying condition to 0\n        svint32_t filtered = svsel(vec, cond, svdup_z(pg, 0));\n        \n        // Horizontal sum\n        int partial_sum = 0;\n        for (size_t j = 0; j < remainder; ++j) {\n            partial_sum += filtered[j];\n        }\n        result += partial_sum;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k){\n    int result = 0;\n    size_t vl = svcntw(); // Get the vector length in terms of number of elements\n    size_t num_elems = arr.size();\n    int *data = arr.data();\n\n    for (size_t i = 0; i < k; i += vl) {\n        svbool_t pg = svptrue_b32(); // Predicate for all true\n        svint32_t vec = svld1(pg, &data[i]); // Load vector\n\n        // Create mask for numbers with at most two digits (-99 to 99)\n        svbool_t mask = svcmpge(pg, vec, svdup_n_s32(-99)) && svcmple(pg, vec, svdup_n_s32(99));\n\n        // Apply mask and sum the valid elements\n        svint32_t masked_vec = svand_x(mask, vec, vec);\n        int partial_sum = svaddv(mask, masked_vec);\n\n        result += partial_sum;\n\n        // If we have processed enough elements, break\n        if (i + vl >= k) {\n            break;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k){\n    int result = 0;\n    size_t vl = svcntw(); // Get the vector length in terms of the number of int elements\n    size_t n = arr.size();\n    k = (k < n) ? k : n;\n\n    for (size_t i = 0; i < k; i += vl) {\n        svbool_t pg = svptrue_b32(); // Predicate for all active lanes\n        size_t chunk = (k - i > vl) ? vl : k - i;\n        pg = svwhilelt_b32(pg, chunk); // Update predicate to handle partial vectors if necessary\n\n        // Load data\n        const int *arr_ptr = &arr[i];\n        svint32_t vec = svld1(pg, arr_ptr);\n\n        // Create a mask for numbers with at most two digits (-99 to 99)\n        svint32_t cmp_min = svclt(vec, svdup_n_s32(-99));\n        svint32_t cmp_max = svcgt(vec, svdup_n_s32(99));\n        svbool_t mask = svbor_z(pg, cmp_min, cmp_max);\n        mask = svnot_b32(mask); // Invert the mask to keep values between -99 and 99\n\n        // Apply the mask and sum the valid elements\n        svint32_t filtered_vec = svand_x(mask, vec);\n        svuint32_t ones = svdup_n_u32(1);\n        svint32_t sum_vec = svhadd(filtered_vec, filtered_vec, ones);\n\n        // Horizontal sum\n        int32x4_t res = svaddv(pg, sum_vec);\n        result += vget_lane_s32(res, 0);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int result = 0;\n    size_t vl = svcntw(); // Get the vector length in terms of number of elements\n    size_t num_elems = (k + vl - 1); // Total number of elements to process\n\n    for (size_t i = 0; i < num_elems; i += vl) {\n        svbool_t pg = svptrue_b32(); // Predicate for all true\n        size_t chunk_size = (k - i > vl) ? vl : (k - i);\n\n        if (chunk_size == 0) break;\n\n        svint32_t vec = svld1(pg, &arr[i]); // Load vector from array\n\n        // Create a predicate where |x| <= 99\n        svbool_t cond = svand_b32(svcplts_x(pg, vec, 100), svcplts_x(pg, svneg_x(pg, vec), 100));\n\n        // Set elements not satisfying condition to 0\n        svint32_t filtered = svsel(vec, svdup_n_s32(0), cond);\n\n        // Horizontal sum of the vector\n        int partial_sum = 0;\n        for (size_t j = 0; j < chunk_size; ++j) {\n            partial_sum += svindex(filtered, j);\n        }\n\n        result += partial_sum;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k){\n    int result = 0;\n    size_t vl = svcntw(); // Get the vector length in terms of number of 32-bit elements\n    size_t n = (k + vl - 1) / vl; // Number of SVE iterations needed\n\n    for (size_t i = 0; i < n; ++i) {\n        svbool_t pg = svptrue_b32(); // Predicate for all active elements\n        size_t index = i * vl;\n\n        if (index + vl > k) {\n            pg = svcmp_lt_u32(svptrue_b32(), svindex_u32(index, index + vl), k); // Mask elements beyond 'k'\n        }\n\n        svint32_t vec = svld1(pg, &arr[index]); // Load vector with predicate\n        svbool_t cond = svand_x(pg, svcmp_ge_s32(pg, vec, -999), svcmp_le_s32(pg, vec, 999)); // Check if elements are between -999 and 999\n        svint32_t filtered = svsel(cond, vec, svdup_s32(0)); // Select valid elements or zero otherwise\n        svint32_t sum_vec = svhadd_sv(pg, filtered); // Horizontal add within vector\n        result += svaddv_s32(pg, sum_vec); // Add the partial sum to the result\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <cstdint>\n\nbool is_sorted_simd(const std::vector<int> & lst){\n    if (lst.size() <= 1) {\n        return true;\n    }\n\n    size_t n = lst.size();\n    const int *data = lst.data();\n    svbool_t pg = svptrue_b32();\n\n    for (size_t i = 0; i + svcntw() <= n - 1; i += svcntw()) {\n        svint32_t vec_curr = svld1(pg, &data[i]);\n        svint32_t vec_next = svld1(pg, &data[i + 1]);\n\n        svbool_t not_increasing = svcmpgt(pg, vec_curr, vec_next);\n        if (svptest_any(svptrue_b32(), not_increasing)) {\n            return false;\n        }\n\n        svbool_t duplicates = svcmpeq(pg, vec_curr, vec_next);\n        if (svptest_any(svptrue_b32(), duplicates)) {\n            // Check for more than one duplicate in the vector\n            svuint32_t ones = svdup_n_u32(1);\n            svuint32_t counts = svadd_x_u32(pg, svand_x_u32(pg, duplicates, ones), svandnot_x_u32(pg, duplicates, ones));\n            uint32x4_t res = svaddv_u32(pg, counts);\n            if (svcntw() > 4 && ((res[0] + res[1] + res[2] + res[3]) > 1)) {\n                return false;\n            }\n        }\n    }\n\n    // Handle remaining elements\n    for (size_t i = (n / svcntw()) * svcntw(); i < n - 1; ++i) {\n        if (data[i] > data[i + 1] || (data[i] == data[i + 1] && std::count(data, data + i + 1, data[i]) > 2)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst){\n    if (lst.size() <= 1) return true;\n\n    size_t num_elements = lst.size();\n    const int * data = lst.data();\n    svbool_t pg = svptrue_b32();\n\n    for (size_t i = 0; i + svcntw() <= num_elements - 1; i += svcntw()) {\n        svint32_t vl = svld1(pg, &data[i]);\n        svint32_t vl_next = svld1(pg, &data[i + 1]);\n\n        svbool_t pred_sorted = svcmple(pg, vl, vl_next);\n        svbool_t pred_duplicates = svcmpeq(pg, vl, vl_next);\n\n        // Check if all elements are in order\n        if (!svptest_all(pg, pred_sorted)) {\n            return false;\n        }\n\n        // Count duplicates\n        uint64_t count_duplicates = svcntp(pred_duplicates, pg);\n        if (count_duplicates > 1) {\n            return false;\n        }\n    }\n\n    // Handle remaining elements\n    size_t i = (num_elements - 1) / svcntw() * svcntw();\n    if (i < num_elements - 1) {\n        size_t left = num_elements - i - 1;\n        svbool_t pg_left = sv reinterpret_pgleft(left);\n        svint32_t vl = svld1(pg_left, &data[i]);\n        svint32_t vl_next = svld1(pg_left, &data[i + 1]);\n\n        svbool_t pred_sorted = svcmple(pg_left, vl, vl_next);\n        svbool_t pred_duplicates = svcmpeq(pg_left, vl, vl_next);\n\n        if (!svptest_all(pg_left, pred_sorted)) {\n            return false;\n        }\n\n        uint64_t count_duplicates = svcntp(pred_duplicates, pg_left);\n        if (count_duplicates > 1) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <stdalign.h>\n\nbool is_sorted_simd(const std::vector<int> & lst){\n    if (lst.size() <= 1) return true;\n\n    size_t vl = svcntw(); // Vector length in terms of the number of int elements\n    int n = lst.size();\n    alignas(16) int data[n];\n    std::copy(lst.begin(), lst.end(), data);\n\n    for (size_t i = 0; i < n - 1; i += vl) {\n        svbool_t pg = svptrue_b32(); // Predicate for all active lanes\n        svint32_t vec_curr = svld1(pg, &data[i]); // Load current vector\n        svint32_t vec_next = svld1(pg, &data[i + 1]); // Load next vector\n\n        // Compare current vector with next vector\n        svbool_t pred_ge = svcmpge(pg, vec_curr, vec_next); \n        svbool_t pred_eq = svcmpeq(pg, vec_curr, vec_next);\n\n        // Check for unsorted or duplicate conditions\n        if (svptest_any(pg, pred_ge)) return false;\n        if (svptest_any(svand_x(pg, pred_eq, svnot_b32(pred_eq)), pred_eq)) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdint>\n\nbool is_sorted_simd(const std:: vector<int> & lst){\n    if (lst.size() < 2) {\n        return true;\n    }\n\n    size_t vl = svcntw(); // Vector length in terms of the number of elements that can be held in a vector register.\n    int32xN_t prev_vec, curr_vec, next_vec;\n    uint32xN_t pred;\n\n    const int32_t *data = lst.data();\n    size_t n = lst.size();\n\n    for (size_t i = 0; i <= n - vl; i += vl) {\n        curr_vec = svld1(svptrue_b32(), data + i);\n        next_vec = svld1(svptrue_b32(), data + i + 1);\n\n        // Check if current >= next\n        pred = svcmpge_u32(svptrue_b32(), svreinterpret_u32(curr_vec), svreinterpret_u32(next_vec));\n        if (svptest_any(svptrue_b32(), pred)) {\n            return false;\n        }\n\n        // Check for more than one duplicate\n        prev_vec = curr_vec;\n        curr_vec = next_vec;\n        pred = svcmpeq_u32(svptrue_b32(), prev_vec, curr_vec);\n        uint64_t count = svcntp(pred);\n        if (count > 1) {\n            return false;\n        }\n    }\n\n    // Handle remaining elements\n    size_t remainder = n % vl;\n    if (remainder != 0) {\n        svbool_t pg = svwhilelt_b32(0, remainder);\n        int32xN_t curr_remain = svld1(pg, data + n - remainder);\n        int32xN_t next_remain = svld1(pg, data + n - remainder + 1);\n\n        pred = svcmpge_u32(pg, svreinterpret_u32(curr_remain), svreinterpret_u32(next_remain));\n        if (svptest_any(pg, pred)) {\n            return false;\n        }\n\n        pred = svcmpeq_u32(pg, curr_remain, next_remain);\n        uint64_t count = svcntp(pred);\n        if (count > 1) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <cstdint>\n\nbool is_sorted_simd(const std::vector<int> & lst){\n    if (lst.size() < 2) return true;\n\n    size_t vl = svcntw(); // Vector length in terms of number of int32 elements\n    uint32x4_t one = svdup_n_u32(1);\n    bool sorted = true;\n\n    for (size_t i = 0; i + vl <= lst.size() - 1; i += vl) {\n        svbool_t pg = svptrue_b32();\n        int32_t *ptr = const_cast<int32_t *>(&lst[i]);\n        svint32_t v_curr = svld1(pg, ptr);\n        svint32_t v_next = svld1(pg, ptr + 1);\n\n        svbool_t cond_gt = svcmpgt(pg, v_curr, v_next);\n        svbool_t cond_eq = svcmpeq(pg, v_curr, v_next);\n\n        uint32_t count_duplicates = svcntp_u32(cond_eq);\n        if (count_duplicates > 1) {\n            return false;\n        }\n\n        uint32_t any_unsorted = svptest_any(svptrue_b32(), cond_gt);\n        if (any_unsorted) {\n            return false;\n        }\n    }\n\n    // Handle remaining elements\n    size_t i = ((lst.size() - 1) / vl) * vl;\n    if (i < lst.size() - 1) {\n        size_t left = lst.size() - 1 - i;\n        svbool_t pg = svwhilelt_b32(i, lst.size() - 1);\n        int32_t *ptr = const_cast<int32_t *>(&lst[i]);\n        svint32_t v_curr = svld1(pg, ptr);\n        svint32_t v_next = svld1(pg, ptr + 1);\n\n        svbool_t cond_gt = svcmpgt(pg, v_curr, v_next);\n        svbool_t cond_eq = svcmpeq(pg, v_curr, v_next);\n\n        uint32_t count_duplicates = svpopc_b32(svand(pg, cond_eq));\n        if (count_duplicates > 1) {\n            return false;\n        }\n\n        uint32_t any_unsorted = svptest_any(pg, cond_gt);\n        if (any_unsorted) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr){\n    if (arr.empty()) return -32768;\n\n    int sum = 0;\n    int prod_sign = 1;\n\n    svbool_t pg = svptrue_b32();\n    size_t vec_len = arr.size();\n    size_t i = 0;\n\n    for (; i <= vec_len - svcntw(); i += svcntw()) {\n        svint32_t vec = svld1(pg, &arr[i]);\n        \n        // Compute absolute values\n        svint32_t abs_vec = svasr_s32(vec, svabs_s32(vec));\n        \n        // Sum of magnitudes\n        svint32_t sum_vec = svadd_x(pg, abs_vec, svdup_z(pg, sum));\n        sum = svaddv(pg, sum_vec);\n\n        // Compute signs (-1, 0, 1)\n        svint32_t sign_vec = svsigns_s32(vec);\n        \n        // Product of signs\n        int local_prod_sign = svminv(pg, sign_vec) * svmaxv(pg, sign_vec);\n        prod_sign *= (local_prod_sign == 0) ? 0 : local_prod_sign;\n    }\n\n    for (; i < vec_len; ++i) {\n        int val = arr[i];\n        sum += std::abs(val);\n        if (val == 0) {\n            prod_sign = 0;\n        } else {\n            prod_sign *= (val > 0) ? 1 : -1;\n        }\n    }\n\n    return prod_sign * sum;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <climits>\n\nint prod_signs_simd(const std::vector<int> & arr){\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int sum = 0;\n    int product_of_signs = 1;\n\n    svbool_t pg = svptrue_b32();\n    size_t vec_len = arr.size();\n    const int *data = arr.data();\n\n    size_t i = 0;\n    for (; i + svcntw() <= vec_len; i += svcntw()) {\n        svint32_t v = svld1(pg, &data[i]);\n        svuint32_t vmag = svasr_u32(svabs_s32(v), svdup_n_s32(0));\n        svint32_t vsign = svsigns_s32(pg, v);\n\n        sum += svaddv(pg, vmag);\n        product_of_signs *= svandv(pg, vsign);\n    }\n\n    for (; i < vec_len; ++i) {\n        int val = data[i];\n        sum += abs(val);\n        product_of_signs *= (val > 0) - (val < 0);\n    }\n\n    return sum * product_of_signs;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\nint prod_signs_simd(const std::vector<int> & arr){\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int sum_magnitudes = 0;\n    int product_of_signs = 1;\n\n    size_t num_elements = arr.size();\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < num_elements; i += vl) {\n        size_t chunk_size = std::min(vl, num_elements - i);\n\n        svbool_t pred = svwhilelt_b32(i, i + chunk_size);\n        svint32_t vec = svld1_gather_index_z_s32(pg, 0, reinterpret_cast<const int *>(&arr[0]) + i, sizeof(int));\n\n        // Compute magnitudes\n        svuint32_t magnitudes = svabs_u32(pred, vec);\n\n        // Sum magnitudes\n        svuint32_t partial_sums = svaddv_u32(pred, magnitudes);\n        sum_magnitudes += svaddv_u32(pg, partial_sums);\n\n        // Compute signs (-1, 0, 1)\n        svint32_t signs = svsigns_s32(pred, vec);\n\n        // Product of signs\n        int local_product = 1;\n        for (size_t j = 0; j < chunk_size; ++j) {\n            int current_sign = svindex_n_s32(j);\n            if (svtest_any(svptrue_b32(), svcmpeq_s32(pred, signs, current_sign))) {\n                local_product *= current_sign;\n            }\n        }\n        product_of_signs *= local_product;\n    }\n\n    return sum_magnitudes * product_of_signs;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <climits>\n\nint prod_signs_simd(const std::vector<int> & arr){\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int sum_magnitude = 0;\n    int product_sign = 1;\n\n    svbool_t pg = svptrue_b32();\n    size_t vec_len = arr.size();\n\n    for (size_t i = 0; i < vec_len; i += svcntw()) {\n        size_t k = svcntw();\n        svbool_t active = svwhilelt_b32(i, vec_len);\n        svint32_t svec = svld1_gather_index_z_s32(pg, active, &arr[0], svindex_s32(i, i + k));\n        \n        // Compute signs (-1, 0, 1)\n        svint32_t sign_vec = svsigns_s32(pg, svec);\n        svint32_t abs_vec = svabs_s32(pg, svec);\n\n        // Reduce the vector of magnitudes and signs\n        int partial_sum = svaddv(pg, abs_vec);\n        int partial_product = svandv(pg, sign_vec);\n\n        sum_magnitude += partial_sum;\n        product_sign *= (partial_product != 0) ? partial_product : 0;\n    }\n\n    return sum_magnitude * product_sign;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <climits>\n\nint prod_signs_simd(const std::vector<int> & arr){\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int result = 0;\n    int sign_product = 1;\n\n    size_t vl = svcntw();\n    svbool_t pg = svptrue_b32();\n\n    for(size_t i = 0; i + vl <= arr.size(); i += vl){\n        svint32_t vec = svld1(pg, &arr[i]);\n        svint32_t abs_vec = svasr_s32(pg, vec, svcntw() - 1);\n        abs_vec = svand_x(pg, abs_vec, vec);\n\n        result += svaddv(pg, abs_vec);\n\n        svuint32_t signs = svshrq_u32(pg, svreinterpret_s32_u32(vec), 31);\n        signs = sveor_x(pg, signs, svdup_n_u32(1));\n        int partial_sign_product = svaddv(pg, signs);\n        sign_product *= (partial_sign_product == vl) ? 1 : ((partial_sign_product == 0) ? 0 : -1);\n    }\n\n    for(size_t i = arr.size() - (arr.size() % vl); i < arr.size(); ++i){\n        if(arr[i] > 0){\n            result += arr[i];\n            sign_product *= 1;\n        }\n        else if(arr[i] < 0){\n            result -= arr[i];\n            sign_product *= -1;\n        }\n        else{\n            sign_product *= 0;\n        }\n    }\n\n    return result * sign_product;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <climits>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>> &grid, int k) {\n    int N = grid.size();\n    std::vector<int> result;\n    if (k <= 0 || N == 0) return result;\n\n    int min_val = INT_MAX;\n    int min_x = 0, min_y = 0;\n\n    // Find the minimum starting point\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if (grid[i][j] < min_val) {\n                min_val = grid[i][j];\n                min_x = i;\n                min_y = j;\n            }\n        }\n    }\n\n    result.push_back(grid[min_x][min_y]);\n\n    svbool_t pg = svptrue_b32();\n    int current_x = min_x, current_y = min_y;\n\n    for (int step = 1; step < k; ++step) {\n        int next_val = INT_MAX;\n        int next_x = current_x, next_y = current_y;\n\n        // Define movement directions\n        const int dx[4] = {-1, 1, 0, 0};\n        const int dy[4] = {0, 0, -1, 1};\n\n        for (int d = 0; d < 4; ++d) {\n            int nx = current_x + dx[d];\n            int ny = current_y + dy[d];\n\n            if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n                int val = grid[nx][ny];\n                if (val < next_val) {\n                    next_val = val;\n                    next_x = nx;\n                    next_y = ny;\n                }\n            }\n        }\n\n        result.push_back(grid[next_x][next_y]);\n        current_x = next_x;\n        current_y = next_y;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <climits>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>> &grid, int k) {\n    int N = grid.size();\n    if (N == 0 || k <= 0) return {};\n\n    // Initialize variables\n    int pg = svptrue_b32();\n    int min_val = INT_MAX;\n    std::vector<int> result;\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            // Start from each cell (i,j)\n            std::vector<int> path;\n            path.push_back(grid[i][j]);\n            \n            // Use SVE to process neighbors in parallel\n            svbool_t pred = svptrue_b32();\n            int vl = svcntw();\n            svint32_t current_vals = svdup_n_s32(grid[i][j]);\n            svint32_t min_path_vals = svdup_n_s32(INT_MAX);\n\n            for (int step = 1; step < k; ++step) {\n                svint32_t next_vals = svdup_n_s32(INT_MAX);\n                for (int di = -1; di <= 1; ++di) {\n                    for (int dj = -1; dj <= 1; ++dj) {\n                        if (di == 0 && dj == 0) continue;\n                        int ni = i + di, nj = j + dj;\n                        if (ni >= 0 && ni < N && nj >= 0 && nj < N) {\n                            svint32_t neighbor_vals = svdup_n_s32(grid[ni][nj]);\n                            next_vals = svmin_s32(pred, next_vals, neighbor_vals);\n                        }\n                    }\n                }\n                current_vals = next_vals;\n                min_path_vals = svmin_s32(pred, min_path_vals, current_vals);\n            }\n\n            int scalar_min = INT_MAX;\n            for (int idx = 0; idx < vl; ++idx) {\n                scalar_min = (scalar_min < svindex_s32()[idx]) ? scalar_min : svget_lane_s32(min_path_vals, idx);\n            }\n\n            if (scalar_min < min_val) {\n                min_val = scalar_min;\n                result = path;\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <climits>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>> &grid, int k) {\n    int N = grid.size();\n    std::vector<int> result;\n    if (N == 0 || k <= 0) return result;\n\n    int min_val = INT_MAX;\n    int svl = svcntw(); // Vector length in terms of the number of int elements\n    svint32_t min_vec = svdup_n_s32(INT_MAX);\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            // Initialize path with starting cell\n            std::vector<int> current_path = {grid[i][j]};\n            int current_min = grid[i][j];\n\n            // Use SVE to process multiple paths in parallel\n            svint32_t current_min_vec = svdup_n_s32(current_min);\n            int x = i, y = j;\n\n            for (int step = 1; step < k; ++step) {\n                svint32_t neighbors[4];\n                int count = 0;\n\n                // Collect valid neighbor values\n                if (x > 0) neighbors[count++] = svdup_n_s32(grid[x-1][y]);\n                if (x < N-1) neighbors[count++] = svdup_n_s32(grid[x+1][y]);\n                if (y > 0) neighbors[count++] = svdup_n_s32(grid[x][y-1]);\n                if (y < N-1) neighbors[count++] = svdup_n_s32(grid[x][y+1]);\n\n                // Find the minimum among neighbors using SVE\n                svint32_t min_neighbor = neighbors[0];\n                for (int m = 1; m < count; ++m) {\n                    min_neighbor = svmin_s32(min_neighbor, neighbors[m]);\n                }\n\n                // Update current path and minimum value\n                current_min_vec = svmin_s32(current_min_vec, min_neighbor);\n                current_min = svminv_s32(current_min_vec);\n                current_path.push_back(current_min);\n\n                // Update position based on selected neighbor\n                if (x > 0 && grid[x-1][y] == current_min) --x;\n                else if (x < N-1 && grid[x+1][y] == current_min) ++x;\n                else if (y > 0 && grid[x][y-1] == current_min) --y;\n                else if (y < N-1 && grid[x][y+1] == current_min) ++y;\n            }\n\n            // Compare and update global minimum path\n            if (current_path < result || result.empty()) {\n                result = current_path;\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <climits>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k){\n    int N = grid.size();\n    int min_val = INT_MAX;\n    int min_x = 0, min_y = 0;\n    svbool_t pg = svptrue_b32();\n    \n    for(int i = 0; i < N; ++i){\n        for(int j = 0; j < N; ++j){\n            if(grid[i][j] < min_val){\n                min_val = grid[i][j];\n                min_x = i;\n                min_y = j;\n            }\n        }\n    }\n\n    std::vector<int> result;\n    result.push_back(grid[min_x][min_y]);\n    \n    int current_x = min_x;\n    int current_y = min_y;\n    \n    for(int step = 1; step < k; ++step){\n        int next_val = INT_MAX;\n        int next_x = current_x, next_y = current_y;\n        int directions[4][2] = { {-1,0}, {1,0}, {0,-1}, {0,1} };\n        \n        svint32_t svinfinity = svdup_n_s32(INT_MAX);\n        svint32_t svnext_val = svinfinity;\n        svint32_t svnext_x = svdup_n_s32(current_x);\n        svint32_t svnext_y = svdup_n_s32(current_y);\n        \n        for(auto &[dx, dy] : directions){\n            int nx = current_x + dx;\n            int ny = current_y + dy;\n            \n            if(nx >=0 && nx < N && ny >=0 && ny < N){\n                int val = grid[nx][ny];\n                svint32_t svval = svdup_n_s32(val);\n                svnext_val = svmin_s32(pg, svnext_val, svval);\n                \n                svbool_t condition = svcmplt_s32(pg, svval, svnext_val);\n                svnext_x = svsel_s32(condition, svdup_n_s32(nx), svnext_x);\n                svnext_y = svsel_s32(condition, svdup_n_s32(ny), svnext_y);\n            }\n        }\n        \n        intx_t active = svlastb_s32(pg);\n        if(active){\n            next_x = svindex_s32()[active];\n            next_y = svindex_s32()[active];\n        }\n        \n        result.push_back(grid[next_x][next_y]);\n        current_x = next_x;\n        current_y = next_y;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> >& grid, int k) {\n    int N = grid.size();\n    int total_elements = N * N;\n    int vl = svcntw(); // Vector length in terms of the number of int elements\n\n    // Flatten the grid into a single vector for easier SIMD processing\n    std::vector<int> flat_grid(total_elements);\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            flat_grid[i * N + j] = grid[i][j];\n        }\n    }\n\n    // Initialize variables\n    std::vector<int> min_path(k, INT32_MAX);\n    int start_idx = 0;\n\n    // SVE intrinsics to process paths in parallel\n    for (int idx = 0; idx < total_elements; idx += vl) {\n        svbool_t pg = svptrue_b32(); // Predicate for all active elements\n        svint32_t current_values = svld1(pg, &flat_grid[idx]);\n\n        for (int step = 0; step < k; ++step) {\n            svint32_t current_min = svdup_n_s32(INT32_MAX);\n            svbool_t min_pred = svcmplt(pg, current_values, current_min);\n\n            // Update current_min with the minimum values found\n            current_min = svmin(pg, current_min, current_values);\n\n            // Extract scalar minimum value from the vector\n            int scalar_min = svminv(pg, current_min);\n\n            // Update the path if a smaller lexicographical order is found\n            if (scalar_min < min_path[step]) {\n                min_path[step] = scalar_min;\n                start_idx = idx + svindex_s32(0, 1)[svfirst(min_pred)];\n            }\n\n            // Prepare for the next step\n            current_values = svadd_n(pg, current_values, 1); // Simulate movement\n        }\n    }\n\n    // Reconstruct the minimum path based on the starting index and k\n    std::vector<int> result;\n    int current = start_idx;\n    for (int i = 0; i < k; ++i) {\n        result.push_back(flat_grid[current]);\n        // Simplified movement logic (actual movement depends on grid structure)\n        current = (current + 1) % total_elements;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t digits_simd(uint64_t n){\n    uint64_t product = 1;\n    int has_odd = 0;\n\n    svbool_t pg = svptrue_b8();\n    uint8_t digits[20];\n    int count = 0;\n\n    // Extract digits into an array\n    while (n > 0) {\n        digits[count++] = n % 10;\n        n /= 10;\n    }\n\n    if (count == 0) return 0;\n\n    // Load digits into a vector\n    svuint8_t sv_digits = svdup_u8(0);\n    for(int i = 0; i < count; i++) {\n        sv_digits = svinslane_u8(sv_digits, digits[i], i);\n    }\n\n    // Mask for odd digits (1,3,5,7,9)\n    svuint8_t mask_odd = svcmpy_u8(pg, sv_digits, svdup_n_u8(1));\n    mask_odd = svand_u8(mask_odd, svcmpeq_u8(pg, sv_digits, svdup_n_u8(3)));\n    mask_odd = svbor_u8(mask_odd, svcmpeq_u8(pg, sv_digits, svdup_n_u8(5)));\n    mask_odd = svbor_u8(mask_odd, svcmpeq_u8(pg, sv_digits, svdup_n_u8(7)));\n    mask_odd = svbor_u8(mask_odd, svcmpeq_u8(pg, sv_digits, svdup_n_u8(9)));\n\n    // Compute product of odd digits\n    svuint8_t sv_product = svdup_n_u8(1);\n    svuint8_t sv_temp = svand_u8(pg, sv_digits, mask_odd);\n\n    for(int i = 0; i < count; i++) {\n        uint8_t val = svindex_u8(i, 1);\n        if(svtst_u8(pg, mask_odd, svcmpeq_u8(pg, sv_digits, svdup_n_u8(val)))) {\n            has_odd = 1;\n            product *= svtbl1_u8(sv_temp, svindex_u8(i, 1));\n        }\n    }\n\n    if (!has_odd) return 0;\n    return product;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t digits_simd(uint64_t n){\n    uint64_t product = 1;\n    int has_odd = 0;\n\n    while (n > 0) {\n        svbool_t pg = svptrue_b8();\n        uint64_t digits = n % 10;\n        n /= 10;\n\n        // Broadcast the digit to a vector\n        svuint8_t vec_digit = svdup_n_u8((uint8_t)digits);\n\n        // Check if the digit is odd\n        svbool_t is_odd = svcmpne_b8(pg, vec_digit & 1, svdup_n_u8(0));\n\n        // If odd, update the product\n        if (svcntp_b8(pg, is_odd) > 0) {\n            has_odd = 1;\n            product *= digits;\n        }\n    }\n\n    return has_odd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t digits_simd(uint64_t n){\n    uint64_t product = 1;\n    uint64_t temp = n;\n    svbool_t pg = svptrue_b8();\n    svuint8_t vec_zero = svdup_n_u8(0);\n    svuint8_t vec_one = svdup_n_u8(1);\n    svuint8_t vec_two = svdup_n_u8(2);\n    svuint8_t vec_ten = svdup_n_u8(10);\n\n    if (n == 0) {\n        return 0;\n    }\n\n    while (temp > 0) {\n        svuint8_t digits = svdup_n_u8((uint8_t)(temp % 10));\n        svuint8_t is_odd = svandnot_u8(svceq_u8(digits, svmla_u8(vec_zero, digits, vec_two)), vec_one);\n        svuint8_t odd_digits = svand_u8(digits, is_odd);\n        uint8_t prod = svaddv_u8(pg, svmla_u8(vec_one, odd_digits, odd_digits));\n        product *= prod;\n        temp /= 10;\n        if (product == 0) break;\n    }\n\n    return (product == 1 && n % 2 == 0) ? 0 : product;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t digits_simd(uint64_t n){\n    uint64_t result = 1;\n    int has_odd = 0;\n\n    svbool_t pg = svptrue_b8();\n    uint8_t digits[20];\n    int count = 0;\n\n    // Extract digits into an array\n    while (n > 0) {\n        digits[count++] = n % 10;\n        n /= 10;\n    }\n\n    if (count == 0) return 0;\n\n    // Load digits into SVE vector\n    svuint8_t sv_digits = svdup_n_u8(0);\n    for(int i = 0; i < count; i += svcntb()) {\n        svuint8_t tmp = svld1_u8(pg, &digits[i]);\n        sv_digits = svsel_u8(pg, sv_digits, tmp);\n    }\n\n    // Mask for odd digits (1,3,5,7,9)\n    svuint8_t odd_mask = svcmpy_u8(pg, svtrue_u8(), svconst_u8(0x55), sv_digits);\n\n    svuint8_t filtered = svand_u8(pg, sv_digits, odd_mask);\n\n    // Check if any digit is odd\n    uint64_t num_odd = svcntp_u8(pg, odd_mask);\n    if (num_odd == 0) return 0;\n\n    // Compute product of odd digits\n    svuint8_t prod = svones_u8();\n    prod = svmul_x_u8(pg, prod, filtered);\n\n    // Horizontal product reduction\n    uint64_t hprod = 1;\n    svuint8_t res = svreinterpret_u8_u64(svmovl_u32(svaddv_u8(pg, prod)));\n    for(int i=0; i < svcntb(); i++) {\n        hprod *= (uint64_t)sveor_u8(res, sveindex_n_u8(i));\n    }\n\n    return hprod;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t digits_simd(uint64_t n){\n    uint64_t product = 1;\n    int has_odd = 0;\n\n    svbool_t pg = svptrue_b8();\n    uint8_t digits[20];\n    int count = 0;\n\n    // Extract digits into an array\n    while (n > 0) {\n        digits[count++] = n % 10;\n        n /= 10;\n    }\n\n    // Process digits in parallel using SVE\n    for(int i = 0; i < count; i += svcntw()) {\n        svuint8_t vec = svld1_u8(pg, &digits[i]);\n        svuint8_t ones = svdup_n_u8(1);\n        svuint8_t twos = svdup_n_u8(2);\n\n        // Check for odd digits\n        svbool_t is_odd = svcmpne_u8_m(pg, vec & ones, twos & ones);\n\n        // Multiply odd digits\n        svuint8_t current_product = svsel_u8(is_odd, vec, svdup_n_u8(1));\n        product *= svaddv_u8(pg, current_product);\n\n        // Check if there are any odd digits\n        has_odd |= svptest_any(svptrue_b8(), is_odd);\n    }\n\n    return has_odd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <cmath>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    if (lst.empty()) return 0;\n\n    uint64_t total_sum = 0;\n    size_t num_elements = lst.size();\n    const float *data = lst.data();\n\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    size_t i = 0;\n    for (; i + vl <= num_elements; i += vl) {\n        svfloat32_t vec = svld1(pg, &data[i]);\n        svint32_t rounded_vec = svceiq_x(pg, vec);\n        svint32_t squared_vec = svmul_x(pg, rounded_vec, rounded_vec);\n        svuint64_t partial_sums = svaddv(pg, svreinterpret_s64_s32(squared_vec));\n        total_sum += svaddv_u64(pg, partial_sums);\n    }\n\n    // Handle leftover elements\n    if (i < num_elements) {\n        size_t left = num_elements - i;\n        svbool_t pg_partial = svwhilelt_b32(i, num_elements);\n        svfloat32_t vec = svld1(pg_partial, &data[i]);\n        svint32_t rounded_vec = svceiq_x(pg_partial, vec);\n        svint32_t squared_vec = svmul_x(pg_partial, rounded_vec, rounded_vec);\n        svuint64_t partial_sums = svaddv(pg_partial, svreinterpret_s64_s32(squared_vec));\n        total_sum += svaddv_u64(pg_partial, partial_sums);\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cmath>\n#include <vector>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    if (lst.empty()) return 0;\n\n    uint64_t total_sum = 0;\n    size_t vl = svcntw(); // Vector length in terms of the number of elements\n    svbool_t pg = svptrue_b32(); // Predicate for all true\n\n    size_t i = 0;\n    size_t n = lst.size();\n\n    // Process full vectors\n    for (; i <= n - vl; i += vl) {\n        svfloat32_t vec = svld1(pg, &lst[i]); // Load vector\n        svfloat32_t ceil_vec = svceil_f32(pg, vec); // Ceiling operation\n        svint32_t int_vec = svcvt_s32_f32(pg, ceil_vec); // Convert to int\n        svint32_t squared_vec = svmul_x_s32(pg, int_vec, int_vec); // Element-wise square\n        svuint64_t partial_sums = svaddv_u64(pg, svreinterpret_u64_s32(squared_vec)); // Horizontal sum\n        total_sum += svaddv_u64(pg, partial_sums); // Accumulate to total sum\n    }\n\n    // Handle leftovers\n    if (i < n) {\n        svbool_t pg_tail = svwhilelt_b32(i, n);\n        svfloat32_t vec = svld1(pg_tail, &lst[i]);\n        svfloat32_t ceil_vec = svceil_f32(pg_tail, vec);\n        svint32_t int_vec = svcvt_s32_f32(pg_tail, ceil_vec);\n        svint32_t squared_vec = svmul_x_s32(pg_tail, int_vec, int_vec);\n        svuint64_t partial_sums = svaddv_u64(pg_tail, svreinterpret_u64_s32(squared_vec));\n        total_sum += svaddv_u64(pg_tail, partial_sums);\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <cstdint>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    uint64_t total_sum = 0;\n    if (lst.empty()) return total_sum;\n\n    size_t num_elements = lst.size();\n    const float *data = lst.data();\n\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < num_elements; i += vl) {\n        size_t chunk_size = (num_elements - i > vl) ? vl : num_elements - i;\n        svbool_t pred = svwhilelt_b32(i, num_elements);\n\n        svfloat32_t vec = svld1_f32(pred, data + i);\n        svint32_t rounded_vec = svmov_i32(pred, svcvt_z(svinterpret_s32(vec), vec));\n        svint32_t ceil_vec = svaddv_s32(pred, rounded_vec, svdup_n_s32(1));\n\n        svuint32_t squared_vec = svmul_u32(pred, svreinterpret_u32(ceil_vec), svreinterpret_u32(ceil_vec));\n        uint64x2_t partial_sums = svaddv_u32(pred, squared_vec);\n\n        total_sum += partial_sums[0] + partial_sums[1];\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cmath>\n#include <vector>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    uint64_t total_sum = 0;\n    if (lst.empty()) return total_sum;\n\n    size_t vl = svcntw();\n    svbool_t pg = svptrue_b32();\n    float *data = const_cast<float*>(lst.data());\n    size_t n = lst.size();\n\n    for (size_t i = 0; i < n; i += vl) {\n        size_t k = n - i;\n        if (k < vl) pg = svwhilelt_b32(k, vl);\n\n        svfloat32_t vec = svld1(pg, &data[i]);\n        svfloat32_t ceil_vec = svceil_f32(pg, vec);\n        svint32_t int_vec = svcvt_s32_f32(pg, ceil_vec);\n        svint32_t squared_vec = svmul_x_s32(pg, int_vec, int_vec);\n\n        // Horizontal sum\n        int32x4_t res = svaddv_s32(pg, squared_vec);\n        total_sum += vpaddlvq_s32(res);\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <cstdint>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    uint64_t total_sum = 0;\n    if (lst.empty()) return total_sum;\n\n    size_t vl = svcntw();\n    float *data = lst.data();\n    size_t size = lst.size();\n\n    svbool_t pg = svptrue_b32();\n    svfloat32_t v_zero = svdup_f32(pg, 0.0f);\n    svint32_t v_int_zero = svdup_s32(pg, 0);\n\n    svfloat32_t v_sum = v_zero;\n    svint32_t v_total = v_int_zero;\n\n    for (size_t i = 0; i <= size - vl; i += vl) {\n        svfloat32_t v_data = svld1_f32(pg, data + i);\n        svint32_t v_ceil = svmovl_s32(svrintp_f32(pg, v_data));\n        svfloat32_t v_sq = svmla_f32(pg, v_zero, svreinterpret_f32_s32(v_ceil), svreinterpret_f32_s32(v_ceil));\n        v_sum = svadd_f32(pg, v_sum, v_sq);\n    }\n\n    // Horizontal sum\n    svint32_t v_sum_i32 = svmovl_s32(svcvt_s32_f32(pg, v_sum));\n    for (size_t i = 0; i < vl; ++i) {\n        total_sum += svindex_s32()[i];\n    }\n\n    // Tail handling\n    size_t leftover = size % vl;\n    if (leftover > 0) {\n        svbool_t pg_tail = svwhilelt_b32(leftover, vl);\n        svfloat32_t v_data_tail = svld1_f32(pg_tail, data + size - leftover);\n        svint32_t v_ceil_tail = svmovl_s32(svrintp_f32(pg_tail, v_data_tail));\n        svfloat32_t v_sq_tail = svmla_f32(pg_tail, v_zero, svreinterpret_f32_s32(v_ceil_tail), svreinterpret_f32_s32(v_ceil_tail));\n        v_sum = svadd_f32(pg_tail, v_sum, v_sq_tail);\n\n        // Add tail contribution to total_sum\n        svint32_t v_sum_i32_tail = svmovl_s32(svcvt_s32_f32(pg_tail, v_sum));\n        for (size_t i = 0; i < leftover; ++i) {\n            total_sum += svindex_s32()[i];\n        }\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cinttypes>\n#include <vector>\n#include <climits>\n\nint can_arrange_simd(const std::vector<int> & arr){\n    if (arr.size() <= 1) return -1;\n\n    size_t n = arr.size();\n    int result = -1;\n    svbool_t pg = svptrue_b32();\n\n    for (size_t i = 0; i < n - 1; i += svcntw()) {\n        size_t k = n - 1 - i < svcntw() ? n - 1 - i : svcntw();\n        svbool_t pg_k = svwhilelt_b32(i, i + k);\n\n        svint32_t vl = svld1(pg_k, &arr[i]);\n        svint32_t vr = svld1(pg_k, &arr[i + 1]);\n\n        svbool_t pred = svcls_b32(pg_k, svcmpge(vl, vr));\n\n        svuint32_t vi = svindex_u32(i, 1);\n        svuint32_t vmax = svmaxv(pg_k, svsel_u32(pred, vi, svdup_n_u32(0)));\n\n        if (svptest_any(svptrue_b32(), pred)) {\n            result = (int)vmax > result ? (int)vmax : result;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cinttypes>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> &arr) {\n    if (arr.size() <= 1) return -1;\n\n    size_t n = arr.size();\n    svbool_t pg = svptrue_b32();\n    int32_t result = -1;\n\n    for (size_t i = 0; i < n - 1; i += svcntw()) {\n        size_t k = n - 1 - i < svcntw() ? n - 1 - i : svcntw();\n        svbool_t pg_k = svwhilelt_b32(i, i + k);\n\n        svint32_t vec_curr = svld1(pg_k, &arr[i]);\n        svint32_t vec_next = svld1(pg_k, &arr[i + 1]);\n\n        svbool_t cond = svclt(pg_k, vec_curr, vec_next);\n\n        // Find the last false in cond\n        svuint32_t indices = svindex_u32(i, i + svcntw());\n        svuint32_t masked_indices = svsel_u32(pg_k, indices, svdup_n_u32(-1));\n        int32_t candidate = svlasta_m(pg_k, cond, masked_indices);\n\n        if (candidate > result) {\n            result = candidate;\n        }\n    }\n\n    return result == -1 ? -1 : result - 1;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cinttypes>\n\nint can_arrange_simd(const std::vector<int> & arr){\n    if (arr.size() <= 1) return -1;\n\n    size_t vl = svlmax();\n    int result = -1;\n\n    svbool_t pg = svptrue_b32();\n    const int *data = arr.data();\n\n    for (size_t i = 0; i + vl <= arr.size() - 1; i += vl) {\n        svint32_t v_curr = svld1(pg, &data[i]);\n        svint32_t v_next = svld1(pg, &data[i + 1]);\n\n        svbool_t pred = svclt(pg, v_curr, v_next);\n\n        // Find the first lane where the condition is false\n        uint32x4_t indices = svindex_z(pg, i, 1);\n        uint32x4_t masked_indices = svwhilelt_b32(pg, indices, arr.size() - 1);\n        uint32x4_t failing_indices = svand_x(pg, svnot_b32(pred), masked_indices);\n\n        uint32_t max_failing_index = svmaxv(pg, failing_indices);\n        if (max_failing_index > result) {\n            result = max_failing_index;\n        }\n    }\n\n    // Scalar cleanup for remaining elements\n    for (size_t i = ((arr.size() - 1) / vl) * vl; i < arr.size() - 1; ++i) {\n        if (data[i] >= data[i + 1]) {\n            result = i;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr){\n    if (arr.size() < 2) return -1;\n\n    size_t n = arr.size();\n    int result = -1;\n\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i + vl <= n - 1; i += vl) {\n        svint32_t vec_curr = svld1(pg, &arr[i]);\n        svint32_t vec_next = svld1(pg, &arr[i + 1]);\n\n        svbool_t cond = svclt(vec_curr, vec_next);\n        svbool_t not_cond = svnot_b32(cond);\n\n        // Find indices where the condition is true\n        int32_t indices[sve_len()/4];\n        svst1(pg, indices, svindex_w(i, 1));\n        int32_t masked_indices[sve_len()/4];\n        svcompactnot_b32(masked_indices, not_cond, indices);\n\n        for (size_t j = 0; j < vl; ++j) {\n            if (masked_indices[j] != 0) {\n                result = masked_indices[j];\n            }\n        }\n    }\n\n    // Handle remaining elements\n    for (size_t i = ((n - 1) / vl) * vl; i < n - 1; ++i) {\n        if (arr[i] >= arr[i + 1]) {\n            result = i;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cinttypes>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> &arr) {\n    if (arr.size() <= 1) return -1;\n\n    size_t n = arr.size();\n    int result = -1;\n    svbool_t pg = svptrue_b32(); // Predicate for all true\n    size_t index = 0;\n\n    while (index + svcntw() <= n - 1) {\n        svbool_t pred = svwhilelt_b32(index, n - 1);\n        svint32_t vl = svld1(pred, &arr[index]);\n        svint32_t vl_next = svld1(pred, &arr[index + 1]);\n\n        svbool_t mismatch = svclt(vl_next, vl);\n\n        if (svptest_any(svptrue_b32(), mismatch)) {\n            svuint32_t indices = svindex_u32(index, 1);\n            indices = svcompact_u32(pred, indices);\n            svuint32_t max_index = svmaxv_m_u32(pg, mismatch, indices);\n            result = svmovemask(max_index);\n        }\n\n        index += svcntw();\n    }\n\n    // Handle remaining elements\n    for (; index < n - 1; ++index) {\n        if (arr[index] > arr[index + 1]) {\n            result = index;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <climits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst){\n    if (lst.empty()) return {0, 0};\n\n    svbool_t pg = svptrue_b32();\n    size_t vec_len = lst.size();\n    int *data = const_cast<int*>(lst.data());\n\n    svint32_t vmax_neg = svdup_s32(SIMD_MIN_INT32);\n    svint32_t vmin_pos = svdup_s32(SIMD_MAX_INT32);\n\n    for (size_t i = 0; i < vec_len; i += svcntw()) {\n        size_t k = svcntw();\n        if (i + k > vec_len) k = vec_len - i;\n\n        svint32_t vld = svld1(pg, &data[i]);\n        svbool_t is_neg = svcmplt(pg, vld, svdup_n_s32(0));\n        svbool_t is_pos = svcmpgt(pg, vld, svdup_n_s32(0));\n\n        vmax_neg = svmaxv(pg, vmax_neg, svsel(is_neg, vld, vmax_neg));\n        vmin_pos = svminv(pg, vmin_pos, svsel(is_pos, vld, vmin_pos));\n    }\n\n    int max_neg = svmaxv_s32(pg, vmax_neg);\n    int min_pos = svminv_s32(pg, vmin_pos);\n\n    if (max_neg >= 0) max_neg = 0;\n    if (min_pos <= 0) min_pos = 0;\n\n    return {max_neg, min_pos};\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <climits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst){\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    svbool_t pg = svptrue_b32();\n    size_t vec_len = lst.size();\n    int *data = const_cast<int*>(lst.data());\n\n    svint32_t vmax_neg = svdup_s32(pg, INT_MIN);\n    svint32_t vmin_pos = svdup_s32(pg, INT_MAX);\n\n    for (size_t i = 0; i < vec_len; i += svcntw()) {\n        size_t chunk = svcntw();\n        svbool_t pgb = svwhilelt_b32(i, vec_len);\n        svint32_t v = svld1(pgb, data + i);\n\n        // Find max negative\n        svbool_t is_neg = svcmplt(pgb, v, svdup_n_s32(0));\n        svint32_t neg_vals = svsel(is_neg, v, svdup_n_s32(INT_MIN));\n        vmax_neg = svmax_m(pg, vmax_neg, neg_vals, is_neg);\n\n        // Find min positive\n        svbool_t is_pos = svcmpgt(pgb, v, svdup_n_s32(0));\n        svint32_t pos_vals = svsel(is_pos, v, svdup_n_s32(INT_MAX));\n        vmin_pos = svmin_m(pg, vmin_pos, pos_vals, is_pos);\n    }\n\n    int max_neg = svmaxv(pg, vmax_neg);\n    int min_pos = svminv(pg, vmin_pos);\n\n    if (max_neg >= 0) max_neg = 0;\n    if (min_pos <= 0) min_pos = 0;\n\n    return {max_neg, min_pos};\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <climits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst){\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    svbool_t pg = svptrue_b32();\n    int32x4_t max_neg = svdup_n_s32(SV_INT32, INT_MIN);\n    int32x4_t min_pos = svdup_n_s32(SV_INT32, INT_MAX);\n\n    size_t index = 0;\n    while (index < lst.size()) {\n        size_t vl = svcntw();\n        size_t chunk_size = std::min(vl, static_cast<size_t>(lst.size()) - index);\n\n        svbool_t pred = svwhilelt_b32(index, lst.size());\n        int32_t data[chunk_size];\n        for (size_t i = 0; i < chunk_size; ++i) {\n            data[i] = lst[index + i];\n        }\n\n        svint32_t vec = svld1(pred, data);\n\n        // Find max negative\n        svbool_t is_neg = svcmplt(vec, svdup_n_s32(SV_INT32, 0));\n        int32x4_t neg_vals = svsel(is_neg, vec, svdup_n_s32(SV_INT32, INT_MIN));\n        max_neg = svmovmla(pg, max_neg, neg_vals);\n\n        // Find min positive\n        svbool_t is_pos = svcmpgt(vec, svdup_n_s32(SV_INT32, 0));\n        int32x4_t pos_vals = svsel(is_pos, vec, svdup_n_s32(SV_INT32, INT_MAX));\n        min_pos = svmovmla(pg, min_pos, pos_vals);\n\n        index += chunk_size;\n    }\n\n    int a = svmaxv(pg, max_neg);\n    int b = svminv(pg, min_pos);\n\n    if (a >= 0) a = 0;\n    if (b <= 0) b = 0;\n\n    return {a, b};\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <climits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst){\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    svbool_t pg = svptrue_b32();\n    int32x4_t max_neg = svdupq_n_s32(SV_MIN_INT32);\n    int32x4_t min_pos = svdupq_n_s32(SV_MAX_INT32);\n\n    size_t index = 0;\n    while (index < lst.size()) {\n        size_t vl = svcntw();\n        size_t num = lst.size() - index;\n        if (num < vl) {\n            pg = svwhilelt_b32(num, vl);\n            vl = num;\n        }\n\n        int32_t data[vl];\n        for (size_t i = 0; i < vl; ++i) {\n            data[i] = lst[index + i];\n        }\n\n        svint32_t vec = svld1(pg, data);\n\n        svbool_t is_neg = svcmplt(pg, vec, svdup_n_s32(0));\n        svbool_t is_pos = svcmpgt(pg, vec, svdup_n_s32(0));\n\n        max_neg = svmaxmv(pg, is_neg, max_neg, vec);\n        min_pos = svminmv(pg, is_pos, min_pos, vec);\n\n        index += vl;\n    }\n\n    int a = svmaxv(pg, max_neg);\n    int b = svminv(pg, min_pos);\n\n    if (a >= 0) a = 0;\n    if (b <= 0) b = 0;\n\n    return {a, b};\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <climits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst){\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    svbool_t pg = svptrue_b32();\n    int32x4_t max_neg = svdupq_n_s32(INT_MIN);\n    int32x4_t min_pos = svdupq_n_s32(INT_MAX);\n\n    size_t index = 0;\n    while (index < lst.size()) {\n        size_t vl = svcntw();\n        size_t num_elements = lst.size() - index;\n        if (num_elements < vl) {\n            pg = svwhilelt_b32(index, lst.size());\n            vl = num_elements;\n        }\n\n        // Load data\n        int32_t temp_array[svlen_w / sizeof(int32_t)];\n        for (size_t i = 0; i < vl; ++i) {\n            temp_array[i] = lst[index + i];\n        }\n        svint32_t vec = svld1(pg, temp_array);\n\n        // Find max negative\n        svbool_t is_neg = svcmplt(pg, vec, svdup_n_s32(0));\n        int32x4_t current_max_neg = svmaxpgv_s32(pg, is_neg, max_neg, vec);\n        max_neg = svmax_n_s32(max_neg, current_max_neg);\n\n        // Find min positive\n        svbool_t is_pos = svcmpgt(pg, vec, svdup_n_s32(0));\n        int32x4_t current_min_pos = svminpgv_s32(pg, is_pos, min_pos, vec);\n        min_pos = svmin_n_s32(min_pos, current_min_pos);\n\n        index += vl;\n    }\n\n    int a = svgetq_lane_s32(max_neg, 0);\n    int b = svgetq_lane_s32(min_pos, 0);\n\n    if (a >= 0) a = 0;\n    if (b <= 0) b = 0;\n\n    return {a, b};\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t special_factorial_simd(uint64_t n){\n    uint64_t result = 1;\n    svbool_t pg = svptrue_b64();\n    for (uint64_t i = 1; i <= n; i++) {\n        uint64_t factorial = 1;\n        for (uint64_t j = 1; j <= i; j++) {\n            svuint64_t sj = svdup_n_u64(j);\n            svuint64_t sfactorial = svdup_n_u64(factorial);\n            sfactorial = svmul_x_u64(pg, sfactorial, sj);\n            factorial = svaddv_u64(pg, sfactorial);\n        }\n        result *= factorial;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t special_factorial_simd(uint64_t n){\n    uint64_t result = 1;\n    svbool_t pg = svptrue_b64();\n    for(uint64_t i = 1; i <= n; i++){\n        uint64_t factorial = 1;\n        for(uint64_t j = 1; j <= i; j++){\n            svuint64_t sj = svdup_n_u64(j);\n            svuint64_t sfactorial = svdup_n_u64(factorial);\n            sfactorial = svmul_x_u64(pg, sfactorial, sj);\n            factorial = svaddv_u64(pg, sfactorial);\n        }\n        result *= factorial;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t special_factorial_simd(uint64_t n){\n    uint64_t result = 1;\n    svbool_t pg = svptrue_b64();\n    svuint64_t acc = svdup_n_u64(pg, 1);\n    \n    for (uint64_t i = 1; i <= n; ++i) {\n        svuint64_t factor = svdup_n_u64(pg, i);\n        svuint64_t factorial_acc = svdup_n_u64(pg, 1);\n        \n        for (uint64_t j = 1; j <= i; ++j) {\n            factorial_acc = svmul_x_u64(pg, factorial_acc, svdup_n_u64(pg, j));\n        }\n        \n        acc = svmul_x_u64(pg, acc, factorial_acc);\n    }\n    \n    result = svaddv_u64(pg, acc);\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t special_factorial_simd(uint64_t n){\n    uint64_t result = 1;\n    svbool_t pg = svptrue_b64();\n    svuint64_t acc = svdup_n_u64(pg, 1);\n    \n    for(uint64_t i = 1; i <= n; ++i){\n        svuint64_t factorial = svdup_n_u64(pg, 1);\n        svuint64_t current = svdup_n_u64(pg, i);\n        \n        for(uint64_t j = 1; j <= i; ++j){\n            factorial = svmul_x_u64(pg, factorial, current);\n            current = svsub_x_u64(pg, current, svdup_n_u64(pg, 1));\n        }\n        \n        acc = svmul_x_u64(pg, acc, factorial);\n    }\n\n    uint64_t scalar_acc = 1;\n    svuint64_t tmp = svindex_u64(0, 1);\n    svuint64_t mask = svcmpeq_u64(pg, tmp, svdup_n_u64(pg, 0));\n    svuint64_t res = svsel_u64(mask, acc, svdup_n_u64(pg, 1));\n    \n    for(int i = 0; i < svcntw(); ++i){\n        scalar_acc *= svindex_u64(0, 1)[i];\n    }\n\n    return scalar_acc;\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t special_factorial_simd(uint64_t n){\n    uint64_t result = 1;\n    svbool_t pg = svptrue_b64();\n    for (uint64_t i = 1; i <= n; i++) {\n        uint64_t factorial = 1;\n        for (uint64_t j = 1; j <= i; j++) {\n            svuint64_t sj = svdup_n_u64(j);\n            svuint64_t sfactorial = svdup_n_u64(factorial);\n            sfactorial = svmul_x_u64(pg, sfactorial, sj);\n            factorial = svaddv_u64(pg, sfactorial);\n        }\n        result *= factorial;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst){\n    if (lst.empty()) return 0;\n\n    int result = 0;\n    size_t num_elements = lst.size();\n    size_t vl = svcntw(); // Vector length in terms of the number of int elements\n\n    for (size_t i = 0; i < num_elements; i += vl) {\n        svbool_t pg = svptrue_b32(); // Predicate for all true\n        size_t chunk_size = num_elements - i;\n        if (chunk_size < vl) {\n            pg = svwhilelt_b32(i, num_elements);\n        }\n\n        // Load data\n        svint32_t vec = svld1(pg, &lst[i]);\n\n        // Create predicates for index conditions\n        svbool_t multiple_of_3 = svcmpeq(pg, svmul_x(pg, svindex_s32(0, 1), 3), svdup_n_s32(0));\n        svbool_t multiple_of_4 = svcmpeq(pg, svmul_x(pg, svindex_s32(0, 1), 4), svdup_n_s32(0));\n        svbool_t not_multiple_of_3 = svnot_b32(pg, multiple_of_3);\n\n        // Apply transformations\n        svint32_t squared = svsqr_x(multiple_of_3, vec);\n        svint32_t cubed = svmul_x(svand_b32(pg, multiple_of_4, not_multiple_of_3), vec, vec);\n        svint32_t transformed = svsel(multiple_of_3, squared, vec);\n        transformed = svsel(svand_b32(pg, multiple_of_4, not_multiple_of_3), cubed, transformed);\n\n        // Horizontal sum\n        int partial_sum = 0;\n        svint32_t acc = svaddv(pg, transformed);\n        partial_sum += svaddv(pg, acc);\n\n        result += partial_sum;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst){\n    if (lst.empty()) return 0;\n\n    int result = 0;\n    size_t vl = svcntw(); // Vector length in terms of number of elements\n    size_t n = lst.size();\n\n    for (size_t i = 0; i < n; i += vl) {\n        svbool_t pg = svptrue_b32(); // Predicate for all true\n        size_t chunk_end = i + vl > n ? n : i + vl;\n\n        // Load data\n        svint32_t vec = svld1(pg, &lst[i]);\n\n        // Create predicates for multiples of 3 and 4\n        svbool_t pred_mult_3 = svcmpeq(pg, svmul_x(pg, sve_i32(vl, 3), sve_i32(vl, 1)), svindex((int)i, (int)chunk_end));\n        svbool_t pred_mult_4_not_3 = svandnot_z(pg, svcmpeq(pg, svmul_x(pg, sve_i32(vl, 4), sve_i32(vl, 1)), svindex((int)i, (int)chunk_end)), pred_mult_3);\n\n        // Square for multiples of 3\n        svint32_t squared = svmul_x(pred_mult_3, vec, vec);\n\n        // Cube for multiples of 4 and not 3\n        svint32_t cubed = svmul_x(pred_mult_4_not_3, svmul_x(pg, vec, vec), vec);\n\n        // Select original values where neither condition is met\n        svbool_t pred_other = svnot_b32(svorr_z(pg, pred_mult_3, pred_mult_4_not_3));\n        svint32_t unchanged = svdup_z(pred_other, 0);\n        unchanged = svsel(pred_other, vec, unchanged);\n\n        // Combine results\n        svint32_t res = svadd_z(pg, squared, cubed);\n        res = svadd_z(pg, res, unchanged);\n\n        // Accumulate the sum\n        int partial_sum = 0;\n        svint32_t acc = svaddv(pg, res);\n        partial_sum += svaddv(pg, acc);\n\n        result += partial_sum;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst){\n    if (lst.empty()) return 0;\n\n    int result = 0;\n    size_t vl = svcntw(); // Vector length in terms of the number of elements\n    size_t n = lst.size();\n\n    for (size_t i = 0; i < n; i += vl) {\n        svbool_t pg = svptrue_b32(); // Predicate for all true\n        size_t bound = (i + vl > n) ? n - i : vl;\n\n        // Load data\n        svint32_t vec = svld1(pg, reinterpret_cast<const int32_t *>(&lst[i]));\n\n        // Create predicates for multiples of 3 and 4\n        svbool_t p3 = svcmpe_true_b32(svand_x(pg, svidx(), svindex((int)i, (int)(i + vl))), 3);\n        svbool_t p4 = svcmpe_true_b32(svand_x(pg, svnot_x(pg, svidx()), svindex((int)i, (int)(i + vl))), 4);\n\n        // Square for multiples of 3\n        svint32_t squared = svmul_x(p3, vec, vec);\n\n        // Cube for multiples of 4 and not 3\n        svint32_t cubed = svmul_x(svptrue_b32(), svmul_x(p4, vec, vec), vec);\n\n        // Selectively update values\n        svint32_t updated = svsel(p3, squared, vec);\n        updated = svsel(p4, cubed, updated);\n\n        // Sum reduction\n        svint32_t acc = svdup_z(pg, 0);\n        acc = svadd(pg, acc, updated);\n\n        // Horizontal sum\n        int32x4_t res = svaddv(acc);\n        result += vaddvq_s32(res);\n\n        // Handle remaining elements\n        if (bound < vl) {\n            svbool_t pg_part = svcmp_lt_b32(svidx(), bound);\n            acc = svadd(pg_part, acc, svdup_z(pg_part, 0));\n            int32x4_t res_part = svaddv(acc);\n            result += vaddvq_s32(res_part);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst){\n    if (lst.empty()) return 0;\n\n    int result = 0;\n    size_t num_elements = lst.size();\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < num_elements; i += vl) {\n        size_t len = num_elements - i;\n        svbool_t pgl = svwhilelt_b32(i, num_elements);\n\n        // Load data\n        svint32_t vec = svld1_gather_index(pgl, lst.data(), i);\n\n        // Compute indices\n        svuint32_t indices = svindex_u32((uint32_t)i, 1);\n\n        // Check multiples of 3 and 4\n        svbool_t is_multiple_of_3 = svcmpeq_b32(pgl, svmul_x_u32(pg, svdup_n_u32(3), svdup_n_u32(3)), indices);\n        svbool_t is_multiple_of_4 = svcmpeq_b32(pgl, svmul_x_u32(pg, svdup_n_u32(4), svdup_n_u32(4)), indices);\n        svbool_t is_multiple_of_4_not_3 = svandnot_b32(pgl, is_multiple_of_4, is_multiple_of_3);\n\n        // Square if multiple of 3\n        svint32_t squared = svsqr_x_s32(is_multiple_of_3, vec);\n\n        // Cube if multiple of 4 and not 3\n        svint32_t cubed = svmul_x_s32(is_multiple_of_4_not_3, vec, vec);\n        cubed = svmul_x_s32(is_multiple_of_4_not_3, cubed, vec);\n\n        // Select original values where neither condition is true\n        svint32_t unchanged = svsel_s32(svnot_b32(pgl, svor_b32(is_multiple_of_3, is_multiple_of_4_not_3)), vec, vec);\n\n        // Combine results\n        svint32_t updated_vec = svsel_s32(is_multiple_of_3, squared, unchanged);\n        updated_vec = svsel_s32(is_multiple_of_4_not_3, cubed, updated_vec);\n\n        // Sum the vector elements\n        svint32_t partial_sum = svadd_x_s32(pgl, svdup_n_s32(0), updated_vec);\n        int temp_sum = 0;\n        for (size_t j = 0; j < svcntw(); ++j) {\n            temp_sum += svget_lane_s32(partial_sum, j);\n        }\n        result += temp_sum;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst){\n    if (lst.empty()) return 0;\n\n    int result = 0;\n    size_t vl = svcntw(); // Get the vector length in terms of the number of int elements\n    size_t n = lst.size();\n\n    for (size_t i = 0; i < n; i += vl) {\n        svbool_t pg = svptrue_b32(); // Predicate for all true\n        size_t len = n - i;\n        if (len < vl) pg = svwhilelt_b32(len, pg); // Adjust predicate if processing less than a full vector\n\n        // Load data\n        svint32_t vec = svld1(pg, &lst[i]);\n\n        // Create predicates for index conditions\n        svbool_t mod3 = svcmpeq(pg, svindex_s32(i, 1), svdup_n_s32(3));\n        svbool_t mod4 = svcmpeq(pg, svindex_s32(i, 1), svdup_n_s32(4));\n        svbool_t not_mod3 = svcmpne(pg, svindex_s32(i, 1), svdup_n_s32(3));\n\n        // Apply transformations based on predicates\n        svint32_t squared = svsqr_x(mod3, vec);\n        svint32_t cubed = svmul_x(svand_x(pg, mod4, not_mod3), vec, vec);\n        svint32_t unchanged = svsel(svnot_x(pg, svor_x(mod3, svand_x(pg, mod4, not_mod3))), vec, vec);\n\n        svint32_t transformed = svadd_x(pg, unchanged, svadd_x(pg, squared, cubed));\n\n        // Horizontal sum\n        int partial_sum = 0;\n        while (pg) {\n            svint32_t tmp = svadd_x(pg, transformed, svdup_n_s32(partial_sum));\n            partial_sum = svaddv(pg, tmp);\n            pg = svcompact(pg);\n        }\n        result += partial_sum;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums){\n    int result = 0;\n    size_t index = 0;\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    for (; index <= nums.size() - vl; index += vl) {\n        svint32_t svec = svld1(pg, reinterpret_cast<const int *>(&nums[index]));\n        \n        // Check if elements are greater than 10\n        svbool_t gt_10 = svcmpgt_n_s32(pg, svec, 10);\n\n        // Extract absolute value of numbers\n        svint32_t abs_vec = svabs(pg, svec);\n\n        // Function to extract last digit\n        auto last_digit = [](svint32_t vec) -> svint32_t {\n            return svmul_x_n_s32(svdivmod_x_n_s32(pg, vec, 10).second, 1);\n        };\n        svint32_t last_dig = last_digit(abs_vec);\n\n        // Function to extract first digit\n        auto first_digit = [](svint32_t vec) -> svint32_t {\n            svint32_t temp = vec;\n            while (svptest_any(pg, svcmpeq(pg, temp, temp))) {\n                temp = svdiv_x_n_s32(temp, 10);\n            }\n            return temp;\n        };\n        svint32_t first_dig = first_digit(abs_vec);\n\n        // Check if both first and last digits are odd\n        svbool_t last_odd = svand_x(pg, svtestb_x_u8(pg, svreinterpret_u8_s32(svadd_x_n_s32(last_dig, 1))), svcmpeq_n_u8(0, 0));\n        svbool_t first_odd = svand_x(pg, svtestb_x_u8(pg, svreinterpret_u8_s32(svadd_x_n_s32(first_dig, 1))), svcmpeq_n_u8(0, 0));\n\n        // Combine conditions\n        svbool_t cond = svand(pg, gt_10, svand(pg, last_odd, first_odd));\n        result += svpopcnt_b32(cond);\n    }\n\n    // Scalar cleanup for remaining elements\n    for (; index < nums.size(); ++index) {\n        int num = nums[index];\n        if (num > 10) {\n            int abs_num = std::abs(num);\n            int last_digit = abs_num % 10;\n            int first_digit = abs_num;\n            while (first_digit >= 10) {\n                first_digit /= 10;\n            }\n            if (last_digit % 2 != 0 && first_digit % 2 != 0) {\n                result++;\n            }\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums){\n    int result = 0;\n    if (nums.empty()) return result;\n\n    size_t vl = svcntw();\n    int *data = const_cast<int*>(nums.data());\n    size_t n = nums.size();\n\n    for (size_t i = 0; i < n; i += vl) {\n        svbool_t pg = svptrue_b32();\n        size_t count = (n - i > vl) ? vl : n - i;\n\n        svint32_t svec = svld1(pg, data + i);\n\n        // Check if elements are greater than 10\n        svbool_t gt_10 = svcmpgt_n_s32(pg, svec, 10);\n\n        // Extract absolute value to handle negatives\n        svuint32_t abs_vec = svmov_f32(svabs_s32(gt_10, svec));\n\n        // Compute first and last digits\n        svuint32_t last_digits = svmov_f32(svand_x_u32(pg, abs_vec, svdup_n_u32(9)));\n\n        svuint32_t divisors = svdup_n_u32(10);\n        svuint32_t first_digits = svmov_f32(abs_vec);\n        for (int j = 0; j < 9; ++j) {\n            svbool_t non_zero = svcmplt_x_u32(pg, first_digits, divisors);\n            first_digits = svdiv_x_u32(non_zero, first_digits, divisors);\n        }\n        first_digits = svmov_f32(svand_x_u32(pg, first_digits, svdup_n_u32(9)));\n\n        // Check if both first and last digits are odd\n        svbool_t first_odd = svtestbit_x_u32(pg, first_digits, 0);\n        svbool_t last_odd = svtestbit_x_u32(pg, last_digits, 0);\n\n        // Combine conditions\n        svbool_t cond = svand_b32(gt_10, svand_b32(first_odd, last_odd));\n        result += svcntp_b32(pg, cond);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums){\n    int result = 0;\n    size_t n = nums.size();\n    if (n == 0) return 0;\n\n    const int *data = nums.data();\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    size_t i = 0;\n    for (; i <= n - vl; i += vl) {\n        svint32_t vec = svld1(pg, &data[i]);\n        svbool_t gt_10 = svcmpgt_n_s32(pg, vec, 10);\n\n        // Extract last digit\n        svuint32_t abs_vec = svabs(pg, vec);\n        svuint32_t last_digit = svand_n_u32(pg, abs_vec, 9); // Mask to get last digit\n        svbool_t last_odd = svtestbits_u32(pg, last_digit, 0x55555555);\n\n        // Extract first digit\n        svuint32_t first_digit = abs_vec;\n        for (int j = 0; j < 9; ++j) { // Assume numbers are within 10 digits\n            svbool_t ge_10 = svcmple_n_u32(pg, first_digit, 10);\n            first_digit = svsel_u32(ge_10, first_digit, svudiv_n_u32(pg, first_digit, 10));\n        }\n        svbool_t first_odd = svtestbits_u32(pg, first_digit, 0x55555555);\n\n        // Combine conditions\n        svbool_t cond = svand_b32(gt_10, svand_b32(last_odd, first_odd));\n        result += svcntp_b32(pg, cond);\n    }\n\n    // Scalar tail processing\n    for (; i < n; ++i) {\n        int val = data[i];\n        if (val > 10) {\n            int abs_val = std::abs(val);\n            int last_digit = abs_val % 10;\n            int first_digit = abs_val;\n            while (first_digit >= 10) {\n                first_digit /= 10;\n            }\n            if ((last_digit & 1) && (first_digit & 1)) {\n                result++;\n            }\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums){\n    int count = 0;\n    size_t index = 0;\n    svbool_t pg = svptrue_b32();\n    const int threshold = 10;\n\n    while (index <= nums.size() - svcntw()) {\n        svint32_t vec = svld1(pg, &nums[index]);\n        \n        // Check if elements are greater than 10\n        svbool_t gt_10 = svcmpgt(vec, svdup_n_s32(threshold));\n        \n        // Extract absolute value for first and last digit checks\n        svint32_t abs_vec = svabs(vec);\n        \n        // Extract last digit\n        svint32_t last_digit = svand(abs_vec, svdup_n_s32(9));\n        \n        // Check if last digit is odd\n        svbool_t last_digit_odd = svtestbits_m(pg, last_digit, svdup_n_u32(1), 1);\n        \n        // Extract first digit (assuming numbers are within reasonable range)\n        svint32_t first_digit = sveor(abs_vec, svmls(abs_vec, svdup_n_s32(10), svdup_n_s32(0)));\n        svbool_t first_digit_odd = svtestbits_m(pg, first_digit, svdup_n_u32(1), 1);\n        \n        // Combine conditions\n        svbool_t condition = svand_b32(gt_10, svand_b32(last_digit_odd, first_digit_odd));\n        \n        // Count the number of elements satisfying the condition\n        count += svpopcnt(condition);\n        \n        index += svcntw();\n    }\n\n    // Scalar cleanup for remaining elements\n    for (; index < nums.size(); ++index) {\n        int num = nums[index];\n        if (num > 10 && ((abs(num) % 10) & 1) && ((abs(num) / static_cast<int>(pow(10, floor(log10(abs(num)))))) & 1)) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums){\n    int count = 0;\n    size_t vl = svcntw(); // Get the vector length in terms of the number of int elements\n    for(size_t i = 0; i < nums.size(); i += vl){\n        size_t j = i;\n        svbool_t pg = svptrue_b32(); // Predicate for all true\n        size_t k = (nums.size() - i) / vl; // Number of full vectors remaining\n        if(k == 0){\n            vl = nums.size() - i;\n            pg = svwhilelt_b32(i, nums.size());\n        }\n        svint32_t svec = svld1(pg, (int*)&nums[j]);\n        \n        // Check if numbers are greater than 10\n        svbool_t gt_10 = svcmpgt(pg, svec, svdup_n_s32(10));\n        \n        // Extract absolute values\n        svint32_t abs_vec = svabs(pg, svec);\n        \n        // Extract last digits\n        svint32_t last_digit = svand_x(pg, abs_vec, svdup_n_u32(0x0F));\n        \n        // Check if last digit is odd\n        svbool_t last_odd = svtestbits(pg, last_digit, svdup_n_u32(0x01));\n        \n        // Extract first digits\n        svuint32_t divisors = svlshr_u32(pg, abs_vec, svcntd());\n        svint32_t first_digit = svand_x(pg, divisors, svdup_n_u32(0x0F));\n        \n        // Check if first digit is odd\n        svbool_t first_odd = svtestbits(pg, first_digit, svdup_n_u32(0x01));\n        \n        // Combine conditions\n        svbool_t cond = svand_b32(gt_10, svand_b32(first_odd, last_odd));\n        \n        // Count the number of elements satisfying the condition\n        count += svcount_b32(cond);\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t get_max_triples_simd(uint64_t n){\n    if (n < 3) return 0;\n\n    uint64_t count = 0;\n    svbool_t pg = svptrue_b64();\n    svuint64_t index = svseq_u64(pg, 1);\n\n    // Compute the vector a using SVE intrinsics\n    svuint64_t a = svmls_x_u64(pg, svmul_x_u64(pg, index, index), index, 1);\n\n    // Determine modulo 3 for each element in vector a\n    svuint8_t mod3 = svsri_x_u8(pg, svaddv_u64(pg, svand_x_u64(pg, a, 2)), 0);\n\n    // Count triples where sum is divisible by 3\n    for (uint64_t i = 0; i < n - 2; ++i) {\n        for (uint64_t j = i + 1; j < n - 1; ++j) {\n            uint8_t mod_i = (i * i - i + 1) % 3;\n            uint8_t mod_j = (j * j - j + 1) % 3;\n            svbool_t mod_k_pg = svcmp_eq_u8(pg, mod3, svdup_n_u8((3 - (mod_i + mod_j)) % 3));\n            uint64_t k_start = j + 1;\n            uint64_t k_count = svcntw() - k_start;\n            svuint64_t indices = svadd_x_u64(pg, svindex_u64(k_start, 1), svdup_n_u64(0));\n            svbool_t in_range = svcmpge_u64(pg, indices, svdup_n_u64(k_start));\n            in_range = svand_b64(in_range, svcmpeq_u64(pg, indices, svsub_x_u64(pg, svdup_n_u64(n), svone_u64())));\n            count += svpopcnt_b64(svand_b64(mod_k_pg, in_range));\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t get_max_triples_simd(uint64_t n){\n    uint64_t count = 0;\n    if (n < 3) return 0;\n\n    // Determine SVE vector length in bits and elements\n    svbool_t pg = svptrue_b64();\n    int vl = svcntd();\n\n    // Allocate and compute the array 'a'\n    uint64_t *a = (uint64_t *)svmalloc(n * sizeof(uint64_t));\n    for (int i = 0; i < n; i += vl) {\n        svindex_s64 idx = svindex_s64(i, i + vl - 1);\n        svuint64_t vi = svadd_x(pg, svmul_x(pg, svdup_u64(1), idx), svdup_u64(1));\n        svst1_u64(pg, &a[i], svmls_x(pg, vi, svdup_u64(1), svdup_u64(1)));\n    }\n\n    // Count triples where a[i] + a[j] + a[k] is multiple of 3\n    for (int i = 0; i < n - 2; i++) {\n        for (int j = i + 1; j < n - 1; j++) {\n            svuint64_t v_a_i = svdup_u64(a[i]);\n            svuint64_t v_a_j = svdup_u64(a[j]);\n            svuint64_t v_sum = svadd_x(pg, v_a_i, v_a_j);\n\n            for (int k = j + 1; k < n; k += vl) {\n                int kl = (k + vl > n) ? (n - k) : vl;\n                svbool_t pgl = svwhilelt_b64(k, k + kl);\n                svuint64_t v_a_k = svld1_u64(pgl, &a[k]);\n                svuint64_t v_total = svadd_x(pgl, v_sum, v_a_k);\n                svuint64_t v_mod = svand_x(pgl, v_total, svdup_n_u64(2)); // mod 3\n                svuint64_t v_zero = svdup_n_u64(0);\n                svbool_t is_multiple = svcmpeq_x(pgl, v_mod, v_zero);\n                count += svmovemask_b64(is_multiple);\n            }\n        }\n    }\n\n    svfree(a);\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t get_max_triples_simd(uint64_t n){\n    uint64_t count = 0;\n    if (n < 3) return 0;\n\n    svbool_t pg = svptrue_b64();\n    svuint64_t index = svindex_u64(1, 1);\n    svuint64_t a_vec = svmla_sv(svmla_sv(svmul_x(pg, index, index), index, -1), pg, 1);\n\n    uint64_t *a = (uint64_t *)sv Interpret_z(pg, a_vec);\n\n    for (uint64_t i = 0; i < n - 2; ++i){\n        uint64_t rem_i = a[i] % 3;\n        for (uint64_t j = i + 1; j < n - 1; ++j){\n            uint64_t rem_j = a[j] % 3;\n            for (uint64_t k = j + 1; k < n; ++k){\n                uint64_t rem_k = a[k] % 3;\n                if ((rem_i + rem_j + rem_k) % 3 == 0){\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t get_max_triples_simd(uint64_t n){\n    uint64_t count = 0;\n    if (n < 3) return 0;\n\n    svbool_t pg = svptrue_b64();\n    svint64_t index = svindex_s64(1, 1);\n    svint64_t a_vec = svmla_m_s64(pg, svmul_m_s64(pg, index, index), index, -1);\n\n    int64_t remainder[3] = {0};\n    for (uint64_t i = 0; i < n; ++i) {\n        int64_t val = svindex_s64(1,1)[i] * svindex_s64(1,1)[i] - svindex_s64(1,1)[i] + 1;\n        remainder[val % 3]++;\n    }\n\n    // Count triples where (a[i] + a[j] + a[k]) % 3 == 0\n    count += remainder[0] * (remainder[0] - 1) * (remainder[0] - 2) / 6;\n    count += remainder[0] * remainder[1] * remainder[2];\n    count += remainder[1] * (remainder[1] - 1) / 2 * (n - 2 * remainder[1]);\n    count += remainder[2] * (remainder[2] - 1) / 2 * (n - 2 * remainder[2]);\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t get_max_triples_simd(uint64_t n){\n    if (n < 3) return 0;\n\n    uint64_t count = 0;\n    svbool_t pg = svptrue_b64();\n    svuint64_t zero = svdup_n_u64(pg, 0);\n\n    // Compute vector a\n    uint64_t a[n];\n    for (uint64_t i = 0; i < n; ++i) {\n        a[i] = (i + 1) * (i + 1) - (i + 1) + 1;\n    }\n\n    // Precompute mod3 values\n    uint8_t mod3[n];\n    for (uint64_t i = 0; i < n; ++i) {\n        mod3[i] = a[i] % 3;\n    }\n\n    // Count triples\n    for (uint64_t i = 0; i < n - 2; ++i) {\n        uint8_t mod_i = mod3[i];\n        for (uint64_t j = i + 1; j < n - 1; ++j) {\n            uint8_t mod_j = mod3[j];\n            uint8_t required_mod_k = (-mod_i - mod_j) % 3;\n            if (required_mod_k < 0) required_mod_k += 3;\n\n            svuint8_t required_mod_k_vec = svdup_n_u8(pg, required_mod_k);\n            svuint8_t mod3_vec = svdup_n_u8(pg, 0);\n\n            uint64_t k_start = j + 1;\n            uint64_t vl = svcntb();\n            uint64_t k = k_start;\n            for (; k + vl <= n; k += vl) {\n                svuint8_t mod3_load = svld1(pg, &mod3[k]);\n                svbool_t match = svcmpeq(pg, mod3_load, required_mod_k_vec);\n                svuint64_t ones = svdup_n_u64(pg, 1);\n                svuint64_t matches_count = svadd_x_u64(pg, zero, ones);\n                uint64_t matches = svaddv_u64(pg, matches_count);\n                count += matches;\n            }\n            for (; k < n; ++k) {\n                if (mod3[k] == required_mod_k) count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint x_or_y_simd(int n, int x, int y){\n    if (n < 2) return y;\n\n    svbool_t pg = svptrue_b32();\n    intvec_t n_vec = svdup_n_s32(n);\n    intvec_t is_prime = svdup_n_s32(1);\n\n    for(int i=2; i*i <= n; i++){\n        intvec_t i_vec = svdup_n_s32(i);\n        intvec_t remainder = svmla_s32(pg, n_vec, svrecpe_u32(pg, i_vec), -svrsqrte_u32(pg, i_vec));\n        svbool_t is_divisible = svcmpeq(pg, remainder, svdup_n_s32(0));\n        is_prime = svand_b32(pg, is_prime, svnot_b32(pg, is_divisible));\n    }\n\n    int result;\n    if(svptest_any(svptrue_b32(), is_prime)){\n        result = x;\n    }\n    else{\n        result = y;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint x_or_y_simd(int n, int x, int y){\n    if (n < 2) return y;\n\n    svbool_t pg = svptrue_b32();\n    int result = y;\n\n    for (int i = 2; i * i <= n; i++) {\n        svint32_t sn = svdup_n_s32(n);\n        svint32_t si = svdup_n_s32(i);\n        svint32_t remainder = svmla_s32(pg, sn, svdup_n_s32(0), -si);\n        svbool_t is_zero = svcmpeq(pg, remainder, svdup_n_s32(0));\n        if (svptest_any(svptrue_b32(), is_zero)) {\n            return y;\n        }\n    }\n\n    result = x;\n    return result;\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint x_or_y_simd(int n, int x, int y){\n    if (n <= 1) return y;\n\n    svbool_t pg = svptrue_b32();\n    int result = y;\n\n    // Check for factors up to sqrt(n)\n    int limit = (int)svmin_n_s32(sv reinterpret_s32(pg, n), (int)(sqrt((double)n)));\n\n    svint32_t vec_n = svdup_n_s32(pg, n);\n    svint32_t vec_x = svdup_n_s32(pg, x);\n    svint32_t vec_y = svdup_n_s32(pg, y);\n\n    for (int i = 2; i <= limit; i++) {\n        svint32_t vec_i = svdup_n_s32(pg, i);\n        svbool_t is_factor = svcmpeq(pg, svmul_x_s32(pg, vec_i, vec_i), vec_n);\n        if (svptest_any(svptrue_b1(), is_factor)) {\n            return y;\n        }\n    }\n\n    return x;\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint x_or_y_simd(int n, int x, int y){\n    if (n < 2) return y;\n\n    svbool_t pg = svptrue_b32();\n    int result = y;\n\n    svint32_t sn = svdup_n_s32(n);\n    svint32_t sx = svdup_n_s32(x);\n    svint32_t sy = svdup_n_s32(y);\n\n    for (int i = 2; i * i <= n; i++) {\n        svint32_t si = svdup_n_s32(i);\n        svbool_t pred = svceq_z(pg, svmod_u32(pg, sn, si), svdup_n_s32(0));\n        if (svptest_any(svptrue_b1(), pred)) {\n            return y;\n        }\n    }\n\n    result = x;\n    return result;\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint x_or_y_simd(int n, int x, int y){\n    if (n < 2) return y;\n\n    svbool_t pg = svptrue_b32();\n    int result = y;\n\n    svint32_t sn = svdup_n_s32(n);\n    svint32_t sx = svdup_n_s32(x);\n    svint32_t sy = svdup_n_s32(y);\n\n    for(int i=2; i*i <= n; i++) {\n        svint32_t si = svdup_n_s32(i);\n        svbool_t pred = svceq_z(pg, svmod_z(pg, sn, si), svdup_n_s32(0));\n        if(svptest_any(svptrue_b1(), pred)) {\n            return y;\n        }\n    }\n\n    result = x;\n    return result;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst){\n    if (lst.empty()) return 0;\n\n    uint64_t sum = 0;\n    size_t vl = svcntw();\n    svbool_t pg = svptrue_b32();\n\n    for (size_t i = 0; i < lst.size(); i += vl) {\n        size_t n = lst.size() - i;\n        svbool_t pgn = svwhilelt_b32(i, i + vl);\n        svfloat32_t vec = svld1_f32(pgn, &lst[i]);\n\n        // Check if the numbers are integers\n        svint32_t casted = svmov_n_s32(0);\n        casted = svcvt_f32s32_x(pg, svrintz_f32(pg, vec));\n        svbool_t is_int = svcmpeq_b32(pg, vec, svcvt_f32s32_x(pg, casted));\n\n        // Check if the integers are positive and odd\n        svbool_t is_positive = svcmplt_b32(pg, svcvt_f32s32_x(pg, casted), svdup_f32(0.0f));\n        svbool_t is_odd = svtestbit_b32(pg, casted, 1);\n        svbool_t condition = svand_b32(is_int, svand_b32(svnot_b32(is_positive), is_odd));\n\n        // Square the values that meet the condition\n        svfloat32_t squared = svmla_f32(pg, vec, vec, svdup_f32(0.0f));\n        svfloat32_t masked_squared = svsel_f32(condition, squared, svdup_f32(0.0f));\n\n        // Accumulate the sum of squares\n        float partial_sum = 0.0f;\n        for (size_t j = 0; j < vl; ++j) {\n            partial_sum += svget_f32(masked_squared, j);\n        }\n        sum += static_cast<uint64_t>(partial_sum);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <stdint.h>\n#include <vector>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst){\n    if (lst.empty()) return 0;\n\n    uint64_t sum = 0;\n    size_t vl = svcntw();\n    svbool_t pg = svptrue_b32();\n\n    const float *data = lst.data();\n    size_t size = lst.size();\n\n    for (size_t i = 0; i < size; i += vl) {\n        size_t n = svcvt_size(size - i);\n        svbool_t pgn = svwhilelt_b32(i, size);\n\n        svfloat32_t vec = svld1(pgn, data + i);\n\n        // Check for positive and integer values\n        svint32_t casted = svmov_n_s32(0);\n        casted = svreinterpret_s32_f32(svrintz(vec));\n        svbool_t is_positive = svcmpge(vec, svdup_f32(0.0f), pgn);\n        svbool_t is_equal = svcmpeq(vec, svfcvt_f32s32_x(svreinterpret_f32_s32(casted)), pgn);\n        svbool_t valid = svand(is_positive, is_equal);\n\n        // Extract integers\n        svint32_t ints = svsel(valid, casted, svmov_n_s32(0));\n\n        // Check for odd numbers\n        svbool_t is_odd = svtestbit_n_b32(ints, 0, valid);\n\n        // Square the odd numbers\n        svint32_t squared = svmul_x(is_odd, ints, ints);\n\n        // Sum the squares\n        svuint64_t partial_sum = svaddv(pg, svreinterpret_u64_s32(squared));\n        sum += svaddv_u64(pg, partial_sum);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst){\n    uint64_t result = 0;\n    if (lst.empty()) return result;\n\n    size_t vl = svcntw();\n    svbool_t pg = svptrue_b32();\n\n    for(size_t i = 0; i < lst.size(); i += vl){\n        size_t n = lst.size() - i;\n        svbool_t pred = svwhilelt_b32(i, lst.size());\n        \n        svfloat32_t vec = svld1_f32(pred, &lst[i]);\n        \n        // Check for non-negative and integer values\n        svint32_t casted = svmov_n_s32(0);\n        casted = svreinterpret_s32_f32(svfcvt_x_f32(pred, vec));\n        svbool_t is_integer = svcmpeq_z_b32(pred, casted, svreinterpret_s32_f32(vec));\n        svbool_t is_non_negative = svcmpge_z_b32(pred, casted, svdup_n_s32(0));\n        svbool_t valid = svand_z_b32(pg, is_integer, is_non_negative);\n\n        // Check for odd numbers\n        svbool_t is_odd = svtestbit_z_b32(valid, casted, 0);\n        \n        // Square the odd numbers\n        svint32_t squared = svmul_x_s32(is_odd, casted, casted);\n        \n        // Accumulate the sum of squares\n        int32x4_t partial_sum = svaddv_s32(is_odd, squared);\n        result += svaddv_s32(pg, partial_sum);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst){\n    if (lst.empty()) return 0;\n\n    uint64_t sum = 0;\n    size_t num_elements = lst.size();\n    svbool_t pg = svptrue_b32();\n    const float *data = lst.data();\n\n    for (size_t i = 0; i <= num_elements - svcntw(); i += svcntw()) {\n        svfloat32_t vec = svld1_f32(pg, &data[i]);\n        svint32_t vec_int = svcvt_n_s32_f32(pg, vec);\n        svfloat32_t vec_reconverted = svcvt_n_f32_s32(pg, vec_int);\n\n        svbool_t is_odd = svand_b32(pg, svcmpeq(pg, vec_reconverted, vec), svtest_bitwise_and(pg, svcaddv_n_u32(pg, vec_int, 1), svdup_n_u32(1)));\n        svbool_t is_positive = svcmpge_f32(pg, vec, svdup_n_f32(0.0f));\n        svbool_t pred = svand_b32(pg, is_odd, is_positive);\n\n        svfloat32_t squared = svmla_f32(pred, vec, vec, svdup_n_f32(0.0f));\n        float partial_sum = svaddv_f32(pg, squared);\n        sum += static_cast<uint64_t>(partial_sum);\n    }\n\n    // Handle remaining elements\n    size_t i = svcntw() * (num_elements / svcntw());\n    if (i < num_elements) {\n        svbool_t pg_remainder = svwhilelt_b32(i, static_cast<int>(num_elements));\n        svfloat32_t vec = svld1_f32(pg_remainder, &data[i]);\n        svint32_t vec_int = svcvt_n_s32_f32(pg_remainder, vec);\n        svfloat32_t vec_reconverted = svcvt_n_f32_s32(pg_remainder, vec_int);\n\n        svbool_t is_odd = svand_b32(pg_remainder, svcmpeq(pg_remainder, vec_reconverted, vec), svtest_bitwise_and(pg_remainder, svcaddv_n_u32(pg_remainder, vec_int, 1), svdup_n_u32(1)));\n        svbool_t is_positive = svcmpge_f32(pg_remainder, vec, svdup_n_f32(0.0f));\n        svbool_t pred = svand_b32(pg_remainder, is_odd, is_positive);\n\n        svfloat32_t squared = svmla_f32(pred, vec, vec, svdup_n_f32(0.0f));\n        float partial_sum = svaddv_f32(pg_remainder, squared);\n        sum += static_cast<uint64_t>(partial_sum);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <cstdint>\n#include <vector>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst){\n    if (lst.empty()) return 0;\n\n    uint64_t result = 0;\n    size_t vl = svcntw();\n    svbool_t pg = svptrue_b32();\n\n    for(size_t i = 0; i < lst.size(); i += vl){\n        size_t n = lst.size() - i;\n        svbool_t pred = svwhilelt_b32(i, n);\n\n        svfloat32_t vec = svld1_f32(pred, &lst[i]);\n        svint32_t casted = svcvt_x_f32(pred, vec);\n        svfloat32_t rounded = svcvt_f32_x(pred, casted);\n\n        svbool_t is_odd = svand_x_b32(pred, svisodd_x_b32(pred, casted), svcmpeq_f32(pred, vec, rounded));\n        svfloat32_t squared = svmul_f32(pred, vec, vec);\n        svfloat32_t masked_squared = svsel_f32(pred, squared, svdup_f32(0.0f), is_odd);\n\n        float sum = 0.0f;\n        for(size_t j = 0; j < vl; ++j){\n            if(svtest_any_b32(svptrue_b32(), svand_b32(svptrue_b32(), pred, is_odd))){\n                sum += masked_squared[j];\n            }\n        }\n        result += static_cast<uint64_t>(sum);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess){\n    size_t n = game.size();\n    std::vector<int> result(n);\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        size_t num_elts = n - i;\n        svbool_t pg = svptrue_b32();\n        if (num_elts < svcntw()) {\n            pg = svwhilelt_b32(i, (int)n);\n        }\n\n        svint32_t vg = svld1(pg, &game[i]);\n        svint32_t vs = svld1(pg, &guess[i]);\n\n        svint32_t diff = svsub_x(pg, vg, vs);\n        svint32_t abs_diff = svabs(pg, diff);\n\n        svst1(pg, &result[i], abs_diff);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess){\n    size_t n = game.size();\n    std::vector<int> result(n, 0);\n\n    if (n == 0) return result;\n\n    size_t i = 0;\n    svbool_t pg = svptrue_b32(); // Predicate for all true\n\n    while (i + svcntw() <= n) {\n        // Load vectors\n        svint32_t vg = svld1(pg, &game[i]);\n        svint32_t vs = svld1(pg, &guess[i]);\n\n        // Compute absolute difference\n        svint32_t diff = svabs(pg, svsub(pg, vg, vs));\n\n        // Store results\n        svst1(pg, &result[i], diff);\n\n        i += svcntw();\n    }\n\n    // Handle leftover elements\n    if (i < n) {\n        size_t left = n - i;\n        svbool_t pleft = svwhilelt_b32(i, n);\n\n        // Load vectors\n        svint32_t vg = svld1(pleft, &game[i]);\n        svint32_t vs = svld1(pleft, &guess[i]);\n\n        // Compute absolute difference\n        svint32_t diff = svabs(pleft, svsub(pleft, vg, vs));\n\n        // Store results\n        svst1(pleft, &result[i], diff);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess){\n    size_t n = game.size();\n    std::vector<int> result(n);\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        svbool_t pg = svptrue_b32();\n        size_t num = n - i;\n        size_t vl = svcntw();\n        if (num < vl) {\n            pg = svwhilelt_b32(num, vl);\n        }\n\n        svint32_t vg = svld1(pg, &game[i]);\n        svint32_t vs = svld1(pg, &guess[i]);\n\n        svint32_t diff = svsub_x(pg, vg, vs);\n        svint32_t abs_diff = svabs_x(pg, diff);\n\n        svst1(pg, &result[i], abs_diff);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess){\n    size_t n = game.size();\n    std::vector<int> result(n);\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        size_t vl = n - i;\n        if (vl > svcntw()) vl = svcntw();\n\n        svbool_t pg = svptrue_b32();\n        svint32_t vg = svld1(pg, &game[i]);\n        svint32_t vs = svld1(pg, &guess[i]);\n\n        svint32_t diff = svsub_x(pg, vg, vs);\n        svuint32_t abs_diff = svasr_uu_x(pg, svabs_x(pg, diff), 0);\n\n        svst1(pg, &result[i], abs_diff);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess){\n    size_t n = game.size();\n    std::vector<int> result(n);\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        svbool_t pg = svptrue_b32();\n        svint32_t vg = svld1(pg, &game[i]);\n        svint32_t vs = svld1(pg, &guess[i]);\n\n        svint32_t diff = svsub_x(pg, vg, vs);\n        svint32_t abs_diff = svabs_x(pg, diff);\n\n        svst1(pg, &result[i], abs_diff);\n    }\n\n    return result;\n}\n```"}

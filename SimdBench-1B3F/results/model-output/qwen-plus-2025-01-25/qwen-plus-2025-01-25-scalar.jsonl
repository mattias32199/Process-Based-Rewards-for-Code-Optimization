{"task_id": "SimdBench_0", "completion": "```c\nvoid conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0", "completion": "```c\nvoid conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0", "completion": "```c\nvoid conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0", "completion": "```c\nvoid conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0", "completion": "```c\nvoid conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_1", "completion": "```c\nvoid load_modify_store(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        int element = src[i];\n        int tmp1 = (element * scale) >> 3;\n        int tmp2 = (element * scale) << 3;\n        int result = (element * scale + tmp1 * tmp2) / 7;\n        dst[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_1", "completion": "```c\nvoid load_modify_store(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int element = src[i];\n        int tmp1 = (element * scale) >> 3;\n        int tmp2 = (element * scale) << 3;\n        dst[i] = (element * scale + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1", "completion": "```c\nvoid load_modify_store(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int element = src[i];\n        int tmp1 = (element * scale) >> 3;\n        int tmp2 = (element * scale) << 3;\n        dst[i] = (element * scale + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1", "completion": "```c\nvoid load_modify_store(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int element = src[i];\n        int tmp1 = (element * scale) >> 3;\n        int tmp2 = (element * scale) << 3;\n        dst[i] = (element * scale + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1", "completion": "```c\nvoid load_modify_store(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int element = src[i];\n        int tmp1 = (element * scale) >> 3;\n        int tmp2 = (element * scale) << 3;\n        dst[i] = (element * scale + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_2", "completion": "```c\nvoid strided_load_store(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; r++) {\n        dst[r] = src[r * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2", "completion": "```c\nvoid strided_load_store(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; r++) {\n        dst[r] = src[r * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2", "completion": "```c\nvoid strided_load_store(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; r++) {\n        dst[r] = src[r * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2", "completion": "```c\nvoid strided_load_store(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; r++) {\n        dst[r] = src[r * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2", "completion": "```c\nvoid strided_load_store(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; r++) {\n        dst[r] = src[r * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_3", "completion": "```c\nvoid indexed_access(const float *src, const int *indices, float *dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = src[indices[i]]; // Gather operation\n    }\n    for (size_t i = 0; i < length; ++i) {\n        dst[indices[i]] = src[i]; // Scatter operation\n    }\n}\n```"}
{"task_id": "SimdBench_3", "completion": "```c\nvoid indexed_access(const float *src, const int *indices, float *dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = src[indices[i]]; // Gather operation\n    }\n    for (size_t i = 0; i < length; ++i) {\n        dst[indices[i]] = src[i]; // Scatter operation\n    }\n}\n```"}
{"task_id": "SimdBench_3", "completion": "```c\nvoid indexed_access(const float *src, const int *indices, float *dst, size_t length) {\n    // Gather operation\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = src[indices[i]];\n    }\n\n    // Scatter operation\n    for (size_t i = 0; i < length; ++i) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3", "completion": "```c\nvoid indexed_access(const float *src, const int *indices, float *dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = src[indices[i]]; // Gather operation\n    }\n    for (size_t i = 0; i < length; ++i) {\n        dst[indices[i]] = src[i]; // Scatter operation\n    }\n}\n```"}
{"task_id": "SimdBench_3", "completion": "```c\nvoid indexed_access(const float *src, const int *indices, float *dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = src[indices[i]]; // Gather operation\n    }\n    for (size_t i = 0; i < length; ++i) {\n        dst[indices[i]] = src[i]; // Scatter operation\n    }\n}\n```"}
{"task_id": "SimdBench_4", "completion": "```c\nvoid range_reverse(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start < end) {\n        int16_t temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n```"}
{"task_id": "SimdBench_4", "completion": "```c\nvoid range_reverse(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start < end) {\n        int16_t temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n```"}
{"task_id": "SimdBench_4", "completion": "```c\nvoid range_reverse(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start < end) {\n        int16_t temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n```"}
{"task_id": "SimdBench_4", "completion": "```c\nvoid range_reverse(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start < end) {\n        int16_t temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n```"}
{"task_id": "SimdBench_4", "completion": "```c\nvoid range_reverse(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start < end) {\n        int16_t temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n```"}
{"task_id": "SimdBench_5", "completion": "```c\nvoid extract_tensor_slice(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t offset = slice_idx * dim1 * dim2;\n    for (size_t i = 0; i < dim1; i++) {\n        for (size_t j = 0; j < dim2; j++) {\n            slice[i * dim2 + j] = tensor[offset + i * dim2 + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5", "completion": "```c\nvoid extract_tensor_slice(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_offset = slice_idx * dim1 * dim2;\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            size_t src_idx = slice_offset + i * dim2 + j;\n            size_t dst_idx = i * dim2 + j;\n            slice[dst_idx] = tensor[src_idx];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5", "completion": "```c\nvoid extract_tensor_slice(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t offset = slice_idx * dim1 * dim2;\n    for (size_t i = 0; i < dim1 * dim2; ++i) {\n        slice[i] = tensor[offset + i];\n    }\n}\n```"}
{"task_id": "SimdBench_5", "completion": "```c\nvoid extract_tensor_slice(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_offset = slice_idx * dim1 * dim2;\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            size_t src_idx = slice_offset + i * dim2 + j;\n            size_t dst_idx = i * dim2 + j;\n            slice[dst_idx] = tensor[src_idx];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5", "completion": "```c\nvoid extract_tensor_slice(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t offset = slice_idx * dim1 * dim2;\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            slice[i * dim2 + j] = tensor[offset + i * dim2 + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6", "completion": "```c\nvoid blocked_matrix_transpose(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t ii = i; ii < i + block_size && ii < rows; ii++) {\n                for (size_t jj = j; jj < j + block_size && jj < cols; jj++) {\n                    dst[jj * rows + ii] = src[ii * cols + jj];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6", "completion": "```c\nvoid blocked_matrix_transpose(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t ii = i; ii < i + block_size && ii < rows; ii++) {\n                for (size_t jj = j; jj < j + block_size && jj < cols; jj++) {\n                    dst[jj * rows + ii] = src[ii * cols + jj];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6", "completion": "```c\nvoid blocked_matrix_transpose(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t ii = i; ii < i + block_size && ii < rows; ii++) {\n                for (size_t jj = j; jj < j + block_size && jj < cols; jj++) {\n                    dst[jj * rows + ii] = src[ii * cols + jj];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6", "completion": "```c\nvoid blocked_matrix_transpose(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t ii = i; ii < i + block_size && ii < rows; ii++) {\n                for (size_t jj = j; jj < j + block_size && jj < cols; jj++) {\n                    dst[jj * rows + ii] = src[ii * cols + jj];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6", "completion": "```c\nvoid blocked_matrix_transpose(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t ii = i; ii < i + block_size && ii < rows; ii++) {\n                for (size_t jj = j; jj < j + block_size && jj < cols; jj++) {\n                    dst[jj * rows + ii] = src[ii * cols + jj];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_7", "completion": "```c\nfloat diagonal_sum_3d(const float *array, size_t dim) {\n    float sum = 0.0;\n    for (size_t i = 0; i < dim; i++) {\n        size_t index = i * (dim * dim + dim + 1);\n        sum += array[index];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7", "completion": "```c\nfloat diagonal_sum_3d(const float *array, size_t dim) {\n    float sum = 0.0;\n    for (size_t i = 0; i < dim; i++) {\n        size_t index = i * (dim * dim + dim + 1);\n        sum += array[index];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7", "completion": "```c\nfloat diagonal_sum_3d(const float *array, size_t dim) {\n    float sum = 0.0;\n    for (size_t i = 0; i < dim; i++) {\n        size_t index = i * (dim * dim + dim + 1);\n        sum += array[index];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7", "completion": "```c\nfloat diagonal_sum_3d(const float *array, size_t dim) {\n    float sum = 0.0;\n    for (size_t i = 0; i < dim; i++) {\n        size_t index = i * (dim * dim + dim + 1);\n        sum += array[index];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7", "completion": "```c\nfloat diagonal_sum_3d(const float *array, size_t dim) {\n    float sum = 0.0;\n    for (size_t i = 0; i < dim; i++) {\n        size_t index = i * (dim * dim + dim + 1);\n        sum += array[index];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_8", "completion": "```c\nvoid conditional_scale(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t size = rows * cols;\n    for (size_t i = 0; i < size; ++i) {\n        if (src[i] > threshold) {\n            dst[i] = src[i] * scale;\n        } else {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8", "completion": "```c\nvoid conditional_scale(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t size = rows * cols;\n    for (size_t i = 0; i < size; ++i) {\n        if (src[i] > threshold) {\n            dst[i] = src[i] * scale;\n        } else {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8", "completion": "```c\nvoid conditional_scale(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t size = rows * cols;\n    for (size_t i = 0; i < size; ++i) {\n        if (src[i] > threshold) {\n            dst[i] = src[i] * scale;\n        } else {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8", "completion": "```c\nvoid conditional_scale(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    for (size_t i = 0; i < total_elements; ++i) {\n        if (src[i] > threshold) {\n            dst[i] = src[i] * scale;\n        } else {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8", "completion": "```c\nvoid conditional_scale(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total = rows * cols;\n    for (size_t i = 0; i < total; ++i) {\n        dst[i] = src[i] > threshold ? src[i] * scale : src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_9", "completion": "```c\nvoid reorder_matrix_rows(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; ++i) {\n        size_t src_row_idx = indices[i];\n        if (src_row_idx >= rows) continue; // Skip invalid indices\n        for (size_t j = 0; j < cols; ++j) {\n            dst[i * cols + j] = src[src_row_idx * cols + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9", "completion": "```c\nvoid reorder_matrix_rows(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t src_row_idx = indices[i];\n        if (src_row_idx >= rows) continue; // Skip invalid indices\n        for (size_t j = 0; j < cols; j++) {\n            dst[i * cols + j] = src[src_row_idx * cols + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9", "completion": "```c\nvoid reorder_matrix_rows(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t src_row_idx = indices[i];\n        if (src_row_idx >= rows) continue; // Skip invalid indices\n        for (size_t j = 0; j < cols; j++) {\n            dst[i * cols + j] = src[src_row_idx * cols + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9", "completion": "```c\nvoid reorder_matrix_rows(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t src_row_idx = indices[i];\n        if (src_row_idx >= rows) continue; // Skip invalid indices\n        for (size_t j = 0; j < cols; j++) {\n            dst[i * cols + j] = src[src_row_idx * cols + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9", "completion": "```c\nvoid reorder_matrix_rows(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t src_row_idx = indices[i];\n        if (src_row_idx >= rows) continue; // Skip invalid indices\n        for (size_t j = 0; j < cols; j++) {\n            dst[i * cols + j] = src[src_row_idx * cols + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_10", "completion": "```c\nvoid vector_vector_add(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int64_t sum = src1[i] + src2[i] + scalar;\n        dst[i] = sum / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10", "completion": "```c\nvoid vector_vector_add(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10", "completion": "```c\nvoid vector_vector_add(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int64_t sum = src1[i] + src2[i] + scalar;\n        dst[i] = sum / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10", "completion": "```c\nvoid vector_vector_add(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int64_t sum = src1[i] + src2[i] + scalar;\n        dst[i] = sum / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10", "completion": "```c\nvoid vector_vector_add(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int64_t sum = src1[i] + src2[i] + scalar;\n        dst[i] = sum / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_11", "completion": "```c\nint vector_even_min(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    int min = INT32_MAX;\n    int found = 0;\n\n    for (size_t i = 0; i < length; i++) {\n        if (src[i] % 2 == 0) {\n            found = 1;\n            if (src[i] < min) {\n                min = src[i];\n            }\n        }\n    }\n\n    return found ? min : -1;\n}\n```"}
{"task_id": "SimdBench_11", "completion": "```c\nint vector_even_min(const int *src, size_t length){\n    if (length == 0) return -1;\n\n    int min = INT32_MAX;\n    int has_even = 0;\n\n    for(size_t i = 0; i < length; i++){\n        if(src[i] % 2 == 0){\n            has_even = 1;\n            if(src[i] < min){\n                min = src[i];\n            }\n        }\n    }\n\n    return (has_even) ? min : -1;\n}\n```"}
{"task_id": "SimdBench_11", "completion": "```c\nint vector_even_min(const int *src, size_t length){\n    if (length == 0) return -1;\n\n    int min_val = INT32_MAX;\n    int found_even = 0;\n\n    for(size_t i = 0; i < length; i++){\n        if(src[i] % 2 == 0){\n            found_even = 1;\n            if(src[i] < min_val){\n                min_val = src[i];\n            }\n        }\n    }\n\n    return found_even ? min_val : -1;\n}\n```"}
{"task_id": "SimdBench_11", "completion": "```c\nint vector_even_min(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    int min_val = INT32_MAX;\n    for (size_t i = 0; i < length; i++) {\n        if (src[i] % 2 == 0 && src[i] < min_val) {\n            min_val = src[i];\n        }\n    }\n\n    return (min_val == INT32_MAX) ? -1 : min_val;\n}\n```"}
{"task_id": "SimdBench_11", "completion": "```c\nint vector_even_min(const int *src, size_t length){\n    if (length == 0) return -1;\n\n    int min = INT32_MAX;\n    int found = 0;\n\n    for(size_t i = 0; i < length; i++){\n        if(src[i] % 2 == 0){\n            if(src[i] < min){\n                min = src[i];\n                found = 1;\n            }\n        }\n    }\n\n    return found ? min : -1;\n}\n```"}
{"task_id": "SimdBench_12", "completion": "```c\nvoid mixed_right_shift(const int *src, int *dst, uint8_t shift, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int arithmetic_shift = src[i] >> shift;\n        int logical_shift = (int)((unsigned int)src[i] >> shift);\n        dst[i] = arithmetic_shift + logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12", "completion": "```c\nvoid mixed_right_shift(const int *src, int *dst, uint8_t shift, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        int arithmetic_shift = src[i] >> shift;\n        int logical_shift = (int)((unsigned int)src[i] >> shift);\n        dst[i] = arithmetic_shift + logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12", "completion": "```c\nvoid mixed_right_shift(const int *src, int *dst, uint8_t shift, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int arithmetic_shift = src[i] >> shift;\n        int logical_shift = (int)((unsigned int)src[i] >> shift);\n        dst[i] = arithmetic_shift + logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12", "completion": "```c\nvoid mixed_right_shift(const int *src, int *dst, uint8_t shift, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        int arithmetic_shift = src[i] >> shift;\n        int logical_shift = (int)((unsigned int)src[i] >> shift);\n        dst[i] = arithmetic_shift + logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12", "completion": "```c\nvoid mixed_right_shift(const int *src, int *dst, uint8_t shift, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        int arithmetic_shift = src[i] >> shift;\n        int logical_shift = (int)((unsigned int)src[i] >> shift);\n        dst[i] = arithmetic_shift + logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_13", "completion": "```c\nint64_t matrix_sum(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < rows * cols; i++) {\n        sum += matrix[i];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13", "completion": "```c\nint64_t matrix_sum(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < rows * cols; i++) {\n        sum += matrix[i];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13", "completion": "```c\nint64_t matrix_sum(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < rows * cols; i++) {\n        sum += matrix[i];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13", "completion": "```c\nint64_t matrix_sum(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < rows * cols; i++) {\n        sum += matrix[i];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13", "completion": "```c\nint64_t matrix_sum(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < rows * cols; i++) {\n        sum += matrix[i];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_14", "completion": "```c\nsize_t argmax(const int8_t *src, size_t length) {\n    if (length == 0 || src == NULL) {\n        return 0;\n    }\n    size_t max_idx = 0;\n    int8_t max_val = src[0];\n    for (size_t i = 1; i < length; ++i) {\n        if (src[i] > max_val) {\n            max_val = src[i];\n            max_idx = i;\n        }\n    }\n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_14", "completion": "```c\nsize_t argmax(const int8_t *src, size_t length) {\n    if (length == 0 || src == NULL) return 0;\n    \n    size_t max_index = 0;\n    int8_t max_value = src[0];\n    \n    for (size_t i = 1; i < length; ++i) {\n        if (src[i] > max_value) {\n            max_value = src[i];\n            max_index = i;\n        }\n    }\n    \n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14", "completion": "```c\nsize_t argmax(const int8_t *src, size_t length) {\n    if (length == 0 || src == NULL) return 0;\n\n    size_t max_idx = 0;\n    int8_t max_val = src[0];\n\n    for (size_t i = 1; i < length; ++i) {\n        if (src[i] > max_val) {\n            max_val = src[i];\n            max_idx = i;\n        }\n    }\n\n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_14", "completion": "```c\nsize_t argmax(const int8_t *src, size_t length) {\n    if (length == 0 || src == NULL) return 0;\n    \n    size_t max_idx = 0;\n    int8_t max_val = src[0];\n    \n    for (size_t i = 1; i < length; ++i) {\n        if (src[i] > max_val) {\n            max_val = src[i];\n            max_idx = i;\n        }\n    }\n    \n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_14", "completion": "```c\nsize_t argmax(const int8_t *src, size_t length) {\n    if (length == 0 || src == NULL) return 0;\n\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n\n    for (size_t i = 1; i < length; ++i) {\n        if (src[i] > max_value) {\n            max_value = src[i];\n            max_index = i;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_15", "completion": "```c\nvoid vector_blend(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if ((i & mask) != 0) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15", "completion": "```c\nvoid vector_blend(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if ((i & mask) != 0) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15", "completion": "```c\nvoid vector_blend(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if ((i & mask) != 0) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15", "completion": "```c\nvoid vector_blend(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if ((i & mask) != 0) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15", "completion": "```c\nvoid vector_blend(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if ((i & mask) != 0) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_16", "completion": "```c\nvoid population_count(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        uint32_t count = 0;\n        uint32_t num = src[i];\n        while (num) {\n            count += num & 1;\n            num >>= 1;\n        }\n        dst[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_16", "completion": "```c\nvoid population_count(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t count = 0;\n        uint32_t num = src[i];\n        while (num) {\n            count += num & 1;\n            num >>= 1;\n        }\n        dst[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_16", "completion": "```c\nvoid population_count(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t count = 0;\n        uint32_t num = src[i];\n        while (num) {\n            count += num & 1;\n            num >>= 1;\n        }\n        dst[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_16", "completion": "```c\nvoid population_count(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t count = 0;\n        uint32_t num = src[i];\n        while (num) {\n            count += num & 1;\n            num >>= 1;\n        }\n        dst[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_16", "completion": "```c\nvoid population_count(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t count = 0;\n        uint32_t num = src[i];\n        while (num) {\n            count += num & 1;\n            num >>= 1;\n        }\n        dst[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_17", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid saturating_add(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        uint32_t sum = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = (sum > UINT16_MAX) ? UINT16_MAX : (uint16_t)sum;\n    }\n}\n```"}
{"task_id": "SimdBench_17", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid saturating_add(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        uint32_t sum = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = (sum > UINT16_MAX) ? UINT16_MAX : (uint16_t)sum;\n    }\n}\n```"}
{"task_id": "SimdBench_17", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid saturating_add(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        uint32_t sum = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = (sum > UINT16_MAX) ? UINT16_MAX : (uint16_t)sum;\n    }\n}\n```"}
{"task_id": "SimdBench_17", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid saturating_add(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        uint32_t sum = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = (sum > UINT16_MAX) ? UINT16_MAX : (uint16_t)sum;\n    }\n}\n```"}
{"task_id": "SimdBench_17", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid saturating_add(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        uint32_t sum = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = (sum > UINT16_MAX) ? UINT16_MAX : (uint16_t)sum;\n    }\n}\n```"}
{"task_id": "SimdBench_18", "completion": "```c\nvoid range_matrix_mul(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                double val_a = A[i * n + k];\n                double val_b = B[k * p + j];\n                if (val_a >= -100 && val_a <= 100 && val_b >= -100 && val_b <= 100) {\n                    sum += val_a * val_b;\n                }\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18", "completion": "```c\nvoid range_matrix_mul(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                double a_val = A[i * n + k];\n                double b_val = B[k * p + j];\n                if (a_val >= -100 && a_val <= 100 && b_val >= -100 && b_val <= 100) {\n                    sum += a_val * b_val;\n                }\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18", "completion": "```c\nvoid range_matrix_mul(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                double a_val = A[i * n + k];\n                double b_val = B[k * p + j];\n                if (a_val >= -100 && a_val <= 100 && b_val >= -100 && b_val <= 100) {\n                    sum += a_val * b_val;\n                }\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18", "completion": "```c\nvoid range_matrix_mul(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                if (A[i * n + k] >= -100 && A[i * n + k] <= 100 &&\n                    B[k * p + j] >= -100 && B[k * p + j] <= 100) {\n                    sum += A[i * n + k] * B[k * p + j];\n                }\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18", "completion": "```c\nvoid range_matrix_mul(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                if (A[i * n + k] >= -100 && A[i * n + k] <= 100 &&\n                    B[k * p + j] >= -100 && B[k * p + j] <= 100) {\n                    sum += A[i * n + k] * B[k * p + j];\n                }\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19", "completion": "```c\nvoid tensor_add_3d(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; ++i) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19", "completion": "```c\nvoid tensor_add_3d(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; i++) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19", "completion": "```c\nvoid tensor_add_3d(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; i++) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19", "completion": "```c\nvoid tensor_add_3d(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; i++) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19", "completion": "```c\nvoid tensor_add_3d(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; i++) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_20", "completion": "```c\nvoid vector_add_round_nearest(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20", "completion": "```c\nvoid vector_add_round_nearest(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20", "completion": "```c\nvoid vector_add_round_nearest(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20", "completion": "```c\nvoid vector_add_round_nearest(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20", "completion": "```c\nvoid vector_add_round_nearest(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = nearbyintf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_21", "completion": "```c\n#include <math.h>\n\nvoid vector_mul_round_up(const float* src1, const float* src2, float* dst, size_t length){\n    for (size_t i = 0; i < length; i++) {\n        if (i % 2 == 0 && fabs(src1[i] - src2[i]) <= 50) {\n            dst[i] = ceil(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21", "completion": "```c\n#include <math.h>\n\nvoid vector_mul_round_up(const float* src1, const float* src2, float* dst, size_t length){\n    for (size_t i = 0; i < length; ++i) {\n        if (i % 2 == 0 && fabs(src1[i] - src2[i]) <= 50) {\n            dst[i] = ceil(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21", "completion": "```c\n#include <math.h>\n\nvoid vector_mul_round_up(const float* src1, const float* src2, float* dst, size_t length){\n    for (size_t i = 0; i < length; i++) {\n        if (i % 2 == 0 && fabs(src1[i] - src2[i]) <= 50) {\n            dst[i] = ceil(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21", "completion": "```c\n#include <math.h>\n\nvoid vector_mul_round_up(const float* src1, const float* src2, float* dst, size_t length){\n    for (size_t i = 0; i < length; i++) {\n        if (i % 2 == 0 && fabs(src1[i] - src2[i]) <= 50) {\n            dst[i] = ceil(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21", "completion": "```c\n#include <math.h>\n\nvoid vector_mul_round_up(const float* src1, const float* src2, float* dst, size_t length){\n    for (size_t i = 0; i < length; i++) {\n        if (i % 2 == 0 && fabs(src1[i] - src2[i]) <= 50) {\n            dst[i] = ceil(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_22", "completion": "```c\nvoid matrix_scalar_mul(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    for (size_t i = 0; i < total_elements; ++i) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22", "completion": "```c\nvoid matrix_scalar_mul(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    for (size_t i = 0; i < total_elements; ++i) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22", "completion": "```c\nvoid matrix_scalar_mul(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    for (size_t i = 0; i < total_elements; ++i) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22", "completion": "```c\nvoid matrix_scalar_mul(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    for (size_t i = 0; i < total_elements; ++i) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22", "completion": "```c\nvoid matrix_scalar_mul(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    for (size_t i = 0; i < total_elements; ++i) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_23", "completion": "```c\n#include <math.h>\n\nvoid matrix_normalize_rows(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float sum_of_squares = 0.0;\n        for (size_t j = 0; j < n; j++) {\n            float val = mat[i * n + j];\n            sum_of_squares += val * val;\n        }\n        float norm = sqrtf(sum_of_squares);\n        if (norm > 0.0) {\n            for (size_t j = 0; j < n; j++) {\n                mat[i * n + j] /= norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23", "completion": "```c\n#include <math.h>\n\nvoid matrix_normalize_rows(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float norm = 0.0;\n        for (size_t j = 0; j < n; j++) {\n            float val = mat[i * n + j];\n            norm += val * val;\n        }\n        norm = sqrtf(norm);\n        if (norm > 1e-6) { // Avoid division by zero\n            for (size_t j = 0; j < n; j++) {\n                mat[i * n + j] /= norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23", "completion": "```c\n#include <math.h>\n\nvoid matrix_normalize_rows(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float norm = 0.0;\n        for (size_t j = 0; j < n; j++) {\n            float val = mat[i * n + j];\n            norm += val * val;\n        }\n        norm = sqrtf(norm);\n        if (norm > 1e-6) { // Avoid division by zero\n            for (size_t j = 0; j < n; j++) {\n                mat[i * n + j] /= norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23", "completion": "```c\n#include <math.h>\n\nvoid matrix_normalize_rows(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float norm = 0.0;\n        for (size_t j = 0; j < n; j++) {\n            float val = mat[i * n + j];\n            norm += val * val;\n        }\n        norm = sqrtf(norm);\n        if (norm > 1e-6) { // Avoid division by zero\n            for (size_t j = 0; j < n; j++) {\n                mat[i * n + j] /= norm;\n            }\n        } else {\n            // If norm is effectively zero, set all elements to zero\n            for (size_t j = 0; j < n; j++) {\n                mat[i * n + j] = 0.0;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23", "completion": "```c\n#include <math.h>\n\nvoid matrix_normalize_rows(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float norm = 0.0;\n        for (size_t j = 0; j < n; j++) {\n            float val = mat[i * n + j];\n            norm += val * val;\n        }\n        norm = sqrtf(norm);\n        if (norm > 1e-6) {\n            for (size_t j = 0; j < n; j++) {\n                mat[i * n + j] /= norm;\n            }\n        } else {\n            // If norm is too small, set all elements to 0 to avoid division by zero\n            for (size_t j = 0; j < n; j++) {\n                mat[i * n + j] = 0.0;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24", "completion": "```c\nvoid matrix_mul_round_int(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24", "completion": "```c\nvoid matrix_mul_round_int(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24", "completion": "```c\nvoid matrix_mul_round_int(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24", "completion": "```c\nvoid matrix_mul_round_int(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24", "completion": "```c\nvoid matrix_mul_round_int(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25", "completion": "```c\nvoid matrix_transpose_round_quarter(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            size_t src_index = i * cols + j;\n            size_t dst_index = j * rows + i;\n            dst[dst_index] = 0.25f * roundf(4.0f * src[src_index]);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25", "completion": "```c\nvoid matrix_transpose_round_quarter(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            size_t src_index = i * cols + j;\n            size_t dst_index = j * rows + i;\n            dst[dst_index] = roundf(src[src_index] * 4.0f) / 4.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25", "completion": "```c\nvoid matrix_transpose_round_quarter(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            size_t src_index = i * cols + j;\n            size_t dst_index = j * rows + i;\n            dst[dst_index] = roundf(src[src_index] * 4.0f) / 4.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25", "completion": "```c\nvoid matrix_transpose_round_quarter(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            size_t src_idx = i * cols + j;\n            size_t dst_idx = j * rows + i;\n            dst[dst_idx] = 0.25f * roundf(4.0f * src[src_idx]);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25", "completion": "```c\nvoid matrix_transpose_round_quarter(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            size_t src_idx = i * cols + j;\n            size_t dst_idx = j * rows + i;\n            dst[dst_idx] = roundf(src[src_idx] * 4.0f) / 4.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26", "completion": "```c\nvoid tensor3d_sub_round_zero(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_size; ++i) {\n        float diff = tensor1[i] - tensor2[i];\n        if (diff > 0) {\n            dst[i] = floorf(diff);\n        } else {\n            dst[i] = ceilf(diff);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26", "completion": "```c\nvoid tensor3d_sub_round_zero(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_size; ++i) {\n        float result = tensor1[i] - tensor2[i];\n        if (result > 0) {\n            dst[i] = (float)(int)result;\n        } else {\n            dst[i] = -(float)(int)(-result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26", "completion": "```c\nvoid tensor3d_sub_round_zero(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_size; ++i) {\n        float result = tensor1[i] - tensor2[i];\n        if (result > 0) {\n            dst[i] = (float)(int)result;\n        } else {\n            dst[i] = (float)(int)result;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26", "completion": "```c\nvoid tensor3d_sub_round_zero(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_size; ++i) {\n        float result = tensor1[i] - tensor2[i];\n        if (result > 0) {\n            dst[i] = (float)(int)result;\n        } else {\n            dst[i] = (float)(int)result;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26", "completion": "```c\nvoid tensor3d_sub_round_zero(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_size; ++i) {\n        float diff = tensor1[i] - tensor2[i];\n        if (diff > 0) {\n            dst[i] = (float)(int)diff;\n        } else {\n            dst[i] = (float)(int)diff;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_27", "completion": "```c\nvoid matrix_hadamard_product(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total = m * n;\n    for (size_t i = 0; i < total; ++i) {\n        dst[i] = mat1[i] * mat2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_27", "completion": "```c\nvoid matrix_hadamard_product(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m * n; ++i) {\n        dst[i] = mat1[i] * mat2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_27", "completion": "```c\nvoid matrix_hadamard_product(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < n; ++j) {\n            size_t idx = i * n + j;\n            dst[idx] = mat1[idx] * mat2[idx];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_27", "completion": "```c\nvoid matrix_hadamard_product(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    for (size_t i = 0; i < total_elements; ++i) {\n        dst[i] = mat1[i] * mat2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_27", "completion": "```c\nvoid matrix_hadamard_product(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    for (size_t i = 0; i < total_elements; ++i) {\n        dst[i] = mat1[i] * mat2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_28", "completion": "```c\nvoid matrix_vector_mul(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float sum = 0.0f;\n        for (size_t j = 0; j < n; ++j) {\n            sum += mat[i * n + j] * vec[j];\n        }\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28", "completion": "```c\nvoid matrix_vector_mul(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float sum = 0.0f;\n        for (size_t j = 0; j < n; ++j) {\n            sum += mat[i * n + j] * vec[j];\n        }\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28", "completion": "```c\nvoid matrix_vector_mul(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float sum = 0.0f;\n        for (size_t j = 0; j < n; ++j) {\n            sum += mat[i * n + j] * vec[j];\n        }\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28", "completion": "```c\nvoid matrix_vector_mul(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float sum = 0.0f;\n        for (size_t j = 0; j < n; ++j) {\n            sum += mat[i * n + j] * vec[j];\n        }\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28", "completion": "```c\nvoid matrix_vector_mul(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float sum = 0.0f;\n        for (size_t j = 0; j < n; ++j) {\n            sum += mat[i * n + j] * vec[j];\n        }\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_29", "completion": "```c\ndouble matrix_average(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    for (size_t i = 0; i < m * n; i++) {\n        sum += mat[i];\n    }\n    return sum / (m * n);\n}\n```"}
{"task_id": "SimdBench_29", "completion": "```c\ndouble matrix_average(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    size_t total_elements = m * n;\n    for (size_t i = 0; i < total_elements; ++i) {\n        sum += *(mat + i);\n    }\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29", "completion": "```c\ndouble matrix_average(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    for (size_t i = 0; i < m * n; ++i) {\n        sum += mat[i];\n    }\n    return sum / (m * n);\n}\n```"}
{"task_id": "SimdBench_29", "completion": "```c\ndouble matrix_average(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    for (size_t i = 0; i < m * n; i++) {\n        sum += mat[i];\n    }\n    return sum / (m * n);\n}\n```"}
{"task_id": "SimdBench_29", "completion": "```c\ndouble matrix_average(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    size_t total_elements = m * n;\n    for (size_t i = 0; i < total_elements; ++i) {\n        sum += *(mat + i);\n    }\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_30", "completion": "```c\nbool matrix_rows_sorted_verify(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        if (directions[i]) { // Ascending order\n            for (size_t j = 1; j < cols; ++j) {\n                if (row[j] < row[j - 1]) {\n                    return false;\n                }\n            }\n        } else { // Descending order\n            for (size_t j = 1; j < cols; ++j) {\n                if (row[j] > row[j - 1]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30", "completion": "```c\nbool matrix_rows_sorted_verify(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        if (directions[i]) { // Ascending order\n            for (size_t j = 1; j < cols; ++j) {\n                if (row[j] < row[j - 1]) {\n                    return false;\n                }\n            }\n        } else { // Descending order\n            for (size_t j = 1; j < cols; ++j) {\n                if (row[j] > row[j - 1]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30", "completion": "```c\nbool matrix_rows_sorted_verify(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        if (directions[i]) { // Ascending order\n            for (size_t j = 1; j < cols; ++j) {\n                if (row[j] < row[j - 1]) {\n                    return false;\n                }\n            }\n        } else { // Descending order\n            for (size_t j = 1; j < cols; ++j) {\n                if (row[j] > row[j - 1]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30", "completion": "```c\nbool matrix_rows_sorted_verify(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const bool is_ascending = directions[i];\n        const int* row = matrix + i * cols;\n        for (size_t j = 1; j < cols; ++j) {\n            if (is_ascending && row[j] < row[j - 1]) {\n                return false;\n            }\n            if (!is_ascending && row[j] > row[j - 1]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30", "completion": "```c\nbool matrix_rows_sorted_verify(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        if (directions[i]) { // Ascending order\n            for (size_t j = 1; j < cols; ++j) {\n                if (row[j] < row[j - 1]) {\n                    return false;\n                }\n            }\n        } else { // Descending order\n            for (size_t j = 1; j < cols; ++j) {\n                if (row[j] > row[j - 1]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_31", "completion": "```c\nvoid nearest_multiple(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int16_t value = src[i];\n        int16_t multiple = (value / base) * base;\n        dst[i] = multiple;\n    }\n}\n```"}
{"task_id": "SimdBench_31", "completion": "```c\nvoid nearest_multiple(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int16_t value = src[i];\n        int16_t multiple = (value / base) * base;\n        dst[i] = multiple;\n    }\n}\n```"}
{"task_id": "SimdBench_31", "completion": "```c\nvoid nearest_multiple(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        int16_t value = src[i];\n        int16_t multiple = (value / base) * base;\n        dst[i] = multiple;\n    }\n}\n```"}
{"task_id": "SimdBench_31", "completion": "```c\nvoid nearest_multiple(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        int16_t value = src[i];\n        int16_t multiple = (value / base) * base;\n        dst[i] = multiple;\n    }\n}\n```"}
{"task_id": "SimdBench_31", "completion": "```c\nvoid nearest_multiple(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        int16_t value = src[i];\n        int16_t multiple = (value / base) * base;\n        dst[i] = multiple;\n    }\n}\n```"}
{"task_id": "SimdBench_32", "completion": "```c\nbool matrix_has_row(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row = matrix + i * cols;\n        bool match = true;\n        for (size_t j = 0; j < cols; ++j) {\n            if (row[j] != vector[j]) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32", "completion": "```c\nbool matrix_has_row(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool match = true;\n        for (size_t j = 0; j < cols; ++j) {\n            if (*(matrix + i * cols + j) != *(vector + j)) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32", "completion": "```c\nbool matrix_has_row(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row = matrix + i * cols;\n        bool match = true;\n        for (size_t j = 0; j < cols; ++j) {\n            if (row[j] != vector[j]) {\n                match = false;\n                break;\n            }\n        }\n        if (match) return true;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32", "completion": "```c\nbool matrix_has_row(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row = matrix + i * cols;\n        bool match = true;\n        for (size_t j = 0; j < cols; ++j) {\n            if (row[j] != vector[j]) {\n                match = false;\n                break;\n            }\n        }\n        if (match) return true;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32", "completion": "```c\nbool matrix_has_row(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool match = true;\n        for (size_t j = 0; j < cols; ++j) {\n            if (*(matrix + i * cols + j) != *(vector + j)) {\n                match = false;\n                break;\n            }\n        }\n        if (match) return true;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_33", "completion": "```c\nsize_t tensor_4d_equal_count(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t count = 0;\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    for (size_t i = 0; i < total_elements; ++i) {\n        if (A[i] == B[i]) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_33", "completion": "```c\nsize_t tensor_4d_equal_count(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t count = 0;\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    for (size_t i = 0; i < total_elements; ++i) {\n        if (A[i] == B[i]) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_33", "completion": "```c\nsize_t tensor_4d_equal_count(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t count = 0;\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    for (size_t i = 0; i < total_elements; ++i) {\n        if (A[i] == B[i]) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_33", "completion": "```c\nsize_t tensor_4d_equal_count(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t count = 0;\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    for (size_t i = 0; i < total_elements; ++i) {\n        if (A[i] == B[i]) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_33", "completion": "```c\nsize_t tensor_4d_equal_count(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t count = 0;\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    for (size_t i = 0; i < total_elements; ++i) {\n        if (A[i] == B[i]) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_34", "completion": "```c\nvoid axm_abs(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; ++i) {\n        int64_t ax = a * x[i];\n        int64_t abs_y = (y[i] < 0) ? -y[i] : y[i];\n        y[i] = ax - abs_y;\n    }\n}\n```"}
{"task_id": "SimdBench_34", "completion": "```c\nvoid axm_abs(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; ++i) {\n        int64_t ax = a * x[i];\n        int64_t abs_y = (y[i] < 0) ? -y[i] : y[i];\n        y[i] = ax - abs_y;\n    }\n}\n```"}
{"task_id": "SimdBench_34", "completion": "```c\nvoid axm_abs(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; ++i) {\n        int64_t ax = a * x[i];\n        int64_t abs_y = (y[i] < 0) ? -y[i] : y[i];\n        y[i] = ax - abs_y;\n    }\n}\n```"}
{"task_id": "SimdBench_34", "completion": "```c\nvoid axm_abs(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; i++) {\n        y[i] = a * x[i] - ((x[i] < 0) ? -x[i] : x[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_34", "completion": "```c\nvoid axm_abs(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; ++i) {\n        int64_t ax = a * x[i];\n        int64_t abs_y = y[i] >= 0 ? y[i] : -y[i];\n        y[i] = ax - abs_y;\n    }\n}\n```"}
{"task_id": "SimdBench_35", "completion": "```c\nMinMaxPair min_max_pair(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    result.min_num = vec[0];\n    result.max_num = vec[0];\n    \n    for (size_t i = 1; i < length; ++i) {\n        if (vec[i] < result.min_num) {\n            result.min_num = vec[i];\n        }\n        if (vec[i] > result.max_num) {\n            result.max_num = vec[i];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35", "completion": "```c\nMinMaxPair min_max_pair(const int16_t* vec, size_t length) {\n    int16_t min_num = vec[0];\n    int16_t max_num = vec[0];\n    for (size_t i = 1; i < length; ++i) {\n        if (vec[i] < min_num) {\n            min_num = vec[i];\n        }\n        if (vec[i] > max_num) {\n            max_num = vec[i];\n        }\n    }\n    MinMaxPair result;\n    result.min_num = min_num;\n    result.max_num = max_num;\n    return result;\n}\n```"}
{"task_id": "SimdBench_35", "completion": "```c\nMinMaxPair min_max_pair(const int16_t* vec, size_t length) {\n    int16_t min_num = vec[0];\n    int16_t max_num = vec[0];\n    for (size_t i = 1; i < length; ++i) {\n        if (vec[i] < min_num) {\n            min_num = vec[i];\n        }\n        if (vec[i] > max_num) {\n            max_num = vec[i];\n        }\n    }\n    MinMaxPair result = {min_num, max_num};\n    return result;\n}\n```"}
{"task_id": "SimdBench_35", "completion": "```c\nMinMaxPair min_max_pair(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    result.min_num = vec[0];\n    result.max_num = vec[0];\n    \n    for (size_t i = 1; i < length; ++i) {\n        if (vec[i] < result.min_num) {\n            result.min_num = vec[i];\n        }\n        if (vec[i] > result.max_num) {\n            result.max_num = vec[i];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35", "completion": "```c\nMinMaxPair min_max_pair(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    result.min_num = vec[0];\n    result.max_num = vec[0];\n    for (size_t i = 1; i < length; ++i) {\n        if (vec[i] < result.min_num) {\n            result.min_num = vec[i];\n        }\n        if (vec[i] > result.max_num) {\n            result.max_num = vec[i];\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_36", "completion": "```c\nbool matrix_rows_strictly_increasing(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 1; j < cols; j++) {\n            if (*(matrix + i * cols + j) <= *(matrix + i * cols + j - 1)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_36", "completion": "```c\nbool matrix_rows_strictly_increasing(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 1; j < cols; ++j) {\n            if (*(matrix + i * cols + j) <= *(matrix + i * cols + j - 1)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_36", "completion": "```c\nbool matrix_rows_strictly_increasing(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 1; j < cols; j++) {\n            if (*(matrix + i * cols + j) <= *(matrix + i * cols + j - 1)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_36", "completion": "```c\nbool matrix_rows_strictly_increasing(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 1; j < cols; j++) {\n            if (*(matrix + i * cols + j) <= *(matrix + i * cols + j - 1)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_36", "completion": "```c\nbool matrix_rows_strictly_increasing(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 1; j < cols; ++j) {\n            if (*(matrix + i * cols + j) <= *(matrix + i * cols + j - 1)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37", "completion": "```c\nbool matrix_blocks_equal(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n\n    for (size_t i = 0; i < num_blocks_row; ++i) {\n        for (size_t j = 0; j < num_blocks_col; ++j) {\n            for (size_t bi = 0; bi < block_size; ++bi) {\n                for (size_t bj = 0; bj < block_size; ++bj) {\n                    size_t ref_i = bi;\n                    size_t ref_j = bj;\n                    size_t curr_i = i * block_size + bi;\n                    size_t curr_j = j * block_size + bj;\n\n                    int reference_value = matrix[ref_i * cols + ref_j];\n                    int current_value = matrix[curr_i * cols + curr_j];\n\n                    if (i > 0 || j > 0) { // Skip comparison for the first block\n                        if (current_value != reference_value) {\n                            return false;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37", "completion": "```c\n#include <stdbool.h>\n#include <stddef.h>\n\nbool matrix_blocks_equal(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n\n    for (size_t i = 0; i < num_blocks_row; ++i) {\n        for (size_t j = 0; j < num_blocks_col; ++j) {\n            for (size_t bi = 0; bi < block_size; ++bi) {\n                for (size_t bj = 0; bj < block_size; ++bj) {\n                    size_t ref_i = bi;\n                    size_t ref_j = bj;\n                    size_t cur_i = i * block_size + bi;\n                    size_t cur_j = j * block_size + bj;\n                    if (matrix[ref_i * cols + ref_j] != matrix[cur_i * cols + cur_j]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37", "completion": "```c\nbool matrix_blocks_equal(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t blocks_vertically = rows / block_size;\n    size_t blocks_horizontally = cols / block_size;\n\n    for (size_t b_row = 0; b_row < blocks_vertically; ++b_row) {\n        for (size_t b_col = 0; b_col < blocks_horizontally; ++b_col) {\n            for (size_t i = 0; i < block_size; ++i) {\n                for (size_t j = 0; j < block_size; ++j) {\n                    size_t ref_i = i;\n                    size_t ref_j = j;\n                    size_t curr_i = b_row * block_size + i;\n                    size_t curr_j = b_col * block_size + j;\n\n                    int reference_value = matrix[ref_i * cols + ref_j];\n                    int current_value = matrix[curr_i * cols + curr_j];\n\n                    if (b_row != 0 || b_col != 0) {\n                        if (current_value != reference_value) {\n                            return false;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37", "completion": "```c\nbool matrix_blocks_equal(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t blocks_vertically = rows / block_size;\n    size_t blocks_horizontally = cols / block_size;\n\n    for (size_t b_row = 0; b_row < blocks_vertically; ++b_row) {\n        for (size_t b_col = 0; b_col < blocks_horizontally; ++b_col) {\n            for (size_t i = 0; i < block_size; ++i) {\n                for (size_t j = 0; j < block_size; ++j) {\n                    size_t ref_i = i;\n                    size_t ref_j = j;\n                    size_t curr_i = b_row * block_size + i;\n                    size_t curr_j = b_col * block_size + j;\n\n                    if (matrix[curr_i * cols + curr_j] != matrix[ref_i * cols + ref_j]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37", "completion": "```c\nbool matrix_blocks_equal(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t blocks_vertically = rows / block_size;\n    size_t blocks_horizontally = cols / block_size;\n\n    for (size_t i = 0; i < block_size; ++i) {\n        for (size_t j = 0; j < block_size; ++j) {\n            int reference_value = matrix[i * cols + j];\n            for (size_t b_row = 0; b_row < blocks_vertically; ++b_row) {\n                for (size_t b_col = 0; b_col < blocks_horizontally; ++b_col) {\n                    size_t current_row = b_row * block_size + i;\n                    size_t current_col = b_col * block_size + j;\n                    if (matrix[current_row * cols + current_col] != reference_value) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_38", "completion": "```cpp\nbool vector_block_equal(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || block_size == 0 || length < block_size || length == 0)\n        return false;\n\n    for (size_t i = block_size; i + block_size <= length; i += block_size) {\n        for (size_t j = 0; j < block_size; ++j) {\n            if (fabs(vec[j] - vec[i + j]) > tolerance)\n                return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_38", "completion": "```cpp\nbool vector_block_equal(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n\n    for (size_t i = 1; i < num_blocks; ++i) {\n        for (size_t j = 0; j < block_size; ++j) {\n            if (fabs(vec[j] - vec[i * block_size + j]) > tolerance) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38", "completion": "```cpp\nbool vector_block_equal(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n\n    for (size_t i = 1; i < num_blocks; ++i) {\n        for (size_t j = 0; j < block_size; ++j) {\n            if (fabs(vec[j] - vec[i * block_size + j]) > tolerance) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38", "completion": "```cpp\nbool vector_block_equal(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    for (size_t i = 1; i < num_blocks; ++i) {\n        for (size_t j = 0; j < block_size; ++j) {\n            if (fabs(vec[j] - vec[i * block_size + j]) > tolerance) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_38", "completion": "```c\nbool vector_block_equal(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == NULL || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n\n    for (size_t block_idx = 1; block_idx < num_blocks; ++block_idx) {\n        for (size_t i = 0; i < block_size; ++i) {\n            if (fabs(vec[i] - vec[block_idx * block_size + i]) > tolerance) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_39", "completion": "```c\nvoid matrix_row_norm_compare(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        double norm = 0.0;\n        for (size_t j = 0; j < cols; ++j) {\n            double val = matrix[i * cols + j];\n            norm += val * val;\n        }\n        result[i] = (sqrt(norm) > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39", "completion": "```c\nvoid matrix_row_norm_compare(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        double norm = 0.0;\n        for (size_t j = 0; j < cols; ++j) {\n            double val = matrix[i * cols + j];\n            norm += val * val;\n        }\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39", "completion": "```c\n#include <math.h>\n\nvoid matrix_row_norm_compare(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        double norm = 0.0;\n        for (size_t j = 0; j < cols; ++j) {\n            double val = matrix[i * cols + j];\n            norm += val * val;\n        }\n        result[i] = (sqrt(norm) > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39", "completion": "```c\nvoid matrix_row_norm_compare(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        double norm = 0.0;\n        for (size_t j = 0; j < cols; ++j) {\n            double val = matrix[i * cols + j];\n            norm += val * val;\n        }\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39", "completion": "```c\nvoid matrix_row_norm_compare(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        double norm = 0.0;\n        for (size_t j = 0; j < cols; ++j) {\n            double val = matrix[i * cols + j];\n            norm += val * val;\n        }\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_40", "completion": "```c\nvoid tensor_bitwise_or(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40", "completion": "```c\nvoid tensor_bitwise_or(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40", "completion": "```c\nvoid tensor_bitwise_or(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40", "completion": "```c\nvoid tensor_bitwise_or(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40", "completion": "```c\nvoid tensor_bitwise_or(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_41", "completion": "```c\nint64_t squarediff(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_of_squares = 0;\n    int64_t sum_of_products = 0;\n    for (size_t i = 0; i < length; i++) {\n        sum_of_squares += (int64_t)A[i] * (int64_t)A[i] + (int64_t)B[i] * (int64_t)B[i];\n        sum_of_products += (int64_t)A[i] * (int64_t)B[i];\n    }\n    return sum_of_squares - 2 * sum_of_products;\n}\n```"}
{"task_id": "SimdBench_41", "completion": "```c\nint64_t squarediff(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_of_squares = 0;\n    int64_t sum_of_products = 0;\n    for (size_t i = 0; i < length; i++) {\n        sum_of_squares += (int64_t)A[i] * (int64_t)A[i] + (int64_t)B[i] * (int64_t)B[i];\n        sum_of_products += (int64_t)A[i] * (int64_t)B[i];\n    }\n    return sum_of_squares - 2 * sum_of_products;\n}\n```"}
{"task_id": "SimdBench_41", "completion": "```c\nint64_t squarediff(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_of_squares = 0;\n    int64_t sum_of_products = 0;\n    for (size_t i = 0; i < length; i++) {\n        sum_of_squares += (int64_t)A[i] * (int64_t)A[i] + (int64_t)B[i] * (int64_t)B[i];\n        sum_of_products += (int64_t)A[i] * (int64_t)B[i];\n    }\n    return sum_of_squares - 2 * sum_of_products;\n}\n```"}
{"task_id": "SimdBench_41", "completion": "```c\nint64_t squarediff(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_of_squares = 0;\n    int64_t sum_of_products = 0;\n    for (size_t i = 0; i < length; i++) {\n        sum_of_squares += (int64_t)A[i] * (int64_t)A[i] + (int64_t)B[i] * (int64_t)B[i];\n        sum_of_products += (int64_t)A[i] * (int64_t)B[i];\n    }\n    return sum_of_squares - 2 * sum_of_products;\n}\n```"}
{"task_id": "SimdBench_41", "completion": "```c\nint64_t squarediff(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_of_squares = 0;\n    int64_t sum_of_products = 0;\n    for (size_t i = 0; i < length; i++) {\n        sum_of_squares += (int64_t)A[i] * (int64_t)A[i] + (int64_t)B[i] * (int64_t)B[i];\n        sum_of_products += (int64_t)A[i] * (int64_t)B[i];\n    }\n    return sum_of_squares - 2 * sum_of_products;\n}\n```"}
{"task_id": "SimdBench_42", "completion": "```c\nvoid tensor_bit_clear(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] & (~B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_42", "completion": "```c\nvoid tensor_bit_clear(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] & (~B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_42", "completion": "```c\nvoid tensor_bit_clear(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] & (~B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_42", "completion": "```c\nvoid tensor_bit_clear(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42", "completion": "```c\nvoid tensor_bit_clear(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] & (~B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_43", "completion": "```c\nvoid tensor_three_valued_logic(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43", "completion": "```c\nvoid tensor_three_valued_logic(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43", "completion": "```c\nvoid tensor_three_valued_logic(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43", "completion": "```c\nvoid tensor_three_valued_logic(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43", "completion": "```c\nvoid tensor_three_valued_logic(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44", "completion": "```c\nvoid tensor_bit_op(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t mid = length / 2;\n    for (size_t i = 0; i < length; ++i) {\n        if (i == mid) {\n            C[i] = A[i];\n        }\n        else if (i < mid) {\n            C[i] = A[i] ^ B[i];\n        }\n        else {\n            C[i] = A[i] & B[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44", "completion": "```c\nvoid tensor_bit_op(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t mid = length / 2;\n    for (size_t i = 0; i < length; ++i) {\n        if (i < mid) {\n            C[i] = A[i] ^ B[i];\n        } else if (i > mid) {\n            C[i] = A[i] & B[i];\n        } else {\n            C[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44", "completion": "```c\nvoid tensor_bit_op(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t mid = length / 2;\n    for (size_t i = 0; i < length; ++i) {\n        if (i < mid) {\n            C[i] = A[i] ^ B[i];\n        } else if (i > mid) {\n            C[i] = A[i] & B[i];\n        } else {\n            C[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44", "completion": "```c\nvoid tensor_bit_op(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t mid = length / 2;\n    for (size_t i = 0; i < length; ++i) {\n        if (i < mid) {\n            C[i] = A[i] ^ B[i];\n        }\n        else if (i > mid) {\n            C[i] = A[i] & B[i];\n        }\n        else {\n            C[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44", "completion": "```c\nvoid tensor_bit_op(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t mid = length / 2;\n    for (size_t i = 0; i < length; ++i) {\n        if (i < mid) {\n            C[i] = A[i] ^ B[i];\n        } else if (i > mid) {\n            C[i] = A[i] & B[i];\n        } else {\n            C[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45", "completion": "```c\nvoid tensor_multi_select(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_size; ++i) {\n        if (cond1[i] && cond2[i]) {\n            out[i] = A[i];\n        }\n        else if (cond1[i] && !cond2[i]) {\n            out[i] = B[i];\n        }\n        else if (!cond1[i] && cond2[i]) {\n            out[i] = C[i];\n        }\n        else {\n            out[i] = D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45", "completion": "```c\nvoid tensor_multi_select(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_size; ++i) {\n        if (cond1[i] && cond2[i]) {\n            out[i] = A[i];\n        }\n        else if (cond1[i] && !cond2[i]) {\n            out[i] = B[i];\n        }\n        else if (!cond1[i] && cond2[i]) {\n            out[i] = C[i];\n        }\n        else {\n            out[i] = D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45", "completion": "```c\nvoid tensor_multi_select(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            for (size_t k = 0; k < dim3; ++k) {\n                size_t idx = i * dim2 * dim3 + j * dim3 + k;\n                if (cond1[idx] && cond2[idx]) {\n                    out[idx] = A[idx];\n                } else if (cond1[idx] && !cond2[idx]) {\n                    out[idx] = B[idx];\n                } else if (!cond1[idx] && cond2[idx]) {\n                    out[idx] = C[idx];\n                } else {\n                    out[idx] = D[idx];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45", "completion": "```c\nvoid tensor_multi_select(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_size; ++i) {\n        if (cond1[i] && cond2[i]) {\n            out[i] = A[i];\n        }\n        else if (cond1[i] && !cond2[i]) {\n            out[i] = B[i];\n        }\n        else if (!cond1[i] && cond2[i]) {\n            out[i] = C[i];\n        }\n        else {\n            out[i] = D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45", "completion": "```c\nvoid tensor_multi_select(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_size; ++i) {\n        if (cond1[i] && cond2[i]) {\n            out[i] = A[i];\n        } else if (cond1[i] && !cond2[i]) {\n            out[i] = B[i];\n        } else if (!cond1[i] && cond2[i]) {\n            out[i] = C[i];\n        } else {\n            out[i] = D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_46", "completion": "```c\nvoid tensor_bit_count(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_size; ++i) {\n        uint32_t val = A[i];\n        uint8_t count = 0;\n        while (val) {\n            count += val & 1;\n            val >>= 1;\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_46", "completion": "```c\nvoid tensor_bit_count(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_size; ++i) {\n        uint32_t val = A[i];\n        uint8_t count = 0;\n        while (val) {\n            count += val & 1;\n            val >>= 1;\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_46", "completion": "```c\nvoid tensor_bit_count(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_size; ++i) {\n        uint32_t val = A[i];\n        uint8_t count = 0;\n        while (val) {\n            count += val & 1;\n            val >>= 1;\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_46", "completion": "```c\nvoid tensor_bit_count(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_size; ++i) {\n        uint32_t val = A[i];\n        uint8_t count = 0;\n        while (val) {\n            count += val & 1;\n            val >>= 1;\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_46", "completion": "```c\nvoid tensor_bit_count(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_size; ++i) {\n        uint32_t val = A[i];\n        uint8_t count = 0;\n        while (val) {\n            count += val & 1;\n            val >>= 1;\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_47", "completion": "```c\nvoid matrix_conditional_abs(const int* A, int* B, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows * cols; i++) {\n        if (A[i] % 3 == 0) {\n            B[i] = (A[i] >= 0) ? A[i] : -A[i];\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47", "completion": "```c\nvoid matrix_conditional_abs(const int* A, int* B, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows * cols; i++) {\n        if (A[i] % 3 == 0) {\n            B[i] = (A[i] >= 0) ? A[i] : -A[i];\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47", "completion": "```c\nvoid matrix_conditional_abs(const int* A, int* B, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows * cols; i++) {\n        if (A[i] % 3 == 0) {\n            B[i] = (A[i] >= 0) ? A[i] : -A[i];\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47", "completion": "```c\nvoid matrix_conditional_abs(const int* A, int* B, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows * cols; ++i) {\n        if (A[i] % 3 == 0) {\n            B[i] = (A[i] >= 0) ? A[i] : -A[i];\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47", "completion": "```c\nvoid matrix_conditional_abs(const int* A, int* B, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows * cols; ++i) {\n        if (A[i] % 3 == 0) {\n            B[i] = (A[i] >= 0) ? A[i] : -A[i];\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48", "completion": "```c\n#include <stdint.h>\n#include <string.h>\n\nvoid matrix_conditional_bit_rotate(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    for (size_t i = 0; i < length; ++i) {\n        if ((src[i] & 0xF) == 0xF) {\n            uint32_t rotated = (src[i] >> rotate_bits) | (src[i] << (32 - rotate_bits));\n            dst[i] = rotated;\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48", "completion": "```c\nvoid matrix_conditional_bit_rotate(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    for (size_t i = 0; i < length; ++i) {\n        if ((src[i] & 0xF) == 0xF) {\n            uint32_t rotated = (src[i] >> rotate_bits) | (src[i] << (32 - rotate_bits));\n            dst[i] = rotated;\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48", "completion": "```c\nvoid matrix_conditional_bit_rotate(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    for (size_t i = 0; i < length; ++i) {\n        if ((src[i] & 0xF) == 0xF) {\n            uint32_t rotated = (src[i] >> rotate_bits) | (src[i] << (32 - rotate_bits));\n            dst[i] = rotated;\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48", "completion": "```c\n#include <stdint.h>\n#include <string.h>\n\nvoid matrix_conditional_bit_rotate(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    for (size_t i = 0; i < length; i++) {\n        if ((src[i] & 0xF) == 0xF) {\n            uint32_t rotated = (src[i] >> rotate_bits) | (src[i] << (32 - rotate_bits));\n            dst[i] = rotated;\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48", "completion": "```c\n#include <stdint.h>\n#include <string.h>\n\nvoid matrix_conditional_bit_rotate(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    for (size_t i = 0; i < length; i++) {\n        if ((src[i] & 0xF) == 0xF) {\n            uint32_t rotated = (src[i] >> rotate_bits) | (src[i] << (32 - rotate_bits));\n            dst[i] = rotated;\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49", "completion": "```c\nvoid tensor_ternary_compare(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float abs_epsilon = (epsilon >= 0) ? epsilon : -epsilon;\n    for (size_t i = 0; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > abs_epsilon) {\n            out[i] = 1;\n        } else if (diff < -abs_epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49", "completion": "```c\nvoid tensor_ternary_compare(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float abs_epsilon = (epsilon > 0) ? epsilon : -epsilon;\n    for (size_t i = 0; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > abs_epsilon) {\n            out[i] = 1;\n        } else if (diff < -abs_epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49", "completion": "```c\nvoid tensor_ternary_compare(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float abs_epsilon = fabsf(epsilon);\n    for (size_t i = 0; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > abs_epsilon) {\n            out[i] = 1;\n        } else if (diff < -abs_epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49", "completion": "```c\nvoid tensor_ternary_compare(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float abs_epsilon = (epsilon > 0) ? epsilon : -epsilon;\n    for (size_t i = 0; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > abs_epsilon) {\n            out[i] = 1;\n        } else if (diff < -abs_epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49", "completion": "```c\nvoid tensor_ternary_compare(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float abs_epsilon = (epsilon >= 0) ? epsilon : -epsilon;\n    for (size_t i = 0; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > abs_epsilon) {\n            out[i] = 1;\n        } else if (diff < -abs_epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50", "completion": "```c\n#include <limits.h>\n\nvoid float_to_int_saturate(const float* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] > INT32_MAX) {\n            B[i] = INT32_MAX;\n        }\n        else if (A[i] < INT32_MIN) {\n            B[i] = INT32_MIN;\n        }\n        else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50", "completion": "```c\n#include <limits.h>\n\nvoid float_to_int_saturate(const float* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (A[i] < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50", "completion": "```c\n#include <limits.h>\n\nvoid float_to_int_saturate(const float* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] > INT32_MAX) {\n            B[i] = INT32_MAX;\n        }\n        else if (A[i] < INT32_MIN) {\n            B[i] = INT32_MIN;\n        }\n        else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50", "completion": "```c\n#include <limits.h>\n\nvoid float_to_int_saturate(const float* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] > INT32_MAX) {\n            B[i] = INT32_MAX;\n        }\n        else if (A[i] < INT32_MIN) {\n            B[i] = INT32_MIN;\n        }\n        else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50", "completion": "```c\n#include <limits.h>\n\nvoid float_to_int_saturate(const float* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] > INT32_MAX) {\n            B[i] = INT32_MAX;\n        }\n        else if (A[i] < INT32_MIN) {\n            B[i] = INT32_MIN;\n        }\n        else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_51", "completion": "```c\nvoid int_to_float_scaled(const int32_t* A, int8_t scale, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        B[i] = (float)(A[i] * scale);\n    }\n}\n```"}
{"task_id": "SimdBench_51", "completion": "```c\nvoid int_to_float_scaled(const int32_t* A, int8_t scale, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        B[i] = (float)(A[i] * scale);\n    }\n}\n```"}
{"task_id": "SimdBench_51", "completion": "```c\nvoid int_to_float_scaled(const int32_t* A, int8_t scale, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        B[i] = (float)(A[i] * scale);\n    }\n}\n```"}
{"task_id": "SimdBench_51", "completion": "```c\nvoid int_to_float_scaled(const int32_t* A, int8_t scale, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        B[i] = (float)(A[i] * scale);\n    }\n}\n```"}
{"task_id": "SimdBench_51", "completion": "```c\nvoid int_to_float_scaled(const int32_t* A, int8_t scale, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        B[i] = (float)(A[i] * scale);\n    }\n}\n```"}
{"task_id": "SimdBench_52", "completion": "```c\nvoid float_div_round(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        if (B[i] != 0.0f) {\n            float result = A[i] / B[i];\n            C[i] = (int32_t)(result + (result >= 0 ? 0.5f : -0.5f));\n        } else {\n            C[i] = 0; // Handle division by zero as needed\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_52", "completion": "```c\n#include <math.h>\n#include <stdint.h>\n#include <stddef.h>\n\nvoid float_div_round(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        if (B[i] == 0.0f) {\n            C[i] = 0; // or handle division by zero as per requirements\n        } else {\n            double result = A[i] / B[i];\n            C[i] = (int32_t)lround(result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_52", "completion": "```c\nvoid float_div_round(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        if (B[i] != 0.0f) {\n            float result = A[i] / B[i];\n            C[i] = (int32_t)(result + (result >= 0 ? 0.5f : -0.5f));\n        } else {\n            C[i] = 0; // Handle division by zero as needed\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_52", "completion": "```c\nvoid float_div_round(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        if (B[i] != 0.0f) {\n            float result = A[i] / B[i];\n            C[i] = (int32_t)(result + (result >= 0 ? 0.5f : -0.5f));\n        } else {\n            C[i] = 0; // Handle division by zero as needed\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_52", "completion": "```c\nvoid float_div_round(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        if (B[i] != 0.0f) {\n            float result = A[i] / B[i];\n            C[i] = (int32_t)(result + (result >= 0 ? 0.5f : -0.5f));\n        } else {\n            C[i] = 0; // Handle division by zero as needed\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53", "completion": "```c\n#include <float.h>\n#include <math.h>\n\nvoid double_to_float_saturate(const double* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        }\n        else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        }\n        else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53", "completion": "```c\n#include <float.h>\n#include <math.h>\n\nvoid double_to_float_saturate(const double* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        }\n        else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        }\n        else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53", "completion": "```c\n#include <float.h>\n#include <math.h>\n\nvoid double_to_float_saturate(const double* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        }\n        else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        }\n        else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53", "completion": "```c\n#include <float.h>\n#include <math.h>\n\nvoid double_to_float_saturate(const double* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        }\n        else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        }\n        else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53", "completion": "```c\n#include <float.h>\n#include <math.h>\n\nvoid double_to_float_saturate(const double* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        }\n        else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        }\n        else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_54", "completion": "```c\nvoid int16_to_int32(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54", "completion": "```c\nvoid int16_to_int32(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54", "completion": "```c\nvoid int16_to_int32(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54", "completion": "```c\nvoid int16_to_int32(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54", "completion": "```c\nvoid int16_to_int32(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_55", "completion": "```c\nvoid conditional_normalize(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    for (size_t i = 0; i < size; ++i) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            if (val < 0.0f) val = 0.0f;\n            if (val > 1.0f) val = 1.0f;\n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55", "completion": "```c\nvoid conditional_normalize(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    for (size_t i = 0; i < size; i++) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            if (val < 0.0f) val = 0.0f;\n            if (val > 1.0f) val = 1.0f;\n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55", "completion": "```c\nvoid conditional_normalize(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    for (size_t i = 0; i < size; ++i) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            if (val < 0.0f) val = 0.0f;\n            if (val > 1.0f) val = 1.0f;\n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55", "completion": "```c\nvoid conditional_normalize(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    for (size_t i = 0; i < size; ++i) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            if (val < 0.0f) {\n                val = 0.0f;\n            } else if (val > 1.0f) {\n                val = 1.0f;\n            }\n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55", "completion": "```c\nvoid conditional_normalize(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    for (size_t i = 0; i < size; ++i) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            if (val < 0.0f) {\n                val = 0.0f;\n            } else if (val > 1.0f) {\n                val = 1.0f;\n            }\n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_56", "completion": "```c\n#include <math.h>\n\nvoid int_to_float_sqrt(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        uint32_t high_bits = A[i] >> 16;\n        float temp = (float)high_bits;\n        B[i] = sqrtf(temp);\n    }\n}\n```"}
{"task_id": "SimdBench_56", "completion": "```c\n#include <math.h>\n\nvoid int_to_float_sqrt(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        uint32_t val = A[i];\n        uint16_t high_bits = val >> 16;\n        float converted = (float)high_bits;\n        float result = sqrtf(converted);\n        B[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_56", "completion": "```c\n#include <math.h>\n\nvoid int_to_float_sqrt(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        uint32_t high_bits = A[i] >> 16;\n        float value = (float)high_bits;\n        B[i] = sqrtf(value);\n    }\n}\n```"}
{"task_id": "SimdBench_56", "completion": "```c\n#include <math.h>\n\nvoid int_to_float_sqrt(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        uint32_t high_bits = A[i] >> 16;\n        float value = (float)high_bits;\n        B[i] = sqrtf(value);\n    }\n}\n```"}
{"task_id": "SimdBench_56", "completion": "```c\n#include <math.h>\n\nvoid int_to_float_sqrt(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        uint32_t high_bits = A[i] >> 16;\n        float value = (float)high_bits;\n        B[i] = sqrtf(value);\n    }\n}\n```"}
{"task_id": "SimdBench_57", "completion": "```c\nvoid int_bits_to_float(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        *(((uint32_t*)B) + i) = A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_57", "completion": "```c\nvoid int_bits_to_float(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        // Reinterpret the bits of uint32_t as a float\n        B[i] = *(reinterpret_cast<const float*>(&A[i]));\n    }\n}\n```"}
{"task_id": "SimdBench_57", "completion": "```c\nvoid int_bits_to_float(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        B[i] = *(reinterpret_cast<const float*>(&A[i]));\n    }\n}\n```"}
{"task_id": "SimdBench_57", "completion": "```c\nvoid int_bits_to_float(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        union {\n            uint32_t int_bits;\n            float float_value;\n        } converter;\n        converter.int_bits = A[i];\n        B[i] = converter.float_value;\n    }\n}\n```"}
{"task_id": "SimdBench_57", "completion": "```c\nvoid int_bits_to_float(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        union {\n            uint32_t int_bits;\n            float float_value;\n        } converter;\n        converter.int_bits = A[i];\n        B[i] = converter.float_value;\n    }\n}\n```"}
{"task_id": "SimdBench_58", "completion": "```c\nvoid conditional_diff(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n    diff[0] = 0.0f;\n    for (size_t i = 1; i < size; ++i) {\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i-1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58", "completion": "```c\nvoid conditional_diff(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n    diff[0] = 0.0f;\n    for (size_t i = 1; i < size; ++i) {\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i-1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58", "completion": "```c\nvoid conditional_diff(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n    diff[0] = 0.0f;\n    for (size_t i = 1; i < size; ++i) {\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i-1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58", "completion": "```c\nvoid conditional_diff(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n    diff[0] = 0.0f;\n    for (size_t i = 1; i < size; ++i) {\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i-1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58", "completion": "```c\nvoid conditional_diff(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n    diff[0] = 0.0f;\n    for (size_t i = 1; i < size; ++i) {\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i-1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_59", "completion": "```c\nvoid widening_uint(const uint32_t* src, uint64_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = ((uint64_t)src[i]) | 0xFFFFFFFF00000000ULL;\n    }\n}\n```"}
{"task_id": "SimdBench_59", "completion": "```c\nvoid widening_uint(const uint32_t* src, uint64_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = ((uint64_t)src[i]) | 0xFFFFFFFF00000000ULL;\n    }\n}\n```"}
{"task_id": "SimdBench_59", "completion": "```c\nvoid widening_uint(const uint32_t* src, uint64_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = ((uint64_t)src[i] | ((uint64_t)0xFFFFFFFF << 32));\n    }\n}\n```"}
{"task_id": "SimdBench_59", "completion": "```c\nvoid widening_uint(const uint32_t* src, uint64_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = ((uint64_t)src[i]) | 0xFFFFFFFF00000000ULL;\n    }\n}\n```"}
{"task_id": "SimdBench_59", "completion": "```c\nvoid widening_uint(const uint32_t* src, uint64_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = ((uint64_t)src[i]) | 0xFFFFFFFF00000000ULL;\n    }\n}\n```"}
{"task_id": "SimdBench_60", "completion": "```c\ndouble indexed_sum(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    for (size_t i = 0; i < length; ++i) {\n        if (index[i] >= 0 && (size_t)index[i] < length) {\n            sum += vec[index[i]];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60", "completion": "```c\ndouble indexed_sum(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    for (size_t i = 0; i < length; ++i) {\n        if (index[i] >= 0 && (size_t)index[i] < length) {\n            sum += vec[index[i]];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60", "completion": "```c\ndouble indexed_sum(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    for (size_t i = 0; i < length; ++i) {\n        if (index[i] >= 0 && (size_t)index[i] < length) {\n            sum += vec[index[i]];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60", "completion": "```c\ndouble indexed_sum(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    for (size_t i = 0; i < length; ++i) {\n        if (index[i] >= 0 && (size_t)index[i] < length) {\n            sum += vec[index[i]];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60", "completion": "```c\ndouble indexed_sum(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    for (size_t i = 0; i < length; ++i) {\n        int16_t idx = index[i];\n        if (idx >= 0 && (size_t)idx < length) {\n            sum += vec[idx];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_61", "completion": "```c\nvoid simple_conv2d(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    size_t input_index = ((i + ki) * input_size) + (j + kj);\n                    size_t kernel_index = (ki * kernel_size) + kj;\n                    sum += input[input_index] * kernel[kernel_index];\n                }\n            }\n            size_t output_index = (i * output_size) + j;\n            output[output_index] = (sum > 0) ? sum : 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61", "completion": "```c\n#include <stddef.h>\n#include <stdio.h>\n\nvoid simple_conv2d(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    size_t input_idx = ((i + ki) * input_size) + (j + kj);\n                    size_t kernel_idx = (ki * kernel_size) + kj;\n                    sum += input[input_idx] * kernel[kernel_idx];\n                }\n            }\n            // Apply ReLU activation\n            size_t output_idx = (i * output_size) + j;\n            output[output_idx] = (sum > 0) ? sum : 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61", "completion": "```c\nvoid simple_conv2d(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    size_t input_idx = (i + ki) * input_size + (j + kj);\n                    size_t kernel_idx = ki * kernel_size + kj;\n                    sum += input[input_idx] * kernel[kernel_idx];\n                }\n            }\n            // Apply ReLU activation\n            size_t output_idx = i * output_size + j;\n            output[output_idx] = (sum > 0) ? sum : 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61", "completion": "```c\nvoid simple_conv2d(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    size_t input_idx = (i + ki) * input_size + (j + kj);\n                    size_t kernel_idx = ki * kernel_size + kj;\n                    sum += input[input_idx] * kernel[kernel_idx];\n                }\n            }\n            // Apply ReLU activation\n            size_t output_idx = i * output_size + j;\n            output[output_idx] = (sum > 0) ? sum : 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61", "completion": "```c\nvoid simple_conv2d(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    size_t input_index = ((i + ki) * input_size) + (j + kj);\n                    size_t kernel_index = (ki * kernel_size) + kj;\n                    sum += input[input_index] * kernel[kernel_index];\n                }\n            }\n            // ReLU activation\n            size_t output_index = (i * output_size) + j;\n            output[output_index] = (sum > 0) ? sum : 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_62", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool has_close_elements(const std::vector<double> & numbers, double threshold){\n    if (numbers.size() < 2) return false;\n    std::vector<double> sorted_numbers = numbers;\n    std::sort(sorted_numbers.begin(), sorted_numbers.end());\n    for (size_t i = 1; i < sorted_numbers.size(); ++i){\n        if (sorted_numbers[i] - sorted_numbers[i - 1] < threshold){\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool has_close_elements(const std::vector<double> & numbers, double threshold){\n    if (numbers.size() < 2) return false;\n    std::vector<double> sorted_numbers = numbers;\n    std::sort(sorted_numbers.begin(), sorted_numbers.end());\n    for (size_t i = 1; i < sorted_numbers.size(); ++i){\n        if (sorted_numbers[i] - sorted_numbers[i - 1] < threshold){\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool has_close_elements(const std::vector<double> & numbers, double threshold){\n    if (numbers.size() < 2) return false;\n    std::vector<double> sorted_numbers = numbers;\n    std::sort(sorted_numbers.begin(), sorted_numbers.end());\n    for (size_t i = 1; i < sorted_numbers.size(); ++i){\n        if (sorted_numbers[i] - sorted_numbers[i-1] < threshold){\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool has_close_elements(const std::vector<double> & numbers, double threshold){\n    if (numbers.size() < 2) return false;\n    std::vector<double> sorted_numbers = numbers;\n    std::sort(sorted_numbers.begin(), sorted_numbers.end());\n    for (size_t i = 1; i < sorted_numbers.size(); ++i){\n        if (sorted_numbers[i] - sorted_numbers[i-1] < threshold){\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool has_close_elements(const std::vector<double> & numbers, double threshold){\n    if (numbers.size() < 2) return false;\n    std::vector<double> sorted_numbers = numbers;\n    std::sort(sorted_numbers.begin(), sorted_numbers.end());\n    for (size_t i = 1; i < sorted_numbers.size(); ++i){\n        if (sorted_numbers[i] - sorted_numbers[i - 1] < threshold){\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63", "completion": "```cpp\n#include <vector>\n\nbool below_zero(std::vector<int> operations){\n    int balance = 0;\n    for(int op : operations){\n        balance += op;\n        if(balance < 0){\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63", "completion": "```cpp\n#include <vector>\n\nbool below_zero(std::vector<int> operations){\n    int balance = 0;\n    for(int op : operations){\n        balance += op;\n        if(balance < 0){\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63", "completion": "```cpp\n#include <vector>\n\nbool below_zero(std::vector<int> operations){\n    int balance = 0;\n    for(int op : operations){\n        balance += op;\n        if(balance < 0){\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63", "completion": "```cpp\n#include <vector>\n\nbool below_zero(std::vector<int> operations){\n    int balance = 0;\n    for(int op : operations){\n        balance += op;\n        if(balance < 0){\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63", "completion": "```cpp\n#include <vector>\n\nbool below_zero(std::vector<int> operations){\n    int balance = 0;\n    for(int op : operations){\n        balance += op;\n        if(balance < 0){\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_64", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <numeric>\n#include <limits>\n\ndouble mean_absolute_deviation(std::vector<double> numbers){\n    if (numbers.empty()) return 0.0;\n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / numbers.size();\n    double mad = 0.0;\n    for (const auto& num : numbers) {\n        mad += std::abs(num - mean);\n    }\n    return mad / numbers.size();\n}\n```"}
{"task_id": "SimdBench_64", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <numeric>\n#include <stdexcept>\n\ndouble mean_absolute_deviation(std::vector<double> numbers){\n    if (numbers.empty()) {\n        throw std::invalid_argument(\"The input vector is empty.\");\n    }\n    \n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / numbers.size();\n    \n    double mad = 0.0;\n    for (const auto& num : numbers) {\n        mad += std::abs(num - mean);\n    }\n    mad /= numbers.size();\n    \n    return mad;\n}\n```"}
{"task_id": "SimdBench_64", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <numeric>\n#include <functional>\n\ndouble mean_absolute_deviation(std::vector<double> numbers){\n    if (numbers.empty()) return 0.0;\n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / numbers.size();\n    double mad = std::accumulate(numbers.begin(), numbers.end(), 0.0, \n        [&mean](double acc, double x) { return acc + std::abs(x - mean); });\n    return mad / numbers.size();\n}\n```"}
{"task_id": "SimdBench_64", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <numeric>\n#include <functional>\n\ndouble mean_absolute_deviation(std::vector<double> numbers){\n    if (numbers.empty()) return 0.0;\n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / numbers.size();\n    double mad = std::accumulate(numbers.begin(), numbers.end(), 0.0, \n        [&mean](double acc, double x) { return acc + std::abs(x - mean); });\n    return mad / numbers.size();\n}\n```"}
{"task_id": "SimdBench_64", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <numeric>\n#include <functional>\n\ndouble mean_absolute_deviation(std::vector<double> numbers){\n    if (numbers.empty()) return 0.0;\n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / numbers.size();\n    double mad = 0.0;\n    for (const auto& num : numbers) {\n        mad += std::abs(num - mean);\n    }\n    return mad / numbers.size();\n}\n```"}
{"task_id": "SimdBench_65", "completion": "```cpp\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter){ \n    std::vector<int> result;\n    for(size_t i = 0; i < numbers.size(); ++i){\n        result.push_back(numbers[i]);\n        if(i < numbers.size() - 1){\n            result.push_back(delimeter);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_65", "completion": "```cpp\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter){ \n    std::vector<int> result;\n    for(size_t i = 0; i < numbers.size(); ++i){\n        result.push_back(numbers[i]);\n        if(i != numbers.size() - 1){\n            result.push_back(delimeter);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_65", "completion": "```cpp\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter){\n    std::vector<int> result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_65", "completion": "```cpp\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter){ \n    std::vector<int> result;\n    for(size_t i = 0; i < numbers.size(); ++i){\n        result.push_back(numbers[i]);\n        if(i != numbers.size() - 1){\n            result.push_back(delimeter);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_65", "completion": "```cpp\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter){ \n    std::vector<int> result;\n    for(size_t i = 0; i < numbers.size(); ++i){\n        result.push_back(numbers[i]);\n        if(i != numbers.size() - 1){\n            result.push_back(delimeter);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_66", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nstd::vector<int64_t> sum_product(std::vector<int16_t> numbers){\n    int64_t sum = 0;\n    int64_t product = 1;\n    for(auto num : numbers){\n        sum += num;\n        product *= num;\n    }\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nstd::vector<int64_t> sum_product(std::vector<int16_t> numbers){\n    int64_t sum = 0;\n    int64_t product = 1;\n    for(auto num : numbers){\n        sum += num;\n        product *= num;\n    }\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nstd::vector<int64_t> sum_product(std::vector<int16_t> numbers){\n    int64_t sum = 0;\n    int64_t product = 1;\n    for(auto num : numbers){\n        sum += num;\n        product *= num;\n    }\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nstd::vector<int64_t> sum_product(std::vector<int16_t> numbers){\n    int64_t sum = 0;\n    int64_t product = 1;\n    for(auto num : numbers){\n        sum += num;\n        product *= num;\n    }\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66", "completion": "```cpp\n#include <vector>\n#include <inttypes.h>\n\nstd::vector<int64_t> sum_product(std::vector<int16_t> numbers){\n    int64_t sum = 0;\n    int64_t product = 1;\n    for(auto num : numbers){\n        sum += num;\n        product *= num;\n    }\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_67", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max(std::vector<int> numbers){\n    std::vector<int> result;\n    if (numbers.empty()) return result;\n    int current_max = numbers[0];\n    result.push_back(current_max);\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        current_max = std::max(current_max, numbers[i]);\n        result.push_back(current_max);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_67", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max(std::vector<int> numbers){\n    std::vector<int> result;\n    if (numbers.empty()) return result;\n    int current_max = numbers[0];\n    result.push_back(current_max);\n    for (size_t i = 1; i < numbers.size(); ++i){\n        current_max = std::max(current_max, numbers[i]);\n        result.push_back(current_max);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_67", "completion": "```cpp\nstd::vector<int> rolling_max(std::vector<int> numbers){\n    std::vector<int> result;\n    if (numbers.empty()) return result;\n    \n    int current_max = numbers[0];\n    result.push_back(current_max);\n    \n    for (size_t i = 1; i < numbers.size(); ++i){\n        if (numbers[i] > current_max){\n            current_max = numbers[i];\n        }\n        result.push_back(current_max);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_67", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max(std::vector<int> numbers){\n    std::vector<int> result;\n    if (numbers.empty()) return result;\n    int current_max = numbers[0];\n    result.push_back(current_max);\n    for (size_t i = 1; i < numbers.size(); ++i){\n        current_max = std::max(current_max, numbers[i]);\n        result.push_back(current_max);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_67", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max(std::vector<int> numbers){\n    std::vector<int> result;\n    if (numbers.empty()) return result;\n    int current_max = numbers[0];\n    result.push_back(current_max);\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        current_max = std::max(current_max, numbers[i]);\n        result.push_back(current_max);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_68", "completion": "```cpp\n#include <string>\n\nstd::string string_xor(std::string a, std::string b){\n    std::string result;\n    int length = a.length();\n    for(int i = 0; i < length; ++i){\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_68", "completion": "```cpp\n#include <string>\n\nstd::string string_xor(std::string a, std::string b){\n    std::string result;\n    int len_a = a.length();\n    int len_b = b.length();\n    int max_len = std::max(len_a, len_b);\n    // Pad the shorter string with leading zeros\n    if (len_a < max_len) {\n        a.insert(0, max_len - len_a, '0');\n    }\n    if (len_b < max_len) {\n        b.insert(0, max_len - len_b, '0');\n    }\n    for(int i = 0; i < max_len; ++i){\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_68", "completion": "```cpp\n#include <string>\n\nstd::string string_xor(std::string a, std::string b){\n    std::string result;\n    int max_size = std::max(a.size(), b.size());\n    a.insert(a.begin(), max_size - a.size(), '0');\n    b.insert(b.begin(), max_size - b.size(), '0');\n    for(int i = 0; i < max_size; ++i){\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_68", "completion": "```cpp\n#include <string>\n\nstd::string string_xor(std::string a, std::string b){\n    std::string result;\n    int len_a = a.length();\n    int len_b = b.length();\n    int max_len = len_a > len_b ? len_a : len_b;\n    \n    for(int i = 0; i < max_len; ++i){\n        char c1 = i < len_a ? a[i] : '0';\n        char c2 = i < len_b ? b[i] : '0';\n        char xor_val = (c1 == c2) ? '0' : '1';\n        result += xor_val;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_68", "completion": "```cpp\n#include <string>\n\nstd::string string_xor(std::string a, std::string b){\n    std::string result;\n    int len_a = a.length();\n    int len_b = b.length();\n    int max_len = len_a > len_b ? len_a : len_b;\n    a.insert(a.begin(), max_len - len_a, '0');\n    b.insert(b.begin(), max_len - len_b, '0');\n    for(int i = 0; i < max_len; ++i){\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_69", "completion": "```cpp\n#include <string>\n#include <vector>\n\nstd::string longest(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return \"\";\n    }\n    std::string longest_str = strings[0];\n    for (const auto& str : strings) {\n        if (str.length() > longest_str.length()) {\n            longest_str = str;\n        }\n    }\n    return longest_str;\n}\n```"}
{"task_id": "SimdBench_69", "completion": "```cpp\n#include <string>\n#include <vector>\n\nstd::string longest(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return \"\";\n    }\n    std::string longest_str = strings[0];\n    for (const auto& str : strings) {\n        if (str.length() > longest_str.length()) {\n            longest_str = str;\n        }\n    }\n    return longest_str;\n}\n```"}
{"task_id": "SimdBench_69", "completion": "```cpp\n#include <string>\n#include <vector>\n\nstd::string longest(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return \"\";\n    }\n    std::string longest_str = strings[0];\n    for (const auto& str : strings) {\n        if (str.length() > longest_str.length()) {\n            longest_str = str;\n        }\n    }\n    return longest_str;\n}\n```"}
{"task_id": "SimdBench_69", "completion": "```cpp\n#include <string>\n#include <vector>\n\nstd::string longest(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return \"\";\n    }\n    std::string longest_str = strings[0];\n    for (const auto& str : strings) {\n        if (str.length() > longest_str.length()) {\n            longest_str = str;\n        }\n    }\n    return longest_str;\n}\n```"}
{"task_id": "SimdBench_69", "completion": "```cpp\n#include <string>\n#include <vector>\n\nstd::string longest(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return \"\";\n    }\n    std::string longest_str = strings[0];\n    for (const auto& str : strings) {\n        if (str.length() > longest_str.length()) {\n            longest_str = str;\n        }\n    }\n    return longest_str;\n}\n```"}
{"task_id": "SimdBench_70", "completion": "```c\nuint64_t greatest_common_divisor(uint64_t a, uint64_t b){\n    while (b != 0){\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_70", "completion": "```cpp\nuint64_t greatest_common_divisor(uint64_t a, uint64_t b){\n    while (b != 0){\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_70", "completion": "```c\nuint64_t greatest_common_divisor(uint64_t a, uint64_t b){\n    while (b != 0) {\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_70", "completion": "```cpp\nuint64_t greatest_common_divisor(uint64_t a, uint64_t b){\n    while (b != 0) {\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_70", "completion": "```cpp\nuint64_t greatest_common_divisor(uint64_t a, uint64_t b){\n    while (b != 0) {\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_71", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nstd::vector<float> find_closest_elements(std::vector<float> numbers){\n    std::sort(numbers.begin(), numbers.end());\n    float min_diff = std::abs(numbers[1] - numbers[0]);\n    float num1 = numbers[0];\n    float num2 = numbers[1];\n    for(size_t i = 1; i < numbers.size() - 1; ++i){\n        float diff = std::abs(numbers[i+1] - numbers[i]);\n        if(diff < min_diff){\n            min_diff = diff;\n            num1 = numbers[i];\n            num2 = numbers[i+1];\n        }\n    }\n    return {num1, num2};\n}\n```"}
{"task_id": "SimdBench_71", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nstd::vector<float> find_closest_elements(std::vector<float> numbers){\n    std::sort(numbers.begin(), numbers.end());\n    float min_diff = std::abs(numbers[1] - numbers[0]);\n    float num1 = numbers[0];\n    float num2 = numbers[1];\n    \n    for(size_t i = 1; i < numbers.size() - 1; ++i){\n        float diff = std::abs(numbers[i+1] - numbers[i]);\n        if(diff < min_diff){\n            min_diff = diff;\n            num1 = numbers[i];\n            num2 = numbers[i+1];\n        }\n    }\n    return {num1, num2};\n}\n```"}
{"task_id": "SimdBench_71", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nstd::vector<float> find_closest_elements(std::vector<float> numbers){\n    std::sort(numbers.begin(), numbers.end());\n    float min_diff = std::abs(numbers[1] - numbers[0]);\n    float num1 = numbers[0];\n    float num2 = numbers[1];\n    for(size_t i = 1; i < numbers.size() - 1; ++i){\n        float diff = std::abs(numbers[i+1] - numbers[i]);\n        if(diff < min_diff){\n            min_diff = diff;\n            num1 = numbers[i];\n            num2 = numbers[i+1];\n        }\n    }\n    return {num1, num2};\n}\n```"}
{"task_id": "SimdBench_71", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nstd::vector<float> find_closest_elements(std::vector<float> numbers){\n    if (numbers.size() < 2) return {};\n    \n    std::sort(numbers.begin(), numbers.end());\n    float min_diff = std::abs(numbers[1] - numbers[0]);\n    float num1 = numbers[0];\n    float num2 = numbers[1];\n    \n    for (size_t i = 1; i < numbers.size() - 1; ++i) {\n        float diff = std::abs(numbers[i+1] - numbers[i]);\n        if (diff < min_diff) {\n            min_diff = diff;\n            num1 = numbers[i];\n            num2 = numbers[i+1];\n        }\n    }\n    \n    return {num1, num2};\n}\n```"}
{"task_id": "SimdBench_71", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nstd::vector<float> find_closest_elements(std::vector<float> numbers){\n    if (numbers.size() < 2) return {};\n    \n    std::sort(numbers.begin(), numbers.end());\n    float min_diff = std::abs(numbers[1] - numbers[0]);\n    float num1 = numbers[0];\n    float num2 = numbers[1];\n    \n    for (size_t i = 1; i < numbers.size() - 1; ++i) {\n        float diff = std::abs(numbers[i+1] - numbers[i]);\n        if (diff < min_diff) {\n            min_diff = diff;\n            num1 = numbers[i];\n            num2 = numbers[i+1];\n        }\n    }\n    \n    return {num1, num2};\n}\n```"}
{"task_id": "SimdBench_72", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit(std::vector<float> numbers){ \n    float min_val = *min_element(numbers.begin(), numbers.end());\n    float max_val = *max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n    std::vector<float> result;\n    for(auto num : numbers){\n        result.push_back((num - min_val) / range);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_72", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit(std::vector<float> numbers){ \n    float min_val = *min_element(numbers.begin(), numbers.end());\n    float max_val = *max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n    std::vector<float> rescaled;\n    for(auto num : numbers){\n        rescaled.push_back((num - min_val) / range);\n    }\n    return rescaled;\n}\n```"}
{"task_id": "SimdBench_72", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit(std::vector<float> numbers){ \n    float min_val = *min_element(numbers.begin(), numbers.end());\n    float max_val = *max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n    std::vector<float> result;\n    for(auto num : numbers){\n        result.push_back((num - min_val) / range);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_72", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit(std::vector<float> numbers){ \n    float min_val = *min_element(numbers.begin(), numbers.end());\n    float max_val = *max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n    std::vector<float> result;\n    for(auto num : numbers){\n        result.push_back((num - min_val) / range);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_72", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <float.h>\n\nstd::vector<float> rescale_to_unit(std::vector<float> numbers){ \n    float min_val = *min_element(numbers.begin(), numbers.end());\n    float max_val = *max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n    std::vector<float> scaled_numbers;\n    for(auto num : numbers){\n        scaled_numbers.push_back((num - min_val) / range);\n    }\n    return scaled_numbers;\n}\n```"}
{"task_id": "SimdBench_73", "completion": "```cpp\nuint64_t largest_divisor(uint64_t n){\n    for(uint64_t i = n / 2; i >= 1; --i){\n        if(n % i == 0){\n            return i;\n        }\n    }\n    return 0;\n}\n```"}
{"task_id": "SimdBench_73", "completion": "```cpp\nuint64_t largest_divisor(uint64_t n){\n    for(uint64_t i = n / 2; i >= 1; --i){\n        if(n % i == 0){\n            return i;\n        }\n    }\n    return 0; // Return 0 if no divisor is found (n is 1)\n}\n```"}
{"task_id": "SimdBench_73", "completion": "```cpp\nuint64_t largest_divisor(uint64_t n){\n    for (uint64_t i = n / 2; i >= 1; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return 0; // Return 0 if no divisor is found (should not happen for n > 1)\n}\n```"}
{"task_id": "SimdBench_73", "completion": "```cpp\nuint64_t largest_divisor(uint64_t n){\n    for(uint64_t i = n/2; i >= 1; --i){\n        if(n % i == 0){\n            return i;\n        }\n    }\n    return 0; // Return 0 if no divisor is found (which won't happen for n > 1)\n}\n```"}
{"task_id": "SimdBench_73", "completion": "```cpp\nuint64_t largest_divisor(uint64_t n){\n    if(n == 1) return 0; // No divisor smaller than 1\n    for(uint64_t i = n/2; i >= 1; --i){\n        if(n % i == 0) return i;\n    }\n    return 0; // Return 0 if no divisor found (should not reach here for n > 1)\n}\n```"}
{"task_id": "SimdBench_74", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> factorize(int n) {\n    std::vector<int> factors;\n    for (int i = 2; i * i <= n; ++i) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> factorize(int n) {\n    std::vector<int> factors;\n    for (int i = 2; i * i <= n; ++i) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> factorize(int n) {\n    std::vector<int> factors;\n    for (int i = 2; i * i <= n; ++i) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> factorize(int n) {\n    std::vector<int> factors;\n    for (int i = 2; i * i <= n; ++i) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> factorize(int n) {\n    std::vector<int> factors;\n    for (int i = 2; i * i <= n; ++i) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n```"}
{"task_id": "SimdBench_75", "completion": "```cpp\n#include <vector>\n\nstd::vector<float> get_positive(const std::vector<float> & l){\n    std::vector<float> result;\n    for(auto num : l){\n        if(num > 0){\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75", "completion": "```cpp\n#include <vector>\n\nstd::vector<float> get_positive(const std::vector<float> & l){\n    std::vector<float> result;\n    for(auto num : l){\n        if(num > 0){\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75", "completion": "```cpp\n#include <vector>\n\nstd::vector<float> get_positive(const std::vector<float> & l){\n    std::vector<float> result;\n    for(auto num : l){\n        if(num > 0){\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75", "completion": "```cpp\n#include <vector>\n\nstd::vector<float> get_positive(const std::vector<float> & l){\n    std::vector<float> result;\n    for(auto num : l){\n        if(num > 0){\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75", "completion": "```cpp\n#include <vector>\n\nstd::vector<float> get_positive(const std::vector<float> & l){\n    std::vector<float> result;\n    for(auto num : l){\n        if(num > 0){\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_76", "completion": "```cpp\nbool is_prime(int64_t n){\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for(int64_t i = 5; i * i <= n; i += 6){\n        if(n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76", "completion": "```cpp\nbool is_prime(int64_t n){\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int64_t i = 5; i * i <= n; i += 6){\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76", "completion": "```cpp\nbool is_prime(int64_t n){\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int64_t i = 5; i * i <= n; i += 6){\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76", "completion": "```cpp\nbool is_prime(int64_t n){\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for(int64_t i = 5; i * i <= n; i += 6){\n        if(n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76", "completion": "```cpp\nbool is_prime(int64_t n){\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int64_t i = 5; i * i <= n; i += 6){\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_77", "completion": "```cpp\n#include <string>\n#include <cctype>\n#include <algorithm>\n\nstd::string solve(const std::string & s){\n    bool has_letter = false;\n    std::string result = s;\n    for(auto &ch : result){\n        if(std::isalpha(ch)){\n            has_letter = true;\n            ch = std::islower(ch) ? std::toupper(ch) : std::tolower(ch);\n        }\n    }\n    if(!has_letter){\n        std::reverse(result.begin(), result.end());\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_77", "completion": "```cpp\n#include <string>\n#include <cctype>\n#include <algorithm>\n\nstd::string solve(const std::string & s){\n    bool has_letter = false;\n    std::string result = s;\n    \n    for(auto &ch : result){\n        if(std::isalpha(ch)){\n            has_letter = true;\n            ch = std::islower(ch) ? std::toupper(ch) : std::tolower(ch);\n        }\n    }\n    \n    if(!has_letter){\n        std::reverse(result.begin(), result.end());\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_77", "completion": "```cpp\n#include <string>\n#include <cctype>\n#include <algorithm>\n\nstd::string solve(const std::string & s){\n    bool has_letter = false;\n    std::string result = s;\n    \n    for(char &c : result){\n        if(std::isalpha(c)){\n            has_letter = true;\n            c = std::islower(c) ? std::toupper(c) : std::tolower(c);\n        }\n    }\n    \n    if(!has_letter){\n        std::reverse(result.begin(), result.end());\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_77", "completion": "```cpp\n#include <string>\n#include <cctype>\n#include <algorithm>\n\nstd::string solve(const std::string & s){\n    bool has_letter = false;\n    std::string result = s;\n    for(auto &ch : result){\n        if(std::isalpha(ch)){\n            has_letter = true;\n            ch = std::islower(ch) ? std::toupper(ch) : std::tolower(ch);\n        }\n    }\n    if(!has_letter){\n        std::reverse(result.begin(), result.end());\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_77", "completion": "```cpp\n#include <string>\n#include <cctype>\n#include <algorithm>\n\nstd::string solve(const std::string & s){\n    bool has_letter = false;\n    std::string result = s;\n    for(auto &ch : result){\n        if(std::isalpha(ch)){\n            has_letter = true;\n            ch = std::islower(ch) ? std::toupper(ch) : std::tolower(ch);\n        }\n    }\n    if(!has_letter){\n        std::reverse(result.begin(), result.end());\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_78", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third(std::vector<int> l){\n    std::vector<int> divisible_by_three;\n    // Collect elements at indices divisible by three\n    for (size_t i = 0; i < l.size(); ++i){\n        if (i % 3 == 0){\n            divisible_by_three.push_back(l[i]);\n        }\n    }\n    // Sort the collected elements\n    std::sort(divisible_by_three.begin(), divisible_by_three.end());\n    \n    // Replace the original elements with sorted ones\n    size_t sort_index = 0;\n    for (size_t i = 0; i < l.size() && sort_index < divisible_by_three.size(); ++i){\n        if (i % 3 == 0){\n            l[i] = divisible_by_three[sort_index++];\n        }\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_78", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third(std::vector<int> l){\n    std::vector<int> divisible_by_three;\n    \n    // Collect elements at indices divisible by three\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            divisible_by_three.push_back(l[i]);\n        }\n    }\n    \n    // Sort the collected elements\n    std::sort(divisible_by_three.begin(), divisible_by_three.end());\n    \n    // Replace the original elements at indices divisible by three with sorted values\n    size_t div_idx = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            l[i] = divisible_by_three[div_idx++];\n        }\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_78", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third(std::vector<int> l){\n    std::vector<int> divisible_by_three;\n    // Collect elements at indices divisible by three\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            divisible_by_three.push_back(l[i]);\n        }\n    }\n    // Sort the collected elements\n    std::sort(divisible_by_three.begin(), divisible_by_three.end());\n    // Replace original elements with sorted ones\n    size_t sorted_index = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            l[i] = divisible_by_three[sorted_index++];\n        }\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_78", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third(std::vector<int> l){\n    std::vector<int> divisible_by_three;\n    // Collect elements at indices divisible by three\n    for(int i = 0; i < l.size(); ++i){\n        if(i % 3 == 0){\n            divisible_by_three.push_back(l[i]);\n        }\n    }\n    // Sort the collected elements\n    std::sort(divisible_by_three.begin(), divisible_by_three.end());\n    // Replace the original elements with sorted ones\n    int sorted_index = 0;\n    for(int i = 0; i < l.size(); ++i){\n        if(i % 3 == 0){\n            l[i] = divisible_by_three[sorted_index++];\n        }\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_78", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third(std::vector<int> l){\n    std::vector<int> divisible_by_three;\n    \n    // Collect elements at indices divisible by three\n    for (size_t i = 0; i < l.size(); ++i){\n        if (i % 3 == 0){\n            divisible_by_three.push_back(l[i]);\n        }\n    }\n    \n    // Sort the collected elements\n    std::sort(divisible_by_three.begin(), divisible_by_three.end());\n    \n    // Replace the original elements at indices divisible by three with sorted values\n    size_t div_idx = 0;\n    for (size_t i = 0; i < l.size() && div_idx < divisible_by_three.size(); ++i){\n        if (i % 3 == 0){\n            l[i] = divisible_by_three[div_idx++];\n        }\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_79", "completion": "```cpp\n#include <vector>\n#include <limits>\n\nfloat max_element(std::vector<float> l){\n    float max_val = std::numeric_limits<float>::lowest();\n    for(float num : l){\n        if(num > max_val){\n            max_val = num;\n        }\n    }\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79", "completion": "```cpp\n#include <vector>\n#include <float.h>\n\nfloat max_element(std::vector<float> l){\n    float max_val = -FLT_MAX;\n    for(float num : l){\n        if(num > max_val){\n            max_val = num;\n        }\n    }\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79", "completion": "```cpp\n#include <vector>\n#include <float.h>\n\nfloat max_element(std::vector<float> l){\n    float max_val = -FLT_MAX;\n    for(float num : l){\n        if(num > max_val){\n            max_val = num;\n        }\n    }\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79", "completion": "```cpp\n#include <vector>\n#include <float.h>\n\nfloat max_element(std::vector<float> l){\n    float max_val = -FLT_MAX;\n    for(float num : l){\n        if(num > max_val){\n            max_val = num;\n        }\n    }\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79", "completion": "```cpp\n#include <vector>\n#include <float.h>\n\nfloat max_element(std::vector<float> l){\n    float max_val = -FLT_MAX;\n    for(float num : l){\n        if(num > max_val){\n            max_val = num;\n        }\n    }\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_80", "completion": "```c\nint fizz_buzz(int n){\n    int count = 0;\n    for(int i = 0; i < n; i++){\n        if(i % 11 == 0 || i % 13 == 0){\n            int num = i;\n            while(num > 0){\n                if(num % 10 == 7){\n                    count++;\n                }\n                num /= 10;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80", "completion": "```c\nint fizz_buzz(int n){\n    int count = 0;\n    for(int i = 0; i < n; i++){\n        if(i % 11 == 0 || i % 13 == 0){\n            int num = i;\n            while(num > 0){\n                if(num % 10 == 7){\n                    count++;\n                }\n                num /= 10;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80", "completion": "```c\nint fizz_buzz(int n){\n    int count = 0;\n    for(int i = 0; i < n; i++){\n        if(i % 11 == 0 || i % 13 == 0){\n            int num = i;\n            while(num > 0){\n                if(num % 10 == 7){\n                    count++;\n                }\n                num /= 10;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80", "completion": "```c\nint fizz_buzz(int n){\n    int count = 0;\n    for(int i = 0; i < n; i++){\n        if(i % 11 == 0 || i % 13 == 0){\n            int num = i;\n            while(num > 0){\n                if(num % 10 == 7){\n                    count++;\n                }\n                num /= 10;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80", "completion": "```c\nint fizz_buzz(int n){\n    int count = 0;\n    for(int i = 0; i < n; i++){\n        if(i % 11 == 0 || i % 13 == 0){\n            int num = i;\n            while(num > 0){\n                if(num % 10 == 7){\n                    count++;\n                }\n                num /= 10;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_81", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even(std::vector<float> l){\n    std::vector<float> even_elements;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            even_elements.push_back(l[i]);\n        }\n    }\n    std::sort(even_elements.begin(), even_elements.end());\n    size_t even_index = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            l[i] = even_elements[even_index++];\n        }\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_81", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even(std::vector<float> l){\n    std::vector<float> even_elements;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            even_elements.push_back(l[i]);\n        }\n    }\n    std::sort(even_elements.begin(), even_elements.end());\n    size_t even_index = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            l[i] = even_elements[even_index++];\n        }\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_81", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even(std::vector<float> l){\n    std::vector<float> even_elements;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            even_elements.push_back(l[i]);\n        }\n    }\n    std::sort(even_elements.begin(), even_elements.end());\n    size_t even_index = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            l[i] = even_elements[even_index++];\n        }\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_81", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even(std::vector<float> l){\n    std::vector<float> even_elements;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            even_elements.push_back(l[i]);\n        }\n    }\n    std::sort(even_elements.begin(), even_elements.end());\n    size_t even_index = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            l[i] = even_elements[even_index++];\n        }\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_81", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even(std::vector<float> l){\n    std::vector<float> even_elements;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            even_elements.push_back(l[i]);\n        }\n    }\n    std::sort(even_elements.begin(), even_elements.end());\n    size_t even_index = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            l[i] = even_elements[even_index++];\n        }\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_82", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool triples_sum_to_zero(std::vector<int> l){\n    if (l.size() < 3) return false;\n    std::sort(l.begin(), l.end());\n    for (size_t i = 0; i < l.size() - 2; ++i){\n        size_t j = i + 1;\n        size_t k = l.size() - 1;\n        while (j < k){\n            int sum = l[i] + l[j] + l[k];\n            if (sum == 0) return true;\n            else if (sum < 0) ++j;\n            else --k;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool triples_sum_to_zero(std::vector<int> l){\n    if (l.size() < 3) return false;\n    std::sort(l.begin(), l.end());\n    for (size_t i = 0; i < l.size() - 2; ++i){\n        size_t j = i + 1;\n        size_t k = l.size() - 1;\n        while (j < k){\n            int sum = l[i] + l[j] + l[k];\n            if (sum == 0) return true;\n            else if (sum < 0) ++j;\n            else --k;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool triples_sum_to_zero(std::vector<int> l){\n    if (l.size() < 3) return false;\n    std::sort(l.begin(), l.end());\n    for (size_t i = 0; i < l.size() - 2; ++i){\n        size_t j = i + 1;\n        size_t k = l.size() - 1;\n        while (j < k){\n            int sum = l[i] + l[j] + l[k];\n            if (sum == 0) return true;\n            else if (sum < 0) ++j;\n            else --k;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool triples_sum_to_zero(std::vector<int> l){\n    if (l.size() < 3) return false;\n    std::sort(l.begin(), l.end());\n    for (size_t i = 0; i < l.size() - 2; ++i){\n        size_t j = i + 1;\n        size_t k = l.size() - 1;\n        while (j < k){\n            int sum = l[i] + l[j] + l[k];\n            if (sum == 0) return true;\n            else if (sum < 0) ++j;\n            else --k;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool triples_sum_to_zero(std::vector<int> l){\n    if (l.size() < 3) return false;\n    std::sort(l.begin(), l.end());\n    for (size_t i = 0; i < l.size() - 2; ++i){\n        size_t j = i + 1;\n        size_t k = l.size() - 1;\n        while (j < k){\n            int sum = l[i] + l[j] + l[k];\n            if (sum == 0) return true;\n            else if (sum < 0) ++j;\n            else --k;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_83", "completion": "```cpp\nstd::vector<int> incr_list(std::vector<int> l){\n    for(auto &x : l){\n        x += 1;\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_83", "completion": "```cpp\nstd::vector<int> incr_list(std::vector<int> l){\n    for(auto &x : l){\n        x += 1;\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_83", "completion": "```cpp\nstd::vector<int> incr_list(std::vector<int> l){\n    for(auto &x : l){\n        x += 1;\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_83", "completion": "```cpp\nstd::vector<int> incr_list(std::vector<int> l){\n    for(auto &x : l){\n        x += 1;\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_83", "completion": "```cpp\nstd::vector<int> incr_list(std::vector<int> l){\n    for(auto &elem : l){\n        elem += 1;\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_84", "completion": "```cpp\n#include <unordered_set>\n#include <vector>\n\nbool pairs_sum_to_zero(std::vector<int> l){\n    std::unordered_set<int> seen;\n    for (int num : l) {\n        if (seen.find(-num) != seen.end()) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84", "completion": "```cpp\n#include <unordered_set>\n#include <vector>\n\nbool pairs_sum_to_zero(std::vector<int> l){\n    std::unordered_set<int> seen;\n    for(int num : l){\n        if(seen.find(-num) != seen.end()){\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84", "completion": "```cpp\n#include <unordered_set>\n#include <vector>\n\nbool pairs_sum_to_zero(std::vector<int> l){\n    std::unordered_set<int> seen;\n    for(int num : l){\n        if(seen.find(-num) != seen.end()){\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84", "completion": "```cpp\n#include <unordered_set>\n#include <vector>\n\nbool pairs_sum_to_zero(std::vector<int> l){\n    std::unordered_set<int> seen;\n    for(int num : l){\n        if(seen.find(-num) != seen.end()){\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84", "completion": "```cpp\n#include <unordered_set>\n#include <vector>\n\nbool pairs_sum_to_zero(std::vector<int> l){\n    std::unordered_set<int> seen;\n    for(int num : l){\n        if(seen.find(-num) != seen.end()){\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_85", "completion": "```cpp\nstd::string change_base(int64_t x, int8_t base){\n    if (base < 2 || base > 9) {\n        return \"\"; // Invalid base\n    }\n    if (x == 0) {\n        return \"0\";\n    }\n    std::string result = \"\";\n    bool is_negative = x < 0;\n    x = std::abs(x);\n    while (x > 0) {\n        result = std::to_string(x % base) + result;\n        x /= base;\n    }\n    if (is_negative) {\n        result = \"-\" + result;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_85", "completion": "```cpp\n#include <string>\n#include <sstream>\n\nstd::string change_base(int64_t x, int8_t base){\n    if (x == 0) return \"0\";\n    std::ostringstream oss;\n    bool is_negative = false;\n    if (x < 0){\n        is_negative = true;\n        x = -x;\n    }\n    while (x > 0){\n        int64_t remainder = x % base;\n        oss << remainder;\n        x /= base;\n    }\n    if (is_negative){\n        oss << \"-\";\n    }\n    std::string result = oss.str();\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_85", "completion": "```cpp\nstd::string change_base(int64_t x, int8_t base){\n    if (base < 2 || base > 9) {\n        return \"\"; // Invalid base\n    }\n    if (x == 0) {\n        return \"0\";\n    }\n    bool is_negative = x < 0;\n    if (is_negative) {\n        x = -x;\n    }\n    std::string result;\n    while (x > 0) {\n        result = static_cast<char>('0' + (x % base)) + result;\n        x /= base;\n    }\n    if (is_negative) {\n        result = \"-\" + result;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_85", "completion": "```cpp\n#include <string>\n#include <sstream>\n\nstd::string change_base(int64_t x, int8_t base){\n    if (base < 2 || base >= 10) {\n        return \"\";\n    }\n    std::ostringstream oss;\n    bool is_negative = false;\n    if (x == 0) {\n        return \"0\";\n    }\n    if (x < 0) {\n        is_negative = true;\n        x = -x;\n    }\n    std::string result = \"\";\n    while (x > 0) {\n        result = static_cast<char>('0' + (x % base)) + result;\n        x /= base;\n    }\n    if (is_negative) {\n        result = \"-\" + result;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_85", "completion": "```cpp\nstd::string change_base(int64_t x, int8_t base){\n    if (base < 2 || base > 9) return \"\";\n    if (x == 0) return \"0\";\n    \n    bool is_negative = x < 0;\n    x = std::abs(x);\n    std::string result;\n    \n    while (x > 0) {\n        result += '0' + (x % base);\n        x /= base;\n    }\n    \n    if (is_negative) result += '-';\n    \n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_86", "completion": "```cpp\nbool is_palindrome(std::string text){\n    int left = 0;\n    int right = text.length() - 1;\n    while(left < right){\n        if(text[left] != text[right]){\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_86", "completion": "```cpp\nbool is_palindrome(std::string text){\n    int left = 0;\n    int right = text.length() - 1;\n    while(left < right){\n        if(text[left] != text[right]){\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_86", "completion": "```cpp\nbool is_palindrome(std::string text){\n    int left = 0;\n    int right = text.length() - 1;\n    while(left < right){\n        if(text[left] != text[right]){\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_86", "completion": "```cpp\nbool is_palindrome(std::string text){\n    int left = 0;\n    int right = text.length() - 1;\n    while(left < right){\n        if(text[left] != text[right]){\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_86", "completion": "```cpp\nbool is_palindrome(std::string text){\n    int left = 0;\n    int right = text.length() - 1;\n    while(left < right){\n        if(text[left] != text[right]){\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_87", "completion": "```cpp\nstd::string decode_shift(std::string s){\n    std::string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]-5-(int)'a'+26)%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_87", "completion": "```cpp\nstd::string decode_shift(std::string s){\n    std::string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]-5-(int)'a'+26)%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_87", "completion": "```cpp\nstd::string decode_shift(std::string s){\n    std::string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]-5-(int)'a')%26+(int)'a';   \n        if(w < 'a') w += 26; // Handle negative shift\n        out=out+(char)w;\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_87", "completion": "```cpp\nstd::string decode_shift(std::string s){\n    std::string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]-5-(int)'a')%26+(int)'a';   \n        if(w < 'a') w += 26; // Handle negative shift\n        out=out+(char)w;\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_87", "completion": "```cpp\nstd::string decode_shift(std::string s){\n    std::string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]-5-(int)'a')%26+(int)'a';   \n        if(w < 'a') w += 26; // Handle negative shift\n        out=out+(char)w;\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_88", "completion": "```cpp\nbool below_threshold(std::vector<int> l, int t){\n    for(int num : l){\n        if(num >= t) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88", "completion": "```cpp\nbool below_threshold(std::vector<int> l, int t){\n    for(int num : l){\n        if(num >= t){\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88", "completion": "```cpp\nbool below_threshold(std::vector<int> l, int t){\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88", "completion": "```cpp\nbool below_threshold(std::vector<int> l, int t){\n    for(int num : l){\n        if(num >= t){\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88", "completion": "```cpp\nbool below_threshold(std::vector<int> l, int t){\n    for(int num : l){\n        if(num >= t){\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_89", "completion": "```cpp\nbool correct_bracketing(std::string brackets){\n    int balance = 0;\n    for(char c : brackets){\n        if(c == '<') balance++;\n        if(c == '>') balance--;\n        if(balance < 0) return false;\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89", "completion": "```cpp\nbool correct_bracketing(std::string brackets){\n    int count = 0;\n    for(char c : brackets){\n        if(c == '<') count++;\n        if(c == '>') count--;\n        if(count < 0) return false;\n    }\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_89", "completion": "```cpp\nbool correct_bracketing(std::string brackets){\n    int balance = 0;\n    for(char c : brackets){\n        if(c == '<') balance++;\n        if(c == '>') balance--;\n        if(balance < 0) return false;\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89", "completion": "```cpp\nbool correct_bracketing(std::string brackets){\n    int balance = 0;\n    for(char c : brackets){\n        if(c == '<') balance++;\n        if(c == '>') balance--;\n        if(balance < 0) return false;\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89", "completion": "```cpp\nbool correct_bracketing(std::string brackets){\n    int balance = 0;\n    for(char c : brackets){\n        if(c == '<') balance++;\n        if(c == '>') balance--;\n        if(balance < 0) return false;\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90", "completion": "```cpp\nbool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    for (char c : brackets) {\n        if (c == '(') balance++;\n        if (c == ')') balance--;\n        if (balance < 0) return false;\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90", "completion": "```cpp\nbool correct_bracketing(std::string brackets){\n    int balance = 0;\n    for(char c : brackets){\n        if(c == '(') balance++;\n        if(c == ')') balance--;\n        if(balance < 0) return false;\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90", "completion": "```cpp\nbool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    for (char c : brackets) {\n        if (c == '(') balance++;\n        if (c == ')') balance--;\n        if (balance < 0) return false;\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90", "completion": "```cpp\nbool correct_bracketing(std::string brackets){\n    int balance = 0;\n    for(char c : brackets){\n        if(c == '(') balance++;\n        if(c == ')') balance--;\n        if(balance < 0) return false;\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90", "completion": "```cpp\nbool correct_bracketing(std::string brackets){\n    int balance = 0;\n    for(char c : brackets){\n        if(c == '(') balance++;\n        if(c == ')') balance--;\n        if(balance < 0) return false;\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_91", "completion": "```cpp\nstd::vector<float> derivative(std::vector<float> xs){\n    std::vector<float> result;\n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_91", "completion": "```cpp\nstd::vector<float> derivative(std::vector<float> xs){\n    std::vector<float> result;\n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_91", "completion": "```cpp\nstd::vector<float> derivative(std::vector<float> xs){\n    std::vector<float> result;\n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_91", "completion": "```cpp\nstd::vector<float> derivative(std::vector<float> xs){\n    std::vector<float> result;\n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_91", "completion": "```cpp\nstd::vector<float> derivative(std::vector<float> xs){\n    std::vector<float> result;\n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_92", "completion": "```cpp\n#include <string>\n#include <cctype>\n\nint vowels_count(std::string s){\n    int count = 0;\n    std::string vowels = \"aeiou\";\n    for(int i = 0; i < s.length(); i++){\n        char c = tolower(s[i]);\n        if(vowels.find(c) != std::string::npos){\n            count++;\n        }\n    }\n    if(tolower(s[s.length()-1]) == 'y' && s.length() > 0){\n        count++;\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_92", "completion": "```cpp\n#include <string>\n#include <cctype>\n\nint vowels_count(std::string s){\n    int count = 0;\n    std::string vowels = \"aeiou\";\n    for(int i = 0; i < s.length(); i++){\n        char c = tolower(s[i]);\n        if(vowels.find(c) != std::string::npos){\n            count++;\n        }\n    }\n    if(tolower(s[s.length()-1]) == 'y'){\n        count++;\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_92", "completion": "```cpp\n#include <string>\n#include <cctype>\n\nint vowels_count(std::string s){\n    int count = 0;\n    std::string vowels = \"aeiou\";\n    for(int i = 0; i < s.length(); ++i){\n        char c = tolower(s[i]);\n        if(vowels.find(c) != std::string::npos){\n            count++;\n        }\n    }\n    if(tolower(s[s.length()-1]) == 'y' && s.length() > 0){\n        count++;\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_92", "completion": "```cpp\n#include <string>\n#include <cctype>\n\nint vowels_count(std::string s){\n    int count = 0;\n    std::string vowels = \"aeiou\";\n    for(int i = 0; i < s.length(); i++){\n        char c = tolower(s[i]);\n        if(vowels.find(c) != std::string::npos){\n            count++;\n        }\n    }\n    if(tolower(s[s.length()-1]) == 'y'){\n        count++;\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_92", "completion": "```cpp\n#include <string>\n#include <cctype>\n\nint vowels_count(std::string s){\n    int count = 0;\n    std::string vowels = \"aeiou\";\n    for(int i = 0; i < s.length(); i++){\n        char c = tolower(s[i]);\n        if(vowels.find(c) != std::string::npos){\n            count++;\n        }\n    }\n    if(tolower(s[s.length()-1]) == 'y'){\n        count++;\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_93", "completion": "```cpp\nint digitSum(std::string s){\n    int sum = 0;\n    for(char c : s){\n        if(c >= 'A' && c <= 'Z'){\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93", "completion": "```cpp\nint digitSum(std::string s){\n    int sum = 0;\n    for(char c : s){\n        if(isupper(c)){\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93", "completion": "```cpp\n#include <string>\n#include <cctype>\n\nint digitSum(std::string s){\n    int sum = 0;\n    for(char c : s){\n        if(std::isupper(c)){\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93", "completion": "```cpp\n#include <string>\n\nint digitSum(std::string s){\n    int sum = 0;\n    for(char c : s){\n        if(c >= 'A' && c <= 'Z'){\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93", "completion": "```cpp\nint digitSum(std::string s){\n    int sum = 0;\n    for(char c : s){\n        if(c >= 'A' && c <= 'Z'){\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_94", "completion": "```cpp\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck(std::vector<int> arr){\n    int min_even = std::numeric_limits<int>::max();\n    int min_index = -1;\n    for(int i = 0; i < arr.size(); ++i){\n        if(arr[i] % 2 == 0 && arr[i] < min_even){\n            min_even = arr[i];\n            min_index = i;\n        }\n    }\n    if(min_index != -1){\n        return {min_even, min_index};\n    }\n    return {};\n}\n```"}
{"task_id": "SimdBench_94", "completion": "```cpp\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck(std::vector<int> arr){\n    int min_even = std::numeric_limits<int>::max();\n    int min_index = -1;\n    \n    for(int i = 0; i < arr.size(); ++i){\n        if(arr[i] % 2 == 0 && arr[i] < min_even){\n            min_even = arr[i];\n            min_index = i;\n        }\n    }\n    \n    if(min_index != -1){\n        return {min_even, min_index};\n    }\n    \n    return {};\n}\n```"}
{"task_id": "SimdBench_94", "completion": "```cpp\nstd::vector<int> pluck(std::vector<int> arr){\n    int min_even = -1;\n    int min_index = -1;\n    for(int i = 0; i < arr.size(); ++i){\n        if(arr[i] % 2 == 0){\n            if(min_even == -1 || arr[i] < min_even || (arr[i] == min_even && i < min_index)){\n                min_even = arr[i];\n                min_index = i;\n            }\n        }\n    }\n    if(min_even != -1){\n        return {min_even, min_index};\n    }\n    return {};\n}\n```"}
{"task_id": "SimdBench_94", "completion": "```cpp\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck(std::vector<int> arr){\n    int min_even = std::numeric_limits<int>::max();\n    int min_index = -1;\n    \n    for(int i = 0; i < arr.size(); ++i){\n        if(arr[i] % 2 == 0 && arr[i] < min_even){\n            min_even = arr[i];\n            min_index = i;\n        }\n    }\n    \n    if(min_index != -1){\n        return {min_even, min_index};\n    }\n    \n    return {};\n}\n```"}
{"task_id": "SimdBench_94", "completion": "```cpp\n#include <vector>\n#include <limits>\n\nstd::vector<int> pluck(std::vector<int> arr){\n    int min_even = std::numeric_limits<int>::max();\n    int min_index = -1;\n    for(int i = 0; i < arr.size(); ++i){\n        if(arr[i] % 2 == 0 && arr[i] < min_even){\n            min_even = arr[i];\n            min_index = i;\n        }\n    }\n    if(min_index != -1){\n        return {min_even, min_index};\n    }\n    return {};\n}\n```"}
{"task_id": "SimdBench_95", "completion": "```cpp\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint search(std::vector<int> lst){\n    std::unordered_map<int, int> freq;\n    for(auto num : lst) freq[num]++;\n    int result = -1;\n    for(const auto &pair : freq){\n        if(pair.second >= pair.first){\n            result = std::max(result, pair.first);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_95", "completion": "```cpp\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint search(std::vector<int> lst){\n    std::unordered_map<int, int> freq;\n    for(auto num : lst) freq[num]++;\n    int result = -1;\n    for(const auto& [num, count] : freq){\n        if(count >= num){\n            result = std::max(result, num);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_95", "completion": "```cpp\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint search(std::vector<int> lst){\n    std::unordered_map<int, int> freq;\n    for(auto num : lst) freq[num]++;\n    int result = -1;\n    for(const auto &pair : freq){\n        if(pair.second >= pair.first){\n            result = std::max(result, pair.first);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_95", "completion": "```cpp\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint search(std::vector<int> lst){\n    std::unordered_map<int, int> freq;\n    for(auto num : lst){\n        freq[num]++;\n    }\n    int result = -1;\n    for(const auto& [num, count] : freq){\n        if(count >= num){\n            result = std::max(result, num);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_95", "completion": "```cpp\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint search(std::vector<int> lst){\n    std::unordered_map<int, int> freq;\n    for(auto num : lst){\n        freq[num]++;\n    }\n    int result = -1;\n    for(const auto& [num, count] : freq){\n        if(count >= num){\n            result = std::max(result, num);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_96", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool will_it_fly(std::vector<int> q, int w){\n    int sum = 0;\n    for(int num : q) sum += num;\n    if(sum > w) return false;\n    std::vector<int> reversed_q = q;\n    std::reverse(reversed_q.begin(), reversed_q.end());\n    return q == reversed_q;\n}\n```"}
{"task_id": "SimdBench_96", "completion": "```cpp\n#include <vector>\n#include <numeric> // for std::accumulate\n\nbool will_it_fly(std::vector<int> q, int w){\n    int sum = std::accumulate(q.begin(), q.end(), 0);\n    if(sum > w) return false;\n    std::vector<int> reversed_q = q;\n    std::reverse(reversed_q.begin(), reversed_q.end());\n    return q == reversed_q;\n}\n```"}
{"task_id": "SimdBench_96", "completion": "```cpp\n#include <vector>\n#include <numeric>\n\nbool will_it_fly(std::vector<int> q, int w){\n    int sum = std::accumulate(q.begin(), q.end(), 0);\n    if(sum > w) return false;\n    std::vector<int> reversed_q = q;\n    std::reverse(reversed_q.begin(), reversed_q.end());\n    return q == reversed_q;\n}\n```"}
{"task_id": "SimdBench_96", "completion": "```cpp\n#include <vector>\n#include <numeric> // For std::accumulate\n\nbool will_it_fly(std::vector<int> q, int w) {\n    int sum = std::accumulate(q.begin(), q.end(), 0);\n    if (sum > w) return false;\n    std::vector<int> reversed_q = q;\n    std::reverse(reversed_q.begin(), reversed_q.end());\n    return q == reversed_q;\n}\n```"}
{"task_id": "SimdBench_96", "completion": "```cpp\n#include <vector>\n#include <numeric>\n\nbool will_it_fly(std::vector<int> q, int w){\n    bool is_palindrome = true;\n    int n = q.size();\n    for(int i = 0; i < n / 2; ++i){\n        if(q[i] != q[n - i - 1]){\n            is_palindrome = false;\n            break;\n        }\n    }\n    int sum = std::accumulate(q.begin(), q.end(), 0);\n    return is_palindrome && sum <= w;\n}\n```"}
{"task_id": "SimdBench_97", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint smallest_change(std::vector<int> arr){\n    int changes = 0;\n    int n = arr.size();\n    for(int i = 0; i < n / 2; ++i){\n        if(arr[i] != arr[n - i - 1]){\n            changes++;\n        }\n    }\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint smallest_change(std::vector<int> arr){\n    int changes = 0;\n    int n = arr.size();\n    for(int i = 0; i < n / 2; ++i){\n        if(arr[i] != arr[n - i - 1]){\n            changes++;\n        }\n    }\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint smallest_change(std::vector<int> arr){\n    int changes = 0;\n    int n = arr.size();\n    for(int i = 0; i < n / 2; ++i){\n        if(arr[i] != arr[n - i - 1]){\n            changes++;\n        }\n    }\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint smallest_change(std::vector<int> arr){\n    int changes = 0;\n    int n = arr.size();\n    for(int i = 0; i < n / 2; ++i){\n        if(arr[i] != arr[n - i - 1]){\n            changes++;\n        }\n    }\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint smallest_change(std::vector<int> arr){\n    int changes = 0;\n    int n = arr.size();\n    for(int i = 0; i < n / 2; ++i){\n        if(arr[i] != arr[n - i - 1]){\n            changes++;\n        }\n    }\n    return changes;\n}\n```"}
{"task_id": "SimdBench_98", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::vector<std::string> total_match(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    auto count_chars = [](const std::vector<std::string> & lst) {\n        size_t total = 0;\n        for (const auto & str : lst) {\n            total += str.size();\n        }\n        return total;\n    };\n    \n    size_t total1 = count_chars(lst1);\n    size_t total2 = count_chars(lst2);\n    \n    if (total1 <= total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::vector<std::string> total_match(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    auto count_chars = [](const std::vector<std::string> & lst) {\n        return std::accumulate(lst.begin(), lst.end(), 0, [](int sum, const std::string & s) {\n            return sum + s.length();\n        });\n    };\n    \n    int total1 = count_chars(lst1);\n    int total2 = count_chars(lst2);\n    \n    if (total1 <= total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::vector<std::string> total_match(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    auto count_chars = [](const std::vector<std::string> & lst) {\n        return std::accumulate(lst.begin(), lst.end(), 0, [](int sum, const std::string & s) {\n            return sum + s.length();\n        });\n    };\n    \n    int total1 = count_chars(lst1);\n    int total2 = count_chars(lst2);\n    \n    if (total1 <= total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::vector<std::string> total_match(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    auto count_chars = [](const std::vector<std::string> & lst) {\n        return std::accumulate(lst.begin(), lst.end(), 0, [](int sum, const std::string & s) {\n            return sum + s.length();\n        });\n    };\n    \n    int total1 = count_chars(lst1);\n    int total2 = count_chars(lst2);\n    \n    if (total1 <= total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::vector<std::string> total_match(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    auto count_chars = [](const std::vector<std::string> & lst) {\n        int total = 0;\n        for (const auto & str : lst) {\n            total += str.length();\n        }\n        return total;\n    };\n    \n    int total1 = count_chars(lst1);\n    int total2 = count_chars(lst2);\n    \n    if (total1 <= total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_99", "completion": "```cpp\nbool is_simple_power(uint64_t x, uint64_t n){\n    if (n == 1) return x == 1;\n    if (x < n) return false;\n    uint64_t current = n;\n    while (current < x){\n        if (current > UINT64_MAX / n) return false;\n        current *= n;\n    }\n    return current == x;\n}\n```"}
{"task_id": "SimdBench_99", "completion": "```cpp\nbool is_simple_power(uint64_t x, uint64_t n){\n    if (n == 0) return x == 0;\n    if (n == 1) return x == 1;\n    if (x == 1) return true;\n    uint64_t current = n;\n    while (current < x && current > 0) {\n        current *= n;\n    }\n    return current == x;\n}\n```"}
{"task_id": "SimdBench_99", "completion": "```cpp\nbool is_simple_power(uint64_t x, uint64_t n){\n    if (n == 0) return x == 0;\n    if (n == 1) return x == 1;\n    if (x == 1) return true;\n    uint64_t current = n;\n    while (current < x){\n        uint64_t next = current * n;\n        if (next < current) break; // Overflow check\n        current = next;\n    }\n    return current == x;\n}\n```"}
{"task_id": "SimdBench_99", "completion": "```c\nbool is_simple_power(uint64_t x, uint64_t n){\n    if (n == 0) return x == 0;\n    if (n == 1) return x == 1;\n    if (x == 1) return true;\n    uint64_t current = n;\n    while (current < x){\n        uint64_t next = current * n;\n        if (next < current) break; // Overflow check\n        current = next;\n    }\n    return current == x;\n}\n```"}
{"task_id": "SimdBench_99", "completion": "```cpp\nbool is_simple_power(uint64_t x, uint64_t n){\n    if (n == 0) return x == 0;\n    if (n == 1) return x == 1;\n    if (x == 1) return true;\n    uint64_t current = 1;\n    while (current < x){\n        current *= n;\n    }\n    return current == x;\n}\n```"}
{"task_id": "SimdBench_100", "completion": "```cpp\nint hex_key(const std::string & num){\n    int count = 0;\n    for(char c : num){\n        switch(c){\n            case '2':\n            case '3':\n            case '5':\n            case '7':\n            case 'B':\n            case 'D':\n                count++;\n                break;\n            default:\n                break;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_100", "completion": "```cpp\nint hex_key(const std::string & num) {\n    int count = 0;\n    std::unordered_set<char> primes = {'2', '3', '5', '7', 'B', 'D'};\n    for(char c : num){\n        if(primes.find(c) != primes.end()){\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_100", "completion": "```cpp\nint hex_key(const std::string & num) {\n    int count = 0;\n    for(char c : num){\n        switch(c){\n            case '2':\n            case '3':\n            case '5':\n            case '7':\n            case 'B':\n            case 'D':\n                count++;\n                break;\n            default:\n                break;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_100", "completion": "```cpp\nint hex_key(const std::string & num){\n    int count = 0;\n    for(char c : num){\n        switch(c){\n            case '2':\n            case '3':\n            case '5':\n            case '7':\n            case 'B':\n            case 'D':\n                count++;\n                break;\n            default:\n                break;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_100", "completion": "```cpp\nint hex_key(const std::string & num){\n    int count = 0;\n    for(char c : num){\n        switch(c){\n            case '2':\n            case '3':\n            case '5':\n            case '7':\n            case 'B':\n            case 'D':\n                count++;\n                break;\n            default:\n                break;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_101", "completion": "```cpp\nbool is_happy(const std::string & s){\n    if (s.length() < 3) return false;\n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_101", "completion": "```cpp\nbool is_happy(const std::string & s){\n    if (s.length() < 3) return false;\n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_101", "completion": "```cpp\nbool is_happy(const std::string & s){\n    if (s.length() < 3) return false;\n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_101", "completion": "```cpp\nbool is_happy(const std::string & s){\n    if (s.length() < 3) return false;\n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_101", "completion": "```cpp\nbool is_happy(const std::string & s){\n    if (s.length() < 3) return false;\n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_102", "completion": "```cpp\nbool prime_length(const std::string & str){\n    if (str.length() < 2) return false;\n    for(int i = 2; i * i <= str.length(); ++i){\n        if(str.length() % i == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_102", "completion": "```cpp\n#include <cmath>\n\nbool is_prime(int n){\n    if(n <= 1) return false;\n    if(n == 2) return true;\n    if(n % 2 == 0) return false;\n    int sqrt_n = static_cast<int>(std::sqrt(n));\n    for(int i = 3; i <= sqrt_n; i += 2){\n        if(n % i == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length(const std::string & str){\n    return is_prime(static_cast<int>(str.length()));\n}\n```"}
{"task_id": "SimdBench_102", "completion": "```cpp\nbool prime_length(const std::string & str){\n    if (str.length() < 2) return false;\n    for(int i = 2; i * i <= str.length(); ++i){\n        if(str.length() % i == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_102", "completion": "```cpp\nbool prime_length(const std::string & str){\n    if (str.length() < 2) return false;\n    for(int i = 2; i * i <= static_cast<int>(str.length()); ++i){\n        if(static_cast<int>(str.length()) % i == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_102", "completion": "```cpp\n#include <string>\n#include <cmath>\n\nbool is_prime(int n){\n    if(n <= 1) return false;\n    if(n == 2) return true;\n    if(n % 2 == 0) return false;\n    int sqrt_n = static_cast<int>(std::sqrt(n));\n    for(int i = 3; i <= sqrt_n; i += 2){\n        if(n % i == 0) return false;\n    }\n    return true;\n}\n\nbool prime_length(const std::string & str){\n    return is_prime(static_cast<int>(str.length()));\n}\n```"}
{"task_id": "SimdBench_103", "completion": "```cpp\n#include <string>\n#include <bitset>\n\nstd::string solve(uint64_t N){\n    int sum = 0;\n    while(N > 0){\n        sum += N % 10;\n        N /= 10;\n    }\n    return std::bitset<64>(sum).to_string().substr(64 - std::bit_width(sum));\n}\n```"}
{"task_id": "SimdBench_103", "completion": "```cpp\n#include <string>\n#include <bitset>\n\nstd::string solve(uint64_t N){\n    int sum = 0;\n    while(N > 0){\n        sum += N % 10;\n        N /= 10;\n    }\n    return std::bitset<64>(sum).to_string().substr(64 - std::bitset<64>(sum).count() - 1);\n}\n```"}
{"task_id": "SimdBench_103", "completion": "```cpp\n#include <string>\n#include <bitset>\n\nstd::string solve(uint64_t N){\n    int sum = 0;\n    while(N > 0){\n        sum += N % 10;\n        N /= 10;\n    }\n    return std::bitset<64>(sum).to_string().substr(64 - std::bitset<64>(sum).to_string().find_first_of('1'));\n}\n```"}
{"task_id": "SimdBench_103", "completion": "```cpp\n#include <string>\n#include <bitset>\n\nstd::string solve(uint64_t N){\n    int sum = 0;\n    while(N > 0){\n        sum += N % 10;\n        N /= 10;\n    }\n    return std::bitset<64>(sum).to_string().substr(64 - std::bitset<64>(sum).count() - 1);\n}\n```"}
{"task_id": "SimdBench_103", "completion": "```cpp\n#include <string>\n#include <bitset>\n\nstd::string solve(uint64_t N){\n    int sum = 0;\n    while(N > 0){\n        sum += N % 10;\n        N /= 10;\n    }\n    return std::bitset<64>(sum).to_string().substr(64 - std::bitset<64>(sum).to_string().find('1'));\n}\n```"}
{"task_id": "SimdBench_104", "completion": "```cpp\n#include <vector>\n\nint add(std::vector<int> lst){\n    int sum = 0;\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104", "completion": "```cpp\n#include <vector>\n\nint add(std::vector<int> lst) {\n    int sum = 0;\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104", "completion": "```cpp\n#include <vector>\n\nint add(std::vector<int> lst){\n    int sum = 0;\n    for(size_t i = 1; i < lst.size(); i += 2){\n        if(lst[i] % 2 == 0){\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104", "completion": "```cpp\n#include <vector>\n\nint add(std::vector<int> lst){\n    int sum = 0;\n    for(size_t i = 1; i < lst.size(); i += 2){\n        if(lst[i] % 2 == 0){\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104", "completion": "```cpp\n#include <vector>\n\nint add(std::vector<int> lst) {\n    int sum = 0;\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_105", "completion": "```cpp\n#include <string>\n\nstd::string encrypt(const std::string & s){\n    std::string result;\n    int shift = 2 * 2; // Shift by four places\n    for(char c : s){\n        if(c >= 'a' && c <= 'z'){\n            char shifted = ((c - 'a') + shift) % 26 + 'a';\n            result += shifted;\n        }\n        else{\n            result += c; // Non-lowercase letters are unchanged\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_105", "completion": "```cpp\n#include <string>\n#include <cctype>\n\nstd::string encrypt(const std::string & s){\n    std::string result;\n    int shift = 2 * 2; // Shift by four places\n    for(char c : s){\n        if(std::islower(c)){\n            char shifted = 'a' + (c - 'a' + shift) % 26;\n            result += shifted;\n        }\n        else if(std::isupper(c)){\n            char shifted = 'A' + (c - 'A' + shift) % 26;\n            result += shifted;\n        }\n        else{\n            result += c; // Non-alphabetic characters are unchanged\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_105", "completion": "```cpp\n#include <string>\n\nstd::string encrypt(const std::string & s){\n    std::string result;\n    int shift = 2 * 2; // Shift by four places\n    for(char c : s){\n        if(c >= 'a' && c <= 'z'){\n            char shifted = ((c - 'a') + shift) % 26 + 'a';\n            result += shifted;\n        }\n        else{\n            result += c; // Non-lowercase letters are unchanged\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_105", "completion": "```cpp\n#include <string>\n#include <cctype>\n\nstd::string encrypt(const std::string & s){\n    std::string result;\n    int shift = 2 * 2; // Shift by 4 places\n    for(char c : s){\n        if(std::islower(c)){\n            char shifted = static_cast<char>(((c - 'a' + shift) % 26) + 'a');\n            result += shifted;\n        }\n        else if(std::isupper(c)){\n            char shifted = static_cast<char>(((c - 'A' + shift) % 26) + 'A');\n            result += shifted;\n        }\n        else{\n            result += c; // Non-alphabetic characters are unchanged\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_105", "completion": "```cpp\n#include <string>\n#include <cctype>\n\nstd::string encrypt(const std::string & s){\n    std::string result;\n    int shift = 2 * 2; // Shift by four places\n    for(char c : s){\n        if(std::islower(c)){\n            char shifted = 'a' + (c - 'a' + shift) % 26;\n            result += shifted;\n        }\n        else if(std::isupper(c)){\n            char shifted = 'A' + (c - 'A' + shift) % 26;\n            result += shifted;\n        }\n        else{\n            result += c; // Non-alphabetic characters are unchanged\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_106", "completion": "```cpp\n#include <string>\n#include <cctype>\n\nstd::string encode(const std::string & message){\n    std::string result;\n    for(char c : message){\n        char original = std::islower(c) ? std::toupper(c) : std::tolower(c);\n        char encoded = original;\n        switch(original){\n            case 'A': encoded = 'C'; break;\n            case 'E': encoded = 'G'; break;\n            case 'I': encoded = 'K'; break;\n            case 'O': encoded = 'Q'; break;\n            case 'U': encoded = 'W'; break;\n            case 'a': encoded = 'c'; break;\n            case 'e': encoded = 'g'; break;\n            case 'i': encoded = 'k'; break;\n            case 'o': encoded = 'q'; break;\n            case 'u': encoded = 'w'; break;\n        }\n        if(std::islower(c)){\n            result += std::islower(encoded) ? encoded : std::tolower(encoded);\n        }\n        else{\n            result += std::isupper(encoded) ? encoded : std::toupper(encoded);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_106", "completion": "```cpp\n#include <string>\n#include <cctype>\n\nstd::string encode(const std::string & message){\n    std::string result;\n    for(char c : message){\n        char original = std::islower(c) ? std::toupper(c) : std::tolower(c);\n        char encoded = original;\n        switch(original){\n            case 'A': encoded = 'C'; break;\n            case 'E': encoded = 'G'; break;\n            case 'I': encoded = 'K'; break;\n            case 'O': encoded = 'Q'; break;\n            case 'U': encoded = 'W'; break;\n            case 'a': encoded = 'c'; break;\n            case 'e': encoded = 'g'; break;\n            case 'i': encoded = 'k'; break;\n            case 'o': encoded = 'q'; break;\n            case 'u': encoded = 'w'; break;\n        }\n        if(std::islower(c)){\n            result += std::tolower(encoded);\n        }\n        else{\n            result += std::toupper(encoded);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_106", "completion": "```cpp\n#include <string>\n#include <cctype>\n\nstd::string encode(const std::string & message){\n    std::string result;\n    for(char c : message){\n        char original = c;\n        // Swap case\n        if(std::islower(c)){\n            c = std::toupper(c);\n        }\n        else if(std::isupper(c)){\n            c = std::tolower(c);\n        }\n        // Replace vowels\n        switch(c){\n            case 'A': case 'a': c = 'C'; break;\n            case 'E': case 'e': c = 'G'; break;\n            case 'I': case 'i': c = 'K'; break;\n            case 'O': case 'o': c = 'Q'; break;\n            case 'U': case 'u': c = 'W'; break;\n        }\n        // Restore case after vowel replacement\n        if(std::islower(original) && std::isupper(c)){\n            c = std::tolower(c);\n        }\n        else if(std::isupper(original) && std::islower(c)){\n            c = std::toupper(c);\n        }\n        result += c;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_106", "completion": "```cpp\n#include <string>\n#include <unordered_map>\n#include <cctype>\n\nstd::string encode(const std::string & message) {\n    std::unordered_map<char, char> vowel_map = {\n        {'a', 'c'}, {'A', 'C'},\n        {'e', 'g'}, {'E', 'G'},\n        {'i', 'k'}, {'I', 'K'},\n        {'o', 'q'}, {'O', 'Q'},\n        {'u', 'w'}, {'U', 'W'}\n    };\n    \n    std::string result;\n    for (char c : message) {\n        if (std::isalpha(c)) {\n            if (vowel_map.find(c) != vowel_map.end()) {\n                result += vowel_map[c];\n            } else {\n                result += std::islower(c) ? std::toupper(c) : std::tolower(c);\n            }\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_106", "completion": "```cpp\n#include <string>\n#include <cctype>\n\nstd::string encode(const std::string & message){\n    std::string result;\n    for(char c : message){\n        char original = std::islower(c) ? std::toupper(c) : std::tolower(c);\n        char encoded = original;\n        if(original == 'A' || original == 'a') encoded = 'C';\n        else if(original == 'E' || original == 'e') encoded = 'G';\n        else if(original == 'I' || original == 'i') encoded = 'K';\n        else if(original == 'O' || original == 'o') encoded = 'Q';\n        else if(original == 'U' || original == 'u') encoded = 'W';\n        if(std::islower(c)){\n            result += std::tolower(encoded);\n        }\n        else{\n            result += std::toupper(encoded);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_107", "completion": "```cpp\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_dict_case(std::map<std::string, std::string> dict){\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for(const auto& pair : dict){\n        const std::string& key = pair.first;\n        if (!std::all_of(key.begin(), key.end(), ::isalpha)) {\n            return false;\n        }\n        for(char c : key){\n            if(!std::islower(c)) all_lower = false;\n            if(!std::isupper(c)) all_upper = false;\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107", "completion": "```cpp\n#include <map>\n#include <cctype>\n#include <string>\n\nbool check_dict_case(std::map<std::string, std::string> dict){\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        for (char c : key) {\n            if (!std::isalpha(c)) {\n                all_lower = all_upper = false;\n                break;\n            }\n            if (std::isupper(c)) all_lower = false;\n            if (std::islower(c)) all_upper = false;\n        }\n        if (!all_lower && !all_upper) return false;\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107", "completion": "```cpp\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_dict_case(std::map<std::string, std::string> dict){\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for(const auto& [key, value] : dict){\n        for(char c : key){\n            if(!std::isalpha(c)){\n                return false;\n            }\n            if(!std::islower(c)){\n                all_lower = false;\n            }\n            if(!std::isupper(c)){\n                all_upper = false;\n            }\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107", "completion": "```cpp\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_dict_case(std::map<std::string, std::string> dict){\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for(const auto& [key, value] : dict){\n        for(char c : key){\n            if(!std::isalpha(c)){\n                all_lower = false;\n                all_upper = false;\n                break;\n            }\n            if(std::isupper(c)) all_lower = false;\n            if(std::islower(c)) all_upper = false;\n        }\n        if(!all_lower && !all_upper) return false;\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107", "completion": "```cpp\n#include <map>\n#include <cctype>\n#include <string>\n\nbool check_dict_case(std::map<std::string, std::string> dict){\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for(const auto& pair : dict){\n        const std::string& key = pair.first;\n        if(key.empty()){\n            all_lower = false;\n            all_upper = false;\n            break;\n        }\n        for(char c : key){\n            if(!std::isalpha(c)){\n                all_lower = false;\n                all_upper = false;\n            }\n            else if(std::islower(c)){\n                all_upper = false;\n            }\n            else if(std::isupper(c)){\n                all_lower = false;\n            }\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_108", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nstd::vector<int> count_up_to(int n){\n    std::vector<int> primes;\n    if(n <= 1) return primes;\n    for(int i = 2; i < n; ++i){\n        bool is_prime = true;\n        int sqrt_i = static_cast<int>(std::sqrt(i));\n        for(int j = 2; j <= sqrt_i; ++j){\n            if(i % j == 0){\n                is_prime = false;\n                break;\n            }\n        }\n        if(is_prime){\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nstd::vector<int> count_up_to(int n){\n    std::vector<int> primes;\n    if(n <= 1) return primes;\n    for(int i = 2; i < n; ++i){\n        bool is_prime = true;\n        int sqrt_i = static_cast<int>(std::sqrt(i));\n        for(int j = 2; j <= sqrt_i; ++j){\n            if(i % j == 0){\n                is_prime = false;\n                break;\n            }\n        }\n        if(is_prime){\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nstd::vector<int> count_up_to(int n){\n    std::vector<int> primes;\n    if(n <= 1) return primes;\n    for(int i = 2; i < n; ++i){\n        bool is_prime = true;\n        int sqrt_i = static_cast<int>(std::sqrt(i));\n        for(int j = 2; j <= sqrt_i; ++j){\n            if(i % j == 0){\n                is_prime = false;\n                break;\n            }\n        }\n        if(is_prime){\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nstd::vector<int> count_up_to(int n){\n    std::vector<int> primes;\n    if(n <= 1) return primes;\n    for(int i = 2; i < n; ++i){\n        bool is_prime = true;\n        int sqrt_i = static_cast<int>(std::sqrt(i));\n        for(int j = 2; j <= sqrt_i; ++j){\n            if(i % j == 0){\n                is_prime = false;\n                break;\n            }\n        }\n        if(is_prime){\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nstd::vector<int> count_up_to(int n){\n    std::vector<int> primes;\n    if(n <= 1) return primes;\n    for(int i = 2; i < n; ++i){\n        bool is_prime = true;\n        int sqrt_i = static_cast<int>(std::sqrt(i));\n        for(int j = 2; j <= sqrt_i; ++j){\n            if(i % j == 0){\n                is_prime = false;\n                break;\n            }\n        }\n        if(is_prime){\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n```"}
{"task_id": "SimdBench_109", "completion": "```cpp\nint count_upper(const std::string & s){\n    int count = 0;\n    for(int i = 0; i < s.length(); i++){\n        if(i % 2 == 0 && (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')){\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_109", "completion": "```cpp\nint count_upper(const std::string & s){\n    int count = 0;\n    for(int i = 0; i < s.length(); i++){\n        if(i % 2 == 0 && (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')){\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_109", "completion": "```cpp\nint count_upper(const std::string & s){\n    int count = 0;\n    for(int i = 0; i < s.length(); ++i){\n        if(i % 2 == 0 && (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')){\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_109", "completion": "```cpp\nint count_upper(const std::string & s){\n    int count = 0;\n    for(int i = 0; i < s.length(); i++){\n        if(i % 2 == 0 && (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')){\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_109", "completion": "```cpp\nint count_upper(const std::string & s){\n    int count = 0;\n    for(int i = 0; i < s.length(); i++){\n        if(i % 2 == 0 && (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')){\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_110", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> make_a_pile(int n){\n    std::vector<int> pile;\n    int current = n;\n    for(int i = 0; i < n; ++i){\n        pile.push_back(current);\n        if(current % 2 == 0){\n            current += 2;\n        }\n        else{\n            current += 2;\n        }\n    }\n    return pile;\n}\n```"}
{"task_id": "SimdBench_110", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> make_a_pile(int n){\n    std::vector<int> pile;\n    int current = n;\n    for(int i = 0; i < n; ++i){\n        pile.push_back(current);\n        if(current % 2 == 0){\n            current += 2;\n        }\n        else{\n            current += 2;\n        }\n    }\n    return pile;\n}\n```"}
{"task_id": "SimdBench_110", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> make_a_pile(int n){\n    std::vector<int> pile;\n    int current = n;\n    for(int i = 0; i < n; ++i){\n        pile.push_back(current);\n        if(current % 2 == 0){\n            current += 2;\n        }\n        else{\n            current += 2;\n        }\n    }\n    return pile;\n}\n```"}
{"task_id": "SimdBench_110", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> make_a_pile(int n){\n    std::vector<int> pile;\n    int current = n;\n    for(int i = 0; i < n; ++i){\n        pile.push_back(current);\n        if(current % 2 == 0){\n            current += 2;\n        }\n        else{\n            current += 2;\n        }\n    }\n    return pile;\n}\n```"}
{"task_id": "SimdBench_110", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> make_a_pile(int n){\n    std::vector<int> pile;\n    int current = n;\n    for(int i = 0; i < n; ++i){\n        pile.push_back(current);\n        if(current % 2 == 0){\n            current += 2;\n        }\n        else{\n            current += 2;\n        }\n    }\n    return pile;\n}\n```"}
{"task_id": "SimdBench_111", "completion": "```cpp\n#include <string>\n#include <cmath>\n\nstd::string rounded_avg(int64_t n, int64_t m){\n    if(n > m){\n        return \"-1\";\n    }\n    int64_t sum = 0;\n    int64_t count = m - n + 1;\n    for(int64_t i = n; i <= m; ++i){\n        sum += i;\n    }\n    int64_t avg = std::floor((double)sum / count);\n    std::string binary = \"\";\n    if(avg == 0){\n        binary = \"0\";\n    }\n    else{\n        while(avg > 0){\n            binary = std::to_string(avg % 2) + binary;\n            avg /= 2;\n        }\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_111", "completion": "```cpp\n#include <string>\n#include <cmath>\n\nstd::string rounded_avg(int64_t n, int64_t m){\n    if(n > m) return \"-1\";\n    int64_t sum = 0;\n    int64_t count = m - n + 1;\n    for(int64_t i = n; i <= m; ++i){\n        sum += i;\n    }\n    int64_t avg = std::floor(static_cast<double>(sum) / count);\n    std::string binary = \"\";\n    if(avg == 0){\n        binary = \"0\";\n    }\n    else{\n        while(avg > 0){\n            binary = std::to_string(avg % 2) + binary;\n            avg /= 2;\n        }\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_111", "completion": "```cpp\n#include <string>\n#include <cmath>\n\nstd::string rounded_avg(int64_t n, int64_t m){\n    if (n > m) return \"-1\";\n    int64_t sum = 0;\n    int64_t count = m - n + 1;\n    for(int64_t i = n; i <= m; ++i){\n        sum += i;\n    }\n    int64_t avg = std::floor((double)sum / count);\n    std::string binary = \"\";\n    if(avg == 0){\n        binary = \"0\";\n    }\n    else{\n        while(avg > 0){\n            binary = std::to_string(avg % 2) + binary;\n            avg /= 2;\n        }\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_111", "completion": "```cpp\n#include <string>\n#include <cmath>\n\nstd::string rounded_avg(int64_t n, int64_t m){\n    if(n > m){\n        return \"-1\";\n    }\n    int64_t sum = 0;\n    int64_t count = m - n + 1;\n    for(int64_t i = n; i <= m; ++i){\n        sum += i;\n    }\n    int64_t avg = std::floor(static_cast<double>(sum) / count);\n    std::string binary = \"\";\n    if(avg == 0){\n        binary = \"0\";\n    }\n    else{\n        while(avg > 0){\n            binary = std::to_string(avg % 2) + binary;\n            avg /= 2;\n        }\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_111", "completion": "```cpp\n#include <string>\n#include <cmath>\n\nstd::string rounded_avg(int64_t n, int64_t m){\n    if(n > m){\n        return \"-1\";\n    }\n    int64_t sum = 0;\n    int64_t count = m - n + 1;\n    for(int64_t i = n; i <= m; ++i){\n        sum += i;\n    }\n    int64_t avg = std::floor(static_cast<double>(sum) / count);\n    std::string binary = \"\";\n    if(avg == 0){\n        binary = \"0\";\n    }\n    else{\n        while(avg > 0){\n            binary = std::to_string(avg % 2) + binary;\n            avg /= 2;\n        }\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_112", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> func(int n){\n    std::vector<int> result;\n    for(int i = 1; i <= n; ++i){\n        if(i % 2 == 0){\n            long long factorial = 1;\n            for(int j = 1; j <= i; ++j){\n                factorial *= j;\n                factorial %= 10000;\n            }\n            result.push_back(factorial);\n        }\n        else{\n            int sum = 0;\n            for(int j = 1; j <= i; ++j){\n                sum += j;\n            }\n            result.push_back(sum);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_112", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> func(int n){\n    std::vector<int> result;\n    for(int i = 1; i <= n; ++i){\n        if(i % 2 == 0){\n            int factorial = 1;\n            for(int j = 1; j <= i; ++j){\n                factorial = (factorial * j) % 10000;\n            }\n            result.push_back(factorial);\n        }\n        else{\n            int sum = 0;\n            for(int j = 1; j <= i; ++j){\n                sum += j;\n            }\n            result.push_back(sum);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_112", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> func(int n){\n    std::vector<int> result;\n    if(n <= 0) return result;\n    for(int i = 1; i <= n; ++i){\n        if(i % 2 == 0){\n            long long factorial = 1;\n            for(int j = 1; j <= i; ++j){\n                factorial *= j;\n                factorial %= 10000;\n            }\n            result.push_back(factorial);\n        }\n        else{\n            int sum = 0;\n            for(int j = 1; j <= i; ++j){\n                sum += j;\n                sum %= 10000;\n            }\n            result.push_back(sum);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_112", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> func(int n){\n    std::vector<int> result;\n    if (n <= 0) return result;\n    for(int i = 1; i <= n; ++i){\n        if(i % 2 == 0){\n            long long factorial = 1;\n            for(int j = 1; j <= i; ++j){\n                factorial *= j;\n                if(factorial >= 10000){\n                    factorial %= 10000;\n                }\n            }\n            result.push_back(static_cast<int>(factorial));\n        }\n        else{\n            int sum = 0;\n            for(int j = 1; j <= i; ++j){\n                sum += j;\n                if(sum >= 10000){\n                    sum %= 10000;\n                }\n            }\n            result.push_back(sum);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_112", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> func(int n){\n    std::vector<int> result;\n    for(int i = 1; i <= n; ++i){\n        if(i % 2 == 0){\n            long long factorial = 1;\n            for(int j = 1; j <= i; ++j){\n                factorial *= j;\n                factorial %= 10000;\n            }\n            result.push_back(factorial);\n        }\n        else{\n            int sum = 0;\n            for(int j = 1; j <= i; ++j){\n                sum += j;\n            }\n            result.push_back(sum);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_113", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<int> even_odd_palindrome(int n){\n    int even = 0, odd = 0;\n    for(int i = 1; i <= n; ++i){\n        std::string str = std::to_string(i);\n        if(std::equal(str.begin(), str.begin() + str.size()/2, str.rbegin())){\n            if(i % 2 == 0){\n                even++;\n            }\n            else{\n                odd++;\n            }\n        }\n    }\n    return {even, odd};\n}\n```"}
{"task_id": "SimdBench_113", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<int> even_odd_palindrome(int n){\n    int even = 0, odd = 0;\n    for(int i = 1; i <= n; ++i){\n        std::string str = std::to_string(i);\n        if(std::equal(str.begin(), str.begin() + str.size()/2, str.rbegin())){\n            if(i % 2 == 0){\n                even++;\n            }\n            else{\n                odd++;\n            }\n        }\n    }\n    return std::vector<int>{even, odd};\n}\n```"}
{"task_id": "SimdBench_113", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<int> even_odd_palindrome(int n){\n    int even = 0, odd = 0;\n    for(int i = 1; i <= n; ++i){\n        std::string str = std::to_string(i);\n        if(std::equal(str.begin(), str.begin() + str.size()/2, str.rbegin())){\n            if(i % 2 == 0){\n                even++;\n            }\n            else{\n                odd++;\n            }\n        }\n    }\n    return {even, odd};\n}\n```"}
{"task_id": "SimdBench_113", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<int> even_odd_palindrome(int n){\n    int even = 0, odd = 0;\n    for(int i = 1; i <= n; ++i){\n        std::string str = std::to_string(i);\n        if(std::equal(str.begin(), str.begin() + str.size()/2, str.rbegin())){\n            if(i % 2 == 0){\n                even++;\n            }\n            else{\n                odd++;\n            }\n        }\n    }\n    return std::vector<int>{even, odd};\n}\n```"}
{"task_id": "SimdBench_113", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> even_odd_palindrome(int n){\n    int even = 0, odd = 0;\n    for(int i = 1; i <= n; ++i){\n        std::string s = std::to_string(i);\n        if(std::equal(s.begin(), s.begin() + s.size()/2, s.rbegin())){\n            if(i % 2 == 0){\n                even++;\n            }\n            else{\n                odd++;\n            }\n        }\n    }\n    return {even, odd};\n}\n```"}
{"task_id": "SimdBench_114", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <cmath>\n\nint count_nums(std::vector<int> n){\n    int count = 0;\n    for(auto num : n){\n        int sum = 0;\n        std::string s = std::to_string(num);\n        for(char c : s){\n            if(c == '-') continue;\n            int digit = c - '0';\n            if(num < 0 && &c == &s[0] + 1) digit *= -1;\n            sum += digit;\n        }\n        if(sum > 0) count++;\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_114", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint count_nums(std::vector<int> n){\n    int count = 0;\n    for(auto num : n){\n        int sum = 0;\n        bool is_negative = num < 0;\n        std::vector<int> digits;\n        if (is_negative) {\n            num = -num;\n        }\n        if (num == 0) {\n            digits.push_back(0);\n        }\n        while(num > 0){\n            int digit = num % 10;\n            if(is_negative && digits.empty()){\n                digit = -digit;\n            }\n            digits.push_back(digit);\n            num /= 10;\n        }\n        for(auto d : digits){\n            sum += d;\n        }\n        if(sum > 0){\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_114", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint count_nums(std::vector<int> n){\n    int count = 0;\n    for(auto num : n){\n        int sum = 0;\n        bool is_negative = false;\n        if(num == 0){\n            sum = 0;\n        }\n        else{\n            if(num < 0){\n                is_negative = true;\n                num = -num;\n            }\n            int first = true;\n            while(num > 0){\n                int digit = num % 10;\n                if(is_negative && first){\n                    digit = -digit;\n                    first = false;\n                }\n                sum += digit;\n                num /= 10;\n            }\n        }\n        if(sum > 0) count++;\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_114", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint count_nums(std::vector<int> n){\n    int count = 0;\n    for (int num : n) {\n        int sum = 0;\n        bool is_negative = num < 0;\n        int digits = std::abs(num);\n        if (is_negative && digits != 0) {\n            sum -= digits / static_cast<int>(std::pow(10, std::floor(std::log10(digits)))) * (digits > 0 ? 1 : -1);\n            digits %= static_cast<int>(std::pow(10, std::floor(std::log10(digits))));\n        }\n        while (digits > 0) {\n            sum += digits % 10;\n            digits /= 10;\n        }\n        if (sum > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_114", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint count_nums(std::vector<int> n){\n    int count = 0;\n    for(auto num : n){\n        int sum = 0;\n        bool is_negative = false;\n        if(num == 0){\n            sum = 0;\n        }\n        else{\n            if(num < 0){\n                is_negative = true;\n                num = -num;\n            }\n            int first_digit_processed = false;\n            while(num > 0){\n                int digit = num % 10;\n                if(is_negative && !first_digit_processed){\n                    digit = -digit;\n                    first_digit_processed = true;\n                }\n                sum += digit;\n                num /= 10;\n            }\n        }\n        if(sum > 0) count++;\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_115", "completion": "```cpp\n#include <vector>\n\nbool move_one_ball(std::vector<int> arr){\n    if (arr.empty()) return true;\n    int count = 0;\n    int n = arr.size();\n    for(int i = 0; i < n; ++i){\n        if(arr[i] > arr[(i+1)%n]){\n            count++;\n            if(count > 1) return false;\n        }\n    }\n    return count <= 1;\n}\n```"}
{"task_id": "SimdBench_115", "completion": "```cpp\n#include <vector>\n\nbool move_one_ball(std::vector<int> arr){\n    if (arr.empty()) return true;\n    int count = 0;\n    int n = arr.size();\n    for(int i = 0; i < n; ++i){\n        if(arr[i] > arr[(i+1)%n]){\n            count++;\n            if(count > 1) return false;\n        }\n    }\n    return count == 0 || count == 1;\n}\n```"}
{"task_id": "SimdBench_115", "completion": "```cpp\nbool move_one_ball(std::vector<int> arr){\n    if (arr.empty()) return true;\n    int count = 0;\n    int n = arr.size();\n    for(int i = 0; i < n; ++i){\n        if(arr[i] > arr[(i+1)%n]){\n            count++;\n            if(count > 1) return false;\n        }\n    }\n    return count == 0 || count == 1;\n}\n```"}
{"task_id": "SimdBench_115", "completion": "```cpp\nbool move_one_ball(std::vector<int> arr){\n    if (arr.empty()) return true;\n    int count = 0;\n    int n = arr.size();\n    for(int i = 0; i < n; ++i){\n        if(arr[i] > arr[(i+1)%n]){\n            count++;\n            if(count > 1) return false;\n        }\n    }\n    return count == 0 || count == 1;\n}\n```"}
{"task_id": "SimdBench_115", "completion": "```cpp\n#include <vector>\n\nbool move_one_ball(std::vector<int> arr){\n    if (arr.empty()) return true;\n    int count = 0;\n    int n = arr.size();\n    for(int i = 0; i < n; ++i){\n        if(arr[i] > arr[(i+1)%n]){\n            count++;\n            if(count > 1) return false;\n        }\n    }\n    return count == 0 || count == 1;\n}\n```"}
{"task_id": "SimdBench_116", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::string myexchange(const std::vector<int>& lst1, const std::vector<int>& lst2){\n    int odd_count_lst1 = 0;\n    int even_count_lst2 = 0;\n    \n    for(auto num : lst1){\n        if(num % 2 != 0){\n            odd_count_lst1++;\n        }\n    }\n    \n    for(auto num : lst2){\n        if(num % 2 == 0){\n            even_count_lst2++;\n        }\n    }\n    \n    if(even_count_lst2 >= odd_count_lst1 && odd_count_lst1 > 0){\n        return \"YES\";\n    }\n    else if(odd_count_lst1 == 0){\n        return \"YES\";\n    }\n    else{\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::string myexchange(const std::vector<int>& lst1, const std::vector<int>& lst2){\n    int odd_count_lst1 = 0;\n    int even_count_lst2 = 0;\n    \n    for(auto num : lst1){\n        if(num % 2 != 0){\n            odd_count_lst1++;\n        }\n    }\n    \n    for(auto num : lst2){\n        if(num % 2 == 0){\n            even_count_lst2++;\n        }\n    }\n    \n    if(even_count_lst2 >= odd_count_lst1){\n        return \"YES\";\n    }\n    else{\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::string myexchange(const std::vector<int>& lst1, const std::vector<int>& lst2){\n    int odd_count_lst1 = 0;\n    int even_count_lst2 = 0;\n    \n    for(auto num : lst1){\n        if(num % 2 != 0){\n            odd_count_lst1++;\n        }\n    }\n    \n    for(auto num : lst2){\n        if(num % 2 == 0){\n            even_count_lst2++;\n        }\n    }\n    \n    if(even_count_lst2 >= odd_count_lst1 && odd_count_lst1 > 0){\n        return \"YES\";\n    }\n    else if(odd_count_lst1 == 0){\n        return \"YES\";\n    }\n    else{\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::string myexchange(const std::vector<int>& lst1, const std::vector<int>& lst2){\n    int odd_count_lst1 = 0;\n    int even_count_lst2 = 0;\n    \n    for(auto num : lst1){\n        if(num % 2 != 0){\n            odd_count_lst1++;\n        }\n    }\n    \n    for(auto num : lst2){\n        if(num % 2 == 0){\n            even_count_lst2++;\n        }\n    }\n    \n    if(even_count_lst2 >= odd_count_lst1 && odd_count_lst1 > 0){\n        return \"YES\";\n    }\n    else if(odd_count_lst1 == 0){\n        return \"YES\";\n    }\n    else{\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::string myexchange(const std::vector<int>& lst1, const std::vector<int>& lst2){\n    int odd_count_lst1 = 0;\n    int even_count_lst2 = 0;\n    \n    for(int num : lst1){\n        if(num % 2 != 0){\n            odd_count_lst1++;\n        }\n    }\n    \n    for(int num : lst2){\n        if(num % 2 == 0){\n            even_count_lst2++;\n        }\n    }\n    \n    if(even_count_lst2 >= odd_count_lst1 && odd_count_lst1 > 0){\n        return \"YES\";\n    }\n    else if(odd_count_lst1 == 0){\n        return \"YES\";\n    }\n    else{\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_117", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <cctype>\n\nstd::vector<std::string> odd_count(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for (const auto& s : lst) {\n        int count = 0;\n        for (char c : s) {\n            if (std::isdigit(c)) {\n                int digit = c - '0';\n                if (digit % 2 != 0) {\n                    count++;\n                }\n            }\n        }\n        std::string output = \"the number of odd elements \";\n        output += std::to_string(count);\n        output += \"n the str\";\n        output += std::to_string(count);\n        output += \"ng \";\n        output += std::to_string(count);\n        output += \" of the \";\n        output += std::to_string(count);\n        output += \"nput.\";\n        result.push_back(output);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <cctype>\n\nstd::vector<std::string> odd_count(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for (const auto& str : lst) {\n        int count = 0;\n        for (char c : str) {\n            if (std::isdigit(c)) {\n                int digit = c - '0';\n                if (digit % 2 != 0) {\n                    count++;\n                }\n            }\n        }\n        std::string output = \"the number of odd elements \";\n        output += std::to_string(count);\n        output += \"n the str\";\n        output += std::to_string(count);\n        output += \"ng \";\n        output += std::to_string(count);\n        output += \" of the \";\n        output += std::to_string(count);\n        output += \"nput.\";\n        result.push_back(output);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for (const auto& s : lst) {\n        int count = 0;\n        for (char c : s) {\n            if ((c - '0') % 2 != 0) {\n                count++;\n            }\n        }\n        std::string output = \"the number of odd elements \";\n        output += std::to_string(count);\n        output += \"n the str\";\n        output += std::to_string(count);\n        output += \"ng \";\n        output += std::to_string(count);\n        output += \" of the \";\n        output += std::to_string(count);\n        output += \"nput.\";\n        result.push_back(output);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for(const auto& str : lst){\n        int count = 0;\n        for(char c : str){\n            if((c - '0') % 2 != 0){\n                count++;\n            }\n        }\n        std::string output = \"the number of odd elements \" + std::to_string(count) + \n                             \"n the str\" + std::to_string(count) + \"ng \" + \n                             std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\";\n        result.push_back(output);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <cctype>\n\nstd::vector<std::string> odd_count(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for (const auto& s : lst) {\n        int count = 0;\n        for (char c : s) {\n            if (std::isdigit(c)) {\n                int digit = c - '0';\n                if (digit % 2 != 0) {\n                    count++;\n                }\n            }\n        }\n        std::string output = \"the number of odd elements \";\n        output += std::to_string(count);\n        output += \"n the str\";\n        output += std::to_string(count);\n        output += \"ng \";\n        output += std::to_string(count);\n        output += \" of the \";\n        output += std::to_string(count);\n        output += \"nput.\";\n        result.push_back(output);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_118", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n#include <limits>\n\nint64_t minSubArraySum(const std::vector<int64_t>& nums){\n    int64_t min_sum = std::numeric_limits<int64_t>::max();\n    int64_t current_sum = 0;\n    for(auto num : nums){\n        current_sum += num;\n        if(current_sum < min_sum){\n            min_sum = current_sum;\n        }\n        if(current_sum > 0){\n            current_sum = 0;\n        }\n    }\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n#include <limits>\n\nint64_t minSubArraySum(const std::vector<int64_t>& nums){\n    int64_t min_sum = std::numeric_limits<int64_t>::max();\n    int64_t current_sum = 0;\n    for(auto num : nums){\n        current_sum += num;\n        if(current_sum < min_sum){\n            min_sum = current_sum;\n        }\n        if(num < current_sum){\n            current_sum = num;\n        }\n    }\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118", "completion": "```cpp\n#include <vector>\n#include <limits>\n#include <inttypes.h>\n\nint64_t minSubArraySum(const std::vector<int64_t>& nums){\n    int64_t min_sum = nums[0];\n    int64_t current_sum = nums[0];\n    for(size_t i = 1; i < nums.size(); ++i){\n        current_sum = std::min(nums[i], current_sum + nums[i]);\n        min_sum = std::min(min_sum, current_sum);\n    }\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n#include <limits>\n\nint64_t minSubArraySum(const std::vector<int64_t>& nums){\n    int64_t min_sum = std::numeric_limits<int64_t>::max();\n    int64_t current_sum = 0;\n    for(auto num : nums){\n        current_sum += num;\n        if(current_sum < min_sum){\n            min_sum = current_sum;\n        }\n        if(num < current_sum){\n            current_sum = num;\n            if(current_sum < min_sum){\n                min_sum = current_sum;\n            }\n        }\n    }\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118", "completion": "```cpp\n#include <vector>\n#include <limits>\n#include <inttypes.h>\n\nint64_t minSubArraySum(const std::vector<int64_t>& nums){\n    int64_t min_sum = std::numeric_limits<int64_t>::max();\n    int64_t current_sum = 0;\n    for(auto num : nums){\n        current_sum += num;\n        if(min_sum > current_sum){\n            min_sum = current_sum;\n        }\n        if(current_sum > num){\n            current_sum = num;\n            if(min_sum > current_sum){\n                min_sum = current_sum;\n            }\n        }\n    }\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_119", "completion": "```cpp\nint max_fill(const std::vector<std::vector<int> > & grid, int capacity) {\n    int total_drops = 0;\n    for (const auto& well : grid) {\n        int water_units = 0;\n        for (int unit : well) {\n            water_units += unit;\n        }\n        if (water_units > 0) {\n            total_drops += (water_units + capacity - 1) / capacity;\n        }\n    }\n    return total_drops;\n}\n```"}
{"task_id": "SimdBench_119", "completion": "```cpp\nint max_fill(const std::vector<std::vector<int> > & grid, int capacity){\n    int total_drops = 0;\n    for(const auto & well : grid){\n        int water_units = 0;\n        for(int unit : well){\n            water_units += unit;\n        }\n        if(water_units > 0){\n            total_drops += (water_units + capacity - 1) / capacity;\n        }\n    }\n    return total_drops;\n}\n```"}
{"task_id": "SimdBench_119", "completion": "```cpp\nint max_fill(const std::vector<std::vector<int> > & grid, int capacity) {\n    int total_drops = 0;\n    for (const auto &row : grid) {\n        int water_units = 0;\n        for (int cell : row) {\n            water_units += cell;\n        }\n        if (water_units > 0) {\n            total_drops += (water_units + capacity - 1) / capacity;\n        }\n    }\n    return total_drops;\n}\n```"}
{"task_id": "SimdBench_119", "completion": "```cpp\nint max_fill(const std::vector<std::vector<int> > & grid, int capacity){\n    int total_drops = 0;\n    for(const auto &row : grid){\n        int water_units = 0;\n        for(int cell : row){\n            water_units += cell;\n        }\n        if(water_units > 0){\n            total_drops += (water_units + capacity - 1) / capacity;\n        }\n    }\n    return total_drops;\n}\n```"}
{"task_id": "SimdBench_119", "completion": "```cpp\nint max_fill(const std::vector<std::vector<int> > & grid, int capacity){\n    int total_drops = 0;\n    for (const auto& row : grid) {\n        int water_units = 0;\n        for (int cell : row) {\n            water_units += cell;\n        }\n        if (water_units > 0) {\n            total_drops += (water_units + capacity - 1) / capacity;\n        }\n    }\n    return total_drops;\n}\n```"}
{"task_id": "SimdBench_120", "completion": "```cpp\nint64_t solution(const std::vector<int16_t>& lst){\n    int64_t sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120", "completion": "```cpp\nint64_t solution(const std::vector<int16_t>& lst){\n    int64_t sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120", "completion": "```cpp\nint64_t solution(const std::vector<int16_t>& lst){\n    int64_t sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120", "completion": "```cpp\nint64_t solution(const std::vector<int16_t>& lst){\n    int64_t sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120", "completion": "```cpp\nint64_t solution(const std::vector<int16_t>& lst){\n    int64_t sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint add_elements(std::vector<int> arr, int k){\n    int sum = 0;\n    for(int i = 0; i < k; ++i){\n        if(arr[i] >= -99 && arr[i] <= 99){\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint add_elements(std::vector<int> arr, int k){\n    int sum = 0;\n    for(int i = 0; i < k; ++i){\n        if(std::abs(arr[i]) < 100){\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint add_elements(std::vector<int> arr, int k){\n    int sum = 0;\n    for(int i = 0; i < k; ++i){\n        if(std::abs(arr[i]) < 100){\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint add_elements(std::vector<int> arr, int k){\n    int sum = 0;\n    for(int i = 0; i < k; ++i){\n        if(arr[i] >= -99 && arr[i] <= 99){\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint add_elements(std::vector<int> arr, int k){\n    int sum = 0;\n    for(int i = 0; i < k; ++i){\n        if(std::abs(arr[i]) < 100){\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_122", "completion": "```cpp\nbool is_sorted(const std::vector<int> & lst){\n    if (lst.size() <= 1) return true;\n    int prev = lst[0];\n    int count = 1;\n    for (size_t i = 1; i < lst.size(); ++i) {\n        if (lst[i] < prev) return false;\n        if (lst[i] == prev) {\n            count++;\n            if (count > 2) return false;\n        } else {\n            count = 1;\n        }\n        prev = lst[i];\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_122", "completion": "```cpp\nbool is_sorted(const std::vector<int> & lst){\n    if (lst.empty()) return true;\n    int prev = lst[0];\n    int count = 1;\n    for (size_t i = 1; i < lst.size(); ++i) {\n        if (lst[i] < prev) {\n            return false;\n        }\n        if (lst[i] == prev) {\n            count++;\n            if (count > 2) {\n                return false;\n            }\n        } else {\n            count = 1;\n        }\n        prev = lst[i];\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_122", "completion": "```cpp\nbool is_sorted(const std::vector<int> & lst){\n    if (lst.empty()) return true;\n    int prev = -1;\n    int count = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i > 0 && lst[i] < lst[i - 1]) return false;\n        if (i > 0 && lst[i] == lst[i - 1]) {\n            count++;\n            if (count > 1) return false;\n        } else {\n            count = 0;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_122", "completion": "```cpp\nbool is_sorted(const std::vector<int> & lst){\n    if (lst.empty()) return true;\n    int prev = lst[0];\n    int count = 1;\n    for (size_t i = 1; i < lst.size(); ++i) {\n        if (lst[i] < prev) {\n            return false;\n        }\n        if (lst[i] == prev) {\n            count++;\n            if (count > 2) {\n                return false;\n            }\n        } else {\n            prev = lst[i];\n            count = 1;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_122", "completion": "```cpp\nbool is_sorted(const std::vector<int> & lst){\n    if (lst.empty()) return true;\n    int prev = lst[0];\n    int count = 1;\n    for (size_t i = 1; i < lst.size(); ++i) {\n        if (lst[i] < prev) {\n            return false;\n        }\n        if (lst[i] == prev) {\n            count++;\n            if (count > 2) {\n                return false;\n            }\n        } else {\n            prev = lst[i];\n            count = 1;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_123", "completion": "```cpp\n#include <vector>\n\nint prod_signs(const std::vector<int> & arr){\n    if (arr.empty()) {\n        return -32768;\n    }\n    int sum = 0;\n    int product_of_signs = 1;\n    for(auto num : arr){\n        if(num > 0){\n            product_of_signs *= 1;\n        }\n        else if(num < 0){\n            product_of_signs *= -1;\n        }\n        else{\n            product_of_signs *= 0;\n        }\n        sum += abs(num);\n    }\n    return sum * product_of_signs;\n}\n```"}
{"task_id": "SimdBench_123", "completion": "```cpp\n#include <vector>\n\nint prod_signs(const std::vector<int> & arr){\n    if (arr.empty()) return -32768;\n\n    int sum_magnitudes = 0;\n    int product_of_signs = 1;\n\n    for(auto num : arr){\n        if(num == 0){\n            product_of_signs = 0;\n            break;\n        }\n        sum_magnitudes += abs(num);\n        product_of_signs *= (num > 0) ? 1 : -1;\n    }\n\n    return sum_magnitudes * product_of_signs;\n}\n```"}
{"task_id": "SimdBench_123", "completion": "```cpp\n#include <vector>\n\nint prod_signs(const std::vector<int> & arr){\n    if (arr.empty()) return -32768;\n    \n    int sign_product = 1;\n    int magnitude_sum = 0;\n    \n    for(auto num : arr){\n        if(num == 0){\n            sign_product = 0;\n            break;\n        }\n        magnitude_sum += abs(num);\n        sign_product *= (num > 0) ? 1 : -1;\n    }\n    \n    return sign_product * magnitude_sum;\n}\n```"}
{"task_id": "SimdBench_123", "completion": "```cpp\n#include <vector>\n\nint prod_signs(const std::vector<int> & arr){\n    if (arr.empty()) return -32768;\n\n    int sign_product = 1;\n    int magnitude_sum = 0;\n\n    for(auto num : arr){\n        if(num == 0){\n            sign_product = 0;\n            break;\n        }\n        else{\n            sign_product *= (num > 0) ? 1 : -1;\n            magnitude_sum += abs(num);\n        }\n    }\n\n    return sign_product * magnitude_sum;\n}\n```"}
{"task_id": "SimdBench_123", "completion": "```cpp\n#include <vector>\n\nint prod_signs(const std::vector<int> & arr){\n    if (arr.empty()) return -32768;\n\n    int sum = 0;\n    int product_of_signs = 1;\n\n    for (const int & num : arr) {\n        if (num == 0) {\n            product_of_signs = 0;\n            break;\n        }\n        product_of_signs *= (num > 0) ? 1 : -1;\n        sum += abs(num);\n    }\n\n    return product_of_signs * sum;\n}\n```"}
{"task_id": "SimdBench_124", "completion": "```cpp\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <climits>\n\nstd::vector<int> minPath(const std::vector<std::vector<int> > & grid, int k){\n    int N = grid.size();\n    std::vector<std::vector<int>> directions = { {-1,0}, {1,0}, {0,-1}, {0,1} };\n    \n    auto isValid = [&](int x, int y) -> bool {\n        return x >= 0 && x < N && y >= 0 && y < N;\n    };\n    \n    std::priority_queue<std::vector<int>, std::vector<std::vector<int>>, std::greater<std::vector<int>>> pq;\n    \n    for(int i=0;i<N;i++) {\n        for(int j=0;j<N;j++) {\n            pq.push({grid[i][j], i, j, 1}); // value, x, y, step\n        }\n    }\n    \n    while(!pq.empty()) {\n        std::vector<int> current = pq.top();\n        pq.pop();\n        \n        int val = current[0];\n        int x = current[1];\n        int y = current[2];\n        int step = current[3];\n        \n        if(step == k) {\n            return {val};\n        }\n        \n        std::vector<int> path = {val};\n        std::queue<std::tuple<int,int,int,std::vector<int>>> q;\n        q.push({x, y, step, path});\n        \n        while(!q.empty()) {\n            auto [cx, cy, cstep, cpath] = q.front(); q.pop();\n            \n            if(cstep == k) {\n                return cpath;\n            }\n            \n            for(auto &dir : directions) {\n                int nx = cx + dir[0];\n                int ny = cy + dir[1];\n                \n                if(isValid(nx, ny)) {\n                    std::vector<int> npath = cpath;\n                    npath.push_back(grid[nx][ny]);\n                    q.push({nx, ny, cstep+1, npath});\n                }\n            }\n        }\n    }\n    \n    return {};\n}\n```"}
{"task_id": "SimdBench_124", "completion": "```cpp\n#include <vector>\n#include <queue>\n#include <tuple>\n\nstd::vector<int> minPath(const std::vector<std::vector<int> > & grid, int k){\n    int N = grid.size();\n    std::vector<std::vector<bool>> visited(N, std::vector<bool>(N, false));\n    std::priority_queue<std::tuple<std::vector<int>, std::vector<int>>, \n                        std::vector<std::tuple<std::vector<int>, std::vector<int>>>, \n                        std::greater<std::tuple<std::vector<int>, std::vector<int>>>> pq;\n\n    for(int i = 0; i < N; ++i){\n        for(int j = 0; j < N; ++j){\n            visited[i][j] = true;\n            pq.emplace(std::vector<int>{grid[i][j]}, std::vector<int>{i, j});\n            visited[i][j] = false;\n        }\n    }\n\n    int dir_x[4] = {1, -1, 0, 0};\n    int dir_y[4] = {0, 0, 1, -1};\n\n    while(!pq.empty()){\n        auto [path, pos] = pq.top(); pq.pop();\n        if(path.size() == k) return path;\n\n        int x = pos[0], y = pos[1];\n        visited[x][y] = true;\n\n        for(int d = 0; d < 4; ++d){\n            int nx = x + dir_x[d];\n            int ny = y + dir_y[d];\n\n            if(nx >= 0 && nx < N && ny >= 0 && ny < N && !visited[nx][ny]){\n                std::vector<int> new_path = path;\n                new_path.push_back(grid[nx][ny]);\n                pq.emplace(new_path, std::vector<int>{nx, ny});\n            }\n        }\n\n        visited[x][y] = false;\n    }\n\n    return {};\n}\n```"}
{"task_id": "SimdBench_124", "completion": "```cpp\n#include <vector>\n#include <queue>\n#include <tuple>\n\nstd::vector<int> minPath(const std::vector<std::vector<int> > & grid, int k){\n    int N = grid.size();\n    std::priority_queue<std::tuple<std::vector<int>, int, int, int>, \n                        std::vector<std::tuple<std::vector<int>, int, int, int>>, \n                        std::greater<std::tuple<std::vector<int>, int, int, int>>> pq;\n    \n    for(int i = 0; i < N; ++i){\n        for(int j = 0; j < N; ++j){\n            pq.emplace(std::vector<int>{grid[i][j]}, i, j, 1);\n        }\n    }\n    \n    while(!pq.empty()){\n        auto [path, x, y, len] = pq.top(); pq.pop();\n        if(len == k) return path;\n        \n        // Define possible moves: up, down, left, right\n        int dx[4] = {-1, 1, 0, 0};\n        int dy[4] = {0, 0, -1, 1};\n        \n        for(int d = 0; d < 4; ++d){\n            int nx = x + dx[d];\n            int ny = y + dy[d];\n            if(nx >= 0 && nx < N && ny >= 0 && ny < N){\n                std::vector<int> new_path = path;\n                new_path.push_back(grid[nx][ny]);\n                pq.emplace(new_path, nx, ny, len + 1);\n            }\n        }\n    }\n    return {};\n}\n```"}
{"task_id": "SimdBench_124", "completion": "```cpp\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <climits>\n\nstd::vector<int> minPath(const std::vector<std::vector<int> > & grid, int k){\n    int N = grid.size();\n    std::vector<std::vector<int>> directions = { {-1,0}, {1,0}, {0,-1}, {0,1} };\n    \n    auto isValid = [&](int x, int y) -> bool {\n        return x >= 0 && x < N && y >= 0 && y < N;\n    };\n    \n    std::vector<int> result;\n    std::priority_queue<std::vector<int>, std::vector<std::vector<int>>, std::greater<std::vector<int>>> pq;\n    \n    for(int i=0; i<N; ++i){\n        for(int j=0; j<N; ++j){\n            pq.push({grid[i][j], i, j});\n        }\n    }\n    \n    while(!pq.empty()){\n        auto current = pq.top(); pq.pop();\n        int value = current[0];\n        int x = current[1];\n        int y = current[2];\n        \n        std::vector<int> path;\n        std::vector<std::vector<bool>> visited(N, std::vector<bool>(N, false));\n        std::priority_queue<std::vector<int>, std::vector<std::vector<int>>, std::greater<std::vector<int>>> pathPq;\n        \n        pathPq.push({value, x, y});\n        visited[x][y] = true;\n        path.push_back(value);\n        \n        for(int step=1; step<k; ++step){\n            int size = pathPq.size();\n            std::vector<std::vector<int>> tempPaths;\n            bool foundNext = false;\n            \n            for(int s=0; s<size; ++s){\n                auto currPath = pathPq.top(); pathPq.pop();\n                int lastValue = currPath[0];\n                int lastX = currPath[1];\n                int lastY = currPath[2];\n                \n                for(auto &dir : directions){\n                    int newX = lastX + dir[0];\n                    int newY = lastY + dir[1];\n                    \n                    if(isValid(newX, newY) && !visited[newX][newY]){\n                        tempPaths.push_back({grid[newX][newY], newX, newY});\n                        visited[newX][newY] = true;\n                        foundNext = true;\n                    }\n                }\n            }\n            \n            if(!foundNext){\n                break;\n            }\n            \n            std::sort(tempPaths.begin(), tempPaths.end());\n            path.push_back(tempPaths[0][0]);\n            pathPq.push({tempPaths[0][0], tempPaths[0][1], tempPaths[0][2]});\n        }\n        \n        if(path.size() == k){\n            if(result.empty() || path < result){\n                result = path;\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_124", "completion": "```cpp\n#include <vector>\n#include <queue>\n#include <tuple>\n\nstd::vector<int> minPath(const std::vector<std::vector<int> > & grid, int k){\n    int N = grid.size();\n    std::vector<std::vector<int>> directions = { {-1,0}, {1,0}, {0,-1}, {0,1} };\n    \n    // Define a lambda for comparing paths in priority queue\n    auto comp = [&](const std::vector<int>& a, const std::vector<int>& b) {\n        for(int i = 0; i < a.size(); ++i){\n            if(a[i] != b[i]) return a[i] > b[i];\n        }\n        return false;\n    };\n    \n    std::priority_queue<std::vector<int>, std::vector<std::vector<int>>, decltype(comp)> pq(comp);\n    \n    for(int i = 0; i < N; ++i){\n        for(int j = 0; j < N; ++j){\n            pq.push({grid[i][j], i, j});\n        }\n    }\n    \n    while(!pq.empty()){\n        auto current = pq.top(); pq.pop();\n        std::vector<int> path = {current[0]};\n        int x = current[1], y = current[2];\n        \n        if(path.size() == k) return path;\n        \n        for(auto &dir : directions){\n            int newX = x + dir[0];\n            int newY = y + dir[1];\n            \n            if(newX >= 0 && newX < N && newY >= 0 && newY < N){\n                std::vector<int> newPath = path;\n                newPath.push_back(grid[newX][newY]);\n                if(newPath.size() == k){\n                    return newPath;\n                }\n                pq.push(newPath);\n            }\n        }\n    }\n    return {};\n}\n```"}
{"task_id": "SimdBench_125", "completion": "```cpp\nuint64_t digits(uint64_t n){\n    uint64_t product = 1;\n    bool has_odd = false;\n    while(n > 0){\n        uint64_t digit = n % 10;\n        if(digit % 2 != 0){\n            product *= digit;\n            has_odd = true;\n        }\n        n /= 10;\n    }\n    return has_odd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_125", "completion": "```cpp\nuint64_t digits(uint64_t n){\n    uint64_t product = 1;\n    bool has_odd = false;\n    while (n > 0) {\n        uint64_t digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n            has_odd = true;\n        }\n        n /= 10;\n    }\n    return has_odd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_125", "completion": "```cpp\nuint64_t digits(uint64_t n){\n    uint64_t product = 1;\n    bool has_odd = false;\n    while(n > 0){\n        uint64_t digit = n % 10;\n        if(digit % 2 != 0){\n            product *= digit;\n            has_odd = true;\n        }\n        n /= 10;\n    }\n    return has_odd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_125", "completion": "```cpp\nuint64_t digits(uint64_t n){\n    uint64_t product = 1;\n    bool has_odd = false;\n    while(n > 0){\n        uint64_t digit = n % 10;\n        if(digit % 2 != 0){\n            product *= digit;\n            has_odd = true;\n        }\n        n /= 10;\n    }\n    return has_odd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_125", "completion": "```cpp\nuint64_t digits(uint64_t n){\n    uint64_t product = 1;\n    bool has_odd = false;\n    while(n > 0){\n        uint64_t digit = n % 10;\n        if(digit % 2 != 0){\n            product *= digit;\n            has_odd = true;\n        }\n        n /= 10;\n    }\n    return has_odd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_126", "completion": "```cpp\n#include <cmath>\n#include <vector>\n#include <cstdint>\n\nuint64_t sum_squares(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    for(auto num : lst){\n        int ceil_num = static_cast<int>(std::ceil(num));\n        sum += static_cast<uint64_t>(ceil_num) * ceil_num;\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126", "completion": "```cpp\n#include <cmath>\n#include <vector>\n#include <cstdint>\n\nuint64_t sum_squares(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    for(auto num : lst){\n        int ceil_num = static_cast<int>(std::ceil(num));\n        sum += static_cast<uint64_t>(ceil_num) * ceil_num;\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126", "completion": "```cpp\n#include <cmath>\n#include <vector>\n#include <cstdint>\n\nuint64_t sum_squares(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    for(auto num : lst){\n        int ceil_num = static_cast<int>(std::ceil(num));\n        sum += static_cast<uint64_t>(ceil_num) * ceil_num;\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126", "completion": "```cpp\n#include <cmath>\n#include <vector>\n#include <cstdint>\n\nuint64_t sum_squares(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    for(auto num : lst){\n        int ceil_num = static_cast<int>(std::ceil(num));\n        sum += static_cast<uint64_t>(ceil_num) * ceil_num;\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126", "completion": "```cpp\n#include <cmath>\n#include <vector>\n#include <cstdint>\n\nuint64_t sum_squares(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    for(auto num : lst){\n        int rounded = static_cast<int>(std::ceil(num));\n        sum += static_cast<uint64_t>(rounded) * rounded;\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_127", "completion": "```cpp\nint can_arrange(const std::vector<int> & arr){\n    for(int i = arr.size() - 1; i > 0; --i){\n        if(arr[i] < arr[i-1]){\n            return i;\n        }\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_127", "completion": "```cpp\nint can_arrange(const std::vector<int> & arr){\n    for(int i = arr.size() - 1; i > 0; --i){\n        if(arr[i] < arr[i-1]){\n            return i;\n        }\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_127", "completion": "```cpp\nint can_arrange(const std::vector<int> & arr){\n    for(int i = arr.size() - 1; i > 0; --i){\n        if(arr[i] < arr[i-1]){\n            return i;\n        }\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_127", "completion": "```cpp\nint can_arrange(const std::vector<int> & arr){\n    for(int i = arr.size() - 1; i > 0; --i){\n        if(arr[i] < arr[i-1]){\n            return i;\n        }\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_127", "completion": "```cpp\nint can_arrange(const std::vector<int> & arr){\n    for(int i = arr.size() - 1; i > 0; --i){\n        if(arr[i] < arr[i-1]){\n            return i;\n        }\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_128", "completion": "```cpp\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers(const std::vector<int>& lst){\n    int max_negative = -std::numeric_limits<int>::max();\n    bool has_negative = false;\n    int min_positive = std::numeric_limits<int>::max();\n    bool has_positive = false;\n\n    for(auto num : lst){\n        if(num < 0){\n            has_negative = true;\n            if(num > max_negative){\n                max_negative = num;\n            }\n        }\n        else if(num > 0){\n            has_positive = true;\n            if(num < min_positive){\n                min_positive = num;\n            }\n        }\n    }\n\n    if(!has_negative){\n        max_negative = 0;\n    }\n    if(!has_positive){\n        min_positive = 0;\n    }\n\n    return {max_negative, min_positive};\n}\n```"}
{"task_id": "SimdBench_128", "completion": "```cpp\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers(const std::vector<int>& lst){\n    int max_negative = std::numeric_limits<int>::min();\n    int min_positive = std::numeric_limits<int>::max();\n    \n    for(auto num : lst){\n        if(num < 0 && num > max_negative){\n            max_negative = num;\n        }\n        if(num > 0 && num < min_positive){\n            min_positive = num;\n        }\n    }\n    \n    if(max_negative == std::numeric_limits<int>::min()){\n        max_negative = 0;\n    }\n    if(min_positive == std::numeric_limits<int>::max()){\n        min_positive = 0;\n    }\n    \n    return {max_negative, min_positive};\n}\n```"}
{"task_id": "SimdBench_128", "completion": "```cpp\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers(const std::vector<int>& lst){\n    int max_negative = -std::numeric_limits<int>::max();\n    int min_positive = std::numeric_limits<int>::max();\n    bool has_negative = false;\n    bool has_positive = false;\n\n    for(auto num : lst){\n        if(num < 0){\n            has_negative = true;\n            if(num > max_negative){\n                max_negative = num;\n            }\n        }\n        else if(num > 0){\n            has_positive = true;\n            if(num < min_positive){\n                min_positive = num;\n            }\n        }\n    }\n\n    return {has_negative ? max_negative : 0, has_positive ? min_positive : 0};\n}\n```"}
{"task_id": "SimdBench_128", "completion": "```cpp\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers(const std::vector<int>& lst){\n    int max_negative = std::numeric_limits<int>::min();\n    int min_positive = std::numeric_limits<int>::max();\n    \n    for(auto num : lst){\n        if(num > 0 && num < min_positive){\n            min_positive = num;\n        }\n        if(num < 0 && num > max_negative){\n            max_negative = num;\n        }\n    }\n    \n    if(max_negative == std::numeric_limits<int>::min()){\n        max_negative = 0;\n    }\n    if(min_positive == std::numeric_limits<int>::max()){\n        min_positive = 0;\n    }\n    \n    return {max_negative, min_positive};\n}\n```"}
{"task_id": "SimdBench_128", "completion": "```cpp\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers(const std::vector<int>& lst){\n    int max_negative = -std::numeric_limits<int>::max();\n    bool has_negative = false;\n    int min_positive = std::numeric_limits<int>::max();\n    bool has_positive = false;\n    \n    for(auto num : lst){\n        if(num < 0){\n            has_negative = true;\n            if(num > max_negative){\n                max_negative = num;\n            }\n        }\n        else if(num > 0){\n            has_positive = true;\n            if(num < min_positive){\n                min_positive = num;\n            }\n        }\n    }\n    \n    return {has_negative ? max_negative : 0, has_positive ? min_positive : 0};\n}\n```"}
{"task_id": "SimdBench_129", "completion": "```c\n#include <stdint.h>\n\nuint64_t factorial(uint64_t k) {\n    uint64_t result = 1;\n    for (uint64_t i = 2; i <= k; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\nuint64_t special_factorial(uint64_t n){\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; ++i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_129", "completion": "```c\n#include <stdint.h>\n\nuint64_t factorial(uint64_t k) {\n    uint64_t result = 1;\n    for (uint64_t i = 2; i <= k; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\nuint64_t special_factorial(uint64_t n){\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; ++i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_129", "completion": "```c\n#include <stdint.h>\n\nuint64_t factorial(uint64_t k) {\n    uint64_t result = 1;\n    for (uint64_t i = 2; i <= k; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\nuint64_t special_factorial(uint64_t n){\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; ++i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_129", "completion": "```c\n#include <stdint.h>\n\nuint64_t factorial(uint64_t k) {\n    uint64_t result = 1;\n    for (uint64_t i = 2; i <= k; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\nuint64_t special_factorial(uint64_t n){\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; ++i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_129", "completion": "```c\n#include <stdint.h>\n\nuint64_t factorial(uint64_t k) {\n    uint64_t result = 1;\n    for (uint64_t i = 2; i <= k; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\nuint64_t special_factorial(uint64_t n){\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; ++i) {\n        result *= factorial(i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_130", "completion": "```cpp\nint sum_squares(const std::vector<int> & lst){\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        }\n        else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        }\n        else {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130", "completion": "```cpp\nint sum_squares(const std::vector<int> & lst){\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130", "completion": "```cpp\nint sum_squares(const std::vector<int> & lst){\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        }\n        else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        }\n        else {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130", "completion": "```cpp\nint sum_squares(const std::vector<int> & lst){\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        }\n        else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        }\n        else {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130", "completion": "```cpp\nint sum_squares(const std::vector<int> & lst){\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i){\n        if (i % 3 == 0){\n            sum += lst[i] * lst[i];\n        }\n        else if (i % 4 == 0){\n            sum += lst[i] * lst[i] * lst[i];\n        }\n        else{\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_131", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint specialFilter(const std::vector<int> & nums){\n    int count = 0;\n    for(auto num : nums){\n        if(num > 10){\n            int absNum = std::abs(num);\n            int lastDigit = absNum % 10;\n            int firstDigit = absNum;\n            while(firstDigit >= 10){\n                firstDigit /= 10;\n            }\n            if( (firstDigit % 2 != 0) && (lastDigit % 2 != 0) ){\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_131", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint specialFilter(const std::vector<int> & nums){\n    int count = 0;\n    for(auto num : nums){\n        if(num > 10){\n            int temp = abs(num);\n            int lastDigit = temp % 10;\n            int firstDigit = 0;\n            while(temp > 0){\n                firstDigit = temp % 10;\n                temp /= 10;\n            }\n            if(firstDigit % 2 != 0 && lastDigit % 2 != 0){\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_131", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint specialFilter(const std::vector<int> & nums){\n    int count = 0;\n    for (int num : nums) {\n        if (num > 10) {\n            int absNum = std::abs(num);\n            int lastDigit = absNum % 10;\n            int firstDigit = absNum;\n            while (firstDigit >= 10) {\n                firstDigit /= 10;\n            }\n            if (firstDigit % 2 != 0 && lastDigit % 2 != 0) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_131", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint specialFilter(const std::vector<int> & nums){\n    int count = 0;\n    for(auto num : nums){\n        if(num > 10){\n            int absNum = std::abs(num);\n            int lastDigit = absNum % 10;\n            int firstDigit = absNum;\n            while(firstDigit >= 10){\n                firstDigit /= 10;\n            }\n            if( (firstDigit % 2 != 0) && (lastDigit % 2 != 0) ){\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_131", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint specialFilter(const std::vector<int> & nums){\n    int count = 0;\n    for(auto num : nums){\n        if(num > 10){\n            int absNum = std::abs(num);\n            int lastDigit = absNum % 10;\n            int firstDigit = absNum;\n            while(firstDigit >= 10){\n                firstDigit /= 10;\n            }\n            if( (firstDigit % 2 != 0) && (lastDigit % 2 != 0) ){\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_132", "completion": "```cpp\nuint64_t get_max_triples(uint64_t n){\n    if(n < 3) return 0;\n    uint64_t count[3] = {0};\n    for(uint64_t i = 1; i <= n; ++i){\n        uint64_t val = (i * i - i + 1) % 3;\n        count[val]++;\n    }\n    uint64_t result = 0;\n    // All three numbers have remainder 0\n    if(count[0] >= 3){\n        result += (count[0] * (count[0] - 1) * (count[0] - 2)) / 6;\n    }\n    // Two numbers with remainder 1 and one number with remainder 0\n    if(count[1] >= 2 && count[0] >= 1){\n        result += (count[1] * (count[1] - 1) / 2) * count[0];\n    }\n    // Two numbers with remainder 2 and one number with remainder 0\n    if(count[2] >= 2 && count[0] >= 1){\n        result += (count[2] * (count[2] - 1) / 2) * count[0];\n    }\n    // One number with each remainder\n    if(count[0] >= 1 && count[1] >= 1 && count[2] >= 1){\n        result += count[0] * count[1] * count[2];\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_132", "completion": "```cpp\nuint64_t get_max_triples(uint64_t n){\n    if (n < 3) return 0;\n    \n    uint64_t count[3] = {0};\n    for(uint64_t i = 1; i <= n; ++i){\n        uint64_t val = (i * i - i + 1) % 3;\n        count[val]++;\n    }\n    \n    uint64_t res = 0;\n    // all three numbers have remainder 0\n    if(count[0] >=3){\n        res += count[0]*(count[0]-1)*(count[0]-2)/6;\n    }\n    // two numbers have remainder 1 and one has remainder 0\n    if(count[1] >=2 && count[0] >=1){\n        res += count[1]*(count[1]-1)/2 * count[0];\n    }\n    // two numbers have remainder 2 and one has remainder 0\n    if(count[2] >=2 && count[0] >=1){\n        res += count[2]*(count[2]-1)/2 * count[0];\n    }\n    // each number has different remainder\n    if(count[0] >=1 && count[1] >=1 && count[2] >=1){\n        res += count[0]*count[1]*count[2];\n    }\n    \n    return res;\n}\n```"}
{"task_id": "SimdBench_132", "completion": "```cpp\nuint64_t get_max_triples(uint64_t n){\n    if (n < 3) return 0;\n    \n    uint64_t count[3] = {0};\n    for(uint64_t i = 1; i <= n; ++i){\n        uint64_t val = (i * i - i + 1) % 3;\n        count[val]++;\n    }\n    \n    uint64_t total = 0;\n    // All three numbers have remainder 0\n    if(count[0] >=3){\n        total += (count[0] * (count[0]-1) * (count[0]-2)) /6;\n    }\n    // Two numbers have remainder 1 and one number has remainder 0\n    if(count[1] >=2 && count[0] >=1){\n        total += (count[1] * (count[1]-1) /2) * count[0];\n    }\n    // Two numbers have remainder 2 and one number has remainder 0\n    if(count[2] >=2 && count[0] >=1){\n        total += (count[2] * (count[2]-1) /2) * count[0];\n    }\n    // One number has each of the remainders 0, 1, and 2\n    if(count[0] >=1 && count[1] >=1 && count[2] >=1){\n        total += count[0] * count[1] * count[2];\n    }\n    return total;\n}\n```"}
{"task_id": "SimdBench_132", "completion": "```cpp\nuint64_t get_max_triples(uint64_t n){\n    if(n < 3) return 0;\n    \n    uint64_t count[3] = {0};\n    for(uint64_t i = 1; i <= n; ++i){\n        uint64_t val = (i * i - i + 1) % 3;\n        count[val]++;\n    }\n    \n    uint64_t res = 0;\n    // All three numbers have remainder 0\n    if(count[0] >= 3){\n        res += (count[0] * (count[0]-1) * (count[0]-2)) / 6;\n    }\n    // Two numbers have remainder 1 and one number has remainder 0\n    if(count[1] >= 2 && count[0] >=1){\n        res += (count[1] * (count[1]-1) / 2) * count[0];\n    }\n    // Two numbers have remainder 2 and one number has remainder 0\n    if(count[2] >= 2 && count[0] >=1){\n        res += (count[2] * (count[2]-1) / 2) * count[0];\n    }\n    // Each number has different remainder\n    if(count[0] >=1 && count[1] >=1 && count[2] >=1){\n        res += count[0] * count[1] * count[2];\n    }\n    \n    return res;\n}\n```"}
{"task_id": "SimdBench_132", "completion": "```cpp\nuint64_t get_max_triples(uint64_t n){\n    if (n < 3) return 0;\n    uint64_t count[3] = {0};\n    for(uint64_t i = 1; i <= n; ++i){\n        uint64_t val = (i * i - i + 1) % 3;\n        count[val]++;\n    }\n    uint64_t res = 0;\n    // all three numbers have remainder 0\n    if(count[0] >=3){\n        res += count[0]*(count[0]-1)*(count[0]-2)/6;\n    }\n    // two numbers have remainder 1 and one number has remainder 0\n    if(count[1] >=2 && count[0] >=1){\n        res += count[1]*(count[1]-1)*count[0]/2;\n    }\n    // two numbers have remainder 2 and one number has remainder 0\n    if(count[2] >=2 && count[0] >=1){\n        res += count[2]*(count[2]-1)*count[0]/2;\n    }\n    // each number has different remainders\n    res += count[0]*count[1]*count[2];\n    return res;\n}\n```"}
{"task_id": "SimdBench_133", "completion": "```c\nint x_or_y(int n, int x, int y){\n    if (n < 2) return y;\n    for(int i = 2; i * i <= n; i++){\n        if(n % i == 0) return y;\n    }\n    return x;\n}\n```"}
{"task_id": "SimdBench_133", "completion": "```c\nint x_or_y(int n, int x, int y){\n    if (n <= 1) return y;\n    for(int i = 2; i * i <= n; i++) {\n        if(n % i == 0) return y;\n    }\n    return x;\n}\n```"}
{"task_id": "SimdBench_133", "completion": "```c\nint x_or_y(int n, int x, int y){\n    if (n < 2) return y;\n    for(int i = 2; i * i <= n; i++){\n        if(n % i == 0) return y;\n    }\n    return x;\n}\n```"}
{"task_id": "SimdBench_133", "completion": "```c\nint x_or_y(int n, int x, int y){\n    if (n < 2) return y;\n    for(int i = 2; i * i <= n; i++){\n        if(n % i == 0) return y;\n    }\n    return x;\n}\n```"}
{"task_id": "SimdBench_133", "completion": "```c\nint x_or_y(int n, int x, int y){\n    if (n < 2) return y;\n    for(int i = 2; i * i <= n; i++) {\n        if(n % i == 0) return y;\n    }\n    return x;\n}\n```"}
{"task_id": "SimdBench_134", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nuint64_t double_the_difference(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    for(auto num : lst){\n        if(num > 0 && static_cast<int>(num) == num){\n            int int_num = static_cast<int>(num);\n            if(int_num % 2 != 0){\n                sum += int_num * int_num;\n            }\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <cstdint>\n\nuint64_t double_the_difference(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    for(auto num : lst){\n        if(num > 0 && std::floor(num) == num){ // Check if positive and integer\n            int n = static_cast<int>(num);\n            if(n % 2 != 0){ // Check if odd\n                sum += n * n;\n            }\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nuint64_t double_the_difference(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    for(auto num : lst){\n        if(num > 0 && static_cast<int>(num) == num){\n            int int_num = static_cast<int>(num);\n            if(int_num % 2 != 0){\n                sum += int_num * int_num;\n            }\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nuint64_t double_the_difference(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    for(auto num : lst){\n        if(num > 0 && static_cast<int>(num) == num){\n            int int_num = static_cast<int>(num);\n            if(int_num % 2 != 0){\n                sum += int_num * int_num;\n            }\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nuint64_t double_the_difference(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    for(auto num : lst){\n        if(num > 0 && static_cast<int>(num) == num){\n            int int_num = static_cast<int>(num);\n            if(int_num % 2 != 0){\n                sum += int_num * int_num;\n            }\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_135", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nstd::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess){\n    std::vector<int> result;\n    for (size_t i = 0; i < game.size(); ++i) {\n        result.push_back(std::abs(game[i] - guess[i]));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nstd::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess){\n    std::vector<int> result;\n    for (size_t i = 0; i < game.size(); ++i) {\n        result.push_back(std::abs(game[i] - guess[i]));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nstd::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess){\n    std::vector<int> result;\n    for (size_t i = 0; i < game.size(); ++i) {\n        result.push_back(std::abs(game[i] - guess[i]));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nstd::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess){\n    std::vector<int> result;\n    for (size_t i = 0; i < game.size(); ++i) {\n        result.push_back(std::abs(game[i] - guess[i]));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nstd::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess){\n    std::vector<int> result;\n    for (size_t i = 0; i < game.size(); ++i) {\n        result.push_back(std::abs(game[i] - guess[i]));\n    }\n    return result;\n}\n```"}

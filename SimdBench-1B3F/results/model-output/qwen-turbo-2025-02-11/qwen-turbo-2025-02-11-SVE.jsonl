{"task_id": "SimdBench_0_SVE", "completion": "```c\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, length);\n    while (svptest_any(svptrue_b64(), pg)) {\n        svint64_t src_vec = svld1(pg, src + i);\n        svbool_t mask_vec = svld1_b64(pg, mask + i);\n        svst1(pg, dst + i, svsel(mask_vec, src_vec, svld1(pg, dst + i)));\n        i += svcntd();\n        pg = svwhilelt_b64(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_0_SVE", "completion": "```c\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, length);\n    while(svptest_any(svptrue_b64(), pg)){\n        svst1_s64(pg, dst, svtbl_s64(pg, svld1_s64(pg, src), svld1_b64(pg, mask)));\n        i += svcntd();\n        pg = svwhilelt_b64(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_0_SVE", "completion": "```c\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, length);\n    while (svptest_any(svptrue_b64(), pg)) {\n        svint64_t src_vec = svld1(pg, src + i);\n        svbool_t mask_vec = svld1_b64(pg, mask + i);\n        svst1(pg, dst + i, svsel(mask_vec, src_vec, svld1(pg, dst + i)));\n        i += svcntd();\n        pg = svwhilelt_b64(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_0_SVE", "completion": "```c\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, length);\n    while (svptest_any(svptrue_b64(), pg)) {\n        svint64_t src_vec = svld1(pg, src + i);\n        svbool_t mask_vec = svld1_b64(pg, mask + i);\n        svst1(pg, dst + i, svcond_b64(mask_vec, src_vec, svdup_n_s64(0)));\n        i += svcntd();\n        pg = svwhilelt_b64(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_0_SVE", "completion": "```c\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, length);\n    while(svptest_any(svptrue_b64(), pg)){\n        svst1_g64(pg, dst, svsel_g64(pg, svld1_g64(pg, src), svld1_g64(pg, dst), svld1_b64(pg, mask)));\n        i += svcntd();\n        pg = svwhilelt_b64(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    svint32_t src_vec = svld1(pg, src);\n    svint32_t scale_vec = svdup_n_s32(scale);\n    \n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t tmp1 = svashr_n_s32(svmla_x(pg, src_vec, scale_vec), 3);\n        svint32_t tmp2 = svshl_n_s32(svmla_x(pg, src_vec, scale_vec), 3);\n        svint32_t result = svdiv_x(pg, svadd_x(pg, svmla_x(pg, src_vec, scale_vec), svmls_x(pg, tmp1, tmp2)), 7);\n        \n        svst1(pg, dst, result);\n        \n        pg = svnext(pg);\n        src_vec = svld1(pg, src);\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    svint32_t src_vec = svld1(pg, src);\n    svint32_t scale_vec = svdup_n_s32(scale);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t tmp1 = svashr_n_s32(svsmul_n_s32(src_vec, scale_vec), 3);\n        svint32_t tmp2 = svshl_n_s32(svsmul_n_s32(src_vec, scale_vec), 3);\n        svint32_t numerator = svadd_n_s32(svsmul_n_s32(src_vec, scale_vec), svsmul_n_s32(tmp1, tmp2));\n        svint32_t result = svdiv_n_s32(numerator, 7);\n        svst1(pg, dst, result);\n\n        pg = svnextblock(pg, length);\n        src_vec = svld1(pg, src);\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    svint32_t src_vec = svld1(pg, src);\n    svint32_t scale_vec = svdup_n_s32(scale);\n    \n    svint32_t tmp1 = svashr_n_s32(svmla_xn_s32(src_vec, scale_vec, scale_vec), 3);\n    svint32_t tmp2 = svlsl_n_s32(svmla_xn_s32(src_vec, scale_vec, scale_vec), 3);\n    svint32_t result = svdiv_rn_s32(svmla_xn_s32(src_vec, scale_vec, scale_vec), svdup_n_s32(7));\n    \n    svst1(pg, dst, result);\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    svint32_t src_vec = svld1(pg, src);\n    svint32_t scale_vec = svdup_n_s32(scale);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t tmp1 = svashr_n_s32(svmla_xn_s32(src_vec, scale_vec, scale_vec), 3);\n        svint32_t tmp2 = svshl_n_s32(svmla_xn_s32(src_vec, scale_vec, scale_vec), 3);\n        svint32_t result = svdiv_s32(svmla_xn_s32(src_vec, scale_vec, tmp2), 7);\n        svst1(pg, dst, result);\n\n        pg = svnext(pg);\n        src_vec = svld1(pg, src);\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    svint32_t src_vec = svld1(pg, src);\n    svint32_t scale_vec = svdup_n_s32(scale);\n    \n    svint32_t tmp1 = svashr_n_s32(svmla_xn_s32(src_vec, scale_vec, scale_vec), 3);\n    svint32_t tmp2 = svlsl_n_s32(svmla_xn_s32(src_vec, scale_vec, scale_vec), 3);\n    svint32_t result = svdiv_n_s32(svadd_xn_s32(svmla_xn_s32(src_vec, scale_vec, scale_vec), tmp1, tmp2), 7);\n    \n    svst1(pg, dst, result);\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t vector_length = svcntd(); // Number of double elements in a vector\n    size_t i = 0;\n    \n    while (i < rows) {\n        size_t elements_to_process = rows - i;\n        if (elements_to_process >= vector_length) {\n            svfloat64_t vec = svld1_sve(src + i * cols + stride, vector_length);\n            svst1_sve(dst + i, vector_length, vec);\n            i += vector_length;\n        }\n        else {\n            svfloat64_t vec = svld1_sve(src + i * cols + stride, elements_to_process);\n            svst1_sve(dst + i, elements_to_process, vec);\n            break;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, rows);\n    while (svptest_any(svptrue_b64(), pg)) {\n        svst1q_gather_index_s64(pg, dst + i, svld1q_gather_index_s64(pg, src, svindex_r32(i, stride, stride)));\n        i += svcntd();\n        pg = svwhilelt_b64(i, rows);\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t r;\n    for (r = 0; r < rows; r++) {\n        svfloat64_t vec = svld1_gather_index(svptrue_b64(), src, svindex_r(r * cols + stride, 1));\n        svst1_scatter_index(dst + r, svptrue_b64(), vec);\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, rows);\n    while (svptest_any(svptrue_b64(), pg)) {\n        svst1q_gather_index_s64(pg, dst + i, svld1q_gather_index_s64(pg, src, svindex_r32(0, stride, 1)));\n        i += svcntd();\n        pg = svwhilelt_b64(i, rows);\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, rows);\n    while (svptest_any(svptrue_b64(), pg)) {\n        svst1q_gather_index_s64(pg, dst + i, svld1q_gather_index_s64(pg, src, svindex_r32(0, stride, 1)));\n        i += svcntd();\n        pg = svwhilelt_b64(i, rows);\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t src_vec = svld1(pg, src);\n        svint32_t indices_vec = svld1(pg, indices);\n        svst1(pg, dst + svindex_r32(indices_vec), src_vec);\n        svst1(pg, src + svindex_w32(indices_vec), src_vec);\n        pg = svwhilelt_b32(svindex_r32(indices_vec)[svcntv()], length);\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t src_vec = svld1(pg, src);\n        svint32_t indices_vec = svld1(pg, indices);\n        svst1(pg, dst + svindex_r32(indices_vec), src_vec);\n        svst1(pg, src + svindex_w32(indices_vec), src_vec);\n        pg = svwhilelt_b32(svindex_r32(indices_vec)[svcntv()-1], length);\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t src_vec = svld1(pg, src);\n        svint32_t indices_vec = svld1(pg, indices);\n        svst1(pg, dst + svindex_r32(indices_vec), src_vec);\n        svst1(pg, src + svindex_w32(indices_vec), src_vec);\n        pg = svnext(pg);\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t src_vec = svld1(pg, src);\n        svint32_t indices_vec = svld1(pg, indices);\n        svst1(pg, dst + svindex_r32(indices_vec), src_vec);\n        svst1(pg, src + svindex_w32(indices_vec), src_vec);\n        pg = svwhilelt_b32(svindex_r32(indices_vec)[svcntv()], length);\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t vector_length = svcntw(); // Determine the vector length\n    svfloat32_t src_vec;\n    svint32_t indices_vec;\n    svfloat32_t dst_vec;\n\n    for (size_t i = 0; i < length; i += vector_length) {\n        size_t elements = (length - i) >= vector_length ? vector_length : (length - i);\n\n        // Gather operation\n        src_vec = svld1_gather_offset_s32(src, indices, elements);\n        svst1_scatter_offset_s32(dst, indices, src_vec, elements);\n\n        // Scatter operation\n        indices_vec = svld1(indices, elements);\n        dst_vec = svld1(dst, elements);\n        svst1_scatter_offset_s32(dst, indices_vec, dst_vec, elements);\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    svbool_t pg = svwhilelt_b64(start, end);\n    uint64_t len = svcntb(pg);\n    int16_t *start_ptr = arr + start;\n    int16_t *end_ptr = arr + end;\n\n    while (len > 0) {\n        int16_t vec_a[sve_len / 16];\n        int16_t vec_b[sve_len / 16];\n        svst1_s16(pg, start_ptr, svld1(pg, end_ptr));\n        svst1_s16(pg, end_ptr, svld1(pg, start_ptr));\n        start_ptr += svcntw();\n        end_ptr -= svcntw();\n        pg = svwhilelt_b64((int64_t)start_ptr - (int64_t)arr, (int64_t)arr + (int64_t)end + 1);\n        len = svcntb(pg);\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    svbool_t pg = svwhilelt_b32((int32_t)start, (int32_t)end);\n    svint16_t reversed;\n    svint16_t original = svld1(pg, arr + start);\n    \n    // Reverse vector\n    reversed = svtrn1_u8(svreinterpret_u8(original), svreinterpret_u8(original));\n    reversed = svrev_b16(reversed);\n    \n    // Store back the reversed elements\n    svst1(pg, arr + start, reversed);\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    size_t n = end - start + 1;\n    svbool_t pg = svwhilelt_b16(0, n);\n\n    // Load the range to be reversed\n    svint16_t vec = svld1(pg, arr + start);\n\n    // Reverse the vector\n    svint16_t reversed_vec = svtrn2_s16(vec, vec);\n\n    // Store the reversed vector back to the array\n    svst1(pg, arr + start, reversed_vec);\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    size_t n = end - start + 1;\n    svbool_t pg = svwhilelt_b((uint64_t)0, n);\n\n    // Load the range to be reversed\n    svint16_t vec = svld1_gather_index(pg, arr + start);\n\n    // Reverse the vector\n    svint16_t reversed_vec = svtrn2(svrevb(vec), svrevh(vec));\n\n    // Store the reversed vector back into the array\n    svst1_scatter_index(pg, arr + start, reversed_vec);\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    size_t n = end - start + 1;\n    svbool_t pg = svwhilelt_b((uint64_t)0, n);\n\n    // Load the range to be reversed\n    svint16_t vec = svld1(pg, arr + start);\n\n    // Reverse the vector\n    svint16_t reversed_vec = svtrn2(svrevb(vec), svrevh(vec));\n\n    // Store the reversed vector back into the array\n    svst1(pg, arr + start, reversed_vec);\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```c\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b((svuint64_t)i, dim2);\n    while (svptest_any(svptrue_b(), pg)) {\n        svst1_u8(pg, slice + svindex_u64(i), svld1_u8(tensor + slice_idx * dim1 * dim3 + svindex_u64(i) * dim1));\n        i += svcntd();\n        pg = svwhilelt_b((svuint64_t)i, dim2);\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```c\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b8(i, dim1 * dim2);\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t indices = svindex_u8(0, 1);\n        svuint8_t base_indices = svuzp1_u8(indices, indices);\n        svuint8_t offsets = svmla_u8(base_indices, indices, dim3);\n        svuint8_t slice_indices = svadd_u8(svindex_u8(slice_idx * dim3, 0), offsets);\n        svuint8_t tensor_indices = svadd_u8(svindex_u8(0, 0), slice_indices);\n        sve store_slice = svld1(pg, &tensor[tensor_indices]);\n        svst1(pg, &slice[i], store_slice);\n        i += svcntb();\n        pg = svwhilelt_b8(i, dim1 * dim2);\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```c\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b((svuint64_t)i, dim2);\n    while (svptest_any(svptrue_b(), pg)) {\n        svst1_u8(pg, slice + svindex_u64(i), svld1_u8(tensor + slice_idx * dim1 * dim3 + svindex_u64(i) * dim1));\n        i += svcntd();\n        pg = svwhilelt_b((svuint64_t)i, dim2);\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```c\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b((svuint64_t)i, dim2);\n    while (svptest_any(svptrue_b(), pg)) {\n        svst1_u8(pg, slice + svindex_u32(i), svld1_u8(tensor + slice_idx * dim1 * dim3 + i * dim1));\n        i += svcntd();\n        pg = svwhilelt_b((svuint64_t)i, dim2);\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```c\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b8(i, dim2);\n    while (svptest_any(svptrue_b8(), pg)) {\n        svst1_u8(pg, slice + i, svld1_u8(tensor + i * dim3 + slice_idx));\n        i += svcntw();\n        pg = svwhilelt_b8(i, dim2);\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    size_t i, j, k;\n    size_t blocks = (rows + block_size - 1) / block_size;\n    size_t block_cols = (cols + block_size - 1) / block_size;\n\n    for (i = 0; i < blocks; ++i) {\n        size_t row_start = i * block_size;\n        size_t row_end = row_start + block_size;\n        if (row_end > rows) row_end = rows;\n\n        for (j = 0; j < block_cols; ++j) {\n            size_t col_start = j * block_size;\n            size_t col_end = col_start + block_size;\n            if (col_end > cols) col_end = cols;\n\n            size_t block_size_local = row_end - row_start;\n            size_t block_size_local_T = col_end - col_start;\n\n            svint16_t buf[block_size];\n            for (k = 0; k < block_size_local; ++k) {\n                svst128_s16(buf[k].v, src + (row_start + k) * cols + col_start);\n            }\n\n            for (k = 0; k < block_size_local_T; ++k) {\n                svst128_s16(dst + (col_start + k) * rows + row_start, buf[k].v);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    size_t i, j, k;\n    size_t blocks = (rows + block_size - 1) / block_size;\n    \n    for (i = 0; i < blocks; ++i) {\n        size_t row_start = i * block_size;\n        size_t row_end = (row_start + block_size <= rows) ? row_start + block_size : rows;\n        size_t row_count = row_end - row_start;\n\n        for (j = 0; j < blocks; ++j) {\n            size_t col_start = j * block_size;\n            size_t col_end = (col_start + block_size <= cols) ? col_start + block_size : cols;\n            size_t col_count = col_end - col_start;\n\n            svint16_t temp[col_count];\n            \n            for (k = 0; k < row_count; ++k) {\n                size_t idx = (row_start + k) * cols + col_start;\n                svint16_t vec = svld1((const svint16_t *)(src + idx));\n                temp[k] = vec;\n            }\n\n            for (k = 0; k < row_count; ++k) {\n                size_t idx = col_start * rows + (row_start + k);\n                svst1((svint16_t *)(dst + idx), temp[k]);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    size_t i, j, k;\n    size_t blocks = (rows + block_size - 1) / block_size;\n    \n    for (i = 0; i < blocks; ++i) {\n        size_t row_start = i * block_size;\n        size_t row_end = (row_start + block_size <= rows) ? row_start + block_size : rows;\n        size_t block_rows = row_end - row_start;\n\n        for (j = 0; j < blocks; ++j) {\n            size_t col_start = j * block_size;\n            size_t col_end = (col_start + block_size <= cols) ? col_start + block_size : cols;\n            size_t block_cols = col_end - col_start;\n\n            svint16_t temp[block_rows];\n            \n            for (k = 0; k < block_rows; ++k) {\n                svint16_t vec = svld1((const int16_t *)(src + (row_start + k) * cols + col_start));\n                temp[k] = vec;\n            }\n\n            for (k = 0; k < block_cols; ++k) {\n                svst1((int16_t *)(dst + (col_start + k) * rows + row_start), temp[k]);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    size_t i, j, k;\n    size_t blocks = (rows + block_size - 1) / block_size;\n    \n    for (i = 0; i < blocks; ++i) {\n        size_t row_start = i * block_size;\n        size_t row_end = (row_start + block_size <= rows) ? row_start + block_size : rows;\n        size_t block_rows = row_end - row_start;\n\n        for (j = 0; j < blocks; ++j) {\n            size_t col_start = j * block_size;\n            size_t col_end = (col_start + block_size <= cols) ? col_start + block_size : cols;\n            size_t block_cols = col_end - col_start;\n\n            svint16_t temp[block_rows];\n            \n            for (k = 0; k < block_rows; ++k) {\n                svint16_t vec = svld1((const svint16_t *)(src + (row_start + k) * cols + col_start));\n                temp[k] = vec;\n            }\n\n            for (k = 0; k < block_cols; ++k) {\n                svst1((svint16_t *)(dst + (col_start + k) * rows + row_start), temp[k]);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    size_t i, j, k;\n    size_t blocks = (rows + block_size - 1) / block_size;\n    \n    for (i = 0; i < blocks; ++i) {\n        size_t row_start = i * block_size;\n        size_t row_end = (row_start + block_size <= rows) ? row_start + block_size : rows;\n        size_t block_rows = row_end - row_start;\n\n        for (j = 0; j < blocks; ++j) {\n            size_t col_start = j * block_size;\n            size_t col_end = (col_start + block_size <= cols) ? col_start + block_size : cols;\n            size_t block_cols = col_end - col_start;\n\n            svint16_t temp[block_rows];\n            \n            for (k = 0; k < block_rows; ++k) {\n                svint16_t vec = svld1((const int16_t *)(src + (row_start + k) * cols + col_start));\n                temp[k] = vec;\n            }\n\n            for (k = 0; k < block_cols; ++k) {\n                svst1((int16_t *)(dst + (col_start + k) * rows + row_start), temp[k]);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t i = 0;\n    svbool_t p = svwhilelt_b32(i, dim);\n    while (svptest_any(svptrue_b32(), p)) {\n        svfloat32_t vec = svld1(p, &array[i * dim * dim + i * dim + i]);\n        svfloat32_t sum_vec = svdup_n_f32(0.0f);\n        sum_vec = svadd_x_f32(sum_vec, vec);\n        sum = svaddv_f32(sum_vec);\n        i = svcntd();\n        p = svwhilelt_b32(i, dim);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t i = 0;\n    svbool_t p = svwhilelt_b32(i, dim);\n    while (svptest_any(svptrue_b32(), p)) {\n        svfloat32_t vec = svld1(p, &array[i * dim * dim + i * dim + i]);\n        sum += svaddv(p, vec);\n        i = svcntb_i32(i);\n        p = svwhilelt_b32(i, dim);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t i = 0;\n    svbool_t p = svwhilelt_b32(i, dim);\n    while (svptest_any(svptrue_b32(), p)) {\n        svfloat32_t vec = svld1(p, &array[i * dim * dim + i * dim + i]);\n        sum += svaddv(p, vec);\n        i = svcntb_i32(i);\n        p = svwhilelt_b32(i, dim);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t i = 0;\n    svbool_t p = svwhilelt_b32(i, dim);\n    while (svptest_any(svptrue_b32(), p)) {\n        svfloat32_t vec = svld1(p, &array[i * dim * dim + i * dim + i]);\n        sum += svaddv(p, vec);\n        i = svcntb() / sizeof(float);\n        p = svwhilelt_b32(i, dim);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t i = 0;\n    svbool_t p = svwhilelt_b32(i, dim);\n    while (svptest_any(svptrue_b32(), p)) {\n        svfloat32_t vec = svld1(p, &array[i * dim * dim + i * dim + i]);\n        svfloat32_t sum_vec = svdup_n_f32(0.0f);\n        sum_vec = svadd_x_f32(sum_vec, vec);\n        sum = svaddv_f32(sum_vec);\n        i = svcntd();\n        p = svwhilelt_b32(i, dim);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t i;\n    size_t row, col;\n    size_t elements_per_block = svcntd(); // Number of elements per vector block\n    svfloat64_t th = svdup_f64(threshold); // Duplicate threshold into a vector\n    svfloat64_t sc = svdup_f64(scale);     // Duplicate scale factor into a vector\n\n    for (row = 0; row < rows; row++) {\n        for (col = 0; col < cols; col += elements_per_block) {\n            size_t actual_elements = (cols - col < elements_per_block) ? (cols - col) : elements_per_block;\n            svfloat64_t src_vec = svld1_f64(src + row * cols + col, actual_elements); // Load source vector\n            svbool_t pg = svwhilelt_b64(col, cols); // Create predicate for actual elements\n            svfloat64_t cond = svcmpgt_f64(src_vec, th); // Compare each element with threshold\n            svfloat64_t scaled = svmla_f64(cond, src_vec, sc); // Scale if condition is true\n            svst1_f64(dst + row * cols + col, pg, scaled); // Store back to destination\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t i;\n    size_t row, col;\n    size_t elements_per_block = svcntd(); // Number of elements per vector block\n    svbool_t pg; // Predicate register\n\n    for (row = 0; row < rows; row++) {\n        for (col = 0; col < cols; col += elements_per_block) {\n            pg = svwhilelt((svuint64_t)(col + elements_per_block), (svuint64_t)cols);\n            svfloat64_t src_vec = svld1(pg, &src[row * cols + col]);\n            svfloat64_t mask = svcmpgt(src_vec, svdupq_n_f64(threshold));\n            svfloat64_t scaled_vec = svmlaq_n_f64(svfnmlaq_n_f64(src_vec, svdupq_n_f64(scale - 1.0)), svdupq_n_f64(scale));\n            svst1(pg, &dst[row * cols + col], svselect_b(mask, scaled_vec, src_vec));\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t elements_per_row = svcntd(); // Number of elements per vector\n    size_t total_elements = rows * cols;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += elements_per_row) {\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        svfloat64_t src_vec = svld1(pg, src + i);\n        svfloat64_t threshold_vec = svdup(pg, threshold);\n        svfloat64_t scale_vec = svdup(pg, scale);\n\n        svfloat64_t mask = svcmpgt_b64(src_vec, threshold_vec);\n        svfloat64_t scaled_vec = svmsub_xb(svmul_xb(src_vec, scale_vec, mask), src_vec, mask);\n\n        svst1(pg, dst + i, scaled_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t i;\n    size_t row, col;\n    size_t vl = svquery_vl(); // Get the vector length\n    size_t elem_per_vec = vl / sizeof(double);\n\n    for (row = 0; row < rows; row++) {\n        for (col = 0; col < cols; col += elem_per_vec) {\n            size_t len = (cols - col) > elem_per_vec ? elem_per_vec : (cols - col);\n            svbool_t pg = svwhilelt_b64(col, cols); // Generate predicate for current vector length\n            svfloat64_t src_vec = svld1(pg, src + row * cols + col); // Load source vector\n            svfloat64_t cond_vec = svcmpgt_f64(src_vec, svdup_f64(threshold)); // Compare with threshold\n            svfloat64_t scaled_vec = svmla_f64(svtrue_f64(), svdup_f64(scale - 1.0), src_vec); // Scale if condition is true\n            svst1(pg, dst + row * cols + col, svsel_b64(cond_vec, scaled_vec, src_vec)); // Store result\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t i, j;\n    size_t vl = svquery_vl(); // Get the vector length\n    size_t elem_per_vec = vl / sizeof(double);\n\n    for (i = 0; i < rows; i++) {\n        for (j = 0; j < cols; j += elem_per_vec) {\n            size_t n = (cols - j < elem_per_vec) ? (cols - j) : elem_per_vec;\n            svbool_t pg = svwhilelt_b64(j, cols); // Create predicate for active elements\n            svfloat64_t src_vec = svld1_gather_index(pg, src + i * cols + j); // Load source vector\n            svfloat64_t cond_vec = svcmpgt_f64(src_vec, svdup_f64(threshold)); // Compare with threshold\n            svfloat64_t scaled_vec = svmla_f64(svtrue_b64(), svdup_f64(scale - 1.0), src_vec); // Scale if true\n            svst1_scatter_index(pg, dst + i * cols + j, svsel_b64(cond_vec, scaled_vec, src_vec)); // Store result\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```c\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, rows);\n    while (svptest_any(svptrue_b64(), pg)) {\n        svuint64_t indices_vec = svld1_u64(indices + svcntb_b64(pg) * i);\n        svfloat64_t src_vec = svld1_gather_index_f64(src, indices_vec, svcntb_b64(pg));\n        svst1_f64(dst + svcntb_b64(pg) * i, pg, src_vec);\n        i += svcntb();\n        pg = svwhilelt_b64(i, rows);\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```c\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t blk = svcntd(); // Number of elements per vector\n    size_t i;\n\n    for (i = 0; i < rows; i += blk) {\n        svbool_t p = svwhilelt_b64(i, rows);\n        svint64_t idx_vec = svld1_gather_index(p, indices, svindex_b64(p));\n        svfloat64_t src_vec;\n        svint64_t row_idx;\n\n        for (size_t j = 0; j < cols; j++) {\n            row_idx = svsel_b64(p, svindex_b64(p) + i, row_idx);\n            src_vec = svld1_gather_index(p, src, row_idx);\n            svst1_scatter_index(p, dst, row_idx, src_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```c\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t blk = svcntd(); // Number of elements per vector\n    size_t i;\n\n    for (i = 0; i < rows; i += blk) {\n        size_t actual_blk = (i + blk <= rows) ? blk : rows - i;\n        svuint64_t idx_vec = svld1_u64(&indices[i]); // Load indices vector\n        for (size_t j = 0; j < cols; j++) {\n            svfloat64_t src_vec = svld1_gather_offset_d(&src[j * rows], svundef_u64(), idx_vec); // Gather from src\n            svst1_gather_offset_d(&dst[j * rows], svundef_u64(), idx_vec, src_vec); // Scatter to dst\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```c\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(0, rows);\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svuint64_t indices_vec = svld1_u64(indices + svcntb(pg) * i++);\n        svfloat64_t src_vec = svld1_gather_index_f64(src, indices_vec, svcntb(pg));\n        svst1_f64(dst + svcntb(pg) * i - 1, src_vec);\n        pg = svwhilelt_b64(svcntb(pg) * i, rows);\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```c\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(0, rows);\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svuint64_t indices_vec = svld1_u64(indices + svwhilelt_b64(i, rows));\n        svfloat64_t src_vec = svld1_gather_index_f64(src + (indices[i] * cols), indices_vec, pg);\n        svst1_f64(dst + (i * cols), pg, src_vec);\n        i += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(0, length);\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        int64_t_1_t v_src1 = svld1(pg, src1 + i);\n        int64_t_1_t v_src2 = svld1(pg, src2 + i);\n        int64_t_1_t v_scalar = svdup_n_b64(scalar);\n\n        int64_t_1_t v_result = svadd_x_b64(svadd_b64(v_src1, v_src2), v_scalar);\n        v_result = svdiv_x_b64(v_result, svdup_n_b64(2));\n\n        svst1(pg, dst + i, v_result);\n\n        i += svcntd();\n        pg = svwhilelt_b64(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    svbool_t pg = svwhilelt_b64(0, length);\n    svint64_t vec_src1 = svld1(pg, src1);\n    svint64_t vec_src2 = svld1(pg, src2);\n    svint64_t vec_result = svadd_x(pg, vec_src1, vec_src2);\n    svint64_t vec_scalar = svdup_n_s64(scalar);\n    vec_result = svadd_x(pg, vec_result, vec_scalar);\n    vec_result = svdiv_x(vec_result, svcreate_s64(2));\n    svst1(pg, dst, vec_result);\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    svbool_t p = svwhilelt_b64(0, length);\n\n    while (svptest_any(svptrue_b64(), p)) {\n        int64_t vl = svcntd();\n        svint64_t v_src1 = svld1(p, src1 + i);\n        svint64_t v_src2 = svld1(p, src2 + i);\n        svint64_t v_scalar = svdup_n_s64(scalar);\n        svint64_t v_result = svadd_x_s64(svadd_x_s64(v_src1, v_src2), v_scalar);\n        svst1(p, dst + i, svdiv_x_s64(v_result, svdup_n_s64(2)));\n\n        i += vl;\n        p = svwhilelt_b64(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    svbool_t pg = svwhilelt_b64(0, length);\n    svint64_t vec1 = svld1(pg, src1);\n    svint64_t vec2 = svld1(pg, src2);\n    svint64_t sum = svadd_x(pg, vec1, vec2);\n    svint64_t scalar_vec = svdup_n_s64(scalar);\n    svint64_t sum_with_scalar = svadd_x(pg, sum, scalar_vec);\n    svint64_t result = svdiv_rtn(sum_with_scalar, svcreate_s64(2));\n    svst1(pg, dst, result);\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    svbool_t p = svwhilelt_b64(0, length);\n\n    while (svptest_any(svptrue_b64(), p)) {\n        int64_t vl = svcntd();\n        svint64_t v_src1 = svld1(p, src1 + i);\n        svint64_t v_src2 = svld1(p, src2 + i);\n        svint64_t v_scalar = svdup_n_s64(scalar);\n        svint64_t v_result = svadd_x(p, svadd_x(p, v_src1, v_src2), v_scalar);\n        svst1(p, dst + i, svdiv_x(p, v_result, svdup_n_s64(2)));\n        i += vl;\n        p = svwhilelt_b64(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\nint vector_even_min_simd(const int *src, size_t length){\n    if(length == 0) return -1;\n    \n    int min_val = INT32_MAX;\n    svbool_t pg = svwhilelt_b32(0, length);\n    \n    svint32_t vec;\n    svint32_t min_vec = svdup_n_s32(min_val);\n    \n    for(size_t i = 0; i < length; i += svcntw()){\n        pg = svwhilelt_b32(i, length);\n        vec = svld1(pg, src + i);\n        svbool_t mask = svcmpeq_m(pg, pg, svindex_u32(0, 2), svcntw());\n        svint32_t even_vec = svsel(mask, vec, svdup_n_s32(0));\n        min_vec = svminv_m(pg, min_vec, even_vec);\n    }\n    \n    min_val = (int)svminv_b32(pg, min_vec);\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\nint vector_even_min_simd(const int *src, size_t length){\n    if(length == 0) return -1;\n    \n    int min_val = INT32_MAX;\n    svbool_t pg = svwhilelt_b32(0, length);\n    \n    svint32_t vec;\n    svint32_t min_vec = svdup_n_s32(min_val);\n    \n    for(size_t i = 0; i < length; i += svcntw()){\n        pg = svwhilelt_b32(i, length);\n        vec = svld1(pg, src + i);\n        svbool_t mask = svcmpeq_m(pg, pg, svindex_u32(0, 2), svcntw());\n        svint32_t even_vec = svsel(mask, vec, svdup_n_s32(0));\n        min_vec = svminv_m(pg, min_vec, even_vec);\n    }\n    \n    min_val = (int)svminv_b32(pg, min_vec);\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\nint vector_even_min_simd(const int *src, size_t length){\n    if(length == 0) return -1;\n    \n    int min_val = INT32_MAX;\n    svbool_t pg = svwhilelt_b32(0, length);\n    \n    for(size_t i = 0; i < length; i += svcntw()){\n        svbool_t p = svwhilelt_b32(i, length);\n        svint32_t vec = svld1(pg, src + i);\n        svint32_t even_mask = svindex_s32(0, 2, svcntw());\n        svint32_t even_vec = svundef_b32();\n        \n        svptrue_b32(p, even_mask);\n        sveor_b32(p, p, even_mask);\n        svst1(p, &even_vec, vec);\n        \n        svint32_t min_temp = svminv_b32(p, even_vec);\n        min_val = svminv_b32(svcmpeq_s32(min_temp, even_vec), min_val, min_temp);\n    }\n    \n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\nint vector_even_min_simd(const int *src, size_t length){\n    if(length == 0) return -1;\n    \n    svbool_t pg = svwhilelt_b32(0, length);\n    svint32_t vec = svld1(pg, src);\n    svint32_t min_val = svmaxv_b32(vec);\n    \n    while(svptest_any(svptrue_b32(), pg)){\n        svptrue_b32();\n        pg = svnext(pg);\n        vec = svld1(pg, src);\n        svint32_t current_min = svminv_b32(vec);\n        min_val = svminv_b32(svcmpeq_s32(min_val, current_min) ? min_val : current_min);\n    }\n    \n    return svminv_b32(min_val);\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\nint vector_even_min_simd(const int *src, size_t length){\n    if(length == 0) return -1;\n    \n    int min_val = INT32_MAX;\n    svbool_t pg = svwhilelt_b32(0, length);\n    \n    for(size_t i = 0; i < length; i += svcntw()){\n        svbool_t p = svwhilelt_b32(i, length);\n        svint32_t vec = svld1(pg, src + i);\n        svint32_t even_mask = svindex_s32(0, 2, svcntw());\n        svint32_t even_vec = svundef_b32();\n        \n        svptrue_b32(p, even_mask);\n        svst1(p, &even_vec, svsel_b32(p, vec, even_vec));\n        \n        svint32_t min_temp = svminv_b32(p, even_vec);\n        min_val = (min_temp > min_val) ? min_val : min_temp;\n    }\n    \n    return min_val;\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t vector_length = svcntw(); // Number of elements per vector\n    size_t i = 0;\n\n    while (i < length) {\n        size_t this_length = (length - i >= vector_length) ? vector_length : (length - i);\n        svint32_t src_vec = svld1((const int *)src + i);\n        svint32_t asr_result = svashr_n_s32(src_vec, shift);\n        svuint32_t usrc_vec = svreinterpret_u32(svabs_s32(src_vec));\n        svint32_t lsr_result = svsub_s32(svashr_n_s32(usrc_vec, shift), svashr_n_s32(usrc_vec, shift));\n        svst1((int *)(dst + i), svadd_s32(asr_result, lsr_result));\n        i += this_length;\n    }\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t vector_length = svcntw(); // Get the vector length\n    size_t i = 0;\n\n    while (i < length) {\n        svint32_t src_vec = svld1_s32(src + i); // Load vector from source\n        svuint32_t src_uvec = svreinterpret_u32_s32(src_vec); // Convert to unsigned vector\n\n        svint32_t arith_shift = svashr_n_s32(src_vec, shift); // Arithmetic right shift\n        svint32_t logic_shift = svlsr_n_s32(svcast_s32_u32(src_uvec), shift); // Logical right shift\n        svint32_t result = svadd_s32(arith_shift, logic_shift); // Add the two shifts\n\n        svst1_s32(dst + i, result); // Store the result back to destination\n        i += vector_length; // Move to the next vector\n    }\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    svbool_t p = svwhilelt_b32(0, length);\n\n    while (svptest_any(svptrue_b32(), p)) {\n        svint32_t src_vec = svld1(p, src + i);\n        svuint32_t src_uvec = svreinterpret_s32_u32(src_vec);\n\n        svint32_t arith_shift = svashr_n_s32(src_vec, shift);\n        svint32_t logic_shift = svcvt_s32_u32(svlsr_n_u32(src_uvec, shift));\n        svint32_t result = svadd_s32(arith_shift, logic_shift);\n\n        svst1(p, dst + i, result);\n        i += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t vector_length = svcntw(); // Get the vector length\n    svint32_t src_vec;\n    svuint32_t src_uvec;\n    svint32_t arith_shifted;\n    svint32_t logic_shifted;\n    svint32_t result;\n\n    for (size_t i = 0; i < length; i += vector_length) {\n        src_vec = svld1((const svint32_t *)(&src[i])); // Load vector from source\n        src_uvec = svreinterpret_s32_u32(src_vec);     // Convert to unsigned for logical shift\n\n        arith_shifted = svshr_n_s32(src_vec, shift);   // Arithmetic right shift\n        logic_shifted = svushr_n_u32(src_uvec, shift); // Logical right shift\n        result = svadd_s32(arith_shifted, svreinterpret_s32_u32(logic_shifted)); // Add results\n\n        svst1((svint32_t *)(&dst[i]), result);         // Store result to destination\n    }\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t vector_length = svcntw(); // Get the vector length\n    svint32_t src_vec;\n    svuint32_t src_uvec;\n    svint32_t arith_shifted;\n    svint32_t logic_shifted;\n    svint32_t result;\n\n    for (size_t i = 0; i < length; i += vector_length) {\n        src_vec = svld1((const svint32_t *)(&src[i])); // Load vector from source\n        src_uvec = svreinterpret_s32_u32(src_vec);      // Convert to unsigned for logical shift\n\n        arith_shifted = svshr_n_s32(src_vec, shift);   // Arithmetic right shift\n        logic_shifted = svushr_n_u32(src_uvec, shift); // Logical right shift\n        result = svadd_s32(arith_shifted, svreinterpret_s32_u32(logic_shifted)); // Add results\n\n        svst1((svint32_t *)(&dst[i]), result);         // Store result to destination\n    }\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    svbool_t pg = svwhilelt_b32(0, cols);\n    int64_t sum = 0;\n    const int *row_ptr = matrix;\n\n    for (size_t i = 0; i < rows; i++) {\n        sum += svaddv_s32(pg, svld1(pg, row_ptr));\n        row_ptr += cols;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    svbool_t pg = svwhilelt_b32(0, cols);\n    int64_t sum = 0;\n    const int *row_ptr = matrix;\n\n    for (size_t i = 0; i < rows; i++) {\n        sum += svaddv_s32(pg, svld1(pg, row_ptr));\n        row_ptr += cols;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    svbool_t pg = svwhilelt_b32(0, cols);\n    int64_t sum = 0;\n    const int *row_ptr = matrix;\n\n    for (size_t i = 0; i < rows; i++) {\n        sum += svaddv_s32(pg, svld1(pg, row_ptr));\n        row_ptr += cols;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    svbool_t pg = svwhilelt_b32(0, cols);\n    int64_t sum = 0;\n    const int *row_ptr = matrix;\n\n    for (size_t i = 0; i < rows; i++) {\n        sum += svaddv_s32(pg, svld1(pg, row_ptr));\n        row_ptr += cols;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    svbool_t pg = svwhilelt_b32(0, cols);\n    int64_t sum = 0;\n    const int *row_ptr = matrix;\n\n    for (size_t i = 0; i < rows; i++) {\n        sum += svaddv_s32(pg, svld1(pg, row_ptr));\n        row_ptr += cols;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    size_t max_idx = 0;\n    size_t i = 0;\n\n    while (i + svcntb() <= length) {\n        svint8_t vec = svld1_s8(src + i);\n        svint8_t mask = svmaxv_s8(vec);\n        svbool_t p_true = svcmpgt_s8(svindex_s8(0, svcntb()), mask);\n        uint8_t result = svlast\u771f_index_u8(p_true);\n        if (result >= svcntb()) {\n            max_idx = i + result;\n        }\n        i += svcntb();\n    }\n\n    for (; i < length; i++) {\n        if (src[i] > src[max_idx]) {\n            max_idx = i;\n        }\n    }\n\n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    size_t max_idx = 0;\n    size_t i = 0;\n\n    while (i + svcntb() <= length) {\n        svint8_t vec = svld1((const int8_t *)src + i);\n        svint8_t mask = svcmplt(vec, svdup_n_s8(src[max_idx]));\n        svbool_t p_true = svcmpgt(vec, svdup_n_s8(src[max_idx]));\n\n        size_t new_idx = i + svcntb_p_u32(p_true);\n        if (new_idx > max_idx) {\n            max_idx = new_idx;\n        }\n        i += svcntb();\n    }\n\n    for (; i < length; i++) {\n        if (src[i] > src[max_idx]) {\n            max_idx = i;\n        }\n    }\n\n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t max_idx = 0;\n    size_t i = 0;\n    svbool_t p;\n\n    while (svcntb() <= length - i) {\n        svint8_t vec = svld1_s8(src + i);\n        svint8_t max_vec = svmaxv_s8(vec);\n        int8_t max_val = svlast_s8(max_vec);\n        size_t local_max_idx = svindex_s8(vec, max_val);\n        if (local_max_idx > max_idx) {\n            max_idx = local_max_idx + i;\n        }\n        i += svcntb();\n    }\n\n    for (; i < length; ++i) {\n        if (src[i] > src[max_idx]) {\n            max_idx = i;\n        }\n    }\n\n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    svbool_t pg = svwhilelt_b8(0, length);\n    svint8_t vec = svld1(pg, src);\n    svint8_t max_val = vec;\n    svuint32_t max_idx = svindex_u32(0, 0);\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        pg = svnext(pg);\n        vec = svld1(pg, src + svcntd() * sizeof(int8_t));\n        svbool_t gt_mask = svcmplt(max_val, vec);\n        max_val = svsel(gt_mask, vec, max_val);\n        max_idx = svsel(gt_mask, svindex_u32(0, svcntd()), max_idx);\n    }\n\n    size_t result = svaddv_u32(max_idx);\n    return result;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    size_t max_idx = 0;\n    size_t i = 0;\n\n    while (i + svcntb() <= length) {\n        svint8_t vec = svld1((const int8_t *)src + i);\n        svint8_t mask = svcmplt(vec, svdup_n_s8(src[max_idx]));\n        if (svcntb() - svcntp(mask) > 0) {\n            max_idx = i + svcntp(mask);\n        }\n        i += svcntb();\n    }\n\n    for (; i < length; i++) {\n        if (src[i] > src[max_idx]) {\n            max_idx = i;\n        }\n    }\n\n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b(u16, i, length);\n\n    while (svptest_any(svptrue_b(u16), pg)) {\n        svuint16_t idx = svindex_u32(0, 1);\n        svbool_t cond = svcmpeq_w(u32, svuzp1_u32(idx), svdup_n_u32(mask));\n\n        svuint16_t src1_vec = svld1_u16(pg, src1 + svfirst_elem_u32(idx));\n        svuint16_t src2_vec = svld1_u16(pg, src2 + svfirst_elem_u32(idx));\n        svst1_u16(pg, dst + svfirst_elem_u32(idx), svselect_u16(cond, src1_vec, src2_vec));\n\n        i += svcntd();\n        pg = svwhilelt_b(u16, i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b(u16, i, length);\n    while (svptest_any(svptrue_b(u16), pg)) {\n        svuint16_t src1_vec = svld1(pg, src1 + i);\n        svuint16_t src2_vec = svld1(pg, src2 + i);\n        svuint32_t index_vec = svindex_u32(i, 1);\n        svbool_t select_mask = svcmpeq_w(svmovlb_u32(index_vec & svindex_u32(mask, mask)), svindex_u32(0, 1));\n        svst1(pg, dst + i, svsel(pg, src1_vec, src2_vec, select_mask));\n        i += svcntw();\n        pg = svwhilelt_b(u16, i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b(u16, i, length);\n    while (svptest_any(svptrue_b(u16), pg)) {\n        svuint16_t idx = svindex_u32(0, 1);\n        svbool_t cond = svcmpeq_w(u32, svuzp1_u32(idx), svdup_n_u32(mask));\n        svuint16_t src1_vec = svld1_u16(pg, src1 + svfirstn_u32(pg, idx));\n        svuint16_t src2_vec = svld1_u16(pg, src2 + svfirstn_u32(pg, idx));\n        svst1_u16(pg, dst + svfirstn_u32(pg, idx), svselect_u16(cond, src1_vec, src2_vec));\n        i += svcntd();\n        pg = svwhilelt_b(u16, i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b16(0, length);\n    \n    while (svptest_any(svptrue_b16(), pg)) {\n        size_t vl = svcntw();\n        svuint16_t idx = svindex_u16(0, 1);\n        svbool_t p = svptrue_b16();\n        \n        // Adjust predicate for remaining elements\n        pg = svwhilelt_b16(i, length);\n        p = svand_b16(pg, p);\n        \n        svuint16_t src1_vec = svld1_u16(src1, p);\n        svuint16_t src2_vec = svld1_u16(src2, p);\n        \n        svbool_t cond = svcmpeq_w_b16(svand_n_u16(idx, mask), svdup_n_u16(0));\n        \n        svst1_u16(dst, svsel_u16(cond, src1_vec, src2_vec), p);\n        \n        src1 += vl;\n        src2 += vl;\n        dst += vl;\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b(u16, i, length);\n    while (svptest_any(svptrue_b(u16), pg)) {\n        svuint16_t idx = svindex_u32(0, 1);\n        svbool_t cond = svcmpeq_w(u32, svand_n_u32(idx, mask), svdup_n_u32(0));\n        svuint16_t val1 = svld1_u16(pg, src1 + i);\n        svuint16_t val2 = svld1_u16(pg, src2 + i);\n        svst1_u16(pg, dst + i, svsel_u16(cond, val1, val2));\n        i += svcntw();\n        pg = svwhilelt_b(u16, i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    while (svptest_any(svptrue_b32(), pg)) {\n        uint32_t vl = svcntw();\n        svuint32_t input = svld1(pg, src);\n        svuint32_t popcount = svcntp_u32(input);\n        svst1(pg, dst, popcount);\n        src += vl;\n        dst += vl;\n        pg = svwhilelt_b32(svlenof(src), length);\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    while (svptest_any(svptrue_b32(), pg)) {\n        uint32_t vl = svcntw();\n        svuint32_t input = svld1(pg, src);\n        svuint32_t popcount = svcntp_u32(input);\n        svst1(pg, dst, popcount);\n        src += vl;\n        dst += vl;\n        pg = svwhilelt_b32(svlenof(src), length);\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    while (svptest_any(svptrue_b32(), pg)) {\n        uint32_t vl = svcntw();\n        svuint32_t input = svld1(pg, src);\n        svuint32_t popcount = svcntp_u32(input);\n        svst1(pg, dst, popcount);\n        src += vl;\n        dst += vl;\n        pg = svwhilelt_b32(svlenof(src), length);\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    while (svptest_any(svptrue_b32(), pg)) {\n        uint32_t vec_len = svcntw();\n        svuint32_t src_vec = svld1(pg, src);\n        svuint32_t popcount_vec = svcntp_u32(src_vec);\n        svst1(pg, dst, popcount_vec);\n        src += vec_len;\n        dst += vec_len;\n        pg = svwhilelt_b32(svindex_w(vec_len), length);\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    while (svptest_any(svptrue_b32(), pg)) {\n        uint32_t vl = svcntw();\n        svuint32_t input = svld1(pg, src);\n        svuint32_t count = svcntp_u32(input);\n        svst1(pg, dst, count);\n        src += vl;\n        dst += vl;\n        pg = svwhilelt_b32(svlenof(src), length);\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t p = svwhilelt_b(u16, i, length);\n\n    while (svptest_any(svptrue_b(u16), p)) {\n        uint16_t vl = svcntw();\n        svuint16_t a = svld1_u16(src1 + i, p);\n        svuint16_t b = svld1_u16(src2 + i, p);\n        svuint16_t res = svmin_u16(svadd_u16(a, b), svdup_n_u16(UINT16_MAX));\n        svst1_u16(dst + i, res, p);\n        i += vl;\n        p = svwhilelt_b(u16, i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t p = svwhilelt_b(u16, i, length);\n\n    while (svptest_any(svptrue_b(u16), p)) {\n        uint16_t vl = svcntw();\n        svuint16_t vec1 = svld1_u16(src1 + i, p);\n        svuint16_t vec2 = svld1_u16(src2 + i, p);\n        svuint16_t sum = svmin_u16(svadd_u16(vec1, vec2), svdup_n_u16(UINT16_MAX));\n        svst1_u16(dst + i, sum, p);\n        i += vl;\n        p = svwhilelt_b(u16, i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t p = svwhilelt_b(u16, i, length);\n\n    while (svptest_any(svptrue_b(u16), p)) {\n        uint16_t vl = svcntw();\n        svuint16_t a = svld1_u16(src1 + i, p);\n        svuint16_t b = svld1_u16(src2 + i, p);\n        svuint16_t res = svmin_u16(svadd_u16(a, b), svdup_n_u16(UINT16_MAX));\n        svst1_u16(dst + i, res, p);\n        i += vl;\n        p = svwhilelt_b(u16, i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t p = svwhilelt_b(u16, i, length);\n\n    while (svptest_any(svptrue_b(u16), p)) {\n        uint16_t vl = svcntw();\n        svuint16_t a = svld1_u16(src1 + i, p);\n        svuint16_t b = svld1_u16(src2 + i, p);\n        svuint16_t res = svmin_u16(svadd_u16(a, b), svdup_n_u16(UINT16_MAX));\n        svst1_u16(dst + i, res, p);\n        i += vl;\n        p = svwhilelt_b(u16, i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t p = svwhilelt_b(u16, i, length);\n    while (svptest_any(svptrue_b(u16), p)) {\n        uint16_t vl = svcntw();\n        uint16_t* src1_ptr = (uint16_t*)src1 + i;\n        uint16_t* src2_ptr = (uint16_t*)src2 + i;\n        uint16_t* dst_ptr = (uint16_t*)dst + i;\n        svuint16_t v_src1 = svld1(p, src1_ptr);\n        svuint16_t v_src2 = svld1(p, src2_ptr);\n        svuint16_t v_result = svminv(svuaddv(v_src1, v_src2), svcreate_h(UINT16_MAX));\n        svst1(p, dst_ptr, v_result);\n        i += vl;\n        p = svwhilelt_b(u16, i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```c\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(0, m * n);\n    while (svptest_any(svptrue_b64(), pg)) {\n        svfloat64_t a_vec = svld1(pg, A + svindex_u64_z(pg, i));\n        svfloat64_t b_vec = svld1(pg, B + svindex_u64_z(pg, i));\n        svbool_t mask = svcmpgt_b64(a_vec, svdup_n_f64(-100.0)) & svcmpgt_b64(b_vec, svdup_n_f64(-100.0)) & svcmplt_b64(a_vec, svdup_n_f64(100.0)) & svcmplt_b64(b_vec, svdup_n_f64(100.0));\n        svfloat64_t prod = svmla_f64(svundef_f64(), a_vec, b_vec);\n        svst1(pg, C + svindex_u64_z(pg, i), svadd_f64(svld1(pg, C + svindex_u64_z(pg, i)), svselect_b64(mask, prod, svundef_f64())));\n        i += svcntd();\n        pg = svwhilelt_b64(i, m * n);\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```c\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(0, m * p);\n    while (svptest_any(svptrue_b64(), pg)) {\n        svfloat64_t sum_vec = svdupq_n_f64(0.0);\n        svbool_t inner_pg = svwhilelt_b64(0, n);\n        size_t j = 0;\n\n        while (svptest_any(pg, inner_pg)) {\n            svfloat64_t a_vec = svld1_gather_index_f64(A + j * m, svindex_b64(inner_pg));\n            svfloat64_t b_vec = svld1_gather_index_f64(B + j * p, svindex_b64(inner_pg));\n            svbool_t mask = svcmpge_b64(a_vec, svdupq_n_f64(-100.0)) & svcmpge_b64(b_vec, svdupq_n_f64(-100.0)) & svcmpgt_b64(svdupq_n_f64(100.0), a_vec) & svcmpgt_b64(svdupq_n_f64(100.0), b_vec);\n            sum_vec = svmla_maskq_f64(sum_vec, a_vec, b_vec, mask);\n            inner_pg = svnext_b64(inner_pg);\n        }\n        svst1_scatter_index_f64(C + i, pg, sum_vec);\n        i += n;\n        pg = svnext_b64(pg);\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```c\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(0, m * n);\n    \n    while (svptest_any(svptrue_b64(), pg)) {\n        svfloat64_t A_vec = svld1(pg, &A[i]);\n        svfloat64_t B_vec = svld1(pg, &B[i]);\n        \n        svbool_t mask = svcmpeq_n_f64(A_vec, -100.0) | svcmpeq_n_f64(A_vec, 100.0) |\n                        svcmpeq_n_f64(B_vec, -100.0) | svcmpeq_n_f64(B_vec, 100.0);\n        \n        svfloat64_t result = svmla_z(pg, A_vec, B_vec, mask);\n        \n        svst1(pg, &C[i], result);\n        \n        i += svcntd();\n        pg = svwhilelt_b64(i, m * n);\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```c\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(0, m * n);\n    \n    while (svptest_any(svptrue_b64(), pg)) {\n        svfloat64_t A_vec = svld1(pg, &A[i]);\n        svfloat64_t B_vec = svld1(pg, &B[i]);\n        svbool_t mask = svcmpge_b64(A_vec, svdup_n_f64(-100.0)) & svcmpge_b64(B_vec, svdup_n_f64(-100.0)) & svcmple_b64(A_vec, svdup_n_f64(100.0)) & svcmple_b64(B_vec, svdup_n_f64(100.0));\n        \n        svfloat64_t prod = svmla_z(pg, A_vec, B_vec, mask);\n        svst1(pg, &C[i], prod);\n        \n        i += svcntd();\n        pg = svwhilelt_b64(i, m * n);\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```c\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(0, m * n);\n    while (svptest_any(svptrue_b64(), pg)) {\n        svfloat64_t a_vec = svld1(pg, A + svindex_u64_z(pg, i));\n        svfloat64_t b_vec = svld1(pg, B + svindex_u64_z(pg, i));\n        svbool_t mask = svcmpgt_b64(a_vec, svdup_n_f64(-100.0)) & svcmpgt_b64(b_vec, svdup_n_f64(-100.0)) & svcmplt_b64(a_vec, svdup_n_f64(100.0)) & svcmplt_b64(b_vec, svdup_n_f64(100.0));\n        svfloat64_t filtered_a = svcond_f64(mask, a_vec, svdup_n_f64(0.0));\n        svfloat64_t filtered_b = svcond_f64(mask, b_vec, svdup_n_f64(0.0));\n        svfloat64_t product = svmla_f64(svdup_n_f64(0.0), filtered_a, filtered_b);\n        svst1(pg, C + svindex_u64_z(pg, i), product);\n        i += svcntd();\n        pg = svwhilelt_b64(i, m * n);\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```c\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t i, j, k;\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vector_length = svcntd(); // Number of elements per vector\n    size_t processed_elements;\n\n    for (i = 0; i < dim1; i++) {\n        for (j = 0; j < dim2; j++) {\n            for (k = 0; k < dim3; k += vector_length) {\n                size_t count = (vector_length <= (dim3 - k)) ? vector_length : (dim3 - k);\n                svint64_t vec_A = svld1((const svint64_t*)(A + i * dim2 * dim3 + j * dim3 + k));\n                svint64_t vec_B = svld1((const svint64_t*)(B + i * dim2 * dim3 + j * dim3 + k));\n                svint64_t vec_C = svadd_x(vec_A, vec_B, count);\n                svst1((svint64_t*)(C + i * dim2 * dim3 + j * dim3 + k), vec_C);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```c\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t i, j, k;\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vector_length = svcntd(); // Number of elements per vector\n    size_t processed_elements;\n\n    for (i = 0; i < dim1; i++) {\n        for (j = 0; j < dim2; j++) {\n            for (k = 0; k < dim3; k += vector_length) {\n                size_t count = (vector_length <= (dim3 - k)) ? vector_length : (dim3 - k);\n                svint64_t vec_A = svld1((const svint64_t*)(A + i * dim2 * dim3 + j * dim3 + k));\n                svint64_t vec_B = svld1((const svint64_t*)(B + i * dim2 * dim3 + j * dim3 + k));\n                svint64_t vec_C = svadd_x(vec_A, vec_B, count);\n                svst1((svint64_t*)(C + i * dim2 * dim3 + j * dim3 + k), vec_C);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```c\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t i, j, k;\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vector_length = svcntd(); // Number of elements per vector\n    size_t processed_elements;\n\n    for (i = 0; i < dim1; i++) {\n        for (j = 0; j < dim2; j++) {\n            for (k = 0; k < dim3; k += vector_length) {\n                size_t count = (vector_length <= (dim3 - k)) ? vector_length : (dim3 - k);\n                svint64_t vec_A = svld1((const svint64_t*)(A + i * dim2 * dim3 + j * dim3 + k));\n                svint64_t vec_B = svld1((const svint64_t*)(B + i * dim2 * dim3 + j * dim3 + k));\n                svint64_t vec_C = svadd_x(vec_A, vec_B, count);\n                svst1((svint64_t*)(C + i * dim2 * dim3 + j * dim3 + k), vec_C);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```c\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t i, j, k;\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vector_length = svcntd(); // Number of elements per vector\n    size_t processed_elements;\n\n    for (i = 0; i < dim1; i++) {\n        for (j = 0; j < dim2; j++) {\n            for (k = 0; k < dim3; k += vector_length) {\n                size_t count = (vector_length <= (dim3 - k)) ? vector_length : (dim3 - k);\n                svint64_t vec_A = svld1((const svint64_t*)(A + i * dim2 * dim3 + j * dim3 + k));\n                svint64_t vec_B = svld1((const svint64_t*)(B + i * dim2 * dim3 + j * dim3 + k));\n                svint64_t vec_C = svadd_x(vec_A, vec_B, count);\n                svst1((svint64_t*)(C + i * dim2 * dim3 + j * dim3 + k), vec_C);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```c\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t i, j, k;\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vector_length = svcntd(); // Number of elements per vector\n    size_t processed_elements;\n\n    for (i = 0; i < dim1; i++) {\n        for (j = 0; j < dim2; j++) {\n            for (k = 0; k < dim3; k += vector_length) {\n                size_t count = (vector_length <= (dim3 - k)) ? vector_length : (dim3 - k);\n                svint64_t vec_A = svld1((const svint64_t*)(A + i * dim2 * dim3 + j * dim3 + k));\n                svint64_t vec_B = svld1((const svint64_t*)(B + i * dim2 * dim3 + j * dim3 + k));\n                svint64_t vec_C = svadd_x(vec_A, vec_B, count);\n                svst1((svint64_t*)(C + i * dim2 * dim3 + j * dim3 + k), vec_C);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    svfloat32_t vsrc1, vsrc2, vresult;\n    svint32_t vrounded;\n\n    while (i + svgetn_v(sizeof(float)) <= length) {\n        vsrc1 = svld1_v(sveofp32_v, src1 + i);\n        vsrc2 = svld1_v(sveofp32_v, src2 + i);\n        vresult = svadd(vsrc1, vsrc2);\n        vrounded = svround_to_int(vresult);\n        svst1_v(sveofp32_v, dst + i, sveasp32_v(vrounded));\n        i += svgetn_v(sizeof(float));\n    }\n\n    // Handle remaining elements if any\n    while (i < length) {\n        dst[i] = roundf(src1[i] + src2[i]);\n        i++;\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    svfloat32_t op1, op2;\n    svfloat32_t res;\n    size_t i = 0;\n\n    while (i + svgetnsize_v(float32_t) <= length) {\n        op1 = svld1_v(float32_t, src1 + i);\n        op2 = svld1_v(float32_t, src2 + i);\n        res = svroundns_v(float32_t, op1 + op2);\n        svst1_v(float32_t, dst + i, res);\n        i += svgetnsize_v(float32_t);\n    }\n\n    // Handle remaining elements if any\n    while (i < length) {\n        dst[i] = roundf(src1[i] + src2[i]);\n        i++;\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    svfloat32_t op1, op2;\n    svfloat32_t res;\n    size_t i = 0;\n\n    while (i + svgetn_vl<float>() <= length) {\n        op1 = svld1_v((svfloat32_t*)src1 + i);\n        op2 = svld1_v((svfloat32_t*)src2 + i);\n        res = svround_n_f32(op1 + op2);\n        svst1_v((svfloat32_t*)dst + i, res);\n        i += svgetn_vl<float>();\n    }\n\n    // Handle remaining elements\n    while (i < length) {\n        dst[i] = roundf(src1[i] + src2[i]);\n        i++;\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    svbool_t p = svwhilelt_b32(0, length);\n\n    while (svptest_any(svptrue_b32(), p)) {\n        svfloat32_t v1 = svld1(p, src1 + i);\n        svfloat32_t v2 = svld1(p, src2 + i);\n        svfloat32_t vsum = svadd(v1, v2);\n        svint32_t vrounded = svround(vsum);\n        svst1(p, dst + i, vrounded);\n        i += svcntd();\n        p = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    svfloat32_t op1, op2;\n    svfloat32_t res;\n    size_t i = 0;\n\n    while (i + svgetn_v_s32(sizeof(svfloat32_t) / sizeof(float)) <= length) {\n        op1 = svld1_v(svptrue_b32(), src1 + i);\n        op2 = svld1_v(svptrue_b32(), src2 + i);\n        res = svroundh_f32(op1 + op2);\n        svst1_v(dst + i, svptrue_b32(), res);\n        i += svgetn_v_s32(sizeof(svfloat32_t) / sizeof(float));\n    }\n\n    // Handle remaining elements if any\n    for (; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length){\n    svbool_t pg = svwhilelt_b32(0, length);\n    svfloat32_t v_src1, v_src2, v_dst;\n    size_t i = 0;\n\n    while(svptest_any(pg)){\n        v_src1 = svld1(pg, src1 + i);\n        v_src2 = svld1(pg, src2 + i);\n\n        // Check if index is a multiple of 2\n        svbool_t idx_even = svcmpeq_i32(svindexhi_b32(i), svindexhi_b32(0));\n\n        // Calculate the absolute difference\n        svfloat32_t abs_diff = svabs_f32(svfma_f32(v_src1, svcntd_f32(), v_src2));\n\n        // Check if the absolute difference is within 50\n        svbool_t diff_condition = svcmple_f32(abs_diff, svcntd_f32() * 50.0f);\n\n        // Combine conditions: index is even AND absolute difference <= 50\n        svbool_t valid_mask = svand_b32(idx_even, diff_condition);\n\n        // Perform element-wise multiplication for valid indices\n        v_dst = svmla_f32(svptrue_b32(), v_src1, v_src2);\n\n        // Apply rounding up toward positive infinity\n        v_dst = svrint_a_f32(v_dst);\n\n        // Set invalid indices to -1\n        v_dst = svsel_f32(valid_mask, v_dst, svdup_n_f32(-1.0f));\n\n        // Store the result\n        svst1_f32(pg, dst + i, v_dst);\n\n        // Update the pointer and predicate\n        i += svcntd();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length){\n    svbool_t pg = svwhilelt_b32(0, length);\n    svfloat32_t v_src1, v_src2, v_dst;\n    svint32_t v_idx;\n    svbool_t mask;\n\n    while(svptest_any(pg)){\n        v_src1 = svld1(pg, src1);\n        v_src2 = svld1(pg, src2);\n        v_idx = svindex_u32(0,1);\n        \n        // Check if index is a multiple of 2\n        mask = svcmpeq_m(pg, svindex_u32(0,1), svdup_n_u32(2));\n        pg = svand_b32(mask, pg);\n\n        // Calculate absolute difference\n        svfloat32_t v_diff = svabs_f32(svfma_f32(v_src1, svneg_f32(v_src2), svdup_n_f32(0.0f)));\n        \n        // Apply condition on absolute difference\n        mask = svcmple_f32(v_diff, svdup_n_f32(50.0f));\n        pg = svand_b32(mask, pg);\n\n        // Element-wise multiplication\n        v_dst = svmla_f32(svtrue_n_f32(0.0f), v_src1, v_src2);\n\n        // Round up toward positive infinity\n        v_dst = svrint_a_f32(v_dst);\n\n        // Assign -1 where conditions are not met\n        v_dst = svsel_f32(svnot_b32(pg), svdup_n_f32(-1.0f), v_dst);\n\n        // Store the result\n        svst1_f32(pg, dst, v_dst);\n\n        // Update pointers\n        src1 = svadd_n_u32(src1, svcntd());\n        src2 = svadd_n_u32(src2, svcntd());\n        dst = svadd_n_u32(dst, svcntd());\n        pg = svwhilelt_b32(0, length - svcntd());\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length){\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(0, length);\n\n    while(svptest_any(svptrue_b32(), pg)){\n        svfloat32_t v_src1 = svld1(pg, src1 + i);\n        svfloat32_t v_src2 = svld1(pg, src2 + i);\n        svfloat32_t v_diff = svabs(v_src1 - v_src2);\n        svint32_t v_idx = svindex_b32(pg, i);\n        \n        svbool_t cond1 = svcmple_f32(v_diff, svdup_f32(50.0f));\n        svbool_t cond2 = svcmpeq_i32(v_idx, svindex_r_i32(2));\n        svbool_t cond = svand_b32(cond1, cond2);\n\n        svfloat32_t v_result = svmla_f32(v_src1, v_src2, svcreate_f32(1.0f, -1.0f));\n        v_result = svrintp_f32(v_result); // Round up toward positive infinity\n\n        svst1_f32(svselect_b32(cond, pg, svdup_n_f32(-1.0f)), dst + i, v_result);\n\n        i += svcntd();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length){\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(0, length);\n\n    while(svptest_any(pg)){\n        svfloat32_t v_src1 = svld1(pg, src1 + i);\n        svfloat32_t v_src2 = svld1(pg, src2 + i);\n        svfloat32_t v_diff = svabsq_f32(svsubq_f32(v_src1, v_src2));\n        svfloat32_t v_index = svindex_b32(pg, i);\n        \n        // Check if index is a multiple of 2\n        svbool_t cond_index = svcmpeq_n_u32(svmovlb_u32(v_index), svtrue_n_u32(2));\n        \n        // Check if absolute difference is within 50\n        svbool_t cond_diff = svcmple_n_f32(v_diff, svtrue_n_f32(50.0f));\n        \n        // Combine conditions\n        svbool_t cond = svand_b32(cond_index, cond_diff);\n        \n        // Perform element-wise multiplication where conditions are met\n        svfloat32_t v_result = svmlaq_f32(svindex_b32(pg, -1), v_src1, v_src2);\n        \n        // Apply rounding up toward positive infinity\n        v_result = svrintaq_p_f32(pg, v_result);\n        \n        // Mask the result based on conditions\n        v_result = svmulq_b32(v_result, cond, svindex_b32(pg, -1));\n        \n        // Set result to -1 where conditions are not met\n        v_result = svselq_b32(v_result, svindex_b32(pg, -1), svnot_b32(cond));\n        \n        // Store the result\n        svst1_f32(pg, dst + i, v_result);\n        \n        // Update index and predicate\n        i += svcntd();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length){\n    size_t i = 0;\n    svbool_t p = svwhilelt_b32(0, length);\n\n    while(svptest_any(svptrue_b32(), p)){\n        svfloat32_t v_src1 = svld1_gather_index(p, src1, i);\n        svfloat32_t v_src2 = svld1_gather_index(p, src2, i);\n        svfloat32_t v_diff = svabsq_f32(svsubq_f32(v_src1, v_src2));\n        svfloat32_t v_mask_diff = svcmpleq_f32(v_diff, svdupq_n_f32(50.0f));\n        svbool_t v_mask_idx = svcmpeq_u32(svindex_u32(i), svindex_u32(0));\n        \n        svbool_t v_mask = svand_b32(v_mask_diff, v_mask_idx);\n        svfloat32_t v_result = svmlaq_f32(svindex_f32(-1.0f), v_src1, v_src2);\n        svst1_scatter_index(p, dst, i, svrintaq_p_f32(svptrue_b32(), v_result, v_mask));\n        \n        i += svcntd();\n        p = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```c\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t i;\n    size_t vl = svquery_vl();\n    size_t elements_per_vector = vl / sizeof(double);\n\n    for (i = 0; i < m * n; i += elements_per_vector) {\n        svfloat64_t vec_mat = svld1((const double *)(&mat[i]));\n        svfloat64_t vec_scalar = svdup_n(scalar);\n        svfloat64_t vec_result = svmla(vec_mat, vec_scalar, vec_mat);\n        svst1((double *)(&dst[i]), vec_result);\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```c\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(0, n);\n\n    while (i < m) {\n        svfloat64_t scalar_vec = svdupq(scalar);\n        size_t j = 0;\n\n        while (j < n) {\n            svfloat64_t mat_vec = svld1(pg, mat + i * n + j);\n            svfloat64_t res_vec = svmlaq(scalar_vec, mat_vec);\n            svst1(pg, dst + i * n + j, res_vec);\n            j += svcntd();\n        }\n        i++;\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```c\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(0, n);\n\n    while (i < m) {\n        svfloat64_t scalar_vec = svdupq(scalar);\n        size_t j = 0;\n\n        while (j < n) {\n            svfloat64_t mat_vec = svld1(pg, mat + i * n + j);\n            svfloat64_t res_vec = svmlaq(scalar_vec, mat_vec);\n            svst1(pg, dst + i * n + j, res_vec);\n            j += svcntd();\n        }\n        i++;\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```c\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(0, n);\n\n    while (i < m) {\n        svfloat64_t scalar_vec = svdupq(scalar);\n        size_t j = 0;\n\n        while (j < n) {\n            svfloat64_t mat_vec = svld1(pg, mat + i * n + j);\n            svfloat64_t res_vec = svmlaq(scalar_vec, mat_vec);\n            svst1(pg, dst + i * n + j, res_vec);\n            j += svcntd();\n        }\n        i++;\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```c\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t i;\n    size_t vector_len = svcntd(); // Number of elements per vector\n    size_t total_elements = m * n;\n\n    for (i = 0; i < total_elements; i += vector_len) {\n        svfloat64_t vec_scalar = svdup_q(scalar); // Broadcast scalar to vector\n        svfloat64_t vec_mat = svld1q(mat + i);   // Load vector from mat\n        svfloat64_t vec_result = svmla_f64(vec_mat, vec_scalar, vec_mat); // Element-wise multiply\n        svst1q(dst + i, vec_result);             // Store result to dst\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```c\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    svbool_t pg = svwhilelt_b32(0, n);\n    for (size_t i = 0; i < m; i++) {\n        size_t offset = i * n;\n        svfloat32_t row = svld1(pg, &mat[offset]);\n        svfloat32_t squared = svmla(row, row, svdup_n_f32(0.0f));\n        svfloat32_t norm = svsqrt(svptrue_b32(), squared);\n        svfloat32_t normalized = svdiv(row, svdup_n_f32(svget_lane_f32(norm, 0)));\n        svst1(pg, &mat[offset], normalized);\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```c\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    svbool_t pg = svwhilelt_b32(0, n);\n    for (size_t i = 0; i < m; ++i) {\n        size_t offset = i * n;\n        svfloat32_t row = svld1(pg, &mat[offset]);\n        svfloat32_t squared = svmla(row, row, svdup_n_f32(0.0f));\n        svfloat32_t norm = svsqrt(squared);\n        svfloat32_t reciprocal_norm = svdiv(svdup_n_f32(1.0f), norm);\n        svfloat32_t normalized_row = svmul(row, reciprocal_norm);\n        svst1(pg, &mat[offset], normalized_row);\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```c\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    svbool_t pg = svwhilelt_b32(0, n);\n    for (size_t i = 0; i < m; i++) {\n        size_t offset = i * n;\n        svfloat32_t row = svld1(pg, &mat[offset]);\n        svfloat32_t squared = svmla(row, row, svdup_n_f32(0.0f));\n        svfloat32_t norm = svsqrt(squared);\n        svfloat32_t inv_norm = svdiv(svdup_n_f32(1.0f), norm);\n        svst1(pg, &mat[offset], svmla(row, inv_norm, svdup_n_f32(-1.0f)));\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```c\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    svbool_t pg = svwhilelt_b32(0, n);\n    for (size_t i = 0; i < m; i++) {\n        size_t offset = i * n;\n        svfloat32_t row = svld1(pg, &mat[offset]);\n        svfloat32_t squared = svmla(row, row, svdup_n_f32(0.0f));\n        svfloat32_t norm = svsqrt(squared);\n        svfloat32_t inv_norm = svdiv(svdup_n_f32(1.0f), norm);\n        svst1(pg, &mat[offset], svmla(row, inv_norm, svdup_n_f32(0.0f)));\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```c\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    size_t i, j;\n    svbool_t pg;\n\n    for (i = 0; i < m; i++) {\n        pg = svwhilelt_b32(0, n);\n        svfloat32_t row = svld1(pg, mat + i * n);\n        svfloat32_t squared = svmla(row, row, svdup_n_f32(0.0f));\n        svfloat32_t norm = svsqrt(svdup_n_f32(0.0f), squared);\n\n        // Handle zero norm case if necessary\n        svbool_t zero_norm = svcmpeq_n_f32(norm, 0.0f);\n        norm = svsel(zero_norm, svdup_n_f32(1.0f), norm);\n\n        for (j = 0; j < n; j += svcntw()) {\n            svfloat32_t current = svld1(pg, mat + i * n + j);\n            svst1(pg, mat + i * n + j, svdiv(current, norm));\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```c\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    size_t i, j, k;\n    size_t vl = svquery_vl();\n    size_t elem_per_vec = vl / sizeof(double);\n\n    for (i = 0; i < m; i++) {\n        for (j = 0; j < p; j++) {\n            svint64_t sum = svdup_n_s64(0);\n            for (k = 0; k < n; k++) {\n                svfloat64_t mat1_val = svld1_gather_index((const double*)(mat1 + i * n + k), elem_per_vec);\n                svfloat64_t mat2_val = svld1_gather_index((const double*)(mat2 + k * p + j), elem_per_vec);\n                svfloat64_t prod = svmul_f64(mat1_val, mat2_val);\n                sum = svadd_s64(sum, svrintn_x_f64(prod));\n            }\n            svst1_scatter_index((double*)(dst + i * p + j), sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```c\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    size_t i, j, k;\n    size_t vl = svquery_vl(); // Get the vector length\n    size_t elements_per_vector = vl / sizeof(double);\n\n    for (i = 0; i < m; i++) {\n        for (j = 0; j < p; j++) {\n            svbool_t pg = svtrue_b64();\n            svfloat64_t sum = svdup_n_f64(0.0);\n\n            for (k = 0; k < n; k++) {\n                svfloat64_t a = svld1(pg, mat1 + i * n + k);\n                svfloat64_t b = svld1(pg, mat2 + k * p + j);\n                sum = svmla_f64(sum, a, b);\n            }\n\n            svint64_t rounded = svrintn_f64(sum);\n            svst1(pg, dst + i * p + j, rounded);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```c\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    size_t i, j, k;\n    size_t vl = svquery_vl(); // Get the vector length\n    size_t elements_per_vector = vl / sizeof(double);\n\n    for (i = 0; i < m; i++) {\n        for (j = 0; j < p; j++) {\n            svbool_t pg = svtrue_b64(); // Full predicate\n            svfloat64_t sum_vec = svdup_n_f64(0.0); // Initialize sum vector\n\n            for (k = 0; k < n; k++) {\n                svfloat64_t mat1_vec = svld1(pg, mat1 + i * n + k);\n                svfloat64_t mat2_vec = svld1(pg, mat2 + k * p + j);\n                svfloat64_t prod_vec = svmul_f64(mat1_vec, mat2_vec);\n\n                sum_vec = svadd_f64(sum_vec, prod_vec);\n            }\n\n            svint64_t rounded_vec = svround_f64(sum_vec);\n            svst1(pg, dst + i * p + j, rounded_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```c\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    size_t i, j, k;\n    size_t vl = svquery_vl(); // Get the vector length\n    size_t elements_per_vector = vl / sizeof(double);\n\n    for (i = 0; i < m; i++) {\n        for (j = 0; j < p; j++) {\n            svbool_t pg = svtrue_b64(); // Initialize predicate for full vector\n            svfloat64_t sum_vec = svdup_n_f64(0.0); // Initialize sum vector\n\n            for (k = 0; k < n; k++) {\n                svfloat64_t mat1_vec = svld1(pg, mat1 + i * n + k); // Load mat1 row\n                svfloat64_t mat2_col_vec = svld1(pg, mat2 + k * p + j); // Load mat2 column\n\n                svfloat64_t prod_vec = svmul_f64(mat1_vec, mat2_col_vec); // Element-wise multiplication\n                sum_vec = svadd_f64(sum_vec, prod_vec); // Accumulate the sum\n            }\n\n            svint64_t rounded_vec = svround_f64(sum_vec); // Round to nearest integer\n            svst1(pg, dst + i * p + j, rounded_vec); // Store the result\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```c\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    size_t i, j, k;\n    size_t vl = svquery_vl(); // Get the vector length\n    size_t elements_per_vector = vl / sizeof(double);\n\n    for (i = 0; i < m; i++) {\n        for (j = 0; j < p; j++) {\n            svbool_t pg = svtrue_b64(); // Initialize predicate for full vector\n            svfloat64_t sum_vec = svdup_n_f64(0.0); // Initialize sum vector\n\n            for (k = 0; k < n; k++) {\n                svfloat64_t mat1_vec = svld1(pg, &mat1[i * n + k]);\n                svfloat64_t mat2_vec = svld1(pg, &mat2[k * p + j]);\n\n                sum_vec = svmla_f64(sum_vec, mat1_vec, mat2_vec); // Accumulate product\n            }\n\n            svint64_t rounded_vec = svrintn_f64(sum_vec); // Round to nearest integer\n            svst1(pg, &dst[i * p + j], rounded_vec); // Store result\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```c\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t i, j;\n    size_t vl = svquery_vl();\n    size_t elements_per_vector = vl / sizeof(float);\n\n    for (i = 0; i < cols; i += elements_per_vector) {\n        for (j = 0; j < rows; j++) {\n            svfloat32_t vec = svld1((const float*)(src + j * cols + i));\n            svfloat32_t rounded = svround(svadd(vec, svdup_f32(0.125f)));\n            svst1((float*)(dst + i * rows + j), rounded);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```c\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    svfloat32_t quarter = svdup_n_f32(0.25f);\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j += svcntm()) {\n            svfloat32_t vec_src = svld1_gather_offset_f32(src, i + j * rows);\n            svfloat32_t vec_add = svadd_v_v_f32(vec_src, quarter);\n            svfloat32_t vec_round = svround_f32(vec_add);\n            svst1_scatter_offset_f32(dst, j + i * cols, vec_round);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```c\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    svfloat32_t quarter = svdup_n_f32(0.25f);\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j += svcntm()) {\n            svfloat32_t vec_src = svld1_gather_offset_f32(src, i + j * rows);\n            svfloat32_t vec_add = svadd_v_v_f32(vec_src, quarter);\n            svfloat32_t vec_round = svround_f32(vec_add);\n            svst1_scatter_offset_f32(dst, j + i * cols, vec_round);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```c\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    svfloat32_t quarter = svdup_n_f32(0.25f);\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j += svcntm()) {\n            svfloat32_t vec_src = svld1_gather_index((const float *)src + i + j * rows, svindex_b(i, j, rows));\n            svfloat32_t vec_rounded = svround_f32(svadd_f32(vec_src, quarter));\n            svst1_scatter_index(dst + j + i * cols, svindex_b(i, j, rows), vec_rounded);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```c\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t i, j;\n    size_t vl = svquery_vl();\n\n    for (i = 0; i < cols; i += vl / sizeof(float)) {\n        svfloat32_t row_vec = svld1((const float *)src + i);\n        svfloat32_t rounded = svroundn(row_vec); // Round to nearest integer\n        rounded = svadd_n(rounded, 0.25f);       // Add 0.25 to shift to nearest quarter\n        svst1((float *)(dst + i), rounded);\n    }\n\n    for (j = 0; j < rows - 1; ++j) {\n        for (i = 0; i < cols; i += vl / sizeof(float)) {\n            svfloat32_t val = svld1((const float *)(src + j * cols + i));\n            svst1((float *)(dst + i * rows + j), val);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```c\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t i, j, k;\n    size_t nelts = dim1 * dim2 * dim3;\n    svbool_t pg = svwhilelt_b32(0, nelts);\n\n    for (i = 0; i < dim1; i++) {\n        for (j = 0; j < dim2; j++) {\n            size_t offset = i * dim2 * dim3 + j * dim3;\n            svfloat32_t v_tensor1, v_tensor2, v_result;\n\n            for (k = 0; k < dim3; k += svcntw()) {\n                pg = svwhilelt_b32(k, dim3);\n                v_tensor1 = svld1(pg, &tensor1[offset + k]);\n                v_tensor2 = svld1(pg, &tensor2[offset + k]);\n                v_result = svrinta_f32(svsub_f32(v_tensor1, v_tensor2));\n                svst1(pg, &dst[offset + k], v_result);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```c\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t i, j, k;\n    size_t nelts = dim1 * dim2 * dim3;\n    svfloat32_t vdiff;\n    svint32_t vrounded;\n\n    for (i = 0; i < dim1; i++) {\n        for (j = 0; j < dim2; j++) {\n            for (k = 0; k < dim3; k += svcntw()) {\n                size_t n = k + svcntw();\n                vdiff = svsub_f32(svld1_f32(tensor1 + i * dim2 * dim3 + j * dim3 + k), svld1_f32(tensor2 + i * dim2 * dim3 + j * dim3 + k));\n                vrounded = svround_to_int_f32(vdiff);\n                svst1_f32(dst + i * dim2 * dim3 + j * dim3 + k, vrounded);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```c\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t i, j, k;\n    size_t nelts = dim1 * dim2 * dim3;\n    svbool_t pg = svwhilelt_b32(0, nelts);\n\n    for (i = 0; svptest_any(pg); i += svcntw()) {\n        svfloat32_t v_tensor1 = svld1(pg, tensor1 + i);\n        svfloat32_t v_tensor2 = svld1(pg, tensor2 + i);\n        svfloat32_t v_result = svsub_x_f32(v_tensor1, v_tensor2, v_tensor1);\n        svfloat32_t v_rounded = svrintm_f32(v_result);\n        svst1(pg, dst + i, v_rounded);\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```c\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t i, j, k;\n    size_t nelts = dim1 * dim2 * dim3;\n    svfloat32_t vdiff;\n    svint32_t vrounded;\n\n    for (i = 0; i < dim1; i++) {\n        for (j = 0; j < dim2; j++) {\n            for (k = 0; k < dim3; k += svcntw()) {\n                size_t n = k + svcntw();\n                vdiff = svsub_f32(svld1_f32(tensor1 + i * dim2 * dim3 + j * dim3 + k), svld1_f32(tensor2 + i * dim2 * dim3 + j * dim3 + k));\n                vrounded = svrintm_f32(vdiff); // Round towards zero\n                svst1_f32(dst + i * dim2 * dim3 + j * dim3 + k, vrounded);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```c\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t i, j, k;\n    size_t nelts = dim1 * dim2 * dim3;\n    svbool_t pg = svwhilelt_b32(0, nelts);\n\n    for (i = 0; svptest_any(pg); i += svcntw()) {\n        svfloat32_t v_tensor1 = svld1(pg, tensor1 + i);\n        svfloat32_t v_tensor2 = svld1(pg, tensor2 + i);\n        svfloat32_t v_result = svsub_x_f32(v_tensor1, v_tensor2, v_tensor1);\n        svfloat32_t v_rounded = svrintm_f32(v_result);\n        svst1(pg, dst + i, v_rounded);\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, m * n);\n    while (svptest_any(svptrue_b64(), pg)) {\n        svfloat64_t vec1 = svld1(pg, mat1 + i);\n        svfloat64_t vec2 = svld1(pg, mat2 + i);\n        svst1(pg, dst + i, svmul_x(pg, vec1, vec2));\n        i += svcntd();\n        pg = svwhilelt_b64(i, m * n);\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, m * n);\n    while (svptest_any(svptrue_b64(), pg)) {\n        svfloat64_t vec1 = svld1(pg, mat1 + i);\n        svfloat64_t vec2 = svld1(pg, mat2 + i);\n        svst1(pg, dst + i, svmul_x(pg, vec1, vec2));\n        i += svcntd();\n        pg = svwhilelt_b64(i, m * n);\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t i = 0;\n    while (i < m * n) {\n        size_t elements_per_block = svcntd(); // Number of elements per vector block\n        svbool_t pg = svwhilelt_b64(i, m * n); // Create predicate for current block\n        svfloat64_t vec1 = svld1(pg, mat1 + i); // Load first matrix block\n        svfloat64_t vec2 = svld1(pg, mat2 + i); // Load second matrix block\n        svfloat64_t result = svmla(pg, vec1, vec2); // Perform element-wise multiplication\n        svst1(pg, dst + i, result); // Store the result back to dst\n        i += elements_per_block; // Move to the next block\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, m * n);\n    while (svptest_any(svptrue_b64(), pg)) {\n        svfloat64_t vec1 = svld1(pg, mat1 + i);\n        svfloat64_t vec2 = svld1(pg, mat2 + i);\n        svst1(pg, dst + i, svmul_x(pg, vec1, vec2));\n        i += svcntd();\n        pg = svwhilelt_b64(i, m * n);\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(0, n);\n\n    for (; i < m; i++) {\n        svst1q_f64(pg, dst + i*n, svmulq(vec_ld1q_f64(mat1 + i*n), vec_ld1q_f64(mat2 + i*n)));\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    svfloat32_t vec_sve = svld1((const float *)vec);\n    for (size_t i = 0; i < m; i += svcntd()) {\n        svint64_t idx = svindex_u64(0, i);\n        svfloat32_t row_sve = svld1_gather_index((const float *)mat, idx);\n        svfloat32_t res_sve = svmla(row_sve, vec_sve, row_sve);\n        svst1((float *)dst + i, res_sve);\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    svfloat32_t vec_sve = svld1((const svfloat32_t*)vec);\n    for (size_t i = 0; i < m; i += svcntd()) {\n        svint64_t idx = svindex_u64(0, 1);\n        svfloat32_t mat_row = svld1_gather_index((const svfloat32_t*)mat, idx);\n        svfloat32_t res = svmla(vec_sve, mat_row);\n        svst1((svfloat32_t*)&dst[i], res);\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    svfloat32_t vec_sve = svld1((const svfloat32_t*)vec);\n    for (size_t i = 0; i < m; i += svcntd()) {\n        svint64_t idx = svindex_u64(0, 1);\n        svfloat32_t mat_row_sve = svld1_gather_index((const svfloat32_t*)mat, idx);\n        svfloat32_t res_sve = svmla(vec_sve, mat_row_sve, mat_row_sve);\n        svst1((svfloat32_t*)(dst + i), res_sve);\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    size_t vl = svquery_vl();\n    size_t elements_per_vector = vl / sizeof(float);\n\n    for (size_t i = 0; i < m; i += elements_per_vector) {\n        size_t limit = (i + elements_per_vector <= m) ? elements_per_vector : m - i;\n        svfloat_t res = svdup_n_f32(0.0f);\n\n        for (size_t j = 0; j < n; j++) {\n            svfloat_t vec_j = svld1_gather_index(sve_set_vl(n), vec + j);\n            for (size_t k = 0; k < limit; k++) {\n                svfloat_t mat_ik = svld1(mat + (i + k) * n + j);\n                res = svmla_f32(res, mat_ik, vec_j);\n            }\n        }\n\n        svst1(dst + i, res);\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    svfloat32_t vec_sve = svld1((const svfloat32_t*)vec);\n    for (size_t i = 0; i < m; i += svcntm()) {\n        svfloat32_t acc = svdup_n_f32(0.0f);\n        size_t j = 0;\n        for (; j + svcntm() <= n; j += svcntm()) {\n            svfloat32_t row_sve = svld1((const svfloat32_t*)(mat + i * n + j));\n            acc = svmla_f32(acc, row_sve, vec_sve);\n        }\n        for (; j < n; j++) {\n            acc = svmla_f32(acc, svld1((const svfloat32_t*)(mat + i * n + j)), vec[j]);\n        }\n        svst1((float*)(dst + i), acc);\n    }\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```c\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    svbool_t pg = svwhilelt_b64(0, n);\n    double sum = 0.0;\n    size_t i = 0;\n\n    while (i < m) {\n        svfloat64_t vec = svld1(pg, mat + i * n);\n        svfloat64_t sum_vec = svaddv(pg, vec);\n        sum += svcvt_f64_f64(svaddv(pg, sum_vec));\n        i += svcntb();\n    }\n\n    return sum / (m * n);\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```c\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    svbool_t pg = svwhilelt_b64(0, n);\n    double sum = 0.0;\n    size_t i = 0;\n\n    while (i < m) {\n        svfloat64_t vec = svld1(pg, mat + i * n);\n        svfloat64_t sum_vec = svaddv(pg, vec);\n        sum += svcvt_f64_f64(svaddv(pg, vec));\n        i += svcntb();\n    }\n    return sum / (m * n);\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```c\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    svbool_t pg = svwhilelt_b64(0, n);\n    double sum = 0.0;\n    size_t i = 0;\n\n    while (i < m) {\n        svfloat64_t vec;\n        double local_sum = 0.0;\n        size_t j = 0;\n\n        while (j < n) {\n            vec = svld1(pg, mat + i * n + j);\n            local_sum += svaddv_b64(pg, vec);\n            j += svcntd();\n        }\n\n        sum += local_sum;\n        i++;\n    }\n\n    return sum / (m * n);\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```c\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    svbool_t pg = svwhilelt_b64(0, n);\n    double sum = 0.0;\n    size_t i = 0;\n\n    while (i < m) {\n        svfloat64_t vec = svld1(pg, mat + i * n);\n        svbool_t isnonempty = svptest_any(svptrue_b64(), pg);\n        if (isnonempty) {\n            svfloat64_t sum_vec = svaddv(pg, vec);\n            sum += svcvt_f64_m(pg, sum_vec);\n        }\n        i += svcntd();\n    }\n    return sum / (m * n);\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```c\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    svbool_t pg = svwhilelt_b64(0, n);\n    double sum = 0.0;\n    size_t i = 0;\n\n    while (i < m) {\n        svfloat64_t vec = svld1(pg, mat + i * n);\n        svbool_t isnonzero = svcmpeq_b64(pg, vec, svdup_n_b64(0));\n        svfloat64_t nonzero_vec = svcond_b64(isnonzero, svdup_n_f64(0), vec);\n        sum += svaddvq_f64(nonzero_vec);\n        i += svcntd();\n    }\n    return sum / (m * n);\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```c\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    svbool_t pg = svwhilelt_b32(0, cols);\n    for (size_t i = 0; i < rows; i++) {\n        svbool_t dir = svcmpne_b32(svld1(pg, &directions[i]), svdup_gather_offset_b32((const int8_t*)directions, i * sizeof(bool)));\n        svint32_t prev = svld1(pg, matrix + i * cols);\n        svint32_t curr;\n        svbool_t sorted = svcmpeq_b32(prev, svdup_n_s32(-1));\n        for (size_t j = 1; j < cols; j++) {\n            curr = svld1(pg, matrix + i * cols + j);\n            svbool_t cmp = dir ? svcmple_s32(curr, prev) : svcmpge_s32(curr, prev);\n            sorted = svand_b32(sorted, cmp);\n            prev = curr;\n        }\n        if (!svptest_any(svptrue_b32(), sorted)) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```c\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    svbool_t pg = svwhilelt_b32(0, (int)cols);\n    bool all_sorted = true;\n\n    for (size_t r = 0; r < rows; r++) {\n        svbool_t sorted = svptrue_b32();\n        const int* row = matrix + r * cols;\n        bool ascending = directions[r];\n\n        for (size_t c = 1; svptest_any(pg); c += svcntw()) {\n            svint32_t current = svld1(pg, row + c - 1);\n            svint32_t next = svld1(pg, row + c);\n\n            if (ascending) {\n                sorted = svcmpgt_b32(sorted, current, next);\n            } else {\n                sorted = svcmplt_b32(sorted, current, next);\n            }\n        }\n\n        all_sorted &= svptest_any(sorted);\n    }\n\n    return all_sorted;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```c\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    svbool_t pg = svwhilelt_b32(0, (int)cols);\n    bool all_sorted = true;\n\n    for (size_t i = 0; i < rows; i++) {\n        svbool_t sorted = svptrue_b32();\n        const int* row = matrix + i * cols;\n        bool ascending = directions[i];\n\n        for (size_t j = 1; j < cols; j += svcntw()) {\n            svint32_t prev = svld1(pg, row + j - 1);\n            svint32_t curr = svld1(pg, row + j);\n\n            if (ascending) {\n                sorted = svcmpeq_b32(sorted, svcmpge_b32(prev, curr));\n            } else {\n                sorted = svcmpeq_b32(sorted, svcmpge_b32(curr, prev));\n            }\n        }\n\n        if (!svptest_any(sorted)) {\n            all_sorted = false;\n            break;\n        }\n    }\n\n    return all_sorted;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```c\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    svbool_t pg = svwhilelt_b32(0, (int)cols);\n    for (size_t r = 0; r < rows; r++) {\n        svbool_t all_sorted = svptrue_b32();\n        const int* row = matrix + r * cols;\n        bool ascending = directions[r];\n        svbool_t dir_mask = svcmpne_b32(svindex_b32(0, ascending ? 1 : -1), svindex_b32(0, 0));\n        for (size_t c = 1; c < cols; c += svcntw()) {\n            svint32_t current = svld1(pg, row + c);\n            svint32_t prev = svld1(pg, row + c - svcntw());\n            svbool_t sorted = svcmple_gather_b32(dir_mask, current, prev);\n            all_sorted = svand_b32(all_sorted, sorted);\n        }\n        if (!svptest_any(svptrue_b32(), all_sorted)) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```c\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    svbool_t pg = svwhilelt_b32(0, cols);\n    for (size_t i = 0; i < rows; i++) {\n        svbool_t dir = svcmpne_b32(svld1(pg, &directions[i]), svdup_n_b32(false));\n        svint32_t prev = svld1(pg, &matrix[i * cols]);\n        while (svptest_any(pg, svwhilelt_b32(i + 1, rows))) {\n            svint32_t curr = svld1(pg, &matrix[(i + 1) * cols]);\n            svbool_t sorted = svcmpeq_b32(svsub(pg, curr, prev), svdup_n_s32(0));\n            if (!svptest_any(dir, sorted)) {\n                return false;\n            }\n            prev = curr;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    svbool_t pg = svwhilelt_b16(0, length);\n    while (svptest_any(svptrue_b16(), pg)) {\n        int16_t vl = svlastb_b16(pg);\n        svint16_t vsrc = svld1(pg, src);\n        svint16_t vdst = svdiv_rn(vsrc, svdup_n_s16(base));\n        vdst = svsmul(vdst, svdup_n_s16(base));\n        svst1(pg, dst, vdst);\n        src += vl;\n        dst += vl;\n        pg = svwhilelt_b16((int)src - (int)src[0], length);\n    }\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    svbool_t pg = svwhilelt_b16(0, length);\n    while (svptest_any(svptrue_b16(), pg)) {\n        int16_t vl = svlast_elemidx_b16(pg);\n        svint16_t vsrc = svld1(pg, src);\n        svint16_t vdst = svdiv_rn(vsrc, svdup_n_s16(base));\n        vdst = svsmul(vdst, svdup_n_s16(base));\n        svst1(pg, dst, vdst);\n        src += vl;\n        dst += vl;\n        pg = svwhilelt_b16((int)src - (int)src[0], length);\n    }\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    svbool_t pg = svwhilelt_b16(0, length);\n    while (svptest_any(svptrue_b16(), pg)) {\n        int16_t vl = svlastcont_b16(pg);\n        svint16_t v_src = svld1(pg, src);\n        svint16_t v_dst = svdiv_rn(v_src, svdup_n_s16(base));\n        v_dst = svmul_n_s16(v_dst, svdup_n_s16(base));\n        svst1(pg, dst, v_dst);\n        src += vl;\n        dst += vl;\n        pg = svwhilelt_b16(svcntb(), length - (src - (const int16_t*)0));\n    }\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    while (svptest_any(svptrue_b32(), pg)) {\n        int16_t vl = svlastcont_b32(pg);\n        svint16_t vec_src = svld1(pg, src);\n        svint16_t vec_dst = svdiv_rn_s16(vec_src, svdup_n_s16(base));\n        vec_dst = svsmul_s16(vec_dst, svdup_n_s16(base));\n        svst1(pg, dst, vec_dst);\n        src += vl;\n        dst += vl;\n        pg = svwhilelt_b32(svcntw(), length - (src - (const int16_t*)0));\n    }\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    svbool_t pg = svwhilelt_b16(0, length);\n    while (svptest_any(svptrue_b16(), pg)) {\n        int16_t vl = svlastcont_b16(pg);\n        svint16_t v_src = svld1(pg, src);\n        svint16_t v_dst = svdiv_rn(v_src, svdup_n_s16(base));\n        v_dst = svmul_n_s16(v_dst, svdup_n_s16(base));\n        svst1(pg, dst, v_dst);\n        src += vl;\n        dst += vl;\n        pg = svwhilelt_b16(svcntb(), length);\n    }\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```c\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    svbool_t pg = svwhilelt_b64(0, cols);\n    for (size_t i = 0; i < rows; ++i) {\n        bool match = true;\n        for (size_t j = 0; j < cols; j += svcntd()) {\n            svbool_t p = svwhilelt_b64(j, cols);\n            svfloat64_t vec = svld1(pg, &matrix[i * cols + j]);\n            svfloat64_t ref = svld1(pg, vector + j);\n            svbool_t eq = svcmpeq_f64(vec, ref, p);\n            if (!svptest_any(eq, pg)) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```c\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    svbool_t pg = svwhilelt_b64(0, cols);\n    for (size_t i = 0; i < rows; ++i) {\n        bool match = true;\n        svbool_t all_match = svptrue_b64();\n        for (size_t j = 0; j < cols; j += svcntd()) {\n            svfloat64_t vec_chunk = svld1(pg, &matrix[i * cols + j]);\n            svfloat64_t ref_chunk = svld1(pg, vector + j);\n            svbool_t eq_chunk = svcmpeq_f64(vec_chunk, ref_chunk);\n            all_match = svand_b64(all_match, eq_chunk);\n            if (!svptest_any(all_match)) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```c\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    svbool_t pg = svwhilelt_b64(0, cols);\n    for (size_t i = 0; i < rows; ++i) {\n        bool match = true;\n        svbool_t all_match = svptrue_b64();\n        for (size_t j = 0; j < cols; j += svcntd()) {\n            svfloat64_t vec_sve = svld1(pg, &matrix[i * cols + j]);\n            svfloat64_t ref_sve = svld1(pg, vector + j);\n            svbool_t eq = svcmpeq_f64(vec_sve, ref_sve);\n            all_match = svand_b64(all_match, eq);\n            if (!svptest_any(svptrue_b64(), all_match)) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```c\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    svbool_t pg = svwhilelt_b64(0, cols);\n    for (size_t i = 0; i < rows; ++i) {\n        bool match = true;\n        svbool_t all_match = svptrue_b64();\n        for (size_t j = 0; j < cols; j += svcntd()) {\n            svfloat64_t vec_chunk = svld1(pg, &matrix[i * cols + j]);\n            svfloat64_t ref_chunk = svld1(pg, vector + j);\n            svbool_t eq_chunk = svcmpeq_f64(vec_chunk, ref_chunk);\n            all_match = svand_b64(all_match, eq_chunk);\n            if (!svptest_any(svptrue_b64(), all_match)) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```c\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    svbool_t pg = svwhilelt_b64(0, cols);\n    for (size_t i = 0; i < rows; ++i) {\n        bool match = true;\n        svbool_t all_match = svptrue_b64();\n        for (size_t j = 0; j < cols; j += svcntd()) {\n            svfloat64_t vec_chunk = svld1(pg, &matrix[i * cols + j]);\n            svfloat64_t ref_chunk = svld1(pg, vector + j);\n            svbool_t eq_chunk = svcmpeq_f64(vec_chunk, ref_chunk);\n            all_match = svand_b64(all_match, eq_chunk);\n            if (!svptest_any(svptrue_b64(), all_match)) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```c\n#include <arm_sve.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_count = 0;\n    size_t i = 0;\n\n    while (i < dims[0]) {\n        size_t j = 0;\n        while (j < dims[1]) {\n            size_t k = 0;\n            while (k < dims[2]) {\n                size_t l = 0;\n                while (l < dims[3]) {\n                    size_t block_size = svcntb(); // Number of bytes in a vector\n                    svuint8_t vec_a = svld1_u8(A + i * dims[1] * dims[2] * dims[3] +\n                                               j * dims[2] * dims[3] +\n                                               k * dims[3] +\n                                               l);\n                    svuint8_t vec_b = svld1_u8(B + i * dims[1] * dims[2] * dims[3] +\n                                               j * dims[2] * dims[3] +\n                                               k * dims[3] +\n                                               l);\n                    svbool_t mask = svwhilelt_b8(l, dims[3]);\n                    svbool_t eq_mask = svcmpeq_u8(vec_a, vec_b);\n                    size_t eq_count = svcntb(svand_b8(eq_mask, mask));\n                    total_count += eq_count;\n\n                    l += block_size;\n                }\n                k += block_size;\n            }\n            j += block_size;\n        }\n        i += block_size;\n    }\n\n    return total_count;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```c\n#include <arm_sve.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_count = 0;\n    size_t i = 0;\n\n    while (i < dims[0]) {\n        size_t j = 0;\n        while (j < dims[1]) {\n            size_t k = 0;\n            while (k < dims[2]) {\n                size_t l = 0;\n                while (l < dims[3]) {\n                    size_t block_size = svcntb(); // Number of elements per vector\n                    svbool_t pg = svwhilelt_b8(l, dims[3]);\n                    svuint8_t vec_A = svld1_u8(A + i * dims[1] * dims[2] * dims[3] +\n                                               j * dims[2] * dims[3] +\n                                               k * dims[3] + l);\n                    svuint8_t vec_B = svld1_u8(B + i * dims[1] * dims[2] * dims[3] +\n                                               j * dims[2] * dims[3] +\n                                               k * dims[3] + l);\n                    svbool_t eq_mask = svcmpeq_u8(pg, vec_A, vec_B);\n                    size_t eq_count = svcntb(svcntp_b8(eq_mask));\n                    total_count += eq_count;\n                    l += block_size;\n                }\n                k += block_size;\n            }\n            j += block_size;\n        }\n        i += block_size;\n    }\n\n    return total_count;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```c\n#include <arm_sve.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_count = 0;\n    size_t i = 0;\n\n    while (i < dims[0]) {\n        size_t j = 0;\n        while (j < dims[1]) {\n            size_t k = 0;\n            while (k < dims[2]) {\n                size_t l = 0;\n                while (l < dims[3]) {\n                    size_t block_size = svcntb(); // Number of bytes in a vector\n                    svbool_t p = svwhilelt_b8(l, dims[3]);\n                    svuint8_t vec_a = svld1_u8(A + i * dims[1] * dims[2] * dims[3] +\n                                               j * dims[2] * dims[3] +\n                                               k * dims[3] + l);\n                    svuint8_t vec_b = svld1_u8(B + i * dims[1] * dims[2] * dims[3] +\n                                               j * dims[2] * dims[3] +\n                                               k * dims[3] + l);\n                    svbool_t eq_mask = svcmpeq_u8(vec_a, vec_b);\n                    size_t eq_count = svcntp_b8(eq_mask);\n                    total_count += eq_count;\n                    l += block_size;\n                }\n                k += 1;\n            }\n            j += 1;\n        }\n        i += 1;\n    }\n    return total_count;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```c\n#include <arm_sve.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_count = 0;\n    size_t i = 0;\n    size_t n = dims[0];\n    size_t m = dims[1];\n    size_t p = dims[2];\n    size_t q = dims[3];\n\n    while (i + svcntb() <= n * m * p * q) {\n        svbool_t pg = svwhilelt_b8(i, n * m * p * q);\n        svuint8_t vec_a = svld1_u8(A + i, pg);\n        svuint8_t vec_b = svld1_u8(B + i, pg);\n        svbool_t eq = svcmpeq_u8(vec_a, vec_b);\n        size_t count = svcntb() - svcntp_b8(svnot_b8(eq));\n        total_count += count;\n        i += svcntb();\n    }\n\n    // Handle remaining elements\n    while (i < n * m * p * q) {\n        if (A[i] == B[i]) {\n            total_count++;\n        }\n        i++;\n    }\n\n    return total_count;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```c\n#include <arm_sve.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_count = 0;\n    size_t i = 0;\n\n    while (i < dims[0]) {\n        size_t j = 0;\n        while (j < dims[1]) {\n            size_t k = 0;\n            while (k < dims[2]) {\n                size_t l = 0;\n                while (l < dims[3]) {\n                    size_t block_size = svcntb(); // Number of bytes in one vector\n                    svbool_t p = svwhilelt_b8(l, dims[3]);\n                    svuint8_t vec_a = svld1_u8(A + i * dims[1] * dims[2] * dims[3] +\n                                               j * dims[2] * dims[3] +\n                                               k * dims[3] + l);\n                    svuint8_t vec_b = svld1_u8(B + i * dims[1] * dims[2] * dims[3] +\n                                               j * dims[2] * dims[3] +\n                                               k * dims[3] + l);\n                    svbool_t eq_mask = svcmpeq_u8(vec_a, vec_b);\n                    size_t eq_count = svcntb(svcntp(eq_mask));\n                    total_count += eq_count;\n                    l += block_size;\n                }\n                k += block_size;\n            }\n            j += block_size;\n        }\n        i += block_size;\n    }\n\n    return total_count;\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    svbool_t p = svwhilelt_b64(i, length);\n    while (svptest_any(svptrue_b64(), p)) {\n        int64_tx_vec = svld1(p, x + i);\n        int64_tx_mul = svmla_x(p, a, int64_tx_vec);\n        int64_tx_abs = svabs_x(p, int64_tx_mul);\n        svst1(p, y + i, int64_tx_abs);\n        i += svcntd();\n        p = svwhilelt_b64(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    svbool_t p = svwhilelt_b64(i, length);\n    while (svptest_any(svptrue_b64(), p)) {\n        int64_tx_vec = svld1(p, x + i);\n        int64_tx_mul = svmls_z(p, svdup_n_q64(a), int64_tx_vec, svabs_q64(int64_tx_vec));\n        svst1(p, y + i, int64_tx_mul);\n        i += svcntd();\n        p = svwhilelt_b64(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    svbool_t p = svwhilelt_b64(i, length);\n    while (svptest_any(svptrue_b64(), p)) {\n        int64_tx_vec = svld1(p, x + i);\n        int64_tx_mul = svmls_z(p, svdup_n_q64(a), int64_tx_vec, svabs_q64(int64_tx_vec));\n        svst1(p, y + i, int64_tx_mul);\n        i += svcntd();\n        p = svwhilelt_b64(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    svbool_t p = svwhilelt_b64(i, length);\n    while (svptest_any(svptrue_b64(), p)) {\n        int64_tx_vec = svld1(p, x + i);\n        int64_tx_mul = svmla_x(p, svdup_n_s64(a), int64_tx_vec);\n        int64_tx_abs = svabs_s64(p, int64_tx_mul);\n        svst1(p, y + i, int64_tx_abs);\n        i += svcntd();\n        p = svwhilelt_b64(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    svbool_t p = svwhilelt_b64(i, length);\n    while (svptest_any(svptrue_b64(), p)) {\n        int64_t_1_t xa = svld1_gather_index(p, x, i);\n        int64_t_1_t ax = svmls_x(p, xa, svdup_n_s64(a));\n        int64_t_1_t abs_ax = svabs_x(p, ax);\n        svst1_scatter_index(p, y, i, abs_ax);\n        i += svcntd();\n        p = svwhilelt_b64(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    svbool_t pg = svwhilelt_b16(0, length);\n    int16_t min_val = svmaxv_b16(pg, svld1(pg, vec));\n    int16_t max_val = svminv_b16(pg, svld1(pg, vec));\n    return (MinMaxPair){min_val, max_val};\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    svbool_t pg = svwhilelt_b16(0, length);\n    int16_t min_val = svmaxv_b16(pg, svld1(pg, vec));\n    int16_t max_val = svminv_b16(pg, svld1(pg, vec));\n    return (MinMaxPair){min_val, max_val};\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    svbool_t pg = svwhilelt_b16(0, length);\n    int16_t min_val = svmaxv_b16(pg, svld1(pg, vec));\n    int16_t max_val = svminv_b16(pg, svld1(pg, vec));\n    return (MinMaxPair){min_val, max_val};\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    svbool_t pg = svwhilelt_b16(0, length);\n    int16_t min_val = svmaxv_b16(pg, svld1(pg, vec));\n    int16_t max_val = svminv_b16(pg, svld1(pg, vec));\n    return (MinMaxPair){min_val, max_val};\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    svbool_t pg = svwhilelt_b16(0, length);\n    int16_t min_val = svmaxv_b16(pg, svld1(pg, vec));\n    int16_t max_val = svminv_b16(pg, svld1(pg, vec));\n    return (MinMaxPair){min_val, max_val};\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```c\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0)\n        return false;\n\n    svbool_t pg = svwhilelt_b32(0, cols);\n    bool result = true;\n\n    for (size_t i = 1; i < rows; ++i) {\n        const int *prev_row = matrix + (i - 1) * cols;\n        const int *curr_row = matrix + i * cols;\n\n        svint32_t prev_vec = svld1(pg, prev_row);\n        svint32_t curr_vec = svld1(pg, curr_row);\n\n        svbool_t cmp_gt = svcmple_s32(pg, prev_vec, curr_vec);\n        result &= !svptest_any(svptrue_b32(), cmp_gt);\n        if (!result)\n            break;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```c\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0)\n        return false;\n\n    svbool_t pg = svwhilelt_b32(0, cols);\n    bool result = true;\n\n    for (size_t i = 1; i < rows; ++i) {\n        const int *prev_row = matrix + (i - 1) * cols;\n        const int *curr_row = matrix + i * cols;\n\n        svint32_t prev_vec = svld1(pg, prev_row);\n        svint32_t curr_vec = svld1(pg, curr_row);\n\n        svbool_t gt_mask = svcmpgt(pg, curr_vec, prev_vec);\n        svbool_t eq_mask = svcmpeq(pg, curr_vec, prev_vec);\n\n        if (svptest_any(gt_mask) && !svptest_any(eq_mask)) {\n            // Check remaining elements sequentially if vector comparison fails\n            for (size_t j = 0; j < cols; ++j) {\n                if (curr_row[j] <= prev_row[j]) {\n                    result = false;\n                    break;\n                }\n            }\n        } else {\n            result = false;\n        }\n\n        if (!result)\n            break;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```c\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0)\n        return false;\n\n    svbool_t pg = svwhilelt_b32(0, cols);\n    bool result = true;\n\n    for (size_t i = 1; i < rows; ++i) {\n        const int *prev_row = matrix + (i - 1) * cols;\n        const int *curr_row = matrix + i * cols;\n\n        svint32_t prev_vec = svld1(pg, prev_row);\n        svint32_t curr_vec = svld1(pg, curr_row);\n\n        svbool_t gt_mask = svcmpgt(pg, curr_vec, prev_vec);\n        svbool_t eq_mask = svcmpeq(pg, curr_vec, prev_vec);\n\n        if (svptest_any(gt_mask) && !svptest_any(eq_mask)) {\n            // Check remaining elements sequentially if vector comparison fails\n            for (size_t j = 0; j < cols; ++j) {\n                if (curr_row[j] <= prev_row[j]) {\n                    result = false;\n                    break;\n                }\n            }\n        } else {\n            result = false;\n        }\n\n        if (!result)\n            break;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```c\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0)\n        return false;\n\n    svbool_t pg = svwhilelt_b32(0, cols);\n    bool result = true;\n\n    for (size_t i = 1; i < rows; ++i) {\n        const int *prev_row = matrix + (i - 1) * cols;\n        const int *curr_row = matrix + i * cols;\n\n        svint32_t prev_vec = svld1(pg, prev_row);\n        svint32_t curr_vec = svld1(pg, curr_row);\n\n        svbool_t gt_mask = svcmpgt(pg, curr_vec, prev_vec);\n        svbool_t eq_mask = svcmpeq(pg, curr_vec, prev_vec);\n\n        if (svptest_any(gt_mask) && !svptest_any(eq_mask)) {\n            // Check remaining elements sequentially if vector comparison fails\n            for (size_t j = 0; j < cols; ++j) {\n                if (curr_row[j] <= prev_row[j]) {\n                    result = false;\n                    break;\n                }\n            }\n        } else {\n            result = false;\n        }\n\n        if (!result)\n            break;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```c\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0)\n        return false;\n\n    svbool_t pg = svwhilelt_b32(0, cols);\n    bool result = true;\n\n    for (size_t i = 1; i < rows; ++i) {\n        const int *prev_row = matrix + (i - 1) * cols;\n        const int *curr_row = matrix + i * cols;\n\n        svint32_t prev_vec = svld1(pg, prev_row);\n        svint32_t curr_vec = svld1(pg, curr_row);\n\n        svbool_t cmp_gt = svcmple_s32(pg, prev_vec, curr_vec);\n        result &= !svptest_any(svptrue_b32(), cmp_gt);\n        if (!result)\n            break;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```c\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n    size_t block_elements = block_size * block_size;\n    size_t total_blocks = num_blocks_row * num_blocks_col;\n    svbool_t pg_all = svwhilelt_b32(0, block_elements);\n    \n    // Load the first block\n    svint32_t first_block = svld1(pg_all, matrix);\n    \n    for (size_t block_id = 1; block_id < total_blocks; block_id++) {\n        size_t row_offset = (block_id / num_blocks_col) * block_size;\n        size_t col_offset = (block_id % num_blocks_col) * block_size;\n        const int* current_block_ptr = matrix + row_offset * cols + col_offset;\n        \n        svint32_t current_block = svld1(pg_all, current_block_ptr);\n        \n        if (!svcmpeq_m(pg_all, pg_all, first_block, current_block)) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```c\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n    size_t total_blocks = num_blocks_row * num_blocks_col;\n\n    svbool_t pg_all = svptrue_b32();\n    svint32_t ref_block = svld1(pg_all, matrix);\n\n    for (size_t b = 1; b < total_blocks; b++) {\n        size_t row_idx = (b / num_blocks_col) * block_size;\n        size_t col_idx = (b % num_blocks_col) * block_size;\n        svint32_t current_block = svld1(pg_all, matrix + row_idx * cols + col_idx);\n        if (!svcmpeq_m(pg_all, pg_all, current_block, ref_block)) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```c\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n    size_t num_rows = rows / block_size;\n    size_t num_cols = cols / block_size;\n    svbool_t pg = svwhilelt_b32(0, block_size * block_size);\n    svint32_t ref_block = svld1(pg, matrix);\n    for (size_t i = 1; i < num_rows; i++) {\n        for (size_t j = 1; j < num_cols; j++) {\n            svint32_t current_block = svld1(pg, matrix + (i * block_size * cols + j * block_size));\n            if (!svcmpeq_b32_z(pg, svcmpne_b32(ref_block, current_block))) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```c\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n    size_t block_elements = block_size * block_size;\n    size_t elements_per_vector = svcntw();\n    svint32_t ref_block = svld1((const int *)matrix);\n    for (size_t br = 0; br < num_blocks_row; br++) {\n        for (size_t bc = 0; bc < num_blocks_col; bc++) {\n            size_t offset = (br * block_size + bc) * block_elements;\n            svint32_t current_block = svld1((const int *)(matrix + offset));\n            svbool_t eq_mask = svcmpeq_n_s32(ref_block, current_block);\n            if (!svptest_any(svptrue_b32(), eq_mask)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```c\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n    size_t block_elements = block_size * block_size;\n    svbool_t pg_all = svptrue_b64();\n    \n    for (size_t br = 1; br < num_blocks_row; br++) {\n        for (size_t bc = 0; bc < num_blocks_col; bc++) {\n            svbool_t pg_block = svwhilelt_b64(0, block_elements);\n            size_t base_idx_ref = (br * block_size * cols + bc * block_size);\n            size_t base_idx_curr = ((br - 1) * block_size * cols + bc * block_size);\n            \n            for (size_t i = 0; i < block_elements; i += svcntw()) {\n                svint32_t ref_block = svld1(pg_block, &matrix[base_idx_ref + i]);\n                svint32_t curr_block = svld1(pg_block, &matrix[base_idx_curr + i]);\n                svbool_t eq = svcmpeq_s32(pg_all, ref_block, curr_block);\n                if (!svptest_any(svptrue_b64(), eq)) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```c\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (length < block_size || block_size == 0) return false;\n    svbool_t pg = svwhilelt_b64(0, length);\n    size_t vl = svcntd();\n    size_t num_blocks = length / block_size;\n\n    // Load the first block\n    svfloat64_t first_block = svld1(pg, vec);\n\n    for (size_t i = 1; i < num_blocks; i++) {\n        svfloat64_t current_block = svld1(pg, vec + i * block_size);\n        svbool_t eq = svcmpeq_f64_m(pg, first_block, current_block);\n        if (!svptest_any(eq)) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```c\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (length < block_size || block_size == 0) return false;\n    svbool_t pg = svwhilelt_b64(0, length);\n    size_t vl = svcntd();\n    size_t num_blocks = length / block_size;\n\n    // Load the first block\n    svfloat64_t first_block = svld1(pg, vec);\n\n    for (size_t i = 1; i < num_blocks; i++) {\n        svfloat64_t current_block = svld1(pg, vec + i * block_size);\n        svbool_t eq = svcmpeq_f64_m(pg, first_block, current_block);\n        if (!svptest_any(eq)) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```c\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (length < block_size || block_size == 0) return false;\n    svbool_t pg = svwhilelt_b64(0, length);\n    size_t vl = svcntd();\n    size_t num_blocks = length / block_size;\n\n    // Load the first block\n    svfloat64_t first_block = svld1(pg, vec);\n\n    for (size_t i = 1; i < num_blocks; i++) {\n        svfloat64_t current_block = svld1(pg, vec + i * block_size);\n        svbool_t eq = svcmpeq_f64_m(pg, svabs_f64(svsub_f64(current_block, first_block)), svdup_gather_indices2_q_f64(pg, &tolerance, 0));\n        if (!svptest_any(svptrue_b64(), eq)) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```c\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (length < block_size || block_size == 0) return false;\n\n    svbool_t pg = svwhilelt_b64(0, length);\n    size_t vl = svcntd();\n    size_t num_blocks = length / block_size;\n\n    // Load the first block\n    svfloat64_t first_block = svld1(pg, vec);\n\n    for (size_t i = 1; i < num_blocks; i++) {\n        svfloat64_t current_block = svld1(pg, vec + i * block_size);\n        svbool_t eq = svcmpeq_f64_m(pg, first_block, current_block);\n        if (!svptest_any(eq)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```c\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (length < block_size || block_size == 0) return false;\n    svbool_t pg = svwhilelt_b64(0, length);\n    size_t vl = svcntd();\n    size_t num_blocks = length / block_size;\n\n    // Load the first block\n    svfloat64_t first_block = svld1(pg, vec);\n\n    for (size_t i = 1; i < num_blocks; i++) {\n        svfloat64_t current_block = svld1(pg, vec + i * block_size);\n        svbool_t eq = svcmpeq_f64_m(pg, svabs_f64(svsub_f64(current_block, first_block)), svdup_gather_indices2_q_f64(pg, &tolerance, 0));\n        if (!svptest_any(svptrue_b64(), eq)) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```c\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    svbool_t pg = svwhilelt_b64(0, rows);\n    while (svptest_any(svptrue_b64(), pg)) {\n        size_t start = svlastcont_b64(pg);\n        size_t end = start + svcntd();\n        svbool_t inner_pg = svwhilelt_b64(start, rows);\n        svfloat64_t sum = svdupq_f64(0.0);\n        for (size_t col = 0; svptest_any(inner_pg); col += svcntd()) {\n            svfloat64_t row_vals = svld1q_f64(matrix + col * cols, inner_pg);\n            sum = svmlaq_f64(sum, row_vals, row_vals);\n            inner_pg = svnextb_b64(inner_pg);\n        }\n        svfloat64_t threshold = svld1_f64(thresholds + start);\n        svbool_t condition = svcmple_f64(sum, svdupq_f64(threshold));\n        svst1_b64(result + start, condition);\n        pg = svnextb_b64(pg);\n    }\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```c\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    svbool_t pg = svwhilelt_b64(0, rows);\n    while (svptest_any(svptrue_b64(), pg)) {\n        size_t start = svlast\u771f_b64(pg);\n        size_t end = rows;\n        if (!svptest_all(svptrue_b64(), pg)) {\n            end = svfirst_false_b64(pg);\n        }\n        for (size_t i = start; i < end; i++) {\n            size_t row_offset = i * cols;\n            svfloat64_t sum_sq = svdup_n_f64(0.0);\n            for (size_t j = 0; j < cols; j += svcntd()) {\n                svfloat64_t val = svld1(pg, &matrix[row_offset + j]);\n                sum_sq = svmla_f64(sum_sq, val, val);\n            }\n            double norm_sq = svaddv_f64(sum_sq);\n            double threshold = thresholds[i];\n            result[i] = (norm_sq > (threshold * threshold));\n        }\n        pg = svnext_pg_b64(pg);\n    }\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```c\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    svbool_t pg = svwhilelt_b64(0, rows);\n    while (svptest_any(svptrue_b64(), pg)) {\n        size_t start = svlast\u771f_b64(pg);\n        size_t end = rows;\n        if (!svptest_all(svptrue_b64(), pg)) {\n            end = svfirst_false_b64(pg);\n        }\n        for (size_t i = start; i < end; i++) {\n            size_t row_offset = i * cols;\n            svfloat64_t sum_sq = svdup_n_f64(0.0);\n            for (size_t j = 0; j < cols; j += svcntd()) {\n                svfloat64_t val = svld1_gather_index_f64(matrix, row_offset + j);\n                sum_sq = svmla_f64(sum_sq, val, val);\n            }\n            double norm_sq = svgetlane_f64(svaddv_f64(sum_sq), 0);\n            double threshold = thresholds[i];\n            result[i] = (norm_sq > (threshold * threshold));\n        }\n        pg = svnext_b64(pg);\n    }\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```c\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    svbool_t pg = svwhilelt_b64(0, rows);\n    while (svptest_any(svptrue_b64(), pg)) {\n        size_t start = svfirst_b64(pg);\n        size_t end = svlast_b64(pg);\n        svfloat64_t sum = svdupq_f64(0.0);\n        for (size_t col = 0; col < cols; col++) {\n            svfloat64_t val = svld1q_f64(matrix + start * cols + col);\n            sum = svmlaq_f64(sum, val, val);\n        }\n        svfloat64_t threshold = svld1_f64(thresholds + start);\n        svbool_t gt = svcmple_f64(sum, svrintmq_f64(svsqrtq_f64(sum)));\n        svst1_b64(result + start, gt);\n        pg = svwhilelt_b64(end + 1, rows);\n    }\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```c\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    svbool_t pg = svwhilelt_b64(0, rows);\n    while (svptest_any(svptrue_b64(), pg)) {\n        size_t start = svfirst_b64(pg);\n        size_t end = svlast_b64(pg);\n        svfloat64_t sum = svdupq_f64(0.0);\n        for (size_t col = 0; col < cols; col++) {\n            svfloat64_t val = svld1q_f64(matrix + start * cols + col);\n            sum = svmlaq_f64(sum, val, val);\n        }\n        svfloat64_t threshold = svld1q_f64(thresholds + start);\n        svbool_t gt = svcmple_f64(sum, svrintasq_f64(svrintmq_f64(threshold)));\n        svst1_b64(result + start, gt);\n        pg = svwhilelt_b64(end + 1, rows);\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t p = svwhilelt_b32(0, length);\n\n    while (svptest_any(svptrue_b32(), p)) {\n        svuint32_t vec_A = svld1_u32(A + i, p);\n        svuint32_t vec_B = svld1_u32(B + i, p);\n        svst1_u32(C + i, svorr_u32(vec_A, vec_B), p);\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i;\n    svbool_t pg = svwhilelt_b32(0, length);\n    for (i = 0; i < length; i += svcntw()) {\n        svuint32_t vec_a = svld1(pg, A + i);\n        svuint32_t vec_b = svld1(pg, B + i);\n        svuint32_t vec_c = svorr_v(vec_a, vec_b, pg);\n        svst1(pg, C + i, vec_c);\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t p = svwhilelt_b32(0, length);\n    \n    while (svptest_any(svptrue_b32(), p)) {\n        svuint32_t vec_A = svld1_u32(A + i, p);\n        svuint32_t vec_B = svld1_u32(B + i, p);\n        svuint32_t vec_C = svorr_u32(vec_A, vec_B);\n        svcadd_u32(C + i, vec_C, p);\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t p = svwhilelt_b32(0, length);\n\n    while (svptest_any(svptrue_b32(), p)) {\n        svuint32_t vec_A = svld1_u32(A + i, p);\n        svuint32_t vec_B = svld1_u32(B + i, p);\n        svst1_u32(C + i, svorr_u32(vec_A, vec_B), p);\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t p = svwhilelt_b32(0, length);\n    \n    while (svptest_any(svptrue_b32(), p)) {\n        svuint32_t vec_A = svld1_u32(A + i, p);\n        svuint32_t vec_B = svld1_u32(B + i, p);\n        svuint32_t vec_C = svorr_u32(vec_A, vec_B);\n        svcadd_u32(C + i, vec_C, p);\n        i += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    svbool_t pg = svwhilelt_b8(0, length);\n    svint16_t sum_of_squares = svdup_n_s16(0);\n    svint16_t sum_of_products = svdup_n_s16(0);\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svint8_t vecA = svld1(pg, A);\n        svint8_t vecB = svld1(pg, B);\n        svint16_t squares = svmla_x_s8(pg, svdup_n_s16(0), vecA, vecA);\n        svint16_t products = svmla_x_s8(pg, svdup_n_s16(0), vecA, vecB);\n        sum_of_squares = svadd_x_s16(pg, sum_of_squares, squares);\n        sum_of_products = svadd_x_s16(pg, sum_of_products, products);\n        A += svcntd();\n        B += svcntd();\n        pg = svwhilelt_b8(A - (const int8_t*)0, length);\n    }\n\n    int64_t total_sum_of_squares = svaddv_s16(sum_of_squares);\n    int64_t total_sum_of_products = svaddv_s16(sum_of_products);\n    return (int64_t)total_sum_of_squares - (int64_t)total_sum_of_products;\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    svbool_t p = svwhilelt_b8(0, length);\n    svint16_t sum_sq = svdup_n_s16(0);\n    svint16_t sum_p = svdup_n_s16(0);\n\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svint8_t a_vec = svld1(p, &A[i]);\n        svint8_t b_vec = svld1(p, &B[i]);\n\n        svint16_t a_sq = svuzp1(svmul_x(a_vec, a_vec), svundef_s16());\n        svint16_t b_sq = svuzp1(svmul_x(b_vec, b_vec), svundef_s16());\n\n        sum_sq = svadd_x(sum_sq, svuzp1(a_sq, b_sq));\n        sum_p = svadd_x(sum_p, svuzp1(svmul_x(a_vec, b_vec), svundef_s16()));\n    }\n\n    int64_t sum_sq_acc = svaddv_s16(sum_sq);\n    int64_t sum_p_acc = svaddv_s16(sum_p);\n\n    return (int64_t)(sum_sq_acc - sum_p_acc);\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    svbool_t pg = svwhilelt_b8(0, length);\n    svint16_t sum_sq = svdup_n_s16(0);\n    svint16_t sum_p = svdup_n_s16(0);\n\n    while (svptest_any(pg)) {\n        svint8_t vec_a = svld1(pg, A);\n        svint8_t vec_b = svld1(pg, B);\n        svint16_t sq_a = svabs_s16(svconvert_s16_s8(vec_a));\n        svint16_t sq_b = svabs_s16(svconvert_s16_s8(vec_b));\n        svint16_t prod = svmla_s16(svdup_n_s16(0), vec_a, vec_b);\n\n        sum_sq = svadd_s16(sum_sq, sq_a);\n        sum_sq = svadd_s16(sum_sq, sq_b);\n        sum_p = svadd_s16(sum_p, prod);\n\n        A += svcntd();\n        B += svcntd();\n        pg = svwhilelt_b8(A - (const int8_t*)0, length);\n    }\n\n    int64_t total_sum_sq = svaddv_s16(sum_sq);\n    int64_t total_sum_p = svaddv_s16(sum_p);\n\n    return (int64_t)(total_sum_sq - total_sum_p);\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    svbool_t p = svwhilelt_b8(0, length);\n    svint16_t sum_sq = svdup_n_s16(0);\n    svint16_t sum_p = svdup_n_s16(0);\n\n    while (svptest_any(svptrue_b8(), p)) {\n        svint8_t vec_a = svld1_u8(A, p);\n        svint8_t vec_b = svld1_u8(B, p);\n\n        svint16_t sq_a = svabs_s16(svconvert_s16_s8(vec_a));\n        svint16_t sq_b = svabs_s16(svconvert_s16_s8(vec_b));\n\n        sum_sq = svadd_s16(sum_sq, sq_a * sq_a + sq_b * sq_b);\n        sum_p = svadd_s16(sum_p, sq_a * sq_b);\n\n        A += svcntd();\n        B += svcntd();\n        p = svwhilelt_b8(A - (const int8_t *)0, length);\n    }\n\n    int64_t total_sum_sq = svaddv_s16(sum_sq);\n    int64_t total_sum_p = svaddv_s16(sum_p);\n\n    return (int64_t)(total_sum_sq - total_sum_p);\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    svbool_t p = svwhilelt_b8(0, length);\n    svint16_t sum_sq = svdup_n_s16(0);\n    svint16_t sum_p = svdup_n_s16(0);\n\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svint8_t a_vec = svld1(p, &A[i]);\n        svint8_t b_vec = svld1(p, &B[i]);\n\n        svint16_t a_sq = svreinterpret_s16_s8(svmla(a_vec, a_vec));\n        svint16_t b_sq = svreinterpret_s16_s8(svmla(b_vec, b_vec));\n        svint16_t ab = svreinterpret_s16_s8(svmul(a_vec, b_vec));\n\n        sum_sq = svadd_s16(sum_sq, svadd_s16(a_sq, b_sq));\n        sum_p = svadd_s16(sum_p, ab);\n    }\n\n    int64_t total_sum_sq = svaddv_s16(sum_sq);\n    int64_t total_sum_p = svaddv_s16(sum_p);\n\n    return total_sum_sq - total_sum_p;\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t p = svwhilelt_b64(0, length);\n\n    while (svptest_any(svptrue_b64(), p)) {\n        svuint64_t a_vec = svld1_u64(A + i, p);\n        svuint64_t b_vec = svld1_u64(B + i, p);\n        svint64_t b_neg_vec = svneg_s64(svtoui64(b_vec));\n        svuint64_t result_vec = svand_u64(a_vec, svuizero_u64(b_neg_vec));\n        svcadd_u64(C + i, result_vec, p);\n        i += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t p = svwhilelt_b64(0, length);\n\n    while (svptest_any(svptrue_b64(), p)) {\n        svuint64_t a_vec = svld1_u64(A + i, p);\n        svuint64_t b_vec = svld1_u64(B + i, p);\n        svuint64_t b_not_vec = svnot_u64(b_vec, p);\n        svst1_u64(C + i, svand_u64(a_vec, b_not_vec, p), p);\n        i += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t p = svwhilelt_b64(0, length);\n\n    while (svptest_any(svptrue_b64(), p)) {\n        svuint64_t a_vec = svld1_u64(A + i, p);\n        svuint64_t b_vec = svld1_u64(B + i, p);\n        svint64_t b_neg_vec = svneg_s64(svtoui64(b_vec));\n        svuint64_t result_vec = svand_u64(a_vec, svuif_u64(b_neg_vec));\n\n        svst1_u64(C + i, result_vec, p);\n        i += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(0, length);\n    \n    while (svptest_any(svptrue_b64(), pg)) {\n        svuint64_t vec_A = svld1(pg, A + i);\n        svuint64_t vec_B = svld1(pg, B + i);\n        svuint64_t vec_not_B = svnot_b64(vec_B);\n        svuint64_t vec_result = svand_b64(vec_A, vec_not_B);\n        \n        svst1(pg, C + i, vec_result);\n        \n        i += svcntd();\n        pg = svwhilelt_b64(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t p = svwhilelt_b64(0, length);\n\n    while (svptest_any(svptrue_b64(), p)) {\n        svuint64_t a_vec = svld1_u64(A + i, p);\n        svuint64_t b_vec = svld1_u64(B + i, p);\n        svuint64_t b_not_vec = svnot_u64(b_vec, p);\n        svst1_u64(C + i, svand_u64(a_vec, b_not_vec, p), p);\n        i += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```c\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    svint8_t *a = (svint8_t*)A;\n    svint8_t *b = (svint8_t*)B;\n    svint8_t *c = (svint8_t*)C;\n\n    size_t i = 0;\n    while (i < length / 16) {\n        svint8_t vec_a = svld1(a + i);\n        svint8_t vec_b = svld1(b + i);\n        \n        svbool_t p_true = svcmpgt(vec_a, svdup_n_s8(0));\n        svbool_t p_false = svcmpeq(vec_a, svdup_n_s8(0));\n        svbool_t n_true = svcmplt(vec_a, svdup_n_s8(0));\n        svbool_t n_false = svcmpeq(vec_a, svdup_n_s8(0));\n\n        svint8_t pos_mask = svcond(p_true, svdup_n_s8(1), svdup_n_s8(0));\n        svint8_t neg_mask = svcond(n_true, svdup_n_s8(-1), svdup_n_s8(0));\n\n        svint8_t vec_c = svselect(svcmpeq(vec_b, svdup_n_s8(0)), svdup_n_s8(0),\n                                 svselect(svcmpeq(vec_b, pos_mask), pos_mask, neg_mask));\n\n        svst1(c + i, vec_c);\n\n        i += 16;\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```c\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    svint8_t *a = (svint8_t*)A;\n    svint8_t *b = (svint8_t*)B;\n    svint8_t *c = (svint8_t*)C;\n\n    size_t i = 0;\n    for (; i <= length - svcntb; i += svcntb) {\n        svint8_t a_vec = svld1(a + i);\n        svint8_t b_vec = svld1(b + i);\n        \n        // Compute masks\n        svbool_t pos_mask = svcmpeq_n_s8(a_vec, 0) & svcmpeq_n_s8(b_vec, 0);\n        svbool_t neg_mask = svcmple_n_s8(a_vec, 0) & svcmple_n_s8(b_vec, 0);\n        \n        // Set values based on masks\n        svint8_t result = svcond(pos_mask, svdup_n_s8(1), \n                                 svcond(neg_mask, svdup_n_s8(-1), svdup_n_s8(0)));\n        \n        svst1(c + i, result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```c\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    svint8_t *a = (svint8_t*)A;\n    svint8_t *b = (svint8_t*)B;\n    svint8_t *c = (svint8_t*)C;\n\n    size_t i = 0;\n    for (; i <= length - svcntb; i += svcntb) {\n        svint8_t a_vec = svld1(a + i);\n        svint8_t b_vec = svld1(b + i);\n        \n        svbool_t mask_pos = svcmpeq_n_s8(a_vec, 0) & svcmpeq_n_s8(b_vec, 0);\n        svint8_t pos_result = svdup_n_s8(1);\n\n        svbool_t mask_neg = svcmple_n_s8(a_vec, 0) & svcmple_n_s8(b_vec, 0);\n        svint8_t neg_result = svdup_n_s8(-1);\n\n        svint8_t result = svsel(mask_pos, pos_result, svsel(mask_neg, neg_result, svdup_n_s8(0)));\n\n        svst1(c + i, result);\n    }\n\n    for (; i < length; i++) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```c\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    svbool_t pg = svwhilelt_b8(0, length);\n    while (svptest_any(svptrue_b8(), pg)) {\n        svint8_t vec_A = svld1(pg, A);\n        svint8_t vec_B = svld1(pg, B);\n        svint8_t vec_C = svcond(svand_x(vec_A, vec_B), \n                                svdup_n_s8(1), \n                                svcmple_x(vec_A, svdup_n_s8(0)), \n                                svcond(svcmple_x(vec_A, svdup_n_s8(0)), \n                                       svcmple_x(vec_B, svdup_n_s8(0)), \n                                       svdup_n_s8(-1), \n                                       svdup_n_s8(0)), \n                                svdup_n_s8(0));\n        svcadd(pg, C, vec_C);\n        A += svcntd();\n        B += svcntd();\n        C += svcntd();\n        pg = svwhilelt_b8(A - (const int8_t*)0, length);\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```c\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    svint8_t *a = (svint8_t*)A;\n    svint8_t *b = (svint8_t*)B;\n    svint8_t *c = (svint8_t*)C;\n\n    size_t i = 0;\n    for (; i <= length - svcntb; i += svcntb) {\n        svint8_t a_vec = svld1(a + i);\n        svint8_t b_vec = svld1(b + i);\n        \n        // Compute masks\n        svbool_t pos_mask = svcmplt_n_s8(a_vec, 0) && svcmplt_n_s8(b_vec, 0); // Both negative\n        svbool_t neg_mask = svcmpgt_n_s8(a_vec, 0) && svcmpgt_n_s8(b_vec, 0); // Both positive\n        \n        // Assign values based on masks\n        svint8_t result = svternary_b(pos_mask, svcvt_s8_n(svptrue_b8()), \n                                      svternary_b(neg_mask, svcvt_s8_n(svnot_b8(svptrue_b8())), \n                                                  svcvt_s8_n(svfalse_b8())));\n        \n        svst1(c + i, result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```c\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t vl = svquery_vl();\n    size_t half = length / 2;\n    svbool_t pg_full = svptrue_b_u16();\n    svbool_t pg_half = svptrue_b_u16();\n    svbool_t pg_before = svptrue_b_u16();\n\n    // Mask for the first half\n    pg_before = svwhilelt_b_u16(svindex_u16(0, 1), svdup_gather_u16(A, svindex_u16(0, half)));\n\n    // Mask for the second half\n    pg_half = svwhilelt_b_u16(svindex_u16(0, half), svdup_gather_u16(A, svindex_u16(0, length)));\n\n    // Process before the midpoint\n    svst1_u16(C, pg_before, svand_u16(svdup_gather_u16(A, svindex_u16(0, half)), svdup_gather_u16(B, svindex_u16(0, half))));\n\n    // Process exactly at the midpoint\n    svst1_u16(C + half, svptrue_b_u16(), svdup_gather_u16(A, svindex_u16(0, half)));\n\n    // Process after the midpoint\n    svst1_u16(C + half + 1, pg_half, svxor_u16(svdup_gather_u16(A, svindex_u16(half + 1, length)), svdup_gather_u16(B, svindex_u16(half + 1, length))));\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```c\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t vl = svquery_vl();\n    size_t midpoint = length / 2;\n    size_t i = 0;\n\n    // Handle first half (before midpoint)\n    for (; i + vl <= midpoint * 2; i += vl) {\n        svbool_t pg = svwhilelt_b16(i, midpoint * 2);\n        svuint16_t a_vec = svld1(pg, A + i);\n        svuint16_t b_vec = svld1(pg, B + i);\n        svst1(pg, C + i, svand_b16(pg, a_vec, b_vec));\n    }\n\n    // Handle exact midpoint\n    if (i < midpoint * 2) {\n        svbool_t pg = svwhilelt_b16(i, midpoint * 2);\n        svuint16_t a_vec = svld1(pg, A + i);\n        svuint16_t b_vec = svld1(pg, B + i);\n        svst1(pg, C + i, svcond_b16(pg, a_vec, b_vec, a_vec));\n        i++;\n    }\n\n    // Handle second half (after midpoint)\n    for (; i + vl <= length; i += vl) {\n        svbool_t pg = svwhilelt_b16(i, length);\n        svuint16_t a_vec = svld1(pg, A + i);\n        svuint16_t b_vec = svld1(pg, B + i);\n        svst1(pg, C + i, svand_b16(pg, a_vec, b_vec));\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        C[i] = (i == midpoint) ? A[i] : (A[i] & B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```c\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t vl = svquery_vl();\n    size_t vector_length = vl / sizeof(uint16_t);\n    size_t midpoint = length / 2;\n\n    for (size_t i = 0; i < length; i += vector_length) {\n        size_t align = i % vector_length;\n        size_t vlen = vector_length - align;\n        if (i + vlen > length) {\n            vlen = length - i;\n        }\n        svbool_t pg = svwhilelt_b16(0, vlen);\n\n        if (i < midpoint) {\n            svuint16_t a_vec = svld1(pg, A + i);\n            svuint16_t b_vec = svld1(pg, B + i);\n            svst1(pg, C + i, svand_b16(pg, a_vec, b_vec));\n        } else if (i == midpoint) {\n            svuint16_t a_vec = svld1(pg, A + i);\n            svst1(pg, C + i, a_vec);\n        } else {\n            svuint16_t a_vec = svld1(pg, A + i);\n            svuint16_t b_vec = svld1(pg, B + i);\n            svst1(pg, C + i, svorr_b16(pg, a_vec, b_vec));\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```c\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t vl = svquery_vl();\n    size_t half = length / 2;\n    svbool_t pg_full = svwhilelt_u32(0, length);\n    svbool_t pg_half = svwhilelt_u32(0, half);\n\n    // Process elements before the midpoint\n    for (size_t i = 0; i < half; i += vl) {\n        svbool_t pg = svwhilelt_b_u32(i, half);\n        svuint16_t a_vec = svld1(pg, A + i);\n        svuint16_t b_vec = svld1(pg, B + i);\n        svuint16_t xor_vec = svbitwise_xor(pg, a_vec, b_vec);\n        svst1(pg, C + i, xor_vec);\n    }\n\n    // Process the midpoint element\n    if (length % 2 == 1) {\n        C[half] = A[half];\n    }\n\n    // Process elements after the midpoint\n    for (size_t i = half + 1; i < length; i += vl) {\n        svbool_t pg = svwhilelt_b_u32(i, length);\n        svuint16_t a_vec = svld1(pg, A + i);\n        svuint16_t b_vec = svld1(pg, B + i);\n        svuint16_t and_vec = svbitwise_and(pg, a_vec, b_vec);\n        svst1(pg, C + i, and_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```c\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t vl = svquery_vl();\n    size_t half = length / 2;\n    size_t i = 0;\n\n    for (; i + vl <= half; i += vl) {\n        svbool_t pg = svwhilelt_b16(i, half);\n        svuint16_t A_vec = svld1(pg, A + i);\n        svuint16_t B_vec = svld1(pg, B + i);\n        svuint16_t xor_vec = svbitwise_xor(A_vec, B_vec);\n        svuint16_t and_vec = svbitwise_and(A_vec, B_vec);\n        svst1(pg, C + i, svselect(pg, xor_vec, and_vec, A_vec));\n    }\n\n    for (; i < half; i++) {\n        C[i] = (i == half - 1) ? A[i] : (A[i] ^ B[i]);\n    }\n\n    for (; i < length; i++) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```c\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vector_length = svcntw(); // Get the vector length for double-word elements\n    size_t i = 0;\n\n    while (i < total_elements) {\n        size_t len = (total_elements - i >= vector_length) ? vector_length : (total_elements - i);\n\n        svbool_t pg = svwhilelt_b64(i, total_elements); // Create a predicate for the current vector length\n\n        svfloat32_t vec_A = svld1(pg, &A[i]);\n        svfloat32_t vec_B = svld1(pg, &B[i]);\n        svfloat32_t vec_C = svld1(pg, &C[i]);\n        svfloat32_t vec_D = svld1(pg, &D[i]);\n\n        svbool_t cond1_vec = svld1_b32(pg, &cond1[i]);\n        svbool_t cond2_vec = svld1_b32(pg, &cond2[i]);\n\n        svfloat32_t result = svsel_b32(cond1_vec, svsel_b32(cond2_vec, vec_A, vec_B), svsel_b32(cond2_vec, vec_C, vec_D));\n\n        svst1(pg, &out[i], result);\n\n        i += len;\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```c\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vector_length = svcntw(); // Get the vector length for double-word elements\n    size_t i = 0;\n\n    while (i < total_elements) {\n        size_t vl = svwhilelt_u32((uint32_t)i, (uint32_t)total_elements);\n        svbool_t pg = svptrue_b32(vl);\n\n        svfloat32_t a_vec = svld1(pg, &A[i]);\n        svfloat32_t b_vec = svld1(pg, &B[i]);\n        svfloat32_t c_vec = svld1(pg, &C[i]);\n        svfloat32_t d_vec = svld1(pg, &D[i]);\n\n        svbool_t cond1_vec = svld1_b32(pg, &cond1[i]);\n        svbool_t cond2_vec = svld1_b32(pg, &cond2[i]);\n\n        svfloat32_t result_vec = svsel(cond1_vec, svsel(cond2_vec, a_vec, b_vec), svsel(cond2_vec, c_vec, d_vec));\n\n        svst1(pg, &out[i], result_vec);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```c\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vector_length = svcntd(); // Number of elements per vector\n    size_t i = 0;\n\n    while (i < total_elements) {\n        size_t len = total_elements - i;\n        if (len >= vector_length) {\n            svbool_t pg = svwhilelt_b32(0, len);\n            svfloat32_t vec_A = svld1(pg, &A[i]);\n            svfloat32_t vec_B = svld1(pg, &B[i]);\n            svfloat32_t vec_C = svld1(pg, &C[i]);\n            svfloat32_t vec_D = svld1(pg, &D[i]);\n            svbool_t pg_cond1 = svindex_b32(0, i);\n            svbool_t pg_cond2 = svindex_b32(0, i);\n\n            svfloat32_t result = svsel_b32(\n                svand_b32(pg_cond1, pg_cond2),\n                vec_A,\n                svsel_b32(\n                    svand_b32(pg_cond1, svnot_b32(pg_cond2)),\n                    vec_B,\n                    svsel_b32(\n                        svand_b32(svnot_b32(pg_cond1), pg_cond2),\n                        vec_C,\n                        vec_D\n                    )\n                )\n            );\n\n            svst1(pg, &out[i], result);\n            i += vector_length;\n        } else {\n            // Handle remaining elements\n            for (size_t j = 0; j < len; j++) {\n                if (cond1[i + j] && cond2[i + j]) {\n                    out[i + j] = A[i + j];\n                } else if (cond1[i + j] && !cond2[i + j]) {\n                    out[i + j] = B[i + j];\n                } else if (!cond1[i + j] && cond2[i + j]) {\n                    out[i + j] = C[i + j];\n                } else {\n                    out[i + j] = D[i + j];\n                }\n            }\n            break;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```c\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vector_length = svcntd(); // Determine the vector length\n    size_t i = 0;\n\n    while (i < total_elements) {\n        size_t vl = svwhilelt_u32((uint32_t)i, (uint32_t)total_elements);\n        svbool_t pg = svptrue_b32(vl);\n\n        svfloat32_t vec_A = svld1(pg, &A[i]);\n        svfloat32_t vec_B = svld1(pg, &B[i]);\n        svfloat32_t vec_C = svld1(pg, &C[i]);\n        svfloat32_t vec_D = svld1(pg, &D[i]);\n\n        svbool_t vec_cond1 = svld1_b32(&cond1[i]);\n        svbool_t vec_cond2 = svld1_b32(&cond2[i]);\n\n        svfloat32_t result = svsel_b32(vec_cond1, vec_cond2, vec_A, svsel_b32(vec_cond1, svnot_b32(vec_cond2), vec_B, svsel_b32(svnot_b32(vec_cond1), vec_cond2, vec_C, vec_D)));\n\n        svst1(pg, &out[i], result);\n\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```c\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vector_length = svcntd(); // Number of elements per vector\n    size_t i = 0;\n\n    while (i < total_elements) {\n        size_t len = total_elements - i;\n        if (len >= vector_length) {\n            svbool_t pg = svwhilelt_b32(0, len);\n\n            svfloat32_t vec_A = svld1(pg, &A[i]);\n            svfloat32_t vec_B = svld1(pg, &B[i]);\n            svfloat32_t vec_C = svld1(pg, &C[i]);\n            svfloat32_t vec_D = svld1(pg, &D[i]);\n\n            svbool_t vec_cond1 = svld1_b32(pg, &cond1[i]);\n            svbool_t vec_cond2 = svld1_b32(pg, &cond2[i]);\n\n            svfloat32_t vec_out = svsel_b32(vec_cond1, vec_A, vec_B);\n            vec_out = svsel_b32(svand_b32(vec_cond1, svnot_b32(vec_cond2)), vec_C, vec_out);\n            vec_out = svsel_b32(svand_b32(svnot_b32(vec_cond1), vec_cond2), vec_D, vec_out);\n\n            svst1(pg, &out[i], vec_out);\n            i += vector_length;\n        } else {\n            // Handle remaining elements\n            for (size_t j = 0; j < len; j++) {\n                if (cond1[i + j] && cond2[i + j]) {\n                    out[i + j] = A[i + j];\n                } else if (cond1[i + j] && !cond2[i + j]) {\n                    out[i + j] = B[i + j];\n                } else if (!cond1[i + j] && cond2[i + j]) {\n                    out[i + j] = C[i + j];\n                } else {\n                    out[i + j] = D[i + j];\n                }\n            }\n            break;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t i, j, k;\n    size_t nelts = dim1 * dim2 * dim3;\n    svbool_t pg = svwhilelt_b32(0, nelts);\n\n    for (i = 0; svptest_any(pg); i += svcntw()) {\n        svbool_t p = svwhilelt_b32(i, nelts);\n        svuint32_t vec_a = svld1_u32(A + i, p);\n        svint32_t vec_count = svcntp_u32(vec_a, p);\n        svst1_u8(out + i, svuqadd_b32(vec_count, p));\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t i, j, k;\n    size_t nelts = dim1 * dim2 * dim3;\n    svbool_t pg = svwhilelt_b32(0, nelts);\n\n    for (i = 0; svptest_any(pg); i += svcntw()) {\n        svbool_t p = svwhilelt_b32(i, nelts);\n        svuint32_t vec_in = svld1_u32(A + i, p);\n        svint32_t vec_bits = svcntp_u32(vec_in);\n        svuint8_t vec_out = svreinterpret_u8_u32(vec_bits);\n        svst1_u8(out + i, p, vec_out);\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t i, j, k;\n    size_t nelts = dim1 * dim2 * dim3;\n    svbool_t pg = svwhilelt_b32(0, nelts);\n\n    for (i = 0; svptest_any(pg); i += svcntw()) {\n        svuint32_t vec_a = svld1_u32(A + i, pg);\n        svint32_t vec_count = svcntp_u32(vec_a);\n        svst1_u8(out + i, svreinterpret_u8_s8(svshll_n_s8(vec_count, 0)), pg);\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t i, j, k;\n    size_t nelts = dim1 * dim2 * dim3;\n    svbool_t pg = svwhilelt_b32(0, nelts);\n\n    for (i = 0; svptest_any(pg); i += svcntw()) {\n        svbool_t p = svwhilelt_b32(i, nelts);\n        svuint32_t vec_in = svld1_u32(A + i, p);\n        svint32_t vec_bits = svcntp_b32(p);\n        svbool_t mask = svcmpeq_u32(vec_in, svcreate_u32(0, p));\n        svuint32_t bit_counts = svcntp_u32(svcmpeq_u32(vec_in, svcreate_u32(0, p)));\n        svst1_u8(out + i, svuzp1_u8(svuzp2_u8(bit_counts, svcreate_u8(0, p)), svcreate_u8(0, p)), p);\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t i, j, k;\n    size_t nelts = dim1 * dim2 * dim3;\n    svbool_t pg = svwhilelt_b32(0, nelts);\n\n    for (i = 0; svptest_any(pg); i += svcntw()) {\n        svbool_t p = svwhilelt_b32(i, nelts);\n        svuint32_t vec_a = svld1_u32(A + i, p);\n        svint32_t vec_count = svcntp_u32(vec_a, p);\n        svst1_u8(out + i, svuqadd_b32(vec_count, p));\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```c\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t elements_per_vector = svcntw();\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    while (i < total_elements) {\n        size_t vector_length = (total_elements - i >= elements_per_vector) ? elements_per_vector : total_elements - i;\n        svint32_t vec_a = svld1((const int8_t *)(&A[i]));\n        svbool_t pg = svwhilelt_b32(0, vector_length);\n\n        svint32_t vec_b = svabs_b32(pg, svcmpne_b32(svmod_b32(vec_a, svcreate_b32(3)), svdup_b32(0)), vec_a);\n\n        svst1((int8_t *)(&B[i]), vec_b);\n        i += vector_length;\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```c\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t elements_per_vector = svcntw();\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    while (i < total_elements) {\n        size_t vector_length = (total_elements - i >= elements_per_vector) ? elements_per_vector : total_elements - i;\n        svint32_t vec_a = svld1((const int8_t *)(&A[i]));\n        svbool_t pg = svwhilelt_b32(0, vector_length);\n\n        svint32_t vec_b = svabs_b32(pg, svcmpne_b32(pg, svmod_n_s32(pg, vec_a, 3), svdup_n_s32(0)), vec_a);\n\n        svst1((int8_t *)(&B[i]), vec_b);\n        i += vector_length;\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```c\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t elements_per_block = svcntw(); // Number of elements per vector\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    while (i < total_elements) {\n        size_t block_size = (total_elements - i >= elements_per_block) ? elements_per_block : total_elements - i;\n        svint32_t vec_A = svld1((const int8_t *)(&A[i]));\n        svbool_t pg = svwhilelt_b32(0, block_size);\n\n        svint32_t vec_B = svabs_b32(pg, svcmpne_b32(svmod_n_s32(vec_A, 3), svdup_n_s32(0)), vec_A);\n\n        svst1((int8_t *)(&B[i]), vec_B);\n        i += block_size;\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```c\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t elements_per_block = svcntw(); // Number of elements per vector\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    while (i < total_elements) {\n        size_t block_size = (total_elements - i >= elements_per_block) ? elements_per_block : total_elements - i;\n        svint32_t vec_a = svld1_s32(A + i);\n        svbool_t pg = svwhilelt_b32(i, block_size);\n        \n        svint32_t vec_abs = svabs_s32(vec_a); // Compute absolute values\n        svint32_t vec_result = svsel_b32(pg, vec_abs, vec_a); // Select based on condition\n        \n        svst1_s32(B + i, vec_result);\n        \n        i += block_size;\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```c\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t elements_per_vector = svcntw();\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    while (i < total_elements) {\n        size_t vector_length = (total_elements - i >= elements_per_vector) ? elements_per_vector : total_elements - i;\n        svint32_t vec_a = svld1((const int8_t *)(&A[i]));\n        svbool_t pg = svwhilelt_b32(0, vector_length);\n\n        svint32_t vec_b = svabs_b32(pg, svcmpne_b32(pg, svmod_b32(pg, vec_a, svcreate_h32(3)), svdup_gather_index_b32(pg, 0)));\n        svst1((int8_t *)(&B[i]), vec_b);\n\n        i += vector_length;\n    }\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    svbool_t pg = svwhilelt_b32(0, length);\n    svuint32_t src_vec = svld1(pg, src);\n    svuint32_t mask = svand_n_u32(svlsr_n_u32(src_vec, 1), 0xF);\n    svbool_t cond = smeql_u32(mask, svcreate_u32(0xF));\n    \n    svuint32_t rotated = svror_n_u32(src_vec, rotate_bits);\n    svuint32_t negated = svnot_u32(src_vec);\n    \n    svst1(pg, dst, svselect_b32(cond, rotated, negated));\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    svbool_t pg = svwhilelt_b32(0, length);\n    svuint32_t src_vec = svld1(pg, src);\n    svuint32_t mask = svand_n_u32(svlsr_n_u32(src_vec, 4), svcreate_and_u32(0xF));\n    svbool_t cond = smeql_u32(mask, svcreate_u32(0xF));\n\n    svuint32_t rotated = svror_n_u32(src_vec, rotate_bits);\n    svuint32_t negated = svnot_u32(src_vec);\n\n    svst1_u32(pg, dst, svsel_u32(cond, rotated, negated));\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    svbool_t pg = svwhilelt_b32(0, length);\n    svuint32_t src_vec = svld1(pg, src);\n    svuint32_t mask = svand_n_u32(svlsr_n_u32(src_vec, 1), 0xF);\n    svbool_t cond = smeql_u32(mask, svcreate_u32(0xF));\n    \n    svuint32_t rotated = svror_n_u32(src_vec, rotate_bits);\n    svuint32_t negated = svnot_u32(src_vec);\n    \n    svst1(pg, dst, svselect_b32(cond, rotated, negated));\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    svbool_t pg = svwhilelt_b32(0, length);\n    svuint32_t src_vec = svld1(pg, src);\n    svuint32_t mask = svand_n_u32(svlsr_n_u32(src_vec, 4), svcreate_and_mask_u32(0xF));\n    svbool_t cond = svcmpeq_n_u32(mask, 0xF);\n\n    svuint32_t rotated = svror_n_u32(src_vec, rotate_bits);\n    svuint32_t negated = svnot_u32(src_vec);\n\n    svst1_u32(pg, dst, svselect_u32(cond, rotated, negated));\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    svbool_t pg = svwhilelt_b32(0, length);\n    svuint32_t src_vec = svld1(pg, src);\n    svuint32_t mask = svand_n_u32(svlsr_n_u32(src_vec, 4), svcreate_and_mask_u32(0xF));\n    svbool_t cond = svcmpeq_n_u32(mask, 0xF);\n\n    svuint32_t rotated = svror_n_u32(src_vec, rotate_bits);\n    svuint32_t negated = svnot_u32(src_vec);\n\n    svst1_u32(pg, dst, svselect_u32(cond, rotated, negated));\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```c\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    svfloat32_t veps = svdup_f32(epsilon);\n    svint8_t vzero = svdup_n_s8(0);\n    svint8_t vone = svdup_n_s8(1);\n    svint8_t vnegone = svdup_n_s8(-1);\n\n    while (svptest_any(pg)) {\n        svfloat32_t va = svld1(pg, A);\n        svfloat32_t vb = svld1(pg, B);\n        svfloat32_t diff = svsub_f32(va, vb);\n        svfloat32_t abs_diff = svabs_f32(diff);\n        svbool_t gt_eps = svcmpgt_f32(abs_diff, veps);\n        svbool_t lt_neg_eps = svcmplt_f32(abs_diff, svneg_f32(veps));\n\n        svst1_u8(pg, out, svselect_b8(gt_eps, vone, svselect_b8(lt_neg_eps, vnegone, vzero)));\n\n        A += svcntd();\n        B += svcntd();\n        out += svcntd();\n        pg = svwhilelt_b32(svcntd(), length);\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```c\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    svfloat32_t veps = svdup_f32(epsilon);\n    svint8_t vzero = svdup_n_s8(0);\n    \n    while (svptest_any(pg)) {\n        svfloat32_t va = svld1(pg, A);\n        svfloat32_t vb = svld1(pg, B);\n        svfloat32_t vdiff = svsub_f32(va, vb);\n        \n        svbool_t gt_mask = svcmpgt_f32(vdiff, svabs_f32(veps));\n        svbool_t lt_mask = svcmplt_f32(vdiff, svneg_f32(svabs_f32(veps)));\n        \n        svint8_t vout_gt = svptrue_b8();\n        svint8_t vout_lt = svptrue_b8();\n        svint8_t vout_eq = svpfalse_b8();\n        \n        vout_gt = svsel_b8(vout_gt, svdup_n_s8(1), gt_mask);\n        vout_lt = svsel_b8(vout_lt, svdup_n_s8(-1), lt_mask);\n        vout_eq = svsel_b8(vout_eq, vzero, svnot_b32(gt_mask | lt_mask));\n        \n        svst1(pg, out, svadd_s8(vout_gt, svadd_s8(vout_lt, vout_eq)));\n        \n        pg = svwhilelt_b32(svget_lane_u32(svadd_u32(svindex_u32(), svdup_u32(sveilsl_n_u32(1, 1))), 0), length);\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```c\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    svfloat32_t veps = svdup_f32(epsilon);\n    svint8_t vout = svdup_n_s8(0);\n\n    while (svptest_any(pg)) {\n        svfloat32_t va = svld1(pg, A);\n        svfloat32_t vb = svld1(pg, B);\n        svfloat32_t diff = svsub_f32(va, vb);\n        svfloat32_t abs_diff = svabs_f32(diff);\n        svfloat32_t cmp_gt = svcmpgt_f32(abs_diff, veps);\n        svfloat32_t cmp_lt = svcmplt_f32(abs_diff, veps);\n\n        svint8_t vout_gt = svptrue_b8();\n        svint8_t vout_lt = svneg_b8(svptrue_b8());\n        svint8_t vout_eq = svcmpeq_b8(vout_gt, vout_gt);\n\n        vout_gt = svsel_b8(cmp_gt, vout_gt, vout_eq);\n        vout_lt = svsel_b8(cmp_lt, vout_lt, vout_eq);\n\n        vout = svsel_b8(cmp_gt, vout_gt, vout);\n        vout = svsel_b8(cmp_lt, vout_lt, vout);\n\n        svst1(pg, out, vout);\n        A += svcntd();\n        B += svcntd();\n        out += svcntd();\n        pg = svwhilelt_b32((int32_t)(A - (const float*)0), length);\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```c\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    svfloat32_t veps = svdup_f32(epsilon);\n    svfloat32_t veps_abs = svabs_f32(veps);\n    while (svptest_any(pg)) {\n        svint8_t result = svcmple_f32(pg, svsub_f32(svld1_f32(A, pg), svld1_f32(B, pg)), veps_abs);\n        svst1_u8(out, pg, svselect_b8(result, svptrue_b8(), svreinterpret_s8_u8(svptrue_b8())));\n        pg = svwhilelt_b32(svget_lane_u32(svadd_u32(svindex_u32(), svcnt_u32()), 0), length);\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```c\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    svfloat32_t veps = svdup_f32(epsilon);\n    svint8_t vzero = svdup_n_s8(0);\n    svint8_t vone = svdup_n_s8(1);\n    svint8_t vnegone = svdup_n_s8(-1);\n\n    while (svptest_any(pg)) {\n        svfloat32_t va = svld1(pg, A);\n        svfloat32_t vb = svld1(pg, B);\n        svfloat32_t diff = svsub_f32(va, vb);\n        svfloat32_t abs_diff = svabs_f32(diff);\n        svfloat32_t cmp_gt = svcmpgt_f32(abs_diff, veps);\n        svfloat32_t cmp_lt = svcmplt_f32(abs_diff, veps);\n\n        svint8_t vout = svselect_b8(cmp_gt, vone, svselect_b8(cmp_lt, vzero, vnegone));\n        svst1_b8(pg, out, vout);\n\n        A += svcntd();\n        B += svcntd();\n        out += svcntd();\n        pg = svwhilelt_b32(svcntd(), length);\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    svbool_t pg = svwhilelt_b32(0, size);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vec_a = svld1(pg, A);\n        svint32_t vec_max = svdup_n_s32(INT32_MAX);\n        svint32_t vec_min = svdup_n_s32(INT32_MIN);\n        svint32_t vec_b = svmin_s32(svmax_s32(svcvtf2int_s32(vec_a, svround_default), vec_min), vec_max);\n        svst1(pg, B, vec_b);\n        A += svcntd();\n        B += svcntd();\n        pg = svwhilelt_b32(A - (const float*)0, size);\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    svbool_t pg = svwhilelt_b32(0, size);\n    svfloat32_t vec_a;\n    svint32_t vec_b;\n\n    while (svptest_any(pg)) {\n        vec_a = svld1(pg, A);\n        vec_b = svrintn_f32(vec_a); // Round to nearest integer\n        vec_b = svmin_v(vec_b, svdup_n_s32(INT32_MAX), pg); // Clamp to INT32_MAX\n        vec_b = svmax_v(vec_b, svdup_n_s32(INT32_MIN), pg); // Clamp to INT32_MIN\n        svst1(pg, B, vec_b);\n        A += svcntd();\n        B += svcntd();\n        pg = svwhilelt_b32((int32_t)(A - (const float*)0), size);\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    svbool_t pg = svwhilelt_b32(0, size);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vec_a = svld1(pg, A);\n        svint32_t vec_max = svdup_n_s32(INT32_MAX);\n        svint32_t vec_min = svdup_n_s32(INT32_MIN);\n        svint32_t vec_b = svmin_s32(svmax_s32(svcvtf2int_s32(vec_a, svround_default), vec_min), vec_max);\n        svst1(pg, B, vec_b);\n        A += svcntd();\n        B += svcntd();\n        pg = svwhilelt_b32(svcntd(), size);\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    svbool_t pg = svwhilelt_b32(0, size);\n    svfloat32_t vec_a;\n    svint32_t vec_b_max = svindex_u32(0, INT32_MAX);\n    svint32_t vec_b_min = svindex_u32(0, INT32_MIN);\n\n    while (svptest_any(pg)) {\n        vec_a = svld1(pg, A);\n        vec_b_max = svmin_v(vec_a, vec_b_max, pg);\n        vec_b_min = svmax_v(vec_a, vec_b_min, pg);\n        svst1(pg, B, svcvtf2int(vec_b_max, svround_default));\n        A += svcntd();\n        B += svcntd();\n        pg = svwhilelt_b32(svcntd(), size);\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    svbool_t pg = svwhilelt_b32(0, size);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vec_a = svld1(pg, A);\n        svint32_t vec_max = svdup_n_s32(INT32_MAX);\n        svint32_t vec_min = svdup_n_s32(INT32_MIN);\n        svint32_t vec_b = svmin_s32(svmax_s32(svcvtf2int_s32(vec_a, svround_default), vec_min), vec_max);\n        svst1(pg, B, vec_b);\n        A += svcntd();\n        B += svcntd();\n        pg = svwhilelt_b32(A - (const float*)0, size);\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t vector_count = size / svcntw();\n    size_t residual = size % svcntw();\n\n    for (size_t i = 0; i < vector_count; i++) {\n        svfloat32_t scale_vec = svdup_n_f32(scale);\n        svint32_t input_vec = svld1(A + i * svcntw());\n        svfloat32_t result_vec = svcvtf_s32_f32(input_vec);\n        result_vec = svmla_f32(result_vec, scale_vec, result_vec);\n        svst1(B + i * svcntw(), result_vec);\n    }\n\n    if (residual) {\n        svfloat32_t scale_vec = svdup_n_f32(scale);\n        svint32_t input_vec = svld1_gather_offset(A, svcntw() - residual);\n        svfloat32_t result_vec = svcvtf_s32_f32(input_vec);\n        result_vec = svmla_f32(result_vec, scale_vec, result_vec);\n        svst1_scatter_offset(B, svcntw() - residual, result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t vector_length = svcntw(); // Determine the vector length\n    svfloat32_t scale_factor = svdup_n_f32((float)(1 << scale)); // Create a vector of scale factors\n\n    for (size_t i = 0; i < size; i += vector_length) {\n        size_t elements = (size - i) >= vector_length ? vector_length : (size - i); // Handle last incomplete vector\n        svint32_t vec_A = svld1_s32(A + i); // Load integers from A\n        svfloat32_t vec_B = svcvtf_s32_f32(vec_A); // Convert integers to floats\n        vec_B = svmla_f32(vec_B, scale_factor, svdup_n_f32(0.0f)); // Scale the floats\n        svst1_f32(B + i, vec_B); // Store the scaled floats into B\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t vector_length = svcntw(); // Determine the vector length\n    svfloat32_t scale_factor = svdup_n_f32(scale); // Duplicate the scale factor into a vector\n\n    for (size_t i = 0; i < size; i += vector_length) {\n        svint32_t vec_A = svld1_u({A + i}); // Load vector from A\n        svfloat32_t vec_B = svcvtf_s32(vec_A); // Convert int32_t to float32_t\n        vec_B = svmla_f32(vec_B, scale_factor, vec_B); // Scale the values\n        svst1_f32({B + i}, vec_B); // Store the result back to B\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t vector_count = size / svcntw();\n    size_t residual = size % svcntw();\n\n    for (size_t i = 0; i < vector_count; i++) {\n        svfloat32_t scale_vec = svdup_n_f32(scale);\n        svint32_t a_vec = svld1(A + i * svcntw());\n        svfloat32_t b_vec = svcvtf_s32_f32(a_vec);\n        b_vec = svmla_f32(b_vec, scale_vec, b_vec);\n        svst1(B + i * svcntw(), b_vec);\n    }\n\n    if (residual) {\n        svfloat32_t scale_vec = svdup_n_f32(scale);\n        svint32_t a_vec = svld1_gather_offset(A, svseqd_n_u32(0, svcntw()));\n        svfloat32_t b_vec = svcvtf_s32_f32(a_vec);\n        b_vec = svmla_f32(b_vec, scale_vec, b_vec);\n        svst1_gather_offset(B, svseqd_n_u32(0, svcntw()), b_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    svbool_t pg = svwhilelt_b32(0, size);\n    while (svptest_any(svptrue_b32(), pg)) {\n        int32_t const *addr_A = A;\n        float *addr_B = B;\n        svint32_t vec_A = svld1(pg, addr_A);\n        svfloat32_t vec_B = svcvtf_s32_f32(vec_A);\n        svint32_t scale_vec = svdup_n_s32(scale);\n        svfloat32_t scaled_vec_B = svmla_f32(svdup_n_f32(1.0f), vec_B, svcast_f32_s32(svshl_s32(vec_A, scale_vec)));\n        svst1(pg, addr_B, scaled_vec_B);\n        A += svcntd();\n        B += svcntd();\n        pg = svwhilelt_b32(A - (const int32_t*)0, size);\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    svbool_t p = svwhilelt_b32(0, size);\n\n    while (svptest_any(svptrue_b32(), p)) {\n        svfloat32_t vecA = svld1(p, A + i);\n        svfloat32_t vecB = svld1(p, B + i);\n        svfloat32_t vecDiv = svdiv_f32(vecA, vecB);\n        svnrintq_s32(vecDiv, p);\n        svst1(p, C + i, svnrintq_s32(vecDiv, p));\n        i += svcntd();\n        p = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    svbool_t p = svwhilelt_b32(0, size);\n\n    while (svptest_any(svptrue_b32(), p)) {\n        svfloat32_t vecA = svld1(p, A + i);\n        svfloat32_t vecB = svld1(p, B + i);\n        svfloat32_t vecDiv = svdiv_f32(vecA, vecB);\n        svnrint32_t vecRounded = svnrint_n_f32(vecDiv);\n        svint32_t vecC = svnarrow_n_s64(svcast_s64_f64(vecRounded), 0);\n        svst1(p, C + i, vecC);\n        i += svcntd();\n        p = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    svbool_t p = svwhilelt_b32(0, size);\n\n    while (svptest_any(svptrue_b32(), p)) {\n        svfloat32_t vecA = svld1_f32(A + i, p);\n        svfloat32_t vecB = svld1_f32(B + i, p);\n\n        // Perform division\n        svfloat32_t vecDiv = svdiv_f32(vecA, vecB);\n\n        // Convert to int32_t and round\n        svint32_t vecResult = svround_n_f32(vecDiv);\n\n        // Store the result\n        svst1_s32(C + i, p, vecResult);\n\n        // Update the pointer and predicate\n        i += svcntd();\n        p = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    svbool_t p = svwhilelt_b32(0, size);\n\n    while (svptest_any(svptrue_b32(), p)) {\n        svfloat32_t vecA = svld1(p, A + i);\n        svfloat32_t vecB = svld1(p, B + i);\n        svfloat32_t vecDiv = svdiv_f32(vecA, vecB);\n        svnrint32_t vecRounded = svnrint_n32(vecDiv);\n        svst1(p, C + i, vecRounded);\n        i += svcntd();\n        p = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    svbool_t p = svwhilelt_b32(0, size);\n\n    while (svptest_any(svptrue_b32(), p)) {\n        svfloat32_t vecA = svld1_f32(A + i, p);\n        svfloat32_t vecB = svld1_f32(B + i, p);\n\n        // Perform division\n        svfloat32_t vecDiv = svdiv_f32(vecA, vecB);\n\n        // Convert to int32_t and round to nearest integer\n        svint32_t vecResult = svround_f32(vecDiv);\n\n        // Store the result\n        svst1_s32(C + i, p, vecResult);\n\n        // Update the pointer and predicate\n        i += svcntw();\n        p = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    while (i + svcntd() <= size) {\n        svfloat32_t saturated;\n        svfloat64_t vec = svld1q(A + i);\n        svbool_t pg = svwhilelt_b64(i, size);\n        saturated = svcvta_f32_f64(pg, vec);\n        saturated = svminv_f32(pg, saturated, svdup_n_f32(FLT_MAX));\n        saturated = svmaxv_f32(pg, saturated, svdup_n_f32(-FLT_MAX));\n        svcvt_st_f32(B + i, pg, saturated);\n        i += svcntd();\n    }\n    // Handle remaining elements\n    while (i < size) {\n        if (A[i] > (double)FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -(double)FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n        i++;\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    while (i + svcntd() <= size) {\n        svfloat32_t saturated;\n        svdouble_t vec = svld1q(A + i);\n        svbool_t pg = svwhilelt_b64(i, size);\n        saturated = svminv_f32(svmaxv_f32(svconvert_f32_f64(vec), svdup_f32(-FLT_MAX)), svdup_f32(FLT_MAX));\n        svst1q(B + i, saturated, pg);\n        i += svcntd();\n    }\n    // Handle remaining elements\n    while (i < size) {\n        double val = A[i];\n        float result = (val > FLT_MAX) ? FLT_MAX : ((val < -FLT_MAX) ? -FLT_MAX : (float)val);\n        B[i] = result;\n        i++;\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    while (i + svcntd() <= size) {\n        svfloat32_t saturated;\n        svdouble_t vec = svld1q(A + i);\n        svbool_t pg = svwhilelt_b64(i, size);\n        saturated = svmaxv_f32(svminv_f32(svconvert_f32_f64(vec), svdup_f32(FLT_MAX)), svdup_f32(-FLT_MAX));\n        svst1q(B + i, saturated, pg);\n        i += svcntd();\n    }\n    // Handle remaining elements\n    while (i < size) {\n        if (A[i] > (double)FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -(double)FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n        i++;\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    while (i + svcntd() <= size) {\n        svfloat32_t saturated;\n        svdouble_t vec = svld1q(A + i);\n        svbool_t pg = svwhilelt_b32(i, size);\n        saturated = svminv_f32(svmaxv_f32(svconvert_f32_f64(vec), svdup_f32(-FLT_MAX)), svdup_f32(FLT_MAX));\n        svst1q(B + i, saturated, pg);\n        i += svcntd();\n    }\n    // Handle remaining elements\n    while (i < size) {\n        if (A[i] > (double)FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -(double)FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n        i++;\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    while (i + svcntd() <= size) {\n        svfloat32_t saturated;\n        svdouble_t vec = svld1q(A + i);\n        svbool_t pg = svwhilelt_b64(i, size);\n        saturated = svcvta_f32_f64(pg, vec);\n        saturated = svminv_f32(pg, saturated, svdup_n_f32(FLT_MAX));\n        saturated = svmaxv_f32(pg, saturated, svdup_n_f32(-FLT_MAX));\n        svst1q(B + i, saturated);\n        i += svcntd();\n    }\n    // Handle remaining elements\n    for (; i < size; i++) {\n        double val = A[i];\n        float result = (val > FLT_MAX) ? FLT_MAX : ((val < -FLT_MAX) ? -FLT_MAX : (float)val);\n        B[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t p = svwhilelt_b32(i, size);\n    while (svptest_any(svptrue_b32(), p)) {\n        int16_t elements[16];\n        svld1_s16(elements, A + i, p);\n        svst1_s32(B + i, svuzp2_s32(svuzp1_s32(svcreate_s16(elements), svcreate_s16(elements))));\n        i += svcntw();\n        p = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t p = svwhilelt_b32(i, size);\n    while (svptest_any(svptrue_b32(), p)) {\n        int16_t elements[16];\n        svld1_s16(elements, A + i, p);\n        svst1_s32(B + i, svuzp2_s32(svuzp1_s32(svuzp1_s16(elements), svuzp2_s16(elements))));\n        i += svcntd();\n        p = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t p = svwhilelt_b32(i, size);\n    while (svptest_any(svptrue_b32(), p)) {\n        int16_t vec_a[16];\n        int32_t vec_b[16];\n        svld1_xn(vec_a, A + i, p);\n        svuzp1_xn(vec_b, svuzp1(svconvert(vec_a), svtrue_h()), p);\n        svst1_xn(B + i, vec_b, p);\n        i += svcntd();\n        p = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t p = svwhilelt_b32(i, size);\n    while (svptest_any(svptrue_b32(), p)) {\n        int16_t elements[16];\n        svld1_s16(elements, A + i);\n        svst1_s32(B + i, svuzp2_s32(svuzp1_s32(svdup_n_s32(0), svld1_s16(elements)),\n                                     svuzp2_s32(svld1_s16(elements), svdup_n_s16(0))));\n        i += svcntd();\n        p = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t p = svwhilelt_b32(i, size);\n    while (svptest_any(svptrue_b32(), p)) {\n        int16_t elements[16];\n        svld1_x(p, elements, A + i);\n        svint16_t vec_a = svld1(p, elements);\n        svint32_t vec_b = svuzp_h2_l(vec_a);\n        svst1(p, B + i, vec_b);\n        i += svcntd();\n        p = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```c\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    svbool_t pg = svwhilelt_b32(0, size);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t A_vec = svld1(pg, A);\n        svint32_t control_vec = svld1(pg, control);\n        svbool_t cond_gt_zero = svcmpgt_b32(control_vec, svdup_n_s32(0));\n        \n        svfloat32_t diff = svsub_f32(A_vec, svdup_n_f32(min_val));\n        svfloat32_t range = svsub_f32(svdup_n_f32(max_val), svdup_n_f32(min_val));\n        svfloat32_t norm = svdiv_f32(diff, range);\n        \n        svfloat32_t zero = svdup_n_f32(0.0f);\n        svfloat32_t one = svdup_n_f32(1.0f);\n        norm = svmin_f32(norm, one);\n        norm = svmax_f32(norm, zero);\n        \n        svfloat32_t A_copy = A_vec;\n        svst1(pg & cond_gt_zero, B, norm);\n        svst1(pg & svnot_b32(cond_gt_zero), B, A_copy);\n        \n        A += svcntd();\n        control += svcntd();\n        B += svcntd();\n        pg = svwhilelt_b32((int32_t)(A - (const float*)0), size);\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```c\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    svbool_t pg = svwhilelt_b32(0, size);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t A_vec = svld1(pg, A);\n        svint32_t control_vec = svld1(pg, control);\n        svbool_t mask = svcmpgt_b32(pg, control_vec, svdup_n_s32(0));\n        \n        svfloat32_t diff = svsub_f32(A_vec, svdup_n_f32(min_val));\n        svfloat32_t range = svsub_f32(svdup_n_f32(max_val), svdup_n_f32(min_val));\n        svfloat32_t norm = svdiv_f32(diff, range);\n        \n        svfloat32_t zero = svdup_n_f32(0.0f);\n        svfloat32_t one = svdup_n_f32(1.0f);\n        norm = svmin_f32(norm, one);\n        norm = svmax_f32(norm, zero);\n        \n        svfloat32_t A_copy = A_vec;\n        svst1(pg, B, svselect_f32(mask, norm, A_copy));\n        \n        A += svcntd();\n        control += svcntd();\n        B += svcntd();\n        pg = svwhilelt_b32(0, size - svcntd());\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```c\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    svbool_t pg = svwhilelt_b32(0, size);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t A_vec = svld1(pg, A);\n        svint32_t control_vec = svld1(pg, control);\n        svbool_t mask = svcmpgt_b32(control_vec, svdup_n_s32(0));\n        \n        svfloat32_t diff = svsub_f32(A_vec, svdup_n_f32(min_val));\n        svfloat32_t range = svsub_f32(svdundup_n_f32(max_val), svdup_n_f32(min_val));\n        svfloat32_t norm = svdiv_f32(diff, range);\n        \n        svfloat32_t zero = svdup_n_f32(0.0f);\n        svfloat32_t one = svdup_n_f32(1.0f);\n        \n        norm = svmin_f32(norm, one);\n        norm = svmax_f32(norm, zero);\n        \n        svfloat32_t A_copy = A_vec;\n        svst1(pg & mask, B, norm);\n        svst1(pg & svnot_b32(mask), B, A_copy);\n        \n        A += svcntd();\n        control += svcntd();\n        B += svcntd();\n        pg = svwhilelt_b32(0, size - svcntd());\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```c\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    svbool_t pg = svwhilelt_b32(0, size);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t A_vec = svld1(pg, A);\n        svint32_t control_vec = svld1(pg, control);\n        svbool_t mask = svcmpgt_b32(pg, control_vec, svdup_n_s32(0));\n        \n        svfloat32_t diff = svsub_f32(A_vec, svdup_n_f32(min_val));\n        svfloat32_t range = svsub_f32(svdup_n_f32(max_val), svdup_n_f32(min_val));\n        svfloat32_t normalized = svdiv_f32(diff, range);\n\n        // Clamp to [0, 1]\n        svfloat32_t clamped = svmax_f32(svmin_f32(normalized, svdup_n_f32(1.0f)), svdup_n_f32(0.0f));\n\n        // Conditional copy\n        svst1_f32(pg, B, svsel_f32(mask, clamped, A_vec));\n\n        A += svcntd();\n        control += svcntd();\n        B += svcntd();\n        pg = svwhilelt_b32(0, size - svcntd());\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```c\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    svbool_t pg = svwhilelt_b32(0, size);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t A_vec = svld1(pg, A);\n        svint32_t control_vec = svld1(pg, control);\n        svbool_t cond_gt0 = svcmpgt_b32(control_vec, svdup_n_s32(0));\n        \n        svfloat32_t diff = svsub_f32(A_vec, svdup_n_f32(min_val));\n        svfloat32_t range = svsub_f32(svdup_n_f32(max_val), svdup_n_f32(min_val));\n        svfloat32_t norm = svdiv_f32(diff, range);\n        \n        svfloat32_t zero = svdup_n_f32(0.0f);\n        svfloat32_t one = svdup_n_f32(1.0f);\n        \n        norm = svmin_f32(norm, one);\n        norm = svmax_f32(norm, zero);\n        \n        svfloat32_t A_copy = A_vec;\n        svst1(pg & cond_gt0, B, norm);\n        svst1(pg & svnot_b32(cond_gt0), B, A_copy);\n        \n        A += svcntd();\n        control += svcntd();\n        B += svcntd();\n        pg = svwhilelt_b32(0, size - (svcntd() * svcntd()));\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    svbool_t pg = svwhilelt_b32(0, size);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t res = svsqrt_f32(svuzp_h_u32(A, pg));\n        svst1_f32(B, pg, res);\n        A += svcntw();\n        B += svcntw();\n        pg = svwhilelt_b32(svcntw(), size);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t p = svwhilelt_b32(0, size);\n\n    while (svptest_any(svptrue_b32(), p)) {\n        svfloat32_t values = svreinterpret_s32_f32(svshr_n_u32(svld1_u32(A + i), 16));\n        svst1_f32(B + i, svsqrt_f32(values));\n        i += svcntd();\n        p = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t p = svwhilelt_b32(0, size);\n\n    while (svptest_any(svptrue_b32(), p)) {\n        svfloat32_t values = svreinterpret_f32_u32(svshr_n_u32(svld1_u32(p, A), 16));\n        svst1_f32(p, B, svsqrt_f32(values));\n        A += svcntd();\n        B += svcntd();\n        p = svwhilelt_b32(svcntd() * i++, size);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    svbool_t pg = svwhilelt_b32(0, size);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t values = svreinterpret_f32_u32(svshr_n_u32(svld1(pg, A), 16));\n        svst1_f32(pg, B, svsqrt_f32(values));\n        A += svcntd();\n        B += svcntd();\n        pg = svwhilelt_b32(svcntd(), size);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    svbool_t pg = svwhilelt_b32(0, size);\n    svfloat32_t res;\n\n    while (svptest_any(pg)) {\n        svuint32_t vec_a = svld1_u32(A, pg);\n        svint32_t vec_a_shifted = svshr_n_s32(svreinterpret_s32_u32(vec_a), 16);\n        res = svsqrt_f32(svcast_f32_s32(vec_a_shifted));\n        svst1_f32(B, pg, res);\n        A += svcntd();\n        B += svcntd();\n        pg = svwhilelt_b32((uintptr_t)A, size);\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t p = svwhilelt_b32(0, size);\n\n    while (svptest_any(svptrue_b32(), p)) {\n        svfloat32_t vec_B = svreinterpret_s32_f32(svld1_s32(p, A + i));\n        svst1_f32(p, B + i, vec_B);\n        i += svcntd();\n        p = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    svbool_t pg = svwhilelt_b32(0, size);\n    for (i = 0; pg; i += svcntw(), pg = svwhilelt_b32(i, size)) {\n        svfloat32_t vec_B = svreinterpret_s32_f32(svld1(pg, A + i));\n        svst1(pg, B + i, vec_B);\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t p = svwhilelt_b32(0, size);\n\n    while (svptest_any(svptrue_b32(), p)) {\n        svfloat32_t v_B = svld1_u32(p, A);\n        svst1_f32(p, B, v_B);\n        A += svcntd();\n        B += svcntd();\n        p = svwhilelt_b32(svcntd() + i, size);\n        i += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    svbool_t pg = svwhilelt_b32(0, size);\n\n    for (i = 0; pg; pg = svwhilelt_b32(i, size)) {\n        svfloat32_t vec_B = svreinterpret_s32_f32(svld1(pg, A + i));\n        svst1(pg, B + i, vec_B);\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t p = svwhilelt_b32(0, size);\n\n    while (svptest_any(svptrue_b32(), p)) {\n        svfloat32_t vec_B = svreinterpret_s32_f32(svld1_s32(p, A + i));\n        svst1_f32(p, B + i, vec_B);\n        i += svcntd();\n        p = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    svbool_t pg = svwhilelt_b32(0, size);\n    size_t i = 0;\n\n    // Initialize diff[0] to 0.0f\n    diff[0] = 0.0f;\n\n    while (svptest_any_b32(pg)) {\n        svint32_t prev = svld1(pg, A + i);\n        svint32_t curr = svld1(pg, A + i + 1);\n        svbool_t mask = svcmpne_b32(pg, svindex_b32(i + 1), svindex_b32(i));\n        mask = svand_b32(mask, svld1_b8(pg, cond + i + 1));\n\n        svint32_t diff_vec = svsub_x(pg, curr, prev, svdup_n_s32(0));\n        svfloat32_t result = svcvtf_x(pg, diff_vec, svdup_n_s32(0));\n\n        svst1_f32(pg, diff + i + 1, result);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    svbool_t pg = svwhilelt_b32(0, size);\n    size_t i = 0;\n\n    // Initialize diff[0] to 0.0f\n    diff[0] = 0.0f;\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t prev = svld1(pg, A + i);\n        svint32_t curr = svld1(pg, A + i + 1);\n        svbool_t mask = svcmpne_b32(pg, svindex_b32(i + 1), svindex_b32(i));\n        svbool_t cond_mask = svld1_b8(pg, cond + i + 1);\n\n        // Compute difference only where cond is true\n        svint32_t diff_vec = svsub_x(pg, curr, prev, svternary_b32(cond_mask, mask, svdup_n_s32(0)));\n\n        // Convert to float and store in diff\n        svfloat32_t diff_float = svreinterpret_f32_s32(diff_vec);\n        svst1_f32(pg, diff + i + 1, diff_float);\n\n        // Update predicate for next iteration\n        pg = svwhilelt_b32(i + svundef_u32(), size);\n        i += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    svbool_t pg = svwhilelt_b32(0, size);\n    size_t i = 0;\n\n    // Initialize diff[0] to 0.0f\n    diff[0] = 0.0f;\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec_A = svld1(pg, &A[i]);\n        svbool_t vec_cond = svld1_b32(pg, &cond[i]);\n        svint32_t prev_vec_A = svld1(pg, &A[i - 1]);\n\n        svint32_t diff_vec = svsub_x(vec_A, prev_vec_A, svindex_b32(pg, 0));\n        svfloat32_t diff_float_vec = svcvtf_s32_f32(diff_vec);\n\n        svbool_t zero_mask = svnot_b32(vec_cond);\n        svfloat32_t zero_vec = svdup_n_f32(0.0f);\n        diff_float_vec = svsel(zero_vec, diff_float_vec, zero_mask);\n\n        svst1_f32(pg, &diff[i], diff_float_vec);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    svbool_t pg = svwhilelt_b32(0, size);\n    size_t i = 0;\n\n    // Initialize diff[0] to 0.0f\n    diff[0] = 0.0f;\n\n    while (svptest_any_b32(pg)) {\n        svint32_t prev = svld1(pg, A + i);\n        svint32_t curr = svld1(pg, A + i + 1);\n        svbool_t mask = svcmpne_b32(pg, svindex_b32(i + 1), svindex_b32(i));\n        mask = svand_b32(mask, svld1_b32(pg, cond + i + 1));\n\n        svint32_t diff_vec = svsub_x(pg, curr, prev, svdup_n_s32(0));\n        svfloat32_t diff_f = svcvtf32_s32(pg, diff_vec);\n\n        svst1(pg, diff + i + 1, svselect_b32(pg, diff_f, svdup_n_f32(0.0f), mask));\n\n        i += svcntd();\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    svbool_t pg = svwhilelt_b32(0, size);\n    size_t i = 0;\n\n    // Initialize diff[0] to 0.0f\n    diff[0] = 0.0f;\n    i += 1;\n    pg = svptrue_b32();\n    pg = svwhilelt_b32(i, size);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load vectors\n        svint32_t vec_A = svld1(pg, &A[i]);\n        svbool_t vec_cond = svld1_b32(pg, &cond[i]);\n        svint32_t vec_prev = svld1(pg, &A[i - 1]);\n\n        // Compute differences where cond is true\n        svint32_t vec_diff = svsub_x(vec_A, vec_prev, svternary_b32(vec_cond, svtrue_b32(), svdup_n_s32(0)));\n\n        // Convert to float and store\n        svfloat32_t vec_float_diff = svcvtf_s32_f32(vec_diff);\n        svst1(pg, &diff[i], vec_float_diff);\n\n        // Update indices and predicate\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t p = svwhilelt_b64(0, length);\n    while (svptest_any(svptrue_b64(), p)) {\n        svuint32_t vec_src = svld1_u32(src + i, p);\n        svuint64_t vec_dst = svuzp_hilo_u32(vec_src, svdup_n_u32(0xFFFFFFFF));\n        svst1_u64(dst + i, vec_dst, p);\n        i += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t p = svwhilelt_b64(0, length);\n    while (svptest_any(svptrue_b64(), p)) {\n        svuint64_t values = svuzp1_u32(svld1_u32(&src[i], p));\n        svst1_u64(&dst[i], svorr_u64(values, svcreate_u64(~0ULL << 32), p));\n        i += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t vector_length = svcntd(); // Number of elements per vector\n    size_t i = 0;\n\n    while (i < length) {\n        size_t vl = svwhilelt_u32(i, length); // Active vector length\n        svint64_t vec_src = svuzp1_u32(svtbl_u32(src, vl), svundef_u32()); // Load and set high bits\n        svint64_t vec_dst = svshl_n_s64(vec_src, 32); // Shift left by 32 to set high bits\n        svst1_u64(dst + i, vec_dst); // Store result\n        i += vl; // Increment by active vector length\n    }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t vector_length = svcntd(); // Number of elements per vector\n    size_t i = 0;\n\n    while (i < length) {\n        size_t j;\n        svuint32_t src_vec;\n        svuint64_t dst_vec;\n\n        // Load as many elements as fit into a vector\n        for (j = 0; j < vector_length && i + j < length; j++) {\n            src_vec.s[j] = src[i + j];\n        }\n\n        // Process the vector\n        dst_vec = svreinterpret_u64_u32(src_vec);\n        dst_vec = svshl_n_u64(dst_vec, 32);\n\n        // Store the result back to memory\n        for (j = 0; j < vector_length && i + j < length; j++) {\n            dst[i + j] = dst_vec.s[j];\n        }\n\n        i += vector_length;\n    }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t p = svwhilelt_b64(0, length);\n    while (svptest_any(svptrue_b64(), p)) {\n        svuint32_t vec_src = svld1_u32(src, p);\n        svuint64_t vec_dst = svuzp_hilo_u32(vec_src, svcreate_hword_u32(~0u));\n        svst1_u64(dst, vec_dst, p);\n        src += svcntd();\n        dst += svcntd();\n        p = svwhilelt_b64(svcntd() * i++, length);\n    }\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double result = 0.0;\n    svbool_t pg = svwhilelt_b64(0, length);\n    svfloat64_t sum_vec = svdup_n_f64(0.0);\n\n    for (size_t i = 0; i < length; i += svcntd()) {\n        svint64_t indices = svld1_s64(pg, &index[i]);\n        svfloat64_t values = svld1_f64(pg, &vec[svminv_i64(indices)]);\n        sum_vec = svadd_v(sum_vec, values, pg);\n    }\n\n    result = svaddv_f64(sum_vec);\n    return result;\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double result = 0.0;\n    svbool_t pg = svwhilelt_b64(0, length);\n    svfloat64_t sum_vec = svdup_n_f64(0.0);\n\n    for (size_t i = 0; i < length; i += svcntd()) {\n        svint64_t indices = svld1_s64(pg, &index[i]);\n        svfloat64_t values = svld1_f64(pg, &vec[svminv_i64(indices)]);\n        sum_vec = svadd_v(svptrue_b64(), sum_vec, values);\n    }\n\n    result = svaddv_f64(sum_vec);\n    return result;\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double result = 0.0;\n    svbool_t pg = svwhilelt_b64(0, length);\n    svfloat64_t sum_vec = svdup_n_f64(0.0);\n\n    for (size_t i = 0; i < length; i += svcntd()) {\n        svint64_t indices = svld1_s64(pg, &index[i]);\n        svfloat64_t values = svld1_f64(pg, &vec[svminv_i64(indices)]);\n        sum_vec = svadd_v(svptrue_b64(), sum_vec, values);\n    }\n\n    result = svaddv_f64(sum_vec);\n    return result;\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double result = 0.0;\n    svbool_t pg = svwhilelt_b64(0, length);\n    svfloat64_t sum_vec = svdup_gather_offset_f64(pg, vec, index);\n    result = svaddv_f64(sum_vec);\n    return result;\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double result = 0.0;\n    svbool_t pg = svwhilelt_b64(0, length);\n    svfloat64_t sum_vec = svdup_n_f64(0.0);\n\n    for (size_t i = 0; svptest_any(pg); i += svcntd()) {\n        svint64_t indices = svld1_s64(pg, index + svindex_u32(i));\n        svfloat64_t values = svld1_f64(pg, vec + svindex_u32(indices));\n        sum_vec = svadd_v(svptrue_b64(), sum_vec, values);\n    }\n\n    result = svaddv_f64(sum_vec);\n    return result;\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```c\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t i, j, k, l;\n    size_t output_size = input_size - kernel_size + 1;\n    svbool_t pg = svwhilelt_b64(0, output_size);\n\n    for (i = 0; i < output_size; i++) {\n        for (j = 0; j < output_size; j++) {\n            svfloat64_t sum_vec = svdupq_f64(0.0);\n            for (k = 0; k < kernel_size; k++) {\n                for (l = 0; l < kernel_size; l++) {\n                    double input_val = input[(i + k) * input_size + (j + l)];\n                    double kernel_val = kernel[k * kernel_size + l];\n                    sum_vec = svaddq(sum_vec, svdupq_n_f64(input_val * kernel_val));\n                }\n            }\n            svfloat64_t relu_vec = svmaxq_f64(sum_vec, svdupq_n_f64(0.0));\n            svst1q_f64(&output[i * output_size + j], relu_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```c\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t i, j, k, l;\n    size_t out_size = input_size - kernel_size + 1;\n    svbool_t pg = svwhilelt_b64(0, out_size);\n\n    for(i = 0; i < out_size; i += svcntd()) {\n        svbool_t pg_i = svwhilelt_b64(i, i + svcntd());\n        for(j = 0; j < out_size; j++) {\n            double acc[sve_len / sizeof(double)];\n            svzeroq_f64(acc);\n            for(k = 0; k < kernel_size; k++) {\n                svbool_t pg_k = svwhilelt_b64(k, k + svcntd());\n                for(l = 0; l < kernel_size; l++) {\n                    double val = input[(i + k) * input_size + (j + l)];\n                    double kern = kernel[k * kernel_size + l];\n                    svfloat64_t v_val = svld1q_f64(&val, pg_k);\n                    svfloat64_t v_kern = svld1q_f64(&kern, pg_k);\n                    svst1q_f64(acc, svmlaq_f64(svld1q_f64(acc, pg_k), v_val, v_kern));\n                }\n            }\n            svfloat64_t v_acc = svld1q_f64(acc, pg_i);\n            v_acc = svmaxq_f64(v_acc, svdupq_n_f64(0.0));\n            svst1q_f64(output + i * out_size + j, v_acc);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```c\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t i, j, k, l;\n    size_t out_h = input_size - kernel_size + 1;\n    size_t out_w = input_size - kernel_size + 1;\n    size_t vl = svgetvl();\n\n    for (i = 0; i < out_h; i++) {\n        for (j = 0; j < out_w; j++) {\n            svbool_t pg = svwhilelt_b64(0, vl);\n            svfloat64_t acc = svdupq_n_f64(0.0);\n\n            for (k = 0; k < kernel_size; k++) {\n                for (l = 0; l < kernel_size; l++) {\n                    size_t idx_in = (i + k) * input_size + (j + l);\n                    size_t idx_ker = k * kernel_size + l;\n                    svfloat64_t val_in = svld1(pg, &input[idx_in]);\n                    svfloat64_t val_ker = svld1(pg, &kernel[idx_ker]);\n                    acc = svmlaq_p(svptrue_b64(), acc, val_in, val_ker);\n                }\n            }\n\n            svfloat64_t relu = svmaxq(acc, svdupq_n_f64(0.0));\n            svst1(pg, &output[i * out_w + j], relu);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```c\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t i, j, k, l;\n    size_t vec_len = svcntd(); // Number of elements per vector\n    size_t out_size = input_size - kernel_size + 1;\n\n    for (i = 0; i < out_size; i++) {\n        for (j = 0; j < out_size; j++) {\n            svfloat64_t sum_vec = svdupq_n_f64(0.0);\n            for (k = 0; k < kernel_size; k++) {\n                for (l = 0; l < kernel_size; l++) {\n                    svfloat64_t input_val = svld1q_gather_offset_f64(input, (i + k) * input_size + (j + l));\n                    svfloat64_t kernel_val = svld1q_dup_gather_offset_f64(kernel, k * kernel_size + l);\n                    sum_vec = svmlaq_f64(sum_vec, kernel_val, input_val);\n                }\n            }\n            svfloat64_t relu_mask = svcmpgtq_f64(sum_vec, svdupq_n_f64(0.0));\n            sum_vec = svselq_f64(sum_vec, svdupq_n_f64(0.0), relu_mask);\n            svst1q_f64(output + i * out_size + j, sum_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```c\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t i, j, k, l;\n    size_t output_size = input_size - kernel_size + 1;\n    svbool_t pg = svwhilelt_b64(0, output_size);\n\n    for (i = 0; i < output_size; i++) {\n        for (j = 0; j < output_size; j++) {\n            svfloat64_t sum = svdupq_n_f64(0.0);\n            for (k = 0; k < kernel_size; k++) {\n                for (l = 0; l < kernel_size; l++) {\n                    double input_val = input[(i + k) * input_size + (j + l)];\n                    double kernel_val = kernel[k * kernel_size + l];\n                    sum = svaddq_m_f64(pg, sum, svmlaq_n_f64(svld1q_f64(&input_val), svld1q_f64(&kernel_val), svdupq_n_f64(0.0)));\n                }\n            }\n            double result = svgetq_lane_f64(svmulq_n_f64(sum, 1.0), 0);\n            if (result > 0.0) {\n                output[i * output_size + j] = result;\n            } else {\n                output[i * output_size + j] = 0.0;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <std_vector>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold){\n    size_t n = numbers.size();\n    svbool_t pg = svwhilelt_b(n, 0);\n    svfloat64_t vec = svld1(pg, numbers.data());\n    \n    for(size_t i = 0; i < n; i += svcntd()){\n        svbool_t pg_i = svwhilelt_b(svcntd(), i);\n        svfloat64_t vec_i = svld1(pg_i, numbers.data() + i);\n        svfloat64_t diff = svabs(pg_i, svsub(pg_i, vec_i, vec));\n        svbool_t any_close = svcmple(pg_i, diff, svdup_n_f64(threshold));\n        if(svptest_any(svptrue_b(), any_close)){\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <std_vector>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold){\n    size_t n = numbers.size();\n    svbool_t pg = svwhilelt_b(n, 0);\n    \n    // Convert threshold to vector\n    svfloat64_t thr = svdup(pg, threshold);\n    \n    for(size_t i=0; i<n; i+=svcntd()){\n        svbool_t pg_i = svwhilelt_b(svcntd(), i);\n        svfloat64_t vec = svld1(pg_i, &numbers[i]);\n        \n        // Compute pairwise differences\n        svfloat64_t diff1 = svabs(pg_i, svsub_x(pg_i, vec, svld1_offset(pg_i, vec, 1)));\n        svfloat64_t diff2 = svabs(pg_i, svsub_x(pg_i, vec, svld1_offset(pg_i, vec, 2)));\n        svfloat64_t diff3 = svabs(pg_i, svsub_x(pg_i, vec, svld1_offset(pg_i, vec, 3)));\n        \n        // Check if any difference is less than threshold\n        svbool_t any_close1 = svcmple(pg_i, diff1, thr);\n        svbool_t any_close2 = svcmple(pg_i, diff2, thr);\n        svbool_t any_close3 = svcmple(pg_i, diff3, thr);\n        \n        if(svmaybeany(any_close1) || svmaybeany(any_close2) || svmaybeany(any_close3)){\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <std_vector>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold){\n    size_t n = numbers.size();\n    svbool_t pg = svwhilelt_b(n, 0);\n    \n    // Convert threshold to vector\n    svfloat64_t thr = svdup(pg, threshold);\n    \n    for(size_t i=0; i<n; i+=svcntd()){\n        svbool_t pg_i = svwhilelt_b(svcntd(), i);\n        svfloat64_t vec = svld1(pg_i, &numbers[i]);\n        \n        // Compute pairwise differences\n        svfloat64_t diff1 = svabs(pg_i, svsub_x(pg_i, vec, svld1_offset(pg_i, vec, 1)));\n        svfloat64_t diff2 = svabs(pg_i, svsub_x(pg_i, vec, svld1_offset(pg_i, vec, 2)));\n        svfloat64_t diff3 = svabs(pg_i, svsub_x(pg_i, vec, svld1_offset(pg_i, vec, 3)));\n        \n        // Check if any difference is less than threshold\n        svbool_t any_close1 = svcmple(pg_i, diff1, thr);\n        svbool_t any_close2 = svcmple(pg_i, diff2, thr);\n        svbool_t any_close3 = svcmple(pg_i, diff3, thr);\n        \n        if(svmaybeany(any_close1) || svmaybeany(any_close2) || svmaybeany(any_close3)){\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold){\n    size_t n = numbers.size();\n    svbool_t pg = svwhilelt_b(n, 0);\n    \n    // Convert threshold to vector\n    svfloat64_t thr = svdup(pg, threshold);\n    \n    for(size_t i=0; i<n; i+=svcntd()){\n        svbool_t pg_i = svwhilelt_b(n, i);\n        svfloat64_t vec = svld1(pg_i, &numbers[i]);\n        \n        // Compute pairwise differences\n        svfloat64_t diff1 = svabs(pg_i, svsub_x(pg_i, vec, svld1(pg_i, &numbers[i+1])));\n        svfloat64_t diff2 = svabs(pg_i, svsub_x(pg_i, vec, svld1(pg_i, &numbers[i+2])));\n        svfloat64_t diff3 = svabs(pg_i, svsub_x(pg_i, vec, svld1(pg_i, &numbers[i+3])));\n        \n        // Check if any difference is less than threshold\n        svbool_t any_close = svcmple(pg_i, diff1, thr);\n        any_close = svorr_v(pg_i, any_close, svcmple(pg_i, diff2, thr));\n        any_close = svorr_v(pg_i, any_close, svcmple(pg_i, diff3, thr));\n        \n        if(svpred_b(any_close)){\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <std_vector>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold){\n    size_t n = numbers.size();\n    svbool_t pg = svwhilelt_b(n, 0);\n    \n    // Convert threshold to vector\n    svfloat64_t thr = svdup(pg, threshold);\n    \n    for(size_t i=0; i<n; i+=svcntd()){\n        svbool_t pg_i = svwhilelt_b(svcntd(), i);\n        svfloat64_t vec = svld1(pg_i, &numbers[i]);\n        \n        // Compute pairwise differences\n        svfloat64_t diff1 = svabs(pg_i, svsub_x(pg_i, vec, svld1_offset(pg_i, vec, 1)));\n        svfloat64_t diff2 = svabs(pg_i, svsub_x(pg_i, vec, svld1_offset(pg_i, vec, 2)));\n        svfloat64_t diff3 = svabs(pg_i, svsub_x(pg_i, vec, svld1_offset(pg_i, vec, 3)));\n        \n        // Check if any difference is less than threshold\n        svbool_t any_close1 = svcmple(pg_i, diff1, thr);\n        svbool_t any_close2 = svcmple(pg_i, diff2, thr);\n        svbool_t any_close3 = svcmple(pg_i, diff3, thr);\n        \n        if(svmaybe(pg_i, any_close1) || svmaybe(pg_i, any_close2) || svmaybe(pg_i, any_close3)){\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <hwy/highway.h>\n\nbool below_zero_simd(const std::vector<int> &operations) {\n    size_t n = operations.size();\n    svbool_t pg = svwhilelt_b32(0, (int32_t)n);\n    svint32_t acc = svdup_gather(pg, operations.data(), 1);\n    svint32_t ops = svld1(pg, operations.data());\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        acc = svadd_x(pg, acc, ops);\n        svbool_t underflow = svcmple_x(pg, acc, svdup_n_s32(0));\n        if (svptest_any(underflow, pg)) {\n            return true;\n        }\n        pg = svwhilelt_b32(svadd_x(pg, pg, 1), (int32_t)n);\n        ops = svld1(pg, operations.data() + svcntb(pg));\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <hwy/highway.h>\n\nbool below_zero_simd(const std::vector<int> &operations) {\n    size_t n = operations.size();\n    svbool_t pg = svwhilelt_b(n, 0);\n    svint32_t acc = svdup_n_s32(0);\n    for (size_t i = 0; i < n; i += svcntw()) {\n        svint32_t ops = svld1(pg, operations.data() + i);\n        acc = svadd_x(acc, ops, pg);\n        svbool_t underflow = svcmplt(acc, svdup_n_s32(0));\n        if (svptest_any(svtrue_b(), underflow)) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <hwy/highway.h>\n\nbool below_zero_simd(const std::vector<int> &operations) {\n    size_t n = operations.size();\n    svbool_t pg = svwhilelt_b32(0, (int32_t)n);\n    svint32_t acc = svdup_gather(pg, operations.data(), 0);\n    svint32_t ops = svld1(pg, operations.data());\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        acc = svadd_x(pg, acc, ops);\n        svbool_t below_zero = svcmplt(acc, svdup_n_s32(0));\n        if (svptest_any(below_zero, pg)) {\n            return true;\n        }\n        pg = svwhilelt_b32(svadd_x(svptrue_b32(), svindex_b32(0), 1), (int32_t)n);\n        ops = svld1(pg, operations.data() + svget_idx_b32(pg));\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <hwy/highway.h>\n\nbool below_zero_simd(const std::vector<int> &operations) {\n    size_t n = operations.size();\n    svbool_t pg = svwhilelt_b32(0, (int32_t)n);\n    svint32_t acc = svdup_gather(pg, operations.data(), 1);\n    svint32_t ops = svld1(pg, operations.data());\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        acc = svadd_x(pg, acc, ops);\n        svbool_t below_zero = svcmplt(acc, svdup_n_s32(0));\n        if (svptest_any(below_zero, pg)) {\n            return true;\n        }\n        pg = svwhilelt_b32(svadd_x(svptrue_b32(), svindex_b32(0), 1), (int32_t)n);\n        ops = svld1(pg, operations.data() + svcntb(pg));\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```c\nbool below_zero_simd(std::vector<int> operations){\n    size_t n = operations.size();\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t vec_ops = svld1(pg, operations.data());\n    svint32_t cumulative = svdup_gather_index_s32(pg, operations.data(), 0);\n    \n    svbool_t below_zero = svcmple_s32(cumulative, svindex_s32(0, 1));\n    if(svptest_any(svptrue_b32(), below_zero)){\n        return true;\n    }\n    \n    for(size_t i = 1; i < n; i += svlen_s32()){\n        size_t len = svcntd();\n        svint32_t current_ops = svld1(pg, operations.data() + i);\n        cumulative = svadd_s32(cumulative, current_ops);\n        below_zero = svcmple_s32(cumulative, svindex_s32(0, 1));\n        if(svptest_any(svptrue_b32(), below_zero)){\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```c\ndouble mean_absolute_deviation_simd(std::vector<double> numbers){\n    size_t n = numbers.size();\n    svfloat64_t sum_val = svdup_n_f64(0.0);\n    svfloat64_t diff_abs_sum = svdup_n_f64(0.0);\n    size_t vector_length = svcntd(); // Get the vector length\n\n    // Calculate the sum of all elements\n    for(size_t i = 0; i < n; i += vector_length){\n        size_t len = (n - i < vector_length) ? n - i : vector_length;\n        svfloat64_t vec = svld1((const double *)(&numbers[i]), len);\n        sum_val = svaddv(vec, sum_val);\n    }\n\n    double total_sum = svaddv_f64(sum_val); // Sum of all elements\n    double mean = total_sum / n;\n\n    // Calculate the Mean Absolute Deviation\n    for(size_t i = 0; i < n; i += vector_length){\n        size_t len = (n - i < vector_length) ? n - i : vector_length;\n        svfloat64_t vec = svld1((const double *)(&numbers[i]), len);\n        svfloat64_t mean_vec = svdup_n_f64(mean);\n        svfloat64_t diff = svabs(svsub_f64(vec, mean_vec));\n        diff_abs_sum = svaddv(diff, diff_abs_sum);\n    }\n\n    double mad_sum = svaddv_f64(diff_abs_sum); // Sum of absolute differences\n    return mad_sum / n;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```c\ndouble mean_absolute_deviation_simd(std::vector<double> numbers){\n    size_t n = numbers.size();\n    svfloat64_t sum_val = svdup_n_f64(0.0);\n    svfloat64_t diff_abs_sum = svdup_n_f64(0.0);\n    svbool_t pg = svwhilelt_b64(0, n);\n\n    for(size_t i = 0; i < n; i += svcntd()){\n        svfloat64_t vec = svld1(pg, &numbers[i]);\n        svfloat64_t mean_val = svdiv_vv_f64(svaddv(pg, vec), svcntd());\n        svfloat64_t diff = svsub_vv_f64(vec, svdup_n_f64(mean_val));\n        svfloat64_t abs_diff = svabs_v_f64(diff);\n        sum_val = svadd_vv_f64(sum_val, svaddv(pg, abs_diff));\n    }\n\n    double total_sum = svget_hf64(svtol_f64(sum_val), 0);\n    return total_sum / n;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```c\ndouble mean_absolute_deviation_simd(std::vector<double> numbers){\n    size_t n = numbers.size();\n    svfloat64_t sum_val = svdup_n_f64(0.0);\n    svfloat64_t diff = svdup_n_f64(0.0);\n    svfloat64_t mean = svdup_n_f64(0.0);\n    svfloat64_t abs_diff_sum = svdup_n_f64(0.0);\n    \n    // Calculate the sum of all elements\n    for(size_t i = 0; i < n; i += svcntd()){\n        svfloat64_t vec = svld1_f64(numbers.data() + i);\n        sum_val = svadd_v_v_f64(sum_val, vec);\n    }\n    \n    mean = svdiv_v_f64(svdup_n_f64((double)n), sum_val);\n    \n    // Calculate the sum of absolute differences\n    for(size_t i = 0; i < n; i += svcntd()){\n        svfloat64_t vec = svld1_f64(numbers.data() + i);\n        diff = svsub_v_v_f64(vec, mean);\n        diff = svabs_f64(diff);\n        abs_diff_sum = svadd_v_v_f64(abs_diff_sum, diff);\n    }\n    \n    double total_abs_diff = svcvt_f64_s64(svaddv_s64(svreinterpret_s64_f64(abs_diff_sum)));\n    return total_abs_diff / n;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```c\ndouble mean_absolute_deviation_simd(std::vector<double> numbers){\n    size_t n = numbers.size();\n    svfloat64_t sum_val = svdup_n_f64(0.0);\n    svfloat64_t diff_abs_sum = svdup_n_f64(0.0);\n    size_t vector_length = svcntd(); // Get the vector length\n\n    // Calculate the sum of all elements\n    for(size_t i = 0; i < n; i += vector_length){\n        size_t chunk_size = std::min(vector_length, n - i);\n        svfloat64_t vec = svld1_f64(numbers.data() + i);\n        sum_val = svaddv_f64(sum_val, vec);\n    }\n\n    double total_sum = svaddv_f64(sum_val, sum_val);\n    double mean = total_sum / n;\n\n    // Calculate the sum of absolute differences from the mean\n    for(size_t i = 0; i < n; i += vector_length){\n        size_t chunk_size = std::min(vector_length, n - i);\n        svfloat64_t vec = svld1_f64(numbers.data() + i);\n        svfloat64_t diff = svabs_f64(svsub_f64(vec, svdup_n_f64(mean)));\n        diff_abs_sum = svaddv_f64(diff_abs_sum, diff);\n    }\n\n    double total_diff_abs_sum = svaddv_f64(diff_abs_sum, diff_abs_sum);\n    double mad = total_diff_abs_sum / n;\n\n    return mad;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```c\ndouble mean_absolute_deviation_simd(std::vector<double> numbers){\n    size_t n = numbers.size();\n    svfloat64_t sum_val = svdup_n_f64(0.0);\n    svfloat64_t diff = svdup_n_f64(0.0);\n    svfloat64_t mean = svdup_n_f64(0.0);\n    svfloat64_t abs_diff_sum = svdup_n_f64(0.0);\n    \n    // Calculate the mean\n    for(size_t i = 0; i < n; i += svcntd()){\n        svfloat64_t vec = svld1_f64(numbers.data() + i);\n        sum_val = svadd_v_v_f64(sum_val, vec, svcntd());\n    }\n    mean = svdiv_v_f64(sum_val, svdup_n_f64((double)n));\n    \n    // Calculate the Mean Absolute Deviation\n    for(size_t i = 0; i < n; i += svcntd()){\n        svfloat64_t vec = svld1_f64(numbers.data() + i);\n        diff = svsub_v_v_f64(vec, mean);\n        diff = svabs_f64(diff);\n        abs_diff_sum = svadd_v_v_f64(abs_diff_sum, diff, svcntd());\n    }\n    \n    double total_abs_diff = svcvt_f64_s64(svsumh_s64(svreinterpret_s64_f64(abs_diff_sum)));\n    return total_abs_diff / n;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter){\n    size_t n = numbers.size();\n    size_t group_size = svcntw(); // Number of elements per vector lane\n    size_t total_size = 2 * n - 1;\n    std::vector<int> result(total_size);\n    \n    svint32_t delimiter_vec = svld1_s32(&delimeter); // Load delimiter as a vector\n    svint32_t* numbers_ptr = reinterpret_cast<svint32_t*>(numbers.data());\n    svint32_t* result_ptr = reinterpret_cast<svint32_t*>(result.data());\n\n    for(size_t i = 0; i < n; i += group_size){\n        size_t chunk_size = std::min(group_size, n - i);\n        svint32_t nums_chunk = svld1_s32(numbers_ptr + i);\n        svint32_t dels_chunk = svdup_n_s32(delimeter);\n\n        if(i + group_size < n){\n            svst1_s32(result_ptr + 2*i, svptrue_b32(), svcat_s32(nums_chunk, dels_chunk));\n        }\n        else{\n            svst1_s32(result_ptr + 2*i, svptrue_b32(), nums_chunk);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter){\n    size_t n = numbers.size();\n    size_t group_size = svcntw(); // Number of elements per vector lane\n    size_t total_size = n * 2 - 1;\n    std::vector<int> result(total_size);\n    \n    svint32_t delimiter_vec = svld1((const int *)(&delimeter));\n    \n    for(size_t i = 0; i < n; i += group_size){\n        size_t count = (n - i >= group_size) ? group_size : n - i;\n        svint32_t nums = svld1((const int *)(&numbers[i]));\n        svint32_t interspersed = svundef();\n        \n        for(int j = 0; j < count; j++){\n            if(j > 0){\n                interspersed = svsel(svmovprv(interspersed), delimiter_vec, svcmpeq_s(svmovprv(interspersed), svundef()));\n            }\n            interspersed = svsel(svmovprv(interspersed), nums, svcmpeq_s(nums, svundef()));\n        }\n        \n        svst1((int *)(&result[i*2]), interspersed);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter){\n    size_t n = numbers.size();\n    size_t group_size = svcntw(); // Number of elements per vector lane\n    size_t total_size = n * 2 - 1;\n    std::vector<int> result(total_size);\n    \n    svint32_t delimiter_vec = svld1((const int *)(&delimeter)); // Load delimiter as vector\n    \n    for(size_t i = 0; i < n; i += group_size){\n        size_t count = std::min(group_size, n - i);\n        svint32_t nums = svld1((const int *)(&numbers[i])); // Load numbers\n        \n        svint32_t interleaved = svundef_h();\n        for(int j = 0; j < count; j++){\n            interleaved = svsetlane_s32(svgetlane_s32(nums, j), 2*j, interleaved);\n            interleaved = svsetlane_s32(delimeter, 2*j + 1, interleaved);\n        }\n        \n        svst1((int *)(&result[2*i]), interleaved); // Store interleaved results\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter){\n    size_t n = numbers.size();\n    size_t group_size = svcntw(); // Number of elements per vector lane\n    size_t total_size = n * 2 - 1;\n    std::vector<int> result(total_size);\n    \n    svint32_t delimiter_vec = svld1((const int *)(&delimeter)); // Load delimiter as vector\n    svint32_t *num_ptr = (svint32_t *)numbers.data();\n    svint32_t *res_ptr = (svint32_t *)result.data();\n\n    for(size_t i = 0; i < n; i += group_size){\n        size_t count = (n - i >= group_size) ? group_size : n - i;\n        svint32_t nums = svld1(num_ptr + i); // Load current group of numbers\n        svint32_t interleaved = svptrue_b32(); // Initialize predicate\n\n        for(int j = 0; j < count; j++){\n            svptrue_b32(interleaved, j*2);\n            svst1(res_ptr + i*2 + j*2, svsel(interleaved, nums[j], delimiter_vec));\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter){\n    size_t n = numbers.size();\n    size_t group_size = svcntw(); // Number of elements per vector lane\n    size_t total_size = 2 * n - 1;\n    std::vector<int> result(total_size);\n    \n    svint32_t delimiter_vec = svld1_s32(&delimeter); // Load delimiter as a vector\n    \n    for(size_t i = 0; i < n; i += group_size){\n        size_t count = std::min(group_size, n - i);\n        svint32_t nums = svld1_s32(numbers.data() + i);\n        svint32_t interspersed = svptrue_b32();\n        \n        for(int j = 0; j < count; j++){\n            if(j > 0){\n                svst1_s32(result.data() + 2*i + j, delimiter_vec);\n            }\n            svst1_s32(result.data() + 2*i + 2*j, svsel_s32(interspersed, nums, svindex_r32(j)));\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers){\n    size_t n = numbers.size();\n    if (n == 0) {\n        return {0, 1};\n    }\n\n    size_t elements_per_block = svcntw(); // Number of elements per vector block\n    size_t blocks = (n + elements_per_block - 1) / elements_per_block;\n\n    svint16_t sum_vec = svdup_n_s16(0);\n    svint16_t prod_vec = svdup_n_s16(1);\n\n    for (size_t i = 0; i < blocks; ++i) {\n        size_t start = i * elements_per_block;\n        size_t end = std::min(start + elements_per_block, n);\n        size_t count = end - start;\n\n        svint16_t block = svld1((const int16_t*)&numbers[start]);\n        block = svundef_b16(block, count); // Mask unused elements\n\n        sum_vec = svadd_x(svptrue_b16(), sum_vec, block);\n        prod_vec = svmla_x(svptrue_b16(), prod_vec, block);\n    }\n\n    int64_t sum = svaddv(svptrue_b16(), sum_vec);\n    int64_t prod = svmlav(svptrue_b16(), svdup_n_s16(1), prod_vec);\n\n    return {sum, prod};\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers){\n    size_t n = numbers.size();\n    if (n == 0) {\n        return {0, 1};\n    }\n\n    size_t elements_per_block = svcntw(); // Number of elements per vector block\n    size_t blocks = (n + elements_per_block - 1) / elements_per_block;\n\n    svint16_t sum_vec = svdup_n_s16(0);\n    svint16_t prod_vec = svdup_n_s16(1);\n\n    for (size_t i = 0; i < blocks; ++i) {\n        size_t start = i * elements_per_block;\n        size_t end = std::min(start + elements_per_block, n);\n        size_t count = end - start;\n\n        svint16_t block = svld1((const int16_t*)&numbers[start]);\n        block = svundef_b16(block, count); // Mask unused elements\n\n        sum_vec = svadd_x_s16(sum_vec, block);\n        prod_vec = svmla_x_s16(prod_vec, svdup_n_s16(1), block);\n    }\n\n    int64_t sum = svaddv_s16(sum_vec);\n    int64_t prod = svmlav_p_s16(svtrue_h(), svdup_n_s16(1), prod_vec);\n\n    return {sum, prod};\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers){\n    size_t n = numbers.size();\n    if (n == 0) {\n        return {0, 1};\n    }\n\n    size_t vector_length = svcntw(); // Get the vector length\n    size_t num_vectors = (n + vector_length - 1) / vector_length;\n\n    svint16_t sum_vec = svdup_n_s16(0);\n    svint16_t prod_vec = svdup_n_s16(1);\n\n    for (size_t i = 0; i < num_vectors; ++i) {\n        size_t start = i * vector_length;\n        size_t end = std::min(start + vector_length, n);\n        size_t count = end - start;\n\n        svint16_t vec = svld1((const int16_t*)(numbers.data() + start));\n        svbool_t pg = svwhilelt_b16(0, count);\n\n        sum_vec = svadd_x(pg, sum_vec, vec);\n        prod_vec = svmla_x(pg, prod_vec, svdup_n_s16(1), vec);\n    }\n\n    int64_t sum = svaddv_s16(sum_vec);\n    int64_t prod = svmlav_p(svptrue_b16(), prod_vec, svdup_n_s16(1));\n\n    return {sum, prod};\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers){\n    size_t n = numbers.size();\n    if (n == 0) {\n        return {0, 1};\n    }\n\n    size_t elements_per_block = svcntw(); // Number of elements per vector block\n    size_t blocks = (n + elements_per_block - 1) / elements_per_block;\n\n    svint16_t sum_vec = svdup_n_s16(0);\n    svint16_t prod_vec = svdup_n_s16(1);\n\n    for (size_t i = 0; i < blocks; ++i) {\n        size_t start = i * elements_per_block;\n        size_t end = std::min(start + elements_per_block, n);\n        size_t count = end - start;\n\n        svint16_t block = svld1((const int16_t*)&numbers[start]);\n        block = svundef_b16(block, count); // Mask unused elements\n\n        sum_vec = svadd_x_s16(sum_vec, block);\n        prod_vec = svmla_x_s16(prod_vec, svdup_n_s16(1), block);\n    }\n\n    int64_t sum = svaddv_s16(sum_vec);\n    int64_t prod = svmlav_p_s16(svptrue_b16(), svdup_n_s16(1), prod_vec);\n\n    return {sum, prod};\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers){\n    size_t n = numbers.size();\n    if (n == 0) {\n        return {0, 1};\n    }\n\n    size_t vector_length = svcntw(); // Get the vector length\n    size_t num_vectors = (n + vector_length - 1) / vector_length;\n\n    svint16_t sum_vec = svdup_n_s16(0);\n    svint16_t prod_vec = svdup_n_s16(1);\n\n    for (size_t i = 0; i < num_vectors; ++i) {\n        size_t start = i * vector_length;\n        size_t end = std::min(start + vector_length, n);\n        size_t count = end - start;\n\n        svint16_t vec = svld1((const int16_t*)(numbers.data() + start));\n        svbool_t pg = svwhilelt_b16(0, count);\n\n        sum_vec = svadd_x(pg, sum_vec, vec);\n        prod_vec = svmla_x(pg, prod_vec, vec, svtrue_b16());\n    }\n\n    int64_t sum = svaddv_s16(sum_vec);\n    int64_t prod = svaddv_s16(prod_vec);\n\n    return {sum, prod};\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers){\n    size_t n = numbers.size();\n    std::vector<int> result(n);\n    svlen = svcntb() * 8; // Get the vector length in elements\n\n    for (size_t i = 0; i < n; i += svlen) {\n        size_t chunk_size = (i + svlen <= n) ? svlen : n - i;\n        svint32_t current_chunk = svld1((const int *)(&numbers[i]));\n        svint32_t max_values = svdup_n_s32(numbers[i]);\n        \n        for (size_t j = 1; j < chunk_size; ++j) {\n            svint32_t new_val = svld1_gather_index((const int *)(&numbers[i]), j);\n            svint32_t updated_max = svmax(max_values, new_val);\n            svst1((int *)(&result[i + j]), updated_max);\n            max_values = updated_max;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    size_t n = numbers.size();\n    std::vector<int> result(n);\n    size_t i = 0;\n\n    while (i + svcntb() <= n) {\n        svint32_t vec_in = svld1_s32(numbers.data() + i);\n        svint32_t vec_max = svmaxv_s32(vec_in);\n        svst1_s32(result.data() + i, svmax_s32(vec_in, svdup_s32(vec_max)));\n        i += svcntb();\n    }\n\n    for (; i < n; ++i) {\n        if (numbers[i] > result[i - 1]) {\n            result[i] = numbers[i];\n        } else {\n            result[i] = result[i - 1];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers){\n    size_t n = numbers.size();\n    std::vector<int> result(n);\n    svlen = svcntb() * 8; // Get the vector length in elements\n\n    for (size_t i = 0; i < n; i += svlen) {\n        size_t chunk_size = (i + svlen <= n) ? svlen : n - i;\n        svint32_t current_chunk = svld1((const int *)(&numbers[i]));\n        svint32_t max_values = svdup_n_s32(numbers[i]);\n        \n        for (size_t j = 1; j < chunk_size; ++j) {\n            svint32_t new_value = svld1_gather_index((const int *)(&numbers[i]), j);\n            svint32_t updated_max = svmax(max_values, new_value);\n            svst1((int *)(&result[i + j]), updated_max);\n            max_values = updated_max;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers){\n    size_t n = numbers.size();\n    std::vector<int> result(n);\n    svlen = svcntb() * 8; // Get the vector length in elements\n\n    for (size_t i = 0; i < n; i += svlen) {\n        size_t chunk_size = (n - i >= svlen) ? svlen : n - i;\n        svint32_t current_chunk = svld1((const int *)(&numbers[i]));\n        svint32_t max_values = svdup_n_s32(numbers[i] > 0 ? numbers[i] : INT_MIN);\n\n        for (size_t j = 1; j < chunk_size; ++j) {\n            svint32_t new_val = svld1((const int *)(&numbers[i + j]));\n            svint32_t updated_max = svmax(max_values, new_val);\n            svst1((int *)(&result[i + j]), updated_max);\n            max_values = updated_max;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    size_t n = numbers.size();\n    std::vector<int> result(n);\n    size_t i = 0;\n\n    while (i + svcntb() <= n) {\n        svint32_t vec_in = svld1((const int *)(&numbers[i]));\n        svint32_t vec_max = svmax(vec_in);\n        svst1((int *)(&result[i]), vec_max);\n        i += svcntb();\n    }\n\n    while (i < n) {\n        result[i] = *std::max_element(numbers.begin(), numbers.begin() + i + 1);\n        i++;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <string>\n#include <bitset>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.size();\n    size_t vec_len = svcntb() * 8; // Get vector length in bits\n    size_t i = 0;\n\n    // Ensure both strings are of equal length\n    if (len != b.size()) {\n        throw std::invalid_argument(\"Strings must be of equal length\");\n    }\n\n    // Convert strings to integer vectors\n    svint8_t vec_a = svld1_u8((const uint8_t*)a.c_str());\n    svint8_t vec_b = svld1_u8((const uint8_t*)b.c_str());\n\n    // Precompute masks for '0' and '1'\n    svint8_t mask_zero = svcmpeq_u8(vec_a, svdup_n_u8('0'));\n    svint8_t mask_one = svcmpeq_u8(vec_a, svdup_n_u8('1'));\n\n    std::string result;\n    result.reserve(len);\n\n    while (i + vec_len <= len) {\n        svint8_t vec_xored = svcmpeq_u8(vec_a, vec_b); // Perform XOR operation\n        uint8_t buf[vec_len];\n        svst1_u8(buf, vec_xored);\n        for (size_t j = 0; j < vec_len; j++) {\n            char c = (buf[j] == 1) ? '1' : '0';\n            result += c;\n        }\n        i += vec_len;\n        vec_a = svld1_u8((const uint8_t*)(a.c_str() + i));\n        vec_b = svld1_u8((const uint8_t*)(b.c_str() + i));\n    }\n\n    // Handle remaining characters\n    for (; i < len; i++) {\n        char bit_a = a[i];\n        char bit_b = b[i];\n        char xor_result = (bit_a != bit_b) ? '1' : '0';\n        result += xor_result;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <string>\n#include <bitset>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.size();\n    size_t vec_len = svcntb() * 8; // Get vector length in bits\n    size_t i = 0;\n\n    // Ensure both strings have the same length\n    if (len != b.size()) {\n        throw std::invalid_argument(\"Strings must be of equal length\");\n    }\n\n    // Convert strings to integer vectors\n    svint8_t vec_a = svld1_u8((const uint8_t*)a.c_str());\n    svint8_t vec_b = svld1_u8((const uint8_t*)b.c_str());\n\n    // Precompute masks for '0' and '1'\n    svint8_t mask_zero = svcmpeq_u8(vec_a, svdup_n_u8('0'));\n    svint8_t mask_one = svcmpeq_u8(vec_a, svdup_n_u8('1'));\n\n    // Result vector\n    svint8_t result = svdup_n_s8(0);\n\n    while (i + vec_len <= len) {\n        svint8_t chunk_a = svuzp1_u8(vec_a, i);\n        svint8_t chunk_b = svuzp1_u8(vec_b, i);\n\n        // Perform XOR operation\n        svint8_t xor_result = svcmpeq_u8(chunk_a, chunk_b);\n\n        // Store the result\n        result = svsel_u8(xor_result, svdup_n_u8('1'), svdup_n_u8('0'));\n\n        i += vec_len;\n    }\n\n    // Handle remaining characters\n    for (; i < len; ++i) {\n        result[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n\n    // Convert back to string\n    std::string res_str(result, len);\n    return res_str;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <string>\n#include <bitset>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.size();\n    size_t vec_len = svcntb() * 8; // Get vector length in bits\n    size_t num_vecs = (len + vec_len - 1) / vec_len;\n    \n    // Convert strings to vectors\n    svbool_t pg = svwhilelt_b32(0, len);\n    svuint8_t vec_a = svld1_u8((const uint8_t*)a.data(), pg);\n    svuint8_t vec_b = svld1_u8((const uint8_t*)b.data(), pg);\n    \n    // Perform XOR operation\n    svuint8_t vec_result = svbitwise_xor_u8(vec_a, vec_b);\n    \n    // Convert result back to string\n    std::string result;\n    result.reserve(len);\n    for(size_t i = 0; i < len; ++i){\n        result += (vec_result[i] == '0') ? '0' : '1';\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <string>\n#include <bit>\n\nstd::string string_xor_simd(std::string a, std::string b){\n    size_t len = a.size();\n    size_t vec_len = svcntb() * 8; // Get vector length in bits\n    size_t i = 0;\n\n    // Ensure both strings have the same length\n    if(len != b.size()) {\n        throw std::invalid_argument(\"Strings must be of equal length\");\n    }\n\n    // Convert strings to vectors\n    svint8_t vec_a, vec_b;\n    svint8_t result_vec;\n\n    std::string result_str;\n    result_str.reserve(len);\n\n    while(i + vec_len <= len){\n        vec_a = svld1_u8((const uint8_t*)(a.data() + i));\n        vec_b = svld1_u8((const uint8_t*)(b.data() + i));\n\n        result_vec = svcmpeq_s8(vec_a, vec_b); // Compare each bit (0 == 0, 1 == 1)\n        result_vec = svnot_b8(result_vec);     // Invert to get XOR result\n\n        // Store result back to string\n        result_str.append(reinterpret_cast<char*>(svreinterpret_u8(result_vec).s), vec_len);\n        i += vec_len;\n    }\n\n    // Handle remaining characters\n    for(; i < len; ++i){\n        result_str += (a[i] != b[i]) ? '1' : '0';\n    }\n\n    return result_str;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <string>\n#include <bitset>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.size();\n    size_t vec_len = svcntb() * 8; // Get vector length in bits\n    size_t i = 0;\n\n    // Ensure both strings are of the same length\n    if (len != b.size()) {\n        throw std::invalid_argument(\"Strings must be of the same length\");\n    }\n\n    // Convert strings to integer vectors\n    svint8_t vec_a = svld1_u8((const uint8_t*)a.c_str());\n    svint8_t vec_b = svld1_u8((const uint8_t*)b.c_str());\n\n    // Precompute masks for '0' and '1'\n    svint8_t mask_zero = svcmpne_u8(vec_a, svdup_n_u8('0'));\n    svint8_t mask_one = svcmpeq_u8(vec_a, svdup_n_u8('1'));\n\n    // Perform XOR operation using vectorized logic\n    svbool_t pg = svwhilelt_b8(0, len);\n    svint8_t xor_result = svand_b8(pg, svabt_b8(pg, svorr_b8(pg, mask_zero, mask_one)));\n\n    // Convert back to string\n    char result[len + 1];\n    for (i = 0; i < len; i += vec_len) {\n        svint8_t chunk = svld1_u8((const uint8_t*)(a.c_str() + i));\n        svst1_u8((uint8_t*)(result + i), chunk);\n    }\n    result[len] = '\\0';\n\n    return std::string(result);\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    size_t max_len = 0;\n    size_t max_idx = 0;\n\n    size_t n = strings.size();\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b64(i, n);\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        size_t len[sve_len / sizeof(size_t)];\n        svst1q_u32((uint32_t *)len, svld1q_u32((uint32_t *)strings[i].length()));\n\n        for (int j = 0; j < sve_len / sizeof(size_t); j++) {\n            if (pg & (1ULL << j)) {\n                if (len[j] > max_len) {\n                    max_len = len[j];\n                    max_idx = i + j;\n                }\n            }\n        }\n\n        i += sve_len / sizeof(size_t);\n        pg = svwhilelt_b64(i, n);\n    }\n\n    return strings[max_idx];\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```c\nstd::string longest_simd(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    size_t max_len = 0;\n    size_t max_idx = 0;\n\n    svbool_t pg = svwhilelt_u32(0, strings.size());\n    size_t i = 0;\n\n    while(svptest_any(svptrue_b32(), pg)){\n        svuint32_t indices = svindex_u32(pg);\n        size_t vec_size = svcntd();\n        svbool_t p_last = svcmpeq_u32(svindex_u32(pg), svsub_u32(svindex_u32(pg), svcreate_index_u32(vec_size -1)));\n\n        svulong_t lens = svld1_u64(pg, reinterpret_cast<const ulong*>(strings.data()));\n        svbool_t p_max = svcmple_u64(svsmax_u64(lens), svcreate_u64(max_len));\n\n        if(svptest_any(p_max, p_last)){\n            svuint64_t new_max = svsel_u64(p_max, lens, svcreate_u64(max_len));\n            svuint32_t new_max_idx = svsel_u32(p_max, indices, svcreate_u32(max_idx));\n            max_len = svcvt_u32_u64(svpred_reduce_max_u64(new_max));\n            max_idx = svcvt_u32_u64(svpred_reduce_max_u64(new_max_idx));\n        }\n\n        i += vec_size;\n        pg = svwhilelt_u32(i, strings.size());\n    }\n\n    return strings[max_idx];\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```c\nstd::string longest_simd(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return \"\"; // None equivalent\n    }\n\n    size_t max_len = 0;\n    size_t max_idx = 0;\n\n    svbool_t pg = svwhilelt_u32(0, strings.size());\n    size_t i = 0;\n\n    while(svptest_any(svptrue_b32(), pg)){\n        svuint32_t indices = svindex_u32(pg, i);\n        size_t n = svlen(indices);\n\n        svulong_t lens = svdup_n_ul(0);\n        for(size_t j = 0; j < n; j++){\n            size_t idx = indices[j];\n            size_t len = strings[idx].length();\n            lens = svsel_ul(lens, svcreate_ul(len), svcmpeq_u32(svindex_u32(pg, j), svindex_u32(pg, j)));\n        }\n\n        svbool_t gt_mask = svcmple_u32(svindex_u32(pg, 0), svindex_u32(pg, n-1));\n        for(size_t j = 1; j < n; j++){\n            svbool_t cmp_mask = svcmple_u32(svindex_u32(pg, j-1), svindex_u32(pg, j));\n            gt_mask = svptrue_b32() ? svorr_b32(gt_mask, cmp_mask) : svand_b32(gt_mask, cmp_mask);\n        }\n\n        svbool_t update_mask = svcmpgt_u32(svcreate_u32(max_len), lens);\n        max_len = svmax_u32(max_len, lens);\n        max_idx = svsel_u32(max_idx, svindex_u32(pg, svbsr_b32(update_mask)), update_mask);\n\n        pg = svnext_u32(pg, n);\n        i += n;\n    }\n\n    return strings[max_idx];\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n\nstd::string longest_simd(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    size_t max_len = 0;\n    size_t max_idx = 0;\n\n    size_t n = strings.size();\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b64(i, n);\n\n    while(svptest_any(svptrue_b64(), pg)){\n        size_t len[sve_len / sizeof(size_t)];\n        svst1_sizet(pg, len, svadd_n_sizet(svld1_sizet(pg, (size_t*)(&strings[0] + i)), -i));\n\n        for(int j=0; j<sve_len/sizeof(size_t); j++){\n            if(len[j] > max_len){\n                max_len = len[j];\n                max_idx = i + j;\n            }\n        }\n\n        i += sve_len / sizeof(size_t);\n        pg = svwhilelt_b64(i, n);\n    }\n\n    return strings[max_idx];\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```c\nstd::string longest_simd(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    size_t max_len = 0;\n    size_t max_idx = 0;\n\n    svbool_t pg = svwhilelt_u32(0, strings.size());\n    size_t i = 0;\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t indices = svindex_u32(pg, i);\n        size_t n = svcntd();\n        svulong_t lens = svld1_u64(pg, reinterpret_cast<const svulong_t*>(strings.data()));\n        \n        for (size_t j = 0; j < n; j++) {\n            size_t idx = indices[j];\n            size_t len = static_cast<size_t>(lens[j]);\n            if (len > max_len) {\n                max_len = len;\n                max_idx = idx;\n            }\n        }\n\n        i += n;\n        pg = svwhilelt_u32(i, strings.size());\n    }\n\n    return strings[max_idx];\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b){\n    svbool_t pg = svwhilelt_b64(0, a);\n    uint64_t result = 0;\n\n    while(svptest_any(pg)){\n        uint64_t va = svuzp1_b64(pg, a);\n        uint64_t vb = svuzp1_b64(pg, b);\n        \n        uint64_t temp_a = va;\n        uint64_t temp_b = vb;\n        while(temp_b != 0){\n            uint64_t remainder = temp_a % temp_b;\n            temp_a = temp_b;\n            temp_b = remainder;\n        }\n        result = temp_a;\n        pg = svnext(pg);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b){\n    svbool_t pg = svwhilelt_b64(0, a);\n    svuint64_t va = svld1(pg, &a);\n    svuint64_t vb = svld1(pg, &b);\n\n    while(svvcmpne_b64(pg, va, vb)) {\n        svbool_t pa = svcmpeq_b64(pg, va, vb);\n        svbool_t pb = svnot_b64(pa);\n        svuint64_t ra = svsub_x_u64(pg, va, vb);\n        svuint64_t rb = vb;\n        va = svsel_b64(pa, va, ra);\n        vb = svsel_b64(pb, vb, rb);\n        pg = svptrue_b64();\n    }\n\n    return svlast_u64(pg, vb);\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b){\n    svbool_t pg = svwhilelt_b64(0, a);\n    uint64_t result = 0;\n\n    while(svptest_any(pg)){\n        uint64_t va = svuzp1_b64(pg, a);\n        uint64_t vb = svuzp1_b64(pg, b);\n        uint64_t temp = va % vb;\n        result = svternary_b64(pg, vb, result);\n        pg = svwhilelt_b64(va, vb);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b){\n    svbool_t pg = svwhilelt_b64(0, a);\n    svuint64_t va = svld1(pg, &a);\n    svuint64_t vb = svld1(pg, &b);\n\n    while(svvcmpne_b64(va, vb, pg).p0){\n        svbool_t pa = svcmplt_b64(va, vb);\n        svbool_t pb = svcmpeq_b64(va, vb);\n\n        svuint64_t diff = svsub_x(pg, vb, va);\n        va = svselect(pg, va, diff, pa);\n        vb = svselect(pg, vb, va, pb);\n    }\n\n    return svcadd(pg, va, vb);\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b){\n    svbool_t pg = svwhilelt_b64(0, a);\n    uint64_t result = 0;\n\n    while(svptest_any(pg)){\n        uint64_t va = svuzp1_b64(pg, a);\n        uint64_t vb = svuzp1_b64(pg, b);\n        uint64_t temp = va % vb;\n        result = svternary_b64(pg, vb, result);\n        pg = svwhilelt_b64(va, vb);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers){\n    size_t n = numbers.size();\n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    // Load all elements into a scalable vector\n    svfloat32_t vec = svld1(pg, numbers.data());\n    \n    float min_diff = __builtin_inf();\n    float first = 0.0f;\n    float second = 0.0f;\n    \n    for(size_t i=0; i<n-1; i+=16){\n        svbool_t pg_i = svwhilelt_b32(0, n - i);\n        svfloat32_t vec_i = svld1(pg_i, numbers.data() + i);\n        \n        for(size_t j=i+1; j<n; j+=16){\n            svbool_t pg_j = svwhilelt_b32(0, n - j);\n            svfloat32_t vec_j = svld1(pg_j, numbers.data() + j);\n            \n            svfloat32_t diff = svabs(vec_i - vec_j);\n            svfloat32_t mask = svcmple_f32(pg_j, diff, svdup(pg_j, svmin_f32(min_diff)));\n            \n            if(svptest_any(mask)){\n                svfloat32_t selected_i = svsel_f32(mask, vec_i, svdup(pg_j, first));\n                svfloat32_t selected_j = svsel_f32(mask, vec_j, svdup(pg_j, second));\n                \n                svbool_t smallest_mask = svcmplt_f32(pg_j, selected_i, selected_j);\n                svfloat32_t smallest = svsel_f32(smallest_mask, selected_i, selected_j);\n                svfloat32_t largest = svsel_f32(smallest_mask, selected_j, selected_i);\n                \n                min_diff = svmin_f32(min_diff, svmax_f32(smallest, largest));\n                first = svsel_f32(mask, smallest, first);\n                second = svsel_f32(mask, largest, second);\n            }\n        }\n    }\n    \n    return {first, second};\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```c\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers){\n    svfloat_t nums = svld1_f32(numbers.data());\n    svfloat_t min_diff = svdup_f32(__builtin_inf());\n    svfloat_t elem1 = svdup_f32(0);\n    svfloat_t elem2 = svdup_f32(0);\n\n    svbool_t pg = svwhilelt_b32(0, svlen_b32());\n    for(int i=0; i<svlen_b32(); i+=16){\n        svbool_t p = svwhilelt_b32(i, svlen_b32());\n        svfloat_t v1 = svundef_f32();\n        svfloat_t v2 = svundef_f32();\n\n        for(int j=0; j<svlen_b32(); j++){\n            if(j == i) continue;\n            svfloat_t diff = svabs_f32(svsub_f32(nums, svdup_f32(numbers[j])));\n            svbool_t p_lt = svcmple_f32(diff, min_diff);\n            v1 = svsel_f32(v1, svdup_f32(numbers[j]), p_lt);\n            v2 = svsel_f32(v2, svdup_f32(numbers[i]), p_lt);\n            min_diff = svsel_f32(min_diff, diff, p_lt);\n        }\n        elem1 = svsel_f32(elem1, v1, p);\n        elem2 = svsel_f32(elem2, v2, p);\n    }\n    return {svgetlane_f32(elem1, 0), svgetlane_f32(elem2, 0)};\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers){\n    size_t n = numbers.size();\n    svfloat_t vec_numbers[sve_len_b / sizeof(float)];\n    svfloat_t min_diff = svdup_f32(__builtin_inf());\n    svfloat_t elem1 = svdup_f32(0);\n    svfloat_t elem2 = svdup_f32(0);\n\n    for(size_t i = 0; i < n; i += sve_len / sizeof(float)){\n        size_t len = std::min(sve_len / sizeof(float), n - i);\n        svfloat_t current = svld1_f32(numbers.data() + i);\n        for(size_t j = 0; j < len; ++j){\n            svfloat_t diff = svabs_f32(svsub_f32(current, svld1_f32(numbers.data() + i + j)));\n            svbool_t mask = svcmple_f32(diff, min_diff);\n            min_diff = svsel_f32(min_diff, diff, mask);\n            elem1 = svsel_f32(elem1, svld1_f32(numbers.data() + i + j), mask);\n            elem2 = svsel_f32(elem2, current, mask);\n        }\n    }\n\n    std::vector<float> result;\n    result.push_back(svgetlane_f32(elem1, 0));\n    result.push_back(svgetlane_f32(elem2, 0));\n    return result;\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers){\n    size_t n = numbers.size();\n    svfloat_t vec_numbers = svld1_f32(numbers.data());\n    svfloat_t min_diff = svdup_f32(__builtin_inf());\n    svfloat_t elem1 = svdup_f32(0);\n    svfloat_t elem2 = svdup_f32(0);\n\n    for(size_t i=0; i<n; i+=svcntm()){\n        svfloat_t current = svld1_f32(numbers.data() + i);\n        svbool_t p = svwhilelt_b32(i, n);\n        \n        for(size_t j=i+1; j<n; j+=svcntm()){\n            svfloat_t other = svld1_f32(numbers.data() + j);\n            svfloat_t diff = svabs_f32(svsub_f32(current, other));\n            \n            svbool_t update = svcmple_b32(diff, min_diff);\n            elem1 = svsel_m_f32(update, current, elem1);\n            elem2 = svsel_m_f32(update, other, elem2);\n            min_diff = svmin_m_f32(update, diff, min_diff);\n        }\n    }\n\n    std::vector<float> result;\n    result.push_back(svdup_f32(elem1));\n    result.push_back(svdup_f32(elem2));\n    return result;\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers){\n    size_t n = numbers.size();\n    svfloat_t vec_numbers = svld1_f32(numbers.data());\n    svfloat_t min_diff = svdup_f32(__builtin_inf());\n    svfloat_t elem1 = svdup_f32(0);\n    svfloat_t elem2 = svdup_f32(0);\n\n    for(size_t i=0; i<n-1; i+=svcntm()){\n        svfloat_t current = svld1_f32(numbers.data() + i);\n        svbool_t p = svwhilelt_b32(i, n-1);\n        \n        for(size_t j=i+1; j<n; j+=svcntm()){\n            svfloat_t other = svld1_f32(numbers.data() + j);\n            svfloat_t diff = svabs_f32(svsub_f32(current, other));\n            \n            svbool_t update = svcmple_b32(diff, min_diff);\n            elem1 = svsel_b32(update, current, elem1);\n            elem2 = svsel_b32(update, other, elem2);\n            min_diff = svsel_b32(update, diff, min_diff);\n        }\n    }\n\n    std::vector<float> result;\n    result.push_back(svdup_f32(elem1));\n    result.push_back(svdup_f32(elem2));\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers){\n    size_t n = numbers.size();\n    svfloat_t min_val = svmaxv_f32(svld1_f32(numbers.data()));\n    svfloat_t max_val = svminv_f32(svld1_f32(numbers.data()));\n    svfloat_t range = svsub_f32(max_val, min_val);\n    \n    std::vector<float> result(n);\n    for(size_t i=0; i<n; i+=svcntd()){\n        svfloat_t input = svld1_f32(numbers.data() + i);\n        svfloat_t normalized = svdiv_f32(svsub_f32(input, min_val), range);\n        svst1_f32(result.data() + i, normalized);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers){\n    size_t n = numbers.size();\n    svfloat_t min_val = svmaxv_f32(svld1_f32(numbers.data()));\n    svfloat_t max_val = svminv_f32(svld1_f32(numbers.data()));\n    svfloat_t range = svsub_f32(max_val, min_val);\n    \n    std::vector<float> result(n);\n    for(size_t i=0; i<n; i+=svcntd()){\n        svfloat_t input = svld1_f32(numbers.data() + i);\n        svfloat_t scaled = svdiv_f32(svsub_f32(input, min_val), range);\n        svst1_f32(result.data() + i, scaled);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers){\n    size_t n = numbers.size();\n    svfloat_t min_val = svmaxv_f32(svld1_f32(numbers.data()));\n    svfloat_t max_val = svminv_f32(svld1_f32(numbers.data()));\n    svfloat_t range = svsub_f32(max_val, min_val);\n    \n    std::vector<float> result(n);\n    for(size_t i=0; i<n; i+=svcntd()){\n        svfloat_t input = svld1_f32(numbers.data() + i);\n        svfloat_t normalized = svdiv_f32(svsub_f32(input, min_val), range);\n        svst1_f32(result.data() + i, normalized);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers){\n    size_t n = numbers.size();\n    svfloat_t min_val = svmaxv_f32(svld1_f32(numbers.data()));\n    svfloat_t max_val = svminv_f32(svld1_f32(numbers.data()));\n    svfloat_t range = svsub_f32(max_val, min_val);\n    \n    std::vector<float> result(n);\n    for(size_t i=0; i<n; i+=svcntd()){\n        svfloat_t input = svld1_f32(numbers.data() + i);\n        svfloat_t scaled = svdiv_f32(svsub_f32(input, min_val), range);\n        svst1_f32(result.data() + i, scaled);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers){\n    size_t n = numbers.size();\n    svfloat_t min_val = svmaxv_f32(svld1_f32(numbers.data()));\n    svfloat_t max_val = svminv_f32(svld1_f32(numbers.data()));\n    svfloat_t range = svsub_f32(max_val, min_val);\n    \n    std::vector<float> result(n);\n    for(size_t i=0; i<n; i+=svcntd()){\n        svfloat_t input = svld1_f32(numbers.data() + i);\n        svfloat_t normalized = svdiv_f32(svsub_f32(input, min_val), range);\n        svst1_f32(result.data() + i, normalized);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    svbool_t pg = svwhilelt_b64(0, n);\n    svint64_t divisors = svindex_b64(pg, 1, 1); // Start from 1 up to n-1\n    svbool_t mask = svcmpeq_b64(divisors, svdup_n_b64(false)); // Initialize mask\n    svbool_t update_mask = pg;\n\n    while (svptest_any(update_mask)) {\n        svint64_t remainders = svdivrem_b64(pg, n, divisors, &update_mask);\n        svbool_t valid_divisors = svcmpeq_s64(remainders, svdup_n_s64(0));\n        mask = svptrue_b64();\n        mask = svorr_b64(mask, valid_divisors);\n        divisors = svaddlv_b64(pg, divisors);\n    }\n\n    svint64_t result = svmaxv_s64(pg, divisors);\n    return svcvt_s64_n_s64(result);\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    svbool_t pg = svwhilelt_b64(0, n);\n    svint64_t divisors = svindex_b64(pg, 1, 1); // Start from 1 up to n-1\n    svbool_t mask = svcmpeq_b64(pg, divisors, svdup_n_b64(n));\n    while (!svptest_any(svptrue_b64(), mask)) {\n        divisors = svsub_x_b64(pg, divisors, svtrue_n_b64(1));\n        mask = svcmpeq_b64(pg, divisors, svdup_n_b64(n));\n    }\n    return svlastb_b64(divisors, mask);\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    svbool_t pg = svwhilelt_b64(0, n);\n    svint64_t divisors = svindex_b64(pg, 1, 1); // Start from 1 up to n-1\n    svbool_t mask = svcmpeq_n_u64(divisors, n);\n    while (!svptest_any(svptrue_b64(), mask)) {\n        svst1_u64(&divisors, svsub_x_u64(divisors, svindex_b64(pg, 1, 1), pg));\n        mask = svcmpeq_n_u64(divisors, n);\n    }\n    return svlast_u64(divisors, mask);\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    svbool_t pg = svwhilelt_b64(0, n);\n    svint64_t divisors = svindex_b64(pg, 1, 1); // Start from 1 up to n-1\n    svbool_t mask = svcmpeq_b64(pg, divisors, svdup_n_b64(n));\n    while (!svptest_any(svptrue_b64(), mask)) {\n        svst1_u64(&divisors, svsub_x_u64(pg, divisors, svdup_n_u64(1)));\n        mask = svcmpeq_b64(pg, divisors, svdup_n_b64(n));\n    }\n    return svlast_u64(divisors);\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    svbool_t pg = svwhilelt_b64(0, n);\n    svint64_t divisors = svindex_b64(pg, 1, 1); // Start from 1 up to n-1\n    svbool_t mask = svcmpeq_n_u64(divisors, n);\n    while (!svptest_any(svptrue_b64(), mask)) {\n        svst1_u64(pg, &divisors, svsub_x_u64(divisors, svtrue_n_u64(1), pg));\n        mask = svcmpeq_n_u64(divisors, n);\n    }\n    return svlast_u64(divisors, mask);\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n){\n    std::vector<int> factors;\n    int32_t max_factor = n / 2;\n    svbool_t pg = svwhilelt_b32(0, max_factor);\n    \n    // Initialize loop variables\n    svint32_t current = svindex_b32(pg, 2); // Start checking from 2\n    svint32_t num = svdup_n_b32(n);\n    \n    while (svptest_any(svptrue_b32(), pg)){\n        // Check if divisible by current factor\n        svbool_t divisible = svcmpeq_m(pg, svdivm(pg, num, current), svindex_z(pg, 0));\n        \n        // If divisible, add to factors and update number\n        svbool_t update = svand_b32(divisible, pg);\n        if(svptest_any(svptrue_b32(), update)){\n            factors.push_back((int)sveq_x(pg, current, update));\n            svst1_s32(&num, svdivv(pg, num, current));\n        }\n        \n        // Increment current factor\n        current = svadd_x(pg, current, svindex_m(pg, 1, update));\n    }\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n){\n    std::vector<int> factors;\n    int32_t max_factor = n / 2;\n    svbool_t pg = svwhilelt_b32(0, max_factor);\n    \n    for(int i = 2; i <= max_factor; ++i){\n        svint32_t test = svindex_b32(pg, i, 1);\n        svbool_t is_factor = svcmpeq_m(pg, svindex_b32(pg, n, 1), svmla_xz_b32(test, svindex_b32(pg, n, 1), test));\n        \n        if(svptest_any(is_factor)){\n            int32_t factor = i;\n            svbool_t active = svwhilelt_b32(0, factor);\n            while(svptest_any(svcmpeq_m(active, svindex_b32(active, n, 1), svindex_b32(active, factor, 1)))){\n                factors.push_back(factor);\n                n /= factor;\n            }\n        }\n    }\n    \n    if(n > 1){\n        factors.push_back(n);\n    }\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n){\n    size_t vl = svquery_vl();\n    svint32_t factors = svdup_n_s32(0);\n    svbool_t pg = svwhilelt_b32(0, vl);\n    int factor_count = 0;\n\n    for(int i=2; i*i <=n; i++){\n        svbool_t updated_pg = pg;\n        while(svptest_any(svptrue_b32(), updated_pg)){\n            size_t first = svfirst_b32(updated_pg);\n            if(n % i == 0){\n                factors = svinsert_n_s32(factors, i, first);\n                factor_count++;\n                n /= i;\n            }\n            updated_pg = svcntb_b32(first+1);\n        }\n    }\n\n    if(n >1){\n        svbool_t updated_pg = pg;\n        while(svptest_any(svptrue_b32(), updated_pg)){\n            size_t first = svfirst_b32(updated_pg);\n            factors = svinsert_n_s32(factors, n, first);\n            factor_count++;\n            updated_pg = svcntb_b32(first+1);\n        }\n    }\n\n    std::vector<int> result(factor_count);\n    for(size_t i=0; i<factor_count; i++){\n        result[i] = svget_s32(factors, i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n){\n    size_t vl = svquery_vl();\n    size_t vec_len = vl / sizeof(int);\n    std::vector<int> factors;\n    int max_factor = n / 2;\n    std::vector<int> candidates(vec_len);\n    for(int i=0; i<=max_factor; i++) candidates[i] = i+1;\n\n    svint32_t candidate_vec = svld1((const int *)candidates.data());\n    svbool_t pg = svwhilelt_b32(0, vec_len);\n\n    while(svcmpeq_b32(pg, candidate_vec, svdup_n_s32(1)).any()){\n        svbool_t mask = svcmpeq_b32(pg, svmod_s32(pg, svdup_n_s32(n), candidate_vec), svdup_n_s32(0));\n        if(mask.any()){\n            int factor = svget_s32(candidate_vec, svfirst_true_b32(pg, mask));\n            factors.push_back(factor);\n            n /= factor;\n        }\n        candidate_vec = svadd_n_s32(candidate_vec, svtrue_s32());\n    }\n\n    if(n > 1){\n        factors.push_back(n);\n    }\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n){\n    size_t vl = svquery_vl(); // Get the vector length\n    size_t num_elements = vl / sizeof(int);\n    std::vector<int> factors;\n    int max_factor = n / 2;\n    std::vector<int> candidates(num_elements);\n    for(int i=2; i<=max_factor; i+=num_elements){\n        svint32_t candidate_vec = svld1((const int*)(&i), num_elements);\n        svbool_t p_true = svwhilelt_b32(0, num_elements);\n        svint32_t mod_result = svmod_s32(p_true, candidate_vec, svdup_n_s32(n));\n        svbool_t is_factor = svcmpeq_b32(p_true, mod_result, svdup_n_s32(0));\n        if(svptest_any(is_factor)){\n            int first_factor = svget_s32(candidate_vec, svfirstTrue_b32(is_factor));\n            factors.push_back(first_factor);\n            int quotient = n / first_factor;\n            n = quotient;\n            if(n == 1){\n                break;\n            }\n            i = 1; // Reset i to check again from the start\n        }\n    }\n    if(n > 1){\n        factors.push_back(n);\n    }\n    return factors;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> &l) {\n    size_t n = l.size();\n    size_t elements_per_block = svcntf(); // Number of elements per vector block\n    std::vector<float> result;\n    result.reserve(n); // Preallocate memory for efficiency\n\n    for (size_t i = 0; i < n; i += elements_per_block) {\n        svfloat32_t vec = svld1((const float *)(&l[i])); // Load vector\n        svbool_t p = svwhilelt_b32(0, elements_per_block); // Create predicate for active elements\n        svfloat32_t positives = svsel_b32(p, svcmpgt_f32(vec, svdup_f32(0.0f)), svundef_f32()); // Select positive values\n        float *positive_ptr = (float *)svwhilelt_b32(0, elements_per_block); // Pointer to active elements\n        svst1(positive_ptr, positives); // Store positive values\n        result.insert(result.end(), positive_ptr, positive_ptr + svcntf()); // Append results\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> &l) {\n    size_t n = l.size();\n    size_t elements_per_block = svcntf(); // Number of elements per vector block\n    std::vector<float> result;\n    result.reserve(n); // Preallocate memory for efficiency\n\n    for (size_t i = 0; i < n; i += elements_per_block) {\n        size_t block_size = (n - i >= elements_per_block) ? elements_per_block : n - i;\n        svfloat32_t vec = svld1((const float *)(&l[i]));\n        svbool_t p = svwhilelt_b32(0, block_size);\n        svfloat32_t positives = svsel_b32(p, svcmpgt_f32(vec, svdup_f32(0.0f)), svdup_f32(0.0f));\n        result.insert(result.end(), (float *)svget_b32(positives), (float *)svget_b32(positives) + svcntf());\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> &l) {\n    size_t n = l.size();\n    size_t elements_per_block = svcntf(); // Number of elements per vector block\n    std::vector<float> result;\n    result.reserve(n); // Preallocate memory for efficiency\n\n    for (size_t i = 0; i < n; i += elements_per_block) {\n        size_t block_size = (n - i >= elements_per_block) ? elements_per_block : n - i;\n        svfloat_t vec = svld1((const float *)(&l[i])); // Load vector\n        svbool_t p = svwhilelt_b_f32(block_size);       // Create predicate for current block\n        svfloat_t positives = svsel_b(p, svcmpgt_f32(vec, svdup_f32(0.0f)), svdup_f32(0.0f)); // Select positive values\n        result.insert(result.end(), (float *)svwhilelt_b_f32(positives, p), (float *)svlastlt_b_f32(positives, p));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> &l) {\n    size_t n = l.size();\n    size_t elements_per_block = svcntf(); // Number of elements per vector block\n    std::vector<float> result;\n    result.reserve(n);\n\n    for (size_t i = 0; i < n; i += elements_per_block) {\n        size_t block_size = (n - i >= elements_per_block) ? elements_per_block : n - i;\n        svfloat32_t vec = svld1((const float *)(&l[i]));\n        svbool_t p = svwhilelt_b32(0, block_size);\n        svfloat32_t pos_vec = svsel_b32(p, svabs_f32(vec), svdup_n_f32(0));\n        result.insert(result.end(), (float *)pos_vec.v, (float *)pos_vec.v + block_size);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> &l) {\n    size_t n = l.size();\n    size_t elements_per_block = svcntf(); // Number of elements per vector block\n    std::vector<float> result;\n    result.reserve(n); // Preallocate memory for efficiency\n\n    for (size_t i = 0; i < n; i += elements_per_block) {\n        size_t block_size = (n - i >= elements_per_block) ? elements_per_block : n - i;\n        svfloat32_t vec = svld1((const float *)(&l[i]));\n        svbool_t p = svwhilelt_b32(0, block_size);\n        svfloat32_t positives = svsel(p, svcmpgt(vec, svdup_n_f32(0.0f)) ? vec : svundef_b32(p), svundef_b32(p));\n        result.insert(result.end(), (float *)svwhilelt_b32(0, block_size), (float *)svwhilelt_b32(0, block_size) + svcntb(p));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```c\nbool is_prime_simd(int64_t n){\n    svbool_t pg = svwhilelt_b64(0, n);\n    svint64_t vec_n = svindex_b64(pg, 1);\n    svbool_t is_prime = svcmpeq_m(pg, pg, vec_n, svdup_n_b64(2));\n    svint64_t limit = svsqrt_n_f64(svptrue_b64(), (double)n);\n    svint64_t step = svindex_b64(pg, 2);\n\n    while(svvcmpge_b64(pg, vec_n, svdup_n_b64(3))){\n        svbool_t divisible = svvmul_b64(pg, svcmpeq_b64(pg, vec_n % step, svindex_b64(pg, 0)), svcmple_b64(pg, step, limit));\n        is_prime = svbitor_b64(is_prime, svnot_b64(pg, divisible));\n        vec_n = vec_n + step;\n    }\n    return svcntd() == svcntb(svmerge_b64(pg, is_prime, svtrue_b64()));\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```c\nbool is_prime_simd(int64_t n){\n    svbool_t pg = svwhilelt_b64(0, n);\n    svint64_t vec_n = svindex_b64(pg, 1);\n    svbool_t is_prime = svcmpeq_n_b64(vec_n, 2); // 2 is prime\n    if (svlastb_b64(pg) < 2) return !svany_b64(is_prime);\n    \n    svint64_t sieve = svcmpeq_n_b64(vec_n, 1); // 1 is not prime\n    svint64_t limit = svsqrt_n_i64(n);\n    svbool_t pg_inner;\n    svint64_t factor;\n    \n    while (svcntw() > 0){\n        pg_inner = svwhilelt_b64(2, limit);\n        factor = svindex_b64(pg_inner, 2);\n        svbool_t divisible = svmod_n_z_b64(pg_inner, vec_n, factor);\n        sieve = svbor_b64(sieve, divisible);\n        if (!svany_b64(divisible)) break;\n    }\n    \n    is_prime = svbnot_b64(svcast_b64_s64(sieve));\n    return !svany_b64(is_prime);\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```c\nbool is_prime_simd(int64_t n){\n    svbool_t pg = svwhilelt_b64(0, n);\n    svint64_t vec_n = svindex_b64(pg, 1);\n    svbool_t is_prime = svcmpeq_n_b64(vec_n, 2);\n    if (svptest_any(is_prime)) return true;\n    svbool_t mask = svcmpgt_b64(vec_n, 3);\n    while (svptest_any(mask)) {\n        svint64_t factors = svdivrem_n_s64(vec_n, 2);\n        svbool_t divisible = svcmpeq_n_s64(factors, 0);\n        is_prime = svand_b64(is_prime, svnot_b64(divisible));\n        if (svptest_any(is_prime)) return true;\n        vec_n = svsubhn_b64(vec_n, factors);\n        mask = svcmpgt_b64(vec_n, 3);\n    }\n    return svptest_any(is_prime);\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```c\nbool is_prime_simd(int64_t n){\n    svbool_t pg = svwhilelt_b64(0, n);\n    svint64_t vec_n = svindex_b64(pg, 1);\n    svbool_t is_prime = svcmpeq_n_b64(vec_n, 2);\n    if (svptest_any(is_prime)) return true;\n    svbool_t mask = svptrue_b64();\n    for(svint64_t i = svindex_b64(mask, 3); svgetlane(i, 0) * svgetlane(i, 0) <= n; i = svadd_x_b64(i, 2, mask)){\n        svbool_t divisible = svmodlv_b64(vec_n, i) == 0;\n        is_prime = svbitor_b64(is_prime, divisible);\n        if (svptest_any(is_prime)) return false;\n    }\n    return svptest_any(is_prime);\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```c\nbool is_prime_simd(int64_t n){\n    svbool_t pg = svwhilelt_b64(0, n);\n    svint64_t vec_n = svindex_b64(pg, 1);\n    svbool_t is_prime = svcmpeq_n_b64(vec_n, 2);\n    \n    for(svint64_t i = svindex_b64(pg, 3); svptest_any(svptrue_b64(), i); ){\n        svbool_t mask = svptest_first(svptrue_b64(), i);\n        svint64_t remainder = svmod_n_s64(vec_n, svand_b64(mask, i));\n        svbool_t cond = svcmpeq_n_s64(remainder, 0);\n        is_prime = svbitor_b64(is_prime, svnot_b64(cond));\n        i = svlsl_n_s64(i, 1);\n    }\n    \n    return svcnot_b64(svptest_any(svptrue_b64(), is_prime));\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <string>\n#include <cstdint>\n\nstd::string solve_simd(const std::string &s) {\n    size_t len = s.size();\n    if (len == 0) return s;\n\n    // Convert string to uint8_t vector\n    uint8_t data[len];\n    for (size_t i = 0; i < len; ++i) {\n        data[i] = static_cast<uint8_t>(s[i]);\n    }\n    svuint8_t vec_data = svld1_u8(data);\n\n    // Create masks for letters and non-letters\n    svbool_t all_true = svptrue_b_u8();\n    svuint8_t lower_mask = svcmpeq_n_u8(vec_data, 'a') | svcmpeq_n_u8(vec_data, 'b') |\n                           svcmpeq_n_u8(vec_data, 'c') | svcmpeq_n_u8(vec_data, 'd') |\n                           svcmpeq_n_u8(vec_data, 'e') | svcmpeq_n_u8(vec_data, 'f') |\n                           svcmpeq_n_u8(vec_data, 'g') | svcmpeq_n_u8(vec_data, 'h') |\n                           svcmpeq_n_u8(vec_data, 'i') | svcmpeq_n_u8(vec_data, 'j') |\n                           svcmpeq_n_u8(vec_data, 'k') | svcmpeq_n_u8(vec_data, 'l') |\n                           svcmpeq_n_u8(vec_data, 'm') | svcmpeq_n_u8(vec_data, 'n') |\n                           svcmpeq_n_u8(vec_data, 'o') | svcmpeq_n_u8(vec_data, 'p') |\n                           svcmpeq_n_u8(vec_data, 'q') | svcmpeq_n_u8(vec_data, 'r') |\n                           svcmpeq_n_u8(vec_data, 's') | svcmpeq_n_u8(vec_data, 't') |\n                           svcmpeq_n_u8(vec_data, 'u') | svcmpeq_n_u8(vec_data, 'v') |\n                           svcmpeq_n_u8(vec_data, 'w') | svcmpeq_n_u8(vec_data, 'x') |\n                           svcmpeq_n_u8(vec_data, 'y') | svcmpeq_n_u8(vec_data, 'z');\n\n    svuint8_t upper_mask = svcmpeq_n_u8(vec_data, 'A') | svcmpeq_n_u8(vec_data, 'B') |\n                           svcmpeq_n_u8(vec_data, 'C') | svcmpeq_n_u8(vec_data, 'D') |\n                           svcmpeq_n_u8(vec_data, 'E') | svcmpeq_n_u8(vec_data, 'F') |\n                           svcmpeq_n_u8(vec_data, 'G') | svcmpeq_n_u8(vec_data, 'H') |\n                           svcmpeq_n_u8(vec_data, 'I') | svcmpeq_n_u8(vec_data, 'J') |\n                           svcmpeq_n_u8(vec_data, 'K') | svcmpeq_n_u8(vec_data, 'L') |\n                           svcmpeq_n_u8(vec_data, 'M') | svcmpeq_n_u8(vec_data, 'N') |\n                           svcmpeq_n_u8(vec_data, 'O') | svcmpeq_n_u8(vec_data, 'P') |\n                           svcmpeq_n_u8(vec_data, 'Q') | svcmpeq_n_u8(vec_data, 'R') |\n                           svcmpeq_n_u8(vec_data, 'S') | svcmpeq_n_u8(vec_data, 'T') |\n                           svcmpeq_n_u8(vec_data, 'U') | svcmpeq_n_u8(vec_data, 'V') |\n                           svcmpeq_n_u8(vec_data, 'W') | svcmpeq_n_u8(vec_data, 'X') |\n                           svcmpeq_n_u8(vec_data, 'Y') | svcmpeq_n_u8(vec_data, 'Z');\n\n    svbool_t has_letters = svorr_v_b_u8(lower_mask, upper_mask);\n    svbool_t reverse_all = svnot_b(all_true, has_letters);\n\n    // Process letters\n    svuint8_t lower_to_upper = svsub_u8(vec_data, svcreate_u8(32));\n    svuint8_t upper_to_lower = svadd_u8(vec_data, svcreate_u8(32));\n\n    svuint8_t result = svsel_u8(lower_mask, lower_to_upper, vec_data);\n    result = svsel_u8(upper_mask, upper_to_lower, result);\n\n    // Reverse if no letters\n    result = svsel_u8(reverse_all, svrev_n_u8(result, len), result);\n\n    // Convert back to string\n    uint8_t result_data[len];\n    svst1_u8(result_data, result);\n    std::string output(reinterpret_cast<char*>(result_data), len);\n    return output;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <string>\n\nstd::string solve_simd(const std::string &s) {\n    size_t n = s.size();\n    if (n == 0) return s;\n\n    // Convert string to array of chars\n    svint8_t mask = svindex_u8(0, 1);\n    svbool_t pg = svwhilelt_b8(mask, n);\n\n    // Load string into vector registers\n    svuint8_t indices = svindex_u8(0, 1);\n    svchar_t input = svld1_u8(pg, (const unsigned char *)s.c_str());\n\n    // Create masks for letters\n    svbool_t has_upper = svcmpeq_n_u8(svmaxn_u8(pg), 'A');\n    svbool_t has_lower = svcmpeq_n_u8(svmaxn_u8(pg), 'a');\n\n    // Check if there are any letters\n    svbool_t has_letters = svorr_v_b8(has_upper, has_lower);\n\n    // If no letters, reverse the string\n    svchar_t reversed = svrev_b8(pg, input);\n\n    // Otherwise, process each character\n    svchar_t result = svsel_b8(has_letters, reversed, input);\n\n    // Store the result back to memory\n    svst1_u8((unsigned char *)s.c_str(), pg, result);\n\n    return s;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <string>\n\nstd::string solve_simd(const std::string &s) {\n    size_t n = s.size();\n    if (n == 0) return s;\n\n    // Convert string to array of chars\n    svint8_t mask = svindex_u8(0, 1);\n    size_t vector_length = svcntb(); // Number of bytes in a vector\n    svbool_t pg = svwhilelt_b8(mask, (int)n);\n\n    // Load input string into vectors\n    svuint8_t input_chars;\n    svuint8_t output_chars;\n    svbool_t has_alpha = svfalse_b8();\n\n    for (size_t i = 0; i < n; i += vector_length) {\n        size_t len = (n - i >= vector_length) ? vector_length : n - i;\n        svuint8_t current_input = svld1_u8((const uint8_t*)&s[i], svwhilelt_b8(mask, (int)len));\n        input_chars = svptrue_b8() ? current_input : input_chars;\n\n        // Check for alphabetic characters\n        svbool_t is_alpha = svabslt_u8(current_input, svcreate_u8('A')) &\n                            svabslt_u8(current_input, svcreate_u8('z'));\n        has_alpha = svorr_b8(has_alpha, is_alpha);\n\n        // Perform transformations\n        svbool_t is_upper = svand_b8(is_alpha, svabslt_u8(current_input, svcreate_u8('Z')));\n        svbool_t is_lower = svand_b8(is_alpha, svabslt_u8(svsub_u8(current_input, svcreate_u8(' '))), svcreate_u8('a'));\n\n        svuint8_t upper_to_lower = svadd_u8(current_input, svcreate_u8(32));\n        svuint8_t lower_to_upper = svsub_u8(current_input, svcreate_u8(32));\n\n        svuint8_t transformed = svsel_u8(is_upper, lower_to_upper, current_input);\n        transformed = svsel_u8(is_lower, upper_to_lower, transformed);\n\n        // Store results\n        output_chars = svptrue_b8() ? transformed : output_chars;\n    }\n\n    // If no alphabetic characters, reverse the string\n    if (!has_alpha) {\n        // Reverse logic here\n    }\n\n    // Convert back to string\n    std::string result;\n    result.reserve(n);\n    for (size_t i = 0; i < n; ++i) {\n        result += static_cast<char>(output_chars[i]);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <string>\n\nstd::string solve_simd(const std::string &s) {\n    size_t n = s.size();\n    if (n == 0) return \"\";\n\n    // Convert string to array of chars\n    svint8_t mask = svindex_u8(0, 1);\n    size_t vector_length = svcntb(); // Number of bytes in a vector\n    svbool_t pg = svwhilelt_b8(mask, (int)n);\n\n    // Load string into vectors\n    svuint8_t indices = svindex_u8(0, 1);\n    svuint8_t byte_indices = svuzp1_u8(indices, indices);\n    svchar_t chars = svld1(pg, (const char *)s.c_str());\n\n    // Create masks for letters\n    svbool_t is_upper = svcmpeq_b8(chars, svindex_u8('A', 'A'));\n    svbool_t is_lower = svcmpeq_b8(chars, svindex_u8('a', 'a'));\n    svbool_t is_letter = svorr_v_b8(is_upper, is_lower);\n\n    // Reverse case for letters\n    svbool_t has_letters = svany_true_b8(is_letter);\n    svbool_t reverse_all = !has_letters;\n\n    svbool_t pg_reverse = reverse_all ? pg : svand_b8(pg, is_letter);\n    svchar_t reversed_chars = svcond_b8(pg_reverse, svnot_b8(chars), chars);\n\n    // If no letters, reverse the entire string\n    if (!has_letters) {\n        reversed_chars = svrev_b8(pg, reversed_chars);\n    }\n\n    // Store back to result\n    char result[n];\n    svst1(pg, (char *)result, reversed_chars);\n\n    return std::string(result, n);\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <string>\n#include <cstdint>\n\nstd::string solve_simd(const std::string &s) {\n    size_t n = s.size();\n    if (n == 0) return s;\n\n    // Convert string to uint8_t vector\n    uint8_t data[n];\n    for (size_t i = 0; i < n; ++i) {\n        data[i] = static_cast<uint8_t>(s[i]);\n    }\n    svuint8_t vec_data = svld1_u8(data);\n\n    // Create masks for letters and non-letters\n    svbool_t all_true = svptrue_b_u8();\n    svbool_t has_letters = svcmpeq_n_u8(vec_data, 'a') || svcmpeq_n_u8(vec_data, 'z') ||\n                           svcmpeq_n_u8(vec_data, 'A') || svcmpeq_n_u8(vec_data, 'Z');\n    \n    // Reverse case for letters, keep non-letters unchanged\n    svuint8_t reversed_case = svcond_b_u8(has_letters, \n        svbsl_u8(svcmple_n_u8(vec_data, 'Z'), svadd_n_u8(vec_data, 0x20), svsub_n_u8(vec_data, 0x20)),\n        vec_data);\n\n    // Check if there are any letters in the string\n    if (svcntb() == svcntv_b(all_true, has_letters)) {\n        // If no letters, reverse the entire string\n        svint64_t indices = svindex_u64(0, -1);\n        svuint8_t reversed_string = svtrn1_u8(reversed_case, svrev_b_u8(all_true, reversed_case));\n        uint8_t result[n];\n        svst1_u8(result, reversed_string);\n        return std::string(reinterpret_cast<char*>(result), n);\n    } else {\n        // Otherwise, apply the case reversal\n        uint8_t result[n];\n        svst1_u8(result, reversed_case);\n        return std::string(reinterpret_cast<char*>(result), n);\n    }\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result(n);\n    svbool_t pg = svwhilelt_b(n);\n\n    // Load input vector\n    svint32_t vec_in = svld1(pg, l.data());\n\n    // Create mask for indices divisible by 3\n    svbool_t mask_div_by_3 = svcmpeq_n_b32(svindex_b32(0), 3);\n\n    // Extract elements at indices divisible by 3\n    svint32_t vec_div_by_3 = svptrue_b32();\n    svint32_t vec_sorted_div_by_3;\n\n    if (svcntw() >= 3) {\n        svint32_t temp_vec = svtrn1_u32(vec_in, vec_in);\n        vec_sorted_div_by_3 = svsort(temp_vec);\n    } else {\n        // Handle smaller vectors if necessary\n        vec_sorted_div_by_3 = vec_div_by_3;\n    }\n\n    // Insert sorted elements back into their positions\n    svint32_t vec_out = svsel_b32(mask_div_by_3, vec_sorted_div_by_3, vec_in);\n\n    // Store output vector\n    svst1(pg, result.data(), vec_out);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> sort_third_simd(std::vector<int> l){\n    size_t n = l.size();\n    size_t vl = svquery_vl(); // Get the vector length\n    size_t elements_per_vector = vl / sizeof(int);\n    std::vector<int> result(n, 0);\n\n    for (size_t i = 0; i < n; i += elements_per_vector) {\n        size_t chunk_size = std::min(elements_per_vector, n - i);\n        svint32_t vec_in = svld1((const int *)(&l[i]));\n        svint32_t vec_out = svdup_s32(0);\n        svbool_t pg = svwhilelt_b32(0, chunk_size);\n\n        // Extract every third element\n        svint32_t every_third = svundef_s32();\n        svint32_t indices = svindex_s32(0, 1);\n        svint32_t mask = svcmpeq_s32(indices, svdup_s32(3));\n        for (int j = 0; j < 3; j++) {\n            svbool_t pg_j = svand_b32(pg, svcmpne_s32(indices, svdup_s32(j)));\n            every_third = svptrue_b32() ? svsel_s32(every_third, svundef_s32(), pg_j) : every_third;\n        }\n\n        // Sort the extracted elements\n        svint32_t sorted_thirds = svsort_s32(every_third);\n\n        // Place sorted thirds back into output vector\n        svst1_s32((int *)(&result[i]), svsel_s32(vec_in, sorted_thirds, mask));\n\n        // Copy non-third elements directly\n        svst1_s32((int *)(&result[i]), svsel_s32(vec_in, vec_out, svnot_b32(mask)));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> sort_third_simd(std::vector<int> l){\n    size_t n = l.size();\n    size_t vl = svquery_vl(); // Get the vector length\n    size_t elements_per_vector = vl / sizeof(int);\n    std::vector<int> result(n, 0);\n\n    for (size_t i = 0; i < n; i += elements_per_vector) {\n        size_t chunk_size = std::min(elements_per_vector, n - i);\n        svint32_t vec_in = svld1((const int *)(&l[i]));\n        svint32_t vec_out = svdup_n_s32(0);\n\n        // Extract every third element\n        svbool_t p = svwhilelt_b32(0, chunk_size);\n        svint32_t indices = svindex_b32(p);\n        svint32_t mask = svcmpeq_w32(indices, svtrue_n_u32(0));\n        svint32_t selected = svsel_s32(mask, svundef_s32(), vec_in);\n\n        // Sort the selected elements\n        svint32_t sorted = svsort_s32(selected);\n\n        // Place sorted elements back into their positions\n        svst1_s32((int *)(&result[i]), svsel_s32(mask, sorted, svundef_s32()));\n\n        // Copy non-third elements directly\n        svst1_s32((int *)(&result[i]), svsel_s32(svcmpeq_w32(indices, svtrue_n_u32(0)), svundef_s32(), vec_in));\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result(n);\n    svbool_t pg = svwhilelt_b32(0, n);\n\n    // Load input vector\n    svint32_t vec_in = svld1_gather_index(pg, l.data(), svindex_b32(0, 1, 1));\n\n    // Extract elements at indices divisible by 3\n    svbool_t pg_mod3 = svcmpeq_n_b32(svindex_b32(0, 1, 1), 3);\n    svint32_t vec_mod3 = svundef_b32();\n    svptrue_b32(pg_mod3);\n    svextgatherindex(pg_mod3, vec_mod3, svindex_b32(0, 1, 1), 3);\n\n    // Sort the extracted elements\n    svint32_t vec_sorted = svsort(pg_mod3, vec_mod3);\n\n    // Scatter the sorted elements back into their original positions\n    svst1_scatter_index(pg_mod3, result.data(), svindex_b32(0, 1, 1), vec_sorted);\n\n    // Copy remaining elements unchanged\n    svst1_gather_index(pg, result.data(), svindex_b32(0, 1, 1), vec_in);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> sort_third_simd(std::vector<int> l){\n    size_t n = l.size();\n    std::vector<int> result(n);\n    svbool_t pg = svwhilelt_b(n, 0);\n\n    // Load input vector\n    svint32_t vec_in = svld1(pg, l.data());\n\n    // Create a mask for indices divisible by three\n    svbool_t pg_div3 = svcmpeq_m(pg, pg, svindex_u32(0, 1), svcreate_with_rne(3));\n\n    // Extract elements at indices divisible by three\n    svint32_t vec_div3 = svundef_h();\n    svint32_t vec_remain = svundef_h();\n    svsplit_m(pg_div3, vec_in, &vec_div3, &vec_remain);\n\n    // Sort the extracted elements\n    svint32_t vec_div3_sorted = svsort(vec_div3);\n\n    // Merge sorted elements back into their original positions\n    svint32_t vec_out = svmerge_m(pg_div3, vec_div3_sorted, vec_remain);\n\n    // Store the result\n    svst1(pg, result.data(), vec_out);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```c\n#include <arm_sve.h>\n\nfloat max_element_simd(std::vector<float> l) {\n    size_t n = l.size();\n    svfloat32_t max_val = svdup_n_f32(-INFINITY);\n    for (size_t i = 0; i < n; i += svcntd()) {\n        svfloat32_t vec = svld1_f32(l.data() + i);\n        svbool_t p = svwhilelt_b32(i, n);\n        max_val = svmax_v(p, max_val, vec);\n    }\n    return svcvt_f32_s32(svmaxv_b32(max_val));\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```c\n#include <arm_sve.h>\n\nfloat max_element_simd(std::vector<float> l) {\n    svlen_t vl = svquery_vl();\n    size_t n = l.size();\n    float max_val = l[0];\n    svfloat32_t vec;\n    svfloat32_t max_vec = svindex_u32(0, 0);\n\n    for (size_t i = 0; i < n; i += vl) {\n        vec = svld1_v(svptrue_b32(), &l[i]);\n        max_vec = svmax_v(max_vec, vec, svptrue_b32());\n    }\n\n    svint32_t idx = svcreate_u32(0);\n    svbool_t p_last = svwhilelt_b32(idx, vl);\n    while (svptest_any(svptrue_b32(), p_last)) {\n        max_val = svget_gather_scalar_f32(max_vec, idx, p_last);\n        idx = svnext_u32(idx, p_last);\n        p_last = svwhilelt_b32(idx, vl);\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```c\n#include <arm_sve.h>\n\nfloat max_element_simd(std::vector<float> l) {\n    svbool_t pg = svwhilelt_b32(0, l.size());\n    svfloat32_t vec = svld1(pg, l.data());\n    svfloat32_t max_val = svmaxv(pg, vec);\n    return svcvt_f32_s32(svget_h_b32(max_val, 0));\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```c\n#include <arm_sve.h>\n\nfloat max_element_simd(std::vector<float> l) {\n    size_t n = l.size();\n    svfloat32_t max_val = svdup_n_f32(-INFINITY);\n    size_t i = 0;\n\n    while (i < n) {\n        size_t len = n - i;\n        svfloat32_t vec = svld1_f32(l.data() + i);\n        svbool_t pg = svwhilelt_b32(0, len);\n        max_val = svmax_v(pg, max_val, vec);\n        i += svcntd();\n    }\n\n    return svmax_n_f32(max_val);\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```c\nfloat max_element_simd(std::vector<float> l){\n    svfloat_t max_val = svdup_n_f32(-FLT_MAX);\n    svfloat_t vec;\n    size_t i = 0;\n    size_t len = l.size();\n    \n    while(i < len){\n        size_t n = len - i;\n        if(n >= svcntm()){\n            vec = svld1_f32(l.data() + i);\n            max_val = svmax_v_f32(max_val, vec);\n            i += svcntm();\n        }\n        else{\n            vec = svld1_f32(l.data() + i);\n            max_val = svmax_v_f32(max_val, vec);\n            break;\n        }\n    }\n    return svcvt_f32_s32(svmaxv_s32_s32(svreinterpret_s32_f32(max_val)));\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint fizz_buzz_simd(int n){\n    svbool_t p = svwhilelt_b32(0, n);\n    int count = 0;\n    svint32_t indices = svindex_b32(0, 1);\n    svuint32_t sevens = svdup_n_u32(7);\n\n    while(svptest_any(p)){\n        svint32_t nums = svmla_x(p, indices, svindex_b32(11, 1));\n        nums = svmla_x(p, nums, svindex_b32(13, 1));\n        svbool_t div_by_11_or_13 = svcmpeq_m(p, p, nums, svindex_b32(0, 1));\n        \n        svbool_t has_seven = svcmpeq_m(p, p, svabs_x(p, nums), sevens);\n        svbool_t has_seven_or_div = svorr_m(p, p, div_by_11_or_13, has_seven);\n        \n        count += svcntd() - svcntp_b32(has_seven_or_div);\n        p = svptrue_b32();\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint fizz_buzz_simd(int n){\n    svbool_t p = svwhilelt_b32(0, n);\n    int count = 0;\n    svint32_t sevens = svindex_u32(p, 7);\n    svuint32_t mask_7 = svcmpeq_n_u32(sevens, '7');\n    \n    for(int i = 0; i < n; i += svcntw()){\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t vals = svindex_u32(pg, i);\n        svuint32_t mod11 = svcmpeq_n_u32(svmod_n_u32(vals, 11), 0);\n        svuint32_t mod13 = svcmpeq_n_u32(svmod_n_u32(vals, 13), 0);\n        svbool_t cond = svorr_b32(mod11, mod13);\n        \n        svuint32_t digits = svuzp1_u8(svreinterpret_u8_u32(vals));\n        svbool_t has_seven = svptrue_b32();\n        for(int d = 0; d < 4; d++){\n            svbool_t pg_d = svwhilelt_b32(d, 4);\n            svbool_t match = svcmpeq_n_u8(digits, '7');\n            has_seven = svorr_b32(has_seven, svand_b32(pg_d, match));\n            digits = svcircright_n_u8(digits, 1);\n        }\n        \n        svbool_t seven_cond = svcmpeq_b32(has_seven, mask_7);\n        svbool_t final_cond = svand_b32(cond, seven_cond);\n        count += svcntd() - svcntz_v(svpred_b64(final_cond));\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```c\nint fizz_buzz_simd(int n){\n    int count = 0;\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t indices = svindex_b32(0, 1);\n    svint32_t nums = svadd_n_s32(indices, 1); // Start from 1\n    svbool_t mask = svcmpeq_n_s32(nums, n);\n\n    while(!svptest_any(svptrue_b32(), mask)){\n        svint32_t divisible_by_11 = svcmpeq_n_s32(svmod_s32(nums, svdup_n_s32(11)), 0);\n        svint32_t divisible_by_13 = svcmpeq_n_s32(svmod_s32(nums, svdup_n_s32(13)), 0);\n        svbool_t divisible = svorr_v_b32(divisible_by_11, divisible_by_13);\n\n        svint32_t num_str[4];\n        for(int i=0; i<4; i++) {\n            num_str[i] = svsub_n_s32(nums[i], svdup_n_s32('0'));\n        }\n\n        svbool_t has_seven = svorr_v_b32(\n            svcmpeq_n_s32(num_str[0], '7'),\n            svorr_v_b32(\n                svcmpeq_n_s32(num_str[1], '7'),\n                svorr_v_b32(\n                    svcmpeq_n_s32(num_str[2], '7'),\n                    svcmpeq_n_s32(num_str[3], '7')\n                )\n            )\n        );\n\n        count += svcntd() * svcntb(svand_v_b32(divisible, has_seven));\n\n        indices = svadd_n_s32(indices, svcntd());\n        nums = svadd_n_s32(nums, svcntd());\n        mask = svcmpeq_n_s32(nums, n);\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint fizz_buzz_simd(int n){\n    svbool_t p = svwhilelt_b32(0, n);\n    int count = 0;\n    svint32_t indices = svindex_b32(0, 1);\n    svuint32_t sevens = svdup_n_u32(7);\n    svbool_t isn11 = svcmpeq_n_u32(svdiv_u32(indices, svdup_n_u32(11)), svsub_u32(indices, svdiv_u32(indices, svdup_n_u32(11))));\n    svbool_t isn13 = svcmpeq_n_u32(svdiv_u32(indices, svdup_n_u32(13)), svsub_u32(indices, svdiv_u32(indices, svdup_n_u32(13))));\n    svbool_t isdiv = svorr_v(p, isn11, isn13);\n    svuint32_t digits = svmod_u32(indices, svdup_n_u32(10));\n    svbool_t has_seven = svcmpeq_n_u32(digits, sevens);\n    svbool_t valid_indices = svand_v(p, isdiv, has_seven);\n    count += svcntd() - svcntp(valid_indices);\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint fizz_buzz_simd(int n){\n    svbool_t p = svwhilelt_b32(0, n);\n    int count = 0;\n    svint32_t indices = svindex_b32(0, 1);\n    svuint32_t sevens = svdup_n_u32(7);\n    svbool_t isn11 = svcmpeq_n_u32(svdiv_u32(indices, svdup_n_u32(11)), svsub_u32(indices, svdiv_u32(indices, svdup_n_u32(11))));\n    svbool_t isn13 = svcmpeq_n_u32(svdiv_u32(indices, svdup_n_u32(13)), svsub_u32(indices, svdiv_u32(indices, svdup_n_u32(13))));\n    svbool_t mask = svorr_v(p, isn11, isn13);\n    svint32_t digits = svabs_s32(svsub_s32(indices, svsmul_s32(svdiv_s32(indices, svdup_n_s32(10)), svdup_n_s32(10))));\n    svbool_t seven_mask = svcmpeq_n_u32((svuint32_t)digits, sevens);\n    while(svptest_any(svptrue_b32(), mask)){\n        count += svcntd() - svcntp_b32(mask);\n        mask = svptrue_b32();\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    std::vector<float> result(n);\n    svbool_t pg = svwhilelt_b(n);\n\n    // Load the input vector into a scalable vector\n    svfloat32_t vec_in = svld1(pg, l.data());\n\n    // Extract even-indexed elements\n    svfloat32_t even = svuzp1(vec_in, vec_in);\n\n    // Sort the even-indexed elements\n    svfloat32_t sorted_even = svsort(even);\n\n    // Extract odd-indexed elements\n    svfloat32_t odd = svuzp2(vec_in, vec_in);\n\n    // Interleave sorted even and original odd elements\n    svfloat32_t vec_out = svzip1(sorted_even, odd);\n\n    // Store the result back into the output vector\n    svst1(pg, result.data(), vec_out);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    std::vector<float> result(n);\n    \n    // Convert input vector to sve type\n    svfloat32_t input = svld1_sve_f32(l.data());\n    svfloat32_t sorted_evens;\n\n    // Extract even indices\n    svfloat32_t evens = svtrn1q_sve_f32(input, input);\n\n    // Sort the even indices\n    sorted_evens = svsortq_f32(evens);\n\n    // Extract odd indices\n    svfloat32_t odds = svtrn2q_sve_f32(input, input);\n\n    // Interleave sorted evens and odds\n    svbool_t pg = svwhilelt_b32(0, n);\n    svst1_sve_f32(result.data(), pg, svzip1q_sve_f32(sorted_evens, odds));\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    std::vector<float> result(n);\n    \n    // Convert input vector to sve type\n    svfloat32_t input = svld1_sve_f32(l.data());\n    svfloat32_t sorted_evens;\n\n    // Extract even indices\n    svfloat32_t evens = svtrn1q_sve_f32(input, input);\n\n    // Sort the even indices\n    sorted_evens = svsortq_f32(evens);\n\n    // Extract odd indices\n    svfloat32_t odds = svtrn2q_sve_f32(input, input);\n\n    // Interleave sorted evens and odds\n    svfloat32_t interleaved = svzipq_sve_f32(sorted_evens, odds);\n\n    // Store the result back to memory\n    svst1_sve_f32(result.data(), interleaved);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    std::vector<float> result(n);\n    \n    // Convert input vector to sve type\n    svfloat32_t input = svld1_sve_f32(l.data());\n    svfloat32_t sorted_evens;\n\n    // Extract even indices\n    svfloat32_t evens = svtrn1q_sve_f32(input, input);\n\n    // Sort the even indices\n    sorted_evens = svsortq_f32(evens);\n\n    // Extract odd indices\n    svfloat32_t odds = svtrn2q_sve_f32(input, input);\n\n    // Interleave sorted evens and odds back into the result\n    svst1_sve_f32(result.data(), svzipq_sve_f32(sorted_evens, odds));\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    std::vector<float> result(n);\n    \n    // Convert input vector to sve type\n    svfloat32_t input = svld1_sve_f32(l.data());\n    svfloat32_t sorted_evens;\n\n    // Extract even indices\n    svfloat32_t evens = svundef_f32();\n    svfloat32_t odds = svundef_f32();\n    for (size_t i = 0; i < n; i += 2) {\n        svbool_t p = svwhilelt_b32(i, n);\n        evens = svsel_f32(p, svld1_lane_f32(l.data() + i, evens, i/2), evens);\n        if (i+1 < n) {\n            odds = svsel_f32(p, svld1_lane_f32(l.data() + i + 1, odds, i/2), odds);\n        }\n    }\n\n    // Sort even indices\n    sorted_evens = svsort_f32(evens);\n\n    // Interleave sorted evens with odds\n    svfloat32_t output = svundef_f32();\n    for (size_t i = 0; i < n; i += 2) {\n        svbool_t p = svwhilelt_b32(i, n);\n        output = svptrue_b32(p);\n        output = svsel_f32(output, svld1_lane_f32(sorted_evens, output, i/2), svsel_f32(output, svdup_n_f32(0.0f), odds));\n    }\n\n    // Store the result back into the vector\n    svst1_sve_f32(result.data(), output);\n    return result;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool triples_sum_to_zero_simd(std::vector<int> l){\n    size_t n = l.size();\n    if(n < 3) return false;\n    \n    svint32_t vec_in[sve_len / sizeof(int)];\n    svint32_t sums[sve_len / sizeof(int)];\n    svbool_t p;\n\n    // Load data into SVE vectors\n    for(size_t i = 0; i < n; i += sve_len / sizeof(int)){\n        p = svwhilelt_b32(i, n);\n        svld1_v(vec_in, p, l.data() + i);\n        \n        // Generate all combinations of three distinct elements\n        for(size_t j = 0; j < sve_len / sizeof(int); j++){\n            svint32_t v1 = svundef_b32();\n            svint32_t v2 = svundef_b32();\n            svint32_t v3 = svundef_b332();\n            \n            for(size_t k = 0; k < sve_len / sizeof(int); k++){\n                if(k != j){\n                    v1 = svptrue_b32();\n                    v2 = svptrue_b32();\n                    v3 = svptrue_b32();\n                    \n                    // Check if sum equals zero\n                    sums[k] = svaddv(sveor3(v1, v2, v3));\n                    if(svcmpeq_b32(p, sums[k], svindexm_b32(0, sve_len))){\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 3) return false;\n\n    // Convert std::vector to sve_int32_t\n    sve_int32_t vec = svld1(svptrue_b32(), l.data());\n\n    // Create a predicate vector for all elements being true initially\n    svbool_t pg = svptrue_b32();\n\n    // Iterate over all combinations of three distinct elements\n    for (size_t i = 0; i < n - 2; ++i) {\n        sve_int32_t v_i = svdup_gather_indices(svptrue_b32(), vec, svindex_s32(i));\n        for (size_t j = i + 1; j < n - 1; ++j) {\n            sve_int32_t v_j = svdup_gather_indices(svptrue_b32(), vec, svindex_s32(j));\n            for (size_t k = j + 1; k < n; ++k) {\n                sve_int32_t v_k = svdup_gather_indices(svptrue_b32(), vec, svindex_s32(k));\n\n                // Check if the sum of the three elements is zero\n                svbool_t pred = svcmpeq_n_s32(svadd(v_i, v_j), -svget_s32(v_k, 0));\n                if (svptest_any(pg, pred)) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```c\nbool triples_sum_to_zero_simd(std::vector<int> l){\n    svbool_t pg = svwhilelt_b32(0, l.size());\n    svint32_t vec = svld1(pg, l.data());\n    size_t n = l.size();\n    for(size_t i = 0; i < n-2; i+=svcntw()){\n        svbool_t pg_inner = svwhilelt_b32(i, n);\n        svint32_t vec_i = svld1(pg_inner, l.data()+i);\n        for(size_t j = i+1; j < n-1; j+=svcntw()){\n            svint32_t vec_j = svld1(pg_inner, l.data()+j);\n            svint32_t sum = svadd_x(pg_inner, vec_i, vec_j);\n            for(size_t k = j+1; k < n; k+=svcntw()){\n                svint32_t vec_k = svld1(pg_inner, l.data()+k);\n                svint32_t total = svadd_x(pg_inner, sum, vec_k);\n                svbool_t cond = svcmpeq_n_s32(total, 0);\n                if(svmovb(cond)){\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```c\nbool triples_sum_to_zero_simd(std::vector<int> l){\n    svbool_t pg = svwhilelt_b32(0, l.size());\n    svint32_t vec = svld1(pg, l.data());\n    size_t n = l.size();\n    for(size_t i = 0; i < n-2; i+=svcntw()){\n        svint32_t window = svld1(pg, &l[i]);\n        svbool_t mask = svcmpeq_m(pg, svindex_b32(0, svcntw()), window);\n        svbool_t found = svptrue_b32();\n        for(size_t j = i+1; j < n-1; j+=svcntw()){\n            svint32_t other = svld1(pg, &l[j]);\n            svint32_t sum = svadd_x(pg, window, other);\n            svbool_t match = svcmpeq_m(pg, sum, svneg_x(pg, window));\n            found = svorr_b32(found, match);\n            if(svmaybe_b32(found)){\n                return true;\n            }\n        }\n        if(svmaybe_b32(found)){\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 3) return false;\n\n    // Convert std::vector<int> to sve_int32_t\n    sve_int32_t vec;\n    memcpy((void *)&vec, l.data(), n * sizeof(int));\n\n    // Initialize mask for result\n    svbool_t p = svwhilelt_b32(0, n);\n\n    // Iterate over all combinations of three distinct indices\n    for (size_t i = 0; i < n - 2; i++) {\n        sve_int32_t v_i = svdup_gather_indices_s32(p, vec, i);\n        for (size_t j = i + 1; j < n - 1; j++) {\n            sve_int32_t v_j = svdup_gather_indices_s32(p, vec, j);\n            for (size_t k = j + 1; k < n; k++) {\n                sve_int32_t v_k = svdup_gather_indices_s32(p, vec, k);\n                sve_int32_t sum = svadd_s32(v_i, svadd_s32(v_j, v_k));\n                svbool_t match = svcmpeq_m_b32(p, svfalse_b32(), sum, svdup_s32(0));\n                if (svptest_any(p, match)) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result(n);\n    svlen = svcntb() * 8; // Get the vector length in elements\n\n    for (size_t i = 0; i < n; i += svlen) {\n        size_t len = (n - i >= svlen) ? svlen : n - i;\n        svint32_t vec_in = svld1((const int *)(&l[i]));\n        svint32_t vec_out = svadd_x(svptrue_b32(), vec_in, svcreate_i32(1));\n        svst1((int *)(&result[i]), vec_out);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result(n);\n    svlen = svcntb() * 8; // Determine the vector length\n\n    for (size_t i = 0; i < n; i += svlen) {\n        size_t len = (n - i >= svlen) ? svlen : n - i;\n        svint32_t vec_in = svld1((const int *)(&l[i]));\n        svint32_t vec_out = svadd_x(svptrue_b32(), vec_in, svcreate_i32(1));\n        svst1((int *)(&result[i]), vec_out);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result(n);\n    svlen = svcntb() * 8; // Determine the vector length\n\n    for (size_t i = 0; i < n; i += svlen) {\n        size_t len = (n - i >= svlen) ? svlen : n - i;\n        svint32_t vec_in = svld1((const int *)(&l[i]));\n        svint32_t vec_out = svundef_s32();\n        svaddv(vec_out, vec_in, svcreate_s32(1));\n        svst1((int *)(&result[i]), vec_out);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result(n);\n    svlen = svcntb() * 8; // Determine the vector length\n\n    for (size_t i = 0; i < n; i += svlen) {\n        size_t len = (n - i >= svlen) ? svlen : n - i;\n        svint32_t vec_in = svld1((const int *)(&l[i]));\n        svint32_t vec_out = svadd_n_s32(vec_in, 1);\n        svst1((int *)(&result[i]), vec_out);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result(n);\n    svlen = svcntb() * 8; // Get the vector length in elements\n\n    for (size_t i = 0; i < n; i += svlen) {\n        size_t len = (n - i >= svlen) ? svlen : n - i;\n        svint32_t vec_in = svld1((const int *)(&l[i]));\n        svint32_t vec_out = svadd_x(svptrue_b32(), vec_in, svcreate_i32(1));\n        svst1((int *)(&result[i]), vec_out);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <std_vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l){\n    size_t n = l.size();\n    if(n < 2) return false;\n    \n    // Convert std::vector to svint32_t\n    svint32_t vec_in[sve_len / sizeof(int)];\n    for(size_t i = 0; i < n; i += sve_len / sizeof(int)){\n        size_t len = std::min<size_t>(sve_len / sizeof(int), n - i);\n        svld1_x(sve_len / sizeof(int), vec_in, &l[i]);\n    }\n    \n    // Create a mask for all elements\n    svbool_t pg_all = svwhilelt_b32(0, n);\n    \n    // Iterate over pairs\n    for(size_t i = 0; i < n - 1; i += sve_len / sizeof(int)){\n        svbool_t pg_i = svwhilelt_b32(i, n);\n        svint32_t v1 = svld1(pg_i, vec_in + i);\n        \n        for(size_t j = i + 1; j < n; j += sve_len / sizeof(int)){\n            svbool_t pg_j = svwhilelt_b32(j, n);\n            svint32_t v2 = svld1(pg_j, vec_in + j);\n            \n            svbool_t mask = svcmpeq_m(pg_all, pg_all, v1, svneg_v(v2, svint32_t{0}));\n            if(svptest_any(mask)){\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```c\nbool pairs_sum_to_zero_simd(std::vector<int> l){\n    size_t n = l.size();\n    if(n < 2) return false;\n    \n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t vec = svld1(pg, l.data());\n    size_t vl = svcntd();\n\n    for(size_t i=0; i<n; i+=vl){\n        svint32_t current = svundef_b32();\n        svint32_t target = svundef_b32();\n        svptrue_b32(pg);\n\n        if(i + vl <= n){\n            current = svld1(pg, l.data() + i);\n            target = svneg_v(current, pg);\n            svbool_t found = svcmpeq_m(pg, pg, current, target);\n            if(svpred_b32(found)){\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <std_vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l){\n    size_t n = l.size();\n    if(n < 2) return false;\n    \n    // Convert std::vector to sve_int32_t\n    sve_int32_t vec = svld1(svptrue_b32(), l.data());\n    size_t vl = svcntd();\n\n    // Create a predicate for the vector length\n    svbool_t pg = svptrue_b32();\n\n    // Generate all unique pairs\n    for(size_t i=0; i<n-1; i+=vl){\n        sve_int32_t v1 = svundef_b32();\n        sve_int32_t v2 = svundef_b32();\n        \n        // Load next vl elements into v1\n        if(i+vl <= n){\n            v1 = svld1(pg, l.data() + i);\n        }\n        else{\n            v1 = svld1_n(pg, l.data() + i, n-i);\n            pg = svptrue_b32_n(n-i);\n        }\n\n        // Load remaining elements into v2\n        for(size_t j=i+1; j<n; j+=vl){\n            sve_int32_t v2_temp = svundef_b32();\n            \n            if(j+vl <= n){\n                v2_temp = svld1(pg, l.data() + j);\n            }\n            else{\n                v2_temp = svld1_n(pg, l.data() + j, n-j);\n                pg = svptrue_b32_n(n-j);\n            }\n\n            // Check for pairs that sum to zero\n            svbool_t pred = svcmpeq_m(pg, svadd_x(pg, v1, v2_temp), svdup_x(pg, 0));\n            if(svptest_any(pred)){\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <std_vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l){\n    size_t n = l.size();\n    if(n < 2) return false;\n    \n    // Convert std::vector to svint32_t\n    svint32_t vec_in[sve_len / sizeof(int)];\n    for(size_t i = 0; i < n; i += sve_len / sizeof(int)){\n        size_t len = std::min<size_t>(sve_len / sizeof(int), n - i);\n        svld1_xn((svuint8_t*)vec_in, &l[i], len);\n    }\n    \n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t mask = svindex_b32(0, 1);\n    \n    for(size_t i = 0; i < n; i += sve_len / sizeof(int)){\n        svint32_t chunk = svld1(pg, vec_in + i);\n        svint32_t neg_chunk = svneg_v(chunk);\n        svbool_t found = svcmpeq_m(pg, pg, chunk, neg_chunk);\n        if(svptest_any(pg, found)){\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <std_vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l){\n    size_t n = l.size();\n    if(n < 2) return false;\n    \n    // Convert std::vector to svint32_t\n    svint32_t vec_in[sve_len / sizeof(int)];\n    for(size_t i = 0; i < n; i += sve_len / sizeof(int)){\n        size_t len = std::min(sve_len / sizeof(int), n - i);\n        svld1_xn((svint32_t*)vec_in, l.data() + i, len);\n    }\n    \n    // Create a mask for all elements\n    svbool_t pg_all = svwhilelt_b32(0, n);\n    \n    // Iterate over pairs\n    for(size_t i = 0; i < n - 1; i += sve_len / sizeof(int)){\n        svbool_t pg_i = svwhilelt_b32(i, n);\n        svint32_t vec_a = svld1(pg_i, vec_in);\n        \n        for(size_t j = i + 1; j < n; j += sve_len / sizeof(int)){\n            svbool_t pg_j = svwhilelt_b32(j, n);\n            svint32_t vec_b = svld1(pg_j, vec_in);\n            \n            svint32_t sum = svadd_x(pg_i & pg_j, vec_a, vec_b);\n            svbool_t found = svcmpeq_z(pg_i & pg_j, sum, svdup_n_s32(0));\n            \n            if(svmad_b_z(pg_all, found, svtrue_b32())){\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <string>\n#include <sstream>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    // Ensure base is between 2 and 9\n    if (base < 2 || base > 9) {\n        return \"\";\n    }\n\n    size_t vec_size = sve_len_n / 64; // Vector length in quadwords\n    size_t num_digits = 0;\n    std::vector<int8_t> digits;\n\n    while (x != 0) {\n        svint8_t rem = svmod_s(vdupq_n_s64(x), vdupq_n_s64(base));\n        svbool_t pg = svwhilelt_b8(0, vec_size);\n        digits.insert(digits.begin(), svget_gather_z(pg, rem, 0));\n        x = svdiv_s(vdupq_n_s64(x), vdupq_n_s64(base));\n    }\n\n    std::ostringstream oss;\n    for (auto digit : digits) {\n        oss << static_cast<char>('0' + digit);\n    }\n    return oss.str();\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <string>\n#include <sstream>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    // Ensure base is between 2 and 9\n    if (base < 2 || base > 9) {\n        return \"\";\n    }\n\n    size_t len = 0;\n    svbool_t pg = svwhilelt_b64(len, 64); // Assuming max length of 64 characters\n\n    // Initialize vectors\n    svint64_t num = svdup_n_s64(x);\n    svint64_t current_base = svdup_n_s64(base);\n    svint64_t result_digits = svdup_n_s64(0);\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svint64_t remainder = svmod_s64(pg, num, current_base);\n        result_digits = svadd_s64(pg, result_digits, svmul_s64(pg, remainder, sv\u6307\u6570(base, len)));\n        num = svdiv_s64(pg, num, current_base);\n        len++;\n        pg = svwhilelt_b64(len, 64);\n    }\n\n    // Convert digits back to string\n    std::ostringstream oss;\n    for (size_t i = 0; i < len; ++i) {\n        oss << static_cast<char>('0' + result_digits[i]);\n    }\n    return oss.str();\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <string>\n#include <sstream>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    // Determine the maximum vector length\n    size_t vl = svquery_vl();\n\n    // Convert x to a vector of integers\n    svint64_t vec_x = svdup_n_s64(x);\n    \n    // Initialize result vectors\n    svint64_t remainders = svdup_n_s64(0);\n    svbool_t pg = svwhilelt_b64(0, vl);\n\n    std::ostringstream oss;\n\n    while (svcmpeq_b64(pg, svdup_n_b64(0))) {\n        // Compute remainders\n        remainders = svmod_s64(vec_x, svdup_n_s64(base), pg);\n        \n        // Convert remainders to characters\n        svuint8_t chars = svsub_u8(svindex_u8(0, '0'), svreinterpret_u8_s8(remainders));\n        \n        // Store characters to output stream\n        for (size_t i = 0; i < vl; ++i) {\n            if (svptest_any_b64(pg, svwhilelt_b64(i, vl))) {\n                oss << static_cast<char>(chars[i]);\n            }\n        }\n\n        // Update vec_x by integer division\n        vec_x = svdiv_s64(vec_x, svdup_n_s64(base));\n        \n        // Check if all elements are zero\n        if (svcmpeq_s64(vec_x, svdup_n_s64(0), pg)) {\n            break;\n        }\n    }\n\n    // Reverse the string since we computed digits in reverse order\n    std::string result = oss.str();\n    std::reverse(result.begin(), result.end());\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <string>\n#include <sstream>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    // Ensure base is between 2 and 9\n    if (base < 2 || base > 9) {\n        return \"\";\n    }\n\n    // Convert x to a vector of integers\n    svint64_t vec_x = svdup_n_s64(x);\n    svint64_t vec_base = svdup_n_s64(base);\n\n    // Initialize result vectors\n    svint64_t vec_digits = svdup_n_s64(0);\n    svbool_t pg = svwhilelt_b64(0, 64); // Assuming 64 digits max\n\n    // Perform base conversion in parallel\n    int digit_count = 0;\n    while (svcmpeq_m(pg, pg, vec_x, svdup_n_s64(0))) {\n        svint64_t remainder = svmod_s64(vec_x, vec_base);\n        vec_digits = svsel_b64(pg, svreinterpret_s64_u8(svashr_u8(svreinterpret_u64(remainder), svindex_u64(0, '0'))), vec_digits);\n        vec_x = svdiv_s64(vec_x, vec_base);\n        digit_count++;\n    }\n\n    // Collect results into a string\n    std::ostringstream oss;\n    for (int i = digit_count - 1; i >= 0; --i) {\n        oss << static_cast<char>(svget_s64(vec_digits, i) + '0');\n    }\n    return oss.str();\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <string>\n#include <sstream>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    // Ensure base is between 2 and 9\n    if (base < 2 || base > 9) {\n        return \"\";\n    }\n\n    size_t len = 0;\n    svbool_t pg = svwhilelt_b64(len, 64); // Assuming max length of 64 digits\n\n    // Initialize vectors\n    svint64_t num = svdup_n_s64(x);\n    svint64_t result_digits = svdup_n_s64(0);\n    svbool_t all_done = svcmpeq_b64(pg, num, svdup_n_s64(0));\n\n    while (!svptest_any(svptrue_b64(), all_done)) {\n        svint64_t remainder = svmod_s64(num, svdup_n_s64(base));\n        result_digits = svcadd_s64(result_digits, remainder, svptrue_b64());\n        num = svdiv_s64(num, svdup_n_s64(base));\n        all_done = svcmpeq_b64(pg, num, svdup_n_s64(0));\n    }\n\n    // Convert digits back to characters\n    std::ostringstream oss;\n    while (!svptest_any(svptrue_b64(), all_done)) {\n        svint64_t digit = svtrn1_s64(result_digits, result_digits);\n        char c = '0' + static_cast<char>(svgetlane_s64(digit, 0));\n        oss << c;\n        all_done = svptest_and(svptrue_b64(), all_done, svcmpeq_b64(pg, digit, svdup_n_s64(0)));\n    }\n\n    return oss.str();\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool is_palindrome_simd(std::string text){\n    size_t len = text.length();\n    svbool_t p = svwhilelt_b32(0, len);\n    \n    // Convert string to array of characters\n    uint8_t *text_ptr = reinterpret_cast<uint8_t*>(&text[0]);\n    svuint8_t v_text = svld1_u8(text_ptr, p);\n    \n    // Create reverse vector\n    svint32_t indices = svindex_u32(0, -1, 1);\n    svuint8_t v_text_rev = svqrev_u8(v_text, indices);\n    \n    // Compare original and reversed vectors\n    svbool_t eq = svcmpeq_u8(p, v_text, v_text_rev);\n    \n    return svptest_any_b32(svptrue_b32(), eq);\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <cstring>\n\nbool is_palindrome_simd(std::string text){\n    size_t len = text.length();\n    if(len <= 1) return true;\n\n    svbool_t p = svwhilelt_b64(0, len);\n    size_t half_len = (len + 1) / 2;\n    svbool_t half_p = svwhilelt_b64(0, half_len);\n\n    const char *str = text.c_str();\n\n    svbool_t match = svcmpeq_n_u8(svptrue_b64(), 0);\n\n    for(size_t i = 0; i < half_len; i += svcntw()){\n        svuint64_t indices = svindex_u64(i, 1);\n        svchar_t left = svld1_gather_index_b8(p, str, indices);\n        svchar_t right = svld1_gather_index_b8(p, str, svsub_x2(indices, svcreate_lane_u64(svptrue_b64(), len - 1, 0)));\n        match = svand_b8(match, svcmpeq_u8(p, left, right));\n    }\n\n    return svcnot_b64(svcmpne_b8(half_p, match, svtrue_b64()));\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```c\nbool is_palindrome_simd(std::string text){\n    svbool_t pg = svwhilelt_b32(0, text.size());\n    size_t len = text.size();\n    svbool_t all_match = svptrue_b32();\n\n    for(size_t i = 0; i < len; i += svlen_b32()){\n        svint32_t vec1 = svld1_gather_index_s32(pg, (const int32_t*)(&text[i]));\n        svint32_t vec2 = svrevb_s32(svld1_gather_index_s32(pg, (const int32_t*)(&text[len - i - 1])));\n        svbool_t match = svcmpeq_s32(pg, vec1, vec2);\n        all_match = svand_b32(all_match, match);\n    }\n\n    return svcnot_b32(all_match);\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```c\nbool is_palindrome_simd(std::string text){\n    svbool_t pg = svwhilelt_b32(0, text.size());\n    size_t len = text.size();\n    svbool_t all_match = svcmpne_b8(svld1(pg, (const char *)text.c_str()), svrev_b8(pg, svld1(pg, (const char *)text.c_str())));\n    return !svptest_any(svptrue_b32(), all_match);\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <cstring>\n\nbool is_palindrome_simd(std::string text){\n    size_t len = text.length();\n    if(len <= 1) return true;\n    \n    svbool_t p = svwhilelt_b64(0, len);\n    size_t half_len = (len + 1) / 2;\n    svbool_t half_p = svwhilelt_b64(0, half_len);\n\n    const char *str = text.c_str();\n\n    // Load first half of the string\n    svint8_t first_half = svld1_gather_index_s8(p, str, svindex_b64(p));\n\n    // Load second half of the string in reverse order\n    svint8_t second_half = svld1_gather_index_s8(p, str + len - 1, svindexr_b64(p, len - 1));\n\n    // Compare characters from both halves\n    svbool_t eq = svcmpeq_s8(half_p, first_half, second_half);\n\n    // All elements must be equal for it to be a palindrome\n    return svptest_any_b64(svptrue_b64(), eq);\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::string decode_shift_simd(std::string s){\n    size_t len = s.length();\n    size_t vec_len = svcntb() * 8 / sizeof(char); // Number of characters per vector\n    size_t i = 0;\n\n    // Create a vector for 'a' and 'z'\n    svbool_t pg = svwhilelt_b8(0, len);\n    svint8_t a_vec = svindex_u8_b8(0, 'a');\n    svint8_t z_vec = svindex_u8_b8(0, 'z');\n\n    std::string out;\n    out.reserve(len);\n\n    while(svptest_any(svptrue_b8(), pg)){\n        svint8_t chars = svld1(pg, (const int8_t*)s.data() + i);\n        svint8_t shifted = svsub_s8(chars, svptrue_b8(5));\n\n        // Clamp values back into the range [a,z]\n        svint8_t clamped = svmin_s8(svmax_s8(shifted, a_vec), z_vec);\n\n        svst1(pg, (int8_t*)out.data() + i, clamped);\n        i += vec_len;\n        pg = svwhilelt_b8(i, len);\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::string decode_shift_simd(std::string s){\n    size_t len = s.length();\n    size_t vec_len = svcntb() * 8; // Number of bytes in one vector\n    size_t i = 0;\n\n    // Create a vector for 'a' and 'z'\n    svint8_t vec_a = svindex_u8(0, 1);\n    svint8_t vec_z = svindex_u8(0, 1) + svptrue_b8();\n\n    // Initialize output buffer\n    std::string out;\n    out.reserve(len);\n\n    while (i + vec_len <= len) {\n        // Load vector\n        svuint8_t vec_in = svld1_u8((const uint8_t*)&s[i]);\n\n        // Decode shift operation\n        svint8_t vec_decoded = svsub_s8(vec_in, svptrue_b8(5));\n\n        // Clamp to 'a' to 'z'\n        vec_decoded = svmin_s8(vec_decoded, vec_z);\n        vec_decoded = svmax_s8(vec_decoded, vec_a);\n\n        // Store result\n        svst1_u8((uint8_t*)&out[i], svreinterpret_u8_s8(vec_decoded));\n\n        i += vec_len;\n    }\n\n    // Handle remaining characters\n    while (i < len) {\n        int w = ((int)s[i] - (int)'a' - 5 + 26) % 26 + (int)'a';\n        out += (char)w;\n        i++;\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\nstd::string decode_shift_simd(std::string s){\n    size_t len = s.length();\n    size_t vector_len = svcntb() * sizeof(uint8_t); // Get vector length in bytes\n    size_t i = 0;\n\n    // Create a vector for 'a' to use in calculations\n    svuint8_t base_a = svld1_u8((const uint8_t *) \"a\");\n\n    while (i + vector_len <= len) {\n        // Load vector from input string\n        svuint8_t vec_in = svld1_u8((const uint8_t *)(s.data() + i));\n\n        // Subtract 5 from each character (decode)\n        svuint8_t vec_out = svsub_u8(vec_in, svdup_n_u8(5));\n\n        // Handle wrap-around for lowercase letters ('a' to 'z')\n        svbool_t pg = svwhilelt_u8(vec_out, base_a);\n        vec_out = svcond_u8(vec_out, svadd_u8(vec_out, svdup_n_u8(26)), pg);\n\n        // Store the result back to output\n        svst1_u8((uint8_t *)(s.data() + i), vec_out);\n\n        i += vector_len;\n    }\n\n    // Handle remaining characters\n    while (i < len) {\n        s[i] = ((s[i] - 'a' - 5 + 26) % 26) + 'a';\n        i++;\n    }\n\n    return s;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::string decode_shift_simd(std::string s){\n    size_t len = s.length();\n    size_t vec_len = svcntb() * 8 / sizeof(char); // Number of characters per vector\n    size_t i = 0;\n\n    // Create a vector for 'a' to use in calculations\n    svint8_t a_vec = svindex_b8(0, 1);\n\n    // Convert 'a' to the appropriate type for vector operations\n    svint8_t shift_val = svcreate_b8((int8_t)(-(int)'a'));\n\n    // Allocate space for the result\n    std::string out(len, '\\0');\n\n    while (i + vec_len <= len) {\n        // Load vector from input string\n        svuint8_t in_vec = svld1_u8((const uint8_t*)&s[i]);\n\n        // Perform the shift operation\n        svint8_t temp_vec = svsub_s8(in_vec, shift_val);\n        svint8_t decoded_vec = svmod_s8(temp_vec, svcreate_b8(26));\n\n        // Store the result back into the output string\n        svst1_u8((uint8_t*)&out[i], decoded_vec);\n\n        i += vec_len;\n    }\n\n    // Handle remaining characters\n    while (i < len) {\n        out[i] = (char)(((s[i] - 'a' - 5 + 26) % 26) + 'a');\n        i++;\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::string decode_shift_simd(std::string s){\n    size_t len = s.length();\n    size_t vec_len = svcntb() * 8 / sizeof(char); // Number of characters per vector\n    size_t i = 0;\n\n    // Create a vector for 'a' and 'z'\n    svint8_t a_vec = svindex_b8_h(0, 1);\n    svint8_t z_vec = svindex_b8_h(0, 1);\n    a_vec = svmls(a_vec, a_vec, svindex_b8_h('a', 'a'));\n    z_vec = svmls(z_vec, z_vec, svindex_b8_h('a', 'a'));\n\n    svbool_t pg = svwhilelt_b8(0, len);\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svint8_t chars = svld1(pg, (const char*)&s[i]);\n        svint8_t shifted = svsub_s8(chars, svdup_n_s8(5));\n        svint8_t clamped = svmax_s8(shifted, a_vec);\n        clamped = svmin_s8(clamped, z_vec);\n\n        svst1(pg, (char*)&s[i], clamped);\n        i += svcntb() * svcntd();\n        pg = svwhilelt_b8(i, len);\n    }\n\n    return s;\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```c\nbool below_threshold_simd(int8_t *l, int t) {\n    svbool_t pg = svwhilelt_b8(0, svcntb());\n    svint8_t vec = svld1(pg, l);\n    svint8_t threshold = svdup_n_s8(t);\n    svbool_t result = svcmple_b8(vec, threshold);\n    return svptest_any(result);\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```c\nbool below_threshold_simd(int8_t *l, int t) {\n    svbool_t pg = svwhilelt_b8(0, svcntb());\n    svint8_t vec = svld1(pg, l);\n    svint8_t threshold = svdup_n_s8(t);\n    svbool_t result = svcmple_b8(vec, threshold);\n    return svptest_any(result);\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```c\nbool below_threshold_simd(int8_t *l, int t) {\n    svbool_t pg = svwhilelt_b8(0, svcntb());\n    svint8_t vec = svld1(pg, l);\n    svint8_t threshold = svdup_n_s8(t);\n    svbool_t result = svcmple_b8(vec, threshold);\n    return svptest_any(result);\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```c\nbool below_threshold_simd(int8_t *l, int t) {\n    svbool_t pg = svwhilelt_b8(0, svcntb());\n    svint8_t vec = svld1(pg, l);\n    svint8_t threshold = svdup_n_s8(t);\n    svbool_t result = svcmple_b8(vec, threshold);\n    return svptest_any(result);\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```c\nbool below_threshold_simd(int8_t *l, int t){\n    svbool_t pg = svwhilelt_b8(0, svcntb());\n    svint8_t vec = svld1(pg, l);\n    svint8_t threshold = svdup_n_s8(t);\n    svbool_t res = svcmple_b8(vec, threshold);\n    return svptest_any(res);\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```c\nbool correct_bracketing_simd(std::string brackets){\n    svbool_t pg = svwhilelt_b32(0, brackets.size());\n    svint8_t open_brackets = svld1_u8((const uint8_t *)\"<\", pg);\n    svint8_t close_brackets = svld1_u8((const uint8_t *)\">\", pg);\n    svint8_t chars;\n    svbool_t mismatch;\n    int balance = 0;\n\n    for (size_t i = 0; i < brackets.size(); i += svcntb()) {\n        chars = svld1_u8((const uint8_t *)brackets.c_str() + i, pg);\n        mismatch = svcmpeq_n_u8(chars, open_brackets);\n        balance += svcntb() - svcntp_b32(svand_b8(mismatch, pg));\n        mismatch = svcmpeq_n_u8(chars, close_brackets);\n        balance -= svcntb() - svcntp_b32(svand_b8(mismatch, pg));\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```c\nbool correct_bracketing_simd(std::string brackets){\n    svbool_t pg = svwhilelt_b32(0, brackets.size());\n    svint8_t open = svld1_u8((const uint8_t *)brackets.c_str(), pg);\n    svint8_t mask_open = svcmpestrm_b8(open, (svint8_t)svesplat_u8('<', pg), 0);\n    svint8_t mask_close = svcmpestrm_b8(open, (svint8_t)svesplat_u8('>', pg), 0);\n    svbool_t has_open = svcmpeq_n_u8(svadd_n_s8(svpopc_b8(mask_open), 1), svpopc_b8(mask_close));\n    return !svcnot_b32(has_open, pg);\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```c\nbool correct_bracketing_simd(std::string brackets){\n    svbool_t pg = svwhilelt_b32(0, brackets.size());\n    svint8_t open_brackets = svld1_u8((const uint8_t *)\"<\", pg);\n    svint8_t close_brackets = svld1_u8((const uint8_t *)\">\", pg);\n    svint8_t chars;\n    svbool_t mismatch;\n    int32_t balance = 0;\n\n    for (size_t i = 0; i < brackets.size(); i += svcntb()) {\n        chars = svld1_u8((const uint8_t *)brackets.c_str() + i, pg);\n        mismatch = svcmpeq_n_u8(chars, open_brackets);\n        balance += svcntb() * svcntp() * svcntb();\n        balance -= svcntb() * svcntp() * svcntb();\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```c\nbool correct_bracketing_simd(std::string brackets){\n    svbool_t pg = svwhilelt_b32(0, brackets.size());\n    svint8_t open_brackets = svld1_u8((const uint8_t *)\"<\", pg);\n    svint8_t close_brackets = svld1_u8((const uint8_t *)\">\", pg);\n    svint8_t chars;\n    svbool_t mismatch;\n    int count = 0;\n\n    for(size_t i = 0; i < brackets.size(); i += svcntb()){\n        pg = svwhilelt_b32(i, i + svcntb());\n        chars = svld1_u8((const uint8_t *)brackets.c_str() + i, pg);\n        mismatch = svcmpeq_n_u8(chars, open_brackets);\n        count += svcntb() - svcntp_b8(mismatch);\n        mismatch = svcmpeq_n_u8(chars, close_brackets);\n        count -= svcntb() - svcntp_b8(mismatch);\n    }\n\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```c\nbool correct_bracketing_simd(std::string brackets){\n    svbool_t pg = svwhilelt_b32(0, brackets.size());\n    svint8_t open = svld1_u8((const uint8_t *)brackets.c_str(), pg);\n    svint8_t mask_open = svcmpeq_n_s8(open, '<');\n    svint8_t mask_close = svcmpeq_n_s8(open, '>');\n    svbool_t any_open = svcntb(pg) > 0 ? svcntb(pg) : svptrue_b32();\n    svbool_t balanced = svcmpeq_n_s32(svaddv_b8(mask_open), svaddv_b8(mask_close));\n    return !svptest_any(svptrue_b32(), svand_b32(any_open, svnot_b32(balanced, pg)));\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <cstring>\n\nbool correct_bracketing_simd(const std::string& brackets) {\n    size_t len = brackets.size();\n    svbool_t pg = svwhilelt_b8(0, len);\n    \n    // Convert string to integer vector where '(' -> 1, ')' -> -1\n    svint8_t vec = svld1_u8((const uint8_t*)brackets.c_str(), pg);\n    vec = svsel_b8(vec, svdup_n_u8('('), svdup_n_u8(1));\n    vec = svsel_b8(vec, svdup_n_u8(')'), svdup_n_u8(-1));\n    \n    // Compute cumulative sum\n    svint8_t cum_sum = svmla_u8(svdup_n_u8(0), vec, pg);\n    \n    // Check if all elements in cumulative sum are non-negative\n    svbool_t all_non_negative = svcmpeq_m(pg, cum_sum, svdup_n_u8(0));\n    \n    // Check if final balance is zero\n    svbool_t final_balance_zero = svcmpeq_m(pg, cum_sum[len-1], svdup_n_u8(0));\n    \n    return (svptest_any(all_non_negative) && svptest_any(final_balance_zero));\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool correct_bracketing_simd(const char *brackets) {\n    size_t len = strlen(brackets);\n    svbool_t pg = svwhilelt_b((svint64_t)len);\n\n    svint64_t open_count = svdup_n_s64(0);\n    svbool_t error = svfalse_b();\n\n    for (size_t i = 0; i < len; i += svcntw()) {\n        svbool_t pg_i = svwhilelt_b(svindex_u64(0, i));\n        svint64_t c = svld1(pg_i, brackets + i);\n\n        svbool_t is_open = svcmpeq_n_s64(c, '(');\n        svbool_t is_close = svcmpeq_n_s64(c, ')');\n\n        open_count = svcond(is_open, svadd_x(open_count, 1, pg_i), \n                            svcond(is_close, svsub_x(open_count, 1, pg_i), open_count));\n\n        error = svorr(error, svand(is_close, svslt_x(open_count, 0, pg_i)));\n    }\n\n    return !svptest_any(error) && svcmpeq_n_s64(open_count, 0);\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <hwy/highway.h>\n#include <string>\n\nbool correct_bracketing_simd(const std::string& brackets) {\n    size_t len = brackets.size();\n    svbool_t pg = svwhilelt_b32(0, (int32_t)len);\n    svint8_t open_bracket = svld1_u8((const unsigned char*)\"( \");\n    svint8_t close_bracket = svld1_u8((const unsigned char*)\") \");\n\n    svint32_t balance = svdup_gather_u8((const unsigned char*)&brackets[0], svindex_u32(0, 1, 1));\n    balance = svsel_b32(pg, balance, svdup_n_u32(0));\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        pg = svwhilelt_b32(svget_lane_u32(balance, 0), (int32_t)len);\n        svint8_t current = svld1_u8((const unsigned char*)&brackets[svget_lane_u32(balance, 0)], pg);\n        svbool_t is_open = svcmpeq_n_u8(current, open_bracket);\n        svbool_t is_close = svcmpeq_n_u8(current, close_bracket);\n\n        balance = svadd_x_u32(balance, svcnot_b32(is_open, svtrue_b32()), pg);\n        balance = svsub_x_u32(balance, svcnot_b32(is_close, svtrue_b32()), pg);\n\n        balance = svsel_b32(pg, balance, svdup_n_u32(0));\n    }\n\n    return svcmpeq_n_u32(svmin_u32(balance, svtrue_u32()), 0);\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <cstring>\n\nbool correct_bracketing_simd(const std::string& brackets) {\n    size_t len = brackets.size();\n    svbool_t pg = svwhilelt_b8(0, len);\n    \n    // Convert string to integer vector where '(' -> 1, ')' -> -1\n    svint8_t vec = svld1_u8((const uint8_t*)brackets.c_str(), pg);\n    vec = svsel_b8(svcmpeq_n_u8(vec, '(':0), svindex_u8(0, 1, pg), svindex_u8(0, -1, pg));\n    \n    // Compute cumulative sum\n    svint8_t cumsum = svmla_low_s8(vec, svdup_n_s8(0), pg);\n    \n    // Check if all elements in cumsum are non-negative\n    svbool_t all_non_negative = svcmpeq_n_s8(cumsum, 0);\n    \n    // Check if final balance is zero\n    bool final_balance_zero = svlast_elem_u8(cumsum) == 0;\n    \n    return svptest_any_s8(pg, all_non_negative) && final_balance_zero;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <cstring>\n\nbool correct_bracketing_simd(const std::string& brackets) {\n    size_t len = brackets.size();\n    svbool_t pg = svwhilelt_b8(0, len);\n    svint8_t open = svld1_u8((const uint8_t*)brackets.c_str());\n    svint8_t mask_open = svcmpeq_n_s8(open, '(');\n    svint8_t mask_close = svcmpeq_n_s8(open, ')');\n    svint8_t balance = svdup_n_s8(0);\n    \n    do {\n        svbool_t pg_now = pg;\n        svint8_t new_balance = svadd_x_s8(svand_b8(pg_now, mask_open), balance, svsub_x_s8(svand_b8(pg_now, mask_close), balance));\n        balance = svcond_b8(pg_now, new_balance, balance);\n        pg = svsrl_b8(pg, svcntw());\n    } while (svptest_any(svptrue_b8(), pg));\n    \n    return svcmpeq_n_s8(balance, 0);\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    size_t n = xs.size();\n    if (n <= 1) {\n        return std::vector<float>();\n    }\n\n    size_t vector_length = svcntd() * sizeof(float) / sizeof(float);\n    size_t num_vectors = (n - 1 + vector_length - 1) / vector_length;\n\n    std::vector<float> result(n - 1);\n    for (size_t i = 0; i < num_vectors; ++i) {\n        size_t start = i * vector_length;\n        size_t end = std::min(start + vector_length, n);\n        size_t len = end - start;\n\n        float32xv_t coeffs = svld1q((float const *)(&xs[start]));\n        float32xv_t indices = svindexq_u32(0, 1);\n\n        float32xv_t deriv = svmlaq_n(coeffs, indices, 1);\n        svst1q((float *)(&result[start]), deriv);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    size_t n = xs.size();\n    if (n <= 1) {\n        return std::vector<float>();\n    }\n\n    size_t vector_length = svcntd() * sizeof(float) / sizeof(float);\n    size_t num_vectors = (n - 1 + vector_length - 1) / vector_length;\n\n    std::vector<float> result(n - 1);\n    for (size_t i = 0; i < num_vectors; ++i) {\n        size_t start = i * vector_length;\n        size_t end = std::min(start + vector_length, n);\n        size_t len = end - start;\n\n        svfloat_t coeffs = svld1q_f32(xs.data() + start);\n        svfloat_t indices = svindex_f32(1.0f, 1.0f);\n\n        svfloat_t deriv = svmla_x_f32(coeffs, indices, svindex_f32(0.0f, 1.0f));\n        svst1q_f32(result.data() + start, deriv);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs){\n    size_t n = xs.size();\n    if(n <= 1){\n        return std::vector<float>();\n    }\n    \n    size_t vector_length = svcntw(); // Get the vector length\n    size_t num_vectors = (n - 1 + vector_length - 1) / vector_length;\n    \n    svfloat32_t result_vec;\n    std::vector<float> result(n - 1);\n    \n    for(size_t i = 0; i < num_vectors; ++i){\n        size_t start = i * vector_length;\n        size_t end = std::min(start + vector_length, static_cast<size_t>(n));\n        size_t count = end - start;\n        \n        svfloat32_t input_vec = svld1((const float *)(&xs[start]));\n        svint32_t indices = svindex_s32(0, 1, count);\n        svfloat32_t multiplier = svdup_n_f32(1.0f);\n        svfloat32_t scaled_vec = svmla_f32(svindex_f32(indices), multiplier, input_vec);\n        \n        svst1((float *)(&result[start]), scaled_vec);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs){\n    size_t n = xs.size();\n    if(n <= 1){\n        return std::vector<float>();\n    }\n    \n    size_t vector_length = svcntw(); // Get the vector length\n    size_t elements = n - 1;\n    size_t vectors = (elements + vector_length - 1) / vector_length;\n\n    std::vector<float> result(elements);\n    svfloat_t* result_ptr = (svfloat_t*)result.data();\n\n    for(size_t i=0; i<vectors; ++i){\n        size_t start = i * vector_length;\n        size_t end = std::min(start + vector_length, static_cast<size_t>(elements));\n        size_t count = end - start;\n\n        svfloat_t coeffs;\n        svptrue_b32_t p = svptrue_b32();\n        \n        // Load coefficients\n        svld1(p, &xs[start+1], &coeffs);\n\n        // Multiply each coefficient by its index\n        coeffs = svmla_x(p, coeffs, svindex_b32(1,1), svindex_b32(0,count));\n\n        // Store the result\n        svst1(p, &result_ptr[i], coeffs);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    size_t n = xs.size();\n    if (n <= 1) {\n        return std::vector<float>();\n    }\n\n    size_t vector_length = svcntd() * sizeof(float) / sizeof(float);\n    size_t num_vectors = (n - 1 + vector_length - 1) / vector_length;\n\n    std::vector<float> result(n - 1);\n    for (size_t i = 0; i < num_vectors; ++i) {\n        size_t start = i * vector_length;\n        size_t end = std::min(start + vector_length, n);\n        size_t len = end - start;\n\n        svfloat_t coeffs = svld1q_f32(xs.data() + start);\n        svfloat_t indices = svindex_f32(1.0f, 1.0f);\n\n        svfloat_t deriv = svmla_f32(svdupq_n_f32(0.0f), coeffs, indices);\n\n        svst1q_f32(result.data() + start, deriv);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```c\nint vowels_count_simd(std::string s){\n    svbool_t pg = svwhilelt_b32(0, s.size());\n    svint8_t vec = svld1_u8((const uint8_t *)s.c_str(), pg);\n    svint8_t vowels = svindex_u8(0, 'a', 'e', 'i', 'o', 'u', 'y');\n    svbool_t mask_vowels = svcmpeq_n_u8(vec, 'a');\n    mask_vowels = svorr_b32(mask_vowels, svcmpeq_n_u8(vec, 'e'));\n    mask_vowels = svorr_b32(mask_vowels, svcmpeq_n_u8(vec, 'i'));\n    mask_vowels = svorr_b32(mask_vowels, svcmpeq_n_u8(vec, 'o'));\n    mask_vowels = svorr_b32(mask_vowels, svcmpeq_n_u8(vec, 'u'));\n    \n    svbool_t mask_y_end = svcmpeq_n_u8(svlast(pg, vec), 'y');\n    \n    int count = svcntd() - svcntb(svpred_b32(pg, ~mask_vowels));\n    if (svptest_any_b32(pg, mask_y_end)) {\n        count += 1;\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```c\nint vowels_count_simd(std::string s){\n    svbool_t pg = svwhilelt_b32(0, s.size());\n    svint8_t vec = svld1_u8((const uint8_t *)s.c_str(), pg);\n    svint8_t vowels = svindex_u8(0, 'a', 'e', 'i', 'o', 'u', 'y');\n    svbool_t mask_vowels = svcmpeq_n_u8(vec, 'a');\n    mask_vowels = svorr_b32(mask_vowels, svcmpeq_n_u8(vec, 'e'));\n    mask_vowels = svorr_b32(mask_vowels, svcmpeq_n_u8(vec, 'i'));\n    mask_vowels = svorr_b32(mask_vowels, svcmpeq_n_u8(vec, 'o'));\n    mask_vowels = svorr_b32(mask_vowels, svcmpeq_n_u8(vec, 'u'));\n    \n    svbool_t mask_y_end = svcmpeq_n_u8(svlast(pg), 'y');\n    \n    int count = svcntd() - svcntb(svpred_b32(pg, mask_vowels));\n    if (svptest_any_b32(pg, mask_y_end)) {\n        count += 1;\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```c\nint vowels_count_simd(std::string s){\n    svbool_t pg = svwhilelt_b32(0, s.size());\n    svint8_t vec = svld1_s8(pg, reinterpret_cast<int8_t*>(const_cast<char*>(s.c_str())));\n    svint8_t vowels = svindex_u8(0, 'a');\n    svbool_t mask_a = svcmpeq_n_u8(vec, 'a');\n    svbool_t mask_e = svcmpeq_n_u8(vec, 'e');\n    svbool_t mask_i = svcmpeq_n_u8(vec, 'i');\n    svbool_t mask_o = svcmpeq_n_u8(vec, 'o');\n    svbool_t mask_u = svcmpeq_n_u8(vec, 'u');\n    svbool_t mask_y = svcmpeq_n_u8(svshr_n_s8(vec, 23), 'y'); // 'y' in ASCII is 0x79, after shifting right by 5 bits, it becomes 0x07, which is 'y'\n    \n    int count = count_population(pg, svorr_v_b32(pg, mask_a, mask_e));\n    count += count_population(pg, svorr_v_b32(pg, mask_i, mask_o));\n    count += count_population(pg, svorr_v_b32(pg, mask_u, mask_y));\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```c\nint vowels_count_simd(std::string s){\n    svbool_t pg = svwhilelt_b32(0, s.size());\n    svint8_t vec = svld1_u8((const uint8_t *)s.c_str(), pg);\n    svint8_t vowels = svindex_u8(0, 'a', 'e', 'i', 'o', 'u', 'y', 'A', 'E', 'I', 'O', 'U', 'Y');\n    svbool_t mask_vowels = svcmpeq_n_u8(vec, vowels);\n    svbool_t mask_y_end = svcmpeq_n_u8(svlast_u8(vec), 'y') | svcmpeq_n_u8(svlast_u8(vec), 'Y');\n    int count = svcntd() - svcntb(svpred_b32(pg, mask_vowels));\n    if (svptest_any_b32(pg, mask_y_end)) {\n        count += 1;\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```c\nint vowels_count_simd(std::string s){\n    svbool_t pg = svwhilelt_b32(0, s.size());\n    svint8_t vec = svld1_u8((const uint8_t *)s.c_str(), pg);\n    svint8_t vowels = svindex_u8(0, 'a', 'e', 'i', 'o', 'u', 'y', 'A', 'E', 'I', 'O', 'U', 'Y');\n    svbool_t match = svcmpeq_n_u8(vec, 'y');\n    svbool_t is_vowel = svptrue_b8();\n    for(int i=0; i<11; i++){\n        svbool_t temp = svcmpeq_n_u8(vec, vowels[i]);\n        is_vowel = svorr_b8(is_vowel, temp);\n    }\n    is_vowel = svand_b8(is_vowel, svwhilelt_b32(0, s.size()));\n    svbool_t last_char = svcmpeq_n_u8(svlast_u8(vec), 'y');\n    is_vowel = svorr_b8(is_vowel, last_char);\n    int count = svcntd() - svcntb(svpfalse_b8()) + svcntd() - svcntb(svcmpne_b8(is_vowel, svptrue_b8()));\n    return count;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```c\nint digitSum_simd(std::string s){\n    svbool_t pg = svwhilelt_b32(0, s.size());\n    svint32_t sum_vec = svdup_n_s32(0);\n    for (size_t i = 0; i < s.size(); i += svcntw()) {\n        svint32_t chars = svld1(pg, (const int32_t*)(&s[i]));\n        svbool_t is_upper = svcmpgt_b32(chars, svdup_n_s32('A'-1));\n        is_upper = svand_b32(is_upper, svcmpgt_b32(svsub_s32(chars, svdup_n_s32('Z'+1)), svdup_n_s32(-1)));\n        svint32_t upper_chars = svcond_s32(chars, svdup_n_s32(0), is_upper);\n        sum_vec = svadd_s32(sum_vec, upper_chars);\n    }\n    return svaddv_s32(sum_vec);\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```c\nint digitSum_simd(std::string s){\n    svbool_t pg = svwhilelt_b32(0, s.size());\n    svint32_t sum_vec = svdup_n_s32(0);\n    for (size_t i = 0; i < s.size(); i += svcntw()) {\n        svint32_t chars = svld1(pg, (const int32_t*)(&s[i]));\n        svbool_t is_upper = svcmpgt_b32(chars, svdup_n_s32('A'-1));\n        is_upper = svand_b32(is_upper, svcmpgt_b32(svsub_s32(chars, svdup_n_s32('Z'+1)), svdup_n_s32(-1)));\n        svint32_t upper_chars = svcond_s32(chars, svdup_n_s32(0), is_upper);\n        sum_vec = svadd_s32(sum_vec, upper_chars);\n    }\n    return svaddv_s32(sum_vec);\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```c\nint digitSum_simd(std::string s){\n    svbool_t pg = svwhilelt_b32(0, s.size());\n    svint32_t sum_vec = svdup_n_s32(0);\n    for (size_t i = 0; i < s.size(); i += svcntw()) {\n        svint32_t chars = svld1(pg, (const int32_t*)(&s[i]));\n        svbool_t is_upper = svcmpgt_b32(chars, svdup_n_s32('A'-1));\n        is_upper = svand_b32(is_upper, svcmpgt_b32(svsub_s32(chars, svdup_n_s32('Z'+1)), svdup_n_s32(-1)));\n        svint32_t upper_chars = svsel_s32(chars, svdup_n_s32(0), is_upper);\n        sum_vec = svadd_s32(sum_vec, upper_chars);\n    }\n    return svaddv_s32(sum_vec);\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```c\nint digitSum_simd(std::string s){\n    svbool_t pg;\n    int sum = 0;\n    size_t i = 0;\n    size_t len = s.length();\n\n    while(i < len){\n        pg = svwhilelt_b((int)i, (int)len);\n        svint8_t chars = svld1(pg, s.data() + i);\n        svbool_t is_upper = svcmpgt_b(chars, svdup_n_s8('A'-1)) & svcmplt_b(chars, svdup_n_s8('Z'+1));\n        svint8_t upper_chars = svcond(is_upper, chars, svdup_n_s8(0));\n        sum += svaddv_b(svptrue_b(), upper_chars);\n        i += svcntw();\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```c\nint digitSum_simd(std::string s){\n    svbool_t pg = svwhilelt_b32(0, s.size());\n    svint32_t sum_vec = svdup_n_s32(0);\n    for (size_t i = 0; i < s.size(); i += svcntw()) {\n        svint32_t chars = svld1(pg, (const int32_t*)(&s[i]));\n        svbool_t is_upper = svcmpgt_b32(chars, svdup_n_s32('A'-1));\n        is_upper = svand_b32(is_upper, svcmpgt_b32(svsub_s32(chars, svdup_n_s32('Z'+1)), svdup_n_s32(-1)));\n        svint32_t upper_chars = svcond_s32(chars, svdup_n_s32(0), is_upper);\n        sum_vec = svadd_s32(sum_vec, upper_chars);\n    }\n    return svcadd_s32(svdup_n_s32(0), sum_vec);\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> pluck_simd(std::vector<int> arr){\n    size_t n = arr.size();\n    if(n == 0) return {};\n\n    // Convert input vector to sve type\n    svint32_t indices = svindex_s32(0, 1);\n    svint32_t values = svld1_s32(arr.data());\n\n    // Mask for even numbers\n    svbool_t p_even = svcmpeq_n_s32(values, 0);\n\n    // Find the smallest even value and its index\n    svint32_t smallest_value = svdup_n_s32(-1); // Initialize to invalid value\n    svint32_t smallest_index = svdup_n_s32(-1);\n\n    while(n > 0){\n        size_t chunk_size = svcntd(); // Process a chunk at a time\n        if(n < chunk_size) chunk_size = n;\n\n        svint32_t chunk_values = svld1_s32(arr.data());\n        svbool_t p_chunk = svwhilelt_b32(indices, svtrue_b32(), chunk_size);\n\n        // Filter even numbers\n        svbool_t p_even_chunk = svcmpeq_n_s32(chunk_values, 0);\n        svbool_t p_valid = svand_b32(p_even_chunk, p_chunk);\n\n        // Compare with current smallest\n        svbool_t p_smaller = svcmple_b32(chunk_values, smallest_value);\n        p_smaller = svand_b32(p_smaller, p_valid);\n        if(svvall_b32(p_smaller)){\n            smallest_value = svsel_s32(smallest_value, chunk_values, p_smaller);\n            smallest_index = svsel_s32(smallest_index, indices, p_smaller);\n        }\n\n        arr.erase(arr.begin(), arr.begin() + chunk_size);\n        n -= chunk_size;\n    }\n\n    // Convert back to std::vector\n    std::vector<int> result;\n    if(smallest_index != svdup_n_s32(-1)){\n        result.push_back(smallest_value);\n        result.push_back(smallest_index);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> pluck_simd(std::vector<int> arr){\n    size_t n = arr.size();\n    if(n == 0) return {};\n\n    // Convert input vector to sve type\n    svint32_t indices = svindex_s32(0, 1);\n    svint32_t values = svld1_s32(arr.data());\n\n    // Mask for even numbers\n    svbool_t p_even = svcmpeq_n_s32(values, 0);\n\n    // Find the minimum even value\n    svint32_t min_even = svminv_p_s32(p_even, values);\n    \n    // Find the index of the first occurrence of the minimum even value\n    svbool_t p_min = svcmpeq_s32(values, svminv_p_s32(p_even, values));\n    svint32_t min_indices = svbfind_b32(p_min, indices);\n\n    // Convert sve types back to standard types\n    int smallest_value = (int)svlast_s32(min_even);\n    int smallest_index = (int)svlast_s32(min_indices);\n\n    return {smallest_value, smallest_index};\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> pluck_simd(std::vector<int> arr){\n    size_t n = arr.size();\n    if(n == 0) return {};\n\n    // Convert input vector to sve type\n    svint32_t indices = svindex_s32(0, 1);\n    svint32_t values = svld1_s32(arr.data());\n\n    // Mask for even numbers\n    svbool_t p_even = svcmpeq_n_s32(values, svand_n_s32(values, svcreate_s32(1)));\n\n    // Find the minimum even value\n    svint32_t min_even = svminv_p_s32(p_even, values);\n    \n    // Find the index of the first occurrence of the minimum even value\n    svbool_t p_min = svcmpeq_s32(values, svdup_n_s32(min_even));\n    svint32_t min_index = svbfind_first_true(p_min, indices);\n\n    // Convert results to standard integers\n    int smallest_value = (int)svgetlane_s32(min_even, 0);\n    int smallest_index = (int)svgetlane_s32(min_index, 0);\n\n    return {smallest_value, smallest_index};\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> pluck_simd(std::vector<int> arr){\n    size_t n = arr.size();\n    if(n == 0) return {};\n\n    // Convert input vector to sve type\n    svint32_t indices = svindex_s32(0, 1);\n    svint32_t values = svld1_s32(arr.data());\n\n    // Mask for even numbers\n    svbool_t p_even = svcmpeq_n_s32(values, svand_n_s32(values, svcreate_low_n_s32(1)));\n\n    // Find the minimum even value\n    svint32_t min_even = svminv_p_s32(p_even, values);\n    \n    // Find the index of the first occurrence of the minimum even value\n    svbool_t p_min = svcmpeq_s32(values, svdup_n_s32(min_even));\n    svint32_t min_index = svbfind_first_true(p_min, indices);\n\n    // Convert results to standard integers\n    int smallest_value = (int)svgetlane_s32(min_even, 0);\n    int smallest_index = (int)svgetlane_s32(min_index, 0);\n\n    return {smallest_value, smallest_index};\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> pluck_simd(std::vector<int> arr){\n    size_t n = arr.size();\n    if(n == 0) return {};\n\n    // Convert input vector to sve type\n    svint32_t indices = svindex_s32(0, 1, 1);\n    svint32_t values = svld1_s32(arr.data());\n\n    // Mask for even numbers\n    svbool_t p_even = svcmpeq_n_s32(values, 0);\n\n    // Initialize min_even_value and min_index\n    svint32_t min_even_value = svdup_n_s32(-1); // -1 indicates no valid even number found yet\n    svint32_t min_index = svdup_n_s32(-1);\n\n    // Iterate over the vector\n    while(n > 0){\n        size_t vl = svcntb();\n        svint32_t current_values = svld1_s32(arr.data());\n        svbool_t current_mask = svwhilelt_b32(indices, n);\n\n        // Check for even numbers\n        svbool_t is_even = svcmpeq_n_s32(current_values, 0);\n        svbool_t is_valid = svand_b32(is_even, current_mask);\n\n        // Update min_even_value and min_index\n        svint32_t candidate_values = svsel_s32(svif_b32(is_valid, current_values), svdup_n_s32(-1));\n        svint32_t candidate_indices = svsel_s32(svif_b32(is_valid, indices), svdup_n_s32(-1));\n\n        svbool_t less_than_min = svcmple_n_s32(candidate_values, min_even_value);\n        svbool_t update_min = svand_b32(less_than_min, is_valid);\n\n        min_even_value = svsel_s32(svif_b32(update_min, candidate_values), min_even_value);\n        min_index = svsel_s32(svif_b32(update_min, candidate_indices), min_index);\n\n        // Move to the next segment\n        arr.erase(arr.begin(), arr.begin() + vl);\n        n -= vl;\n        indices = svadd_n_s32(indices, vl);\n    }\n\n    // Convert back to scalar\n    int smallest_value = -1;\n    int smallest_index = -1;\n    svint32_t_to_scalar(min_even_value, smallest_value);\n    svint32_t_to_scalar(min_index, smallest_index);\n\n    if(smallest_value == -1) return {};\n    return {smallest_value, smallest_index};\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```c\nint search_simd(std::vector<int> lst){\n    svbool_t pg = svwhilelt_b32(0, lst.size());\n    svint32_t values = svld1(pg, lst.data());\n    svint32_t freq = svdup_n_s32(0);\n    \n    // Count frequency\n    for(int i=1; i<=*std::max_element(lst.begin(), lst.end()); ++i){\n        svint32_t target = svdup_n_s32(i);\n        svbool_t eq = svcmpeq_n_s32(values, target);\n        freq = svpadd_s32(freq, svcntb_b32(eq));\n    }\n    \n    // Find max valid value\n    int result = -1;\n    for(int i=*std::max_element(lst.begin(), lst.end()); i>=1; --i){\n        svint32_t target = svdup_n_s32(i);\n        svbool_t geq = svcmplt_n_s32(freq, target);\n        if(!svptest_any(svptrue_b32(), geq)){\n            result = i;\n            break;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```c\nint search_simd(std::vector<int> lst){\n    size_t n = lst.size();\n    if(n == 0) return -1;\n\n    // Determine the vector length\n    svlen = svcntd() * 64;\n    size_t vec_size = svlen / sizeof(int);\n\n    // Initialize frequency counters\n    int freq[svlen] = {0};\n    \n    for(size_t i = 0; i < n; i += vec_size){\n        svint32_t vl = svld1((const int *)(&lst[i]));\n        svuint32_t indices = svindex_s32(0, vec_size);\n        svuint32_t mask = svcmplt(indices, svcreate_from_ptr(&n));\n        \n        svaddp(freq, vl, mask);\n    }\n\n    // Find the maximum valid frequency\n    int result = -1;\n    for(int val = 1; val <= svlen; ++val){\n        if(freq[val] >= val && val > result){\n            result = val;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```c\nint search_simd(std::vector<int> lst){\n    size_t n = lst.size();\n    if(n == 0) return -1;\n\n    // Determine the vector length\n    svlen = svcntw();\n\n    // Initialize frequency vector\n    svint64_t freq = svdup_n_s64(0);\n\n    for(size_t i = 0; i < n; i += svlen){\n        size_t chunk_size = (n - i >= svlen) ? svlen : n - i;\n        svint32_t vec = svld1_s32(lst.data() + i);\n        \n        // Update frequency\n        freq = svadd_s64(freq, svcntp_u32(svcmpeq_s32(vec, svindex_s32(i, i + chunk_size))));\n    }\n\n    // Find the maximum valid value\n    int result = -1;\n    for(int val = n; val > 0; --val){\n        if(svcmpeq_s64(freq[val], svdup_n_s64(val)).all()){\n            result = val;\n            break;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```c\nint search_simd(std::vector<int> lst){\n    size_t n = lst.size();\n    if(n == 0) return -1;\n\n    // Determine the vector length\n    svlen = svcntw();\n\n    // Initialize a frequency vector with zeros\n    svint32_t freq = svdup_n_s32(0);\n\n    // Count frequencies using SVE\n    for(size_t i = 0; i < n; i += svlen){\n        size_t chunk_size = (n - i >= svlen) ? svlen : n - i;\n        svint32_t indices = svindex_s32(0, chunk_size);\n        svint32_t values = svld1_s32(lst.data() + i);\n        freq = svadd_s32(freq, svcntp_u32(svcmpeq_s32(values, indices)));\n    }\n\n    // Find the maximum valid value\n    int result = -1;\n    for(int val = n; val > 0; --val){\n        svbool_t p = svcmpgt_s32(freq, svdup_n_s32(val));\n        if(svmad_s32(p, svtrue_h(), svint32_t(0)) > 0){\n            result = val;\n            break;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```c\nint search_simd(std::vector<int> lst){\n    size_t n = lst.size();\n    if(n == 0) return -1;\n\n    // Determine the vector length\n    svint32_t zero = svdup_n_s32(0);\n    svbool_t pg = svwhilelt_b32(0, n);\n\n    // Initialize frequency vector\n    svint32_t freq[sve_smallest_vector_length()];\n    for(int i=0; i<sve_smallest_vector_length(); i++) {\n        freq[i] = svdup_n_s32(0);\n    }\n\n    // Count frequencies using SVE\n    for(size_t i=0; i<n; i+=svcntw()){\n        svint32_t values = svld1(pg, &lst[i]);\n        svaddv(svptrue_b32(), freq, values);\n    }\n\n    // Find the maximum valid result\n    int max_result = -1;\n    for(int val=1; val<=sve_smallest_vector_length(); val++){\n        svint32_t check = svcmpgt_s32(svindex_s32(0, val), svld1(pg, freq));\n        int count = svcntw();\n        for(int j=0; j<count; j++){\n            if(check[j]){\n                max_result = val;\n                break;\n            }\n        }\n        if(max_result != -1) break;\n    }\n\n    return max_result;\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool will_it_fly_simd(sve_int_t q, int w) {\n    size_t vl = svquery_vl();\n    sve_int_t sum = svdup_n_sve_int(0);\n    sve_bool_t is_palindrome = svcmp_eq_sve_int(q, svrevq_sve_int(q));\n\n    for (size_t i = 0; i < vl; i += svcntw()) {\n        sum = svadd_sve_int(sum, svld1_sve_int(q + i));\n    }\n\n    return (svcmpeq_sve_int(svsub_sve_int(svsum_sve_int(sum), sum), svdup_n_sve_int(0)) && svcmple_sve_int(sum, svdup_n_sve_int(w)));\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool will_it_fly_simd(sve_int_t q, int w, size_t len) {\n    sve_int_t sum = svaddv(sve_true_h, q);\n    sve_bool_t balanced = svcmpeq_z(sve_true_h, svdup_q(q), svrev_b64(q));\n    return (svcntw() * svmaxv(s16, q) <= w) && svany(sve_true_h, balanced);\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool will_it_fly_simd(sve_int_t q, int w) {\n    size_t len = sve_len(q) / sizeof(int);\n    sve_int_t sum_vec = svdup_q_s32(0);\n    sve_bool_t balance_mask = svcmpeq_n_s32(q, svrev_n_s32(q, len));\n    \n    for (size_t i = 0; i < len; i += svcntw()) {\n        sve_int_t chunk = svld1_s32(q + i * sizeof(int));\n        sum_vec = svadd_x_s32(sum_vec, chunk);\n    }\n    \n    int total_sum = svaddlv_s32(sum_vec);\n    return (svcntp() && svcmpeq_n_s32(balance_mask, 1) && total_sum <= w);\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool will_it_fly_simd(sve_int_t q, int w) {\n    size_t len = sve_len(q) / sizeof(int);\n    sve_bool_t balanced = svcmpeq_z(svptrue(), q, svreverse(q));\n    sve_int_t sum = svaddv(svptrue(), q);\n    return (svcntw() == len) && svcmpeq_w(svptrue(), sum, svminv(svptrue(), sum)) && (sum <= w);\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <hwy/highway.h>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    size_t n = q.size();\n    svbool_t pg = svwhilelt_b32(0, (int32_t)n);\n    svint32_t vec_q = svld1(pg, q.data());\n    svint32_t reversed_vec_q = svtrn1q_s32(vec_q, vec_q);\n\n    svbool_t is_balanced = sveor_b32(pg, vec_q, reversed_vec_q) == svfalse_b32();\n\n    svint32_t sum_vec = svaddv(pg, vec_q);\n    int total_sum = svaddv_u32(svreinterpret_u32(pg, sum_vec));\n\n    return is_balanced && total_sum <= w;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```c\nint smallest_change_simd(sve_int_t arr) {\n    size_t n = svcntw();\n    sve_int_t left = svdup_n_w(0);\n    sve_int_t right = svdup_n_w(0);\n    int changes = 0;\n\n    for (size_t i = 0; i < n / 2; i++) {\n        left = svld1_s32(arr + i);\n        right = svld1_s32(arr + n - i - 1);\n        sve_bool_t mismatch = svcmpeq_w(left, right);\n        changes += svcntw() - svcntb(mismatch);\n    }\n\n    if (n % 2 != 0) {\n        size_t mid = n / 2;\n        left = svld1_s32(arr + mid);\n        right = svdup_n_w(0); // Assuming mid element doesn't need comparison\n        sve_bool_t mismatch = svcmpeq_w(left, right);\n        changes += svcntw() - svcntb(mismatch);\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```c\nint smallest_change_simd(sve_int_t arr){\n    size_t n = svlen / sizeof(int);\n    sve_int_t left = svundef_s32();\n    sve_int_t right = svundef_s32();\n    sve_uint_t mask = svwhilelt_u32(0, n/2);\n    \n    svptrue_b32(mask);\n    \n    svtrn1_s32(left, arr, mask);\n    svtrn2_s32(right, arr, mask);\n    \n    sve_int_t diff = svabs_s32(svsub_s32(left, svrev_s32(right)));\n    sve_int_t count = svcntb_s32(diff);\n    \n    return svaddv_u32(count);\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```c\nint smallest_change_simd(sve_int_t arr){\n    size_t n = sve_len(arr) / sizeof(int);\n    int changes = 0;\n    svbool_t p = svwhilelt_b(n);\n    \n    // Compare elements from start and end moving towards the center\n    for(size_t i = 0; i < n/2; i += svcntb()){\n        svbool_t mask = svwhilelt_x(i, n/2);\n        sve_int_t left = svld1_gather_index_b(p, arr, svindex_u32(i));\n        sve_int_t right = svld1_gather_index_b(p, arr, svindex_u32(n - i - 1));\n        sve_int_t diff = svabs_v(left - right);\n        changes += svcntb() - svcntz_b(svcmpeq_v(diff, svundef_b()));\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```c\nint smallest_change_simd(sve_int_t arr){\n    size_t n = svlen(arr);\n    sve_int_t left = svdup_n(n, 0);\n    sve_int_t right = svdup_n(n, 0);\n    \n    for(size_t i = 0; i < n/2; i++){\n        left = svsel(svcmpeq(left, arr[i]), left, arr[i]);\n        right = svsel(svcmpeq(right, arr[n-1-i]), right, arr[n-1-i]);\n    }\n    \n    if(n % 2 != 0){\n        left = svsel(svcmpeq(left, arr[n/2]), left, arr[n/2]);\n    }\n    \n    sve_int_t changes = svabs(left - right);\n    int total_changes = svcntd() - svcntp(changes);\n    return total_changes;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```c\nint smallest_change_simd(sve_int_t arr){\n    size_t n = svlen(arr);\n    sve_int_t left = svdup_n(n, 0);\n    sve_int_t right = svdup_n(n, 0);\n    \n    for(size_t i = 0; i < n / 2; i += svcntw()){\n        sve_int_t chunk_left = svld1_s32(arr + i);\n        sve_int_t chunk_right = svld1_s32(arr + n - i - svcntw());\n        \n        left = svsel(left, chunk_left, svcmpeq_s32(chunk_left, chunk_right));\n        right = svsel(right, chunk_right, svcmpeq_s32(chunk_left, chunk_right));\n    }\n    \n    int total_changes = svcntw() - svaddv_u32(svcmpeq_s32(left, svtrue()));\n    return total_changes;\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    size_t len1 = 0;\n    size_t len2 = 0;\n\n    if (!lst1.empty()) {\n        svint64_t lens1 = svindex_s64(0, lst1.size());\n        svbool_t pg = svwhilelt_b64(lens1, (int64_t)lst1.size());\n        svint64_t total_len1 = svptrue_b64();\n        svptrue_b64().p[0] = 0;\n\n        do {\n            svint64_t indices = svlsr_n_b64(pg, lens1);\n            svuint8_t lens = svld1_u8((const uint8_t**)lst1.data() + indices);\n            total_len1 = svaddv_u8(pg, lens);\n        } while (svptest_any(svptrue_b64(), pg = svwhilelt_b64(pg, (int64_t)lst1.size())));\n\n        len1 = svcvt_s64_f64(svaddv_s64(total_len1));\n    }\n\n    if (!lst2.empty()) {\n        svint64_t lens2 = svindex_s64(0, lst2.size());\n        svbool_t pg = svwhilelt_b64(lens2, (int64_t)lst2.size());\n        svint64_t total_len2 = svptrue_b64();\n        svptrue_b64().p[0] = 0;\n\n        do {\n            svint64_t indices = svlsr_n_b64(pg, lens2);\n            svuint8_t lens = svld1_u8((const uint8_t**)lst2.data() + indices);\n            total_len2 = svaddv_u8(pg, lens);\n        } while (svptest_any(svptrue_b64(), pg = svwhilelt_b64(pg, (int64_t)lst2.size())));\n\n        len2 = svcvt_s64_f64(svaddv_s64(total_len2));\n    }\n\n    if (len1 < len2 || (len1 == len2 && !lst1.empty())) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```c\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    size_t len1 = 0;\n    size_t len2 = 0;\n\n    if (!lst1.empty()) {\n        size_t count1 = lst1.size();\n        svlength_t vl = svwhilelt_u32(0, count1);\n        svint32_t indices1 = svindex_u32(0, 1);\n        do {\n            svbool_t p = svptest_any(svptrue_b32(), indices1);\n            size_t index = svget_gather_u32(lst1.data(), p, indices1);\n            len1 += lst1[index].size();\n        } while (svptrue_b32() != svlastlane_u32(indices1));\n    }\n\n    if (!lst2.empty()) {\n        size_t count2 = lst2.size();\n        svlength_t vl = svwhilelt_u32(0, count2);\n        svint32_t indices2 = svindex_u32(0, 1);\n        do {\n            svbool_t p = svptest_any(svptrue_b32(), indices2);\n            size_t index = svget_gather_u32(lst2.data(), p, indices2);\n            len2 += lst2[index].size();\n        } while (svptrue_b32() != svlastlane_u32(indices2));\n    }\n\n    if (len1 <= len2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```c\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    size_t len1 = 0;\n    size_t len2 = 0;\n\n    if (!lst1.empty()) {\n        svlength_t vl = svlen();\n        size_t i = 0;\n        svbool_t pg = svwhilelt_b64(i, lst1.size());\n        do {\n            svint32_t lens = svld1(pg, (const int32_t*)(&lst1[i]));\n            len1 += svcadd_reduce_u32(svpredtest(pg), lens);\n            i += vl;\n            pg = svwhilelt_b64(i, lst1.size());\n        } while(svpredtest(pg));\n    }\n\n    if (!lst2.empty()) {\n        svlength_t vl = svlen();\n        size_t i = 0;\n        svbool_t pg = svwhilelt_b64(i, lst2.size());\n        do {\n            svint32_t lens = svld1(pg, (const int32_t*)(&lst2[i]));\n            len2 += svcadd_reduce_u32(svpredtest(pg), lens);\n            i += vl;\n            pg = svwhilelt_b64(i, lst2.size());\n        } while(svpredtest(pg));\n    }\n\n    if (len1 <= len2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    size_t len1 = 0;\n    size_t len2 = 0;\n\n    if (!lst1.empty() && !lst2.empty()) {\n        size_t min_size = std::min(lst1.size(), lst2.size());\n        size_t vector_length = svcntw(); // Get the vector length\n\n        for (size_t i = 0; i < min_size; i += vector_length) {\n            size_t count = std::min(vector_length, min_size - i);\n            svulong_t mask = svwhilelt_uw((int)i, (int)min_size);\n\n            svlength_t lens1 = svindex_uw(0, i, i + count);\n            svlength_t lens2 = svindex_uw(0, i, i + count);\n\n            svuint32_t lengths1 = svtrn1_u32(svtbl_w(sveor_w(svld1_w(lens1), svld1_w(lens1)), 0));\n            svuint32_t lengths2 = svtrn1_u32(svtbl_w(sveor_w(svld1_w(lens2), svld1_w(lens2)), 0));\n\n            svbool_t p1 = svcmpgt_u32(lengths1, svindex_u32(0, count));\n            svbool_t p2 = svcmpgt_u32(lengths2, svindex_u32(0, count));\n\n            len1 += svaddv_u32(svbsl_u32(p1, lengths1, svdup_n_u32(0)));\n            len2 += svaddv_u32(svbsl_u32(p2, lengths2, svdup_n_u32(0)));\n        }\n\n        for (size_t i = min_size; i < lst1.size(); ++i) {\n            len1 += lst1[i].length();\n        }\n\n        for (size_t i = min_size; i < lst2.size(); ++i) {\n            len2 += lst2[i].length();\n        }\n    }\n\n    if ((len1 < len2) || (len1 == len2 && !lst1.empty())) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    size_t len1 = 0;\n    size_t len2 = 0;\n\n    if (!lst1.empty()) {\n        svint64_t lens1 = svindex_s64(0, lst1.size());\n        svbool_t pg = svwhilelt_b64(lens1, (int64_t)lst1.size());\n        svint64_t total_len1 = svptrue_b64();\n        svptrue_b64(total_len1);\n\n        do {\n            svint64_t indices = svlsr_n_b64(pg, lens1, 1);\n            svuint64_t lens = svuzp1_u64(svlen_u8(svptrue_b64()), svlen_u8(svptrue_b64()));\n            svaddv_u64(len1, lens);\n        } while (svptest_any(svptrue_b64(), pg));\n\n        len1 = svaddv_u64(len1);\n    }\n\n    if (!lst2.empty()) {\n        svint64_t lens2 = svindex_s64(0, lst2.size());\n        svbool_t pg = svwhilelt_b64(lens2, (int64_t)lst2.size());\n        svint64_t total_len2 = svptrue_b64();\n        svptrue_b64(total_len2);\n\n        do {\n            svint64_t indices = svlsr_n_b64(pg, lens2, 1);\n            svuint64_t lens = svuzp1_u64(svlen_u8(svptrue_b64()), svlen_u8(svptrue_b64()));\n            svaddv_u64(len2, lens);\n        } while (svptest_any(svptrue_b64(), pg));\n\n        len2 = svaddv_u64(len2);\n    }\n\n    if (len1 <= len2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    svbool_t pg = svwhilelt_b64(0, x);\n    svuint64_t n_vec = svld1_u64(&n, pg);\n    svuint64_t result = svmla_u64(pg, n_vec, n_vec);\n    svbool_t match = svcmpeq_u64(pg, result, svindex_u64(0, pg));\n    return svget_b32(svand_b32(pg, match));\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    svbool_t pg = svwhilelt_b64(0, x);\n    svbool_t result = svcmpeq_b64(pg, svdup_n_u64(n), svlsl_n_u64(svindex_u64(0, 1), pg));\n    return svptest_any(svptrue_b64(), result);\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n){\n    svbool_t pg = svwhilelt_b64(0, x);\n    svbool_t result = svcmpeq_b64(pg, svdup_n_u64(n), svlsl_n_u64(svindex_u64(0, 1, 1), svcntb()));\n    return svptest_any(svptrue_b64(), result);\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    svbool_t pg = svwhilelt_b64(0, x);\n    svbool_t result = svptrue_b16();\n\n    while (svptest_any(pg)) {\n        uint64_t current = svlastb_x(pg);\n        uint64_t count = 0;\n\n        while (current > 0 && current % n == 0) {\n            current /= n;\n            count++;\n        }\n\n        if (current != 1) {\n            result = svcnot_b16(result, svcreate_b16(current == x));\n        }\n\n        pg = svclear_b64(pg, current);\n    }\n\n    return svcnot_b16(result, svtrue_b16());\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    svbool_t pg = svwhilelt_b64(0, x);\n    svbool_t result = svcmpeq_b64(pg, svdup_n_u64(n), svlsl_n_u64(svindex_u64(0, 1), pg));\n    return svptest_any(svptrue_b64(), result);\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```c\nint hex_key_simd(const std::string & num){\n    svbool_t pg = svwhilelt_b32(0, num.size());\n    svint32_t primes = svld1_s32((const int32_t*) \"2357BD\");\n    svint32_t count = svdup_n_s32(0);\n    for(size_t i = 0; i < num.size(); i += 8){\n        pg = svwhilelt_b32(i, num.size());\n        svint32_t chars = svindex_u8_b32(pg, i);\n        svint32_t conv_chars = svsub_s32(chars, svdup_n_s32('0'));\n        svbool_t is_prime = svcmpeq_n_s32(svmax_s32(conv_chars, svdup_n_s32(9)), svdup_n_s32(11));\n        for(int j = 0; j < 4; ++j){\n            is_prime = svorr_v_b32(is_prime, svcmpeq_s32(svget_s32(conv_chars, j), svget_s32(primes, j)));\n        }\n        count = svadd_v_s32(count, svcntb_b32(is_prime));\n    }\n    return svcntd() - svaddv_u32(svmovlb_s32(count));\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```c\nint hex_key_simd(const std::string & num){\n    svbool_t pg = svwhilelt_b32(0, num.size());\n    svint32_t primes = svld1_s32((const int32_t*) \"2357BD\", pg);\n    svuint8_t input = svld1_u8((const uint8_t*)num.data(), pg);\n    svbool_t mask = svcmpeq_u8(input, svindex_u8(0, '2', pg), pg);\n    mask = svptrue_b8();\n    svuint8_t hex_primes = svcmpeq_u8(input, svindex_u8(0, '3', pg), mask);\n    mask = svptrue_b8();\n    hex_primes = svorr_b8(hex_primes, svcmpeq_u8(input, svindex_u8(0, '5', pg), mask));\n    mask = svptrue_b8();\n    hex_primes = svorr_b8(hex_primes, svcmpeq_u8(input, svindex_u8(0, '7', pg), mask));\n    mask = svptrue_b8();\n    hex_primes = svorr_b8(hex_primes, svcmpeq_u8(input, svindex_u8(0, 'B', pg), mask));\n    mask = svptrue_b8();\n    hex_primes = svorr_b8(hex_primes, svcmpeq_u8(input, svindex_u8(0, 'D', pg), mask));\n    return svcntd() - svcntb(svtbl_b8(hex_primes, svindex_u32(0, pg)));\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```c\nint hex_key_simd(const std::string & num){\n    svbool_t pg = svwhilelt_b32(0, num.size());\n    svint32_t primes = svld1_s32((const int32_t*) \"2357BDF\");\n    svuint8_t input = svld1_u8((const uint8_t*)num.data());\n    svbool_t mask = svcmpeq_n_u8(input, 'A');\n    svbool_t prime_mask;\n    svint32_t indices;\n    int count = 0;\n\n    while(svptest_any(pg)){\n        indices = svindex_u8(pg);\n        prime_mask = svcmpeq_u8(input, svsel_u8(mask, svindex_u8(pg), input));\n        prime_mask = svptrue_b32();\n        for(int i=0;i<svcntw();i++) {\n            if(svcmpeq_s32(primes, svindex_s32(pg+i))){\n                count++;\n            }\n        }\n        pg = svnext(pg);\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```c\nint hex_key_simd(const std::string & num){\n    svbool_t pg = svwhilelt_b32(0, num.size());\n    svint32_t primes = svld1_s32((const int32_t*) \"2357BDF\");\n    svint32_t count = svdup_n_s32(0);\n    for(size_t i = 0; i < num.size(); i += 8){\n        pg = svwhilelt_b32(i, num.size());\n        svint32_t chars = svindex_u8_b32(pg, i);\n        svint32_t conv_chars = svsub_s32(chars, svdup_n_s32('0'));\n        svbool_t is_prime = svcmpeq_n_s32(svmax_s32(conv_chars, svdup_n_s32(9)), svdup_n_s32(11));\n        for(int j = 0; j < 4; j++){\n            is_prime = svorr_b32(is_prime, svcmpeq_n_s32(primes, j + 2 * svtrue_b32()));\n        }\n        count = svadd_s32(count, svcntb_b32(is_prime));\n    }\n    return svcntd_s32(count);\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```c\nint hex_key_simd(const std::string & num){\n    svbool_t pg = svwhilelt_b32(0, num.size());\n    svint32_t primes = svld1_s32((const int32_t*) \"2357BDF\");\n    svint32_t count = svdup_n_s32(0);\n    for(size_t i = 0; i < num.size(); i += 8){\n        pg = svwhilelt_b32(i, num.size());\n        svint32_t chars = svindex_u8_b32(pg, i);\n        svint32_t conv_chars = svsub_s32(chars, svdup_n_s32('0'));\n        svbool_t is_prime = svcmpeq_n_s32(svmax_s32(conv_chars, svdup_n_s32(9)), svdup_n_s32(11));\n        for(int j = 0; j < 4; ++j){\n            is_prime = svorr_v_b32(is_prime, svcmpeq_s32(conv_chars, svld1_lane_s32(&primes, j, 0)));\n        }\n        count = svadd_v_s32(count, svcntb_b32(is_prime));\n    }\n    return svcntd() - svaddv_u32(svmovlb_s32(count));\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <hwy/highway.h>\n\nbool is_happy_simd(const std::string &s) {\n    size_t len = s.length();\n    if (len < 3) return false;\n\n    // Convert string to uint8_t array\n    svint8_t input = svld1_u8((const uint8_t *)s.c_str());\n\n    // Define vector width\n    size_t VL = svcntb();\n\n    // Check if length is not a multiple of vector width\n    size_t remainder = len % VL;\n    if (remainder != 0) {\n        for (size_t i = len - remainder; i < len; ++i) {\n            if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n                return false;\n            }\n        }\n    }\n\n    // Process full vectors\n    for (size_t i = 0; i <= len - 3; i += VL) {\n        svint8_t vec = svld1_u8((const uint8_t *)s.c_str() + i);\n        svint8_t next_vec = svld1_u8((const uint8_t *)s.c_str() + i + 1);\n        svint8_t next_next_vec = svld1_u8((const uint8_t *)s.c_str() + i + 2);\n\n        svbool_t mask = svcmpeq_n_u8(vec, next_vec) | svcmpeq_n_u8(vec, next_next_vec) | svcmpeq_n_u8(next_vec, next_next_vec);\n        if (svptest_any(svptrue_b(), mask)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <hwy/highway.h>\n\nbool is_happy_simd(const std::string &s) {\n    size_t len = s.length();\n    if (len < 3) return false;\n\n    // Convert string to uint8_t array\n    svint8_t input = svld1_u8((const uint8_t *)s.c_str());\n\n    // Define vector width\n    size_t VL = svcntb();\n\n    // Check if length is not a multiple of vector width\n    size_t remainder = len % VL;\n    if (remainder != 0) {\n        for (size_t i = len - remainder; i < len; ++i) {\n            if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n                return false;\n            }\n        }\n    }\n\n    // Process full vectors\n    for (size_t i = 0; i <= len - 3; i += VL) {\n        svint8_t vec = svld1_u8((const uint8_t *)s.c_str() + i);\n        svbool_t p = svwhilelt_b8(0, VL);\n\n        svint8_t a = svtrn1_s8(vec, vec);\n        svint8_t b = svtrn2_s8(vec, vec);\n\n        svbool_t cond1 = svcmpeq_m_b8(p, a, svdup_n_s8(-1));\n        svbool_t cond2 = svcmpeq_m_b8(p, b, svdup_n_s8(-1));\n        svbool_t cond3 = svcmpeq_m_b8(p, svsub_s8(a, b), svdup_n_s8(-1));\n\n        svbool_t not_happy = svcnot_b8(svand_b8(svand_b8(cond1, cond2), cond3));\n        if (svptest_any(svptrue_b8(), not_happy)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <hwy/highway.h>\n\nbool is_happy_simd(const std::string &s) {\n    size_t len = s.length();\n    if (len < 3) return false;\n\n    // Convert string to uint8_t array\n    svint8_t input = svld1_u8((const uint8_t *)s.c_str());\n\n    // Define vector width\n    size_t VL = svcntb();\n\n    // Check if length is not a multiple of vector width\n    size_t remainder = len % VL;\n    if (remainder != 0) {\n        for (size_t i = len - remainder; i < len; ++i) {\n            if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n                return false;\n            }\n        }\n    }\n\n    // Process full vectors\n    for (size_t i = 0; i <= len - 3; i += VL) {\n        svint8_t vec = svld1_u8((const uint8_t *)s.c_str() + i);\n        svbool_t p = svwhilelt_b8(0, VL);\n\n        svint8_t a = svtrn1_s8(vec, vec);\n        svint8_t b = svtrn2_s8(vec, vec);\n\n        svbool_t cond1 = svcmpeq_b8(a, b);\n        svbool_t cond2 = svcmpeq_b8(svadd_s8(a, 1), b);\n        svbool_t cond3 = svcmpeq_b8(a, svadd_s8(b, 1));\n\n        svbool_t any_false = svbitor_b8(cond1, svbitor_b8(cond2, cond3));\n        if (svptest_any(svptrue_b8(), any_false)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```c\nbool is_happy_simd(const std::string & s){\n    svbool_t pg = svwhilelt_b32(0, svcntw());\n    size_t len = s.length();\n    if(len < 3) return false;\n\n    const char * str = s.c_str();\n    svint8_t v_prev = svld1_gather_index_b32((const int8_t *)str, pg);\n    svint8_t v_curr;\n    svint8_t v_a = svindex_b32(0, 'a');\n    svint8_t v_z = svindex_b32(0, 'z');\n\n    for(size_t i = 3; i < len; i += svcntw()){\n        v_curr = svld1_gather_index_b32((const int8_t *)(str + i), pg);\n        \n        svbool_t cond1 = svcmpeq_n_s8(v_prev, v_curr);\n        svbool_t cond2 = svcmpeq_n_s8(svadd_n_s8(v_prev, 1), v_curr);\n        svbool_t cond3 = svcmpeq_n_s8(svadd_n_s8(v_prev, 2), v_curr);\n\n        svbool_t not_happy = svorr_v_b32(cond1, cond2);\n        not_happy = svorr_v_b32(not_happy, cond3);\n\n        if(svpred_any_b32(not_happy)) return false;\n\n        v_prev = v_curr;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <hwy/highway.h>\n\nbool is_happy_simd(const std::string &s) {\n    size_t len = s.length();\n    if (len < 3) return false;\n\n    // Convert string to uint8_t vector\n    svuint8_t input = svld1_u8((const uint8_t *)s.c_str());\n\n    // Create masks for the first three characters\n    svbool_t mask_first_three = svwhilelt_b8(0, 3);\n\n    // Check if the first three characters are distinct\n    svbool_t distinct_first_three = svcmpeq_b8(svundef_u8(), input, svlsl_x4_u8(input, svindex_u8(1, 1, 1))) &\n                                    svcmpeq_b8(svundef_u8(), input, svlsl_x4_u8(input, svindex_u8(2, 2, 2)));\n\n    if (!svptest_any(mask_first_three, distinct_first_three)) return false;\n\n    // Process the rest of the string in chunks of 16 bytes\n    size_t i = 3;\n    while (i + 16 <= len) {\n        svbool_t mask = svwhilelt_b8(0, 16);\n        svuint8_t chunk = svld1_u8((const uint8_t *)s.c_str() + i, mask);\n\n        // Check if each set of three consecutive characters in the chunk is distinct\n        svbool_t distinct = svcmpeq_b8(chunk, svlsl_x4_u8(chunk, svindex_u8(1, 1, 1), mask)) &\n                            svcmpeq_b8(chunk, svlsl_x4_u8(chunk, svindex_u8(2, 2, 2), mask));\n\n        if (!svptest_any(mask, distinct)) return false;\n\n        i += 16;\n    }\n\n    // Handle remaining characters less than 16 bytes\n    while (i < len - 2) {\n        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {\n            return false;\n        }\n        i++;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```c\nbool prime_length_simd(const std::string & str){\n    size_t len = str.length();\n    svbool_t p = svwhilelt_b_u32(0, len);\n    uint32_t mask = svcntw();\n\n    // Check divisibility by numbers up to sqrt(len)\n    for(uint32_t i = 2; i * i <= len; i += svget_lane_u32(mask, 0)){\n        svbool_t divisible = svcmpeq_n_u32(p, len % i, 0);\n        if(svptest_any(p, divisible)){\n            return false;\n        }\n    }\n    return len > 1;\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```c\nbool prime_length_simd(const std::string & str){\n    size_t len = str.length();\n    svbool_t p = svwhilelt_b_u32(0, len);\n    svbool_t is_prime = svptrue_b_u32();\n\n    for(size_t i = 2; i * i <= len; i += 1){\n        svbool_t mask = svcmpeq_u32(svptrue_b_u32(), svuzp1_u32(svindex_u32(i), svindex_u32(i)), svindex_u32(len));\n        is_prime = svbitor_b_u32(is_prime, svand_b_u32(p, mask));\n    }\n\n    return !svptest_any_b_u32(p, is_prime);\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <hwy/highway.h>\n\nbool prime_length_simd(const std::string &str) {\n    size_t len = str.length();\n    svbool_t p = svwhilelt_b_u32(0, len);\n\n    // Precompute small primes up to sqrt(len)\n    uint32_t primes[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\n    size_t num_primes = sizeof(primes) / sizeof(primes[0]);\n\n    // SIMD loop\n    for (size_t i = 0; i < num_primes; i++) {\n        uint32_t prime = primes[i];\n        svbool_t is_divisible = svcmpeq_u32(svindex_u32(0, prime), svdiv_u32(svindex_u32(0, len), svindex_u32(0, prime)));\n        if (svptest_any(p, is_divisible)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <hwy/highway.h>\n\nbool prime_length_simd(const std::string &str) {\n    size_t len = str.length();\n    svbool_t p = svwhilelt_b_u32(0, len);\n\n    // Define a vector of potential divisors\n    svuint32_t divisors = svindex_u32(0, 2, 1); // Start with 2, 3, 4, ...\n\n    // SIMD loop to check divisibility\n    svbool_t is_prime = svcmpeq_m(p, p, svdiv_u32(divisors, len), svdup_n_u32(1));\n\n    // Reduce the vector to determine if any divisor divides the length\n    bool result = svcnot_b_z(p, is_prime);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```c\nbool prime_length_simd(const std::string & str){\n    size_t len = str.length();\n    svbool_t p = svptrue_b64();\n    if(len < 2) return svcmpeq_n_u64(p, len, 1);\n    \n    svbool_t is_prime = svcmpeq_n_u64(p, len, 2);\n    svuint64_t factors = svindex_u64(0, 1);\n    \n    while(svgetlane_u64(factors, 0) * 2 <= len){\n        svbool_t divisible = svcmpeq_n_u64(p, len % svgetlane_u64(factors, 0), 0);\n        is_prime = svbitor_v(p, is_prime, divisible);\n        factors = svadd_n_u64(p, factors, 1);\n    }\n    \n    return !svptest_any(p, is_prime);\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <string>\n\nstd::string solve_simd(uint64_t N) {\n    // Convert the integer to a string for digit extraction\n    char num_str[21];\n    snprintf(num_str, sizeof(num_str), \"%lu\", N);\n    size_t len = strlen(num_str);\n\n    // Determine the vector length\n    size_t vl = svgetvl();\n\n    // Initialize vectors\n    svint8_t digits = svdup_n_s8(0);\n    svuint64_t mask = svcreate_mask_u64(vl);\n\n    // Load digits into vector\n    for (size_t i = 0; i < len; i += vl) {\n        size_t chunk_len = (len - i >= vl) ? vl : len - i;\n        svstr2sve_u8(digits, num_str + i, chunk_len);\n    }\n\n    // Compute the sum of digits\n    svint8_t sum_digits = svabs_s8(svaddv_s8(digits));\n\n    // Convert the sum to binary string\n    uint8_t bin_sum[64] = {0};\n    size_t bin_len = 0;\n    while (sum_digits > 0) {\n        bin_sum[bin_len++] = (sum_digits % 2) + '0';\n        sum_digits /= 2;\n    }\n\n    // Reverse the binary string\n    std::string binary(bin_sum, bin_sum + bin_len);\n    std::reverse(binary.begin(), binary.end());\n\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <string>\n\nstd::string solve_simd(uint64_t N) {\n    size_t vec_len = svcntw(); // Get the vector length\n    uint64_t digits[vec_len];\n    svuint64_t digit_vec;\n    svbool_t pg;\n\n    // Initialize digits array with N repeated across the vector\n    for (size_t i = 0; i < vec_len; ++i) {\n        digits[i] = N;\n    }\n\n    // Load data into SIMD vector\n    digit_vec = svld1_u64(pg, digits);\n\n    // Extract digits in parallel\n    svuint64_t sum_digits = svdup_n_u64(0);\n    while (svcntp_b_u64(pg, digit_vec)) {\n        digit_vec = svuzp1_u64(digit_vec, svsub_u64(digit_vec, svdup_n_u64(10)));\n        sum_digits = svadd_u64(sum_digits, svand_u64(svdup_n_u64(9), digit_vec));\n    }\n\n    // Sum all elements in the vector\n    uint64_t total_sum = svaddv_u64(sum_digits);\n\n    // Convert the sum to binary string\n    std::string binary_str = \"\";\n    while (total_sum > 0) {\n        binary_str = std::to_string(total_sum % 2) + binary_str;\n        total_sum /= 2;\n    }\n\n    return binary_str.empty() ? \"0\" : binary_str;\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <string>\n\nstd::string solve_simd(uint64_t N) {\n    uint8_t buffer[64];\n    size_t count = 0;\n    svbool_t pg = svwhilelt_b8(0, 64);\n\n    // Convert each digit to vector and accumulate\n    while (N > 0) {\n        uint64_t chunk = N % 256;\n        svuint8_t digits = svld1_u8((const uint8_t*)&chunk);\n        svst1_u8(buffer + count, svand_b8(pg, digits, svcreate_b8(0x30)));\n        count += svcntb_b8(pg);\n        N /= 256;\n    }\n\n    // Compute the sum of digits\n    svint32_t sum = svdup_gather_s32((int32_t*)buffer, svindex_s32(0, 1, 1));\n    sum = svadd_x_s32(sum, svsub_x_s32(svtrue_s32(), sum));\n\n    // Convert sum to binary string\n    int32_t sum_val = svlast_s32(sum);\n    std::string result = \"\";\n    while (sum_val > 0) {\n        result += (sum_val % 2 == 1) ? '1' : '0';\n        sum_val /= 2;\n    }\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <string>\n\nstd::string solve_simd(uint64_t N) {\n    // Convert the integer to a string for digit extraction\n    char num_str[21];\n    snprintf(num_str, sizeof(num_str), \"%lu\", N);\n    size_t len = strlen(num_str);\n\n    // Determine the vector length\n    size_t vl = svgetvl();\n\n    // Precompute the maximum vector length for 8-bit elements\n    size_t max_vl = svcntb();\n\n    // Initialize the sum\n    uint64_t sum = 0;\n\n    // Process the digits in vectors\n    for (size_t i = 0; i < len; i += max_vl) {\n        size_t chunk_len = (len - i > max_vl) ? max_vl : (len - i);\n        svint8_t digits = svld1_u8((const uint8_t*)(num_str + i));\n        svint8_t ones = svdup_n_s8(1);\n        svbool_t pg = svwhilelt_b8(0, chunk_len);\n        sum += svcadd_reduce_xn(svptrue_b8(), digits, ones, pg);\n    }\n\n    // Convert the sum to binary string\n    std::string binary_sum;\n    while (sum > 0) {\n        binary_sum.insert(0, 1, (sum % 2) + '0');\n        sum /= 2;\n    }\n\n    return binary_sum.empty() ? \"0\" : binary_sum;\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <string>\n\nstd::string solve_simd(uint64_t N) {\n    uint8_t buffer[64];\n    size_t count = 0;\n    svbool_t pg = svwhilelt_b8(0, 64);\n\n    // Convert each digit to SVE registers\n    while (N > 0) {\n        uint64_t chunk = N % 256;\n        svuint8_t digits = svld1_u8((const uint8_t*)&chunk);\n        svst1_u8(buffer + count, pg, digits);\n        count += svcntw();\n        N /= 256;\n    }\n\n    // Sum the digits\n    svint32_t sum = svdup_n_s32(0);\n    for (size_t i = 0; i < count; i += svcntw()) {\n        svbool_t pg_i = svwhilelt_b32(0, svcntw());\n        svint8_t digits = svld1_u8(buffer + i, pg_i);\n        svint32_t temp = svaddlv_s32(svsub_s32(digits, svdup_n_s8('0')), pg_i);\n        sum = svaddv_s32(sum, temp);\n    }\n\n    // Convert sum to binary string\n    int total_sum = svlast_s32(sum);\n    char result[64];\n    snprintf(result, sizeof(result), \"%s\", \"\");\n    while (total_sum > 0) {\n        snprintf(result, sizeof(result), \"%s%d\", (total_sum & 1) ? \"1\" : \"0\", total_sum & 1);\n        total_sum >>= 1;\n    }\n    std::string binary_str(result);\n    return binary_str;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```c\nint add_simd(std::vector<int> lst){\n    svbool_t pg = svwhilelt_b32(0, lst.size());\n    int sum = 0;\n    for(size_t i = 1; i < lst.size(); i += 2){\n        svbool_t mask = svwhilelt_b32(i, i + svcntb(pg));\n        svint32_t evens = svld1(pg, &lst[i]);\n        svint32_t is_even = svcmpeq_m(pg, svindex_b32(0), svdiv_n(svens(svens(evens)), svones()));\n        svint32_t filtered = svcond(is_even, evens, svundef_h32());\n        sum += svcadd(pg, sum, filtered);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```c\nint add_simd(std::vector<int> lst){\n    svbool_t pg = svwhilelt_b32(0, lst.size());\n    int sum = 0;\n    for(size_t i = 1; i < lst.size(); i += 2){\n        svbool_t mask = svwhilelt_b32(i, i + 2);\n        svint32_t evens = svld1(pg, &lst[i]);\n        svint32_t is_even = svcmpeq_m(pg, svindex_b32(0), svdiv_n(svens(sveadd_m(pg, evens, evens)), svindex_n_u32(1)));\n        sum += svaddv_b32(pg, is_even ? evens : svundef_b32(pg));\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```c\nint add_simd(std::vector<int> lst){\n    svbool_t pg = svwhilelt_b32(0, lst.size());\n    int sum = 0;\n    for(size_t i = 1; i < lst.size(); i += 2){\n        svbool_t mask = svwhilelt_b32(0, lst.size() - i);\n        svint32_t vec = svld1(pg, &lst[i]);\n        svint32_t evens = svcmpeq_m(pg, mask, vec, svindex_s32(0, 2));\n        svint32_t masked_evens = svptrue_b32();\n        masked_evens = svand_b32(masked_evens, evens);\n        svint32_t selected_evens = svsel_b32(vec, svundef_b32(), masked_evens);\n        sum += svcadd_n_s32(sum, svaddv_b32(pg, selected_evens));\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```c\nint add_simd(std::vector<int> lst){\n    svbool_t pg = svwhilelt_b32(0, lst.size());\n    int sum = 0;\n    for(size_t i = 1; i < lst.size(); i += 2){\n        svbool_t mask = svwhilelt_b32(0, std::min(2, (int)(lst.size() - i)));\n        svint32_t evens = svld1(pg, &lst[i]);\n        svint32_t is_even = svcmpeq_m(pg, svindex_b32(0, 2), svmod_m(pg, evens, svindex_s32(2, 0)));\n        svint32_t filtered = svcond(is_even, evens, svdup_n_s32(0));\n        sum += svcadd_v(svptrue_b32(), sum, filtered);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```c\nint add_simd(std::vector<int> lst){\n    svbool_t pg = svwhilelt_b32(0, lst.size());\n    int sum = 0;\n    for(size_t i = 1; i < lst.size(); i += 2){\n        svbool_t mask = svwhilelt_b32(i, i + svcntb(pg));\n        svint32_t evens = svld1(pg, &lst[i]);\n        svint32_t even_mask = svcmpeq_m(pg, mask, evens, svindex_s32(0, 2));\n        svint32_t filtered_evens = svcond(even_mask, evens, svundef_s32());\n        sum += svcadd(pg, sum, filtered_evens);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <cstring>\n#include <string>\n\nstd::string encrypt_simd(const std::string &s) {\n    size_t len = s.size();\n    size_t vec_len = svcntb() * sizeof(uint8_t); // Get vector length in bytes\n    size_t num_vecs = (len + vec_len - 1) / vec_len;\n    \n    // Allocate space for the result\n    std::string result(len, ' ');\n    \n    // Convert input string to array of uint8_t\n    uint8_t in[len + 1];\n    std::memcpy(in, s.c_str(), len);\n    in[len] = 0;\n\n    // Convert result string to array of uint8_t\n    uint8_t out[len + 1];\n    std::memset(out, 0, len + 1);\n\n    for (size_t i = 0; i < num_vecs; ++i) {\n        size_t start = i * vec_len;\n        size_t end = std::min(start + vec_len, len);\n        size_t count = end - start;\n\n        svbool_t pg = svwhilelt_b8(0, count);\n\n        svuint8_t input = svld1_u8(in + start);\n        svuint8_t shifted = svadd_u8(input, svcreate_u8(2));\n        svst1_u8(out + start, pg, shifted);\n    }\n\n    // Convert back to string\n    result.assign(reinterpret_cast<char*>(out));\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <cstring>\n#include <string>\n\nstd::string encrypt_simd(const std::string &s) {\n    size_t len = s.size();\n    size_t vec_len = svcntb() * sizeof(uint8_t); // Number of bytes in a vector\n    size_t num_vecs = (len + vec_len - 1) / vec_len;\n    \n    // Allocate space for the result\n    std::string result(len, ' ');\n    \n    // Convert input string to SVE-friendly arrays\n    svuint8_t in_vec[sve_count1d()];\n    svuint8_t out_vec[sve_count1d()];\n    size_t i = 0;\n\n    while (i < len) {\n        size_t n = std::min(vec_len, len - i);\n        svuint8_t input = svld1_u8((const uint8_t*)(s.c_str() + i));\n        svuint8_t shift = svdup_n_u8(4); // Shift by 2*2 = 4 positions\n\n        svuint8_t output = svadd_u8(input, shift);\n\n        svst1_u8((uint8_t*)(result.data() + i), output);\n\n        i += n;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <cstring>\n#include <string>\n\nstd::string encrypt_simd(const std::string &s) {\n    size_t len = s.size();\n    if (len == 0) return \"\";\n\n    // Allocate space for the result\n    std::string result(len, ' ');\n    svlength_t vl = svquery_vl();\n\n    // Convert input string to vector of characters\n    svuint8_t input_chars = svld1_u8((const uint8_t *)s.c_str(), vl);\n    svuint8_t shift = svdup_n_u8(4); // Shift by 2 * 2\n\n    // Encrypt each character using SIMD\n    svuint8_t encrypted = svadd_u8(input_chars, shift);\n\n    // Wrap around for lowercase letters (a-z)\n    svbool_t p_all = svptrue_b_u8();\n    svuint8_t lower_a = svdup_n_u8('a');\n    svuint8_t lower_z = svdup_n_u8('z');\n    while (svptest_any(p_all, svwhilelt_u8(encrypted, lower_a))) {\n        encrypted = svcond_u8(svuge_u8(encrypted, lower_a), \n                             svsub_u8(encrypted, svsub_u8(svdup_n_u8('z'), lower_a)), \n                             encrypted);\n    }\n\n    // Store the result back to memory\n    svst1_u8((uint8_t *)result.data(), p_all, encrypted);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string &s) {\n    size_t len = s.size();\n    if (len == 0) return \"\";\n\n    // Determine the vector length at runtime\n    size_t vl = svquery_vl();\n\n    // Convert input string to array of unsigned chars\n    svcvec_u8 input = svld1_u8((const uint8_t *)s.data());\n\n    // Initialize output vector\n    svcvec_u8 output = svdup_u8(0);\n\n    // Define the rotation amount (2 * 2 = 4)\n    int rot_amount = 4;\n\n    // Encrypt each character using SVE\n    for (size_t i = 0; i < len; i += vl) {\n        size_t chunk_len = (len - i >= vl) ? vl : len - i;\n        svcvec_u8 chars = svld1_u8((const uint8_t *)s.data() + i);\n        svcvec_u8 shifted = svlsl_u8(chars, svindex_u8(0, 1, 1)); // Shift left by 2\n        svcvec_u8 rotated = svadd_u8(shifted, svindex_u8(0, rot_amount, rot_amount));\n        svst1_u8((uint8_t *)s.data() + i, rotated);\n    }\n\n    return s;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string &s) {\n    size_t len = s.size();\n    if (len == 0) return \"\";\n\n    // Determine the vector length at runtime\n    size_t vl = svquery_vl();\n\n    // Convert input string to array of unsigned chars\n    uint8_t input[len];\n    for (size_t i = 0; i < len; ++i) {\n        input[i] = static_cast<uint8_t>(s[i]);\n    }\n\n    // Allocate space for output\n    uint8_t output[len];\n\n    // Process data using SVE\n    size_t i = 0;\n    while (i < len) {\n        size_t chunk_len = std::min(len - i, vl / sizeof(uint8_t));\n        svbool_t pg = svwhilelt_b8(0, chunk_len);\n\n        // Load data\n        svuint8_t vec_in = svld1_u8(pg, input + i);\n\n        // Encrypt: shift by 4 ('a' -> 'e', 'b' -> 'f', etc.)\n        svuint8_t vec_out = svadd_u8(vec_in, svdup_n_u8(4));\n\n        // Store result\n        svst1_u8(pg, output + i, vec_out);\n\n        i += chunk_len;\n    }\n\n    // Convert back to string\n    std::string result = \"\";\n    for (size_t j = 0; j < len; ++j) {\n        result += static_cast<char>(output[j]);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <string>\n\nstd::string encode_simd(const std::string &message) {\n    size_t len = message.length();\n    if (len == 0) return \"\";\n\n    // Convert input string to array of characters\n    svint8_t vowels = svld1_s8((const int8_t *)\"aeiouAEIOU\");\n    svint8_t shift = svld1_s8((const int8_t *)\"cgikmoCGIKMO\"); // Shifted by 2 positions\n    svbool_t pg = svptrue_b8();\n\n    size_t vector_length = svcntb(); // Get the vector length\n    svint8_t result = svdup_n_s8(0);\n\n    for (size_t i = 0; i < len; i += vector_length) {\n        size_t chunk_len = (len - i < vector_length) ? len - i : vector_length;\n        svint8_t chars = svld1_s8((const int8_t *)&message[i]);\n        svbool_t p = svwhilelt_b8(i + svcntb(), len);\n\n        // Swap case\n        svint8_t swapped_case = svabs_s8(chars ^ (1 << 5));\n\n        // Replace vowels\n        svint8_t mask = svcmpeq_b8(vowels, swapped_case);\n        svint8_t replaced = svsel_b8(mask, shift, swapped_case);\n\n        // Store the result\n        result = svmerge_b8(result, replaced, p);\n    }\n\n    // Convert back to string\n    std::string encoded(len, ' ');\n    for (size_t i = 0; i < len; ++i) {\n        encoded[i] = (char)svgetlane_s8(result, i);\n    }\n    return encoded;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <string>\n\nstd::string encode_simd(const std::string &message) {\n    size_t len = message.length();\n    if (len == 0) return \"\";\n\n    // Convert input string to array of chars\n    svint8_t v_input = svld1_s8((const int8_t *)message.c_str());\n    svint8_t v_result = svdup_s8(0);\n    size_t i = 0;\n\n    while (i < len) {\n        svint8_t v_chars = svld1_s8((const int8_t *)message.c_str() + i);\n        svbool_t pg = svwhilelt_b8(0, svcntb());\n\n        // Swap case\n        svint8_t v_swapped_case = svcond_b8(\n            svcmpeq_b8(v_chars, svcnot_b8(svindex_u8('a', 'z'))), \n            svsub_s8(v_chars, svcgeq_u8('A', 'Z')), \n            svadd_s8(v_chars, svcgeq_u8('a', 'z'))\n        );\n\n        // Replace vowels\n        svint8_t v_replaced_vowels = svmap_b8(pg, v_swapped_case, [](svint8_t x) {\n            return svsel_b8(\n                svcmpeq_b8(x, svcnot_b8(svindex_u8('a', 'e', 'i', 'o', 'u'))),\n                x,\n                svadd_s8(x, svcgeq_u8('c', 'y'))\n            );\n        });\n\n        // Store result\n        svst1_s8((int8_t *)v_result, v_replaced_vowels);\n\n        i += svcntb();\n    }\n\n    // Convert back to string\n    char result[len + 1];\n    svst1_s8((int8_t *)result, v_result);\n    result[len] = '\\0';\n    return std::string(result);\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <string>\n\nstd::string encode_simd(const std::string &message) {\n    size_t len = message.length();\n    svbool_t pg = svwhilelt_b32(0, len);\n    \n    // Define vowels and their replacements\n    const char vowel_replacements[5] = {'V', 'W', 'X', 'Y', 'Z'};\n    svint8_t vowels = svld1_s8(vowel_replacements);\n    \n    std::string result = message;\n    svint8_t res_vec;\n    \n    for (size_t i = 0; i < len; i += svcntb()) {\n        svint8_t chars = svld1_s8(message.data() + i);\n        svbool_t mask = svwhilelt_b32(i, len);\n        \n        // Swap case\n        svint8_t swapped_case = svabs_s8(chars ^ (1 << 5));\n        \n        // Replace vowels\n        svint8_t replaced = svmlal_s8(mask, swapped_case, vowels);\n        \n        // Store back to result\n        svst1_s8(result.data() + i, replaced);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <string>\n\nstd::string encode_simd(const std::string &message) {\n    size_t len = message.size();\n    if (len == 0) return \"\";\n\n    // Convert string to array of unsigned chars\n    svint8_t vowels = svld1_s8((const int8_t *)\"aeiouAEIOU\");\n    svint8_t shift = svld1_s8((const int8_t *)\"cgikmoCGIKMO\");\n    svbool_t pg = svwhilelt_b8(0, len);\n\n    size_t i = 0;\n    std::string result = message;\n\n    while (svptest_any(svptrue_b8(), pg)) {\n        svint8_t chars = svld1_u8((const uint8_t *)result.data() + i);\n        svbool_t mask = svptest_first_b8(pg);\n\n        // Swap case\n        svint8_t swapped_case = svabs_s8(chars ^ (1 << 5));\n\n        // Replace vowels\n        svint8_t replaced = svsel_s8(\n            svcntb(),\n            svcmpeq_n_s8(swapped_case, vowels),\n            swapped_case,\n            shifted_chars\n        );\n\n        // Store back to result\n        svst1_u8((uint8_t *)result.data() + i, replaced);\n\n        // Update pointers\n        i += svcntb();\n        pg = svwhilelt_b8(i, len);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <string>\n\nstd::string encode_simd(const std::string &message) {\n    size_t len = message.size();\n    if (len == 0) return \"\";\n\n    // Determine the vector length at runtime\n    size_t vl = svcntb() * 8;\n\n    // Convert input string to array of unsigned chars\n    svcvec_u8 vec_in = svld1_u8((const uint8_t *)message.c_str());\n\n    // Initialize output vector\n    svcvec_u8 vec_out = svdup_u8(0);\n\n    // Define masks for vowels\n    svcvec_u8 mask_a = svcmpeq_n_u8('a', vec_in);\n    svcvec_u8 mask_e = svcmpeq_n_u8('e', vec_in);\n    svcvec_u8 mask_i = svcmpeq_n_u8('i', vec_in);\n    svcvec_u8 mask_o = svcmpeq_n_u8('o', vec_in);\n    svcvec_u8 mask_u = svcmpeq_n_u8('u', vec_in);\n\n    // Define shifts for vowels\n    svcvec_u8 shift_a = svadd_n_u8('a', 2);\n    svcvec_u8 shift_e = svadd_n_u8('e', 2);\n    svcvec_u8 shift_i = svadd_n_u8('i', 2);\n    svcvec_u8 shift_o = svadd_n_u8('o', 2);\n    svcvec_u8 shift_u = svadd_n_u8('u', 2);\n\n    // Process each character\n    for (size_t i = 0; i < len; i += vl) {\n        svcvec_u8 chunk = svld1_u8((const uint8_t *)message.c_str() + i);\n\n        // Swap case\n        svcvec_u8 lower = svand_u8(chunk, svptrue_b8());\n        svcvec_u8 upper = svbic_u8(chunk, svptrue_b8());\n\n        // Replace vowels\n        svcvec_u8 new_chunk = svsel_u8(svorr(mask_a, mask_e), shift_a, chunk);\n        new_chunk = svsel_u8(svorr(mask_i, mask_o), shift_i, new_chunk);\n        new_chunk = svsel_u8(mask_u, shift_u, new_chunk);\n\n        // Combine swapped case and vowel replacements\n        svcvec_u8 final_chunk = svorr_u8(new_chunk, svbic_u8(lower, svptrue_b8()));\n\n        // Store result\n        svst1_u8((uint8_t *)vec_out + i, final_chunk);\n    }\n\n    // Convert back to string\n    std::string encoded(len, '0');\n    for (size_t i = 0; i < len; ++i) {\n        encoded[i] = (char)svget_u8(vec_out, i);\n    }\n    return encoded;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <arm_neon.h>\n#include <string.h>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict){\n    size_t count = dict.size();\n    if(count == 0) return false;\n\n    // Determine the vector length\n    size_t vl = svcntb();\n\n    // Convert map to array of strings\n    std::vector<std::string> keys;\n    for(const auto &pair : dict){\n        keys.push_back(pair.first);\n    }\n\n    // SIMD variables\n    svbool_t all_upper = svptrue_b8(vl);\n    svbool_t all_lower = svptrue_b8(vl);\n\n    for(size_t i=0; i < count; i+=vl){\n        size_t len = keys[i].length();\n        svbool_t mask = svwhilelt_b8((int)i, (int)count);\n        svbool_t valid_len = svcmpeq_b8(svindex_u8(0, len), svindex_u8(0, vl));\n\n        svbool_t upper_check = valid_len;\n        svbool_t lower_check = valid_len;\n\n        for(int j=0; j < vl; j++){\n            if(!svptest_any(mask, svindex_b8(j))){\n                continue;\n            }\n            uint8_t c = keys[i+j][j];\n            if(c >= 'A' && c <= 'Z'){\n                lower_check = svand_b8(lower_check, svcmpeq_b8(svindex_u8(0, c), svindex_u8(0, c)));\n            }\n            if(c >= 'a' && c <= 'z'){\n                upper_check = svand_b8(upper_check, svcmpeq_b8(svindex_u8(0, c), svindex_u8(0, c)));\n            }\n            else{\n                upper_check = svfalse_b8();\n                lower_check = svfalse_b8();\n            }\n        }\n\n        all_upper = svand_b8(all_upper, upper_check);\n        all_lower = svand_b8(all_lower, lower_check);\n    }\n\n    return (svptest_any(all_upper, svptrue_b8(vl)) || svptest_any(all_lower, svptrue_b8(vl))) ? true : false;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <arm_neon.h>\n#include <string.h>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    size_t count = dict.size();\n    if (count == 0) return false;\n\n    // Determine the vector length\n    size_t vl = svcntb();\n\n    // Convert map to array of strings\n    std::vector<std::string> keys;\n    for (const auto &pair : dict) {\n        keys.push_back(pair.first);\n    }\n\n    // SIMD processing\n    bool all_upper = true;\n    bool all_lower = true;\n    size_t i = 0;\n    while (i < count) {\n        size_t len = keys[i].length();\n        svbool_t pg = svwhilelt_b8((int)i, (int)count);\n\n        // Load key characters\n        svuint8_t upper_mask = svindex_u8(0, 1);\n        svuint8_t lower_mask = svindex_u8(0, 1);\n        svuint8_t chars[sve_len / sizeof(uint8_t)];\n        for (size_t j = 0; j < len; j++) {\n            chars[j] = svle_u8(keys[i][j]);\n        }\n\n        // Check for uppercase\n        svbool_t upper_check = svcmpeq_b8(chars, svindex_u8('A', 'Z'));\n        all_upper &= svptest_any(svptrue_b8(), upper_check);\n\n        // Check for lowercase\n        svbool_t lower_check = svcmpeq_b8(chars, svindex_u8('a', 'z'));\n        all_lower &= svptest_any(svptrue_b8(), lower_check);\n\n        i += vl;\n    }\n\n    return all_upper || all_lower;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <arm_neon.h>\n#include <string.h>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    size_t count = dict.size();\n    if (count == 0) return false;\n\n    // Determine the number of elements per vector\n    size_t vl = svquery_vl();\n    size_t elements_per_vector = vl / sizeof(char*);\n\n    // Convert map to array of char* for SVE processing\n    char** keys = new char*[count];\n    size_t i = 0;\n    for (auto& pair : dict) {\n        keys[i++] = const_cast<char*>(pair.first.c_str());\n    }\n\n    // Initialize flags\n    svbool_t all_upper = svptrue_b_u8();\n    svbool_t all_lower = svptrue_b_u8();\n\n    for (i = 0; i < count; i += elements_per_vector) {\n        size_t n = count - i;\n        if (n < elements_per_vector) break;\n\n        svbool_t mask = svwhilelt_b_u32(i, count);\n        svuint8_t upper_mask = svcmpeq_n_u8(svld1_u8(keys + i), 'A');\n        svuint8_t lower_mask = svcmpeq_n_u8(svld1_u8(keys + i), 'a');\n\n        all_upper = svand_b_u8(all_upper, svcmpeq_b_u8(svmax_u8(svld1_u8(keys + i), 'A'), svmin_u8(svld1_u8(keys + i), 'Z')));\n        all_lower = svand_b_u8(all_lower, svcmpeq_b_u8(svmax_u8(svld1_u8(keys + i), 'a'), svmin_u8(svld1_u8(keys + i), 'z')));\n\n        if (!svptest_any(mask, all_upper) && !svptest_any(mask, all_lower)) {\n            delete[] keys;\n            return false;\n        }\n    }\n\n    bool result = (svptest_any(svptrue_b_u8(), all_upper) || svptest_any(svptrue_b_u8(), all_lower));\n    delete[] keys;\n    return result;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <arm_neon.h>\n#include <string.h>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict){\n    size_t count = dict.size();\n    if(count == 0) return false;\n\n    // Convert map to array of strings for processing\n    const char **keys = new const char*[count];\n    size_t i = 0;\n    for(auto &pair : dict){\n        keys[i++] = pair.first.c_str();\n    }\n\n    // SIMD vector length in bytes\n    size_t vl = sve_len() / 8;\n\n    // Initialize flags\n    svbool_t all_upper = svptrue_b8_h();\n    svbool_t all_lower = svptrue_b8_h();\n\n    for(i = 0; i < count; i += vl){\n        size_t len = strlen(keys[i]);\n        svbool_t valid = svptrue_b8_h();\n        svuint8_t upper_mask = svdup_u8(0);\n        svuint8_t lower_mask = svdup_u8(0);\n\n        for(size_t j = 0; j < len && (i + j) < count; j++){\n            svuint8_t c = svld1_u8((const uint8_t*)(keys[i + j]));\n            svbool_t is_upper = svcmpeq_u8(c, svindex_u8('A', 'Z'));\n            svbool_t is_lower = svcmpeq_u8(c, svindex_u8('a', 'z'));\n\n            upper_mask = svorr_u8(upper_mask, svcond_b8(is_upper, svdup_u8(1), svdup_u8(0)));\n            lower_mask = svorr_u8(lower_mask, svcond_b8(is_lower, svdup_u8(1), svdup_u8(0)));\n\n            valid = svand_b8(valid, is_upper || is_lower);\n        }\n\n        all_upper = svand_b8(all_upper, svcmpeq_u8(upper_mask, svdup_u8(len)));\n        all_lower = svand_b8(all_lower, svcmpeq_u8(lower_mask, svdup_u8(len)));\n    }\n\n    bool result = (svptest_any(all_upper) || svptest_any(all_lower));\n    delete[] keys;\n    return result;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <arm_neon.h>\n#include <string.h>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict){\n    size_t count = dict.size();\n    if(count == 0) return false;\n\n    // Determine the vector length\n    size_t vl = svcntb();\n\n    // Convert map to array of strings\n    std::vector<std::string> keys;\n    for(const auto &pair : dict){\n        keys.push_back(pair.first);\n    }\n\n    // SIMD variables\n    svbool_t all_upper = svptrue_b8(vl);\n    svbool_t all_lower = svptrue_b8(vl);\n\n    for(size_t i=0; i < count; i+=vl){\n        size_t len = keys[i].length();\n        svbool_t mask = svwhilelt_b8((int)i, (int)count);\n        svfloat32_t upper_check = svdup_gather_mask_f32(mask, (const float32_t*)keys[i].c_str());\n        svfloat32_t lower_check = svdup_gather_mask_f32(mask, (const float32_t*)keys[i].c_str());\n\n        for(int j=0; j<len; j++){\n            uint8_t c = keys[i][j];\n            if(c >= 'A' && c <= 'Z'){\n                lower_check = svsel_b8(svcmpeq_b8(svindex_u8(j), svindex_u8(0)), \n                                       svdup_f32(1.0f), lower_check);\n            }\n            if(c >= 'a' && c <= 'z'){\n                upper_check = svsel_b8(svcmpeq_b8(svindex_u8(j), svindex_u8(0)), \n                                       svdup_f32(1.0f), upper_check);\n            }\n        }\n\n        all_upper = svand_b8(all_upper, upper_check);\n        all_lower = svand_b8(all_lower, lower_check);\n    }\n\n    return (svptest_any_b8(all_upper) || svptest_any_b8(all_lower));\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n){\n    if(n <= 2){\n        return std::vector<int>();\n    }\n    \n    size_t vec_len = svcntw();\n    size_t total_count = 0;\n    std::vector<int> primes;\n    svbool_t pg = svwhilelt_b(wtrue, n);\n    \n    // Initialize a vector to hold potential primes\n    svuint32_t candidates = svindex_w_u(0, 1);\n    \n    while(svptest_any(pg)){\n        svbool_t pgt = svwhilelt_b(pg, n);\n        \n        // Sieve of Eratosthenes logic\n        for(svuint32_t i = svindex_w_u(2, 1); svcmpeq_m(pgt, pg, i, svtrue_h()); ){\n            svbool_t mask = svcmpeq_m(pgt, pg, candidates, svtrue_h());\n            if(svptest_any(mask)){\n                primes.push_back((int)sveal(pgt, candidates, mask));\n                candidates = svmla_x(pgt, candidates, i);\n            }\n            else{\n                break;\n            }\n        }\n        \n        // Move to the next segment\n        pg = svtail(pg);\n    }\n    \n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n){\n    if(n <= 2){\n        return std::vector<int>();\n    }\n    \n    size_t vec_len = svcntw();\n    size_t total_count = 0;\n    std::vector<int> primes;\n    svbool_t pg = svtrue_n_s32(vec_len);\n    \n    // Initialize a vector to hold potential primes\n    svuint32_t candidates = svindex_u32(0, 1, vec_len);\n    \n    while(svget_lane_u32(candidates, 0) < n){\n        // Create a predicate for numbers less than n\n        svbool_t mask = svcmp_lt(pg, candidates, n);\n        \n        // Check primality for each candidate in parallel\n        svbool_t is_prime = svtrue_n_s32(vec_len);\n        for(size_t i=2; i*i < n; ++i){\n            svbool_t divisible = svcmpeq(pg, candidates, i * svindex_u32(i, 1, vec_len));\n            is_prime = svand(pg, is_prime, svnot_b32(divisible));\n        }\n        \n        // Collect primes\n        svbool_t prime_mask = svand(pg, mask, is_prime);\n        size_t count = svcntb(prime_mask);\n        size_t* indices = (size_t*)malloc(count * sizeof(size_t));\n        svuint32_t prime_candidates;\n        sveq_u32(pg, prime_mask, candidates, &prime_candidates);\n        for(size_t j=0; j<count; ++j){\n            primes.push_back(svget_lane_u32(prime_candidates, j));\n        }\n        \n        // Move to the next set of candidates\n        candidates = svadd_u32(candidates, svindex_u32(vec_len, 1, vec_len));\n    }\n    \n    free(indices);\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n){\n    if(n <= 2){\n        return std::vector<int>();\n    }\n    \n    size_t vec_len = sve_len / sizeof(int);\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t primes = svundef_b32();\n    int current = 2;\n    \n    while(svptest_any(pg)){\n        svint32_t range = svindex_b32(pg, current, current + vec_len -1);\n        svbool_t mask = svcmpeq_n_b32(range, current);\n        \n        // Sieve of Eratosthenes logic here\n        // This is a placeholder for the actual sieve implementation using SVE intrinsics\n        \n        current += vec_len;\n    }\n    \n    // Convert the result vector to std::vector<int>\n    std::vector<int> result;\n    result.reserve(svcount_b32(primes));\n    for(int i=0; i<n; ++i){\n        if(svgetlane_b32(primes, i)){\n            result.push_back(i);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n){\n    if(n <= 2){\n        return std::vector<int>();\n    }\n    \n    size_t vec_len = svquery_vl(SVE_VEC_LENGTH_MAX);\n    size_t max_len = n - 1;\n    svbool_t pg = svwhilelt_b((int32_t)n, 2);\n    \n    svint32_t sieve = svindex_b_u32(pg, 2, 1);\n    svbool_t all_set = svptrue_b32();\n    \n    for(svuint32_t p = svabs_s32(svindex_b_u32(all_set, 2, 1)); svcmpeq_m(all_set, pg, p, p); p += 1){\n        svuint32_t mask = svmls_b32(all_set, sieve, svuzp1_u32(p, p));\n        sieve = svselect_b32(mask, sieve, svundef_u32());\n        all_set = svand_b32(all_set, mask);\n        \n        if(svcmpeq_m(all_set, pg, p, p)){\n            break;\n        }\n    }\n    \n    std::vector<int> primes;\n    svint32_t indices = svindex_b_u32(pg, 0, 1);\n    svbool_t non_zero = svcmpeq_m(all_set, pg, sieve, indices);\n    \n    for(size_t i = 0; i < vec_len; ++i){\n        if(svnarrow_s32_s16(svget_h32(non_zero, i))){\n            primes.push_back(svget_h32(sieve, i));\n        }\n    }\n    \n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n){\n    if(n <= 2){\n        return std::vector<int>();\n    }\n    \n    size_t vec_len = svcntw();\n    size_t max_len = n - 2;\n    size_t num_vecs = (max_len + vec_len - 1) / vec_len;\n    \n    // Initialize vectors\n    svbool_t pg = svwhilelt_b32(0, n);\n    svuint32_t primes = svundef_u32();\n    svuint32_t candidates = svindex_u32(0, 1);\n    \n    // Sieve of Eratosthenes using SVE\n    for(svuint32_t i = svindex_u32(2, 1); svcmpeq_m(pg, svcmpge_u32(i, svdup_n_u32(n))); i += svdup_n_u32(1)){\n        svbool_t mask = svcmpeq_m(pg, svcmpeq_u32(candidates, svdup_n_u32(0)));\n        primes = svsel_u32(primes, svorr_b32(pg, svtrue_b32()), mask);\n        candidates = svcntmask_b32(svand_b32(mask, svcmpgt_u32(candidates, svdup_n_u32(0)))) ? svmla_u32(candidates, i, candidates) : candidates;\n    }\n    \n    // Collect results\n    std::vector<int> result;\n    for(svuint32_t j = svindex_u32(0, 1); svcmpeq_m(pg, svcmpge_u32(j, svdup_n_u32(n - 2))); j += svdup_n_u32(1)){\n        if(svcmpeq_u32(primes[j], svdup_n_u32(1))){\n            result.push_back(j + 2);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```c\nint count_upper_simd(const std::string & s){\n    svbool_t pg = svwhilelt_b32(0, svcntw());\n    svint8_t indices = svindex_b8_h(0, 2);\n    svuint8_t upper_vowels = svcreate_h<uint8_t>({'A','E','I','O','U'});\n    svuint8_t count = svdup_n_u8(0);\n    \n    for(size_t i = 0; i < s.size(); i += svcntw() * 2){\n        svuint8_t chars = svld1_u8((const uint8_t*)&s[i], pg);\n        svbool_t mask = svcmpeq_b8(chars, indices);\n        svbool_t vowel_mask = svcmpeq_b8(chars, upper_vowels);\n        svbool_t final_mask = svand_b8(mask, vowel_mask);\n        count = svadd_u8(count, svcntb_b8(final_mask));\n    }\n    \n    return svaddv_u8(count);\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```c\nint count_upper_simd(const std::string & s){\n    svbool_t pg = svwhilelt_b32(0, svcntw());\n    svint8_t indices = svindex_b8_h(0, 2);\n    svuint8_t upper_vowels = svcreate_h_u8('A', 'E', 'I', 'O', 'U');\n    svuint8_t count = svdup_n_u8(0);\n    \n    for (size_t i = 0; i < s.size(); i += svcntw() * 2){\n        svuint8_t chars = svld1_u8((const uint8_t*)&s[i], pg);\n        svbool_t mask = svcmpeq_n_u8(chars, indices);\n        svbool_t is_upper_vowel = svcmpeq_n_u8(chars, upper_vowels);\n        is_upper_vowel = svand_b8(is_upper_vowel, mask);\n        count = svadd_u8(count, svcntb_b8(is_upper_vowel));\n    }\n    \n    return svaddv_u8(count);\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```c\nint count_upper_simd(const std::string & s){\n    svbool_t pg = svwhilelt_b32(0, svcntw());\n    const char * str = s.data();\n    int count = 0;\n    svuint8_t upper_vowels = svld1_u8((const uint84_t *) \"AEIOU\");\n    svbool_t p0 = svptrue_b32();\n    \n    while(sve_while(pg)){\n        svuint8_t chars = svld1_u8(str, pg);\n        svbool_t even_mask = svcmpeq_w32(svindexhi_u32(0), svindexhi_u32(0));\n        svbool_t is_upper_vowel = svcmpeq_u8(chars, upper_vowels);\n        svbool_t is_even_and_upper_vowel = svand_b8(even_mask, is_upper_vowel);\n        count += svcntb() - svcntb(svtz_b8(is_even_and_upper_vowel));\n        str += svcntb();\n        pg = svwhilelt_b32((int)(str - s.data()), svcntw());\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```c\nint count_upper_simd(const std::string & s){\n    svbool_t pg = svwhilelt_b32(0, svcntw());\n    svint8_t indices = svindex_b8_h(0, 2);\n    svuint8_t upper_vowels = svcreate_h_u8('A', 'E', 'I', 'O', 'U');\n    int count = 0;\n    svint8_t chars = svld1(pg, (const char *)s.c_str());\n\n    svbool_t p0 = svcmpeq_n_s8(chars, indices);\n    svbool_t p1 = svptrue_b8();\n    svbool_t p2 = svand_b8(p0, p1);\n\n    svuint8_t filtered_chars = svcond_u8(p2, svtbl1_u8(chars, indices), svdup_n_u8(0));\n    svbool_t matches = svcmpeq_n_u8(filtered_chars, upper_vowels);\n\n    count += svcntd() - svcntz_d(svtbz_b8(matches));\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```c\nint count_upper_simd(const std::string & s){\n    svbool_t pg = svwhilelt_b32(0, svcntw());\n    svint8_t indices = svindex_b8_h(0, 2);\n    svuint8_t upper_vowels = svcreate_h_u8('A', 'E', 'I', 'O', 'U');\n    int count = 0;\n    svint8_t chars = svld1(pg, (char*)s.c_str());\n\n    svbool_t mask = svcmpeq_n_s8(chars, indices);\n    svbool_t is_upper = svcmpeq_n_s8(chars, upper_vowels);\n\n    svbool_t cond = svand_b8(mask, is_upper);\n    count += svcntb() - svcntp_b8(cond);\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n){\n    size_t vl = sve_len_n / sizeof(int); // Get the vector length\n    svint32_t result = svdup_n_s32(0);   // Initialize result vector\n    int current = n;                     // Start with the input number\n\n    for(size_t i = 0; i < vl; ++i){\n        int is_odd = current % 2;\n        current += 2 - is_odd;           // Next odd/even number\n        result = svsetlane_s32(result, i, current);\n    }\n\n    std::vector<int> output(svlen_to_size(vl));\n    svint32_t_to_int32_t(result, output.data());\n    return output;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n){\n    size_t vl = sve_len_n / sizeof(int); // Get vector length\n    svint32_t res = svdup_n_s32(n);     // Initialize vector with input n\n\n    // Compute the step based on parity\n    int step = (n % 2 == 0) ? 2 : 1;\n    svint32_t step_vec = svdup_n_s32(step);\n\n    for(size_t i = 1; i < vl; ++i){\n        res = svmla_s32(res, svtrue_h(), step_vec);\n    }\n\n    std::vector<int> result(svlen_to_size_t(vl));\n    svint32_t_to_blasint32(res, result.data());\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n){\n    size_t vl = svquery_vl(SVE_VEC_LENGTH_B);\n    size_t elements_per_vector = vl / sizeof(int);\n    std::vector<int> result(elements_per_vector * 2); // Allocate enough space\n    svint32_t vec_n = svdup_n_s32(n);\n    \n    svbool_t pg = svwhilelt_b32(0, elements_per_vector);\n    \n    while(svptest_any(svptrue_b32(), pg)){\n        svint32_t current = svundef_s32();\n        svbool_t mask = pg;\n        \n        // Initialize the first value\n        current = svsel_b32(mask, svadd_n_s32(vec_n, svindexhi_s32(mask, 0)), current);\n        mask = svptrue_b32(); // All elements active\n        \n        // Compute subsequent values\n        svint32_t step = svdup_n_s32(2);\n        current = svsel_b32(mask, svadd(current, step), current);\n        \n        // Store results\n        svst1_s32(result.data(), pg, current);\n        \n        // Prepare for next iteration if needed\n        pg = svwhilelt_b32(svget_lane_s32(current, elements_per_vector - 1), n + elements_per_vector * 2);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n){\n    size_t vl = svquery_vl();\n    size_t elements_per_vector = vl / sizeof(int);\n    std::vector<int> result(elements_per_vector);\n\n    svint32_t vec_n = svdup_n_s32(n);\n    svbool_t pg = svwhilelt_b32(0, elements_per_vector);\n\n    svint32_t vec_result = svadd_x_s32(pg, vec_n, svindex_u32_b32(pg, 1));\n    \n    // Determine if the current index is odd or even\n    svbool_t is_odd = svcmpeq_w_b32(pg, svindex_u32_b32(pg, 0), svand_n_u32(vec_n, 1));\n\n    // Add the appropriate increment (next odd/even number)\n    vec_result = svcond_b32(is_odd, svadd_x_s32(pg, vec_result, 2), vec_result);\n\n    svst1_s32(&result[0], pg, vec_result);\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n){\n    size_t vl = svquery_vl(SVE_VEC_LENGTH_BASIS);\n    size_t elements_per_vector = vl / sizeof(int);\n    std::vector<int> result(elements_per_vector * 2); // Allocate enough space\n    svint32_t vec_n = svdup_n_s32(n);\n    \n    svbool_t pg = svwhilelt_b32(0, elements_per_vector);\n    \n    while(svptest_any(svptrue_b32(), pg)){\n        svint32_t current = svundef_s32();\n        svbool_t pg_inner = svwhilelt_b32(0, elements_per_vector);\n        \n        // Initialize the first value\n        current = svsel_b32(pg_inner, svadd_n_s32(vec_n, svindex_s32(0,1)), current);\n        pg_inner = svlsb_b32(pg_inner);\n        \n        // Compute subsequent values\n        while(svptest_any(svptrue_b32(), pg_inner)){\n            svint32_t is_odd = svcmpeq_m_b32(pg_inner, svand_b32(pg_inner, svcmpeq_s32(current, svand_s32(current, svindex_s32(1,1))))));\n            current = svsel_b32(is_odd, svadd_n_s32(current, svindex_s32(2,1)), svadd_n_s32(current, svindex_s32(1,1)));\n            pg_inner = svlsb_b32(pg_inner);\n        }\n        \n        svst1_s32(result.data() + svcnts_b32(pg)*svcnts_b32(pg_inner), pg, current);\n        pg = svlsb_b32(pg);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdint.h>\n#include <stdio.h>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m){\n    if (n > m) {\n        return \"-1\";\n    }\n\n    int64_t count = m - n + 1;\n    svint64_t vec_n = svindex_s64(0, 1); // Generate vector [0, 1, 2, ..., count-1]\n    vec_n = svaddv_s64(vec_n, svdup_s64(n)); // Add n to each element\n\n    svint64_t sum_vec = svmla_s64(svindex_s64(0, 1), svdup_s64(1), vec_n);\n    int64_t sum = svcadd_s64(svptrue_b64(), 0, sum_vec);\n\n    int64_t avg = (sum + (count / 2)) / count; // Round to nearest integer\n    uint64_t binary_val = (uint64_t)avg;\n\n    char buffer[64];\n    snprintf(buffer, sizeof(buffer), \"%b\", binary_val);\n    return std::string(buffer);\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <bit>\n#include <string>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m){\n    if (n > m) {\n        return \"-1\";\n    }\n\n    int64_t count = m - n + 1;\n    int64_t sum = 0;\n\n    svint64_t vec_n = svindex_s64(0, 1); // Generate vector [0, 1, 2, ..., count-1]\n    vec_n = svadd_s64(vec_n, svdup_s64(n)); // Add n to each element\n\n    size_t vl = svcntd(); // Get vector length\n    svint64_t vec_sum = svmla_s64(svindex_s64(0, 1), svtrue_s64(), svdup_s64(0)); // Initialize vector sum\n\n    for (size_t i = 0; i < count; i += vl) {\n        svint64_t vec_i = svld1_s64(vec_n + i);\n        vec_sum = svmla_s64(vec_sum, vec_i, vec_i);\n    }\n\n    sum = svcadd_s64(svptrue_s64(), sum, svaddv_s64(vec_sum));\n\n    int64_t average = (sum + (count / 2)) / count;\n    uint64_t binary_result = static_cast<uint64_t>(average);\n    std::string binary_str = std::bitset<64>(binary_result).to_string();\n\n    // Find the first '1' to strip leading zeros\n    size_t first_one = binary_str.find('1');\n    if (first_one != std::string::npos) {\n        binary_str = binary_str.substr(first_one);\n    } else {\n        binary_str = \"0\";\n    }\n\n    return binary_str;\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <bit>\n#include <string>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m){\n    if (n > m) {\n        return \"-1\";\n    }\n\n    // Compute the number of elements\n    int64_t count = m - n + 1;\n\n    // Compute the sum using SVE\n    svint64_t indices = svindex_b64(0, 1); // Generate vector of indices [0, 1, ..., count-1]\n    svint64_t start = svdup_n_b64(n);      // Duplicate n into a vector\n    svint64_t range = svadd_x_b64(start, indices); // Generate [n, n+1, ..., m]\n\n    svint64_t sum_vec = svabd_x_b64(svindex_b64(0, 1), svindex_b64(0, 1)); // Initialize sum vector\n    svbool_t pg = svwhilelt_b64(0, count); // Predicate for the range\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        sum_vec = svadd_x_b64(sum_vec, svld1(pg, range));\n        pg = svwhilelt_b64(svget_lane_b64(sum_vec, 0), count);\n    }\n\n    int64_t sum = svaddv_b64(sum_vec);\n\n    // Compute the average and round\n    int64_t avg = (sum + (count / 2)) / count;\n\n    // Convert to binary string\n    std::string binary = std::bitset<64>(avg).to_string();\n    size_t pos = binary.find('1');\n    if (pos != std::string::npos) {\n        binary = binary.substr(pos);\n    } else {\n        binary = \"0\";\n    }\n\n    return binary;\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <bit>\n#include <string>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m){\n    if (n > m) {\n        return \"-1\";\n    }\n\n    // Compute the number of elements\n    int64_t count = m - n + 1;\n\n    // Compute the sum using SVE\n    svint64_t indices = svindex_b64(0, 1); // Generate vector of indices [0, 1, ..., count-1]\n    svint64_t start = svdup_n_s64(n);      // Duplicate the value of 'n' into a vector\n    svint64_t range = svadd_x_s64(start, indices); // Create the range [n, n+1, ..., m]\n\n    svint64_t sum_vec = svaddv_s64(range); // Sum all elements in the vector\n\n    // Convert sum to scalar\n    int64_t sum = svcvt_s64_s64(sum_vec);\n\n    // Compute the average and round to the nearest integer (smaller one)\n    int64_t avg = (sum + (count / 2)) / count;\n\n    // Convert the result to binary string\n    std::string binary = std::bitset<64>(avg).to_string();\n    size_t pos = binary.find('1');\n    if (pos != std::string::npos) {\n        binary = binary.substr(pos);\n    } else {\n        binary = \"0\";\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```c\nstd::string rounded_avg_simd(int64_t n, int64_t m){\n    if(n > m){\n        return \"-1\";\n    }\n    uint64_t count = m - n + 1;\n    svint64_t vec_n = svindex_s64(0, 1, count);\n    svint64_t vec_m = svindex_s64(n, 1, count);\n    svint64_t vec_sum = svadd_x(vec_n, vec_m);\n    svint64_t vec_avg = svround_f64_z(svmul_x(svcast_f64(vec_sum), svdup_f64(0.5)), count);\n    int64_t avg = svget_s64(vec_avg, 0);\n    return std::bitset<64>(avg).to_string();\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n){\n    std::vector<int> result(sve_len / sizeof(int));\n    svbool_t p = svwhilelt_b(n);\n    svint32_t indices = svindex_b(p);\n    svint32_t res = svdup_n_s32(0);\n\n    // Compute factorial for even indices\n    svbool_t even_mask = svcmpeq_m(p, svindexhi_b(), svindexhi_n(2), 2);\n    svint32_t fact = svdup_n_s32(1);\n    svbool_t fact_mask = svcmpeq_m(p, svindexhi_b(), svindexhi_n(2), 2);\n    for(int i=1; i<=4; i++) {\n        fact = svmla_x(p, fact, svindexhi_n(i), svindexhi_n(i));\n        fact_mask = svorr_m(p, fact_mask, svcmpeq_m(p, svindexhi_b(), svindexhi_n(i), i));\n    }\n    res = svsel_m(p, res, fact, fact_mask);\n\n    // Compute sum for odd indices\n    svint32_t sum = svsub_x(p, svindexhi_n(1), svdup_n_s32(1));\n    svbool_t sum_mask = svorn_m(p, fact_mask, svcmpeq_m(p, svindexhi_b(), svindexhi_n(2), 1));\n    res = svsel_m(p, res, sum, sum_mask);\n\n    svst1_s32(result.data(), p, res);\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n){\n    std::vector<int> result(sve_len / sizeof(int)); // sve_len is the vector length in bytes\n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    svint32_t indices = svindex_b32(0, 1); // Start indexing from 1\n    svbool_t even_mask = svcmpeq_m(pg, svindex_b32(0, 2), svdiv_b32(indices, svcreate_b32(2)));\n    \n    svint32_t fact_mod = svdup_gather_u32((const uint32_t *)result.data(), indices);\n    svint32_t sum_val = svdup_gather_u32((const uint32_t *)result.data(), indices);\n    \n    // Factorial calculation loop\n    for(int k=2; k<=n; ++k){\n        svint32_t current = svsel_b32(even_mask, svfmul_x(pg, fact_mod, svindex_b32(0, k)), svadd_x(pg, sum_val, svindex_b32(0, k)));\n        \n        fact_mod = svsel_b32(even_mask, svfmul_x(pg, fact_mod, svindex_b32(0, k)), current);\n        sum_val = svsel_b32(even_mask, current, svadd_x(pg, sum_val, svindex_b32(0, k)));\n    }\n    \n    svscatter_u32((uint32_t *)result.data(), indices, svsel_b32(even_mask, fact_mod, sum_val));\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n){\n    std::vector<int> result(n);\n    svint32_t indices = svindex_b32(0, 1); // Initialize vector of indices starting from 0\n    svbool_t p = svwhilelt_b32(indices, n); // Predicate for vector length\n\n    while (svptest_any(svptrue_b32(), p)) {\n        svint32_t evens = svmla_x(p, indices, svdup_n_s32(2)); // Even indices: i+2\n        svint32_t odds = indices; // Odd indices: i\n\n        // Compute factorials for even indices\n        svint32_t even_factorials = svdup_n_s32(1);\n        for(int k=1; k<=n; k+=2){\n            even_factorials = sveor_x(p, even_factorials, svmla_x(p, even_factorials, svindex_b32(k, 1)));\n        }\n        even_factorials = svmod(p, even_factorials, svdup_n_s32(10000));\n\n        // Compute sums for odd indices\n        svint32_t odd_sums = svmla_x(p, odds, svdup_n_s32(1));\n        odd_sums = svmla_x(p, odd_sums, svdup_n_s32(1));\n\n        // Merge results based on even/odd\n        svint32_t merged = svsel_b32(svcmpeq_b32(p, indices, svand_b32(p, indices, svdup_n_s32(1))), odd_sums, even_factorials);\n\n        // Store results\n        svst1_s32(result.data() + svgetlane_s32(svminv_b32(p), indices), merged);\n\n        // Advance indices\n        indices = svadd_x(p, indices, svdup_n_s32(1));\n        p = svwhilelt_b32(indices, n);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n){\n    std::vector<int> result(sve_len / sizeof(int));\n    svbool_t p = svwhilelt_b(n);\n    svint32_t indices = svindex_b(p);\n    svint32_t values;\n\n    // Calculate factorial for even indices\n    svint32_t factorials = svdup_n_s32(1);\n    svbool_t is_even = svcmpeq_m(p, p, svand_m(p, svcmpeq_m(p, indices, svdup_n_s32(2)), svcmpeq_m(p, svmod_m(p, indices, svdup_n_s32(2)), svdup_n_s32(0))));\n    for(int i=2; i<=n; i+=2){\n        factorials = svmla_x(p, factorials, svdup_n_s32(i));\n    }\n    values = svsel_m(p, factorials, values, is_even);\n\n    // Calculate sum for odd indices\n    svint32_t sums = svsub_x(p, svadd_x(p, indices, svdup_n_s32(1)), svdup_n_s32(1));\n    values = svsel_m(p, sums, values, svnot_b(p, is_even));\n\n    // Apply modulo 10000\n    values = svminv_m(p, values, svdup_n_s32(10000));\n\n    svst1_s32(result.data(), p, values);\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n){\n    std::vector<int> result(n);\n    svint32_t indices = svindex_s32(0, 1); // Create a vector of indices starting from 0\n    svbool_t p = svwhilelt_b32(0, n);      // Predicate for vector length\n\n    while(svptest_any(svptrue_b32(), p)){\n        svint32_t fact_mod = svdup_gather_fixed(p, result.data(), indices); // Load existing results\n        svint32_t fact = fact_mod; // Temporary for factorial calculation\n        svint32_t sum = svadd_n_s32(indices, -1); // Temporary for sum calculation\n\n        // Calculate factorial for even indices\n        svbool_t is_even = svcmpeq_m_b32(p, svand_b32(p, svcmpeq_b32(indices, svdup_s32(0)), p), p);\n        fact = svselect_b32(is_even, svdup_s32(1), fact);\n        fact = svmla_b32(fact, is_even, svsel_b32(is_even, svdup_s32(1), svsub_s32(indices, svdup_s32(1))));\n        fact_mod = svsel_b32(is_even, svmod_s32(fact, svdup_s32(10000)), fact_mod);\n\n        // Calculate sum for odd indices\n        sum = svadd_n_s32(sum, 1);\n        sum = svmla_b32(sum, svnot_b32(is_even), svsub_s32(indices, svdup_s32(1)));\n\n        // Store back the results\n        svscatter_fixed(p, result.data(), indices, svselect_b32(is_even, fact_mod, sum));\n\n        // Advance indices and update predicate\n        indices = svadd_n_s32(indices, svcntd());\n        p = svwhilelt_b32(svget_lane_s32(indices, 0), n);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n){\n    size_t vl = svquery_vl(SVE_VEC_LENGTH_B);\n    svbool_t pg = svwhilelt_b(vl, 1);\n    \n    // Initialize counters\n    svint32_t even_count = svdup_n_s32(0);\n    svint32_t odd_count = svdup_n_s32(0);\n\n    while (svptest_any(pg)) {\n        svint32_t indices = svindex_b(pg);\n        svuint32_t nums = svadd_u32(svuzp1_u32(indices), svcreate_u32(1));\n        \n        // Filter numbers within range [1, n]\n        svbool_t in_range = svcmple_u32(nums, svcreate_u32(n));\n        nums = svselect_u32(in_range, nums, svundef_u32());\n\n        // Check if each number is a palindrome\n        svbool_t is_palindrome = svtrue_b();\n        for (size_t i = 0; i < vl && nums[i] != 0; ++i) {\n            int num = nums[i];\n            int original = num;\n            int reversed = 0;\n            while (num > 0) {\n                reversed = reversed * 10 + (num % 10);\n                num /= 10;\n            }\n            is_palindrome = svcmpeq_u32(svcreate_u32(original), svcreate_u32(reversed));\n        }\n\n        // Count even and odd palindromes\n        svbool_t is_even = svcmpeq_u32(svand_u32(nums, svcreate_u32(1)), svcreate_u32(0));\n        svbool_t is_odd = svnot_b(is_even);\n\n        even_count = svadd_u32(even_count, svcond_u32(is_palindrome & is_even, svcreate_u32(1), svundef_u32()));\n        odd_count = svadd_u32(odd_count, svcond_u32(is_palindrome & is_odd, svcreate_u32(1), svundef_u32()));\n\n        pg = svnext(pg);\n    }\n\n    // Reduce vectors to scalars\n    int total_even = svaddv_u32(even_count);\n    int total_odd = svaddv_u32(odd_count);\n\n    return {total_even, total_odd};\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n){\n    size_t vl = svquery_vl(SVE_VEC_LENGTH_BASIS);\n    svbool_t pg = svwhilelt_b(vl, 1);\n    \n    // Initialize counters\n    svint32_t evens = svdup_n_s32(0);\n    svint32_t odds = svdup_n_s32(0);\n    \n    while(svptest_any(pg)){\n        svuint32_t values = svundef_u32();\n        svuint32_t reversed = svundef_u32();\n        \n        svptrue_b_u32(pg);\n        svcntw(pg);\n        \n        // Load values into vector\n        svst1_u32(pg, &values, svwhilelt_u32(pg, n));\n        \n        // Reverse digits in parallel\n        // (Placeholder for actual digit reversal logic)\n        reversed = reverse_digits_sve(values);\n        \n        // Check if palindrome\n        svbool_t is_palindrome = svcmpeq_u32(values, reversed);\n        \n        // Check if even or odd\n        svbool_t is_even = svcmpeq_u32(svand_u32(values, svdup_n_u32(1)), svdup_n_u32(0));\n        \n        // Update counters\n        evens = sveor_x(pg, evens, svcond_b(is_even, svadd_x(pg, evens, svdup_n_s32(1)), evens));\n        odds = sveor_x(pg, odds, svcond_b(svnot_b(is_even), svadd_x(pg, odds, svdup_n_s32(1)), odds));\n    }\n    \n    // Reduce vectors to scalar values\n    int total_evens = svaddv_u32(evens);\n    int total_odds = svaddv_u32(odds);\n    \n    return {total_evens, total_odds};\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n){\n    size_t vl = svquery_vl(SVE_VEC_LENGTH_BASIS);\n    svbool_t pg = svwhilelt_b(vl, 1);\n    \n    // Initialize counters\n    svint32_t evens = svdup_n_s32(0);\n    svint32_t odds = svdup_n_s32(0);\n    \n    while(svptest_any(pg)){\n        svuint32_t indices = svindex_u32(pg);\n        svuint32_t num = svadd_u32(indices, svdup_n_u32(1));\n        \n        // Check if number is a palindrome\n        svbool_t is_palindrome = svtrue_b();\n        svuint32_t temp_num = num;\n        svuint32_t reversed = svdup_n_u32(0);\n        \n        while(svptest_any(is_palindrome)){\n            svuint32_t digit = svmod_u32(temp_num, svdup_n_u32(10));\n            reversed = svmla_u32(reversed, svdup_n_u32(10), digit);\n            temp_num = svdiv_u32(temp_num, svdup_n_u32(10));\n            is_palindrome = svcmpeq_u32(temp_num, reversed);\n        }\n        \n        // Check if palindrome is within range\n        svbool_t in_range = svcmple_u32(num, svdup_n_u32(n));\n        is_palindrome = svand_b(is_palindrome, in_range);\n        \n        // Count even and odd palindromes\n        svbool_t is_even = svcmpeq_u32(svmod_u32(num, svdup_n_u32(2)), svdup_n_u32(0));\n        evens = svadd_s32(evens, svuzp1_s32(svuzp2_s32(svcond_s32(is_palindrome, is_even, svfalse_b()), svfalse_b())));\n        odds = svadd_s32(odds, svuzp1_s32(svuzp2_s32(svcond_s32(is_palindrome, svnot_b(is_even), svfalse_b()), svfalse_b())));\n        \n        pg = svtbl_b(pg, svlsr_n_b(pg, 1));\n    }\n    \n    int total_evens = svaddv_u32(svtst_s32(evens, svtrue_b()));\n    int total_odds = svaddv_u32(svtst_s32(odds, svtrue_b()));\n    \n    return {total_evens, total_odds};\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n){\n    size_t vl = svquery_vl(SVE_VEC_LENGTH_BASIS);\n    svbool_t pg = svwhilelt_b(vl, 1);\n    \n    // Initialize counters\n    svint32_t evens = svdup_n_s32(0);\n    svint32_t odds = svdup_n_s32(0);\n    \n    while(svptest_any(pg)){\n        svuint32_t values = svundef_u32();\n        svuint32_t reversed = svundef_u32();\n        \n        svptrue_b_u32(pg);\n        svcntw(values, pg);\n        svsubw_u32(values, values, svindex_u32(1,1));\n        \n        // Check if each value is a palindrome\n        svcmpeq_m(pg, pg, svreinterpret_u32_u64(svrev64_u64(svreinterpret_u64_u32(values))), values);\n        \n        // Check if each palindrome is even or odd\n        svuint32_t is_even = svcmpeq_u32(values, svand_u32(values, svdup_n_u32(1)));\n        svuint32_t is_odd = svnot_b_u32(is_even);\n        \n        evens = svadd_s32(evens, svuzp1_s32(svindex_s32(0), svindex_s32(0)), is_even);\n        odds = svadd_s32(odds, svuzp1_s32(svindex_s32(0), svindex_s32(0)), is_odd);\n        \n        pg = svtail_b(pg);\n    }\n    \n    int total_evens = svaddv_s32(evens);\n    int total_odds = svaddv_s32(odds);\n    \n    return {total_evens, total_odds};\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n){\n    size_t vl = svquery_vl(SVE_VEC_LENGTH_BASIS);\n    svbool_t pg = svwhilelt_b(vl, 1);\n    \n    // Initialize counters\n    svint32_t even_count = svdup_n_s32(0);\n    svint32_t odd_count = svdup_n_s32(0);\n    \n    for(int i=1; i<=n; i+=vl){\n        svint32_t current = svindex_s32(pg, i);\n        svbool_t is_palindrome = svtrue_b();\n        \n        // Check if each number in the vector is a palindrome\n        for(int j=0; j<svcntw(); j++){\n            int num = current[j];\n            int original = num;\n            int reversed = 0;\n            \n            while(num > 0){\n                reversed = reversed * 10 + (num % 10);\n                num /= 10;\n            }\n            \n            if(original != reversed){\n                is_palindrome = svclear_b(is_palindrome, j);\n            }\n        }\n        \n        // Check if even or odd\n        svbool_t is_even = svcmpeq_w(current, svdiv_w(current, svdup_n_s32(2)));\n        svbool_t is_odd = svnot_b(is_even);\n        \n        even_count = sveor_x(even_count, svptrue_b(), svcond_b(is_palindrome & is_even, svones_b(), svfalse_b()));\n        odd_count = sveor_x(odd_count, svptrue_b(), svcond_b(is_palindrome & is_odd, svones_b(), svfalse_b()));\n    }\n    \n    // Reduce the vector results to scalar values\n    int total_even = svaddv_s32(even_count);\n    int total_odd = svaddv_s32(odd_count);\n    \n    return {total_even, total_odd};\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```c\nint count_nums_simd(std::vector<int> n){\n    svbool_t pg = svwhilelt_b32(0, n.size());\n    svint32_t nums = svld1(pg, n.data());\n    svint32_t abs_digits;\n    svint32_t digit_sum_gt_zero;\n    int count = 0;\n\n    while(svptest_any(svptrue_b32(), pg)){\n        abs_digits = svabs_s32(nums);\n        digit_sum_gt_zero = svcmple_s32(svsub_s32(abs_digits, svdup_n_s32(1)), svdup_n_s32(0));\n        count += svcntd() - svcntb(svand_b32(pg, digit_sum_gt_zero));\n        pg = svsrl_b32(pg, svcntd());\n        nums = svld1(pg, n.data() + svcntd());\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```c\nint count_nums_simd(std::vector<int> n){\n    int count = 0;\n    svbool_t pg = svwhilelt_b32(0, n.size());\n    svint32_t nums = svld1(pg, n.data());\n    svint32_t abs_nums = svabs_v(nums);\n    svint32_t sums = svuzp1(svptrue_b32(), abs_nums);\n    svbool_t predicate = svcmple_n_u32(sums, 0);\n    count += svcntd() - svcntb(predicate);\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```c\nint count_nums_simd(std::vector<int> n){\n    int count = 0;\n    svbool_t pg = svwhilelt_b32(0, n.size());\n    svint32_t nums = svld1(pg, n.data());\n    svint32_t abs_nums = svabs_v(nums);\n    svint32_t sums = svuzp1(svptrue_b32(), abs_nums);\n    svbool_t predicate = svcmple_n_s32(sums, 0);\n    count += svcntd() - svcntb(predicate);\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```c\nint count_nums_simd(std::vector<int> n){\n    svbool_t pg = svwhilelt_b32(0, n.size());\n    svint32_t nums = svld1(pg, n.data());\n    svint32_t abs_digits;\n    svbool_t cond;\n    int count = 0;\n\n    while(svptest_any(svptrue_b32(), pg)){\n        abs_digits = svabs_s32(nums);\n        cond = svcmple_s32(abs_digits, svcreate_s32(0));\n        count += svcntd() - svcntp_b32(cond);\n        nums = svld1_x(pg, n.data(), nums);\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```c\nint count_nums_simd(std::vector<int> n){\n    int count = 0;\n    svbool_t pg = svwhilelt_b32(0, n.size());\n    svint32_t nums = svld1(pg, n.data());\n    svint32_t abs_nums = svabs_v(nums);\n    svint32x2_t split_nums = svuzp1(abs_nums, abs_nums);\n    svint32_t digits = svreinterpret_s32_s64(svrev64_v(svreinterpret_s64_s32(split_nums)));\n    svbool_t cond = svcmple_n_s32(digits, 0);\n    svbool_t sum_gt_zero = svnot_b32(cond);\n    count += svcntd() - svcntv_b32(sum_gt_zero);\n    return count;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```c\n#include <arm_sve.h> \n\nbool move_one_ball_simd(std::vector<int> arr){\n    size_t n = arr.size();\n    if(n == 0) return true;\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t vec = svld1(pg, arr.data());\n\n    // Find the maximum value in the vector\n    svint32_t max_val = svmaxv(pg, vec);\n\n    // Count how many times the sequence breaks the non-decreasing order\n    svint32_t count_breaks = svcntb(svcmpeq(pg, vec, svshr_n_s32(max_val, 1)));\n\n    return svcmpeq_n_b32(pg, count_breaks, 1);\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    size_t n = arr.size();\n    if (n == 0) return true;\n\n    // Convert input vector to SVE integer vector\n    svint32_t vec = svld1_s32(arr.data());\n\n    // Find the maximum value in the vector\n    svint32_t max_val = svmaxv_s32(vec);\n\n    // Count how many times the sequence decreases\n    svbool_t decreasing = svcmpgt_s32(svshr_n_s32(vec, 1), vec);\n    int count_decreases = svcntd() - svcntb(svpred1_b(decreasing));\n\n    // If there are more than one decrease, it's not possible\n    if (count_decreases > 1) return false;\n\n    // Check if the vector can be made non-decreasing with shifts\n    svbool_t is_sorted = svcmpeq_s32(svrotate_n_s32(vec, 1, n-1), svmin_s32(vec));\n    return svcnth_b(is_sorted);\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    size_t n = arr.size();\n    if (n == 0) return true;\n\n    // Convert input vector to SVE integer vector\n    svint32_t vec = svld1_s32(arr.data());\n\n    // Find the maximum value in the vector\n    svint32_t max_val = svmaxv_s32(vec);\n\n    // Count how many times the sequence decreases\n    svbool_t decreasing = svcmpgt_s32(svshr_n_s32(vec, 1), vec);\n    int count_decreases = svcntd() - svcntp_z_s32(decreasing);\n\n    return count_decreases <= 1;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```c\n#include <arm_sve.h> \n\nbool move_one_ball_simd(std::vector<int> arr){\n    size_t n = arr.size();\n    if(n == 0) return true;\n    \n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t vec_arr = svld1(pg, arr.data());\n    \n    svint32_t sorted_vec = svabd_n_s32(vec_arr, svmaxv_s32(pg, vec_arr));\n    svbool_t is_sorted = svcmpeq_m(pg, pg, sorted_vec, svdup_n_s32(0));\n    \n    if(svptest_any(isa, is_sorted)) return true;\n    \n    for(size_t i=1; i<n; ++i){\n        vec_arr = svrshr_n_s32(vec_arr, 1);\n        sorted_vec = svabd_n_s32(vec_arr, svmaxv_s32(pg, vec_arr));\n        is_sorted = svcmpeq_m(pg, pg, sorted_vec, svdup_n_s32(0));\n        if(svptest_any(isa, is_sorted)) return true;\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```c\n#include <arm_sve.h> \n\nbool move_one_ball_simd(std::vector<int> arr){\n    size_t n = arr.size();\n    if(n == 0) return true;\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t vec_arr = svld1(pg, arr.data());\n\n    // Create a sorted version of the array\n    svint32_t sorted_arr = svundef_b32();\n    svint32_t temp_vec = vec_arr;\n    for(size_t i=0; i<n; ++i){\n        svint32_t min_val = svminv_b32(pg, temp_vec);\n        sorted_arr = svsel_b32(svcmpeq_b32(pg, temp_vec, min_val), min_val, sorted_arr);\n        temp_vec = svbsl_b32(svcmpeq_b32(pg, temp_vec, min_val), svundef_b32(), temp_vec);\n    }\n\n    // Check if the original array can be transformed into the sorted array with shifts\n    for(size_t shift=0; shift<n; ++shift){\n        svint32_t shifted_arr = svext_b32(vec_arr, vec_arr, shift, n);\n        if(svcmpeq_b32(pg, shifted_arr, sorted_arr)){\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```c\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2){\n    size_t n = lst1.size();\n    svbool_t pg = svwhilelt_b(n);\n    \n    // Convert lists to SVE vectors\n    svint32_t v1 = svld1(pg, lst1.data());\n    svint32_t v2 = svld1(pg, lst2.data());\n    \n    // Check if there are enough odd numbers in lst2 to replace all odd numbers in lst1\n    svbool_t has_odd_in_lst1 = svcmpeq_n_b32(svand_b32(v1, svcreate_b32(1)), 0);\n    svbool_t has_even_in_lst2 = svcmpeq_n_b32(svand_b32(v2, svcreate_b32(1)), 0);\n    \n    svbool_t can_exchange = svcnt_v_b32(pg) <= svcnt_v_b32(svbsl_b32(has_even_in_lst2, pg, svfalse_b32()));\n    \n    return svptest_any_b32(pg, can_exchange) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```c\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2){\n    size_t n = lst1.size();\n    svbool_t pg = svwhilelt_b(n);\n    \n    // Convert lists to SVE vectors\n    svint32_t v1 = svld1(pg, lst1.data());\n    svint32_t v2 = svld1(pg, lst2.data());\n    \n    // Check if there are enough odd numbers in lst2 to replace odd numbers in lst1\n    svbool_t has_odd_in_lst1 = svcmpeq_n_s32(svand_s32(v1, svcreate_s32(1)), 1);\n    svbool_t has_even_in_lst2 = svcmpeq_n_s32(svand_s32(v2, svcreate_s32(1)), 0);\n    \n    svbool_t can_exchange = svcntb(pg) == svcntb(svmerge_b(has_odd_in_lst1, has_even_in_lst2));\n    \n    return svptest_any_b(svptrue_b(), can_exchange) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```c\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2){\n    size_t n = lst1.size();\n    svbool_t pg = svwhilelt_b(n);\n    \n    // Convert lists to SVE vectors\n    svint32_t v1 = svld1(pg, lst1.data());\n    svint32_t v2 = svld1(pg, lst2.data());\n\n    // Check if there are enough odd numbers in lst2 to replace all odd numbers in lst1\n    svbool_t has_odd_in_lst1 = svcmpeq_n_s32(svand_s32(v1, svcreate_s32(1)), 1);\n    svbool_t has_even_in_lst2 = svcmpeq_n_s32(svand_s32(v2, svcreate_s32(1)), 0);\n\n    // Count the number of odd numbers in lst1 and even numbers in lst2\n    int count_odds_in_lst1 = svcntd() - svcntb(svbsl_b32(has_odd_in_lst1, pg));\n    int count_evens_in_lst2 = svcntd() - svcntb(svbsl_b32(has_even_in_lst2, pg));\n\n    // Determine if the exchange is possible\n    if (count_odds_in_lst1 <= count_evens_in_lst2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```c\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2){\n    size_t n = lst1.size();\n    svbool_t pg = svwhilelt_b(n);\n    \n    // Convert vectors to SVE compatible arrays\n    int32_t lst1_arr[n];\n    int32_t lst2_arr[n];\n    for(size_t i=0; i<n; i++) {\n        lst1_arr[i] = lst1[i];\n        lst2_arr[i] = lst2[i];\n    }\n    \n    // Load vectors into SVE registers\n    svint32_t v1 = svld1(pg, lst1_arr);\n    svint32_t v2 = svld1(pg, lst2_arr);\n    \n    // Check if all elements in v1 are even after potential exchange\n    svbool_t all_even = svcmpeq_m(pg, pg, svand(pg, svcmpeq_h(v1, svindex_r(0,2)), svcmpeq_h(v2, svindex_r(0,2))));\n    \n    return svptest_any(all_even) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```c\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2){\n    size_t n = lst1.size();\n    svbool_t pg = svwhilelt_b(n);\n    \n    // Convert vectors to SVE compatible arrays\n    int32_t lst1_sve[n];\n    int32_t lst2_sve[n];\n    for(size_t i=0; i<n; i++) {\n        lst1_sve[i] = lst1[i];\n        lst2_sve[i] = lst2[i];\n    }\n    \n    // Load vectors into SVE registers\n    svint32_t v1 = svld1(pg, lst1_sve);\n    svint32_t v2 = svld1(pg, lst2_sve);\n    \n    // Check if all odd numbers in lst1 can be replaced by even numbers from lst2\n    svbool_t has_odd_in_lst1 = svcmpeq_m(pg, pg, v1, svindex_u32(0,1));\n    svbool_t has_even_in_lst2 = svcmpeq_m(pg, pg, v2, svindex_u32(0,0));\n    \n    svbool_t can_exchange = svbany_m(pg, has_odd_in_lst1 & has_even_in_lst2);\n    \n    return svptest_any_b(svptrue_b(), can_exchange) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst){\n    // Implementation goes here\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> &lst) {\n    // Determine the vector length\n    size_t vl = svgetvl();\n\n    // Initialize result vector\n    std::vector<std::string> result(lst.size());\n\n    // Define masks and constants\n    svbool_t pg = svwhilelt_b(vl);\n    svint32_t odd_mask = svindex_b(0, 1); // Mask for odd numbers\n\n    for (size_t i = 0; i < lst.size(); i += vl) {\n        size_t len = lst[i].length();\n        svbool_t pg_len = svwhilelt_b(len);\n\n        svint32_t counts = svdup_n_s32(0);\n        svuint8_t chars = svld1_u8((const uint8_t *)lst[i].c_str(), pg_len);\n\n        for (size_t j = 0; j < len; j += vl) {\n            svbool_t pg_j = svwhilelt_b(j + vl);\n            svint32_t current_chars = svuzp1_u8(chars, pg_j);\n            svint32_t digit_vals = svsub_s32(current_chars, svdup_n_s32('0'));\n            svbool_t is_odd = svcmpeq_m(pg_j, svand_m(pg_j, svcmpeq_s32(digit_vals, digit_vals % 2), odd_mask));\n            counts = svadd_m(pg_j, counts, svcond_s32(is_odd, svdup_n_s32(1), svdup_n_s32(0)));\n        }\n\n        int count_sum = svcntd();\n        for (int k = 0; k < svcntd(); k++) {\n            count_sum -= counts[k];\n        }\n        char buf[64];\n        snprintf(buf, sizeof(buf), \"the number of odd elements %dn the str%dng %d of the %dnput.\", count_sum, count_sum, count_sum, count_sum);\n        result[i] = std::string(buf);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst){\n    // Implementation goes here\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    // Determine the vector length at runtime\n    size_t vl = svquery_vl();\n\n    // Initialize vectors to hold results\n    std::vector<int32_t> counts(sve_count1(vl));\n    std::vector<std::string> results(lst.size());\n\n    // Define masks and constants\n    svbool_t pg = svwhilelt_b32(0, vl);\n    svint32_t odd_mask = svindex_b32(1, 2); // Mask for odd numbers\n\n    for (size_t i = 0; i < lst.size(); i += vl) {\n        pg = svwhilelt_b32(0, vl);\n        svint32_t count_vec = svdup_n_s32(0);\n\n        for (size_t j = 0; j < lst[i].length(); j++) {\n            if (j >= vl) break;\n            svuint8_t char_vec = svld1_u8((const uint8_t*)&lst[i][j]);\n            svbool_t eq_digit = svcmpeq_u8(pg, char_vec, svindex_u8(48, 1)); // Compare with '0' to '9'\n            svbool_t is_odd = svand_b32(eq_digit, svcmpeq_s32(pg, svsub_s32(char_vec, svindex_s32(48, 1)), odd_mask));\n            count_vec = svadd_s32(pg, count_vec, svcond_s32(is_odd, svindex_s32(1, 0), svindex_s32(0, 0)));\n        }\n\n        svst1_s32(&counts[i], count_vec);\n    }\n\n    for (size_t i = 0; i < lst.size(); ++i) {\n        int count = counts[i];\n        results[i] = \"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\";\n    }\n\n    return results;\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst){\n    // Determine the maximum length of strings in the input list\n    size_t max_len = 0;\n    for(const auto & s : lst) {\n        if(s.length() > max_len) {\n            max_len = s.length();\n        }\n    }\n\n    // Initialize the result vector with the base template\n    const std::string template_str = \"the number of odd elements _n the str_ng _ of the _nput.\";\n    std::vector<std::string> result(lst.size(), template_str);\n\n    // SVE vector width\n    size_t vl = sve_get_vl();\n\n    // Process each string using SVE intrinsics\n    for(size_t i = 0; i < lst.size(); i += vl) {\n        size_t batch_size = std::min(lst.size() - i, vl);\n        \n        // Load input strings into a vector\n        svulong_t lens[batch_size];\n        for(size_t j = 0; j < batch_size; j++) {\n            lens[j] = svindex_u64(0, lst[i + j].length());\n        }\n\n        // Count odd digits in parallel\n        svbool_t pg = svwhilelt_b64(0, max_len);\n        svuint64_t counts = svptrue_b64();\n        for(size_t k = 0; k < max_len; k++) {\n            svchar_t chars = svld1_u8((const unsigned char*)lst[i + 0].c_str() + k, pg);\n            svbool_t is_odd = svcmpeq_b8(chars, svindex_u8(0, '1')) |\n                              svcmpeq_b8(chars, svindex_u8(0, '3')) |\n                              svcmpeq_b8(chars, svindex_u8(0, '5')) |\n                              svcmpeq_b8(chars, svindex_u8(0, '7')) |\n                              svcmpeq_b8(chars, svindex_u8(0, '9'));\n            counts = svcadd_b64(pg, counts, svuzp1_b64(is_odd, is_odd));\n        }\n\n        // Update the result strings with the counts\n        for(size_t j = 0; j < batch_size; j++) {\n            size_t count = svcntd_b64(counts, j);\n            result[i + j] = template_str;\n            result[i + j][31] = '0' + (count % 10);\n            result[i + j][36] = '0' + ((count / 10) % 10);\n            result[i + j][41] = '0' + ((count / 100) % 10);\n            result[i + j][46] = '0' + ((count / 1000) % 10);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```c\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums){\n    size_t n = nums.size();\n    svbool_t pg = svwhilelt_b64(0, n);\n    svint64_t vec = svld1(pg, nums.data());\n    int64_t min_sum = svmaxv_b64(svptrue_b64(), vec);\n    \n    for(size_t i = svcntd(); i < n; i += svcntd()){\n        svint64_t current = svld1(pg, nums.data() + i);\n        svint64_t sums = svmaxv_b64(pg, vec + current);\n        min_sum = svminv_b64(pg, min_sum, sums);\n    }\n    \n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```c\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums){\n    size_t n = nums.size();\n    svbool_t pg = svwhilelt_b64(0, n);\n    svint64_t vec = svld1(pg, nums.data());\n    int64_t min_sum = 0;\n    svint64_t current_min = svdup_n_s64(INT64_MAX);\n    \n    while(svptest_any(svptrue_b64(), pg)){\n        svint64_t sums = svmaxv_s64(vec);\n        current_min = svminv_s64(current_min, sums);\n        pg = svnext(pg);\n        vec = svld1(pg, nums.data() + svcntb(pg));\n    }\n    \n    min_sum = svminv_s64(current_min, min_sum);\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```c\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums){\n    size_t n = nums.size();\n    svbool_t pg = svwhilelt_b64(0, n);\n    svint64_t vec = svld1(pg, nums.data());\n    int64_t min_sum = svmaxv_b64(svptrue_b64(), vec);\n    \n    for(size_t i = svcntd(); i < n; i += svcntd()){\n        svint64_t current = svld1(pg, nums.data() + i);\n        svint64_t sums = svmaxv_b64(pg, vec + current);\n        min_sum = svminv_b64(pg, min_sum, sums);\n    }\n    \n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```c\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums){\n    size_t n = nums.size();\n    svbool_t pg = svwhilelt_b64(0, n);\n    svint64_t vec = svld1(pg, nums.data());\n    int64_t min_sum = svmaxv_b64(svptrue_b64(), vec);\n    \n    for(size_t i = svcntb_b64(pg); i < n; i += svcntb_b64(pg)){\n        pg = svwhilelt_b64(i, n);\n        svint64_t current = svld1(pg, nums.data() + i);\n        svint64_t sums = svmaxv_b64(pg, vec + current);\n        min_sum = svminv_b64(pg, min_sum, sums);\n    }\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```c\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums){\n    size_t n = nums.size();\n    svbool_t pg = svwhilelt_b64(0, n);\n    svint64_t vec = svld1(pg, nums.data());\n    int64_t min_sum = svmaxv_b64(svptrue_b64(), vec);\n    \n    for(size_t i = svcntd(); i < n; i += svcntd()){\n        svint64_t current = svld1(pg, nums.data() + i);\n        svint64_t sums = svmaxv_b64(pg, vec + current);\n        min_sum = svminv_b64(pg, min_sum, sums);\n    }\n    \n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```c\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity){\n    size_t rows = grid.size();\n    size_t cols = grid[0].size();\n    size_t vector_length = svcntw(); // Get the vector length\n    size_t i = 0;\n    \n    svbool_t pg = svtrue_b(wid); // Full predicate\n    \n    svint64_t total_buckets = svdup_n_s64(0);\n    \n    for (; i + vector_length <= rows; i += vector_length){\n        svint64_t row_sums = svdup_n_s64(0);\n        for(size_t j = 0; j < cols; j++){\n            svint64_t col_data = svld1_s64((const int64_t*)&grid[i][j]);\n            row_sums = svaddv(pg, row_sums, col_data);\n        }\n        total_buckets = svaddv(pg, total_buckets, row_sums);\n    }\n    \n    for (; i < rows; i++){\n        int sum = 0;\n        for(size_t j = 0; j < cols; j++){\n            sum += grid[i][j];\n        }\n        total_buckets = svadd_s64(total_buckets, svdup_n_s64(sum));\n    }\n    \n    return (int)(svcntp_s64(svdivp_s64(total_buckets, svdup_n_s64(capacity))));\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```c\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity){\n    size_t rows = grid.size();\n    size_t cols = grid[0].size();\n    size_t vl = sve_len / 64; // Assuming 64-bit elements\n    svbool_t pg = svwhilelt_b64(0, cols);\n    \n    int total_drops = 0;\n    \n    for(size_t i=0; i<rows; ++i){\n        svint64_t sum_vec = svdup_n_s64(0);\n        \n        for(size_t j=0; j<cols; j += vl){\n            svint64_t chunk = svld1(pg, &grid[i][j]);\n            sum_vec = svadd_x_s64(sum_vec, svaddv_b64(pg, chunk));\n        }\n        \n        int well_sum = svcvt_s32_s64(svaddv_s64(sum_vec));\n        total_drops += (well_sum + capacity - 1) / capacity;\n    }\n    \n    return total_drops;\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```c\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity){\n    size_t rows = grid.size();\n    size_t cols = grid[0].size();\n    size_t vl = sve_true_s32();\n\n    svint32_t capacity_vec = svdup_n_s32(capacity);\n    svint32_t count = svdup_n_s32(0);\n\n    for(size_t i=0; i<rows; i+=vl){\n        svint32_t row_mask = svwhilelt_b32((int)i, (int)rows);\n        svbool_t pg = svptrue_b32(row_mask);\n\n        svint32_t row_sum = svdup_n_s32(0);\n        for(size_t j=0; j<cols; j+=vl){\n            svint32_t col_mask = svwhilelt_b32((int)j, (int)cols);\n            svbool_t pg_col = svptrue_b32(col_mask);\n\n            svint32_t col_data = svld1(pg_col, &grid[i][j]);\n            row_sum = svadd_x(pg, row_sum, svcntb(pg_col));\n        }\n\n        row_sum = svdiv_x(pg, row_sum, capacity_vec);\n        count = svmax_x(pg, count, row_sum);\n    }\n\n    return svcntd() - svlastb(count);\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```c\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity){\n    size_t rows = grid.size();\n    size_t cols = grid[0].size();\n    size_t vector_length = svcntw(); // Get the vector length\n    size_t i = 0;\n    \n    svbool_t pg = svtrue_b64(); // Full predicate for the first vector\n    svint64_t total_count = svdup_n_s64(0);\n    \n    while(i + vector_length <= rows){\n        svint64_t count_vector = svdup_n_s64(0);\n        \n        for(size_t j=0; j<cols; j++){\n            svbool_t pg_j = svwhilelt_b64(j, cols);\n            svint64_t col_vector = svld1(pg_j, (const int64_t*)&grid[i][j]);\n            \n            svbool_t non_zero = svcmpeq_n_b64(col_vector, 1);\n            count_vector = svaddv_b64(non_zero, count_vector);\n        }\n        \n        count_vector = svdiv_n_s64(count_vector, capacity);\n        total_count = svaddv_b64(svcmpgt_b64(count_vector, total_count), total_count);\n        \n        i += vector_length;\n    }\n    \n    for(; i < rows; i++){\n        int count = 0;\n        for(size_t j=0; j<cols; j++){\n            if(grid[i][j] == 1){\n                count++;\n            }\n        }\n        int temp = (count + capacity - 1) / capacity;\n        total_count = svmax_n_s64(total_count, svdup_n_s64(temp));\n    }\n    \n    return (int)svlast_n_s64(total_count);\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```c\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity){\n    size_t rows = grid.size();\n    size_t cols = grid[0].size();\n    size_t vector_length = svcntw(); // Get the vector length\n    size_t i = 0;\n    \n    svbool_t pg = svtrue_b(wid);\n    \n    svint32_t total_buckets = svdup_n_s32(0);\n    \n    for (; i + vector_length <= rows; i += vector_length){\n        svint32_t row_sums = svdup_n_s32(0);\n        for(size_t j=0; j<cols; j++){\n            svint32_t col_data = svld1_s32((const int*)&grid[i][j]);\n            row_sums = svadd_s32(row_sums, col_data);\n        }\n        svst1_s32((int*)&total_buckets, svadd_s32(total_buckets, svdiv_s32(row_sums, svdup_n_s32(capacity))));\n    }\n    \n    for (; i < rows; i++){\n        int sum = 0;\n        for(size_t j=0; j<cols; j++){\n            sum += grid[i][j];\n        }\n        total_buckets = svadd_s32(total_buckets, svdup_n_s32(sum / capacity));\n    }\n    \n    return svaddv_s32(total_buckets);\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```c\nint64_t solution_simd(const std::vector<int16_t>& lst){\n    svbool_t pg = svwhilelt_b16(0, lst.size());\n    svint16_t vec = svld1(pg, lst.data());\n    svint16_t indices = svindex_b16(0, 2);\n    svint16_t selected = svptrue_b16();\n    selected = svsel_b16(selected, svcmpeq_w(vec, svand_b16(svcmpeq_h(vec, svindexh_b16(1)), indices)));\n    svint64_t sum = svmlal_s16(svptrue_b64(), svcond_s16(selected, vec, svdup_n_s16(0)));\n    return svaddv_s64(sum);\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```c\nint64_t solution_simd(const std::vector<int16_t>& lst){\n    svbool_t pg = svwhilelt_b16(0, lst.size());\n    svint16_t vec = svld1(pg, lst.data());\n    svint16_t indices = svindex_b16(0, 2);\n    svint16_t selected = svtrn1(vec, vec);\n    svbool_t is_odd = svcmpeq_n_b16(selected, svadd_n_s16(selected, 1));\n    svint16_t odd_values = svsel(is_odd, selected, svdup_n_s16(0));\n    svint64_t sum = svaddlv_b16(pg, odd_values);\n    return svaddv_s64(sum);\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```c\nint64_t solution_simd(const std::vector<int16_t>& lst){\n    svbool_t pg = svwhilelt_b16(0, lst.size());\n    svint16_t vec = svld1(pg, lst.data());\n    svint16_t indices = svindex_b16(0, 2);\n    svint16_t selected = svptrue_b16();\n    selected = svsel_b16(selected, pg, indices);\n    svint16_t odds = svcmpeq_m(pg, selected, svand_b16(selected, svcreate_b16(1)));\n    svint64_t sums = svdup_n_s64(0);\n    sums = svmla_reduce_s64(sums, vec, odds);\n    int64_t total;\n    svst1_s64(&total, sums);\n    return total;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```c\nint64_t solution_simd(const std::vector<int16_t>& lst){\n    svbool_t pg = svwhilelt_b16(0, lst.size());\n    svint16_t vec = svld1(pg, lst.data());\n    svint16_t indices = svindex_b16(0, 2);\n    svint16_t selected = svptrue_b16();\n    selected = svsel_b16(selected, svtrue_b16(), svcmpeq_w(svptrue_b16(), svindexhi_b16(indices), svindexlo_b16(indices)));\n    svint16_t filtered = svcond_b16(selected, svand_b16(svset_b16(svptrue_b16()), svcmpeq_h(vec, svdup_n_h(1))), vec);\n    svint64_t sum = svmlal_s16(svdup_n_s64(0), svreinterpret_s64_h(filtered));\n    return svaddv_s64(sum);\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```c\nint64_t solution_simd(const std::vector<int16_t>& lst){\n    svbool_t pg = svwhilelt_b16(0, lst.size());\n    svint16_t vec = svld1(pg, lst.data());\n    svint16_t indices = svindex_b16(0, 2);\n    svint16_t selected = svptrue_b16();\n    selected = svsel_b16(selected, svcmpeq_w(svptrue_b16(), indices, svindex_b16(0, 1)), selected);\n    svint16_t odds = svabd_n_s16(vec, svand_n_s16(vec, svcreate_low_n_b16(1)));\n    svbool_t mask = svcmpeq_n_s16(odds, 1);\n    svint64_t sum = svmla_reduce_n_s64(svptrue_b64(), svcond_b16(mask, vec, svdup_n_s16(0)));\n    return svundef_to_x64(sum);\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```c\nint add_elements_simd(std::vector<int> arr, int k){\n    svbool_t pg = svwhilelt_b32(0, k);\n    svint32_t vec = svld1(pg, arr.data());\n    svint32_t mask = svcmp_lt(vec, svdup_n_s32(100));\n    svint32_t filtered = svsel(mask, vec, svdup_n_s32(0));\n    svint32_t abs_vec = svabs_s32(filtered);\n    svint32_t two_digit_mask = svcmpeq(abs_vec, svsub_s32(filtered, svdup_n_s32(10)));\n    svbool_t two_digit_pg = svptrue_b32();\n    two_digit_pg = svand_b32(two_digit_pg, two_digit_mask);\n    int sum = svaddv_b32(pg, filtered);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```c\nint add_elements_simd(std::vector<int> arr, int k){\n    svbool_t pg = svwhilelt_b32(0, k);\n    svint32_t vec_arr = svld1(pg, arr.data());\n    svint32_t mask = svcmplt_n_s32(vec_arr, 100);\n    svint32_t filtered = svsel_b32(pg, vec_arr, mask, svdup_n_s32(0));\n    svint32_t mask_neg = svcmpgt_n_s32(vec_arr, -100);\n    filtered = svsel_b32(pg, filtered, mask_neg, svdup_n_s32(0));\n    int sum = svaddv_b32(pg, filtered);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```c\nint add_elements_simd(std::vector<int> arr, int k){\n    svbool_t pg = svwhilelt_b32(0, k);\n    svint32_t vec_arr = svld1(pg, arr.data());\n    svint32_t mask = svcmp_le_n_s32(vec_arr, 99);\n    svint32_t masked_vec = svptrue_b32();\n    masked_vec = svand_b32(masked_vec, mask);\n    svint32_t filtered = svsel_s32(svuzp1_s32(vec_arr, masked_vec), svuzp2_s32(vec_arr, masked_vec));\n    int sum = svaddv_s32(filtered);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```c\nint add_elements_simd(std::vector<int> arr, int k){\n    svbool_t pg = svwhilelt_b32(0, k);\n    svint32_t vec = svld1(pg, arr.data());\n    svint32_t mask = svcmp_lt(vec, svcreate_i32(100));\n    svint32_t mask_neg = svcmp_gt(vec, svcreate_i32(-100));\n    svbool_t valid = svand_b32(mask, mask_neg);\n    svint32_t filtered = svsel(pg, vec, svcreate_i32(0), valid);\n    int sum = svaddv_b32(pg, filtered);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```c\nint add_elements_simd(std::vector<int> arr, int k){\n    svbool_t pg = svwhilelt_b32(0, k);\n    svint32_t vec = svld1(pg, arr.data());\n    svint32_t mask = svcmplt_n_s32(vec, 100);\n    svint32_t filtered = svsel_b32(pg, vec, mask, svdup_n_s32(0));\n    svint32_t two_digit_mask = svcmple_n_s32(filtered, 99);\n    svint32_t valid_values = svsel_b32(pg, filtered, two_digit_mask, svdup_n_s32(0));\n    int sum = svaddv_b32(pg, valid_values);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <std_vector>\n\nbool is_sorted_simd(const std::vector<int> & lst){\n    size_t n = lst.size();\n    if(n <= 1) return true;\n\n    size_t vec_len = svcntw(); // Get the vector length\n    size_t i = 0;\n    \n    while(i + vec_len <= n){\n        svint32_t v = svld1((const int *)(&lst[i]));\n        svint32_t prev = svsub(svadd(v, svdup_n_s32(1)), svdup_n_s32(1));\n        \n        svbool_t gt_mask = svcmple_n(prev, v);\n        svbool_t eq_mask = sveor_m(gt_mask, svcmpeq_n(v, prev), svtrue_h());\n        \n        if(!svptest_any(svtrue_h(), eq_mask)) {\n            return false;\n        }\n        \n        i += vec_len;\n    }\n\n    while(i < n){\n        if(lst[i] < lst[i-1]){\n            return false;\n        }\n        i++;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <std_vector>\n\nbool is_sorted_simd(const std::vector<int> & lst){\n    size_t n = lst.size();\n    if(n <= 1) return true;\n    \n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t vec = svld1(pg, lst.data());\n    svint32_t prev = svundef_b32();\n    bool duplicates = false;\n\n    for(size_t i=1; i<n; i+=svcntw()){\n        svint32_t curr = svld1(pg, lst.data()+i);\n        svbool_t gt = svcmpgt_b32(curr, prev);\n        svbool_t eq = svcmpeq_b32(curr, prev);\n        duplicates |= svptest_any(gt, eq);\n        if(!svptest_any(gt, pg)) break;\n        prev = curr;\n    }\n\n    return !duplicates;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <std_vector>\n\nbool is_sorted_simd(const std::vector<int> & lst){\n    size_t n = lst.size();\n    if(n <= 1) return true;\n\n    size_t vl = svquery_vl(sizeof(int));\n    size_t elements_per_vector = vl / sizeof(int);\n\n    svbool_t all_valid = svptrue_b8();\n    svbool_t sorted = svptrue_b8();\n\n    for(size_t i=0; i<n; i+=elements_per_vector){\n        size_t chunk_size = std::min(elements_per_vector, n - i);\n        int32_t prev_value = lst[i];\n        svbool_t local_sorted = svptrue_b8();\n        svbool_t duplicates = svpfalse_b8();\n\n        for(size_t j=1; j<chunk_size; ++j){\n            int32_t current_value = lst[i + j];\n            svbool_t gt = svcmpgt_b8(svindex_s32(i + j), svindex_s32(i + j -1));\n            svbool_t eq = svcmpeq_b8(svindex_s32(i + j), svindex_s32(i + j -1));\n\n            local_sorted = svand_b8(local_sorted, gt);\n            duplicates = svorr_b8(duplicates, eq);\n            prev_value = current_value;\n        }\n\n        sorted = svand_b8(sorted, local_sorted);\n        all_valid = svand_b8(all_valid, svnot_b8(duplicates));\n    }\n\n    return svptest_any_b8(all_valid, sorted);\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <std_vector>\n\nbool is_sorted_simd(const std::vector<int> & lst){\n    size_t n = lst.size();\n    if(n <= 1) return true;\n\n    size_t vl = svcntb() * 8 / sizeof(int);\n    size_t i = 0;\n    \n    while(i + vl <= n){\n        svint32_t vec = svld1((const int *)(&lst[i]));\n        svint32_t prev = svsubv(svptrue(), vec);\n        \n        svbool_t gt_mask = svcmpgt(vec, prev);\n        svbool_t eq_mask = svcmpeq(vec, prev);\n        \n        if(svptest_any(gt_mask) || svptest_any(eq_mask)){\n            return false;\n        }\n        \n        i += vl;\n    }\n    \n    for(size_t j = i; j < n - 1; j++){\n        if(lst[j] > lst[j + 1]){\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <std_vector>\n\nbool is_sorted_simd(const std::vector<int> & lst){\n    size_t n = lst.size();\n    if(n <= 1) return true;\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t vec = svld1(pg, lst.data());\n    svint32_t prev = svundef_b32();\n\n    for(int i=1; i<n; i+=svcntw()){\n        svbool_t pg_i = svwhilelt_b32(i, n);\n        svint32_t curr = svld1(pg_i, lst.data()+i);\n\n        svint32_t diff1 = svsub_x4(vec, prev);\n        svbool_t sorted1 = svcmpeq_m(pg_i, svcmpgt_x4(diff1, svundef_b32()));\n\n        svint32_t diff2 = svsub_x4(curr, vec);\n        svbool_t sorted2 = svcmpeq_m(pg_i, svcmpgt_x4(diff2, svundef_b32()));\n\n        svbool_t sorted = svand_b32(sorted1, sorted2);\n\n        if(!svptest_any(svtrue_b32(), sorted)){\n            return false;\n        }\n\n        prev = vec;\n        vec = curr;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```c\nint prod_signs_simd(const std::vector<int> & arr){\n    if (arr.empty()) return -32768;\n    \n    size_t n = arr.size();\n    int32_t sum = 0;\n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    svint32_t vec_arr = svld1(pg, arr.data());\n    svint32_t signs = svcmpne_b32(vec_arr, svdup_n_s32(0));\n    svint32_t abs_vals = svabs_v(sveor_v(vec_arr, signs), signs);\n    svint32_t sign_product = svand_v(signs);\n    \n    sum += svaddv_b32(pg, svreinterpret_b32_s32(svmla_f32(svdup_n_f32(0), sign_product, abs_vals)));\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```c\nint prod_signs_simd(const std::vector<int> & arr){\n    if (arr.empty()) return -32768;\n    \n    size_t n = arr.size();\n    int32_t sum = 0;\n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    svint32_t vec_arr = svld1(pg, arr.data());\n    svint32_t signs = svcmpne_b32(vec_arr, svdup_n_s32(0));\n    svint32_t abs_vals = svabs_v(sveor_v(vec_arr, signs), signs);\n    svint32_t sign_product = svand_v(signs);\n    \n    sum += svaddv_b32(pg, svmsb_v(svtst_b32(pg, signs), abs_vals, sign_product));\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```c\nint prod_signs_simd(const std::vector<int> & arr){\n    if (arr.empty()) return -32768;\n    svint32_t sum = svdup_n_s32(0);\n    svbool_t pg = svwhilelt_b32(0, arr.size());\n    for (size_t i = 0; i < arr.size(); i += svcntw()) {\n        svint32_t vec = svld1(pg, &arr[i]);\n        svint32_t signs = svcmpne_b32(vec, svdup_n_s32(0));\n        svint32_t abs_vals = svabs_v(sveor_v(vec, signs, signs));\n        sum = svadd_v(sum, abs_vals, pg);\n    }\n    int result = 0;\n    svptrue_b32(pg);\n    svst1(pg, &result, sum);\n    return result;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```c\nint prod_signs_simd(const std::vector<int> & arr){\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    size_t n = arr.size();\n    int32_t sum = 0;\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t vec = svld1(pg, arr.data());\n    svint32_t signs = svcmpne_b32(vec, svdup_n_s32(0));\n    svint32_t abs_vals = svabs_v(sveqz_b32(signs), vec);\n\n    svint32_t sign_product = svdup_n_s32(1);\n    while(svptest_any(pg)){\n        svbool_t inner_pg = svwhilelt_b32(0, svcntw());\n        svint32_t current_signs = svtrn1_b32(signs, signs);\n        sign_product = svmla_v(sign_product, current_signs, svtrue_h32());\n        vec = svld1(inner_pg, arr.data() + svcntw()*svcntw());\n        signs = svcmpne_b32(vec, svdup_n_s32(0));\n        pg = svptrue_b32();\n    }\n\n    sum = svaddv_b32(sign_product * abs_vals);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```c\nint prod_signs_simd(const std::vector<int> & arr){\n    if (arr.empty()) return -32768;\n    svbool_t pg = svwhilelt_b32(0, arr.size());\n    svint32_t vec = svld1(pg, arr.data());\n    svint32_t signs = svcmpne_b32(svptrue_b32(), vec);\n    svint32_t abs_vals = svabs_v(svptrue_b32(), vec);\n    svint32_t sum_masked = svmla_v(pg, svindex_b32(0,1), signs, abs_vals);\n    int sum_result;\n    svst1_s32(&sum_result, svptrue_b32(), sum_masked);\n    return sum_result;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k){\n    // Implementation goes here\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k){\n    // Implementation goes here\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k){\n    // Implementation goes here\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k){\n    // Implementation goes here\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k){\n    // Implementation using SVE intrinsics goes here\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t digits_simd(uint64_t n){\n    svbool_t pg = svwhilelt_b64(0, 64);\n    uint64_t mask_even = 0xAAAAAAAAAAAAAAAA;\n    uint64_t mask_odd = ~mask_even;\n    svuint64_t v_n = svld1(pg, &n);\n    svbool_t is_odd = svcmpeq_u64(pg, v_n, v_n & svcreate_b64(mask_odd));\n    svbool_t has_odd = svptrue_b64();\n    svbool_t all_even = svptrue_b64();\n    \n    while(svptest_any(has_odd, all_even)){\n        svbool_t active = svand_b64(has_odd, all_even);\n        svuint64_t v_digit = svand_u64(active, v_n);\n        svbool_t is_odd_active = svcmpeq_u64(active, v_digit, v_digit & svcreate_b64(mask_odd));\n        has_odd = svbitor_b64(has_odd, is_odd_active);\n        all_even = svbic_b64(all_even, is_odd_active);\n        \n        v_n = svshr_n_u64(v_n, 1);\n    }\n    \n    return svptest_any(has_odd, svcreate_b64(1)) ? 0 : 1;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t digits_simd(uint64_t n){\n    svbool_t pg = svwhilelt_b64(0, 19); // Assuming max 19 digits for 64-bit number\n    svint64_t digits = svindex_b64(pg, 0, 1); // Create vector of indices\n    svuint64_t num_vec = svdup_n_u64(n);\n    svbool_t mask_all_even = svptrue_b64();\n    \n    while(svptest_any(pg)){\n        svint64_t extracted_digits = svqmovn_s8(svptrue_b8(), svreinterpret_s8(svashr_n_s64(digits, svcntb()-1)));\n        svbool_t is_odd = svcmpeq_n_u8((svuint8_t)extracted_digits, 1);\n        mask_all_even = svand_b64(mask_all_even, is_odd);\n        \n        digits = svadd_n_s64(digits, 1);\n    }\n    \n    uint64_t result = svlastb_u64(svcmpeq_n_u64(num_vec, 0));\n    return result;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t digits_simd(uint64_t n){\n    svbool_t pg = svwhilelt_b64(0, 19); // Assuming max 19 digits for uint64_t\n    svint64_t digits = svindex_b64(pg, 0, 1); // Create vector of indices [0...18]\n    svint64_t num_vec = svdup_n_s64(n);\n    svint64_t powers_of_10 = svptrue_b64();\n    svint64_t odd_mask = svptrue_b64();\n\n    // Compute powers of 10\n    for(int i=0; i<19; i++) {\n        powers_of_10 = svsel_b64(svcmpeq_s64(digits, svindex_b64(pg, i, i)), \n                                 svdup_n_s64((int64_t)svpowi_n_s64(10, i)),\n                                 powers_of_10);\n    }\n\n    // Extract digits\n    svint64_t extracted_digits = svdiv_n_s64(svmax_s64(svmin_s64(num_vec / powers_of_10, svdup_n_s64(9)), svdup_n_s64(0)), \n                                             svdup_n_s64(1));\n\n    // Odd mask\n    for(int i=0; i<19; i++) {\n        odd_mask = svsel_b64(svcmpeq_s64(extracted_digits, svdup_n_s64(i)), \n                             svptrue_b64(), \n                             odd_mask);\n    }\n\n    // Compute product\n    svint64_t product = svdup_n_s64(1);\n    for(int i=0; i<19; i++) {\n        product = svmla_s64(product, svcmpeq_b64(odd_mask, svptrue_b64()), \n                           svdup_n_s64(i));\n    }\n\n    return svcvt_s64_u64(svlast_s64(product));\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t digits_simd(uint64_t n){\n    svbool_t pg = svwhilelt_b64(0, 64);\n    uint64_t mask_even = 0xAAAAAAAAAAAAAAAA;\n    uint64_t mask_odd = ~mask_even;\n    svuint64_t v_n = svld1(pg, &n);\n    svbool_t is_odd = svcmpeq_m(pg, svand_b64(pg, v_n, svcreate_b64(mask_odd)), svcreate_b64(mask_odd));\n    svbool_t has_odd = svptrue_b64();\n    svuint64_t product = svcreate_u64(1);\n    \n    while(svptest_any(has_odd)){\n        svbool_t pg_inner = svwhilelt_b64(0, 64);\n        svuint64_t v_digits = svand_b64(pg_inner, v_n, svcreate_u64(0x00000000000000FF));\n        svbool_t is_odd_digit = svcmpeq_m(pg_inner, svand_b64(pg_inner, v_digits, svcreate_u64(0x0000000000000001)), svcreate_u64(0x0000000000000001));\n        has_odd = svand_b64(pg_inner, has_odd, is_odd_digit);\n        svbool_t valid_digits = svand_b64(pg_inner, is_odd_digit, has_odd);\n        product = svmul_x(pg_inner, product, svcond_m(valid_digits, v_digits, svcreate_u64(1)));\n        v_n = svshr_n_u64(v_n, 8);\n    }\n    return svcnot_b64(pg, product);\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t digits_simd(uint64_t n){\n    svbool_t pg = svwhilelt_b64(0, 64);\n    uint64_t mask_even = 0xAAAAAAAAAAAAAAAA;\n    svuint64_t vec_n = svld1(pg, &n);\n    svbool_t is_odd = svcmpeq_m(pg, svand_b64(pg, vec_n, svindex_u64(pg, 1, 1)), svindex_b64(pg, 0, 1));\n    svbool_t is_not_all_even = svbany_b64(is_odd);\n    uint64_t result = 0;\n\n    if (svptest_any(is_odd)) {\n        svbool_t pg_odd = svptrue_b64();\n        svuint64_t odd_digits = svand_b64(pg_odd, vec_n, svcreate_b64(mask_even));\n        result = svaddv(pg_odd, odd_digits);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <cmath>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    size_t n = lst.size();\n    if(n == 0) return 0;\n\n    uint64_t sum = 0;\n    size_t i = 0;\n\n    // Determine the vector length\n    size_t vl = svcntb() / sizeof(float);\n\n    // Convert std::vector to SVE compatible array\n    float *arr = const_cast<float*>(lst.data());\n\n    while(i + vl <= n){\n        svfloat_t vec = svld1((const float *)(&arr[i]));\n        svfloat_t ceil_vec = svrinta_f32(vec); // Ceiling operation\n        svfloat_t square_vec = svmla_f32(ceil_vec, ceil_vec, svindex_f32(0.0f)); // Square each element\n        sum += svaddv_u32(svreinterpret_u32_f32(square_vec)); // Sum all elements\n        i += vl;\n    }\n\n    // Handle remaining elements\n    while(i < n){\n        float val = arr[i];\n        float ceil_val = std::ceil(val);\n        sum += static_cast<uint64_t>(ceil_val * ceil_val);\n        i++;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <cmath>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    size_t n = lst.size();\n    if(n == 0) return 0;\n\n    uint64_t sum = 0;\n    size_t i = 0;\n\n    // Determine the vector length\n    size_t vl = svlen / sizeof(float);\n\n    while(i + vl <= n){\n        svfloat32_t vec = svld1((const float *)lst.data() + i);\n        svint32_t rounded = svrinta_f32(vec); // Round to nearest integer\n        svint32_t squared = svmla_x(squared, rounded, rounded); // Square each element\n        sum += svaddv_u32(svmovlb_u32(svreinterpret_u32(squared))); // Sum the results\n        i += vl;\n    }\n\n    // Handle remaining elements\n    while(i < n){\n        float val = lst[i];\n        int rounded = static_cast<int>(std::ceil(val));\n        sum += rounded * rounded;\n        i++;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <cmath>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    size_t n = lst.size();\n    if (n == 0) return 0;\n\n    uint64_t sum = 0;\n    size_t i = 0;\n\n    // Determine the vector length\n    size_t vl = svlen / sizeof(float);\n\n    while (i + vl <= n) {\n        svfloat32_t vec = svld1((const float *)(&lst[i]));\n        svint32_t ceil_vec = svrinta_f32(vec);\n        svfloat32_t squared_vec = svmla_f32(ceil_vec, ceil_vec, svdup_f32(0.0f));\n        sum += svaddv_u32(svreinterpret_u32_f32(squared_vec));\n        i += vl;\n    }\n\n    // Handle remaining elements\n    while (i < n) {\n        float val = lst[i];\n        int ceil_val = static_cast<int>(std::ceil(val));\n        sum += ceil_val * ceil_val;\n        i++;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <cmath>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    size_t n = lst.size();\n    if (n == 0) return 0;\n\n    uint64_t sum = 0;\n    size_t i = 0;\n\n    // Determine the vector length\n    size_t vl = svlen / sizeof(float);\n\n    // Convert std::vector to SVE compatible array\n    float *arr = const_cast<float*>(lst.data());\n\n    while (i + vl <= n) {\n        svfloat32_t vec = svld1((const float *)(&arr[i]));\n        svint32_t rounded = svrinta_f32(vec); // Round to nearest integer\n        svint32_t squared = svmla_x(svmul_x(rounded, rounded), svdup_n_s32(0)); // Square each element\n        sum += svaddv_u32(svtol_h(svtoui_h(svtol_b(svtou_f(squared)))));\n        i += vl;\n    }\n\n    // Handle remaining elements\n    while (i < n) {\n        int rounded = static_cast<int>(std::ceil(lst[i]));\n        sum += rounded * rounded;\n        i++;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <cmath>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    size_t n = lst.size();\n    if (n == 0) return 0;\n\n    uint64_t sum = 0;\n    size_t i = 0;\n\n    // Determine the vector length\n    size_t vl = svcntb() / sizeof(float);\n\n    // Convert std::vector to SVE compatible array\n    float *arr = const_cast<float*>(lst.data());\n\n    while (i + vl <= n) {\n        svfloat32_t vec = svld1((const float *)(&arr[i]));\n        svfloat32_t ceil_vec = svrinta_f32(vec); // Ceiling operation\n        svint32_t int_vec = svcvtr_s32_f32(ceil_vec); // Convert to int\n        svint32_t square_vec = svmla_x(svinvl(), int_vec, int_vec); // Square each element\n        sum += svaddv_u32(svreinterpret_u32(sq_x(svmovlb, square_vec))); // Sum the squares\n        i += vl;\n    }\n\n    // Handle remaining elements\n    while (i < n) {\n        float val = arr[i];\n        int ceil_val = static_cast<int>(std::ceil(val));\n        sum += ceil_val * ceil_val;\n        i++;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```c\nint can_arrange_simd(const std::vector<int> & arr){\n    size_t n = arr.size();\n    svbool_t pg = svwhilelt_b(n, 1);\n    svint32_t vec = svld1(pg, arr.data());\n    svint32_t prev = svld1(pg, arr.data() + 1);\n    svbool_t cond = svcmple_b32(pg, vec, prev);\n    size_t idx = -1;\n    if(svptest_any(svptrue_b(), cond)){\n        idx = svcntd() - svcntp_b32(cond);\n    }\n    return (int)idx;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```c\nint can_arrange_simd(const std::vector<int> & arr){\n    size_t n = arr.size();\n    svbool_t pg = svwhilelt_b(n, 1);\n    svint32_t vec = svld1(pg, arr.data());\n    svint32_t prev = svundef_s32();\n    int result = -1;\n    svbool_t found = svfalse_b();\n\n    for(size_t i = 1; i < n; i += svcntw()){\n        svbool_t lt_mask = svcmplt(pg, vec, svld1(pg, arr.data() + i));\n        if(!svptest_any(svptrue_b(), lt_mask)){\n            continue;\n        }\n        svint32_t current = svld1(lt_mask, arr.data() + i);\n        svbool_t cond = svcmpeq_b(pg, current, svmax(pg, prev, current));\n        found = svptrue_b() if !(found || cond);\n        if(svptest_any(svptrue_b(), found)){\n            result = i - 1;\n            break;\n        }\n        prev = current;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```c\nint can_arrange_simd(const std::vector<int> & arr){\n    size_t n = arr.size();\n    svbool_t pg = svwhilelt_b(n, 1);\n    svint32_t vec = svld1(pg, arr.data());\n    svint32_t prev = svundef_s32();\n    int result = -1;\n    size_t idx = 0;\n\n    while(svmadlo_b(pg)){\n        svint32_t gt = svcmpgt_s32(vec, prev);\n        svbool_t cond = svcmpeq_b32(svlast_elem_s32(gt), svtrue_b32());\n        if(!svptest_any(svptrue_b32(), cond)){\n            result = idx - 1;\n            break;\n        }\n        prev = svlast_elem_s32(vec);\n        vec = svshr_n_s32(vec, 1);\n        pg = svlsr_n_b(pg, 1);\n        idx++;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```c\nint can_arrange_simd(const std::vector<int> & arr){\n    size_t n = arr.size();\n    svbool_t pg = svwhilelt_b(n, 1);\n    svint32_t vec = svld1(pg, arr.data());\n    svint32_t prev = svext(pg, vec, 1);\n    svbool_t cond = svcmple_b32(pg, vec, prev);\n    svint32_t indices = svindex_b32(pg, cond);\n    if(svptest_any(svptrue_b32(), indices)){\n        return svcntd() - svlast_elem_d(indices) - 1;\n    }\n    else{\n        return -1;\n    }\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```c\nint can_arrange_simd(const std::vector<int> & arr){\n    size_t n = arr.size();\n    svbool_t pg = svwhilelt_b(n, 1);\n    svint32_t vec = svld1(pg, arr.data());\n    svint32_t prev = svundef_s32();\n    int result = -1;\n    svbool_t found = svfalse_b();\n\n    for(size_t i=1; i<n; i+=svcntw()){\n        svbool_t lt_mask = svcmple_s32(vec, svld1(pg, arr.data()+i));\n        if(!svptest_any(svptrue_b(), lt_mask)){\n            continue;\n        }\n        svint32_t current = svld1(pg, arr.data()+i);\n        svbool_t cond = svcmpeq_s32(prev, svsel(lt_mask, current, prev));\n        if(svptest_any(svptrue_b(), cond)){\n            svbool_t local_found = svptrue_b();\n            svuint32_t idx = svindex_u32(svptrue_b(), i);\n            result = svmaxv_u32(svptrue_b(), svreinterpret_u32(idx));\n            found = svtrue_b();\n            break;\n        }\n        prev = current;\n    }\n    return found ? result : -1;\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst){\n    size_t n = lst.size();\n    if(n == 0){\n        return {0, 0};\n    }\n    \n    size_t chunks = (n + sve smaxvl() - 1) / sve smaxvl();\n    std::vector<int> result(2, 0);\n    svint32_t max_neg = svdup_n_s32(0);\n    svint32_t min_pos = svdup_n_s32(0);\n    \n    for(size_t i = 0; i < chunks; ++i){\n        size_t start = i * sve smaxvl();\n        size_t end = std::min(start + sve smaxvl(), n);\n        size_t len = end - start;\n        svint32_t v = svld1_s32(lst.data() + start);\n        v = svundef_b32(svcmpeq_s32(v, svdup_n_s32(0)));\n        \n        svbool_t p_neg = svcmplt_s32(v, svdup_n_s32(0));\n        svbool_t p_pos = svcmpgt_s32(v, svdup_n_s32(0));\n        \n        max_neg = svmaxv_s32(max_neg, svselect_b32(p_neg, v, svundef_s32()));\n        min_pos = svminv_s32(min_pos, svselect_b32(p_pos, v, svundef_s32()));\n    }\n    \n    result[0] = (svcntd_s32(max_neg) > 0) ? svget_s32(max_neg, 0) : 0;\n    result[1] = (svcntd_s32(min_pos) > 0) ? svget_s32(min_pos, 0) : 0;\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst){\n    size_t n = lst.size();\n    if(n == 0){\n        return {0, 0};\n    }\n    \n    size_t chunks = (n + sve_smallest_vector_length_v(sizeof(int)) / sizeof(int) - 1) / (sve_smallest_vector_length_v(sizeof(int)) / sizeof(int));\n    std::vector<int> result(2, 0);\n    svint32_t max_neg = svdup_n_s32(0);\n    svint32_t min_pos = svdup_n_s32(0);\n    \n    for(size_t i = 0; i < chunks; ++i){\n        size_t start = i * sve_smallest_vector_length_v(sizeof(int)) / sizeof(int);\n        size_t end = std::min(start + sve_smallest_vector_length_v(sizeof(int)) / sizeof(int), n);\n        size_t len = end - start;\n        \n        svint32_t v = svld1_s32(lst.data() + start);\n        v = svundef_b32(svcmpeq_s32(v, svdup_n_s32(0))); // Mask for zero elements\n        \n        svint32_t neg_mask = svcmplt_s32(v, svdup_n_s32(0)); // Mask for negative elements\n        svint32_t pos_mask = svcmpgt_s32(v, svdup_n_s32(0)); // Mask for positive elements\n        \n        svint32_t neg_vals = svsel_s32(v, v, v, neg_mask); // Select negative values\n        svint32_t pos_vals = svsel_s32(v, v, v, pos_mask); // Select positive values\n        \n        max_neg = svmaxv_s32(max_neg, neg_vals); // Find max of negative values\n        min_pos = svminv_s32(min_pos, pos_vals); // Find min of positive values\n    }\n    \n    result[0] = svlast_s32(max_neg);\n    result[1] = svlast_s32(min_pos);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst){\n    size_t n = lst.size();\n    if(n == 0){\n        return {0, 0};\n    }\n    \n    size_t vec_len = svcntw(); // Get the vector length\n    size_t num_vecs = (n + vec_len - 1) / vec_len;\n    \n    svint32_t max_neg = svdup_n_s32(0);\n    svint32_t min_pos = svdup_n_s32(0);\n    \n    for(size_t i = 0; i < num_vecs; ++i){\n        size_t start = i * vec_len;\n        size_t end = std::min(start + vec_len, n);\n        size_t len = end - start;\n        \n        svint32_t v = svld1_s32(lst.data() + start);\n        v = svtrim_s32(v, len);\n        \n        svbool_t p = svwhilelt_b32(0, len);\n        \n        svint32_t neg_mask = svcmplt_s32(v, svdup_n_s32(0));\n        svint32_t pos_mask = svcmpgt_s32(v, svdup_n_s32(0));\n        \n        svint32_t neg_vals = svptrue_b32(p) & svbsl_s32(neg_mask, v, svdup_n_s32(0));\n        svint32_t pos_vals = svptrue_b32(p) & svbsl_s32(pos_mask, v, svdup_n_s32(0));\n        \n        svint32_t current_max_neg = svmaxv_s32(neg_vals);\n        svint32_t current_min_pos = svminv_s32(pos_vals);\n        \n        max_neg = svmax_s32(max_neg, current_max_neg);\n        min_pos = svmin_s32(min_pos, current_min_pos);\n    }\n    \n    int result_max_neg = svlast_s32(max_neg);\n    int result_min_pos = svlast_s32(min_pos);\n    \n    return {result_max_neg, result_min_pos};\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst){\n    size_t n = lst.size();\n    if(n == 0){\n        return {0, 0};\n    }\n\n    svint32_t max_neg = svdup_n_s32(0);\n    svint32_t min_pos = svdup_n_s32(0);\n\n    for(size_t i = 0; i < n; i += svcntw()){\n        svint32_t chunk = svld1_s32(lst.data() + i);\n        svbool_t p = svwhilelt_u32(i, n);\n\n        svint32_t neg_mask = svcmplt_s32(chunk, svdup_n_s32(0));\n        svint32_t pos_mask = svcmpgt_s32(chunk, svdup_n_s32(0));\n\n        svint32_t neg_chunk = svsel_s32(svneg_s32(chunk), svdup_n_s32(0), neg_mask);\n        svint32_t pos_chunk = svsel_s32(svabs_s32(chunk), svdup_n_s32(0), pos_mask);\n\n        max_neg = svmaxv_s32(svmax_s32(max_neg, neg_chunk));\n        min_pos = svminv_s32(svmin_s32(min_pos, pos_chunk));\n    }\n\n    int largest_neg = svlast_s32(max_neg);\n    int smallest_pos = svlast_s32(min_pos);\n\n    return {largest_neg, smallest_pos};\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst){\n    size_t n = lst.size();\n    if(n == 0){\n        return {0, 0};\n    }\n    \n    size_t chunks = (n + sve_smallest_vector_length_v(sizeof(int)) / sizeof(int) - 1) / (sve_smallest_vector_length_v(sizeof(int)) / sizeof(int));\n    svint32_t max_neg = svdup_n_s32(0);\n    svint32_t min_pos = svdup_n_s32(0);\n    \n    for(size_t i = 0; i < chunks; ++i){\n        size_t start = i * sve_smallest_vector_length_v(sizeof(int)) / sizeof(int);\n        size_t end = std::min(start + sve_smallest_vector_length_v(sizeof(int)) / sizeof(int), n);\n        size_t len = end - start;\n        \n        svint32_t v = svld1_s32(lst.data() + start);\n        v = svundef_b32(svcmpeq_s32(v, svdup_n_s32(0)));\n        \n        svbool_t pg = svwhilelt_b32(0, len);\n        svint32_t neg = svmaxv_s32_m(pg, v, svdup_n_s32(0));\n        svint32_t pos = svminv_s32_m(pg, v, svdup_n_s32(0));\n        \n        max_neg = svmaxv_s32(max_neg, neg);\n        min_pos = svminv_s32(min_pos, pos);\n    }\n    \n    int result_a = svlastb_s32(max_neg);\n    int result_b = svlastb_s32(min_pos);\n    \n    return {result_a, result_b};\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t special_factorial_simd(uint64_t n){\n    svbool_t pg = svwhilelt_b64(0, n);\n    svint64_t indices = svindex_b64(0, n);\n    svint64_t fact = svdup_n_s64(1);\n    \n    do {\n        svint64_t current = svsel_b64(pg, svadd_x_s64(indices, svdup_n_s64(1)), fact);\n        svbool_t mask = svcmpeq_b64(current, svdup_n_s64(1));\n        svint64_t temp = svmla_x_s64(current, current, svdup_n_s64(-1));\n        fact = svmla_b64(pg, fact, temp);\n        fact = svselect_b64(mask, svdup_n_s64(1), fact);\n    } while ((pg = svnext(pg)));\n\n    return svlast_s64(fact);\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t special_factorial_simd(uint64_t n){\n    svbool_t pg = svwhilelt_b64(0, n);\n    svint64_t indices = svindex_b64(0, 1);\n    svint64_t fact_indices = svadd_x_b64(indices, svdup_n_b64(1));\n    svbool_t stop_cond = svcmpeq_b64(fact_indices, svdup_n_b64(n + 1));\n    \n    svint64_t fact_acc = svdup_n_b64(1);\n    while(!svptest_any(svptrue_b64(), stop_cond)){\n        svbool_t pg_fact = svwhilelt_b64(0, n);\n        svint64_t fact_vals = svmla(pg_fact, fact_acc, fact_indices);\n        fact_acc = svselect_b64(stop_cond, fact_acc, fact_vals);\n        fact_indices = svadd_x_b64(fact_indices, svdup_n_b64(1));\n        stop_cond = svcmpeq_b64(fact_indices, svdup_n_b64(n + 1));\n    }\n    return svlast_elem_u64(fact_acc);\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t special_factorial_simd(uint64_t n){\n    svbool_t pg = svwhilelt_b64(0, n);\n    svint64_t indices = svindex_b64(0, 1);\n    svint64_t fact_indices = svadd_x_b64(indices, svdup_n_b64(1 - svindex_b64(0, 1)[0]));\n    svbool_t stop_cond = svcmpeq_n_b64(fact_indices, n);\n    svbool_t active = svptrue_b64();\n    \n    svfloat64_t fact_acc = svdup_n_f64(1.0);\n    \n    while(!svptest_any(svptrue_b64(), stop_cond)){\n        svfloat64_t fact_val = svtrn1_f64(svld1(pg, fact_indices), svld1(pg, fact_indices));\n        fact_acc = svmla_f64(fact_acc, fact_val, fact_val);\n        fact_indices = svadd_x_b64(fact_indices, svdup_n_b64(1));\n        stop_cond = svcmpeq_n_b64(fact_indices, n);\n    }\n    \n    return (uint64_t)svlast_n_f64(fact_acc);\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t special_factorial_simd(uint64_t n){\n    svbool_t pg = svwhilelt_b64(0, n);\n    svint64_t indices = svindex_b64(0, 1);\n    svint64_t fact_indices = svadd_x_b64(indices, svdup_n_b64(1));\n    svbool_t stop_cond = svcmpeq_n_b64(fact_indices, n);\n    svbool_t last_iter = svlast_elem_b64(pg, stop_cond);\n\n    svfloat64_t acc = svdup_n_f64(1.0);\n    svfloat64_t temp_acc;\n\n    do {\n        temp_acc = svdiv_f64(svconst_f64(pg, 1.0), acc);\n        acc = svmla_f64(acc, temp_acc, svindex_f64(pg, 0));\n    } while ((pg = svptrue_b64()) && !last_iter);\n\n    return (uint64_t)svgetlane_f64(acc, 0);\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t special_factorial_simd(uint64_t n){\n    svbool_t pg = svwhilelt_b64(0, n);\n    svint64_t indices = svindex_b64(0, n);\n    svint64_t fact = svdup_n_s64(1);\n    \n    while(svptest_any(pg)){\n        svbool_t inner_pg = svwhilelt_b64(0, n);\n        svint64_t inner_indices = svindex_b64(0, n);\n        svint64_t inner_fact = svdup_n_s64(1);\n        \n        while(svptest_any(inner_pg)){\n            svint64_t val = svundef_s64();\n            svptrue_b64_b32(val, inner_pg);\n            svint64_t current = svsel_s64(val, inner_indices, svundef_s64());\n            \n            svint64_t temp = svdup_n_s64(1);\n            for(int i=1; i<=current.svlen; i++){\n                temp = svmla_s64(temp, temp, svindex_s64(current, i));\n            }\n            inner_fact = svmul_s64(inner_fact, temp);\n            inner_pg = svlsr_b64(inner_pg, 1);\n        }\n        fact = svmul_s64(fact, inner_fact);\n        pg = svlsr_b64(pg, 1);\n    }\n    return svaddv_u64(fact);\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```c\nint sum_squares_simd(const std::vector<int> & lst){\n    svint32_t indices = svindex_b32(0, 1);\n    svint32_t mask_mult_3 = svcmpeq_n_s32(indices, 3);\n    svint32_t mask_mult_4 = svcmpeq_n_s32(indices, 4);\n    svbool_t pg = svwhilelt_b32(0, lst.size());\n    svint32_t vec = svld1(pg, lst.data());\n    svint32_t squared = svmla_x(pg, vec, vec, svcond_b32(mask_mult_3, vec, svdup_n_s32(1)));\n    svint32_t cubed = svmla_x(pg, vec, squared, svcond_b32(svand_b32(mask_mult_4, svnot_b32(mask_mult_3)), vec, svdup_n_s32(1)));\n    svint32_t result_vec = svadd_x(pg, squared, cubed);\n    int result = svaddv_b32(pg, result_vec);\n    return result;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```c\nint sum_squares_simd(const std::vector<int> & lst){\n    svint32_t indices = svindex_b32(0, 1);\n    svint32_t mask3 = svcmpeq_n_s32(indices, 3);\n    svint32_t mask4 = svcmpeq_n_s32(indices, 4);\n    svbool_t pg = svwhilelt_b32(0, lst.size());\n    svint32_t vec = svld1(pg, lst.data());\n    svint32_t squared = svmla_xn_s32(vec, vec, 0);\n    svint32_t cubed = svmla_xn_s32(vec, svmla_xn_s32(vec, vec, 0), 0);\n    svint32_t result = svptrue_b32();\n    result = svsel_b32(svand_b32(pg, mask3), squared, result);\n    result = svsel_b32(svand_b32(pg, mask4), cubed, result);\n    int sum = svaddv_b32(pg, result);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```c\nint sum_squares_simd(const std::vector<int> & lst){\n    svint32_t indices = svindex_b32(0, 1);\n    svbool_t pg = svwhilelt_b32(0, lst.size());\n    svint32_t input = svld1(pg, lst.data());\n    svint32_t result = svdup_n_s32(0);\n\n    svint32_t mask_mult3 = svcmpeq_n_b32(indices, 3);\n    svint32_t mask_mult4 = svcmpeq_n_b32(indices, 4);\n\n    svint32_t squared = svmla_x_s32(input, input, svtrue_s32());\n    svint32_t cubed = svmla_x_s32(squared, input, svtrue_s32());\n\n    result = svpadd_x_s32(result, svcond_b32(mask_mult3, squared, svcond_b32(mask_mult4, cubed, input)));\n\n    return svaddv_s32(result);\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```c\nint sum_squares_simd(const std::vector<int> & lst){\n    svint32_t input = svld1_s32(lst.data());\n    svint32_t indices = svindex_s32(0, 1);\n    svbool_t p3 = svcmpeq_n_s32(indices, 3);\n    svbool_t p4 = svcmpeq_n_s32(indices, 4);\n    svint32_t result = svabs_s32(input);\n\n    result = svsel_s32(svmla_x(svptrue_b32(), result, result), result, p3);\n    result = svsel_s32(svmla_x(svptrue_b32(), result, result, result), result, svand_b32(p4, svnot_b32(p3)));\n\n    int sum = 0;\n    for(int i = 0; i < svcnts(); ++i){\n        sum += svget_s32(result, i);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```c\nint sum_squares_simd(const std::vector<int> & lst){\n    svbool_t pg = svwhilelt_b32(0, lst.size());\n    svint32_t vec = svld1(pg, lst.data());\n    svint32_t indices = svindex_b32(0, lst.size());\n\n    svint32_t squared = svmla_x(pg, vec, vec, svdup_n_s32(0));\n    svint32_t cubed = svmla_x(pg, svpow_n_v(vec, svdup_n_s32(3)), svdup_n_s32(0));\n\n    svbool_t mask_multiple_of_3 = svcmpeq_n_u32(svindex_u32(indices), svdup_n_u32(3));\n    svbool_t mask_multiple_of_4 = svcmpeq_n_u32(svindex_u32(indices), svdup_n_u32(4));\n\n    svint32_t result = svptrue_b32();\n    result = svsel_b32(mask_multiple_of_3, squared, result);\n    result = svsel_b32(mask_multiple_of_4 & ~mask_multiple_of_3, cubed, result);\n\n    int sum = svaddv_b32(pg, result);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```c\nint specialFilter_simd(const std::vector<int> & nums){\n    svbool_t pg = svwhilelt_b32(0, nums.size());\n    int count = 0;\n    svint32_t vec = svld1(pg, nums.data());\n    svint32_t mask_gt_10 = svcmpgt(vec, svdup_n_s32(10));\n    svint32_t first_digits, last_digits;\n    svint32_t mask_odd_first_last = svtrue_b32();\n    \n    for(int i=0; i<svcntw(); i++){\n        svint32_t num = svsel_b32(pg, vec, svdup_n_s32(0), i);\n        int n = svget_s32(num, 0);\n        if(n > 10){\n            int abs_n = abs(n);\n            int first_digit = abs_n;\n            while(first_digit >= 10){\n                first_digit /= 10;\n            }\n            int last_digit = abs_n % 10;\n            if((first_digit % 2 != 0) && (last_digit % 2 != 0)){\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```c\nint specialFilter_simd(const std::vector<int> & nums){\n    svbool_t pg = svwhilelt_b32(0, nums.size());\n    svint32_t vec = svld1(pg, nums.data());\n    svint32_t gt_ten = svcmpgt(vec, svdup_n_s32(10));\n    svint32_t first_digit_odd = svand_n(svcmpeq_n(svsmul(vec, svdup_n_s32(10)), svdup_n_s32(10)), \n                                         svorr_n(svcmpeq_n(svsmul(vec, svdup_n_s32(100)), svdup_n_s32(100)),\n                                                 svcmpeq_n(svsmul(vec, svdup_n_s32(1000)), svdup_n_s32(1000))));\n    svint32_t last_digit_odd = svand_n(svcmpeq_n(svbitwise_and(vec, svdup_n_s32(1)), svdup_n_s32(1)),\n                                       svorr_n(svcmpeq_n(svbitwise_and(vec, svdup_n_s32(3)), svdup_n_s32(3)),\n                                               svcmpeq_n(svbitwise_and(vec, svdup_n_s32(5)), svdup_n_s32(5))));\n    svbool_t mask = svand(pg, svand(gt_ten, svand(first_digit_odd, last_digit_odd)));\n    int count = svcntd() - svcntb(svmvn_b32(mask));\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```c\nint specialFilter_simd(const std::vector<int> & nums){\n    svbool_t pg = svwhilelt_b32(0, nums.size());\n    int count = 0;\n    svint32_t vec = svld1(pg, nums.data());\n    svint32_t mask_gt_10 = svcmpgt(vec, svdup_n_s32(10));\n    svint32_t first_digits, last_digits;\n    svint32_t mask_odd_first_last = svtrue_b32();\n    \n    for(int i=0; i<nums.size(); i+=16){\n        first_digits = svabs_s32(svshr_n_s32(vec, 31));\n        last_digits = svabs_s32(svmvn_s32(vec, svlsl_n_s32(first_digits, 4)));\n        \n        svbool_t mask_first_odd = svcmpeq_n_s32(first_digits, 1) |\n                                  svcmpeq_n_s32(first_digits, 3) |\n                                  svcmpeq_n_s32(first_digits, 5) |\n                                  svcmpeq_n_s32(first_digits, 7) |\n                                  svcmpeq_n_s32(first_digits, 9);\n        \n        svbool_t mask_last_odd = svcmpeq_n_s32(last_digits, 1) |\n                                 svcmpeq_n_s32(last_digits, 3) |\n                                 svcmpeq_n_s32(last_digits, 5) |\n                                 svcmpeq_n_s32(last_digits, 7) |\n                                 svcmpeq_n_s32(last_digits, 9);\n        \n        mask_odd_first_last = svand_b32(mask_first_odd, mask_last_odd);\n        svbool_t mask_final = svand_b32(mask_gt_10, mask_odd_first_last);\n        count += svcntd() - svcntb(svtz_b32(mask_final));\n        vec = svld1_x(pg, nums.data()+i, vec);\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```c\nint specialFilter_simd(const std::vector<int> & nums){\n    svbool_t pg = svwhilelt_b32(0, nums.size());\n    svint32_t vec = svld1(pg, nums.data());\n    svint32_t gt_ten = svcmpgt(vec, svdup_n_s32(10));\n    svbool_t odd_digits = svtrue_b32();\n    for(int i=0; i<svcntw(); i++){\n        svint32_t num = svundef_b32();\n        if(i == 0){\n            num = svtrn1_u32(svreinterpret_u32_s32(vec), svreinterpret_u32_s32(vec));\n        }\n        else{\n            num = svtrn2_u32(svreinterpret_u32_s32(vec), svreinterpret_u32_s32(vec));\n        }\n        svint32_t abs_num = svabs_s32(num);\n        svint32_t first_digit = svdivide(abs_num, svdup_n_s32(1000000000));\n        svint32_t last_digit = svmod(abs_num, svdup_n_s32(10));\n        svbool_t first_odd = svcmpeq(first_digit, svdup_n_s32(1)) |\n                             svcmpeq(first_digit, svdup_n_s32(3)) |\n                             svcmpeq(first_digit, svdup_n_s32(5)) |\n                             svcmpeq(first_digit, svdup_n_s32(7)) |\n                             svcmpeq(first_digit, svdup_n_s32(9));\n        svbool_t last_odd = svcmpeq(last_digit, svdup_n_s32(1)) |\n                            svcmpeq(last_digit, svdup_n_s32(3)) |\n                            svcmpeq(last_digit, svdup_n_s32(5)) |\n                            svcmpeq(last_digit, svdup_n_s32(7)) |\n                            svcmpeq(last_digit, svdup_n_s32(9));\n        svbool_t digit_check = svand(first_odd, last_odd);\n        odd_digits = svand(odd_digits, digit_check);\n    }\n    svbool_t final_check = svand(gt_ten, odd_digits);\n    int count = svcntw() - svcntb(final_check);\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```c\nint specialFilter_simd(const std::vector<int> & nums){\n    svbool_t pg = svwhilelt_b32(0, nums.size());\n    int count = 0;\n    svint32_t vec = svld1(pg, nums.data());\n    svint32_t mask_gt_10 = svcmpgt(vec, svdup_n_s32(10));\n    svint32_t first_digits, last_digits;\n    svint32_t mask_odd_first_last = svtrue_b32();\n    \n    for(int i=0; i<svcntw(); i+=8){\n        first_digits = svuzp1_b32(svshr_n_b32(mask_gt_10, i), svshr_n_b32(mask_gt_10, i+4));\n        last_digits = svuzp2_b32(svshr_n_b32(mask_gt_10, i), svshr_n_b32(mask_gt_10, i+4));\n        mask_odd_first_last = svand_b32(mask_odd_first_last, svcmpeq_b32(svmovlb_h_b32(first_digits), svcreate_h_b32(1,3,5,7,9,1,3,5)));\n        mask_odd_first_last = svand_b32(mask_odd_first_last, svcmpeq_b32(svmovlb_h_b32(last_digits), svcreate_h_b32(1,3,5,7,9,1,3,5)));\n        count += svcntw() * svcntw();\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t get_max_triples_simd(uint64_t n){\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t a = svindex_b32(pg, 1, 1); // Generate a_i = i\n    a = svcadd_b32(pg, a, svdup_n_b32(-1)); // a_i = i - 1\n    a = svcmla_b32(pg, a, a, a); // a_i = i * i - i + 1\n\n    uint64_t count = 0;\n    svint32_t sum_mask = svdup_n_b32(3);\n\n    for(int i=0; i<n-2; i++){\n        svint32_t ai = svundef_b32();\n        if(i > 0) ai = svld1(pg, &a[i]);\n        else      ai = svdup_n_b32(a[i]);\n\n        svint32_t aj = svundef_b32();\n        for(int j=i+1; j<n-1; j++){\n            if(j > i+1) aj = svld1(pg, &a[j]);\n            else         aj = svdup_n_b32(a[j]);\n\n            svint32_t ak = svundef_b32();\n            for(int k=j+1; k<n; k++){\n                if(k > j+1) ak = svld1(pg, &a[k]);\n                else         ak = svdup_n_b32(a[k]);\n\n                svint32_t sum = svadd_b32(ai, aj);\n                sum = svadd_b32(sum, ak);\n\n                svbool_t cond = svcmpeq_b32(svdiv_b32(sum, sum_mask), svdup_n_b32(0));\n                count += svcntd_b32(cond);\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t get_max_triples_simd(uint64_t n){\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t a = svindex_b32(pg, 1, 1); // Generate indices from 1 to n\n    a = svsubv_s32(a, svdup_n_s32(1));   // a_i = i - 1\n    a = svmulv_s32(a, a);                // a_i = (i - 1)^2\n    a = svaddv_s32(a, svdup_n_s32(1));   // a_i = (i - 1)^2 + 1\n\n    uint64_t count = 0;\n    for(int i=0; i<n-2; i+=svcntw()){\n        svint32_t ai = svundef_s32();\n        svint32_t aj = svundef_s32();\n        svint32_t ak = svundef_s32();\n\n        svbool_t pg_inner = svwhilelt_b32(i, n);\n        ai = svptrue_b32(pg_inner) ? svld1_s32(&a, svindex_b32(pg_inner, i, 1)) : ai;\n        \n        for(int j=i+1; j<n-1; j+=svcntw()){\n            svbool_t pg_j = svwhilelt_b32(j, n);\n            aj = svptrue_b32(pg_j) ? svld1_s32(&a, svindex_b32(pg_j, j, 1)) : aj;\n\n            for(int k=j+1; k<n; k+=svcntw()){\n                svbool_t pg_k = svwhilelt_b32(k, n);\n                ak = svptrue_b32(pg_k) ? svld1_s32(&a, svindex_b32(pg_k, k, 1)) : ak;\n\n                svint32_t sum = svaddv_s32(ai, svaddv_s32(aj, ak));\n                svbool_t cond = svcmpeq_u32(svand_b32(svmvn_b32(svcmpeq_u32(sum, svdup_n_u32(0))), \n                                                      svcmpeq_u32(svmodq_u32(sum, svdup_n_u32(3)), \n                                                                  svdup_n_u32(0))), \n                                             svptrue_b32());\n                count += svcntw() * svcntw() * svcntw() * svcntb(cond);\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t get_max_triples_simd(uint64_t n){\n    svbool_t pg = svwhilelt_b64(0, n);\n    svint64_t a = svindex_b64(pg, 1, 1); // Create vector of indices starting from 1\n    a = svsubv_b64(a, svindex_b64(pg, 0, 1)); // Subtract 1 to align with 0-based indexing\n    a = svmulv_b64(a, a); // Square each element\n    a = svaddv_b64(a, svindex_b64(pg, 1, 0)); // Add 1 to each element\n\n    uint64_t count = 0;\n    for(svuint64_t i = svindex_u64_b64(pg, 0, 1); svcmpeq_b64(i, svlen_b64(pg)); i = svadd_n_u64(i, 1)){\n        for(svuint64_t j = svadd_n_u64(i, 1); svcmple_b64(j, svlen_b64(pg)); j = svadd_n_u64(j, 1)){\n            svint64_t sum_ij = svaddv_b64(a[i], a[j]);\n            for(svuint64_t k = svadd_n_u64(j, 1); svcmple_b64(k, svlen_b64(pg)); k = svadd_n_u64(k, 1)){\n                svint64_t total = svaddv_b64(sum_ij, a[k]);\n                svbool_t cond = svcmpeq_m_b64(pg, svmod_b64(total, svdup_n_b64(3)), svdup_n_b64(0));\n                count += svcntd() * svcntb(cond);\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t get_max_triples_simd(uint64_t n){\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t a = svindex_b32(pg, 1, 1); // Generate a_i = i\n    a = svcadd_b32(pg, a, svdup_n_b32(-1)); // a_i = i - 1\n    a = svcmla_b32(pg, a, a, a); // a_i = i * i - i + 1\n\n    uint64_t count = 0;\n    svint32_t sum_mask = svdup_n_s32(3);\n    svbool_t all_true = svptrue_b32();\n\n    for(int i=0; i<n-2; i+=svcntw()){\n        svint32_t ai = svld1(pg, &a + i);\n        for(int j=i+1; j<n-1; j+=svcntw()){\n            svint32_t aj = svld1(pg, &a + j);\n            svint32_t temp_sum = svcadd_b32(pg, ai, aj);\n            for(int k=j+1; k<n; k+=svcntw()){\n                svint32_t ak = svld1(pg, &a + k);\n                svint32_t total_sum = svcadd_b32(pg, temp_sum, ak);\n                svbool_t cond = svcmpeq_m_b32(all_true, svmod_b32(pg, total_sum, sum_mask), svdup_n_s32(0));\n                count += svcntv_b32(cond);\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t get_max_triples_simd(uint64_t n){\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t a = svindex_b32(pg, 1, 1); // Generate indices from 1 to n\n    a = svsubv_s32(a, svdup_n_s32(1));   // a_i = i - 1\n    a = svmulv_s32(a, a);                // a_i = a_i * a_i\n    a = svaddv_s32(a, svdup_n_s32(1));   // a_i = a_i + 1\n\n    uint64_t count = 0;\n    for(int i=0; i<n-2; i+=svcntw()){\n        svint32_t ai = svundef_s32();\n        svint32_t aj = svundef_s32();\n        svint32_t ak = svundef_s32();\n\n        svbool_t pg_inner = svwhilelt_b32(i, n);\n        ai = svext_s32(a, svundef_s32(), i);\n\n        for(int j=i+1; j<n-1; j+=svcntw()){\n            aj = svext_s32(a, svundef_s32(), j);\n\n            for(int k=j+1; k<n; k+=svcntw()){\n                ak = svext_s32(a, svundef_s32(), k);\n\n                svint32_t sum = svaddv_s32(svaddv_s32(ai, aj), ak);\n                svbool_t cond = svcmpeq_m(pg_inner, svmodq_s32(sum, svdupq_n_s32(3)), svdupq_n_s32(0));\n                count += svcntw() * svcntw() * svcntw() * svcntb(cond);\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\nint x_or_y_simd(int n, int x, int y){\n    svbool_t pg = svwhilelt_b32(0, n);\n    int result = svtern_b32(pg, svcmpne_b32(pg, svprimes_b32(pg, n), svtrue_b32()), x, y);\n    return result;\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\nint x_or_y_simd(int n, int x, int y){\n    svbool_t pg = svwhilelt_b32(0, n);\n    int32_t result = svtern_b32(pg, svcmpgt_b32(pg, svprimes_b32(pg, n), svdup_g32(1)), svdup_g32(x), svdup_g32(y));\n    return result;\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\nint x_or_y_simd(int n, int x, int y){\n    svbool_t pg = svwhilelt_b32(0, n);\n    int result = svternm_b32(pg, svcmpeq_n_s32(n, svcreate_lane_s32(0, svindex_u32(0), 0)), x, y);\n    return result;\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\nint x_or_y_simd(int n, int x, int y){\n    svbool_t pg = svwhilelt_b32(0, n);\n    int32_t result = svternm_b32(pg, svcmpeq_n_s32(n, svmla_x_s32(1, 1, 1)), x, y);\n    return result;\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\nint x_or_y_simd(int n, int x, int y){\n    svbool_t pg = svwhilelt_b32(0, n);\n    int32_t result = svtern_b32(pg, svcmpne_b32(svprfxb(), svcreateb(2)), x, y);\n    return result;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <cmath>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    if (lst.empty()) return 0;\n\n    size_t n = lst.size();\n    size_t i = 0;\n    svbool_t p = svwhilelt_b(n, i);\n\n    svfloat32_t sum = svdup_n_f32(0.0f);\n    \n    while (svptest_any(p)) {\n        svfloat32_t values = svld1(p, &lst[i]);\n        svbool_t is_odd = svcmpeq_m(p, p, svrinta_f32(values), svdup_n_f32(0.0f));\n        svbool_t is_positive = svcmple_m(p, p, svdup_n_f32(0.0f), values);\n        svbool_t is_integer = svcmpeq_m(p, p, svrinta_f32(values), values);\n\n        svbool_t mask = svand_m(p, p, is_odd, svand_m(p, p, is_positive, is_integer));\n\n        svfloat32_t squared = svmla_f32(values, values, svdup_n_f32(0.0f));\n        sum = svaddv_f32(svselect_f32(mask, squared, svdup_n_f32(0.0f)), sum);\n\n        i += svcntd();\n        p = svwhilelt_b(n, i);\n    }\n\n    return (uint64_t)svarith_reduce_add(sum);\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <cmath>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    if (lst.empty()) return 0;\n\n    size_t n = lst.size();\n    size_t align = svcntw(); // Number of elements per vector\n    uint64_t sum = 0;\n\n    // Convert the list to integer values\n    svint32_t int_vals = svld1_s32(reinterpret_cast<const int32_t*>(lst.data()), align);\n\n    // Process in chunks of 'align' elements\n    for (size_t i = 0; i < n; i += align) {\n        svint32_t vals = svld1_s32(reinterpret_cast<const int32_t*>(lst.data() + i), align);\n        \n        // Filter out non-positive values\n        svbool_t mask_pos = svcmpgt_s32(vals, svdup_n_s32(0));\n        vals = svsel_s32(svundef_s32(), vals, mask_pos);\n\n        // Check for odd integers\n        svbool_t mask_odd = svcmpeq_s32(svand_s32(vals, svdup_n_s32(1)), svdup_n_s32(1));\n        vals = svsel_s32(svundef_s32(), vals, mask_odd);\n\n        // Compute squares\n        svint32_t squares = svmla_s32(vals, vals, svundef_s32());\n\n        // Accumulate results\n        sum += svaddv_u32(svtol_u32(squares, svtrue()));\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <cmath>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    if (lst.empty()) return 0;\n\n    size_t n = lst.size();\n    size_t i = 0;\n    svbool_t p = svwhilelt_b(n, i);\n\n    svfloat32_t sum = svdup_n_f32(0.0f);\n    svfloat32_t values;\n\n    while (svptest_any(p)) {\n        values = svld1(p, &lst[i]);\n        svbool_t is_odd = svcmpeq_m(p, p, svrinta_f32(values), svdup_n_f32(0.0f));\n        svbool_t is_positive = svcmple_m(p, p, svdup_n_f32(0.0f), values);\n        svbool_t is_integer = svcmpeq_m(p, p, svrinta_f32(values), values);\n\n        svbool_t mask = svand_m(p, p, is_odd, svand_m(p, p, is_positive, is_integer));\n\n        svfloat32_t squared = svmla_f32(values, values, svdup_n_f32(0.0f));\n        sum = svaddv_m(p, sum, squared, mask);\n\n        i += svcntd();\n        p = svwhilelt_b(n, i);\n    }\n\n    uint64_t result = svaddv_u64(svreinterpret_u64_f32(sum));\n    return result;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <cmath>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst){\n    if (lst.empty()) {\n        return 0;\n    }\n\n    size_t n = lst.size();\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b(n, i);\n    svfloat32_t vec = svld1(pg, lst.data() + i);\n\n    uint64_t sum = 0;\n\n    while(svptest_any(svptrue_b(), pg)){\n        svint32_t int_vec = svrintx_f32(vec);\n        svbool_t is_odd = svcmpeq_m(pg, svand_m(pg, int_vec, svcreate_h(1)), svcreate_h(1));\n        svbool_t is_positive = svcmple_m(pg, int_vec, svcreate_h(0));\n        svbool_t is_valid = svand_m(pg, is_odd, is_positive);\n\n        svfloat32_t squared = svmul_x(vec, vec);\n        svfloat32_t filtered_squared = svternary_x(is_valid, squared, svdup_n_f32(0));\n\n        sum += svaddv_u64(svaddv_u32(svtol_u32(filtered_squared)));\n\n        i += svcntd();\n        pg = svwhilelt_b(n, i);\n        vec = svld1(pg, lst.data() + i);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <cmath>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst){\n    if (lst.empty()) {\n        return 0;\n    }\n\n    size_t n = lst.size();\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b(n, i);\n    svfloat32_t vec = svld1(pg, lst.data() + i);\n\n    uint64_t sum = 0;\n\n    while(svptest_any(svptrue_b(), pg)){\n        svint32_t int_vec = svrintx_f32(vec);\n        svbool_t is_odd = svcmpeq_w(svmovlb_h(svand_h(int_vec, svcreate_h(1))), svcreate_h(1));\n        svbool_t is_positive = svcmple_f32(vec, svdup_f32(0.0f));\n        svbool_t is_valid = svand_b(is_odd, svnot_b(is_positive));\n\n        svfloat32_t squared = svmul_x(vec, vec);\n        svfloat32_t filtered_squared = svptrue_b_f32(is_valid, squared);\n\n        sum += svaddv_u32(svreinterpret_u32_f32(filtered_squared));\n\n        i += svcntd();\n        pg = svwhilelt_b(n, i);\n        vec = svld1(pg, lst.data() + i);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess){\n    svint32_t game_vec = svld1_s32(game.data());\n    svint32_t guess_vec = svld1_s32(guess.data());\n    svint32_t diff_vec = svabs_s32(svsub_s32(game_vec, guess_vec));\n    svbool_t pg = svwhilelt_b32(0, (int32_t)game.size());\n    svst1_s32((int32_t*)guess.data(), pg, diff_vec);\n    return guess;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess){\n    svint32_t game_vec = svld1_s32(game.data());\n    svint32_t guess_vec = svld1_s32(guess.data());\n    svint32_t diff_vec = svabs_s32(svsub_s32(game_vec, guess_vec));\n    svbool_t pg = svwhilelt_b32(0, (int32_t)game.size());\n    svst1_s32((int32_t*)guess.data(), pg, diff_vec);\n    return guess;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess){\n    svint32_t game_vec = svld1_s32(game.data());\n    svint32_t guess_vec = svld1_s32(guess.data());\n    svint32_t diff_vec = svabs_s32(svsub_s32(game_vec, guess_vec));\n    svbool_t pg = svwhilelt_u32(0, svlen_s32(diff_vec));\n    svst1_s32((int*)guess.data(), pg, diff_vec);\n    return guess;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess){\n    svint32_t game_vec = svld1_s32(game.data());\n    svint32_t guess_vec = svld1_s32(guess.data());\n    svint32_t diff_vec = svabs_s32(svsub_s32(game_vec, guess_vec));\n    svbool_t pg = svwhilelt_b32(0, svcntw());\n    svst1_s32(diff_vec, pg, reinterpret_cast<int*>(diff_vec.data()));\n    return std::vector<int>(diff_vec.data(), diff_vec.data() + svcntw());\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess){\n    svint32_t game_vec = svld1_s32(game.data());\n    svint32_t guess_vec = svld1_s32(guess.data());\n    svint32_t diff_vec = svabs_s32(svsub_s32(game_vec, guess_vec));\n    svbool_t pg = svwhilelt_b32(0, (int32_t)game.size());\n    svst1_s32((int32_t*)guess.data(), pg, diff_vec);\n    return guess;\n}\n```"}

{"task_id": "SimdBench_0", "completion": "```c\nvoid conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0", "completion": "```c\nvoid conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0", "completion": "```c\nvoid conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0", "completion": "```cpp\nvoid conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0", "completion": "```c\nvoid conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_1", "completion": "```c\nvoid load_modify_store(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int element = src[i];\n        int tmp1 = (element * scale) >> 3;\n        int tmp2 = (element * scale) << 3;\n        dst[i] = (element * scale + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1", "completion": "```c\nvoid load_modify_store(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int element = src[i];\n        int tmp1 = (element * scale) >> 3;\n        int tmp2 = (element * scale) << 3;\n        dst[i] = (element * scale + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1", "completion": "```c\nvoid load_modify_store(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int element = src[i];\n        int tmp1 = (element * scale) >> 3;\n        int tmp2 = (element * scale) << 3;\n        dst[i] = (element * scale + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1", "completion": "```c\nvoid load_modify_store(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int element = src[i];\n        int tmp1 = (element * scale) >> 3;\n        int tmp2 = (element * scale) << 3;\n        dst[i] = (element * scale + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1", "completion": "```c\nvoid load_modify_store(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int element = src[i];\n        int tmp1 = (element * scale) >> 3;\n        int tmp2 = (element * scale) << 3;\n        dst[i] = (element * scale + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_2", "completion": "```c\nvoid strided_load_store(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; r++) {\n        dst[r] = src[r * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2", "completion": "```c\nvoid strided_load_store(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; r++) {\n        dst[r] = src[r * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2", "completion": "```c\nvoid strided_load_store(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; r++) {\n        dst[r] = src[r * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2", "completion": "```c\nvoid strided_load_store(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; r++) {\n        dst[r] = src[r * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2", "completion": "```c\nvoid strided_load_store(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; r++) {\n        dst[r] = src[r * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_3", "completion": "```c\nvoid indexed_access(const float *src, const int *indices, float *dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = src[indices[i]]; // Gather operation\n    }\n    for (size_t i = 0; i < length; ++i) {\n        dst[indices[i]] = src[i]; // Scatter operation\n    }\n}\n```"}
{"task_id": "SimdBench_3", "completion": "```c\nvoid indexed_access(const float *src, const int *indices, float *dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = src[indices[i]]; // Gather operation\n    }\n    for (size_t i = 0; i < length; ++i) {\n        dst[indices[i]] = src[i]; // Scatter operation\n    }\n}\n```"}
{"task_id": "SimdBench_3", "completion": "```c\nvoid indexed_access(const float *src, const int *indices, float *dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = src[indices[i]]; // Gather operation\n    }\n    for (size_t i = 0; i < length; ++i) {\n        dst[indices[i]] = src[i]; // Scatter operation\n    }\n}\n```"}
{"task_id": "SimdBench_3", "completion": "```c\nvoid indexed_access(const float *src, const int *indices, float *dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = src[indices[i]]; // Gather operation\n    }\n    for (size_t i = 0; i < length; ++i) {\n        dst[indices[i]] = src[i]; // Scatter operation\n    }\n}\n```"}
{"task_id": "SimdBench_3", "completion": "```c\nvoid indexed_access(const float *src, const int *indices, float *dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = src[indices[i]]; // Gather operation\n    }\n    for (size_t i = 0; i < length; ++i) {\n        dst[indices[i]] = src[i]; // Scatter operation\n    }\n}\n```"}
{"task_id": "SimdBench_4", "completion": "```c\nvoid range_reverse(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start < end) {\n        int16_t temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n```"}
{"task_id": "SimdBench_4", "completion": "```c\nvoid range_reverse(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start < end) {\n        int16_t temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n```"}
{"task_id": "SimdBench_4", "completion": "```c\nvoid range_reverse(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start < end) {\n        int16_t temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n```"}
{"task_id": "SimdBench_4", "completion": "```c\nvoid range_reverse(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start < end) {\n        int16_t temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n```"}
{"task_id": "SimdBench_4", "completion": "```c\nvoid range_reverse(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start < end) {\n        int16_t temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n```"}
{"task_id": "SimdBench_5", "completion": "```c\nvoid extract_tensor_slice(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            size_t src_idx = i * dim2 * dim3 + j * dim3 + slice_idx;\n            size_t dst_idx = i * dim2 + j;\n            slice[dst_idx] = tensor[src_idx];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5", "completion": "```c\nvoid extract_tensor_slice(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            size_t src_idx = i * dim2 * dim3 + j * dim3 + slice_idx;\n            size_t dst_idx = i * dim2 + j;\n            slice[dst_idx] = tensor[src_idx];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5", "completion": "```c\nvoid extract_tensor_slice(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            size_t src_idx = i * dim2 * dim3 + j * dim3 + slice_idx;\n            size_t dst_idx = i * dim2 + j;\n            slice[dst_idx] = tensor[src_idx];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5", "completion": "```c\nvoid extract_tensor_slice(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            size_t src_idx = i * dim2 * dim3 + j * dim3 + slice_idx;\n            size_t dst_idx = i * dim2 + j;\n            slice[dst_idx] = tensor[src_idx];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5", "completion": "```c\nvoid extract_tensor_slice(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            size_t src_idx = i * dim2 * dim3 + j * dim3 + slice_idx;\n            size_t dst_idx = i * dim2 + j;\n            slice[dst_idx] = tensor[src_idx];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6", "completion": "```c\nvoid blocked_matrix_transpose(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t br = 0; br < rows; br += block_size) {\n        for (size_t bc = 0; bc < cols; bc += block_size) {\n            for (size_t i = 0; i < block_size; ++i) {\n                for (size_t j = 0; j < block_size; ++j) {\n                    if ((br + i) < rows && (bc + j) < cols) {\n                        dst[(bc + j) * rows + (br + i)] = src[(br + i) * cols + (bc + j)];\n                    }\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6", "completion": "```c\nvoid blocked_matrix_transpose(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t br = 0; br < rows; br += block_size) {\n        for (size_t bc = 0; bc < cols; bc += block_size) {\n            for (size_t i = 0; i < block_size; ++i) {\n                for (size_t j = 0; j < block_size; ++j) {\n                    if ((br + i) < rows && (bc + j) < cols) {\n                        dst[(bc + j) * rows + (br + i)] = src[(br + i) * cols + (bc + j)];\n                    }\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6", "completion": "```c\nvoid blocked_matrix_transpose(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t br = 0; br < rows; br += block_size) {\n        for (size_t bc = 0; bc < cols; bc += block_size) {\n            for (size_t i = 0; i < block_size; ++i) {\n                for (size_t j = 0; j < block_size; ++j) {\n                    if ((br + i < rows) && (bc + j < cols)) {\n                        dst[(bc + j) * rows + (br + i)] = src[(br + i) * cols + (bc + j)];\n                    }\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6", "completion": "```c\nvoid blocked_matrix_transpose(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t br = 0; br < rows; br += block_size) {\n        for (size_t bc = 0; bc < cols; bc += block_size) {\n            for (size_t i = 0; i < block_size; ++i) {\n                for (size_t j = 0; j < block_size; ++j) {\n                    if ((br + i < rows) && (bc + j < cols)) {\n                        dst[(bc + j) * rows + (br + i)] = src[(br + i) * cols + (bc + j)];\n                    }\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6", "completion": "```c\nvoid blocked_matrix_transpose(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t br = 0; br < rows; br += block_size) {\n        for (size_t bc = 0; bc < cols; bc += block_size) {\n            for (size_t i = 0; i < block_size; ++i) {\n                for (size_t j = 0; j < block_size; ++j) {\n                    if ((br + i < rows) && (bc + j < cols)) {\n                        dst[(bc + j) * rows + (br + i)] = src[(br + i) * cols + (bc + j)];\n                    }\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_7", "completion": "```c\nfloat diagonal_sum_3d(const float *array, size_t dim) {\n    float sum = 0.0f;\n    for (size_t i = 0; i < dim; i++) {\n        size_t index = i * dim * dim + i * dim + i;\n        sum += array[index];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7", "completion": "```c\nfloat diagonal_sum_3d(const float *array, size_t dim) {\n    float sum = 0.0f;\n    for (size_t i = 0; i < dim; i++) {\n        size_t index = i * dim * dim + i * dim + i;\n        sum += array[index];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7", "completion": "```c\nfloat diagonal_sum_3d(const float *array, size_t dim) {\n    float sum = 0.0f;\n    for (size_t i = 0; i < dim; i++) {\n        size_t index = i * dim * dim + i * dim + i;\n        sum += array[index];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7", "completion": "```c\nfloat diagonal_sum_3d(const float *array, size_t dim) {\n    float sum = 0.0f;\n    for (size_t i = 0; i < dim; i++) {\n        size_t index = i * dim * dim + i * dim + i;\n        sum += array[index];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7", "completion": "```c\nfloat diagonal_sum_3d(const float *array, size_t dim) {\n    float sum = 0.0f;\n    for (size_t i = 0; i < dim; i++) {\n        size_t index = i * dim * dim + i * dim + i;\n        sum += array[index];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_8", "completion": "```c\nvoid conditional_scale(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j++) {\n            size_t index = i * cols + j;\n            dst[index] = (src[index] > threshold) ? src[index] * scale : src[index];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8", "completion": "```c\nvoid conditional_scale(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j++) {\n            size_t index = i * cols + j;\n            dst[index] = (src[index] > threshold) ? src[index] * scale : src[index];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8", "completion": "```c\nvoid conditional_scale(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j++) {\n            size_t index = i * cols + j;\n            dst[index] = (src[index] > threshold) ? src[index] * scale : src[index];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8", "completion": "```c\nvoid conditional_scale(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j++) {\n            size_t index = i * cols + j;\n            dst[index] = (src[index] > threshold) ? src[index] * scale : src[index];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8", "completion": "```c\nvoid conditional_scale(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j++) {\n            size_t index = i * cols + j;\n            dst[index] = (src[index] > threshold) ? src[index] * scale : src[index];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9", "completion": "```c\nvoid reorder_matrix_rows(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; ++i) {\n        size_t src_row = indices[i];\n        for (size_t j = 0; j < cols; ++j) {\n            dst[i * cols + j] = src[src_row * cols + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9", "completion": "```c\nvoid reorder_matrix_rows(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t src_row = indices[i];\n        for (size_t j = 0; j < cols; j++) {\n            dst[i * cols + j] = src[src_row * cols + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9", "completion": "```c\nvoid reorder_matrix_rows(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t src_row = indices[i];\n        for (size_t j = 0; j < cols; j++) {\n            dst[i * cols + j] = src[src_row * cols + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9", "completion": "```c\nvoid reorder_matrix_rows(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; ++i) {\n        size_t src_row = indices[i];\n        for (size_t j = 0; j < cols; ++j) {\n            dst[i * cols + j] = src[src_row * cols + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9", "completion": "```c\nvoid reorder_matrix_rows(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; ++i) {\n        size_t src_row = indices[i];\n        for (size_t j = 0; j < cols; ++j) {\n            dst[i * cols + j] = src[src_row * cols + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_10", "completion": "```c\nvoid vector_vector_add(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = ((src1[i] + src2[i]) + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10", "completion": "```c\nvoid vector_vector_add(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = ((src1[i] + src2[i]) + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10", "completion": "```c\nvoid vector_vector_add(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = ((src1[i] + src2[i]) + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10", "completion": "```c\nvoid vector_vector_add(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = ((src1[i] + src2[i]) + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10", "completion": "```c\nvoid vector_vector_add(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = ((src1[i] + src2[i]) + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_11", "completion": "```c\nint vector_even_min(const int *src, size_t length){\n    if(length == 0) return -1;\n    \n    int min = INT32_MAX;\n    for(size_t i = 0; i < length; i += 2){\n        if(src[i] % 2 == 0 && src[i] < min){\n            min = src[i];\n        }\n    }\n    return min == INT32_MAX ? -1 : min;\n}\n```"}
{"task_id": "SimdBench_11", "completion": "```c\nint vector_even_min(const int *src, size_t length){\n    if(length == 0) return -1;\n    \n    int min = INT32_MAX;\n    for(size_t i = 0; i < length; i += 2){\n        if(src[i] < min){\n            min = src[i];\n        }\n    }\n    return min != INT32_MAX ? min : -1;\n}\n```"}
{"task_id": "SimdBench_11", "completion": "```c\nint vector_even_min(const int *src, size_t length){\n    if(length == 0) return -1;\n    \n    int min = INT32_MAX;\n    for(size_t i = 0; i < length; i += 2){\n        if(src[i] % 2 == 0 && src[i] < min){\n            min = src[i];\n        }\n    }\n    \n    return min == INT32_MAX ? -1 : min;\n}\n```"}
{"task_id": "SimdBench_11", "completion": "```c\nint vector_even_min(const int *src, size_t length){\n    if(length == 0) return -1;\n    \n    int min = INT32_MAX;\n    for(size_t i = 0; i < length; i += 2){\n        if(src[i] < min){\n            min = src[i];\n        }\n    }\n    return min != INT32_MAX ? min : -1;\n}\n```"}
{"task_id": "SimdBench_11", "completion": "```c\nint vector_even_min(const int *src, size_t length){\n    if(length == 0) return -1;\n    \n    int min = INT32_MAX;\n    for(size_t i = 0; i < length; i += 2){\n        if(src[i] % 2 == 0 && src[i] < min){\n            min = src[i];\n        }\n    }\n    return min != INT32_MAX ? min : -1;\n}\n```"}
{"task_id": "SimdBench_12", "completion": "```c\nvoid mixed_right_shift(const int *src, int *dst, uint8_t shift, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int arithmetic_shift = src[i] >> shift;\n        int logical_shift = ((unsigned int)src[i]) >> shift;\n        dst[i] = arithmetic_shift + logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12", "completion": "```c\nvoid mixed_right_shift(const int *src, int *dst, uint8_t shift, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int arithmetic_shift = src[i] >> shift;\n        int logical_shift = ((unsigned int)src[i]) >> shift;\n        dst[i] = arithmetic_shift + logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12", "completion": "```c\nvoid mixed_right_shift(const int *src, int *dst, uint8_t shift, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        int arithmetic_shift = src[i] >> shift;\n        int logical_shift = ((unsigned int)src[i]) >> shift;\n        dst[i] = arithmetic_shift + logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12", "completion": "```c\nvoid mixed_right_shift(const int *src, int *dst, uint8_t shift, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        // Arithmetic right shift\n        int arith_shift = src[i] >> shift;\n\n        // Logical right shift\n        unsigned int temp = src[i];\n        int log_shift = (int)(temp >> shift);\n\n        // Add the results and store in the destination array\n        dst[i] = arith_shift + log_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12", "completion": "```c\nvoid mixed_right_shift(const int *src, int *dst, uint8_t shift, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        // Arithmetic right shift\n        int arith_shift = src[i] >> shift;\n\n        // Logical right shift\n        unsigned int temp = src[i];\n        int logic_shift = (int)(temp >> shift);\n\n        // Add the results and store in the destination array\n        dst[i] = arith_shift + logic_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_13", "completion": "```c\n#include <stdint.h>\n\nint64_t matrix_sum(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < rows * cols; ++i) {\n        sum += matrix[i];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13", "completion": "```c\n#include <stdint.h>\n\nint64_t matrix_sum(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < rows * cols; ++i) {\n        sum += matrix[i];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13", "completion": "```cpp\n#include <cstdint>\n#include <cstddef>\n\nint64_t matrix_sum(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < rows * cols; ++i) {\n        sum += static_cast<int64_t>(matrix[i]);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13", "completion": "```cpp\n#include <cstdint>\n#include <cstddef>\n\nint64_t matrix_sum(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < rows * cols; ++i) {\n        sum += static_cast<int64_t>(matrix[i]);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13", "completion": "```cpp\n#include <cstdint>\n#include <cstddef>\n\nint64_t matrix_sum(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < rows * cols; ++i) {\n        sum += static_cast<int64_t>(matrix[i]);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_14", "completion": "```c\nsize_t argmax(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n    for (size_t i = 1; i < length; i++) {\n        if (src[i] > max_value) {\n            max_value = src[i];\n            max_index = i;\n        }\n    }\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14", "completion": "```c\nsize_t argmax(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n    for (size_t i = 1; i < length; i++) {\n        if (src[i] > max_value) {\n            max_value = src[i];\n            max_index = i;\n        }\n    }\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14", "completion": "```c\nsize_t argmax(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n    for (size_t i = 1; i < length; i++) {\n        if (src[i] > max_value) {\n            max_value = src[i];\n            max_index = i;\n        }\n    }\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14", "completion": "```c\nsize_t argmax(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n    for (size_t i = 1; i < length; i++) {\n        if (src[i] > max_value) {\n            max_value = src[i];\n            max_index = i;\n        }\n    }\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14", "completion": "```c\nsize_t argmax(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n    for (size_t i = 1; i < length; i++) {\n        if (src[i] > max_value) {\n            max_value = src[i];\n            max_index = i;\n        }\n    }\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_15", "completion": "```c\nvoid vector_blend(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (i & mask) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15", "completion": "```c\nvoid vector_blend(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if ((i & mask) != 0) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15", "completion": "```c\nvoid vector_blend(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if ((i & mask) != 0) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15", "completion": "```c\nvoid vector_blend(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if ((i & mask) != 0) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15", "completion": "```c\nvoid vector_blend(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if ((i & mask) != 0) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_16", "completion": "```c\nvoid population_count(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t value = src[i];\n        uint32_t count = 0;\n        while (value) {\n            count += value & 1;\n            value >>= 1;\n        }\n        dst[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_16", "completion": "```c\nvoid population_count(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t value = src[i];\n        uint32_t count = 0;\n        while (value) {\n            count += value & 1;\n            value >>= 1;\n        }\n        dst[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_16", "completion": "```c\nvoid population_count(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t value = src[i];\n        uint32_t count = 0;\n        while (value) {\n            count += value & 1;\n            value >>= 1;\n        }\n        dst[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_16", "completion": "```c\nvoid population_count(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t value = src[i];\n        uint32_t count = 0;\n        while (value) {\n            count += value & 1;\n            value >>= 1;\n        }\n        dst[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_16", "completion": "```c\nvoid population_count(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t value = src[i];\n        uint32_t count = 0;\n        while (value) {\n            count += value & 1;\n            value >>= 1;\n        }\n        dst[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_17", "completion": "```c\nvoid saturating_add(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t sum = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = (sum > UINT16_MAX) ? UINT16_MAX : (uint16_t)sum;\n    }\n}\n```"}
{"task_id": "SimdBench_17", "completion": "```c\nvoid saturating_add(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t sum = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = (sum > UINT16_MAX) ? UINT16_MAX : (uint16_t)sum;\n    }\n}\n```"}
{"task_id": "SimdBench_17", "completion": "```c\nvoid saturating_add(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t sum = (uint32_t)src1[i] + (uint32_t)src2[i];\n        if (sum > UINT16_MAX) {\n            dst[i] = UINT16_MAX;\n        } else {\n            dst[i] = (uint16_t)sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_17", "completion": "```c\nvoid saturating_add(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t sum = (uint32_t)src1[i] + (uint32_t)src2[i];\n        if (sum > UINT16_MAX) {\n            dst[i] = UINT16_MAX;\n        } else {\n            dst[i] = (uint16_t)sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_17", "completion": "```c\nvoid saturating_add(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t sum = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = (sum > UINT16_MAX) ? UINT16_MAX : (uint16_t)sum;\n    }\n}\n```"}
{"task_id": "SimdBench_18", "completion": "```c\nvoid range_matrix_mul(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                double a_ik = A[i * n + k];\n                double b_kj = B[k * p + j];\n                if (-100 <= a_ik && a_ik <= 100 && -100 <= b_kj && b_kj <= 100) {\n                    sum += a_ik * b_kj;\n                }\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18", "completion": "```c\nvoid range_matrix_mul(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                double a_ik = A[i * n + k];\n                double b_kj = B[k * p + j];\n                if (-100 <= a_ik && a_ik <= 100 && -100 <= b_kj && b_kj <= 100) {\n                    sum += a_ik * b_kj;\n                }\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18", "completion": "```c\nvoid range_matrix_mul(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                double a_ik = A[i * n + k];\n                double b_kj = B[k * p + j];\n                if (-100 <= a_ik && a_ik <= 100 && -100 <= b_kj && b_kj <= 100) {\n                    sum += a_ik * b_kj;\n                }\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18", "completion": "```c\nvoid range_matrix_mul(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                double a_ik = A[i * n + k];\n                double b_kj = B[k * p + j];\n                if (-100 <= a_ik && a_ik <= 100 && -100 <= b_kj && b_kj <= 100) {\n                    sum += a_ik * b_kj;\n                }\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18", "completion": "```c\nvoid range_matrix_mul(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                double a_ik = A[i * n + k];\n                double b_kj = B[k * p + j];\n                if (-100 <= a_ik && a_ik <= 100 && -100 <= b_kj && b_kj <= 100) {\n                    sum += a_ik * b_kj;\n                }\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19", "completion": "```cpp\nvoid tensor_add_3d(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            for (size_t k = 0; k < dim3; ++k) {\n                size_t index = i * dim2 * dim3 + j * dim3 + k;\n                C[index] = A[index] + B[index];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19", "completion": "```cpp\nvoid tensor_add_3d(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            for (size_t k = 0; k < dim3; ++k) {\n                size_t index = i * dim2 * dim3 + j * dim3 + k;\n                C[index] = A[index] + B[index];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19", "completion": "```cpp\nvoid tensor_add_3d(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            for (size_t k = 0; k < dim3; ++k) {\n                size_t index = i * dim2 * dim3 + j * dim3 + k;\n                C[index] = A[index] + B[index];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19", "completion": "```cpp\nvoid tensor_add_3d(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            for (size_t k = 0; k < dim3; ++k) {\n                size_t index = i * dim2 * dim3 + j * dim3 + k;\n                C[index] = A[index] + B[index];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19", "completion": "```c\nvoid tensor_add_3d(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            for (size_t k = 0; k < dim3; ++k) {\n                size_t index = i * dim2 * dim3 + j * dim3 + k;\n                C[index] = A[index] + B[index];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_20", "completion": "```c\nvoid vector_add_round_nearest(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = nearbyintf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20", "completion": "```c\nvoid vector_add_round_nearest(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = nearbyintf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20", "completion": "```c\nvoid vector_add_round_nearest(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = nearbyintf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20", "completion": "```c\nvoid vector_add_round_nearest(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = nearbyintf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20", "completion": "```c\nvoid vector_add_round_nearest(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = nearbyintf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_21", "completion": "```c\nvoid vector_mul_round_up(const float* src1, const float* src2, float* dst, size_t length){\n    for(size_t i = 0; i < length; i += 2){\n        if(i < length && fabsf(src1[i] - src2[i]) <= 50.0f){\n            dst[i] = ceilf(src1[i] * src2[i]);\n        }\n        else{\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21", "completion": "```c\nvoid vector_mul_round_up(const float* src1, const float* src2, float* dst, size_t length){\n    for(size_t i = 0; i < length; i += 2){\n        if(i + 1 < length && fabsf(src1[i] - src2[i]) <= 50.0f){\n            float result = src1[i] * src2[i];\n            dst[i] = (result > 0) ? ceilf(result) : floorf(result);\n        }\n        else{\n            dst[i] = -1.0f;\n        }\n\n        if(i + 1 < length && fabsf(src1[i+1] - src2[i+1]) <= 50.0f){\n            float result = src1[i+1] * src2[i+1];\n            dst[i+1] = (result > 0) ? ceilf(result) : floorf(result);\n        }\n        else{\n            dst[i+1] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21", "completion": "```c\nvoid vector_mul_round_up(const float* src1, const float* src2, float* dst, size_t length){\n    for(size_t i = 0; i < length; i += 2){\n        if(i + 1 < length && fabsf(src1[i] - src2[i]) <= 50.0f){\n            float result = src1[i] * src2[i];\n            dst[i] = (result > 0.0f) ? ceilf(result) : floorf(result);\n        }\n        else{\n            dst[i] = -1.0f;\n        }\n        if(i + 1 < length && fabsf(src1[i+1] - src2[i+1]) <= 50.0f){\n            float result = src1[i+1] * src2[i+1];\n            dst[i+1] = (result > 0.0f) ? ceilf(result) : floorf(result);\n        }\n        else{\n            dst[i+1] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21", "completion": "```c\nvoid vector_mul_round_up(const float* src1, const float* src2, float* dst, size_t length){\n    for(size_t i = 0; i < length; i += 2){\n        if(i + 1 < length && fabsf(src1[i] - src2[i]) <= 50.0f){\n            float result = src1[i] * src2[i];\n            dst[i] = (result > 0) ? (float)((int)(result + 1)) : (float)((int)(result));\n        }\n        else{\n            dst[i] = -1.0f;\n        }\n        if(i + 1 < length && fabsf(src1[i+1] - src2[i+1]) <= 50.0f){\n            float result = src1[i+1] * src2[i+1];\n            dst[i+1] = (result > 0) ? (float)((int)(result + 1)) : (float)((int)(result));\n        }\n        else{\n            dst[i+1] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21", "completion": "```c\nvoid vector_mul_round_up(const float* src1, const float* src2, float* dst, size_t length){\n    for(size_t i = 0; i < length; i += 2){\n        if(i + 1 < length && fabsf(src1[i] - src2[i]) <= 50.0f){\n            float result = src1[i] * src2[i];\n            dst[i] = (result > 0) ? ceilf(result) : floorf(result);\n        }\n        else{\n            dst[i] = -1.0f;\n        }\n\n        if(i + 1 < length && fabsf(src1[i+1] - src2[i+1]) <= 50.0f){\n            float result = src1[i+1] * src2[i+1];\n            dst[i+1] = (result > 0) ? ceilf(result) : floorf(result);\n        }\n        else{\n            dst[i+1] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_22", "completion": "```c\nvoid matrix_scalar_mul(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m * n; i++) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22", "completion": "```c\nvoid matrix_scalar_mul(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m * n; i++) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22", "completion": "```c\nvoid matrix_scalar_mul(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m * n; i++) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22", "completion": "```c\nvoid matrix_scalar_mul(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m * n; i++) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22", "completion": "```c\nvoid matrix_scalar_mul(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m * n; i++) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_23", "completion": "```c\nvoid matrix_normalize_rows(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float norm = 0.0f;\n        for (size_t j = 0; j < n; j++) {\n            size_t idx = i * n + j;\n            norm += mat[idx] * mat[idx];\n        }\n        norm = sqrt(norm);\n        if (norm > 0.0f) {\n            for (size_t j = 0; j < n; j++) {\n                size_t idx = i * n + j;\n                mat[idx] /= norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23", "completion": "```c\nvoid matrix_normalize_rows(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float norm = 0.0f;\n        for (size_t j = 0; j < n; j++) {\n            size_t idx = i * n + j;\n            norm += mat[idx] * mat[idx];\n        }\n        norm = sqrt(norm);\n        if (norm > 0.0f) {\n            for (size_t j = 0; j < n; j++) {\n                size_t idx = i * n + j;\n                mat[idx] /= norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23", "completion": "```c\nvoid matrix_normalize_rows(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float norm = 0.0f;\n        for (size_t j = 0; j < n; j++) {\n            size_t idx = i * n + j;\n            norm += mat[idx] * mat[idx];\n        }\n        norm = sqrt(norm);\n        if (norm > 0.0f) {\n            for (size_t j = 0; j < n; j++) {\n                size_t idx = i * n + j;\n                mat[idx] /= norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23", "completion": "```c\nvoid matrix_normalize_rows(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float norm = 0.0f;\n        for (size_t j = 0; j < n; j++) {\n            size_t idx = i * n + j;\n            norm += mat[idx] * mat[idx];\n        }\n        norm = sqrt(norm);\n        if (norm > 0.0f) {\n            for (size_t j = 0; j < n; j++) {\n                size_t idx = i * n + j;\n                mat[idx] /= norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23", "completion": "```c\nvoid matrix_normalize_rows(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float norm = 0.0f;\n        for (size_t j = 0; j < n; j++) {\n            size_t idx = i * n + j;\n            norm += mat[idx] * mat[idx];\n        }\n        norm = sqrt(norm);\n        if (norm > 0.0f) {\n            for (size_t j = 0; j < n; j++) {\n                size_t idx = i * n + j;\n                mat[idx] /= norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24", "completion": "```c\nvoid matrix_mul_round_int(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24", "completion": "```c\nvoid matrix_mul_round_int(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24", "completion": "```c\nvoid matrix_mul_round_int(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24", "completion": "```c\nvoid matrix_mul_round_int(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24", "completion": "```c\nvoid matrix_mul_round_int(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25", "completion": "```c\nvoid matrix_transpose_round_quarter(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            float value = src[i * cols + j];\n            int rounded = roundf(value * 4.0f) / 4.0f;\n            dst[j * rows + i] = rounded;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25", "completion": "```c\nvoid matrix_transpose_round_quarter(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            float value = src[i * cols + j];\n            int rounded = roundf(value * 4.0f) / 4.0f;\n            dst[j * rows + i] = rounded;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25", "completion": "```c\nvoid matrix_transpose_round_quarter(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            float value = src[i * cols + j];\n            int rounded = (int)(value * 4 + 0.5f);\n            dst[j * rows + i] = rounded / 4.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25", "completion": "```c\nvoid matrix_transpose_round_quarter(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            float value = src[i * cols + j];\n            int rounded = roundf(value * 4.0f) / 4.0f;\n            dst[j * rows + i] = rounded;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25", "completion": "```c\nvoid matrix_transpose_round_quarter(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            float value = src[i * cols + j];\n            int rounded = roundf(value * 4.0f) / 4.0f;\n            dst[j * rows + i] = rounded;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26", "completion": "```c\nvoid tensor3d_sub_round_zero(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1 * dim2 * dim3; ++i) {\n        dst[i] = (float)(int)(tensor1[i] - tensor2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_26", "completion": "```c\nvoid tensor3d_sub_round_zero(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1 * dim2 * dim3; ++i) {\n        dst[i] = (float)(int)(tensor1[i] - tensor2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_26", "completion": "```c\nvoid tensor3d_sub_round_zero(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1 * dim2 * dim3; ++i) {\n        dst[i] = (float)(int)(tensor1[i] - tensor2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_26", "completion": "```c\nvoid tensor3d_sub_round_zero(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1 * dim2 * dim3; ++i) {\n        dst[i] = (float)(int)(tensor1[i] - tensor2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_26", "completion": "```c\nvoid tensor3d_sub_round_zero(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1 * dim2 * dim3; ++i) {\n        dst[i] = (float)(int)(tensor1[i] - tensor2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_27", "completion": "```c\nvoid matrix_hadamard_product(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < n; j++) {\n            size_t index = i * n + j;\n            dst[index] = mat1[index] * mat2[index];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_27", "completion": "```c\nvoid matrix_hadamard_product(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < n; j++) {\n            size_t index = i * n + j;\n            dst[index] = mat1[index] * mat2[index];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_27", "completion": "```c\nvoid matrix_hadamard_product(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < n; j++) {\n            dst[i * n + j] = mat1[i * n + j] * mat2[i * n + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_27", "completion": "```c\nvoid matrix_hadamard_product(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < n; j++) {\n            size_t index = i * n + j;\n            dst[index] = mat1[index] * mat2[index];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_27", "completion": "```c\nvoid matrix_hadamard_product(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < n; j++) {\n            dst[i * n + j] = mat1[i * n + j] * mat2[i * n + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_28", "completion": "```c\nvoid matrix_vector_mul(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        dst[i] = 0.0f;\n        for (size_t j = 0; j < n; j++) {\n            dst[i] += mat[i * n + j] * vec[j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_28", "completion": "```c\nvoid matrix_vector_mul(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        dst[i] = 0.0f;\n        for (size_t j = 0; j < n; j++) {\n            dst[i] += mat[i * n + j] * vec[j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_28", "completion": "```c\nvoid matrix_vector_mul(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        dst[i] = 0.0f;\n        for (size_t j = 0; j < n; j++) {\n            dst[i] += mat[i * n + j] * vec[j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_28", "completion": "```c\nvoid matrix_vector_mul(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        dst[i] = 0.0f;\n        for (size_t j = 0; j < n; j++) {\n            dst[i] += mat[i * n + j] * vec[j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_28", "completion": "```c\nvoid matrix_vector_mul(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float sum = 0.0f;\n        for (size_t j = 0; j < n; j++) {\n            sum += mat[i * n + j] * vec[j];\n        }\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_29", "completion": "```c\ndouble matrix_average(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    size_t total_elements = m * n;\n    for (size_t i = 0; i < total_elements; i++) {\n        sum += mat[i];\n    }\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29", "completion": "```c\ndouble matrix_average(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    size_t total_elements = m * n;\n    for (size_t i = 0; i < total_elements; i++) {\n        sum += mat[i];\n    }\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29", "completion": "```c\ndouble matrix_average(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    size_t total_elements = m * n;\n    for (size_t i = 0; i < total_elements; i++) {\n        sum += mat[i];\n    }\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29", "completion": "```c\ndouble matrix_average(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    size_t total_elements = m * n;\n    for (size_t i = 0; i < total_elements; i++) {\n        sum += mat[i];\n    }\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29", "completion": "```c\ndouble matrix_average(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    size_t total_elements = m * n;\n    for (size_t i = 0; i < total_elements; ++i) {\n        sum += mat[i];\n    }\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_30", "completion": "```c\nbool matrix_rows_sorted_verify(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        if (directions[i]) {\n            // Ascending order\n            for (size_t j = 1; j < cols; j++) {\n                if (matrix[i * cols + j] < matrix[i * cols + j - 1]) {\n                    return false;\n                }\n            }\n        } else {\n            // Descending order\n            for (size_t j = 1; j < cols; j++) {\n                if (matrix[i * cols + j] > matrix[i * cols + j - 1]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30", "completion": "```c\nbool matrix_rows_sorted_verify(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        if (directions[i]) {\n            // Ascending order\n            for (size_t j = 1; j < cols; j++) {\n                if (matrix[i * cols + j] < matrix[i * cols + j - 1]) {\n                    return false;\n                }\n            }\n        } else {\n            // Descending order\n            for (size_t j = 1; j < cols; j++) {\n                if (matrix[i * cols + j] > matrix[i * cols + j - 1]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30", "completion": "```c\nbool matrix_rows_sorted_verify(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        if (directions[i]) {\n            // Ascending order\n            for (size_t j = 1; j < cols; j++) {\n                if (matrix[i * cols + j] < matrix[i * cols + j - 1]) {\n                    return false;\n                }\n            }\n        } else {\n            // Descending order\n            for (size_t j = 1; j < cols; j++) {\n                if (matrix[i * cols + j] > matrix[i * cols + j - 1]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30", "completion": "```c\nbool matrix_rows_sorted_verify(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        if (directions[i]) {\n            // Ascending order\n            for (size_t j = 1; j < cols; j++) {\n                if (matrix[i * cols + j] < matrix[i * cols + j - 1]) {\n                    return false;\n                }\n            }\n        } else {\n            // Descending order\n            for (size_t j = 1; j < cols; j++) {\n                if (matrix[i * cols + j] > matrix[i * cols + j - 1]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30", "completion": "```c\nbool matrix_rows_sorted_verify(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        if (directions[i]) {\n            // Ascending order\n            for (size_t j = 1; j < cols; j++) {\n                if (matrix[i * cols + j] < matrix[i * cols + j - 1]) {\n                    return false;\n                }\n            }\n        } else {\n            // Descending order\n            for (size_t j = 1; j < cols; j++) {\n                if (matrix[i * cols + j] > matrix[i * cols + j - 1]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_31", "completion": "```c\nvoid nearest_multiple(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int16_t value = src[i];\n        if (value >= 0) {\n            dst[i] = (value / base) * base;\n        } else {\n            dst[i] = ((value - base + 1) / base) * base;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_31", "completion": "```c\nvoid nearest_multiple(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int16_t value = src[i];\n        if (value >= 0) {\n            dst[i] = (value / base) * base;\n        } else {\n            dst[i] = ((value - base + 1) / base) * base;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_31", "completion": "```c\nvoid nearest_multiple(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int16_t value = src[i];\n        if (value >= 0) {\n            dst[i] = (value / base) * base;\n        } else {\n            dst[i] = ((value - base + 1) / base) * base;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_31", "completion": "```c\nvoid nearest_multiple(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int16_t value = src[i];\n        if (value >= 0) {\n            dst[i] = (value / base) * base;\n        } else {\n            dst[i] = ((value - base + 1) / base) * base;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_31", "completion": "```c\nvoid nearest_multiple(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int16_t value = src[i];\n        if (value >= 0) {\n            dst[i] = (value / base) * base;\n        } else {\n            dst[i] = ((value - base + 1) / base) * base;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_32", "completion": "```c\nbool matrix_has_row(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool match = true;\n        for (size_t j = 0; j < cols; ++j) {\n            if (matrix[i * cols + j] != vector[j]) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32", "completion": "```cpp\nbool matrix_has_row(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool match = true;\n        for (size_t j = 0; j < cols; ++j) {\n            if (matrix[i * cols + j] != vector[j]) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32", "completion": "```c\nbool matrix_has_row(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool match = true;\n        for (size_t j = 0; j < cols; ++j) {\n            if (fabs(matrix[i * cols + j] - vector[j]) > 1e-9) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32", "completion": "```cpp\nbool matrix_has_row(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool match = true;\n        for (size_t j = 0; j < cols; ++j) {\n            if (matrix[i * cols + j] != vector[j]) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32", "completion": "```c\nbool matrix_has_row(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool match = true;\n        for (size_t j = 0; j < cols; ++j) {\n            if (fabs(matrix[i * cols + j] - vector[j]) > 1e-9) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_33", "completion": "```c\nsize_t tensor_4d_equal_count(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t count = 0;\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    for (size_t i = 0; i < total_elements; i++) {\n        if (A[i] == B[i]) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_33", "completion": "```c\nsize_t tensor_4d_equal_count(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t count = 0;\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    for (size_t i = 0; i < total_elements; i++) {\n        if (A[i] == B[i]) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_33", "completion": "```c\nsize_t tensor_4d_equal_count(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t count = 0;\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    for (size_t i = 0; i < total_elements; i++) {\n        if (A[i] == B[i]) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_33", "completion": "```c\nsize_t tensor_4d_equal_count(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t count = 0;\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    for (size_t i = 0; i < total_elements; i++) {\n        if (A[i] == B[i]) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_33", "completion": "```c\nsize_t tensor_4d_equal_count(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t count = 0;\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    for (size_t i = 0; i < total_elements; i++) {\n        if (A[i] == B[i]) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_34", "completion": "```c\nvoid axm_abs(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; ++i) {\n        int64_t result = a * x[i];\n        y[i] = (result >= 0) ? result : -result;\n    }\n}\n```"}
{"task_id": "SimdBench_34", "completion": "```c\nvoid axm_abs(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; i++) {\n        int64_t result = a * x[i];\n        y[i] = (result >= 0) ? result : -result;\n    }\n}\n```"}
{"task_id": "SimdBench_34", "completion": "```c\nvoid axm_abs(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; i++) {\n        int64_t temp = a * x[i];\n        y[i] = (temp >= 0) ? temp : -temp;\n    }\n}\n```"}
{"task_id": "SimdBench_34", "completion": "```c\nvoid axm_abs(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; ++i) {\n        int64_t result = a * x[i];\n        y[i] = (result >= 0) ? result : -result;\n    }\n}\n```"}
{"task_id": "SimdBench_34", "completion": "```c\nvoid axm_abs(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; i++) {\n        int64_t result = a * x[i];\n        y[i] = (result >= 0) ? result : -result;\n    }\n}\n```"}
{"task_id": "SimdBench_35", "completion": "```c\nMinMaxPair min_max_pair(const int16_t* vec, size_t length) {\n    MinMaxPair result = { .min_num = vec[0], .max_num = vec[0] };\n    for (size_t i = 1; i < length; i++) {\n        if (vec[i] < result.min_num) {\n            result.min_num = vec[i];\n        }\n        if (vec[i] > result.max_num) {\n            result.max_num = vec[i];\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_35", "completion": "```c\nMinMaxPair min_max_pair(const int16_t* vec, size_t length) {\n    MinMaxPair result = { .min_num = vec[0], .max_num = vec[0] };\n    for (size_t i = 1; i < length; i++) {\n        if (vec[i] < result.min_num) {\n            result.min_num = vec[i];\n        }\n        if (vec[i] > result.max_num) {\n            result.max_num = vec[i];\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_35", "completion": "```c\nMinMaxPair min_max_pair(const int16_t* vec, size_t length) {\n    MinMaxPair result = { .min_num = vec[0], .max_num = vec[0] };\n    for (size_t i = 1; i < length; i++) {\n        if (vec[i] < result.min_num) {\n            result.min_num = vec[i];\n        }\n        if (vec[i] > result.max_num) {\n            result.max_num = vec[i];\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_35", "completion": "```c\nMinMaxPair min_max_pair(const int16_t* vec, size_t length) {\n    MinMaxPair result = { .min_num = vec[0], .max_num = vec[0] };\n    for (size_t i = 1; i < length; i++) {\n        if (vec[i] < result.min_num) {\n            result.min_num = vec[i];\n        }\n        if (vec[i] > result.max_num) {\n            result.max_num = vec[i];\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_35", "completion": "```c\nMinMaxPair min_max_pair(const int16_t* vec, size_t length) {\n    MinMaxPair result = { .min_num = vec[0], .max_num = vec[0] };\n    for (size_t i = 1; i < length; i++) {\n        if (vec[i] < result.min_num) {\n            result.min_num = vec[i];\n        }\n        if (vec[i] > result.max_num) {\n            result.max_num = vec[i];\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_36", "completion": "```c\nbool matrix_rows_strictly_increasing(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n    for (size_t i = 1; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            if (matrix[i * cols + j] <= matrix[(i - 1) * cols + j]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_36", "completion": "```c\nbool matrix_rows_strictly_increasing(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n    \n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 1; j < cols; j++) {\n            if (matrix[i * cols + j] <= matrix[i * cols + j - 1]) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_36", "completion": "```c\nbool matrix_rows_strictly_increasing(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n    \n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 1; j < cols; j++) {\n            if (matrix[i * cols + j] <= matrix[i * cols + j - 1]) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_36", "completion": "```c\nbool matrix_rows_strictly_increasing(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n    \n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 1; j < cols; j++) {\n            if (matrix[i * cols + j] <= matrix[i * cols + j - 1]) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_36", "completion": "```c\nbool matrix_rows_strictly_increasing(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n    for (size_t i = 1; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            if (matrix[i * cols + j] <= matrix[(i - 1) * cols + j]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37", "completion": "```cpp\nbool matrix_blocks_equal(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n    size_t num_rows = rows / block_size;\n    size_t num_cols = cols / block_size;\n    for (size_t i = 1; i < num_rows; ++i) {\n        for (size_t j = 1; j < num_cols; ++j) {\n            size_t base_index = i * block_size * cols + j * block_size;\n            size_t ref_index = 0;\n            for (size_t k = 0; k < block_size; ++k) {\n                for (size_t l = 0; l < block_size; ++l) {\n                    if (matrix[ref_index + k * cols + l] != matrix[base_index + k * cols + l]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37", "completion": "```cpp\nbool matrix_blocks_equal(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n    \n    size_t num_rows = rows / block_size;\n    size_t num_cols = cols / block_size;\n    \n    for (size_t i = 1; i < num_rows; ++i) {\n        for (size_t j = 1; j < num_cols; ++j) {\n            size_t offset1 = i * block_size * cols + j * block_size;\n            size_t offset2 = 0;\n            \n            for (size_t k = 0; k < block_size; ++k) {\n                for (size_t l = 0; l < block_size; ++l) {\n                    if (matrix[offset1 + k * cols + l] != matrix[offset2 + k * cols + l]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_37", "completion": "```cpp\nbool matrix_blocks_equal(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n    size_t num_rows = rows / block_size;\n    size_t num_cols = cols / block_size;\n    for (size_t i = 1; i < num_rows; ++i) {\n        for (size_t j = 1; j < num_cols; ++j) {\n            size_t base_index = i * block_size * cols + j * block_size;\n            size_t ref_index = 0;\n            for (size_t k = 0; k < block_size; ++k) {\n                for (size_t l = 0; l < block_size; ++l) {\n                    if (matrix[ref_index + k * cols + l] != matrix[base_index + k * cols + l]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37", "completion": "```cpp\nbool matrix_blocks_equal(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n    \n    size_t num_rows = rows / block_size;\n    size_t num_cols = cols / block_size;\n    \n    for (size_t i = 1; i < num_rows; ++i) {\n        for (size_t j = 1; j < num_cols; ++j) {\n            size_t offset1 = i * block_size * cols + j * block_size;\n            size_t offset2 = 0;\n            \n            for (size_t k = 0; k < block_size; ++k) {\n                for (size_t l = 0; l < block_size; ++l) {\n                    if (matrix[offset1 + k * cols + l] != matrix[offset2 + k * cols + l]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_37", "completion": "```cpp\nbool matrix_blocks_equal(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n    \n    size_t num_rows = rows / block_size;\n    size_t num_cols = cols / block_size;\n    \n    for (size_t i = 1; i < num_rows; ++i) {\n        for (size_t j = 1; j < num_cols; ++j) {\n            size_t base_index = i * block_size * cols + j * block_size;\n            size_t ref_index = 0;\n            \n            for (size_t k = 0; k < block_size; ++k) {\n                for (size_t l = 0; l < block_size; ++l) {\n                    if (matrix[ref_index + k * cols + l] != matrix[base_index + k * cols + l]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_38", "completion": "```cpp\nbool vector_block_equal(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (!vec || block_size == 0 || length < block_size) {\n        return false;\n    }\n    size_t num_blocks = length / block_size;\n    if (num_blocks == 0) {\n        return true; // No complete blocks, trivially true\n    }\n    for (size_t i = 1; i < num_blocks; ++i) {\n        for (size_t j = 0; j < block_size; ++j) {\n            if (fabs(vec[i * block_size + j] - vec[j]) > tolerance) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_38", "completion": "```cpp\nbool vector_block_equal(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (!vec || block_size == 0 || length < block_size) {\n        return false;\n    }\n    size_t num_blocks = length / block_size;\n    if (num_blocks == 0) {\n        return true; // No complete blocks, trivially true\n    }\n    for (size_t i = 1; i < num_blocks; ++i) {\n        for (size_t j = 0; j < block_size; ++j) {\n            if (fabs(vec[i * block_size + j] - vec[j]) > tolerance) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_38", "completion": "```cpp\nbool vector_block_equal(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (!vec || block_size == 0 || length < block_size) {\n        return false;\n    }\n    size_t num_blocks = length / block_size;\n    if (num_blocks == 0) {\n        return true; // No complete blocks, trivially true\n    }\n    for (size_t i = 1; i < num_blocks; ++i) {\n        for (size_t j = 0; j < block_size; ++j) {\n            if (fabs(vec[i * block_size + j] - vec[j]) > tolerance) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_38", "completion": "```cpp\nbool vector_block_equal(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (!vec || block_size == 0 || length < block_size) return false;\n\n    size_t num_blocks = length / block_size;\n\n    for (size_t i = 1; i < num_blocks; ++i) {\n        for (size_t j = 0; j < block_size; ++j) {\n            if (fabs(vec[i * block_size + j] - vec[j]) > tolerance) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38", "completion": "```cpp\nbool vector_block_equal(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (!vec || block_size == 0 || length < block_size) {\n        return false;\n    }\n    size_t num_blocks = length / block_size;\n    if (num_blocks == 0) {\n        return true; // No complete blocks, trivially true\n    }\n    for (size_t i = 1; i < num_blocks; ++i) {\n        for (size_t j = 0; j < block_size; ++j) {\n            if (fabs(vec[i * block_size + j] - vec[j]) > tolerance) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_39", "completion": "```c\nvoid matrix_row_norm_compare(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        double squared_norm = 0.0;\n        for (size_t j = 0; j < cols; j++) {\n            double value = matrix[i * cols + j];\n            squared_norm += value * value;\n        }\n        double norm = sqrt(squared_norm);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39", "completion": "```c\nvoid matrix_row_norm_compare(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        double squared_norm = 0.0;\n        for (size_t j = 0; j < cols; j++) {\n            size_t idx = i * cols + j;\n            squared_norm += matrix[idx] * matrix[idx];\n        }\n        double norm = sqrt(squared_norm);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39", "completion": "```c\nvoid matrix_row_norm_compare(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        double squared_norm = 0.0;\n        for (size_t j = 0; j < cols; j++) {\n            size_t idx = i * cols + j;\n            squared_norm += matrix[idx] * matrix[idx];\n        }\n        double norm = sqrt(squared_norm);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39", "completion": "```c\nvoid matrix_row_norm_compare(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        double squared_norm = 0.0;\n        for (size_t j = 0; j < cols; j++) {\n            size_t idx = i * cols + j;\n            squared_norm += matrix[idx] * matrix[idx];\n        }\n        double norm = sqrt(squared_norm);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39", "completion": "```c\nvoid matrix_row_norm_compare(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        double squared_norm = 0.0;\n        for (size_t j = 0; j < cols; j++) {\n            size_t idx = i * cols + j;\n            squared_norm += matrix[idx] * matrix[idx];\n        }\n        double norm = sqrt(squared_norm);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_40", "completion": "```cpp\nvoid tensor_bitwise_or(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40", "completion": "```cpp\nvoid tensor_bitwise_or(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40", "completion": "```cpp\nvoid tensor_bitwise_or(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40", "completion": "```cpp\nvoid tensor_bitwise_or(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40", "completion": "```cpp\nvoid tensor_bitwise_or(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_41", "completion": "```cpp\nint64_t squarediff(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_of_squares = 0;\n    int64_t sum_of_products = 0;\n    \n    for (size_t i = 0; i < length; ++i) {\n        int8_t a = A[i];\n        int8_t b = B[i];\n        sum_of_squares += static_cast<int64_t>(a) * a + static_cast<int64_t>(b) * b;\n        sum_of_products += static_cast<int64_t>(a) * b;\n    }\n    \n    return sum_of_squares - sum_of_products;\n}\n```"}
{"task_id": "SimdBench_41", "completion": "```cpp\nint64_t squarediff(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_of_squares = 0;\n    int64_t sum_of_products = 0;\n    \n    for (size_t i = 0; i < length; ++i) {\n        int8_t a = A[i];\n        int8_t b = B[i];\n        sum_of_squares += static_cast<int64_t>(a) * a + static_cast<int64_t>(b) * b;\n        sum_of_products += static_cast<int64_t>(a) * b;\n    }\n    \n    return sum_of_squares - sum_of_products;\n}\n```"}
{"task_id": "SimdBench_41", "completion": "```cpp\nint64_t squarediff(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_of_squares = 0;\n    int64_t sum_of_products = 0;\n    for (size_t i = 0; i < length; ++i) {\n        int8_t a = A[i];\n        int8_t b = B[i];\n        sum_of_squares += static_cast<int64_t>(a) * a + static_cast<int64_t>(b) * b;\n        sum_of_products += static_cast<int64_t>(a) * b;\n    }\n    return sum_of_squares - sum_of_products;\n}\n```"}
{"task_id": "SimdBench_41", "completion": "```cpp\nint64_t squarediff(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_of_squares = 0;\n    int64_t sum_of_products = 0;\n    for (size_t i = 0; i < length; ++i) {\n        int8_t a = A[i];\n        int8_t b = B[i];\n        sum_of_squares += static_cast<int64_t>(a) * a + static_cast<int64_t>(b) * b;\n        sum_of_products += static_cast<int64_t>(a) * b;\n    }\n    return sum_of_squares - sum_of_products;\n}\n```"}
{"task_id": "SimdBench_41", "completion": "```cpp\nint64_t squarediff(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_of_squares = 0;\n    int64_t sum_of_products = 0;\n    \n    for (size_t i = 0; i < length; ++i) {\n        int8_t a = A[i];\n        int8_t b = B[i];\n        sum_of_squares += static_cast<int64_t>(a) * a + static_cast<int64_t>(b) * b;\n        sum_of_products += static_cast<int64_t>(a) * b;\n    }\n    \n    return sum_of_squares - sum_of_products;\n}\n```"}
{"task_id": "SimdBench_42", "completion": "```cpp\nvoid tensor_bit_clear(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] & (~B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_42", "completion": "```c\nvoid tensor_bit_clear(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] & (~B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_42", "completion": "```cpp\nvoid tensor_bit_clear(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] & (~B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_42", "completion": "```cpp\nvoid tensor_bit_clear(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] & (~B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_42", "completion": "```cpp\nvoid tensor_bit_clear(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] & (~B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_43", "completion": "```cpp\nvoid tensor_three_valued_logic(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        int8_t a = A[i];\n        int8_t b = B[i];\n        if (a > 0 && b > 0) {\n            C[i] = 1;\n        } else if (a < 0 && b < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43", "completion": "```cpp\nvoid tensor_three_valued_logic(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        int8_t a = A[i];\n        int8_t b = B[i];\n        if (a > 0 && b > 0) {\n            C[i] = 1;\n        } else if (a < 0 && b < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43", "completion": "```cpp\nvoid tensor_three_valued_logic(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        int8_t a = A[i];\n        int8_t b = B[i];\n        if (a > 0 && b > 0) {\n            C[i] = 1;\n        } else if (a < 0 && b < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43", "completion": "```cpp\nvoid tensor_three_valued_logic(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        int8_t a = A[i];\n        int8_t b = B[i];\n        if (a > 0 && b > 0) {\n            C[i] = 1;\n        } else if (a < 0 && b < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43", "completion": "```cpp\nvoid tensor_three_valued_logic(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        int8_t a = A[i];\n        int8_t b = B[i];\n        if (a > 0 && b > 0) {\n            C[i] = 1;\n        } else if (a < 0 && b < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44", "completion": "```cpp\nvoid tensor_bit_op(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    \n    for (size_t i = 0; i < length; ++i) {\n        if (i == midpoint) {\n            C[i] = A[i];\n        } else if (i < midpoint) {\n            C[i] = A[i] ^ B[i];\n        } else {\n            C[i] = A[i] & B[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44", "completion": "```cpp\nvoid tensor_bit_op(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    \n    for (size_t i = 0; i < length; ++i) {\n        if (i == midpoint) {\n            C[i] = A[i];\n        } else if (i < midpoint) {\n            C[i] = A[i] ^ B[i];\n        } else {\n            C[i] = A[i] & B[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44", "completion": "```cpp\nvoid tensor_bit_op(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    \n    for (size_t i = 0; i < length; ++i) {\n        if (i == midpoint) {\n            C[i] = A[i];\n        } else if (i < midpoint) {\n            C[i] = A[i] ^ B[i];\n        } else {\n            C[i] = A[i] & B[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44", "completion": "```cpp\nvoid tensor_bit_op(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    \n    for (size_t i = 0; i < length; ++i) {\n        if (i == midpoint) {\n            C[i] = A[i];\n        } else if (i < midpoint) {\n            C[i] = A[i] ^ B[i];\n        } else {\n            C[i] = A[i] & B[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44", "completion": "```cpp\nvoid tensor_bit_op(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    \n    for (size_t i = 0; i < length; ++i) {\n        if (i == midpoint) {\n            C[i] = A[i];\n        } else if (i < midpoint) {\n            C[i] = A[i] ^ B[i];\n        } else {\n            C[i] = A[i] & B[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45", "completion": "```cpp\nvoid tensor_multi_select(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            for (size_t k = 0; k < dim3; ++k) {\n                size_t index = i * dim2 * dim3 + j * dim3 + k;\n                if (cond1[index] && cond2[index]) {\n                    out[index] = A[index];\n                } else if (cond1[index] && !cond2[index]) {\n                    out[index] = B[index];\n                } else if (!cond1[index] && cond2[index]) {\n                    out[index] = C[index];\n                } else {\n                    out[index] = D[index];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45", "completion": "```cpp\nvoid tensor_multi_select(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            for (size_t k = 0; k < dim3; ++k) {\n                size_t index = i * dim2 * dim3 + j * dim3 + k;\n                if (cond1[index] && cond2[index]) {\n                    out[index] = A[index];\n                } else if (cond1[index] && !cond2[index]) {\n                    out[index] = B[index];\n                } else if (!cond1[index] && cond2[index]) {\n                    out[index] = C[index];\n                } else {\n                    out[index] = D[index];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45", "completion": "```cpp\nvoid tensor_multi_select(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            for (size_t k = 0; k < dim3; ++k) {\n                size_t index = i * dim2 * dim3 + j * dim3 + k;\n                if (cond1[index] && cond2[index]) {\n                    out[index] = A[index];\n                } else if (cond1[index] && !cond2[index]) {\n                    out[index] = B[index];\n                } else if (!cond1[index] && cond2[index]) {\n                    out[index] = C[index];\n                } else {\n                    out[index] = D[index];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45", "completion": "```cpp\nvoid tensor_multi_select(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            for (size_t k = 0; k < dim3; ++k) {\n                size_t index = i * dim2 * dim3 + j * dim3 + k;\n                if (cond1[index] && cond2[index]) {\n                    out[index] = A[index];\n                } else if (cond1[index] && !cond2[index]) {\n                    out[index] = B[index];\n                } else if (!cond1[index] && cond2[index]) {\n                    out[index] = C[index];\n                } else {\n                    out[index] = D[index];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45", "completion": "```cpp\nvoid tensor_multi_select(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            for (size_t k = 0; k < dim3; ++k) {\n                size_t index = i * dim2 * dim3 + j * dim3 + k;\n                if (cond1[index] && cond2[index]) {\n                    out[index] = A[index];\n                } else if (cond1[index] && !cond2[index]) {\n                    out[index] = B[index];\n                } else if (!cond1[index] && cond2[index]) {\n                    out[index] = C[index];\n                } else {\n                    out[index] = D[index];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_46", "completion": "```c\nvoid tensor_bit_count(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1 * dim2 * dim3; ++i) {\n        uint32_t value = A[i];\n        uint8_t count = 0;\n        while (value) {\n            count += value & 1;\n            value >>= 1;\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_46", "completion": "```c\nvoid tensor_bit_count(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1 * dim2 * dim3; ++i) {\n        uint32_t value = A[i];\n        uint8_t count = 0;\n        while (value) {\n            count += value & 1;\n            value >>= 1;\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_46", "completion": "```c\nvoid tensor_bit_count(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1 * dim2 * dim3; ++i) {\n        uint32_t value = A[i];\n        uint8_t count = 0;\n        while (value) {\n            count += value & 1;\n            value >>= 1;\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_46", "completion": "```c\nvoid tensor_bit_count(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1 * dim2 * dim3; ++i) {\n        uint32_t val = A[i];\n        uint8_t count = 0;\n        while (val) {\n            count += (val & 1);\n            val >>= 1;\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_46", "completion": "```c\nvoid tensor_bit_count(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1 * dim2 * dim3; ++i) {\n        uint32_t val = A[i];\n        uint8_t count = 0;\n        while (val) {\n            count += (val & 1);\n            val >>= 1;\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_47", "completion": "```c\nvoid matrix_conditional_abs(const int* A, int* B, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows * cols; ++i) {\n        if (A[i] % 3 == 0) {\n            B[i] = abs(A[i]);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47", "completion": "```c\nvoid matrix_conditional_abs(const int* A, int* B, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows * cols; ++i) {\n        if (A[i] % 3 == 0) {\n            B[i] = abs(A[i]);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47", "completion": "```c\nvoid matrix_conditional_abs(const int* A, int* B, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows * cols; i++) {\n        if (A[i] % 3 == 0) {\n            B[i] = abs(A[i]);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47", "completion": "```c\nvoid matrix_conditional_abs(const int* A, int* B, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows * cols; ++i) {\n        if (A[i] % 3 == 0) {\n            B[i] = abs(A[i]);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47", "completion": "```c\nvoid matrix_conditional_abs(const int* A, int* B, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows * cols; ++i) {\n        if (A[i] % 3 == 0) {\n            B[i] = abs(A[i]);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48", "completion": "```c\nvoid matrix_conditional_bit_rotate(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    for(size_t i = 0; i < length; ++i){\n        uint32_t src_val = src[i];\n        uint32_t low_4_bits = src_val & 0xF;\n\n        if(low_4_bits == 0xF){\n            // Rotate right by rotate_bits\n            dst[i] = (src_val >> rotate_bits) | (src_val << (32 - rotate_bits));\n        }\n        else{\n            // Bitwise negation\n            dst[i] = ~src_val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48", "completion": "```c\nvoid matrix_conditional_bit_rotate(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    for(size_t i = 0; i < length; ++i){\n        uint32_t src_val = src[i];\n        uint32_t low_nibble = src_val & 0xF;\n\n        if(low_nibble == 0xF){\n            // Rotate towards low bits\n            uint32_t rotated = (src_val >> rotate_bits) | (src_val << (32 - rotate_bits));\n            dst[i] = rotated;\n        }\n        else{\n            // Bitwise negation\n            dst[i] = ~src_val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48", "completion": "```c\nvoid matrix_conditional_bit_rotate(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    for(size_t i = 0; i < length; ++i){\n        uint32_t src_val = src[i];\n        uint32_t low_4_bits = src_val & 0xF;\n\n        if(low_4_bits == 0xF){\n            // Rotate towards low bits\n            dst[i] = (src_val >> rotate_bits) | (src_val << (32 - rotate_bits));\n        }\n        else{\n            // Bitwise negation\n            dst[i] = ~src_val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48", "completion": "```c\nvoid matrix_conditional_bit_rotate(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    for(size_t i = 0; i < length; ++i){\n        uint32_t src_val = src[i];\n        uint32_t low_nibble = src_val & 0xF;\n\n        if(low_nibble == 0xF){\n            // Rotate right by rotate_bits\n            dst[i] = (src_val >> rotate_bits) | (src_val << (32 - rotate_bits));\n        }\n        else{\n            // Bitwise negation\n            dst[i] = ~src_val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48", "completion": "```c\nvoid matrix_conditional_bit_rotate(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    for(size_t i = 0; i < length; ++i){\n        uint32_t src_val = src[i];\n        uint32_t low_nibble = src_val & 0xF;\n\n        if(low_nibble == 0xF){\n            // Rotate towards low bits\n            uint32_t rotated = (src_val >> rotate_bits) | (src_val << (32 - rotate_bits));\n            dst[i] = rotated;\n        }\n        else{\n            // Bitwise negation\n            dst[i] = ~src_val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49", "completion": "```cpp\nvoid tensor_ternary_compare(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > epsilon) {\n            out[i] = 1;\n        } else if (diff < -epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49", "completion": "```cpp\nvoid tensor_ternary_compare(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > epsilon) {\n            out[i] = 1;\n        } else if (diff < -epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49", "completion": "```cpp\nvoid tensor_ternary_compare(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > epsilon) {\n            out[i] = 1;\n        } else if (diff < -epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49", "completion": "```cpp\nvoid tensor_ternary_compare(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > epsilon) {\n            out[i] = 1;\n        } else if (diff < -epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49", "completion": "```cpp\nvoid tensor_ternary_compare(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > epsilon) {\n            out[i] = 1;\n        } else if (diff < -epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50", "completion": "```c\nvoid float_to_int_saturate(const float* A, int32_t* B, size_t size) {\n    const int32_t INT32_MAX = 2147483647;\n    const int32_t INT32_MIN = -2147483648;\n\n    for (size_t i = 0; i < size; i++) {\n        float value = A[i];\n        if (value > (float)INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (value < (float)INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)value;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50", "completion": "```c\nvoid float_to_int_saturate(const float* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        float val = A[i];\n        if (val > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (val < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50", "completion": "```cpp\nvoid float_to_int_saturate(const float* A, int32_t* B, size_t size) {\n    const int32_t INT32_MAX = std::numeric_limits<int32_t>::max();\n    const int32_t INT32_MIN = std::numeric_limits<int32_t>::min();\n\n    for (size_t i = 0; i < size; ++i) {\n        float value = A[i];\n        if (value > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (value < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = static_cast<int32_t>(value);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50", "completion": "```c\nvoid float_to_int_saturate(const float* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        float val = A[i];\n        if (val > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (val < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50", "completion": "```c\nvoid float_to_int_saturate(const float* A, int32_t* B, size_t size) {\n    const int32_t INT32_MAX = 2147483647;\n    const int32_t INT32_MIN = -2147483648;\n\n    for (size_t i = 0; i < size; i++) {\n        float value = A[i];\n        if (value > (float)INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (value < (float)INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)value;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_51", "completion": "```c\nvoid int_to_float_scaled(const int32_t* A, int8_t scale, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        B[i] = (float)A[i] * (1 << scale);\n    }\n}\n```"}
{"task_id": "SimdBench_51", "completion": "```c\nvoid int_to_float_scaled(const int32_t* A, int8_t scale, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        B[i] = (float)A[i] * (1 << scale);\n    }\n}\n```"}
{"task_id": "SimdBench_51", "completion": "```c\nvoid int_to_float_scaled(const int32_t* A, int8_t scale, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (float)A[i] * (1 << scale);\n    }\n}\n```"}
{"task_id": "SimdBench_51", "completion": "```c\nvoid int_to_float_scaled(const int32_t* A, int8_t scale, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        B[i] = (float)A[i] * (1 << scale);\n    }\n}\n```"}
{"task_id": "SimdBench_51", "completion": "```c\nvoid int_to_float_scaled(const int32_t* A, int8_t scale, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        B[i] = (float)A[i] * (1 << scale);\n    }\n}\n```"}
{"task_id": "SimdBench_52", "completion": "```c\nvoid float_div_round(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        float result = A[i] / B[i];\n        C[i] = (int32_t)(result > 0 ? result + 0.5f : result - 0.5f);\n    }\n}\n```"}
{"task_id": "SimdBench_52", "completion": "```c\nvoid float_div_round(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        float result = A[i] / B[i];\n        C[i] = (int32_t)(result + (result > 0 ? 0.5f : -0.5f));\n    }\n}\n```"}
{"task_id": "SimdBench_52", "completion": "```c\nvoid float_div_round(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        float result = A[i] / B[i];\n        int32_t rounded = (int32_t)(result + 0.5f);\n        // Handle potential overflow/underflow by clamping\n        if (result > 0) {\n            C[i] = (rounded > INT32_MAX) ? INT32_MAX : rounded;\n        } else {\n            C[i] = (rounded < INT32_MIN) ? INT32_MIN : rounded;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_52", "completion": "```c\nvoid float_div_round(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        float result = A[i] / B[i];\n        C[i] = (int32_t)(result + (result > 0 ? 0.5f : -0.5f));\n    }\n}\n```"}
{"task_id": "SimdBench_52", "completion": "```c\nvoid float_div_round(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        float result = A[i] / B[i];\n        C[i] = (int32_t)(result > 0 ? result + 0.5f : result - 0.5f);\n    }\n}\n```"}
{"task_id": "SimdBench_53", "completion": "```c\nvoid double_to_float_saturate(const double* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        double val = A[i];\n        if (val > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (val < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53", "completion": "```cpp\nvoid double_to_float_saturate(const double* A, float* B, size_t size) {\n    const float FLT_MAX_VAL = FLT_MAX;\n    const float FLT_MIN_VAL = -FLT_MAX;\n    for (size_t i = 0; i < size; ++i) {\n        double val = A[i];\n        if (val > FLT_MAX_VAL) {\n            B[i] = FLT_MAX_VAL;\n        } else if (val < FLT_MIN_VAL) {\n            B[i] = FLT_MIN_VAL;\n        } else {\n            B[i] = static_cast<float>(val);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53", "completion": "```c\nvoid double_to_float_saturate(const double* A, float* B, size_t size) {\n    const float FLT_MAX_VAL = FLT_MAX;\n    const float FLT_MIN_VAL = -FLT_MAX;\n    for (size_t i = 0; i < size; i++) {\n        double val = A[i];\n        if (val > FLT_MAX_VAL) {\n            B[i] = FLT_MAX_VAL;\n        } else if (val < FLT_MIN_VAL) {\n            B[i] = FLT_MIN_VAL;\n        } else {\n            B[i] = static_cast<float>(val);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53", "completion": "```c\nvoid double_to_float_saturate(const double* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        double value = A[i];\n        if (value > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (value < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)value;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53", "completion": "```cpp\nvoid double_to_float_saturate(const double* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        double value = A[i];\n        if (value > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (value < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = static_cast<float>(value);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_54", "completion": "```c\nvoid int16_to_int32(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = static_cast<int32_t>(A[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_54", "completion": "```c\nvoid int16_to_int32(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = static_cast<int32_t>(A[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_54", "completion": "```c\nvoid int16_to_int32(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = static_cast<int32_t>(A[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_54", "completion": "```c\nvoid int16_to_int32(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = static_cast<int32_t>(A[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_54", "completion": "```c\nvoid int16_to_int32(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = static_cast<int32_t>(A[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_55", "completion": "```c\nvoid conditional_normalize(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    for (size_t i = 0; i < size; i++) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            if (val < 0.0f) {\n                B[i] = 0.0f;\n            } else if (val > 1.0f) {\n                B[i] = 1.0f;\n            } else {\n                B[i] = val;\n            }\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55", "completion": "```c\nvoid conditional_normalize(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    for (size_t i = 0; i < size; i++) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            if (val < 0.0f) {\n                B[i] = 0.0f;\n            } else if (val > 1.0f) {\n                B[i] = 1.0f;\n            } else {\n                B[i] = val;\n            }\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55", "completion": "```c\nvoid conditional_normalize(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    for (size_t i = 0; i < size; i++) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            if (val < 0.0f) {\n                B[i] = 0.0f;\n            } else if (val > 1.0f) {\n                B[i] = 1.0f;\n            } else {\n                B[i] = val;\n            }\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55", "completion": "```c\nvoid conditional_normalize(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    for (size_t i = 0; i < size; i++) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            if (val < 0.0f) {\n                B[i] = 0.0f;\n            } else if (val > 1.0f) {\n                B[i] = 1.0f;\n            } else {\n                B[i] = val;\n            }\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55", "completion": "```c\nvoid conditional_normalize(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    for (size_t i = 0; i < size; i++) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            if (val < 0.0f) {\n                B[i] = 0.0f;\n            } else if (val > 1.0f) {\n                B[i] = 1.0f;\n            } else {\n                B[i] = val;\n            }\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_56", "completion": "```c\nvoid int_to_float_sqrt(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        uint32_t high_bits = A[i] >> 16;\n        B[i] = sqrtf(__int32_to_float(high_bits));\n    }\n}\n```"}
{"task_id": "SimdBench_56", "completion": "```c\nvoid int_to_float_sqrt(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        uint32_t value = A[i];\n        uint32_t high_bits = value >> 16;\n        B[i] = sqrtf((float)high_bits);\n    }\n}\n```"}
{"task_id": "SimdBench_56", "completion": "```cpp\nvoid int_to_float_sqrt(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        uint32_t value = A[i];\n        uint32_t high_bits = value >> 16;\n        B[i] = sqrtf(static_cast<float>(high_bits));\n    }\n}\n```"}
{"task_id": "SimdBench_56", "completion": "```c\nvoid int_to_float_sqrt(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        uint32_t high_bits = A[i] >> 16;\n        B[i] = sqrtf(__int32_to_float(high_bits));\n    }\n}\n```"}
{"task_id": "SimdBench_56", "completion": "```c\nvoid int_to_float_sqrt(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        uint32_t high_bits = A[i] >> 16;\n        B[i] = sqrtf((float)high_bits);\n    }\n}\n```"}
{"task_id": "SimdBench_57", "completion": "```c\nvoid int_bits_to_float(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = *(reinterpret_cast<const float*>(&A[i]));\n    }\n}\n```"}
{"task_id": "SimdBench_57", "completion": "```c\nvoid int_bits_to_float(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = *(reinterpret_cast<const float*>(&A[i]));\n    }\n}\n```"}
{"task_id": "SimdBench_57", "completion": "```c\nvoid int_bits_to_float(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        B[i] = *(reinterpret_cast<const float*>(&A[i]));\n    }\n}\n```"}
{"task_id": "SimdBench_57", "completion": "```c\nvoid int_bits_to_float(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        B[i] = reinterpret_cast<const float&>(A[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_57", "completion": "```c\nvoid int_bits_to_float(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        B[i] = reinterpret_cast<const float&>(A[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_58", "completion": "```c\nvoid conditional_diff(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n\n    diff[0] = 0.0f;\n    for (size_t i = 1; i < size; i++) {\n        diff[i] = cond[i] ? (float)(A[i] - A[i - 1]) : 0.0f;\n    }\n}\n```"}
{"task_id": "SimdBench_58", "completion": "```c\nvoid conditional_diff(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n\n    diff[0] = 0.0f;\n    for (size_t i = 1; i < size; i++) {\n        diff[i] = cond[i] ? (float)(A[i] - A[i - 1]) : 0.0f;\n    }\n}\n```"}
{"task_id": "SimdBench_58", "completion": "```c\nvoid conditional_diff(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n\n    diff[0] = 0.0f;\n    for (size_t i = 1; i < size; i++) {\n        diff[i] = cond[i] ? (float)(A[i] - A[i - 1]) : 0.0f;\n    }\n}\n```"}
{"task_id": "SimdBench_58", "completion": "```c\nvoid conditional_diff(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n\n    diff[0] = 0.0f;\n    for (size_t i = 1; i < size; i++) {\n        diff[i] = cond[i] ? (float)(A[i] - A[i - 1]) : 0.0f;\n    }\n}\n```"}
{"task_id": "SimdBench_58", "completion": "```c\nvoid conditional_diff(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n\n    diff[0] = 0.0f;\n    for (size_t i = 1; i < size; i++) {\n        diff[i] = cond[i] ? (float)(A[i] - A[i - 1]) : 0.0f;\n    }\n}\n```"}
{"task_id": "SimdBench_59", "completion": "```c\nvoid widening_uint(const uint32_t* src, uint64_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = ((uint64_t)src[i]) | 0xFFFFFFFF00000000;\n    }\n}\n```"}
{"task_id": "SimdBench_59", "completion": "```c\nvoid widening_uint(const uint32_t* src, uint64_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = ((uint64_t)src[i]) | 0xFFFFFFFF00000000;\n    }\n}\n```"}
{"task_id": "SimdBench_59", "completion": "```c\nvoid widening_uint(const uint32_t* src, uint64_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = ((uint64_t)src[i]) | 0xFFFFFFFF00000000;\n    }\n}\n```"}
{"task_id": "SimdBench_59", "completion": "```c\nvoid widening_uint(const uint32_t* src, uint64_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = (uint64_t)src[i] | 0xFFFFFFFF00000000;\n    }\n}\n```"}
{"task_id": "SimdBench_59", "completion": "```c\nvoid widening_uint(const uint32_t* src, uint64_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = ((uint64_t)src[i]) | 0xFFFFFFFF00000000;\n    }\n}\n```"}
{"task_id": "SimdBench_60", "completion": "```c\ndouble indexed_sum(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    for (size_t i = 0; i < length; i++) {\n        int16_t idx = index[i];\n        if (idx >= 0 && (size_t)idx < length) {\n            sum += vec[idx];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60", "completion": "```c\ndouble indexed_sum(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    for (size_t i = 0; i < length; i++) {\n        int16_t idx = index[i];\n        if (idx >= 0 && (size_t)idx < length) {\n            sum += vec[idx];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60", "completion": "```c\ndouble indexed_sum(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    for (size_t i = 0; i < length; i++) {\n        int16_t idx = index[i];\n        if (idx >= 0 && (size_t)idx < length) {\n            sum += vec[idx];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60", "completion": "```c\ndouble indexed_sum(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    for (size_t i = 0; i < length; i++) {\n        int16_t idx = index[i];\n        if (idx >= 0 && (size_t)idx < length) {\n            sum += vec[idx];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60", "completion": "```c\ndouble indexed_sum(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    for (size_t i = 0; i < length; i++) {\n        int16_t idx = index[i];\n        if (idx >= 0 && (size_t)idx < length) {\n            sum += vec[idx];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_61", "completion": "```c\nvoid simple_conv2d(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t m = 0; m < kernel_size; ++m) {\n                for (size_t n = 0; n < kernel_size; ++n) {\n                    size_t input_idx = (i + m) * input_size + (j + n);\n                    size_t kernel_idx = m * kernel_size + n;\n                    sum += input[input_idx] * kernel[kernel_idx];\n                }\n            }\n            output[i * output_size + j] = (sum > 0.0) ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61", "completion": "```c\nvoid simple_conv2d(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t m = 0; m < kernel_size; ++m) {\n                for (size_t n = 0; n < kernel_size; ++n) {\n                    size_t input_idx = (i + m) * input_size + (j + n);\n                    size_t kernel_idx = m * kernel_size + n;\n                    sum += input[input_idx] * kernel[kernel_idx];\n                }\n            }\n            output[i * output_size + j] = (sum > 0.0) ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61", "completion": "```c\nvoid simple_conv2d(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t m = 0; m < kernel_size; ++m) {\n                for (size_t n = 0; n < kernel_size; ++n) {\n                    size_t in_idx = (i + m) * input_size + (j + n);\n                    size_t ker_idx = m * kernel_size + n;\n                    sum += input[in_idx] * kernel[ker_idx];\n                }\n            }\n            output[i * output_size + j] = (sum > 0.0) ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61", "completion": "```c\nvoid simple_conv2d(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t m = 0; m < kernel_size; ++m) {\n                for (size_t n = 0; n < kernel_size; ++n) {\n                    size_t in_idx = (i + m) * input_size + (j + n);\n                    size_t ker_idx = m * kernel_size + n;\n                    sum += input[in_idx] * kernel[ker_idx];\n                }\n            }\n            output[i * output_size + j] = (sum > 0.0) ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61", "completion": "```c\nvoid simple_conv2d(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t m = 0; m < kernel_size; ++m) {\n                for (size_t n = 0; n < kernel_size; ++n) {\n                    size_t input_idx = (i + m) * input_size + (j + n);\n                    size_t kernel_idx = m * kernel_size + n;\n                    sum += input[input_idx] * kernel[kernel_idx];\n                }\n            }\n            output[i * output_size + j] = sum > 0.0 ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_62", "completion": "```cpp\nbool has_close_elements(const std::vector<double> & numbers, double threshold){\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            if (std::abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62", "completion": "```cpp\nbool has_close_elements(const std::vector<double> & numbers, double threshold){\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            if (std::abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62", "completion": "```cpp\nbool has_close_elements(const std::vector<double> & numbers, double threshold){\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            if (std::abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62", "completion": "```cpp\nbool has_close_elements(const std::vector<double> & numbers, double threshold){\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            if (std::abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62", "completion": "```cpp\nbool has_close_elements(const std::vector<double> & numbers, double threshold){\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            if (std::abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63", "completion": "```cpp\nbool below_zero(std::vector<int> operations){\n    int balance = 0;\n    for(int op : operations){\n        balance += op;\n        if(balance < 0) return true;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63", "completion": "```cpp\nbool below_zero(std::vector<int> operations){\n    int balance = 0;\n    for(int op : operations){\n        balance += op;\n        if(balance < 0) return true;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63", "completion": "```cpp\nbool below_zero(std::vector<int> operations){\n    int balance = 0;\n    for(int op : operations){\n        balance += op;\n        if(balance < 0) return true;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63", "completion": "```cpp\nbool below_zero(std::vector<int> operations){\n    int balance = 0;\n    for(int op : operations){\n        balance += op;\n        if(balance < 0) return true;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63", "completion": "```cpp\nbool below_zero(std::vector<int> operations){\n    int balance = 0;\n    for(int op : operations){\n        balance += op;\n        if(balance < 0) return true;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_64", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation(std::vector<double> numbers) {\n    if (numbers.empty()) return 0.0;\n\n    double sum = 0.0;\n    for (const auto& num : numbers) {\n        sum += num;\n    }\n    double mean = sum / numbers.size();\n\n    double mad_sum = 0.0;\n    for (const auto& num : numbers) {\n        mad_sum += std::abs(num - mean);\n    }\n    return mad_sum / numbers.size();\n}\n```"}
{"task_id": "SimdBench_64", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation(std::vector<double> numbers) {\n    if (numbers.empty()) return 0.0;\n\n    double sum = 0.0;\n    for (const auto& num : numbers) {\n        sum += num;\n    }\n    double mean = sum / numbers.size();\n\n    double mad_sum = 0.0;\n    for (const auto& num : numbers) {\n        mad_sum += std::abs(num - mean);\n    }\n    return mad_sum / numbers.size();\n}\n```"}
{"task_id": "SimdBench_64", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation(std::vector<double> numbers) {\n    if (numbers.empty()) return 0.0;\n\n    double sum = 0.0;\n    for (double num : numbers) {\n        sum += num;\n    }\n    double mean = sum / numbers.size();\n\n    double mad_sum = 0.0;\n    for (double num : numbers) {\n        mad_sum += std::abs(num - mean);\n    }\n    return mad_sum / numbers.size();\n}\n```"}
{"task_id": "SimdBench_64", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation(std::vector<double> numbers) {\n    if (numbers.empty()) return 0.0;\n\n    double sum = 0.0;\n    for (double num : numbers) {\n        sum += num;\n    }\n    double mean = sum / numbers.size();\n\n    double mad_sum = 0.0;\n    for (double num : numbers) {\n        mad_sum += std::abs(num - mean);\n    }\n    return mad_sum / numbers.size();\n}\n```"}
{"task_id": "SimdBench_64", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation(std::vector<double> numbers) {\n    if (numbers.empty()) return 0.0;\n\n    double sum = 0.0;\n    for (double num : numbers) {\n        sum += num;\n    }\n    double mean = sum / numbers.size();\n\n    double mad_sum = 0.0;\n    for (double num : numbers) {\n        mad_sum += std::abs(num - mean);\n    }\n    return mad_sum / numbers.size();\n}\n```"}
{"task_id": "SimdBench_65", "completion": "```cpp\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter) { \n    std::vector<int> result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i != numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_65", "completion": "```cpp\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter) { \n    std::vector<int> result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i != numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_65", "completion": "```cpp\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter) { \n    std::vector<int> result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i != numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_65", "completion": "```cpp\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter) { \n    std::vector<int> result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i != numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_65", "completion": "```cpp\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter) { \n    std::vector<int> result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i != numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_66", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nstd::vector<int64_t> sum_product(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    for (int16_t num : numbers) {\n        sum += num;\n        product *= num;\n    }\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nstd::vector<int64_t> sum_product(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    for (int16_t num : numbers) {\n        sum += num;\n        product *= num;\n    }\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nstd::vector<int64_t> sum_product(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    for (int16_t num : numbers) {\n        sum += num;\n        product *= num;\n    }\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nstd::vector<int64_t> sum_product(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    for (int16_t num : numbers) {\n        sum += num;\n        product *= num;\n    }\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nstd::vector<int64_t> sum_product(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    for (int16_t num : numbers) {\n        sum += num;\n        product *= num;\n    }\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_67", "completion": "```cpp\nstd::vector<int> rolling_max(std::vector<int> numbers){\n    std::vector<int> result;\n    if (numbers.empty()) return result;\n    int current_max = numbers[0];\n    for (int num : numbers) {\n        if (num > current_max) {\n            current_max = num;\n        }\n        result.push_back(current_max);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_67", "completion": "```cpp\nstd::vector<int> rolling_max(std::vector<int> numbers){\n    std::vector<int> result;\n    if (numbers.empty()) return result;\n    int current_max = numbers[0];\n    for (int num : numbers) {\n        if (num > current_max) {\n            current_max = num;\n        }\n        result.push_back(current_max);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_67", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> rolling_max(std::vector<int> numbers) {\n    std::vector<int> result;\n    if (numbers.empty()) return result;\n    \n    int current_max = numbers[0];\n    result.push_back(current_max);\n    \n    for (size_t i = 1; i < numbers.size(); ++i) {\n        if (numbers[i] > current_max) {\n            current_max = numbers[i];\n        }\n        result.push_back(current_max);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_67", "completion": "```cpp\nstd::vector<int> rolling_max(std::vector<int> numbers){\n    std::vector<int> result;\n    if (numbers.empty()) return result;\n    int current_max = numbers[0];\n    for (int num : numbers) {\n        if (num > current_max) {\n            current_max = num;\n        }\n        result.push_back(current_max);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_67", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> rolling_max(std::vector<int> numbers) {\n    std::vector<int> result;\n    if (numbers.empty()) return result;\n    \n    int current_max = numbers[0];\n    result.push_back(current_max);\n    \n    for (size_t i = 1; i < numbers.size(); ++i) {\n        if (numbers[i] > current_max) {\n            current_max = numbers[i];\n        }\n        result.push_back(current_max);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_68", "completion": "```cpp\nstd::string string_xor(std::string a, std::string b){\n    std::string result = \"\";\n    for(size_t i = 0; i < a.size(); ++i){\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_68", "completion": "```cpp\nstd::string string_xor(std::string a, std::string b){\n    std::string result = \"\";\n    for(size_t i = 0; i < a.size(); ++i){\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_68", "completion": "```cpp\nstd::string string_xor(std::string a, std::string b){\n    std::string result = \"\";\n    for(size_t i = 0; i < a.size(); ++i){\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_68", "completion": "```cpp\nstd::string string_xor(std::string a, std::string b){\n    std::string result = \"\";\n    for(size_t i = 0; i < a.size(); ++i){\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_68", "completion": "```cpp\nstd::string string_xor(std::string a, std::string b){\n    std::string result = \"\";\n    for(size_t i = 0; i < a.size(); ++i){\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_69", "completion": "```cpp\n#include <string>\n#include <vector>\n\nstd::string longest(const std::vector<std::string> &strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n    const std::string *longest_str = &strings[0];\n    for (const auto &str : strings) {\n        if (str.length() > longest_str->length()) {\n            longest_str = &str;\n        }\n    }\n    return *longest_str;\n}\n```"}
{"task_id": "SimdBench_69", "completion": "```cpp\n#include <string>\n#include <vector>\n\nstd::string longest(const std::vector<std::string> &strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n    const std::string *longest_str = &strings[0];\n    for (const auto &str : strings) {\n        if (str.length() > longest_str->length()) {\n            longest_str = &str;\n        }\n    }\n    return *longest_str;\n}\n```"}
{"task_id": "SimdBench_69", "completion": "```cpp\n#include <string>\n#include <vector>\n\nstd::string longest(const std::vector<std::string> &strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n    const std::string *longest_str = &strings[0];\n    for (const auto &str : strings) {\n        if (str.length() > longest_str->length()) {\n            longest_str = &str;\n        }\n    }\n    return *longest_str;\n}\n```"}
{"task_id": "SimdBench_69", "completion": "```cpp\n#include <string>\n#include <vector>\n\nstd::string longest(const std::vector<std::string> &strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n    const std::string *longest_str = &strings[0];\n    for (const auto &str : strings) {\n        if (str.length() > longest_str->length()) {\n            longest_str = &str;\n        }\n    }\n    return *longest_str;\n}\n```"}
{"task_id": "SimdBench_69", "completion": "```cpp\n#include <string>\n#include <vector>\n\nstd::string longest(const std::vector<std::string> &strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n    const std::string *longest_str = &strings[0];\n    for (const auto &str : strings) {\n        if (str.length() > longest_str->length()) {\n            longest_str = &str;\n        }\n    }\n    return *longest_str;\n}\n```"}
{"task_id": "SimdBench_70", "completion": "```c\nuint64_t greatest_common_divisor(uint64_t a, uint64_t b){\n    while (b != 0){\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_70", "completion": "```c\nuint64_t greatest_common_divisor(uint64_t a, uint64_t b){\n    while (b != 0){\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_70", "completion": "```c\nuint64_t greatest_common_divisor(uint64_t a, uint64_t b){\n    while (b != 0){\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_70", "completion": "```c\nuint64_t greatest_common_divisor(uint64_t a, uint64_t b){\n    while (b != 0){\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_70", "completion": "```c\nuint64_t greatest_common_divisor(uint64_t a, uint64_t b){\n    while (b != 0){\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_71", "completion": "```cpp\n#include <vector>\n#include <utility>\n#include <algorithm>\n\nstd::pair<float, float> find_closest_elements(std::vector<float> numbers) {\n    std::sort(numbers.begin(), numbers.end());\n    float min_diff = std::abs(numbers[1] - numbers[0]);\n    std::pair<float, float> closest_pair = {numbers[0], numbers[1]};\n    \n    for (size_t i = 1; i < numbers.size() - 1; ++i) {\n        float diff = std::abs(numbers[i + 1] - numbers[i]);\n        if (diff < min_diff) {\n            min_diff = diff;\n            closest_pair = {numbers[i], numbers[i + 1]};\n        }\n    }\n    \n    return closest_pair;\n}\n```"}
{"task_id": "SimdBench_71", "completion": "```cpp\n#include <vector>\n#include <utility>\n#include <algorithm>\n\nstd::pair<float, float> find_closest_elements(std::vector<float> numbers) {\n    std::sort(numbers.begin(), numbers.end());\n    float min_diff = std::abs(numbers[1] - numbers[0]);\n    std::pair<float, float> closest_pair = {numbers[0], numbers[1]};\n    \n    for (size_t i = 1; i < numbers.size() - 1; ++i) {\n        float diff = std::abs(numbers[i + 1] - numbers[i]);\n        if (diff < min_diff) {\n            min_diff = diff;\n            closest_pair = {numbers[i], numbers[i + 1]};\n        }\n    }\n    \n    return closest_pair;\n}\n```"}
{"task_id": "SimdBench_71", "completion": "```cpp\n#include <vector>\n#include <utility>\n#include <algorithm>\n\nstd::pair<float, float> find_closest_elements(std::vector<float> numbers) {\n    std::sort(numbers.begin(), numbers.end());\n    float min_diff = std::abs(numbers[1] - numbers[0]);\n    std::pair<float, float> closest_pair = {numbers[0], numbers[1]};\n    \n    for (size_t i = 1; i < numbers.size() - 1; ++i) {\n        float diff = std::abs(numbers[i + 1] - numbers[i]);\n        if (diff < min_diff) {\n            min_diff = diff;\n            closest_pair = {numbers[i], numbers[i + 1]};\n        }\n    }\n    \n    return closest_pair;\n}\n```"}
{"task_id": "SimdBench_71", "completion": "```cpp\n#include <vector>\n#include <utility>\n#include <algorithm>\n\nstd::pair<float, float> find_closest_elements(std::vector<float> numbers) {\n    std::sort(numbers.begin(), numbers.end());\n    float min_diff = std::abs(numbers[1] - numbers[0]);\n    std::pair<float, float> closest_pair = {numbers[0], numbers[1]};\n    \n    for (size_t i = 1; i < numbers.size() - 1; ++i) {\n        float diff = std::abs(numbers[i + 1] - numbers[i]);\n        if (diff < min_diff) {\n            min_diff = diff;\n            closest_pair = {numbers[i], numbers[i + 1]};\n        }\n    }\n    \n    return closest_pair;\n}\n```"}
{"task_id": "SimdBench_71", "completion": "```cpp\n#include <vector>\n#include <utility>\n#include <algorithm>\n\nstd::pair<float, float> find_closest_elements(std::vector<float> numbers) {\n    std::sort(numbers.begin(), numbers.end());\n    float min_diff = std::abs(numbers[1] - numbers[0]);\n    std::pair<float, float> closest_pair = {numbers[0], numbers[1]};\n    \n    for (size_t i = 1; i < numbers.size() - 1; ++i) {\n        float diff = std::abs(numbers[i + 1] - numbers[i]);\n        if (diff < min_diff) {\n            min_diff = diff;\n            closest_pair = {numbers[i], numbers[i + 1]};\n        }\n    }\n    \n    return closest_pair;\n}\n```"}
{"task_id": "SimdBench_72", "completion": "```cpp\n#include <vector>\n\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float min_val = *min_element(numbers.begin(), numbers.end());\n    float max_val = *max_element(numbers.begin(), numbers.end());\n    std::vector<float> rescaled;\n    for (float num : numbers) {\n        rescaled.push_back((num - min_val) / (max_val - min_val));\n    }\n    return rescaled;\n}\n```"}
{"task_id": "SimdBench_72", "completion": "```cpp\n#include <vector>\n\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float min_val = *min_element(numbers.begin(), numbers.end());\n    float max_val = *max_element(numbers.begin(), numbers.end());\n    std::vector<float> rescaled;\n    for (float num : numbers) {\n        rescaled.push_back((num - min_val) / (max_val - min_val));\n    }\n    return rescaled;\n}\n```"}
{"task_id": "SimdBench_72", "completion": "```cpp\n#include <vector>\n\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float min_val = *min_element(numbers.begin(), numbers.end());\n    float max_val = *max_element(numbers.begin(), numbers.end());\n    std::vector<float> rescaled;\n    for (float num : numbers) {\n        rescaled.push_back((num - min_val) / (max_val - min_val));\n    }\n    return rescaled;\n}\n```"}
{"task_id": "SimdBench_72", "completion": "```cpp\n#include <vector>\n\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float min_val = *min_element(numbers.begin(), numbers.end());\n    float max_val = *max_element(numbers.begin(), numbers.end());\n    std::vector<float> rescaled;\n    for (float num : numbers) {\n        rescaled.push_back((num - min_val) / (max_val - min_val));\n    }\n    return rescaled;\n}\n```"}
{"task_id": "SimdBench_72", "completion": "```cpp\n#include <vector>\n\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float min_val = *min_element(numbers.begin(), numbers.end());\n    float max_val = *max_element(numbers.begin(), numbers.end());\n    std::vector<float> rescaled;\n    for (float num : numbers) {\n        rescaled.push_back((num - min_val) / (max_val - min_val));\n    }\n    return rescaled;\n}\n```"}
{"task_id": "SimdBench_73", "completion": "```cpp\nuint64_t largest_divisor(uint64_t n){\n    for(uint64_t i = n / 2; i > 0; --i){\n        if(n % i == 0){\n            return i;\n        }\n    }\n    return 1; // This line is theoretically unreachable for n > 1\n}\n```"}
{"task_id": "SimdBench_73", "completion": "```cpp\nuint64_t largest_divisor(uint64_t n){\n    for(uint64_t i = n / 2; i > 0; --i){\n        if(n % i == 0){\n            return i;\n        }\n    }\n    return 1; // This line is theoretically unreachable for n > 1\n}\n```"}
{"task_id": "SimdBench_73", "completion": "```cpp\nuint64_t largest_divisor(uint64_t n){\n    for(uint64_t i = n / 2; i > 0; --i){\n        if(n % i == 0){\n            return i;\n        }\n    }\n    return 1; // This line is theoretically unreachable for n > 1\n}\n```"}
{"task_id": "SimdBench_73", "completion": "```cpp\nuint64_t largest_divisor(uint64_t n){\n    for(uint64_t i = n / 2; i > 0; --i){\n        if(n % i == 0){\n            return i;\n        }\n    }\n    return 1; // This line is theoretically unreachable for n > 1\n}\n```"}
{"task_id": "SimdBench_73", "completion": "```cpp\nuint64_t largest_divisor(uint64_t n){\n    for(uint64_t i = n / 2; i > 0; --i){\n        if(n % i == 0){\n            return i;\n        }\n    }\n    return 1; // n itself is always a divisor of n\n}\n```"}
{"task_id": "SimdBench_74", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> factorize(int n) {\n    std::vector<int> factors;\n    for (int i = 2; i * i <= n; ++i) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> factorize(int n) {\n    std::vector<int> factors;\n    for (int i = 2; i * i <= n; ++i) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> factorize(int n) {\n    std::vector<int> factors;\n    for (int i = 2; i * i <= n; ++i) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> factorize(int n) {\n    std::vector<int> factors;\n    for (int i = 2; i * i <= n; ++i) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> factorize(int n) {\n    std::vector<int> factors;\n    for (int i = 2; i * i <= n; ++i) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n```"}
{"task_id": "SimdBench_75", "completion": "```cpp\nstd::vector<float> get_positive(const std::vector<float> & l){\n    std::vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75", "completion": "```cpp\nstd::vector<float> get_positive(const std::vector<float> & l){\n    std::vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75", "completion": "```cpp\nstd::vector<float> get_positive(const std::vector<float> & l){\n    std::vector<float> result;\n    for(auto num : l){\n        if(num > 0.0f){\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75", "completion": "```cpp\nstd::vector<float> get_positive(const std::vector<float> & l){\n    std::vector<float> result;\n    for(auto num : l){\n        if(num > 0.0f){\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75", "completion": "```cpp\nstd::vector<float> get_positive(const std::vector<float> & l){\n    std::vector<float> result;\n    for(auto num : l){\n        if(num > 0.0f){\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_76", "completion": "```cpp\nbool is_prime(int64_t n){\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int64_t i = 5; i * i <= n; i += 6){\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76", "completion": "```cpp\nbool is_prime(int64_t n){\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int64_t i = 5; i * i <= n; i += 6){\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76", "completion": "```cpp\nbool is_prime(int64_t n){\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int64_t i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76", "completion": "```cpp\nbool is_prime(int64_t n){\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int64_t i = 5; i * i <= n; i += 6){\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76", "completion": "```cpp\nbool is_prime(int64_t n){\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int64_t i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_77", "completion": "```cpp\nstd::string solve(const std::string & s){\n    bool hasLetter = false;\n    for(char c : s){\n        if( (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') ){\n            hasLetter = true;\n            break;\n        }\n    }\n    if(hasLetter){\n        std::string result = s;\n        for(auto & c : result){\n            if(c >= 'A' && c <= 'Z'){\n                c = c + ('a' - 'A');\n            }\n            else if(c >= 'a' && c <= 'z'){\n                c = c - ('a' - 'A');\n            }\n        }\n        return result;\n    }\n    else{\n        std::string result = s;\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n}\n```"}
{"task_id": "SimdBench_77", "completion": "```cpp\nstd::string solve(const std::string & s){\n    bool has_alpha = false;\n    for(char c : s){\n        if(isalpha(c)){\n            has_alpha = true;\n            break;\n        }\n    }\n    if(has_alpha){\n        std::string result = s;\n        for(auto & c : result){\n            if(islower(c)) c = toupper(c);\n            else if(isupper(c)) c = tolower(c);\n        }\n        return result;\n    }\n    else{\n        std::string result = s;\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n}\n```"}
{"task_id": "SimdBench_77", "completion": "```cpp\nstd::string solve(const std::string & s){\n    bool hasLetter = false;\n    for(char c : s){\n        if( (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') ){\n            hasLetter = true;\n            break;\n        }\n    }\n    if(hasLetter){\n        std::string result = s;\n        for(auto & c : result){\n            if(c >= 'A' && c <= 'Z'){\n                c = c + ('a' - 'A');\n            }\n            else if(c >= 'a' && c <= 'z'){\n                c = c - ('a' - 'A');\n            }\n        }\n        return result;\n    }\n    else{\n        std::string result = s;\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n}\n```"}
{"task_id": "SimdBench_77", "completion": "```cpp\nstd::string solve(const std::string & s){\n    bool hasLetter = false;\n    for(char c : s){\n        if( (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') ){\n            hasLetter = true;\n            break;\n        }\n    }\n    if(hasLetter){\n        std::string result = s;\n        for(auto & c : result){\n            if(c >= 'A' && c <= 'Z'){\n                c = c + ('a' - 'A');\n            }\n            else if(c >= 'a' && c <= 'z'){\n                c = c - ('a' - 'A');\n            }\n        }\n        return result;\n    }\n    else{\n        std::string result = s;\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n}\n```"}
{"task_id": "SimdBench_77", "completion": "```cpp\nstd::string solve(const std::string & s){\n    bool hasLetter = false;\n    for(char c : s){\n        if( (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') ){\n            hasLetter = true;\n            break;\n        }\n    }\n    if(hasLetter){\n        std::string result = s;\n        for(auto & c : result){\n            if(c >= 'A' && c <= 'Z'){\n                c = c + ('a' - 'A');\n            }\n            else if(c >= 'a' && c <= 'z'){\n                c = c - ('a' - 'A');\n            }\n        }\n        return result;\n    }\n    else{\n        std::string result = s;\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n}\n```"}
{"task_id": "SimdBench_78", "completion": "```cpp\nstd::vector<int> sort_third(std::vector<int> l) {\n    std::vector<int> indices;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            indices.push_back(l[i]);\n        }\n    }\n    std::sort(indices.begin(), indices.end());\n    \n    std::vector<int> result = l;\n    size_t idx = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            result[i] = indices[idx];\n            ++idx;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_78", "completion": "```cpp\nstd::vector<int> sort_third(std::vector<int> l) {\n    std::vector<int> indices;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            indices.push_back(l[i]);\n        }\n    }\n    std::sort(indices.begin(), indices.end());\n    \n    std::vector<int> result = l;\n    size_t idx = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            result[i] = indices[idx];\n            ++idx;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_78", "completion": "```cpp\nstd::vector<int> sort_third(std::vector<int> l) {\n    std::vector<int> indices;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            indices.push_back(l[i]);\n        }\n    }\n    std::sort(indices.begin(), indices.end());\n    \n    std::vector<int> result = l;\n    size_t idx = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 3 == 0) {\n            result[i] = indices[idx];\n            ++idx;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_78", "completion": "```cpp\nstd::vector<int> sort_third(std::vector<int> l){\n    std::vector<int> indices;\n    for(int i = 0; i < l.size(); ++i){\n        if(i % 3 == 0){\n            indices.push_back(i);\n        }\n    }\n    std::vector<int> values;\n    for(auto idx : indices){\n        values.push_back(l[idx]);\n    }\n    std::sort(values.begin(), values.end());\n    for(size_t i = 0; i < indices.size(); ++i){\n        l[indices[i]] = values[i];\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_78", "completion": "```cpp\nstd::vector<int> sort_third(std::vector<int> l){\n    std::vector<int> indices;\n    for(int i = 0; i < l.size(); ++i){\n        if(i % 3 == 0){\n            indices.push_back(i);\n        }\n    }\n    std::vector<int> slice;\n    for(auto idx : indices){\n        slice.push_back(l[idx]);\n    }\n    std::sort(slice.begin(), slice.end());\n    for(size_t i = 0; i < indices.size(); ++i){\n        l[indices[i]] = slice[i];\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_79", "completion": "```cpp\nfloat max_element(std::vector<float> l){\n    float max_val = l[0];\n    for(float num : l){\n        if(num > max_val){\n            max_val = num;\n        }\n    }\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79", "completion": "```cpp\nfloat max_element(std::vector<float> l){\n    float max_val = l[0];\n    for(float num : l){\n        if(num > max_val){\n            max_val = num;\n        }\n    }\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79", "completion": "```cpp\nfloat max_element(std::vector<float> l){\n    float max_val = l[0];\n    for(float num : l){\n        if(num > max_val){\n            max_val = num;\n        }\n    }\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79", "completion": "```cpp\nfloat max_element(std::vector<float> l){\n    float max_val = l[0];\n    for(float num : l){\n        if(num > max_val){\n            max_val = num;\n        }\n    }\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79", "completion": "```cpp\nfloat max_element(std::vector<float> l){\n    float max_val = l[0];\n    for(float num : l){\n        if(num > max_val){\n            max_val = num;\n        }\n    }\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_80", "completion": "```cpp\nint fizz_buzz(int n){\n    int count = 0;\n    for(int i = 0; i < n; ++i){\n        if(i % 11 == 0 || i % 13 == 0){\n            int num = i;\n            while(num > 0){\n                if(num % 10 == 7){\n                    count++;\n                }\n                num /= 10;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80", "completion": "```cpp\nint fizz_buzz(int n){\n    int count = 0;\n    for(int i = 0; i < n; ++i){\n        if(i % 11 == 0 || i % 13 == 0){\n            int num = i;\n            while(num > 0){\n                if(num % 10 == 7){\n                    count++;\n                }\n                num /= 10;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80", "completion": "```cpp\nint fizz_buzz(int n){\n    int count = 0;\n    for(int i = 0; i < n; ++i){\n        if(i % 11 == 0 || i % 13 == 0){\n            int num = i;\n            while(num > 0){\n                if(num % 10 == 7){\n                    count++;\n                }\n                num /= 10;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80", "completion": "```cpp\nint fizz_buzz(int n){\n    int count = 0;\n    for(int i = 0; i < n; ++i){\n        if(i % 11 == 0 || i % 13 == 0){\n            int num = i;\n            while(num > 0){\n                if(num % 10 == 7){\n                    count++;\n                }\n                num /= 10;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80", "completion": "```cpp\nint fizz_buzz(int n){\n    int count = 0;\n    for(int i = 0; i < n; ++i){\n        if(i % 11 == 0 || i % 13 == 0){\n            int num = i;\n            while(num > 0){\n                if(num % 10 == 7){\n                    count++;\n                }\n                num /= 10;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_81", "completion": "```cpp\nstd::vector<float> sort_even(std::vector<float> l) {\n    std::vector<float> even_values;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            even_values.push_back(l[i]);\n        }\n    }\n    std::sort(even_values.begin(), even_values.end());\n    size_t even_idx = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            l[i] = even_values[even_idx++];\n        }\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_81", "completion": "```cpp\nstd::vector<float> sort_even(std::vector<float> l) {\n    std::vector<float> even_values;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            even_values.push_back(l[i]);\n        }\n    }\n    std::sort(even_values.begin(), even_values.end());\n    size_t even_idx = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            l[i] = even_values[even_idx++];\n        }\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_81", "completion": "```cpp\nstd::vector<float> sort_even(std::vector<float> l) {\n    std::vector<float> even_values;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            even_values.push_back(l[i]);\n        }\n    }\n    std::sort(even_values.begin(), even_values.end());\n    size_t even_idx = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            l[i] = even_values[even_idx++];\n        }\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_81", "completion": "```cpp\nstd::vector<float> sort_even(std::vector<float> l) {\n    std::vector<float> even_values;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even_values.push_back(l[i]);\n    }\n    std::sort(even_values.begin(), even_values.end());\n    size_t even_idx = 0;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        l[i] = even_values[even_idx++];\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_81", "completion": "```cpp\nstd::vector<float> sort_even(std::vector<float> l) {\n    std::vector<float> even_values;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            even_values.push_back(l[i]);\n        }\n    }\n    std::sort(even_values.begin(), even_values.end());\n    size_t even_idx = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (i % 2 == 0) {\n            l[i] = even_values[even_idx++];\n        }\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_82", "completion": "```cpp\nbool triples_sum_to_zero(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n    std::sort(l.begin(), l.end());\n    for (int i = 0; i < n-2; i++) {\n        if (i > 0 && l[i] == l[i-1]) continue; // Skip duplicate elements\n        int left = i + 1;\n        int right = n - 1;\n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            if (sum == 0) {\n                return true;\n            } else if (sum < 0) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82", "completion": "```cpp\nbool triples_sum_to_zero(std::vector<int> l) {\n    std::sort(l.begin(), l.end());\n    int n = l.size();\n    for (int i = 0; i < n-2; i++) {\n        if (i > 0 && l[i] == l[i-1]) // Skip duplicate elements\n            continue;\n        int j = i+1, k = n-1;\n        while (j < k) {\n            int sum = l[i] + l[j] + l[k];\n            if (sum == 0) {\n                return true;\n            } else if (sum < 0) {\n                j++;\n            } else {\n                k--;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82", "completion": "```cpp\nbool triples_sum_to_zero(std::vector<int> l) {\n    std::sort(l.begin(), l.end());\n    int n = l.size();\n    for (int i = 0; i < n-2; i++) {\n        if (i > 0 && l[i] == l[i-1]) // Skip duplicate elements\n            continue;\n        int j = i+1, k = n-1;\n        while (j < k) {\n            int sum = l[i] + l[j] + l[k];\n            if (sum == 0) {\n                return true;\n            } else if (sum < 0) {\n                j++;\n            } else {\n                k--;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82", "completion": "```cpp\nbool triples_sum_to_zero(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n    std::sort(l.begin(), l.end());\n    for (int i = 0; i < n-2; i++) {\n        if (i > 0 && l[i] == l[i-1]) continue; // Skip duplicate elements\n        int left = i + 1;\n        int right = n - 1;\n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            if (sum == 0) {\n                return true;\n            } else if (sum < 0) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82", "completion": "```cpp\nbool triples_sum_to_zero(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n    std::sort(l.begin(), l.end());\n    for (int i = 0; i < n-2; i++) {\n        if (i > 0 && l[i] == l[i-1]) continue; // Skip duplicate elements\n        int left = i + 1;\n        int right = n - 1;\n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            if (sum == 0) {\n                return true;\n            } else if (sum < 0) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_83", "completion": "```cpp\nstd::vector<int> incr_list(std::vector<int> l){\n    for(auto &x : l) {\n        x += 1;\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_83", "completion": "```cpp\nstd::vector<int> incr_list(std::vector<int> l){\n    for(auto &x : l) {\n        x += 1;\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_83", "completion": "```cpp\nstd::vector<int> incr_list(std::vector<int> l){\n    for(auto &x : l) {\n        x += 1;\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_83", "completion": "```cpp\nstd::vector<int> incr_list(std::vector<int> l){\n    for(auto &x : l) {\n        x += 1;\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_83", "completion": "```cpp\nstd::vector<int> incr_list(std::vector<int> l){\n    for(auto &x : l) {\n        x += 1;\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_84", "completion": "```cpp\nbool pairs_sum_to_zero(std::vector<int> l) {\n    std::unordered_set<int> seen;\n    for (int num : l) {\n        if (seen.find(-num) != seen.end()) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84", "completion": "```cpp\nbool pairs_sum_to_zero(std::vector<int> l) {\n    std::unordered_set<int> seen;\n    for (int num : l) {\n        if (seen.find(-num) != seen.end()) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84", "completion": "```cpp\nbool pairs_sum_to_zero(std::vector<int> l){\n    std::unordered_set<int> seen;\n    for(int num : l){\n        if(seen.find(-num) != seen.end()){\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84", "completion": "```cpp\nbool pairs_sum_to_zero(std::vector<int> l){\n    std::unordered_set<int> seen;\n    for(int num : l){\n        if(seen.find(-num) != seen.end()){\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84", "completion": "```cpp\nbool pairs_sum_to_zero(std::vector<int> l){\n    std::unordered_set<int> seen;\n    for(int num : l){\n        if(seen.find(-num) != seen.end()){\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_85", "completion": "```cpp\nstd::string change_base(int64_t x, int8_t base){\n    if (x == 0) return \"0\";\n    std::string result = \"\";\n    while (x > 0){\n        result = std::to_string(x % base) + result;\n        x /= base;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_85", "completion": "```cpp\nstd::string change_base(int64_t x, int8_t base){\n    if (x == 0) return \"0\";\n    std::string result = \"\";\n    while (x > 0){\n        result = std::to_string(x % base) + result;\n        x /= base;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_85", "completion": "```cpp\nstd::string change_base(int64_t x, int8_t base){\n    if (x == 0) return \"0\";\n    std::string result = \"\";\n    while (x > 0){\n        result = std::to_string(x % base) + result;\n        x /= base;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_85", "completion": "```cpp\nstd::string change_base(int64_t x, int8_t base){\n    if (x == 0) return \"0\";\n    std::string result = \"\";\n    while (x > 0){\n        result = std::to_string(x % base) + result;\n        x /= base;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_85", "completion": "```cpp\nstd::string change_base(int64_t x, int8_t base){\n    if (x == 0) return \"0\";\n    std::string result = \"\";\n    while (x > 0){\n        result = std::to_string(x % base) + result;\n        x /= base;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_86", "completion": "```cpp\nbool is_palindrome(std::string text){\n    int left = 0;\n    int right = text.length() - 1;\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_86", "completion": "```cpp\nbool is_palindrome(std::string text){\n    int left = 0;\n    int right = text.length() - 1;\n    while(left < right){\n        if(text[left] != text[right]){\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_86", "completion": "```cpp\nbool is_palindrome(std::string text){\n    int left = 0;\n    int right = text.length() - 1;\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_86", "completion": "```cpp\nbool is_palindrome(std::string text){\n    int left = 0;\n    int right = text.length() - 1;\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_86", "completion": "```cpp\nbool is_palindrome(std::string text){\n    int left = 0;\n    int right = text.length() - 1;\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_87", "completion": "```cpp\nstd::string decode_shift(std::string s){\n    std::string out;\n    int i;\n    for(i = 0; i < s.length(); i++){\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out = out + (char)w;\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_87", "completion": "```cpp\nstd::string decode_shift(std::string s){\n    std::string out;\n    int i;\n    for(i = 0; i < s.length(); i++){\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out = out + (char)w;\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_87", "completion": "```cpp\nstd::string decode_shift(std::string s){\n    std::string out;\n    int i;\n    for(i = 0; i < s.length(); i++){\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out = out + (char)w;\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_87", "completion": "```cpp\nstd::string decode_shift(std::string s){\n    std::string out;\n    int i;\n    for (i=0; i<s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out += (char)w;\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_87", "completion": "```cpp\nstd::string decode_shift(std::string s){\n    std::string out;\n    int i;\n    for (i=0; i<s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out += (char)w;\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_88", "completion": "```cpp\nbool below_threshold(std::vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88", "completion": "```cpp\nbool below_threshold(std::vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88", "completion": "```cpp\nbool below_threshold(std::vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88", "completion": "```cpp\nbool below_threshold(std::vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88", "completion": "```cpp\nbool below_threshold(std::vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_89", "completion": "```cpp\nbool correct_bracketing(std::string brackets){\n    int balance = 0;\n    for(char ch : brackets){\n        if(ch == '<') balance++;\n        else if(ch == '>') balance--;\n        if(balance < 0) return false;\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89", "completion": "```cpp\nbool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    for (char ch : brackets) {\n        if (ch == '<') {\n            balance++;\n        } else if (ch == '>') {\n            balance--;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89", "completion": "```cpp\nbool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    for (char ch : brackets) {\n        if (ch == '<') {\n            balance++;\n        } else if (ch == '>') {\n            balance--;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89", "completion": "```cpp\nbool correct_bracketing(std::string brackets){\n    int balance = 0;\n    for(char ch : brackets){\n        if(ch == '<') balance++;\n        else if(ch == '>') balance--;\n        if(balance < 0) return false;\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89", "completion": "```cpp\nbool correct_bracketing(std::string brackets){\n    int balance = 0;\n    for(char ch : brackets){\n        if(ch == '<') balance++;\n        else if(ch == '>') balance--;\n        if(balance < 0) return false;\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90", "completion": "```cpp\nbool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    for (char ch : brackets) {\n        if (ch == '(') {\n            balance++;\n        } else if (ch == ')') {\n            balance--;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90", "completion": "```cpp\nbool correct_bracketing(std::string brackets){\n    int balance = 0;\n    for(char ch : brackets){\n        if(ch == '(') balance++;\n        if(ch == ')') balance--;\n        if(balance < 0) return false;\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90", "completion": "```cpp\nbool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    for (char ch : brackets) {\n        if (ch == '(') {\n            balance++;\n        } else if (ch == ')') {\n            balance--;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90", "completion": "```cpp\nbool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    for (char ch : brackets) {\n        if (ch == '(') {\n            balance++;\n        } else if (ch == ')') {\n            balance--;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90", "completion": "```cpp\nbool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    for (char ch : brackets) {\n        if (ch == '(') {\n            balance++;\n        } else if (ch == ')') {\n            balance--;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_91", "completion": "```cpp\nstd::vector<float> derivative(std::vector<float> xs){\n    std::vector<float> result;\n    for(size_t i = 1; i < xs.size(); ++i){\n        result.push_back(xs[i] * static_cast<float>(i));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_91", "completion": "```cpp\nstd::vector<float> derivative(std::vector<float> xs){\n    std::vector<float> result;\n    for(size_t i = 1; i < xs.size(); ++i){\n        result.push_back(xs[i] * static_cast<float>(i));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_91", "completion": "```cpp\nstd::vector<float> derivative(std::vector<float> xs){\n    std::vector<float> result;\n    for(size_t i = 1; i < xs.size(); ++i){\n        result.push_back(xs[i] * static_cast<float>(i));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_91", "completion": "```cpp\nstd::vector<float> derivative(std::vector<float> xs){\n    std::vector<float> result;\n    for(size_t i = 1; i < xs.size(); ++i){\n        result.push_back(xs[i] * static_cast<float>(i));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_91", "completion": "```cpp\nstd::vector<float> derivative(std::vector<float> xs){\n    std::vector<float> result;\n    for(size_t i = 1; i < xs.size(); ++i){\n        result.push_back(xs[i] * static_cast<float>(i));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_92", "completion": "```cpp\nint vowels_count(std::string s){\n    int count = 0;\n    std::string vowels = \"aeiou\";\n    for(int i = 0; i < s.length(); ++i){\n        char c = tolower(s[i]);\n        if(vowels.find(c) != std::string::npos){\n            count++;\n        }\n    }\n    if(s.length() > 0 && tolower(s[s.length()-1]) == 'y'){\n        count++;\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_92", "completion": "```cpp\nint vowels_count(std::string s){\n    int count = 0;\n    std::string vowels = \"aeiou\";\n    for(int i = 0; i < s.length(); ++i){\n        char c = tolower(s[i]);\n        if(vowels.find(c) != std::string::npos){\n            count++;\n        }\n    }\n    if(s.length() > 0 && tolower(s.back()) == 'y'){\n        count++;\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_92", "completion": "```cpp\nint vowels_count(std::string s){\n    int count = 0;\n    std::string vowels = \"aeiou\";\n    for(int i = 0; i < s.length(); ++i){\n        char c = tolower(s[i]);\n        if(vowels.find(c) != std::string::npos){\n            count++;\n        }\n    }\n    if(s.length() > 0 && tolower(s.back()) == 'y'){\n        count++;\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_92", "completion": "```cpp\nint vowels_count(std::string s){\n    int count = 0;\n    std::string vowels = \"aeiou\";\n    for(int i = 0; i < s.length(); ++i){\n        char c = tolower(s[i]);\n        if(vowels.find(c) != std::string::npos){\n            count++;\n        }\n    }\n    if(s.length() > 0 && tolower(s.back()) == 'y'){\n        count++;\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_92", "completion": "```cpp\nint vowels_count(std::string s){\n    int count = 0;\n    std::string vowels = \"aeiou\";\n    for(int i = 0; i < s.length(); ++i){\n        char c = tolower(s[i]);\n        if(vowels.find(c) != std::string::npos){\n            count++;\n        }\n    }\n    if(s.length() > 0 && tolower(s.back()) == 'y'){\n        count++;\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_93", "completion": "```cpp\nint digitSum(std::string s){\n    int sum = 0;\n    for(char c : s){\n        if(c >= 'A' && c <= 'Z'){\n            sum += c;\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93", "completion": "```cpp\nint digitSum(std::string s){\n    int sum = 0;\n    for(char c : s){\n        if(c >= 'A' && c <= 'Z'){\n            sum += c;\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93", "completion": "```cpp\nint digitSum(std::string s){\n    int sum = 0;\n    for(char c : s){\n        if(c >= 'A' && c <= 'Z'){\n            sum += c;\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93", "completion": "```cpp\nint digitSum(std::string s){\n    int sum = 0;\n    for(char c : s){\n        if(c >= 'A' && c <= 'Z'){\n            sum += c;\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93", "completion": "```cpp\nint digitSum(std::string s){\n    int sum = 0;\n    for(char c : s){\n        if(c >= 'A' && c <= 'Z'){\n            sum += c;\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_94", "completion": "```cpp\nstd::vector<int> pluck(std::vector<int> arr) {\n    int min_even = -1;\n    int min_index = -1;\n    for (size_t i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) {\n            if (min_even == -1 || arr[i] < min_even || (arr[i] == min_even && i < min_index)) {\n                min_even = arr[i];\n                min_index = i;\n            }\n        }\n    }\n    if (min_even != -1) {\n        return {min_even, min_index};\n    }\n    return {};\n}\n```"}
{"task_id": "SimdBench_94", "completion": "```cpp\nstd::vector<int> pluck(std::vector<int> arr){\n    int min_even = -1;\n    int min_index = -1;\n    for(int i = 0; i < arr.size(); ++i){\n        if(arr[i] % 2 == 0){\n            if(min_even == -1 || arr[i] < min_even || (arr[i] == min_even && i < min_index)){\n                min_even = arr[i];\n                min_index = i;\n            }\n        }\n    }\n    if(min_even != -1){\n        return {min_even, min_index};\n    }\n    return {};\n}\n```"}
{"task_id": "SimdBench_94", "completion": "```cpp\nstd::vector<int> pluck(std::vector<int> arr) {\n    int min_even = -1;\n    int min_index = -1;\n    for (size_t i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) {\n            if (min_even == -1 || arr[i] < min_even || (arr[i] == min_even && i < min_index)) {\n                min_even = arr[i];\n                min_index = i;\n            }\n        }\n    }\n    if (min_even != -1) {\n        return {min_even, min_index};\n    }\n    return {};\n}\n```"}
{"task_id": "SimdBench_94", "completion": "```cpp\nstd::vector<int> pluck(std::vector<int> arr){\n    int min_even = -1;\n    int min_index = -1;\n    for(int i = 0; i < arr.size(); ++i){\n        if(arr[i] % 2 == 0){\n            if(min_even == -1 || arr[i] < min_even || (arr[i] == min_even && i < min_index)){\n                min_even = arr[i];\n                min_index = i;\n            }\n        }\n    }\n    if(min_even != -1){\n        return {min_even, min_index};\n    }\n    return {};\n}\n```"}
{"task_id": "SimdBench_94", "completion": "```cpp\nstd::vector<int> pluck(std::vector<int> arr) {\n    int min_even = -1;\n    int min_index = -1;\n    for (size_t i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) {\n            if (min_even == -1 || arr[i] < min_even || (arr[i] == min_even && i < min_index)) {\n                min_even = arr[i];\n                min_index = i;\n            }\n        }\n    }\n    if (min_even != -1) {\n        return {min_even, min_index};\n    }\n    return {};\n}\n```"}
{"task_id": "SimdBench_95", "completion": "```cpp\nint search(std::vector<int> lst) {\n    std::unordered_map<int, int> freq;\n    for (int num : lst) {\n        freq[num]++;\n    }\n    int result = -1;\n    for (const auto& [num, count] : freq) {\n        if (num > 0 && count >= num && num > result) {\n            result = num;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_95", "completion": "```cpp\nint search(std::vector<int> lst) {\n    std::unordered_map<int, int> freq;\n    for (int num : lst) {\n        freq[num]++;\n    }\n    int result = -1;\n    for (const auto& entry : freq) {\n        int num = entry.first;\n        int count = entry.second;\n        if (num > 0 && count >= num && num > result) {\n            result = num;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_95", "completion": "```cpp\nint search(std::vector<int> lst) {\n    std::unordered_map<int, int> freq;\n    for (int num : lst) {\n        freq[num]++;\n    }\n    int result = -1;\n    for (const auto& entry : freq) {\n        int num = entry.first;\n        if (num > 0 && freq[num] >= num && num > result) {\n            result = num;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_95", "completion": "```cpp\nint search(std::vector<int> lst) {\n    std::unordered_map<int, int> freq;\n    for (int num : lst) {\n        freq[num]++;\n    }\n    int result = -1;\n    for (const auto& entry : freq) {\n        int num = entry.first;\n        if (num > 0 && freq[num] >= num && num > result) {\n            result = num;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_95", "completion": "```cpp\nint search(std::vector<int> lst) {\n    std::unordered_map<int, int> freq;\n    for (int num : lst) {\n        freq[num]++;\n    }\n    int result = -1;\n    for (const auto& entry : freq) {\n        int num = entry.first;\n        int count = entry.second;\n        if (count >= num && num > 0 && num > result) {\n            result = num;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_96", "completion": "```cpp\nbool will_it_fly(std::vector<int> q, int w) {\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    bool is_palindrome = true;\n    int n = q.size();\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - i - 1]) {\n            is_palindrome = false;\n            break;\n        }\n    }\n    return is_palindrome && sum <= w;\n}\n```"}
{"task_id": "SimdBench_96", "completion": "```cpp\nbool will_it_fly(std::vector<int> q, int w) {\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    bool is_palindrome = true;\n    int n = q.size();\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - i - 1]) {\n            is_palindrome = false;\n            break;\n        }\n    }\n    return (sum <= w) && is_palindrome;\n}\n```"}
{"task_id": "SimdBench_96", "completion": "```cpp\nbool will_it_fly(std::vector<int> q, int w) {\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    bool is_palindrome = true;\n    int n = q.size();\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - i - 1]) {\n            is_palindrome = false;\n            break;\n        }\n    }\n    return is_palindrome && sum <= w;\n}\n```"}
{"task_id": "SimdBench_96", "completion": "```cpp\nbool will_it_fly(std::vector<int> q, int w) {\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    bool is_palindrome = true;\n    int n = q.size();\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - i - 1]) {\n            is_palindrome = false;\n            break;\n        }\n    }\n    return is_palindrome && sum <= w;\n}\n```"}
{"task_id": "SimdBench_96", "completion": "```cpp\nbool will_it_fly(std::vector<int> q, int w) {\n    std::vector<int> reversed_q = q;\n    std::reverse(reversed_q.begin(), reversed_q.end());\n    bool is_balanced = q == reversed_q;\n    int sum = 0;\n    for(int num : q) {\n        sum += num;\n    }\n    return is_balanced && sum <= w;\n}\n```"}
{"task_id": "SimdBench_97", "completion": "```cpp\nint smallest_change(std::vector<int> arr) {\n    int changes = 0;\n    int n = arr.size();\n    for (int i = 0; i < n / 2; ++i) {\n        if (arr[i] != arr[n - i - 1]) {\n            changes++;\n        }\n    }\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97", "completion": "```cpp\nint smallest_change(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    for(int i = 0; i < n / 2; ++i){\n        if(arr[i] != arr[n - i - 1]){\n            changes++;\n        }\n    }\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97", "completion": "```cpp\nint smallest_change(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    for(int i = 0; i < n / 2; ++i){\n        if(arr[i] != arr[n - i - 1]){\n            changes++;\n        }\n    }\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97", "completion": "```cpp\nint smallest_change(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    for(int i = 0; i < n / 2; ++i){\n        if(arr[i] != arr[n - i - 1]){\n            changes++;\n        }\n    }\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97", "completion": "```cpp\nint smallest_change(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    for(int i = 0; i < n / 2; ++i){\n        if(arr[i] != arr[n - i - 1]){\n            changes++;\n        }\n    }\n    return changes;\n}\n```"}
{"task_id": "SimdBench_98", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match(const std::vector<std::string> &lst1, const std::vector<std::string> &lst2) {\n    int total1 = 0;\n    for (const auto &str : lst1) {\n        total1 += str.length();\n    }\n    \n    int total2 = 0;\n    for (const auto &str : lst2) {\n        total2 += str.length();\n    }\n    \n    if (total1 <= total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match(const std::vector<std::string> &lst1, const std::vector<std::string> &lst2) {\n    int total1 = 0;\n    for (const auto &str : lst1) {\n        total1 += str.length();\n    }\n    \n    int total2 = 0;\n    for (const auto &str : lst2) {\n        total2 += str.length();\n    }\n    \n    if (total1 <= total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match(const std::vector<std::string> &lst1, const std::vector<std::string> &lst2) {\n    int total1 = 0;\n    for (const auto &str : lst1) {\n        total1 += str.length();\n    }\n    \n    int total2 = 0;\n    for (const auto &str : lst2) {\n        total2 += str.length();\n    }\n    \n    if (total1 <= total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match(const std::vector<std::string> &lst1, const std::vector<std::string> &lst2) {\n    int sum1 = 0;\n    for (const auto &s : lst1) {\n        sum1 += s.length();\n    }\n    \n    int sum2 = 0;\n    for (const auto &s : lst2) {\n        sum2 += s.length();\n    }\n    \n    if (sum1 <= sum2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match(const std::vector<std::string> &lst1, const std::vector<std::string> &lst2) {\n    int total1 = 0;\n    for (const auto &s : lst1) {\n        total1 += s.length();\n    }\n    \n    int total2 = 0;\n    for (const auto &s : lst2) {\n        total2 += s.length();\n    }\n    \n    if (total1 <= total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_99", "completion": "```cpp\nbool is_simple_power(uint64_t x, uint64_t n){\n    if(n == 1) return x == 1;\n    if(x < n) return false;\n    while(x > 1){\n        if(x % n != 0) return false;\n        x /= n;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_99", "completion": "```cpp\nbool is_simple_power(uint64_t x, uint64_t n){\n    if(n == 1) return x == 1;\n    if(x < n) return false;\n    while(x > 1){\n        if(x % n != 0) return false;\n        x /= n;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_99", "completion": "```cpp\nbool is_simple_power(uint64_t x, uint64_t n){\n    if(n == 1) return x == 1;\n    if(x < n) return false;\n    while(x % n == 0){\n        x /= n;\n    }\n    return x == 1;\n}\n```"}
{"task_id": "SimdBench_99", "completion": "```cpp\nbool is_simple_power(uint64_t x, uint64_t n){\n    if(n == 1) return x == 1;\n    if(x < n) return false;\n    while(x % n == 0){\n        x /= n;\n    }\n    return x == 1;\n}\n```"}
{"task_id": "SimdBench_99", "completion": "```cpp\nbool is_simple_power(uint64_t x, uint64_t n){\n    if(n == 1) return x == 1;\n    if(x < n) return false;\n    while(x % n == 0){\n        x /= n;\n    }\n    return x == 1;\n}\n```"}
{"task_id": "SimdBench_100", "completion": "```cpp\nint hex_key(const std::string & num){\n    int count = 0;\n    for(char c : num){\n        switch(c){\n            case '2':\n            case '3':\n            case '5':\n            case '7':\n            case 'B':\n            case 'D':\n                count++;\n                break;\n            default:\n                break;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_100", "completion": "```cpp\nint hex_key(const std::string & num){\n    int count = 0;\n    for(char c : num){\n        switch(c){\n            case '2':\n            case '3':\n            case '5':\n            case '7':\n            case 'B':\n            case 'D':\n                count++;\n                break;\n            default:\n                break;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_100", "completion": "```cpp\nint hex_key(const std::string & num){\n    int count = 0;\n    for(char c : num){\n        if(c >= '0' && c <= '9'){\n            if(c == '2' || c == '3' || c == '5' || c == '7') count++;\n        }\n        else if(c >= 'A' && c <= 'F'){\n            switch(c){\n                case 'B': case 'D':\n                    count++;\n                    break;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_100", "completion": "```cpp\nint hex_key(const std::string & num){\n    int count = 0;\n    for(char c : num){\n        switch(c){\n            case '2':\n            case '3':\n            case '5':\n            case '7':\n            case 'B':\n            case 'D':\n                count++;\n                break;\n            default:\n                break;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_100", "completion": "```cpp\nint hex_key(const std::string & num){\n    int count = 0;\n    for(char c : num){\n        switch(c){\n            case '2':\n            case '3':\n            case '5':\n            case '7':\n            case 'B':\n            case 'D':\n                count++;\n                break;\n            default:\n                break;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_101", "completion": "```cpp\nbool is_happy(const std::string & s){\n    if (s.length() < 3) return false;\n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_101", "completion": "```cpp\nbool is_happy(const std::string & s){\n    if (s.length() < 3) return false;\n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_101", "completion": "```cpp\nbool is_happy(const std::string & s){\n    if (s.length() < 3) return false;\n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_101", "completion": "```cpp\nbool is_happy(const std::string & s){\n    if (s.length() < 3) return false;\n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_101", "completion": "```cpp\nbool is_happy(const std::string & s){\n    if (s.length() < 3) return false;\n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        char a = s[i];\n        char b = s[i + 1];\n        char c = s[i + 2];\n        if (a == b || b == c || a == c) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_102", "completion": "```cpp\nbool prime_length(const std::string & str){\n    int len = str.length();\n    if(len < 2) return false;\n    for(int i = 2; i * i <= len; ++i){\n        if(len % i == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_102", "completion": "```cpp\nbool prime_length(const std::string & str){\n    int len = str.length();\n    if(len < 2) return false;\n    for(int i = 2; i * i <= len; ++i){\n        if(len % i == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_102", "completion": "```cpp\nbool prime_length(const std::string & str){\n    int len = str.length();\n    if(len < 2) return false;\n    for(int i = 2; i * i <= len; ++i){\n        if(len % i == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_102", "completion": "```cpp\nbool prime_length(const std::string & str){\n    int len = str.length();\n    if(len < 2) return false;\n    for(int i = 2; i * i <= len; ++i){\n        if(len % i == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_102", "completion": "```cpp\nbool prime_length(const std::string & str){\n    int len = str.length();\n    if(len < 2) return false;\n    for(int i = 2; i * i <= len; ++i){\n        if(len % i == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_103", "completion": "```cpp\nstd::string solve(uint64_t N){\n    int sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n    return std::bitset<64>(sum).to_string();\n}\n```"}
{"task_id": "SimdBench_103", "completion": "```cpp\nstd::string solve(uint64_t N){\n    int sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n    return std::bitset<64>(sum).to_string();\n}\n```"}
{"task_id": "SimdBench_103", "completion": "```cpp\nstd::string solve(uint64_t N){\n    int sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n    return std::bitset<64>(sum).to_string();\n}\n```"}
{"task_id": "SimdBench_103", "completion": "```cpp\nstd::string solve(uint64_t N){\n    int sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n    return std::bitset<64>(sum).to_string();\n}\n```"}
{"task_id": "SimdBench_103", "completion": "```cpp\nstd::string solve(uint64_t N){\n    int sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n    return std::bitset<64>(sum).to_string();\n}\n```"}
{"task_id": "SimdBench_104", "completion": "```cpp\nint add(std::vector<int> lst){\n    int sum = 0;\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104", "completion": "```cpp\nint add(std::vector<int> lst){\n    int sum = 0;\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104", "completion": "```cpp\nint add(std::vector<int> lst){\n    int sum = 0;\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104", "completion": "```cpp\nint add(std::vector<int> lst){\n    int sum = 0;\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104", "completion": "```cpp\nint add(std::vector<int> lst){\n    int sum = 0;\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_105", "completion": "```cpp\nstd::string encrypt(const std::string & s) {\n    std::string result = s;\n    for (char &c : result) {\n        if (c >= 'a' && c <= 'z') {\n            c = 'a' + (c - 'a' + 4) % 26;\n        } else if (c >= 'A' && c <= 'Z') {\n            c = 'A' + (c - 'A' + 4) % 26;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_105", "completion": "```cpp\nstd::string encrypt(const std::string & s) {\n    std::string result = s;\n    for (char &c : result) {\n        if (c >= 'a' && c <= 'z') {\n            c = 'a' + (c - 'a' + 4) % 26;\n        } else if (c >= 'A' && c <= 'Z') {\n            c = 'A' + (c - 'A' + 4) % 26;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_105", "completion": "```cpp\nstd::string encrypt(const std::string & s) {\n    std::string result = s;\n    for (char &c : result) {\n        if (c >= 'a' && c <= 'z') {\n            c = 'a' + (c - 'a' + 4) % 26;\n        } else if (c >= 'A' && c <= 'Z') {\n            c = 'A' + (c - 'A' + 4) % 26;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_105", "completion": "```cpp\nstd::string encrypt(const std::string & s) {\n    std::string result = s;\n    for (char &c : result) {\n        if (c >= 'a' && c <= 'z') {\n            c = 'a' + (c - 'a' + 4) % 26;\n        } else if (c >= 'A' && c <= 'Z') {\n            c = 'A' + (c - 'A' + 4) % 26;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_105", "completion": "```cpp\nstd::string encrypt(const std::string & s){\n    std::string result = s;\n    for(char & c : result){\n        if(c >= 'a' && c <= 'z'){\n            c = 'a' + (c - 'a' + 4) % 26;\n        }\n        else if(c >= 'A' && c <= 'Z'){\n            c = 'A' + (c - 'A' + 4) % 26;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_106", "completion": "```cpp\nstd::string encode(const std::string & message) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result;\n    for (char c : message) {\n        if (isalpha(c)) {\n            // Swap case\n            char swapped = islower(c) ? toupper(c) : tolower(c);\n            // Replace vowel with letter 2 places ahead\n            size_t pos = vowels.find(swapped);\n            if (pos != std::string::npos) {\n                swapped = vowels[(pos + 2) % vowels.size()];\n            }\n            result += swapped;\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_106", "completion": "```cpp\nstd::string encode(const std::string & message) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result;\n    for (char c : message) {\n        if (isalpha(c)) {\n            // Swap case\n            char swapped = islower(c) ? toupper(c) : tolower(c);\n            // Replace vowel with letter 2 places ahead\n            size_t pos = vowels.find(swapped);\n            if (pos != std::string::npos) {\n                swapped = vowels[(pos + 2) % vowels.size()];\n            }\n            result += swapped;\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_106", "completion": "```cpp\nstd::string encode(const std::string & message) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result;\n    for (char c : message) {\n        if (isalpha(c)) {\n            // Swap case\n            char swapped = islower(c) ? toupper(c) : tolower(c);\n            // Replace vowel with letter 2 places ahead\n            size_t pos = vowels.find(swapped);\n            if (pos != std::string::npos) {\n                swapped = vowels[(pos + 2) % vowels.size()];\n            }\n            result += swapped;\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_106", "completion": "```cpp\nstd::string encode(const std::string & message) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result;\n    for (char c : message) {\n        if (isalpha(c)) {\n            // Swap case\n            char swapped = islower(c) ? toupper(c) : tolower(c);\n            // Replace vowel with letter 2 places ahead\n            size_t pos = vowels.find(swapped);\n            if (pos != std::string::npos) {\n                swapped = vowels[(pos + 2) % vowels.size()];\n            }\n            result += swapped;\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_106", "completion": "```cpp\nstd::string encode(const std::string & message) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string result;\n    for (char c : message) {\n        if (isalpha(c)) {\n            // Swap case\n            char swapped = islower(c) ? toupper(c) : tolower(c);\n            // Replace vowel with letter 2 places ahead\n            size_t pos = vowels.find(swapped);\n            if (pos != std::string::npos) {\n                swapped = vowels[(pos + 2) % vowels.size()];\n            }\n            result += swapped;\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_107", "completion": "```cpp\nbool check_dict_case(std::map<std::string, std::string> dict){\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for(const auto& pair : dict){\n        const std::string& key = pair.first;\n        for(char c : key){\n            if(c >= 'A' && c <= 'Z') all_lower = false;\n            if(c >= 'a' && c <= 'z') all_upper = false;\n        }\n        if(!all_lower && !all_upper) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_107", "completion": "```cpp\nbool check_dict_case(std::map<std::string, std::string> dict){\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for(const auto& pair : dict){\n        const std::string& key = pair.first;\n        for(char c : key){\n            if(!std::islower(c)){\n                all_lower = false;\n            }\n            if(!std::isupper(c)){\n                all_upper = false;\n            }\n            if(!all_lower && !all_upper){\n                return false;\n            }\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107", "completion": "```cpp\nbool check_dict_case(std::map<std::string, std::string> dict){\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for(const auto& pair : dict){\n        const std::string& key = pair.first;\n        for(char c : key){\n            if(c >= 'A' && c <= 'Z') all_lower = false;\n            if(c >= 'a' && c <= 'z') all_upper = false;\n        }\n        if(!all_lower && !all_upper) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_107", "completion": "```cpp\nbool check_dict_case(std::map<std::string, std::string> dict){\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for(const auto& pair : dict){\n        const std::string& key = pair.first;\n        for(char c : key){\n            if(!std::islower(c)){\n                all_lower = false;\n            }\n            if(!std::isupper(c)){\n                all_upper = false;\n            }\n            if(!all_lower && !all_upper){\n                return false;\n            }\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107", "completion": "```cpp\nbool check_dict_case(std::map<std::string, std::string> dict){\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for(const auto& pair : dict){\n        const std::string& key = pair.first;\n        for(char c : key){\n            if(!std::islower(c)){\n                all_lower = false;\n            }\n            if(!std::isupper(c)){\n                all_upper = false;\n            }\n            if(!all_lower && !all_upper){\n                return false;\n            }\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_108", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> count_up_to(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n\n    for (int i = 2; i < n; ++i) {\n        bool is_prime = true;\n        for (int j = 2; j * j <= i; ++j) {\n            if (i % j == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if (is_prime) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> count_up_to(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n\n    for (int i = 2; i < n; ++i) {\n        bool is_prime = true;\n        for (int j = 2; j * j <= i; ++j) {\n            if (i % j == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if (is_prime) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> count_up_to(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n\n    for (int i = 2; i < n; ++i) {\n        bool is_prime = true;\n        for (int j = 2; j * j <= i; ++j) {\n            if (i % j == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if (is_prime) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> count_up_to(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n\n    for (int i = 2; i < n; ++i) {\n        bool is_prime = true;\n        for (int j = 2; j * j <= i; ++j) {\n            if (i % j == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if (is_prime) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> count_up_to(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n\n    for (int i = 2; i < n; ++i) {\n        bool is_prime = true;\n        for (int j = 2; j * j <= i; ++j) {\n            if (i % j == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if (is_prime) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n```"}
{"task_id": "SimdBench_109", "completion": "```cpp\nint count_upper(const std::string & s){\n    int count = 0;\n    std::string vowels = \"AEIOU\";\n    for (size_t i = 0; i < s.size(); ++i) {\n        if (i % 2 == 0 && vowels.find(s[i]) != std::string::npos) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_109", "completion": "```cpp\nint count_upper(const std::string & s){\n    int count = 0;\n    std::string vowels = \"AEIOU\";\n    for (size_t i = 0; i < s.size(); ++i) {\n        if (i % 2 == 0 && vowels.find(s[i]) != std::string::npos) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_109", "completion": "```cpp\nint count_upper(const std::string & s){\n    int count = 0;\n    std::string vowels = \"AEIOU\";\n    for (size_t i = 0; i < s.size(); ++i) {\n        if (i % 2 == 0 && vowels.find(s[i]) != std::string::npos) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_109", "completion": "```cpp\nint count_upper(const std::string & s){\n    int count = 0;\n    std::string vowels = \"AEIOU\";\n    for (size_t i = 0; i < s.size(); ++i) {\n        if (i % 2 == 0 && vowels.find(s[i]) != std::string::npos) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_109", "completion": "```cpp\nint count_upper(const std::string & s){\n    int count = 0;\n    std::string vowels = \"AEIOU\";\n    for (size_t i = 0; i < s.size(); ++i) {\n        if (i % 2 == 0 && vowels.find(s[i]) != std::string::npos) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_110", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> make_a_pile(int n) {\n    std::vector<int> pile;\n    int current = n;\n    for (int i = 0; i < n; ++i) {\n        pile.push_back(current);\n        if (current % 2 == 0) {\n            current += 2;\n        } else {\n            current += 2;\n        }\n    }\n    return pile;\n}\n```"}
{"task_id": "SimdBench_110", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> make_a_pile(int n) {\n    std::vector<int> pile;\n    int current = n;\n    for (int i = 0; i < n; ++i) {\n        pile.push_back(current);\n        if (current % 2 == 0) {\n            current += 2;\n        } else {\n            current += 2;\n        }\n    }\n    return pile;\n}\n```"}
{"task_id": "SimdBench_110", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> make_a_pile(int n) {\n    std::vector<int> pile;\n    int current = n;\n    for (int i = 0; i < n; ++i) {\n        pile.push_back(current);\n        if (current % 2 == 0) {\n            current += 2;\n        } else {\n            current += 2;\n        }\n    }\n    return pile;\n}\n```"}
{"task_id": "SimdBench_110", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> make_a_pile(int n) {\n    std::vector<int> pile;\n    int current = n;\n    for (int i = 0; i < n; ++i) {\n        pile.push_back(current);\n        if (current % 2 == 0) {\n            current += 2;\n        } else {\n            current += 2;\n        }\n    }\n    return pile;\n}\n```"}
{"task_id": "SimdBench_110", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> make_a_pile(int n) {\n    std::vector<int> pile;\n    int current = n;\n    for (int i = 0; i < n; ++i) {\n        pile.push_back(current);\n        if (current % 2 == 0) {\n            current += 2;\n        } else {\n            current += 2;\n        }\n    }\n    return pile;\n}\n```"}
{"task_id": "SimdBench_111", "completion": "```cpp\n#include <cmath>\n#include <string>\n\nstd::string rounded_avg(int64_t n, int64_t m){\n    if (n > m) return \"-1\";\n    long long sum = 0;\n    for(int64_t i = n; i <= m; ++i){\n        sum += i;\n    }\n    long long count = m - n + 1;\n    long long avg = round((double)sum / count);\n    return std::bitset<64>(avg).to_string().substr(64 - count_digits(avg));\n}\n\nint count_digits(long long num){\n    int digits = 0;\n    while(num > 0){\n        num /= 10;\n        digits++;\n    }\n    return digits;\n}\n```"}
{"task_id": "SimdBench_111", "completion": "```cpp\nstd::string rounded_avg(int64_t n, int64_t m){\n    if(n > m){\n        return \"-1\";\n    }\n    long long sum = 0;\n    for(int64_t i = n; i <= m; ++i){\n        sum += i;\n    }\n    long long count = m - n + 1;\n    long long avg = sum / count;\n    if((sum % count) * 2 >= count){\n        avg += 1;\n    }\n    return std::bitset<64>(avg).to_string();\n}\n```"}
{"task_id": "SimdBench_111", "completion": "```cpp\nstd::string rounded_avg(int64_t n, int64_t m){\n    if(n > m){\n        return \"-1\";\n    }\n    long long sum = 0;\n    for(int64_t i = n; i <= m; ++i){\n        sum += i;\n    }\n    long long count = m - n + 1;\n    long long avg = sum / count;\n    if((sum % count) * 2 >= count){\n        avg += 1;\n    }\n    return std::bitset<64>(avg).to_string();\n}\n```"}
{"task_id": "SimdBench_111", "completion": "```cpp\nstd::string rounded_avg(int64_t n, int64_t m){\n    if(n > m){\n        return \"-1\";\n    }\n    int64_t sum = 0;\n    for(int64_t i = n; i <= m; ++i){\n        sum += i;\n    }\n    int count = m - n + 1;\n    int avg = sum / count;\n    if((sum % count) * 2 >= count){\n        avg += 1;\n    }\n    return std::bitset<64>(avg).to_string();\n}\n```"}
{"task_id": "SimdBench_111", "completion": "```cpp\n#include <cmath>\n#include <string>\n\nstd::string rounded_avg(int64_t n, int64_t m){\n    if (n > m) {\n        return \"-1\";\n    }\n    long long sum = 0;\n    for (int64_t i = n; i <= m; ++i) {\n        sum += i;\n    }\n    long long count = m - n + 1;\n    long long average = round((double)sum / count);\n    return std::bitset<64>(average).to_string().substr(64 - count_digits(average));\n}\n\nint count_digits(long long num) {\n    int digits = 0;\n    while (num > 0) {\n        num /= 10;\n        digits++;\n    }\n    return digits;\n}\n```"}
{"task_id": "SimdBench_112", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> func(int n) {\n    std::vector<int> result;\n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            int sum = (i * (i + 1)) / 2;\n            result.push_back(sum);\n        } else {\n            int factorial = 1;\n            for (int j = 1; j <= i; ++j) {\n                factorial *= j;\n            }\n            result.push_back(factorial % 10000);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_112", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> func(int n) {\n    std::vector<int> result;\n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            // Sum of numbers from 1 to i\n            int sum = (i * (i + 1)) / 2;\n            result.push_back(sum);\n        } else {\n            // Factorial of i modulo 10,000\n            long long fact = 1;\n            for (int j = 1; j <= i; ++j) {\n                fact *= j;\n                fact %= 10000;\n            }\n            result.push_back(fact);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_112", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> func(int n) {\n    std::vector<int> result;\n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            int sum = (i * (i + 1)) / 2;\n            result.push_back(sum);\n        } else {\n            int factorial = 1;\n            for (int j = 1; j <= i; ++j) {\n                factorial *= j;\n                factorial %= 10000;\n            }\n            result.push_back(factorial);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_112", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> func(int n) {\n    std::vector<int> result;\n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            // Sum of numbers from 1 to i\n            int sum = (i * (i + 1)) / 2;\n            result.push_back(sum);\n        } else {\n            // Factorial of i modulo 10,000\n            long long fact = 1;\n            for (int j = 1; j <= i; ++j) {\n                fact *= j;\n                fact %= 10000;\n            }\n            result.push_back(fact);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_112", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> func(int n) {\n    std::vector<int> result;\n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            // Sum of numbers from 1 to i\n            int sum = (i * (i + 1)) / 2;\n            result.push_back(sum);\n        } else {\n            // Factorial of i modulo 10,000\n            long long fact = 1;\n            for (int j = 1; j <= i; ++j) {\n                fact *= j;\n                fact %= 10000;\n            }\n            result.push_back(fact);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_113", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> even_odd_palindrome(int n) {\n    int even = 0;\n    int odd = 0;\n    for (int i = 1; i <= n; ++i) {\n        int temp = i;\n        int reversed = 0;\n        while (temp > 0) {\n            reversed = reversed * 10 + (temp % 10);\n            temp /= 10;\n        }\n        if (reversed == i) {\n            if (i % 2 == 0) {\n                even++;\n            } else {\n                odd++;\n            }\n        }\n    }\n    return {even, odd};\n}\n```"}
{"task_id": "SimdBench_113", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> even_odd_palindrome(int n) {\n    int even = 0, odd = 0;\n    for (int i = 1; i <= n; ++i) {\n        int temp = i;\n        int reversed = 0;\n        while (temp > 0) {\n            reversed = reversed * 10 + (temp % 10);\n            temp /= 10;\n        }\n        if (reversed == i) {\n            if (i % 2 == 0) {\n                even++;\n            } else {\n                odd++;\n            }\n        }\n    }\n    return {even, odd};\n}\n```"}
{"task_id": "SimdBench_113", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> even_odd_palindrome(int n) {\n    int even = 0, odd = 0;\n    for (int i = 1; i <= n; ++i) {\n        int temp = i;\n        int reversed = 0;\n        while (temp > 0) {\n            reversed = reversed * 10 + (temp % 10);\n            temp /= 10;\n        }\n        if (reversed == i) {\n            if (i % 2 == 0) {\n                even++;\n            } else {\n                odd++;\n            }\n        }\n    }\n    return {even, odd};\n}\n```"}
{"task_id": "SimdBench_113", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> even_odd_palindrome(int n) {\n    int even = 0, odd = 0;\n    for (int i = 1; i <= n; ++i) {\n        int temp = i;\n        int reversed = 0;\n        while (temp > 0) {\n            reversed = reversed * 10 + (temp % 10);\n            temp /= 10;\n        }\n        if (reversed == i) {\n            if (i % 2 == 0) {\n                even++;\n            } else {\n                odd++;\n            }\n        }\n    }\n    return {even, odd};\n}\n```"}
{"task_id": "SimdBench_113", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> even_odd_palindrome(int n) {\n    int even = 0, odd = 0;\n    for (int i = 1; i <= n; ++i) {\n        int temp = i;\n        int reversed = 0;\n        while (temp > 0) {\n            reversed = reversed * 10 + (temp % 10);\n            temp /= 10;\n        }\n        if (reversed == i) {\n            if (i % 2 == 0) {\n                even++;\n            } else {\n                odd++;\n            }\n        }\n    }\n    return {even, odd};\n}\n```"}
{"task_id": "SimdBench_114", "completion": "```cpp\nint count_nums(std::vector<int> n){\n    int count = 0;\n    for(int num : n){\n        int sum = 0;\n        int abs_num = std::abs(num);\n        while(abs_num > 0){\n            sum += abs_num % 10;\n            abs_num /= 10;\n        }\n        if(sum > 0) count++;\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_114", "completion": "```cpp\nint count_nums(std::vector<int> n){\n    int count = 0;\n    for(int num : n){\n        int temp = abs(num);\n        int sum = 0;\n        while(temp > 0){\n            sum += temp % 10;\n            temp /= 10;\n        }\n        if(num < 0 && (num % 10) < 0) sum -= 2 * (num % 10);\n        if(sum > 0) count++;\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_114", "completion": "```cpp\nint count_nums(std::vector<int> n){\n    int count = 0;\n    for(int num : n){\n        int temp = abs(num);\n        int sum = 0;\n        while(temp > 0){\n            sum += temp % 10;\n            temp /= 10;\n        }\n        if(num < 0 && (num % 10) < 0){\n            sum -= 2 * (abs(num % 10));\n        }\n        if(sum > 0){\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_114", "completion": "```cpp\nint count_nums(std::vector<int> n){\n    int count = 0;\n    for(int num : n){\n        int temp = abs(num);\n        int sum = 0;\n        while(temp > 0){\n            sum += (temp % 10) * (num < 0 ? -1 : 1);\n            temp /= 10;\n        }\n        if(sum > 0){\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_114", "completion": "```cpp\nint count_nums(std::vector<int> n){\n    int count = 0;\n    for(int num : n){\n        int temp = abs(num);\n        int sum = 0;\n        while(temp > 0){\n            sum += (temp % 10) * (num < 0 ? -1 : 1);\n            temp /= 10;\n        }\n        if(sum > 0){\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_115", "completion": "```cpp\nbool move_one_ball(std::vector<int> arr) {\n    if (arr.empty()) return true;\n    int count = 0;\n    for (size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            count++;\n            if (count > 1) return false;\n            if (i > 1 && arr[i] > arr[0]) return false;\n        }\n    }\n    return count == 0 || arr[arr.size() - 1] <= arr[0];\n}\n```"}
{"task_id": "SimdBench_115", "completion": "```cpp\nbool move_one_ball(std::vector<int> arr) {\n    if (arr.empty()) return true;\n    int count = 0;\n    for (size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            count++;\n            if (count > 1) return false;\n            if (arr[i] > arr[0] || arr[arr.size() - 1] > arr[0]) return false;\n        }\n    }\n    return count == 0 || (arr[arr.size() - 1] <= arr[0]);\n}\n```"}
{"task_id": "SimdBench_115", "completion": "```cpp\nbool move_one_ball(std::vector<int> arr) {\n    if (arr.empty()) return true;\n    int count = 0;\n    for (size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            count++;\n            if (count > 1) return false;\n            if (i > 1 && arr[i] > arr[0]) return false;\n        }\n    }\n    return count == 0 || arr[arr.size() - 1] <= arr[0];\n}\n```"}
{"task_id": "SimdBench_115", "completion": "```cpp\nbool move_one_ball(std::vector<int> arr) {\n    if (arr.empty()) return true;\n    int count = 0;\n    int n = arr.size();\n    for (int i = 1; i < n; ++i) {\n        if (arr[i] < arr[i - 1]) {\n            count++;\n            if (count > 1) return false;\n            if (arr[i] > arr[0] || arr[n - 1] > arr[0]) return false;\n        }\n    }\n    return count == 0 || (arr[n - 1] <= arr[0]);\n}\n```"}
{"task_id": "SimdBench_115", "completion": "```cpp\nbool move_one_ball(std::vector<int> arr) {\n    if (arr.empty()) return true;\n    int count = 0;\n    int n = arr.size();\n    for (int i = 1; i < n; ++i) {\n        if (arr[i] < arr[i - 1]) {\n            count++;\n            if (count > 1) return false;\n            if (arr[i] > arr[0] || arr[n - 1] > arr[0]) return false;\n        }\n    }\n    return count == 0 || (arr[n - 1] <= arr[0]);\n}\n```"}
{"task_id": "SimdBench_116", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::string myexchange(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int odd_in_lst1 = 0;\n    int even_in_lst2 = 0;\n\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            odd_in_lst1++;\n        }\n    }\n\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            even_in_lst2++;\n        }\n    }\n\n    return (even_in_lst2 >= odd_in_lst1) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116", "completion": "```cpp\nstd::string myexchange(const std::vector<int>& lst1, const std::vector<int>& lst2){\n    int odd_in_lst1 = 0;\n    int even_in_lst2 = 0;\n\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            odd_in_lst1++;\n        }\n    }\n\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            even_in_lst2++;\n        }\n    }\n\n    return (even_in_lst2 >= odd_in_lst1) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116", "completion": "```cpp\nstd::string myexchange(const std::vector<int>& lst1, const std::vector<int>& lst2){\n    int odd_in_lst1 = 0;\n    int even_in_lst2 = 0;\n\n    for(auto num : lst1) {\n        if(num % 2 != 0) {\n            odd_in_lst1++;\n        }\n    }\n\n    for(auto num : lst2) {\n        if(num % 2 == 0) {\n            even_in_lst2++;\n        }\n    }\n\n    return (even_in_lst2 >= odd_in_lst1) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::string myexchange(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int odd_in_lst1 = 0;\n    int even_in_lst2 = 0;\n\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            odd_in_lst1++;\n        }\n    }\n\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            even_in_lst2++;\n        }\n    }\n\n    return (even_in_lst2 >= odd_in_lst1) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::string myexchange(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int odd_in_lst1 = 0;\n    int even_in_lst2 = 0;\n\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            odd_in_lst1++;\n        }\n    }\n\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            even_in_lst2++;\n        }\n    }\n\n    return (even_in_lst2 >= odd_in_lst1) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_117", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count(const std::vector<std::string> &lst) {\n    std::vector<std::string> result;\n    for (const auto &s : lst) {\n        int count = 0;\n        for (char c : s) {\n            if ((c - '0') % 2 != 0) {\n                count++;\n            }\n        }\n        std::string replacement = \"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\";\n        result.push_back(replacement);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count(const std::vector<std::string> &lst) {\n    std::vector<std::string> result;\n    for (const auto &s : lst) {\n        int count = 0;\n        for (char c : s) {\n            if ((c - '0') % 2 != 0) {\n                count++;\n            }\n        }\n        std::string replacement = \"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\";\n        result.push_back(replacement);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count(const std::vector<std::string> &lst) {\n    std::vector<std::string> result;\n    for (const auto &s : lst) {\n        int count = 0;\n        for (char c : s) {\n            if ((c - '0') % 2 != 0) {\n                count++;\n            }\n        }\n        std::string replacement = \"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\";\n        result.push_back(replacement);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count(const std::vector<std::string> &lst) {\n    std::vector<std::string> result;\n    for (const auto &s : lst) {\n        int count = 0;\n        for (char c : s) {\n            if ((c - '0') % 2 != 0) {\n                count++;\n            }\n        }\n        std::string replacement = \"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\";\n        result.push_back(replacement);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count(const std::vector<std::string> &lst) {\n    std::vector<std::string> result;\n    for (const auto &s : lst) {\n        int count = 0;\n        for (char c : s) {\n            if ((c - '0') % 2 != 0) {\n                count++;\n            }\n        }\n        std::string replacement = \"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\";\n        result.push_back(replacement);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_118", "completion": "```cpp\nint64_t minSubArraySum(const std::vector<int64_t>& nums) {\n    if (nums.empty()) return 0;\n    int64_t min_sum = nums[0];\n    int64_t current_sum = nums[0];\n    for (size_t i = 1; i < nums.size(); ++i) {\n        current_sum = std::min(nums[i], current_sum + nums[i]);\n        min_sum = std::min(min_sum, current_sum);\n    }\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118", "completion": "```cpp\nint64_t minSubArraySum(const std::vector<int64_t>& nums) {\n    if (nums.empty()) return 0;\n    int64_t min_sum = nums[0];\n    int64_t current_sum = nums[0];\n    for (size_t i = 1; i < nums.size(); ++i) {\n        current_sum = std::min(nums[i], current_sum + nums[i]);\n        min_sum = std::min(min_sum, current_sum);\n    }\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118", "completion": "```cpp\nint64_t minSubArraySum(const std::vector<int64_t>& nums) {\n    if (nums.empty()) return 0;\n    int64_t min_sum = nums[0];\n    int64_t current_sum = nums[0];\n    for (size_t i = 1; i < nums.size(); ++i) {\n        current_sum = std::min(nums[i], current_sum + nums[i]);\n        min_sum = std::min(min_sum, current_sum);\n    }\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118", "completion": "```cpp\nint64_t minSubArraySum(const std::vector<int64_t>& nums) {\n    if (nums.empty()) return 0;\n    int64_t min_sum = nums[0];\n    int64_t current_sum = nums[0];\n    for (size_t i = 1; i < nums.size(); ++i) {\n        current_sum = std::min(nums[i], current_sum + nums[i]);\n        min_sum = std::min(min_sum, current_sum);\n    }\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118", "completion": "```cpp\nint64_t minSubArraySum(const std::vector<int64_t>& nums) {\n    if (nums.empty()) return 0;\n    int64_t min_sum = nums[0];\n    int64_t current_sum = nums[0];\n    for (size_t i = 1; i < nums.size(); ++i) {\n        current_sum = std::min(nums[i], current_sum + nums[i]);\n        min_sum = std::min(min_sum, current_sum);\n    }\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_119", "completion": "```cpp\nint max_fill(const std::vector<std::vector<int> > & grid, int capacity){\n    long long total_trips = 0;\n    for(const auto & well : grid){\n        long long water_units = 0;\n        for(int unit : well){\n            water_units += unit;\n        }\n        long long trips_for_well = (water_units + capacity - 1) / capacity;\n        total_trips += trips_for_well;\n    }\n    return total_trips;\n}\n```"}
{"task_id": "SimdBench_119", "completion": "```cpp\nint max_fill(const std::vector<std::vector<int> > & grid, int capacity){\n    long long total_trips = 0;\n    for(const auto & well : grid){\n        long long water_units = 0;\n        for(auto unit : well){\n            water_units += unit;\n        }\n        if(water_units > 0){\n            total_trips += (water_units + capacity - 1) / capacity;\n        }\n    }\n    return total_trips;\n}\n```"}
{"task_id": "SimdBench_119", "completion": "```cpp\nint max_fill(const std::vector<std::vector<int> > & grid, int capacity){\n    long long total = 0;\n    for(const auto & well : grid){\n        long long sum = 0;\n        for(int unit : well){\n            sum += unit;\n        }\n        total += (sum + capacity - 1) / capacity;\n    }\n    return total;\n}\n```"}
{"task_id": "SimdBench_119", "completion": "```cpp\nint max_fill(const std::vector<std::vector<int> > & grid, int capacity) {\n    long long total_trips = 0;\n    for (const auto &well : grid) {\n        long long water_units = 0;\n        for (int unit : well) {\n            water_units += unit;\n        }\n        if (water_units > 0) {\n            long long trips_for_well = (water_units + capacity - 1) / capacity;\n            total_trips += trips_for_well;\n        }\n    }\n    return static_cast<int>(total_trips);\n}\n```"}
{"task_id": "SimdBench_119", "completion": "```cpp\nint max_fill(const std::vector<std::vector<int> > & grid, int capacity) {\n    long long total_trips = 0;\n    for (const auto &well : grid) {\n        long long water_units = 0;\n        for (int unit : well) {\n            water_units += unit;\n        }\n        if (water_units > 0) {\n            long long trips_for_well = (water_units + capacity - 1) / capacity;\n            total_trips += trips_for_well;\n        }\n    }\n    return static_cast<int>(total_trips);\n}\n```"}
{"task_id": "SimdBench_120", "completion": "```cpp\nint64_t solution(const std::vector<int16_t>& lst){\n    int64_t sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120", "completion": "```cpp\nint64_t solution(const std::vector<int16_t>& lst){\n    int64_t sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120", "completion": "```cpp\nint64_t solution(const std::vector<int16_t>& lst){\n    int64_t sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120", "completion": "```cpp\nint64_t solution(const std::vector<int16_t>& lst){\n    int64_t sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120", "completion": "```cpp\nint64_t solution(const std::vector<int16_t>& lst){\n    int64_t sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121", "completion": "```cpp\nint add_elements(std::vector<int> arr, int k){\n    int sum = 0;\n    for(int i = 0; i < k && i < arr.size(); ++i){\n        if(arr[i] >= -99 && arr[i] <= 99){\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121", "completion": "```cpp\nint add_elements(std::vector<int> arr, int k){\n    int sum = 0;\n    for(int i = 0; i < k && i < arr.size(); ++i){\n        if(arr[i] >= -99 && arr[i] <= 99){\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121", "completion": "```cpp\nint add_elements(std::vector<int> arr, int k){\n    int sum = 0;\n    for(int i = 0; i < k && i < arr.size(); ++i){\n        if(arr[i] >= -99 && arr[i] <= 99){\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121", "completion": "```cpp\nint add_elements(std::vector<int> arr, int k){\n    int sum = 0;\n    for(int i = 0; i < k && i < arr.size(); ++i){\n        if(arr[i] >= -99 && arr[i] <= 99){\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121", "completion": "```cpp\nint add_elements(std::vector<int> arr, int k){\n    int sum = 0;\n    for(int i = 0; i < k && i < arr.size(); ++i){\n        if(arr[i] >= -99 && arr[i] <= 99){\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_122", "completion": "```cpp\nbool is_sorted(const std::vector<int> & lst){\n    if (lst.size() <= 1) {\n        return true;\n    }\n    \n    for (size_t i = 1; i < lst.size(); ++i) {\n        if (lst[i] < lst[i - 1]) {\n            return false;\n        }\n        if (lst[i] == lst[i - 1] && i > 1 && lst[i] == lst[i - 2]) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_122", "completion": "```cpp\nbool is_sorted(const std::vector<int> & lst){\n    if (lst.size() <= 1) {\n        return true;\n    }\n    for (size_t i = 1; i < lst.size(); ++i) {\n        if (lst[i] < lst[i - 1]) {\n            return false;\n        }\n        if (lst[i] == lst[i - 1]) {\n            size_t count = 1;\n            while (i + 1 < lst.size() && lst[i] == lst[i + 1]) {\n                count++;\n                i++;\n            }\n            if (count > 2) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_122", "completion": "```cpp\nbool is_sorted(const std::vector<int> & lst){\n    if (lst.size() <= 1) {\n        return true;\n    }\n    \n    for (size_t i = 1; i < lst.size(); ++i) {\n        if (lst[i] < lst[i - 1]) {\n            return false;\n        }\n        if (lst[i] == lst[i - 1]) {\n            size_t count = 1;\n            while (i + 1 < lst.size() && lst[i] == lst[i + 1]) {\n                count++;\n                i++;\n            }\n            if (count > 2) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_122", "completion": "```cpp\nbool is_sorted(const std::vector<int> & lst){\n    if (lst.size() <= 1) {\n        return true;\n    }\n    \n    for (size_t i = 1; i < lst.size(); ++i) {\n        if (lst[i] < lst[i - 1]) {\n            return false;\n        }\n        if (lst[i] == lst[i - 1]) {\n            size_t count = 1;\n            while (i + 1 < lst.size() && lst[i] == lst[i + 1]) {\n                count++;\n                i++;\n            }\n            if (count > 2) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_122", "completion": "```cpp\nbool is_sorted(const std::vector<int> & lst){\n    if (lst.size() <= 1) {\n        return true;\n    }\n    for (size_t i = 1; i < lst.size(); ++i) {\n        if (lst[i] < lst[i - 1]) {\n            return false;\n        }\n        if (lst[i] == lst[i - 1]) {\n            size_t count = 1;\n            while (i + 1 < lst.size() && lst[i] == lst[i + 1]) {\n                count++;\n                i++;\n            }\n            if (count > 2) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_123", "completion": "```cpp\nint prod_signs(const std::vector<int> & arr){\n    if (arr.empty()) return -32768;\n    int total = 0;\n    int sign = 1;\n    bool hasZero = false;\n    for(int num : arr){\n        if(num > 0) {\n            total += num;\n        }\n        else if(num < 0){\n            total -= num;\n            sign *= -1;\n        }\n        else{\n            hasZero = true;\n        }\n    }\n    return hasZero ? 0 : total * sign;\n}\n```"}
{"task_id": "SimdBench_123", "completion": "```cpp\nint prod_signs(const std::vector<int> & arr){\n    if (arr.empty()) return -32768;\n    \n    int total_sum = 0;\n    int sign_product = 1;\n    \n    for(int num : arr){\n        if(num > 0){\n            total_sum += num;\n            sign_product *= 1;\n        }\n        else if(num < 0){\n            total_sum -= num;\n            sign_product *= -1;\n        }\n        else{\n            sign_product *= 0;\n        }\n    }\n    \n    return total_sum * sign_product;\n}\n```"}
{"task_id": "SimdBench_123", "completion": "```cpp\nint prod_signs(const std::vector<int> & arr){\n    if (arr.empty()) return -32768;\n    \n    int total_sum = 0;\n    int sign_product = 1;\n    \n    for(int num : arr){\n        if(num > 0){\n            total_sum += num;\n            sign_product *= 1;\n        }\n        else if(num < 0){\n            total_sum -= num;\n            sign_product *= -1;\n        }\n        else{\n            sign_product *= 0;\n        }\n    }\n    \n    return total_sum * sign_product;\n}\n```"}
{"task_id": "SimdBench_123", "completion": "```cpp\nint prod_signs(const std::vector<int> & arr){\n    if (arr.empty()) return -32768;\n    \n    int total_sum = 0;\n    int sign_product = 1;\n    \n    for(int num : arr){\n        if(num > 0){\n            total_sum += num;\n            sign_product *= 1;\n        }\n        else if(num < 0){\n            total_sum -= num;\n            sign_product *= -1;\n        }\n        else{\n            sign_product *= 0;\n        }\n    }\n    \n    return total_sum * sign_product;\n}\n```"}
{"task_id": "SimdBench_123", "completion": "```cpp\nint prod_signs(const std::vector<int> & arr){\n    if (arr.empty()) return -32768;\n    \n    int total_sum = 0;\n    int sign_product = 1;\n    \n    for(int num : arr){\n        if(num > 0){\n            total_sum += num;\n            sign_product *= 1;\n        }\n        else if(num < 0){\n            total_sum -= num;\n            sign_product *= -1;\n        }\n        else{\n            sign_product *= 0;\n        }\n    }\n    \n    return total_sum * sign_product;\n}\n```"}
{"task_id": "SimdBench_124", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath(const std::vector<std::vector<int>> &grid, int k) {\n    int N = grid.size();\n    std::vector<int> result;\n    \n    // Helper function to get all neighbors of a cell\n    auto getNeighbors = [&](int x, int y) -> std::vector<std::pair<int, int>> {\n        std::vector<std::pair<int, int>> neighbors;\n        if (x > 0) neighbors.emplace_back(x - 1, y);\n        if (x < N - 1) neighbors.emplace_back(x + 1, y);\n        if (y > 0) neighbors.emplace_back(x, y - 1);\n        if (y < N - 1) neighbors.emplace_back(x, y + 1);\n        return neighbors;\n    };\n    \n    // Recursive function to explore paths\n    std::vector<int> currentPath;\n    std::vector<bool> visited(N * N + 1, false);\n    \n    auto dfs = [&](auto &&dfs, int x, int y, int stepsLeft) -> void {\n        if (stepsLeft == 0) {\n            if (result.empty() || currentPath < result) {\n                result = currentPath;\n            }\n            return;\n        }\n        currentPath.push_back(grid[x][y]);\n        visited[grid[x][y]] = true;\n        for (const auto &[nx, ny] : getNeighbors(x, y)) {\n            if (!visited[grid[nx][ny]]) {\n                dfs(dfs, nx, ny, stepsLeft - 1);\n            }\n        }\n        currentPath.pop_back();\n        visited[grid[x][y]] = false;\n    };\n    \n    // Start DFS from every cell\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            dfs(dfs, i, j, k - 1);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_124", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath(const std::vector<std::vector<int>> &grid, int k) {\n    int N = grid.size();\n    std::vector<int> result;\n    \n    // Helper function to get all neighbors of a cell\n    auto getNeighbors = [&](int x, int y) -> std::vector<std::pair<int, int>> {\n        std::vector<std::pair<int, int>> neighbors;\n        if (x > 0) neighbors.emplace_back(x - 1, y);\n        if (x < N - 1) neighbors.emplace_back(x + 1, y);\n        if (y > 0) neighbors.emplace_back(x, y - 1);\n        if (y < N - 1) neighbors.emplace_back(x, y + 1);\n        return neighbors;\n    };\n    \n    // Initialize the result with the smallest possible value\n    int minValue = N * N;\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if (grid[i][j] < minValue) {\n                minValue = grid[i][j];\n            }\n        }\n    }\n    \n    // Start from the smallest value and explore paths\n    std::vector<std::pair<int, int>> current = {{0, minValue}};\n    while (!current.empty() && k > 0) {\n        std::vector<std::pair<int, int>> nextLevel;\n        for (auto &[path, val] : current) {\n            result.push_back(val);\n            std::vector<std::pair<int, int>> neighbors = getNeighbors(path / N, path % N);\n            for (auto &[nx, ny] : neighbors) {\n                int nval = grid[nx][ny];\n                nextLevel.emplace_back(nx * N + ny, nval);\n            }\n        }\n        current = nextLevel;\n        --k;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_124", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath(const std::vector<std::vector<int>> &grid, int k) {\n    int N = grid.size();\n    std::vector<int> result;\n    \n    // Helper function to get all neighbors of a cell\n    auto getNeighbors = [&](int x, int y) -> std::vector<std::pair<int, int>> {\n        std::vector<std::pair<int, int>> neighbors;\n        if (x > 0) neighbors.emplace_back(x - 1, y);\n        if (x < N - 1) neighbors.emplace_back(x + 1, y);\n        if (y > 0) neighbors.emplace_back(x, y - 1);\n        if (y < N - 1) neighbors.emplace_back(x, y + 1);\n        return neighbors;\n    };\n    \n    // Initialize the result with the smallest possible value\n    int minValue = N * N;\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if (grid[i][j] < minValue) {\n                minValue = grid[i][j];\n            }\n        }\n    }\n    \n    // Start from the smallest value and explore paths\n    std::vector<std::pair<int, int>> current = {{0, minValue}};\n    while (!current.empty() && k > 0) {\n        std::vector<std::pair<int, int>> nextLevel;\n        for (auto &[path, val] : current) {\n            result.push_back(val);\n            std::vector<std::pair<int, int>> neighbors = getNeighbors(path / N, path % N);\n            for (auto &[nx, ny] : neighbors) {\n                int new_val = grid[nx][ny];\n                nextLevel.emplace_back(nx * N + ny, new_val);\n            }\n        }\n        current = nextLevel;\n        --k;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_124", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath(const std::vector<std::vector<int>> &grid, int k) {\n    int N = grid.size();\n    std::vector<int> result;\n    \n    // Helper function to get all neighbors of a cell\n    auto getNeighbors = [&](int x, int y) -> std::vector<std::pair<int, int>> {\n        std::vector<std::pair<int, int>> neighbors;\n        if (x > 0) neighbors.emplace_back(x - 1, y);\n        if (x < N - 1) neighbors.emplace_back(x + 1, y);\n        if (y > 0) neighbors.emplace_back(x, y - 1);\n        if (y < N - 1) neighbors.emplace_back(x, y + 1);\n        return neighbors;\n    };\n    \n    // Initialize the result with the smallest possible value\n    int minValue = N * N;\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if (grid[i][j] < minValue) {\n                minValue = grid[i][j];\n            }\n        }\n    }\n    \n    // Start from the smallest value and explore paths\n    std::vector<std::pair<int, int>> current = {{0, minValue}};\n    while (!current.empty() && k > 0) {\n        std::vector<std::pair<int, int>> nextLevel;\n        for (auto &[path, val] : current) {\n            result.push_back(val);\n            std::vector<std::pair<int, int>> neighbors = getNeighbors(path / N, path % N);\n            for (auto &[nx, ny] : neighbors) {\n                nextLevel.emplace_back(nx * N + ny, grid[nx][ny]);\n            }\n        }\n        current = nextLevel;\n        --k;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_124", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath(const std::vector<std::vector<int>> &grid, int k) {\n    int N = grid.size();\n    std::vector<int> result;\n    \n    // Define possible moves: up, down, left, right\n    const int dx[4] = {-1, 1, 0, 0};\n    const int dy[4] = {0, 0, -1, 1};\n\n    // Helper function to check if a position is within bounds\n    auto isValid = [&](int x, int y) -> bool {\n        return x >= 0 && x < N && y >= 0 && y < N;\n    };\n\n    // Initialize the result with the smallest possible value\n    int minValue = N * N + 1;\n\n    // Iterate over all starting positions\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if (grid[i][j] < minValue) {\n                minValue = grid[i][j];\n            }\n        }\n    }\n\n    // Start from the smallest value\n    result.push_back(minValue);\n\n    // If k == 1, return the single value\n    if (k == 1) {\n        return result;\n    }\n\n    // Perform BFS to find the minimum path of length k\n    std::vector<std::vector<bool>> visited(N, std::vector<bool>(N, false));\n    std::vector<std::pair<int, int>> queue;\n    queue.emplace_back(0, 0); // Starting point\n\n    while (!queue.empty()) {\n        std::vector<std::pair<int, int>> nextQueue;\n        for (auto &[x, y] : queue) {\n            visited[x][y] = true;\n            for (int dir = 0; dir < 4; ++dir) {\n                int nx = x + dx[dir];\n                int ny = y + dy[dir];\n                if (isValid(nx, ny) && !visited[nx][ny]) {\n                    nextQueue.emplace_back(nx, ny);\n                    result.push_back(grid[nx][ny]);\n                    if (result.size() == k) {\n                        return result;\n                    }\n                }\n            }\n        }\n        queue = std::move(nextQueue);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_125", "completion": "```cpp\nuint64_t digits(uint64_t n){\n    uint64_t product = 1;\n    bool hasOdd = false;\n    while(n > 0){\n        uint64_t digit = n % 10;\n        if(digit % 2 != 0){\n            product *= digit;\n            hasOdd = true;\n        }\n        n /= 10;\n    }\n    return hasOdd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_125", "completion": "```cpp\nuint64_t digits(uint64_t n){\n    uint64_t product = 1;\n    bool hasOdd = false;\n    while(n > 0){\n        uint64_t digit = n % 10;\n        if(digit % 2 != 0){\n            product *= digit;\n            hasOdd = true;\n        }\n        n /= 10;\n    }\n    return hasOdd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_125", "completion": "```cpp\nuint64_t digits(uint64_t n){\n    uint64_t product = 1;\n    bool hasOdd = false;\n    while(n > 0){\n        uint64_t digit = n % 10;\n        if(digit % 2 != 0){\n            product *= digit;\n            hasOdd = true;\n        }\n        n /= 10;\n    }\n    return hasOdd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_125", "completion": "```cpp\nuint64_t digits(uint64_t n){\n    uint64_t product = 1;\n    bool hasOdd = false;\n    while(n > 0){\n        uint64_t digit = n % 10;\n        if(digit % 2 != 0){\n            product *= digit;\n            hasOdd = true;\n        }\n        n /= 10;\n    }\n    return hasOdd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_125", "completion": "```cpp\nuint64_t digits(uint64_t n){\n    uint64_t product = 1;\n    bool hasOdd = false;\n    while(n > 0){\n        uint64_t digit = n % 10;\n        if(digit % 2 != 0){\n            product *= digit;\n            hasOdd = true;\n        }\n        n /= 10;\n    }\n    return hasOdd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_126", "completion": "```cpp\n#include <cmath>\n#include <vector>\n#include <cstdint>\n\nuint64_t sum_squares(const std::vector<float> &lst) {\n    uint64_t sum = 0;\n    for (float num : lst) {\n        int ceil_num = static_cast<int>(std::ceil(num));\n        sum += static_cast<uint64_t>(ceil_num * ceil_num);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126", "completion": "```cpp\n#include <cmath>\n#include <vector>\n#include <cstdint>\n\nuint64_t sum_squares(const std::vector<float> &lst) {\n    uint64_t sum = 0;\n    for (float num : lst) {\n        int ceil_num = static_cast<int>(std::ceil(num));\n        sum += static_cast<uint64_t>(ceil_num * ceil_num);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126", "completion": "```cpp\n#include <cmath>\n#include <vector>\n#include <cstdint>\n\nuint64_t sum_squares(const std::vector<float> &lst) {\n    uint64_t sum = 0;\n    for (float num : lst) {\n        int ceil_num = static_cast<int>(std::ceil(num));\n        sum += static_cast<uint64_t>(ceil_num * ceil_num);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126", "completion": "```cpp\n#include <cmath>\n#include <vector>\n#include <cstdint>\n\nuint64_t sum_squares(const std::vector<float> &lst) {\n    uint64_t sum = 0;\n    for (float num : lst) {\n        int ceil_num = static_cast<int>(std::ceil(num));\n        sum += static_cast<uint64_t>(ceil_num * ceil_num);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126", "completion": "```cpp\n#include <cmath>\n#include <vector>\n#include <cstdint>\n\nuint64_t sum_squares(const std::vector<float> &lst) {\n    uint64_t sum = 0;\n    for (float num : lst) {\n        int ceil_num = static_cast<int>(std::ceil(num));\n        sum += static_cast<uint64_t>(ceil_num * ceil_num);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_127", "completion": "```cpp\nint can_arrange(const std::vector<int> &arr) {\n    for (int i = arr.size() - 1; i > 0; --i) {\n        if (arr[i] < arr[i - 1]) {\n            return i - 1;\n        }\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_127", "completion": "```cpp\nint can_arrange(const std::vector<int> &arr) {\n    for (int i = arr.size() - 1; i > 0; --i) {\n        if (arr[i] < arr[i - 1]) {\n            return i - 1;\n        }\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_127", "completion": "```cpp\nint can_arrange(const std::vector<int> &arr) {\n    for (int i = arr.size() - 1; i > 0; --i) {\n        if (arr[i] < arr[i - 1]) {\n            return i - 1;\n        }\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_127", "completion": "```cpp\nint can_arrange(const std::vector<int> &arr) {\n    for (int i = arr.size() - 1; i > 0; --i) {\n        if (arr[i] < arr[i - 1]) {\n            return i - 1;\n        }\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_127", "completion": "```cpp\nint can_arrange(const std::vector<int> &arr) {\n    for (int i = arr.size() - 1; i > 0; --i) {\n        if (arr[i] < arr[i - 1]) {\n            return i - 1;\n        }\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_128", "completion": "```cpp\nstd::vector<int> largest_smallest_integers(const std::vector<int>& lst){\n    int a = 0, b = 0;\n    for(auto num : lst){\n        if(num < 0){\n            if(a == 0 || num > a){\n                a = num;\n            }\n        }\n        else if(num > 0){\n            if(b == 0 || num < b){\n                b = num;\n            }\n        }\n    }\n    return {a, b};\n}\n```"}
{"task_id": "SimdBench_128", "completion": "```cpp\nstd::vector<int> largest_smallest_integers(const std::vector<int>& lst){\n    int a = 0, b = 0;\n    for(auto num : lst){\n        if(num < 0){\n            if(a == 0 || num > a){\n                a = num;\n            }\n        }\n        else if(num > 0){\n            if(b == 0 || num < b){\n                b = num;\n            }\n        }\n    }\n    return {a, b};\n}\n```"}
{"task_id": "SimdBench_128", "completion": "```cpp\nstd::vector<int> largest_smallest_integers(const std::vector<int>& lst){\n    int largest_negative = 0;\n    int smallest_positive = 0;\n    \n    for(int num : lst){\n        if(num < 0){\n            if(largest_negative == 0 || num > largest_negative){\n                largest_negative = num;\n            }\n        }\n        else if(num > 0){\n            if(smallest_positive == 0 || num < smallest_positive){\n                smallest_positive = num;\n            }\n        }\n    }\n    \n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_128", "completion": "```cpp\nstd::vector<int> largest_smallest_integers(const std::vector<int>& lst){\n    int a = 0, b = 0;\n    for(auto num : lst){\n        if(num < 0){\n            if(a == 0 || num > a){\n                a = num;\n            }\n        }\n        else if(num > 0){\n            if(b == 0 || num < b){\n                b = num;\n            }\n        }\n    }\n    return {a, b};\n}\n```"}
{"task_id": "SimdBench_128", "completion": "```cpp\nstd::vector<int> largest_smallest_integers(const std::vector<int>& lst){\n    int largest_negative = 0;\n    int smallest_positive = 0;\n    \n    for(int num : lst){\n        if(num < 0){\n            if(largest_negative == 0 || num > largest_negative){\n                largest_negative = num;\n            }\n        }\n        else if(num > 0){\n            if(smallest_positive == 0 || num < smallest_positive){\n                smallest_positive = num;\n            }\n        }\n    }\n    \n    return {largest_negative, smallest_positive};\n}\n```"}
{"task_id": "SimdBench_129", "completion": "```cpp\nuint64_t special_factorial(uint64_t n){\n    uint64_t result = 1;\n    for(uint64_t i = 1; i <= n; ++i){\n        uint64_t factorial = 1;\n        for(uint64_t j = 1; j <= i; ++j){\n            factorial *= j;\n        }\n        result *= factorial;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_129", "completion": "```cpp\nuint64_t special_factorial(uint64_t n){\n    uint64_t result = 1;\n    for(uint64_t i = 1; i <= n; ++i){\n        uint64_t factorial = 1;\n        for(uint64_t j = 1; j <= i; ++j){\n            factorial *= j;\n        }\n        result *= factorial;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_129", "completion": "```cpp\nuint64_t special_factorial(uint64_t n){\n    uint64_t result = 1;\n    for(uint64_t i = 1; i <= n; ++i){\n        uint64_t factorial = 1;\n        for(uint64_t j = 1; j <= i; ++j){\n            factorial *= j;\n        }\n        result *= factorial;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_129", "completion": "```cpp\nuint64_t special_factorial(uint64_t n){\n    uint64_t result = 1;\n    for(uint64_t i = 1; i <= n; ++i){\n        uint64_t factorial = 1;\n        for(uint64_t j = 1; j <= i; ++j){\n            factorial *= j;\n        }\n        result *= factorial;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_129", "completion": "```cpp\nuint64_t special_factorial(uint64_t n){\n    uint64_t result = 1;\n    for(uint64_t i = 1; i <= n; ++i){\n        uint64_t factorial = 1;\n        for(uint64_t j = 1; j <= i; ++j){\n            factorial *= j;\n        }\n        result *= factorial;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_130", "completion": "```cpp\nint sum_squares(const std::vector<int> &lst) {\n    int total = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0 && i % 4 != 0) {\n            total += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            total += lst[i] * lst[i] * lst[i];\n        } else {\n            total += lst[i];\n        }\n    }\n    return total;\n}\n```"}
{"task_id": "SimdBench_130", "completion": "```cpp\nint sum_squares(const std::vector<int> &lst) {\n    int total = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0 && i % 4 != 0) {\n            total += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            total += lst[i] * lst[i] * lst[i];\n        } else {\n            total += lst[i];\n        }\n    }\n    return total;\n}\n```"}
{"task_id": "SimdBench_130", "completion": "```cpp\nint sum_squares(const std::vector<int> &lst) {\n    int total = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0 && i % 4 != 0) {\n            total += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            total += lst[i] * lst[i] * lst[i];\n        } else {\n            total += lst[i];\n        }\n    }\n    return total;\n}\n```"}
{"task_id": "SimdBench_130", "completion": "```cpp\nint sum_squares(const std::vector<int> &lst) {\n    int total = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0 && i % 4 != 0) {\n            total += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            total += lst[i] * lst[i] * lst[i];\n        } else {\n            total += lst[i];\n        }\n    }\n    return total;\n}\n```"}
{"task_id": "SimdBench_130", "completion": "```cpp\nint sum_squares(const std::vector<int> &lst) {\n    int total = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0 && i % 4 != 0) {\n            total += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            total += lst[i] * lst[i] * lst[i];\n        } else {\n            total += lst[i];\n        }\n    }\n    return total;\n}\n```"}
{"task_id": "SimdBench_131", "completion": "```cpp\nint specialFilter(const std::vector<int> & nums){\n    int count = 0;\n    for(int num : nums){\n        if(num > 10){\n            int absNum = std::abs(num);\n            int firstDigit = absNum;\n            while(firstDigit >= 10){\n                firstDigit /= 10;\n            }\n            int lastDigit = absNum % 10;\n            if((firstDigit % 2 != 0) && (lastDigit % 2 != 0)){\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_131", "completion": "```cpp\nint specialFilter(const std::vector<int> & nums){\n    int count = 0;\n    for(int num : nums){\n        if(num > 10){\n            int absNum = std::abs(num);\n            int firstDigit = absNum;\n            while(firstDigit >= 10){\n                firstDigit /= 10;\n            }\n            int lastDigit = absNum % 10;\n            if((firstDigit % 2 != 0) && (lastDigit % 2 != 0)){\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_131", "completion": "```cpp\nint specialFilter(const std::vector<int> & nums){\n    int count = 0;\n    for(int num : nums){\n        if(num > 10){\n            int absNum = std::abs(num);\n            int firstDigit = absNum;\n            while(firstDigit >= 10){\n                firstDigit /= 10;\n            }\n            int lastDigit = absNum % 10;\n            if((firstDigit % 2 != 0) && (lastDigit % 2 != 0)){\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_131", "completion": "```cpp\nint specialFilter(const std::vector<int> & nums){\n    int count = 0;\n    for(int num : nums){\n        if(num > 10){\n            int absNum = std::abs(num);\n            int firstDigit = absNum;\n            while(firstDigit >= 10){\n                firstDigit /= 10;\n            }\n            int lastDigit = absNum % 10;\n            if((firstDigit % 2 != 0) && (lastDigit % 2 != 0)){\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_131", "completion": "```cpp\nint specialFilter(const std::vector<int> & nums){\n    int count = 0;\n    for(int num : nums){\n        if(num > 10){\n            int absNum = std::abs(num);\n            int firstDigit = absNum;\n            while(firstDigit >= 10){\n                firstDigit /= 10;\n            }\n            int lastDigit = absNum % 10;\n            if((firstDigit % 2 != 0) && (lastDigit % 2 != 0)){\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_132", "completion": "```cpp\nuint64_t get_max_triples(uint64_t n){\n    uint64_t count0 = 0, count1 = 0, count2 = 0;\n    for(uint64_t i = 1; i <= n; ++i){\n        uint64_t val = i * i - i + 1;\n        if(val % 3 == 0) count0++;\n        else if(val % 3 == 1) count1++;\n        else count2++;\n    }\n    uint64_t result = count0 * count1 * count2;\n    result += (count1 * (count1 - 1) / 2) * count2;\n    result += count0 * (count0 - 1) * (count0 - 2) / 6;\n    result += count1 * (count1 - 1) * (count1 - 2) / 6;\n    result += count2 * (count2 - 1) * (count2 - 2) / 6;\n    return result;\n}\n```"}
{"task_id": "SimdBench_132", "completion": "```cpp\nuint64_t get_max_triples(uint64_t n){\n    uint64_t count0 = 0, count1 = 0, count2 = 0;\n    for(uint64_t i = 1; i <= n; ++i){\n        uint64_t val = i * i - i + 1;\n        if(val % 3 == 0) count0++;\n        else if(val % 3 == 1) count1++;\n        else count2++;\n    }\n    uint64_t result = count0 * count1 * count2;\n    result += (count1 * (count1 - 1) / 2) * count2;\n    result += count0 * (count0 - 1) * (count0 - 2) / 6;\n    result += count1 * (count1 - 1) * (count1 - 2) / 6;\n    result += count2 * (count2 - 1) * (count2 - 2) / 6;\n    return result;\n}\n```"}
{"task_id": "SimdBench_132", "completion": "```cpp\nuint64_t get_max_triples(uint64_t n){\n    uint64_t count0 = 0, count1 = 0, count2 = 0;\n    for(uint64_t i = 1; i <= n; ++i){\n        uint64_t val = i * i - i + 1;\n        if(val % 3 == 0) count0++;\n        else if(val % 3 == 1) count1++;\n        else count2++;\n    }\n    uint64_t result = count0 * count1 * count2;\n    result += (count1 * (count1 - 1) / 2) * count2;\n    result += (count2 * (count2 - 1) / 2) * count0;\n    return result;\n}\n```"}
{"task_id": "SimdBench_132", "completion": "```cpp\nuint64_t get_max_triples(uint64_t n){\n    uint64_t count0 = 0, count1 = 0, count2 = 0;\n    for(uint64_t i = 1; i <= n; ++i){\n        uint64_t val = i * i - i + 1;\n        if(val % 3 == 0) count0++;\n        else if(val % 3 == 1) count1++;\n        else count2++;\n    }\n    uint64_t result = count0 * count1 * count2;\n    result += (count1 * (count1 - 1) / 2) * count2;\n    result += count0 * (count0 - 1) * (count0 - 2) / 6;\n    result += count1 * (count1 - 1) * (count1 - 2) / 6;\n    result += count2 * (count2 - 1) * (count2 - 2) / 6;\n    return result;\n}\n```"}
{"task_id": "SimdBench_132", "completion": "```cpp\nuint64_t get_max_triples(uint64_t n){\n    uint64_t count0 = 0, count1 = 0, count2 = 0;\n    for(uint64_t i = 1; i <= n; ++i){\n        uint64_t val = i * i - i + 1;\n        if(val % 3 == 0) count0++;\n        else if(val % 3 == 1) count1++;\n        else count2++;\n    }\n    uint64_t result = count0 * count1 * count2;\n    result += (count1 * (count1 - 1) / 2) * count2;\n    result += (count2 * (count2 - 1) / 2) * count0;\n    return result;\n}\n```"}
{"task_id": "SimdBench_133", "completion": "```c\nint x_or_y(int n, int x, int y){\n    if(n < 2) return y;\n    for(int i = 2; i * i <= n; i++){\n        if(n % i == 0) return y;\n    }\n    return x;\n}\n```"}
{"task_id": "SimdBench_133", "completion": "```cpp\nint x_or_y(int n, int x, int y){\n    if(n < 2) return y;\n    for(int i = 2; i * i <= n; i++){\n        if(n % i == 0) return y;\n    }\n    return x;\n}\n```"}
{"task_id": "SimdBench_133", "completion": "```cpp\nint x_or_y(int n, int x, int y){\n    if(n < 2) return y;\n    for(int i = 2; i * i <= n; i++){\n        if(n % i == 0) return y;\n    }\n    return x;\n}\n```"}
{"task_id": "SimdBench_133", "completion": "```cpp\nint x_or_y(int n, int x, int y){\n    if(n < 2) return y;\n    for(int i = 2; i * i <= n; i++){\n        if(n % i == 0) return y;\n    }\n    return x;\n}\n```"}
{"task_id": "SimdBench_133", "completion": "```cpp\nint x_or_y(int n, int x, int y){\n    if(n < 2) return y;\n    for(int i = 2; i * i <= n; i++){\n        if(n % i == 0) return y;\n    }\n    return x;\n}\n```"}
{"task_id": "SimdBench_134", "completion": "```cpp\n#include <cstdint>\n#include <vector>\n\nuint64_t double_the_difference(const std::vector<float> &lst) {\n    uint64_t sum = 0;\n    for (float num : lst) {\n        if (num == static_cast<int>(num) && num > 0) {\n            int n = static_cast<int>(num);\n            if (n % 2 != 0) {\n                sum += n * n;\n            }\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134", "completion": "```cpp\n#include <cstdint>\n#include <vector>\n\nuint64_t double_the_difference(const std::vector<float> &lst) {\n    uint64_t sum = 0;\n    for (float num : lst) {\n        if (num == static_cast<int>(num) && static_cast<int>(num) > 0) {\n            int n = static_cast<int>(num);\n            if (n % 2 != 0) {\n                sum += static_cast<uint64_t>(n) * n;\n            }\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134", "completion": "```cpp\nuint64_t double_the_difference(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    for(auto num : lst){\n        if(num >= 0 && num == static_cast<int>(num)){\n            int n = static_cast<int>(num);\n            if(n % 2 != 0){\n                sum += n * n;\n            }\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134", "completion": "```cpp\n#include <cstdint>\n#include <vector>\n\nuint64_t double_the_difference(const std::vector<float> &lst) {\n    uint64_t sum = 0;\n    for (float num : lst) {\n        if (num == static_cast<int>(num) && static_cast<int>(num) > 0) {\n            int n = static_cast<int>(num);\n            if (n % 2 != 0) {\n                sum += static_cast<uint64_t>(n) * n;\n            }\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134", "completion": "```cpp\nuint64_t double_the_difference(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    for(auto num : lst){\n        if(num >= 0 && num == static_cast<int>(num)){\n            int n = static_cast<int>(num);\n            if(n % 2 != 0){\n                sum += static_cast<uint64_t>(n) * n;\n            }\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_135", "completion": "```cpp\nstd::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess){\n    std::vector<int> result;\n    for(size_t i = 0; i < game.size(); ++i){\n        if(game[i] == guess[i]){\n            result.push_back(0);\n        }\n        else{\n            result.push_back(std::abs(game[i] - guess[i]));\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135", "completion": "```cpp\nstd::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess){\n    std::vector<int> result;\n    for(size_t i = 0; i < game.size(); ++i){\n        if(game[i] == guess[i]){\n            result.push_back(0);\n        }\n        else{\n            result.push_back(std::abs(game[i] - guess[i]));\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess){\n    std::vector<int> differences;\n    for(size_t i = 0; i < game.size(); ++i){\n        if(game[i] == guess[i]){\n            differences.push_back(0);\n        }\n        else{\n            differences.push_back(std::abs(game[i] - guess[i]));\n        }\n    }\n    return differences;\n}\n```"}
{"task_id": "SimdBench_135", "completion": "```cpp\nstd::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess){\n    std::vector<int> result;\n    for(size_t i = 0; i < game.size(); ++i){\n        if(game[i] == guess[i]){\n            result.push_back(0);\n        }\n        else{\n            result.push_back(std::abs(game[i] - guess[i]));\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess){\n    std::vector<int> result;\n    for(size_t i = 0; i < game.size(); ++i){\n        if(game[i] == guess[i]){\n            result.push_back(0);\n        }\n        else{\n            result.push_back(std::abs(game[i] - guess[i]));\n        }\n    }\n    return result;\n}\n```"}

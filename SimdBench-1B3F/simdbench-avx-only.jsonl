{"task_id": "SimdBench_0_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are: pointers to:\n- A non-empty source array of 64-bit integers (src);\n- A non-empty destination array of 64-bit integers (dst);\n- A non-empty mask array of boolean values (mask);\n- Their common length (length).\n\nYour goal is to conditionally copy elements from src to dst where the corresponding mask value is true.\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n}", "solution_scalar": "void conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (mask[i]) dst[i] = src[i];\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int  i = 0; i < iterations; i++){\n        /* one check */\n        size_t length = Small_Arg_1D;\n        std::vector<int64_t> src(length); rng.initialize_vector_with_random_values(src);\n        std::vector<int64_t> dst(length); rng.initialize_vector_with_random_values(dst);\n        std::vector<int64_t> dst_simd(dst); \n        std::vector<uint8_t> mask(length); rng.initialize_vector_with_random_values(mask, true);\n\n        conditional_move(src.data(), dst.data(), reinterpret_cast<const bool*>(mask.data()), length);\n        conditional_move_simd(src.data(), dst_simd.data(), reinterpret_cast<const bool*>(mask.data()), length);\n        \n        if(!allclose(dst, dst_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const int64_t *, int64_t *, const bool *, size_t)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<int64_t> src(length); rng.initialize_vector_with_random_values(src);\n    std::vector<int64_t> dst(length); rng.initialize_vector_with_random_values(dst);\n    std::vector<uint8_t> mask(length); rng.initialize_vector_with_random_values(mask, true);\n    \n    for (auto _ : state) {\n        Func(src.data(), dst.data(), reinterpret_cast<const bool*>(mask.data()), length);\n        benchmark::DoNotOptimize(dst.data()); // Prevent optimization of the result\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, conditional_move)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, conditional_move_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-1", "entrypoint_scalar": "conditional_move", "entrypoint_simd": "conditional_move_simd"}
{"task_id": "SimdBench_1_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are: pointers to two non-empty 32-bit signed integer arrays (src & dst),\na scaling factor (scale), and the arrays' common length (length).\nYour goal is to perform the following operations on each element of src and store results in dst:\n1. Calculate tmp1 as (element * scale) right-shifted by 3 bits;\n2. Calculate tmp2 as (element * scale) left-shifted by 3 bits;\n3. Compute the final result as: (element * scale + tmp1 * tmp2) divided by 7;\n4. Finally store the result in dst.\n\nOur input guarantee that no overflow will occur during the calculations.\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n}", "solution_scalar": "void load_modify_store(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int tmp1 = (src[i] * scale) >> 3;\n        int tmp2 = (src[i] * scale) << 3;\n        dst[i] = (src[i] * scale + tmp1 * tmp2) / 7;\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int  i = 0; i < iterations; i++){\n        size_t length = Small_Arg_1D;\n        std::vector<int> src(length); for ( auto & element : src) { element = rng.randint(- (1 << 12), 1 << 12); }\n        std::vector<int> dst(length); rng.initialize_vector_with_random_values(dst);\n        std::vector<int> dst_simd(dst);\n        int scale = rng.randint(-100, 100);\n\n        load_modify_store(src.data(), dst.data(), scale, length);\n        load_modify_store_simd(src.data(), dst_simd.data(), scale, length);\n        \n        if(!allclose(dst, dst_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "// Benchmarking function\ntemplate<void (*Func)(const int *, int *, int, size_t)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<int> src(length); for ( auto & element : src) { element = rng.randint(0, 1 << 12); }\n    std::vector<int> dst(length); rng.initialize_vector_with_random_values(dst);\n    std::vector<int> dst_simd(dst);\n    int scale = rng.randint(1, 100);\n    \n    for (auto _ : state) {\n        Func(src.data(), dst.data(), scale, length);\n        benchmark::DoNotOptimize(dst.data()); // Prevent optimization of the result\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, load_modify_store)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, load_modify_store_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-2", "entrypoint_scalar": "load_modify_store", "entrypoint_simd": "load_modify_store_simd"}
{"task_id": "SimdBench_2_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are: pointers to two non-empty 64-bit floating-point arrays (src & dst),\nthe number of rows (rows), the number of columns (cols), and a stride value (stride).\nEach array is a 1D representation of a 2D matrix with rows * cols elements.\nYour goal is to perform the following operations:\nFor each row r from 0 to rows-1:\nLoad the element at position (r * cols + stride) from src array, \nStore it in position r of dst array\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n}", "solution_scalar": "void strided_load_store(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; r++) {\n        dst[r] = src[r * cols + stride];\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int  i = 0; i < iterations; i++){\n        /* one check */\n        size_t rows = Small_Arg_2D;\n        size_t cols = Small_Arg_2D;\n        std::vector<double> src(rows * cols); rng.initialize_vector_with_random_values(src);\n        std::vector<double> dst(rows); rng.initialize_vector_with_random_values(dst);\n        std::vector<double> dst_simd(dst);\n        size_t stride = rng.randint(size_t(0), cols - 1);\n\n        strided_load_store(src.data(), dst.data(), rows, cols, stride);\n        strided_load_store_simd(src.data(), dst_simd.data(), rows, cols, stride);\n        \n        if(!allclose(dst, dst_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "// Benchmarking function\ntemplate<void (*Func)(const double *, double *, size_t, size_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t rows = state.range(0);\n    size_t cols = state.range(1);\n    std::vector<double> src(rows * cols); rng.initialize_vector_with_random_values(src);\n    std::vector<double> dst(rows); rng.initialize_vector_with_random_values(dst);\n    std::vector<double> dst_simd(dst);\n    size_t stride = rng.randint(size_t(0), cols - 1);\n    \n    for (auto _ : state) {\n        Func(src.data(), dst.data(), rows, cols, stride);\n        benchmark::DoNotOptimize(dst.data()); // Prevent optimization of the result\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, strided_load_store)->Name(\"Scalar\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM, strided_load_store_simd)->Name(\"SIMD\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-1", "entrypoint_scalar": "strided_load_store", "entrypoint_simd": "strided_load_store_simd"}
{"task_id": "SimdBench_3_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThis function takes a 32-bit non-empty floating-point source array, a 32-bit non-empty integer array of indices, and a 32-bit floating-point\ndestination array, all of the same length. \n\nThe function performs two operations:\n- First, it copies values from the source array to the destination array using the indices \nas lookups (gather operation);\n- Then it copies values from the source array to the destination \narray using the indices as write locations (scatter operation).\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n}", "solution_scalar": "void indexed_access(const float *src, const int *indices, float *dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = src[indices[i]];\n    }\n    for (size_t i = 0; i < length; i++) {\n        dst[indices[i]] = src[i];\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int  i = 0; i < iterations; i++){\n        /* one check */\n        size_t length = Small_Arg_1D;\n        std::vector<float> src(length); rng.initialize_vector_with_random_values(src);\n        std::vector<int> indices(length); for(auto& index : indices){ index = rng.randint(size_t(0), length - 1); }\n        std::vector<float> dst(length); rng.initialize_vector_with_random_values(dst);\n        std::vector<float> dst_simd(dst);\n\n        indexed_access(src.data(), indices.data(), dst.data(), length);\n        indexed_access_simd(src.data(), indices.data(), dst_simd.data(), length);\n        \n        if(!allclose(dst, dst_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "// Benchmarking function\ntemplate<void (*Func)(const float *, const int *, float *, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t length = state.range(0);\n    std::vector<float> src(length); rng.initialize_vector_with_random_values(src);\n    std::vector<int> indices(length); for(auto& index : indices){ index = rng.randint(size_t(0), length - 1); }\n    std::vector<float> dst(length); rng.initialize_vector_with_random_values(dst);\n    \n    for (auto _ : state) {\n        Func(src.data(), indices.data(), dst.data(), length);\n        benchmark::DoNotOptimize(dst.data()); // Prevent optimization of the result\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, indexed_access)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, indexed_access_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-1", "entrypoint_scalar": "indexed_access", "entrypoint_simd": "indexed_access_simd"}
{"task_id": "SimdBench_4_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 16-bit non-empty integer array (arr);\n- The 64-bit starting index (start);\n- The 64-bit ending index (end).\n\nYour goal is to reverse the elements in the array between the start and end indices (inclusive), the remaining elements should be unchanged.\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n}", "solution_scalar": "void range_reverse(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start < end) {\n        int temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int  i = 0; i < iterations; i++){\n        /* one check */\n        int length = Small_Arg_1D;\n        std::vector<int16_t> arr(length); rng.initialize_vector_with_random_values(arr);\n        std::vector<int16_t> arr_simd(arr);\n        uint64_t start = rng.randint<uint64_t>(0, length - 1);\n        uint64_t end = rng.randint<uint64_t>(start, length - 1);\n        range_reverse(arr.data(), start, end);\n        range_reverse_simd(arr_simd.data(), start, end);\n        \n        if(!allclose(arr, arr_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(int16_t *, uint64_t, uint64_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng(DEFAULT_SEED);\n    int length = state.range(0);\n    std::vector<int16_t> arr(length); rng.initialize_vector_with_random_values(arr);\n    int start = rng.randint(0, length - 1);\n    int end = rng.randint(start, length - 1);\n    \n    for (auto _ : state) {\n        Func(arr.data(), start, end);\n        benchmark::DoNotOptimize(arr.data()); // Prevent optimization of the result\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, range_reverse)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, range_reverse_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-1", "entrypoint_scalar": "range_reverse", "entrypoint_simd": "range_reverse_simd"}
{"task_id": "SimdBench_5_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 3D tensor stored in an non-empty 1D array (tensor);\n- The dimensions of the tensor (dim1, dim2, dim3);\n- The index of the slice to extract (slice_idx).\n\nYour goal is to extract a 2D slice from the 3D tensor (represented as a flattened 1D array in memory) \nalong the third dimension (dim3) at the given index (slice_idx).\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n}", "solution_scalar": "void extract_tensor_slice(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n// Extract 2D slice from 3D tensor at given index\n    for (size_t i = 0; i < dim1; i++) {\n        for (size_t j = 0; j < dim2; j++) {\n            slice[i * dim2 + j] = tensor[(i * dim2 * dim3) + (j * dim3) + slice_idx];\n        }\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int  i = 0; i < iterations; i++){\n        /* one check */\n        size_t dim1 = Small_Arg_3D;\n        size_t dim2 = Small_Arg_3D;\n        size_t dim3 = Small_Arg_3D;\n        size_t slice_idx = rng.randint(size_t(0), dim3 - 1);\n        \n        std::vector<uint8_t> tensor(dim1 * dim2 * dim3); rng.initialize_vector_with_random_values(tensor);\n        std::vector<uint8_t> slice(dim1 * dim2); rng.initialize_vector_with_random_values(slice);\n        std::vector<uint8_t> slice_simd(slice);\n\n        extract_tensor_slice(tensor.data(), slice.data(), dim1, dim2, dim3, slice_idx);\n        extract_tensor_slice_simd(tensor.data(), slice_simd.data(), dim1, dim2, dim3, slice_idx);\n        \n        if(!allclose(slice, slice_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "// Benchmarking function\ntemplate<void (*Func)(const uint8_t *, uint8_t *, size_t, size_t, size_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t dim1 = state.range(0);\n    size_t dim2 = state.range(1);\n    size_t dim3 = state.range(2);\n    size_t slice_idx = rng.randint(size_t(0), dim3 - 1);\n    \n    std::vector<uint8_t> tensor(dim1 * dim2 * dim3); rng.initialize_vector_with_random_values(tensor);\n    std::vector<uint8_t> slice(dim1 * dim2); rng.initialize_vector_with_random_values(slice);\n    std::vector<uint8_t> slice_simd(slice);\n    \n    for (auto _ : state) {\n        Func(tensor.data(), slice.data(), dim1, dim2, dim3, slice_idx);\n        benchmark::DoNotOptimize(slice.data()); // Prevent optimization of the result\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, extract_tensor_slice)->Name(\"Scalar\")->Large_Args_3D;\nBENCHMARK_TEMPLATE(BM, extract_tensor_slice_simd)->Name(\"SIMD\")->Large_Args_3D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-1", "entrypoint_scalar": "extract_tensor_slice", "entrypoint_simd": "extract_tensor_slice_simd"}
{"task_id": "SimdBench_6_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/* The inputs to this function are::\n- A pointer to a non-empty 16-bit integer source array (src);\n- A pointer to a non-empty 16-bit integer destination array (dst);\n- The number of rows (rows);\n- The number of columns (cols);\n- The block size (block_size).\n\nThe matrix src and dst are represented as 1D arrays in memory.\nYour goal is to transpose the matrix in a blocked manner.\nThe result should be stored in the destination array.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n}", "solution_scalar": "void blocked_matrix_transpose(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t i_end = (i + block_size) < rows ? (i + block_size) : rows;\n            size_t j_end = (j + block_size) < cols ? (j + block_size) : cols;\n            \n            for (size_t ii = i; ii < i_end; ii++) {\n                for (size_t jj = j; jj < j_end; jj++) {\n                    dst[jj * rows + ii] = src[ii * cols + jj];\n                }\n            }\n        }\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int  i = 0; i < iterations; i++){\n        /* one check */\n        size_t rows = Small_Arg_2D;\n        size_t cols = Small_Arg_2D;\n        size_t block_size = rng.randint(size_t(1), std::min(rows, cols));\n        std::vector<int16_t> src(rows * cols); rng.initialize_vector_with_random_values(src);\n        std::vector<int16_t> dst(rows * cols); rng.initialize_vector_with_random_values(dst);\n        std::vector<int16_t> dst_simd(dst);\n\n        blocked_matrix_transpose(src.data(), dst.data(), rows, cols, block_size);\n        blocked_matrix_transpose_simd(src.data(), dst_simd.data(), rows, cols, block_size);\n        \n        if(!allclose(dst, dst_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const int16_t *, int16_t*, size_t, size_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t rows = state.range(0);\n    size_t cols = state.range(1);\n    size_t block_size = rng.randint(size_t(1), std::min(rows, cols));\n    std::vector<int16_t> src(rows * cols); rng.initialize_vector_with_random_values(src);\n    std::vector<int16_t> dst(rows * cols); rng.initialize_vector_with_random_values(dst);\n\n    for (auto _ : state) {\n        Func(src.data(), dst.data(), rows, cols, block_size);\n        benchmark::DoNotOptimize(dst.data()); // Prevent optimization of the result\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, blocked_matrix_transpose)->Name(\"Scalar\")->Large_Args_3D;\nBENCHMARK_TEMPLATE(BM, blocked_matrix_transpose_simd)->Name(\"SIMD\")->Large_Args_3D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-1", "entrypoint_scalar": "blocked_matrix_transpose", "entrypoint_simd": "blocked_matrix_transpose_simd"}
{"task_id": "SimdBench_7_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/* The inputs to this function are::\n- A pointer to a non-empty 32-bit float array (array), representing a 3D array of dimensions dim*dim*dim, flattened into a 1D array;\n- The size of each dimension (dim).\n\nYour goal is to calculate the sum of the diagonal elements (i.e., the ones where the three indices are equal) in a 3D array.\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n}", "solution_scalar": "float diagonal_sum_3d(const float *array, size_t dim) {\n    float sum = 0.0f;\n    for (size_t i = 0; i < dim; i++) {\n        sum += array[i * dim * dim + i * dim + i]; // Accessing the diagonal element\n    }\n    return sum;\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int  i = 0; i < iterations; i++){\n        /* one check */\n        size_t length = Small_Arg_3D;\n        std::vector<float> array(length*length*length); rng.initialize_vector_with_random_values(array);\n        std::vector<float> array_simd(array);\n        float sum = diagonal_sum_3d(array.data(), length);\n        float sum_simd = diagonal_sum_3d_simd(array_simd.data(), length);\n        if(!allclose(sum, sum_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "// Benchmarking function\ntemplate<float (*Func)(const float *, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t length = state.range(0);\n    std::vector<float> array(length*length*length); rng.initialize_vector_with_random_values(array);\n    std::vector<float> array_simd(array);\n    for (auto _ : state) {\n        Func(array.data(), length);\n        benchmark::DoNotOptimize(array.data()); // Prevent optimization of the result\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, diagonal_sum_3d)->Name(\"Scalar\")->RangeMultiplier(2)->Range(1 << 3, 1 << 7);\nBENCHMARK_TEMPLATE(BM, diagonal_sum_3d_simd)->Name(\"SIMD\")->RangeMultiplier(2)->Range(1 << 3, 1 << 7);\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-3", "entrypoint_scalar": "diagonal_sum_3d", "entrypoint_simd": "diagonal_sum_3d_simd"}
{"task_id": "SimdBench_8_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point (double) source array (src);\n- A pointer to a non-empty 64-bit floating-point (double) destination array (dst);\n- The number of rows (rows);\n- The number of columns (cols);\n- A threshold value (threshold);\n- A scale factor (scale).\n\nYour goal is to apply a conditional scaling operation on the source array.\nIf the value is greater than the threshold, scale it by the scale factor; otherwise, keep it unchanged.\nThe result should be stored in the destination array.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n}", "solution_scalar": "void conditional_scale(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j++) {\n            float val = src[i * cols + j];\n            dst[i * cols + j] = (val > threshold) ? val * scale : val;\n        }\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int  i = 0; i < iterations; i++){\n        size_t rows = Small_Arg_2D;\n        size_t cols = Small_Arg_2D;\n        std::vector<double> src(rows * cols); rng.initialize_vector_with_random_values(src);\n        std::vector<double> dst(rows * cols); rng.initialize_vector_with_random_values(dst);\n        std::vector<double> dst_simd(dst);\n        double threshold = rng.uniform(0.0f, 100.0f);\n        double scale = rng.uniform(-10.0f, 10.0f);\n\n        conditional_scale(src.data(), dst.data(), rows, cols, threshold, scale);\n        conditional_scale_simd(src.data(), dst_simd.data(), rows, cols, threshold, scale);\n        \n        if(!allclose(dst, dst_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "// Benchmarking function\ntemplate<void (*Func)(const double*, double*, size_t, size_t, double, double)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t rows = state.range(0);\n    size_t cols = state.range(1);\n    std::vector<double> src(rows * cols); rng.initialize_vector_with_random_values(src);\n    std::vector<double> dst(rows * cols); rng.initialize_vector_with_random_values(dst);\n    std::vector<double> dst_simd(dst);\n    double threshold = rng.uniform(0.0f, 100.0f);\n    double scale = rng.uniform(-10.0f, 10.0f);\n\n    for (auto _ : state) {\n        Func(src.data(), dst.data(), rows, cols, threshold, scale);\n        benchmark::DoNotOptimize(dst.data()); // Prevent optimization of the result\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, conditional_scale)->Name(\"Scalar\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM, conditional_scale_simd)->Name(\"SIMD\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-1", "entrypoint_scalar": "conditional_scale", "entrypoint_simd": "conditional_scale_simd"}
{"task_id": "SimdBench_9_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point (double) source matrix stored in an 1D array (src);\n- A pointer to a non-empty 64-bit floating-point (double) destination matrix stored in an 1D array (dst);\n- The number of rows (rows);\n- The number of columns (cols);\n- A pointer to an array of indices (indices).\n\nThe matrix src and dst are matrix in shape (rows, cols) represented as 1D arrays in memory, and `indices` is a 1D array.\nYour goal is to reorder the rows of the source matrix based on the given indices.\nThe result should be stored in the destination matrix.\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n}", "solution_scalar": "void reorder_matrix_rows(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t src_row = indices[i];\n        for (size_t j = 0; j < cols; j++) {\n            dst[i * cols + j] = src[src_row * cols + j];\n        }\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    for (int  i = 0; i < iterations; i++){\n        /* one check */\n        Random rng;\n        size_t rows = Small_Arg_2D;\n        size_t cols = Small_Arg_2D;\n        std::vector<size_t> indices(rows);\n        for (auto & index : indices) {\n            index = rng.randint(size_t(0), rows - 1);\n        }\n        std::vector<double> src(rows * cols); rng.initialize_vector_with_random_values(src);\n        std::vector<double> dst(rows * cols); rng.initialize_vector_with_random_values(dst);\n        std::vector<double> dst_simd(dst);\n\n        reorder_matrix_rows(src.data(), dst.data(), rows, cols, indices.data());\n        reorder_matrix_rows_simd(src.data(), dst_simd.data(), rows, cols, indices.data());\n        \n        if(!allclose(dst, dst_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "// Benchmarking function\ntemplate<void (*Func)(const double*, double*, size_t, size_t, const size_t*)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t rows = state.range(0);\n    size_t cols = state.range(1);\n    std::vector<size_t> indices(rows);\n    for (auto & index : indices) {\n        index = rng.randint(size_t(0), rows - 1);\n    }\n    std::vector<double> src(rows * cols); rng.initialize_vector_with_random_values(src);\n    std::vector<double> dst(rows * cols); rng.initialize_vector_with_random_values(dst);\n\n    for (auto _ : state) {\n        Func(src.data(), dst.data(), rows, cols, indices.data());\n        benchmark::DoNotOptimize(dst.data()); // Prevent optimization of the result\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, reorder_matrix_rows)->Name(\"Scalar\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM, reorder_matrix_rows_simd)->Name(\"SIMD\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-1", "entrypoint_scalar": "reorder_matrix_rows", "entrypoint_simd": "reorder_matrix_rows_simd"}
{"task_id": "SimdBench_10_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty source array of 64-bit integers (src1);\n- A pointer to a non-empty source array of 64-bit integers (src2);\n- A pointer to a non-empty destination array of 64-bit integers (dst);\n- A scalar integer value (scalar);\n- The length of the arrays (length).\n\nYour goal is to calculate the result of the element-wise addition of src1 and src2, \nand then add the scalar value to each element of the result. \nFinally, divide the result by 2 (round-toward-zero).\nThe final result should be stored in the dst array.\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n}", "solution_scalar": "void vector_vector_add(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<int64_t> src1(length); for ( auto & element : src1) { element = rng.randint<int64_t>(- (1 << 28), 1 << 28); }\n        std::vector<int64_t> src2(length); for ( auto & element : src2) { element = rng.randint<int64_t>(- (1 << 28), 1 << 28); }\n        std::vector<int64_t> dst(length); \n        std::vector<int64_t> dst_simd(length);\n        int64_t scalar = rng.randint<int64_t>(- (1 << 28), 1 << 28);\n\n        vector_vector_add(src1.data(), src2.data(), dst.data(), scalar, length);\n        vector_vector_add_simd(src1.data(), src2.data(), dst_simd.data(), scalar, length);\n        \n        if(!allclose(dst, dst_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const int64_t*, const int64_t*, int64_t*, int64_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t length = state.range(0);\n    std::vector<int64_t> src1(length); for ( auto & element : src1) { element = rng.randint<int64_t>(- (1 << 28), 1 << 28); }\n    std::vector<int64_t> src2(length); for ( auto & element : src2) { element = rng.randint<int64_t>(- (1 << 28), 1 << 28); }\n    std::vector<int64_t> dst(length); \n    int64_t scalar = rng.randint<int64_t>(- (1 << 28), 1 << 28);\n\n    for (auto _ : state) {\n        Func(src1.data(), src2.data(), dst.data(), scalar, length);\n        benchmark::DoNotOptimize(dst.data()); // Prevent optimization of the result\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, vector_vector_add)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, vector_vector_add_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-2", "entrypoint_scalar": "vector_vector_add", "entrypoint_simd": "vector_vector_add_simd"}
{"task_id": "SimdBench_11_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 32-bit integer source array (src);\n- The length of the array (length).\n\nYour goal is to find and return the minimum value among the even-numbered elements in the array..\nIf the array is empty, return -1.\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nint vector_even_min_simd(const int *src, size_t length){\n}", "solution_scalar": "int vector_even_min(const int *src, size_t length) {\n    if(src == NULL || length <= 0) return -1;\n    int min_val = src[0];\n    for (size_t i = 1; i < length; i++) {\n        if (src[i] < min_val && i % 2 == 0) min_val = src[i];\n    }\n    return min_val;\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = rng.randint(size_t(0), size_t(1024));\n        std::vector<int> src(length); \n        rng.initialize_vector_with_random_values(src);\n\n        int scalar_result = vector_even_min(src.data(), length);\n        int simd_result = vector_even_min_simd(src.data(), length);\n        \n        if(scalar_result != simd_result){\n            if(ERROR_PRINT) {\n                std::cerr << \"Correctness check failed!\" << std::endl;\n            }\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<int (*Func)(const int*, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t length = state.range(0);\n    std::vector<int> src(length); \n    rng.initialize_vector_with_random_values(src);\n\n    for (auto _ : state) {\n        int result = Func(src.data(), length);\n        benchmark::DoNotOptimize(&result);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, vector_even_min)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, vector_even_min_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-5", "entrypoint_scalar": "vector_even_min", "entrypoint_simd": "vector_even_min_simd"}
{"task_id": "SimdBench_12_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 32-bit integer source array (src);\n- A pointer to a 32-bit integer destination array (dst);\n- the number of each element to be shifted (shift);\n- The length of the array (length).\n\nYour goal:\n    First, calculate the arithmetic right shift of each element in the array by the given number of bits;\n    Then, calculate the logical right shift of each element in the array by the same number of bits,\n    converting each int to uint before shifting, and then casting the result back to int;\n    Finally, add the results of the arithmetic and logical shifts together and store them in the destination array.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n}", "solution_scalar": "void mixed_right_shift(const int *src, int *dst, uint8_t shift, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = src[i] >> shift; // Arithmetic shift\n        dst[i] += (int)((unsigned int)src[i] >> shift); // Logical shift\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        uint8_t shift = rng.randint<uint8_t>(0, 31);\n        std::vector<int> src(length); \n        rng.initialize_vector_with_random_values(src);\n        std::vector<int> dst(length);\n        std::vector<int> dst_simd(length);\n\n        mixed_right_shift(src.data(), dst.data(), shift, length);\n        mixed_right_shift_simd(src.data(), dst_simd.data(), shift, length);\n        \n        if(!allclose(dst, dst_simd)){\n            if(ERROR_PRINT) {\n                std::cerr << \"Correctness check failed! Shift: \" << shift << std::endl;\n            }\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const int*, int*, uint8_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t length = state.range(0);\n    uint8_t shift = rng.randint<uint8_t>(1, 31);\n    std::vector<int> src(length); \n    rng.initialize_vector_with_random_values(src);\n    std::vector<int> dst(length);\n\n    for (auto _ : state) {\n        Func(src.data(), dst.data(), shift, length);\n        benchmark::DoNotOptimize(dst.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, mixed_right_shift)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, mixed_right_shift_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-6", "entrypoint_scalar": "mixed_right_shift", "entrypoint_simd": "mixed_right_shift_simd"}
{"task_id": "SimdBench_13_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a matrix stored in a non-empty 32-bit integer array (matrix);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nThe input matrix is flattened into a 1D array.\nYour goal is to calculate the sum of all elements in the matrix.\nThe sum should be returned as a 64-bit integer value (the input is guaranteed not to cause an overflow).\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n}", "solution_scalar": "int64_t matrix_sum(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j++) {\n            sum += matrix[i * cols + j];\n        }\n    }\n    return sum;\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t rows = Small_Arg_2D;\n        size_t cols = Small_Arg_2D;\n        std::vector<int> matrix(rows * cols);\n        rng.initialize_vector_with_random_values(matrix);\n\n        int64_t scalar_result = matrix_sum(matrix.data(), rows, cols);\n        int64_t simd_result = matrix_sum_simd(matrix.data(), rows, cols);\n        \n        if(scalar_result != simd_result){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<int64_t (*Func)(const int*, size_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t rows = state.range(0);\n    size_t cols = state.range(1);\n    std::vector<int> matrix(rows * cols);\n    rng.initialize_vector_with_random_values(matrix);\n\n    for (auto _ : state) {\n        int result = Func(matrix.data(), rows, cols);\n        benchmark::DoNotOptimize(&result);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, matrix_sum)->Name(\"Scalar\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM, matrix_sum_simd)->Name(\"SIMD\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-2", "entrypoint_scalar": "matrix_sum", "entrypoint_simd": "matrix_sum_simd"}
{"task_id": "SimdBench_14_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 8-bit integer source array (src);\n- The length of the array (length).\n\nYour goal is to find the index of the maximum value in the array and return it.\nIf the input array is empty, return 0.\nThe index should be returned as a size_t value.\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nsize_t argmax_simd(const int8_t *src, size_t length) {\n}", "solution_scalar": "size_t argmax(const int8_t *src ,size_t length) {\n    if(src == NULL) return size_t(0);\n    size_t index = 0;\n    for (size_t i = 1; i < length; i++) {\n        if (src[i] > src[index]) index = i;\n    }\n    return index;\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<int8_t> src(length);\n        rng.initialize_vector_with_random_values(src);\n\n        size_t scalar_result = argmax(src.data(), length);\n        size_t simd_result = argmax_simd(src.data(), length);\n        \n        if(scalar_result != simd_result){\n            if(ERROR_PRINT) {\n                std::cerr << \"Correctness check failed!\" << std::endl;\n                std::cerr << \"Scalar result index: \" << scalar_result \n                          << \" (value: \" << src[scalar_result] << \")\" << std::endl;\n                std::cerr << \"SIMD result index: \" << simd_result\n                          << \" (value: \" << src[simd_result] << \")\" << std::endl;\n            }\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<size_t (*Func)(const int8_t*, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t length = state.range(0);\n    std::vector<int8_t> src(length);\n    rng.initialize_vector_with_random_values(src);\n\n    for (auto _ : state) {\n        size_t result = Func(src.data(), length);\n        benchmark::DoNotOptimize(&result);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, argmax)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, argmax_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-2", "entrypoint_scalar": "argmax", "entrypoint_simd": "argmax_simd"}
{"task_id": "SimdBench_15_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty uint16_t source array (src);\n- A pointer to a non-empty uint16_t destination array (dst);\n- A uint32_t mask value (mask);\n- The length of the array (length).\n\nYour goal is to blend two arrays based on the following condition:\n    If the bitwise AND of the element's index and the mask is non-zero, take the value from src1; \n    otherwise, take the value from src2.\nThe result should be stored in the destination array (dst).\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n}", "solution_scalar": "void vector_blend(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (i & mask) ? src1[i] : src2[i];\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        uint32_t mask = rng.randint<uint32_t>();\n        std::vector<uint16_t> src1(length); rng.initialize_vector_with_random_values(src1);\n        std::vector<uint16_t> src2(length); rng.initialize_vector_with_random_values(src2);\n        std::vector<uint16_t> dst(length);\n        std::vector<uint16_t> dst_simd(length);\n\n        vector_blend(src1.data(), src2.data(), mask, dst.data(), length);\n        vector_blend_simd(src1.data(), src2.data(), mask, dst_simd.data(), length);\n        \n        if(!allclose(dst, dst_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed! Mask: \" << mask << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const uint16_t*, const uint16_t*, uint32_t, uint16_t*, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t length = state.range(0);\n    uint32_t mask = rng.randint<uint32_t>();\n    std::vector<uint16_t> src1(length); rng.initialize_vector_with_random_values(src1);\n    std::vector<uint16_t> src2(length); rng.initialize_vector_with_random_values(src2);\n    std::vector<uint16_t> dst(length);\n\n    for (auto _ : state) {\n        Func(src1.data(), src2.data(), mask, dst.data(), length);\n        benchmark::DoNotOptimize(dst.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, vector_blend)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, vector_blend_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-2", "entrypoint_scalar": "vector_blend", "entrypoint_simd": "vector_blend_simd"}
{"task_id": "SimdBench_16_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty uint32_t source array (src);\n- A pointer to a non-empty uint32_t destination array (dst);\n- The length of the array (length).\n\nYour goal is to calculate the population count (the number of 1 bits in the binary representation of an integer) \nfor each element in the array.\nThe result should be stored in the destination array (dst).\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n}", "solution_scalar": "void population_count(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t x = src[i];\n        x = x - ((x >> 1) & 0x55555555);\n        x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n        dst[i] = (((x + (x >> 4)) & 0x0F0F0F0F) * 0x01010101) >> 24;\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<uint32_t> src(length); \n        rng.initialize_vector_with_random_values(src);\n        std::vector<uint32_t> dst(length);\n        std::vector<uint32_t> dst_simd(length);\n\n        population_count(src.data(), dst.data(), length);\n        population_count_simd(src.data(), dst_simd.data(), length);\n        \n        if(!allclose(dst, dst_simd)){\n            if(ERROR_PRINT) {\n                std::cerr << \"Correctness check failed!\" << std::endl;\n            }\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const uint32_t*, uint32_t*, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t length = state.range(0);\n    std::vector<uint32_t> src(length);\n    rng.initialize_vector_with_random_values(src);\n    std::vector<uint32_t> dst(length);\n\n    for (auto _ : state) {\n        Func(src.data(), dst.data(), length);\n        benchmark::DoNotOptimize(dst.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, population_count)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, population_count_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-5", "entrypoint_scalar": "population_count", "entrypoint_simd": "population_count_simd"}
{"task_id": "SimdBench_17_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 16-bit unsigned integer source array (src1);\n- A pointer to a non-empty 16-bit unsigned integer source array (src2);\n- A pointer to a non-empty 16-bit unsigned integer destination array (dst);\n- The length of the array (length).\n\nYour goal is to calculate the element-wise addition of two arrays (src1 and src2)\nand store the result in the destination array (dst).\nThe addition should be saturating, meaning that if the result exceeds the maximum value for uint16_t,\nit should be clamped to UINT16_MAX.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n}", "solution_scalar": "void saturating_add(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint16_t sum = src1[i] + src2[i];\n        dst[i] = (sum < src1[i]) ? UINT16_MAX : sum;\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<uint16_t> src1(length); rng.initialize_vector_with_random_values(src1);\n        std::vector<uint16_t> src2(length); rng.initialize_vector_with_random_values(src2);\n        std::vector<uint16_t> dst(length);\n        std::vector<uint16_t> dst_simd(length);\n\n        if (i == 0) {\n            src1[0] = UINT16_MAX;\n            src2[0] = 1;\n        }\n\n        saturating_add(src1.data(), src2.data(), dst.data(), length);\n        saturating_add_simd(src1.data(), src2.data(), dst_simd.data(), length);\n        \n        if(!allclose(dst, dst_simd)){\n            if(ERROR_PRINT) {\n                std::cerr << \"Correctness check failed!\" << std::endl;\n                std::cerr << \"First mismatch at index: \";\n                for (size_t j = 0; j < length; j++) {\n                    if (dst[j] != dst_simd[j]) {\n                        std::cerr << j << \" (scalar: \" << dst[j] \n                                  << \", SIMD: \" << dst_simd[j] \n                                  << \", src1: \" << src1[j]\n                                  << \", src2: \" << src2[j] << \")\" << std::endl;\n                        break;\n                    }\n                }\n            }\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const uint16_t*, const uint16_t*, uint16_t*, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t length = state.range(0);\n    std::vector<uint16_t> src1(length); rng.initialize_vector_with_random_values(src1);\n    std::vector<uint16_t> src2(length); rng.initialize_vector_with_random_values(src2);\n    std::vector<uint16_t> dst(length);\n\n    for (auto _ : state) {\n        Func(src1.data(), src2.data(), dst.data(), length);\n        benchmark::DoNotOptimize(dst.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, saturating_add)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, saturating_add_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-4", "entrypoint_scalar": "saturating_add", "entrypoint_simd": "saturating_add_simd"}
{"task_id": "SimdBench_18_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point (double) source matrix (A);\n- A pointer to a non-empty 64-bit floating-point (double) source matrix (B);\n- A pointer to a non-empty 64-bit floating-point (double) destination matrix (C);\n- The number of rows in matrix A (m);\n- The number of columns in matrix A and rows in matrix B (n);\n- The number of columns in matrix B (p).\n\nA, B, and C are 2D matrices flattened into 1D arrays.\nYour goal is to perform matrix multiplication of A and B for elements in the range [-100, 100]\n(i.e., skipping summing elements when A[i] or B[i] outside the range),\nand store the result in C.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n}", "solution_scalar": "void range_matrix_mul(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                double a_val = A[i * n + k];\n                double b_val = B[k * p + j];\n                if (a_val >= -100 && a_val <= 100 && b_val >= -100 && b_val <= 100) {\n                    sum += a_val * b_val;\n                }\n            }\n            C[i*p + j] = sum;\n        }\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t m = Small_Arg_2D;\n        size_t n = Small_Arg_2D;\n        size_t p = Small_Arg_2D;\n        \n        std::vector<double> A(m * n);\n        for(auto & item: A) { item = rng.normal_distribution<double>(); }\n        std::vector<double> B(n * p);\n        for(auto & item: B) { item = rng.normal_distribution<double>(); }\n        std::vector<double> C(m * p);\n        std::vector<double> C_simd(C);\n\n        range_matrix_mul(A.data(), B.data(), C.data(), m, n, p);\n        range_matrix_mul_simd(A.data(), B.data(), C_simd.data(), m, n, p);\n        \n        if(!allclose(C, C_simd)){\n            if(ERROR_PRINT) {\n                std::cerr << \"Correctness check failed!\" << std::endl;\n            }\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const double*, const double*, double*, size_t, size_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t m = state.range(0);\n    size_t n = state.range(1);\n    size_t p = state.range(2);\n    \n    std::vector<double> A(m * n);\n    for(auto & item: A) { item = rng.normal_distribution<double>(); }\n    std::vector<double> B(n * p);\n    for(auto & item: B) { item = rng.normal_distribution<double>(); }\n    std::vector<double> C(m * p);\n\n    for (auto _ : state) {\n        Func(A.data(), B.data(), C.data(), m, n, p);\n        benchmark::DoNotOptimize(C.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, range_matrix_mul)->Name(\"Scalar\")->Large_Args_3D;\nBENCHMARK_TEMPLATE(BM, range_matrix_mul_simd)->Name(\"SIMD\")->Large_Args_3D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-5", "entrypoint_scalar": "range_matrix_mul", "entrypoint_simd": "range_matrix_mul_simd"}
{"task_id": "SimdBench_19_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit integer source tensor (A);\n- A pointer to a non-empty 64-bit integer source tensor (B);\n- A pointer to a non-empty 64-bit integer destination tensor (C);\n- The dimensions of the tensor (dim1, dim2, dim3).\n\nA, B, and C are 3D tensors stored in non-empty 1D arrays.\nYour goal is to perform element-wise addition of two 3D tensors (A and B),\nand store the result in C (no overflow).\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n}", "solution_scalar": "void tensor_add_3d(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; i++) {\n        for (size_t j = 0; j < dim2; j++) {\n            for (size_t k = 0; k < dim3; k++) {\n                size_t idx = i*dim2*dim3 + j*dim3 + k;\n                C[idx] = A[idx] + B[idx];\n            }\n        }\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t dim1 = Small_Arg_3D;\n        size_t dim2 = Small_Arg_3D;\n        size_t dim3 = Small_Arg_3D;\n        \n        std::vector<int64_t> A(dim1 * dim2 * dim3); for ( auto & element : A) { element = rng.randint<int64_t>(- (1 << 12), 1 << 12); }\n        std::vector<int64_t> B(dim1 * dim2 * dim3); for ( auto & element : B) { element = rng.randint<int64_t>(- (1 << 12), 1 << 12); }\n        std::vector<int64_t> C(dim1 * dim2 * dim3);\n        std::vector<int64_t> C_simd(dim1 * dim2 * dim3);\n\n        tensor_add_3d(A.data(), B.data(), C.data(), dim1, dim2, dim3);\n        tensor_add_3d_simd(A.data(), B.data(), C_simd.data(), dim1, dim2, dim3);\n        \n        if(!allclose(C, C_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const int64_t*, const int64_t*, int64_t*, size_t, size_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t dim1 = state.range(0);\n    size_t dim2 = state.range(1);\n    size_t dim3 = state.range(2);\n    \n    std::vector<int64_t> A(dim1 * dim2 * dim3); for ( auto & element : A) { element = rng.randint<int64_t>(- (1 << 12), 1 << 12); }\n    std::vector<int64_t> B(dim1 * dim2 * dim3); for ( auto & element : B) { element = rng.randint<int64_t>(- (1 << 12), 1 << 12); }\n    std::vector<int64_t> C(dim1 * dim2 * dim3);\n\n    for (auto _ : state) {\n        Func(A.data(), B.data(), C.data(), dim1, dim2, dim3);\n        benchmark::DoNotOptimize(C.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, tensor_add_3d)->Name(\"Scalar\")->Large_Args_3D;\nBENCHMARK_TEMPLATE(BM, tensor_add_3d_simd)->Name(\"SIMD\")->Large_Args_3D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-2", "entrypoint_scalar": "tensor_add_3d", "entrypoint_simd": "tensor_add_3d_simd"}
{"task_id": "SimdBench_20_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit floating-point source array (src1);\n- A pointer to a non-empty 32-bit floating-point source array (src2);\n- A pointer to a non-empty 32-bit floating-point destination array (dst);\n- The length of the arrays (length).\n\nYour goal is to calculate the result of the element-wise addition of src1 and src2,\nand then round the result to the nearest integer.\nFinally, the result should be stored in the dst array.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n}", "solution_scalar": "void vector_add_round_nearest(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<float> src1(length); rng.initialize_vector_with_random_values(src1);\n        std::vector<float> src2(length); rng.initialize_vector_with_random_values(src2);\n        std::vector<float> dst(length);\n        std::vector<float> dst_simd(length);\n\n        vector_add_round_nearest(src1.data(), src2.data(), dst.data(), length);\n        vector_add_round_nearest_simd(src1.data(), src2.data(), dst_simd.data(), length);\n        \n        if(!allclose(dst, dst_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const float*, const float*, float*, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t length = state.range(0);\n    std::vector<float> src1(length); rng.initialize_vector_with_random_values(src1);\n    std::vector<float> src2(length); rng.initialize_vector_with_random_values(src2);\n    std::vector<float> dst(length);\n\n    for (auto _ : state) {\n        Func(src1.data(), src2.data(), dst.data(), length);\n        benchmark::DoNotOptimize(dst.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, vector_add_round_nearest)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, vector_add_round_nearest_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-3", "entrypoint_scalar": "vector_add_round_nearest", "entrypoint_simd": "vector_add_round_nearest_simd"}
{"task_id": "SimdBench_21_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit floating-point source array (src1);\n- A pointer to a non-empty 32-bit floating-point source array (src2);\n- A pointer to a non-empty 32-bit floating-point destination array (dst);\n- The length of the arrays (length).\n\nYour goal is to calculate the result of the element-wise multiplication of src1 and src2\nfor elements that meet the following conditions:\n    1: the absolute value of the difference is within 50;\n    2: index is is a multiple of 2.\nand then round the result up toward positive infinity.\nFor elements that do not meet the above conditions, the results should be -1.\nFinally, the result should be stored in the dst array.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length){\n}", "solution_scalar": "void vector_mul_round_up(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (i % 2 == 0 && fabsf(src1[i] - src2[i]) <= 50.0f) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<float> src1(length); rng.initialize_vector_with_random_values(src1);\n        std::vector<float> src2(length); rng.initialize_vector_with_random_values(src2);\n        std::vector<float> dst(length);\n        std::vector<float> dst_simd(length);\n\n        vector_mul_round_up(src1.data(), src2.data(), dst.data(), length);\n        vector_mul_round_up_simd(src1.data(), src2.data(), dst_simd.data(), length);\n        \n        if(!allclose(dst, dst_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const float*, const float*, float*, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t length = state.range(0);\n    std::vector<float> src1(length); rng.initialize_vector_with_random_values(src1);\n    std::vector<float> src2(length); rng.initialize_vector_with_random_values(src2);\n    std::vector<float> dst(length);\n\n    for (auto _ : state) {\n        Func(src1.data(), src2.data(), dst.data(), length);\n        benchmark::DoNotOptimize(dst.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, vector_mul_round_up)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, vector_mul_round_up_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-5", "entrypoint_scalar": "vector_mul_round_up", "entrypoint_simd": "vector_mul_round_up_simd"}
{"task_id": "SimdBench_22_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point source matrix (mat);\n- A scalar value in 64-bit floating-point (scalar);\n- A pointer to a non-empty 64-bit floating-point destination matrix (dst);\n- The number of rows in the matrix (m);\n- The number of columns in the matrix (n).\n\nmat and dst are 2D matrices flattened into 1D arrays.\nYour goal is to calculate the result of the element-wise multiplication of mat and scalar,\nand then store the result in the dst matrix.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n}", "solution_scalar": "void matrix_scalar_mul(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < n; j++) {\n            dst[i * n + j] = mat[i * n + j] * scalar;\n        }\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t m = Small_Arg_2D;\n        size_t n = Small_Arg_2D;\n        double scalar = rng.uniform<double>();\n        std::vector<double> mat(m * n); rng.initialize_vector_with_random_values(mat);\n        std::vector<double> dst(m * n);\n        std::vector<double> dst_simd(dst);\n\n        matrix_scalar_mul(mat.data(), scalar, dst.data(), m, n);\n        matrix_scalar_mul_simd(mat.data(), scalar, dst_simd.data(), m, n);\n        \n        if(!allclose(dst, dst_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const double*, double, double*, size_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t m = state.range(0);\n    size_t n = state.range(1);\n    double scalar = rng.uniform<double>();\n    std::vector<double> mat(m * n);\n    rng.initialize_vector_with_random_values(mat);\n    std::vector<double> dst(m * n);\n\n    for (auto _ : state) {\n        Func(mat.data(), scalar, dst.data(), m, n);\n        benchmark::DoNotOptimize(dst.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, matrix_scalar_mul)->Name(\"Scalar\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM, matrix_scalar_mul_simd)->Name(\"SIMD\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-3", "entrypoint_scalar": "matrix_scalar_mul", "entrypoint_simd": "matrix_scalar_mul_simd"}
{"task_id": "SimdBench_23_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit floating-point matrix (mat) that is flattened into a 1D array;\n- The number of rows in the matrix (m);\n- The number of columns in the matrix (n).\n\nYour goal is to normalize each row of the matrix mat by dividing each element in the row by the L^2 norm of that row.\nThe L^2 norm is calculated as the square root of the sum of squares of the elements in the row.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n}", "solution_scalar": "void matrix_normalize_rows(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float norm = 0.0f;\n        for (size_t j = 0; j < n; j++) {\n            norm += mat[i * n + j] * mat[i * n + j];\n        }\n        norm = sqrtf(norm);\n        if (norm > 1e-8f) {\n            for (size_t j = 0; j < n; j++) {\n                mat[i * n + j] /= norm;\n            }\n        }\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t m = Small_Arg_2D;\n        size_t n = Small_Arg_2D;\n        \n        std::vector<float> mat(m * n); rng.initialize_vector_with_random_values(mat);\n        std::vector<float> mat_simd(mat);\n\n        matrix_normalize_rows(mat.data(), m, n);\n        matrix_normalize_rows_simd(mat_simd.data(), m, n);\n        \n        if(!allclose(mat, mat_simd, 1e-6f, 1e-6f)){\n            if(ERROR_PRINT) {\n                std::cerr << \"Correctness check failed!\" << std::endl;\n            }\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(float*, size_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t m = state.range(0);\n    size_t n = state.range(1);\n    \n    std::vector<float> mat(m * n);\n    rng.initialize_vector_with_random_values(mat);\n\n    for (auto _ : state) {\n        Func(mat.data(), m, n);\n        benchmark::DoNotOptimize(mat.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, matrix_normalize_rows)->Name(\"Scalar\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM, matrix_normalize_rows_simd)->Name(\"SIMD\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-3", "entrypoint_scalar": "matrix_normalize_rows", "entrypoint_simd": "matrix_normalize_rows_simd"}
{"task_id": "SimdBench_24_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point matrix (mat1);\n- A pointer to a non-empty 64-bit floating-point matrix (mat2);\n- A pointer to a non-empty 64-bit floating-point destination matrix (dst);\n- The number of rows in the first matrix (m);\n- The number of columns in the first matrix and rows in the second matrix (n);\n- The number of columns in the second matrix (p).\n\nmat1, mat2, and dst are 2D matrices flattened into 1D arrays.\nYour goal is to perform matrix multiplication of mat1 and mat2,\nand then round the result to the nearest integer.\nThe result should be stored in the dst matrix.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n}", "solution_scalar": "void matrix_mul_round_int(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = round(sum);\n        }\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t m = Small_Arg_2D;\n        size_t n = Small_Arg_2D;\n        size_t p = Small_Arg_2D;\n        \n        std::vector<double> mat1(m * n); rng.initialize_vector_with_random_values(mat1);\n        std::vector<double> mat2(n * p); rng.initialize_vector_with_random_values(mat2);\n        std::vector<double> dst(m * p);\n        std::vector<double> dst_simd(m * p);\n\n        matrix_mul_round_int(mat1.data(), mat2.data(), dst.data(), m, n, p);\n        matrix_mul_round_int_simd(mat1.data(), mat2.data(), dst_simd.data(), m, n, p);\n        \n        if(!allclose(dst, dst_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const double*, const double*, double*, size_t, size_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t m = state.range(0);\n    size_t n = state.range(1);\n    size_t p = state.range(2);\n    \n    std::vector<double> mat1(m * n); rng.initialize_vector_with_random_values(mat1);\n    std::vector<double> mat2(n * p); rng.initialize_vector_with_random_values(mat2);\n    std::vector<double> dst(m * p);\n\n    for (auto _ : state) {\n        Func(mat1.data(), mat2.data(), dst.data(), m, n, p);\n        benchmark::DoNotOptimize(dst.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, matrix_mul_round_int)->Name(\"Scalar\")->Large_Args_3D;\nBENCHMARK_TEMPLATE(BM, matrix_mul_round_int_simd)->Name(\"SIMD\")->Large_Args_3D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-3", "entrypoint_scalar": "matrix_mul_round_int", "entrypoint_simd": "matrix_mul_round_int_simd"}
{"task_id": "SimdBench_25_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit floating-point matrix (src);\n- A pointer to a non-empty 32-bit floating-point destination matrix (dst);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nYour goal is to transpose the matrix src and round each element to the nearest quarter (0.25).\nThe result should be stored in the dst matrix.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n}", "solution_scalar": "void matrix_transpose_round_quarter(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j++) {\n            dst[j * rows + i] = roundf(src[i * cols + j] * 4.0f) / 4.0f;\n        }\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t rows = Small_Arg_2D;\n        size_t cols = Small_Arg_2D;\n        \n        std::vector<float> src(rows * cols); \n        rng.initialize_vector_with_random_values(src);\n        std::vector<float> dst(rows * cols);\n        std::vector<float> dst_simd(rows * cols);\n\n        matrix_transpose_round_quarter(src.data(), dst.data(), rows, cols);\n        matrix_transpose_round_quarter_simd(src.data(), dst_simd.data(), rows, cols);\n        \n        if(!allclose(dst, dst_simd, 1e-6f, 1e-6f)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const float*, float*, size_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t rows = state.range(0);\n    size_t cols = state.range(1);\n    \n    std::vector<float> src(rows * cols);\n    rng.initialize_vector_with_random_values(src);\n    std::vector<float> dst(rows * cols);\n\n    for (auto _ : state) {\n        Func(src.data(), dst.data(), rows, cols);\n        benchmark::DoNotOptimize(dst.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, matrix_transpose_round_quarter)->Name(\"Scalar\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM, matrix_transpose_round_quarter_simd)->Name(\"SIMD\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-3", "entrypoint_scalar": "matrix_transpose_round_quarter", "entrypoint_simd": "matrix_transpose_round_quarter_simd"}
{"task_id": "SimdBench_26_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit floating-point tensor (tensor1);\n- A pointer to a non-empty 32-bit floating-point tensor (tensor2);\n- A pointer to a non-empty 32-bit floating-point destination tensor (dst);\n- The first dimension of the tensor (dim1);\n- The second dimension of the tensor (dim2);\n- The third dimension of the tensor (dim3).\n\ntensor1, tensor2, and dst are 3D tensors in the shape (dim1, dim2, dim3) flattened into 1D arrays.\nYour goal is to perform element-wise subtraction of tensor1 and tensor2,\nand then round the result towards zero.\nThe result should be stored in the dst tensor.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n}", "solution_scalar": "void tensor3d_sub_round_zero(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; i++) {\n        for (size_t j = 0; j < dim2; j++) {\n            for (size_t k = 0; k < dim3; k++) {\n                size_t idx = i * dim2 * dim3 + j * dim3 + k;\n                dst[idx] = truncf(tensor1[idx] - tensor2[idx]);\n            }\n        }\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t dim1 = Small_Arg_3D;\n        size_t dim2 = Small_Arg_3D;\n        size_t dim3 = Small_Arg_3D;\n        \n        std::vector<float> tensor1(dim1 * dim2 * dim3); rng.initialize_vector_with_random_values(tensor1);\n        std::vector<float> tensor2(dim1 * dim2 * dim3); rng.initialize_vector_with_random_values(tensor2);\n        std::vector<float> dst(dim1 * dim2 * dim3);\n        std::vector<float> dst_simd(dim1 * dim2 * dim3);\n\n        tensor3d_sub_round_zero(tensor1.data(), tensor2.data(), dst.data(), dim1, dim2, dim3);\n        tensor3d_sub_round_zero_simd(tensor1.data(), tensor2.data(), dst_simd.data(), dim1, dim2, dim3);\n        \n        if(!allclose(dst, dst_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const float*, const float*, float*, size_t, size_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t dim1 = state.range(0);\n    size_t dim2 = state.range(1);\n    size_t dim3 = state.range(2);\n    \n    std::vector<float> tensor1(dim1 * dim2 * dim3); rng.initialize_vector_with_random_values(tensor1);\n    std::vector<float> tensor2(dim1 * dim2 * dim3); rng.initialize_vector_with_random_values(tensor2);\n    std::vector<float> dst(dim1 * dim2 * dim3);\n\n    for (auto _ : state) {\n        Func(tensor1.data(), tensor2.data(), dst.data(), dim1, dim2, dim3);\n        benchmark::DoNotOptimize(dst.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, tensor3d_sub_round_zero)->Name(\"Scalar\")->Large_Args_3D;\nBENCHMARK_TEMPLATE(BM, tensor3d_sub_round_zero_simd)->Name(\"SIMD\")->Large_Args_3D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-3", "entrypoint_scalar": "tensor3d_sub_round_zero", "entrypoint_simd": "tensor3d_sub_round_zero_simd"}
{"task_id": "SimdBench_27_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point matrix (mat1);\n- A pointer to a non-empty 64-bit floating-point matrix (mat2);\n- A pointer to a non-empty 64-bit floating-point destination matrix (dst);\n- The number of rows in the matrices (m);\n- The number of columns in the matrices (n).\n\nmat1, mat2, and dst are 2D matrices flattened into 1D arrays.\nYour goal is to perform the Hadamard product (element-wise multiplication) of mat1 and mat2,\nand then store the result in the dst matrix.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n}", "solution_scalar": "void matrix_hadamard_product(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < n; j++) {\n            dst[i * n + j] = mat1[i * n + j] * mat2[i * n + j];\n        }\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t m = Small_Arg_2D;\n        size_t n = Small_Arg_2D;\n        \n        std::vector<double> mat1(m * n); rng.initialize_vector_with_random_values(mat1);\n        std::vector<double> mat2(m * n); rng.initialize_vector_with_random_values(mat2);\n        std::vector<double> dst(m * n);\n        std::vector<double> dst_simd(m * n);\n\n        matrix_hadamard_product(mat1.data(), mat2.data(), dst.data(), m, n);\n        matrix_hadamard_product_simd(mat1.data(), mat2.data(), dst_simd.data(), m, n);\n        \n        if(!allclose(dst, dst_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const double*, const double*, double*, size_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t m = state.range(0);\n    size_t n = state.range(1);\n    \n    std::vector<double> mat1(m * n);\n    rng.initialize_vector_with_random_values(mat1);\n    std::vector<double> mat2(m * n);\n    rng.initialize_vector_with_random_values(mat2);\n    std::vector<double> dst(m * n);\n\n    for (auto _ : state) {\n        Func(mat1.data(), mat2.data(), dst.data(), m, n);\n        benchmark::DoNotOptimize(dst.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, matrix_hadamard_product)->Name(\"Scalar\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM, matrix_hadamard_product_simd)->Name(\"SIMD\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-3", "entrypoint_scalar": "matrix_hadamard_product", "entrypoint_simd": "matrix_hadamard_product_simd"}
{"task_id": "SimdBench_28_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit floating-point matrix (mat);\n- A pointer to a non-empty 32-bit floating-point vector (vec);\n- A pointer to a non-empty 32-bit floating-point destination vector (dst);\n- The number of rows in the matrix (m);\n- The number of columns in the matrix (n).\n\nThe matrix is flattened into a 1D array.\nmat has the shape (m, n), and vec has the shape (n).\nYour goal is to perform matrix-vector multiplication of mat and vec,\nand then store the result in the dst vector in the shape (m).\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n\n*/\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n}", "solution_scalar": "void matrix_vector_mul(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float sum = 0.0f;\n        for (size_t j = 0; j < n; j++) {\n            sum += mat[i * n + j] * vec[j];\n        }\n        dst[i] = sum;\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t m = Small_Arg_2D;\n        size_t n = Small_Arg_2D;\n        \n        std::vector<float> mat(m * n); rng.initialize_vector_with_random_values(mat);\n        std::vector<float> vec(n); rng.initialize_vector_with_random_values(vec);\n        std::vector<float> dst(m);\n        std::vector<float> dst_simd(m);\n\n        matrix_vector_mul(mat.data(), vec.data(), dst.data(), m, n);\n        matrix_vector_mul_simd(mat.data(), vec.data(), dst_simd.data(), m, n);\n        \n        if(!allclose(dst, dst_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const float*, const float*, float*, size_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t m = state.range(0);\n    size_t n = state.range(1);\n    \n    std::vector<float> mat(m * n); rng.initialize_vector_with_random_values(mat);\n    std::vector<float> vec(n); rng.initialize_vector_with_random_values(vec);\n    std::vector<float> dst(m);\n\n    for (auto _ : state) {\n        Func(mat.data(), vec.data(), dst.data(), m, n);\n        benchmark::DoNotOptimize(dst.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, matrix_vector_mul)->Name(\"Scalar\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM, matrix_vector_mul_simd)->Name(\"SIMD\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-3", "entrypoint_scalar": "matrix_vector_mul", "entrypoint_simd": "matrix_vector_mul_simd"}
{"task_id": "SimdBench_29_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point matrix (mat);\n- The number of rows in the matrix (m);\n- The number of columns in the matrix (n).\n\nYour goal is to calculate and return the average of elements in the matrix mat.\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n}", "solution_scalar": "double matrix_average(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    for (size_t j = 0; j < n; j++) {\n        for (size_t i = 0; i < m; i++) {\n            sum += mat[i * n + j];\n        }\n    }\n    return sum / double(m * n);\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t m = Small_Arg_2D;\n        size_t n = Small_Arg_2D;\n        \n        std::vector<double> mat(m * n);  rng.initialize_vector_with_random_values(mat);\n\n        double avg = matrix_average(mat.data(), m, n);\n        double avg_simd = matrix_average_simd(mat.data(), m, n);\n        \n        if(!allclose(avg, avg_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<double (*Func)(const double*, size_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t m = state.range(0);\n    size_t n = state.range(1);\n    \n    std::vector<double> mat(m * n);  rng.initialize_vector_with_random_values(mat);\n\n    for (auto _ : state) {\n        double res = Func(mat.data(), m, n);\n        benchmark::DoNotOptimize(res);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, matrix_average)->Name(\"Scalar\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM, matrix_average_simd)->Name(\"SIMD\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-3", "entrypoint_scalar": "matrix_average", "entrypoint_simd": "matrix_average_simd"}
{"task_id": "SimdBench_30_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit integer matrix (matrix);\n- A pointer to a boolean array (directions) indicating the sort direction for each row;\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nYour goal is to check if each row in the matrix is sorted according to the specified direction.\nThe value of the boolean array (directions) indicates whether the row should be sorted in ascending (true) or descending (false) order.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n}", "solution_scalar": "bool matrix_rows_sorted_verify(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        bool ascending = directions[i];\n        for (size_t j = 1; j < cols; j++) {\n            int curr = matrix[i*cols + j];\n            int prev = matrix[i*cols + (j-1)];\n            if ((ascending && curr < prev) || (!ascending && curr > prev)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t rows = Small_Arg_2D;\n        size_t cols = Small_Arg_2D;\n        \n        std::vector<int> matrix(rows * cols); for ( auto & element : matrix) { element = rng.randint(- (1 << 8), 1 << 8); }\n        std::vector<uint8_t> directions(rows);\n        rng.initialize_vector_with_random_values(directions, true);\n\n        // Sort each row according to its direction\n        bool sth_wrong = rng.randint(0, 2)%3==0;\n        for (size_t i = 0; i < rows; i++) {\n            if(sth_wrong){\n                bool out_of_order = rng.randint(0, 10)%10==0;\n                if(out_of_order) continue;\n                else{\n                    if(rng.randint(0, 1)==0) std::sort(matrix.begin() + i*cols, matrix.begin() + (i+1)*cols);\n                    else std::sort(matrix.begin() + i*cols, matrix.begin() + (i+1)*cols, std::greater<int>());\n                }\n            } else if (directions[i]) {\n                std::sort(matrix.begin() + i*cols, matrix.begin() + (i+1)*cols);\n            } else {\n                std::sort(matrix.begin() + i*cols, matrix.begin() + (i+1)*cols, std::greater<int>());\n            }\n        }\n\n        bool scalar_result = matrix_rows_sorted_verify(matrix.data(), reinterpret_cast<const bool*>(directions.data()), rows, cols);\n        bool simd_result = matrix_rows_sorted_verify_simd(matrix.data(), reinterpret_cast<const bool*>(directions.data()), rows, cols);\n        \n        if(scalar_result != simd_result){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<bool (*Func)(const int*, const bool*, size_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng(DEFAULT_SEED);\n    size_t rows = state.range(0);\n    size_t cols = state.range(1);\n    \n    std::vector<int> matrix(rows * cols);\n    rng.initialize_vector_with_random_values(matrix);\n    std::vector<uint8_t> directions(rows);\n    rng.initialize_vector_with_random_values(directions, true);\n\n    // Sort the matrix rows according to directions\n    for (size_t i = 0; i < rows; i++) {\n        if (directions[i]) {\n            std::sort(matrix.begin() + i*cols, matrix.begin() + (i+1)*cols);\n        } else {\n            std::sort(matrix.begin() + i*cols, matrix.begin() + (i+1)*cols, std::greater<int>());\n        }\n    }\n\n    for (auto _ : state) {\n        bool result = Func(matrix.data(), reinterpret_cast<const bool*>(directions.data()), rows, cols);\n        benchmark::DoNotOptimize(&result);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, matrix_rows_sorted_verify)->Name(\"Scalar\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM, matrix_rows_sorted_verify_simd)->Name(\"SIMD\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-4", "entrypoint_scalar": "matrix_rows_sorted_verify", "entrypoint_simd": "matrix_rows_sorted_verify_simd"}
{"task_id": "SimdBench_31_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/* \nThe inputs to this function are::\n- A pointer to a non-empty 16-bit integer source array (src);\n- A pointer to a non-empty 16-bit integer destination array (dst);\n- A 8-bit unsigned integer (base) that is greater than 0;\n- The common length of src and dst (length).\n\nYour goal is, for each element in src, to store in dst the nearest integer that \n1) is a multiple of base, and \n2) has a value no more than the value of the element in src.\nNo overflow in the input.\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n}", "solution_scalar": "void nearest_multiple(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        int16_t value = src[i];\n        int16_t mode = ((value % base) + base) % base;\n        dst[i] = value - mode;\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        \n        std::vector<int16_t> src(length); rng.initialize_vector_with_random_values(src);\n        std::vector<int16_t> dst(length);\n        std::vector<int16_t> dst_simd(length);\n\n        uint8_t base = rng.randint<uint8_t>(1, 255);\n\n        nearest_multiple(src.data(), dst.data(), base, length);\n        nearest_multiple_simd(src.data(), dst_simd.data(), base, length);\n        \n        if(!allclose(dst, dst_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const int16_t*, int16_t*, uint8_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t length = state.range(0);\n\n    std::vector<int16_t> src(length); rng.initialize_vector_with_random_values(src);\n    std::vector<int16_t> dst(length);\n    uint8_t base = rng.randint<uint8_t>(1, 255);\n\n    for (auto _ : state) {\n        Func(src.data(), dst.data(), base, length);\n        benchmark::DoNotOptimize(dst.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, nearest_multiple)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, nearest_multiple_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-2", "entrypoint_scalar": "nearest_multiple", "entrypoint_simd": "nearest_multiple_simd"}
{"task_id": "SimdBench_32_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point matrix (matrix);\n- A pointer to a non-empty 64-bit floating-point vector (vector);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nYour goal is to check if any row in the matrix matches the given vector.\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n}", "solution_scalar": "bool matrix_has_row(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        bool match = true;\n        for (size_t j = 0; j < cols; j++) {\n            if (matrix[i * cols + j] != vector[j]) {\n                match = false;\n                break;\n            }\n        }\n        if (match) return true;\n    }\n    return false;\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t rows = Small_Arg_2D;\n        size_t cols = Small_Arg_2D;\n        \n        std::vector<double> matrix(rows * cols); rng.initialize_vector_with_random_values(matrix);\n        std::vector<double> vector(cols); rng.initialize_vector_with_random_values(vector);\n\n        bool correct_case = rng.random_bool();\n        if(correct_case){\n            size_t idx = rng.randint( size_t(0), rows-1);\n            std::copy(vector.begin(), vector.end(), matrix.begin()+idx*cols);\n        }\n\n        bool scalar_result = matrix_has_row(matrix.data(), vector.data(), rows, cols);\n        bool simd_result = matrix_has_row_simd(matrix.data(), vector.data(), rows, cols);\n        \n        if(scalar_result != simd_result){\n            if(ERROR_PRINT) {\n                std::cerr << \"Correctness check failed!\" << std::endl;\n                std::cerr << \"Scalar result: \" << scalar_result \n                          << \", SIMD result: \" << simd_result << std::endl;\n            }\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<bool (*Func)(const double*, const double*, size_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng(DEFAULT_SEED);\n    size_t rows = state.range(0);\n    size_t cols = state.range(1);\n    \n    std::vector<double> matrix(rows * cols); rng.initialize_vector_with_random_values(matrix);\n    std::vector<double> vector(cols); rng.initialize_vector_with_random_values(vector);\n\n    bool correct_case = rng.random_bool();\n    if(correct_case){\n        size_t idx = rng.randint( size_t(0), rows-1);\n        std::copy(vector.begin(), vector.end(), matrix.begin()+idx*cols);\n    }\n\n    for (auto _ : state) {\n        bool result = Func(matrix.data(), vector.data(), rows, cols);\n        benchmark::DoNotOptimize(&result);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, matrix_has_row)->Name(\"Scalar\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM, matrix_has_row_simd)->Name(\"SIMD\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-4", "entrypoint_scalar": "matrix_has_row", "entrypoint_simd": "matrix_has_row_simd"}
{"task_id": "SimdBench_33_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 8-bit unsigned integer tensor (A);\n- A pointer to a non-empty 8-bit unsigned integer tensor (B);\n- An array of 4 size_t integers representing the dimensions of the tensors (dims).\n\nA and B are flattened into 1D arrays.\nYour goal is to count the number of equal elements between the two tensors.\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n}", "solution_scalar": "size_t tensor_4d_equal_count(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t count = 0;\n    size_t total = dims[0] * dims[1] * dims[2] * dims[3];\n    for (size_t i = 0; i < total; i++) {\n        count += (A[i] == B[i]);\n    }\n    return count;\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t dims[4] = {Small_Arg_4D, Small_Arg_4D, Small_Arg_4D, Small_Arg_4D};\n        size_t total = dims[0] * dims[1] * dims[2] * dims[3];\n        \n        std::vector<uint8_t> A(total); rng.initialize_vector_with_random_values(A);\n        std::vector<uint8_t> B(total); rng.initialize_vector_with_random_values(B);\n\n        size_t n = rng.randint(size_t(0), total);\n        while(n-- && total > 0){\n            size_t idx = rng.randint(size_t(0), total-1);\n            B[idx] = A[idx];\n        }\n\n        size_t scalar_result = tensor_4d_equal_count(A.data(), B.data(), dims);\n        size_t simd_result = tensor_4d_equal_count_simd(A.data(), B.data(), dims);\n        \n        if(scalar_result != simd_result){\n            if(ERROR_PRINT) {\n                std::cerr << \"Correctness check failed!\" << std::endl;\n                std::cerr << \"Scalar count: \" << scalar_result \n                          << \", SIMD count: \" << simd_result << std::endl;\n            }\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<size_t (*Func)(const uint8_t*, const uint8_t*, const size_t[4])>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t dims[4] = {static_cast<size_t>(state.range(0)),\n                      static_cast<size_t>(state.range(1)),\n                      static_cast<size_t>(state.range(2)),\n                      static_cast<size_t>(state.range(3))};\n    size_t total = dims[0] * dims[1] * dims[2] * dims[3];\n    \n    std::vector<uint8_t> A(total); rng.initialize_vector_with_random_values(A);\n    std::vector<uint8_t> B(total); rng.initialize_vector_with_random_values(B);\n\n    size_t n = rng.randint(size_t(0), total);\n    while(n-- && total > 0){\n        size_t idx = rng.randint(size_t(0), total-1);\n        B[idx] = A[idx];\n    }\n\n    for (auto _ : state) {\n        size_t count = Func(A.data(), B.data(), dims);\n        benchmark::DoNotOptimize(&count);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, tensor_4d_equal_count)->Name(\"Scalar\")->Large_Args_4D;\nBENCHMARK_TEMPLATE(BM, tensor_4d_equal_count_simd)->Name(\"SIMD\")->Large_Args_4D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-4", "entrypoint_scalar": "tensor_4d_equal_count", "entrypoint_simd": "tensor_4d_equal_count_simd"}
{"task_id": "SimdBench_34_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- The common length of the given vectors;\n- A 64-bit integer `a`;\n- Two pointers to 64-bit integer arrays.\n\nYour goal is to do the element-wise vector operation involving:\n1. scalar-vector multiplication a and x;\n2. absolute value of vector: y;\n3. element-wise subtraction.\nStore the results to `y`.\n\nNo overflow in the input.\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n}", "solution_scalar": "void axm_abs(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; ++i) {\n        y[i] = a * x[i] - llabs(y[i]);\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        \n        int64_t a = rng.randint<int64_t>( - (1 << 20), (1 << 20));\n        std::vector<int64_t> x(length); \n        for (auto & item: x) { item = rng.randint<int64_t>( - (1 << 20), (1 << 20)); }\n        std::vector<int64_t> y_scalar(length);\n        std::vector<int64_t> y_simd(length);\n        for(int i=0; i<length; ++i){\n            int64_t item = rng.randint<int64_t>( - (1 << 20), (1 << 20));\n            y_scalar[i] = item;\n            y_simd[i] = item;\n        }\n\n        axm_abs(length, a, x.data(), y_scalar.data());\n        axm_abs_simd(length, a, x.data(), y_simd.data());\n        \n        if(!allclose(y_scalar, y_simd)){\n            if(ERROR_PRINT) {\n                std::cerr << \"Correctness check failed!\" << std::endl;\n            }\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(size_t, const int64_t, const int64_t*, int64_t *)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t length = state.range(0);\n\n    int64_t a = rng.randint<int64_t>( - (1 << 20), (1 << 20));\n    std::vector<int64_t> x(length); \n    for (auto & item: x) { item = rng.randint<int64_t>( - (1 << 20), (1 << 20)); }\n    std::vector<int64_t> y(length);\n    for(int i=0; i<length; ++i){\n        int64_t item = rng.randint<int64_t>( - (1 << 20), (1 << 20));\n        y[i] = item;\n    }\n\n    for (auto _ : state) {\n        Func(length, a, x.data(), y.data());\n        benchmark::DoNotOptimize(y);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, axm_abs)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, axm_abs_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-2", "entrypoint_scalar": "axm_abs", "entrypoint_simd": "axm_abs_simd"}
{"task_id": "SimdBench_35_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 16-bit integer vector (vec);\n- The length of the given vector.\n\nYour goal is to return the the maximum and minimum values in the given vector.\nThe function should return a value of the defined `MinMaxPair` type:\n```c\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n```\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n}", "solution_scalar": "typedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    if (length == 0 || vec == NULL) {\n        result.min_num = 0;\n        result.max_num = 0;\n        return result;\n    }\n    int16_t min_val = vec[0];\n    int16_t max_val = vec[0];\n\n    for (size_t i = 1; i < length; i++) {\n        min_val = std::min(vec[i], min_val);\n        max_val = std::max(vec[i], max_val);\n    }\n\n    result.min_num = min_val;\n    result.max_num = max_val;\n    return result;\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;       \n        std::vector<int16_t> src(length); rng.initialize_vector_with_random_values(src);\n\n        MinMaxPair res_scalar = min_max_pair(src.data(), length);\n        MinMaxPair res_simd = min_max_pair_simd(src.data(), length);\n        \n        if(!(res_scalar.max_num == res_simd.max_num && \n        res_scalar.min_num == res_simd.min_num)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<MinMaxPair (*Func)(const int16_t*, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t length = state.range(0);\n    std::vector<int16_t> src(length); \n    rng.initialize_vector_with_random_values(src);\n\n    for (auto _ : state) {\n        MinMaxPair res = Func(src.data(), length);\n        benchmark::DoNotOptimize(res);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, min_max_pair)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, min_max_pair_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-2", "entrypoint_scalar": "min_max_pair", "entrypoint_simd": "min_max_pair_simd"}
{"task_id": "SimdBench_36_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 32-bit integer matrix (matrix);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nYour goal is to check if all rows in the matrix are strictly increasing.\nIf the input matrix is empty, return false.\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n}", "solution_scalar": "bool matrix_rows_strictly_increasing(const int* matrix, size_t rows, size_t cols) {\n    if(matrix == NULL || rows <= 0 || cols <= 0) return false;\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 1; j < cols; ++j) {\n            if (matrix[i * cols + j] <= matrix[i * cols + j - 1]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t rows = Small_Arg_2D;\n        size_t cols = Small_Arg_2D;\n        \n        std::vector<int> matrix(rows * cols);\n        \n        for (size_t r = 0; r < rows; r++) {\n            for (size_t c = 0; c < cols; c++) {\n                matrix[r * cols + c] = static_cast<int>(r * cols + c);\n            }\n        }\n\n        bool wrong_case = rng.random_bool();\n        if (wrong_case && rows > 0 && cols > 0) {\n            size_t r = rng.randint(size_t(0), rows-1);\n            size_t c = rng.randint(size_t(0), cols-1);\n            matrix[r*cols + c] = rng.randint<int>();\n        }\n\n        bool scalar_result = matrix_rows_strictly_increasing(matrix.data(), rows, cols);\n        bool simd_result = matrix_rows_strictly_increasing_simd(matrix.data(), rows, cols);\n        \n        if(scalar_result != simd_result){\n            if(ERROR_PRINT) {\n                std::cerr << \"Correctness check failed!\" << std::endl;\n                std::cerr << \"Scalar result: \" << scalar_result \n                          << \", SIMD result: \" << simd_result << std::endl;\n            }\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<bool (*Func)(const int*, size_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng(DEFAULT_SEED);\n    size_t rows = state.range(0);\n    size_t cols = state.range(1);\n    \n    std::vector<int> matrix(rows * cols);\n    \n    for (size_t r = 0; r < rows; r++) {\n        for (size_t c = 0; c < cols; c++) {\n            matrix[r * cols + c] = static_cast<int>(r * cols + c);\n        }\n    }\n\n    bool wrong_case = rng.random_bool();\n    if (wrong_case && rows > 0 && cols > 0) {\n        size_t r = rng.randint(size_t(0), rows-1);\n        size_t c = rng.randint(size_t(0), cols-1);\n        matrix[r*cols + c] = rng.randint<int>();\n    }\n\n    for (auto _ : state) {\n        bool result = Func(matrix.data(), rows, cols);\n        benchmark::DoNotOptimize(&result);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, matrix_rows_strictly_increasing)->Name(\"Scalar\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM, matrix_rows_strictly_increasing_simd)->Name(\"SIMD\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-4", "entrypoint_scalar": "matrix_rows_strictly_increasing", "entrypoint_simd": "matrix_rows_strictly_increasing_simd"}
{"task_id": "SimdBench_37_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 32-bit integer matrix (matrix);\n- The size of each block (block_size);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nYour goal is to check if all blocks of the matrix are equal to the first block.\nReturn true if the given matrix can be perfectly divided into identical blocks of shape (block_size, block_size); \notherwise, return false.\nIf block_size is illegal, return false.\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n}", "solution_scalar": "bool matrix_blocks_equal(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (matrix == NULL) return false;\n    if (block_size <= 0) return false;\n    if (rows % block_size != 0 || cols % block_size != 0) return false;\n    \n    size_t block_rows = rows / block_size;\n    size_t block_cols = cols / block_size;\n\n    // Compare all blocks to first block\n    for (size_t br = 0; br < block_rows; br++) {\n        for (size_t bc = 0; bc < block_cols; bc++) {\n            for (size_t r = 0; r < block_size; r++) {\n                for (size_t c = 0; c < block_size; c++) {\n                    size_t idx1 = r*cols + c; // First block\n                    size_t idx2 = (br*block_size + r)*cols + (bc*block_size + c);\n                    if (matrix[idx1] != matrix[idx2]) return false;\n                }\n            }\n        }\n    }\n    return true;\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        bool wrong_case = rng.random_bool();\n        size_t block_size = rng.randint(size_t(0), size_t(8));\n        size_t rows, cols;\n        if(wrong_case || block_size==0){\n            rows = Small_Arg_2D;\n            cols = Small_Arg_2D;\n        }else{\n            size_t times = rng.randint(size_t(1), size_t(8));\n            rows = block_size * times;\n            cols = block_size * times;\n        }\n        \n        std::vector<int> matrix(rows * cols);\n        for (size_t r = 0; r < rows; r++) {\n            for (size_t c = 0; c < cols; c++) {\n                if(block_size > 0) matrix[r * cols + c] = static_cast<int>((r % block_size) + (c % block_size));\n                else matrix[r * cols + c] = rng.randint<int>();\n            }\n        }\n\n        if (wrong_case) {\n            size_t r = rng.randint(size_t(0), rows - 1);\n            size_t c = rng.randint(size_t(0), cols - 1);\n            matrix[r * cols + c] = rng.randint<int>();\n        }\n\n        bool scalar_result = matrix_blocks_equal(matrix.data(), block_size, rows, cols);\n        bool simd_result = matrix_blocks_equal_simd(matrix.data(), block_size, rows, cols);\n        \n        if(scalar_result != simd_result){\n            if(ERROR_PRINT) {\n                std::cerr << \"Correctness check failed!\" << std::endl;\n            }\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool null_pass = matrix_blocks_equal_simd(NULL, 1, 0, 0) == matrix_blocks_equal(NULL, 1, 0, 0);\n    bool pass = correctness_check(ITERATIONS) && null_pass;\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<bool (*Func)(const int*, size_t, size_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng(DEFAULT_SEED);\n    size_t block_size = rng.randint(size_t(1), size_t(8));\n    size_t rows = block_size * static_cast<size_t>(state.range(0));\n    size_t cols = block_size * static_cast<size_t>(state.range(1));\n    \n    std::vector<int> matrix(rows * cols);\n    for (size_t r = 0; r < rows; r++) {\n        for (size_t c = 0; c < cols; c++) {\n            matrix[r * cols + c] = static_cast<int>((r % block_size) + (c % block_size));\n        }\n    }\n\n    if (rng.random_bool()) {\n        size_t r = rng.randint(size_t(0), rows - 1);\n        size_t c = rng.randint(size_t(0), cols - 1);\n        matrix[r * cols + c] = rng.randint<int>();\n    }\n\n    for (auto _ : state) {\n        bool result = Func(matrix.data(), block_size, rows, cols);\n        benchmark::DoNotOptimize(&result);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, matrix_blocks_equal)->Name(\"Scalar\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM, matrix_blocks_equal_simd)->Name(\"SIMD\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-4", "entrypoint_scalar": "matrix_blocks_equal", "entrypoint_simd": "matrix_blocks_equal_simd"}
{"task_id": "SimdBench_38_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a 64-bit floating-point vector (vec);\n- A 64-bit floating-point tolerance;\n- The length of the given vector (length);\n- The size of each block (block_size).\n\nYour goal is to check whether all blocks (excluding tail elements that cannot form a complete block)\nof the vector are element-wise equal to the first block, within the specified tolerance.\nReturn false is the input is illegal or no complete blocks in block_size.\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n}", "solution_scalar": "bool vector_block_equal(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == NULL || block_size == 0 || length < block_size) {\n        return false;\n    }\n    size_t num_blocks = length / block_size;\n    for (size_t i = 1; i < num_blocks; ++i) {\n        for (size_t j = 0; j < block_size; ++j) {\n            double diff = fabsf(vec[i * block_size + j] - vec[j]);\n            if (diff > tolerance) {\n                return false;\n            }\n        }\n    }\n    return true;\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;    \n    for (int i = 0; i < iterations; i++) {\n        const double tolerance = rng.random<double>();\n        size_t length = Small_Arg_1D;\n        size_t block_size = Small_Arg_2D;\n        std::vector<double> vec(length); for(auto & element: vec) { element = rng.uniform<double>(); }\n        \n        bool correct_case = rng.random_bool();\n        if(correct_case && block_size < length && block_size > 0) { \n            size_t num_blocks = length / block_size;\n            for(int block_n=1; block_n < num_blocks; block_n++){\n                for(int k=0; k<block_size; ++k){\n                    vec[block_n*block_size+k] = vec[ k ];\n                }\n            } \n        }\n\n        bool scalar_result = vector_block_equal(vec.data(), tolerance, length, block_size);\n        bool simd_result = vector_block_equal_simd(vec.data(), tolerance, length, block_size);\n        \n        if(scalar_result != simd_result){\n            if(ERROR_PRINT) {\n                std::cerr << \"Correctness check failed!\" << std::endl;\n                std::cerr << \"Scalar result: \" << scalar_result \n                          << \", SIMD result: \" << simd_result << std::endl;\n            }\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool corner_pass = true;\n    corner_pass = corner_pass && \\\n    ( vector_block_equal(NULL, 1.0f, 0, 100) == vector_block_equal_simd(NULL, 1.0f, 0, 100) );\n    std::vector<double> tmp(100);\n    corner_pass = corner_pass && \\\n    ( vector_block_equal(tmp.data(), 1.0f, 100, 0) == vector_block_equal_simd(tmp.data(), 1.0f, 100, 0) );      \n    bool pass = corner_pass && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<bool (*Func)(const double*, double, size_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng(DEFAULT_SEED);\n    const double tolerance = rng.random<double>();\n    size_t length = state.range(0);\n    size_t block_size = 32;\n    std::vector<double> vec(length); for(auto & element: vec) { element = rng.uniform<double>(); }\n    \n    // true\n    if(block_size < length && block_size > 0) { \n        size_t num_blocks = length / block_size;\n        for(int block_n=1; block_n < num_blocks; block_n++){\n            for(int k=0; k<block_size; ++k){\n                vec[block_n*block_size+k] = vec[ k ];\n            }\n        } \n    }\n\n    for (auto _ : state) {\n        bool result = Func(vec.data(), tolerance, length, block_size);\n        benchmark::DoNotOptimize(&result);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, vector_block_equal)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, vector_block_equal_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-4", "entrypoint_scalar": "vector_block_equal", "entrypoint_simd": "vector_block_equal_simd"}
{"task_id": "SimdBench_39_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit floating-point matrix (matrix);\n- A pointer to a non-empty 64-bit floating-point vector (thresholds);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n- A pointer to a boolean result array (result).\n\nThe input matrix is flattened into a 1D array.\nYour goal is to check if the Euclidean norm of each row in the matrix exceeds the corresponding threshold in the vector.\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n}", "solution_scalar": "void matrix_row_norm_compare(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        double sum_sq = 0.0;\n        for (size_t j = 0; j < cols; j++) {\n            double val = matrix[i*cols + j];\n            sum_sq += val * val;\n        }\n        result[i] = (sqrt(sum_sq) > thresholds[i]);\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t rows = Small_Arg_2D;\n        size_t cols = Small_Arg_2D;\n        \n        std::vector<double> matrix(rows * cols); for(auto & element: matrix) { element = rng.random<double>(); }\n        //rng.initialize_vector_with_random_values(matrix);\n        std::vector<double> thresholds(rows); for(auto & element: thresholds) { element = rng.normal_distribution(1.0, 0.75); }\n        //rng.initialize_vector_with_random_values(thresholds);\n\n        std::vector<uint8_t> result_scalar(rows);\n        std::vector<uint8_t> result_simd(rows);\n\n        matrix_row_norm_compare(matrix.data(), thresholds.data(), rows, cols, reinterpret_cast<bool*>(result_scalar.data()));\n        matrix_row_norm_compare_simd(matrix.data(), thresholds.data(), rows, cols, reinterpret_cast<bool*>(result_simd.data()));\n        \n        if(!allclose(result_scalar, result_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const double*, const double*, size_t, size_t, bool*)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t rows = state.range(0);\n    size_t cols = state.range(1);\n    \n    std::vector<double> matrix(rows * cols); for(auto & element: matrix) { element = rng.random<double>(); }\n    //rng.initialize_vector_with_random_values(matrix);\n    std::vector<double> thresholds(rows); for(auto & element: thresholds) { element = rng.normal_distribution(1.0, 0.75); }\n    //rng.initialize_vector_with_random_values(thresholds);\n\n    std::vector<uint8_t> result(rows);\n\n    for (auto _ : state) {\n        Func(matrix.data(), thresholds.data(), rows, cols, reinterpret_cast<bool*>(result.data()));\n        benchmark::DoNotOptimize(result.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, matrix_row_norm_compare)->Name(\"Scalar\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM, matrix_row_norm_compare_simd)->Name(\"SIMD\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-4", "entrypoint_scalar": "matrix_row_norm_compare", "entrypoint_simd": "matrix_row_norm_compare_simd"}
{"task_id": "SimdBench_40_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit unsigned integer tensor (A);\n- A pointer to a non-empty 32-bit unsigned integer tensor (B);\n- A pointer to a non-empty 32-bit unsigned integer tensor (C);\n- The common length of A, B, and C.\n\nYour goal is to perform element-wise bitwise OR operation between tensors A and B,\nand then store the result in tensor C.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n}", "solution_scalar": "void tensor_bitwise_or(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    for (size_t idx = 0; idx < length; idx++) {\n        C[idx] = A[idx] | B[idx];\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t total = Small_Arg_1D;\n        \n        std::vector<uint32_t> A(total);\n        rng.initialize_vector_with_random_values(A);\n        std::vector<uint32_t> B(total);\n        rng.initialize_vector_with_random_values(B);\n        \n        std::vector<uint32_t> C_scalar(total);\n        std::vector<uint32_t> C_simd(total);\n\n        tensor_bitwise_or(A.data(), B.data(), C_scalar.data(), total);\n        tensor_bitwise_or_simd(A.data(), B.data(), C_simd.data(), total);\n        \n        if(!allclose(C_scalar, C_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const uint32_t*, const uint32_t*, uint32_t*, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t total = state.range(0);\n    \n    std::vector<uint32_t> A(total);\n    rng.initialize_vector_with_random_values(A);\n    std::vector<uint32_t> B(total);\n    rng.initialize_vector_with_random_values(B);\n    std::vector<uint32_t> C(total);\n\n    for (auto _ : state) {\n        Func(A.data(), B.data(), C.data(), total);\n        benchmark::DoNotOptimize(C.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, tensor_bitwise_or)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, tensor_bitwise_or_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-5", "entrypoint_scalar": "tensor_bitwise_or", "entrypoint_simd": "tensor_bitwise_or_simd"}
{"task_id": "SimdBench_41_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/* \nThe inputs to this function are::\n- Pointers to two non-empty 8-bit integer vector (A, B);\n- The common length of A and B\n\nYour goal is to return the difference between the sum of squares and the sum of products.\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n}", "solution_scalar": "int64_t squarediff(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum1 = 0, sum2 = 0;\n    for (int i = 0; i < length; i++) {\n        sum1 += (int64_t)A[i] * A[i] + (int64_t)B[i] * B[i];\n        sum2 += (int64_t)A[i] * B[i];\n    }\n    return sum1 - sum2;\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<int8_t> A(length); rng.initialize_vector_with_random_values(A);\n        std::vector<int8_t> B(length); rng.initialize_vector_with_random_values(B);\n\n        int64_t diff_scalar = squarediff(A.data(), B.data(), length);\n        int64_t diff_simd =  squarediff_simd(A.data(), B.data(), length);\n        \n        if(diff_scalar != diff_simd){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed at iteration \" << i << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<int64_t (*Func)(const int8_t *, const int8_t *, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t length = state.range(0);\n    std::vector<int8_t> A(length); rng.initialize_vector_with_random_values(A);\n    std::vector<int8_t> B(length); rng.initialize_vector_with_random_values(B);\n    \n    for (auto _ : state) {\n        int64_t diff = Func(A.data(), B.data(), length);\n        benchmark::DoNotOptimize(diff);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, squarediff)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, squarediff_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-2", "entrypoint_scalar": "squarediff", "entrypoint_simd": "squarediff_simd"}
{"task_id": "SimdBench_42_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 64-bit unsigned integer tensor (A);\n- A pointer to a non-empty 64-bit unsigned integer tensor (B);\n- A pointer to a non-empty 64-bit unsigned integer tensor (C);\n- The common length of A, B, and C.\n\nYour goal is to perform element-wise bitwise AND operation between tensor A and the bitwise negation of tensor B,\nand then store the result in tensor C.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n}", "solution_scalar": "void tensor_bit_clear(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t idx = 0; idx < length; idx++) {\n        C[idx] = A[idx] & (~B[idx]);\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t total = Small_Arg_1D;\n        \n        std::vector<uint64_t> A(total); rng.initialize_vector_with_random_values(A);\n        std::vector<uint64_t> B(total); rng.initialize_vector_with_random_values(B);\n        \n        std::vector<uint64_t> C_scalar(total);\n        std::vector<uint64_t> C_simd(total);\n\n        tensor_bit_clear(A.data(), B.data(), C_scalar.data(), total);\n        tensor_bit_clear_simd(A.data(), B.data(), C_simd.data(), total);\n        \n        if(!allclose(C_scalar, C_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const uint64_t*, const uint64_t*, uint64_t*, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t total = state.range(0);\n    \n    std::vector<uint64_t> A(total);\n    rng.initialize_vector_with_random_values(A);\n    std::vector<uint64_t> B(total);\n    rng.initialize_vector_with_random_values(B);\n    std::vector<uint64_t> C(total);\n\n    for (auto _ : state) {\n        Func(A.data(), B.data(), C.data(), total);\n        benchmark::DoNotOptimize(C.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, tensor_bit_clear)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, tensor_bit_clear_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-5", "entrypoint_scalar": "tensor_bit_clear", "entrypoint_simd": "tensor_bit_clear_simd"}
{"task_id": "SimdBench_43_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 8-bit integer tensor (A);\n- A pointer to a non-empty 8-bit integer tensor (B);\n- A pointer to a non-empty 8-bit integer tensor (C);\n- The common length of A, B, and C.\n\nYour goal is to perform element-wise three-valued logic operation on tensors A and B,\nif A[i][j][k] and B[i][j][k] are both positive, C[i][j][k] should be 1;\nif A[i][j][k] and B[i][j][k] are both negative, C[i][j][k] should be -1;\nin other cases, C[i][j][k] should be 0.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n}", "solution_scalar": "void tensor_three_valued_logic(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    for (size_t idx = 0; idx < length; idx++) {\n        int a = A[idx], b = B[idx];\n        if (a == 0 || b == 0) {\n            C[idx] = 0;\n        } else if (a > 0 && b > 0) {\n            C[idx] = 1;\n        } else if (a < 0 && b < 0) {\n            C[idx] = -1;\n        } else {\n            C[idx] = 0;\n        }\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t total = Small_Arg_1D;\n        \n        std::vector<int8_t> A(total); rng.initialize_vector_with_random_values(A);      \n        std::vector<int8_t> B(total); rng.initialize_vector_with_random_values(B); \n        \n        std::vector<int8_t> C_scalar(total);\n        std::vector<int8_t> C_simd(total);\n\n        tensor_three_valued_logic(A.data(), B.data(), C_scalar.data(), total);\n        tensor_three_valued_logic_simd(A.data(), B.data(), C_simd.data(), total);\n        \n        if(!allclose(C_scalar, C_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const int8_t*, const int8_t*, int8_t*, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t total = state.range(0);\n    \n    std::vector<int8_t> A(total); rng.initialize_vector_with_random_values(A);      \n    std::vector<int8_t> B(total); rng.initialize_vector_with_random_values(B); \n    std::vector<int8_t> C(total);\n\n    for (auto _ : state) {\n        Func(A.data(), B.data(), C.data(), total);\n        benchmark::DoNotOptimize(C.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, tensor_three_valued_logic)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, tensor_three_valued_logic_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-5", "entrypoint_scalar": "tensor_three_valued_logic", "entrypoint_simd": "tensor_three_valued_logic_simd"}
{"task_id": "SimdBench_44_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 16-bit unsigned integer tensor (A);\n- A pointer to a non-empty 16-bit unsigned integer tensor (B);\n- A pointer to a non-empty 16-bit unsigned integer tensor (C);\n- The common length of A, B, and C.\n\nYour goal is to perform the following operation to A and B,\nand then store the result in tensor C:\nfor the element **exactly** at the midpoint: keep the value in A;\nfor elements before the midpoint: values are element-wise bitwise XOR operation between A and B;\nfor elements before the midpoint: values are element-wise bitwise AND operation between A and B.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n}", "solution_scalar": "void tensor_bit_op(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    double half_idx = double(length) / 2.0;\n    for (size_t idx = 0; idx < length; idx++){\n        if(idx < half_idx) C[idx] = A[idx] ^ B[idx];\n        else if(idx == half_idx) C[idx] = A[idx];\n        else if(idx > half_idx) C[idx] = A[idx] & B[idx];\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t total = Small_Arg_1D;\n        \n        std::vector<uint16_t> A(total); rng.initialize_vector_with_random_values(A);\n        std::vector<uint16_t> B(total); rng.initialize_vector_with_random_values(B);\n        \n        std::vector<uint16_t> C_scalar(total);\n        std::vector<uint16_t> C_simd(total);\n\n        tensor_bit_op(A.data(), B.data(), C_scalar.data(), total);\n        tensor_bit_op_simd(A.data(), B.data(), C_simd.data(), total);\n\n        if(!allclose(C_scalar, C_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const uint16_t*, const uint16_t*, uint16_t*, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t total = state.range(0);\n    \n    std::vector<uint16_t> A(total);\n    rng.initialize_vector_with_random_values(A);\n    std::vector<uint16_t> B(total);\n    rng.initialize_vector_with_random_values(B);\n    std::vector<uint16_t> C(total);\n\n    for (auto _ : state) {\n        Func(A.data(), B.data(), C.data(), total);\n        benchmark::DoNotOptimize(C.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, tensor_bit_op)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, tensor_bit_op_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-5", "entrypoint_scalar": "tensor_bit_op", "entrypoint_simd": "tensor_bit_op_simd"}
{"task_id": "SimdBench_45_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit floating-point tensor (A);\n- A pointer to a non-empty 32-bit floating-point tensor (B);\n- A pointer to a non-empty 32-bit floating-point tensor (C);\n- A pointer to a non-empty 32-bit floating-point tensor (D);\n- A pointer to a boolean condition tensor (cond1);\n- A pointer to a boolean condition tensor (cond2);\n- The first dimension of the tensor (dim1);\n- The second dimension of the tensor (dim2);\n- The third dimension of the tensor (dim3).\n\nA, B, C, and D are 3D tensors that are flattened into 1D arrays.\nYour goal is to perform element-wise selection based on the conditions in cond1 and cond2.\nIf cond1[i][j][k] is true and cond2[i][j][k] is true, out[i][j][k] should be A[i][j][k];\nif cond1[i][j][k] is true and cond2[i][j][k] is false, out[i][j][k] should be B[i][j][k];\nif cond1[i][j][k] is false and cond2[i][j][k] is true, out[i][j][k] should be C[i][j][k];\nif cond1[i][j][k] is false and cond2[i][j][k] is false, out[i][j][k] should be D[i][j][k].\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n}", "solution_scalar": "void tensor_multi_select(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; i++) {\n        for (size_t j = 0; j < dim2; j++) {\n            for (size_t k = 0; k < dim3; k++) {\n                size_t idx = i * dim2 * dim3 + j * dim3 + k;\n                bool c1 = cond1[idx], c2 = cond2[idx];\n                if (c1 && c2) out[idx] = A[idx];\n                else if (c1 && !c2) out[idx] = B[idx];\n                else if (!c1 && c2) out[idx] = C[idx];\n                else out[idx] = D[idx];\n            }\n        }\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t dim1 = Small_Arg_3D;\n        size_t dim2 = Small_Arg_3D;\n        size_t dim3 = Small_Arg_3D;\n        size_t total = dim1 * dim2 * dim3;\n\n        std::vector<float> A(total); rng.initialize_vector_with_random_values(A);\n        std::vector<float> B(total); rng.initialize_vector_with_random_values(B);\n        std::vector<float> C(total); rng.initialize_vector_with_random_values(C);\n        std::vector<float> D(total); rng.initialize_vector_with_random_values(D);\n\n        std::vector<uint8_t> cond1_data(total);\n        rng.initialize_vector_with_random_values(cond1_data, true);\n        const bool* cond1 = reinterpret_cast<const bool*>(cond1_data.data());\n        \n        std::vector<uint8_t> cond2_data(total);\n        rng.initialize_vector_with_random_values(cond2_data, true);\n        const bool* cond2 = reinterpret_cast<const bool*>(cond2_data.data());\n        \n        std::vector<float> out_scalar(total);\n        std::vector<float> out_simd(total);\n\n        tensor_multi_select(A.data(), B.data(), C.data(), D.data(),\n                           cond1, cond2, out_scalar.data(),\n                           dim1, dim2, dim3);\n        tensor_multi_select_simd(A.data(), B.data(), C.data(), D.data(),\n                                cond1, cond2, out_simd.data(),\n                                dim1, dim2, dim3);\n        \n        if(!allclose(out_scalar, out_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const float*, const float*, const float*, const float*,\n    const bool*, const bool*, float*,\n    size_t, size_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t dim1 = state.range(0);\n    size_t dim2 = state.range(1);\n    size_t dim3 = state.range(2);\n    size_t total = dim1 * dim2 * dim3;\n\n    std::vector<float> A(total); rng.initialize_vector_with_random_values(A);\n    std::vector<float> B(total); rng.initialize_vector_with_random_values(B);\n    std::vector<float> C(total); rng.initialize_vector_with_random_values(C);\n    std::vector<float> D(total); rng.initialize_vector_with_random_values(D);\n\n    std::vector<uint8_t> cond1_data(total);\n    rng.initialize_vector_with_random_values(cond1_data, true);\n    const bool* cond1 = reinterpret_cast<const bool*>(cond1_data.data());\n    \n    std::vector<uint8_t> cond2_data(total);\n    rng.initialize_vector_with_random_values(cond2_data, true);\n    const bool* cond2 = reinterpret_cast<const bool*>(cond2_data.data());\n    std::vector<float> out(total);\n\n    for (auto _ : state) {\n        Func(A.data(), B.data(), C.data(), D.data(),\n            cond1, cond2, out.data(),\n            dim1, dim2, dim3);\n        benchmark::DoNotOptimize(out.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, tensor_multi_select)->Name(\"Scalar\")->Large_Args_3D;\nBENCHMARK_TEMPLATE(BM, tensor_multi_select_simd)->Name(\"SIMD\")->Large_Args_3D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-5", "entrypoint_scalar": "tensor_multi_select", "entrypoint_simd": "tensor_multi_select_simd"}
{"task_id": "SimdBench_46_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit unsigned integer tensor (A);\n- A pointer to a non-empty 8-bit unsigned integer tensor (out);\n- The first dimension of the tensor (dim1);\n- The second dimension of the tensor (dim2);\n- The third dimension of the tensor (dim3).\n\nA and out are 3D tensors flattened into 1D arrays.\nYour goal is to count the number of bits set to 1 in each element of tensor A,\nand then store the result in tensor out.\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n}", "solution_scalar": "void tensor_bit_count(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t length = dim1 * dim2 * dim3;\n    for(size_t idx = 0; idx < length; ++idx){\n        uint32_t val = A[idx];\n        uint8_t count = 0;\n        while (val) {\n            count += val & 1;\n            val >>= 1;\n        }\n        out[idx] = count;\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t dim1 = Small_Arg_3D;\n        size_t dim2 = Small_Arg_3D;\n        size_t dim3 = Small_Arg_3D;\n        size_t total = dim1 * dim2 * dim3;\n        \n        std::vector<uint32_t> A(total);\n        int idx = 0;\n        for (auto& val : A) {\n            val = rng.randint<uint32_t>();\n            // corner cases\n            if (idx % 16 == 0) val = 0;\n            else if (idx % 16 == 1) val = ~0u;\n            else if (idx % 16 == 2) val = 0x55555555;\n            else if (idx % 16 == 3) val = 0xAAAAAAAA;\n            idx++;\n        }\n        \n        std::vector<uint8_t> out_scalar(total);\n        std::vector<uint8_t> out_simd(total);\n\n        tensor_bit_count(A.data(), out_scalar.data(), dim1, dim2, dim3);\n        tensor_bit_count_simd(A.data(), out_simd.data(), dim1, dim2, dim3);\n        \n        if(!allclose(out_scalar, out_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const uint32_t*, uint8_t*, size_t, size_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t dim1 = state.range(0);\n    size_t dim2 = state.range(1);\n    size_t dim3 = state.range(2);\n    size_t total = dim1 * dim2 * dim3;\n    \n    std::vector<uint32_t> A(total);\n    for (auto& val : A) {\n        val = rng.randint<uint32_t>();\n    }\n    \n    std::vector<uint8_t> out(total);\n\n    for (auto _ : state) {\n        Func(A.data(), out.data(), dim1, dim2, dim3);\n        benchmark::DoNotOptimize(out.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, tensor_bit_count)->Name(\"Scalar\")->Large_Args_3D;\nBENCHMARK_TEMPLATE(BM, tensor_bit_count_simd)->Name(\"SIMD\")->Large_Args_3D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-5", "entrypoint_scalar": "tensor_bit_count", "entrypoint_simd": "tensor_bit_count_simd"}
{"task_id": "SimdBench_47_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit integer matrix (A);\n- A pointer to a non-empty 32-bit integer destination matrix (B);\n- The number of rows in the matrix (rows);\n- The number of columns in the matrix (cols).\n\nA and B are 2D matrices flattened into 1D arrays.\nYour goal is to apply the condition to the matrix A. If the condition is true,\nthe corresponding element in C should be the absolute value of A.\nIf the condition is false, the corresponding element in C should be the same as in A.\nThe condition is whether the current element is divisible by 3.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n}", "solution_scalar": "void matrix_conditional_abs(const int* A, int* B, size_t rows, size_t cols) {\n    size_t length = rows*cols;\n    for (size_t idx = 0; idx < length; idx++) {\n        int val = A[idx];\n        B[idx] = (val % 3 == 0) ? (val < 0 ? -val : val) : val;\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t rows = Small_Arg_2D;\n        size_t cols = Small_Arg_2D;\n        size_t total = rows * cols;\n        \n        std::vector<int> A(total); rng.initialize_vector_with_random_values(A);\n        \n        std::vector<int> B_scalar(total);\n        std::vector<int> B_simd(total);\n        matrix_conditional_abs(A.data(), B_scalar.data(), rows, cols);\n        matrix_conditional_abs_simd(A.data(), B_simd.data(), rows, cols);\n        \n        if(!allclose(B_scalar, B_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed at iteration \" << i << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const int*, int*, size_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t rows = state.range(0);\n    size_t cols = state.range(1);\n    size_t total = rows * cols;\n    \n    std::vector<int> A(total); rng.initialize_vector_with_random_values(A);\n    std::vector<int> B(total);\n\n    for (auto _ : state) {\n        Func(A.data(), B.data(), rows, cols);\n        benchmark::DoNotOptimize(B.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, matrix_conditional_abs)->Name(\"Scalar\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM, matrix_conditional_abs_simd)->Name(\"SIMD\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-4", "entrypoint_scalar": "matrix_conditional_abs", "entrypoint_simd": "matrix_conditional_abs_simd"}
{"task_id": "SimdBench_48_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit unsigned integer vector (src);\n- A pointer to a non-empty 32-bit unsigned integer destination vector (dst);\n- A 8-bit integer value of the number of bits to rotate (rotate_bits);\n- The number of common length of src and dst.\n\nYour goal is to perform a conditional bitwise rotation on the src vector.\nThe condition in this task is whether the low 4 bits of current element in src are all 1.\nIf the condition is true, the element in dst should be the result of \nrotating the corresponding element in src by `rotate_bits` bits toward the low bits;\notherwise, the element in dst should be bitwise negation of the corresponding element in src.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n}", "solution_scalar": "void matrix_conditional_bit_rotate(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    rotate_bits %= 32;\n    for (size_t idx = 0; idx < length; idx++) {\n        uint32_t val = src[idx];\n        if (val & 0xf == 0xf) {\n            dst[idx] = (val >> rotate_bits) | (val << (32 - rotate_bits));\n        } else {\n            dst[idx] = val;\n        }\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t rows = Small_Arg_2D;\n        size_t cols = Small_Arg_2D;\n        size_t total = rows * cols;\n        std::vector<uint32_t> src(total); rng.initialize_vector_with_random_values(src);\n        uint8_t rotate_bits = rng.randint<uint8_t>();\n        \n        std::vector<uint32_t> dst_scalar(total);\n        std::vector<uint32_t> dst_simd(total);\n\n        matrix_conditional_bit_rotate(src.data(), dst_scalar.data(), rotate_bits, total);\n        matrix_conditional_bit_rotate_simd(src.data(), dst_simd.data(), rotate_bits, total);\n        \n        if(!allclose(dst_scalar, dst_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed at iteration \" << i << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const uint32_t*, uint32_t*, uint8_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng(DEFAULT_SEED);\n    size_t rows = state.range(0);\n    size_t cols = state.range(1);\n    size_t total = rows * cols;\n\n    std::vector<uint32_t> src(total); rng.initialize_vector_with_random_values(src);\n    uint8_t rotate_bits = rng.randint<uint8_t>();\n    \n    std::vector<uint32_t> dst(total);\n\n    for (auto _ : state) {\n        Func(src.data(), dst.data(), rotate_bits, total);\n        benchmark::DoNotOptimize(dst.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, matrix_conditional_bit_rotate)->Name(\"Scalar\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM, matrix_conditional_bit_rotate_simd)->Name(\"SIMD\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-5", "entrypoint_scalar": "matrix_conditional_bit_rotate", "entrypoint_simd": "matrix_conditional_bit_rotate_simd"}
{"task_id": "SimdBench_49_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are::\n- A pointer to a non-empty 32-bit floating-point tensor (A);\n- A pointer to a non-empty 32-bit floating-point tensor (B);\n- A pointer to a non-empty 32-bit floating-point tensor (out);\n- A floating-point epsilon value (epsilon);\n- The common length of the tensors.\n\nYour goal is to perform element-wise comparison between tensors A and B.\nIf A[i] - B[i] > abs(epsilon), out[i] should be 1;\nif A[i] - B[i] < -abs(epsilon), out[i] should be -1;\nif abs(A[i] - B[i]) <= abs(epsilon), out[i] should be 0.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n}", "solution_scalar": "void tensor_ternary_compare(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    for (size_t idx = 0; idx < length; idx++) {\n        float diff = A[idx] - B[idx];\n        float eps = abs(epsilon);\n        if (diff > eps) out[idx] = 1;\n        else if (diff < -eps) out[idx] = -1;\n        else out[idx] = 0;\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t total = Small_Arg_1D;\n        float epsilon = rng.normal_distribution<float>(0.0f, 10.0f);\n\n        std::vector<float> A(total); rng.initialize_vector_with_random_values(A);\n        std::vector<float> B(total); rng.initialize_vector_with_random_values(B);\n        \n        // corner case\n        if(i==0){ \n            for(int idx=0; idx<total; ++idx){\n                B[idx] = A[idx] + pow(-1, idx) * epsilon;\n            }\n        } \n        \n        std::vector<int8_t> out_scalar(total); rng.initialize_vector_with_random_values(out_scalar);\n        std::vector<int8_t> out_simd(out_scalar);\n\n        tensor_ternary_compare(A.data(), B.data(), out_scalar.data(), epsilon, total);\n        tensor_ternary_compare_simd(A.data(), B.data(), out_simd.data(), epsilon, total);\n        \n        if(!allclose(out_scalar, out_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed at iteration \" << i << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const float*, const float*, int8_t*, float, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t total = state.range(0);\n    float epsilon = rng.normal_distribution<float>(0.0f, 10.0f);\n\n    std::vector<float> A(total); rng.initialize_vector_with_random_values(A);\n    std::vector<float> B(total); rng.initialize_vector_with_random_values(B);\n    std::vector<int8_t> out(total);\n\n    for (auto _ : state) {\n        Func(A.data(), B.data(), out.data(), epsilon, total);\n        benchmark::DoNotOptimize(out.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, tensor_ternary_compare)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, tensor_ternary_compare_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-4", "entrypoint_scalar": "tensor_ternary_compare", "entrypoint_simd": "tensor_ternary_compare_simd"}
{"task_id": "SimdBench_50_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit floating-point (float) source array (A);\n- A pointer to a non-empty 32-bit integer (int32_t) destination array (B);\n- The common length of the arrays (size).\n\nYour goal is to convert the float values in A to int32_t values in B.\nThe conversion should be done in a way that if the float value is greater than INT32_MAX,\nit should be set to INT32_MAX, and if its value is less than INT32_MIN, it should be set to INT32_MIN, \notherwise, it should be converted to int32_t directly.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n}", "solution_scalar": "void float_to_int_saturate(const float* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        float val = A[i];\n        if (val > INT32_MAX) B[i] = INT32_MAX;\n        else if (val < INT32_MIN) B[i] = INT32_MIN;\n        else B[i] = (int32_t)val;\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<float> src(length);\n        for (auto & element: src) { element = ((int64_t)1 << 32) * rng.normal_distribution<float>(0.0, 1.0); }\n        std::vector<int32_t> dst(length); rng.initialize_vector_with_random_values(dst);\n        std::vector<int32_t> dst_simd(dst);\n        \n        float_to_int_saturate(src.data(), dst.data(), length);\n        float_to_int_saturate_simd(src.data(), dst_simd.data(), length);\n        \n        if (!allclose(dst, dst_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const float*, int32_t*, size_t)>\nstatic void BM_FloatToIntSaturate(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<float> src(length); \n    for (auto & element: src) { element = ((int64_t)1 << 32) * rng.normal_distribution<float>(0.0, 1.0); }\n    std::vector<int32_t> dst(length); \n    rng.initialize_vector_with_random_values(dst);\n    \n    for (auto _ : state) {\n        Func(src.data(), dst.data(), length);\n        benchmark::DoNotOptimize(dst.data());\n    }\n}\n\n\nBENCHMARK_TEMPLATE(BM_FloatToIntSaturate, float_to_int_saturate)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_FloatToIntSaturate, float_to_int_saturate_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-6", "entrypoint_scalar": "float_to_int_saturate", "entrypoint_simd": "float_to_int_saturate_simd"}
{"task_id": "SimdBench_51_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit integer (int32_t) source array (A);\n- An int8_t scale factor (scale);\n- A pointer to a non-empty 32-bit floating-point (float) destination array (B);\n- The size of the arrays (size).\n\nYour goal is to convert the int32_t values in A to values in float type in B,\nand scale them by the given scale factor.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n}", "solution_scalar": "void int_to_float_scaled(const int32_t* A, int8_t scale, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (float)A[i] * scale;\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;    \n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<int32_t> src(length);\n        std::vector<float> dst(length);\n        std::vector<float> dst_simd(length);\n        const int8_t test_scale = rng.randint<int8_t>();\n        rng.initialize_vector_with_random_values(src);\n        \n        int_to_float_scaled(src.data(), test_scale, dst.data(), length);\n        int_to_float_scaled_simd(src.data(), test_scale, dst_simd.data(), length);      \n        \n        if (!allclose(dst, dst_simd)) {\n            if (ERROR_PRINT) {\n                std::cerr << \"Correctness check failed at iteration \" << i << std::endl;\n                std::cerr << \"Expected: \" << dst[0] << \" Got: \" << dst_simd[0] << std::endl;\n            }\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0; \n}", "test_performance": "template<void (*Func)(const int32_t*, int8_t, float*, size_t)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<int32_t> src(length); rng.initialize_vector_with_random_values(src);\n    std::vector<float> dst(length);\n    const int8_t scale = rng.randint<int8_t>();\n    \n    for (auto _ : state) {\n        Func(src.data(), scale, dst.data(), length);\n        benchmark::DoNotOptimize(dst.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, int_to_float_scaled)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, int_to_float_scaled_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-6", "entrypoint_scalar": "int_to_float_scaled", "entrypoint_simd": "int_to_float_scaled_simd"}
{"task_id": "SimdBench_52_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit floating-point (float) source array (A);\n- A pointer to a non-empty 32-bit floating-point (float) source array (B);\n- A pointer to a non-empty 32-bit integer (int32_t) destination array (C);\n- The common length of the arrays (size).\n\nYour goal is to perform element-wise division of A by B,\nand round the result to the nearest integer in the range that can be represented by a 32-bit integer.\nThe result should be stored in C.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n}", "solution_scalar": "void float_div_round(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        float val = roundf(A[i] / B[i]);\n        if (val > INT32_MAX) C[i] = INT32_MAX;\n        else if (val < INT32_MIN) C[i] = INT32_MIN;\n        else C[i] = (int32_t)val;\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<float> A(length);\n        std::vector<float> B(length);\n        std::vector<int32_t> C(length);\n        std::vector<int32_t> C_simd(length);\n        \n        for (auto & element: A) { element = ((int64_t)1 << 32) * rng.normal_distribution<float>(0.0, 1.0); }\n        rng.initialize_vector_with_random_values(B);\n\n        float_div_round(A.data(), B.data(), C.data(), length);\n        float_div_round_simd(A.data(), B.data(), C_simd.data(), length);\n        \n        if(!allclose(C, C_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const float*, const float*, int32_t*, size_t)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<float> A(length);\n    std::vector<float> B(length);\n    std::vector<int32_t> C(length);\n    \n    for (auto & element: A) { element = ((int64_t)1 << 32) * rng.normal_distribution<float>(0.0, 1.0); }\n    rng.initialize_vector_with_random_values(B);\n\n    for (auto _ : state) {\n        Func(A.data(), B.data(), C.data(), length);\n        benchmark::DoNotOptimize(C.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, float_div_round)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, float_div_round_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-6", "entrypoint_scalar": "float_div_round", "entrypoint_simd": "float_div_round_simd"}
{"task_id": "SimdBench_53_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 64-bit floating-point (double) source array (A);\n- A pointer to a non-empty 32-bit floating-point (float) destination array (B);\n- The common length of the arrays (size).\n\nYour goal is to convert the double values in A to float values in B.\nThe conversion should be done in a way that if the double value is greater than FLT_MAX,\nit should be set to FLT_MAX, and if it is less than -FLT_MAX, it should be set to -FLT_MAX, else\nit should be converted to float directly.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n}", "solution_scalar": "void double_to_float_saturate(const double* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        double val = A[i];\n        if (val > FLT_MAX) B[i] = FLT_MAX;\n        else if (val < -FLT_MAX) B[i] = -FLT_MAX;\n        else B[i] = (float)val;\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<double> A(length);\n        std::vector<float> B(length);\n        std::vector<float> B_simd(length);\n        \n        for(auto & item: A) { item = (double)(FLT_MAX) * rng.normal_distribution<double>(0.0, 2.0); }\n\n        double_to_float_saturate(A.data(), B.data(), length);\n        double_to_float_saturate_simd(A.data(), B_simd.data(), length);\n        \n        if(!allclose(B, B_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const double*, float*, size_t)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<double> A(length);\n    std::vector<float> B(length);\n    \n    for(auto & item: A) { item = (double)(FLT_MAX) * rng.normal_distribution<double>(0.0, 2.0); }\n\n    for (auto _ : state) {\n        Func(A.data(), B.data(), length);\n        benchmark::DoNotOptimize(B.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, double_to_float_saturate)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, double_to_float_saturate_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-6", "entrypoint_scalar": "double_to_float_saturate", "entrypoint_simd": "double_to_float_saturate_simd"}
{"task_id": "SimdBench_54_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 16-bit integer (int16_t) source array (A);\n- A pointer to a non-empty 32-bit integer (int32_t) destination array (B);\n- The common length of the arrays (size).\n\nYour goal is to convert the int16_t values in A to int32_t values in B.\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n}", "solution_scalar": "void int16_to_int32(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<int16_t> A(length);\n        std::vector<int32_t> B(length);\n        std::vector<int32_t> B_simd(length);\n        \n        rng.initialize_vector_with_random_values(A);\n\n        int16_to_int32(A.data(), B.data(), length);\n        int16_to_int32_simd(A.data(), B_simd.data(), length);\n        \n        if(!allclose(B, B_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const int16_t*, int32_t*, size_t)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<int16_t> A(length);\n    std::vector<int32_t> B(length);\n    \n    rng.initialize_vector_with_random_values(A);\n\n    for (auto _ : state) {\n        Func(A.data(), B.data(), length);\n        benchmark::DoNotOptimize(B.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, int16_to_int32)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, int16_to_int32_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-6", "entrypoint_scalar": "int16_to_int32", "entrypoint_simd": "int16_to_int32_simd"}
{"task_id": "SimdBench_55_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit floating-point (float) source array (A);\n- A pointer to a non-empty 32-bit integer (int32_t) control array (control);\n- A pointer to a non-empty 32-bit floating-point (float) destination array (B);\n- The common length of the arrays (size);\n- A float min_val;\n- A float max_val.\n\nYour goal is to min-max normalize the values in array A based on the control array and the given min_val and max_val.\n\nThe min-max normalization should be done in a way that if the control value is greater than 0,\nthe value in A should be normalized to the range [0, 1] using min_val and max_val.\n\nThe normalization formula is:\nval = (A[i] - min_val) / (max_val - min_val);\nIf the result is less than 0, it should be set to 0.0f.\nIf the result is greater than 1, it should be set to 1.0f.\nThe result should be stored in B[i].\n\nIf the control value is less than or equal to 0, the value in A should be copied directly to B.\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n}", "solution_scalar": "void conditional_normalize(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    for (size_t i = 0; i < size; i++) {\n        if (control[i] > 0) {\n            float val = A[i];\n            val = (val - min_val) / (max_val - min_val);\n            B[i] = val < 0.0f ? 0.0f : (val > 1.0f ? 1.0f : val);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<float> A(length);\n        std::vector<int32_t> control(length);\n        std::vector<float> B(length);\n        std::vector<float> B_simd(length);\n        \n        rng.initialize_vector_with_random_values(A);\n        rng.initialize_vector_with_random_values(control);\n\n        float a = rng.uniform<float>(), b = rng.uniform<float>();\n        float min_val = std::min(a, b);\n        float max_val = std::max(a, b) + 0.1; // assert(min_val != max_val)\n\n        conditional_normalize(A.data(), control.data(), B.data(), length, min_val, max_val);\n        conditional_normalize_simd(A.data(), control.data(), B_simd.data(), length, min_val, max_val);\n        \n        if(!allclose(B, B_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const float*, const int32_t*, float*, size_t, float, float)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<float> A(length);\n    std::vector<int32_t> control(length);\n    std::vector<float> B(length);\n    std::vector<float> B_simd(length);\n    \n    rng.initialize_vector_with_random_values(A);\n    rng.initialize_vector_with_random_values(control);\n\n    float a = rng.uniform<float>(), b = rng.uniform<float>();\n    float min_val = std::min(a, b);\n    float max_val = std::max(a, b) + 0.1; // assert(min_val != max_val)\n\n    for (auto _ : state) {\n        Func(A.data(), control.data(), B.data(), length, min_val, max_val);\n        benchmark::DoNotOptimize(B.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, conditional_normalize)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, conditional_normalize_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-4", "entrypoint_scalar": "conditional_normalize", "entrypoint_simd": "conditional_normalize_simd"}
{"task_id": "SimdBench_56_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit unsigned integer (uint32_t) source array (A);\n- A pointer to a non-empty 32-bit floating-point (float) destination array (B);\n- The common length of the arrays (size).\n\nYour goal is:\n    First, convert the high 16 bits of the uint32_t value in A to float;\n    Then, take the square root of the float value;\n    Finally, store the result in B.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n}", "solution_scalar": "void int_to_float_sqrt(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        uint16_t high16 = static_cast<uint16_t>(A[i] >> 16);\n        float fval = static_cast<float>(high16);\n        B[i] = sqrtf(fval);\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<uint32_t> A(length);\n        std::vector<float> B(length);\n        std::vector<float> B_simd(length);\n        \n        rng.initialize_vector_with_random_values(A);\n\n        int_to_float_sqrt(A.data(), B.data(), length);\n        int_to_float_sqrt_simd(A.data(), B_simd.data(), length);\n        \n        if(!allclose(B, B_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const uint32_t*, float*, size_t)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<uint32_t> A(length);\n    std::vector<float> B(length);\n    \n    rng.initialize_vector_with_random_values(A);\n\n    for (auto _ : state) {\n        Func(A.data(), B.data(), length);\n        benchmark::DoNotOptimize(B.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, int_to_float_sqrt)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, int_to_float_sqrt_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-6", "entrypoint_scalar": "int_to_float_sqrt", "entrypoint_simd": "int_to_float_sqrt_simd"}
{"task_id": "SimdBench_57_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit unsigned integer (uint32_t) source array (A);\n- A pointer to a non-empty 32-bit floating-point (float) destination array (B);\n- The common length of the arrays (size).\n\nYour goal is to:\n1. Interpret the bit pattern of each uint32_t value in A as an IEEE 754 floating-point representation\n2. Store the resulting float value in B without any numerical conversion\n3. This is effectively a type-punning operation that reinterprets the bits directly\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n}", "solution_scalar": "void int_bits_to_float(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        union { uint32_t i; float f; } u;\n        u.i = A[i];\n        B[i] = u.f;\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<uint32_t> A(length);\n        std::vector<float> B(length);\n        std::vector<float> B_simd(length);\n        \n        rng.initialize_vector_with_random_values(A);\n\n        int_bits_to_float(A.data(), B.data(), length);\n        int_bits_to_float_simd(A.data(), B_simd.data(), length);\n        \n        if(!allclose(B, B_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const uint32_t*, float*, size_t)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<uint32_t> A(length);\n    std::vector<float> B(length);\n    \n    rng.initialize_vector_with_random_values(A);\n\n    for (auto _ : state) {\n        Func(A.data(), B.data(), length);\n        benchmark::DoNotOptimize(B.data());\n    }\n}\nBENCHMARK_TEMPLATE(BM, int_bits_to_float)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, int_bits_to_float_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-6", "entrypoint_scalar": "int_bits_to_float", "entrypoint_simd": "int_bits_to_float_simd"}
{"task_id": "SimdBench_58_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit integer (int32_t) source array (A);\n- A pointer to a non-empty boolean condition array (cond);\n- A pointer to a non-empty 32-bit floating-point (float) destination array (diff);\n- The common length of the arrays (size).\n\nYour goal is to:\n1. Compute the difference between consecutive elements (A[i] - A[i-1]) when cond[i] is true\n2. Convert the difference to float and store in diff[i]\n3. Set diff[i] to 0.0f when cond[i] is false\n4. The first element (diff[0]) is always set to 0.0f as there's no previous element\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n}", "solution_scalar": "void conditional_diff(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    diff[0] = 0.0f;\n    for (size_t i = 1; i < size; i++) {\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i-1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<int32_t> A(length);\n        std::vector<uint8_t> cond(length);\n        std::vector<float> diff(length);\n        std::vector<float> diff_simd(length);\n        \n        rng.initialize_vector_with_random_values(A);\n        rng.initialize_vector_with_random_values(cond, true);\n\n        conditional_diff(A.data(), reinterpret_cast<const bool*>(cond.data()), diff.data(), length);\n        conditional_diff_simd(A.data(), reinterpret_cast<const bool*>(cond.data()), diff_simd.data(), length);\n\n        if(!allclose(diff, diff_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const int32_t*, const bool*, float*, size_t)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<int32_t> A(length);\n    std::vector<u_int8_t> cond(length);\n    std::vector<float> diff(length);\n    \n    rng.initialize_vector_with_random_values(A);\n    rng.initialize_vector_with_random_values(cond, true);\n\n    for (auto _ : state) {\n        Func(A.data(), reinterpret_cast<const bool*>(cond.data()), diff.data(), length);\n        benchmark::DoNotOptimize(diff.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, conditional_diff)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, conditional_diff_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-6", "entrypoint_scalar": "conditional_diff", "entrypoint_simd": "conditional_diff_simd"}
{"task_id": "SimdBench_59_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 32-bit unsigned integer (uint32_t) source array (src);\n- A pointer to a non-empty 64-bit unsigned integer (uint64_t) destination array (dst);\n- The common length of the arrays (length).\n\nYour goal is to:\n1. Convert each element in src to a 64-bit unsigned integer;\n2. Set all the high 32 bits of each value to 1 and store the results in dst.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n}", "solution_scalar": "void widening_uint(const uint32_t* src, uint64_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        uint64_t val = static_cast<uint64_t>(src[i]);\n        val |= 0xFFFFFFFF00000000ULL;\n        dst[i] = val;\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<uint32_t> src(length);\n        std::vector<uint64_t> dst(length);\n        std::vector<uint64_t> dst_simd(length);\n        \n        rng.initialize_vector_with_random_values(src);\n\n        widening_uint(src.data(), dst.data(), length);\n        widening_uint_simd(src.data(), dst_simd.data(), length);\n\n        if(!allclose(dst, dst_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const uint32_t*, uint64_t*, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    const size_t length = state.range(0);\n\n    std::vector<uint32_t> src(length);\n    std::vector<uint64_t> dst(length);\n    rng.initialize_vector_with_random_values(src);\n\n    for (auto _ : state) {\n        Func(src.data(), dst.data(), length);\n        benchmark::DoNotOptimize(dst.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, widening_uint)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, widening_uint_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-6", "entrypoint_scalar": "widening_uint", "entrypoint_simd": "widening_uint_simd"}
{"task_id": "SimdBench_60_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 64-bit floating-point source array (vec);\n- A pointer to a non-empty 16-bit integer (int16_t) index array (index);\n- The common length of the arrays (length).\n\nYour goal is to:\nFor all legal indices `index[i]` (i.e., within the range [0, length)), sum the elements `vec[index[i]]`, \nand return the result.\n\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n}", "solution_scalar": "double indexed_sum(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    for (size_t i = 0; i < length; ++i) {\n        if (index[i] < length && index[i] >= 0) {\n            sum += vec[index[i]];\n        }\n    }\n    return sum;\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<double> vec(length); rng.initialize_vector_with_random_values(vec);\n        std::vector<int16_t> index(length);\n        for(auto& item: index){\n            item = rng.randint<int16_t>( -(2*length), 2*length );\n        }\n\n        double res_scalar = indexed_sum(vec.data(), index.data(), length);\n        double res_simd = indexed_sum_simd(vec.data(), index.data(), length);\n\n        if(!allclose(res_scalar, res_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<double (*Func)(const double*, const int16_t*, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    const size_t length = state.range(0);\n    std::vector<double> vec(length); rng.initialize_vector_with_random_values(vec);\n    std::vector<int16_t> index(length);\n    for(auto& item: index){\n        item = rng.randint<int16_t>( -(2*length), 2*length );\n    }\n\n    for (auto _ : state) {\n        double res = Func(vec.data(), index.data(), length);\n        benchmark::DoNotOptimize(res);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, indexed_sum)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, indexed_sum_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-5", "entrypoint_scalar": "indexed_sum", "entrypoint_simd": "indexed_sum_simd"}
{"task_id": "SimdBench_61_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nInput to this function are:\n- A pointer to a non-empty 64-bit floating-point (double) input array (input);\n- A pointer to a non-empty 64-bit floating-point (double) kernel array (kernel);\n- A pointer to a non-empty 64-bit floating-point (double) destination array (output);\n- The size of the input array (input_size);\n- The size of the kernel array (kernel_size).\n\nYour goal is to implement a simple 2D Convolution function (conv2d) using ReLU activation.\nThe input array is in the shape (input_size, input_size).\nThe kernel array is in the shape (kernel_size, kernel_size). \nThe output array is in the shape (input_size - kernel_size + 1, input_size - kernel_size + 1).\nAll three arrays are flattened into 1D arrays.\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n}", "solution_scalar": "void simple_conv2d(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n\n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    size_t input_row = i + ki;\n                    size_t input_col = j + kj;\n                    size_t input_index = input_row * input_size + input_col;\n                    size_t kernel_index = ki * kernel_size + kj;\n                    \n                    sum += input[input_index] * kernel[kernel_index];\n                }\n            }\n\n            // ReLU activation\n            if (sum < 0) { sum = 0.0; }\n            output[i * output_size + j] = sum;\n        }\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t input_size = Small_Arg_2D;\n        size_t kernel_size = rng.randint(size_t(1), input_size);\n        size_t output_size = input_size - kernel_size + 1;\n\n        std::vector<double> input(input_size * input_size); rng.initialize_vector_with_random_values(input);\n        std::vector<double> kernel(kernel_size * kernel_size); rng.initialize_vector_with_random_values(kernel);\n        std::vector<double> output_scalar(output_size * output_size); rng.initialize_vector_with_random_values(output_scalar);\n        std::vector<double> output_simd(output_scalar);\n        \n        simple_conv2d(input.data(), kernel.data(), output_scalar.data(), input_size, kernel_size);\n        simple_conv2d_simd(input.data(), kernel.data(), output_simd.data(), input_size, kernel_size);\n\n        if(!allclose(output_scalar, output_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const double*, const double*, double*, size_t, size_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n\n    size_t input_size = state.range(0);\n    size_t kernel_size = 8;\n    size_t output_size = input_size - kernel_size + 1;\n\n    std::vector<double> input(input_size * input_size); rng.initialize_vector_with_random_values(input);\n    std::vector<double> kernel(kernel_size * kernel_size); rng.initialize_vector_with_random_values(kernel);\n    std::vector<double> output(output_size * output_size);\n\n    for (auto _ : state) {\n        Func(input.data(), kernel.data(), output.data(), input_size, kernel_size);\n        benchmark::DoNotOptimize(output.data());\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, simple_conv2d)->Name(\"Scalar\")->Medium_Args_1D;\nBENCHMARK_TEMPLATE(BM, simple_conv2d_simd)->Name(\"SIMD\")->Medium_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-4", "entrypoint_scalar": "simple_conv2d", "entrypoint_simd": "simple_conv2d_simd"}
{"task_id": "SimdBench_62_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nCheck if in given vector of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements_simd({1.0, 2.0, 3.0}, 0.5)\nfalse\n>>> has_close_elements_simd({1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3)\ntrue\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold){\n}", "solution_scalar": "bool has_close_elements(const std::vector<double> & numbers, double threshold){\n    int i,j;\n    \n    for (i=0;i<numbers.size();i++)\n    for (j=i+1;j<numbers.size();j++)\n    if (std::abs(numbers[i]-numbers[j])<threshold)\n    return true;\n\n    return false;\n}", "test_correctness": "bool humaneval_check(){\n    std::vector<double> a={1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    bool res = true;\n    res = res && (has_close_elements_simd(a, 0.3)==true);\n    res = res && (has_close_elements_simd(a, 0.05) == false);\n\n    res = res && (has_close_elements_simd({1.0, 2.0, 5.9, 4.0, 5.0}, 0.95) == true);\n    res = res && (has_close_elements_simd({1.0, 2.0, 5.9, 4.0, 5.0}, 0.8) ==false);\n    res = res && (has_close_elements_simd({1.0, 2.0, 3.0, 4.0, 5.0}, 2.0) == true);\n    res = res && (has_close_elements_simd({1.1, 2.2, 3.1, 4.1, 5.1}, 1.0) == true);\n    res = res && (has_close_elements_simd({1.1, 2.2, 3.1, 4.1, 5.1}, 0.5) == false);\n    return res;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n\n        std::vector<double> numbers(length); rng.initialize_vector_with_random_values(numbers);\n        double threshold = rng.normal_distribution<double>();\n        \n        bool res_scalar = has_close_elements(numbers, threshold);\n        bool res_simd = has_close_elements_simd(numbers, threshold);\n\n        if(!allclose(res_scalar, res_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<bool (*Func)(const std::vector<double> &, double)>\nstatic void BM(benchmark::State& state) {\n    Random rng(DEFAULT_SEED);\n\n    size_t length = state.range(0);\n    std::vector<double> numbers(length); rng.initialize_vector_with_random_values(numbers);\n    double threshold = rng.normal_distribution<double>();\n\n    for (auto _ : state) {\n        bool res = Func(numbers, threshold);\n        benchmark::DoNotOptimize(res);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, has_close_elements)->Name(\"Scalar\")->Medium_Args_1D;\nBENCHMARK_TEMPLATE(BM, has_close_elements_simd)->Name(\"SIMD\")->Medium_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/0", "entrypoint_scalar": "has_close_elements", "entrypoint_simd": "has_close_elements_simd"}
{"task_id": "SimdBench_63_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nYou\"re given a vector of deposit and withdrawal operations on a bank account that starts with\nzero balance. Your task is to detect if at any point the balance of account falls below zero, and\nat that point function should return true. Otherwise it should return false.\n>>> below_zero_simd({1, 2, 3})\nfalse\n>>> below_zero_simd({1, 2, -4, 5})\ntrue\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nbool below_zero_simd(std::vector<int> operations){\n}", "solution_scalar": "bool below_zero(std::vector<int> operations){\n    int num=0;\n    for (int i=0;i<operations.size();i++)\n    {\n        num+=operations[i];\n        if (num<0) return true;\n    }\n    return false;\n}", "test_correctness": "bool humaneval_check(){\n    bool res = true;\n    res = res && (below_zero_simd({}) == false);\n    res = res && (below_zero_simd({1, 2, -3, 1, 2, -3}) == false);\n    res = res && (below_zero_simd({1, 2, -4, 5, 6}) == true);\n    res = res && (below_zero_simd({1, -1, 2, -2, 5, -5, 4, -4}) == false);\n    res = res && (below_zero_simd({1, -1, 2, -2, 5, -5, 4, -5}) == true);\n    res = res && (below_zero_simd({1, -2, 2, -2, 5, -5, 4, -4}) == true);\n    return res;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n\n        std::vector<int> operations(length);\n        for(auto& item:operations){\n            item = rng.randint<int>(-10.0, 20.0);\n        }\n        \n        bool res_scalar = below_zero(operations);\n        bool res_simd = below_zero_simd(operations);\n\n        if(!allclose(res_scalar, res_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<bool (*Func)(std::vector<int>)>\nstatic void BM(benchmark::State& state) {\n    Random rng(DEFAULT_SEED);\n\n    size_t length = state.range(0);\n    std::vector<int> operations(length);\n    for(auto& item:operations){\n        item = rng.randint<int>(-10.0, 20.0);\n    }\n\n    for (auto _ : state) {\n        bool res = Func(operations);\n        benchmark::DoNotOptimize(res);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, below_zero)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, below_zero_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/3", "entrypoint_scalar": "below_zero", "entrypoint_simd": "below_zero_simd"}
{"task_id": "SimdBench_64_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nFor a given vector of input numbers, calculate Mean Absolute Deviation\naround the mean of this dataset.\nMean Absolute Deviation is the average absolute difference between each\nelement and a centerpoint (mean in this case):\nMAD = average | x - x_mean |\n>>> mean_absolute_deviation_simd({1.0, 2.0, 3.0, 4.0})\n1.0\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\ndouble mean_absolute_deviation_simd(std::vector<double> numbers){\n}", "solution_scalar": "double mean_absolute_deviation(std::vector<double> numbers){\n    double sum=0;\n    double avg,msum,mavg;\n    int i=0;\n    for (i=0;i<numbers.size();i++)\n        sum+=numbers[i];\n    avg=sum/numbers.size();\n    msum=0;\n    for (i=0;i<numbers.size();i++)\n        msum+=abs(numbers[i]-avg);\n    return msum/numbers.size();\n}", "test_correctness": "bool humaneval_check(){\n    bool res = true;\n    res = res && (abs(mean_absolute_deviation_simd({1.0, 2.0, 3.0}) - 2.0/3.0) < 1e-4);\n    res = res && (abs(mean_absolute_deviation_simd({1.0, 2.0, 3.0, 4.0}) - 1.0) < 1e-4);\n    res = res && (abs(mean_absolute_deviation_simd({1.0, 2.0, 3.0, 4.0, 5.0}) - 6.0/5.0) < 1e-4);\n    return res;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n\n        std::vector<double> numbers(length); \n        rng.initialize_vector_with_random_values(numbers);\n        \n        double res_scalar = mean_absolute_deviation(numbers);\n        double res_simd = mean_absolute_deviation_simd(numbers);\n\n        if(!allclose(res_scalar, res_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<double (*Func)(std::vector<double>)>\nstatic void BM(benchmark::State& state) {\n    Random rng(DEFAULT_SEED);\n\n    size_t length = state.range(0);\n    std::vector<double> numbers(length);\n    rng.initialize_vector_with_random_values(numbers);\n\n    for (auto _ : state) {\n        double res = Func(numbers);\n        benchmark::DoNotOptimize(res);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, mean_absolute_deviation)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, mean_absolute_deviation_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/4", "entrypoint_scalar": "mean_absolute_deviation", "entrypoint_simd": "mean_absolute_deviation_simd"}
{"task_id": "SimdBench_65_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nInsert a number \"delimeter\" between every two consecutive elements of input vector `numbers\"\n>>> intersperse_simd({}, 4)\n{}\n>>> intersperse_simd({1, 2, 3}, 4)\n{1, 4, 2, 4, 3}\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter){ \n}", "solution_scalar": "std::vector<int> intersperse(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) {\n        return {};\n    }\n    size_t output_size = numbers.size() + (numbers.size() - 1);\n    std::vector<int> out(output_size);\n\n    size_t out_index = 0;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        out[out_index++] = numbers[i];\n        if (i != numbers.size() - 1) { \n            out[out_index++] = delimeter;\n        }\n    }\n    return out;\n}", "test_correctness": "bool humaneval_check(){\n    bool res = true;\n    res = res && (allclose(intersperse_simd({}, 7), {}));\n    res = res && (allclose(intersperse_simd({5, 6, 3, 2}, 8),{5, 8, 6, 8, 3, 8, 2}));\n    res = res && (allclose(intersperse_simd({2, 2, 2}, 2),{2, 2, 2, 2, 2}));\n    return res;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n\n        std::vector<int> numbers(length);\n        rng.initialize_vector_with_random_values(numbers);\n        int delimeter = rng.randint<int>();\n        \n        std::vector<int> res_scalar = intersperse(numbers, delimeter);\n        std::vector<int> res_simd = intersperse_simd(numbers, delimeter);\n\n        if(!allclose(res_scalar, res_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::vector<int> (*Func)(std::vector<int>, int)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n\n    size_t length = state.range(0);\n    std::vector<int> numbers(length);\n    rng.initialize_vector_with_random_values(numbers);\n    int delimeter = rng.randint<int>();\n\n    for (auto _ : state) {\n        std::vector<int> res = Func(numbers, delimeter);\n        benchmark::DoNotOptimize(res);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, intersperse)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, intersperse_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/5", "entrypoint_scalar": "intersperse", "entrypoint_simd": "intersperse_simd"}
{"task_id": "SimdBench_66_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nFor a given vector of integers, return a vector consisting of a sum and a product of all the integers in a vector.\nEmpty sum should be equal to 0 and empty product should be equal to 1.\n>>> sum_product_simd({})\n(0, 1)\n>>> sum_product_simd({1, 2, 3, 4})\n(10, 24)\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers){\n}", "solution_scalar": "std::vector<int64_t> sum_product(std::vector<int16_t> numbers){\n    int64_t sum=0,product=1;\n    for (int i=0;i<numbers.size();i++)\n    {\n        sum+=numbers[i];\n        product*=numbers[i];\n    }\n    return {sum,product};\n}", "test_correctness": "bool humaneval_check(){\n    bool res = true;\n    res = res && (allclose(sum_product_simd({}) ,{0, 1}));\n    res = res && (allclose(sum_product_simd({1, 1, 1}), {3, 1}));\n    res = res && (allclose(sum_product_simd({100, 0}),{100, 0}));\n    res = res && (allclose(sum_product_simd({3, 5, 7}) , {3 + 5 + 7, 3 * 5 * 7}));\n    res = res && (allclose(sum_product_simd({10}) ,{10, 10}));\n    return res;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = rng.randint(size_t(1), size_t(32));\n\n        std::vector<int16_t> numbers(length);\n        for(auto& item:numbers){\n            item = rng.randint<int16_t>(1, 4);\n        }\n        \n        std::vector<int64_t> res_scalar = sum_product(numbers);\n        std::vector<int64_t> res_simd = sum_product_simd(numbers);\n\n        if(!allclose(res_scalar, res_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::vector<int64_t> (*Func)(std::vector<int16_t>)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n\n    size_t length = state.range(0);\n    std::vector<int16_t> numbers(length);\n    for(auto& item:numbers){\n        item = 1;\n    }\n\n    for (auto _ : state) {\n        std::vector<int64_t> res = Func(numbers);\n        benchmark::DoNotOptimize(res);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, sum_product)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, sum_product_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/8", "entrypoint_scalar": "sum_product", "entrypoint_simd": "sum_product_simd"}
{"task_id": "SimdBench_67_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nFrom a given vector of integers, generate a vector of rolling maximum element found until given moment\nin the sequence.\n>>> rolling_max_simd({1, 2, 3, 2, 3, 4, 2})\n{1, 2, 3, 3, 3, 4, 4}\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> rolling_max_simd(std::vector<int> numbers){\n}", "solution_scalar": "std::vector<int> rolling_max(std::vector<int> numbers) {\n    if (numbers.empty()) {\n        return {};\n    }\n    std::vector<int> out(numbers.size());\n    int max = numbers[0];\n    out[0] = max;\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        max = std::max(max, numbers[i]);\n        out[i] = max;\n    }\n    return out;\n}", "test_correctness": "bool humaneval_check(){\n    bool res = true;\n    res = res && (allclose(rolling_max_simd({}),{}));\n    res = res && (allclose(rolling_max_simd({1, 2, 3, 4}) , {1, 2, 3, 4}));\n    res = res && (allclose(rolling_max_simd({4, 3, 2, 1}),{4, 4, 4, 4}));\n    res = res && (allclose(rolling_max_simd({3, 2, 3, 100, 3}) ,{3, 3, 3, 100, 100}));\n    return res;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n\n        std::vector<int> numbers(length); rng.initialize_vector_with_random_values(numbers);       \n        std::vector<int> res_scalar = rolling_max(numbers);\n        std::vector<int> res_simd = rolling_max_simd(numbers);\n\n        if(!allclose(res_scalar, res_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::vector<int> (*Func)(std::vector<int>)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n\n    size_t length = state.range(0);\n    std::vector<int> numbers(length); rng.initialize_vector_with_random_values(numbers);\n\n    for (auto _ : state) {\n        std::vector<int> res = Func(numbers);\n        benchmark::DoNotOptimize(res);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, rolling_max)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, rolling_max_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/9", "entrypoint_scalar": "rolling_max", "entrypoint_simd": "rolling_max_simd"}
{"task_id": "SimdBench_68_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nInput are two strings a and b consisting only of 1s and 0s.\nPerform binary XOR on these inputs and return result also as a string.\n>>> string_xor_simd(\"010\", \"110\")\n\"100\"\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::string string_xor_simd(std::string a, std::string b){\n}", "solution_scalar": "std::string string_xor(std::string a, std::string b){\n    std::string output=\"\";\n    for (int i=0;(i<a.length() and i<b.length());i++)\n    {\n        if (i<a.length() and i<b.length())\n        {\n            if (a[i]== b[i]) \n            {\n                output+='0';\n            }  \n            else output+='1';\n        }\n        else\n        {\n            if (i>=a.length()) \n            {\n            output+=b[i];\n            }\n            else output+=a[i];\n        }\n    }\n    return output;\n}", "test_correctness": "bool humaneval_check(){\n    bool res = true;\n    res = res && (string_xor_simd(\"111000\", \"101010\") == \"010010\");\n    res = res && (string_xor_simd(\"1\", \"1\") == \"0\");\n    res = res && (string_xor_simd(\"0101\", \"0000\") == \"0101\");\n    return res;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        const std::string charset = \"01\";\n        std::string a = rng.random_string(charset, length);\n        std::string b = rng.random_string(charset, length);\n              \n        std::string res_scalar = string_xor(a, b);\n        std::string res_simd = string_xor_simd(a, b);\n\n        if(!allclose(res_scalar, res_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::string (*Func)(std::string, std::string)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t length = state.range(0);\n    const std::string charset = \"01\";\n    std::string a = rng.random_string(charset, length);\n    std::string b = rng.random_string(charset, length);\n\n    for (auto _ : state) {\n        std::string res = Func(a, b);\n        benchmark::DoNotOptimize(res);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, string_xor)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, string_xor_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/11", "entrypoint_scalar": "string_xor", "entrypoint_simd": "string_xor_simd"}
{"task_id": "SimdBench_69_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nOut of vector of strings, return the longest one. Return the first one in case of multiple\nstrings of the same length. Return None in case the input vector is empty.\n>>> longest_simd({})\n\n>>> longest_simd({\"a\", \"b\", \"c\"})\n\"a\"\n>>> longest_simd({\"a\", \"bb\", \"ccc\"})\n\"ccc\"\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::string longest_simd(const std::vector<std::string> & strings){\n}", "solution_scalar": "std::string longest(const std::vector<std::string>& strings){\n    std::string out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].length()>out.length()) out=strings[i];\n    }\n    return out;\n}", "test_correctness": "bool humaneval_check(){\n    bool res = true;\n    res = res && (longest_simd({}) == \"\");\n    res = res && (longest_simd({\"x\", \"y\", \"z\"}) == \"x\");\n    res = res && (longest_simd({\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"}) == \"zzzz\");\n    return res;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        const std::string charset = CHARSET_ALPHANUMERIC;\n        std::vector<std::string> strings(length);\n        for(auto& item: strings){\n            item = rng.random_string(charset, rng.randint(size_t(0), size_t(64)));\n        }\n              \n        std::string res_scalar = longest(strings);\n        std::string res_simd = longest_simd(strings);\n\n        if(!allclose(res_scalar, res_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::string (*Func)(const std::vector<std::string>&)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t length = state.range(0);\n    const std::string charset = CHARSET_ALPHANUMERIC;\n    std::vector<std::string> strings(length);\n    for(auto& item: strings){\n        item = rng.random_string(charset, rng.randint(size_t(0), size_t(64)));\n    }\n\n    for (auto _ : state) {\n        std::string res = Func(strings);\n        benchmark::DoNotOptimize(res);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, longest)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, longest_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/12", "entrypoint_scalar": "longest", "entrypoint_simd": "longest_simd"}
{"task_id": "SimdBench_70_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nReturn a greatest common divisor of two positive integers a and b\n>>> greatest_common_divisor_simd(3, 5)\n1\n>>> greatest_common_divisor_simd(25, 15)\n5\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b){\n}", "solution_scalar": "uint64_t greatest_common_divisor(uint64_t a, uint64_t b){\n    uint64_t out, m;\n    while (true){\n        if (a<b) \n        {\n            m=a;a=b;b=m;\n        }\n        a=a%b;\n        if (a==0) return b;\n    }\n}", "test_correctness": "bool humaneval_check(){\n    bool res = true;\n    res = res && (greatest_common_divisor_simd(3, 7) == 1);\n    res = res && (greatest_common_divisor_simd(10, 15) == 5);\n    res = res && (greatest_common_divisor_simd(49, 14) == 7);\n    res = res && (greatest_common_divisor_simd(144, 60) == 12);\n    return res;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        uint64_t a = rng.randint<uint64_t>(1);\n        uint64_t b = rng.randint<uint64_t>(1);\n        \n        uint64_t result = greatest_common_divisor(a, b);\n        uint64_t result_simd = greatest_common_divisor_simd(a, b);\n        \n        if(result != result_simd){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<uint64_t (*Func)(uint64_t, uint64_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng(state.range(0));\n    uint64_t a = rng.randint<uint64_t>(1);\n    uint64_t b = rng.randint<uint64_t>(1, 1024);\n\n    for (auto _ : state) {\n        uint64_t res = Func(a, b);\n        benchmark::DoNotOptimize(res);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, greatest_common_divisor)->Name(\"Scalar\")->RangeMultiplier(2)->Range(2, 2<<8);\nBENCHMARK_TEMPLATE(BM, greatest_common_divisor_simd)->Name(\"SIMD\")->RangeMultiplier(2)->Range(2, 2<<8);\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/13", "entrypoint_scalar": "greatest_common_divisor", "entrypoint_simd": "greatest_common_divisor_simd"}
{"task_id": "SimdBench_71_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nFrom a supplied vector of numbers (of length at least two) select and return two that are the closest to each\nother and return them in order (smaller number, larger number).\n>>> find_closest_elements_simd({1.0, 2.0, 3.0, 4.0, 5.0, 2.2})\n(2.0, 2.2)\n>>> find_closest_elements_simd({1.0, 2.0, 3.0, 4.0, 5.0, 2.0})\n(2.0, 2.0)\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers){\n}", "solution_scalar": "std::vector<float> find_closest_elements(std::vector<float> numbers){\n    std::vector<float> out={};\n    for (int i=0;i<numbers.size();i++)\n    for (int j=i+1;j<numbers.size();j++)\n        if (out.size()==0 or std::abs(numbers[i]-numbers[j])<std::abs(out[0]-out[1]))\n            out={numbers[i],numbers[j]};\n    if (out[0]>out[1])\n        out={out[1],out[0]};\n    return out;\n}", "test_correctness": "bool humaneval_check(){\n    bool pass = true;\n    pass = pass && (allclose(find_closest_elements_simd({1.0, 2.0, 3.9, 4.0, 5.0, 2.2}) , {3.9, 4.0}));\n    pass = pass && (allclose(find_closest_elements_simd({1.0, 2.0, 5.9, 4.0, 5.0}) , {5.0, 5.9} ));\n    pass = pass && (allclose(find_closest_elements_simd({1.0, 2.0, 3.0, 4.0, 5.0, 2.2}) ,{2.0, 2.2}));\n    pass = pass && (allclose(find_closest_elements_simd({1.0, 2.0, 3.0, 4.0, 5.0, 2.0}) ,{2.0, 2.0}));\n    pass = pass && (allclose(find_closest_elements_simd({1.1, 2.2, 3.1, 4.1, 5.1}) , {2.2, 3.1}));\n    return true;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = rng.randint(size_t(2), size_t(512));\n        std::vector<float> numbers(length);\n        rng.initialize_vector_with_random_values(numbers);\n        \n        std::vector<float> result = find_closest_elements(numbers);\n        std::vector<float> result_simd = find_closest_elements_simd(numbers);\n        \n        if(result.size() != 2 || result_simd.size() != 2 || \n           result[0] != result_simd[0] || result[1] != result_simd[1]){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::vector<float> (*Func)(std::vector<float>)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<float> numbers(length);\n    rng.initialize_vector_with_random_values(numbers);\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(numbers));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, find_closest_elements)->Name(\"Scalar\")->Medium_Args_1D;\nBENCHMARK_TEMPLATE(BM, find_closest_elements_simd)->Name(\"SIMD\")->Medium_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/20", "entrypoint_scalar": "find_closest_elements", "entrypoint_simd": "find_closest_elements_simd"}
{"task_id": "SimdBench_72_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven vector of numbers (of at least two elements), apply a linear transform to that vector,\nsuch that the smallest number will become 0 and the largest will become 1\n>>> rescale_to_unit_simd({1.0, 2.0, 3.0, 4.0, 5.0})\n{0.0, 0.25, 0.5, 0.75, 1.0}\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers){ \n}", "solution_scalar": "std::vector<float> rescale_to_unit(std::vector<float> numbers){ \n    float min=100000,max=-100000;\n    for (int i=0;i<numbers.size();i++)\n        {\n            if (numbers[i]<min) min=numbers[i];\n            if (numbers[i]>max) max=numbers[i];\n        }\n    for (int i=0;i<numbers.size();i++)\n        numbers[i]=(numbers[i]-min)/(max-min);\n    return numbers;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (allclose(rescale_to_unit_simd({2.0, 49.9}), {0.0, 1.0}));\n    pass = pass && (allclose(rescale_to_unit_simd({100.0, 49.9}), {1.0, 0.0}));\n    pass = pass && (allclose(rescale_to_unit_simd({1.0, 2.0, 3.0, 4.0, 5.0}), {0.0, 0.25, 0.5, 0.75, 1.0}));\n    pass = pass && (allclose(rescale_to_unit_simd({2.0, 1.0, 5.0, 3.0, 4.0}), {0.25, 0.0, 1.0, 0.5, 0.75}));\n    pass = pass && (allclose(rescale_to_unit_simd({12.0, 11.0, 15.0, 13.0, 14.0}), {0.25, 0.0, 1.0, 0.5, 0.75}));\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = rng.randint(size_t(2), size_t(128));\n        std::vector<float> numbers(length);\n        rng.initialize_vector_with_random_values(numbers);\n        \n        std::vector<float> result = rescale_to_unit(numbers);\n        std::vector<float> result_simd = rescale_to_unit_simd(numbers);\n        \n        \n        if(!allclose(result, result_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n\n    }\n    return true;\n}\n\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::vector<float> (*Func)(std::vector<float>)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<float> numbers(length);\n    rng.initialize_vector_with_random_values(numbers);\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(numbers));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, rescale_to_unit)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, rescale_to_unit_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/21", "entrypoint_scalar": "rescale_to_unit", "entrypoint_simd": "rescale_to_unit_simd"}
{"task_id": "SimdBench_73_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nFor a given positive number n, find the largest number that divides n evenly, smaller than n\n>>> largest_divisor_simd(15)\n5\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nuint64_t largest_divisor_simd(uint64_t n){\n}", "solution_scalar": "uint64_t largest_divisor(uint64_t n){\n    for (uint64_t i=2;i*i<=n;i++)\n        if (n%i==0) return  n/i;\n    return 1;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (largest_divisor_simd(3) == 1);\n    pass = pass && (largest_divisor_simd(7) == 1);\n    pass = pass && (largest_divisor_simd(10) == 5);\n    pass = pass && (largest_divisor_simd(100) == 50);\n    pass = pass && (largest_divisor_simd(49) == 7);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        uint64_t n = rng.randint<uint64_t>(1, 1000000);\n        uint64_t result = largest_divisor(n);\n        uint64_t result_simd = largest_divisor_simd(n);        \n        \n        if(!allclose(result, result_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n\n    }\n    return true;\n}\n\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<uint64_t (*Func)(uint64_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng(state.range(0));\n    uint64_t n = rng.randint<uint64_t>(1 << 12, 1 << 24);\n\n    for (auto _ : state) {\n        uint64_t res = Func(n);\n        benchmark::DoNotOptimize(res);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, largest_divisor)->Name(\"Scalar\")->RangeMultiplier(2)->Range(2, 2<<8);\nBENCHMARK_TEMPLATE(BM, largest_divisor_simd)->Name(\"SIMD\")->RangeMultiplier(2)->Range(2, 2<<8);\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/24", "entrypoint_scalar": "largest_divisor", "entrypoint_simd": "largest_divisor_simd"}
{"task_id": "SimdBench_74_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nReturn vector of prime factors of given integer in the order from smallest to largest.\nEach of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\nInput number should be equal to the product of all factors\n>>> factorize_simd(8)\n{2, 2, 2}\n>>> factorize_simd(25)\n{5, 5}\n>>> factorize_simd(70)\n{2, 5, 7}\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> factorize_simd(int n){\n}", "solution_scalar": "std::vector<int> factorize(int n) {\n    // Estimate the maximum size of the factor list\n    int max_factors = std::log2(n) + 1;  // A rough upper bound for prime factors\n    std::vector<int> out(max_factors);  // Pre-allocate space\n    int index = 0;  // Current position in the vector\n\n    for (int i = 2; i * i <= n; i++) {\n        while (n % i == 0) {  // While `i` is a factor of `n`\n            n /= i;\n            out[index++] = i;  // Add factor to the vector\n        }\n    }\n    if (n > 1) {  // If there is a remaining prime factor > sqrt(n)\n        out[index++] = n;\n    }\n\n    // Resize the vector to match the number of factors found\n    out.resize(index);\n    return out;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (allclose(factorize_simd(2) , {2}));\n    pass = pass && (allclose(factorize_simd(4) , {2, 2}));\n    pass = pass && (allclose(factorize_simd(8) , {2, 2, 2}));\n    pass = pass && (allclose(factorize_simd(3 * 19) , {3, 19}));\n    pass = pass && (allclose(factorize_simd(3 * 19 * 3 * 19) , {3, 3, 19, 19})); \n    pass = pass && (allclose(factorize_simd(3 * 19 * 3 * 19 * 3 * 19) , {3, 3, 3, 19, 19, 19})); \n    pass = pass && (allclose(factorize_simd(3 * 19 * 19 * 19) , {3, 19, 19, 19})); \n    pass = pass && (allclose(factorize_simd(3 * 2 * 3) , {2, 3, 3}));\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        int n = rng.randint(2, 1000000);\n        std::vector<int> result = factorize(n);\n        std::vector<int> result_simd = factorize_simd(n);\n    \n        if(!allclose(result, result_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n\n    }\n    return true;\n}\n\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::vector<int> (*Func)(int)>\nstatic void BM(benchmark::State& state) {\n    Random rng(state.range(0));\n    int n = rng.randint<int>(1 << 15, 1 << 30);\n\n    for (auto _ : state) {\n        std::vector<int> res = Func(n);\n        benchmark::DoNotOptimize(res);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, factorize)->Name(\"Scalar\")->RangeMultiplier(2)->Range(2, 2<<8);\nBENCHMARK_TEMPLATE(BM, factorize_simd)->Name(\"SIMD\")->RangeMultiplier(2)->Range(2, 2<<8);\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/25", "entrypoint_scalar": "factorize", "entrypoint_simd": "factorize_simd"}
{"task_id": "SimdBench_75_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nReturn only positive numbers in the vector.\n>>> get_positive_simd({-1, 2, -4, 5, 6})\n{2, 5, 6}\n>>> get_positive_simd({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n{5, 3, 2, 3, 9, 123, 1}\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<float> get_positive_simd(const std::vector<float> & l){\n}", "solution_scalar": "std::vector<float> get_positive(const std::vector<float> & l) {\n    std::vector<float> out(l.size());  // Pre-allocate space equal to the input size\n    int index = 0;  // Track the current position in the output vector\n\n    for (int i = 0; i < l.size(); i++) {\n        if (l[i] > 0) {\n            out[index++] = l[i];  // Add positive numbers to the output vector\n        }\n    }\n    // Resize the vector to contain only the positive numbers\n    out.resize(index);\n    return out;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (allclose(get_positive_simd({-1, -2, 4, 5, 6}), { 4, 5, 6}));\n    pass = pass && (allclose(get_positive_simd({5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10}), {5, 3, 2, 3, 3, 9, 123, 1}));\n    pass = pass && (allclose(get_positive_simd({-1, -2}), {}));\n    pass = pass && (allclose(get_positive_simd({}), {}));\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<float> numbers(length);\n        rng.initialize_vector_with_random_values(numbers);\n        \n        std::vector<float> result = get_positive(numbers);\n        std::vector<float> result_simd = get_positive_simd(numbers);\n        \n        if(!allclose(result, result_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::vector<float> (*Func)(const std::vector<float> &)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<float> numbers(length);\n    rng.initialize_vector_with_random_values(numbers);\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(numbers));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, get_positive)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, get_positive_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/30", "entrypoint_scalar": "get_positive", "entrypoint_simd": "get_positive_simd"}
{"task_id": "SimdBench_76_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nReturn true if a given number is prime, and false otherwise.\n>>> is_prime_simd(6)\nfalse\n>>> is_prime_simd(101)\ntrue\n>>> is_prime_simd(11)\ntrue\n>>> is_prime_simd(13441)\ntrue\n>>> is_prime_simd(61)\ntrue\n>>> is_prime_simd(4)\nfalse\n>>> is_prime_simd(1)\nfalse\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nbool is_prime_simd(int64_t n){\n}", "solution_scalar": "bool is_prime(int64_t n){\n    if (n<2) return false;\n    for (int64_t i=2;i*i<=n;i++)\n        if (n%i==0) return false;\n    return true;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (is_prime_simd(6) == false);\n    pass = pass && (is_prime_simd(101) == true);\n    pass = pass && (is_prime_simd(11) == true);\n    pass = pass && (is_prime_simd(13441) == true);\n    pass = pass && (is_prime_simd(61) == true);\n    pass = pass && (is_prime_simd(4) == false);\n    pass = pass && (is_prime_simd(1) == false);\n    pass = pass && (is_prime_simd(5) == true);\n    pass = pass && (is_prime_simd(11) == true);\n    pass = pass && (is_prime_simd(17) == true);\n    pass = pass && (is_prime_simd(5 * 17) == false);\n    pass = pass && (is_prime_simd(11 * 7) == false);\n    pass = pass && (is_prime_simd(13441 * 19) == false);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        int64_t n = rng.randint(2, 1000000);\n        bool result = is_prime(n);\n        bool result_simd = is_prime_simd(n);\n    \n        if(!allclose(result, result_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n\n    }\n    return true;\n}\n\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<bool (*Func)(int64_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng(state.range(0));\n    std::vector<int64_t> large_primes = {100000007, 1000000007, 10000000019, 100000000003, 1000000000039,\n    100000841, 1000000931, 10000001051, 10000000949, 100000000747, 1000000001123};\n    \n    int64_t n = rng.choice(large_primes);\n    for (auto _ : state) {\n        bool res = Func(n);\n        benchmark::DoNotOptimize(res);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, is_prime)->Name(\"Scalar\")->RangeMultiplier(2)->Range(2, 2<<8);\nBENCHMARK_TEMPLATE(BM, is_prime_simd)->Name(\"SIMD\")->RangeMultiplier(2)->Range(2, 2<<8);\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/31", "entrypoint_scalar": "is_prime", "entrypoint_simd": "is_prime_simd"}
{"task_id": "SimdBench_77_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nYou are given a string s.\nif s[i] is a letter, reverse its case from lower to upper or vise versa, \notherwise keep it as it is.\nIf the string contains no letters, reverse the string.\nThe function should return the resulted string.\nExamples\nsolve_simd(\"1234\") = \"4321\"\nsolve_simd(\"ab\") = \"AB\"\nsolve_simd(\"#a@C\") = \"#A@c\"\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::string solve_simd(const std::string & s){\n}", "solution_scalar": "std::string solve(const std::string & s){\n    int nletter=0;\n    std::string out=\"\";\n    for (int i=0;i<s.length();i++)\n    {\n        char w=s[i];\n        if (w>=65 and w<=90) w=w+32;\n        else if (w>=97 and w<=122) w=w-32;\n        else nletter+=1;\n        out=out+w;\n    }\n    if (nletter==s.length())\n    {\n        std::string p(s.rbegin(),s.rend());\n        return p;\n    }\n    else return out;\n}", "test_correctness": "bool humaneval_check(){\n    bool res = true;\n    res = res && (solve_simd(\"AsDf\") == \"aSdF\");\n    res = res && (solve_simd(\"1234\") == \"4321\");\n    res = res && (solve_simd(\"ab\") == \"AB\");\n    res = res && (solve_simd(\"#a@C\") == \"#A@c\");\n    res = res && (solve_simd(\"#AsdfW^45\") == \"#aSDFw^45\");\n    res = res && (solve_simd(\"#6@2\") == \"2@6#\");\n    res = res && (solve_simd(\"#$a^D\") == \"#$A^d\");\n    res = res && (solve_simd(\"#ccc\") == \"#CCC\");\n    return res;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::string charset;\n        if( i % 2 ) charset = CHARSET_PRINTABLE;\n        else charset = CHARSET_DIGITS;\n\n        std::string s = rng.random_string(charset, length);\n\n        std::string res_scalar = solve(s);\n        std::string res_simd = solve_simd(s);\n        if(!allclose(res_scalar, res_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::string (*Func)(const std::string &)>\nstatic void BM(benchmark::State& state) {\n    Random rng(DEFAULT_SEED);\n    size_t length = state.range(0);\n    \n    std::string charset;\n    if(rng.random_bool()) charset = CHARSET_PRINTABLE;\n    else charset = CHARSET_DIGITS;\n    \n    std::string s = rng.random_string(charset, length);\n\n    for (auto _ : state) {\n        std::string res = Func(s);\n        benchmark::DoNotOptimize(res);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, solve)->Name(\"Scalar\")->Medium_Args_1D;\nBENCHMARK_TEMPLATE(BM, solve_simd)->Name(\"SIMD\")->Medium_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/161", "entrypoint_scalar": "solve", "entrypoint_simd": "solve_simd"}
{"task_id": "SimdBench_78_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThis function takes a vector l and returns a vector l' such that\nl' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\nto the values of the corresponding indicies of l, but sorted.\n>>> sort_third_simd({1, 2, 3})\n{1, 2, 3}\n>>> sort_third_simd({5, 6, 3, 4, 8, 9, 2})\n{2, 6, 3, 4, 8, 9, 5}\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> sort_third_simd(std::vector<int> l){\n}", "solution_scalar": "std::vector<int> sort_third(std::vector<int> l) {\n    int third_size = (l.size() + 2) / 3;\n    std::vector<int> third(third_size);\n    for (int i = 0; i < third_size; i++) {\n        third[i] = l[i * 3];\n    }\n    std::sort(third.begin(), third.end());\n    std::vector<int> out(l.size());\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            out[i] = third[i / 3];\n        } else {\n            out[i] = l[i];\n        }\n    }\n    return out;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (allclose(sort_third_simd({1, 2, 3}), sort_third({1, 2, 3})));\n    pass = pass && (allclose(sort_third_simd({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}), \n                     sort_third({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})));\n    pass = pass && (allclose(sort_third_simd({5, 8, -12, 4, 23, 2, 3, 11, 12, -10}),\n                     sort_third({5, 8, -12, 4, 23, 2, 3, 11, 12, -10})));\n    pass = pass && (allclose(sort_third_simd({5, 6, 3, 4, 8, 9, 2}), {2, 6, 3, 4, 8, 9, 5}));\n    pass = pass && (allclose(sort_third_simd({5, 8, 3, 4, 6, 9, 2}), {2, 8, 3, 4, 6, 9, 5}));\n    pass = pass && (allclose(sort_third_simd({5, 6, 9, 4, 8, 3, 2}), {2, 6, 9, 4, 8, 3, 5}));\n    pass = pass && (allclose(sort_third_simd({5, 6, 3, 4, 8, 9, 2, 1}), {2, 6, 3, 4, 8, 9, 5, 1}));\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<int> numbers(length);\n        rng.initialize_vector_with_random_values(numbers);\n        \n        std::vector<int> result = sort_third(numbers);\n        std::vector<int> result_simd = sort_third_simd(numbers);\n        \n        if(!allclose(result, result_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::vector<int> (*Func)(std::vector<int>)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<int> numbers(length);\n    rng.initialize_vector_with_random_values(numbers);\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(numbers));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, sort_third)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, sort_third_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/33", "entrypoint_scalar": "sort_third", "entrypoint_simd": "sort_third_simd"}
{"task_id": "SimdBench_79_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nReturn maximum element in the non-empty vector.\n>>> max_element_simd({1, 2, 3})\n3\n>>> max_element_simd({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})\n123\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nfloat max_element_simd(std::vector<float> l){\n}", "solution_scalar": "float max_element(std::vector<float> l){\n  float max=-10000;\n  for (int i=0;i<l.size();i++)\n  if (max<l[i]) max=l[i];\n  return max;\n\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (allclose(max_element_simd({1, 2, 3}), 3.0f));\n    pass = pass && (allclose(max_element_simd({5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10}), 124.0f));\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<float> numbers(length);\n        rng.initialize_vector_with_random_values(numbers);\n        \n        float result = max_element(numbers);\n        float result_simd = max_element_simd(numbers);\n        \n        if(!allclose(result, result_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<float (*Func)(std::vector<float>)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<float> numbers(length);\n    rng.initialize_vector_with_random_values(numbers);\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(numbers));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, max_element)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, max_element_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/35", "entrypoint_scalar": "max_element", "entrypoint_simd": "max_element_simd"}
{"task_id": "SimdBench_80_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nReturn the number of times the digit 7 appears in non-negative integers less than n which are divisible by 11 or 13.\n>>> fizz_buzz_simd(50)\n0\n>>> fizz_buzz_simd(78)\n2\n>>> fizz_buzz_simd(79)\n3\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nint fizz_buzz_simd(int n){\n}", "solution_scalar": "int fizz_buzz(int n){\n    int count=0;\n    for (int i=0;i<n;i++)\n    if (i%11==0 or i%13==0)\n    {\n        int q=i;\n        while (q>0)\n        {\n            if (q%10==7) count+=1;\n            q=q/10;\n        }\n    } \n    return count;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (fizz_buzz_simd(50) == 0);\n    pass = pass && (fizz_buzz_simd(78) == 2);\n    pass = pass && (fizz_buzz_simd(79) == 3);\n    pass = pass && (fizz_buzz_simd(100) == 3);\n    pass = pass && (fizz_buzz_simd(200) == 6);\n    pass = pass && (fizz_buzz_simd(4000) == 192);\n    pass = pass && (fizz_buzz_simd(10000) == 639);\n    pass = pass && (fizz_buzz_simd(100000) == 8026);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        int n = rng.randint<int>(0, 10000);\n        \n        auto result = fizz_buzz(n);\n        auto result_simd = fizz_buzz_simd(n);\n\n        if(!allclose(result, result_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main(){\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<int (*Func)(int)>\nstatic void BM(benchmark::State& state) {\n    const size_t n = state.range(0);    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(n));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, fizz_buzz)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, fizz_buzz_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/36", "entrypoint_scalar": "fizz_buzz", "entrypoint_simd": "fizz_buzz_simd"}
{"task_id": "SimdBench_81_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThis function takes a vector l and returns a vector l' such that\nl' is identical to l in the odd indicies, while its values at the even indicies are equal\nto the values of the even indicies of l, but sorted.\n>>> sort_even_simd({1, 2, 3})\n{1, 2, 3}\n>>> sort_even_simd({5, 6, 3, 4})\n{3, 6, 5, 4}\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<float> sort_even_simd(std::vector<float> l){\n}", "solution_scalar": "std::vector<float> sort_even(std::vector<float> l) {\n    int even_size = (l.size() + 1) / 2;\n    std::vector<float> even(even_size);\n\n    for (int i = 0; i < even_size; i++) {\n        even[i] = l[i * 2];\n    }\n\n    std::sort(even.begin(), even.end());\n    std::vector<float> out(l.size());\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 2 == 0) {\n            out[i] = even[i / 2];\n        } else {\n            out[i] = l[i];\n        }\n    }\n\n    return out;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (allclose(sort_even_simd({1, 2, 3}), {1, 2, 3}));\n    pass = pass && (allclose(sort_even_simd({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}), \n                     {-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123}));\n    pass = pass && (allclose(sort_even_simd({5, 8, -12, 4, 23, 2, 3, 11, 12, -10}),\n                     {-12, 8, 3, 4, 5, 2, 12, 11, 23, -10}));\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<float> numbers(length);\n        rng.initialize_vector_with_random_values(numbers);\n        \n        std::vector<float> result = sort_even(numbers);\n        std::vector<float> result_simd = sort_even_simd(numbers);\n        \n        if(!allclose(result, result_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::vector<float> (*Func)(std::vector<float>)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<float> numbers(length);\n    rng.initialize_vector_with_random_values(numbers);\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(numbers));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, sort_even)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, sort_even_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/37", "entrypoint_scalar": "sort_even", "entrypoint_simd": "sort_even_simd"}
{"task_id": "SimdBench_82_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\ntriples_sum_to_zero takes a vector of integers as an input.\nit returns true if there are three distinct elements in the vector that\nsum to zero, and false otherwise.\n\n>>> triples_sum_to_zero_simd({1, 3, 5, 0})\nfalse\n>>> triples_sum_to_zero_simd({1, 3, -2, 1})\ntrue\n>>> triples_sum_to_zero_simd({1, 2, 3, 7})\nfalse\n>>> triples_sum_to_zero_simd({2, 4, -5, 3, 9, 7})\ntrue\n>>> triples_sum_to_zero_simd({1})\nfalse\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nbool triples_sum_to_zero_simd(std::vector<int> l){\n}", "solution_scalar": "bool triples_sum_to_zero(std::vector<int> l){\n    for (int i=0;i<l.size();i++)\n    for (int j=i+1;j<l.size();j++)\n    for (int k=j+1;k<l.size();k++)\n        if (l[i]+l[j]+l[k]==0) return true;\n    return false;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (triples_sum_to_zero_simd({1, 3, 5, 0}) == false);\n    pass = pass && (triples_sum_to_zero_simd({1, 3, 5, -1}) == false);\n    pass = pass && (triples_sum_to_zero_simd({1, 3, -2, 1}) == true);\n    pass = pass && (triples_sum_to_zero_simd({1, 2, 3, 7}) == false);\n    pass = pass && (triples_sum_to_zero_simd({1, 2, 5, 7}) == false);\n    pass = pass && (triples_sum_to_zero_simd({2, 4, -5, 3, 9, 7}) == true);\n    pass = pass && (triples_sum_to_zero_simd({1}) == false);\n    pass = pass && (triples_sum_to_zero_simd({1, 3, 5, -100}) == false);\n    pass = pass && (triples_sum_to_zero_simd({100, 3, 5, -100}) == false);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_2D;\n        std::vector<int> numbers(length);\n        for(auto& number : numbers) {\n            number = rng.randint(-100, 100);\n        }\n        \n        bool result = triples_sum_to_zero(numbers);\n        bool result_simd = triples_sum_to_zero_simd(numbers);\n        \n        if(result != result_simd){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<bool (*Func)(std::vector<int>)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = sqrt(state.range(0) * state.range(1));\n    Random rng(DEFAULT_SEED);\n    std::vector<int> numbers(length);\n    rng.initialize_vector_with_random_values(numbers);\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(numbers));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, triples_sum_to_zero)->Name(\"Scalar\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM, triples_sum_to_zero_simd)->Name(\"SIMD\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/40", "entrypoint_scalar": "triples_sum_to_zero", "entrypoint_simd": "triples_sum_to_zero_simd"}
{"task_id": "SimdBench_83_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nReturn vector with elements incremented by 1.\n>>> incr_list_simd({1, 2, 3})\n{2, 3, 4}\n>>> incr_list_simd({5, 3, 5, 2, 3, 3, 9, 0, 123})\n{6, 4, 6, 3, 4, 4, 10, 1, 124}\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> incr_list_simd(std::vector<int> l){\n}", "solution_scalar": "std::vector<int> incr_list(std::vector<int> l){\n    for (int i=0;i<l.size();i++)\n        l[i]+=1;\n    return l;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (allclose(incr_list_simd({}), {}));\n    pass = pass && (allclose(incr_list_simd({3, 2, 1}), {4, 3, 2}));\n    pass = pass && (allclose(incr_list_simd({5, 2, 5, 2, 3, 3, 9, 0, 123}), {6, 3, 6, 3, 4, 4, 10, 1, 124}));\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = rng.randint<size_t>(0, 128);\n        std::vector<int> numbers(length);\n        for (size_t j = 0; j < length; j++) {\n            numbers[j] = rng.randint( - (1 << 24), (1 << 24));\n        }\n        \n        std::vector<int> result = incr_list(numbers);\n        std::vector<int> result_simd = incr_list_simd(numbers);\n        \n        if(!allclose(result, result_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::vector<int> (*Func)(std::vector<int>)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<int> numbers(length);\n    rng.initialize_vector_with_random_values(numbers);\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(numbers));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, incr_list)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, incr_list_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/42", "entrypoint_scalar": "incr_list", "entrypoint_simd": "incr_list_simd"}
{"task_id": "SimdBench_84_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\npairs_sum_to_zero takes a vector of integers as an input.\nit returns true if there are two distinct elements in the vector that\nsum to zero, and false otherwise.\n>>> pairs_sum_to_zero_simd({1, 3, 5, 0})\nfalse\n>>> pairs_sum_to_zero_simd({1, 3, -2, 1})\nfalse\n>>> pairs_sum_to_zero_simd({1, 2, 3, 7})\nfalse\n>>> pairs_sum_to_zero_simd({2, 4, -5, 3, 5, 7})\ntrue\n>>> pairs_sum_to_zero_simd({1})\nfalse\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nbool pairs_sum_to_zero_simd(std::vector<int> l){\n}", "solution_scalar": "bool pairs_sum_to_zero(std::vector<int> l){\n    for (int i=0;i<l.size();i++)\n    for (int j=i+1;j<l.size();j++)\n    if (l[i]+l[j]==0) return true;\n    return false;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (pairs_sum_to_zero_simd({1, 3, 5, 0}) == false);\n    pass = pass && (pairs_sum_to_zero_simd({1, 3, -2, 1}) == false);\n    pass = pass && (pairs_sum_to_zero_simd({1, 2, 3, 7}) == false);\n    pass = pass && (pairs_sum_to_zero_simd({2, 4, -5, 3, 5, 7}) == true);\n    pass = pass && (pairs_sum_to_zero_simd({1}) == false);\n    pass = pass && (pairs_sum_to_zero_simd({-3, 9, -1, 3, 2, 30}) == true);\n    pass = pass && (pairs_sum_to_zero_simd({-3, 9, -1, 3, 2, 31}) == true);\n    pass = pass && (pairs_sum_to_zero_simd({-3, 9, -1, 4, 2, 30}) == false);\n    pass = pass && (pairs_sum_to_zero_simd({-3, 9, -1, 4, 2, 31}) == false);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<int> numbers(length);\n        for (size_t j = 0; j < length; j++) {\n            numbers[j] = rng.randint( -(1<<10), 1>>10);\n        }\n        \n        bool result = pairs_sum_to_zero(numbers);\n        bool result_simd = pairs_sum_to_zero_simd(numbers);\n        \n        if(result != result_simd){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<bool (*Func)(std::vector<int>)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n    std::vector<int> numbers(length);\n    for (size_t j = 0; j < length; j++) {\n        numbers[j] = rng.randint( -(1<<10), 1>>10);\n    }\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(numbers));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, pairs_sum_to_zero)->Name(\"Scalar\")->Medium_Args_1D;\nBENCHMARK_TEMPLATE(BM, pairs_sum_to_zero_simd)->Name(\"SIMD\")->Medium_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/43", "entrypoint_scalar": "pairs_sum_to_zero", "entrypoint_simd": "pairs_sum_to_zero_simd"}
{"task_id": "SimdBench_85_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nChange numerical base of input number x to base.\nreturn string representation after the conversion.\nbase numbers are less than 10.\n>>> change_base_simd(8, 3)\n\"22\"\n>>> change_base_simd(8, 2)\n\"1000\"\n>>> change_base_simd(7, 2)\n\"111\"\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::string change_base_simd(int64_t x, int8_t base){\n}", "solution_scalar": "std::string change_base(int64_t x, int8_t base){\n    bool is_negative = false;\n    if (x < 0) {\n        is_negative = true;\n        x = std::abs(x);\n    }\n    std::string out=\"\";\n    if(x==0) out=std::to_string(0);\n    while (x>0)\n    {\n        out=std::to_string(x%base)+out;\n        x=x/base;\n    }\n    if (is_negative) {\n        out = \"-\" + out;\n    }\n    return out;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;    \n    pass = pass && (change_base_simd(8, 3) == \"22\");\n    pass = pass && (change_base_simd(9, 3) == \"100\");\n    pass = pass && (change_base_simd(234, 2) == \"11101010\");\n    pass = pass && (change_base_simd(16, 2) == \"10000\");\n    pass = pass && (change_base_simd(8, 2) == \"1000\");\n    pass = pass && (change_base_simd(7, 2) == \"111\");\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        int x = rng.randint<int>(); if(i==0) x=0;\n        int base = rng.randint<int>(2, 9);\n        \n        auto result = change_base(x, base);\n        auto result_simd = change_base_simd(x, base);\n\n        if(!allclose(result, result_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main(){\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::string (*Func)(int64_t, int8_t)>\nstatic void BM(benchmark::State& state) {\n    const size_t x = state.range(0); \n    int base = 3;   \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(x, base));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, change_base)->Name(\"Scalar\")->Arg(1<<30)->Arg(int64_t(1)<<35)->Arg(int64_t(1)<<40)->Arg(int64_t(1)<<45)\n->Arg(int64_t(1)<<50)->Arg(int64_t(1)<<55)->Arg(int64_t(1)<<60);\nBENCHMARK_TEMPLATE(BM, change_base_simd)->Name(\"SIMD\")->Arg(1<<30)->Arg(int64_t(1)<<35)->Arg(int64_t(1)<<40)->Arg(int64_t(1)<<45)\n->Arg(int64_t(1)<<50)->Arg(int64_t(1)<<55)->Arg(int64_t(1)<<60);\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/44", "entrypoint_scalar": "change_base", "entrypoint_simd": "change_base_simd"}
{"task_id": "SimdBench_86_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nChecks if given string is a palindrome\n>>> is_palindrome_simd(\"\")\ntrue\n>>> is_palindrome_simd(\"aba\")\ntrue\n>>> is_palindrome_simd(\"aaaaa\")\ntrue\n>>> is_palindrome_simd(\"zbcd\")\nfalse\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nbool is_palindrome_simd(std::string text){\n}", "solution_scalar": "bool is_palindrome(std::string text){\n    for(int i = 0; i < text.size() / 2; i++){\n        if(text[i] != text[text.size() - 1 - i]){\n            return false;\n        }\n    }\n    return true;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (is_palindrome_simd(\"\") == true);\n    pass = pass && (is_palindrome_simd(\"aba\") == true);\n    pass = pass && (is_palindrome_simd(\"aaaaa\") == true);\n    pass = pass && (is_palindrome_simd(\"zbcd\") == false);\n    pass = pass && (is_palindrome_simd(\"xywyx\") == true);\n    pass = pass && (is_palindrome_simd(\"xywyz\") == false);\n    pass = pass && (is_palindrome_simd(\"xywzx\") == false);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    std::vector<std::string> charsets = {\n        CHARSET_LOWERCASE, CHARSET_UPPERCASE, CHARSET_DIGITS, CHARSET_ALPHA,\n        CHARSET_ALPHANUMERIC, CHARSET_HEX, CHARSET_PRINTABLE\n    };\n    for (int i = 0; i < iterations; i++) {\n        int length = rng.randint<int>(0, 128);\n        std::string charset = rng.choice(charsets);\n        std::string text = rng.random_string(charset, length);\n        if(rng.random_bool()){\n            for(int ii = 0; ii < text.size() / 2; ii++) \n                text[ii] = text[text.size() - 1 - ii];\n        }\n        \n        auto result = is_palindrome(text);\n        auto result_simd = is_palindrome_simd(text);\n\n        if(!allclose(result, result_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main(){\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<bool (*Func)(std::string)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    std::vector<std::string> charsets = {\n        CHARSET_LOWERCASE, CHARSET_UPPERCASE, CHARSET_DIGITS, CHARSET_ALPHA,\n        CHARSET_ALPHANUMERIC, CHARSET_HEX, CHARSET_PRINTABLE\n    };\n    const size_t length = state.range(0);  \n    std::string charset = rng.choice(charsets);\n    std::string text = rng.random_string(charset, length);  \n    for(int ii = 0; ii < text.size() / 2; ii++) \n        text[ii] = text[text.size() - 1 - ii];\n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(text));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, is_palindrome)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, is_palindrome_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/48", "entrypoint_scalar": "is_palindrome", "entrypoint_simd": "is_palindrome_simd"}
{"task_id": "SimdBench_87_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/* \nencode_shift: returns encoded string by shifting every character by 5 in the alphabet.\nstd::string encode_shift(std::string s){\n    std::string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+5-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\n\ndecode_shift_simd: takes as input string encoded with encode_shift function. Returns decoded string.\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::string decode_shift_simd(std::string s){\n}", "solution_scalar": "std::string decode_shift(std::string s){\n    std::string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+21-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}", "test_correctness": "std::string encode_shift(std::string s){\n    std::string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+5-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\n\nbool humaneval_check() {\n    bool pass = true;\n    for (int i=0;i<100;i++)\n    {\n        int l=10+rand()%11;\n        std::string str=\"\";\n        for (int j=0;j<l;j++)\n        {\n            char chr=97+rand()%26;\n            str+=chr;\n        }\n\n        std::string encoded_str = encode_shift(str);\n        pass = pass && (decode_shift_simd(encoded_str) == str);\n    }\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    std::vector<std::string> charsets = {\n        CHARSET_LOWERCASE, CHARSET_UPPERCASE, CHARSET_DIGITS, CHARSET_ALPHA,\n        CHARSET_ALPHANUMERIC, CHARSET_HEX, CHARSET_PRINTABLE\n    };\n    for (int i = 0; i < iterations; i++) {\n        int length = rng.randint<int>(0, 128);\n        std::string charset = rng.choice(charsets);\n        std::string text = rng.random_string(charset, length);\n        \n        auto result = decode_shift(text);\n        auto result_simd = decode_shift_simd(text);\n\n        if(!allclose(result, result_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main(){\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::string (*Func)(std::string)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    std::vector<std::string> charsets = {\n        CHARSET_LOWERCASE, CHARSET_UPPERCASE, CHARSET_DIGITS, CHARSET_ALPHA,\n        CHARSET_ALPHANUMERIC, CHARSET_HEX, CHARSET_PRINTABLE\n    };\n    const size_t length = state.range(0);  \n    std::string charset = rng.choice(charsets);\n    std::string text = rng.random_string(charset, length);  \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(text));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, decode_shift)->Name(\"Scalar\")->Medium_Args_1D;\nBENCHMARK_TEMPLATE(BM, decode_shift_simd)->Name(\"SIMD\")->Medium_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/50", "entrypoint_scalar": "decode_shift", "entrypoint_simd": "decode_shift_simd"}
{"task_id": "SimdBench_88_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nReturn true if all numbers in the vector l are below threshold t.\n>>> below_threshold_simd({1, 2, 4, 10}, 100)\ntrue\n>>> below_threshold_simd({1, 20, 4, 10}, 5)\nfalse\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nbool below_threshold_simd(std::vector<int>l, int t){\n}", "solution_scalar": "bool below_threshold(std::vector<int>l, int t){\n    for (int i=0;i<l.size();i++)\n        if (l[i]>=t) return false;\n    return true;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (below_threshold_simd({1, 2, 4, 10}, 100));\n    pass = pass && (!below_threshold_simd({1, 20, 4, 10}, 5));\n    pass = pass && (below_threshold_simd({1, 20, 4, 10}, 21));\n    pass = pass && (below_threshold_simd({1, 20, 4, 10}, 22));\n    pass = pass && (below_threshold_simd({1, 8, 4, 10}, 11));\n    pass = pass && (!below_threshold_simd({1, 8, 4, 10}, 10));\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<int> numbers(length);\n        for (size_t j = 0; j < length; j++) {\n            numbers[j] = rng.randint<int>(-100, 100);\n        }\n        int threshold = rng.randint<int>(-1000, 1000);\n        \n        bool result = below_threshold(numbers, threshold);\n        bool result_simd = below_threshold_simd(numbers, threshold);\n        \n        if(result != result_simd){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<bool (*Func)(std::vector<int>, int)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n    std::vector<int> numbers(length);\n    rng.initialize_vector_with_random_values(numbers);\n    int threshold = rng.randint<int>() % 100;\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(numbers, threshold));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, below_threshold)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, below_threshold_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/52", "entrypoint_scalar": "below_threshold", "entrypoint_simd": "below_threshold_simd"}
{"task_id": "SimdBench_89_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nbrackets is a string of '<' and '>'.\nreturn true if every opening bracket has a corresponding closing bracket.\n\n>>> correct_bracketing_simd(\"<\")\nfalse\n>>> correct_bracketing_simd(\"<>\")\ntrue\n>>> correct_bracketing_simd(\"<<><>>\")\ntrue\n>>> correct_bracketing_simd(\"><<>\")\nfalse\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nbool correct_bracketing_simd(std::string brackets){\n}", "solution_scalar": "bool correct_bracketing(std::string brackets){\n    int level=0;\n    for (int i=0;i<brackets.length();i++)\n    {\n        if (brackets[i]=='<') level+=1;\n        if (brackets[i]=='>') level-=1;\n        if (level<0) return false;\n    }\n    if (level!=0) return false;\n    return true;\n}", "test_correctness": "bool humaneval_check(){\n    bool pass = true;\n    pass = pass && (correct_bracketing_simd(\"<>\"));\n    pass = pass && (correct_bracketing_simd(\"<<><>>\"));\n    pass = pass && (correct_bracketing_simd(\"<><><<><>><>\"));\n    pass = pass && (correct_bracketing_simd(\"<><><<<><><>><>><<><><<>>>\"));\n    pass = pass && (! (correct_bracketing_simd(\"<<<><>>>>\")));\n    pass = pass && (! (correct_bracketing_simd(\"><<>\")));\n    pass = pass && (! (correct_bracketing_simd(\"<\")));\n    pass = pass && (! (correct_bracketing_simd(\"<<<<\")));\n    pass = pass && (! (correct_bracketing_simd(\">\")));\n    pass = pass && (! (correct_bracketing_simd(\"<<>\")));\n    pass = pass && (! (correct_bracketing_simd(\"<><><<><>><>><<>\")));\n    pass = pass && (! (correct_bracketing_simd(\"<><><<><>><>>><>\")));\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = rng.randint<size_t>(0, 32);\n        const std::string charset = \"<>\";\n        std::string brackets = rng.random_string(charset, length);\n              \n        bool res_scalar = correct_bracketing(brackets);\n        bool res_simd = correct_bracketing_simd(brackets);\n\n        if(!allclose(res_scalar, res_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<bool (*Func)(std::string)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t length = state.range(0);\n    std::string brackets;\n    if(rng.random_bool()){\n        for (int i = 0; i < length; ++i) {\n            brackets += \"<>\";\n        }\n    }else{\n        brackets = std::string(length, '<') + std::string(length, '>');\n    }\n\n    for (auto _ : state) {\n        bool res = Func(brackets);\n        benchmark::DoNotOptimize(res);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, correct_bracketing)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, correct_bracketing_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/56", "entrypoint_scalar": "correct_bracketing", "entrypoint_simd": "correct_bracketing_simd"}
{"task_id": "SimdBench_90_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\nbool correct_bracketing_simd(std::string brackets){\n/*\nbrackets is a string of '(' and ')'.\nreturn true if every opening bracket has a corresponding closing bracket.\n\n>>> correct_bracketing_simd(\"(\")\nfalse\n>>> correct_bracketing_simd(\"()\")\ntrue\n>>> correct_bracketing_simd(\"(()())\")\ntrue\n>>> correct_bracketing_simd(\")(()\")\nfalse\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\n}", "solution_scalar": "bool correct_bracketing(std::string brackets){\n    int level=0;\n    for (int i=0;i<brackets.length();i++)\n    {\n        if (brackets[i]=='(') level+=1;\n        if (brackets[i]==')') level-=1;\n        if (level<0) return false;\n    }\n    if (level!=0) return false;\n    return true;\n}", "test_correctness": "bool humaneval_check(){\n    bool pass = true;\n    pass = pass && (correct_bracketing_simd(\"()\"));\n    pass = pass && (correct_bracketing_simd(\"(()())\"));\n    pass = pass && (correct_bracketing_simd(\"()()(()())()\"));\n    pass = pass && (correct_bracketing_simd(\"()()((()()())())(()()(()))\"));\n    pass = pass && (! (correct_bracketing_simd(\"((()())))\")));\n    pass = pass && (! (correct_bracketing_simd(\")(()\")));\n    pass = pass && (! (correct_bracketing_simd(\"(\")));\n    pass = pass && (! (correct_bracketing_simd(\"((((\")));\n    pass = pass && (! (correct_bracketing_simd(\")\")));\n    pass = pass && (! (correct_bracketing_simd(\"(()\")));\n    pass = pass && (! (correct_bracketing_simd(\"()()(()())())(()\")));\n    pass = pass && (! (correct_bracketing_simd(\"()()(()())()))()\")));\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = rng.randint<size_t>(0, 32);\n        const std::string charset = \"()\";\n        std::string brackets = rng.random_string(charset, length);\n              \n        bool res_scalar = correct_bracketing(brackets);\n        bool res_simd = correct_bracketing_simd(brackets);\n\n        if(!allclose(res_scalar, res_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<bool (*Func)(std::string)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t length = state.range(0);\n    std::string brackets;\n    if(rng.random_bool()){\n        for (int i = 0; i < length; ++i) {\n            brackets += \"()\";\n        }\n    }else{\n        brackets = std::string(length, '(') + std::string(length, ')');\n    }\n\n    for (auto _ : state) {\n        bool res = Func(brackets);\n        benchmark::DoNotOptimize(res);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, correct_bracketing)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, correct_bracketing_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/61", "entrypoint_scalar": "correct_bracketing", "entrypoint_simd": "correct_bracketing_simd"}
{"task_id": "SimdBench_91_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nxs represent coefficients of a polynomial.\nxs{0} + xs{1} * x + xs{2} * x^2 + ....\n Return derivative of this polynomial in the same form.\n>>> derivative_simd({3, 1, 2, 4, 5})\n{1, 4, 12, 20}\n>>> derivative_simd({1, 2, 3})\n{2, 6}\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<float> derivative_simd(std::vector<float> xs){\n}", "solution_scalar": "std::vector<float> derivative(std::vector<float> xs) {\n    if (xs.size() <= 1) {\n        std::vector<float> out(0);\n        return out;\n    }\n    std::vector<float> out(xs.size() - 1);\n    for (std::size_t i = 1; i < xs.size(); i++) {\n        out[i - 1] = i * xs[i];\n    }\n    return out;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (allclose(derivative_simd({3, 1, 2, 4, 5}), {1, 4, 12, 20}));\n    pass = pass && (allclose(derivative_simd({1, 2, 3}), {2, 6}));\n    pass = pass && (allclose(derivative_simd({3, 2, 1}), {2, 2}));\n    pass = pass && (allclose(derivative_simd({3, 2, 1, 0, 4}), {2, 2, 0, 16}));\n    pass = pass && (allclose(derivative_simd({1}), {}));\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<float> numbers(length);\n        rng.initialize_vector_with_random_values(numbers);\n        \n        std::vector<float> result = derivative(numbers);\n        std::vector<float> result_simd = derivative_simd(numbers);\n        \n        if(!allclose(result, result_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::vector<float> (*Func)(std::vector<float>)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<float> numbers(length);\n    rng.initialize_vector_with_random_values(numbers);\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(numbers));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, derivative)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, derivative_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/62", "entrypoint_scalar": "derivative", "entrypoint_simd": "derivative_simd"}
{"task_id": "SimdBench_92_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nWrite a function vowels_count which takes a string representing a word as input and returns the number of vowels in the string. Vowels in this case are 'a', 'e', 'i', 'o', 'u'. \nHere, 'y' is also a vowel, but only when it is at the end of the given word.\nExample: \n>>> vowels_count_simd(\"abcde\") \n2 \n>>> vowels_count_simd(\"ACEDY\") \n3\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nint vowels_count_simd(std::string s){\n}", "solution_scalar": "int vowels_count(std::string s){\n    std::string vowels=\"aeiouAEIOU\";\n    int count=0;\n    for (int i=0;i<s.length();i++)\n    if (find(vowels.begin(),vowels.end(),s[i])!=vowels.end())\n        count+=1;\n    if (s[s.length()-1]=='y' or s[s.length()-1]=='Y') count+=1;\n    return count;\n}", "test_correctness": "bool humaneval_check(){\n    bool pass = true;\n    pass = pass && (vowels_count_simd(\"abcde\") == 2);\n    pass = pass && (vowels_count_simd(\"Alone\") == 3);\n    pass = pass && (vowels_count_simd(\"key\") == 2);\n    pass = pass && (vowels_count_simd(\"bye\") == 1);\n    pass = pass && (vowels_count_simd(\"keY\") == 2);\n    pass = pass && (vowels_count_simd(\"bYe\") == 1);\n    pass = pass && (vowels_count_simd(\"ACEDY\") == 3);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        const std::string charset = CHARSET_ALPHANUMERIC;\n        std::string s = rng.random_string(charset, length);\n              \n        auto res_scalar = vowels_count(s);\n        auto res_simd = vowels_count_simd(s);\n\n        if(!allclose(res_scalar, res_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<int (*Func)(std::string)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t length = state.range(0);\n    const std::string charset = CHARSET_ALPHANUMERIC;\n    std::string s = rng.random_string(charset, length);\n\n    for (auto _ : state) {\n        int res = Func(s);\n        benchmark::DoNotOptimize(res);\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, vowels_count)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, vowels_count_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/64", "entrypoint_scalar": "vowels_count", "entrypoint_simd": "vowels_count_simd"}
{"task_id": "SimdBench_93_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nWrite a function that takes a string as input and returns the sum of the upper characters only's\nASCII codes.\nExamples:\n    digitSum_simd(\"\") => 0\n    digitSum_simd(\"abAB\") => 131\n    digitSum_simd(\"abcCd\") => 67\n    digitSum_simd(\"helloE\") => 69\n    digitSum_simd(\"woArBld\") => 131\n    digitSum_simd(\"aAaaaXa\") => 153\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nint digitSum_simd(std::string s){\n}", "solution_scalar": "int digitSum(std::string s){\n    int sum=0;\n    for (int i=0;i<s.length();i++)\n        if (s[i]>=65 and s[i]<=90)\n            sum+=s[i];\n    return sum;\n}", "test_correctness": "bool humaneval_check(){\n    bool pass = true;\n    pass = pass && (digitSum_simd(\"\") == 0);\n    pass = pass && (digitSum_simd(\"abAB\") == 131);\n    pass = pass && (digitSum_simd(\"abcCd\") == 67);\n    pass = pass && (digitSum_simd(\"helloE\") == 69);\n    pass = pass && (digitSum_simd(\"woArBld\") == 131);\n    pass = pass && (digitSum_simd(\"aAaaaXa\") == 153);\n    pass = pass && (digitSum_simd(\" How are yOu?\") == 151);\n    pass = pass && (digitSum_simd(\"You arE Very Smart\") == 327);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = rng.randint(size_t(0), size_t(128));\n        const std::string charset = CHARSET_PRINTABLE;\n        std::string s = rng.random_string(charset, length);\n              \n        auto res_scalar = digitSum(s);\n        auto res_simd = digitSum_simd(s);\n\n        if(!allclose(res_scalar, res_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<int (*Func)(std::string)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t length = state.range(0);\n    const std::string charset = CHARSET_PRINTABLE;\n    std::string s = rng.random_string(charset, length);\n\n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(s));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, digitSum)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, digitSum_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/66", "entrypoint_scalar": "digitSum", "entrypoint_simd": "digitSum_simd"}
{"task_id": "SimdBench_94_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a vector representing a branch of a tree that has non-negative integer nodes\nyour task is to pluck one of the nodes and return it.\nThe plucked node should be the node with the smallest even value.\nIf multiple nodes with the same smallest even value are found return the node that has smallest index.\n\nThe plucked node should be returned in a vector, { smalest_value, its index },\nIf there are no even values or the given vector is empty, return {}.\n\nExample 1:\n    Input: {4,2,3}\n    Output: {2, 1}\n    Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\nExample 2:\n    Input: {1,2,3}\n    Output: {2, 1}\n    Explanation: 2 has the smallest even value, and 2 has the smallest index. \n\nExample 3:\n    Input: {}\n    Output: {}\n\nExample 4:\n    Input: {5, 0, 3, 0, 4, 2}\n    Output: {0, 1}\n    Explanation: 0 is the smallest value, but there are two zeros,\n                 so we will choose the first zero, which has the smallest index.\n\nConstraints:\n    * 1 <= nodes.length <= 10000\n    * 0 <= node.value\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> pluck_simd(std::vector<int> arr){\n}", "solution_scalar": "std::vector<int> pluck(std::vector<int> arr){\n    std::vector<int> out(0);\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]%2==0 and (out.size()==0 or arr[i]<out[0]))\n        out={arr[i],i};\n    return out;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (allclose(pluck_simd({4,2,3}), {2, 1}));\n    pass = pass && (allclose(pluck_simd({1,2,3}), {2, 1}));\n    pass = pass && (allclose(pluck_simd({}), {}));\n    pass = pass && (allclose(pluck_simd({5, 0, 3, 0, 4, 2}), {0, 1}));\n    pass = pass && (allclose(pluck_simd({1, 2, 3, 0, 5, 3}), {0, 3}));\n    pass = pass && (allclose(pluck_simd({5, 4, 8, 4 ,8}), {4, 1}));\n    pass = pass && (allclose(pluck_simd({7, 6, 7, 1}), {6, 1}));\n    pass = pass && (allclose(pluck_simd({7, 9, 7, 1}), {}));\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = rng.randint<size_t>(0, 128);\n        std::vector<int> numbers(length);\n        rng.initialize_vector_with_random_values(numbers);\n        \n        std::vector<int> result = pluck(numbers);\n        std::vector<int> result_simd = pluck_simd(numbers);\n        \n        if(!allclose(result, result_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::vector<int> (*Func)(std::vector<int>)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<int> numbers(length);\n    rng.initialize_vector_with_random_values(numbers);\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(numbers));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, pluck)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, pluck_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/68", "entrypoint_scalar": "pluck", "entrypoint_simd": "pluck_simd"}
{"task_id": "SimdBench_95_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nYou are given a non-empty vector of positive integers. Return the greatest integer that is greater than \nzero, and has a frequency greater than or equal to the value of the integer itself. \nThe frequency of an integer is the number of times it appears in the vector.\nIf no such a value exist, return -1.\nExamples:\n    search_simd({4, 1, 2, 2, 3, 1}) == 2\n    search_simd({1, 2, 2, 3, 3, 3, 4, 4, 4}) == 3\n    search_simd({5, 5, 4, 4, 4}) == -1\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nint search_simd(std::vector<int> lst){\n}", "solution_scalar": "int search(std::vector<int> lst) {\n    std::unordered_map<int, int> freq;\n    for (int num : lst) {\n        freq[num]++;\n    }\n\n    int max = -1;\n    for (const auto& pair : freq) {\n        int value = pair.first;\n        int count = pair.second;\n        if (count >= value && value > max) {\n            max = value;\n        }\n    }\n    return max;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (search_simd({5, 5, 5, 5, 1}) == 1);\n    pass = pass && (search_simd({4, 1, 4, 1, 4, 4}) == 4);\n    pass = pass && (search_simd({3, 3}) == -1);\n    pass = pass && (search_simd({8, 8, 8, 8, 8, 8, 8, 8}) == 8);\n    pass = pass && (search_simd({2, 3, 3, 2, 2}) == 2);\n    pass = pass && (search_simd({2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1}) == 1);\n    pass = pass && (search_simd({3, 2, 8, 2}) == 2);\n    pass = pass && (search_simd({6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10}) == 1);\n    pass = pass && (search_simd({8, 8, 3, 6, 5, 6, 4}) == -1);\n    pass = pass && (search_simd({6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9}) == 1);\n    pass = pass && (search_simd({1, 9, 10, 1, 3}) == 1);\n    pass = pass && (search_simd({6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10}) == 5);\n    pass = pass && (search_simd({1}) == 1);\n    pass = pass && (search_simd({8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5}) == 4);\n    pass = pass && (search_simd({2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10}) == 2);\n    pass = pass && (search_simd({1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3}) == 1);\n    pass = pass && (search_simd({9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4}) == 4);\n    pass = pass && (search_simd({2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7}) == 4);\n    pass = pass && (search_simd({9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1}) == 2);\n    pass = pass && (search_simd({5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8}) == -1);\n    pass = pass && (search_simd({10}) == -1);\n    pass = pass && (search_simd({9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2}) == 2);\n    pass = pass && (search_simd({5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8}) == 1);\n    pass = pass && (search_simd({7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6}) == 1);\n    pass = pass && (search_simd({3, 10, 10, 9, 2}) == -1);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<int> numbers(length);\n        rng.initialize_vector_with_random_values(numbers);\n        \n        int result = search(numbers);\n        int result_simd = search_simd(numbers);\n        \n        if(result != result_simd){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<int (*Func)(std::vector<int>)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<int> numbers(length);\n    rng.initialize_vector_with_random_values(numbers);\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(numbers));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, search)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, search_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/69", "entrypoint_scalar": "search", "entrypoint_simd": "search_simd"}
{"task_id": "SimdBench_96_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nWrite a function that returns true if the non-empty object q will fly, and false otherwise.\nThe object q will fly if it's balanced (it is a palindromic vector) and the sum of its elements is less than or equal the maximum possible weight w.\n\nExample:\nwill_it_fly_simd({1, 2}, 5) \u279e false \n// 1+2 is less than the maximum possible weight, but it's unbalanced.\n\nwill_it_fly_simd({3, 2, 3}, 1) \u279e false\n// it's balanced, but 3+2+3 is more than the maximum possible weight.\n\nwill_it_fly_simd({3, 2, 3}, 9) \u279e true\n// 3+2+3 is less than the maximum possible weight, and it's balanced.\n\nwill_it_fly_simd({3}, 5) \u279e true\n// 3 is less than the maximum possible weight, and it's balanced.\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nbool will_it_fly_simd(std::vector<int> q,int w){\n}", "solution_scalar": "bool will_it_fly(std::vector<int> q, int w){\n    int sum=0;\n    for (int i=0;i<q.size();i++)\n    {\n        if (q[i]!=q[q.size()-1-i]) return false;\n        sum+=q[i];\n    }\n    if (sum>w) return false;\n    return true;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (will_it_fly_simd({3, 2, 3}, 9) == true);\n    pass = pass && (will_it_fly_simd({1, 2}, 5) == false);\n    pass = pass && (will_it_fly_simd({3}, 5) == true);\n    pass = pass && (will_it_fly_simd({3, 2, 3}, 1) == false);\n    pass = pass && (will_it_fly_simd({1, 2, 3}, 6) == false);\n    pass = pass && (will_it_fly_simd({5}, 5) == true);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<int> numbers(length);\n        for(auto & element : numbers) {\n            element = rng.randint<int>(-50, 100);\n        }\n        for(int j = 0; j < length / 2; j++) {\n            numbers[length - 1 - j] = numbers[j];\n        }\n        int weight = rng.randint<int>(0, 10000);\n        \n        bool result = will_it_fly(numbers, weight);\n        bool result_simd = will_it_fly_simd(numbers, weight);\n        \n        if(result != result_simd){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<bool (*Func)(std::vector<int>, int)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<int> numbers(length);\n    for(auto & element : numbers) {\n        element = rng.randint<int>(-50, 100);\n    }\n    for(int j = 0; j < length / 2; j++) {\n        numbers[length - 1 - j] = numbers[j];\n    }\n    int weight = rng.randint<int>(0, 10000);\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(numbers, weight));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, will_it_fly)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, will_it_fly_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/72", "entrypoint_scalar": "will_it_fly", "entrypoint_simd": "will_it_fly_simd"}
{"task_id": "SimdBench_97_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a non-empty vector arr of integers, find the minimum number of elements that\nneed to be changed to make the vector palindromic. A palindromic vector is a vector that\nis read the same backwards and forwards. In one change, you can change one element to any other element.\n\nFor example:\nsmallest_change_simd({1,2,3,5,4,7,9,6}) == 4\nsmallest_change_simd({1, 2, 3, 4, 3, 2, 2}) == 1\nsmallest_change_simd({1, 2, 3, 2, 1}) == 0\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nint smallest_change_simd(std::vector<int> arr){\n}", "solution_scalar": "int smallest_change(std::vector<int> arr){\n    int out=0;\n    for (int i=0;i<arr.size()-1-i;i++)\n        if (arr[i]!=arr[arr.size()-1-i])\n            out+=1;\n    return out;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (smallest_change_simd({1,2,3,5,4,7,9,6}) == 4);\n    pass = pass && (smallest_change_simd({1, 2, 3, 4, 3, 2, 2}) == 1);\n    pass = pass && (smallest_change_simd({1, 4, 2}) == 1);\n    pass = pass && (smallest_change_simd({1, 4, 4, 2}) == 1);\n    pass = pass && (smallest_change_simd({1, 2, 3, 2, 1}) == 0);\n    pass = pass && (smallest_change_simd({3, 1, 1, 3}) == 0);\n    pass = pass && (smallest_change_simd({1}) == 0);\n    pass = pass && (smallest_change_simd({0, 1}) == 1);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<int> numbers(length);\n        for(auto& number : numbers) {\n            number = rng.randint<int>(-10, 10);\n        }\n        \n        int result = smallest_change(numbers);\n        int result_simd = smallest_change_simd(numbers);\n        \n        if(result != result_simd){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<int (*Func)(std::vector<int>)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<int> numbers(length);\n    rng.initialize_vector_with_random_values(numbers);\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(numbers));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, smallest_change)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, smallest_change_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/73", "entrypoint_scalar": "smallest_change", "entrypoint_simd": "smallest_change_simd"}
{"task_id": "SimdBench_98_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nWrite a function that accepts two vectors of strings and returns the vector that has \ntotal number of chars in the all strings of the vector less than the other vector.\n\nif the two vectors have the same number of chars, return the first vector.\n\nExamples\ntotal_match_simd({}, {}) \u279e {}\ntotal_match_simd({\"hi\", \"admin\"}, {\"hI\", \"Hi\"}) \u279e {\"hI\", \"Hi\"}\ntotal_match_simd({\"hi\", \"admin\"}, {\"hi\", \"hi\", \"admin\", \"project\"}) \u279e {\"hi\", \"admin\"}\ntotal_match_simd({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hi\"}) \u279e {\"hI\", \"hi\", \"hi\"}\ntotal_match_simd({\"4\"}, {\"1\", \"2\", \"3\", \"4\", \"5\"}) \u279e {\"4\"}\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n}", "solution_scalar": "std::vector<std::string> total_match(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    int num1,num2,i;\n    num1=0;num2=0;\n    for (i=0;i<lst1.size();i++)\n        num1+=lst1[i].length();\n    for (i=0;i<lst2.size();i++)\n        num2+=lst2[i].length();\n    if (num1>num2) return lst2;\n    return lst1;\n}", "test_correctness": "bool humaneval_check(){\n    bool pass = true;\n    pass = pass && (allclose(total_match_simd({}, {}) , {}));\n    pass = pass && (allclose(total_match_simd({\"hi\", \"admin\"}, {\"hi\", \"hi\"}) , {\"hi\", \"hi\"}));\n    pass = pass && (allclose(total_match_simd({\"hi\", \"admin\"}, {\"hi\", \"hi\", \"admin\", \"project\"}) , {\"hi\", \"admin\"}));\n    pass = pass && (allclose(total_match_simd({\"4\"}, {\"1\", \"2\", \"3\", \"4\", \"5\"}) , {\"4\"}));\n    pass = pass && (allclose(total_match_simd({\"hi\", \"admin\"}, {\"hI\", \"Hi\"}) , {\"hI\", \"Hi\"}));\n    pass = pass && (allclose(total_match_simd({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hi\"}) , {\"hI\", \"hi\", \"hi\"}));\n    pass = pass && (allclose(total_match_simd({\"hi\", \"admin\"}, {\"hI\", \"hi\", \"hii\"}) , {\"hi\", \"admin\"}));\n    pass = pass && (allclose(total_match_simd({}, {\"this\"}) , {}));\n    pass = pass && (allclose(total_match_simd({\"this\"}, {}) , {}));\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length1 = rng.randint(size_t(0), size_t(128));\n        size_t length2 = rng.randint(size_t(0), size_t(128));\n        const std::string charset = CHARSET_PRINTABLE;\n        std::vector<std::string> lst1(length1);\n        std::vector<std::string> lst2(length2);\n\n        for(auto & s: lst1) s = rng.random_string(charset, rng.randint(0,10));\n        for(auto & s: lst2) s = rng.random_string(charset, rng.randint(0,20));\n              \n        auto res_scalar = total_match(lst1, lst2);\n        auto res_simd = total_match_simd(lst1, lst2);\n\n        if(!allclose(res_scalar, res_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::vector<std::string> (*Func)(const std::vector<std::string> &, const std::vector<std::string> &)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t length = state.range(0)/4;\n    const std::string charset = CHARSET_PRINTABLE;\n    std::vector<std::string> lst1(length);\n    std::vector<std::string> lst2(length);\n\n    for(auto & s: lst1) s = rng.random_string(charset, rng.randint(0,10));\n    for(auto & s: lst2) s = rng.random_string(charset, rng.randint(0,20));\n\n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(lst1, lst2));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, total_match)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, total_match_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/74", "entrypoint_scalar": "total_match", "entrypoint_simd": "total_match_simd"}
{"task_id": "SimdBench_99_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nYour task is to write a function that returns true if a number x is a simple\npower of n and false in other cases.\nx is a simple power of n if n**int=x\nFor example:\nis_simple_power_simd(1, 4) => true\nis_simple_power_simd(2, 2) => true\nis_simple_power_simd(8, 2) => true\nis_simple_power_simd(3, 2) => false\nis_simple_power_simd(3, 1) => false\nis_simple_power_simd(5, 3) => false\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nbool is_simple_power_simd(uint64_t x, uint64_t n){\n}", "solution_scalar": "bool is_simple_power(uint64_t x, uint64_t n){\n    uint64_t p=1, count=0;\n    while (p<=x && count<128)\n    {\n        if (p==x) return true;\n        p=p*n; count+=1;\n    }\n    return false;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (is_simple_power_simd(1, 4)== true);\n    pass = pass && (is_simple_power_simd(2, 2)==true);\n    pass = pass && (is_simple_power_simd(8, 2)==true);\n    pass = pass && (is_simple_power_simd(3, 2)==false);\n    pass = pass && (is_simple_power_simd(3, 1)==false);\n    pass = pass && (is_simple_power_simd(5, 3)==false);\n    pass = pass && (is_simple_power_simd(16, 2)== true);\n    pass = pass && (is_simple_power_simd(143214, 16)== false);\n    pass = pass && (is_simple_power_simd(4, 2)==true);\n    pass = pass && (is_simple_power_simd(9, 3)==true);\n    pass = pass && (is_simple_power_simd(16, 4)==true);\n    pass = pass && (is_simple_power_simd(24, 2)==false);\n    pass = pass && (is_simple_power_simd(128, 4)==false);\n    pass = pass && (is_simple_power_simd(12, 6)==false);\n    pass = pass && (is_simple_power_simd(1, 1)==true);\n    pass = pass && (is_simple_power_simd(1, 12)==true);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        int x = rng.randint<int>(1, 10000);\n        int n = rng.randint<int>(1, 16);\n        \n        auto result = is_simple_power(x, n);\n        auto result_simd = is_simple_power_simd(x, n);\n\n        if(!allclose(result, result_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main(){\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<bool (*Func)(uint64_t, uint64_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    uint64_t n = rng.randint<int>(2, 3);\n    uint64_t x = pow(n, 30);  \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(x, n));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, is_simple_power)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, is_simple_power_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/76", "entrypoint_scalar": "is_simple_power", "entrypoint_simd": "is_simple_power_simd"}
{"task_id": "SimdBench_100_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nYou have been tasked to write a function that receives \na hexadecimal number as a string and counts the number of hexadecimal \ndigits that are primes (prime number, or a prime, is a natural number \ngreater than 1 that is not a product of two smaller natural numbers).\nHexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\nPrime numbers are 2, 3, 5, 7, 11, 13, 17,...\nSo you have to determine a number of the following digits: 2, 3, 5, 7, \nB (=decimal 11), D (=decimal 13).\nNote: you may assume the input is always correct or empty string, \nand symbols A,B,C,D,E,F are always uppercase.\nExamples:\nFor num = \"AB\" the output should be 1.\nFor num = \"1077E\" the output should be 2.\nFor num = \"ABED1A33\" the output should be 4.\nFor num = \"123456789ABCDEF0\" the output should be 6.\nFor num = \"2020\" the output should be 2.\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nint hex_key_simd(const std::string & num){\n}", "solution_scalar": "int hex_key(const std::string & num){\n    std::string key=\"2357BD\";\n    int out=0;\n    for (int i=0;i<num.length();i++)\n    if (find(key.begin(),key.end(),num[i])!=key.end()) out+=1;\n    return out;\n}", "test_correctness": "bool humaneval_check(){\n    bool res = true;\n    res = res && (hex_key_simd(\"AB\") == 1);\n    res = res && (hex_key_simd(\"1077E\") == 2);\n    res = res && (hex_key_simd(\"ABED1A33\") == 4);\n    res = res && (hex_key_simd(\"2020\") == 2);\n    res = res && (hex_key_simd(\"123456789ABCDEF0\") == 6);\n    res = res && (hex_key_simd(\"112233445566778899AABBCCDDEEFF00\") == 12);\n    res = res && (hex_key_simd(\"\") == 0);\n    return res;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = rng.randint(size_t(0), size_t(128));\n        const std::string charset = CHARSET_HEX;\n        std::string num = rng.random_string(charset, length);\n              \n        auto res_scalar = hex_key(num);\n        auto res_simd = hex_key_simd(num);\n\n        if(!allclose(res_scalar, res_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<int (*Func)(const std::string &)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t length = state.range(0);\n    const std::string charset = CHARSET_HEX;\n    std::string num = rng.random_string(charset, length);\n\n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(num));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, hex_key)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, hex_key_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/78", "entrypoint_scalar": "hex_key", "entrypoint_simd": "hex_key_simd"}
{"task_id": "SimdBench_101_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nYou are given a string s.\nYour task is to check if the string is happy or not.\nA string is happy if its length is at least 3 and every 3 consecutive letters are distinct\nFor example:\nis_happy_simd(\"a\") => false\nis_happy_simd(\"aa\") => false\nis_happy_simd(\"abcd\") => true\nis_happy_simd(\"aabb\") => false\nis_happy_simd(\"adb\") => true\nis_happy_simd(\"xyy\") => false\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nbool is_happy_simd(const std::string & s){\n}", "solution_scalar": "bool is_happy(const std::string & s){\n    if (s.length()<3) return false;\n    for (int i=2;i<s.length();i++)\n    if (s[i]==s[i-1] or s[i]==s[i-2]) return false;\n    return true;\n}", "test_correctness": "bool humaneval_check(){\n    bool pass = true;\n    pass = pass && (is_happy_simd(\"a\") == false );\n    pass = pass && (is_happy_simd(\"aa\") == false );\n    pass = pass && (is_happy_simd(\"abcd\") == true );\n    pass = pass && (is_happy_simd(\"aabb\") == false );\n    pass = pass && (is_happy_simd(\"adb\") == true );\n    pass = pass && (is_happy_simd(\"xyy\") == false );\n    pass = pass && (is_happy_simd(\"iopaxpoi\") == true );\n    pass = pass && (is_happy_simd(\"iopaxioi\") == false );\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = rng.randint(size_t(0), size_t(10));\n        const std::string charset = CHARSET_PRINTABLE;\n        std::string s = rng.random_string(charset, length);\n              \n        auto res_scalar = is_happy(s);\n        auto res_simd = is_happy_simd(s);\n\n        if(!allclose(res_scalar, res_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<bool (*Func)(const std::string &)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t length = state.range(0);\n    const std::string charset = CHARSET_PRINTABLE;\n    std::string s = \"\";\n    for(int i=0; i<length; ++i) s.push_back(charset[i%charset.length()]);\n\n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(s));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, is_happy)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, is_happy_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/80", "entrypoint_scalar": "is_happy", "entrypoint_simd": "is_happy_simd"}
{"task_id": "SimdBench_102_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nWrite a function that takes a non-empty string and returns true if the string\nlength is a prime number or false otherwise\nExamples\nprime_length_simd(\"Hello\") == true\nprime_length_simd(\"abcdcba\") == true\nprime_length_simd(\"kittens\") == true\nprime_length_simd(\"orange\") == false\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nbool prime_length_simd(const std::string & str){\n}", "solution_scalar": "bool prime_length(const std::string & str){\n    int l,i;\n    l=str.length();\n    if (l<2) return false;\n    for (i=2;i*i<=l;i++)\n    if (l%i==0) return false;\n    return true;\n}", "test_correctness": "bool humaneval_check(){\n    bool pass = true;\n    pass = pass && (prime_length_simd(\"Hello\") == true);\n    pass = pass && (prime_length_simd(\"abcdcba\") == true);\n    pass = pass && (prime_length_simd(\"kittens\") == true);\n    pass = pass && (prime_length_simd(\"orange\") == false);\n    pass = pass && (prime_length_simd(\"wow\") == true);\n    pass = pass && (prime_length_simd(\"world\") == true);\n    pass = pass && (prime_length_simd(\"MadaM\") == true);\n    pass = pass && (prime_length_simd(\"Wow\") == true);\n    pass = pass && (prime_length_simd(\"\") == false);\n    pass = pass && (prime_length_simd(\"HI\") == true);\n    pass = pass && (prime_length_simd(\"go\") == true);\n    pass = pass && (prime_length_simd(\"gogo\") == false);\n    pass = pass && (prime_length_simd(\"aaaaaaaaaaaaaaa\") == false);\n    pass = pass && (prime_length_simd(\"Madam\") == true);\n    pass = pass && (prime_length_simd(\"M\") == false);\n    pass = pass && (prime_length_simd(\"0\") == false);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        const std::string charset = CHARSET_PRINTABLE;\n        std::string s = rng.random_string(charset, length);\n              \n        auto res_scalar = prime_length(s);\n        auto res_simd = prime_length_simd(s);\n\n        if(!allclose(res_scalar, res_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<bool (*Func)(const std::string &)>\nstatic void BM(benchmark::State& state) {\n    Random rng(DEFAULT_SEED);\n    std::vector<size_t> large_primes = {8503057, 9834497, 29986577, 40960001, 45212177, 59969537, 65610001};\n    const std::string charset = CHARSET_ALPHA;\n    size_t length = rng.choice(large_primes);\n    std::string s = \"\";\n    for(int i=0; i<length; ++i) s.push_back(charset[i%charset.length()]);\n\n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(s));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, prime_length)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, prime_length_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/82", "entrypoint_scalar": "prime_length", "entrypoint_simd": "prime_length_simd"}
{"task_id": "SimdBench_103_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a positive integer N, return the total sum of its digits in binary.\n\nExample\n    For N = 1000, the sum of digits will be 1 the output should be \"1\".\n    For N = 150, the sum of digits will be 6 the output should be \"110\".\n    For N = 147, the sum of digits will be 12 the output should be \"1100\".\n\nVariables:\n    @N 64-bit integer\nOutput:\n     a string of binary number\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::string solve_simd(uint64_t N){\n}", "solution_scalar": "std::string solve(uint64_t N){\n    std::string str,bi=\"\";\n    str=std::to_string(N);\n    int i,sum=0;\n    for (int i=0;i<str.length();i++)\n        sum+=str[i]-48;\n    while (sum>0)\n    {\n        bi=std::to_string(sum%2)+bi;\n        sum=sum/2;\n    }\n    return bi;\n}", "test_correctness": "bool humaneval_check(){\n    bool pass = true;\n    pass = pass && (solve_simd(1000) == \"1\");\n    pass = pass && (solve_simd(150) == \"110\");\n    pass = pass && (solve_simd(147) == \"1100\");\n    pass = pass && (solve_simd(333) == \"1001\");\n    pass = pass && (solve_simd(963) == \"10010\");\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        const uint64_t N = rng.randint<uint64_t>();\n              \n        auto res_scalar = solve(N);\n        auto res_simd = solve_simd(N);\n\n        if(!allclose(res_scalar, res_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::string (*Func)(uint64_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng(DEFAULT_SEED);\n    const uint64_t N = rng.randint<uint64_t>();\n\n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(N));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, solve)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, solve_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/84", "entrypoint_scalar": "solve", "entrypoint_simd": "solve_simd"}
{"task_id": "SimdBench_104_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a non-empty vector of integers lst. add the even elements that are at odd indices.\nExamples:\n    add_simd({4, 2, 6, 7}) ==> 2 \n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nint add_simd(std::vector<int> lst){\n}", "solution_scalar": "int add(std::vector<int> lst){\n    int sum=0;\n    for (int i=0;i*2+1<lst.size();i++)\n        if (lst[i*2+1]%2==0) sum+=lst[i*2+1];\n    return sum;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (add_simd({4, 88}) == 88);\n    pass = pass && (add_simd({4, 5, 6, 7, 2, 122}) == 122);\n    pass = pass && (add_simd({4, 0, 6, 7}) == 0);\n    pass = pass && (add_simd({4, 4, 6, 8}) == 12);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<int> numbers(length);\n        rng.initialize_vector_with_random_values(numbers);\n        \n        int result = add(numbers);\n        int result_simd = add_simd(numbers);\n        \n        if(result != result_simd){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<int (*Func)(std::vector<int>)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<int> numbers(length);\n    rng.initialize_vector_with_random_values(numbers);\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(numbers));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, add)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, add_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/85", "entrypoint_scalar": "add", "entrypoint_simd": "add_simd"}
{"task_id": "SimdBench_105_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nCreate a function encrypt that takes a string as an argument and\nreturns a string encrypted with the alphabet being rotated. \nThe alphabet should be rotated in a manner such that the letters \nshift down by two multiplied to two places.\nFor example:\nencrypt_simd(\"hi\") returns \"lm\"\nencrypt_simd(\"asdfghjkl\") returns \"ewhjklnop\"\nencrypt_simd(\"gf\") returns \"kj\"\nencrypt_simd(\"et\") returns \"ix\"\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::string encrypt_simd(const std::string & s){\n}", "solution_scalar": "std::string encrypt(const std::string & s){\n    std::string out = \"\";\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]+4-(int)'a')%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}", "test_correctness": "bool humaneval_check(){\n    bool pass = true;\n    pass = pass && (encrypt_simd(\"hi\") == \"lm\");\n    pass = pass && (encrypt_simd(\"asdfghjkl\") == \"ewhjklnop\");\n    pass = pass && (encrypt_simd(\"gf\") == \"kj\");\n    pass = pass && (encrypt_simd(\"et\") == \"ix\");\n    pass = pass && (encrypt_simd(\"faewfawefaewg\")==\"jeiajeaijeiak\");\n    pass = pass && (encrypt_simd(\"hellomyfriend\")==\"lippsqcjvmirh\");\n    pass = pass && (encrypt_simd(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")==\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\");\n    pass = pass && (encrypt_simd(\"a\")==\"e\");\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = rng.randint(size_t(0), size_t(128));\n        const std::string charset = CHARSET_LOWERCASE;\n        std::string s = rng.random_string(charset, length);\n              \n        auto res_scalar = encrypt(s);\n        auto res_simd = encrypt_simd(s);\n\n        if(!allclose(res_scalar, res_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::string (*Func)(const std::string &)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    const std::string charset = CHARSET_LOWERCASE;\n    size_t length = state.range(0);\n    std::string s = \"\";\n    for(int i=0; i<length; ++i) s.push_back(charset[i%charset.length()]);\n\n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(s));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, encrypt)->Name(\"Scalar\")->Medium_Args_1D;\nBENCHMARK_TEMPLATE(BM, encrypt_simd)->Name(\"SIMD\")->Medium_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/89", "entrypoint_scalar": "encrypt", "entrypoint_simd": "encrypt_simd"}
{"task_id": "SimdBench_106_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nWrite a function that takes a message, and encodes in such a \nway that it swaps case of all letters, replaces all vowels in \nthe message with the letter that appears 2 places ahead of that \nvowel in the english alphabet. \nAssume only letters. \n\nExamples:\n>>> encode_simd('test\")\n\"TGST\"\n>>> encode_simd(\"This is a message\")\n'tHKS KS C MGSSCGG\"\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::string encode_simd(const std::string & message){\n}", "solution_scalar": "std::string encode(const std::string & message){\n    std::string vowels=\"aeiouAEIOU\";\n    std::string out=\"\";\n    for (int i=0;i<message.length();i++)\n    {\n        char w=message[i];\n        if (w>=97 and w<=122){w=w-32;}\n        else if (w>=65 and w<=90) w=w+32;\n        if (find(vowels.begin(),vowels.end(),w)!=vowels.end()) w=w+2;\n        out=out+w;\n    }\n    return out;\n}", "test_correctness": "bool humaneval_check(){\n    bool pass = true;\n    pass = pass && (encode_simd(\"TEST\") == \"tgst\");\n    pass = pass && (encode_simd(\"Mudasir\") == \"mWDCSKR\");\n    pass = pass && (encode_simd(\"YES\") == \"ygs\");\n    pass = pass && (encode_simd(\"This is a message\") == \"tHKS KS C MGSSCGG\");\n    pass = pass && (encode_simd(\"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\");\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = rng.randint(size_t(0), size_t(128));\n        const std::string charset = CHARSET_LOWERCASE + CHARSET_UPPERCASE + \" \";\n        std::string s = rng.random_string(charset, length);\n              \n        auto res_scalar = encode(s);\n        auto res_simd = encode_simd(s);\n\n        if(!allclose(res_scalar, res_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::string (*Func)(const std::string &)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    const std::string charset = CHARSET_LOWERCASE;\n    size_t length = state.range(0);\n    std::string s = rng.random_string(charset, length);\n\n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(s));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, encode)->Name(\"Scalar\")->Medium_Args_1D;\nBENCHMARK_TEMPLATE(BM, encode_simd)->Name(\"SIMD\")->Medium_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/93", "entrypoint_scalar": "encode", "entrypoint_simd": "encode_simd"}
{"task_id": "SimdBench_107_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a map, return true if all keys are strings in lower \ncase or all keys are strings in upper case, else return false.\nThe function should return false is the given map is empty.\nExamples:\ncheck_map_case_simd({{\"a\",\"apple\"}, {\"b\",\"banana\"}}) should return true.\ncheck_map_case_simd({{\"a\",\"apple\"}, {\"A\",\"banana\"}, {\"B\",\"banana\"}}) should return false.\ncheck_map_case_simd({{\"a\",\"apple\"}, {\"8\",\"banana\"}, {\"a\",\"apple\"}}) should return false.\ncheck_map_case_simd({{\"Name\",\"John\"}, {\"Age\",\"36\"}, {\"City\",\"Houston\"}}) should return false.\ncheck_map_case_simd({{\"STATE\",\"NC\"}, {\"ZIP\",\"12345\"} }) should return true.\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nbool check_dict_case_simd(std::map<std::string, std::string> dict){\n}", "solution_scalar": "bool check_dict_case(std::map<std::string, std::string> dict) {\n    std::map<std::string, std::string>::const_iterator it;\n    int islower = 0, isupper = 0;\n    if (dict.size() == 0) return false;\n    for (it = dict.begin(); it != dict.end(); it++) {\n        std::string key = it->first;\n\n        for (size_t i = 0; i < key.size(); i++) {\n            if (key[i] < 65 || (key[i] > 90 && key[i] < 97) || key[i] > 122) return false;\n            if (key[i] >= 65 && key[i] <= 90) isupper = 1;\n            if (key[i] >= 97 && key[i] <= 122) islower = 1;\n            if (isupper + islower == 2) return false;\n        }\n    }\n    return true;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (check_dict_case_simd({{\"p\",\"pineapple\"}, {\"b\",\"banana\"}}) == true);\n    pass = pass && (check_dict_case_simd({{\"p\",\"pineapple\"}, {\"A\",\"banana\"}, {\"B\",\"banana\"}}) == false);\n    pass = pass && (check_dict_case_simd({{\"p\",\"pineapple\"}, {\"5\",\"banana\"}, {\"a\",\"apple\"}}) == false);\n    pass = pass && (check_dict_case_simd({{\"Name\",\"John\"}, {\"Age\",\"36\"}, {\"City\",\"Houston\"}}) == false);\n    pass = pass && (check_dict_case_simd({{\"STATE\",\"NC\"}, {\"ZIP\",\"12345\"} }) == true  );\n    pass = pass && (check_dict_case_simd({{\"fruit\",\"Orange\"}, {\"taste\",\"Sweet\"} }) == true  );\n    pass = pass && (check_dict_case_simd({}) == false);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = rng.randint<size_t>(0, 128);\n        int type = rng.randint<int>() % 6;\n        std::string charset;\n        if(type==0) charset = CHARSET_LOWERCASE;\n        else if(type==1) charset = CHARSET_UPPERCASE;\n        else if(type==2) charset = CHARSET_ALPHANUMERIC;\n        else if(type==3) charset = CHARSET_PRINTABLE;\n        else if(type==4) charset = CHARSET_HEX;\n        else charset = CHARSET_ALPHA;\n\n        std::map<std::string, std::string> dict;\n        for (size_t j = 0; j < length; j++) {\n            std::string key = rng.random_string(charset, rng.randint<size_t>(1, 20));\n            std::string value = rng.random_string(charset, rng.randint<size_t>(1, 20));\n            dict[key] = value;\n        }\n        \n        bool result = check_dict_case(dict);\n        bool result_simd = check_dict_case_simd(dict);\n        \n        if(result != result_simd){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<bool (*Func)(std::map<std::string, std::string>)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    const std::string charset = CHARSET_UPPERCASE;\n    std::map<std::string, std::string> dict;\n    for (size_t j = 0; j < length; j++) {\n        std::string key = rng.random_string(charset, rng.randint<size_t>(1, 20));\n        std::string value = rng.random_string(charset, rng.randint<size_t>(1, 20));\n        dict[key] = value;\n    }\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(dict));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, check_dict_case)->Name(\"Scalar\")->Medium_Args_1D;\nBENCHMARK_TEMPLATE(BM, check_dict_case_simd)->Name(\"SIMD\")->Medium_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/95", "entrypoint_scalar": "check_dict_case", "entrypoint_simd": "check_dict_case_simd"}
{"task_id": "SimdBench_108_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nImplement a function that takes an non-negative integer and returns a vector of the first n\nintegers that are prime numbers and less than n.\nfor example:\ncount_up_to_simd(5) => {2,3}\ncount_up_to_simd(11) => {2,3,5,7}\ncount_up_to_simd(0) => {}\ncount_up_to_simd(20) => {2,3,5,7,11,13,17,19}\ncount_up_to_simd(1) => {}\ncount_up_to_simd(18) => {2,3,5,7,11,13,17}\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> count_up_to_simd(int n){\n}", "solution_scalar": "std::vector<int> count_up_to(int n) {\n    if (n <= 2) {\n        return {};\n    }\n    std::vector<int> out(n);\n    int count = 0;\n    for (int i = 2; i < n; i++) {\n        bool isp = true;\n        for (int j = 0; j < count && out[j] * out[j] <= i; j++) {\n            if (i % out[j] == 0) {\n                isp = false;\n                break;\n            }\n        }\n\n        if (isp) {\n            out[count] = i;\n            count++;\n        }\n    }\n    out.resize(count);\n    return out;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (allclose(count_up_to_simd(5), {2,3}));\n    pass = pass && (allclose(count_up_to_simd(6), {2,3,5}));\n    pass = pass && (allclose(count_up_to_simd(7), {2,3,5}));\n    pass = pass && (allclose(count_up_to_simd(10), {2,3,5,7}));\n    pass = pass && (allclose(count_up_to_simd(0), {}));\n    pass = pass && (allclose(count_up_to_simd(22), {2,3,5,7,11,13,17,19}));\n    pass = pass && (allclose(count_up_to_simd(1), {}));\n    pass = pass && (allclose(count_up_to_simd(18), {2,3,5,7,11,13,17}));\n    pass = pass && (allclose(count_up_to_simd(47), {2,3,5,7,11,13,17,19,23,29,31,37,41,43}));\n    pass = pass && (allclose(count_up_to_simd(101), {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97}));\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        int n = rng.randint<int>(2, 1 << 14);\n        \n        std::vector<int> result = count_up_to(n);\n        std::vector<int> result_simd = count_up_to_simd(n);\n        \n        if(!allclose(result, result_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed for n=\" << n << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::vector<int> (*Func)(int)>\nstatic void BM(benchmark::State& state) {\n    const int n = state.range(0);\n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(n));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, count_up_to)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, count_up_to_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/96", "entrypoint_scalar": "count_up_to", "entrypoint_simd": "count_up_to_simd"}
{"task_id": "SimdBench_109_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a string s, count the number of uppercase vowels in even indices.\n\nFor example:\ncount_upper_simd(\"aBCdEf\") returns 1\ncount_upper_simd(\"abcdefg\") returns 0\ncount_upper_simd(\"dBBE\") returns 0\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nint count_upper_simd(const std::string & s){\n}", "solution_scalar": "int count_upper(const std::string & s){\n    std::string uvowel=\"AEIOU\";\n    int count=0;\n    for (int i=0;i*2<s.length();i++)\n    if (find(uvowel.begin(),uvowel.end(),s[i*2])!=uvowel.end())\n        count+=1;\n    return count;\n}", "test_correctness": "bool humaneval_check(){\n    bool pass = true;\n    pass = pass && (count_upper_simd(\"aBCdEf\")  == 1);\n    pass = pass && (count_upper_simd(\"abcdefg\") == 0);\n    pass = pass && (count_upper_simd(\"dBBE\") == 0);\n    pass = pass && (count_upper_simd(\"B\")  == 0);\n    pass = pass && (count_upper_simd(\"U\")  == 1);\n    pass = pass && (count_upper_simd(\"\") == 0);\n    pass = pass && (count_upper_simd(\"EEEE\") == 2);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = rng.randint(size_t(0), size_t(128));\n        const std::string charset = CHARSET_ALPHANUMERIC;\n        std::string s = rng.random_string(charset, length);\n              \n        auto res_scalar = count_upper(s);\n        auto res_simd = count_upper_simd(s);\n\n        if(!allclose(res_scalar, res_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<int (*Func)(const std::string &)>\nstatic void BM(benchmark::State& state) {\n    Random rng;\n    size_t length = state.range(0);\n    const std::string charset = CHARSET_ALPHANUMERIC;\n    std::string s = rng.random_string(charset, length);\n\n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(s));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, count_upper)->Name(\"Scalar\")->Medium_Args_1D;\nBENCHMARK_TEMPLATE(BM, count_upper_simd)->Name(\"SIMD\")->Medium_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/98", "entrypoint_scalar": "count_upper", "entrypoint_simd": "count_upper_simd"}
{"task_id": "SimdBench_110_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a positive integer n, you have to make a pile of n levels of stones.\nThe first level has n stones.\nThe number of stones in the next level is:\n    - the next odd number if n is odd.\n    - the next even number if n is even.\nReturn the number of stones in each level in a vector, where element at index\ni represents the number of stones in the level (i+1).\n\nExamples:\n>>> make_a_pile_simd(3)\n{3, 5, 7}\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> make_a_pile_simd(int n){\n}", "solution_scalar": "std::vector<int> make_a_pile(int n) {\n    std::vector<int> out(n);\n    out[0] = n;\n    for (int i = 1; i < n; i++) {\n        out[i] = out[i - 1] + 2;\n    }\n    return out;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (allclose(make_a_pile_simd(5), {5, 7, 9, 11, 13}));\n    pass = pass && (allclose(make_a_pile_simd(6), {6, 8, 10, 12, 14, 16}));\n    pass = pass && (allclose(make_a_pile_simd(7), {7, 9, 11, 13, 15, 17, 19}));\n    pass = pass && (allclose(make_a_pile_simd(10), {10, 12, 14, 16, 18, 20, 22, 24, 26, 28}));\n    pass = pass && (allclose(make_a_pile_simd(1), {1}));\n    pass = pass && (allclose(make_a_pile_simd(3), {3, 5, 7}));\n    pass = pass && (allclose(make_a_pile_simd(4), {4, 6, 8, 10}));\n    pass = pass && (allclose(make_a_pile_simd(8), {8, 10, 12, 14, 16, 18, 20, 22}));\n    pass = pass && (allclose(make_a_pile_simd(9), {9, 11, 13, 15, 17, 19, 21, 23, 25}));\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        int n = rng.randint<int>(1, 1024);\n        \n        std::vector<int> result = make_a_pile(n);\n        std::vector<int> result_simd = make_a_pile_simd(n);\n        \n        if(!allclose(result, result_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed for n=\" << n << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool res =correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", res ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::vector<int> (*Func)(int)>\nstatic void BM(benchmark::State& state) {\n    const int n = state.range(0);\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(n));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, make_a_pile)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, make_a_pile_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/100", "entrypoint_scalar": "make_a_pile", "entrypoint_simd": "make_a_pile_simd"}
{"task_id": "SimdBench_111_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nYou are given two positive integers n and m, and your task is to compute the\naverage of the integers from n through m (including n and m). \nRound the answer to the nearest integer(smaller one) and convert that to binary.\nIf n is greater than m, return \"-1\".\nExample:\nrounded_avg_simd(1, 5) => \"11\"\nrounded_avg_simd(7, 5) => \"-1\"\nrounded_avg_simd(10, 20) => \"1111\"\nrounded_avg_simd(20, 33) => \"11010\"\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::string rounded_avg_simd(int64_t n, int64_t m){\n}", "solution_scalar": "std::string rounded_avg(int64_t n, int64_t m){\n    if (n>m) return \"-1\";\n    \n    int64_t sum = 0;\n    for(int64_t i = n; i<=m; ++i) {sum += i;}\n    sum /= m - n + 1;\n\n    std::string out=\"\";\n    while (sum>0){\n        out=std::to_string(sum%2)+out;\n        sum=sum/2;\n    }\n    return out;\n}", "test_correctness": "bool humaneval_check(){\n    bool pass = true;\n    pass = pass && (rounded_avg_simd(1, 5) == \"11\");\n    pass = pass && (rounded_avg_simd(7, 13) == \"1010\");\n    pass = pass && (rounded_avg_simd(964,977) == \"1111001010\");\n    pass = pass && (rounded_avg_simd(996,997) == \"1111100100\");\n    pass = pass && (rounded_avg_simd(560,851) == \"1011000001\");  \n    pass = pass && (rounded_avg_simd(185,546) == \"101101101\");\n    pass = pass && (rounded_avg_simd(362,496) == \"110101101\");\n    pass = pass && (rounded_avg_simd(350,902) == \"1001110010\");\n    pass = pass && (rounded_avg_simd(197,233) == \"11010111\");\n    pass = pass && (rounded_avg_simd(7, 5) == \"-1\");\n    pass = pass && (rounded_avg_simd(5, 1) == \"-1\");\n    pass = pass && (rounded_avg_simd(5, 5) == \"101\");\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        int64_t a = rng.randint<int64_t>(1, 10000);\n        int64_t b = rng.randint<int64_t>(1, 10000);\n              \n        auto res_scalar = rounded_avg(a, b);\n        auto res_simd = rounded_avg_simd(a, b);\n\n        if(!allclose(res_scalar, res_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::string (*Func)(int64_t, int64_t)>\nstatic void BM(benchmark::State& state) {\n    Random rng(DEFAULT_SEED);\n    int64_t a = state.range(0);\n    int64_t b = state.range(0)*2;\n\n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(a, b));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, rounded_avg)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, rounded_avg_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/103", "entrypoint_scalar": "rounded_avg", "entrypoint_simd": "rounded_avg_simd"}
{"task_id": "SimdBench_112_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nImplement the function f that takes n as a parameter,\nand returns a vector of size n, such that the value of the element at index i is the factorial of i modulo 10,000 if i is even\nor the sum of numbers from 1 to i otherwise.\ni starts from 1.\nthe factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\nExample:\nfunc_simd(5) == {1, 2, 6, 24, 15}\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> func_simd(int n){\n}", "solution_scalar": "std::vector<int> func(int n) {\n    // Create a vector of size n\n    std::vector<int> result(n);\n\n    for (int i = 1; i <= n; i++) {\n        if (i % 2 == 0) {\n            // Calculate factorial for even indices\n            int factorial = 1;\n            for (int j = 1; j <= i; j++) {\n                factorial *= j;\n                factorial %= 10000;\n            }\n            result[i - 1] = factorial;\n        } else {\n            // Calculate sum of numbers from 1 to i for odd indices\n            int sum = i * (i + 1) / 2; // Use the formula for sum of first i natural numbers\n            result[i - 1] = sum;\n        }\n    }\n\n    return result;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (allclose(func_simd(5), {1, 2, 6, 24, 15}));\n    pass = pass && (allclose(func_simd(7), {1, 2, 6, 24, 15, 720, 28}));\n    pass = pass && (allclose(func_simd(1), {1}));\n    pass = pass && (allclose(func_simd(3), {1, 2, 6}));\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        int n = Small_Arg_1D;\n        \n        std::vector<int> result = func(n);\n        std::vector<int> result_simd = func_simd(n);\n        \n        if(!allclose(result, result_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed for n=\" << n << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::vector<int> (*Func)(int)>\nstatic void BM(benchmark::State& state) {\n    const int n = state.range(0);\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(n));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, func)->Name(\"Scalar\")->Medium_Args_1D;\nBENCHMARK_TEMPLATE(BM, func_simd)->Name(\"SIMD\")->Medium_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/106", "entrypoint_scalar": "func", "entrypoint_simd": "func_simd"}
{"task_id": "SimdBench_113_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a positive integer n, return a vector that has the number of even and odd\ninteger palindromes that fall within the range(1, n), inclusive.\n\nExample 1:\n\n    Input: 3\n    Output: (1, 2)\n    Explanation:\n    Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\nExample 2:\n\n    Input: 12\n    Output: (4, 6)\n    Explanation:\n    Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\nNote:\n    1. 1 <= n <= 2^10\n    2. returned vector has the number of even and odd integer palindromes respectively.\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> even_odd_palindrome_simd(int n){\n}", "solution_scalar": "std::vector<int> even_odd_palindrome(int n){\n    int num1=0,num2=0;\n    for (int i=1;i<=n;i++)\n    {\n        std::string w=std::to_string(i);\n        std::string p(w.rbegin(),w.rend());\n        if (w==p and i%2==1) num1+=1;\n        if (w==p and i%2==0) num2+=1;\n            \n    }\n    return {num2,num1};\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (allclose(even_odd_palindrome_simd(123), {8, 13}));\n    pass = pass && (allclose(even_odd_palindrome_simd(12), {4, 6}));\n    pass = pass && (allclose(even_odd_palindrome_simd(3), {1, 2}));\n    pass = pass && (allclose(even_odd_palindrome_simd(63), {6, 8}));\n    pass = pass && (allclose(even_odd_palindrome_simd(25), {5, 6}));\n    pass = pass && (allclose(even_odd_palindrome_simd(19), {4, 6}));\n    pass = pass && (allclose(even_odd_palindrome_simd(9), {4, 5}));\n    pass = pass && (allclose(even_odd_palindrome_simd(1), {0, 1}));\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        int n = Small_Arg_1D;\n        \n        std::vector<int> result = even_odd_palindrome(n);\n        std::vector<int> result_simd = even_odd_palindrome_simd(n);\n        \n        if(!allclose(result, result_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed for n=\" << n << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::vector<int> (*Func)(int)>\nstatic void BM(benchmark::State& state) {\n    //const int n = state.range(0);\n    const int n = 1024;\n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(n));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, even_odd_palindrome)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, even_odd_palindrome_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/107", "entrypoint_scalar": "even_odd_palindrome", "entrypoint_simd": "even_odd_palindrome_simd"}
{"task_id": "SimdBench_114_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nWrite a function count_nums which takes a vector of integers and returns\nthe number of elements which has a sum of digits > 0.\nIf a number is negative, then its first signed digit will be negative:\ne.g. -123 has signed digits -1, 2, and 3.\n>>> count_nums_simd({}) == 0\n>>> count_nums_simd({-1, 11, -11}) == 1\n>>> count_nums_simd({1, 1, 2}) == 3\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nint count_nums_simd(std::vector<int> n){\n}", "solution_scalar": "int count_nums(std::vector<int> n){\n    int num=0;\n    for (int i=0;i<n.size();i++)\n        if (n[i]>0) num+=1;\n        else\n        {\n            int sum=0;\n            int w;\n            w=abs(n[i]);\n            while (w>=10)\n            {\n                sum+=w%10;\n                w=w/10;\n            }\n            sum-=w;\n            if (sum>0) num+=1;\n        }\n    return num;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (count_nums_simd({}) == 0);\n    pass = pass && (count_nums_simd({-1, -2, 0}) == 0);\n    pass = pass && (count_nums_simd({1, 1, 2, -2, 3, 4, 5}) == 6);\n    pass = pass && (count_nums_simd({1, 6, 9, -6, 0, 1, 5}) == 5);\n    pass = pass && (count_nums_simd({1, 100, 98, -7, 1, -1}) == 4);\n    pass = pass && (count_nums_simd({12, 23, 34, -45, -56, 0}) == 5);\n    pass = pass && (count_nums_simd({-0, 1}) == 1);\n    pass = pass && (count_nums_simd({1}) == 1);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = rng.randint<size_t>(0, 128);\n        std::vector<int> numbers(length);\n        for(auto & number: numbers){\n            number = rng.randint<int>(-200, 200);\n        }\n        \n        int result = count_nums(numbers);\n        int result_simd = count_nums_simd(numbers);\n        \n        if(result != result_simd){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<int (*Func)(std::vector<int>)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n    std::vector<int> numbers(length);\n    rng.initialize_vector_with_random_values(numbers);\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(numbers));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, count_nums)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, count_nums_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/108", "entrypoint_scalar": "count_nums", "entrypoint_simd": "count_nums_simd"}
{"task_id": "SimdBench_115_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nWe have a vector \"arr\" of N integers arr[1], arr[2], ..., arr[N].The\nnumbers in the vector will be randomly ordered. Your task is to determine if\nit is possible to get a vector sorted in non-decreasing order by performing \nthe following operation on the given vector:\n    You are allowed to perform right shift operation any number of times.\n\nOne right shift operation means shifting all elements of the vector by one\nposition in the right direction. The last element of the vector will be moved to\nthe starting position in the vector i.e. 0th index. \n\nIf it is possible to obtain the sorted vector by performing the above operation\nthen return true else return false.\nIf the given vector is empty then return true.\n\nNote: The given vector is guaranteed to have unique elements.\n\nFor Example:\n\nmove_one_ball_simd({3, 4, 5, 1, 2})==>true\nExplanation: By performing 2 right shift operations, non-decreasing order can\n             be achieved for the given vector.\nmove_one_ball_simd({3, 5, 4, 1, 2})==>false\nExplanation:It is not possible to get non-decreasing order for the given\n            vector by performing any number of right shift operations.\n            \n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nbool move_one_ball_simd(std::vector<int> arr){\n}", "solution_scalar": "bool move_one_ball(std::vector<int> arr){\n    int num=0;\n    if (arr.size()==0) return true;\n    for (int i=1;i<arr.size();i++)\n        if (arr[i]<arr[i-1]) num+=1;\n    if (arr[arr.size()-1]>arr[0]) num+=1;\n    if (num<2) return true;\n    return false;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (move_one_ball_simd({3, 4, 5, 1, 2}) == true);\n    pass = pass && (move_one_ball_simd({3, 5, 10, 1, 2}) == true);\n    pass = pass && (move_one_ball_simd({4, 3, 1, 2}) == false);\n    pass = pass && (move_one_ball_simd({3, 5, 4, 1, 2}) == false);\n    pass = pass && (move_one_ball_simd({}) == true);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = rng.randint<size_t>(0, 128);\n        std::vector<int> arr(length);\n        rng.initialize_vector_with_random_values(arr);\n        \n        bool result = move_one_ball(arr);\n        bool result_simd = move_one_ball_simd(arr);\n        \n        if(result != result_simd){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<bool (*Func)(std::vector<int>)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<int> arr(length);\n    rng.initialize_vector_with_random_values(arr);\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(arr));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, move_one_ball)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, move_one_ball_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/109", "entrypoint_scalar": "move_one_ball", "entrypoint_simd": "move_one_ball_simd"}
{"task_id": "SimdBench_116_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nIn this problem, you will implement a function that takes two vectors of numbers,\nand determines whether it is possible to perform an exchange of elements\nbetween them to make lst1 a vector of only even numbers.\nThere is no limit on the number of exchanged elements between lst1 and lst2.\nIf it is possible to exchange elements between the lst1 and lst2 to make\nall the elements of lst1 to be even, return \"YES\".\nOtherwise, return \"NO\".\nFor example:\nexchange_simd({1, 2, 3, 4}, {1, 2, 3, 4}) => \"YES\"\nexchange_simd({1, 2, 3, 4}, {1, 5, 3, 4}) => \"NO\"\nIt is assumed that the input vectors will be non-empty.\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2){\n}", "solution_scalar": "std::string myexchange(const std::vector<int>& lst1, const std::vector<int>& lst2){\n    int num=0;\n    for (int i=0;i<lst1.size();i++)\n    if (lst1[i]%2==0) num+=1;\n    for (int i=0;i<lst2.size();i++)\n    if (lst2[i]%2==0) num+=1;\n    if (num>=lst1.size()) return \"YES\";\n    return \"NO\";\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (myexchange_simd({1, 2, 3, 4}, {1, 2, 3, 4}) == \"YES\");\n    pass = pass && (myexchange_simd({1, 2, 3, 4}, {1, 5, 3, 4}) == \"NO\");\n    pass = pass && (myexchange_simd({1, 2, 3, 4}, {2, 1, 4, 3}) == \"YES\");\n    pass = pass && (myexchange_simd({5, 7, 3}, {2, 6, 4}) == \"YES\");\n    pass = pass && (myexchange_simd({5, 7, 3}, {2, 6, 3}) == \"NO\");\n    pass = pass && (myexchange_simd({3, 2, 6, 1, 8, 9}, {3, 5, 5, 1, 1, 1}) == \"NO\");\n    pass = pass && (myexchange_simd({100, 200}, {200, 200}) == \"YES\");\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        std::vector<int> lst1(rng.randint<size_t>(1, 100));\n        std::vector<int> lst2(rng.randint<size_t>(1, 100));\n        rng.initialize_vector_with_random_values(lst1);\n        rng.initialize_vector_with_random_values(lst2);\n        \n        std::string result = myexchange(lst1, lst2);\n        std::string result_simd = myexchange_simd(lst1, lst2);\n        \n        if(result != result_simd){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::string (*Func)(const std::vector<int>&, const std::vector<int>&)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<int> lst1(length);\n    std::vector<int> lst2(length);\n    rng.initialize_vector_with_random_values(lst1);\n    rng.initialize_vector_with_random_values(lst2);\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(lst1, lst2));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, myexchange)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, myexchange_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/110", "entrypoint_scalar": "myexchange", "entrypoint_simd": "myexchange_simd"}
{"task_id": "SimdBench_117_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a vector of strings, where each string consists of only digits, return a vector.\nEach element i of the output should be 'the number of odd elements in the\nstring i of the input.\" where all the i's should be replaced by the number\nof odd digits in the i'th string of the input.\n\n>>> odd_count_simd({\"1234567\"})\n{'the number of odd elements 4n the str4ng 4 of the 4nput.\"}\n>>> odd_count_simd({\"3\",\"11111111\"})\n{'the number of odd elements 1n the str1ng 1 of the 1nput.\",\n 'the number of odd elements 8n the str8ng 8 of the 8nput.\"}\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst){\n}", "solution_scalar": "std::vector<std::string> odd_count(const std::vector<std::string> & lst) {\n    // Pre-allocate the output vector with the same size as the input\n    std::vector<std::string> out(lst.size());\n    \n    for (int i = 0; i < lst.size(); i++) {\n        int sum = 0;\n\n        // Count the number of odd digits in the current string\n        for (int j = 0; j < lst[i].length(); j++) {\n            if (lst[i][j] >= '0' && lst[i][j] <= '9' && (lst[i][j] - '0') % 2 == 1) {\n                sum += 1;\n            }\n        }\n\n        // Construct the output string with the number of odd digits\n        std::string s = \"the number of odd elements in the string i of the input.\";\n        std::string s2 = \"\";\n        for (int j = 0; j < s.length(); j++) {\n            if (s[j] == 'i') {\n                s2 += std::to_string(sum);\n            } else {\n                s2 += s[j];\n            }\n        }\n\n        // Assign the result to the pre-allocated output vector\n        out[i] = s2;\n    }\n\n    return out;\n}", "test_correctness": "bool humaneval_check(){\n    bool pass = true;\n    pass = pass && (allclose(odd_count({\"1234567\"}) , {\"the number of odd elements 4n the str4ng 4 of the 4nput.\"}));\n    pass = pass && (allclose(odd_count({\"3\",\"11111111\"}) , {\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"}));\n    pass = pass && (allclose(odd_count({\"271\", \"137\", \"314\"}) , {\n        \"the number of odd elements 2n the str2ng 2 of the 2nput.\",\n        \"the number of odd elements 3n the str3ng 3 of the 3nput.\",\n        \"the number of odd elements 2n the str2ng 2 of the 2nput.\"\n    }));\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        const std::string charset = CHARSET_DIGITS;\n\n        std::vector<std::string> lst;\n        for(int i=0; i<length; ++i){\n            std::string s = rng.random_string(charset, rng.randint<int>(0, 20));\n            lst.push_back(s);\n        }\n              \n        auto res_scalar = odd_count(lst);\n        auto res_simd = odd_count_simd(lst);\n\n        if(!allclose(res_scalar, res_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::vector<std::string> (*Func)(const std::vector<std::string> &)>\nstatic void BM(benchmark::State& state) {\n    Random rng(DEFAULT_SEED);\n    size_t length = state.range(0);\n    const std::string charset = CHARSET_DIGITS;\n\n    std::vector<std::string> lst;\n    for(int i=0; i<length; ++i){\n        std::string s = rng.random_string(charset, rng.randint<int>(0, 20));\n        lst.push_back(s);\n    }\n\n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(lst));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, odd_count)->Name(\"Scalar\")->Medium_Args_1D;\nBENCHMARK_TEMPLATE(BM, odd_count_simd)->Name(\"SIMD\")->Medium_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/113", "entrypoint_scalar": "odd_count", "entrypoint_simd": "odd_count_simd"}
{"task_id": "SimdBench_118_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a vector of integers nums, find the minimum sum of any non-empty sub-vector\nof nums.\nExample\nminSubArraySum_simd({2, 3, 4, 1, 2, 4}) == 1\nminSubArraySum_simd({-1, -2, -3}) == -6\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums){\n}", "solution_scalar": "int64_t minSubArraySum(const std::vector<int64_t>& nums){\n    int64_t current, min;\n    current=nums[0];\n    min=nums[0];\n    for (int i=1;i<nums.size();i++)\n    {\n       if (current<0) current=current+nums[i];\n       else current=nums[i];\n       if (current<min) min=current;\n    }\n    return min;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (minSubArraySum_simd({2, 3, 4, 1, 2, 4}) == 1);\n    pass = pass && (minSubArraySum_simd({-1, -2, -3}) == -6);\n    pass = pass && (minSubArraySum_simd({-1, -2, -3, 2, -10}) == -14);\n    pass = pass && (minSubArraySum_simd({-9999999999999999}) == -9999999999999999);\n    pass = pass && (minSubArraySum_simd({0, 10, 20, 1000000}) == 0);\n    pass = pass && (minSubArraySum_simd({-1, -2, -3, 10, -5}) == -6);\n    pass = pass && (minSubArraySum_simd({100, -1, -2, -3, 10, -5}) == -6);\n    pass = pass && (minSubArraySum_simd({10, 11, 13, 8, 3, 4}) == 3);\n    pass = pass && (minSubArraySum_simd({100, -33, 32, -1, 0, -2}) == -33);\n    pass = pass && (minSubArraySum_simd({-10}) == -10);\n    pass = pass && (minSubArraySum_simd({7}) == 7);\n    pass = pass && (minSubArraySum_simd({1, -1}) == -1);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<int64_t> nums(length);\n        for(auto& number: nums){\n            number = rng.randint<int64_t>(-1024, 1024);\n        }\n        \n        int64_t result = minSubArraySum(nums);\n        int64_t result_simd = minSubArraySum_simd(nums);\n        \n        if(result != result_simd){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<int64_t (*Func)(const std::vector<int64_t>&)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<int64_t> nums(length);\n    for(auto& number: nums){\n        number = rng.randint<int64_t>(-1024, 1024);\n    }\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(nums));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, minSubArraySum)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, minSubArraySum_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/114", "entrypoint_scalar": "minSubArraySum", "entrypoint_simd": "minSubArraySum_simd"}
{"task_id": "SimdBench_119_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nYou are given a rectangular grid of wells. Each row represents a single well,\nand each 1 in a row represents a single unit of water.\nEach well has a corresponding bucket that can be used to extract water from it, \nand all buckets have the same capacity.\nYour task is to use the buckets to empty the wells.\nOutput the number of times you need to lower the buckets.\n\nExample 1:\n    Input: \n        grid : {{0,0,1,0}, {0,1,0,0}, {1,1,1,1}}\n        bucket_capacity : 1\n    Output: 6\n\nExample 2:\n    Input: \n        grid : {{0,0,1,1}, {0,0,0,0}, {1,1,1,1}, {0,1,1,1}}\n        bucket_capacity : 2\n    Output: 5\n\nExample 3:\n    Input: \n        grid : {{0,0,0}, {0,0,0}}\n        bucket_capacity : 5\n    Output: 0\n\nConstraints:\n    * all wells have the same length\n    * 1 <= grid.length <= 10^5\n    * 1 <= grid{:,1}.length <= 10^5\n    * grid{i}{j} -> 0 | 1\n    * 1 <= capacity <= 10\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nint max_fill_simd(const std::vector<std::vector<int> > & grid,int capacity){\n}", "solution_scalar": "int max_fill(const std::vector<std::vector<int> > & grid,int capacity){\n    int out=0;\n    for (int i=0;i<grid.size();i++)\n    {\n        int sum=0;\n        for (int j=0;j<grid[i].size();j++)\n            sum+=grid[i][j];\n        if (sum>0)  out+=(sum-1)/capacity+1;\n    }\n    return out;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (max_fill_simd({{0,0,1,0}, {0,1,0,0}, {1,1,1,1}}, 1) == 6);\n    pass = pass && (max_fill_simd({{0,0,1,1}, {0,0,0,0}, {1,1,1,1}, {0,1,1,1}}, 2) == 5);\n    pass = pass && (max_fill_simd({{0,0,0}, {0,0,0}}, 5) == 0);\n    pass = pass && (max_fill_simd({{1,1,1,1}, {1,1,1,1}}, 2) == 4);\n    pass = pass && (max_fill_simd({{1,1,1,1}, {1,1,1,1}}, 9) == 2);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t rows = Small_Arg_2D;\n        size_t cols = Small_Arg_2D;\n        int capacity = rng.randint<int>(1, 10);\n        \n        std::vector<std::vector<int>> grid(rows, std::vector<int>(cols));\n        for (auto& row : grid) {\n            rng.initialize_vector_with_random_values(row, true);\n        }\n        \n        int result = max_fill(grid, capacity);\n        int result_simd = max_fill_simd(grid, capacity);\n        \n        if(result != result_simd){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<int (*Func)(const std::vector<std::vector<int> > &, int)>\nstatic void BM(benchmark::State& state) {\n    const size_t rows = state.range(0);\n    const size_t cols = state.range(1);\n    Random rng;\n    const int capacity = rng.randint<int>(1, 10);\n    std::vector<std::vector<int>> grid(rows, std::vector<int>(cols));\n    for (auto& row : grid) {\n        rng.initialize_vector_with_random_values(row, true);\n    }\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(grid, capacity));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, max_fill)->Name(\"Scalar\")->Large_Args_2D;\nBENCHMARK_TEMPLATE(BM, max_fill_simd)->Name(\"SIMD\")->Large_Args_2D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/115", "entrypoint_scalar": "max_fill", "entrypoint_simd": "max_fill_simd"}
{"task_id": "SimdBench_120_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a non-empty vector of 16-bit integers, return the sum of all of the odd elements that are in even positions.\nExamples\nsolution_simd({5, 8, 7, 1}) ==> 12\nsolution_simd({3, 3, 3, 3, 3}) ==> 9\nsolution_simd({30, 13, 24, 321}) ==>0\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nint64_t solution_simd(const std::vector<int16_t>& lst){\n}", "solution_scalar": "int64_t solution(const std::vector<int16_t>& lst){\n    int64_t sum=0;\n    for (int i=0;i*2<lst.size();i++)\n        if (lst[i*2]%2==1) sum+=lst[i*2];\n    return sum;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (solution_simd({5, 8, 7, 1}) == 12);\n    pass = pass && (solution_simd({3, 3, 3, 3, 3}) == 9);\n    pass = pass && (solution_simd({30, 13, 24, 321}) == 0);\n    pass = pass && (solution_simd({5, 9}) == 5);\n    pass = pass && (solution_simd({2, 4, 8}) == 0);\n    pass = pass && (solution_simd({30, 13, 23, 32}) == 23);\n    pass = pass && (solution_simd({3, 13, 2, 9}) == 3);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        std::vector<int16_t> lst(length);\n        rng.initialize_vector_with_random_values(lst);\n        \n        int result = solution(lst);\n        int result_simd = solution_simd(lst);\n        \n        if(result != result_simd){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<int64_t (*Func)(const std::vector<int16_t>&)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<int16_t> lst(length);\n    rng.initialize_vector_with_random_values(lst);\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(lst));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, solution)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, solution_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/121", "entrypoint_scalar": "solution", "entrypoint_simd": "solution_simd"}
{"task_id": "SimdBench_121_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a non-empty vector of integers arr and an integer k, return\nthe sum of the elements with at most two digits from the first k elements of arr.\n\nExample:\n    Input: arr = {111,21,3,4000,5,6,7,8,9}, k = 4\n    Output: 24 # sum of 21 + 3\n\nConstraints:\n    1. 1 <= len(arr) <= 2^24\n    2. 1 <= k <= len(arr)\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nint add_elements_simd(std::vector<int> arr, int k){\n}", "solution_scalar": "int add_elements(std::vector<int> arr, int k){\n    int sum=0;\n    for (int i=0;i<k;i++)\n        if( arr[i]>=-99 and arr[i]<=99)\n            sum+=arr[i];\n    return sum;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (add_elements_simd({1,-2,-3,41,57,76,87,88,99}, 3) == -4);\n    pass = pass && (add_elements_simd({111,121,3,4000,5,6}, 2) == 0);\n    pass = pass && (add_elements_simd({11,21,3,90,5,6,7,8,9}, 4) == 125);\n    pass = pass && (add_elements_simd({111,21,3,4000,5,6,7,8,9}, 4) == 24);\n    pass = pass && (add_elements_simd({1}, 1) == 1);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = Small_Arg_1D;\n        int k = rng.randint<int>(1, length);\n        std::vector<int> arr(length);\n        for(auto & num: arr){\n            num = rng.randint(-500, 500);\n        }\n        \n        int result = add_elements(arr, k);\n        int result_simd = add_elements_simd(arr, k);\n        \n        if(result != result_simd){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<int (*Func)(std::vector<int>, int)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    const int k = length/2;\n    Random rng;\n    std::vector<int> arr(length);\n    rng.initialize_vector_with_random_values(arr);\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(arr, k));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, add_elements)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, add_elements_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/122", "entrypoint_scalar": "add_elements", "entrypoint_simd": "add_elements_simd"}
{"task_id": "SimdBench_122_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a vector of numbers, return whether or not they are sorted\nin ascending order. If vector has more than 1 duplicate of the same\nnumber, return false. Assume no negative numbers and only integers.\n\nExamples\nis_sorted_simd({5}) \u279e true\nis_sorted_simd({1, 2, 3, 4, 5}) \u279e true\nis_sorted_simd({1, 3, 2, 4, 5}) \u279e false\nis_sorted_simd({1, 2, 3, 4, 5, 6}) \u279e true\nis_sorted_simd({1, 2, 3, 4, 5, 6, 7}) \u279e true\nis_sorted_simd({1, 3, 2, 4, 5, 6, 7}) \u279e false\nis_sorted_simd({1, 2, 2, 3, 3, 4}) \u279e true\nis_sorted_simd({1, 2, 2, 2, 3, 4}) \u279e false\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nbool is_sorted_simd(const std::vector<int> & lst){\n}", "solution_scalar": "bool is_sorted(const std::vector<int> & lst){\n    for (int i=1;i<lst.size();i++)\n    {\n        if (lst[i]<lst[i-1]) return false;\n        if (i>=2 and lst[i]==lst[i-1] and lst[i]==lst[i-2]) return false;\n    }\n    return true;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (is_sorted_simd({5}) == true);\n    pass = pass && (is_sorted_simd({1, 2, 3, 4, 5}) == true);\n    pass = pass && (is_sorted_simd({1, 3, 2, 4, 5}) == false);\n    pass = pass && (is_sorted_simd({1, 2, 3, 4, 5, 6}) == true);\n    pass = pass && (is_sorted_simd({1, 2, 3, 4, 5, 6, 7}) == true);\n    pass = pass && (is_sorted_simd({1, 3, 2, 4, 5, 6, 7}) == false);\n    pass = pass && (is_sorted_simd({}) == true);\n    pass = pass && (is_sorted_simd({1}) == true);\n    pass = pass && (is_sorted_simd({3, 2, 1}) == false);\n    pass = pass && (is_sorted_simd({1, 2, 2, 2, 3, 4}) == false);\n    pass = pass && (is_sorted_simd({1, 2, 3, 3, 3, 4}) == false);\n    pass = pass && (is_sorted_simd({1, 2, 2, 3, 3, 4}) == true);\n    pass = pass && (is_sorted_simd({1, 2, 3, 4}) == true);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = rng.randint(size_t(0), size_t(1024));\n        std::vector<int> lst(length);\n        if(rng.randint<int>() % 2) {\n\n            for(size_t j = 0; j < length; j++) {\n                lst[j] = static_cast<int>(j);\n            }\n\n            if(rng.randint<int>() % 2) {\n                for(size_t j = 1; j < length; j++) {\n                    if(rng.randint<int>() % 3 == 0) { \n                        lst[j] = lst[j-1];\n                    }\n                }\n            }\n        } else {\n            rng.initialize_vector_with_random_values(lst);\n        }\n        \n        bool result = is_sorted(lst);\n        bool result_simd = is_sorted_simd(lst);\n        \n        if(result != result_simd){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<bool (*Func)(const std::vector<int> &)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng(DEFAULT_SEED);\n    std::vector<int> lst(length);\n    for(size_t i = 0; i < length; i++) {\n        lst[i] = static_cast<int>(i);\n    }\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(lst));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, is_sorted)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, is_sorted_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/126", "entrypoint_scalar": "is_sorted", "entrypoint_simd": "is_sorted_simd"}
{"task_id": "SimdBench_123_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nYou are given a vector arr of integers and you need to return\nsum of magnitudes of integers multiplied by product of all signs\nof each number in the vector, represented by 1, -1 or 0.\nNote: return -32768 for empty arr.\n\nExample:\n>>> prod_signs_simd({1, 2, 2, -4}) == -9\n>>> prod_signs_simd({0, 1}) == 0\n>>> prod_signs_simd({}) == -32768\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nint prod_signs_simd(const std::vector<int> & arr){\n}", "solution_scalar": "int prod_signs(const std::vector<int> & arr){\n    if (arr.size()==0) return -32768;\n    int i,sum=0,prods=1;\n    for (i=0;i<arr.size();i++){\n        sum+=abs(arr[i]);\n        if (arr[i]==0) prods=0;\n        if (arr[i]<0) prods=-prods;\n    }\n   return sum*prods;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (prod_signs_simd({1, 2, 2, -4}) == -9);\n    pass = pass && (prod_signs_simd({0, 1}) == 0);\n    pass = pass && (prod_signs_simd({1, 1, 1, 2, 3, -1, 1}) == -10);\n    pass = pass && (prod_signs_simd({}) == -32768);\n    pass = pass && (prod_signs_simd({2, 4, 1, 2, -1, -1, 9}) == 20);\n    pass = pass && (prod_signs_simd({-1, 1, -1, 1}) == 4);\n    pass = pass && (prod_signs_simd({-1, 1, 1, 1}) == -4);\n    pass = pass && (prod_signs_simd({-1, 1, 1, 0}) == 0);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = rng.randint<size_t>(0, 128);\n        std::vector<int> arr(length);\n        rng.initialize_vector_with_random_values(arr);\n        \n        int result = prod_signs(arr);\n        int result_simd = prod_signs_simd(arr);\n        \n        if(result != result_simd){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<int (*Func)(const std::vector<int> &)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<int> arr(length);\n    std::vector<int> choiceset = {-2, -1, 0, 1, 2};\n    for(auto& num: arr){\n        num = rng.choice(choiceset);\n    }\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(arr));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, prod_signs)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, prod_signs_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/128", "entrypoint_scalar": "prod_signs", "entrypoint_simd": "prod_signs_simd"}
{"task_id": "SimdBench_124_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a grid with N rows and N columns (N >= 2) and a positive integer k, \neach cell of the grid contains a value. Every integer in the range [1, N * N]\ninclusive appears exactly once on the cells of the grid.\n\nYou have to find the minimum path of length k in the grid. You can start\nfrom any cell, and in each step you can move to any of the neighbor cells,\nin other words, you can go to cells which share an edge with you current\ncell.\nPlease note that a path of length k means visiting exactly k cells (not\nnecessarily distinct).\nYou CANNOT go off the grid.\nA path A (of length k) is considered less than a path B (of length k) if\nafter making the ordered vectors of the values on the cells that A and B go\nthrough (let's call them lst_A and lst_B), lst_A is lexicographically less\nthan lst_B, in other words, there exist an integer index i (1 <= i <= k)\nsuch that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\nlst_A[j] = lst_B[j].\nIt is guaranteed that the answer is unique.\nReturn an ordered vector of the values on the cells that the minimum path go through.\n\nExamples:\n\n    Input: grid = { {1,2,3}, {4,5,6}, {7,8,9}}, k = 3\n    Output: {1, 2, 1}\n\n    Input: grid = { {5,9,3}, {4,1,6}, {7,8,2}}, k = 1\n    Output: {1}\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k){\n}", "solution_scalar": "std::vector<int> minPath(const std::vector<std::vector<int> > & grid, int k) {\n    int n = grid.size();\n    int x, y, minValue;\n\n    // Find the position of the cell with value 1\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] == 1) {\n                x = i;\n                y = j;\n            }\n        }\n    }\n\n    // Find the smallest neighbor of the cell containing 1\n    minValue = INT_MAX;\n\n    if (x > 0 && grid[x - 1][y] < minValue) {\n        minValue = grid[x - 1][y];\n    }\n    if (x < n - 1 && grid[x + 1][y] < minValue) {\n        minValue = grid[x + 1][y];\n    }\n    if (y > 0 && grid[x][y - 1] < minValue) {\n        minValue = grid[x][y - 1];\n    }\n    if (y < n - 1 && grid[x][y + 1] < minValue) {\n        minValue = grid[x][y + 1];\n    }\n\n    // Pre-allocate the output vector and directly assign values\n    std::vector<int> out(k);\n    for (int i = 0; i < k; i++) {\n        if (i % 2 == 0) {\n            out[i] = 1;\n        } else {\n            out[i] = minValue;\n        }\n    }\n\n    return out;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && allclose(minPath_simd({{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, 3), {1, 2, 1});\n    pass = pass && allclose(minPath_simd({{5, 9, 3}, {4, 1, 6}, {7, 8, 2}}, 1), {1});\n    pass = pass && allclose(minPath_simd({{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}}, 4), {1, 2, 1, 2});\n    pass = pass && allclose(minPath_simd({{6, 4, 13, 10}, {5, 7, 12, 1}, {3, 16, 11, 15}, {8, 14, 9, 2}}, 7), {1, 10, 1, 10, 1, 10, 1});\n    pass = pass && allclose(minPath_simd({{8, 14, 9, 2}, {6, 4, 13, 15}, {5, 7, 1, 12}, {3, 10, 11, 16}}, 5), {1, 7, 1, 7, 1});\n    pass = pass && allclose(minPath_simd({{11, 8, 7, 2}, {5, 16, 14, 4}, {9, 3, 15, 6}, {12, 13, 10, 1}}, 9), {1, 6, 1, 6, 1, 6, 1, 6, 1});\n    pass = pass && allclose(minPath_simd({{12, 13, 10, 1}, {9, 3, 15, 6}, {5, 16, 14, 4}, {11, 8, 7, 2}}, 12), {1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6});\n    pass = pass && allclose(minPath_simd({{2, 7, 4}, {3, 1, 5}, {6, 8, 9}}, 8), {1, 3, 1, 3, 1, 3, 1, 3});\n    pass = pass && allclose(minPath_simd({{6, 1, 5}, {3, 8, 9}, {2, 7, 4}}, 8), {1, 5, 1, 5, 1, 5, 1, 5});\n    pass = pass && allclose(minPath_simd({{1, 2}, {3, 4}}, 10), {1, 2, 1, 2, 1, 2, 1, 2, 1, 2});\n    pass = pass && allclose(minPath_simd({{1, 3}, {3, 2}}, 10), {1, 3, 1, 3, 1, 3, 1, 3, 1, 3});\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t n = rng.randint<size_t>(2, 16);\n        int k = rng.randint<int>(1, 16);\n        \n        std::vector<int> permutation(n * n);\n        for (int i = 0; i < n * n; ++i) {\n            permutation[i] = i + 1;\n        }\n        rng.shuffle(permutation);\n        std::vector<std::vector<int>> grid(n, std::vector<int>(n));\n        for (size_t idx = 0; idx < permutation.size(); ++idx) {\n            size_t row = idx / n;\n            size_t col = idx % n;\n            grid[row][col] = permutation[idx];\n        }\n        \n        auto result = minPath(grid, k);\n        auto result_simd = minPath_simd(grid, k);\n        \n        if (!allclose(result, result_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::vector<int> (*Func)(const std::vector<std::vector<int>> &, int)>\nstatic void BM_grid(benchmark::State& state) {\n    Random rng(DEFAULT_SEED);\n    const size_t n = sqrt(state.range(0)); \n    const int k = 32;\n\n    std::vector<int> permutation(n * n);\n    for (int i = 0; i < n * n; ++i) {\n        permutation[i] = i + 1;\n    }\n    rng.shuffle(permutation);\n    std::vector<std::vector<int>> grid(n, std::vector<int>(n));\n    for (size_t idx = 0; idx < permutation.size(); ++idx) {\n        size_t row = idx / n;\n        size_t col = idx % n;\n        grid[row][col] = permutation[idx];\n    }\n\n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(grid, k));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM_grid, minPath)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_grid, minPath_simd)->Name(\"SIMD\")->Large_Args_1D;\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/129", "entrypoint_scalar": "minPath", "entrypoint_simd": "minPath_simd"}
{"task_id": "SimdBench_125_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a positive integer n, return the product of the odd digits.\nReturn 0 if all digits are even.\nFor example:\ndigits_simd(1)  == 1\ndigits_simd(4)  == 0\ndigits_simd(235) == 15\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nuint64_t digits_simd(uint64_t n){\n}", "solution_scalar": "uint64_t digits(uint64_t n){\n    uint64_t prod=1,has=0;\n    std::string s=std::to_string(n);\n    for (int i=0;i<s.length();i++)\n        if (s[i]%2==1) \n        {\n            has=1;\n            prod=prod*(s[i]-48);\n        }\n    if (has==0) return 0;\n    return prod;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (digits_simd(5) == 5);\n    pass = pass && (digits_simd(54) == 5);\n    pass = pass && (digits_simd(120) ==1);\n    pass = pass && (digits_simd(5014) == 5);\n    pass = pass && (digits_simd(98765) == 315);\n    pass = pass && (digits_simd(5576543) == 2625);\n    pass = pass && (digits_simd(2468) == 0);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n\n        uint64_t n = rng.randint<uint64_t>(1);\n        auto result = digits(n);\n        auto result_simd = digits_simd(n);\n        \n        if (!allclose(result, result_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<uint64_t (*Func)(uint64_t)>\nstatic void BM_grid(benchmark::State& state) {\n    Random rng(DEFAULT_SEED);\n    uint64_t n = rng.randint<uint64_t>(1);\n\n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(n));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM_grid, digits)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_grid, digits_simd)->Name(\"SIMD\")->Large_Args_1D;\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/131", "entrypoint_scalar": "digits", "entrypoint_simd": "digits_simd"}
{"task_id": "SimdBench_126_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nYou are given a vector of numbers.\nYou need to return the sum of squared numbers in the given vector,\nround each element in the vector to the upper int (ceiling) first.\nExamples:\nFor lst = {1,2,3} the output should be 14\nFor lst = {1,4,9} the output should be 98\nFor lst = {1,3,5,7} the output should be 84\nFor lst = {1.4,4.2,0} the output should be 29\nFor lst = {-2.4,1,1} the output should be 6\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n}", "solution_scalar": "uint64_t sum_squares(const std::vector<float> & lst){\n    uint64_t sum=0;\n    for (int i=0;i<lst.size();i++)\n        sum+=ceil(lst[i])*ceil(lst[i]);\n    return sum;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && fabs(sum_squares_simd({1,2,3}) - 14) < 1e-6;\n    pass = pass && fabs(sum_squares_simd({1.0,2,3}) - 14) < 1e-6;\n    pass = pass && fabs(sum_squares_simd({1,3,5,7}) - 84) < 1e-6;\n    pass = pass && fabs(sum_squares_simd({1.4,4.2,0}) - 29) < 1e-6;\n    pass = pass && fabs(sum_squares_simd({-2.4,1,1}) - 6) < 1e-6;\n    pass = pass && fabs(sum_squares_simd({100,1,15,2}) - 10230) < 1e-6;\n    pass = pass && fabs(sum_squares_simd({10000,10000}) - 200000000) < 1e-6;\n    pass = pass && fabs(sum_squares_simd({-1.4,4.6,6.3}) - 75) < 1e-6;\n    pass = pass && fabs(sum_squares_simd({-1.4,17.9,18.9,19.9}) - 1086) < 1e-6;\n    pass = pass && fabs(sum_squares_simd({0}) - 0) < 1e-6;\n    pass = pass && fabs(sum_squares_simd({-1}) - 1) < 1e-6;\n    pass = pass && fabs(sum_squares_simd({-1,1,0}) - 2) < 1e-6;\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = rng.randint<size_t>(0, 128);\n        std::vector<float> lst(length);\n        rng.initialize_vector_with_random_values(lst);\n        \n        float result = sum_squares(lst);\n        float result_simd = sum_squares_simd(lst);\n        \n        if(fabs(result - result_simd) > 1e-6){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<uint64_t (*Func)(const std::vector<float> &)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<float> lst(length);\n    rng.initialize_vector_with_random_values(lst);\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(lst));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, sum_squares)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, sum_squares_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/133", "entrypoint_scalar": "sum_squares", "entrypoint_simd": "sum_squares_simd"}
{"task_id": "SimdBench_127_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nCreate a function which returns the largest index of an element which\nis not greater than or equal to the element immediately preceding it. If\nno such element exists then return -1. The given vector will not contain\nduplicate values.\n\nExamples:\ncan_arrange_simd({1,2,4,3,5}) = 3\ncan_arrange_simd({1,2,3}) = -1\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nint can_arrange_simd(const std::vector<int> & arr){\n}", "solution_scalar": "int can_arrange(const std::vector<int> & arr){\n    int max=-1;\n    for (int i=0;i<arr.size();i++)\n    if (arr[i]<=i) max=i;\n    return max;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (can_arrange_simd({1,2,4,3,5}) == 3);\n    pass = pass && (can_arrange_simd({1,2,4,5}) == -1);\n    pass = pass && (can_arrange_simd({1,4,2,5,6,7,8,9,10}) == 2);\n    pass = pass && (can_arrange_simd({4,8,5,7,3}) == 4);\n    pass = pass && (can_arrange_simd({}) == -1);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = rng.randint<size_t>(0, 128);\n        std::vector<int> arr(length);\n        rng.initialize_vector_with_random_values(arr);\n        \n        int result = can_arrange(arr);\n        int result_simd = can_arrange_simd(arr);\n        \n        if(result != result_simd){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<int (*Func)(const std::vector<int> & )>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<int> arr(length);\n    rng.initialize_vector_with_random_values(arr);\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(arr));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, can_arrange)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, can_arrange_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/135", "entrypoint_scalar": "can_arrange", "entrypoint_simd": "can_arrange_simd"}
{"task_id": "SimdBench_128_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nCreate a function that returns a vector (a, b), where \"a\" is\nthe largest of negative integers, and \"b\" is the smallest\nof positive integers in a vector.\nIf there is no negative or positive integers, return them as 0.\n\nExamples:\nlargest_smallest_integers_simd({2, 4, 1, 3, 5, 7}) == {0, 1}\nlargest_smallest_integers_simd({}) == {0,0}\nlargest_smallest_integers_simd({0}) == {0,0}\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst){\n}", "solution_scalar": "std::vector<int> largest_smallest_integers(const std::vector<int>& lst){\n    int maxneg=0,minpos=0;\n    for (int i=0;i<lst.size();i++)\n    {\n        if (lst[i]<0 and (maxneg==0 or lst[i]>maxneg)) maxneg=lst[i];\n        if (lst[i]>0 and (minpos==0 or lst[i]<minpos)) minpos=lst[i];\n    }\n    return {maxneg,minpos};\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && allclose(largest_smallest_integers_simd({2, 4, 1, 3, 5, 7}), {0, 1});\n    pass = pass && allclose(largest_smallest_integers_simd({2, 4, 1, 3, 5, 7, 0}), {0, 1});\n    pass = pass && allclose(largest_smallest_integers_simd({1, 3, 2, 4, 5, 6, -2}), {-2, 1});\n    pass = pass && allclose(largest_smallest_integers_simd({4, 5, 3, 6, 2, 7, -7}), {-7, 2});\n    pass = pass && allclose(largest_smallest_integers_simd({7, 3, 8, 4, 9, 2, 5, -9}), {-9, 2});\n    pass = pass && allclose(largest_smallest_integers_simd({}), {0, 0});\n    pass = pass && allclose(largest_smallest_integers_simd({0}), {0, 0});\n    pass = pass && allclose(largest_smallest_integers_simd({-1, -3, -5, -6}), {-1, 0});\n    pass = pass && allclose(largest_smallest_integers_simd({-1, -3, -5, -6, 0}), {-1, 0});\n    pass = pass && allclose(largest_smallest_integers_simd({-6, -4, -4, -3, 1}), {-3, 1});\n    pass = pass && allclose(largest_smallest_integers_simd({-6, -4, -4, -3, -100, 1}), {-3, 1});\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = rng.randint<size_t>(0, 128);\n        std::vector<int> lst(length);\n        rng.initialize_vector_with_random_values(lst);\n        \n        auto result = largest_smallest_integers(lst);\n        auto result_simd = largest_smallest_integers_simd(lst);\n        \n        if(!allclose(result, result_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::vector<int> (*Func)(const std::vector<int>&)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<int> lst(length);\n    rng.initialize_vector_with_random_values(lst);\n    \n    // Ensure we have both positive and negative numbers\n    if (length > 1) {\n        lst[0] = -abs(lst[0]);\n        lst[1] = abs(lst[1]);\n    }\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(lst));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, largest_smallest_integers)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, largest_smallest_integers_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/136", "entrypoint_scalar": "largest_smallest_integers", "entrypoint_simd": "largest_smallest_integers_simd"}
{"task_id": "SimdBench_129_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe Brazilian factorial is defined as:\nbrazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\nwhere n > 0\n\nFor example:\n>>> special_factorial_simd(4)\n288\n\nThe function will receive an integer as input and should return the special\nfactorial of this integer.\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nuint64_t special_factorial_simd(uint64_t n){\n}", "solution_scalar": "uint64_t special_factorial(uint64_t n){\n    uint64_t fact=1,bfact=1;\n    for (int i=1;i<=n;i++){\n        fact=fact*i;\n        bfact=bfact*fact % 100000;\n    }\n    return bfact;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (special_factorial_simd(4) == 288);\n    pass = pass && (special_factorial_simd(5) == 34560);\n    pass = pass && (special_factorial_simd(7) == 125411328000 % 100000);\n    pass = pass && (special_factorial_simd(1) == 1);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        uint64_t n = rng.randint<uint64_t>(1, 64);\n        auto result = special_factorial(n);\n        auto result_simd = special_factorial_simd(n);\n        \n        if (!allclose(result, result_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<uint64_t (*Func)(uint64_t)>\nstatic void BM_grid(benchmark::State& state) {\n    Random rng(DEFAULT_SEED);\n    uint64_t n = state.range(0);\n\n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(n));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM_grid, special_factorial)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM_grid, special_factorial_simd)->Name(\"SIMD\")->Large_Args_1D;\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/139", "entrypoint_scalar": "special_factorial", "entrypoint_simd": "special_factorial_simd"}
{"task_id": "SimdBench_130_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThis function will take a vector of integers. For all entries in the vector, the function shall square the integer entry if its index is a \nmultiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \nchange the entries in the vector whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n\nExamples:\nFor lst = {1,2,3} the output should be 6\nFor lst = {}  the output should be 0\nFor lst = {-1,-5,2,-1,-5}  the output should be -126\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nint sum_squares_simd(const std::vector<int> & lst){\n}", "solution_scalar": "int sum_squares(const std::vector<int> & lst){\n    int sum=0;\n    for (int i=0;i<lst.size();i++)\n        if (i%3==0) sum+=lst[i]*lst[i];\n        else if (i%4==0) sum+=lst[i]*lst[i]*lst[i];\n        else sum+=lst[i];\n    return sum;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (sum_squares_simd({1,2,3}) == 6);\n    pass = pass && (sum_squares_simd({1,4,9}) == 14);\n    pass = pass && (sum_squares_simd({}) == 0);\n    pass = pass && (sum_squares_simd({1,1,1,1,1,1,1,1,1}) == 9);\n    pass = pass && (sum_squares_simd({-1,-1,-1,-1,-1,-1,-1,-1,-1}) == -3);\n    pass = pass && (sum_squares_simd({0}) == 0);\n    pass = pass && (sum_squares_simd({-1,-5,2,-1,-5}) == -126);\n    pass = pass && (sum_squares_simd({-56,-99,1,0,-2}) == 3030);\n    pass = pass && (sum_squares_simd({-1,0,0,0,0,0,0,0,-1}) == 0);\n    pass = pass && (sum_squares_simd({-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37}) == -14196);\n    pass = pass && (sum_squares_simd({-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10}) == -1448);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = rng.randint<size_t>(0, 128);\n        std::vector<int> lst(length);\n        for(auto & num: lst){\n            num = rng.randint<int>(-100, 100);\n        }\n        \n        int result = sum_squares(lst);\n        int result_simd = sum_squares_simd(lst);\n        \n        if(result != result_simd){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<int (*Func)(const std::vector<int> &)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<int> lst(length);\n    std::vector<int> choiceset = {-2, -1, 0, 1, 2};\n    for(auto& num: lst){\n        num = rng.choice(choiceset);\n    }\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(lst));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, sum_squares)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, sum_squares_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/142", "entrypoint_scalar": "sum_squares", "entrypoint_simd": "sum_squares_simd"}
{"task_id": "SimdBench_131_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nWrite a function that takes a vector of numbers as input and returns \nthe number of elements in the vector that are greater than 10 and both \nfirst and last digits of a number are odd (1, 3, 5, 7, 9).\nFor example:\nspecialFilter_simd({15, -73, 14, -15}) => 1 \nspecialFilter_simd({33, -2, -3, 45, 21, 109}) => 2\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nint specialFilter_simd(const std::vector<int> & nums){\n}", "solution_scalar": "int specialFilter(const std::vector<int> & nums){\n    int num=0;\n    for (int i=0;i<nums.size();i++)\n    if (nums[i]>10)\n    {\n        std::string w=std::to_string(nums[i]);\n        if (w[0]%2==1 and w[w.length()-1]%2==1) num+=1;\n    }\n    return num;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (specialFilter_simd({5, -2, 1, -5}) == 0);\n    pass = pass && (specialFilter_simd({15, -73, 14, -15}) == 1);\n    pass = pass && (specialFilter_simd({33, -2, -3, 45, 21, 109}) == 2);\n    pass = pass && (specialFilter_simd({43, -12, 93, 125, 121, 109}) == 4);\n    pass = pass && (specialFilter_simd({71, -2, -33, 75, 21, 19}) == 3);\n    pass = pass && (specialFilter_simd({1}) == 0);\n    pass = pass && (specialFilter_simd({}) == 0);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = rng.randint<size_t>(0, 128);\n        std::vector<int> nums(length);\n        rng.initialize_vector_with_random_values(nums);\n        \n        int result = specialFilter(nums);\n        int result_simd = specialFilter_simd(nums);\n        \n        if(result != result_simd){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<int (*Func)(const std::vector<int> &)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<int> nums(length);\n    rng.initialize_vector_with_random_values(nums);\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(nums));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, specialFilter)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, specialFilter_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/146", "entrypoint_scalar": "specialFilter", "entrypoint_simd": "specialFilter_simd"}
{"task_id": "SimdBench_132_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nYou are given a positive integer n. You have to create an integer vector a of length n.\n    For each i (1 \u2264 i \u2264 n), the value of a{i} = i * i - i + 1.\n    Return the number of triples (a{i}, a{j}, a{k}) of a where i < j < k, \nand a[i] + a[j] + a[k] is a multiple of 3.\n\nExample :\n    Input: n = 5\n    Output: 1\n    Explanation: \n    a = {1, 3, 7, 13, 21}\n    The only valid triple is (1, 7, 13).\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nuint64_t get_max_triples_simd(uint64_t n){\n}", "solution_scalar": "uint64_t get_max_triples(uint64_t n) {\n    // Pre-allocate the vector `a` of size n\n    std::vector<int> a(n);\n\n    // Pre-allocate the `sum` and `sum2` vectors with size (n + 1) \u00d7 3, initialized to 0\n    std::vector<std::vector<int> > sum(n + 1, std::vector<int>(3, 0));\n    std::vector<std::vector<int> > sum2(n + 1, std::vector<int>(3, 0));\n\n    // Fill the vector `a` with the formula (i^2 - i + 1) % 3\n    for (int i = 1; i <= n; i++) {\n        a[i - 1] = (i * i - i + 1) % 3;\n    }\n\n    // Compute the cumulative counts of remainders for `sum`\n    for (int i = 1; i <= n; i++) {\n        sum[i] = sum[i - 1];  // Copy the previous cumulative counts\n        sum[i][a[i - 1]] += 1;  // Increment the count for the current value of `a[i-1]`\n    }\n\n    // Perform two rounds of cumulative count updates using `sum2`\n    for (int times = 1; times < 3; times++) {\n        for (int i = 1; i <= n; i++) {\n            sum2[i] = sum2[i - 1];  // Copy the previous cumulative counts\n\n            if (i >= 1) {\n                for (int j = 0; j <= 2; j++) {\n                    sum2[i][(a[i - 1] + j) % 3] += sum[i - 1][j];\n                }\n            }\n        }\n\n        // Update `sum` with the new cumulative counts from `sum2`\n        sum = sum2;\n\n        // Reset `sum2` to zero for the next round\n        for (int i = 0; i <= n; i++) {\n            sum2[i] = {0, 0, 0};\n        }\n    }\n\n    // Return the count of triples where the sum is divisible by 3\n    return sum[n][0];\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (get_max_triples_simd(5) == 1);\n    pass = pass && (get_max_triples_simd(6) == 4);\n    pass = pass && (get_max_triples_simd(10) == 36);\n    pass = pass && (get_max_triples_simd(100) == 53361);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        uint64_t n = rng.randint<uint64_t>(1, 64);\n        auto result = get_max_triples(n);\n        auto result_simd = get_max_triples_simd(n);\n        \n        if (!allclose(result, result_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<uint64_t (*Func)(uint64_t)>\nstatic void BM_grid(benchmark::State& state) {\n    Random rng(DEFAULT_SEED);\n    uint64_t n = state.range(0);\n\n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(n));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM_grid, get_max_triples)->Name(\"Scalar\")->Medium_Args_1D;\nBENCHMARK_TEMPLATE(BM_grid, get_max_triples_simd)->Name(\"SIMD\")->Medium_Args_1D;\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/147", "entrypoint_scalar": "get_max_triples", "entrypoint_simd": "get_max_triples_simd"}
{"task_id": "SimdBench_133_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nA simple program which should return the value of x if n is \na prime number and should return the value of y otherwise.\nExamples:\nfor x_or_y_simd(7, 34, 12) == 34\nfor x_or_y_simd(15, 8, 5) == 5\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nint x_or_y_simd(int n, int x, int y){\n}", "solution_scalar": "int x_or_y(int n,int x,int y){\n    bool isp=true;\n    if (n<2) isp=false;\n    for (int i=2;i*i<=n;i++)\n    if (n%i==0) isp=false;\n    if (isp) return x;\n    return y;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (x_or_y_simd(7, 34, 12) == 34);\n    pass = pass && (x_or_y_simd(15, 8, 5) == 5);\n    pass = pass && (x_or_y_simd(3, 33, 5212) == 33);\n    pass = pass && (x_or_y_simd(1259, 3, 52) == 3);\n    pass = pass && (x_or_y_simd(7919, -1, 12) == -1);\n    pass = pass && (x_or_y_simd(3609, 1245, 583) == 583);\n    pass = pass && (x_or_y_simd(91, 56, 129) == 129);\n    pass = pass && (x_or_y_simd(6, 34, 1234) == 1234);\n    pass = pass && (x_or_y_simd(1, 2, 0) == 0);\n    pass = pass && (x_or_y_simd(2, 2, 0) == 2);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        int n = rng.randint<int>(1, 64);\n        int x = rng.randint<int>();\n        int y = rng.randint<int>();\n        auto result = x_or_y(n,x,y);\n        auto result_simd = x_or_y_simd(n,x,y);\n        \n        if (!allclose(result, result_simd)) {\n            if (ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<int (*Func)(int, int, int)>\nstatic void BM_grid(benchmark::State& state) {\n    Random rng(DEFAULT_SEED);\n\n    std::vector<int> large_primes = {20996011, 24036583, 25964951, 30402457, 32582657, 37156667, 42643801, 43112609, 57885161};\n    int n = rng.choice(large_primes);\n    int x = rng.randint<int>();\n    int y = rng.randint<int>();\n\n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(n,x,y));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM_grid, x_or_y)->Name(\"Scalar\")->Medium_Args_1D;\nBENCHMARK_TEMPLATE(BM_grid, x_or_y_simd)->Name(\"SIMD\")->Medium_Args_1D;\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/150", "entrypoint_scalar": "x_or_y", "entrypoint_simd": "x_or_y_simd"}
{"task_id": "SimdBench_134_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nGiven a vector of numbers, return the sum of squares of the numbers\nin the vector that are odd. Ignore numbers that are negative or not integers.\n\ndouble_the_difference_simd({1, 3, 2, 0}) == 1 + 9 + 0 + 0 = 10\ndouble_the_difference_simd({-1, -2, 0}) == 0\ndouble_the_difference_simd({9, -2}) == 81\ndouble_the_difference_simd({0}) == 0  \n\nIf the input vector is empty, return 0.\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nuint64_t double_the_difference_simd(const std::vector<float> & lst){\n}", "solution_scalar": "uint64_t double_the_difference(const std::vector<float> & lst){\n    uint64_t sum=0;\n    for (int i=0;i<lst.size();i++)\n    if (lst[i]-round(lst[i])<1e-4)\n    if (lst[i]>0 and (int)(round(lst[i]))%2==1) sum+=(int)(round(lst[i]))*(int)(round(lst[i]));\n    return sum;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && (double_the_difference_simd({}) == 0);\n    pass = pass && (double_the_difference_simd({5, 4}) == 25);\n    pass = pass && (double_the_difference_simd({0.1, 0.2, 0.3}) == 0);\n    pass = pass && (double_the_difference_simd({-10, -20, -30}) == 0);\n    pass = pass && (double_the_difference_simd({-1, -2, 8}) == 0);\n    pass = pass && (double_the_difference_simd({0.2, 3, 5}) == 34);\n    \n    long long odd_sum = 0;\n    std::vector<float> lst;\n    for (int i = -99; i < 100; i += 2) {\n        lst.push_back(i + 0.0f);\n        if (i > 0 && i % 2 == 1) odd_sum += i * i;\n    }\n    pass = pass && (double_the_difference_simd(lst) == odd_sum);\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = rng.randint<size_t>(0, 128);\n        std::vector<float> lst(length);\n        \n        for (auto& num : lst) {\n            num = rng.uniform<float>(-100.0f, 100.0f);\n            if (rng.randint<int>() % 10 != 0) {\n                num = round(num);\n            }\n        }\n        \n        long long result = double_the_difference(lst);\n        long long result_simd = double_the_difference_simd(lst);\n        \n        if(result != result_simd){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<uint64_t (*Func)(const std::vector<float> &)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<float> lst(length);\n    \n    for (auto& num : lst) {\n        num = rng.uniform<float>(-100.0f, 100.0f);\n        if (rng.randint<int>() % 4 == 0) {\n            num = round(num);\n        }\n    }\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(lst));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, double_the_difference)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, double_the_difference_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/151", "entrypoint_scalar": "double_the_difference", "entrypoint_simd": "double_the_difference_simd"}
{"task_id": "SimdBench_135_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nI think we all remember that feeling when the result of some long-awaited\nevent is finally known. The feelings and thoughts you have at that moment are\ndefinitely worth noting down and comparing.\nYour task is to determine if a person correctly guessed the results of a number of matches.\nYou are given two vectors of scores and guesses of equal length, where each index shows a match. \nReturn a vector of the same length denoting how far off each guess was. If they have guessed correctly,\nthe value is 0, and if not, the value is the absolute difference between the guess and the score.\nExample:\ncompare_simd({1,2,3,4,5,1},{1,2,3,4,2,-2}) -> {0,0,0,0,3,3}\ncompare_simd({0,5,0,0,0,4},{4,1,1,0,0,-2}) -> {4,4,1,0,0,6}\n\nThe requirement is to implement the function using AVX/AVX2 (Advanced Vector Extensions) intrinsics to achieve parallelism.\n*/\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess){\n}", "solution_scalar": "std::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> out(game.size());\n    for (int i = 0; i < game.size(); i++) {\n        out[i] = std::abs(game[i] - guess[i]);\n    }\n    return out;\n}", "test_correctness": "bool humaneval_check() {\n    bool pass = true;\n    pass = pass && allclose(compare_simd({1,2,3,4,5,1}, {1,2,3,4,2,-2}), {0,0,0,0,3,3});\n    pass = pass && allclose(compare_simd({0,5,0,0,0,4}, {4,1,1,0,0,-2}), {4,4,1,0,0,6});\n    pass = pass && allclose(compare_simd({1,2,3,4,5,1}, {1,2,3,4,2,-2}), {0,0,0,0,3,3});\n    pass = pass && allclose(compare_simd({0,0,0,0,0,0}, {0,0,0,0,0,0}), {0,0,0,0,0,0});\n    pass = pass && allclose(compare_simd({1,2,3}, {-1,-2,-3}), {2,4,6});\n    pass = pass && allclose(compare_simd({1,2,3,5}, {-1,2,3,4}), {2,0,0,1});\n    return pass;\n}\n\nbool correctness_check(int iterations) {\n    Random rng;\n    for (int i = 0; i < iterations; i++) {\n        size_t length = rng.randint<size_t>(0, 128);\n        std::vector<int> game(length);\n        std::vector<int> guess(length);\n        for( int i=0; i< length; ++i){\n            game[i] = rng.randint<int>(-1000, 1000);\n            guess[i] = rng.randint<int>(-1000, 1000);\n        }\n        auto result = compare(game, guess);\n        auto result_simd = compare_simd(game, guess);\n        \n        if(!allclose(result, result_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = humaneval_check() && correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<std::vector<int> (*Func)(const std::vector<int>&, const std::vector<int>&)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<int> game(length);\n    std::vector<int> guess(length);\n    for( int i=0; i< length; ++i){\n        game[i] = rng.randint<int>(-1000, 1000);\n        guess[i] = rng.randint<int>(-1000, 1000);\n    }\n    \n    for (auto _ : state) {\n        benchmark::DoNotOptimize(Func(game, guess));\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, compare)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, compare_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "2", "subtype": "HumanEval/152", "entrypoint_scalar": "compare", "entrypoint_simd": "compare_simd"}
